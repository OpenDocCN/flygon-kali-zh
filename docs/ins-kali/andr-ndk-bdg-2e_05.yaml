- en: Chapter 5. Writing a Fully Native Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。编写完全本地应用程序
- en: '*In previous chapters, we have breached Android NDK''s surface using JNI. But
    there is much more to find inside! The NDK includes its own set of specific features,
    one of them being **Native Activities**. Native activities allow creating applications
    based only on native code, without a single line of Java. No more JNI! No more
    references! No more Java!*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在之前的章节中，我们已经使用JNI接触过Android NDK的表面。但是在里面还有更多的东西！NDK包括自己的一套特定功能，其中之一就是**本地活动**。本地活动允许创建仅基于本地代码的应用程序，而不需要一行Java代码。不再需要JNI！不再需要引用！不再需要Java！*'
- en: '>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*In addition to native activities, the NDK brings some APIs for native access
    to Android resources, such as **display windows**, **assets**, **device configuration**…
    These APIs help in getting rid of the tortuous JNI bridge often necessary to embed
    native code. Although there is a lot still missing, and not likely to be available
    (Java remains the main platform language for GUIs and most frameworks), multimedia
    applications are a perfect target to apply them...*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*除了本地活动，NDK还为本地访问Android资源提供了一些API，例如**显示窗口**，**资源**，**设备配置**...这些API有助于摆脱通常需要嵌入本地代码的曲折JNI桥梁。尽管仍然有很多东西缺失，并且不太可能可用（Java仍然是主要的平台语言用于GUI和大多数框架），多媒体应用程序是应用它们的完美目标...*'
- en: 'This chapter initiates a native C++ project developed progressively throughout
    this book: **DroidBlaster**. Based on a top-down viewpoint, this sample scrolling
    shooter will feature 2D graphics, and, later on, 3D graphics, sound, input, and
    sensor management. In this chapter, we will create its base structure and main
    game components.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章逐步开发了一个本地C++项目：**DroidBlaster**。基于自上而下的视角，这个示例滚动射击游戏将具有2D图形，以及后来的3D图形，声音，输入和传感器管理。在本章中，我们将创建其基本结构和主要游戏组件。
- en: 'Let''s now enter the heart of the Android NDK by:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入Android NDK的核心：
- en: Creating a fully native activity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个完全本地活动
- en: Handling main activity events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理主活动事件
- en: Accessing display window natively
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地访问显示窗口
- en: Retrieving time and calculating delays
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索时间并计算延迟
- en: Creating a native Activity
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建本地活动
- en: The `NativeActivity` class provides a facility to minimize the work necessary
    to create a native application. It lets the developer get rid of all the boilerplate
    code to initialize and communicate with native code and concentrate on core functionalities.
    This *glue* Activity is the simplest way to write applications, such as games
    without a line of Java code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`NativeActivity`类提供了一个设施，可以最小化创建本地应用程序所需的工作。它让开发人员摆脱了初始化和与本地代码通信的所有样板代码，并集中精力于核心功能。这个*粘合*活动是编写应用程序的最简单方式，比如游戏，而不需要一行Java代码。'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part1`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`DroidBlaster_Part1`的名称提供。
- en: Time for action – creating a basic native Activity
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建基本本地活动
- en: We are now going to see how to create a minimal native activity that runs an
    event loop.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到如何创建一个运行事件循环的最小本地活动。
- en: Create a new hybrid Java/C++ project, as shown in [Chapter 2](ch02.html "Chapter 2. Starting
    a Native Android Project"), *Starting a Native Android Project*.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的混合Java/C++项目，如[第2章](ch02.html "第2章。开始一个本地Android项目")所示，*开始一个本地Android项目*。
- en: Name it `DroidBlaster`.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其命名为`DroidBlaster`。
- en: Turn the project into a native project, as already seen in the previous chapter.
    Name the native module `droidblaster`.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目转换为本地项目，如前一章所示。将本地模块命名为`droidblaster`。
- en: Remove the native source and header files that have been created by ADT.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除ADT创建的本地源文件和头文件。
- en: Remove the reference to the Java `src` directory in **Project Properties** |
    **Java Build Path** | **Source**. Then, remove the directory itself on disk.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**项目属性** | **Java构建路径** | **源**中删除对Java `src`目录的引用。然后，在磁盘上删除该目录本身。
- en: Get rid of all layouts in the `res/layout` directory.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`res/layout`目录中的所有布局。
- en: Get rid of `jni/droidblaster.cpp` if it has been created.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已创建，删除`jni/droidblaster.cpp`。
- en: In `AndroidManifest.xml`, use `Theme.NoTitleBar.Fullscreen` as the application
    theme.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`中，使用`Theme.NoTitleBar.Fullscreen`作为应用程序主题。
- en: 'Declare a `NativeActivity` that refers to the native module named `droidblaster`
    (that is, the native library we will compile) using the meta-data property `android.app.lib_name`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个引用名为`droidblaster`的本地模块的`NativeActivity`（即我们将编译的本地库），使用元数据属性`android.app.lib_name`：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the file `jni/Types.hpp`. This header will contain common types and
    the header `cstdint`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`jni/Types.hpp`。这个头文件将包含常见类型和头文件`cstdint`：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's write a logging class to get some feedback in the Logcat.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个日志记录类，在Logcat中获得一些反馈。
- en: Create `jni/Log.hpp` and declare a new class `Log`.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`jni/Log.hpp`并声明一个新类`Log`。
- en: 'Define the `packt_Log_debug` macro to allow the activating or deactivating
    of debug messages with a simple compile flag:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`packt_Log_debug`宏，以允许使用简单的编译标志激活或停用调试消息：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Implement the `jni/Log.cpp` file and implement the `info()` method. To write
    messages to Android logs, the NDK provides a dedicated logging API in the `android/log.h`
    header, which can be used similarly as `printf()` or `vprintf()` (with `varArgs`)
    in C:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`jni/Log.cpp`文件并实现`info()`方法。为了将消息写入Android日志，NDK在`android/log.h`头文件中提供了专用的日志记录API，可以类似地用于C中的`printf()`或`vprintf()`（带`varArgs`）：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Write other log methods, `error()`, `warn()`, and `debug()`, which are almost
    identical, except the level macro, which are respectively `ANDROID_LOG_ERROR,
    ANDROID_LOG_WARN`, and `ANDROID_LOG_DEBUG` instead.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 编写其他日志方法，`error()`，`warn()`和`debug()`，它们几乎相同，除了级别宏，分别是`ANDROID_LOG_ERROR, ANDROID_LOG_WARN`和`ANDROID_LOG_DEBUG`。
- en: Application events in `NativeActivity` can be processed with an event loop.
    So, create `jni/EventLoop.hpp` to define a class with a unique method `run()`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NativeActivity`中的应用程序事件可以使用事件循环进行处理。因此，创建`jni/EventLoop.hpp`来定义一个具有唯一方法`run()`的类。'
- en: 'Include the `android_native_app_glue.h` header, which defines the `android_app`
    structure. It represents what could be called an **applicative context**, where
    all the information is related to the native activity; its state, its window,
    its event queue, and so on:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 包括`android_native_app_glue.h`头文件，该文件定义了`android_app`结构。它代表了可以称为**应用上下文**的东西，其中所有信息都与原生活动相关；它的状态，它的窗口，它的事件队列等等：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Create `jni/EventLoop.cpp` and implement the activity event loop in the `run()`
    method. Include a few log events to get some feedback in Android logs.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/EventLoop.cpp`并在`run()`方法中实现活动事件循环。包括一些日志事件以在Android日志中获得一些反馈。
- en: During the whole activity lifetime, the `run()` method loops continuously over
    events until it is requested to terminate. When an activity is about to be destroyed,
    the `destroyRequested` value in the `android_app` structure is changed internally
    to indicate to the client code that it must exit.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个活动生命周期中，`run()`方法会持续循环处理事件，直到被要求终止。当活动即将被销毁时，`android_app`结构中的`destroyRequested`值会在内部更改，以指示客户端代码必须退出。
- en: Also, call `app_dummy()` to ensure the glue code that ties native code to `NativeActivity`
    is not stripped by the linker. We will see more about this in [Chapter 9](ch09.html
    "Chapter 9. Porting Existing Libraries to Android"), *Porting Existing Libraries
    to Android*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 还要调用`app_dummy()`来确保将本地代码与`NativeActivity`连接起来的粘合代码不会被链接器剥离。我们将在[第9章](ch09.html
    "第9章。将现有库移植到Android")中看到更多关于这个的内容，“将现有库移植到Android”。
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, create `jni/Main.cpp` to define the program entry point `android_main()`,
    which runs the event loop in a new file `Main.cpp`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建`jni/Main.cpp`来定义程序入口点`android_main()`，它在新文件`Main.cpp`中运行事件循环：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Edit the `jni/Android.mk` file to define the `droidblaster` module (the `LOCAL_MODULE`
    directive).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/Android.mk`文件以定义`droidblaster`模块（`LOCAL_MODULE`指令）。
- en: Describe the C++ files to compile the `LOCAL_SRC_FILES` directive with the help
    of the `LS_CPP` macro (more about this in [Chapter 9](ch09.html "Chapter 9. Porting
    Existing Libraries to Android"), *Porting Existing Libraries to Android*).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`LS_CPP`宏描述要编译的C++文件以编译`LOCAL_SRC_FILES`指令（有关更多信息，请参阅[第9章](ch09.html "第9章。将现有库移植到Android")，“将现有库移植到Android”）。
- en: 'Link `droidblaster` with the `native_app_glue` module (the `LOCAL_STATIC_LIBRARIES`
    directive) and `android` (required by the **Native App Glue** module), as well
    as the `log` libraries (the `LOCAL_LDLIBS` directive):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将`droidblaster`与`native_app_glue`模块（`LOCAL_STATIC_LIBRARIES`指令）和`android`（**Native
    App Glue**模块所需）以及`log`库（`LOCAL_LDLIBS`指令）链接起来：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create `jni/Application.mk` to compile the native module for multiple `ABI`s.
    We will use the most basic ones, as shown in the following code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/Application.mk`以为多个`ABI`编译本机模块。我们将使用最基本的那些，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*What just happened?*'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: 'Build and run the application. Of course, you will not see anything tremendous
    when starting this application. Actually, you will just see a black screen! However,
    if you look carefully at the **LogCat** view in Eclipse (or the `adb logcat` command),
    you will discover a few interesting messages that have been emitted by your native
    application in reaction to activity events:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。当启动此应用程序时，当然不会看到什么了不起的东西。实际上，你只会看到一个黑屏！但是，如果你仔细观察Eclipse中的**LogCat**视图（或`adb
    logcat`命令），你会发现一些有趣的消息，这些消息是由你的本机应用在活动事件发生时发出的：
- en: '![What just happened?](img/9645_05_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/9645_05_01.jpg)'
- en: We initiated a Java Android project without a single line of Java code! Instead
    of referencing a child of `Activity` in `AndroidManifest`, we referenced the `android.app.NativeActivity`
    class provided by the Android framework.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动了一个不包含一行Java代码的Java Android项目！我们在`AndroidManifest`中引用`Activity`的子类，而是引用了Android框架提供的`android.app.NativeActivity`类。
- en: '`NativeActivity` is a Java class, launched like any other Android activity
    and interpreted by the Dalvik Virtual Machine like any other Java class. However,
    we never faced it directly. `NativeActivity` is in fact a helper class provided
    with Android SDK, which contains all the necessary glue code to handle application
    events (lifecycle, input, sensors, and so on) and broadcasts them transparently
    to native code. Thus, a native activity does not eliminate the need for JNI. It
    just hides it under the cover! However, the native C/C++ module run by `NativeActivity`
    is executed outside Dalvik boundaries in its own thread, entirely natively (using
    the Posix Thread API)!'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`NativeActivity`是一个Java类，像其他Android活动一样启动，并且像其他Java类一样由Dalvik虚拟机解释。但是，我们从未直接面对过它。`NativeActivity`实际上是Android
    SDK提供的一个辅助类，其中包含处理应用程序事件（生命周期、输入、传感器等）的所有必要粘合代码，并且将它们透明地广播到本机代码。因此，本机活动并不消除对JNI的需求。它只是将其隐藏在幕后！但是，由`NativeActivity`运行的本机C/C++模块在其自己的线程中完全在Dalvik边界之外本地执行（使用Posix线程API）！'
- en: '`NativeActivity` and native code are connected together through the `native_app_glue`
    module. The Native App Glue has the responsibility of:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`NativeActivity`和本机代码通过`native_app_glue`模块连接在一起。本机应用粘合的责任是：'
- en: Launching the native thread, which runs our own native code
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动本机线程，运行我们自己的本机代码
- en: Receiving events from `NativeActivity`
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`NativeActivity`接收事件
- en: Routing these events to the native thread event loop for further processing
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些事件路由到本机线程事件循环以进行进一步处理
- en: The `Native glue` module code is located in `${ANDROID_NDK}/sources/android/native_app_glue`
    and can be analyzed, modified, or forked at will (see [Chapter 9](ch09.html "Chapter 9. Porting
    Existing Libraries to Android"), *Porting Existing Libraries to Android*, for
    more information). The headers related to native APIs such as, `looper.h`, can
    be found in `${ANDROID_NDK}/platforms/<Target Platform>/<Target Architecture>/usr/include/android/`.
    Let's see in more detail how it works.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Native glue`模块代码位于`${ANDROID_NDK}/sources/android/native_app_glue`，可以随意分析、修改或分叉（有关更多信息，请参见[第9章](ch09.html
    "第9章。将现有库移植到Android")，“将现有库移植到Android”）。与本机API相关的头文件，如`looper.h`，可以在`${ANDROID_NDK}/platforms/<Target
    Platform>/<Target Architecture>/usr/include/android/`中找到。让我们更详细地看看它是如何工作的。'
- en: More about the Native App Glue
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有关本机应用粘合的更多信息
- en: Our own native code entry point is declared inside the `android_main()` method,
    which is similar to the main methods in desktop applications. It is called only
    once when `NativeActivity` is instantiated and launched. It loops over application
    events until `NativeActivity` is terminated by the user (for example, when pressing
    a device's back button) or until it exits by itself (more about this in the next
    part).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自己的本地代码入口点在`android_main()`方法中声明，类似于桌面应用程序中的主要方法。它只在`NativeActivity`实例化和启动时调用一次。它循环处理应用程序事件，直到用户终止`NativeActivity`（例如，按下设备的返回按钮）或直到它自己退出（关于这一点我们将在下一部分详细了解）。
- en: The `android_main()` method is not the real native application entry point.
    The real entry point is the `ANativeActivity_onCreate()` method hidden in the
    `android_native_app_glue` module. The event loop we implemented in `android_main()`
    is in fact a delegate event loop, launched in its own native thread by the glue
    module. This design decouples native code from the `NativeActivity` class, which
    is run on the UI thread on the Java side. Thus, even if your code takes a long
    time to handle an event, `NativeActivity` is not blocked and your Android device
    still remains responsive.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`android_main()`方法不是真正的本地应用程序入口点。真正的入口点是隐藏在`android_native_app_glue`模块中的`ANativeActivity_onCreate()`方法。我们在`android_main()`中实现的事件循环实际上是一个委托事件循环，在其自己的本地线程中由粘合剂模块启动。这种设计将本地代码与在Java端的UI线程上运行的`NativeActivity`类分离开来。因此，即使您的代码花费很长时间来处理事件，`NativeActivity`也不会被阻塞，您的Android设备仍然保持响应。'
- en: The delegate native event loop in `android_main()` is itself composed, in our
    example, of two nested while loops. The outer one is an infinite loop, terminated
    only when activity destruction is requested by the system (indicated by the `destroyRequested`
    flag). It executes an inner loop, which processes all pending application events.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`android_main()`中的委托本地事件循环本身由两个嵌套的while循环组成。外部循环是一个无限循环，只有在系统请求销毁活动（由`destroyRequested`标志指示）时才终止。它执行一个内部循环，处理所有挂起的应用程序事件。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The inner `For` loop polls events by calling `ALooper_pollAll()`. This method
    is part of the `Looper` API, which can be described as a general-purpose event
    loop manager provided by Android. When timeout is set to `-1`, like in the preceding
    example, `ALooper_pollAll()` remains blocked while waiting for events. When at
    least one is received, `ALooper_pollAll()` returns and the code flow continues.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的`For`循环通过调用`ALooper_pollAll()`来轮询事件。这个方法是`Looper` API的一部分，可以被描述为Android提供的通用事件循环管理器。当超时设置为`-1`时，就像前面的例子一样，`ALooper_pollAll()`在等待事件时保持阻塞。当至少收到一个事件时，`ALooper_pollAll()`返回，代码流程继续。
- en: 'The `android_poll_source` structure describing the event is filled and is then
    used by client code for further processing. This structure looks as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 描述事件的`android_poll_source`结构被填充，然后被客户端代码用于进一步处理。这个结构如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `process()` function pointer can be customized to process application events
    manually, as we will see in the next section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`process()`函数指针可以定制为手动处理应用程序事件，我们将在下一节中看到。'
- en: 'As we saw in this part, the event loop receives an `android_app` structure
    in parameter. This structure, described in `android_native_app_glue.h`, contains
    some contextual information as shown in the following table:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本部分中看到的，事件循环在参数中接收一个`android_app`结构。这个结构在`android_native_app_glue.h`中描述，包含一些上下文信息，如下表所示：
- en: '| `void* userData` | Pointer to any data you want. This is essential in giving
    some contextual information to the activity or input event callbacks. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '`void* userData` | 指向任何你想要的数据的指针。这对于给活动或输入事件回调提供一些上下文信息是至关重要的。'
- en: '| `void (*pnAppCmd)(…)` and `int32_t (*onInputEvent)(…)` | These member variables
    represent the event callbacks triggered by the Native App Glue when an activity
    or an input event occurs. We will see more about this in the next section. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '`void (*pnAppCmd)(…)` 和 `int32_t (*onInputEvent)(…)` | 这些成员变量代表本地应用程序粘合剂触发的事件回调，当活动或输入事件发生时。我们将在下一节中详细了解这一点。'
- en: '| `ANativeActivity* activity` | Describes the Java native activity (its class
    as a JNI object, its data directories, and so on) and gives the necessary information
    to retrieve a JNI context. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '`ANativeActivity* activity` | 描述Java本地活动（作为JNI对象的类，其数据目录等），并提供检索JNI上下文所需的信息。'
- en: '| `AConfiguration* config` | Describes the current hardware and system state,
    such as the current language and country, the current screen orientation, density,
    size, and so on. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '`AConfiguration* config` | 描述当前的硬件和系统状态，比如当前的语言和国家、当前的屏幕方向、密度、大小等。'
- en: '| `void* savedState size_t` and `savedStateSize` | Used to save a buffer of
    data when an activity (and thus its native thread) is destroyed and later restored.
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '`void* savedState size_t` 和 `savedStateSize` | 在活动（及其本地线程）被销毁并稍后恢复时用于保存数据缓冲区。'
- en: '| `AInputQueue* inputQueue` | Provides input events (used internally by the
    native glue). We will see more about input events in [Chapter 8](ch08.html "Chapter 8. Handling
    Input Devices and Sensors"), *Handling Input Devices and Sensors*. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '`AInputQueue* inputQueue` | 提供输入事件（由本地粘合剂内部使用）。我们将在[第8章](ch08.html "第8章。处理输入设备和传感器")中详细了解输入事件，*处理输入设备和传感器*。'
- en: '| `ALooper* looper` | Allows attaching and detaching event queues used internally
    by the native glue. Listeners poll and wait for events sent on a communication
    pipe. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '`ALooper* looper` | 允许附加和分离内部使用的事件队列，这些事件队列由本地代码内部使用。监听器轮询并等待在通信管道上发送的事件。'
- en: '| `ANativeWindow* window` and `ARect contentRect` | Represents the "drawable"
    area on which graphics can be drawn. The `ANativeWindow` API, declared in `native_window.h`,
    allows retrieval of the window width, height, and pixel format, and the changing
    of these settings. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '`ANativeWindow* window` 和 `ARect contentRect` | 代表可以绘制图形的“可绘制”区域。`ANativeWindow`
    API在`native_window.h`中声明，允许检索窗口宽度、高度和像素格式，并更改这些设置。'
- en: '| `int activityState` | Current activity state, that is, `APP_CMD_START`, `APP_CMD_RESUME`,
    `APP_CMD_PAUSE`, and so on. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '`int activityState` | 当前活动状态，即`APP_CMD_START`、`APP_CMD_RESUME`、`APP_CMD_PAUSE`等。|'
- en: '| `int destroyRequested` | When equal to `1`, it indicates that the application
    is about to be destroyed and the native thread must be terminated immediately.
    This flag has to be checked in the event loop. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `int destroyRequested` | 当等于`1`时，表示应用程序即将被销毁，本机线程必须立即终止。这个标志必须在事件循环中检查。 |'
- en: The `android_app` structure also contains some additional data for internal
    use only, which should not be changed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`android_app`结构还包含一些仅供内部使用的附加数据，不应更改。'
- en: Knowing all these details is not essential to program native programs but can
    help you understand what's going on behind your back. Let's now see how to handle
    these activity events.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 了解所有这些细节对于编写本机程序并不是必要的，但可以帮助您了解在背后发生了什么。现在让我们看看如何处理这些活动事件。
- en: Handling Activity events
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理活动事件
- en: In the first part, a native event loop was run, which flushes events without
    really processing them. In this second part, we are going to discover more about
    these events occurring during the activity lifecycle, and how to process them,
    spending the remaining time stepping our application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，运行了一个本机事件循环，它刷新事件而不真正处理它们。在第二部分中，我们将了解有关活动生命周期中发生的这些事件的更多信息，以及如何处理它们，花费剩余时间来步进我们的应用程序。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part2`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的项目名称为`DroidBlaster_Part2`。
- en: Time for action – stepping the event loop
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-执行事件循环
- en: Let's extend the previous example to step our application when events are processed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展前面的示例，以在处理事件时步进我们的应用程序。
- en: 'Open `jni/Types.hpp` and define a new type status to represent return codes:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jni/Types.hpp`并定义一个新的状态类型来表示返回码：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create the `jni/ActivityHandler.hpp` header and define an "interface" to observe
    native activity events. Each possible event has its own handler method: `onStart()`,
    `onResume()`, `onPause()`, `onStop()`, `onDestroy()`, and so on. However, we are
    generally interested in three specific moments in the activity life cycle:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/ActivityHandler.hpp`头文件，并定义一个"接口"来观察本机活动事件。每个可能的事件都有自己的处理程序方法：`onStart()`，`onResume()`，`onPause()`，`onStop()`，`onDestroy()`等。然而，我们通常对活动生命周期中的三个特定时刻感兴趣：
- en: '`onActivate()`, invoked when the activity is resumed and its window is available
    and focused'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onActivate()`，在活动恢复并且其窗口可用和聚焦时调用'
- en: '`onDeactivate()`, invoked when the activity is paused or the display window
    loses its focus or is destroyed'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDeactivate()`，在活动暂停或显示窗口失去焦点或被销毁时调用'
- en: '`onStep()`, invoked when no event has to be processed and computations can
    take place'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStep()`，在没有事件需要处理并且可以进行计算时调用'
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Enhance `jni/EventLoop.hpp` with the following methods:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/EventLoop.hpp`中增加以下方法：
- en: '`activate()` and `deactivate()`, executed when an activity availability changes'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activate()`和`deactivate()`，在活动可用性发生变化时执行'
- en: '`callback_appEvent()`, which is static and routes events to `processActivityEvent()`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback_appEvent()`是静态的，并将事件路由到`processActivityEvent()`'
- en: 'Also, define some member variables as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还要定义一些成员变量如下：
- en: '`mActivityHandler` observes activity events. This instance is given as a constructor
    parameter and requires the inclusion of `ActivityHandler.hpp`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mActivityHandler`观察活动事件。此实例作为构造函数参数给出，并需要包含`ActivityHandler.hpp`'
- en: '`mEnabled` saves the application state when the application is active/paused'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mEnabled`保存应用程序在活动/暂停时的状态'
- en: '`mQuit` indicates the event loop needs to exit'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mQuit`指示事件循环需要退出'
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Edit `jni/EventLoop.cpp`. The constructor initialization list itself is trivial
    to implement. Then, fill the `android_app` application context with additional
    information:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/EventLoop.cpp`。构造函数初始化列表本身很容易实现。然后，用附加信息填充`android_app`应用程序上下文：
- en: '`userData` points to any data you want. It is the only information accessible
    from `callback_appEvent()` declared previously. In our case, this is the `EventLoop`
    instance (that is, `this`).'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userData`指向您想要的任何数据。这是先前声明的`callback_appEvent()`中唯一可访问的信息。在我们的情况下，这是`EventLoop`实例（即`this`）。'
- en: '`onAppCmd` points to an internal callback triggered each time an event occurs.
    In our case, this is the role devoted to the static method `callback_appEvent()`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAppCmd`指向一个内部回调，每次事件发生时触发。在我们的情况下，这是专门用于静态方法`callback_appEvent()`的角色。'
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Update the `run()` main event loop. Instead of blocking when there is no more
    activity event to process, `ALooper_pollAll()` must let the program flow continue
    to perform the recurrent processing. Here, processing is performed by the listener
    in `mActivityHandler.onStep()`. This behavior is obviously only needed when the
    application is enabled.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`run()`主事件循环。当没有更多活动事件需要处理时，`ALooper_pollAll()`不再阻塞，而是让程序流继续执行循环处理。在这里，处理由`mActivityHandler.onStep()`中的监听器执行。这种行为显然只在应用程序启用时才需要。
- en: Also, allow the activity to be terminated programmatically using the `AnativeActivity_finish()`
    method.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还可以使用`AnativeActivity_finish()`方法以编程方式终止活动。
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*What just happened?*'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'We changed our event loop to update our application, instead of blocking uselessly,
    when there are no more events to process. This behavior is specified in `ALooper_pollAll()`
    by its first parameter, timeout:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变了我们的事件循环，以更新我们的应用程序，而不是在没有更多事件需要处理时无用地阻塞。这种行为在`ALooper_pollAll()`中通过其第一个参数timeout指定：
- en: When timeout is `-1`, as defined previously, call is blocking until events are
    received.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当超时为`-1`时，如前所述，调用是阻塞的，直到接收到事件。
- en: When timeout is `0`, call is non-blocking so that, if nothing remains in the
    queue, the program flow continues (the inner while loop is terminated) and makes
    it possible to perform recurrent processing.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当超时为`0`时，调用是非阻塞的，因此，如果队列中没有剩余内容，程序流会继续（内部while循环终止），并且可以执行循环处理。
- en: When timeout is greater than `0`, we have a blocking call, which remains until
    an event is received or the duration is elapsed.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当超时大于`0`时，我们有一个阻塞调用，直到接收到事件或经过了持续时间。
- en: Here, we want to step the activity (that is, perform computations) when it is
    in active state (`mEnabled` is `true`); in that case, timeout is `0`. When the
    activity is in deactivated state (`mEnabled` is `false`), events are still processed
    (for example, to resurrect the activity) but nothing needs to get computed. The
    thread has to be blocked to avoid consuming battery and processor time uselessly;
    in that case, timeout is `-1`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们希望在活动处于活动状态（`mEnabled`为`true`）时进行活动（即进行计算）；在这种情况下，超时为`0`。当活动处于停用状态（`mEnabled`为`false`）时，事件仍然被处理（例如，重新启动活动），但不需要进行计算。线程必须被阻塞以避免无用地消耗电池和处理器时间；在这种情况下，超时为`-1`。
- en: Once all pending events are processed, the listener is stepped. It can request
    the application to be terminated, for example, if the game is finished. To leave
    the application programmatically, the NDK API provides the `AnativeActivity_finish()`
    method to request activity termination. Termination does not occur immediately
    but after the last few events (pause, stop, and so on) are processed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有待处理的事件都被处理，就会执行监听器。例如，如果游戏结束，它可以请求应用程序被终止。为了以编程方式离开应用程序，NDK API提供了`AnativeActivity_finish()`方法来请求活动终止。终止不会立即发生，而是在最后几个事件（暂停，停止等）处理后发生。
- en: Time for action – handling Activity events
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-处理活动事件
- en: 'We are not done yet. Let''s continue our example to handle activity events
    and log them to the **LogCat** view:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成。让我们继续我们的示例，处理活动事件并将它们记录到**LogCat**视图中：
- en: 'Continue editing `jni/EventLoop.cpp`. Implement `activate()` and `deactivate()`.Check
    both activity states before notifying the listener (to avoid untimely triggering).
    We consider an activity as activated only if a display window is available:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续编辑`jni/EventLoop.cpp`。实现`activate()`和`deactivate()`。在通知监听器之前检查两种活动状态（以避免不时触发）。我们只有在显示窗口可用时才将活动视为已激活：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Route activity events from the static callback `callback_appEvent()` to the
    member method `processAppEvent()`.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将活动事件从静态回调`callback_appEvent()`路由到成员方法`processAppEvent()`。
- en: To do so, retrieve the `EventLoop` instance, thanks to the `userData` pointer
    (this being unavailable from a static method). Effective event processing is then
    delegated to `processAppEvent()`, which brings us back to the object-oriented
    world. The command, that is the activity event, given by the native glue is passed
    at the same time.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为此，通过`userData`指针检索`EventLoop`实例（这在静态方法中不可用）。然后将有效的事件处理委托给`processAppEvent()`，这将把我们带回到面向对象的世界。同时传递由本机胶水给出的命令，即活动事件。
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Process the forwarded events in `processAppEvent()`. The `pCommand` parameter
    contains an enumeration value (`APP_CMD_*`), which describes the occurring event
    (`APP_CMD_START, APP_CMD_GAINED_FOCUS`, and so on).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`processAppEvent()`中处理转发的事件。`pCommand`参数包含一个枚举值（`APP_CMD_*`），描述发生的事件（`APP_CMD_START,
    APP_CMD_GAINED_FOCUS`等）。
- en: 'Depending on the event, activate or deactivate the event loop and notify the
    listener:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 根据事件，激活或停用事件循环并通知监听器：
- en: Activation occurs when the activity gains focus. This event is always the last
    event that occurs after the activity is resumed and the window is created. Getting
    focus means that the activity can receive input events.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动获得焦点时，激活发生。这个事件总是在活动恢复和窗口创建后发生的最后一个事件。获得焦点意味着活动可以接收输入事件。
- en: Deactivation occurs when the window loses focus or the application is paused
    (both can occur first). For security, deactivation is also performed when the
    window is destroyed, although this should always occur after the focus is lost.
    Losing focus means that the application does not receive input events anymore.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口失去焦点或应用程序暂停时，停用发生（两者都可能首先发生）。出于安全考虑，当窗口被销毁时也会执行停用，尽管这应该总是在失去焦点之后发生。失去焦点意味着应用程序不再接收输入事件。
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A few events, such as `APP_CMD_WINDOW_RESIZED`, are available but never triggered.
    Do not listen to them unless you are ready to stick your hands in the glue.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一些事件，比如`APP_CMD_WINDOW_RESIZED`，是可用的，但从未触发。除非你准备好把手伸进胶水中，否则不要监听它们。
- en: 'Create `jni/DroidBlaster.hpp`, which implements the `ActivityHandler` interface
    and all its methods (some have been skipped here for conciseness). This class
    will run the game logic as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/DroidBlaster.hpp`，它实现了`ActivityHandler`接口和所有方法（为了简洁起见，这里有一些被跳过了）。这个类将按照以下方式运行游戏逻辑：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Implement `jni/DroidBlaster.cpp` with all the required handlers. To keep this
    introduction to the activity lifecycle simple, we are just going to log each event
    that occurs. Use `onStart()` as a model for all the handlers that have been skipped
    in the following code.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所有必需的处理程序实现`jni/DroidBlaster.cpp`。为了使这个活动生命周期的介绍简单，我们只是要记录每个发生的事件。使用`onStart()`作为以下代码中被跳过的所有处理程序的模型。
- en: Steps are limited to a simple thread sleep (to avoid flooding the Android log),
    which requires the inclusion of `unistd.h`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤仅限于简单的线程休眠（以避免洪水般的Android日志），这需要包含`unistd.h`。
- en: 'Note that the event loop is now run directly by the `DroidBlaster` class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，事件循环现在由`DroidBlaster`类直接运行：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, initialize and run the `DroidBlaster` game in the `android_main()`
    entry point:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`android_main()`入口点初始化和运行`DroidBlaster`游戏：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*What just happened?*'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'If you like a black screen, you are served! Again, this time, everything happens
    in the Eclipse **LogCat** view. All messages that have been emitted in reaction
    to application events are displayed here, as shown in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢黑屏，你会得到！同样，这一次，一切都发生在Eclipse的**LogCat**视图中。对应用程序事件发出的所有消息都显示在这里，如下面的截图所示：
- en: '![What just happened?](img/9645_05_02.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/9645_05_02.jpg)'
- en: We created a minimalist framework, which handles application events in the native
    thread using an event-driven approach. Events (which are named commands) are redirected
    to a listener object, which performs its own specific computations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个最小化的框架，使用基于事件的方法在本机线程中处理应用程序事件。事件（被命名为命令）被重定向到一个监听器对象，该对象执行自己的特定计算。
- en: 'Native activity events correspond mostly to classic Java activity events. Events
    are a critical and rather tricky point that any application needs to handle. They
    occur generally in pairs, such as `start/stop`, `resume/pause`, `create/destroy`,
    `create window/destroy window`, or `gain/lose focus`. Although they occur most
    of the time in a predetermined order, some specific cases may cause different
    behaviors, for example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 原生活动事件大部分对应于经典的 Java 活动事件。事件是任何应用程序需要处理的关键和相当棘手的问题。它们通常成对出现，比如 `start/stop`、`resume/pause`、`create/destroy`、`create
    window/destroy window` 或 `gain/lose focus`。尽管它们大多数情况下按照预定的顺序发生，但一些特定情况可能导致不同的行为，例如：
- en: Leaving the application using the back button destroys the activity and native
    thread.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用返回按钮离开应用程序会销毁活动和原生线程。
- en: Leaving the application using the home button stops the activity and releases
    the window. The native thread is kept on hold.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主页按钮离开应用程序会停止活动并释放窗口。原生线程会保持挂起状态。
- en: Pressing the device's home button for a long time and then getting back should
    cause a loss and gain of focus only. The native thread is kept on hold.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间按住设备的主页按钮然后返回应该只会导致焦点的丢失和获取。原生线程会保持挂起状态。
- en: Shutting down the phone screen and switching it back should terminate and reinitialize
    the window right after the activity is resumed. The native thread is kept on hold.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭手机屏幕然后再次打开应该在活动恢复后立即终止和重新初始化窗口。原生线程会保持挂起状态。
- en: When changing screen orientation (not applicable here), the whole activity may
    not lose its focus, although the recreated activity will regain it.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当更改屏幕方向（这里不适用）时，整个活动可能不会失去焦点，尽管重新创建的活动将重新获得焦点。
- en: Understanding the activity lifecycle is essential to develop Android applications.
    Have a look at [http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html)
    in the official Android documentation for a detailed description.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 理解活动生命周期对于开发 Android 应用程序至关重要。在官方 Android 文档中查看 [http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html)
    以获取详细描述。
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The Native App Glue gives you a chance to save your activity state before it
    is destroyed by triggering `APP_CMD_SAVE_STATE`. The state must be saved in the
    `android_app` structure in `savedState`, which is a pointer to a memory buffer
    to save, and in `savedStateSize`, which is the size of the memory buffer to save.
    The buffer must be allocated by ourselves, using `malloc()` (deallocation being
    automatic), and must not contain pointers, only "raw" data.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Native App Glue 给了你一个机会，在触发 `APP_CMD_SAVE_STATE` 之前保存活动状态。状态必须保存在 `android_app`
    结构中的 `savedState` 中，它是一个指向要保存的内存缓冲区的指针，并且在 `savedStateSize` 中，它是要保存的内存缓冲区的大小。缓冲区必须由我们自己分配，使用
    `malloc()`（释放是自动的），并且不能包含指针，只能包含“原始”数据。
- en: Accessing window surface natively
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原生访问窗口表面
- en: Application events are essential to understand, but not very exciting. An interesting
    feature of the Android NDK is the ability to access the display window natively.
    With this privileged access, applications can draw any graphics they want onscreen.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序事件是理解的必要条件，但并不是很令人兴奋。 Android NDK 的一个有趣特性是能够原生访问显示窗口。通过这种特权访问，应用程序可以在屏幕上绘制任何他们想要的图形。
- en: 'We will now exploit this feature to get a graphic feedback in our application:
    a red square on screen. This square is going to represent the spaceship the user
    will control during the game.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将利用这个特性在我们的应用程序中获得图形反馈：屏幕上的一个红色正方形。这个正方形将代表用户在游戏中控制的飞船。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part3`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目名称为 `DroidBlaster_Part3`。
- en: Time for action – displaying raw graphics
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 显示原始图形
- en: Let's make `DroidBlaster` more interactive with some graphics and game components.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些图形和游戏组件使 `DroidBlaster` 更加交互。
- en: 'Edit `jni/Types.hpp` and create a new structure `Location` to hold entity positions.
    Also, define a macro to generate a random value in the requested range as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `jni/Types.hpp` 并创建一个新的结构 `Location` 来保存实体位置。同时，定义一个宏来生成请求范围内的随机值，如下所示：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a new file, `jni/GraphicsManager.hpp`. Define a structure `GraphicsElement`,
    which contains the location and dimensions of the graphical element to display:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，`jni/GraphicsManager.hpp`。定义一个结构 `GraphicsElement`，其中包含要显示的图形元素的位置和尺寸：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, in the same file, define a `GraphicsManager` class as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在同一个文件中，定义一个 `GraphicsManager` 类如下：
- en: '`getRenderWidth()` and `getRenderHeight()` to return the display size'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRenderWidth()` 和 `getRenderHeight()` 用于返回显示大小'
- en: '`registerElement()` is a `GraphicsElement` factory method that tells the manager
    what element to draw'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerElement()` 是一个 `GraphicsElement` 工厂方法，告诉管理器要绘制什么元素'
- en: '`start()` and `update()initialize` the manager and render the screen for each
    frame respectively'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start()` 和 `update()` 初始化管理器并分别为每一帧渲染屏幕'
- en: 'A few member variables are needed:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一些成员变量：
- en: '`mApplication` stores the application context needed to access the display
    window'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mApplication` 存储了访问显示窗口所需的应用程序上下文'
- en: '`mRenderWidth` and `mRenderHeight` for the display size'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mRenderWidth` 和 `mRenderHeight` 用于显示大小'
- en: '`mElements` and `mElementCount` for a table of all the elements to draw'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mElements` 和 `mElementCount` 用于绘制所有元素的表格'
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement `jni/GraphicsManager.cpp`, starting with the constructor, destructor,
    and registration methods. They manage the list of `GraphicsElement` to update:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `jni/GraphicsManager.cpp`，从构造函数、析构函数和注册方法开始。它们管理要更新的 `GraphicsElement` 列表：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Implement the `start()` method to initialize the manager.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `start()` 方法来初始化管理器。
- en: First, use the `ANativeWindow_setBuffersGeometry()` API method to force the
    window depth format to 32 bits. The two zeros passed in parameters are the required
    window width and height. They are ignored unless initialized with a positive value.
    In such a case, the requested window area defined by width and height is scaled
    to match the screen size.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`ANativeWindow_setBuffersGeometry()`API方法将窗口深度格式强制设置为32位。传递的两个零是所需的窗口宽度和高度。除非用正值初始化，否则它们将被忽略。在这种情况下，由宽度和高度定义的请求的窗口区域将被缩放以匹配屏幕尺寸。
- en: Then, retrieve all the necessary window dimensions in an `ANativeWindow_Buffer`
    structure. To fill this structure, the window must be first locked with `ANativeWindow_lock()`,
    and then unlocked with `AnativeWindow_unlockAndPost()` once done.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`ANativeWindow_Buffer`结构中检索所有必要的窗口尺寸。要填充这个结构，窗口必须首先用`ANativeWindow_lock()`锁定，然后在完成后用`ANativeWindow_unlockAndPost()`解锁。
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Write the `update()`method, which renders raw graphics each time an application
    is stepped.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`update()`方法，每次应用程序进行步进时都会渲染原始图形。
- en: The window surface must be locked before any draw operation takes place with
    `AnativeWindow_lock()`. Again, the `AnativeWindow_Buffer` structure is filled
    with window information for width and height, but more importantly, the `stride`
    and `bits` pointer.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何绘制操作之前，窗口表面必须被锁定，使用`AnativeWindow_lock()`。再次，`AnativeWindow_Buffer`结构填充了窗口信息，包括宽度和高度，但更重要的是`stride`和`bits`指针。
- en: The `stride` gives the distance in "pixels" between two successive pixel lines
    in the window.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`stride`给出窗口中两个连续像素行之间的距离。'
- en: The `bits` pointer gives direct access to the window surface, in much the same
    way as the Bitmap API, as seen in the previous chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`bits`指针直接访问窗口表面，方式与位图API相同，如前一章所示。'
- en: With these two pieces of information, any pixel-based operations can be performed
    natively.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个信息，就可以在本地执行任何基于像素的操作。
- en: For example, clear the window memory area with `0` to get a black background.
    A brute-force approach using `memset()` can be applied for that purpose.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用`0`清除窗口内存区域，以获得黑色背景。可以应用`memset()`的蛮力方法来实现这个目的。
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once cleared, draw all elements registered with `GraphicsManager`. Each element
    is represented as a red square onscreen.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除后，绘制所有注册到`GraphicsManager`的元素。每个元素在屏幕上表示为红色正方形。
- en: First, compute the coordinates (upper-left and bottom-right corners) of the
    elements to draw.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，计算要绘制的元素的坐标（左上角和右下角）。
- en: 'Then, clip their coordinates to avoid drawing outside the window memory area.
    This operation is rather important as going beyond window limits might result
    in a segmentation fault:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，裁剪它们的坐标，以避免在窗口内存区域之外绘制。这个操作相当重要，因为超出窗口限制可能导致分段错误：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After that, draw each pixel of the element on screen. The `line` variable points
    to the beginning of the first line of pixels on which the element is drawn. This
    pointer is computed using the stride (distance between two lines of pixels) and
    the top `Y` coordinate of the element.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在屏幕上绘制元素的每个像素。`line`变量指向元素绘制的第一行像素的开头。这个指针是使用stride（两行像素之间的距离）和元素的顶部`Y`坐标计算出来的。
- en: Then, we can loop over window pixels to draw a red square representing the element.
    Start from the left `X` coordinate to the right `X` coordinate of the element,
    switching from one pixel line to another (that is, on the `Y` axis) when the end
    of each is reached.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以循环遍历窗口像素，绘制代表元素的红色正方形。从元素的左`X`坐标到右`X`坐标开始，当到达每个像素行的末尾时（即在`Y`轴上），切换到另一个像素行。
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finish drawing operations with `ANativeWindow_unlockAndPost()` and pend call
    to `pendANativeWindow_lock()`. These must always be called in pairs:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ANativeWindow_unlockAndPost()`完成绘图操作，并调用`pendANativeWindow_lock()`。这些必须成对调用：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Create a new component `jni/Ship.hpp` that represents our spaceship.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的组件`jni/Ship.hpp`，代表我们的飞船。
- en: We will handle initialization only for now, using `initialize()`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只处理初始化，使用`initialize()`。
- en: '`Ship` is created with the factory method `registerShip()`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂方法`registerShip()`创建`Ship`。
- en: The `GraphicsManager` and the ship `GraphicsElement` are needed to initialize
    the ship properly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 需要初始化船只的`GraphicsManager`和船只`GraphicsElement`。
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement `jni/Ship.cpp`. The important part is `initialize()`, which positions
    the ship on the lower quarter of the screen, as shown in the following code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`jni/Ship.cpp`。重要的部分是`initialize()`，它将飞船定位在屏幕的下四分之一，如下所示：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Append the newly created manager and component to `jni/DroidBlaster.hpp`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的管理器和组件附加到`jni/DroidBlaster.hpp`：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, update the `jni/DroidBlaster.cpp` constructor:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新`jni/DroidBlaster.cpp`构造函数：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Initialize `GraphicsManager` and the `Ship` component in `onActivate()`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onActivate()`中初始化`GraphicsManager`和`Ship`组件：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, update the manager in `onStep()`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`onStep()`中更新管理器：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*What just happened?*'
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'Compile and run `DroidBlaster`. The result should be a simple red square representing
    our spaceship in the first quarter of the screen, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行`DroidBlaster`。结果应该是屏幕的第一季度中代表我们的飞船的简单红色正方形，如下所示：
- en: '![What just happened?](img/9645_05_04.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/9645_05_04.jpg)'
- en: Graphical feedback is provided through the `ANativeWindow` API, which gives
    native access to the display window. It allows manipulating its surface like a
    bitmap. Similarly, accessing the window surface requires locking and unlocking
    both before and after processing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ANativeWindow` API提供图形反馈，它可以本地访问显示窗口。它允许像操作位图一样操纵其表面。同样，访问窗口表面需要在处理之前和之后都进行锁定和解锁。
- en: 'The `AnativeWindow` API is defined in `android/native_window.h` and `android/native_window_jni.h`.
    It provides the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnativeWindow` API在`android/native_window.h`和`android/native_window_jni.h`中定义。它提供以下内容：'
- en: '`ANativeWindow_setBuffersGeometry()` initializes the Pixel format (or Depth
    format) and size of the window buffer. The possible Pixel formats are:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`ANativeWindow_setBuffersGeometry()`初始化窗口缓冲区的像素格式（或深度格式）和大小。可能的像素格式有：'
- en: '`WINDOW_FORMAT_RGBA_8888` for 32-bit colors per pixel, 8 bits for each of the
    Red, Green, Blue, and Alpha (for transparency) channels.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WINDOW_FORMAT_RGBA_8888`表示每像素32位颜色，每个通道8位，分别为红色、绿色、蓝色和Alpha（透明度）通道。'
- en: '`WINDOW_FORMAT_RGBX_8888` is the same as the previous one, except that the
    Alpha channel is ignored.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WINDOW_FORMAT_RGBX_8888`与前一个相同，只是忽略了Alpha通道。'
- en: '`WINDOW_FORMAT_RGB_565` for 16-bit colors per pixel (5 bits for Red and Blue,
    and 6 for the Green channel).'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WINDOW_FORMAT_RGB_565`表示每像素16位颜色（红色和蓝色各5位，绿色通道6位）。'
- en: 'If the supplied dimension is `0`, the window size is used. If it is non-zero,
    then the window buffer is scaled to match window dimensions when displayed onscreen:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的尺寸为`0`，则使用窗口大小。如果不为零，则在屏幕上显示时，窗口缓冲区将被缩放以匹配窗口尺寸：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`ANativeWindow_lock()` must be called before performing any drawing operations:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行任何绘图操作之前必须调用`ANativeWindow_lock()`：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`ANativeWindow_unlockAndPost()` releases the window after drawing operations
    are done and sends it to the display. It must be called in a pair with `ANativeWindow_lock()`:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在完成绘图操作后释放窗口并将其发送到显示器的`ANativeWindow_unlockAndPost()`。它必须与`ANativeWindow_lock()`成对调用：
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`ANativeWindow_acquire()` gets a reference, in the Java way, on the specified
    window to prevent potential deletion. This might be necessary if you do not have
    fine control on the surface life cycle:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANativeWindow_acquire()`以Java方式获取指定窗口的引用，以防止潜在的删除。如果您对表面的生命周期没有很好的控制，这可能是必要的：'
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`ANativeWindow_fromSurface()` associates the window with the given Java `android.view.Surface`.
    This method automatically acquires a reference to the given surface. It must be
    released with `ANativeWindow_release()` to avoid memory leaks:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANativeWindow_fromSurface()`将窗口与给定的Java `android.view.Surface`关联起来。此方法会自动获取对给定表面的引用。必须使用`ANativeWindow_release()`释放它，以避免内存泄漏：'
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`ANativeWindow_release()` removes an acquired reference to allow freeing window
    resources:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANativeWindow_release()`取消获取的引用，以允许释放窗口资源：'
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following methods return the width, height (in pixels), and the format
    of the window surface. The returned value is negative incase an error occurs.
    Note that these methods are tricky to use because their behavior is a bit inconsistent.
    Prior to Android 4, it is preferable to lock the surface once to get reliable
    information (which is already provided by `ANativeWindow_lock()`):'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下方法返回窗口表面的宽度、高度（以像素为单位）和格式。如果发生错误，返回的值为负数。请注意，由于这些方法的行为有点不一致，在Android 4之前，最好是锁定表面一次以获取可靠的信息（这已经由`ANativeWindow_lock()`提供）：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We now know how to draw. However, how do we animate what is drawn? A key is
    needed in order to do this: *time*.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何绘制。但是，如何使所绘制的内容动起来呢？这就需要一个关键：*时间*。
- en: Measuring time natively
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地测量时间
- en: Those who talk about graphics also need to talk about timing. Indeed, Android
    devices have different capabilities, and animations should be adapted to their
    speed. To help us in this task, Android gives access to time primitives, thanks
    to its good support of Posix APIs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 谈论图形的人也需要谈论时间。的确，Android设备具有不同的功能，动画应该根据其速度进行调整。为了帮助我们完成这项任务，Android通过其对Posix
    API的良好支持，提供了对时间原语的访问。
- en: To experiment with these capabilities, we will use a timer to move asteroids
    onscreen according to time.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试这些功能，我们将使用定时器根据时间在屏幕上移动小行星。
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part4`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的项目名称为`DroidBlaster_Part4`，并随本书提供。
- en: Time for action – animating graphics with a timer
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采取行动-使用定时器为图形添加动画
- en: Let's animate the game.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来给游戏添加动画。
- en: 'Create `jni/TimeManager.hpp` with the `time.h` manager and define the following
    methods:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/TimeManager.hpp`，其中包含`time.h`管理器，并定义以下方法：
- en: '`reset()` to initialize the manager.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset()`来初始化管理器。'
- en: '`update()` to measure game step duration.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`用于测量游戏步长持续时间。'
- en: '`elapsed()` and `elapsedTotal()` to get game step duration and game duration.
    They are going to allow the adaptation of the application behavior to the device
    speed.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elapsed()`和`elapsedTotal()`用于获取游戏步长持续时间和游戏持续时间。它们将允许将应用程序行为适应设备速度。'
- en: '`now()` is a utility method to recompute the current time.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`now()`是一个重新计算当前时间的实用方法。'
- en: 'Define the following member variables:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 定义以下成员变量：
- en: '`mFirstTime` and `mLastTime` to save a time checkpoint in order to compute
    `elapsed()` and `elapsedTotal()`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mFirstTime`和`mLastTime`用于保存时间检查点，以便计算`elapsed()`和`elapsedTotal()`'
- en: '`mElapsed` and `mElapsedTotal` to save computed time measures'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mElapsed`和`mElapsedTotal`用于保存计算的时间测量'
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Implement `jni/TimeManager.cpp`. When reset, `TimeManager` saves the current
    time computed by the `now()` method.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`jni/TimeManager.cpp`。重置时，`TimeManager`保存由`now()`方法计算的当前时间。
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Implement `update()` which checks:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`update()`，检查：
- en: elapsed time since last frame in `mElapsed`
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一帧到现在的经过时间为`mElapsed`
- en: elapsed time since the very first frame in `mElapsedTotal`
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自第一帧以来的经过时间为`mElapsedTotal`
- en: Note
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that it is important to work with double types when handling the current
    time to avoid losing accuracy. Then, the resulting delay can be converted back
    to float for the elapsed time, since the time difference between the two frames
    is quite low.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在处理当前时间时，重要的是使用double类型，以避免失去精度。然后，由于两帧之间的时间差非常低，因此得到的延迟可以转换回浮点数以获取经过的时间。
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Compute the current time in the `now()` method. Use the Posix primitive `clock_gettime()`
    to retrieve the current time. A monotonic clock is essential to ensure that the
    time always goes forward and is not subject to system changes (for example, if
    the user travels around the world):'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`now()`方法中计算当前时间。使用Posix原语`clock_gettime()`来检索当前时间。单调时钟是必不可少的，以确保时间始终向前推进，并且不受系统更改的影响（例如，如果用户环游世界）：
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create a new file, `jni/PhysicsManager.hpp`. Define a structure `PhysicsBody`
    to hold asteroid location, dimensions, and velocity:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`jni/PhysicsManager.hpp`。定义一个结构`PhysicsBody`来保存小行星的位置、尺寸和速度：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Define a basic `PhysicsManager`. We need a reference to `TimeManager` to adapt
    bodies of movements to time.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个基本的`PhysicsManager`。我们需要一个对`TimeManager`的引用，以便将物体的运动适应时间。
- en: 'Define a method `update()` to move asteroids during each game step. The `PhysicsManager`
    stores the asteroids to update in `mPhysicsBodies` and `mPhysicsBodyCount`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个`update()`方法，在每个游戏步骤中移动小行星。`PhysicsManager`存储要更新的小行星在`mPhysicsBodies`和`mPhysicsBodyCount`中：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Implement `jni/PhysicsManager.cpp`, starting with the constructor, destructor,
    and registration methods:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从构造函数、析构函数和注册方法开始实现`jni/PhysicsManager.cpp`：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Move asteroids in `update()` according to their velocity. The computation is
    performed according to the amount of time between the two game steps:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据其速度在`update()`中移动小行星。计算是根据两个游戏步骤之间的时间量执行的：
- en: '[PRE51]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create the `jni/Asteroid.hpp` component with the following methods:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方法创建`jni/Asteroid.hpp`组件：
- en: '`initialize()` to set up asteroids with random properties when the game starts'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()`在游戏开始时设置具有随机属性的小行星'
- en: '`update()` to detect asteroids that get out of game boundaries'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`以检测超出游戏边界的小行星'
- en: '`spawn()` is used by both `initialize()` and `update()` to set up one individual
    asteroid'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spawn()`被`initialize()`和`update()`使用，以设置一个单独的小行星'
- en: 'We also need the following members:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要以下成员：
- en: '`mBodies` and `mBodyCount` to store the list of asteroids to be managed'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mBodies`和`mBodyCount`用于存储要管理的小行星列表'
- en: A few integer members to store game boundaries
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些整数成员用于存储游戏边界
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Write the `jni/Asteroid.cpp` implementation. Start with a few constants, as
    well as the constructor and registration method, as follows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`jni/Asteroid.cpp`实现。首先是一些常量，以及构造函数和注册方法，如下所示：
- en: '[PRE53]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Set up boundaries in `initialize()`. Asteroids are generated above the top of
    screen (in `mMinBound`, the maximum boundary `mUpperBound` is twice the height
    of the screen). They move from the top to the bottom of the screen. Other boundaries
    correspond to screen edges padded with a margin (representing twice the size of
    an asteroid).
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initialize()`中设置边界。小行星在屏幕顶部生成（在`mMinBound`中，最大边界`mUpperBound`是屏幕高度的两倍）。它们从屏幕顶部向底部移动。其他边界对应于填充有边距的屏幕边缘（表示小行星大小的两倍）。
- en: 'Then, initialize all asteroids using `spawn()`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`spawn()`初始化所有小行星：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'During each game step, check the asteroids that get out of bounds and reinitialize
    them:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个游戏步骤中，检查超出边界的小行星并重新初始化它们：
- en: '[PRE55]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, initialize each asteroid in `spawn()`, with velocity and location
    being generated randomly:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`spawn()`中初始化每个小行星，速度和位置是随机生成的：
- en: '[PRE56]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add the newly created managers and components to `jni/DroidBlaster.hpp`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的管理器和组件添加到`jni/DroidBlaster.hpp`：
- en: '[PRE57]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Register asteroids with `GraphicsManager` and `PhysicsManager` in the `jni/DroidBlaster.cpp`
    constructor:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.cpp`构造函数中注册小行星到`GraphicsManager`和`PhysicsManager`：
- en: '[PRE58]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Initialize the newly added classes in `onActivate()` properly:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onActivate()`中正确初始化新添加的类：
- en: '[PRE59]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*What just happened?*'
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Compile and run the application. This time it should be a bit more animated!
    Red squares representing asteroids cross the screen at a constant rhythm. The
    `TimeManger` helps with setting the pace.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行应用程序。这次应该更有动画效果！代表小行星的红色正方形以恒定的节奏穿过屏幕。`TimeManger`有助于设置步伐。
- en: '![What just happened?](img/9645_05_05.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/9645_05_05.jpg)'
- en: Timers are essential to display animations and movement at the correct speed.
    They can be implemented with the POSIX method `clock_gettime()`, which retrieves
    time with a high precision, theoretically to the nanosecond.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器对于以正确的速度显示动画和移动是至关重要的。它们可以使用POSIX方法`clock_gettime()`实现，该方法以高精度检索时间，理论上可以达到纳秒级。
- en: In this tutorial, we used the `CLOCK_MONOTONIC` flag to set up the timer. A
    monotonic clock gives the elapsed clock time from an arbitrary starting point
    in the past. It is unaffected by potential system date change, and thus cannot
    go back in the past like other options. The downside with `CLOCK_MONOTONIC` is
    that it is system-specific and it is not guaranteed to be supported. Hopefully
    Android supports it, but care should be taken when porting Android code to other
    platforms. Another point specific to Android to be aware of is that monotonic
    clocks stop when the system is suspended.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们使用了`CLOCK_MONOTONIC`标志来设置计时器。单调时钟从过去的任意起始点给出经过的时钟时间。它不受潜在的系统日期更改的影响，因此不能像其他选项那样返回过去。`CLOCK_MONOTONIC`的缺点是它是特定于系统的，并且不能保证支持。希望Android支持它，但在将Android代码移植到其他平台时应谨慎。另一个特定于Android的要点是，当系统暂停时，单调时钟会停止。
- en: 'An alternative, that is less precise and affected by changes in the system
    time (which may or may not be desirable), is `gettimeofday()`, which is also provided
    in `ctime`. The usage is similar but the precision is in microseconds instead
    of nanoseconds. The following could be a usage example that could replace the
    current `now()` implementation in `TimeManager`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，不太精确且受系统时间更改影响（可能是不可取的），是`gettimeofday()`，它也在`ctime`中提供。使用方法类似，但精度是微秒而不是纳秒。以下是一个用法示例，可以替换`TimeManager`中当前的`now()`实现：
- en: '[PRE60]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For more information, have a look at the Man-pages at [http://man7.org/linux/man-pages/man2/clock_gettime.2.html](http://man7.org/linux/man-pages/man2/clock_gettime.2.html).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请查看[http://man7.org/linux/man-pages/man2/clock_gettime.2.html](http://man7.org/linux/man-pages/man2/clock_gettime.2.html)上的Man-pages。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The Android NDK allows us to write fully native applications without a line
    of Java code. `NativeActivity` provides a skeleton to implement an event loop
    that processes application events. Associated with the Posix time management API,
    the NDK provides the required base to build complex multimedia applications or
    games.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK允许我们编写完全的本机应用程序，而无需一行Java代码。`NativeActivity`提供了一个框架，用于实现处理应用程序事件的事件循环。与Posix时间管理API相关联，NDK提供了构建复杂多媒体应用程序或游戏所需的基础。
- en: In summary, we created `NativeActivity` that polls activity events to start
    or stop native code accordingly. We accessed the display window natively, like
    a bitmap, to display raw graphics. Finally, we retrieved time to make the application
    adapt to device speed using a monotonic clock.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们创建了`NativeActivity`，它轮询活动事件以相应地启动或停止本机代码。我们以本机方式访问显示窗口，就像位图一样，以显示原始图形。最后，我们检索时间以使应用程序适应设备速度，使用单调时钟。
- en: The basic framework initiated here will form the base of the 2D/3D game that
    we will develop throughout this book. However, although the flat design is in
    fashion nowadays, we need something a bit fancier than red squares!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这里启动的基本框架将构成我们在整本书中将开发的2D/3D游戏的基础。然而，尽管扁平设计如今很流行，我们需要比红色方块更花哨的东西！
- en: In the next chapter, we will discover how to render advanced graphics with OpenGL
    ES 2 for Android.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将发现如何使用OpenGL ES 2在Android上渲染高级图形。
