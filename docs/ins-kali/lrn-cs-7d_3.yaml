- en: Day 03 - What&#x27;s New in C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三天 - C#中的新功能
- en: 'Today, we will learn a very recent and newly released feature with the current
    version of the C# language, that is, C# 7.0 (this is the most recent adaptation
    amid the review of this book). Some of these elements are altogether new and others
    were present in past adaptations and have been upgraded in the current version
    of the language. C# 7.0 will change the game with a lot of new features to the
    table. Some of these elements, such as tuples, are augmentations of officially
    accessible ideas while others are completely new. Here are the fundamental elements
    we will learn about on Day 03:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们将学习C#语言的当前版本中非常新的和新发布的功能，即C# 7.0（这是本书审阅中最新的适应版本）。其中一些元素是全新的，而其他一些在过去的版本中已经存在，并在当前版本中得到了升级。C#
    7.0将带来许多新功能。其中一些元素，比如元组，是已经存在的概念的扩展，而其他一些是全新的。以下是我们将在第三天学习的基本元素：
- en: Tuples and deconstruction
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组和解构
- en: Pattern matching
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Local functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地函数
- en: Literal improvements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字改进
- en: Async Main
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步主函数
- en: Default Expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认表达式
- en: Infer Tuple Names
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推断元组名称
- en: Tuples and deconstruction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组和解构
- en: Tuples have not been newly introduced in the current version but were introduced
    with the .NET 4.0 release. In the present release, they have been improved.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 元组并不是在当前版本中新引入的，而是在.NET 4.0发布时引入的。在当前版本中，它们得到了改进。
- en: Tuples
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: Tuples are there at whatever point a particular case needs to return multiple
    values from a method. For instance, let's say we have to find odd and even numbers
    from a given number series.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每当特定情况需要从方法返回多个值时，就会使用元组。例如，假设我们需要从给定数字系列中找到奇数和偶数。
- en: Tuples are an unchanging information esteem that hold related data. Tuples used
    to aggregate together related data, for example, such that a person's name, age,
    gender and whatever you want data as an information.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是一个包含相关数据的不可变数据值。元组用于聚合相关数据，例如一个人的姓名、年龄、性别以及任何你想要的数据作为输入。
- en: To complete this, our method should return or provide us the result with a number
    and saying whether this is an odd number or even number. For a method that will
    return these multiple values, we could use custom datatypes, dynamic return types,
    or out parameters, which sometimes will create confusion for a developer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个问题，我们的方法应该返回或提供一个数字，并说明这是一个奇数还是偶数。对于将返回这些多个值的方法，我们可以使用自定义数据类型、动态返回类型或输出参数，这有时会让开发人员感到困惑。
- en: 'To use tuples, you need to add the NuGet package:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用元组，您需要添加NuGet包：
- en: '[https://www.nuget.org/packages/System.ValueTuple/](https://www.nuget.org/packages/System.ValueTuple/)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.nuget.org/packages/System.ValueTuple/](https://www.nuget.org/packages/System.ValueTuple/)'
- en: For this problem, we have a tuple object and in C# 7.0 we have two different
    things, tuple types and tuple literals, to return multiple values from a method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，我们有一个元组对象，在C# 7.0中我们有两种不同的东西，元组类型和元组文字，用于从方法返回多个值。
- en: 'Let us discuss tuples in detail using a code example. Consider the following
    code snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个代码示例详细讨论元组。考虑以下代码片段：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code snippet, we added more descriptive names to our tuple.
    Now the caller method can directly use these names, as shown in the following
    code snippet:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们为元组添加了更具描述性的名称。现在调用方法可以直接使用这些名称，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By adding some descriptive names to the tuple, we can easily identify and use
    items/elements of the tuple in the caller method.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为元组添加一些描述性名称，我们可以在调用方法中轻松识别和使用元组的项目/元素。
- en: The System.ValueTuple struct
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System.ValueTuple结构
- en: 'Tuples in C# 7.0 require the NuGet package `System.ValueType`. This is nothing
    but a struct by design. This contains a few static and public methods to work
    undeneath:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.0中，元组需要NuGet包`System.ValueType`。这实际上是一个结构。它包含一些静态和公共方法来进行操作：
- en: '**CompareTo(ValueTuple)**: A public method that compares to the `ValueTuple`
    instance. The method returns 0 if the comparison is successful, else it returns
    1.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CompareTo(ValueTuple)**：比较`ValueTuple`实例的公共方法。如果比较成功，则该方法返回0，否则返回1。'
- en: 'Here we have two methods that show the power of the `CompareTo` method:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有两个方法展示了`CompareTo`方法的强大之处：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the calling code snippet to get the results from preceding code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调用代码片段，用于从上述代码中获取结果：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we execute the preceding code, it will provide the output as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行上述代码时，将会得到以下输出：
- en: '![](img/00044.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00044.jpeg)'
- en: '**Equals(Object)**: A public method that returns true/false, stating whether
    the `TupleValue` instance is equal to the provided object. It returns true if
    successful.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Equals(Object)**：返回true/false的公共方法，指示`TupleValue`实例是否等于提供的对象。如果成功则返回true。'
- en: 'The following is the implementation:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是实现：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the calling method code snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调用方法的代码片段：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, the output is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，输出如下：
- en: '![](img/00045.gif)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00045.gif)'
- en: '**Equals(ValueTuple)**: A public method that always returns true and it''s
    by design. It is designed in this way because `ValueTuple` is a zero-element tuple,
    hence when two ValueTuples perform equally having no element will always return
    zero.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Equals(ValueTuple)**：始终返回true的公共方法，这是设计上的。它是这样设计的，因为`ValueTuple`是一个零元素元组，因此当两个ValueTuples执行相等操作时，由于没有元素，将始终返回零。'
- en: '**GetHashCode()**: A public method that returns the hash code of the object.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GetHashCode()**：返回对象的哈希码的公共方法。'
- en: '**GetType()**: A public method that provides the specific type of the current
    instance.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GetType()**：提供当前实例的具体类型的公共方法。'
- en: '**ToString()**: A public method that is a string representation of the `ValueTuple`
    instance. However, as per design, it always returns zero.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ToString()**：是`ValueTuple`实例的字符串表示形式的公共方法。然而，根据设计，它总是返回零。'
- en: '**Create()**: A static method that creates a new `ValueTuple` (0 tuple). We
    can create a 0 tuple as follows:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Create()**：创建一个新的`ValueTuple`（0元组）的静态方法。我们可以按以下方式创建0元组：'
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Create<T1>(T1) ... Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1, T2, T3, T4, T5, T6, T7, T8)**:
    All are static methods which create Value Tuples with 1-components (singleton)
    to 8-components (octuple).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Create<T1>(T1) ... Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1, T2, T3, T4, T5, T6, T7, T8)**：所有这些都是创建具有1个组件（单例）到8个组件（八元组）的Value
    Tuples的静态方法。'
- en: 'See the following code snippet showing singleton and octuple examples:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参见以下代码片段，显示了单例和八元组示例：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will need to update the NuGet package to Microsoft.Net.Compilers to 2.0
    preview if you get compilation warnings. To do so, just select preview and search
    Microsoft.Net.Compilers to 2.0 from NuGet Package Manager [[https://www.nuget.org/packages/Microsoft.Net.Compilers/](https://www.nuget.org/packages/Microsoft.Net.Compilers/)].
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现编译警告，您需要将NuGet包更新到Microsoft.Net.Compilers 2.0预览版。要这样做，只需选择预览并从NuGet包管理器中搜索Microsoft.Net.Compilers到2.0[[https://www.nuget.org/packages/Microsoft.Net.Compilers/](https://www.nuget.org/packages/Microsoft.Net.Compilers/)]。
- en: Deconstruction
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构
- en: In the preceding section, we saw that multiple return values with the use of
    `ValueTuple` are accessible with its items/element. Now think of a scenario where
    we want to directly assign these element values to variables. Here, deconstruction
    helps us. Deconstruction is a way in which we can unpackage the tuple that is
    returned by a method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们看到了使用`ValueTuple`的多个返回值可以通过其项/元素进行访问。现在想象一种情况，我们想要直接将这些元素值分配给变量。在这里，解构帮助了我们。解构是一种我们可以拆开方法返回的元组的方式。
- en: 'There are mainly two ways to deconstruct a tuple:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有两种方法可以解构元组：
- en: 'Explicitly typed declaration: We explicitly declare the type of each field.
    Let''s see the following code example:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式声明类型：我们明确声明每个字段的类型。让我们看下面的代码示例：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Implicitly typed declaration: We implicitly declare the type of each field.
    Let''s see the following code example:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式声明类型：我们隐式声明每个字段的类型。让我们看下面的代码示例：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can also deconstruct UserDefined/Custom types by implementing deconstruction
    using out parameters; see the following code-example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用out参数实现解构UserDefined/Custom类型；请参阅以下代码示例：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, the deconstruct method enables assignment from a `UserDefinedModel`
    to one int and one string, which represent the properties `number` and `OddEven`
    respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，deconstruct方法使得从`UserDefinedModel`到一个int和一个string的赋值成为可能，它们分别代表了属性`number`和`OddEven`。
- en: Tuple – important points to remember
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组 - 需要记住的重要要点
- en: 'In the preceding section, we discussed tuples and noticed how they help us
    in scenarios where we need multiple values and complex data values (besides custom
    types). Here are the important points that we should remember while working with
    tuples:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了元组，并注意到它们如何在需要多个值和复杂数据值（除了自定义类型）的情况下帮助我们。以下是我们在使用元组时应该记住的重要要点：
- en: To work with tuples, we need the NuGet package `System.ValueTuple`.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元组，我们需要NuGet包`System.ValueTuple`。
- en: '`ValueTuple` (`System.ValueTuple`) is a struct instead of a class by design.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValueTuple` (`System.ValueTuple`)是一个结构，而不是一个类。'
- en: '`ValueTuple` implements `IEquatable<ValueTuple>, IStructuralEquatable, IStructuralComparable,
    IComparable, IComparable<ValueTuple>` interfaces.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValueTuple`实现了`IEquatable<ValueTuple>, IStructuralEquatable, IStructuralComparable,
    IComparable, IComparable<ValueTuple>`接口。'
- en: ValueTuples are mutable.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ValueTuples是可变的。
- en: 'ValueTuples are flexible data containers and can be either unnamed or named:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ValueTuples是灵活的数据容器，可以是未命名的，也可以是命名的：
- en: '**Unnamed**: When we do not provide any name for a field, these are unnamed
    tuples and accessible using the default fields `Item1`, `Item2`, and so on:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未命名**：当我们不为字段提供任何名称时，这些是未命名的元组，并且可以使用默认字段`Item1`，`Item2`等进行访问：'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Named**: When we explicitly provide some descriptive name to fields:'
  id: totrans-70
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名**：当我们为字段明确提供一些描述性名称时：'
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Assignment: When we assign one tuple to another, only values get assigned and
    not field names:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值：当我们将一个元组分配给另一个元组时，只有值被分配，而字段名称不会：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding code-snippet would be as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段的输出将如下所示：
- en: '![](img/00046.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00046.jpeg)'
- en: In the preceding code-snippet, we can see that the output of an assigned tuple
    is the same with an assigned tuple.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到分配的元组的输出与分配的元组相同。
- en: Pattern matching
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: In a general way, pattern matching is a way to compare contents in predefined
    formats in an expression. The format is nothing but a combination of different
    matches.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，模式匹配是一种在表达式中比较预定义格式的内容的方法。格式实际上是不同匹配的组合。
- en: In C# 7.0, pattern matching is a feature. With the use of this feature, we can
    implement method dispatch on properties other than the type of an object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.0中，模式匹配是一个特性。通过使用这个特性，我们可以在对象的类型之外实现方法分派。
- en: Pattern matching supports various expressions; let's discuss these with code-examples.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配支持各种表达式；让我们通过代码示例讨论这些。
- en: 'Patterns can be constant patterns: Type patterns or Var patterns.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 模式可以是常量模式：类型模式或变量模式。
- en: is expression
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: is表达式
- en: 'The `is` expression enables the inspection of an object and its properties
    and determines whether it satisfies the pattern:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`表达式使得可以检查对象及其属性，并确定它是否满足模式：'
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code is not showing any fancy stuff and informs us whether the
    input parameter is a specific type and a vowel or a consonant. You can see here
    we simply use the `is` operator, that tells whether the object is of the same
    type or not.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码没有展示任何花哨的东西，只是告诉我们输入参数是否是特定类型和元音或辅音。在这里我们简单地使用`is`运算符，告诉对象是否是相同类型。
- en: The `is` operator ([https://goo.gl/79sLW5](https://goo.gl/79sLW5)) checks the
    object, and if the object is of the same type, it returns true; if not, it returns
    false.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`运算符([https://goo.gl/79sLW5](https://goo.gl/79sLW5))检查对象，如果对象是相同类型，则返回true；如果不是，则返回false。'
- en: 'In the preceding code, while we are checking object for string, we need to
    explicitly cast object to string and then pass this to our utility method, `IsVowel()`.
    In the preceding code, we are doing two things: the first is checking the type
    of the incoming parameter and if the type is the same then we are casting it to
    the desired type and performing actions as per our case. Sometimes this creates
    confusion when we need to write more complex logic with expressions.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当我们检查对象是否为字符串时，我们需要显式地将对象转换为字符串，然后将其传递给我们的实用方法`IsVowel()`。在前面的代码中，我们正在做两件事：第一是检查传入参数的类型，如果类型相同，我们就将其转换为所需的类型，并根据我们的情况执行操作。有时，当我们需要使用表达式编写更复杂的逻辑时，这会造成混淆。
- en: 'C# 7.0 resolves this subtly to make our expression simpler. Now we can directly
    declare a variable while checking the type in an expression; see the following
    code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0以微妙的方式解决了这个问题，使我们的表达式更简单。现在我们可以在表达式中直接声明一个变量，同时检查类型；请参阅以下代码：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, which is updated where the `is` expression both tests
    the variable and assigns it to a new variable of the desired type. With this change,
    there is no need to explicitly cast the type `((string) character)` as we were
    doing in the previous code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，更新了`is`表达式，它既测试变量又将其分配给所需类型的新变量。有了这个改变，就不需要像在以前的代码中那样显式地转换类型`((string)
    character)`。
- en: 'Let us add one more condition to the preceding code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在前面的代码中添加一个条件：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we are checking *object* for `int`, which is a *struct*.
    The preceding condition works perfectly fine and produces the expected results.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在检查*对象*是否为`int`，这是一个*结构*。前面的条件完全正常，并产生了预期的结果。
- en: 'Here is our complete code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们完整的代码：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `is` expression works perfectly fine with both value types as well as reference
    types.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`表达式可以很好地处理值类型和引用类型。'
- en: In the preceding code-example, the variables `str` and `number` are only assigned
    when the respective expression matches results as `true`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，只有当相应的表达式匹配结果为`true`时，变量`str`和`number`才会被赋值。
- en: switch statement
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: switch语句
- en: We have already discussed the `switch` statement in Day 02\. The `switch` pattern
    helps a great deal as it uses any datatype for matching additionally `case` provides
    a way so, it matched the condition.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第2天讨论了`switch`语句。`switch`模式非常有用，因为它可以使用任何数据类型进行匹配，此外`case`提供了一种方式，因此它匹配了条件。
- en: The `match` expression is the same but in C# 7.0, this feature has been enhanced
    in three different ways. Let us understand them using code examples.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`表达式是相同的，但在C# 7.0中，这个特性以三种不同的方式得到了增强。让我们使用代码示例来理解它们。'
- en: constant pattern
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量模式
- en: 'In earlier versions of C#, the `switch` statement only supported the *constant*
    pattern, where we evaluate some variable in the `switch` and then make a conditional
    call as per the constant case. See the following code example, where we are trying
    to check whether `inputChar` is of a specific length, which is computed in `switch`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#的早期版本中，`switch`语句只支持*常量*模式，在这种模式中，我们在`switch`中评估一些变量，然后根据常量情况进行条件调用。请参阅以下代码示例，我们试图检查`inputChar`是否具有特定长度，这是在`switch`中计算的：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, our main task is to check whether `inputChar` is a vowel
    or consonant, and what we are doing here is we are first evaluating the length
    of the `inputChar` and then performing operations as required, which leads to
    more work/code for more complex conditions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们的主要任务是检查`inputChar`是元音还是辅音，我们在这里要做的是首先评估`inputChar`的长度，然后根据需要执行操作，这会导致更复杂条件的更多工作/代码。
- en: type pattern
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型模式
- en: 'With the introduction of the *type* pattern, we can overcome the problem we
    were facing with the *constant* pattern (in the previous section). Consider the
    following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入*类型*模式，我们可以克服我们在*常量*模式（在前一节中）中遇到的问题。请考虑以下代码：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, now it's easy to perform the operation as per type pattern.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，现在根据类型模式执行操作变得更容易。
- en: When clause in case expression
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`case`表达式中的`when`子句
- en: 'With the introduction of a `when` clause in `case` expressions, you can do
    special things in the expression; see the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`case`表达式中引入`when`子句，您可以在表达式中执行特殊操作；请参阅以下代码：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, `case` with `when` makes sure that it will perform the
    operation only if `listObjects` has some value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`case`与`when`确保只有在`listObjects`有一些值时才执行操作。
- en: The `case` statement requires that each `case` ends with a `break`, `return`,
    or `goto`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`语句要求每个`case`都以`break`、`return`或`goto`结束。'
- en: Local functions
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地函数
- en: 'Local functions can be achievable using function and action using anonymous
    methods in prior versions, but there are still a few limitations:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的版本中，可以使用匿名方法来实现函数和动作，但仍然存在一些限制：
- en: Generics
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型
- en: '`ref` and `out` parameters'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ref`和`out`参数'
- en: '`params`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`'
- en: Local functions are featured to declare within the block scope. These functions
    are very powerful and have the same capability as any other normal function but
    with the difference that they are scoped within the block these were declared.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本地函数的特点是在块范围内声明。这些函数非常强大，并且具有与任何其他普通函数相同的功能，但不同之处在于它们在声明它们的块内部范围内。
- en: 'Consider the following code-example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码示例：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The method `FindOddEvenBySingleNumber()` in the preceding code is simply returning
    a number as *Odd* or *Even* for numbers greater than 1\. This uses a private method,
    `IsOddNumber()`, as shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，方法`FindOddEvenBySingleNumber()`只是简单地返回大于1的数字为*奇数*或*偶数*。这使用了一个私有方法`IsOddNumber()`，如下所示：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The method `IsOddNumber()` is a private method and is available within the class
    it declared. Hence, its scope is within a class and not within a code block.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`IsOddNumber()`是一个私有方法，只能在声明它的类中使用。因此，它的范围在类内部，而不是在代码块内部。
- en: 'Let us see the following code-example of a local function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个本地函数的代码示例：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, the local function `IsOddNumber()` is performing the
    same action as in the case of the `private` method in the previous section. But
    here, the scope of `IsOddNumber()` is within the method `FindOddEvenBySingleNumberUsingLocalFunction()`.
    Hence, it would not be available outside this code block.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，本地函数`IsOddNumber()`执行的操作与上一节中的`private`方法相同。但是在这里，`IsOddNumber()`的范围在方法`FindOddEvenBySingleNumberUsingLocalFunction()`内。因此，它在此代码块之外将不可用。
- en: Literal improvements
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文字改进
- en: When it comes to literals, we can think about the declaration of various variables
    constant, which are sometimes the life of a method as these would be very important
    for a method or to take any decision. And it leads to wrong decisions with the
    misreading of a numeric constant. To overcome this confusion, C# 7.0 introduced
    two new features, binary literals and digit separators.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用文字时，我们可以考虑声明各种变量常量，有时这些变量对于方法的生命周期非常重要，因为这些变量对于方法或做出任何决定非常重要。并且会导致错误的决策，因为对数字常量的误读。为了克服这种混淆，C#
    7.0引入了两个新功能，二进制文字和数字分隔符。
- en: Binary literals
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制文字
- en: 'Binary digits are very important for performing complex operations. A constant
    of a binary digit can be declared as *0b<binaryvalue>*, where 0b tells us that
    this is a binary literal and binary values is the value of your decimal digit.
    Here are a few examples:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数字对于执行复杂操作非常重要。二进制数字的常量可以声明为*0b<binaryvalue>*，其中0b告诉我们这是一个二进制文字，而二进制值是您的十进制数字的值。以下是一些例子：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Digit separator
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字分隔符
- en: 'With the introduction of digit separators, we can easily read long numeric,
    binary digits. Digit separators can be used with both numeric and binary digits.
    For binary digits, the digit separator, that is, underscore (`_`), applies on
    bit pattern, and for numeric, it can appear anywhere but it is good to make 1,000
    the separator. Take a look at the following examples:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了数字分隔符后，我们可以轻松阅读长数字、二进制数字。数字分隔符可以用于数字和二进制数字。对于二进制数字，数字分隔符，即下划线(`_`)，适用于位模式，对于数字，它可以出现在任何地方，但最好将1,000作为分隔符。看一下以下例子：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The digit separator can be used with decimal, float, and double types as well.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 数字分隔符也可以用于十进制、浮点和双精度类型。
- en: '<p>Followings are the new features shipped with Visual Studio 2017 update 3
    as a language features of C# 7.1, we will discuss all the features as per: [https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <p>以下是作为C# 7.1语言特性随Visual Studio 2017更新3一起发布的新功能，我们将根据：[https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md)讨论所有功能
- en: 'For more information new release of Visual Stuio 2017 refer to: [https://www.visualstudio.com/en-us/news/releasenotes/vs2017-relnotes](https://www.visualstudio.com/en-us/news/releasenotes/vs2017-relnotes)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Visual Studio 2017新版本的更多信息，请参考：[https://www.visualstudio.com/en-us/news/releasenotes/vs2017-relnotes](https://www.visualstudio.com/en-us/news/releasenotes/vs2017-relnotes)
- en: 'If you are looking how to set up your existing project or new project that
    is using C# 7.0 – then you need not to worry, Visual Studio 2017 Update 3 is there
    to assist you. Whenever you start using new feature of C# 7.1 – you need to follow
    these steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解如何设置您现有的项目或使用C# 7.0的新项目 - 那么您不用担心，Visual Studio 2017更新3会帮助您。每当您开始使用C#
    7.1的新功能时，您需要遵循以下步骤：
- en: Visual Studio will warn about existing version support and suggest to upgrade
    your project if you want to use new feature of C# 7.1.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio将警告现有版本的支持，并建议升级您的项目，如果您想使用C# 7.1的新功能。
- en: Just click on yellow bulb and select best option fits for your requirement and
    you’re good to go with new C# 7.1.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需点击黄色灯泡，选择最适合您需求的选项，您就可以使用新的C# 7.1了。
- en: 'Following image tells you two-steps to get ready with C# 7.1:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片告诉您准备好C# 7.1的两个步骤：
- en: '![](img/00047.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00047.jpeg)'
- en: 'Let us start discussion on new features of Language C# 7.1:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始讨论C# 7.1语言的新功能：
- en: Async Main
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步主函数
- en: 'A new feature of language C# 7.1 that enables entry-point that is, `Main` of
    an application. Async main enables `main` method to be awaitable that mean `Main`
    method is now asynchronous to get `Task` or `Task<int>`. With this feature followings
    are valid entry-points:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.1的一项新功能，使应用程序的入口点即`Main`成为可能。异步主函数使`main`方法可以等待，这意味着`Main`方法现在是异步的，可以获得`Task`或`Task<int>`。有了这个功能，以下是有效的入口点：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Restrictions while using new signatures
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在使用新签名时有一些限制。
- en: You can use these new signature entry-points and these marked as valid if no
    overload of previous signature is present that means if you are using an existing
    entry-point.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用这些新签名的入口点，如果没有先前签名的重载存在，那么这些标记为有效，这意味着如果您使用现有的入口点。
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is not mandatory to mark your entry-point as async that means you can
    still use the existing async entry-point:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这并不是强制将入口点标记为异步的，这意味着您仍然可以使用现有的异步入口点：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There may be more usage of the entry-point that you can incorporate in the
    application – refer to official document of this feature: [https://github.com/dotnet/csharplang/blob/master/proposals/async-main.md](https://github.com/dotnet/csharplang/blob/master/proposals/async-main.md)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有更多的入口点用法可以整合到应用程序中 - 请参考此功能的官方文档：[https://github.com/dotnet/csharplang/blob/master/proposals/async-main.md](https://github.com/dotnet/csharplang/blob/master/proposals/async-main.md)
- en: Default expressions
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认表达式
- en: A new expression introduced in C# 7.1 that is default literal. With the introduction
    of this new literal, the expression can be implicitly converted to any type and
    produces result as default value of the type.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.1引入了一个新的表达式，即默认文字。引入这个新文字后，表达式可以隐式转换为任何类型，并产生类型的默认值。
- en: New default literal is different than old `default(T)`. Earlier `default` convert
    the target type of `T` but newer one can convert any type.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 新的默认文字与旧的`default(T)`不同。早期的`default`转换了`T`的目标类型，但新的可以转换任何类型。
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code when we are writing `int thisIsANewDefault = default;`
    an expression that is valid in C# 7.1 and it implicitly convert the expression
    to type int and assign a default value that is 0 (zero) to `thisIsANewDefault`.
    The notable point here is that default literal implicitly detect the type of `thisIsANewDefault`
    and set the value. On the other hand, we need to explicitly tell the target type
    to set the default value in expression `var thisIsAnOlderDefault = default(int);`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，当我们写`int thisIsANewDefault = default;`时，这是C# 7.1中有效的表达式，它隐式地将表达式转换为int类型，并将默认值0（零）赋给`thisIsANewDefault`。这里值得注意的是，默认文字隐式地检测`thisIsANewDefault`的类型并设置值。另一方面，我们需要明确告诉目标类型在表达式`var
    thisIsAnOlderDefault = default(int);`中设置默认值。
- en: 'The preceding code generates following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成以下输出：
- en: '![](img/00048.gif)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00048.gif)'
- en: 'There are multiple implementations of new default literal so, you can use the
    same with following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种实现新的默认文字，因此，您可以在以下情况下使用相同的：
- en: Member variables
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成员变量
- en: 'New `default` expression can be applied to assign default values to variables,
    followings are the various ways:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`default`表达式可以用于为变量分配默认值，以下是各种方式：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Constants
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: 'Similar to variables, with the use of default we can declare constants, followings
    are the various ways:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量类似，使用default我们可以声明常量，以下是各种方式：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There are more scenarios where you can use this new default literal viz. optional
    parameter in method that is, For more information, refer to: [https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-03-07.md](https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-03-07.md)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的情景可以使用这个新的默认文字，比如方法中的可选参数，更多信息请参考：[https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-03-07.md](https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-03-07.md)
- en: Infer tuple names
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推断元组名称
- en: With the introduction of this new feature we you do not require to explicitly
    declare the tuple candidate names. We discussed Tuples in previous section *Tuples
    and Deconstructions*. Infer tuple names feature is an extended to the tuple values
    introduced in C# 7.0.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这个新功能的引入，您不需要显式声明元组候选名称。我们在之前的*Tuples and Deconstructions*部分讨论了元组。推断元组名称功能是C#
    7.0引入的元组值的扩展。
- en: 'To work with this new feature, you require updated NuGet package of `ValueTuple`
    that you’ve installed in previous section *Tuple*. To update the NuGet package,
    go to *NuGet Package manager* and click on Update tab and then click update latest
    version. Following screenshot provides the complete information:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个新功能，您需要更新之前在*Tuple*部分安装的`ValueTuple`的NuGet包。要更新NuGet包，转到*NuGet包管理器*，点击更新选项卡，然后点击更新最新版本。以下截图提供了完整信息：
- en: '![](img/00049.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00049.jpeg)'
- en: 'Following code-snippet shows, various ways to declare the tuple:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了声明元组的各种方式：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code is self-explanatory, Tuple `noNamed` does not have any member
    name and can be accessed using `item1` and `item2`. Similarly, in Tuple `IgnoredName`
    all defined member names will be ignored as declaration is not defined with a
    member name. Following code-snippet tells the complete story of how we can access
    various tuples:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是不言自明的，元组`noNamed`没有任何成员名称，可以使用`item1`和`item2`进行访问。同样，在元组`IgnoredName`中，所有定义的成员名称将被忽略，因为声明中没有定义成员名称。以下代码片段讲述了如何访问各种元组的完整故事：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code produces the following output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下输出：
- en: '![](img/00050.gif)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00050.gif)'
- en: 'There is more variation where you can use this new feature for more info, refer:
    [https://github.com/dotnet/roslyn/blob/master/docs/features/tuples.md](https://github.com/dotnet/roslyn/blob/master/docs/features/tuples.md)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多变化可以使用这个新功能，更多信息，请参考：[https://github.com/dotnet/roslyn/blob/master/docs/features/tuples.md](https://github.com/dotnet/roslyn/blob/master/docs/features/tuples.md)
- en: Other features supposed to release
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他预计发布的功能
- en: There would be more features with the final release of programming language
    C# 7.1 in addition to previous, following are the features that encountered a
    bug or partially implemented as on date.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终发布的C# 7.1编程语言中将会有更多功能，除了之前的功能外，以下是遇到bug或部分实现的功能。
- en: Pattern-matching with generics
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型模式匹配
- en: 'The pattern-matching with generic is proposed here: [https://github.com/dotnet/csharplang/blob/master/proposals/generics-pattern-match.md](https://github.com/dotnet/csharplang/blob/master/proposals/generics-pattern-match.md)
    as new feature of C# 7.1 that encountered a bug and can be seen here: [https://github.com/dotnet/roslyn/issues/16195](https://github.com/dotnet/roslyn/issues/16195)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式匹配与泛型提议在这里：[https://github.com/dotnet/csharplang/blob/master/proposals/generics-pattern-match.md](https://github.com/dotnet/csharplang/blob/master/proposals/generics-pattern-match.md)
    作为C# 7.1的新功能，遇到了一个bug，可以在这里看到：[https://github.com/dotnet/roslyn/issues/16195](https://github.com/dotnet/roslyn/issues/16195)
- en: 'The implementation of this feature would be based on `as` operator as detailed
    here: [https://github.com/dotnet/csharplang/blob/master/spec/expressions.md#the-as-operator](https://github.com/dotnet/csharplang/blob/master/spec/expressions.md#the-as-operator)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能的实现将基于`as`运算符，详细信息请参见：[https://github.com/dotnet/csharplang/blob/master/spec/expressions.md#the-as-operator](https://github.com/dotnet/csharplang/blob/master/spec/expressions.md#the-as-operator)
- en: Reference assemblies
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用程序集
- en: 'Reference assemblies feature is yet to be incorporated within IDE, you can
    refer: [https://github.com/dotnet/roslyn/blob/master/docs/features/refout.md](https://github.com/dotnet/roslyn/blob/master/docs/features/refout.md)
    here for more details.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 引用程序集功能尚未纳入IDE中，您可以参考：[https://github.com/dotnet/roslyn/blob/master/docs/features/refout.md](https://github.com/dotnet/roslyn/blob/master/docs/features/refout.md)
    这里获取更多详细信息。
- en: Hands-on exercises
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手练习
- en: 'Answer the following questions, which cover the concepts of today''s learning:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题，涵盖了今天学习的概念：
- en: What are `ValueTuple` types?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`ValueTuple`类型？
- en: ValueTuples are mutable; prove with an example.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ValueTuples是可变的；通过示例证明。
- en: Create a `ValueTuple` of 10 elements.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含10个元素的`ValueTuple`。
- en: 'Create a user-defined class employee as follows and then write a program to
    deconstruct user-defined types:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个如下所示的用户定义类employee，然后编写一个程序来解构用户定义的类型：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Create a class of various constants using digit separators and implement these
    constants to a function `ToDecimal()` and `ToBinary()`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用数字分隔符的各种常量的类，并将这些常量实现到函数`ToDecimal()`和`ToBinary()`中。
- en: What are local functions? How are they different from private functions?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地函数是什么？它们与私有函数有什么不同？
- en: Rewrite the `OddEven` program using generic local functions.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用通用本地函数重写`OddEven`程序。
- en: Rewrite the `OddEven` program using the type pattern in `switch` case.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`switch`语句中的类型模式重写`OddEven`程序。
- en: Write a program to find out `OddEven` with the utilization of inferred Tuple
    names feature of language C# 7.1.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，利用C# 7.1语言的推断元组名称特性来找出`OddEven`。
- en: What is default expression (C# 7.1), elaborate with the help of program?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认表达式（C# 7.1）是什么，通过程序详细说明？
- en: Revisiting Day 03
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重温第03天
- en: Today, we have discussed all the new features introduced in C# 7.0 with code
    examples. We also understood the important points and usage of these features.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们讨论了C# 7.0中引入的所有新功能，并提供了代码示例。我们还了解了这些功能的重要点和用法。
- en: We discussed how ValueTuples help us gather the data information and the cases
    where we are expecting multiple outputs from a method. One of the good points
    of `ValueTuple` is that this is a mutable and `ValueType`. There are a few `public`
    and `static` methods provided by `System.ValueTuple` and we can achieve many complex
    scenarios with the use of these.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了ValueTuples如何帮助我们收集数据信息以及我们期望从方法中获得多个输出的情况。`ValueTuple`的一个优点是它是可变的和`ValueType`。`System.ValueTuple`提供了一些`public`和`static`方法，我们可以利用这些方法实现许多复杂的场景。
- en: Then we came to know the advantage and power of pattern matching; this helps
    the coder perform various complex conditional scenarios which were not possible
    in prior versions of the C# language. The type pattern and the `when` clause in
    `case` statements makes this feature superb.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们了解了模式匹配的优势和能力；这有助于编码人员执行各种复杂的条件场景，这在C#语言的先前版本中是不可能的。类型模式和`case`语句中的`when`子句使这个功能非常出色。
- en: Local functions are one of the most important features introduced in C# 7.0\.
    They help a lot in a scenario, where we need to make our code symmetric, so you
    can read code perfectly and when we do not require the method outside, or we do
    not need to reuse this operation which is required within a block scope.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本地函数是C# 7.0中引入的最重要的功能之一。它们在需要使我们的代码对称的场景中非常有帮助，这样你就可以完美地阅读代码，当我们不需要在方法外部使用方法，或者我们不需要重用在块范围内需要的操作时。
- en: With the literal improvements, now we can declare binary numbers as constants
    and use them as we use other variables. The capability of adding the digit separator
    underscore (`_`) made this feature more useful.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 随着字面改进，现在我们可以将二进制数字声明为常量，并像使用其他变量一样使用它们。添加数字分隔符下划线（`_`）的能力使这个功能更加有用。
- en: Finally, we have gone through the new features released for language C# 7.1
    as a part of Visual Studio update 3.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经了解了作为Visual Studio更新3的一部分发布的C# 7.1语言的新功能。
- en: 'Earlier, in plan there were more features which were planned to release but
    the final release came with preceding new features. Next release is in plan and
    there are more robust features which are yet to come. You can watch the plan and
    next release feature list here: [https://github.com/dotnet/csharplang/tree/master/proposals](https://github.com/dotnet/csharplang/tree/master/proposals).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，计划中有更多的功能计划发布，但最终发布的版本却包含了之前的新功能。下一个版本已经计划中，还有更强大的功能尚未推出。您可以在这里查看计划和下一个版本的功能列表：[https://github.com/dotnet/csharplang/tree/master/proposals](https://github.com/dotnet/csharplang/tree/master/proposals)。
