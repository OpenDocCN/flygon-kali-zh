- en: Chapter 10. Intensive Computing with RenderScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。使用RenderScript进行密集计算
- en: '*If the NDK is one of the best tools to get a high performance on Android.
    It gives low-level access to the machine, gives you control on memory allocation,
    provides access to advanced CPU instruction-sets, and even more.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果NDK是在Android上获得高性能的最佳工具之一。它提供对机器的低级访问，让您控制内存分配，提供对高级CPU指令集的访问，甚至更多。*'
- en: '>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*This power comes with a price: to get maximum performance on a key piece of
    code, ones need to optimize code for the many devices and platforms in the world.
    Sometimes, it is more appropriate to use CPU SIMD instructions, and other times,
    to perform computation on the GPU. You had better be experienced and have plenty
    of devices and time in front of you! This is the reason Google introduced RenderScript
    on Android.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*这种动力是有代价的：为了在关键代码上获得最大性能，需要为世界上的许多设备和平台优化代码。有时，更适合使用CPU SIMD指令，而其他时候，需要在GPU上执行计算。你最好有经验，并且有大量的设备和时间在你面前！这就是Google在Android上引入RenderScript的原因。*'
- en: '**RenderScript** is a programming language specific to Android written with
    one goal in mind: *performance*. Let''s be clear, applications cannot be entirely
    written in RenderScript. However, the critical parts, requiring intensive computations,
    should be! RenderScript can be executed from either Java or C/C++.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**RenderScript**是一种专门针对Android编写的编程语言，其目标是*性能*。让我们明确一点，应用程序不能完全用RenderScript编写。然而，需要进行密集计算的关键部分应该使用RenderScript！RenderScript可以从Java或C/C++中执行。'
- en: 'In this chapter, we will discuss these basics and concentrate our effort on
    its NDK binding. We will create a new project to demonstrate RenderScript capabilities
    by filtering images. More precisely, we will see how to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论这些基础知识，并集中精力讨论其NDK绑定。我们将创建一个新项目来演示RenderScript的功能，通过对图像进行滤镜处理。更确切地说，我们将看到如何：
- en: Execute the predefined **Intrinsics**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行预定义的**内在功能**
- en: Create your own custom **Kernels**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您自己的自定义**内核**
- en: Combine Intrinsics and Kernels together
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将内在功能和内核结合在一起
- en: By the end of this chapter, you should be able to create your own RenderScript
    programs and bind them into your native code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您应该能够创建自己的RenderScript程序，并将它们绑定到您的本地代码中。
- en: What is RenderScript ?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是RenderScript？
- en: RenderScript was introduced in Honeycomb in 2011 with a strong focus on graphics
    capabilities, hence the name. The graphics engine part of RenderScript has, however,
    been deprecated since Android 4.1 JellyBean. Although it has kept its name, RenderScript
    has deeply evolved to emphasize its "compute engine". It is similar to technologies
    such as OpenCL and CUDA, with an emphasis on portability and usability.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: RenderScript于2011年在Honeycomb中推出，重点放在图形能力上，因此得名。然而，RenderScript的图形引擎部分自Android
    4.1 JellyBean以来已经被弃用。尽管它保留了其名称，但RenderScript已经深刻发展，强调其“计算引擎”。它类似于OpenCL和CUDA等技术，强调可移植性和可用性。
- en: More specifically, RenderScript tries to abstract hardware specificities from
    the programmer and extract the maximum raw power from it. Instead of taking the
    least common denominator, it optimizes code according to the platform it executes
    on at runtime. The final code can run on either the CPU or GPU, with an advantage
    of automatic parallelization managed by RenderScript.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，RenderScript试图将程序员的硬件特性抽象出来，并从中提取最大的原始动力。它不是采用最低公共分母，而是根据运行时执行的平台优化代码。最终的代码可以在CPU或GPU上运行，并且由RenderScript管理的自动并行化具有优势。
- en: 'The RenderScript framework is composed of a few elements:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: RenderScript框架由几个元素组成：
- en: A C-like language based on C99, which provides variables, functions, structures,
    and so on
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种基于C99的类似C的语言，提供变量、函数、结构等
- en: A **low level virtual machine** (**LLVM**) based compiler on the developer machine
    that produces intermediate code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者机器上基于LLVM的编译器，生成中间代码
- en: A RenderScript library and runtime that translates intermediate code to machine
    code only when the final program runs on the device
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个RenderScript库和运行时，仅在最终程序在设备上运行时将中间代码转换为机器代码
- en: A Java and NDK binding API to execute and chain computation tasks
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Java和NDK绑定API，用于执行和链接计算任务
- en: 'Computation tasks are obviously the center of RenderScript. There are two kinds
    of tasks:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 计算任务显然是RenderScript的中心。有两种类型的任务：
- en: Kernels, which are user-created scripts that perform a computation task using
    the RenderScript language
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核是用户创建的脚本，使用RenderScript语言执行计算任务
- en: Intrinsics, which are built-in Kernels to perform some common tasks such as
    blurring pixels
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内在功能是执行一些常见任务的内置内核，例如模糊像素
- en: Kernels and Intrinsics can be combined together, the output of a program being
    linked to the input of another. From the complex graphs of computation tasks emerge
    fast and powerful programs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 内核和内在功能可以结合在一起，程序的输出链接到另一个程序的输入。从复杂的计算任务图中出现快速和强大的程序。
- en: However, for the moment, let's see what Intrinsics are and how they work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前让我们看看内在功能是什么，以及它们是如何工作的。
- en: Executing a predefined Intrinsic
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行预定义的内在功能
- en: RenderScript provides a few built-in functions, mainly dedicated to Image processing,
    called Intrinsics. With these, blending images, such as in Photoshop, blurring
    them, or even decoding raw YUV images from the camera, (see [Chapter 4](ch04.html
    "Chapter 4. Calling Java Back from Native Code"), *Calling Java Back from Native
    Code*, for a slower alternative) becomes simple and highly efficient. Indeed,
    Intrinsics are highly optimized and can be considered as one of the best implementations
    in their domain.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: RenderScript提供了一些内置函数，主要用于图像处理，称为内在功能。使用这些功能，像在Photoshop中混合图像、模糊图像，甚至从相机解码原始YUV图像（参见[第4章](ch04.html
    "第4章。从本地代码调用Java返回")，“从本地代码调用Java返回”，作为一个较慢的替代方案）变得简单且高效。事实上，内在功能经过高度优化，可以被认为是其领域中最好的实现之一。
- en: To see how Intrinsics work, let's create a new project that takes an input image
    and applies a blur effect to it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解内在功能的工作原理，让我们创建一个新项目，对输入图像应用模糊效果。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `RenderScript_Part1`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的结果项目名为`RenderScript_Part1`。
- en: Time for action – creating a Java UI
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建Java UI
- en: Let's create a new Java project with a JNI module.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个带有JNI模块的新的Java项目。
- en: 'Create a new hybrid Java/C++ project as shown in [Chapter 2](ch02.html "Chapter 2. Starting
    a Native Android Project"), *Starting a Native Android Project*:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的混合Java/C++项目，如[第2章](ch02.html "第2章。开始一个本地Android项目")所示，“开始一个本地Android项目”：
- en: Name it `RenderScript`.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其命名为`RenderScript`。
- en: The main package is `com.packtpub.renderscript`.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主包是`com.packtpub.renderscript`。
- en: '`minSdkVersion` is 9 and `targetSdkVersion` is 19.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minSdkVersion`为9，`targetSdkVersion`为19。'
- en: Define the `android.permission.WRITE_EXTERNAL_STORAGE` permission in the `AndroidManifest.xml`
    file.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中定义`android.permission.WRITE_EXTERNAL_STORAGE`权限。
- en: Turn the project into a native project as already seen.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目转换为本地项目，如已经看到的。
- en: Remove the native source and header files that have been created by ADT.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除ADT创建的本地源文件和头文件。
- en: Name the main Activity `RenderScriptActivity` and its layout `activity_renderscript.xml`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将主Activity命名为`RenderScriptActivity`，其布局为`activity_renderscript.xml`。
- en: 'Define the `project.properties` file as follows. These lines activate the `RenderScript`
    support library, which allows porting code to older devices until API 8:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`project.properties`文件定义如下。这些行激活了`RenderScript`支持库，允许将代码移植到API 8之前的旧设备：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Modify `res/activity_renderscript.xml` to make it look as follows. We will
    need:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`res/activity_renderscript.xml`，使其如下所示。我们需要：
- en: A `SeekBar` to define the blur radius
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`SeekBar`来定义模糊半径
- en: A `Button` to apply the blur effect
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个应用模糊效果的`Button`
- en: Two `ImageView` elements to display the image before and after the effect is
    applied.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个`ImageView`元素用于显示应用效果前后的图像。
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Implement `RenderScriptActivity` as shown below.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照下面的方式实现`RenderScriptActivity`。
- en: Load the `RSSupport` module, which is the `RenderScript` support library, and
    the `renderscript` module, which we are about to create in a static block.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 加载`RSSupport`模块，这是`RenderScript`支持库，以及我们即将创建的`renderscript`模块，在静态块中。
- en: 'Then, in `onCreate()`, load a 32-bit bitmap from an image placed in `drawable`
    resources (here, named `picture`) and create a second empty bitmap of the same
    size. Assign these bitmaps to their respective `ImageView` component. Also, define
    `OnClickListener` on the **Blur** button:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`onCreate()`中，从`drawable`资源中加载一个32位位图（这里命名为`picture`），并创建一个相同大小的空位图。将这些位图分配给它们各自的`ImageView`组件。还在**Blur**按钮上定义`OnClickListener`：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a native function, `blur`, which takes in the parameter:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个本地函数`blur`，它接受参数：
- en: The application cache directory for the `RenderScript` runtime
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RenderScript`运行时的应用程序缓存目录'
- en: The source and destination bitmaps
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源位图和目标位图
- en: The blur effect radius to determine the blur strength
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊效果半径以确定模糊强度
- en: Call this method from the `onClick()` handler using the seek bar value to determine
    the blur radius. The radius must be in the range [`0`, `25`].
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用seek bar的值从`onClick()`处理程序调用此方法来确定模糊半径。半径必须在[`0`,`25`]范围内。
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Time for action – running RenderScript Blur intrinsic
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-运行RenderScript模糊内在
- en: Let's create the native module that will generate our new effect.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个将生成新效果的本地模块。
- en: 'Create a new file `jni/ RenderScript.cpp`. We will need the following:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`jni/ RenderScript.cpp`。我们需要以下内容：
- en: '`android/bitmap.h` header to manipulate bitmaps.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android/bitmap.h`头文件来操作位图。'
- en: '`jni.h` for JNI strings.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jni.h`用于JNI字符串。'
- en: '`RenderScript.h`, which is the main `RenderScript` header file. This is the
    only one you should need. RenderScript is written in C++ and is defined in the
    `android::RSC` namespace.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RenderScript.h`，这是主要的`RenderScript`头文件。这是你唯一需要的。RenderScript是用C++编写的，并在`android::RSC`命名空间中定义。'
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Write two utility methods to lock and unlock Android bitmaps as seen in [Chapter
    4](ch04.html "Chapter 4. Calling Java Back from Native Code"), *Calling Java Back
    from Native Code*:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写两个实用方法来锁定和解锁Android位图，如[第4章](ch04.html "第4章。从本地代码调用Java")所示，“从本地代码调用Java”：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Implement the native method `blur()` using the JNI convention.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JNI约定实现本地方法`blur()`。
- en: Then, instantiate the RS class. This class is the main interface, which controls
    RenderScript initialization, resource management, and object creation. Wrap it
    with the `sp` helper class provided by RenderScript, which represents a smart
    pointer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，实例化RS类。这个类是主要的接口，用于控制RenderScript的初始化、资源管理和对象创建。用RenderScript提供的`sp`助手类包装它，表示智能指针。
- en: 'Initialize it with the cache directory given in parameter, converting the string
    appropriately with JNI:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 用JNI适当地转换参数中给定的缓存目录进行初始化：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lock the bitmaps we are working on using the utility methods we just wrote:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们刚刚编写的实用方法锁定我们正在处理的位图：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now comes the interesting part. Create a RenderScript **Allocation** from the
    source bitmap. This `ALLOCATION` represents the whole input memory area whose
    dimensions are defined by `Type`. The Allocation is composed of "individual" **Elements**;
    in our case, 32-bit RGBA pixels are defined as `Element::RGBA_8888`. Since the
    bitmap is not used as a texture, we have no need for **Mipmaps** (see [Chaper
    6](ch06.html "Chapter 6. Rendering Graphics with OpenGL ES"), *Rendering Graphics
    with OpenGL ES*, about OpenGL ES for more information).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是有趣的部分。从源位图创建一个RenderScript **Allocation**。这个`ALLOCATION`代表了由`Type`定义尺寸的整个输入内存区域。分配是由“单独的”**Elements**组成；在我们的例子中，32位RGBA像素被定义为`Element::RGBA_8888`。由于位图不用作纹理，我们不需要**Mipmaps**（有关更多信息，请参见[第6章](ch06.html
    "第6章。使用OpenGL ES渲染图形")，“使用OpenGL ES渲染图形”）。
- en: 'Repeat the same operation for the output `ALLOCATION` created from the output
    bitmap:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对从输出位图创建的输出`ALLOCATION`执行相同的操作：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create a `ScriptIntrinsicBlur` instance and the kind of elements it works on,
    which is again RGBA pixels. An Intrinsic is a predefined RenderScript function,
    which implements a common operation, such as a blur effect in our case. The **Blur
    Intrinsic** takes a radius as an input parameter. Set it with `setRadius()`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ScriptIntrinsicBlur`实例以及它所处理的元素类型，这里再次是RGBA像素。内在是预定义的RenderScript函数，它实现了常见的操作，比如在我们的例子中是模糊效果。**模糊内在**接受半径作为输入参数。使用`setRadius()`设置它。
- en: Then, specify the blur Intrinsic input, that is the source Allocation with `setInput()`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，指定模糊内在输入，即源分配与`setInput()`。
- en: Apply the Intrinsic on each of its elements with `forEach()` and save it to
    the output Allocation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个元素应用内在的`forEach()`并将其保存到输出分配中。
- en: Finally, copy the result to the destination bitmap with `copy2DRangeTo()`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`copy2DRangeTo()`将结果复制到目标位图。
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Don't forget to unlock the bitmap after the effect is applied!
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记在应用效果后解锁位图！
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create a `jni/Application.mk` file targeting the `ArmEABI V7` and `X86` platforms.
    Indeed, RenderScript currently does not support older `ArmEABI V5`. `STLPort`,
    and is also required by the RenderScript native library.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`jni/Application.mk`文件，针对`ArmEABI V7`和`X86`平台。实际上，RenderScript目前不支持较旧的`ArmEABI
    V5`。`STLPort`，并且RenderScript本地库也需要它。
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Create a `jni/Android.mk` file defining our `renderscript` module and listing
    `RenderScript.cpp` for compilation.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`jni/Android.mk`文件，定义我们的`renderscript`模块，并列出`RenderScript.cpp`进行编译。
- en: Make `LOCAL_C_INCLUDES` point to the appropriate RenderScript, including the
    file directory in the NDK platform directory. Also, append the RenderScript precompiled
    libraries directory to `LOCAL_LDFLAG`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使`LOCAL_C_INCLUDES`指向适当的RenderScript，包括NDK平台目录中的文件目录。还要将RenderScript预编译库目录附加到`LOCAL_LDFLAG`。
- en: 'Finally, link against `dl`, `log`, and `RScpp_static`, which are required for
    RenderScript:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，链接`dl`、`log`和`RScpp_static`，这些是RenderScript所需的：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*What just happened?*'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'Run the project, increase the `SeekBar` value, and click on the **Blur** button.
    The output `ImageView` should display the filtered picture as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目，增加`SeekBar`的值，并点击**模糊**按钮。输出的`ImageView`应该显示过滤后的图片如下：
- en: '![What just happened?](img/9645_10_01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/9645_10_01.jpg)'
- en: We embedded the RenderScript compatibility library in our project, giving us
    access to RenderScript down to the API 8 Froyo. On older devices, RenderScript
    is "emulated" on the CPU.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在项目中嵌入了RenderScript兼容库，使我们可以访问到API 8 Froyo的RenderScript。在较旧的设备上，RenderScript在CPU上是“模拟”的。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you decide to use RenderScript from the NDK but do not want to use the compatibility
    library, you will need to embed the RenderScript runtime manually. To do so, remove
    all the stuff we added in the `project.properties` file in step 2 and include
    the following piece of code at the end of your `Android.mk` files:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定从NDK使用RenderScript，但不想使用兼容库，你需要手动嵌入RenderScript运行时。为此，删除我们在步骤2中添加的`project.properties`文件中的所有内容，并在你的`Android.mk`文件的末尾包含以下代码片段：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we executed our first RenderScript Intrinsic that applies a blur effect
    as efficiently as possible. Intrinsic execution follows a simple and repetitive
    pattern that you will see repeatedly:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们执行了我们的第一个RenderScript内在，尽可能高效地应用模糊效果。内在执行遵循一个简单而重复的模式，你会反复看到：
- en: Ensure that the input and output memory areas are exclusively available, for
    example, by locking bitmaps.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保输入和输出内存区域是独占的，例如通过锁定位图。
- en: Create or reuse the appropriate input and output Allocation.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或重用适当的输入和输出分配。
- en: Create and set up the Intrinsic parameters.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并设置内在参数。
- en: Set the input Allocation and apply the Intrinsic to an output Allocation.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置输入分配并将内在应用到输出分配。
- en: Copy the result from the output Allocation to the target memory area.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果从输出分配复制到目标内存区域。
- en: 'To understand this process better, let''s dive a bit more into the way RenderScript
    works. RenderScript follows a simple model. It takes some data as the input and
    processes it to an output memory area:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个过程，让我们更深入地了解RenderScript的工作方式。RenderScript遵循一个简单的模型。它将一些数据作为输入，并处理到一个输出内存区域：
- en: '![What just happened?](img/9645_10_04.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/9645_10_04.jpg)'
- en: 'As a computing solution, RenderScript works with any type of data stored in-memory.
    This is an Allocation. An Allocation is composed of individual Elements. For an
    Allocation pointing to a bitmap, an element would typically be a pixel (which
    is itself a set of 4 `uchar` values). Among the large list of Elements available,
    we can cite:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为计算解决方案，RenderScript可以处理内存中存储的任何类型的数据。这是一个分配。分配由单独的元素组成。对于指向位图的分配，一个元素通常是一个像素（它本身是一组4个`uchar`值）。在可用的大量元素列表中，我们可以列举：
- en: '| Possible Allocation Elements |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 可能的分配元素 |'
- en: '| --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `U8`, `U8_2`, `U8_3`, `U8_4` | `I8`, `I8_2`, `I8_3`, `I8_4` | `RGBA_8888`
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `U8`, `U8_2`, `U8_3`, `U8_4` | `I8`, `I8_2`, `I8_3`, `I8_4` | `RGBA_8888`
    |'
- en: '| `U16`, `U16_2`, `U16_3`, `U16_4` | `I16`, `I16_2`¸ `I16_3`, `I16_4` | `RGB_565`
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `U16`, `U16_2`, `U16_3`, `U16_4` | `I16`, `I16_2`¸ `I16_3`, `I16_4` | `RGB_565`
    |'
- en: '| `U32`, `U32_2`, `U32_3`, `U32_4` | `I32`, `I32_2`¸ `I32_3`¸ `I32_4` | `RGB_888`
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `U32`, `U32_2`, `U32_3`, `U32_4` | `I32`, `I32_2`¸ `I32_3`¸ `I32_4` | `RGB_888`
    |'
- en: '| `U64`, `U64_2`, `U64_3`, `U64_4` | `I64`, `I64_2`, `I64_3`, `I64_4` | `A_8`
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `U64`, `U64_2`, `U64_3`, `U64_4` | `I64`, `I64_2`, `I64_3`, `I64_4` | `A_8`
    |'
- en: '| `F32`, `F32_2`, `F32_3`, `F32_4` | `F64`, `F64_2`, `F64_3`¸ `F64_4` | `YUV`
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `F32`, `F32_2`, `F32_3`, `F32_4` | `F64`, `F64_2`, `F64_3`¸ `F64_4` | `YUV`
    |'
- en: '| `MATRIX_2X2` | `MATRIX_3X3` | `MATRIX_4X4` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `MATRIX_2X2` | `MATRIX_3X3` | `MATRIX_4X4` |'
- en: '`U` = unsigned integer, `I` = signed integer, `F` = float'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`U` = 无符号整数，`I` = 有符号整数，`F` = 浮点数'
- en: '`8`, `16`, `32`, `64` = byte count. For example `I8` = 8-bits signed `int`
    (that is, a signed char)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`8`、`16`、`32`、`64` = 字节计数。例如`I8` = 8位有符号`int`（即，有符号字符）'
- en: '`_2`, `_3`, `_4` = Number of elements for vectors (`I8_3` means vector of 3
    signed int)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`_2`、`_3`、`_4` = 向量的元素数（`I8_3`表示3个有符号整数的向量）'
- en: '`A_8` represents an Alpha channel (with each pixel represented as an unsigned
    char).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`A_8`代表Alpha通道（每个像素表示为无符号字符）。'
- en: Internally, Elements are described with a **DataType** (such as `UNSIGNED_8`
    for an unsigned char) and a **DataKind** (such as `PIXEL_RGBA` for a pixel). The
    DataKind is used with something called **Samplers** for graphics data that is
    interpreted on the GPU (see [Chapter 6](ch06.html "Chapter 6. Rendering Graphics
    with OpenGL ES"), *Rendering Graphics with OpenGL ES*, about OpenGL ES to better
    understand what is a Sampler). DataType and DataKind are for more advanced usage
    and should be transparent to you most of the time. You can have a look at the
    full list of elements at [http://developer.android.com/reference/android/renderscript/Element.html](http://developer.android.com/reference/android/renderscript/Element.html).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，元素用**DataType**（例如`UNSIGNED_8`表示无符号字符）和**DataKind**（例如`PIXEL_RGBA`表示像素）来描述。DataKind与GPU上解释的图形数据一起使用，用于更高级的用途，大部分时间应该对你透明。你可以在[http://developer.android.com/reference/android/renderscript/Element.html](http://developer.android.com/reference/android/renderscript/Element.html)上查看完整的元素列表。
- en: Knowing the type of input/output Element is not enough. Their number is also
    essential, as this determines the whole Allocation size. This is the role of `Type`,
    which can be set up with 1 dimension, 2 dimensions (typically for bitmaps), or
    3 dimensions. Some other information is also supported, such as the YUV format
    (NV21 being the default in Android as seen in [Chapter 4](ch04.html "Chapter 4. Calling
    Java Back from Native Code"), *Calling Java Back from Native Code*). So, in other
    words, `Type` describes a multi-dimensional array.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 了解输入/输出元素的类型是不够的。它们的数量也很重要，因为这决定了整个分配的大小。这是`Type`的作用，可以设置为1维、2维（通常用于位图）或3维。还支持一些其他信息，例如YUV格式（在Android中默认为NV21，如[第4章](ch04.html
    "第4章。从本机代码调用Java")中所示，*从本机代码调用Java*）。换句话说，`Type`描述了一个多维数组。
- en: Allocations have a specific flag to control how Mipmaps are generated. By default,
    most Allocations will not need one (`RS_ALLOCATION_MIPMAP_NONE`). However, when
    used as the input of a graphics texture, Mipmaps are either created in script
    memory (`RS_ALLOCATION_MIPMAP_FULL`) or when uploaded to the GPU (`RS_ALLOCATION_MIPMAP_ON_SYNC_TO_TEXTURE`).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 分配具有特定的标志来控制Mipmaps的生成方式。默认情况下，大多数分配都不需要（`RS_ALLOCATION_MIPMAP_NONE`）。但是，当用作图形纹理的输入时，Mipmaps要么在脚本内存中创建（`RS_ALLOCATION_MIPMAP_FULL`），要么在上传到GPU时创建（`RS_ALLOCATION_MIPMAP_ON_SYNC_TO_TEXTURE`）。
- en: 'Once we create the Allocation from a Type and an Element, we can take care
    of creating and setting up Intrinsics. RenderScript provides a few of them, which
    are not many, but mainly focused on image processing:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从类型和元素创建了分配，我们就可以开始创建和设置内在函数。RenderScript提供了一些内在函数，虽然不多，但主要集中在图像处理上：
- en: '| Intrinsic | Description |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 内在函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| To blend two Allocations together, for example, two images (we will see additive
    blending in the last part of this chapter). |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 将两个分配混合在一起，例如，两个图像（我们将在本章的最后部分看到加法混合）。|'
- en: '|'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| To apply a blur effect on a Bitmap. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 用于在位图上应用模糊效果。|'
- en: '|'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| To apply a color matrix to an Allocation (for example, to adjust image hue,
    change colors, and so on). |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 例如，将颜色矩阵应用于分配（例如，调整图像色调，更改颜色等）。|'
- en: '|'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| To apply a convolve matrix of size 3 to an Allocation (many image filters
    can be implemented with a convolve matrix, including blurring). |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 将大小为3的卷积矩阵应用于分配（许多图像滤镜可以使用卷积矩阵实现，包括模糊）。|'
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| This is the same as `ScriptIntrinsicConvolve3x3` but with a matrix of size
    5. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 这与`ScriptIntrinsicConvolve3x3`相同，但矩阵大小为5。|'
- en: '|'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| This is used to apply a histogram filter (for example, to improve the image
    contrast). |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 用于应用直方图滤镜（例如，改善图像对比度）。|'
- en: '|'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| This is used to apply a "Lookup Table" per channel (for example, to translate
    a given red value in a pixel to another predefined value in the table). |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 用于按通道应用“查找表”（例如，将像素中给定的红色值转换为表中另一个预定义值）。|'
- en: '|'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| This is used to resize a 2D Allocation (for example, to scale an image).
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 用于调整2D分配的大小（例如，缩放图像）。|'
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| To translate YUV images coming, for example, from a camera to an RGB image
    (like we did in [Chapter 4](ch04.html "Chapter 4. Calling Java Back from Native
    Code"), *Calling Java Back from Native Code*). The binding of this Intrinsic in
    the NDK is bugged and, thus, unusable at the time this book was written. If you
    really need it, apply it from Java. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 例如，将来自摄像头的YUV图像转换为RGB图像（就像我们在[第4章](ch04.html "第4章。从本机代码调用Java")中所做的那样，*从本机代码调用Java*）。NDK中的这个内在函数存在错误，因此在撰写本书时无法使用。如果你真的需要它，可以从Java中应用它。|'
- en: Each of these Intrinsics requires its own specific parameters (for example,
    the radius for a blur effect). Full Intrinsics documentation can be found at [http://developer.android.com/reference/android/renderscript/package-summary.html](http://developer.android.com/reference/android/renderscript/package-summary.html).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每个内在函数都需要自己特定的参数（例如，模糊效果的半径）。完整的内在函数文档可以在[http://developer.android.com/reference/android/renderscript/package-summary.html](http://developer.android.com/reference/android/renderscript/package-summary.html)找到。
- en: Intrinsics require an input and output Allocation. It is technically possible
    to use an input as an output if the kind of function applied is appropriate. This
    is not the case, for example, `ScriptIntrinsicBlur` as a blurred pixel could be
    written at the same time it is read to blur other pixels.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 内在函数需要输入和输出分配。在技术上，如果应用的函数类型合适，可以将输入用作输出。例如，`ScriptIntrinsicBlur`就不是这种情况，因为模糊像素可能会在读取时同时被写入以模糊其他像素。
- en: Once Allocations are set, an Intrinsic is applied and performs its work. After
    that, the result must be copied to the output memory area with one of the `copy***To()`
    methods (`copy2DRangeTo()` for a bitmap, which has two dimensions or `copy2DStridedTo()`
    if there are gaps in the target area). Data copying is a prerequisite step before
    making use of the computation result.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分配设置好，就会应用内在功能并执行其工作。之后，结果必须使用`copy***To()`方法之一（对于具有两个维度的位图，使用`copy2DRangeTo()`，如果目标区域中有间隙，则使用`copy2DStridedTo()`）将其复制到输出内存区域。在使用计算结果之前，数据复制是一个先决条件。
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Some problems have been reported on some devices when the size of an image Allocation
    was not a multiple of 4\. This will probably remind you of OpenGL textures, which
    have the same requirements. So, try to stick with dimensions that are multiples
    of 4.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设备报告了一些问题，当图像分配的大小不是4的倍数时。这可能会让你想起OpenGL纹理，它们有相同的要求。因此，尽量使用4的倍数维度。
- en: Although the Intrinsics provided by RenderScript are really useful, you may
    want more flexibility. Maybe you need your own custom image filter, or a blur
    effect of more than 25 pixels, or maybe you do not want to process images at all.
    Then, RenderScript Kernels might be the right answer for you.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管RenderScript提供的内在功能非常有用，但你可能需要更灵活性。也许你需要自己定制的图像滤镜，或者一个超过25像素的模糊效果，或者你根本不想处理图像。那么，RenderScript内核可能是你的答案。
- en: Writing a custom Kernel
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义内核
- en: RenderScript gives you the ability to develop small custom "scripts" instead
    of the built-in Intrinsics. These programs are called Kernels and are written
    in a C-like language. They are compiled to an intermediate language by the RenderScript
    LLVM-based compiler at build time. Finally, they are translated to machine code
    at runtime. RenderScript takes care of platform-dependent optimizations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: RenderScript使您能够开发小型自定义“脚本”，而不是内置的内在功能。这些程序称为内核，使用类似C的语言编写。它们在构建时由RenderScript基于LLVM的编译器编译为中间语言。最后，它们在运行时被翻译为机器代码。RenderScript负责平台相关的优化。
- en: Let's now see how to create such a Kernel by implementing a custom image effect
    that filters pixels according to their luminosity.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何通过实现自定义图像效果来创建这样一个内核，该效果根据其亮度过滤像素。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `RenderScript_Part2`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的项目名称为`RenderScript_Part2`。
- en: Time for action – writing a luminance threshold filter
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-编写亮度阈值滤镜
- en: Let's append a new component to our UI and implement the new image filter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在UI中添加一个新组件并实现新的图像滤镜。
- en: 'Add a new **Threshold** `SeekBar` and `Button` in `res/activity_renderscript.xml`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/activity_renderscript.xml`中添加一个新的**Threshold** `SeekBar`和`Button`：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Edit `RenderScriptActivity` and bind the **Threshold** `SeekBar` and `Button`
    to a new native method `threshold()`. This method is similar to `blur()`, except
    that it takes a threshold float parameter in the range [`0`, `100`].
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`RenderScriptActivity`并将**Threshold** `SeekBar`和`Button`绑定到一个新的本地方法`threshold()`。这个方法类似于`blur()`，只是它接受一个范围在[`0`,`100`]的阈值浮点参数。
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s write our own `jni/threshold.rs` filter using the RenderScript
    language. First, use pragma directives to declare:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用RenderScript语言编写自己的`jni/threshold.rs`滤镜。首先，使用#pragma指令声明：
- en: The script language version (currently, only `1` is possible)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本语言版本（目前，只有`1`是可能的）
- en: The Java package name the script is associated with
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与脚本相关联的Java包名称
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Then, declare an input parameter `thresholdValue` of type `float`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，声明一个类型为`float`的输入参数`thresholdValue`。
- en: 'We also to need two constant vectors of 3 floats (`float3`):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要两个常量向量，每个向量包含3个浮点数（`float3`）：
- en: The first value represents a `BLACK` color
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个值代表`BLACK`颜色
- en: The second value a predefined `LUMINANCE_VECTOR`
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个值是预定义的`LUMINANCE_VECTOR`
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the root function of the script named `threshold()`. It takes a vector
    of 4 unsigned char, that is, an RGBA pixel in input, and returns a new one in
    output. Prepend `__attribute__((kernel))` to indicate that this function is the
    main script function, that is, the "Kernel''s Root". The function works as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`threshold()`的脚本的根函数。它接受一个4个无符号字符的向量，即输入中的RGBA像素，并返回一个新的输出。在函数前面加上`__attribute__((kernel))`以指示这个函数是主要的脚本函数，即“内核的根”。该函数的工作方式如下：
- en: It converts the input pixel from a vector of char, with each color component
    in the range [`0`, `255`], to a vector of float value with each component in the
    range [`0.0`, `1.0`]. This is the role of the function `rsUnpackColor8888()`.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将输入像素从一个字符向量转换为一个浮点值向量，每个分量的范围为[`0.0`,`1.0`]。这是函数`rsUnpackColor8888()`的作用。
- en: Now that we have a float vector, some of the many mathematical functions provided
    by RenderScript can be applied. Here, a dot product with a predefined luminosity
    vector for the RGBA color space returns the relative luminosity of a pixel.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们有了一个浮点向量，RenderScript提供的许多数学函数可以应用。在这里，使用预定义的RGBA颜色空间的亮度向量进行点积运算，返回像素的相对亮度。
- en: With this information, the function checks whether a pixel's luminosity is sufficient
    according to the given threshold. If not, the pixel is set to black.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有了这些信息，函数会检查像素的亮度是否符合给定的阈值。如果不符合，像素将被设置为黑色。
- en: Finally, it converts a pixel's color from a float vector to an unsigned char
    vector with `rsPackColor8888()`. This value will then be copied by RenderScript
    into the final Bitmap as we will see.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它将像素的颜色从浮点向量转换为无符号字符向量，使用`rsPackColor8888()`。然后，RenderScript将这个值复制到最终的位图中，我们将看到。
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To compile our new `threshold.rs` script, list it in the `Android.mk` file.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译我们的新的`threshold.rs`脚本，将其列在`Android.mk`文件中。
- en: 'During the compilation process, `ScriptC_threshold.h` and `ScriptC_threshold.cpp`
    is generated in `obj/local/armeabi-v7a/objs-debug/renderscript`. These files contain
    the code to bind our code with the **Threshold Kernel** executed by RenderScript.
    So, we also need to append the directory to the `LOCAL_C_INCLUDES` directory:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中，`ScriptC_threshold.h`和`ScriptC_threshold.cpp`在`obj/local/armeabi-v7a/objs-debug/renderscript`中生成。这些文件包含了将我们的代码与由RenderScript执行的**Threshold
    Kernel**绑定的代码。因此，我们还需要将目录附加到`LOCAL_C_INCLUDES`目录中：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Include the generated header in `jni/RenderScript.cpp`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/RenderScript.cpp`中包含生成的头文件。
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Then, implement the new method `threshold()`, respecting the JNI naming convention.
    This method is similar to `blur()`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现新的方法`threshold()`，遵循JNI命名约定。这个方法类似于`blur()`。
- en: However, instead of instantiating a predefined Intrinsic, we instantiate a Kernel
    generated by RenderScript. This Kernel is named `ScriptC_threshold` according
    to our RenderScript filename.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不是实例化预定义的内在功能，而是实例化由RenderScript生成的内核。这个内核根据我们的RenderScript文件命名为`ScriptC_threshold`。
- en: The input parameter `thresholdValue` defined in our script can be initialized
    with `set_thresholdValue()` generated by RenderScript. Then, the main method `threshold()`
    can be applied using the generated method `forEach_threshold()`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本中定义的输入参数`thresholdValue`可以使用RenderScript生成的`set_thresholdValue()`进行初始化。然后，可以使用生成的方法`forEach_threshold()`应用主方法`threshold()`。
- en: 'Once the Kernel has been applied, the result can be copied on the target bitmap,
    such as with Intrinsics, using `copy2DRangeTo()`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用了内核，结果就可以被复制到目标位图上，就像内在功能一样，使用`copy2DRangeTo()`：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*What just happened?*'
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'Run the project, increase the new `SeekBar`, and click on the **Threshold**
    button. The output `ImageView` should display the filtered picture with only luminous
    pixels as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目，增加新的`SeekBar`，然后点击**Threshold**按钮。输出的`ImageView`应该显示只有亮像素的滤镜图片，如下所示：
- en: '![What just happened?](img/9645_10_02.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: 发生了什么？
- en: 'We have written and compiled our first RenderScript Kernel. Kernel scripts
    have a `.rs` extension and are written in a language inspired by C99\. Their content
    starts with pragma definitions that bring additional "meta" information about
    them: the language version (which can be only 1) and the Java package. We can
    also use them to tweak the floating point precision for calculations with pragma
    directives `(#pragma rs_fp_full, #pragma rs_fp_relaxed`, or `#pragma rs_fp_imprecise`).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经编写并编译了我们的第一个RenderScript内核。内核脚本具有`.rs`扩展名，并且是用受C99启发的语言编写的。它们的内容以pragma定义开始，这些定义提供了有关它们的附加“元”信息：语言版本（只能是1）和Java包。我们还可以使用它们来使用pragma指令调整浮点精度进行计算（`#pragma
    rs_fp_full, #pragma rs_fp_relaxed`或`#pragma rs_fp_imprecise`）。'
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The Java package is important for the RenderScript runtime, which needs to resolve
    compiled Kernels during execution. When using the RenderScript Compatibility library,
    scripts compiled with the NDK (that is stored in the `jni` folder) might not get
    resolved. In that case, a possible solution is to make a copy of the `.rs` files
    in the Java `src` folder in the appropriate package.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Java包对RenderScript运行时很重要，需要在执行期间解析编译的内核。使用RenderScript兼容库时，使用NDK编译的脚本（存储在`jni`文件夹中）可能无法解析。在这种情况下，一个可能的解决方案是将`.rs`文件的副本复制到Java
    `src`文件夹中的适当包中。
- en: 'Kernels are, in a way similar, to Intrinsics. Indeed, once compiled, the same
    process applies to them: creating the allocations, the Kernel, setting everything
    up, applying, and finally, copying the result. When executed, a Kernel function
    is applied on each Element of the input and returned in the corresponding output
    allocation Element, in parallel.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 内核在某种程度上类似于内在功能。事实上，一旦编译，它们也适用于相同的过程：创建分配、内核、设置所有内容、应用，最后，复制结果。执行时，内核函数在输入的每个元素上并行应用，并在相应的输出分配元素中返回。
- en: You can set up a Kernel through the NDK binding API and an additional binding
    layer (more commonly called the **reflected** layer), which is generated at compile
    time. Each compiled script is "reflected" by a C++ class, whose name is defined
    according to the script filename prefixed with `ScriptC_`. The final code is generated
    in the **eponym** header and the source files in the `obj` directory, one for
    each per ABI. The reflected classes are your only interface with the script file,
    as a kind of wrapper. They perform some runtime checks on the kind of Allocation
    passed in the input or output of the Kernel to ensure their Element type matches
    what is declared in the script file. Have a look at the generated `ScriptC_threshold.cpp`
    in the project `obj` directory for a concrete example.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过NDK绑定API和附加绑定层（更常被称为**反射**层）来设置内核，这在编译时生成。每个编译的脚本都由一个C++类“反射”，其名称根据脚本文件名前缀为`ScriptC_`来定义。最终的代码生成在**同名**头文件中，源文件在`obj`目录中，每个ABI一个。反射类是您与脚本文件的唯一接口，一种包装器。它们对传入内核的分配的类型进行一些运行时检查，以确保其元素类型与脚本文件中声明的匹配。具体示例，请查看项目`obj`目录中生成的`ScriptC_threshold.cpp`。
- en: 'Kernel input parameters are passed from the reflected layer to the script file
    through global variables. Global variables correspond to all the non-`static`
    and non-`const` variables, for example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 内核输入参数通过全局变量从反射层传递到脚本文件。全局变量对应于所有非`static`和非`const`变量，例如：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: They are declared outside functions such as a C variable. Global variables are
    made available in the reflected layer through setters. In our project, the `thresholdValue`
    global variable is passed through the generated method `set_thresholdValue()`.
    Variables do not have to be primitive types. They can also be pointers, in which
    case the reflected method name is prefixed with `bind_`. and expects an Allocation.
    Getters are also provided in the generated classes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 它们声明在函数之外，如C变量。全局变量通过setter在反射层中提供。在我们的项目中，`thresholdValue`全局变量通过生成的方法`set_thresholdValue()`传递。变量不必是原始类型。它们也可以是指针，此时反射方法名称前缀为`bind_`，并且期望一个分配。生成的类还提供了getter。
- en: 'On the other hand, static variables, declared in the same scope as global variables,
    are not accessible in the NDK reflected layer and cannot be modified outside of
    the script. When marked `const`, they are obviously treated as constants, like
    the luminance vector in our project:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在与全局变量相同作用域中声明的静态变量在NDK反射层中是不可访问的，并且不能在脚本外部修改。当标记为`const`时，它们显然被视为常量，就像我们项目中的亮度向量一样：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The main Kernel functions, more commonly called **root functions**, are declared
    like a C function except that they are marked with `__attribute__((kernel))`.
    They take as parameter the Element type of the input Allocation and return the
    type of Element of the output Allocation. Both the input parameter and return
    value are optional but at least one of them must be present. In our example, the
    input parameter and the output return value is a pixel Element (that is, a vector
    of 4 unsigned char; 1 byte for each color channel):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的Kernel函数，通常被称为**root函数**，声明方式类似于C函数，只是它们被标记为`__attribute__((kernel))`。它们以输入Allocation的Element类型作为参数，并返回输出Allocation的Element类型。输入参数和返回值都是可选的，但至少其中一个必须存在。在我们的例子中，输入参数和输出返回值都是像素Element（即4个无符号字符的向量；每个颜色通道1字节）。
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'RenderScript root functions can be also given additional index parameters that
    represent Element position (or "coordinates") within its Allocation. For example,
    we can declare two additional `uint32_t` parameters to get pixel Element coordinates
    in `threshold()`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: RenderScript root函数也可以添加额外的索引参数，表示其Allocation中的Element位置（或“坐标”）。例如，我们可以声明两个额外的`uint32_t`参数来获取`threshold()`中的像素Element坐标：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Multiple root functions with different names can be declared in one script.
    After compilation, they are reflected in the generated class as functions prefixed
    with `forEach_`, for example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个脚本中可以声明多个不同名称的root函数。编译后，它们会以`forEach_`为前缀的函数的形式反映在生成的类中，例如：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Before `__attribute__((kernel))` was introduced, RenderScript files could only
    contain one main function named root. This form is still allowed nowadays. Such
    functions take a pointer to the input, output Allocation in parameters, and do
    not allow return values. So the `threshold()` function rewritten as a traditional
    root method would look like the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入`__attribute__((kernel))`之前，RenderScript文件只能包含一个名为root的主函数。这种形式现在仍然被允许。这样的函数在参数中接受输入、输出Allocation的指针，并且不允许返回值。因此，`threshold()`函数重写为传统的root方法将如下所示：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In addition to the `root()` function, a script can also contain an `init()`
    function with no parameter and return value. This function is called only once
    when the script is instantiated.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`root()`函数之外，脚本还可以包含一个没有参数和返回值的`init()`函数。这个函数只在脚本实例化时调用一次。
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Obviously, the possibilities of the RenderScript language are more limited
    and constrained than traditional C. We cannot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，RenderScript语言的可能性比传统的C语言更有限和受限。我们不能：
- en: Allocate resources directly. The memory must be allocated by the client application
    before running the Kernel.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接分配资源。内存必须在运行Kernel之前由客户端应用程序分配。
- en: Write low-level assembly code or do fancy C stuff. However, hopefully, plenty
    of familiar elements of the C language are available, such as `struct`, `typedef`,
    `enum` and so on; even pointers!
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写低级汇编代码或者进行花哨的C语言操作。然而，希望C语言的许多熟悉元素都是可用的，比如`struct`、`typedef`、`enum`等，甚至包括指针！
- en: Use C libraries or runtime. However, RenderScript provides a full "runtime"
    library with plenty of math, conversion, atomic functions, and so on. Have a look
    at [http://developer.android.com/guide/topics/renderscript/reference.html](http://developer.android.com/guide/topics/renderscript/reference.html)
    for more details about them.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C库或运行时。然而，RenderScript提供了一个完整的“运行时”库，其中包含大量的数学、转换、原子函数等。有关更多详细信息，请参阅[http://developer.android.com/guide/topics/renderscript/reference.html](http://developer.android.com/guide/topics/renderscript/reference.html)。
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A method provided by RenderScript that you may find particularly useful is `rsDebug()`,
    which prints debug log to ADB.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: RenderScript提供的一个特别有用的方法是`rsDebug()`，它可以将调试日志打印到ADB。
- en: Even with those limitations, RenderScript constraints are still quite relaxed.
    A consequence is that some scripts might not benefit from maximum acceleration,
    for example, on the GPU, which is quite restricting. To overcome this issue, a
    limited subset of RenderScript called **FilterScript** was designed to favor optimization
    and compatibility. Consider it if you need maximum performance.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有这些限制，RenderScript的约束仍然相当宽松。一个结果是，一些脚本可能无法充分利用最大的加速，例如在GPU上，这是相当限制的。为了解决这个问题，设计了一个名为**FilterScript**的RenderScript的有限子集，以支持优化和兼容性。如果需要最大的性能，请考虑使用它。
- en: For more information about the RenderScript language capabilities, have a look
    at [http://developer.android.com/guide/topics/renderscript/advanced.html](http://developer.android.com/guide/topics/renderscript/advanced.html).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有关RenderScript语言功能的更多信息，请参阅[http://developer.android.com/guide/topics/renderscript/advanced.html](http://developer.android.com/guide/topics/renderscript/advanced.html)。
- en: Combining scripts together
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合脚本
- en: '*Unity is strength* could not be truer than with RenderScript. Intrinsics and
    Kernels alone are powerful features. However, combined together, they give its
    full strength to the RenderScript framework.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 团结就是力量，在RenderScript中这句话再合适不过了。Intrinsics和Kernels本身就是强大的功能。然而，当它们结合在一起时，它们为RenderScript框架提供了全部的力量。
- en: Let's now see how to combine the **Blur** and **Luminosity** threshold filters
    together with a blending Intrinsic to create a great-looking image effect.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何将**Blur**和**Luminosity**阈值滤镜与混合Intrinsic结合在一起，创建一个看起来很棒的图像效果。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `RenderScript_Part3`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`RenderScript_Part3`的名称提供。
- en: Time for action – combining Intrinsics and scripts together
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-将Intrinsics和脚本结合在一起
- en: Let's improve our project to apply a new combined filter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进我们的项目，应用一个新的组合滤镜。
- en: 'Add a new **Combine** `Button` in `res/activity_renderscript.xml`, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/activity_renderscript.xml`中添加一个新的**Combine** `Button`，如下所示：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Bind the **Combine** button to a new native method `combine()`, which has the
    parameters of both `blur()` and `threshold()`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Combine**按钮绑定到一个新的本地方法`combine()`，该方法具有`blur()`和`threshold()`的参数：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Edit `jni/RenderScript.cpp` and add the new `combine()` method, following the
    JNI convention again. The method performs similarly to what we saw previously:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/RenderScript.cpp`并添加新的`combine()`方法，遵循JNI约定。该方法的执行方式与我们之前看到的类似。
- en: The RenderScript engine is initialized
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RenderScript引擎已初始化
- en: Bitmaps are locked
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位图已锁定
- en: The appropriate Allocation is created for the input and output bitmaps
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为输入和输出位图创建适当的分配
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will also need a temporary memory area to store the result of computations.
    Let''s create a temporary allocation backed by a memory buffer `tmpBuffer`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个临时内存区域来存储计算结果。让我们创建一个由内存缓冲区`tmpBuffer`支持的临时分配：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Initialize the Kernels and Intrinsics we need for the combined filter:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化我们需要的组合滤镜的内核和内在函数：
- en: The `Threshold` Kernel
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Threshold`内核'
- en: The `Blur` Intrinsic
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Blur`内在函数'
- en: An additional `Blend` Intrinsic that does not require parameters
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个不需要参数的额外`Blend`内在函数
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, combine the multiple filters together:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将多个滤镜组合在一起：
- en: First, apply the Threshold filter and save the result into the temporary allocation.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在临时分配上应用阈值滤镜，并将结果保存到临时分配中。
- en: Second, apply the Blur filter on the temporary Allocation and save the result
    in the target bitmap Allocation.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，在临时分配上应用模糊滤镜，并将结果保存在目标位图分配中。
- en: Finally, blend both the source and the filtered bitmap using an additive operation
    to create the final image. Blending can be done "in-place", without an additional
    Allocation, since each pixel is read and written only once (to the opposite of
    the blur filter).
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用加法运算混合源图和滤镜后的位图，创建最终图像。混合可以“原地”完成，无需额外的分配，因为每个像素只读取和写入一次（与模糊滤镜相反）。
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, save the result and free resources. All values wrapped in a `sp<>`
    (that is, a smart pointer) template, such as `tmpAlloc`, are freed automatically:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，保存结果并释放资源。所有包装在`sp<>`（即智能指针）模板中的值，如`tmpAlloc`，都会自动释放：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*What just happened?*'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'Run the project, tweak the `SeekBar` components, and click on the **Combine**
    button. The output `ImageView` should display a "remastered" picture, where the
    luminous parts are highlighted:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目，调整`SeekBar`组件，并单击**Combine**按钮。输出的`ImageView`应该显示一个“重新制作”的图片，其中亮部被突出显示。
- en: '![What just happened?](img/9645_10_03.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![刚刚发生了什么？](img/9645_10_03.jpg)'
- en: We chained multiple Intrinsics and Kernels together to apply a **Combine** filter
    to an image. Such a chain is easy to put in place; we basically need to connect
    the output Allocation of one script to the input Allocation of the next. Copying
    data to the output memory area is really only necessary at the end.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将多个内在函数和内核链接在一起，以对图像应用**Combine**滤镜。这样的链条很容易建立；我们基本上只需要连接一个脚本的输出分配到下一个脚本的输入分配。只有在最后才真正需要将数据复制到输出内存区域。
- en: Tip
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's really sad but script grouping features are not yet available on the Android
    NDK API, only on the Java side. With the script grouping feature, a full "graph"
    of scripts can be defined allowing RenderScript to optimize the code further.
    If you need this feature, then you can either wait or go back to Java.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很遗憾，但脚本分组功能目前尚未在Android NDK API上可用，只能在Java端使用。使用脚本分组功能可以定义一个完整的脚本“图”，从而使RenderScript能够进一步优化代码。如果您需要此功能，那么您可以等待或返回Java。
- en: Hopefully, Allocations can be reused if necessary in multiple scripts, to avoid
    allocating useless memory. It is even possible to reuse the same Allocation in
    input and output, if the script allows "in-place" modifications. This is not the
    case, for example, of the **Blur** filter, which would rewrite blurred pixels
    while they are read to blur other pixels, resulting in weird visual artefacts.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 希望，如果需要在多个脚本中重复使用分配，以避免分配无用的内存。如果脚本允许“原地”修改，甚至可以在输入和输出中重复使用相同的分配。例如，**模糊**滤镜就不是这种情况，它会在读取模糊其他像素时重写模糊的像素，导致奇怪的视觉伪影。
- en: Tip
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Speaking of reuse, it is good practice to reuse RenderSript objects (that is
    the RS context object, Intrinsics, Kernels, and so on) between executions. This
    is even more important if you repeatedly perform a computation, such as processing
    images from the camera.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到重用，重用RenderSript对象（即RS上下文对象、内在函数、内核等）在执行之间是一个良好的实践。如果您反复执行计算，比如处理来自相机的图像，这就更加重要了。
- en: 'Memory is an important aspect of RenderScript performance. Used badly, it can
    decrease efficiency. In our project, we provided a pointer to the Allocations
    we created it. This means that the Allocations we created in our project are "backed"
    with native memory, in our case, the bitmap content:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 内存是RenderScript性能的一个重要方面。使用不当会降低效率。在我们的项目中，我们为创建的分配提供了指针。这意味着我们在项目中创建的分配是由本机内存支持的，即位图内容：
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: However, data can also be copied before processing from the input memory area
    into the allocation using the `copy***From()` methods, which are the pendant of
    the `copy***To()` methods. This is especially useful with the Java binding side,
    which does not always allow the use of "backed Allocation". The NDK binding is
    more flexible and input data copying can be avoided most of the time.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数据也可以在处理之前从输入内存区域复制到分配中，使用`copy***From()`方法，这些方法是`copy***To()`方法的对应物。这在Java绑定端特别有用，因为它并不总是允许使用“支持的分配”。NDK绑定更加灵活，大多数情况下可以避免输入数据复制。
- en: RenderScript provides others mechanisms to communicate data from a script. The
    first ones are the methods `rsSendToClient()` and `rsSendToClientBlocking()`.
    They allow a script to communicate a "command", optionally with some data, to
    the calling side. The latter method is obviously a bit more dangerous in terms
    of performances, and should be avoided.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: RenderScript提供了其他机制来从脚本中传递数据。首先是`rsSendToClient()`和`rsSendToClientBlocking()`方法。它们允许脚本向调用方传递“命令”，可选地带有一些数据。后者在性能方面显然更加危险，应该避免使用。
- en: Data can also be communicated through pointers. Pointers are dynamic memory
    that allows bi-directional communication between the Kernel and the caller. As
    indicated previously, they are reflected in the generated classes with a method
    prefixed with `bind_`. The appropriate getters and setters should be generated
    in the reflected layer at compile time.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 数据也可以通过指针进行通信。指针是允许内核和调用者之间进行双向通信的动态内存。如前所述，它们在生成的类中以 `bind_` 为前缀的方法中反映出来。适当的获取器和设置器应该在编译时在反映层中生成。
- en: However, the NDK RenderScript framework does not reflect structures declared
    in RenderScript files yet. So declaring a pointer to `struct` defined in a script
    file will not work for now. Pointers to primitive types work using Allocations
    though. Thus, expect annoying limitations on the NDK side on this subject.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，NDK RenderScript 框架尚未反映在 RenderScript 文件中声明的结构。因此，目前在脚本文件中声明指向 `struct` 的指针是行不通的。使用分配可以使用原始类型的指针。因此，在这个主题上，可以在
    NDK 端预期到一些令人讨厌的限制。
- en: Let's end on the subject of memory by saying that in case you need more than
    one input or output Allocations for a script, there is a solution, an `rs_allocation`,
    which represents an Allocation reflected through a getter and setter. You can
    have as many of them as you want. Then, you can access dimensions and elements
    through the `rsAllocationGetDim*()`, `rsGetElementAt*()`, `rsSetElementAt*()`
    methods, and so on.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们谈谈内存的问题，如果你需要为脚本使用多个输入或输出分配，有一个解决方案，即 `rs_allocation`，它代表通过获取器和设置器反映的分配。你可以拥有任意数量的它们。然后，你可以通过
    `rsAllocationGetDim*()`、`rsGetElementAt*()`、`rsSetElementAt*()` 方法等访问维度和元素。
- en: 'For example, the `threshold()` method could be rewritten the following way:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`threshold()` 方法可以按照以下方式重写：
- en: Note
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that since we do not pass an input Allocation in parameter, return one
    as usual
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们没有传递输入分配作为参数，因此像往常一样返回一个
- en: The `for` loops are not implicit like it would be with an Allocation passed
    in parameter
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环不像将分配传递为参数那样隐式'
- en: The `threshold()` function cannot be a Kernel root. It is perfectly possible
    to use input Allocation in conjunction with `rs_allocation` though.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threshold()` 函数不能作为内核根。但是可以将输入分配与 `rs_allocation` 结合使用。'
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also, the Kernel would be called in the following way. Note how the method
    that applies the effect is prefixed with `invoked_` (instead of `forEach_`). This
    is because the `threshold()` function is not a Kernel root:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，内核将以以下方式被调用。请注意，应用效果的方法前缀为 `invoked_`（而不是 `forEach_`）。这是因为 `threshold()`
    函数不是内核根：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For more information about the RenderScript language capabilities, have a look
    at [http://developer.android.com/guide/topics/renderscript/advanced.html](http://developer.android.com/guide/topics/renderscript/advanced.html).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 RenderScript 语言功能的更多信息，请查看 [http://developer.android.com/guide/topics/renderscript/advanced.html](http://developer.android.com/guide/topics/renderscript/advanced.html)。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced RenderScript, an advanced technology to parallelize
    intensive computation tasks. More specifically, we saw how to use predefined RenderScript
    built-in Intrinsics, which are currently mainly dedicated to image processing.
    We also discovered how to implement our own Kernels with the RenderScript custom
    language inspired by C. Finally, we saw an example of an Intrinsics and Kernels
    combination to perform computations that are more complex.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 RenderScript，这是一种用于并行化密集计算任务的先进技术。更具体地说，我们看到了如何使用预定义的 RenderScript 内置
    Intrinsics，这些主要用于图像处理。我们还发现了如何使用受 C 启发的 RenderScript 自定义语言实现自己的内核。最后，我们看到了一个使用
    Intrinsics 和 Kernels 结合进行更复杂计算的示例。
- en: RenderScript is available from either the Java or the native side. However,
    let's be clear, apart from the exception of Allocations backed by memory buffers
    (a rather important feature for performance though), RenderScript is still more
    useable through its Java API. Grouping is not available, `struct` is not reflected
    yet, and some other features are still buggy (for example YUV Intrinsics).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: RenderScript 可以从 Java 或本地端使用。然而，除了由内存缓冲区支持的分配的例外情况（这是性能的一个相当重要的特性），RenderScript
    仍然更适合通过其 Java API 使用。分组不可用，`struct` 尚未反映，还有一些其他功能仍然存在错误（例如 YUV Intrinsics）。
- en: Indeed, RenderScript aims at giving tremendous computing power to the developers
    who neither have the time nor the knowledge to follow the native path. Thus, the
    NDK is not well-served yet. Although that will probably change in the future,
    you should be ready to keep at least parts of your RenderScript code on the Java
    side.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，RenderScript 旨在为那些没有时间也没有知识跟随本地路径的开发人员提供巨大的计算能力。因此，NDK 目前并不完善。尽管这可能会在未来发生改变，但你应该准备好至少将部分
    RenderScript 代码保留在 Java 端。
