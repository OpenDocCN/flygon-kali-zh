["```js\nvar str = function(s) {\n  if (typeof s === \"string\") {\n    return s;\n  }\n  else {\n    throw new TypeError(\"Error: String expected, \" + typeof s + \" given.\");   \n  }\n}\nvar num = function(n) {\n  if (typeof n === \"number\") {\n    return n;\n  }\n  else {\n    throw new TypeError(\"Error: Number expected, \" + typeof n + \" given.\");   \n  }\n}\nvar bool = function(b) {\n  if (typeof b === \"boolean\") {\n    return b;\n  }\n  else {\n    throw new TypeError(\"Error: Boolean expected, \" + typeof b + \" given.\");   \n  }\n}\nvar func = function(f) {\n  if (typeof f === \"function\") {\n    return f;\n  }\n  else {\n    throw new TypeError(\"Error: Function expected, \" + typeof f + \" given.\");   \n  }\n}\n```", "```js\nvar typeOf = function(type) {\n  return function(x) {\n    if (typeof x === type) {\n      return x;\n    }\n    else {\n      throw new TypeError(\"Error: \"+type+\" expected, \"+typeof x+\" given.\");\n    }\n  }\n}\nvar str = typeOf('string'),\n  num = typeOf('number'),\n  func = typeOf('function'),\n  bool = typeOf('boolean');\n```", "```js\n// unprotected method:\nvar x = '24';\nx + 1; // will return '241', not 25\n\n// protected method\n// plusplus :: Int -> Int\nfunction plusplus(n) {\n  return num(n) + 1;\n}\nplusplus(x); // throws error, preferred over unexpected output\n```", "```js\n// timestampLength :: String -> Int\nfunction timestampLength(t) { return num(**str(t)**.length); }\ntimestampLength(Date.parse('12/31/1999')); // throws error\ntimestampLength(Date.parse('12/31/1999')\n  .toString()); // returns 12\n```", "```js\nvar obj = typeOf('object');\nobj(123); // throws error\nobj({x:'a'}); // returns {x:'a'}\n```", "```js\nvar obj = function(o) {\n  if (Object.prototype.toString.call(o)===\"[object Object]\") {\n    return o;\n  }\n  else {\n    throw new TypeError(\"Error: Object expected, something else given.\"); \n  }\n}\n```", "```js\nvar objectTypeOf = function(name) {\n  return function(o) {\n    if (Object.prototype.toString.call(o) === \"[object \"+name+\"]\") {\n      return o;\n    }\n    else {\n      throw new TypeError(\"Error: '+name+' expected, something else given.\");\n    }\n  }\n}\nvar obj = objectTypeOf('Object');\nvar arr = objectTypeOf('Array');\nvar date = objectTypeOf('Date');\nvar div = objectTypeOf('HTMLDivElement');\n```", "```js\n// myFunctor :: (a -> b) -> f a -> f b\n```", "```js\n[1, 4, 9].map(Math.sqrt); // Returns: [1, 2, 3]\n```", "```js\n// map :: (a -> b) -> [a] -> [b]\nvar map = function(f, a) {\n  return arr(a).map(func(f));\n}\n```", "```js\n// strmap :: (str -> str) -> str -> str\nvar strmap = function(f, s) {\n  return str(s).split('').map(func(f)).join('');\n}\n\n// MyObject#map :: (myValue -> a) -> a\nMyObject.prototype.map(f{\n  return func(f)(this.myValue);\n}\n```", "```js\n// arrayOf :: (a -> b) -> ([a] -> [b])\nvar arrayOf = function(f) {\n  return function(a) {\n    return map(func(f), arr(a));\n  }\n}\n```", "```js\nvar plusplusall = arrayOf(plusplus); // plusplus is our morphism\nconsole.log( plusplusall([1,2,3]) ); // returns [2,3,4]\nconsole.log( plusplusall([1,'2',3]) ); // error is thrown\n```", "```js\nvar strs = arrayOf(str);\nconsole.log( strs(['a','b','c']) ); // returns ['a','b','c']\nconsole.log( strs(['a',2,'c']) ); // throws error\n```", "```js\nvar fcompose = function(f, g) {\n  return function() {\n    return f.call(this, g.apply(this, arguments));\n  };\n};\n```", "```js\nvar fcompose = function() {\n  // first make sure all arguments are functions\n  var funcs = arrayOf(func)(arguments);\n\n  // return a function that applies all the functions\n  return function() {\n    var argsOfFuncs = arguments;\n    for (var i = funcs.length; i > 0; i -= 1) {\n      argsOfFuncs  = [funcs[i].apply(this, args)];\n    }\n    return args[0];\n  };\n};\n\n// example:\nvar f = fcompose(negate, square, mult2, add1);\nf(2); // Returns: -36\n```", "```js\nif (getUsername() == null ) {\n  username = 'Anonymous') {\nelse {\n  username = getUsername();\n}\n```", "```js\n// the Maybe monad constructor, empty for now\nvar Maybe = function(){}; \n\n// the None instance, a wrapper for an object with no value\nvar None = function(){}; \nNone.prototype = Object.create(Maybe.prototype);\nNone.prototype.toString = function(){return 'None';};\n\n// now we can write the `none` function\n// saves us from having to write `new None()` all the time\nvar none = function(){return new None()};\n\n// and the Just instance, a wrapper for an object with a value\nvar Just = function(x){return this.x = x;};\nJust.prototype = Object.create(Maybe.prototype);\nJust.prototype.toString = function(){return \"Just \"+this.x;};\nvar just = function(x) {return new Just(x)};\n```", "```js\nvar maybe = function(m){\n  if (m instanceof None) {\n    return m;\n  }\n  else if (m instanceof Just) {\n    return just(m.x);   \n  }\n  else {\n    throw new TypeError(\"Error: Just or None expected, \" + m.toString() + \" given.\"); \n  }\n}\n```", "```js\nvar maybeOf = function(f){\n  return function(m) {\n    if (m instanceof None) {\n      return m;\n    }\n    else if (m instanceof Just) {\n      return just(f(m.x));\n    }\n    else {\n      throw new TypeError(\"Error: Just or None expected, \" + m.toString() + \" given.\"); \n    }\n  }\n}\n```", "```js\nMaybe.prototype.orElse = function(y) {\n  if (this instanceof Just) {\n    return this.x;\n  }\n  else {\n    return y;\n  }\n}\n```", "```js\nmaybe(just(123)).x; // Returns 123\nmaybeOf(plusplus)(just(123)).x; // Returns 124\nmaybe(plusplus)(none()).orElse('none'); // returns 'none'\n```", "```js\nmaybePlusPlus = maybeOf.curry()(plusplus);\nmaybePlusPlus(just(123)).x; // returns 123\nmaybePlusPlus(none()).orElse('none'); // returns none\n```", "```js\nvar User = function(){\n  this.username = none(); // initially set to `none`\n};\nUser.prototype.setUsername = function(name) {\n  this.username = just(str(name)); // it's now a `just\n};\nUser.prototype.getUsernameMaybe = function() {\n  var usernameMaybe = maybeOf.curry()(str);\n  return usernameMaybe(this.username).orElse('anonymous');\n};\n\nvar user = new User();\nuser.getUsernameMaybe(); // Returns 'anonymous'\n\nuser.setUsername('Laura');\nuser.getUsernameMaybe(); // Returns 'Laura'\n```", "```js\nfs.readFile(\"file.json\", function(err, val) {\n  if( err ) {\n    console.error(\"unable to read file\");\n  }\n  else {\n    try {\n      val = JSON.parse(val);\n      console.log(val.success);\n    }\n    catch( e ) {\n      console.error(\"invalid json in file\");\n    }\n  }\n});\n```", "```js\nfs.readFileAsync(\"file.json\").then(JSON.parse)\n  .then(function(val) {\n    console.log(val.success);\n  })\n  .catch(SyntaxError, function(e) {\n    console.error(\"invalid json in file\");\n  })\n  .catch(function(e){\n    console.error(\"unable to read file\")\n  });\n```", "```js\n// the Promise monad\nvar Promise = require('bluebird');\n\n// the promise functor\nvar promise = function(fn, receiver) {\n  return function() {\n    var slice = Array.prototype.slice,\n    args = slice.call(arguments, 0, fn.length - 1),\n    promise = new Promise();\n    args.push(function() {\n      var results = slice.call(arguments),\n      error = results.shift();\n      if (error) promise.reject(error);\n      else promise.resolve.apply(promise, results);\n    });\n    fn.apply(receiver, args);\n    return promise;\n  };\n};\n```", "```js\nvar files = ['a.json', 'b.json', 'c.json'];\nreadFileAsync = promise(fs.readFile);\nvar data = files\n  .map(function(f){\n    readFileAsync(f).then(JSON.parse)\n  })\n  .reduce(function(a,b){\n    return $.extend({}, a, b)\n  });\n```", "```js\nvar first = lens(\n  function (a) { return arr(a)[0]; }, // get\n  function (a, b) { return [b].concat(arr(a).slice(1)); } // set\n);\nfirst([1, 2, 3]); // outputs 1\nfirst.set([1, 2, 3], 5); // outputs [5, 2, 3]\nfunction tenTimes(x) { return x * 10 }\nfirst.modify(tenTimes, [1,2,3]); // outputs [10,2,3]\n```", "```js\nvar lens = fuction(get, set) {\n  var f = function (a) {return get(a)};\n  f.get = function (a) {return get(a)}; \n  f.set = set;\n  f.mod = function (f, a) {return set(a, f(get(a)))};\n  return f;\n};\n```", "```js\n// userName :: User -> str\nvar userName = lens(\n  function (u) {return u.getUsernameMaybe()}, // get\n  function (u, v) { // set\n    u.setUsername(v);  \n    return u.getUsernameMaybe(); \n  }\n);\n\nvar bob = new User();\nbob.setUsername('Bob');\nuserName.get(bob); // returns 'Bob'\nuserName.set(bob, 'Bobby'); //return 'Bobby'\nuserName.get(bob); // returns 'Bobby'\nuserName.mod(strToUpper, bob); // returns 'BOBBY'\nstrToUpper.compose(userName.set)(bob, 'robert'); // returns 'ROBERT'\nuserName.get(bob); // returns 'robert'\n```", "```js\n$('li').add('p.me-too').css('color', 'red').attr({id:'foo'});\n```", "```js\nvar jQuery = (function () {\n  var j = function (selector, context) {\n    var jq-obj = new j.fn.init(selector, context);\n    return jq-obj;\n  };\n\n  j.fn = j.prototype = {\n    init: function (selector, context) {\n      if (!selector) {\n        return this;\n      }\n    }\n  };\n  j.fn.init.prototype = j.fn;\n  return j;\n})();\n```", "```js\nvar $ = jQuery(); // the function is returned and assigned to `$`\nvar x = $('#select-me'); // jQuery object is returned\n```", "```js\n$('li').map(function(index, element) {\n  // do something to the element\n  return element\n});\n```", "```js\nvar homoMorph = function( /* input1, input2,..., inputN, output */ ) {\n  var before = checkTypes(arrayOf(func)(Array.prototype.slice.call(arguments, 0, arguments.length-1)));\n  var after = func(arguments[arguments.length-1])\n  return function(middle) {\n    return function(args) {\n      return after(middle.apply(this, before([].slice.apply(arguments))));   \n    }\n  }\n}\n\n// now we don't need to add type signature comments\n// because now they're built right into the function declaration\nadd = homoMorph(num, num, num)(function(a,b){return a+b})\nadd(12,24); // returns 36\nadd('a', 'b'); // throws error\nhomoMorph(num, num, num)(function(a,b){\n  return a+b;\n})(18, 24); // returns 42\n```", "```js\nvar checkTypes = function( typeSafeties ) {\n  arrayOf(func)(arr(typeSafeties));\n  var argLength = typeSafeties.length;\n  return function(args) {\n    arr(args);\n    if (args.length != argLength) {\n      throw new TypeError('Expected '+ argLength + ' arguments');\n    }\n    var results = [];\n    for (var i=0; i<argLength; i++) {\n      results[i] = typeSafeties[i](args[i]);   \n    }\n    return results;\n  }\n}\n```", "```js\nvar lensHM = homoMorph(func, func, func)(lens);\nvar userNameHM = lensHM(\n  function (u) {return u.getUsernameMaybe()}, // get\n  function (u, v) { // set\n    u.setUsername(v);\n    return u.getUsernameMaybe(); \n  }\n)\nvar strToUpperCase = homoMorph(str, str)(function(s) {\n  return s.toUpperCase();\n});\nvar morphFirstLetter = homoMorph(func, str, str)(function(f, s) {\n  return f(s[0]).concat(s.slice(1));\n});\nvar capFirstLetter = homoMorph(str, str)(function(s) {\n  return morphFirstLetter(strToUpperCase, s)\n});\n```", "```js\n// homomorphic lenses\nvar bill = new User();\nuserNameHM.set(bill, 'William'); // Returns: 'William'\nuserNameHM.get(bill); // Returns: 'William'\n\n// compose\nvar capatolizedUsername = fcompose(capFirstLetter,userNameHM.get);\ncapatolizedUsername(bill, 'bill'); // Returns: 'Bill'\n\n// it's a good idea to use homoMorph on .set and .get too\nvar getUserName = homoMorph(obj, str)(userNameHM.get);\nvar setUserName = homoMorph(obj, str, str)(userNameHM.set);\ngetUserName(bill); // Returns: 'Bill'\nsetUserName(bill, 'Billy'); // Returns: 'Billy'\n\n// now we can rewrite capatolizeUsername with the new setter\ncapatolizedUsername = fcompose(capFirstLetter, setUserName);\ncapatolizedUsername(bill, 'will'); // Returns: 'Will'\ngetUserName(bill); // Returns: 'will'\n```"]