- en: Sunago - An Android Port
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sunago - 一个Android端口
- en: In the last chapter, we built Sunago, a social media aggregation application.
    In that chapter, we learned that Sunago is a JavaFX-based application that can
    pull posts, tweets, photos, and so on from a variety of social media networks
    and display them in one place. The application certainly provided a number of
    interesting architectural and technical examples, but the application itself could
    be more practical--we tend to interact with social networks from mobile devices
    such as phones and tablets, so a mobile version would be much more useful. In
    this chapter, then, we'll write an Android port, reusing as much of the code as
    possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了Sunago，一个社交媒体聚合应用程序。在那一章中，我们了解到Sunago是一个基于JavaFX的应用程序，可以从各种社交媒体网络中获取帖子、推文、照片等，并在一个地方显示它们。该应用程序提供了许多有趣的架构和技术示例，但应用程序本身可能更实用--我们倾向于从手机和平板电脑等移动设备与社交网络互动，因此移动版本将更有用。因此，在本章中，我们将编写一个Android端口，尽可能重用尽可能多的代码。
- en: 'Android applications, while built in Java, look quite a bit different than,
    say, a desktop application. While we can''t cover every aspect of Android development,
    we''ll cover enough in this chapter to get you started, including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序，虽然是用Java构建的，但看起来与桌面应用程序有很大不同。虽然我们无法涵盖Android开发的每个方面，但在本章中，我们将涵盖足够的内容来让您入门，包括以下内容：
- en: Setting up an Android development environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Android开发环境
- en: Gradle builds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle构建
- en: Android views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android视图
- en: Android state management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android状态管理
- en: Android services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android服务
- en: Application packaging and deployment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序打包和部署
- en: Like the other chapters, there will be too many small items to call out each
    of them, but we'll do our best to highlight the new ones as they're introduced.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他章节一样，将有太多的小项目需要指出，但我们将尽力突出介绍新的项目。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: The first step is to get the Android development environment set up. As with
    *regular* Java development, an IDE isn't strictly necessary, but it sure helps,
    so we'll install Android Studio, which is an IDE based on IntelliJ IDEA. If you
    already have IDEA installed, you can just install the Android plugin and have
    everything you need. For our purposes here, though, we'll assume you don't have
    either installed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是设置Android开发环境。与*常规*Java开发一样，IDE并不是绝对必要的，但它确实有帮助，所以我们将安装Android Studio，这是一个基于IntelliJ
    IDEA的IDE。如果您已经安装了IDEA，您只需安装Android插件，就可以拥有所需的一切。不过，在这里，我们假设您两者都没有安装。
- en: 'To download Android Studio, go to [https://developer.android.com/studio/index.html](https://developer.android.com/studio/index.html),
    and download the package appropriate for your operating system. When you start
    Android Studio for the first time, you should see following screen:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要下载Android Studio，前往[https://developer.android.com/studio/index.html](https://developer.android.com/studio/index.html)，并下载适合您操作系统的软件包。当您第一次启动Android
    Studio时，您应该看到以下屏幕：
- en: '![](img/74eabc68-7103-49c2-935e-bca9650a22ed.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74eabc68-7103-49c2-935e-bca9650a22ed.png)'
- en: 'Before we start a new project, let''s configure the Android SDKs that are available.
    Click on the Configure menu in the bottom-right corner, then click on SDK Manager
    to get this screen:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始一个新项目之前，让我们配置可用的Android SDK。点击右下角的Configure菜单，然后点击SDK Manager，以获取以下屏幕：
- en: '![](img/34f5a1cb-3fdf-4414-9e47-5396a67f16cf.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34f5a1cb-3fdf-4414-9e47-5396a67f16cf.png)'
- en: Which SDKs you select will vary depending on your needs. You may need to support
    older devices as far back as, say, Android 5.0, or maybe you just want to support
    the very latest with Android 7.0 or 7.1.1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您选择的SDK将根据您的需求而变化。您可能需要支持旧设备，比如Android 5.0，或者您可能只想支持最新的Android 7.0或7.1.1。
- en: Once you know what need, select the appropriate SDKs (or do as I've done in
    the preceding screenshot and select everything from 5.0 and forward), then click
    on OK. You will need to read and accept the license before continuing.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你知道需要什么，选择适当的SDK（或者像我在前面的屏幕截图中所做的那样，选择从5.0版本开始的所有内容），然后点击确定。在继续之前，您需要阅读并接受许可证。
- en: Once you've done that, Android Studio will begin downloading the selected SDKs
    and any dependencies. This process can take a while, so be patient.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，Android Studio将开始下载所选的SDK和任何依赖项。这个过程可能需要一段时间，所以请耐心等待。
- en: 'When the SDK installation completes, click on the Finish button, which will
    take you take to the Welcome screen. Click on Start a new Android Studio project
    to get the following screen:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当SDK安装完成时，点击完成按钮，这将带您到欢迎屏幕。点击开始一个新的Android Studio项目，以获取以下屏幕：
- en: '![](img/fb7938a4-e5fb-47cd-bf09-38cf4620544d.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb7938a4-e5fb-47cd-bf09-38cf4620544d.png)'
- en: 'Nothing exciting here--we need to specify the Application name, Company domain,
    and Project location of our app:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里没有什么激动人心的--我们需要指定应用程序名称，公司域和应用程序的项目位置：
- en: '![](img/13d262cb-6a32-4e4c-862c-7d47dbc20d05.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13d262cb-6a32-4e4c-862c-7d47dbc20d05.png)'
- en: Next, though, we need to specify the form factor for our app. Our options are
    Phone and Tablet, Wear, TV, Android Auto, and Glass. As seen in this preceding
    screenshot, all we're interested in for this application is Phone and Tablet.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要指定应用程序的形态因素。我们的选项是手机和平板电脑，佩戴，电视，Android Auto和眼镜。如前面的屏幕截图所示，我们对这个应用程序感兴趣的是手机和平板电脑。
- en: On the next window, we need to select a type for the main `Activity` for the
    application. In an Android application, what we might refer to as a *screen* (or
    maybe *page*, if you're coming from a web application background) is known as
    an `Activity`. Not every `Activity` is a screen, though.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个窗口中，我们需要为应用程序的主“Activity”选择一个类型。在Android应用程序中，我们可能称之为“屏幕”（或者如果您来自Web应用程序背景，可能是“页面”）的东西被称为“Activity”。不过，并非每个“Activity”都是一个屏幕。
- en: 'From the Android developer documentation ([https://developer.android.com/reference/android/app/Activity.html](https://developer.android.com/reference/android/app/Activity.html)),
    we learn the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android开发者文档([https://developer.android.com/reference/android/app/Activity.html](https://developer.android.com/reference/android/app/Activity.html))中，我们了解到以下内容：
- en: '[a]n activity is a single, focused thing that the user can do. Almost all activities
    interact with the user, so the Activity class takes care of creating a window
    for you...'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[a]活动是用户可以执行的单一、专注的事情。几乎所有的活动都与用户进行交互，因此活动类会为您创建一个窗口...'
- en: 'For our purposes, it''s probably acceptable to equate the two, but do so loosely,
    and always with this caveat in mind. The wizard gives us many options, as seen
    in this screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，可能可以将两者等同起来，但要松散地这样做，并始终牢记这一警告。向导为我们提供了许多选项，如在此截图中所示：
- en: '![](img/d0ed3ec9-b414-48c3-80b1-0d3e62781a94.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0ed3ec9-b414-48c3-80b1-0d3e62781a94.png)'
- en: 'As you can see, there are several options: Basic, Empty, Fullscreen, Google
    AdMobs Ads, Google Maps, Login, and so on. Which to choose depends, again, on
    what your requirements are for the application. Our bare minimum requirements,
    in terms of user interface, are that it tells the user the name of the app, shows
    the list of social media items, and provides a menu for changing the application
    settings. From the preceding list, then, the Basic Activity is the closest match,
    so we select that, and click on Next:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，有几个选项：基本、空白、全屏、Google AdMobs广告、Google地图、登录等。选择哪个取决于应用程序的要求。就用户界面而言，我们的最低要求是告诉用户应用程序的名称，显示社交媒体项目列表，并提供一个菜单来更改应用程序设置。因此，从上面的列表中，基本活动是最接近的匹配，因此我们选择它，然后点击下一步：
- en: '![](img/db218934-2b49-41d2-becb-43a3e9d1914c.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db218934-2b49-41d2-becb-43a3e9d1914c.png)'
- en: The defaults in the preceding screen are mostly acceptable (notice that Activity
    Name was changed), but before we click on Finish, there are a few final words.
    When building an Android application of any size, you are going to have a lot
    of layouts, menus, activities, and so on. I have found it helpful to name these
    artifacts as you see here--the layout for an `Activity` is named `activity_` plus
    the `Activity` name; menus are `menu_` plus the activity name, or, for shared
    menus, a meaningful summary of its contents. Each artifact type is prefixed by
    its type. This general pattern will help you quickly navigate to the source file
    as the number of files grows, as the arrangement of these files is very flat and
    shallow.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面屏幕中的默认值大多是可以接受的（请注意，活动名称已更改），但在点击完成之前，还有一些最后的话。构建任何规模的Android应用程序时，您将拥有许多布局、菜单、活动等。我发现将这些工件命名为您在此处看到的名称很有帮助--活动的布局命名为`activity_`加上活动名称；菜单为活动名称加上`menu_`，或者对于共享菜单，是其内容的有意义的摘要。每种工件类型都以其类型为前缀。这种一般模式将帮助您在文件数量增加时快速导航到源文件，因为这些文件的排列非常扁平和浅。
- en: Finally, notice the Use a Fragment checkbox. *A Fragment is a piece of an application's
    user interface or behavior that can be placed in an Activity*. It is, effectively,
    a way for you, as the developer, to decompose the user interface definition into
    multiple pieces (or Fragments, thus, the name) that can be composed into a whole
    in an Activity in different ways depending on the current context of the application.
    For example, a Fragment-based user interface might have two screens for certain
    operations on a phone, but might combine those into one Activity for the larger
    screen on a tablet. It's a bit more complicated than that, of course, but I include
    that brief and incomplete description simply to give some explanation of the checkbox.
    We will not be using Fragments in our application, so we leave that unchecked,
    and click on Finish.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，请注意使用片段复选框。*片段是应用程序用户界面或行为的一部分，可以放置在活动中*。实际上，这是您作为开发人员将用户界面定义分解为多个片段（或片段，因此名称）的一种方式，这些片段可以根据应用程序当前上下文以不同的方式组合成一个整体在活动中。例如，基于片段的用户界面可能在手机上有两个屏幕用于某些操作，但在平板上可能将这些组合成一个活动。当然，情况比这更复杂，但我包含了这个简短而不完整的描述，只是为了解释复选框。我们不会在我们的应用程序中使用片段，因此我们将其取消选中，然后点击完成。
- en: 'After processing for some time, Android Studio now creates a basic application
    for us. Before we start coding the application, let''s run it to see what that
    process looks like. We can run the app in a few ways--we can click on Run | Run
    ''app''; click on the green play button in the middle of the toolbar, or press
    *Shift* + *F10*. All three will bring up the same Select Deployment Target window,
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 处理一段时间后，Android Studio现在为我们创建了一个基本应用程序。在开始编写应用程序之前，让我们运行它，看看该过程是什么样子。我们可以以几种方式运行应用程序--我们可以单击“运行”|“运行‘app’”；单击工具栏中间的绿色播放按钮；或按下*Shift*
    + *F10*。所有这三种方法都会弹出相同的选择部署目标窗口，如下所示：
- en: '![](img/218d9d68-39b5-44d1-8f73-f81d0094ec27.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/218d9d68-39b5-44d1-8f73-f81d0094ec27.png)'
- en: 'Since we just installed Android Studio, we don''t have any emulators created,
    so we need to do that now. To create the emulators, follow these steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们刚刚安装了Android Studio，我们还没有创建任何模拟器，因此现在需要这样做。要创建模拟器，请按照以下步骤操作：
- en: 'Clicking on the Create New Virtual Device button gets us this screen:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“创建新虚拟设备”按钮后，会出现以下屏幕：
- en: '![](img/43e46090-343b-4f45-bbd0-4f1a8971900b.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43e46090-343b-4f45-bbd0-4f1a8971900b.png)'
- en: 'Let''s start with a reasonably modern Android phone--select the Nexus 6 profile,
    and click on Next:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从一个相当现代的Android手机开始--选择Nexus 6配置文件，然后点击下一步：
- en: '![](img/7361ff87-aa1a-414c-8985-781b118a8ae0.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7361ff87-aa1a-414c-8985-781b118a8ae0.png)'
- en: In the preceding screen, your options will vary based on which SDKs you've installed.
    Which SDK you choose, again, depends on your target audience, application needs,
    and so on. As enjoyable as it always is to use the latest and greatest, we don't
    strictly need any APIs from, say, Nougat. Choosing Android 7.x would restrict
    the availability of Sunago to those on very new phones, and do so for no good
    reason. We will, then, target Lollipop (Android 5.0), which strikes a good balance
    between supporting as many users as possible and providing access to newer Android
    features.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕中，您的选项将根据您安装了哪些SDK而有所不同。再次选择哪个SDK取决于您的目标受众、应用程序需求等等。尽管始终使用最新和最好的东西很愉快，但我们并不严格需要来自Nougat的任何API。选择Android
    7.x将限制Sunago仅适用于新手机上，并且没有充分的理由这样做。因此，我们将以Lollipop（Android 5.0）为目标，这在支持尽可能多的用户和提供对新Android功能的访问之间取得了良好的平衡。
- en: Click the Download link if necessary for the x86_64 ABI, select that release,
    click on Next, and then click on Finish on the Verify Configuration screen.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要x86_64 ABI，请单击下载链接，选择该版本，然后在“验证配置”屏幕上单击“完成”。
- en: With an emulator created, we can now select it in the Select Deployment Target
    screen, and run the application by clicking on OK. If you want to skip the selection
    screen the next time you run the application, you can check the Use same selection
    for future launches checkbox before clicking on OK.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个模拟器后，我们现在可以在“选择部署目标”屏幕中选择它，并通过单击“确定”来运行应用程序。如果您想要在下次运行应用程序时跳过选择屏幕，可以在单击“确定”之前选中“将来启动使用相同的选择”复选框。
- en: 'The first time the application is run, it will take a bit longer, as the application
    is built and packaged and the emulator started. After a few moments, you should
    see the following screen:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行应用程序时，由于应用程序正在构建和打包，模拟器正在启动，所以会花费更长的时间。几分钟后，您应该会看到以下屏幕：
- en: '![](img/faa68398-f03d-4db0-b58b-4bcd7cb98270.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/faa68398-f03d-4db0-b58b-4bcd7cb98270.png)'
- en: It's nothing special, but it shows that everything is working as expected. Now,
    we're ready to start the real work in porting Sunago.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这没什么特别的，但它表明一切都按预期运行。现在，我们准备开始在移植Sunago中进行真正的工作。
- en: Building the user interface
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: 'Put simply, Android user interfaces are based on Activities, which use layout
    files to describe the structure of the user interface. There''s more to it, of
    course, but this simple definition should be sufficient for our work on Sunago.
    Let''s start, then, by looking at our `Activity`, `MainActivity`, which is as
    follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Android用户界面是基于Activities的，它使用布局文件来描述用户界面的结构。当然，还有更多内容，但这个简单的定义对我们在Sunago上的工作应该足够了。那么，让我们开始看看我们的“Activity”，“MainActivity”，如下所示：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This last bit of code is the class exactly as it was generated by Android Studio.
    It''s very basic, but it has most of what you need to create an `Activity`. Note
    that the class extends `AppCompatActivity`. While Google has been very active
    in pushing the Android platform, they have also worked tirelessly to make sure
    that older devices aren''t left behind any sooner than they have to be. To achieve
    that, Google has backported many new features in "compat" (or compatibility) packages,
    which means many of the newer APIs will actually run on older versions of Android.
    The changes, though, since they are in separate packages, won''t break any existing
    functionality--they must be explicitly opted for, which is what we''re doing here.
    While we''re not planning on supporting older versions of Android, such as KitKat,
    it is still suggested that your `Activity` classes extend the compatibility classes,
    like this one, as there is a significant number of features built in to these
    classes that we would otherwise have to implement ourselves. Let''s walk through
    this class to get a sense of what all is going on in the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分代码是由Android Studio生成的类。它非常基础，但它具有大部分创建“Activity”所需的内容。请注意，该类扩展了“AppCompatActivity”。尽管Google一直在积极推动Android平台，但他们也不遗余力地确保旧设备不会被抛弃得比必要的更早。为了实现这一点，Google已经在“compat”（或兼容性）包中将许多新功能进行了后向兼容，这意味着许多新的API实际上可以在旧版本的Android上运行。然而，由于它们在单独的包中，所以不会破坏任何现有的功能——它们必须明确选择，这就是我们在这里要做的。虽然我们不打算支持旧版本的Android，比如KitKat，但建议您的“Activity”类扩展兼容性类，就像这个类一样，因为这些类内置了大量功能，否则我们将不得不自己实现。让我们逐步了解这个类，以便在接下来的步骤中了解正在进行的所有工作：
- en: The first method is `onCreate()`, which is an `Activity` life cycle method (we'll
    talk more about Activity life cycle in a moment). When the system creates the
    `Activity` class, this method is called. It is here that we initialize the user
    interface, setting values, connection controls to data sources, and so on. Note
    that the method takes a **Bundle**. This is how Android passes in the Activity
    state so that it may be restored.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个方法是“onCreate()”，这是一个“Activity”生命周期方法（我们稍后会详细讨论Activity生命周期）。当系统创建“Activity”类时，将调用此方法。在这里，我们初始化用户界面，设置值，将控件连接到数据源等。请注意，该方法需要一个**Bundle**。这是Android传递Activity状态的方式，以便可以恢复它。
- en: In the `setContentView(R.layout.activity_main)` method, we tell the system what
    layout we want to use for this `Activity`. Once we've set the content `View` for
    `Activity`, we can then start acquiring references to various elements. Notice
    that we first look for the `Toolbar` defined in the view, `findViewById(R.id.toolbar)`,
    then we tell Android to use that as our action bar via `setSupportActionBar()`.
    This is an example of a functionality that is implemented for us via the `compat`
    class. If we extended, say, `Activity` directly, we would be required to do much
    more work to make the action bar work. As it is, we call one setter and we're
    done.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setContentView(R.layout.activity_main)`方法中，我们告诉系统我们要为这个“Activity”使用哪个布局。一旦我们为“Activity”设置了内容“View”，我们就可以开始获取对各种元素的引用。请注意，我们首先寻找视图中定义的“Toolbar”，`findViewById(R.id.toolbar)`，然后我们告诉Android使用它作为我们的操作栏，通过`setSupportActionBar()`。这是一个通过“compat”类为我们实现的功能的例子。如果我们直接扩展了，比如说，`Activity`，我们将需要做更多的工作来使操作栏工作。现在，我们只需调用一个setter，就完成了。
- en: Next, we look up another user interface element, the `FloatingActionButton`.
    In the preceding screenshot, this is the button in the lower-right corner with
    the email icon. We will actually be removing this, but, since Android Studio generated
    it, we can learn what we can from it before it is removed. Once we have a reference
    to it, we can attach listeners. In this case, we're adding an `on Click` listener
    by creating an anonymous inner class of type `View.OnClickListener`. This works,
    but we've just spent the last five chapters getting rid of those.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们查找另一个用户界面元素，即`FloatingActionButton`。在前面的屏幕截图中，这是右下角带有电子邮件图标的按钮。实际上，我们将删除它，但是由于Android
    Studio生成了它，所以在删除之前我们可以从中学到一些东西。一旦我们有了对它的引用，我们就可以附加监听器。在这种情况下，我们通过创建一个类型为`View.OnClickListener`的匿名内部类来添加一个`onClick`监听器。这样做是有效的，但是在过去的五章中，我们一直在摆脱这些。
- en: 'The Android build system now natively supports using Java 8, so we can modify
    the `onClick` listener registration to look like this:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android构建系统现在原生支持使用Java 8，因此我们可以修改`onClick`监听器注册，使其看起来像这样：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the user taps the button, the Snackbar appears. According to the Google
    documentation, *Snackbars provide brief feedback about an operation through a
    message at the bottom of the screen*. And that's exactly what we get--a message
    telling us to replace the `onClick` result with our own action. As stated earlier,
    though, we don't need the floating button, so we'll remove this method and, later,
    the view definition from the layout.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，Snackbar会出现。根据谷歌的文档，*Snackbar通过屏幕底部的消息提供有关操作的简短反馈*。这正是我们得到的 - 一条消息告诉我们用自己的操作替换`onClick`的结果。不过，正如前面所述，我们不需要浮动按钮，所以我们将删除这个方法，以及稍后从布局中删除视图定义。
- en: The next method in the class is `onCreateOptionsMenu()`. This method is called
    when the options menu is first opened to populate the list of items. We use `MenuInflater`
    to inflate the menu definition file, and add what it defined there to `Menu` that
    the system passes in. This method is called only once, though, so if you need
    a menu that changes, you should override `onPrepareOptionsMenu(Menu)`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类中的下一个方法是`onCreateOptionsMenu()`。当选项菜单首次打开以填充项目列表时，将调用此方法。我们使用`MenuInflater`来填充菜单定义文件，并将其添加到系统传入的`Menu`中。这个方法只会被调用一次，所以如果你需要一个会变化的菜单，你应该重写`onPrepareOptionsMenu(Menu)`。
- en: The final method, `onOptionsItemSelected()`, is called when the user taps an
    options menu item. The specific `MenuItem` selected is passed in. We get its ID,
    and call the method appropriate for the menu item.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个方法`onOptionsItemSelected()`在用户点击选项菜单项时被调用。传入了特定的`MenuItem`。我们获取它的ID，并调用适用于菜单项的方法。
- en: 'That''s a basic `Activity`, but what does a layout look like? Here are the
    contents of `activity_main.xml`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的`Activity`，但是布局是什么样的呢？这是`activity_main.xml`的内容：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That''s a fair bit of XML, so let''s walk through the major items of interest
    quickly, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当多的XML，所以让我们快速浏览一下主要的兴趣点，如下所示：
- en: The root element is `CoordinatorLayout`. Its Java document describes it as a
    super-powered `FrameLayout`. One of its intended purposes is as *a top-level application
    decor or chrome layout*, which is exactly what we're using it for here. Layouts
    such as `CoordinatorLayout` are roughly analogous to JavaFX's containers. Different
    layouts (or `ViewGroup`) provide a variety of capabilities such as laying out
    elements with exact X/Y coordinates (`AbsoluteLayout`), in a grid (`GridLayout`),
    relative to each other (`RelativeLayout`), and so on.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根元素是`CoordinatorLayout`。它的Java文档将其描述为一个超级强大的`FrameLayout`。其预期目的之一是作为*顶级应用程序装饰或Chrome布局*，这正是我们在这里使用它的目的。诸如`CoordinatorLayout`之类的布局大致相当于JavaFX的容器。不同的布局（或`ViewGroup`）提供了各种功能，例如使用精确的X/Y坐标布置元素（`AbsoluteLayout`），在网格中布置元素（`GridLayout`），相对于彼此布置元素（`RelativeLayout`），等等。
- en: In addition to providing our top-level container, the element defines a number
    of required XML namespaces. It also sets the height and width for the control.
    There are three possible values for this field--`match_parent` (in earlier versions
    of the SDK, this was called `fill_parent` should you ever come across that), which
    means that the control should match the value of its parent, `wrap_content`, which
    means the control should be just big enough for its contents; or an exact number.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了提供我们的顶级容器之外，该元素还定义了一些必需的XML命名空间。它还为控件设置了高度和宽度。该字段有三个可能的值 - `match_parent`（在SDK的早期版本中，这被称为`fill_parent`，如果你遇到过的话），这意味着控件应该与其父级的值匹配，`wrap_content`，这意味着控件应该足够大以容纳其内容；或者是一个确切的数字。
- en: The next element is `AppBarLayout`, which is a `ViewGroup` that implements a
    number of the material designs app bar concepts. **Material design** is the latest
    **visual language** being developed and supported by Google. It provides a modern,
    consistent look and feel across Android apps. Its usage is encouraged by Google,
    and fortunately, the new `Activity` wizard has set us up to use it out of the
    box. The layout's width is set to `match_parent` so that it fills the screen,
    and the width is set to `wrap_content` so that's it's just big enough to show
    its content, which is a single `Toolbar`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的元素是`AppBarLayout`，它是一个实现了一些材料设计应用栏概念的`ViewGroup`。**材料设计**是谷歌正在开发和支持的最新**视觉语言**。它为Android应用程序提供了现代、一致的外观和感觉。谷歌鼓励使用它，并且幸运的是，新的`Activity`向导已经设置好了让我们直接使用它。布局的宽度设置为`match_parent`，以便填满屏幕，宽度设置为`wrap_content`，以便刚好足够显示其内容，即一个`Toolbar`。
- en: Skipping the `include` element for a moment, the last element in the view is
    `FloatingActionButton`. Our only interest here is noting that the widget exists,
    should the need for one arise in other projects. As we did in the `Activity` class
    though, we need to remove this widget.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂时跳过`include`元素，视图中的最后一个元素是`FloatingActionButton`。我们唯一感兴趣的是注意到这个小部件的存在，以防其他项目中需要它。不过，就像我们在`Activity`类中所做的那样，我们需要移除这个小部件。
- en: Finally, there's the `include` element. This does what you would think it should--the
    specified file is included in the layout definition as if its contents were hard
    coded into the file. This allows us to keep our layout files small, reuse user
    interface element definitions (which is especially helpful for complex scenarios),
    and so on.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，还有`include`元素。这做的就是你认为它应该做的--指定的文件被包含在布局定义中，就好像它的内容被硬编码到文件中一样。这允许我们保持布局文件的小巧，重用用户界面元素定义（对于复杂的情况尤其有帮助），等等。
- en: 'The included file, `content_main.xml`, looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的文件`content_main.xml`看起来是这样的：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This preceding view uses `RelativeLayout` to wrap its only child, a `TextView`.
    Note that we can set the padding of a control. This controls how much space is
    *inside* the control around its children. Think of it like packing a box--inside
    the box, you may have a fragile ceramic antique, so you pad the box to protect
    it. You can also set the margin of a control, which is the space *outside* the
    control, akin to the personal space around us we are so often fond of.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个前面的视图使用`RelativeLayout`来包裹它唯一的子元素，一个`TextView`。请注意，我们可以设置控件的填充。这控制了控件周围*内部*空间有多大。想象一下，就像包装一个盒子--在盒子里，你可能有一个易碎的陶瓷古董，所以你填充盒子来保护它。你也可以设置控件的边距，这是控件*外部*的空间，类似于我们经常喜欢的个人空间。
- en: 'The `TextView`, though, isn''t helpful, so we''ll remove that, and add what
    we really need, which is a `ListView`, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不过`TextView`并不有用，所以我们将其移除，并添加我们真正需要的，即`ListView`，如下所示：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`ListView` is a control that shows items in a vertically scrolling list. In
    terms of user experience, this works pretty much like the `ListView` we looked
    at in JavaFX. How it works, though, is quite different. To see how, we need to
    make some adjustments to activity''s `onCreate()` method as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`是一个在垂直滚动列表中显示项目的控件。在用户体验方面，这基本上与我们在JavaFX中看到的`ListView`工作方式相似。不过，它的工作方式是完全不同的。为了了解它是如何工作的，我们需要对活动的`onCreate()`方法进行一些调整，如下所示：'
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are several things going on here, which sets us up nicely for discussing
    data access in Android. Before we get to that in detail, though, a quick overview
    is in order:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件事情正在进行，这为我们讨论Android中的数据访问做好了准备。在我们详细讨论之前，让我们先进行一个快速概述。
- en: We check to make sure that the device has a working network connection via `isNetworkAvailable()`,
    which we'll look at later in this chapter.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查设备是否有工作的网络连接通过`isNetworkAvailable()`，我们稍后在本章中会看到。
- en: If the connection is available, we configure the user interface, starting with
    setting the toolbar.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果连接可用，我们配置用户界面，首先设置工具栏。
- en: Next, we create an instance of `SunagoCursorAdapter`, which we'll discuss in
    detail later. For now, though, just note that an `Adapter` is how the `ListView`
    is connected to the data source, and they can be backed by things as varied as
    an SQL datasource or an `Array`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`SunagoCursorAdapter`的实例，我们稍后会详细讨论。不过现在，只需注意`Adapter`是`ListView`与数据源连接的方式，它们可以由各种各样的东西支持，比如SQL数据源或`Array`。
- en: We pass the adapter to `ListView`, thus completing this connection via `ListView.setAdapter()`.
    Much like JavaFX's `Observable` model property, we'll be able to use this to update
    the user interface without direct interaction any time the data changes.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将适配器传递给`ListView`，从而通过`ListView.setAdapter()`完成这个连接。就像JavaFX的`Observable`模型属性一样，我们将能够在数据发生变化时更新用户界面，而无需直接交互。
- en: Next, we set up an `onClick` listener for the items in the list. We'll use this
    to display the item the user taps (or clicks) on in an external browser. In a
    nutshell, given the `position` parameter, we get the item at that position, a
    `Cursor`, extract the URL of the item, then display the page at that URL using
    the device's default browser via an `Intent` (which we'll discuss in detail later).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为列表中的项目设置一个`onClick`监听器。我们将使用这个来在外部浏览器中显示用户点击（或点击）的项目。简而言之，给定`position`参数，我们获取该位置的项目，一个`Cursor`，提取项目的URL，然后使用设备的默认浏览器通过`Intent`显示该URL的页面（我们稍后会详细讨论）。
- en: Finally, completing our data binding, we initialize the `LoaderManager` that
    will handle loading and updating the `Adapter` in an asynchronous manner.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，完成我们的数据绑定，我们初始化将以异步方式处理加载和更新`Adapter`的`LoaderManager`。
- en: 'One last bit of code to look at before diving into data access--`isNetworkAvailable()`--
    is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入数据访问之前，我们要看的最后一点代码是`isNetworkAvailable()`，如下所示：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we start by getting a reference to the system service,
    `ConnectivityManager`, then we loop through each `Network` known to the system.
    For each `Network`, we get a reference to its `NetworkInfo` and call `isConnected()`.
    If we find one connected network, we return true, otherwise, we return false.
    In the calling code, if our return value is `false`, we show an error dialog,
    the method for which is shown here as well. This is a standard Android dialog.
    We have, however, added an `onClick` listener to the OK button, which closes the
    application. Using this, we tell the user that a network connection is needed,
    then close the app when the user taps on OK. It is debatable, of course, if this
    behavior is desirable, but the process for determining a device's network state
    is interesting enough, so I've included it here.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先获取系统服务`ConnectivityManager`的引用，然后循环遍历系统中已知的每个`Network`。对于每个`Network`，我们获取其`NetworkInfo`的引用并调用`isConnected()`。如果我们找到一个连接的网络，我们返回true，否则返回false。在调用代码中，如果我们的返回值是`false`，我们显示一个错误对话框，其方法也在这里显示。这是一个标准的Android对话框。不过，我们添加了一个`onClick`监听器到OK按钮，它关闭应用程序。使用这个，我们告诉用户需要网络连接，然后当用户点击OK时关闭应用程序。当然，这种行为是否可取是值得商榷的，但是确定设备的网络状态的过程是足够有趣的，所以我在这里包含了它。
- en: Let's turn our attention now to how data access is often done in Android apps--`CursorAdapters`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把注意力转向Android应用中经常进行的数据访问--`CursorAdapters`。
- en: Android data access
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android数据访问
- en: With any platform, there are multiple ways to access data, from built-in facilities
    to homegrown APIs. Android is no different, so while you can write your own way
    to load data from some arbitrary data source, unless you have very particular
    requirements, there is often no need, as Android has a system built in--the `ContentProvider`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何平台上，都有多种访问数据的方式，从内置设施到自制API。安卓也不例外，因此，虽然你可以编写自己的方式从任意数据源加载数据，但除非你有非常特殊的要求，通常是没有必要的，因为安卓内置了一个系统——`ContentProvider`。
- en: The Android documentation will tell you that a *content provider manages access
    to a central repository of data*, and that it offers a consistent, *standard interface
    to data that also handles inter-process communication and secure data access*.
    If you intend to expose your application's data to external sources (either for
    read or write), `ContentProvider` is a great way to go. However, if you don't
    intend to expose your data, you are more than welcome to write the needed CRUD
    methods yourself, manually issuing various SQL statements. In our case, we'll
    use a `ContentProvider`, as we have an interest in allowing third-party developers
    access to the data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓文档会告诉你，*内容提供者管理对数据的中央存储库的访问*，并且它提供了一个一致的、*标准的数据接口，还处理进程间通信和安全数据访问*。如果你打算向外部来源（无论是读取还是写入）公开应用程序的数据，`ContentProvider`是一个很好的选择。然而，如果你不打算公开你的数据，你完全可以自己编写所需的CRUD方法，手动发出各种SQL语句。在我们的情况下，我们将使用`ContentProvider`，因为我们有兴趣允许第三方开发人员访问数据。
- en: 'To create a `ContentProvider`, we need to create a new class that extends `ContentProvider`
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`ContentProvider`，我们需要创建一个新的类，继承`ContentProvider`，如下所示：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also need to register the provider in `AndroidManfest.xml`, which we''ll
    do like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`AndroidManfest.xml`中注册提供者，我们将这样做：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Interaction with `ContentProvider` is never done directly. The client code will
    specify the URL of the data to be manipulated, and the Android system will direct
    the request to the appropriate provider. To make sure our `ContentProvider` functions
    as expected, then, we need to register the provider's authority, which we've already
    seen in the previous XML. In our provider, we'll create some static fields to
    help us manage the parts of our authority and the related URLs in a DRY manner.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ContentProvider`的交互永远不是直接进行的。客户端代码将指定要操作的数据的URL，安卓系统将把请求转发给适当的提供者。因此，为了确保我们的`ContentProvider`按预期运行，我们需要注册提供者的权限，这已经在之前的XML中看到了。在我们的提供者中，我们将创建一些静态字段来帮助我们以DRY的方式管理我们权限的部分和相关的URL。
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first two fields in the preceding bit of code are private, as they're not
    needed outside the class. We define them as separate fields here, though, for
    clarity's sake. The third field, `CONTENT_URI`, is public, as we'll be referencing
    that field elsewhere in our app. Third-party consumers won't have access to the
    field, obviously, but will need to know its value, `content://com.steeplesoft.sunago.SunagoProvider/items`,
    which we would document somewhere for add-on developers. The first part of the
    URL, the protocol field, tells Android that we're looking for a `ContentProvider`.
    The next section is the authority, which uniquely identifies a particular `ContentProvider`,
    and the final field specifies the type of data, or model, that we're interested
    in. For Sunago, we have a single data type, `items`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码的前两个字段中，是私有的，因为在类外部不需要它们。我们在这里将它们定义为单独的字段，以便更清晰。第三个字段`CONTENT_URI`是公共的，因为我们将在应用程序的其他地方引用该字段。第三方消费者显然无法访问该字段，但需要知道它的值`content://com.steeplesoft.sunago.SunagoProvider/items`，我们会在某个地方为附加开发人员记录这个值。URL的第一部分，协议字段，告诉安卓我们正在寻找一个`ContentProvider`。接下来的部分是权限，它唯一标识特定的`ContentProvider`，最后一个字段指定我们感兴趣的数据类型或模型。对于Sunago，我们只有一个数据类型，`items`。
- en: 'Next, we need to specify the URIs we want to support. We only have two--one
    for the items collection, and one for a particular item. Please, refer to following
    code snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要指定我们想要支持的URI。我们只有两个——一个用于项目集合，一个用于特定项目。请参考以下代码片段：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the last code, we start by creating a `UriMatcher`. Note that we pass `UriMatcher.NO_MATCH`
    to the constructor. It's not immediately clear what this value is for, but this
    is the value that will be returned if the user passes in a URI that doesn't match
    any of those registered. Finally, we register each URI with a unique `int` identifier.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的代码中，我们首先创建了一个`UriMatcher`。请注意，我们将`UriMatcher.NO_MATCH`传递给构造函数。这个值的作用并不立即清楚，但如果用户传入一个不匹配任何已注册的URI的URI，将返回这个值。最后，我们为每个URI注册一个唯一的`int`标识符。
- en: 'Next, like many Android classes, we need specify an `onCreate` lifecycle hook
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，像许多安卓类一样，我们需要指定一个`onCreate`生命周期钩子，如下所示：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`SunagoOpenHelper` is a child of `SQLiteOpenHelper`, which manages the creation
    and/or update of the underlying SQLite database. The class itself is pretty simple,
    and is given as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`SunagoOpenHelper`是`SQLiteOpenHelper`的子类，它管理底层SQLite数据库的创建和/或更新。这个类本身非常简单，如下所示：'
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I've not shown the table creation DDL, as it's a pretty simple table creation,
    but this class is all you need to create and maintain your database. If you have
    multiple tables, you would issue multiple creates in `onCreate`. When the application
    updates, `onUpgrade()` is called to allow you to modify the schema if needed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有展示表的创建DDL，因为它是一个非常简单的表创建，但这个类是你创建和维护数据库所需的全部。如果你有多个表，你将在`onCreate`中发出多个创建。当应用程序更新时，将调用`onUpgrade()`来允许你根据需要修改模式。
- en: 'Back in our `ContentProvider`, we need to implement two methods, one to read
    data, and one to insert (given the nature of the app, we''re not interested in
    deletes or updates right now). For reading data, we override `query()` as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`ContentProvider`，我们需要实现两个方法，一个用于读取数据，一个用于插入（考虑到应用程序的性质，我们现在不关心删除或更新）。对于读取数据，我们重写`query()`如下：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This last code is where our URIs and their `int` identifiers come in. Using
    `UriMatcher`, we check the `Uri` passed in by the caller. Given that our provider
    is simple, the only one we need to do anything special for is `#2`, which is the
    query for a specific item. In that case, we extract the ID passed in as the last
    path segment, and add it to the selection criteria specified by the caller.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一段代码是我们的URI及其`int`标识符的用处。使用`UriMatcher`，我们检查调用者传入的`Uri`。鉴于我们的提供者很简单，我们只需要为`#2`做一些特殊处理，这是针对特定项目的查询。在这种情况下，我们提取传入的ID作为最后的路径段，并将其添加到调用者指定的选择条件中。
- en: Once we have the query configured as requested, we get a readable `SQLiteDatabase`
    from our `openHelper`, and query it using the values passed by the caller. This
    is one of the areas where the `ContentProvider` contract comes in handy--we don't
    need to write any `SELECT` statements manually.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们按照要求配置了查询，我们就从我们的`openHelper`中获得一个可读的`SQLiteDatabase`，并使用调用者传递的值进行查询。这是`ContentProvider`合同非常方便的地方之一--我们不需要手动编写任何`SELECT`语句。
- en: 'Before returning the cursor, we need to do something to it, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回游标之前，我们需要对它进行一些处理，如下所示：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this preceding call, we tell the system that we want the cursor notified
    when the data is updated. Since we're using a `Loader`, this will allow us to
    update the user interface automatically when data is inserted.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述调用，我们告诉系统我们希望在数据更新时通知游标。由于我们使用了`Loader`，这将允许我们在插入数据时自动更新用户界面。
- en: 'For inserting data, we override `insert()` as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于插入数据，我们重写`insert()`如下：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using `openHelper`, this time, we get a writable instance of the database, on
    which we call `insert()`. The insert method returns the ID of the row just inserted.
    If we get a non-zero ID, we generate a URI for the row, which we'll eventually
    return. Before we do so, however, we notify the content resolver of the change
    in the data, which triggers our auto-reload in the user interface.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`openHelper`，这一次，我们获得了数据库的可写实例，在这个实例上调用`insert()`。插入方法返回刚刚插入的行的ID。如果我们得到一个非零的ID，我们会为这一行生成一个URI，最终会返回它。然而，在这之前，我们会通知内容解析器数据的变化，这会触发用户界面的自动重新加载。
- en: 'We have one more step to finish our data loading code, though. If you look
    back on `MainActivity.onCreate()`, you''ll see this line:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还有一步要完成我们的数据加载代码。如果你回顾一下`MainActivity.onCreate()`，你会看到这一行：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This last line tells the system that we want to initialize a `Loader` and that
    the `Loader` is `this` or `MainActivity`. In our definition of `MainActivity`,
    we''ve specified that it implements the `LoaderManager.LoaderCallbacks<Cursor>`
    interface. This requires us to implement a few methods as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一行告诉系统我们要初始化一个`Loader`，并且`Loader`是`this`或`MainActivity`。在我们对`MainActivity`的定义中，我们已经指定它实现了`LoaderManager.LoaderCallbacks<Cursor>`接口。这要求我们实现一些方法，如下所示：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `onCreateLoader()`, we specify both what to load and where to load it. We
    pass in the URI of the `ContentProvider` we just created, we specify the fields
    we're interested in via the `ITEM_PROJECTION` variable (which is a `String[]`,
    and not shown here), and, finally, the sort order (which we've specified as the
    timestamp of the items in descending order so that we get the newest items on
    top). The method `onLoadFinished()` is where the auto-reload happens. Once a new
    `Cursor` is created for the updated data, we swap it in for the `Cursor` that
    `Adapter` is currently using. While you can write your own persistence code, this
    highlights why using the platform facilities, whenever possible, can be a wise
    choice.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreateLoader()`中，我们指定要加载的内容和加载的位置。我们传入刚刚创建的`ContentProvider`的URI，通过`ITEM_PROJECTION`变量（这是一个`String[]`，这里没有显示）指定我们感兴趣的字段，最后是排序顺序（我们已经指定为项目的时间戳按降序排列，这样我们就可以得到最新的项目）。`onLoadFinished()`方法是自动重新加载发生的地方。一旦为更新的数据创建了新的`Cursor`，我们就将其替换为`Adapter`当前正在使用的`Cursor`。虽然你可以编写自己的持久化代码，但这突出了为什么尽可能使用平台设施可能是一个明智的选择。
- en: 'There is one large item left to look at with regard to data handling-- `SunagoCursorAdapter`.
    Looking again at the Android Javadocs, we learn that *an* `Adapter` *object acts
    as a bridge between an* `AdapterView` *and the underlying data for that view*,
    and that `CursorAdapter` *exposes data from a* `Cursor` *to a* `ListView` *widget*.
    Often--if not in the majority of cases--a particular `ListView` will require a
    custom `CursorAdapter` to allow the underlying data to be rendered correctly.
    Sunago is no exception. To create our `Adapter`, then, we create a new class as
    follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据处理方面还有一个重要的内容要看--`SunagoCursorAdapter`。再次查看Android Javadocs，我们了解到*一个*`Adapter`*对象充当*`AdapterView`*和该视图的基础数据之间的桥梁*，而`CursorAdapter`*将*`Cursor`*中的数据暴露给*`ListView`*小部件*。通常--如果不是大多数情况--特定的`ListView`将需要一个自定义的`CursorAdapter`来正确渲染基础数据。Sunago也不例外。因此，为了创建我们的`Adapter`，我们创建一个新的类，如下所示：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is pretty standard fare. The truly interesting parts come in the view
    creation, which is one of the reasons for being for a `CursorAdapter`. When the
    `Adapter` needs to create a new view to hold the data pointed to by the cursor,
    it calls the following method. This is where we specify what the view should look
    like with the call to `LayoutInflater.inflate()`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常标准的做法。真正有趣的部分在于视图的创建，这也是`CursorAdapter`存在的原因之一。当`Adapter`需要创建一个新的视图来保存游标指向的数据时，它会调用以下方法。这是我们通过调用`LayoutInflater.inflate()`来指定视图的外观的地方。
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''ll look at our layout definition in a moment, but first, let''s take a
    look at `ViewHolder`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看一下我们的布局定义，但首先让我们来看一下`ViewHolder`：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finding views by ID can be an expensive operation, so a very common pattern
    is this `ViewHolder` approach. After the view is inflated, we immediately look
    up the fields we're interested in, and store those references in a `ViewHolder`
    instance, which is then stored as the tag on the `View`. Since views are recycled
    by the `ListView` class (meaning, they're reused as needed as you scroll through
    the data), this expensive `findViewById()` is called once and cached per `View`
    rather than once per item in the underlying data. For large datasets (and complex
    views), this can be a substantial performance boost.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过ID查找视图可能是一个昂贵的操作，因此一个非常常见的模式是使用`ViewHolder`方法。在视图被膨胀后，我们立即查找我们感兴趣的字段，并将这些引用存储在`ViewHolder`实例中，然后将其作为标签存储在`View`上。由于视图被`ListView`类回收利用（意味着，根据需要重复使用，当你滚动数据时），这昂贵的`findViewById()`只调用一次并缓存每个`View`，而不是在底层数据的每个项目中调用一次。对于大型数据集（和复杂的视图），这可能是一个重大的性能提升。
- en: In this method, we also set the size of the `ImageView` class. Android doesn't
    support setting the width of a view to a percentage via the XML markup (given
    next), so we do that manually here as we create the `View`. We get the `WindowManager`
    system service from which we get the default display's size. We multiply the display's
    width by 0.33, which will restrict the image, if any, to 1/3 of the display's
    width, and set the `ImageView`'s width to that.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们还设置了`ImageView`类的大小。Android不支持通过XML标记设置视图的宽度为百分比（如下所示），因此我们在创建`View`时手动设置。我们从中获取默认显示的大小，将显示的宽度乘以0.33，这将限制图像（如果有的话）为显示宽度的1/3，并将`ImageView`的宽度设置为这个值。
- en: So, what does the view look like for each row?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，每一行的视图是什么样子的呢？
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As the `ViewHolder` hinted, our view consists of an `ImageView` and a `TextView`,
    presented horizontally, thanks to the enclosing `LinearLayout`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`ViewHolder`所暗示的，我们的视图由一个`ImageView`和一个`TextView`组成，由于包含的`LinearLayout`，它们是水平呈现的。
- en: 'While `CursorAdapter` calls `newView()` to create a `View`, it calls `bindView()`
    to--if you can imagine--bind the `View` to a specific row in the `Cursor`. This
    is where `View` recycling comes into play. The `Adapter` has a number of `View`
    instances cached, and passes one to this method as needed. Our method looks like
    this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CursorAdapter`调用`newView()`创建一个`View`时，它调用`bindView()`来将`View`绑定到`Cursor`中的特定行。这就是`View`回收利用的地方。适配器有许多`View`实例被缓存，并根据需要传递给这个方法。我们的方法如下所示：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We start by getting the `ViewHolder` instance. As discussed previously, we'll
    use the widget references stored here to update the user interface. Next, we pull
    the image URL from the cursor. It's up to each `SocialMediaItem` to decide how
    this field is populated, but it might be a tweeted image or a photo in an Instagram
    post. If the item has one, we need to download it so that it can be displayed.
    Since this requires a network operation, and we're running on the user interface
    thread, we hand that work off to `DownloadImageTask`. If there is no image for
    this item, we need to set the bitmap for the image to `null` (otherwise, the image
    that was there the last time this view instance was used would be displayed again).
    That frees up some memory, which is always good, but we also set the `ImageView`
    class' visibility to `GONE`, which hides it from the user interface. You might
    be tempted to use `INVISIBLE`, but that only makes it invisible **while preserving
    its space in the user interface**. The end result of that would be a big blank
    square, which is not what we want. Finally, we set the text of the `TextView`
    body to the text specified for the item.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取`ViewHolder`实例。正如之前讨论的，我们将使用存储在这里的小部件引用来更新用户界面。接下来，我们从游标中提取图像URL。每个`SocialMediaItem`决定如何填充这个字段，但它可能是一条推文中的图像或者Instagram帖子中的照片。如果该项有图像，我们需要下载它以便显示。由于这需要网络操作，并且我们正在用户界面线程上运行，我们将这项工作交给`DownloadImageTask`。如果这个项目没有图像，我们需要将图像的位图设置为`null`（否则，上次使用此视图实例时显示的图像将再次显示）。这样可以释放一些内存，这总是很好的，但我们还将`ImageView`类的可见性设置为`GONE`，这将隐藏它不显示在用户界面上。你可能会想使用`INVISIBLE`，但那只会使它在用户界面上不可见**同时保留其空间**。最终，我们将`TextView`正文的文本设置为该项指定的文本。
- en: 'The image downloading is handled off-thread by an `AsyncTask`, which is as
    follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图像下载由一个`AsyncTask`在非主线程中处理，如下所示：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Android will create a background `Thread` on which to run this task. The main
    entry point for our logic is `doInBackground()`. Please refer the following snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Android将创建一个后台`Thread`来运行此任务。我们的逻辑的主要入口点是`doInBackground()`。请参考以下代码片段：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is not the most robust download code imaginable (for example, redirect
    status codes are happily ignored), but it's certainly usable. Using Java 7's `try-with-resources`,
    we create a `URL` instance on which we call `openStream()`. Assuming no `Exception`
    is thrown in either of those operations, we call `BitmapFactory.decodeStream()`
    to convert the incoming bytes into a `Bitmap`, which is what the method is expected
    to return.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是最健壮的下载代码（例如，重定向状态代码被忽略），但它肯定是可用的。使用Java 7的`try-with-resources`，我们创建一个`URL`实例，然后调用`openStream()`。假设这两个操作都没有抛出`Exception`，我们调用`BitmapFactory.decodeStream()`将传入的字节转换为`Bitmap`，这是该方法预期返回的内容。
- en: 'So, what happens to the `Bitmap` once we return it? We process that in `onPostExecute()`
    like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，一旦我们返回`Bitmap`，它会发生什么？我们在`onPostExecute()`中处理它，如下所示：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this last method, we update `ImageView` with our now downloaded `Bitmap`,
    makes it `VISIBLE`, then request that the view update itself on the screen.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的方法中，我们使用现在下载的`Bitmap`更新`ImageView`，使其可见，然后请求视图在屏幕上更新自己。
- en: So far, we've built an app that's capable of displaying `SocialMediaItem` instances,
    but we have nothing for it to show. We'll fix that now with a look at Android
    Services.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一个能够显示`SocialMediaItem`实例的应用程序，但我们没有任何内容可以显示。现在我们将通过查看Android服务来解决这个问题。
- en: Android services
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android服务
- en: 'For the desktop version of Sunago, we defined an API that would allow third-party
    developers (or ourselves) to add support for an arbitrary social network to Sunago.
    That was a great goal for the desktop, and it''s a great goal for mobile. Fortunately,
    Android provides us with a mechanism that can be used to do just that: Services.
    *A Service is an application component representing either an application''s desire
    to perform a longer-running operation while not interacting with the user or to
    supply functionality for other applications to use*. While services were designed
    for more than extensibility, we can leverage this facility to that end.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Sunago的桌面版本，我们定义了一个API，允许第三方开发者（或我们自己）为Sunago添加对任意社交网络的支持。这对于桌面来说是一个很好的目标，对于移动设备也是一个很好的目标。幸运的是，Android为我们提供了一个可以实现这一目标的机制：服务。*服务是一个应用组件，代表应用程序要执行长时间操作而不与用户交互，或者为其他应用程序提供功能*。虽然服务的设计不仅仅是为了可扩展性，但我们可以利用这个功能来实现这一目标。
- en: 'While there are a number of ways to implement and interact with services, we
    are going to bind the services to our `Activity` so that their life cycle is tied
    to that of our `Activity`, and we''ll send messages to them asynchronously. We''ll
    start by defining our class as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多实现和与服务交互的方法，我们将把服务绑定到我们的`Activity`，以便它们的生命周期与我们的`Activity`绑定，并且我们将以异步方式向它们发送消息。我们将首先定义我们的类如下：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Technically, these are the only methods required to create a service. Clearly,
    it doesn''t do much, but we''ll fix that in just a moment. Before we do that,
    we need to declare our new `Service` to Android which is done in `AndroidManifest.xml`,
    as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这些是创建服务所需的唯一方法。显然，它并没有做太多事情，但我们将在片刻之后解决这个问题。在我们这样做之前，我们需要在`AndroidManifest.xml`中声明我们的新`Service`，如下所示：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice that, in addition to the service declaration, we also specify an `IntentFilter`
    via the `intent-filter` element. We''ll use that in `MainActivity` later to find
    and bind our services. While we''re looking at our service, though, let''s look
    at this side of the binding process. We''ll need to implement these two lifecycle
    methods:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除了服务声明之外，我们还通过`intent-filter`元素指定了一个`IntentFilter`。稍后我们将在`MainActivity`中使用它来查找和绑定我们的服务。虽然我们正在查看我们的服务，但让我们也看看绑定过程的这一方面。我们需要实现这两个生命周期方法：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These preceding methods are called when the service is bound and unbound, which
    give us an opportunity to register our receiver, which may lead to the question:
    What''s that? Android provides an **Interprocess Communication** (**IPC**), but
    it is somewhat limited in that the payload size can not exceed 1 MB. Though our
    payload is only text, we can (and certainly will, based on my testing) exceed
    that. Our approach, then, will be to use asynchronous communication, via a receiver,
    and have the service persist the data via our `ContentProvider`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些先前的方法在服务绑定和解绑时被调用，这给了我们一个注册接收器的机会，这可能会引发一个问题：那是什么？Android提供了**进程间通信**（**IPC**），但它在有效载荷大小上有一定限制，不能超过1MB。虽然我们的有效载荷只是文本，但我们可以（并且根据我的测试肯定会）超过这个限制。因此，我们的方法将是通过接收器使用异步通信，并让服务通过我们的`ContentProvider`持久保存数据。
- en: 'To create a receiver, we extend `android.content.BroadcastReceiver` as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个接收器，我们扩展`android.content.BroadcastReceiver`如下：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our message scheme is very simple--Sunago sends the message `REFRESH`, and the
    service performs its work, which we have wrapped up in `TwitterUpdatesAsyncTask`.
    In `onBind()`, we register the receiver with a specific `IntentFilter` that specifies
    the `Intent` broadcasts that we're interested in. In `onUnbind()`, we unregister
    our receiver as the service is released.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的消息方案非常简单--Sunago发送消息`REFRESH`，服务执行其工作，我们已经将其封装在`TwitterUpdatesAsyncTask`中。在`onBind()`中，我们使用特定的`IntentFilter`注册接收器，指定我们感兴趣的`Intent`广播。在`onUnbind()`中，当服务被释放时，我们取消注册接收器。
- en: 'The rest of our service is in our `AsyncTask`, which is given as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务的其余部分在我们的`AsyncTask`中，如下所示：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We need to make sure that the network operation isn't performed on the user
    interface thread, so we perform the work in `AsyncTask`. We don't need any parameters
    passed into the task, so we set the `Params` and `Progress` types to `Void`. We
    are, though, interested in the `Result` type, which is `List<ContentValue>`, which
    we see reflected in both the type declaration and the return type of `execute()`.
    In `onPostExecute()`, we then issue a bulk insert on `ContentProvider` to save
    the data. In this way, we can make the newly-retrieved data available to the application
    without running afoul the 1 MB limit with `IBinder`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保网络操作不是在用户界面线程上执行，因此我们在`AsyncTask`中执行工作。我们不需要将任何参数传递给任务，因此我们将`Params`和`Progress`类型设置为`Void`。但是，我们对`Result`类型感兴趣，它是`List<ContentValue>`，我们在`execute()`的类型声明和返回类型中看到了这一点。然后在`onPostExecute()`中，我们对`ContentProvider`进行批量插入以保存数据。通过这种方式，我们可以使新检索到的数据在不违反`IBinder`的1MB限制的情况下对应用程序可用。
- en: 'With our service defined, we need now to look at how to find and bind the services.
    Looking back at `MainActivity`, we''ll finally look at a method we''ve already
    seen mentioned, `findPlugins()`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了我们的服务之后，我们现在需要看看如何找到和绑定服务。回顾一下`MainActivity`，我们最终将看到一个我们已经提到过的方法`findPlugins()`：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To find the plugins we're interested in, we create an `Intent` with a specific
    action. In this case, that action is `com.steeplesoft.sunago.intent.plugin`, which
    we've already seen in the service definition in `AndroidManifest.xml`. Using this
    `Intent`, we query `PackageManager` for all `IntentServices` matching Intent.
    Next, we iterate over the list of `ResolveInfo` instances, getting the `ServiceInfo`
    instances, and create and store a `ComponentName` representing the plugin.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到我们感兴趣的插件，我们创建一个具有特定操作的`Intent`。在这种情况下，该操作是`com.steeplesoft.sunago.intent.plugin`，我们已经在`AndroidManifest.xml`中的服务定义中看到了。使用这个`Intent`，我们查询`PackageManager`以查找与Intent匹配的所有`IntentServices`。接下来，我们遍历`ResolveInfo`实例列表，获取`ServiceInfo`实例，并创建和存储代表插件的`ComponentName`。
- en: 'The actual binding of the services is done in the following `bindPlugins()`
    method, which we call from the `onStart()` method to make sure the binding occurs
    at the appropriate time in activity''s lifecycle:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实际绑定服务是在以下`bindPlugins()`方法中完成的，我们从`onStart()`方法中调用它，以确保在活动的生命周期中适当的时间发生绑定：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For each plugin found, we create an `Intent` using the `ComponentName` we created
    earlier. Each service binding will need a `ServiceConnection` object. For that,
    we created `PluginServiceConnection`, which implements the interface. Its methods
    are empty, so we'll not look at that class here. With our `ServiceConnection`
    instance, we can now bind the service with a call to `bindService()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于找到的每个插件，我们使用我们之前创建的`ComponentName`创建一个`Intent`。每个服务绑定都需要一个`ServiceConnection`对象。为此，我们创建了`PluginServiceConnection`，它实现了该接口。它的方法是空的，所以我们不会在这里看这个类。有了我们的`ServiceConnection`实例，我们现在可以通过调用`bindService()`来绑定服务。
- en: 'Finally, to clean up as the application is closing, we need to unbind our services.
    From `onStop()`, we call this method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在应用程序关闭时进行清理，我们需要解除服务的绑定。从`onStop()`中，我们调用这个方法：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we simply loop through our `ServiceConnection` plugins, passing each to
    `unbindService()`, which will allow Android to garbage collect any services we
    may have started.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需循环遍历我们的`ServiceConnection`插件，将每个传递给`unbindService()`，这将允许Android回收我们可能启动的任何服务。
- en: 'So far, we''ve defined a service, looked it up, and bound it. But how do we
    interact with it? We''ll go the simple route, and add an option menu item. To
    do that, we modify `res/menu/main_menu.xml` as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了一个服务，查找了它，并绑定了它。但我们如何与它交互呢？我们将采用简单的方法，并添加一个选项菜单项。为此，我们修改`res/menu/main_menu.xml`如下：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To respond to the menu item being selected, we need to revisit `onOptionsItemSelected()`
    here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要响应菜单项的选择，我们需要在这里重新访问`onOptionsItemSelected()`：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `switch` block of the preceding code, we add a `case` label for `R.id.action_refresh`,
    which matches the ID of our newly added menu item in which we call the method
    `sendRefreshMessage()`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码的`switch`块中，我们为`R.id.action_refresh`添加了一个`case`标签，该标签与我们新添加的菜单项的ID相匹配，在其中调用了`sendRefreshMessage()`方法：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first method is pretty straightforward. In fact, it might not even be necessary,
    given its simplicity, but it does add semantic clarity to the consuming code,
    so I think it's a good method to add.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法非常简单。实际上，鉴于其简单性，可能甚至是不必要的，但它确实为消费代码添加了语义上的清晰度，因此我认为这是一个很好的方法。
- en: The interesting part, however, is the method `sendMessage()`. We start by creating
    an `Intent` that specifies our action, `sunago.service`. This is an arbitrary
    string that we define, and then document for any third-party consumers. This will
    help our services filter out messages that are of no interest, which is exactly
    what we did in `TwitterService.onBind()` with the call to `registerReceiver(receiver,
    new IntentFilter("sunago.service"))`. We then add the message that our app wants
    to send (`REFRESH`, in this case) as an extra on `Intent`, which we then broadcast
    via `sendBroadcast()`. From here, Android will handle delivering the message to
    our service, which is already running (since we've bound it to our `Activity`)
    and listening (as we registered a `BroadcastReceiver`).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有趣的部分是`sendMessage()`方法。我们首先创建一个指定我们动作的`Intent`，`sunago.service`。这是一个我们定义的任意字符串，然后为任何第三方消费者进行文档化。这将帮助我们的服务过滤掉没有兴趣的消息，这正是我们在`TwitterService.onBind()`中使用`registerReceiver(receiver,
    new IntentFilter("sunago.service"))`所做的。然后，我们将我们的应用程序想要发送的消息（在这种情况下是`REFRESH`）作为`Intent`的额外部分添加，然后通过`sendBroadcast()`进行广播。从这里，Android将处理将消息传递给我们的服务，该服务已经在运行（因为我们已将其绑定到我们的`Activity`）并且正在监听（因为我们注册了`BroadcastReceiver`）。
- en: Android tabs and fragments
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android选项卡和片段
- en: We've looked at quite a bit, but there is still a fair bit we haven't seen,
    such as the implementation for `TwitterClient`, as well as any details on the
    integration of networks, such as Instagram, which we saw in the last chapter.
    For the most part, `TwitterClient` is identical to what we saw in [Chapter 5](../Text/ec70a9e6-836b-4b8f-af0d-2438fd50ed1d.xhtml),
    *Sunago - A Social Media Aggregator*. The only major difference is in the use
    of the stream APIs. Some APIs are only available in certain Android versions,
    specifically, version 24, also known as Nougat. Since we're targeting Lollipop
    (SDK version 21), we are unable to use them. That aside, the internal logic and
    API usage are identical. You can see the details in the source repository. Before
    we finish, though, we need to take a look at the Twitter preferences screen, as
    there are some interesting items there.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看了很多，但还有一些我们没有看到的，比如`TwitterClient`的实现，以及任何关于网络集成的细节，比如我们在上一章中看到的Instagram。在很大程度上，`TwitterClient`与我们在[第5章](../Text/ec70a9e6-836b-4b8f-af0d-2438fd50ed1d.xhtml)中看到的
    *Sunago - A Social Media Aggregator* 是相同的。唯一的主要区别在于流API的使用。一些API仅在特定的Android版本中可用，具体来说是版本24，也被称为Nougat。由于我们的目标是Lollipop（SDK版本21），我们无法使用它们。除此之外，内部逻辑和API使用是相同的。您可以在源代码库中看到细节。不过，在我们结束之前，我们需要看一下Twitter偏好设置屏幕，因为那里有一些有趣的项目。
- en: 'We''ll start with a tab layout activity, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个选项卡布局活动开始，如下所示：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For making a tabbed interface, we need two things--`FragmentPagerAdapter` and
    `ViewPager`. The `ViewPager` is a user-interface element that actually shows the
    tabs. Think of it as `ListView` for tabs. The `FragmentPagerAdapter`, then, is
    like `CursorAdapter` for the tabs. Instead of an SQL-backed data source, though,
    `FragmentPagerAdapter` is an adapter that represents pages as Fragments. In this
    method, we create an instance of our `SectionsPagerAdapter`, and set it as the
    adapter on our `ViewPager`. We also associate the `ViewPager` element with the
    `TabLayout`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个分页界面，我们需要两样东西——`FragmentPagerAdapter`和`ViewPager`。`ViewPager`是一个实际显示选项卡的用户界面元素。把它想象成选项卡的`ListView`。然后，`FragmentPagerAdapter`就像选项卡的`CursorAdapter`。不过，与SQL支持的数据源不同，`FragmentPagerAdapter`是一个代表片段的适配器。在这种方法中，我们创建了我们的`SectionsPagerAdapter`的一个实例，并将其设置为我们的`ViewPager`上的适配器。我们还将`ViewPager`元素与`TabLayout`关联起来。
- en: '`SectionsPagerAdapter` is a simple class, and is written as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`SectionsPagerAdapter`是一个简单的类，写成如下：'
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The method `getCount()` tells the system how many tabs we support, the title
    for each tab that is returned by `getPageTitle()`, and the `Fragment` representing
    the selected tab is returned from `getItem()`. In this example, we create a `Fragment`
    instance as needed. Note, we hint at Instagram support here, but its implementation
    looks strikingly similar to the Twitter implementation, so we won't go into detail
    on that here.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`getCount()`告诉系统我们支持多少个选项卡，每个选项卡的标题由`getPageTitle()`返回，所选选项卡的`Fragment`由`getItem()`返回。在这个例子中，我们根据需要创建`Fragment`实例。请注意，我们在这里暗示支持Instagram，但其实现看起来与Twitter实现非常相似，因此我们不会在这里详细介绍。
- en: '`TwitterPreferencesFragment` looks as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwitterPreferencesFragment`如下所示：'
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Fragments have a slightly different lifecycle than an `Activity`. Here, we inflate
    the view in `onCreateView()`, then we update the user interface with the current
    state from `onStart()`. What does the view look like? That's determined by `R.layout.fragment_twitter_preferences`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 片段的生命周期与`Activity`略有不同。在这里，我们在`onCreateView()`中填充视图，然后在`onStart()`中使用当前状态更新用户界面。视图是什么样子？这由`R.layout.fragment_twitter_preferences`确定。
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In a nutshell, as you can see in the preceding code, we have a button for logging
    in and out, and a `ListView` for allowing the user to select which Twitter lists
    from which to load data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，正如您在上述代码中所看到的，我们有一个用于登录和注销的按钮，以及一个`ListView`，允许用户选择要从中加载数据的Twitter列表。
- en: 'Given the frequent use of the network for interacting with Twitter plus Android''s
    aversion to network access on the user interface thread, the code here gets a
    little complicated. We can see the start of that in `updateUI()`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到经常使用网络与Twitter进行交互以及Android对用户界面线程上的网络访问的厌恶，这里的代码变得有些复杂。我们可以在`updateUI()`中看到这一点，如下所示：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first thing that should stand out in the last code is that first line. Since
    we're updating the user interface, we have to make sure this code runs on the
    user interface thread. To make that happen, we wrap our logic in a `Runnable`,
    and pass that to the method `runOnUiThread()`. In `Runnable`, we check to see
    if the user is logged in or not. If not, we set the `prefsLayout` section's visibility
    to `GONE`, set the `Button`'s text to Login, and set its `onClick` listener to
    a `View.OnClickListener` method that executes `TwitterAuthenticateTask`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，应该引起注意的第一件事是第一行。由于我们正在更新用户界面，我们必须确保此代码在用户界面线程上运行。为了实现这一点，我们将逻辑包装在`Runnable`中，并将其传递给`runOnUiThread()`方法。在`Runnable`中，我们检查用户是否已登录。如果没有，我们将`prefsLayout`部分的可见性设置为`GONE`，将`Button`的文本设置为登录，并将其`onClick`监听器设置为执行`TwitterAuthenticateTask`的`View.OnClickListener`方法。
- en: If the user is not logged in, we do the opposite--make `prefsLayout` visible,
    set the `Button` text to Logout, set the `onClick` to an anonymous `View.OnClickListener`
    class that removes the authentication-related preferences, and recursively call
    `updateUI()` to make sure the interface is updated to reflect the logout.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户未登录，我们则相反——使`prefsLayout`可见，将`Button`文本设置为注销，将`onClick`设置为一个匿名的`View.OnClickListener`类，该类删除与身份验证相关的偏好设置，并递归调用`updateUI()`以确保界面更新以反映注销状态。
- en: '`TwitterAuthenticateTask` is another `AsyncTask` that handles authenticating
    with Twitter. To authenticate, we have to get a Twitter request token, which requires
    network access, so this must be done off of the user interface thread, thus, `AsyncTask`.
    Please refer to the following code snippet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwitterAuthenticateTask`是另一个处理与Twitter身份验证的`AsyncTask`。为了进行身份验证，我们必须获取Twitter请求令牌，这需要网络访问，因此必须在用户界面线程之外完成，因此使用`AsyncTask`。请参考以下代码片段：'
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Once we have the `RequestToken`, we show the `WebLoginActivity` from which the
    user will enter the credentials for the service. We'll look at that in the next
    code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`RequestToken`，我们就会显示`WebLoginActivity`，用户将在其中输入服务的凭据。我们将在下一段代码中看到这一点。
- en: When that activity returns, we need to check the results and respond appropriately.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当该活动返回时，我们需要检查结果并做出适当的响应。
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When we started `WebLoginActivity`, we specified that we wanted to get a result,
    and we specified an identifier, `LOGIN_REQUEST`, which is set to 1, to uniquely
    identify which `Activity` was returning the result. If `requestCode` is `LOGIN_REQUEST`,
    and the result code is `Activity.RESULT_OK` (see `WebLoginActivity` given next),
    then we have a successful response, and we need to finish the login process, for
    which we'll use another `AsyncTask`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动`WebLoginActivity`时，我们指定要获取结果，并指定一个标识符`LOGIN_REQUEST`，设置为1，以唯一标识返回结果的`Activity`。如果`requestCode`是`LOGIN_REQUEST`，并且结果代码是`Activity.RESULT_OK`（见下文给出的`WebLoginActivity`），那么我们有一个成功的响应，我们需要完成登录过程，为此我们将使用另一个`AsyncTask`。
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In `doInBackground()`, we perform the network operation. When we have a result,
    the `AccessToken`, we use that to authenticate our `TwitterClient` instance, then
    we return the token. In `onPostExecute()`, we save the `AccessToken` details to
    `SharedPreferences`. Technically, all of this could have been done in `doInBackground()`,
    but I find it helpful, especially when learning something new, not to cut corners.
    Once you're comfortable with how all of this works, you are, of course, free to
    cut corners when and where you feel comfortable doing so.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`doInBackground()`中，我们执行网络操作。当我们有了结果`AccessToken`时，我们使用它来验证我们的`TwitterClient`实例，然后返回令牌。在`onPostExecute()`中，我们将`AccessToken`的详细信息保存到`SharedPreferences`中。从技术上讲，所有这些都可以在`doInBackground()`中完成，但我发现这样做很有帮助，特别是在学习新东西时，不要走捷径。一旦你对所有这些工作原理感到满意，当你感到舒适时，当然可以随时随地走捷径。
- en: We have one last piece to look over, `WebLoginActivity`. Functionally, it is
    identical to `LoginActivity`--it presents a web view which displays the login
    page for the given network. When the login succeeds, the needed information is
    returned to the calling code. This being Android rather than JavaFX, the mechanics
    are, of course, a little different.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有最后一个部分要检查，`WebLoginActivity`。在功能上，它与`LoginActivity`是相同的——它呈现一个网页视图，显示给定网络的登录页面。当登录成功时，所需的信息将返回给调用代码。由于这是Android而不是JavaFX，因此机制当然有些不同。
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Most of this preceding code looks very much like the other `Activity` classes
    we've written. We do some basic user interface set up, then, getting a reference
    to the `Intent`, we extract the two parameters of interest--the URL of the login
    page, and the query parameter that indicates a successful login.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分前面的代码看起来非常像我们写过的其他`Activity`类。我们进行一些基本的用户界面设置，然后获取对`Intent`的引用，提取感兴趣的两个参数--登录页面的URL和指示成功登录的查询参数。
- en: 'To participate in the page loading life cycle, we extend `WebViewClient` (which
    we then attach to `WebView` in `Activity`, as seen previously). This is done as
    follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参与页面加载生命周期，我们扩展了`WebViewClient`（然后将其附加到`Activity`中的`WebView`，如前所示）。操作如下：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: While `WebViewClient` offers a myriad of life cycle events, we're only concerned
    with one right now, `onPageStarted()`, which is fired, as expected, when the page
    starts to load. By hooking in here, we can look at the URL before the related
    network activity begins. We can examine the desired URL to see if the query parameter
    of interest is present. If it is, we create a new `Intent` to pass data back to
    the caller, copy all of the query parameters to it, set the `Activity` result
    to `RESULT_OK`, and finish the `Activity`. If you look back at `onActivityResult()`,
    you should see now from where `resultCode` comes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`WebViewClient`提供了许多生命周期事件，但我们现在只关心一个，即`onPageStarted()`，当页面开始加载时会触发。通过在这里挂钩，我们可以在相关的网络活动开始之前查看URL。我们可以检查所需的URL，看看感兴趣的查询参数是否存在。如果存在，我们创建一个新的`Intent`将数据传递回调用者，将所有查询参数复制到其中，将`Activity`结果设置为`RESULT_OK`，然后完成`Activity`。如果您回顾一下`onActivityResult()`，现在应该能够看到`resultCode`来自哪里了。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With that, our application is complete. It's not a perfect application, but
    it is a complete Android application, which demonstrates a number of features
    you might need in your own app including `Activities`, services, database creation,
    content providers, messaging, and asynchronous processing. Clearly, there are
    parts of the application where the error handling could be more robust, or the
    design generalized a bit more to be more readily reusable. Doing so in this context,
    however, would obscure the basics of the application too much. Making these changes,
    then, will make a great exercise for the reader.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的应用程序就完成了。它不是一个完美的应用程序，但它是一个完整的Android应用程序，演示了您可能在自己的应用程序中需要的许多功能，包括`Activities`、服务、数据库创建、内容提供程序、消息传递和异步处理。显然，应用程序的某些部分在错误处理方面可能需要更加健壮，或者设计需要更广泛地通用化。然而，在这种情况下这样做会使应用程序的基础知识变得太过模糊。因此，对读者来说，做出这些改变将是一个很好的练习。
- en: In the next chapter, we'll take a look at a completely different type of application.
    We'll build a small utility to handle what can be a serious problem--too much
    email. This application will allow us to describe a set of rules that will delete
    or move emails. It's a simple concept, but it will allow us to work with JSON
    APIs and the `JavaMail` package. You'll learn a bit and end up with a useful little
    utility as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看一个完全不同类型的应用程序。我们将构建一个小型实用程序来处理可能是一个严重问题的事情--太多的电子邮件。这个应用程序将允许我们描述一组规则，用于删除或移动电子邮件。这是一个简单的概念，但它将允许我们使用JSON
    API和`JavaMail`包。您将学到一些知识，并最终得到一个有用的小工具。
