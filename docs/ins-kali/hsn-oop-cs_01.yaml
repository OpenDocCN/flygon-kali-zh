- en: Overview of C# as a Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#作为一种语言的概述
- en: With the introduction of modern-day programming practices, it is evident that
    developers are looking for more advanced constructs to help them to deliver the
    best software in the most effective way. Languages that evolve on top of frameworks
    are built to enhance the capabilities of the developers in a way that allows them
    to quickly build their code with less complexity so that the code is maintainable,
    yet readable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着现代编程实践的引入，显然开发人员正在寻找更先进的构造，以帮助他们以最有效的方式交付最佳软件。建立在框架之上的语言旨在增强开发人员的能力，使他们能够快速构建具有较少复杂性的代码，以便代码可维护且可读。
- en: There are many high-level object, oriented programming languages available on
    the market, but among them I would say one of the most promising is C#. The C#
    language is not new in the programming world and has existed for over a decade,
    but with the dynamic progress of the language itself creating so many newer constructs,
    it has already left some of the most widely accepted language competition behind.
    C# is an object-oriented, type-safe, general-purpose language that is built on
    top of the .NET framework that was developed by Microsoft and approved by the **European
    Computer Manufacturers Association** (**ECMA**) and the **International Standards
    Organization** (**ISO**). It is built to run on the Common Language Infrastructure
    and can interact with any other languages that are built based on the same architecture.
    Inspired by C++, the language is rich in delivering the best of breed applications
    without handling too many complexities in code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有许多高级面向对象的编程语言，但其中我认为最有前途的是C#。C#语言在编程世界中并不新，已经存在了十多年，但随着语言本身的动态进展创造了许多新的构造，它已经超越了一些最广泛接受的语言竞争。C#是一种面向对象的、类型安全的、通用的语言，它是建立在由微软开发并由**欧洲计算机制造商协会**（**ECMA**）和**国际标准化组织**（**ISO**）批准的.NET框架之上的。它是建立在公共语言基础设施上的，并且可以与基于相同架构构建的任何其他语言进行交互。受C++的启发，该语言在不处理过多代码复杂性的情况下提供了最优质的应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Evolution of C#
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#的演变
- en: Architecture of C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#的架构
- en: Fundamentals and syntax of the C# language
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#语言的基础和语法
- en: Visual Studio as an editor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio作为编辑器
- en: Writing your first program in Visual Studio
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio中编写你的第一个程序
- en: Evolution of C#
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#的演变
- en: 'C# has been one of the most dynamic languages in recent times. This language
    is open source and mostly driven by a group of software engineers, who recently
    came up with lots of major changes to enhance the language and provide features
    to handle the complexities in the languages that exist. Some of the major enhancements
    that have been put forward for the language include **Generics**, LINQ, Dynamics,
    and the async/await pattern:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: C#是近年来最具活力的语言之一。这门语言是开源的，主要由一群软件工程师推动，他们最近提出了许多重大变化，以增强语言并提供处理现有语言复杂性的功能。为该语言提出的一些主要增强功能包括泛型、LINQ、动态和异步/等待模式：
- en: '![](img/73797b91-d957-41f7-bd59-0b55cbde8a73.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73797b91-d957-41f7-bd59-0b55cbde8a73.png)'
- en: In the preceding diagram, we can see how the language has evolved from its inception
    with managed code in C# 1.0, to async programming constructs that were introduced
    in C# 5.0, to modern-day C# 8\. Before going further, let's look at some of the
    highlights of C# in its different stages of evolution.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到这门语言是如何从C# 1.0的托管代码开始演变的，到C# 5.0引入的异步编程构造，再到现代的C# 8。在继续之前，让我们看一下C#在不同演变阶段的一些亮点。
- en: Managed code
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管代码
- en: The phrase managed code came into being after Microsoft declared the .NET framework.
    Any code running in a managed environment is handled by **Common Language Runtime** (**CLR**),
    which keeps
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 托管代码这个词是在微软宣布.NET框架之后出现的。在托管环境中运行的任何代码都由**公共语言运行时**（**CLR**）处理，它保持
- en: Generics
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: Generics is a concept that was introduced with C# 2.0 and allows template type
    definition and type parameters. Generics allow the programmer to define types
    with open-ended type parameters that dramatically changed the way that programmers
    write code. The type-safety with dynamic typed generic templates improves readability,
    reusability, and code performance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是在C# 2.0中引入的概念，允许模板类型定义和类型参数。泛型允许程序员定义具有开放类型参数的类型，这从根本上改变了程序员编写代码的方式。动态类型的泛型模板提高了可读性、可重用性和代码性能。
- en: LINQ
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINQ
- en: The third installment of the C# language introduced **Language Integrated Query
    (LINQ)**, a new construct of queries that can be run over object structures. LINQ
    is very new to the programming world and gives us a glimpse of functional programming
    on top of object-oriented general programming structure. LINQ also introduced
    a bunch of new interfaces in the form of the `IQueryable` interface, which introduced
    a number of libraries that can interact with the external world using LINQ. LINQ
    was boosted with the introduction of Lambda expressions and expression trees.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言的第三个版本引入了**语言集成查询（LINQ）**，这是一种可以在对象结构上运行的新查询构造。LINQ在编程世界中非常新颖，让我们一窥面向对象通用编程结构之上的函数式编程。LINQ还引入了一堆新的接口，以`IQueryable`接口的形式，引入了许多可以使用LINQ与外部世界交互的库。Lambda表达式和表达式树的引入提升了LINQ的性能。
- en: Dynamics
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态
- en: The fourth instalment also provides a completely new construct. It introduces
    the dynamic language structure. The dynamic programming capability helps the developer
    to defer the programming calls to runtime. There is a specific syntactic sugar
    that was introduced in the language that compiles the dynamic code on the same
    runtime. The version also puts forward a number of new interfaces and classes
    that enhance its language capabilities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第四版还提供了一个全新的构造。它引入了动态语言结构。动态编程能力帮助开发人员将编程调用推迟到运行时。语言中引入了特定的语法糖，它在同一运行时编译动态代码。该版本还提出了许多增强其语言能力的新接口和类。
- en: Async/await
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步/等待
- en: With any language, threading or asynchronous programming is a pain. When dealing
    with asynchrony, the programmers have to come across many complexities that reduce
    the readability and maintainability of the code. With the async/await feature
    in the C# language, programming in an asynchronous way is as simple as synchronous
    programming. The programming has been simplified, with all of the complexities
    handled by the compiler and the framework internally.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何语言，线程或异步编程都是一种痛苦。在处理异步时，程序员必须面对许多复杂性，这些复杂性降低了代码的可读性和可维护性。有了C#语言中的async/await功能，以异步方式编程就像同步编程一样简单。编程已经简化，所有复杂性都由编译器和框架在内部处理。
- en: Compiler as a service
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器作为服务
- en: Microsoft has been working on how some parts of the source code of the compiler
    can be opened up to the world. Consequently, as a programmer, you are capable
    of querying the compiler on some of its internal work principles. C# 6.0 introduced
    a number of libraries that enable the developer to get an insight into the compiler,
    the binder, the syntax tree of the program, and so on. Although the features were
    developed for a long time as the Roslyn project, Microsoft have finally released
    it to the external world.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 微软一直在研究如何向世界开放编译器源代码的某些部分。因此，作为程序员，您可以查询编译器的一些内部工作原理。C# 6.0引入了许多库，使开发人员能够深入了解编译器、绑定器、程序的语法树等。尽管这些功能作为Roslyn项目开发了很长时间，但微软最终将其发布给外部世界。
- en: Exception filters
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常过滤器
- en: C# 6.0 is adorned with a lot of smaller features. Some of the features give the
    developers an opportunity to implement complex logic with simple code, while some
    of them enhance the overall capabilities of the language. Exception filters are
    newly introduced with this version and give a program the capability to filter
    out certain exception types. The exception filters, being a CLR construct, have
    been hidden in the language throughout its lifetime, but were finally introduced
    with C# 6.0.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6.0装饰有许多较小的功能。其中一些功能为开发人员提供了实现简单代码的复杂逻辑的机会，而另一些则增强了语言的整体能力。异常过滤器是这个版本的新功能，它使程序能够过滤出特定的异常类型。异常过滤器作为CLR构造一直隐藏在语言中，但最终在C#
    6.0中引入。
- en: C# 8 and beyond
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 8及更高版本
- en: With C# being the most dynamic language in the market, it is constantly improving.
    With the newer features, such as nullable reference types, async streams, ranges
    and indices, interface members, and many other features that came with the latest
    version of C#, they have enhanced the basic features and helped programmers to
    take advantage of these new constructs, hence making their lives easier.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着C#成为市场上最具动态性的语言，它不断改进。通过新功能，如可空引用类型、异步流、范围和索引、接口成员等，以及最新版本的C#带来的许多其他功能，它增强了基本功能，并帮助程序员利用这些新构造，从而使他们的生活更轻松。
- en: Note that, during the language's evolution, the .NET framework was also made
    open source. You can find the source code of the .NET framework at the following
    link: [https://referencesource.microsoft.com/](https://referencesource.microsoft.com/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在语言的演变过程中，.NET框架也已开源。您可以在以下链接找到.NET框架的源代码：[https://referencesource.microsoft.com/](https://referencesource.microsoft.com/)。
- en: Architecture of .NET
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET架构
- en: Even though it is a decade old, the .NET framework is still well-built and makes
    sure to make it tiered, moduler, and hierarchical. Each tier provides specific
    functionalities to the user—some in terms of security and some in terms of language
    capabilities. The tiers produce a layer of abstraction to the end users and hide
    most of the complexities of the native operating system as much as possible. The
    .NET framework is partitioned into modules, with each of them having their own
    distinct responsibilities. The higher tiers request specific capabilities from
    the lower tiers and hence it is hierarchical.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它已有十年历史，但.NET框架仍然构建良好，并确保将其分层、模块化和分级。每个层提供特定的功能给用户，有些是安全性方面的，有些是语言能力方面的。这些层为最终用户提供了一层抽象，并尽可能隐藏本机操作系统的大部分复杂性。.NET框架被分成模块，每个模块都有自己独特的责任。较高层从较低层请求特定功能，因此它是分级的。
- en: 'Let''s look at a diagram of the .NET architecture:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下.NET架构的图表：
- en: '![](img/015b47d1-2a67-40d8-8ef0-348aee4382c1.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/015b47d1-2a67-40d8-8ef0-348aee4382c1.png)'
- en: The preceding diagram depicts how the .NET framework architecture is laid out.
    On its lowest level, it is the operating system that interacts with the kernel
    APIs that are present in the operating system. The Common Language Infrastructure
    connects with the CLR, which provides services that monitor each code execution
    and managed memory, handles exceptions, and ensures that the application behaves
    as intended. Another important goal of the infrastructure is language inter-operability.
    The common language runtime is yet again abstracted with the .NET class libraries.
    This layer holds the binaries that the language is built on, and all of the compilers
    built on top of the libraries provide the same compiled code so that the CLR can
    understand the code and interact easily with one another.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上图描述了.NET框架架构的布局。在最低级别上，它是与操作系统交互的操作系统，该操作系统中存在与操作系统中的内核API交互的操作系统。公共语言基础设施与CLR连接，提供监视每个代码执行和管理内存、处理异常以及确保应用程序行为符合预期的服务。基础设施的另一个重要目标是语言互操作性。公共语言运行时再次通过.NET类库进行抽象。该层保存了语言构建的二进制文件，所有构建在库之上的编译器提供相同的编译代码，以便CLR可以理解代码并轻松相互交互。
- en: Before going further, let's quickly look at some of the key aspects on which
    languages are built on the .NET framework.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们快速看一下构建在.NET框架上的语言的一些关键方面。
- en: Common Language Runtime
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共语言运行时
- en: The CLR provides an interfacing between the underlying unmanaged infrastructure
    with the managed environment. This provides all of the basic functionalities of
    the managed environment in the form of garbage collection, security, and interoperability.
    The CLR is formed with the just-in-time compiler, which compiles the assembly
    code that's produced with the specific compilers to the native calls. CLR is the
    most important portion of the .NET architecture.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: CLR提供了底层未管理基础设施与托管环境之间的接口。这以垃圾回收、安全性和互操作性的形式提供了托管环境的所有基本功能。CLR由即时编译器组成，该编译器将使用特定编译器生成的程序集代码编译为本机调用。CLR是.NET架构中最重要的部分。
- en: Common Type System
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共类型系统
- en: As there is a layer of abstraction between the language and the framework, it
    is evident that each of the language literals are mapped to specific CLR types.
    For instance, the integer of VB.NET is the same as the int of C#, as both of them
    point to the same type, System.Int32\. It is always preferred to use language
    types since the compiler takes care of the mapping of types. The CTS system is
    built as a hierarchy of types with `System.Object` at its apex. The **Common Type
    System** (**CTS**) is divided into two kinds, one of which is value types, which
    are primitives that are derived from `System.ValueTypes`, while anything other
    than that is a reference type. The value types are treated differently to the
    reference types. This is because while allocation of memory value types are created
    on a thread stack during execution, reference types are always created on the
    heap.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于语言和框架之间存在一层抽象，因此很明显，每种语言文字都映射到特定的CLR类型。例如，VB.NET的整数与C#的整数相同，因为它们都指向相同的类型System.Int32。始终建议使用语言类型，因为编译器会处理类型的映射。CTS系统构建为`System.Object`位于其顶点的类型层次结构。**公共类型系统**（**CTS**）分为两种类型，一种是值类型，它们是从`System.ValueTypes`派生的原始类型，而其他任何类型都是引用类型。值类型与引用类型的处理方式不同。这是因为在分配内存时，值类型在执行期间在线程堆栈上创建，而引用类型始终在堆上创建。
- en: .NET framework class libraries
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET框架类库
- en: The framework class library lies in-between the language and the CLR, and therefore
    any type that's present in the framework is exposed to the language you code.
    The .NET framework is formed with a good number of classes and structures, exposing
    never-ending functionalities that you, as a programmer, can benefit from. The
    class libraries are stored in the form of binaries that can be referenced directly
    from your program code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 框架类库位于语言和CLR之间，因此框架中存在的任何类型都暴露给您编写的语言。.NET框架由大量类和结构组成，提供无穷尽的功能，您作为程序员可以从中受益。类库以可以直接从程序代码中引用的二进制形式存储。
- en: Just-in-time compiler
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即时编译器
- en: .NET languages are compiled twice. During the first form of compilation, the
    high-level language is converted into a **Microsoft Intermediate Language** (**MSIL**),
    which can be understood by the CLR, while the MSIL is again compiled during runtime
    when the program is executed. The JIT works inside the program runtime and periodically
    compiles the code that is expected to be required during execution.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: .NET语言被编译两次。在第一种编译形式中，高级语言被转换为**Microsoft中间语言**（**MSIL**），CLR可以理解，而在程序执行时，MSIL再次被编译。JIT在程序运行时内部工作，并定期编译预计在执行期间需要的代码。
- en: Fundamentals and syntax of C# language
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#语言的基本原理和语法
- en: 'Being a high-level language, C# is adorned with a lot of newer and updated
    syntax, which helps the programmer to write code efficiently. As we mentioned
    earlier, the type system that''s supported by the language is divided into two
    types:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种高级语言，C#装饰有许多更新和更新的语法，这有助于程序员高效地编写代码。正如我们之前提到的，语言支持的类型系统分为两种类型：
- en: Value types
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型
- en: Reference types
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型
- en: The value types are generally primitive types that are stored in the stack during
    local execution for faster allocation and deallocation of memory. The value types
    are mostly used during the development of code and, consequently, this forms the
    major spectrum of the code altogether.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型通常是存储在堆栈中的原始类型，用于本地执行，以便更快地分配和释放内存。值类型在代码开发过程中大多被使用，因此构成了整个代码的主要范围。
- en: Data types
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'The basic data types of C# are divided into the following categories:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: C#的基本数据类型分为以下几类：
- en: Boolean type: `bool`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔类型：`bool`
- en: Character type: `char`
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符类型：`char`
- en: 'Integer types: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, and `ulong`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数类型：`sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`和`ulong`
- en: 'Floating-point types: `float` and `double`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点类型：`float`和`double`
- en: 'Decimal precision: `decimal`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小数精度：`decimal`
- en: 'String: `string`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：`string`
- en: 'Object type: `object`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象类型：`object`
- en: These are primitive data types. These data types are embedded in the C# programming
    language.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是原始数据类型。这些数据类型嵌入在C#编程语言中。
- en: Nullable types
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可空类型
- en: 'The primitive types or value types are not nullable in C#. Consequently, there
    is always a requirement for the developer to make the type nullable, as a developer
    might need to identify whether the value is provided explicitly or not. The newest
    version of .NET provides nullable types:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，原始类型或值类型是不可空的。因此，开发人员总是需要将类型设置为可空，因为开发人员可能需要确定值是否是显式提供的。最新版本的.NET提供了可空类型：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Both lines in the preceding example define the nullable variable, while the
    second line is just a shortcut of the first declaration. When the value is null,
    the `HasValue` property will return `false`. This will ensure that you can detect
    whether the variable is explicitly specified as a value or not.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，两行都定义了可空变量，而第二行只是第一次声明的快捷方式。当值为null时，`HasValue`属性将返回`false`。这将确保您可以检测变量是否显式指定为值。
- en: Literals
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文字
- en: Literals are also an important part of any program. C# language gives the developer
    different kinds of options that allow the programmer to specify literals in code.
    Let's take a look at the different types of literals that are supported.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 文字也是任何程序的重要部分。C#语言为开发人员提供了不同种类的选项，允许程序员在代码中指定文字。让我们看看支持的不同类型的文字。
- en: Boolean
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔
- en: 'Boolean literals are defined in the form of `true` or `false`. No other values
    except `true` and `false` can be assigned in the Boolean type:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔文字以`true`或`false`的形式定义。除了`true`和`false`之外，布尔类型不能分配其他值：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The default value of a Boolean type is `false`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型的默认值是`false`。
- en: Integer
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数
- en: 'An integer is a number that can have a plus (+) or minus (-) sign as a prefix,
    but this is optional. If no sign is given, it is considered as positive. You can
    define numeric literals in int, long, or hexadecimal form:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 整数是一个可以有加号(+)或减号(-)作为前缀的数字，但这是可选的。如果没有给出符号，则被视为正数。您可以以int、long或十六进制形式定义数字文字：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see that the first literal, `-16`, is a literal that's been specified
    in an integer variable, while the same value is assigned to an integer using a
    hexadecimal literal. The long variable is assigned a value with an `L` suffix.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，第一个文字`-16`是指定为整数变量的文字，而相同的值是使用十六进制文字分配给整数的。长变量被分配了一个带有`L`后缀的值。
- en: Real
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实
- en: 'Real values are sequences of digits with a positive or negative sign, like
    integers. This also makes it possible to specify fraction values:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实数是带有正负号的数字序列，如整数。这也使得可以指定分数值：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the literal in the last line, `12.5`, is `double` by default,
    hence it needed to be assigned to a double variable, while the first two lines
    specify the literal in float types. You can also specify `d` or `D` as a suffix
    to define a `double`, like `f` or `F` for `float` and `m` for decimal.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，最后一行中的文字`12.5`默认为`double`，因此需要分配给double变量，而前两行指定了浮点类型中的文字。您还可以指定`d`或`D`作为后缀来定义`double`，例如`f`或`F`用于`float`和`m`用于decimal。
- en: Character
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符
- en: 'Character literals need to be kept inside a single quote. The value of the
    literal can be as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 字符文字需要保留在单引号内。文字的值可以如下：
- en: A character, for example, `c`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符，例如，`c`
- en: A character code, for example, `\u0063`
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符代码，例如，`\u0063`
- en: An escape character, for example, `\\` (the forward slash is an escape character)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转义字符，例如，`\\`（反斜杠是一个转义字符）
- en: String
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'A string is a sequence of characters. In C#, a string is represented by double
    quotation marks. There are different ways a string can be created in C#. Let''s
    look at the different ways of creating a string in C#:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一系列字符。在C#中，字符串由双引号表示。在C#中有不同的创建字符串的方式。让我们看看在C#中创建字符串的不同方式：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `@` character can be placed as a prefix before a string to take the string
    as it is, without worrying about any escape characters. It is called a verbatim
    string. The `$` character is used as a prefix for string interpolation. In case
    your string literal is preceded with the `$` sign, the variables are automatically
    replaced with values if they're placed within `{ }` brackets.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`@`字符可以放在字符串前面作为前缀，以便将字符串作为原样处理，而不必担心任何转义字符。它被称为原始字符串。`$`字符用作字符串插值的前缀。如果您的字符串文字以`$`符号开头，则如果它们放在`{
    }`括号内，变量将自动替换为值。'
- en: Programming syntax – conditions
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程语法-条件
- en: 'Conditions are one of the most common building blocks of any program. A program
    cannot have single dimensions; comparison, jumps, and breaks are the most common
    forms of practice in C#. There are three types of conditions available:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 条件是任何程序的最常见构建块之一。程序不能只有单个维度；比较、跳转和中断是C#中最常见的练习形式。有三种类型的条件可用：
- en: '`if...else`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if...else`'
- en: '`switch-case`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch-case`'
- en: '`goto` (lumps without condition)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goto`（无条件lumps）'
- en: If-else construct
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: If-else结构
- en: 'The most commonly used conditional statement is the if-else construct. The
    building block of the if-else structure contains an `if` keyword, followed by
    a Boolean expression and a set of curly brackets to specify the steps to execute.
    Optionally, there could be an  `else` keyword, followed by curly brackets for
    the code to execute when the `if` block is `false`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的条件语句是if-else结构。if-else结构的基本组成部分包含一个`if`关键字，后面跟着一个布尔表达式和一组花括号来指定要执行的步骤。可选地，可能会有一个`else`关键字，后面跟着花括号，用于在`if`块为`false`时执行的代码：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The if-else construct can also have an else-if statement to specify multiple
    criteria for execution.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: if-else结构也可以有一个else-if语句来指定多个执行条件。
- en: Switch-case construct
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Switch-case结构
- en: 'Switch-case, on the other hand, is almost similar to the `if` statement; in
    this statement, the cases will determine the execution step. In the case of `switch`,
    this always falls in a discrete set of values, and hence, those values can be
    set up:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，switch-case几乎与`if`语句类似；在这个语句中，case将确定执行步骤。在`switch`的情况下，这总是落在一组离散的值中，因此，这些值可以被设置：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The switch case automatically picks the correct case statement, depending on
    the value, and executes the steps defined inside the block. A case need to be
    concluded with a break statement.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: switch case会自动选择正确的case语句，取决于值，并执行块内定义的步骤。case需要以break语句结束。
- en: goto statements
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: goto语句
- en: 'Even though they are less popular and it is not advisable to use them, `goto`
    statements are used for unconditional jumps in the language and they are widely
    used by the language itself. As a developer, you can use a `goto` statement to
    jump to any location of your program with the context you have:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们不太受欢迎，也不建议使用，`goto`语句用于语言中的无条件跳转，并且被语言本身广泛使用。作为开发人员，你可以使用`goto`语句跳转到程序中的任何位置：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `goto` statement directly jumps to the location specified without any condition
    or criteria.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`语句直接跳转到指定的位置，没有任何条件或标准。'
- en: Programming syntax – loops
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程语法 - 循环
- en: 'For a repetitive task during execution, loops play a vital role. Loops allow
    the programmer to define a criteria in which the loop will end or until the loop
    should execute, depending on the type of loop. There are four types of loops:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于执行过程中的重复任务，循环发挥着至关重要的作用。循环允许程序员定义循环将在何时结束，或者循环应该执行到何时的条件，具体取决于循环的类型。有四种类型的循环：
- en: While
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当
- en: Do-while
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: do-while
- en: For
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于
- en: Foreach
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Foreach
- en: The while construct
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: while结构
- en: 'A loop is used in the programming world to make a sequence of execution steps
    repeat itself until the condition is met. The `while` loop is one of the building
    blocks of the C# programming architecture and is used to loop through the body
    mentioned in curly brackets until the condition mentioned in the `while` criteria
    is `true`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中，循环用于使一系列执行步骤重复，直到满足条件。`while`循环是C#编程架构的基本组成部分之一，用于循环执行大括号中提到的循环体，直到`while`条件中提到的条件为`true`：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The condition mentioned in the loop should evaluate to `true` to execute the
    loop for the next iteration.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中提到的条件应该评估为`true`，以执行下一次迭代的循环。
- en: The do-while construct
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: do-while结构
- en: 'The `do...while` construct checks the condition after executing the step once.
    Even though the `do...while` loop is similar to the `while` loop, the only difference
    between a `do...while` loop and a `while` loop is that a `do...while` loop will
    execute the body at least once, even if the criteria is `false`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`do...while`结构在执行一次步骤后检查条件。尽管`do...while`循环类似于`while`循环，但`do...while`循环和`while`循环之间唯一的区别是，`do...while`循环将至少执行一次循环体，即使条件为`false`：'
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The for construct
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for结构
- en: 'The most popular loop in the language is the `for` loop, which handles complications
    by maintaining the number of executions of the loop efficiently within the block
    itself:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 语言中最流行的循环是`for`循环，它通过在块内部高效地维护循环的执行次数来处理复杂性：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `for` loop has a few sections in the criteria. Each of these is separated
    by a semicolon (`;`). The first portion defines the index variable, which is executed
    once before executing the loop. The second portion is the condition that is executed
    in every iteration of the `for` loop. If the condition becomes `false`, the `for`
    loop doesn't continue its execution and stops. The third portion is also executed
    after every execution of the loop body and it manipulates the variable that was
    used in the `for` loop initialization and condition.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环在条件中有几个部分。每个部分都用分号(`;`)分隔。第一部分定义了索引变量，在执行循环之前执行一次。第二部分是在每次`for`循环迭代时执行的条件。如果条件变为`false`，`for`循环将停止执行。第三部分也在每次执行循环体后执行，并且操作了在`for`循环初始化和条件中使用的变量。'
- en: The foreach construct
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: foreach结构
- en: 'The `foreach` loops are new to the language and are used to iterate over a
    sequence of objects. Even though this is purely syntactic sugar in the language,
    the `foreach` loop is widely used when dealing with collections. The `foreach`
    loop inherently uses an `IEnumerable<object>` interface and should only be used
    for objects implementing this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`循环是语言中的新功能，用于迭代对象序列。尽管这在语言中纯粹是语法糖，但在处理集合时，`foreach`循环被广泛使用。`foreach`循环内部使用`IEnumerable<object>`接口，并且应该只用于实现了该接口的对象：'
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Contextual – break and continue statements
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文 - break和continue语句
- en: If you are working with loops, it is very important to understand two more contextual
    keywords that make it possible to interact with loops.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用循环，理解另外两个上下文关键字是非常重要的，它们使得与循环进行交互成为可能。
- en: Break
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Break
- en: This allows the developer to break the loop and take the context out of the
    loop, even though the criteria is still valid. The programming contextual keyword, `break`,
    is used as a bypass to break the loop in which it is getting executed. The `break`
    statement is valid inside loops and switch statements.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许开发人员在条件仍然有效的情况下中断循环并将上下文带出循环。编程上下文关键字`break`用作绕过正在执行的循环的循环。`break`语句在循环和switch语句中有效。
- en: Continue
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Continue
- en: This is used to invoke the next iteration. The contextual keyword allows the
    developer to continue to the next step without executing any further code in the
    block.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于调用下一次迭代。上下文关键字允许开发人员继续到下一步，而不执行块中的任何其他代码。
- en: 'Now, let''s look at how we can use both of these contextual statements in our
    program:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在我们的程序中使用这两个上下文语句：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code will skip execution of the body for the iteration value, `2`,
    because of the `continue` statement. The loop will execute until the value of
    `x` is `5` because of the `break` statement.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将跳过迭代值为`2`的循环体的执行，因为有`continue`语句。循环将一直执行直到`x`的值为`5`，因为有`break`语句。
- en: Writing your first C# program in a console application
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在控制台应用程序中编写您的第一个C#程序
- en: As you are now aware of the fundamentals and basics of the C# language, literals,
    loops, conditions, and so on, I think it is time to see a C# code example. So,
    let's start this section by writing a simple console application, compiling it,
    and running it using the C# compiler.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了C#语言的基本知识和基础知识，文字，循环，条件等，我认为是时候看一个C#代码示例了。所以，让我们通过编写一个简单的控制台应用程序，编译它，并使用C#编译器运行它来开始本节。
- en: 'Open any notepad application that you have in your computer and type in the
    following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您计算机上的任何记事本应用程序，并输入以下代码：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code is a classic example of calculating the sum of all of the
    digits of a number. It takes a number as input using the `Console.ReadLine()`
    function, parses it, and stores it into a variable, `num`, loops through while
    the number is `0`, and takes modulus by `10` to get the reminder of the division,
    which is then summed up to produce the result.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是计算数字所有数字之和的经典示例。它使用`Console.ReadLine()`函数作为输入，解析并将其存储到变量`num`中，循环遍历直到数字为`0`，并取模`10`以获得除法的余数，然后将其相加以产生结果。
- en: You can see there is a `using` statement at the top of the code block, which
    ensures that `Console.ReadLine()` and `Console.WriteLine()` can be called. `System`
    is a namespace from the code, which enables the program to call the classes defined
    inside it without specifying the full namespace path of the class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到代码块顶部有一个`using`语句，它确保可以调用`Console.ReadLine()`和`Console.WriteLine()`。`System`是代码中的一个命名空间，它使程序能够调用其中定义的类，而无需指定类的完整命名空间路径。
- en: Let's save the class as `program.cs`.  Now, open the console and move it to
    the location where you have saved the code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将类保存为`program.cs`。现在，打开控制台并将其移动到您保存代码的位置。
- en: 'To compile the code, we can use the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译代码，我们可以使用以下命令：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The compilation will produce something like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 编译将产生类似于这样的东西：
- en: '![](img/2f54ec56-f834-44ce-85f9-aaeb2570861c.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f54ec56-f834-44ce-85f9-aaeb2570861c.png)'
- en: 'The compilation will produce `program.exe`. If you run this, it will take the
    number as input and produce the result:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 编译将产生`program.exe`。如果您运行此程序，它将接受数字作为输入并产生结果：
- en: '![](img/19038024-805d-4d63-bfab-9ebfef4760a2.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19038024-805d-4d63-bfab-9ebfef4760a2.png)'
- en: You can see that the code is being executed in the console window.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到代码正在控制台窗口中执行。
- en: If we dissect how the code is being executed further, we can see that the .NET
    framework provides the `csc` compiler, an executable that is capable of compiling
    my C# code into a managed executable. The compiler produces an executable with
    MSIL as its content, and then, when the executable is being executed, the .NET
    framework invokes an executable and uses JIT to compile it further so that it
    can interact with the input/output devices.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进一步分析代码的执行方式，我们可以看到.NET框架提供了`csc`编译器，这是一个能够将我的C#代码编译成托管可执行文件的可执行文件。编译器生成一个包含MSIL的可执行文件，然后在执行可执行文件时，.NET框架调用一个可执行文件，并使用JIT进一步编译它，以便与输入/输出设备进行交互。
- en: The `csc` compiler provides various command-line hooks, which can be used further
    to add **dynamic link library** (**dll**) references to the program, target the
    output as dll, and much more. You can find the full functional document at the
    following link: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/listed-alphabetically](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/listed-alphabetically).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`csc`编译器提供了各种命令行钩子，可以进一步用于向程序添加**动态链接库**（**dll**）引用，将输出目标设置为dll等。您可以在以下链接找到完整的功能文档：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/listed-alphabetically](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/listed-alphabetically)。'
- en: Visual Studio as an editor
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio作为编辑器
- en: Microsoft has created a number of improvement toolsets that help in creating,
    debugging, and running programs. One of these tools is called **Visual Studio**
    (**VS**). Microsoft VS is a Development Environment that works with Microsoft
    languages. It is a tool that developers can rely on so that they can work easily
    with Microsoft technologies. VS has been around for quite some time, but the new
    VS has been totally redesigned and was released as VS 2019 to support .NET languages.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 微软创建了许多改进工具集，帮助创建，调试和运行程序。其中一个工具就是**Visual Studio**（**VS**）。微软VS是一个与微软语言一起工作的开发环境。这是开发人员可以依赖的工具，以便他们可以轻松地使用微软技术。VS已经存在了相当长的时间，但新的VS已经完全重新设计，并作为VS
    2019发布，以支持.NET语言。
- en: Evolution of Visual Studio
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio的演变
- en: As time passed, Microsoft released newer versions of VS with more advantages
    and enhancements. Being a plugin host that hosts a number of services as plug-in,
    VS has evolved with a lot of tools and extensions. It has been the core part of
    every developer's activity. VS has been used by a large number of people who are
    not a part of the developer community, because they have found this IDE beneficial
    for editing and managing documents.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，微软发布了更多优势和增强功能的新版本VS。作为托管许多服务作为插件的插件主机，VS已经发展出许多工具和扩展。它一直是每个开发人员活动的核心部分。VS已被许多不属于开发人员社区的人使用，因为他们发现这个IDE对编辑和管理文档很有益。
- en: Types of Visual Studio
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio的类型
- en: Microsoft has introduced different types or editions of VS. The difference between
    these editions are features and pricing. Among the editions, one is free, while
    others you have to buy. Consequently, knowing which edition provides which features
    and which edition is better for which type of work will make it easier for a developer
    to choose the edition right.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 微软推出了不同类型或版本的VS。这些版本之间的区别在于功能和定价。其中一个版本是免费的，而其他版本需要购买。因此，了解哪个版本提供了哪些功能，哪个版本更适合哪种类型的工作，将使开发人员更容易选择合适的版本。
- en: Let's look at a comparison between all versions of VS.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来比较一下所有版本的VS。
- en: Visual Studio Community
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Community
- en: VS Community edition is the free edition. This edition doesn't have some advanced
    features that are available in the others, but this Community edition is perfectly
    fine for building small/mid-sized projects. This is especially useful for a person
    who wants to explore the C# programming language, since they can download this
    edition for free and start building applications.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: VS社区版是免费版。这个版本没有一些其他版本中可用的高级功能，但这个社区版完全适用于构建小型/中型项目。这对于想要探索C#编程语言的人特别有用，因为他们可以免费下载这个版本并开始构建应用程序。
- en: Visual Studio Professional
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Professional
- en: This version of VS is for your own development, with important debugging tools
    and all of the commonly used developer tools. So, you can use the IDE as your
    primary orientation and then you can go ahead!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的VS是为您自己的开发而设计的，具有重要的调试工具和所有常用的开发人员工具。因此，您可以将IDE用作您的主要方向，然后可以继续！
- en: Visual Studio Enterprise
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Enterprise
- en: VS Enterprise edition is for enterprises that require commercial levels of usage
    of the IDE. It supports special tools for testing, debugging, and so on. It also
    discovers common coding errors, generates test data, and much more.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: VS企业版是为需要商业级IDE使用的企业而设计的。它支持用于测试、调试等的特殊工具。它还可以发现常见的编码错误，生成测试数据等等。
- en: Visual Studio Code
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: VS Code is a small, open source tool that is not a full IDE, but a simple code
    editor that has been developed by Microsoft. This editor is very lightweight and
    platform-independent. VS Code doesn't come with most of the features that the
    VS IDE has, but has sufficient features for developing and debugging an application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code是一个小型的开源工具，不是完整的IDE，而是由微软开发的简单代码编辑器。这个编辑器非常轻量级且与平台无关。VS Code没有大多数VS IDE具有的功能，但具有足够的功能来开发和调试应用程序。
- en: For this book, we are going to use VS Community in most of our cases, but you
    can install any version that you wish. You can download the Community edition
    free of cost at the following link: [https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书，我们将在大多数情况下使用VS社区版，但您可以安装任何您希望的版本。您可以免费下载社区版，网址如下：[https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/)。
- en: Introduction to the Visual Studio IDE
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio IDE简介
- en: After you first install VS, the VS installer will give you a few options regarding
    workloads, which means the type of applications you are going to develop using
    this IDE. For this book, we will only be creating C# console applications, so
    you can choose that option if you want. Now, let's start the VS IDE. After loading
    the IDE, it'll show you a start page with multiple options. Choose the option
    to create a new project.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 安装VS后，VS安装程序将为您提供关于工作负载的几个选项，这意味着您将使用此IDE开发的应用程序类型。对于本书，我们只会创建C#控制台应用程序，因此您可以选择该选项。现在，让我们开始VS
    IDE。加载IDE后，它将显示一个带有多个选项的起始页面。选择创建新项目的选项。
- en: New Project
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新项目
- en: 'After you choose new project, the New Project dialog box will appear. In this
    dialog box, a number of options will be available based on the packages that are
    currently installed with the IDE, as shown in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 选择新项目后，将出现新项目对话框。在此对话框中，将基于当前与IDE一起安装的软件包提供一些选项，如下图所示：
- en: '![](img/5e1316ae-e768-453e-b989-0eadeab4ed8d.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e1316ae-e768-453e-b989-0eadeab4ed8d.png)'
- en: In the preceding screenshot, the left-hand side groups are the types of templates
    that you can choose from. Here, I have chosen Windows Desktop and, from the middle
    window, I have selected Console App (.NET framework) to create my application.
    The bottom of the screen allows you to name the project and choose the location
    to store the project files. There are two checkboxes available, one of which says
    Create directory for solution when selected (by default, this remains selected).
    This creates a directory below the chosen path and places the files inside it, otherwise
    it will create files just inside the folder.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，左侧的分组是您可以选择的模板类型。在这里，我选择了Windows桌面，并从中间窗口中选择了控制台应用程序(.NET框架)来创建我的应用程序。屏幕底部允许您命名项目并选择存储项目文件的位置。有两个复选框可用，其中一个说“选择时创建解决方案目录”（默认情况下，此复选框保持选中状态）。这将在所选路径下创建一个目录并将文件放入其中，否则它将在文件夹内部创建文件。
- en: Use Search Installed Template to search for any template by its name at the
    right corner of the dialog box if you do not find your template. Since more than
    one framework can exist in one PC, the New Project dialog will allow you to choose
    a framework; you need to use this while deploying the application. It shows .NET
    framework 4.6.1 by default as the framework for the project, but you can change
    to any framework by selecting one from the drop-down menu.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“搜索已安装的模板”在对话框的右上角按名称搜索任何模板，如果找不到您的模板。由于一台PC上可以存在多个框架，新项目对话框将允许您选择一个框架；在部署应用程序时需要使用它。默认情况下，它显示.NET框架4.6.1作为项目的框架，但您可以通过从下拉菜单中选择一个来更改为任何框架。
- en: 'Finally, click OK to create the project with the default files:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，单击“确定”以使用默认文件创建项目：
- en: '![](img/354b45b5-260c-4e91-ae13-360897be8c3c.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/354b45b5-260c-4e91-ae13-360897be8c3c.png)'
- en: The preceding screenshot shows what a basic IDE looks like after the project
    is created. We can also see each section of IDE. The main IDE is composed of many
    tool windows. You can see some tool windows on all sides of the screen. The Task
    List window is at the bottom of the screen. The main IDE workspace is in the middle
    and forms the working area of the IDE. The workspace can be zoomed into by using
    the Zoom control in the corner of the screen. The IDE search box at the top of
    the screen gives you insight into finding options inside the IDE more elegantly
    and easily. We will now divide the whole IDE into those parts and explore the
    IDE.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了项目创建后基本IDE的外观。我们还可以看到IDE的每个部分。主要IDE由许多工具窗口组成。您可以在屏幕的各个部分看到一些工具窗口。任务列表窗口位于屏幕底部。主要IDE工作区位于中间，形成了IDE的工作区域。可以使用屏幕角落的缩放控件放大工作区。屏幕顶部的IDE搜索框可以帮助您更优雅、更轻松地找到IDE内部的选项。现在我们将整个IDE分成这些部分，并探索IDE。
- en: Solution Explorer
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案资源管理器
- en: The folders and files are hierarchically depicted in the Solution Explorer.
    Solution Explorer is the main window and lists the entire solution that is loaded
    to the IDE. This gives you a view of projects and files that have a solution for
    easy navigation in the form of a tree. The outer node of the Solution Explorer
    is itself a solution, then the projects, and then the files and folders. The Solution
    Explorer supports loading folders inside the solution and storing documents in
    the first level, too. The project that is set as startup is marked in bold.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹和文件在解决方案资源管理器中按层次结构显示。解决方案资源管理器是主窗口，列出了加载到IDE中的整个解决方案。这使您可以以树的形式轻松导航查看具有解决方案的项目和文件。解决方案资源管理器的外部节点本身就是一个解决方案，然后是项目，然后是文件和文件夹。解决方案资源管理器支持加载解决方案中的文件夹，并在第一级存储文档。设置为启动的项目以粗体标记。
- en: 'There are many buttons present at the top of the Solution Explorer called toolbar
    buttons. Based on the file that''s selected in the tree, the toolbar buttons will
    be enabled or disabled. Let''s look at each of them individually:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案资源管理器顶部有许多称为工具栏按钮的按钮。根据树中所选文件，工具栏按钮将启用或禁用。让我们逐个查看它们：
- en: '**Collapse All button:** This button allows you to collapse all of the nodes
    below the node that''s currently selected. While working with a big solution,
    it is often necessary to collapse a portion of the tree completely. You can use
    this feature without collapsing each node manually.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折叠所有按钮：此按钮允许您折叠当前选定节点下方的所有节点。在处理大型解决方案时，通常需要完全折叠部分树。您可以使用此功能而无需手动折叠每个节点。
- en: '**Properties:** As a shortcut to the Properties window, you can select this
    button to open the Properties window and load the metadata associated with the
    currently selected node.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性：作为打开属性窗口的快捷方式，您可以选择此按钮以打开属性窗口并加载与当前选择节点相关联的元数据。
- en: '**Show all files:** A solution is generally mapped to a Folder structure on
    a directory in the filesystem. The files that are included in the solution are
    only shown on the Solution tree. Showing all files allows you to toggle between
    viewing all files in the directory and only the files that have been added to
    the solution.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有文件：解决方案通常映射到文件系统中目录的文件夹结构。解决方案中包含的文件仅显示在解决方案树上。显示所有文件允许您在查看目录中的所有文件和仅添加到解决方案中的文件之间切换。
- en: '**Refresh:** This refreshes the state of files in the current solution. The
    Refresh button also checks every file from the filesystem and shows its status
    accordingly (if any).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新：刷新当前解决方案中文件的状态。刷新按钮还会检查文件系统中的每个文件，并根据需要显示其状态。
- en: '**View Class Diagram:** The class diagram is the logical tree of namespaces
    and classes rather than the files in the filesystem. When you select this option,
    VS launches the class diagram with all of the details of its properties, methods,
    and so on. The class diagram is useful for viewing all of the classes and their
    associations individually.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看类图：类图是命名空间和类的逻辑树，而不是文件系统中的文件。选择此选项时，VS会启动具有其属性、方法等所有详细信息的类图。类图对于单独查看所有类及其关联非常有用。
- en: '**View Code:** When you select a code file, the View Code button appears, which
    loads the code file associated with the current selection. For instance, when
    you select a Windows Form, it will show its code behind where the code needs to
    be written.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看代码：当选择代码文件时，将出现查看代码按钮，它会加载与当前选择相关联的代码文件。例如，当选择Windows窗体时，它将显示其代码后端，代码需要在其中编写。
- en: '**View Designer:** Sometimes, based on the file type that is selected in the
    tree, the View Designer button appears. This button launches the Designer associated
    with the currently selected file type.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看设计器：有时，根据树中所选的文件类型，会出现查看设计器按钮。此按钮会启动与当前选择的文件类型相关联的设计器。
- en: '**Add New Folder:** As I have already stated, a solution can also contain folders.
    You can add folders directly to the solution by using the Add New Folder button.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新文件夹：如我已经提到的，解决方案也可以包含文件夹。您可以使用添加新文件夹按钮直接向解决方案中添加文件夹。
- en: '**Create New Solution:** Sometimes, when working with large projects, you might
    need to create a subset of the entire solution and list only the items that you
    are currently working on. This button will create a separate Solution Explorer
    that is in sync with the original Solution Explorer, but projects a specific portion
    of the solution tree.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新解决方案：有时，在处理大型项目时，您可能需要创建整个解决方案的子集，并仅列出您当前正在处理的项目。此按钮将创建一个与原始解决方案同步的单独的解决方案资源管理器，但会显示解决方案树的特定部分。
- en: 'The solution tree in VS also loads the class structure of the project in the
    way it is organized in the filesystem. If you see a collapsed folder, you can
    expand it to see what is inside it. If you expand a `.cs` file, all of the members
    of that class are listed. If you just want to see how the classes are organized,
    you can use the class view window, but by using the Solution Explorer, you can
    see the classes, as well as the other elements inside its own hierarchy. You can
    open the Class View by choosing View | ClassView or pressing *Ctrl + W and C*,
    so that you can view only a portion of the class and its members:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS中的解决方案树也以文件系统中的组织方式加载项目的类结构。如果你看到一个折叠的文件夹，你可以展开它来看看里面有什么。如果你展开一个`.cs`文件，那么该类的所有成员都会被列出来。如果你只想看看类是如何组织的，你可以使用类视图窗口，但是通过使用解决方案资源管理器，你可以看到类，以及其自己层次结构内的其他元素。你可以通过选择视图|类视图或按*Ctrl
    + W和C*来打开类视图，这样你就可以只查看类的一部分和其成员：
- en: '![](img/1b806af1-3d32-49bd-9325-46daf202e4f1.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b806af1-3d32-49bd-9325-46daf202e4f1.png)'
- en: Some files are shown in the solution as blank files (in our case, folders such
    as `bin` and `obj`). This means that these files exist in the filesystem but are
    not included in the solution file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中有一些文件显示为空文件（在我们的情况下，像`bin`和`obj`这样的文件夹）。这意味着这些文件存在于文件系统中，但没有包含在解决方案文件中。
- en: Each file shows additional information on the right-hand side of the tree node
    in the solution. This button gives extra information that's associated with the
    file. For instance, if you click on the button corresponding to a `.cs` file,
    it will open a menu with `Contains`. This will get the associated class view for
    that particular file in the solution. The menu can be pretty long, depending on
    the items that cannot be shown in the generalized toolbar buttons. When the solution
    loads additional information, there are forward and backward buttons, which can
    be used to navigate between views on the solution.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件在解决方案中的树节点右侧都显示了额外的信息。这个按钮提供了与文件相关的额外信息。例如，如果你点击与`.cs`文件对应的按钮，它将打开一个带有`Contains`的菜单。这将在解决方案中为该特定文件获取关联的类视图。菜单可能会很长，取决于不能在通用工具栏按钮中显示的项目。当解决方案加载额外信息时，会有前进和后退按钮，可以用来在解决方案的视图之间导航。
- en: Main workspace area
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主工作区域
- en: The main workspace area is where you will actually write your code or apply
    different settings to your application. This section will open different kinds
    of files that you have in your project. This is the area which, as a developer,
    you will spend most of your time coding. You can open multiple files in this window.
    Different files will be shown in different tabs and you can switch from one tab
    to another just by clicking on the tab. If you need to, you can also pin tabs.
    You can make the tabs float if you think you need them that way, or you can also
    make it full-screen size so that you can focus on the code you are working on.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 主工作区域是你实际编写代码或对应用程序应用不同设置的地方。这个部分将打开你项目中的不同类型的文件。作为开发人员，你会在这个区域花费大部分时间编码。你可以在这个窗口中打开多个文件。不同的文件将显示在不同的标签中，你可以通过点击标签来在不同的标签之间切换。如果需要的话，你也可以固定标签。如果你认为需要这样，你可以让标签浮动，或者也可以使其全屏大小，这样你就可以专注于你正在工作的代码。
- en: 'So, when you double-click on files in the Solution Explorer or choose Open from
    the context menu of the file, that file is opened in a tab in the main editor
    area. This way, you can open multiple files in separate tabs in the editor window
    and switch between them when needed. Each tab header contains a few fixed sets
    of items:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你在解决方案资源管理器中双击文件或从文件的上下文菜单中选择打开时，该文件将在主编辑区域的标签页中打开。这样，你可以在编辑器窗口中打开多个文件，并在需要时在不同的标签之间切换。每个标签标题都包含一些固定的项目集：
- en: '![](img/6267cd7c-b4ce-4bc1-b4ee-244ed3935694.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6267cd7c-b4ce-4bc1-b4ee-244ed3935694.png)'
- en: In the preceding screenshot, you can see that the tab header contains the name
    of the file (`Program.cs`) that links to the tab; it shows a `*` when the item
    needs to be saved, and it has a Toggle pinner button (just like all other IDE
    tool windows), which makes the tab sticky on the left side, and a close button.
     The title section also sometimes indicates some additional status, for example,
    when the file is locked, it shows a lock icon, and when the object is loaded from
    metadata, it shows that in square brackets, as in the preceding screenshot. In
    this section, as we keep on opening files, it goes in a stack of tab pages, one
    after another, until it reaches the end. After the whole area is occupied, it
    finally creates a menu on the rightmost corner of the workspace title to hold
    a list of all of the files that cannot be shown on the screen. From this menu,
    you can choose which file you need to open. *Ctrl + Tab* can also be used to toggle
    between the tabs that are already loaded in the workspace.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，你可以看到标签标题包含文件的名称（`Program.cs`），它显示`*`当项目需要保存时，并且有一个切换固定按钮（就像所有其他IDE工具窗口一样），它可以使标签固定在左侧，并且有一个关闭按钮。标题部分有时也会指示一些额外的状态，例如，当文件被锁定时，它会显示一个锁图标，当对象从元数据中加载时，它会在方括号中显示，就像上面的截图中一样。在这个部分，当我们不断打开文件时，它会形成一个标签页的堆栈，一直到最后。当整个区域被占满时，它最终会在工作区标题的右上角创建一个菜单，用来保存所有不能在屏幕上显示的文件列表。从这个菜单中，你可以选择需要打开的文件。*Ctrl
    + Tab*也可以用来在工作区中已加载的标签之间切换。
- en: Below the title of the tab and before the main workable area are two drop-down
    menus. One has been loaded with the class that is opened in the IDE, and the right
    one loads all of the members that are created on the file. These drop-downs menu
    aid in easier navigation in the file by listing all of the classes that are loaded
    in the current file on the left, while on the right there is another that contextually
    lists all of the members that are there in the class. These two drop-downs menu
    are smart enough to update the drop-down values automatically whenever any new
    code is added to the editor.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在选项卡标题下方和主工作区域之前有两个下拉菜单。一个加载了在IDE中打开的类，右边的一个加载了文件中创建的所有成员。这些下拉菜单有助于更轻松地在文件中导航，左边列出了当前文件中加载的所有类，而右边则列出了上下文中存在的所有成员。这两个下拉菜单足够智能，可以在编辑器中添加新代码时自动更新下拉值。
- en: 'The main workspace area is bounded by two scrollbars, which handle the overflow
    of the document. However, after the vertical scrollbar, there is a special button
    to split the window, as shown in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 主工作区域由两个滚动条限定，用于处理文档的溢出。然而，在垂直滚动条之后，有一个特殊的按钮可以分割窗口，如下面的屏幕截图所示：
- en: '![](img/ef0a01a8-f0c9-4939-84ad-21aad17d40b8.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef0a01a8-f0c9-4939-84ad-21aad17d40b8.png)'
- en: The horizontal scrollbar, on the other hand, holds another drop-down menu that
    shows the current zoom percentage of the Editor. VS now allows you to scale your
    editor to your preferred zoom level. The shortcut for the Zoom feature is *Ctrl*
    + scroll mouse wheel.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，水平滚动条上有另一个下拉菜单，显示编辑器的当前缩放百分比。VS现在允许您将编辑器缩放到您喜欢的缩放级别。缩放功能的快捷键是*Ctrl* +滚动鼠标滚轮。
- en: Output window
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出窗口
- en: 'The output window is placed on the bottom of the IDE (in general) and it opens
    up at various times when you either compile, connect to various services, start
    debugging, or do something that requires the IDE to show some code. The Output
    window is used by the IDE to display log and trace messages:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 输出窗口通常位于IDE底部，并在编译、连接到各种服务、开始调试或需要IDE显示一些代码时打开。输出窗口用于显示日志和跟踪消息：
- en: '![](img/e8288f79-7448-400a-97b0-939e02b33dd4.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8288f79-7448-400a-97b0-939e02b33dd4.png)'
- en: The Output window is docked on the bottom of the page, which lists various types
    of output. From the drop-down menu at the top, you can select which output you
    want to see in the output window. You will also have the option to clear the log
    if you want to display only the newer logs.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 输出窗口停靠在页面底部，列出各种类型的输出。从顶部的下拉菜单中，您可以选择要在输出窗口中看到的输出。您还可以选择清除日志，如果您只想显示更新的日志。
- en: The Command and Immediate windows
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令和即时窗口
- en: The Command window is very similar to Command Prompt of the Windows operating
    system. You can execute commands using this tool. In the VS command line, you
    can execute commands on the project you are working on in. Commands are very handy
    and increase your productivity as you don't have to drag your mouse around to execute
    something. You can run a command to make this happen easily.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 命令窗口与Windows操作系统的命令提示符非常相似。您可以使用此工具执行命令。在VS命令行中，您可以在正在处理的项目上执行命令。命令非常方便，可以提高您的生产率，因为您不必四处拖动鼠标来执行某些操作。您可以运行命令轻松实现这一点。
- en: 'To open a Command window in VS, you can click on the View menu and then Windows.
    After this, select Command Window. Alternatively, you can use the keyboard shortcut, *Ctrl
    + Alt + A,* to open it. When you are in the Command window, you will see a `>`
    placed in front of every input. This is called a prompt. In the prompt, when you
    start typing, it will show an Intellisense menu for you. Start typing `Build.Compile`,
    at which point the project will be compiled for you as well. You can also use `Debug.Start`
    to start debugging the application. You can debug your application easily using
    commands. I will list some of the important commands that are used most often
    when debugging using the Command window:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要在VS中打开命令窗口，可以单击“查看”菜单，然后选择“窗口”。然后，选择“命令窗口”。或者，您可以使用键盘快捷键*Ctrl + Alt + A*来打开它。当您在命令窗口中时，您会看到每个输入前面都有一个`>`。这称为提示符。在提示符中，当您开始输入时，它将为您显示智能感知菜单。开始输入`Build.Compile`，项目将为您编译。您还可以使用`Debug.Start`来开始调试应用程序。您可以使用命令轻松调试应用程序。我将列出一些在使用命令窗口调试时经常使用的重要命令：
- en: '`?`: Tells you the value of a variable (you can also use `Debug.Print` to do
    the same)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`: 告诉您变量的值（也可以使用`Debug.Print`执行相同操作）'
- en: '`??`: Sends the variable to the watch window'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`??`: 将变量发送到监视窗口'
- en: '`locals`: Shows the locals window'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locals`: 显示本地窗口'
- en: '`autos`: Shows the autos window'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autos`: 显示自动窗口'
- en: '`GotoLn`: Sets the cursor to a specific line'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GotoLn`: 将光标设置到特定行'
- en: '`Bp`: Puts a breakpoint in the current line'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bp`: 在当前行设置断点'
- en: Similar to the Command window, an Intermediate window lets you test code without
    having to run it.  An Intermediate window is used to evaluate, execute a statement,
    or even print variable values. To open the Immediate window, go to Debug | Windows
    and select Immediate.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令窗口类似，中间窗口允许您测试代码而无需运行它。中间窗口用于评估、执行语句，甚至打印变量值。要打开即时窗口，请转到“调试|窗口”并选择“即时”。
- en: Search option in IDE
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDE中的搜索选项
- en: 'On the very top-right corner of the screen, you will find a new Search box.
    This is called the IDE search box. VS IDE is vast. There are thousands of options
    available inside of it that you can configure. Sometimes, it is hard to find a
    specific option that you want. The IDE search feature helps you find this option
    easier:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的右上角，您会找到一个新的搜索框。这称为IDE搜索框。VS IDE非常庞大。其中有成千上万的选项可供配置。有时，很难找到您想要的特定选项。IDE搜索功能可以帮助您更轻松地找到此选项：
- en: '![](img/4f733c3a-cef0-46ce-a811-8f23b5a91f6a.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f733c3a-cef0-46ce-a811-8f23b5a91f6a.png)'
- en: The search option will list all of the entries related to VS IDE options, and
    you can easily find any feature you are looking for here.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索选项将列出与VS IDE选项相关的所有条目，您可以轻松找到您要查找的任何功能。
- en: Writing your first program in Visual Studio
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Visual Studio中编写您的第一个程序
- en: VS is the IDE where developers mostly code while working with the C# language.
    As you already have a basic idea of how VS works, let's write our first program
    in VS. Let's create a console application, name the solution `MyFirstApp`, and
    press OK. The default solution template will be automatically added, which includes
    one `Program.cs` with the `Main` program, and a number of other files.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: VS是开发人员在使用C#语言时主要编码的IDE。由于您已经对VS的工作原理有了基本的了解，让我们在VS中编写我们的第一个程序。让我们创建一个控制台应用程序，将解决方案命名为`MyFirstApp`，然后按下OK。默认的解决方案模板将自动添加，其中包括一个带有`Main`程序的`Program.cs`，以及其他一些文件。
- en: 'Let''s build a program that generates an ATM machine. There will be a menu
    that has three options:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个生成ATM机的程序。菜单中有三个选项：
- en: Withdraw
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提款
- en: Deposit
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存款
- en: Balance check
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 余额检查
- en: 'The withdrawal will be performed on the balance (initially $1,000) and a deposit
    will add an amount to the current balance. Now, let''s see what the program looks
    like:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 提款将在余额（最初为$1,000）上执行，存款将向当前余额添加金额。现在，让我们看看程序的样子：
- en: '[PRE15]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let's illustrate the program. The program requests a PIN number before
    opening the ATM machine. The PIN is not checked and can be anything. Once the
    program starts up, it creates a menu in the front of the console with all of the
    desired options.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们说明一下程序。程序在打开ATM机之前会要求输入PIN码。PIN码不会被检查，可以是任何数字。一旦程序启动，它会在控制台的前面创建一个菜单，其中包含所有所需的选项。
- en: You can see that the entire code is written inside a `while` loop, as it ensures
    that the program is kept alive for multiple executions. During execution, you
    can choose any of the options that are available and perform the action associated
    with it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到整个代码都写在一个`while`循环中，因为它确保程序保持活动状态以进行多次执行。在执行期间，您可以选择任何可用的选项并执行与之相关的操作。
- en: 'To execute the program, just click on the Run button on the toolbar of the
    IDE:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行程序，只需单击IDE工具栏上的运行按钮：
- en: '![](img/0c757c06-5b31-4177-a91b-98fab60b2e87.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c757c06-5b31-4177-a91b-98fab60b2e87.png)'
- en: If the program does not run automatically, you can look at the Error List window
    to figure out the actual issue. If you made a mistake in the code, VS will show
    you the appropriate error message and you can double-click on this to navigate
    to the actual location.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序没有自动运行，您可以查看错误列表窗口以找出实际问题。如果代码中有错误，VS将向您显示适当的错误消息，您可以双击它以导航到实际位置。
- en: How to debug
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何调试
- en: 'If you have heard about VS, you must have heard about the debugging capabilities
    of the IDE. You can start the program in debug mode by pressing *F10*. The program
    will start in debug mode with the context in the first line. Let''s execute a
    few of the lines. This will look as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您听说过VS，您一定听说过IDE的调试功能。您可以按*F10*以调试模式启动程序。程序将以第一行的上下文启动调试模式。让我们执行几行。这将如下所示：
- en: '![](img/37fb2d11-7ce8-4f7b-b8e2-f21c4a3c4b12.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37fb2d11-7ce8-4f7b-b8e2-f21c4a3c4b12.png)'
- en: The highlighted line in the code editor workspace depicts the line where the
    current execution has halted. The line is also marked with an arrow on the very
    left of the code editor. You can continue pressing *F10* or *F11* (step into)
    buttons to execute these lines. You must inspect the Locals window to find out
    about all of the values of the local variables during their execution.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编辑器工作区中突出显示的行表示当前执行已停止的行。该行还在代码编辑器的最左边标有箭头。您可以继续按*F10*或*F11*（步入）按钮来执行这些行。您必须检查本地窗口，以了解在执行期间本地变量的所有值。
- en: Debugging through code
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过代码调试
- en: For really advanced users, the .NET class library opens up some of the interesting
    debugger APIs that you can invoke from your source code to call a debugger manually.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于真正高级的用户，.NET类库开放了一些有趣的调试器API，您可以从源代码中调用调试器手动调试。
- en: From the very beginning of a program, there is a `DEBUG` preprocessor variable,
    which determines whether the project was built in debug mode.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序的一开始，有一个`DEBUG`预处理变量，它确定项目是否是以调试模式构建的。
- en: 'You can write the code in the following way:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式编写代码：
- en: '[PRE16]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preprocessor directives are actually evaluated during compile time. This
    means that the code inside `IF DEBUG` will only be compiled in the assembly when
    the project is built in debug mode.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理指令实际上是在编译时评估的。这意味着`IF DEBUG`内部的代码只会在以调试模式构建项目时编译到程序集中。
- en: There are other options such as `Debug.Assert`, `Debug.Fail`, and `Debug.Print`.
    All of these only work during debug mode. In release mode, these APIs won't be
    compiled.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他选项，如`Debug.Assert`、`Debug.Fail`和`Debug.Print`。所有这些选项只在调试模式下工作。在发布模式下，这些API将不会被编译。
- en: You can also call the debugger attached to the process if there is any such
    process available, using the `Debugger.Break()`  method, which will break in the
    debugger at the current line. You can check the debugger. `IsAttached` is used
    to find out whether the debugger is attached to the current process.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何可用的进程，您还可以调用附加到进程的调试器，使用`Debugger.Break()`方法，在当前行中断调试器。您可以检查调试器。`IsAttached`用于查找调试器是否附加到当前进程。
- en: When you start debugging your code, VS launches the actual process as well as
    one in `.vshost` in its filename. VS enhances the experience of debugging by enabling
    Partial Trust's debugging and improving the *F5* experience by using the `.vshost`
    file. These files work in the background to attach the actual process with a predefined
    app domain for debugging to make a flawless debugging experience.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始调试代码时，VS会启动实际的进程以及一个带有`.vshost`文件名的进程。VS通过启用部分信任的调试和使用`.vshost`文件来提高*F5*体验，增强了调试体验。这些文件在后台工作，将实际进程与预定义的应用程序域附加以进行调试，以实现无缝的调试体验。
- en: '`.vshost` files are solely used by the IDE and shouldn''t be shipped in an
    actual project.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`.vshost`文件仅由IDE使用，不应该在实际项目中进行部署。'
- en: VS needs Terminal Services to run these debuggers as it communicates with the
    process even when it is in the same machine. It does this by using a Terminal
    Service to maintain a seamless experience with both normal and remote debugging
    of a process.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: VS需要终端服务来运行这些调试器，因为它即使在同一台机器上也会与进程通信。它通过使用终端服务来保持对进程的正常和远程调试的无缝体验。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the basics of the C# language and introduced the
    VS Editor. We also tried to write our first program using the command line and
    VS.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了C#语言的基础知识，并介绍了VS编辑器。我们还尝试使用命令行和VS编写了我们的第一个程序。
- en: In the next chapter, we will continue this discussion by looking at OOP concepts
    and techniques, which will allow us to write more classes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论面向对象的概念和技术，这将使我们能够编写更多的类。
