- en: '*Chapter 2*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*'
- en: Asynchronous JavaScript
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步JavaScript
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Define asynchronous programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义异步编程
- en: Characterize the JavaScript event loop
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述JavaScript事件循环
- en: Utilize callbacks and promises to write asynchronous code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用回调函数和promises来编写异步代码
- en: Simplify asynchronous code with async/await syntax
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用async/await语法简化异步代码
- en: In this chapter, we shall learn Asynchronous JavaScript and its uses.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习异步JavaScript及其用途。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we covered many of the new and powerful features released
    in ES6\. We discussed the evolution of JavaScript and highlighted the key additions
    in ES6\. We discussed scope rules, variable declaration, arrow functions, template
    literals, enhanced object properties, destructuring assignment, classes and modules,
    transpiling, and iterators and generators.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们涵盖了ES6中发布的许多新功能和强大功能。我们讨论了JavaScript的发展，并突出了ES6中的关键添加。我们讨论了作用域规则、变量声明、箭头函数、模板文字、增强对象属性、解构赋值、类和模块、转译以及迭代器和生成器。
- en: In this chapter, we will learn what an asynchronous programming language is
    and how to write and understand asynchronous code. In the first topic, we will
    define asynchronous programming and show how JavaScript is an asynchronous, event
    driven programming language. Then, we will outline callbacks and show how to use
    callbacks to write asynchronous JavaScript. We will then define promises and demonstrate
    how to use promises to write asynchronous JavaScript. In the final topic, we will
    present the async/await syntax and simplify our asynchronous code using promises
    and this syntax.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习什么是异步编程语言，以及如何编写和理解异步代码。在第一个主题中，我们将定义异步编程，并展示JavaScript是一种异步、事件驱动的编程语言。然后，我们将概述回调函数，并展示如何使用回调函数来编写异步JavaScript。然后，我们将定义promises，并演示如何使用promises来编写异步JavaScript。在最后一个主题中，我们将介绍async/await语法，并使用promises和这种语法简化我们的异步代码。
- en: Asynchronous Programming
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步编程
- en: JavaScript is a single threaded, event driven, asynchronous programming language.
    What does this mean? This means that JavaScript runs on a single thread and delays/handles
    certain events or function calls through an event queue. We will break down the
    basics of how JavaScript does this through the following topic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是单线程、事件驱动、异步编程语言。这意味着JavaScript在单个线程上运行，并通过事件队列延迟/处理某些事件或函数调用。我们将通过以下主题来分解JavaScript如何做到这一点的基础知识。
- en: Sync Versus Async
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步与异步
- en: What does it mean for code to be synchronous or asynchronous? These two buzzwords
    get thrown around a lot in JavaScript. **Synchronous** is derived from the Greek
    root **syn**, meaning "with", and **chronos**, which means "time". Synchronous
    literally means "with time", or rather, code that is coordinated with time. Lines
    of code are run one at a time and are not started until the previous line has
    been handled. **Asynchronous**, or **async**, is derived from the Greek root *async*,
    meaning "not with", and chronos, hence asynchronous literally means "not with
    time" or rather, code that is not coordinated with time. The order code that is
    run is not coordinated with the time at which the interpreter first encounters
    the line of code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是同步还是异步意味着什么？这两个词在JavaScript中经常被提及。**同步**源自希腊词根**syn**，意思是"与"，**chronos**，意思是"时间"。同步字面上意味着"与时间"，或者说，与时间协调的代码。代码一次运行一行，并且在处理完前一行之前不会开始下一行。**异步**或**async**源自希腊词根*async*，意思是"不与"，chronos，因此异步字面上意味着"不与时间"，或者说，与解释器首次遇到代码行的时间不协调的代码。运行的代码顺序与解释器首次遇到代码行的时间不协调。
- en: Synchronous versus Asynchronous Timing
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步与异步的时间控制
- en: There are two types of code — **synchronous** and **asynchronous**. We shall
    cover them in this section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的代码——**同步**和**异步**。我们将在本节中涵盖它们。
- en: In asynchronous JavaScript, the JavaScript engine handles slow and fast code
    differently. We know what the words "fast" and "slow" mean, but how does this
    practically apply to our code? Asynchronous JavaScript allows the thread to execute
    new lines of code while waiting for the response from a slow time-dependent operation,
    such as file system I/O. To understand this, we must understand a little bit about
    computer operation speeds.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步JavaScript中，JavaScript引擎以不同的方式处理慢速和快速代码。我们知道"快"和"慢"这两个词的含义，但这在我们的代码中如何实际应用呢？异步JavaScript允许线程在等待来自慢速时间相关操作的响应时执行新的代码行。例如文件系统I/O。要理解这一点，我们必须了解一些关于计算机操作速度的知识。
- en: CPUs are very, very fast and can handle millions to billions of operations per
    second. Other parts of a computer or network run much slower than the CPU. For
    example, a hard drive can only perform hundreds to thousands of operations per
    second, and a computer network may only be able to perform one operation per second.
    A call to memory is many orders of magnitude slower than a CPU cycle.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: CPU非常非常快，可以处理每秒数百万到数十亿次操作。计算机或网络的其他部分比CPU慢得多。例如，硬盘每秒只能执行数百到数千次操作，计算机网络可能每秒只能执行一次操作。对内存的调用比CPU周期慢得多个数量级。
- en: Hard disk operations are several orders of magnitude slower than memory operations.
    Network calls are several orders of magnitude slower than hard-disk calls.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘操作比内存操作慢几个数量级。网络调用比硬盘调用慢几个数量级。
- en: In **synchronous code**, we execute one line of code at a time. The next line
    of code does not execute until the previous line of code has finished running.
    Since synchronous code handles only execute one line of code at a time and wait
    for the operation to finish before starting a new line, if our code makes a request
    to a slower medium, such as memory, a hard disk, or a network, our program will
    not continue to the next line of code until the request to the slow medium (HDD, network,
    etc) is completed. The CPU will idle, wasting precious time, waiting for the operation
    to complete. In the case of a network call, this could be several seconds. When
    writing complex synchronous code, programmers generally write code that is multithreaded.
    The operating system then switches between threads while one is waiting for a
    slow operation. This helps reduce the CPU idle time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在**同步代码**中，我们一次执行一行代码。下一行代码直到前一行代码完成运行后才执行。由于同步代码一次只执行一行代码并等待操作完成后才开始新的一行，如果我们的代码向较慢的介质（如内存、硬盘或网络）发出请求，程序将不会继续执行下一行代码，直到慢介质（HDD、网络等）的请求完成。CPU将空闲，浪费宝贵的时间，等待操作完成。在网络调用的情况下，这可能需要几秒钟。在编写复杂的同步代码时，程序员通常编写多线程代码。操作系统会在一个线程等待缓慢操作时切换到其他线程。这有助于减少CPU的空闲时间。
- en: In **asynchronous code**, we can execute lines of code out of chronological
    order. This means that we can start working on a new line of code before the previous
    line of code has finished its operation. JavaScript does this with the event loop,
    which will be covered later in the chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在**异步代码**中，我们可以按非时间顺序执行代码行。这意味着我们可以在前一行代码完成操作之前开始处理新的代码行。JavaScript通过事件循环实现这一点，这将在本章后面介绍。
- en: 'In asynchronous code, when the JavaScript engine encounters a line of code
    that uses a slow, non-CPU-dependent operation, the operation is started, and instead
    of waiting for completion, the program moves on to the next line of code and continues
    running. When the slow operation has completed, the CPU jumps back to the operation,
    handles the response from the operation, and continues running the preceding code.
    This allows the CPU to not waste precious resources waiting for an operation that
    could potentially take several seconds. An example of a synchronous and asynchronous
    timing diagram is shown in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步代码中，当JavaScript引擎遇到使用缓慢的、非CPU依赖操作的代码行时，操作会被启动，而不是等待完成，程序会继续执行下一行代码并继续运行。当缓慢操作完成时，CPU会跳回到该操作，处理操作的响应，然后继续运行之前的代码。这样可以让CPU不浪费宝贵的资源等待可能需要几秒钟的操作。下图显示了同步和异步时间图的示例：
- en: '![Figure 2.1: Sync versus async timing diagram'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1：同步与异步时间图'
- en: '](image/Figure_2.1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.1.jpg)'
- en: 'Figure 2.1: Sync versus async timing diagram'
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.1：同步与异步时间图
- en: 'In the preceding diagram, we have four operations: A, B, C, and D. Operation
    C makes a call to the network and has a delay before completion, expressed by
    Network Delay. In the synchronous example, we run each operation sequentially.
    When we reach operation C, we must wait for the network delay before we can finish
    operation C. After operation C completes, we run operation D. During this wait,
    the CPU is idle and unable to do any other work.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们有四个操作：A、B、C和D。操作C调用网络并在完成之前有延迟，由网络延迟表示。在同步示例中，我们按顺序运行每个操作。当到达操作C时，我们必须等待网络延迟才能完成操作C。操作C完成后，我们运行操作D。在此等待期间，CPU处于空闲状态，无法进行其他工作。
- en: In the asynchronous example, we run the first three operations in sequence.
    When we reach operation C, instead of waiting for the network delay, we run operation
    D. When the network delay ends, we finish operation C. In the asynchronous example,
    we can clearly see that the overall completion time for all the operations and
    the CPU idle time are shorter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步示例中，我们按顺序运行前三个操作。当到达操作C时，不会等待网络延迟，而是运行操作D。当网络延迟结束时，我们完成操作C。在异步示例中，我们可以清楚地看到所有操作的整体完成时间和CPU空闲时间都更短。
- en: If this concept is still a little confusing, we can use a real-life situation
    to help explain it. Imagine synchronous code as a line of people waiting to buy
    tickets in a train station. Only one person cause use the ticket vending machine
    at a time. I cannot get a ticket from the machine until all the people in front
    of me have finished getting their tickets. Similarly, the person behind me cannot
    begin getting their ticket until I have finished getting mine. Even if the person
    in front of me decides to take five minutes to get their ticket, I am stuck waiting
    until my turn. Much like with the ticket line, synchronous code runes one step
    at a time, in order. No new code line is run until the previous has finished,
    no matter how long a single step might take.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个概念还有点混乱，我们可以用现实生活中的情况来解释。想象同步代码就像在火车站排队买票的人群。一次只能有一个人使用售票机。在我前面的人都买完票之前，我无法从机器上取票。同样，站在我后面的人在我取票之前也无法开始取票。即使我前面的人决定花五分钟来取票，我也得等到轮到我。就像排队买票一样，同步代码一次只运行一步，按顺序进行。无论一步需要多长时间，都不会运行新的代码行，直到前一步完成。
- en: Asynchronous code is more like eating at a restaurant. Each customer orders
    one at a time, and must wait while the kitchen cooks the orders. The orders are
    served as they finish cooking, but not the order that they were given the kitchen.
    Orders that take less time to cook may come out before orders that take a long
    time. This parallels asynchronous code quite neatly. Each asynchronous code operation,
    or food order in our example, is started in sequential order. While the operation
    is waiting for a response, the next operations can be started. The CPU can handle
    other operations while waiting for responses from previous operations. This clearly
    differs from synchronous code. If the kitchen ran in a synchronous format, you
    would not be able to order your food until the kitchen had finished cooking the
    previous order. Imagine how inefficient this would be!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 异步代码更像是在餐厅用餐。每位顾客依次点餐，并且必须等待厨房烹饪订单。订单完成烹饪后会被上菜，但不是按照它们被厨房接收的顺序。烹饪时间较短的订单可能会在烹饪时间较长的订单之前上菜。这与异步代码非常相似。每个异步代码操作，或者我们例子中的食物订单，都是按顺序开始的。当操作等待响应时，可以开始下一个操作。CPU可以在等待前一个操作的响应时处理其他操作。这显然与同步代码不同。如果厨房以同步方式运行，你将无法在厨房完成前一个订单的烹饪之前点餐。想象一下这会有多低效！
- en: Introducing Event Loops
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入事件循环
- en: JavaScript is an event-driven, asynchronous, single-threaded language because
    of its asynchronous event loop feature. Asynchronous operations are handled in
    JavaScript in the form of events. When we make an asynchronous call, an event
    is fired as soon as the call is finished. The JavaScript Engine then handles that
    event by calling a callback function, and then moves on to whatever was next in
    the code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其异步事件循环特性，JavaScript是一个事件驱动、异步、单线程语言。在JavaScript中，异步操作以事件的形式处理。当我们进行异步调用时，一旦调用完成，就会触发一个事件。然后JavaScript引擎通过调用回调函数来处理该事件，然后继续执行代码中的下一个操作。
- en: '**Event Loop** is the name we use for a four-part system that manages all operations
    in JavaScript. The parts of this system are the Stack, the Heap, the Event Queue,
    and the (main) Event Loop. The Stack, Heap, and Event Queue are all data structures
    that the JavaScript engine maintains. The main event loop is a process that runs
    behind the scenes and manages the three data structures. In its simplest form,
    this system is easy to understand. The stack tracks function calls. When a function
    makes an asynchronous operation, it puts an event handler into the heap. When
    the async operation completes, the event is pushed to the event queue. The event
    loop polls the queue for events, gets the associated handler off the heap, then
    calls the function and adds it to the stack. This is the absolute most basic form
    of the Event Loop. A visual representation of the event loop data structure is
    shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件循环**是我们用来管理JavaScript中所有操作的四部分系统的名称。这个系统的部分包括堆栈、堆、事件队列和（主）事件循环。堆栈、堆和事件队列都是JavaScript引擎维护的数据结构。主事件循环是在后台运行并管理这三个数据结构的过程。在其最简单的形式中，这个系统很容易理解。堆栈跟踪函数调用。当函数进行异步操作时，它会将事件处理程序放入堆中。当异步操作完成时，事件被推送到事件队列中。事件循环轮询队列以获取事件，然后从堆中获取相关的处理程序，然后调用函数并将其添加到堆栈中。这是事件循环的最基本形式。事件循环数据结构的可视化表示如下：'
- en: '![Figure 2.2: Event loop data structure visual model'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2：事件循环数据结构可视化模型'
- en: '](image/Figure_2.2-01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.2-01.jpg)'
- en: 'Figure 2.2: Event loop data structure visual model'
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.2：事件循环数据结构可视化模型
- en: 'This is the Event Loop in its simplest form—three data structures: one to track
    function calls, one to track event handlers, one to track event completions, and
    a loop to tie them all together. The individual parts will be discussed in more
    detail in the following subsections.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是事件循环的最简单形式——三个数据结构：一个用于跟踪函数调用，一个用于跟踪事件处理程序，一个用于跟踪事件完成，以及一个循环将它们全部连接在一起。这些各个部分将在接下来的小节中进行更详细的讨论。
- en: Stack
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆栈
- en: The JavaScript engine has a single call stack, the event loop stack. The **event
    loop stack** is a traditional call stack—it keeps track of the currently executing
    function and what function is to be executed after that. The functions held in
    the stack are called frames. The event loop takes a first in last out approach.
    It is essentially an array-like data structure with special limitations. Function
    frames are added and removed only from the top of the stack, like a stack of plates
    in a kitchen. The first item placed onto the stack will always be at the bottom,
    and this will be the last one taken off.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript引擎有一个单一的调用堆栈，事件循环堆栈。**事件循环堆栈**是一个传统的调用堆栈——它跟踪当前正在执行的函数以及在之后要执行的函数。堆栈中保存的函数被称为帧。事件循环采用先进后出的方式。它本质上是一种类似数组的数据结构，具有特殊的限制。函数帧只能从堆栈顶部添加和移除，就像厨房里的一叠盘子。放在堆栈上的第一项始终在底部，这将是最后一个被取走的。
- en: The stack keeps track of the current executing function at the top of the stack
    and the chain of the function calls at the lower levels. When a function is executed,
    a frame gets created and added to the top of the stack. When a function finishes
    executing, its frame is removed from the top of the stack. These frames contain
    the function, the arguments, and the local variables.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪堆栈顶部的当前执行函数以及较低级别的函数调用链。当函数被执行时，会创建一个帧并添加到堆栈顶部。当函数执行完成时，其帧会从堆栈顶部移除。这些帧包含函数、参数和局部变量。
- en: If a function, function A, calls another function, function B, a new frame gets
    created for the newly executed function B. The new frame for function B gets put
    on the top of the stack, on top of the frame for function A, the function that
    called it. When function B finishes executing, its frame is removed from the stack
    and the frame for function A is now at the top. Function A resumes executing until
    it completes and when it completes, its frame is removed. An example of this is
    shown in the following code snippet and figure.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数A调用另一个函数B，那么为新执行的函数B会创建一个新的帧。函数B的新帧会被放在堆栈的顶部，即调用它的函数A的帧的顶部。当函数B执行完成时，它的帧会从堆栈中移除，函数A的帧现在位于顶部。函数A继续执行，直到完成，完成后它的帧被移除。以下代码片段和图示例了这一点。
- en: 'Consider the following code snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Snippet 2.1: Call stack example code'
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.1：调用堆栈示例代码
- en: 'When the program starts, the first frame is created. This frame contains the
    global state. Then, a second frame is called when `console.log` is called. This
    frame is placed on top of the global frame. When the `bar` function is called,
    a third frame is created and added to the stack. The frame contains `bar''s` arguments
    and local variables. When bar calls `foo`, a fourth frame is added to the stack,
    on top of the bar frame. The full call stack is shown in the following figure:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 程序启动时，会创建第一个帧。该帧包含全局状态。然后，当调用`console.log`时，会创建第二个帧。该帧被放置在全局帧的顶部。当调用`bar`函数时，会创建第三个帧并添加到堆栈中。该帧包含`bar`的参数和局部变量。当bar调用`foo`时，会在bar帧的顶部添加第四个帧。完整的调用堆栈如下图所示：
- en: '![Figure 2.3: Call stack'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3：调用堆栈'
- en: '](image/Figure_2.3.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.3.jpg)'
- en: 'Figure 2.3: Call stack'
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.3：调用堆栈
- en: When `foo` returns, its frame is removed from the stack. The stack now only
    contains a frame containing bar's arguments and variables, the `console.log` call,
    and the global frame.. When **bar** returns, its frame is removed from the stack
    and the stack contains only the last 2 frames..
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当`foo`返回时，它的帧从堆栈中移除。堆栈现在只包含一个包含bar的参数和变量、`console.log`调用和全局帧的帧。当**bar**返回时，它的帧从堆栈中移除，堆栈只包含最后2个帧。
- en: Heap and Event Queue
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆和事件队列
- en: '**Heap**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆**'
- en: The **heap** is a large, mostly unstructured, block of memory that is used to
    track what functions should be called when an event completes. When an asynchronous
    operation is started, it gets added to the heap. Items are removed from the heap
    once the asynchronous operation is complete. When the asynchronous operation completes,
    the heap pushes the necessary data to the event queue.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆**是一个大的、大部分是无结构的内存块，用于跟踪事件完成时应调用哪些函数。当启动异步操作时，它会被添加到堆中。一旦异步操作完成，项目就会从堆中移除。当异步操作完成时，堆会将必要的数据推送到事件队列中。'
- en: '**Queue**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列**'
- en: The **queue** is a message queue used to track asynchronous event completions.
    It is a traditional first in, first out queue. This means that it is an array-like
    data structure where items are pushed to the back of the queue and removed from
    the front of the queue. The oldest items are removed and handled first.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列**是用于跟踪异步事件完成的消息队列。它是一个传统的先进先出队列。这意味着它是一个类似数组的数据结构，其中项目被推到队列的末尾并从队列的前端移除。最旧的项目首先被移除和处理。'
- en: Each message in the message queue has an associated function which gets called
    when the message is handled. To handle a message, it is removed from the queue
    and its corresponding function is called with the message's data as its input
    parameters. As expected, a new stack frame is created when the function is called.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列中的每条消息都有一个关联的函数，当处理消息时会调用该函数。要处理消息，它会从队列中移除，并以消息的数据作为输入参数调用相应的函数。预期地，当调用函数时会创建一个新的堆栈帧。
- en: 'Let''s consider an example of two buttons in our web page, `button1` and `button2`,
    set up to handle click events with the `clickHandler` handler function. The user
    clicks `button1` and `button2` in quick succession. The event queue will contain
    the following simplified information:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个网页中有两个按钮`button1`和`button2`，设置为使用`clickHandler`处理函数处理点击事件。用户快速点击`button1`和`button2`。事件队列将包含以下简化信息：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Snippet 2.2: Call stack example code'
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.2：调用堆栈示例代码
- en: Event Loops
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件循环
- en: 'The **event loop** is responsible for handling messages in the event queue.
    It does this through a constant polling cycle. At every "tick" of the event loop,
    the event queue does up to three things: check the stack, check the queue, and
    wait.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件循环**负责处理事件队列中的消息。它通过一个不断的轮询循环来实现这一点。在事件循环的每个“tick”中，事件队列最多执行三件事：检查堆栈，检查队列，等待。'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: An event queue "tick" is the synchronous calling of zero or more callback functions
    associated with a JavaScript event. It is the time it takes to handle an event
    and run the associated callback.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 事件队列的“tick”是同步调用与JavaScript事件相关的零个或多个回调函数。这是处理事件并运行相关回调的时间。
- en: During every tick, the event loop first checks the call stack to see if it is
    empty and if we can do other work. If the call stack is not empty, the event queue
    will wait a bit, then check again. If the call stack is empty, the event loop
    will check the event queue for an event to handle. If the event queue is empty,
    then we have no work to do and the event loop will wait until the next tick and
    start the process over again. If there is an event to handle, the event loop will
    unqueue the event message from the event queue and call the function associated
    with the message. The called function has a frame created on the stack and the
    JavaScript Engine starts doing the work specified by the function. The event loop
    continues its polling cycle.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个时刻，事件循环首先检查调用栈是否为空，以及我们是否可以做其他工作。如果调用栈不为空，事件队列将等一会儿，然后再次检查。如果调用栈为空，事件循环将检查事件队列以处理事件。如果事件队列为空，那么我们没有工作要做，事件循环将等待下一个时刻，然后重新开始这个过程。如果有事件要处理，事件循环将从事件队列中取消息并调用与消息相关联的函数。被调用的函数在栈上创建一个帧，JavaScript引擎开始执行函数指定的工作。事件循环继续其轮询循环。
- en: Looking at the event loop polling, we can notice that only one event can be processed
    at a time. If there is anything in the call stack, the event loop will not dequeue
    a message from the event queue. This functionality is called **run-to-completion**.
    Each message is processed completely before any other message starts processing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 观察事件循环轮询，我们可以注意到一次只能处理一个事件。如果调用栈中有任何内容，事件循环将不会从事件队列中取出消息。这个功能被称为**运行到完成**。每条消息在任何其他消息开始处理之前都会被完全处理。
- en: '**Run-to-completion** offers some benefits when writing applications. One such
    benefit is that functions cannot be pre-empted and will run before any other code
    runs, potentially modifying the data the function was manipulating.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行到完成**在编写应用程序时提供了一些好处。其中一个好处是函数不能被抢占，将在任何其他代码运行之前运行，可能修改函数正在操作的数据。'
- en: The downside of this model, however, is that if an event callback or loop in
    the code takes a long time to complete, the application can delay other pending
    events. In a browser, a user interaction event like click or scroll could hang
    because another event callback was taking a long time to run. In server-side code,
    the result of a database query or HTTP request could hang because another event
    callback was taking a long time to complete.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种模式的缺点是，如果代码中的事件回调或循环花费很长时间才能完成，应用程序可能会延迟其他待处理的事件。在浏览器中，用户交互事件如点击或滚动可能会因为另一个事件回调花费很长时间而挂起。在服务器端代码中，数据库查询或HTTP请求的结果可能会因为另一个事件回调花费很长时间而挂起。
- en: 'It is good practice to make sure that the callback functions called by events
    are short. Long callback functions can be broken into several message with the
    `setTimeout` function. An example of the delay issue is shown in the following
    code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 确保由事件调用的回调函数很短是一个良好的实践。长回调函数可以使用`setTimeout`函数分成几条消息。延迟问题的示例如下所示：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Snippet 2.3: Blocking loop example'
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码片段2.3：阻塞循环示例
- en: In the preceding example, we created two asynchronous calls with `setTimeout`.
    The first one counts to two billion and then logs `done delaying`, the second
    just logs `done!`. When the first message is pulled off the event queue, the callback
    is put onto the call stack. Counting to two billion will cause a noticeable delay
    in most computers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`setTimeout`创建了两个异步调用。第一个计数到20亿，然后记录`done delaying`，第二个只记录`done!`。当第一个消息从事件队列中取出时，回调被放入调用栈。在大多数计算机上，计数到20亿会导致明显的延迟。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If your computer is old, then this delay may be substantial. If you run this
    code, start with smaller numbers, such as 2,000,000.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的电脑比较旧，那么这种延迟可能会很长。如果你运行这段代码，从较小的数字开始，比如200万。
- en: While the computer is counting, the event loop will not pull the next message
    off of the event queue. The async call to log `done!` will not get handled until
    after the counting is finished. Be cautious, as making callback functions may
    take a long time. If the blocked `console.log( 'done! ')` callback were a user
    input event in a website, the website would be blocking user input and could lead
    to an upset user and potentially the loss of a valuable user.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机在计数时，事件循环不会从事件队列中取出下一个消息。对`done!`的异步调用将在计数完成后才会得到处理。要小心，因为制作回调函数可能需要很长时间。如果被阻塞的`console.log('done!')`回调是网站中的用户输入事件，网站将阻塞用户输入，可能导致用户不满意，甚至可能失去宝贵的用户。
- en: Things to Consider
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需要考虑的事情
- en: 'When working with the event loop, we have three important things consider when
    writing our asynchronous code. The first thing to consider is that events may
    come out of sync. The second is that synchronous code is blocking. The third is
    that zero delay functions do not execute after 0 milliseconds. These three concepts
    are explained as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理事件循环时，我们在编写异步代码时有三个重要的事情要考虑。第一件要考虑的事情是事件可能会出现不同步。第二个是同步代码是阻塞的。第三个是零延迟函数不会在0毫秒后执行。这三个概念如下所述：
- en: '**Events can occur out of order**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件可能会出现无序**'
- en: Events are added to the event queue in the order that they occur or are resolved.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件按照它们发生或解决的顺序添加到事件队列中。
- en: This may not be the order that asynchronous calls are started.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能不是异步调用启动的顺序。
- en: If an asynchronous operation is slow, events that fire before it completes will be
    addressed first.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个异步操作很慢，在它完成之前触发的事件将首先得到处理。
- en: We must account for program timing with callbacks and promises.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须考虑回调和承诺的程序定时。
- en: We must make sure that we are careful about accessing data that is being filled
    in by an asynchronous call before the data is available.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须确保在数据可用之前不要访问由异步调用填充的数据。
- en: '**Synchronous code is blocking**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**同步代码是阻塞的**'
- en: It is very bad practice to avoid asynchronous code by using synchronous modules
    that do the same or similar tasks.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用执行相同或类似任务的同步模块来避免异步代码是非常不好的做法。
- en: JavaScript is single threaded.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript是单线程的。
- en: Event message may not be handled in a prompt manner if a large amount of synchronous
    code is used.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用大量同步代码，事件消息可能无法及时处理。
- en: Events such as mouse clicks or scrolling could hang.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如鼠标点击或滚动等事件可能会挂起。
- en: '**Zero delay functions will not actually execute after 0 milliseconds**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**零延迟函数实际上不会在0毫秒后执行**'
- en: A `setTimeout` adds an event to the event queue after the timeout has expired.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setTimeout`在超时后将事件添加到事件队列中。'
- en: If the event queue has a lot of messages to process, the timeout message may
    not be addressed for several milliseconds.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果事件队列有很多消息要处理，超时消息可能需要几毫秒才能得到处理。
- en: The delay argument indicates a minimum time, not a guaranteed time.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟参数表示的是最小时间，而不是保证时间。
- en: 'The concepts of zero delay functions and the event loop states can be demonstrated
    in the following snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 零延迟函数和事件循环状态的概念可以在以下片段中得到展示：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Snippet 2.4: Handling Asynchronous code'
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.4：处理异步代码
- en: In the preceding snippet, we saw that there is work to be done in the main code
    file. The main program body is run, and a frame is added to the call stack. The
    first line of code is then interpreted and the `setTimeout` function adds its
    callback to the heap and schedules an event to fire after 0 milliseconds. The
    event then fires, and a message is added to the event queue. The JavaScript engine
    interprets the next line of code, the second `setTimeout` call. The callback is
    added to the heap, and the event is registered to fire after 0 ms. The second
    timeout event immediately fires, and a second message is added to the event queue.
    The JavaScript engine handles the `console.log` call and `step0` is logged to
    the console. The main program body has no more synchronous work to do and the
    call stack is empty. The event loop now begins to handle the events in the event
    queue. The event queue contains two messages, one for the first timeout event
    and one for the second timeout event. The event loop then takes the first message
    and adds the associated `callback` function to the call stack. The JavaScript
    engine handles that call stack frame and logs `step1`. The JavaScript engine then
    handles the second message that was in the event queue. The event queue message
    is removed from the queue and a frame is added to the call stack. The JS engine
    handles the frame in the stack and logs `done!`. No more work can be done. All
    events have fired, and the stack and queue are both empty.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们看到主代码文件中有工作要做。运行主程序体，并向调用堆栈添加一个帧。然后解释第一行代码，`setTimeout`函数将其回调添加到堆中，并安排在0毫秒后触发事件。然后事件触发，消息被添加到事件队列。JavaScript引擎解释下一行代码，即第二个`setTimeout`调用。回调被添加到堆中，并注册在0毫秒后触发事件。第二个超时事件立即触发，并将第二个消息添加到事件队列。JavaScript引擎处理`console.log`调用，并将`step0`记录到控制台。主程序体没有更多同步工作要做，调用堆栈为空。事件循环现在开始处理事件队列中的事件。事件队列包含两条消息，一条是第一个超时事件的消息，另一条是第二个超时事件的消息。然后事件循环获取第一条消息，并将相关的`callback`函数添加到调用堆栈。JavaScript引擎处理该调用堆栈帧并记录`step1`。然后JavaScript引擎处理事件队列中的第二条消息。事件队列消息从队列中移除，并向调用堆栈添加一个帧。JS引擎处理堆栈中的帧并记录`done!`。没有更多的工作可以做了。所有事件都已触发，堆栈和队列都为空。
- en: '**Conclusion**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**'
- en: Unlike most programming languages, JavaScript is an asynchronous programming
    language. More specifically, it is a single threaded, event driven, asynchronous
    programming language. This means that JavaScript does not idle when waiting for
    the results of a long-running operation. It runs other code blocks while waiting.
    JavaScript manages this with the Event Loop. The event loop is composed of four
    parts, a function stack, a memory heap, an event queue, and the event loop. These
    four parts work together to handle events fired from operation completion.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数编程语言不同，JavaScript是一种异步编程语言。更具体地说，它是一种单线程、事件驱动的异步编程语言。这意味着JavaScript在等待长时间运行操作的结果时不会空闲。它在等待时运行其他代码块。JavaScript通过事件循环来管理这一点。事件循环由四个部分组成，即函数堆栈、内存堆、事件队列和事件循环。这四个部分共同处理来自操作完成的事件。
- en: 'Exercise 16: Handling the Stack with an Event Loop'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习16：使用事件循环处理堆栈
- en: To better understand why events in your program are being fired and handled
    in the expected order, look at the program provided next, and without running
    the program, write out the expected output of the program.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解程序中事件按预期顺序触发和处理的原因，请查看下面提供的程序，并在不运行程序的情况下，写出程序的预期输出。
- en: 'For the first 10 steps of the program, write the expected stack, queue, and
    heap at each step. A step is any time an event fires, the event loop dequeues
    an event, or the JS Engine handles a function call:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序的前10个步骤，在每个步骤写出预期的堆栈、队列和堆。步骤是指事件触发时，事件循环出列一个事件，或JS引擎处理函数调用的任何时间：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Snippet 2.5: Call stack example code (starting step)'
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.5：调用堆栈示例代码（起始步骤）
- en: 'The program is displayed in the following snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 程序显示在以下片段中：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Snippet 2.6: Call stack example code (program)'
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.6：调用堆栈示例代码（程序）
- en: 'To demonstrate a simplified form of how the Event Loop handles the stack, queue,
    and heap while handling JavaScript events, perform the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示事件循环处理堆栈、队列和堆的简化形式，执行以下步骤：
- en: Add an event loop stack frame to the stack if a function is called and being
    handled.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果调用并处理函数，则向堆栈中添加事件循环堆栈帧。
- en: Process the function and add the necessary event and handler info to the heap.
    Remove the event and handler in the next step.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数并将必要的事件和处理程序信息添加到堆中。在下一步中移除事件和处理程序。
- en: Push to the event queue if an event completes.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果事件完成，则将其推送到事件队列中。
- en: Pull from the event queue and call the handler function.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从事件队列中拉取并调用处理程序函数。
- en: Repeat this for the rest of the steps (first 10 only).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对程序的其余步骤重复此操作（仅限前10步）。
- en: '**Code**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: https://bit.ly/2R5YGPA
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2R5YGPA
- en: '**Outcome**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '![Figure 2.4: Scope outputs'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4：作用域输出]'
- en: '](image/Figure_2.4.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.4.jpg)'
- en: 'Figure 2.4: Scope outputs'
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.4：作用域输出
- en: '![Figure 2.5: Scope outputs'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5：作用域输出'
- en: '](image/Figure_2.5.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.5.jpg)'
- en: 'Figure 2.5: Scope outputs'
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.5：作用域输出
- en: '![Figure 2.6: Scope outputs'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6：作用域输出'
- en: '](image/Figure_2.6.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.6.jpg)'
- en: 'Figure 2.6: Scope outputs'
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.6：作用域输出
- en: You have successfully demonstrated a simplified form of how the Event Loop handles
    the stack.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功演示了事件循环如何处理堆栈的简化形式。
- en: Callbacks
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调
- en: '**Callbacks** are the most basic form of JavaScript asynchronous programming.
    In the simplest terms, a callback is a function that gets called after another
    function completes. Callbacks are used to handle the response of an asynchronous
    function call.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调**是JavaScript异步编程的最基本形式。简单来说，回调是在另一个函数完成后被调用的函数。回调用于处理异步函数调用的响应。'
- en: In JavaScript, functions are treated like objects. They can be passed around
    as arguments, returned by functions, and saved into variables. A callback is a
    function object that is passed as an argument into a higher order function. A
    higher order function is simply a mathematics and computer science term for a
    function that takes one or more functions as arguments (callbacks) or returns
    a function. In JavaScript, a higher order function will take a callback as a parameter.
    Once the higher order finishes doing some form of work, such as an HTTP request
    or database call, it calls the callback function with the error or return values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数被视为对象。它们可以作为参数传递，被函数返回，并保存到变量中。回调是作为参数传递到高阶函数中的函数对象。高阶函数简单地是一个数学和计算机科学术语，用于指代接受一个或多个函数作为参数（回调）或返回一个函数的函数。在JavaScript中，高阶函数将回调作为参数。一旦高阶函数完成某种形式的工作，比如HTTP请求或数据库调用，它将调用回调函数并传递错误或返回值。
- en: As mentioned in the Event Loop section in *Asynchronous Programming*, JavaScript
    is an event driven language. Since JavaScript is single threaded, any long-running
    operations are blocking. JavaScript handles this blocking effect by using events.
    When an operation completes and event fires, the event has an attached handler
    function that gets called to handle the result. These functions are **callbacks**.
    Callbacks are the key that allow JavaScript events to perform work when handling
    asynchronous events.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*异步编程*中的事件循环部分所述，JavaScript是一种事件驱动的语言。由于JavaScript是单线程的，任何长时间运行的操作都会阻塞。JavaScript通过使用事件来处理这种阻塞效应。当操作完成并触发事件时，事件会有一个附加的处理程序函数来处理结果。这些函数就是**回调**。回调是允许JavaScript事件在处理异步事件时执行工作的关键。
- en: Building Callbacks
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建回调
- en: 'Callbacks in JavaScript follow a simple unofficial convention. A callback function
    should take in at least two arguments: **error** and **result**. When building
    callback APIs or writing callback functions, we recommend that you follow this
    convention so that your code can seamlessly integrate with other libraries. An
    example of a callback function is shown in the following snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的回调遵循一个简单的非官方约定。回调函数应至少接受两个参数：**error**和**result**。在构建回调API或编写回调函数时，我们建议您遵循这个约定，以便您的代码可以无缝地集成到其他库中。下面是一个回调函数的示例：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Snippet 2.7: Basic callback example'
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码段2.7：基本回调示例
- en: In the preceding example, we used a fake Twitter API. Our fake API has a higher
    order function, `listFollowers`, that accepts an object and a callback function
    as parameters. Once `listFollowers` completes its internal work, in this case
    an HTTP request to the Twitter API, our callback function will be called.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了一个假的Twitter API。我们的假API有一个高阶函数`listFollowers`，它接受一个对象和一个回调函数作为参数。一旦`listFollowers`完成其内部工作，比如在这种情况下是对Twitter
    API的HTTP请求，我们的回调函数将被调用。
- en: A callback may take in as many arguments as needed or specified by the higher
    order function, but the first argument must be the `error` object. This convention
    is followed by nearly every API in existence. Breaking from this convention when
    writing APIs will make your code much more difficult to integrate with any third-party
    APIs or applications.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 回调可以接受高阶函数需要的或指定的任意数量的参数，但第一个参数必须是错误对象。几乎每个API都遵循这个约定。在编写API时违反这个约定将使您的代码更难与任何第三方API或应用程序集成。
- en: A callback's error argument will only be set if the higher order function encounters
    an error while running. The contents of the error argument may be any legal JavaScript
    value. In most cases, it is an instance of the `Error` class; however, there is no
    convention for the contents of the error object. Some APIs may return an object,
    string, or number instead of an Error instance. Be sure to read the documentation
    of any third-party API to ensure that your code can handle the error format being
    returned.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果高阶函数在运行时遇到错误，回调的错误参数将被设置。错误参数的内容可以是任何合法的JavaScript值。在大多数情况下，它是Error类的一个实例；然而，错误对象的内容没有约定。一些API可能返回一个对象、字符串或数字，而不是Error实例。请确保阅读任何第三方API的文档，以确保您的代码可以处理返回的错误格式。
- en: If the higher order function does NOT encounter an error, the error parameter
    should be set to null. When building your own APIs, it is recommended that you
    also follow this convention. Some third-party APIs may return a falsy value that
    is not null, but this is discouraged because it can make error handling logic
    more complicated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果高阶函数没有遇到错误，则错误参数应设置为null。在构建自己的API时，建议您也遵循这个惯例。一些第三方API可能会返回一个不是null的假值，但这是不鼓励的，因为它会使错误处理逻辑变得更加复杂。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '**Falsy** is a term used in JavaScript type comparison and conversion. Falsy values
    in JavaScript translate to the Boolean false when used in type comparisons. Examples
    of falsy values are null, undefined, 0, and the Boolean false.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**Falsy**是JavaScript类型比较和转换中使用的术语。在JavaScript中，Falsy值在类型比较时转换为布尔值false。Falsy值的示例包括null、undefined、0和布尔值false。'
- en: The result argument of a callback function contains the evaluated result of
    the higher order function. This may be the result of an HTTP request, database
    query, or any other asynchronous operation. Some APIs also may provide more detailed
    error information in the result field when an error is returned. It is important
    to not assume a function completed successfully if the result object is present.
    You must check the error field.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的结果参数包含了高阶函数的评估结果。这可能是一个HTTP请求的结果，数据库查询的结果，或者任何其他异步操作的结果。当返回错误时，一些API还可能在结果字段中提供更详细的错误信息。重要的是不要假设函数成功完成，如果结果对象存在的话，你必须检查错误字段。
- en: 'When handling errors in callback functions, we must check the error argument.
    If the error argument is not null or undefined, then we must handle the error
    in some way. An example error handler is shown in the following snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理回调函数中的错误时，我们必须检查错误参数。如果错误参数不是null或undefined，那么我们必须以某种方式处理错误。下面的示例中显示了一个错误处理程序：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Snippet 2.8: Basic callback error handling'
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.8：基本回调错误处理
- en: Most developers check to see if the error value is a truthy value. If `err`
    is truthy then error handling code is executed. This is a general practice; however,
    it is the lazy way of coding. In some cases, the error object could be the Boolean
    false, the number 0, the empty string, and so on. These all evaluate to falsy,
    even though the value is not null or undefined. If you are using an API, be sure
    to check that it will not return an error that evaluates to falsy. If you are
    building an API, we do not recommend ever returning an error that could evaluate
    to falsy.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员会检查错误值是否为真值。如果`err`是真值，那么将执行错误处理代码。这是一种通用做法；然而，这是编码的懒惰方式。在某些情况下，错误对象可能是布尔值false，数字0，空字符串等。这些都会评估为假值，即使值不是null或undefined。如果你正在使用API，请确保它不会返回一个评估为假值的错误。如果你正在构建一个API，我们不建议返回一个可能评估为假值的错误。
- en: Callback Pitfalls
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回调陷阱
- en: Callbacks are easy to use and serve their purpose very well, but there are a
    few pitfalls to consider when using callbacks. The two most common pitfalls are
    callback hell and callback existence assumption. Both of these pitfalls are easily
    avoided if the code is written with foresight.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回调很容易使用，并且非常有效地实现了它们的目的，但在使用回调时需要考虑一些陷阱。最常见的两个陷阱是回调地狱和回调存在假设。只要有远见地编写代码，这两个陷阱都很容易避免。
- en: 'The most common callback pitfall is **callback hell**. After asynchronous work
    completes and a callback is called, the callback function can call another asynchronous
    function to do more asynchronous work. When it calls the new asynchronous function,
    another callback will be provided. The new callback will be nested inside of the
    old callback. An example of callback nesting is shown in the following snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的回调陷阱是**回调地狱**。在异步工作完成并调用回调后，回调函数可以调用另一个异步函数来进行更多的异步工作。当它调用新的异步函数时，将提供另一个回调。新的回调将嵌套在旧的回调内。回调嵌套的示例在下面的片段中显示：
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Snippet 2.9: Callback nesting'
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.9：回调嵌套
- en: 'In the preceding snippet, we have nested callbacks. The callback of the first
    asynchronous operation, `listFollowers` calls a second asynchronous operation.
    The unfollow operation also has a callback that simply handles an error or logs
    text. Since callbacks can be nested, after several nesting layers the code can
    become quite hard to read. This is callback hell. An example of callback hell
    is shown in the following snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们有嵌套的回调。第一个异步操作的回调`listFollowers`调用了第二个异步操作。取消关注操作也有一个回调，只是处理错误或记录文本。由于回调可以嵌套，经过几层嵌套后，代码可能变得很难阅读。这就是回调地狱。回调地狱的示例在下面的片段中显示：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Snippet 2.10: Callback hell'
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.10：回调地狱
- en: In the preceding snippet, we listed our followers, then unfollow and block the
    first three followers. It is very simple code, but because the callbacks are nested,
    the code becomes messier. This is callback hell.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们列出了我们的关注者，然后取消关注并阻止前三个关注者。这是非常简单的代码，但由于回调嵌套，代码变得更加混乱。这就是回调地狱。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Callback hell is about untidy code presentation, not the logic behind it. Callback
    nesting can lead to code that runs without errors but is very hard to read. Code
    that is very difficult to read can be very difficult to explain to new developers
    or debug when an error occurs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 回调地狱是关于代码呈现的凌乱，而不是其背后的逻辑。回调嵌套可能导致代码运行无误，但非常难以阅读。非常难以阅读的代码可能非常难以向新开发人员解释，或者在发生错误时进行调试。
- en: Fixing Callback Hell
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复回调地狱
- en: 'Callback hell can easily be avoided with two tricks: **named functions** and
    **modules**. A named function is very simple; define the callback and assign it
    to an identifier (variable). The defined callback functions can be kept in the
    same file or put into a module and imported. Using named functions in callbacks
    will help prevent callback nesting from cluttering your code. This is shown in
    the following snippet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 回调地狱可以通过两种技巧轻松避免：**命名函数**和**模块**。命名函数非常简单；定义回调并将其分配给标识符（变量）。定义的回调函数可以保存在同一个文件中或放入一个模块并导入。在回调中使用命名函数将有助于防止回调嵌套使代码混乱。这在下面的示例中显示：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Snippet 2.11: Fixing callback hell'
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.11：修复回调地狱
- en: As we can see from the preceding snippet, the code without nesting is much cleaner.
    If we had a callback nesting depth of 30, the only way to make the code readable
    would be to break the callbacks into named functions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的片段中可以看出，没有嵌套的代码要清晰得多。如果我们有30层的回调嵌套深度，使代码可读的唯一方法就是将回调拆分为命名函数。
- en: 'Another potential pitfall is the non-existence of a callback function. If we
    are writing an API, we must consider the possibility that the user of the API
    might not pass a valid callback function into the API. If the intended callback
    is not a function or does not exist, then trying to call it will cause a runtime
    error. It is a good practice to validate that a callback exists and that it is
    a function before attempting to call it. If the user passes in an invalid callback,
    then we can fail gracefully. An example of this is shown in the following snippet:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个潜在的陷阱是回调函数的不存在。如果我们正在编写一个API，我们必须考虑到API的用户可能不会将有效的回调函数传递给API。如果预期的回调不是一个函数或不存在，那么尝试调用它将导致运行时错误。在尝试调用之前，验证回调存在且是一个函数是一个很好的做法。如果用户传入了无效的回调，那么我们可以优雅地失败。以下是一个示例：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Snippet 2.12: Checking callback existence'
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码片段2.12：检查回调存在
- en: In the preceding code snippet, we checked to make sure that the `callback` argument
    exists and is truthy, and that it is of type function. If the callback does not
    exist or is not a function, we throw an error to let the user know exactly what
    went wrong. If the `callback` is a function, we proceed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们检查了`callback`参数是否存在且为真，并且它是函数类型。如果回调不存在或不是函数，我们会抛出一个错误，让用户知道出了什么问题。如果`callback`是一个函数，我们继续。
- en: '**Conclusion**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**'
- en: A callback is simply a function passed as an argument into another function,
    called a **higher order** function. JavaScript uses callbacks to handle events.
    Callbacks are defined with an error argument and a result argument. If there is
    an error in the higher order function, the callback error field will be set. If
    the higher order function completes with results, the result field will contain
    the result of the completed operation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回调只是作为参数传递给另一个函数的函数，称为**高阶**函数。JavaScript使用回调来处理事件。回调使用错误参数和结果参数进行定义。如果在高阶函数中出现错误，回调错误字段将被设置。如果高阶函数完成了结果，结果字段将包含已完成操作的结果。
- en: When using callbacks, we should be cautious of two pitfalls. We must be careful
    of nesting too many callbacks together and creating callback hell. We must make
    sure that we validate the arguments passed into our higher order functions to
    ensure that the callback is a function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用回调时，我们应该注意两个陷阱。我们必须小心不要嵌套太多的回调并创建回调地狱。我们必须确保验证传递给我们的高阶函数的参数，以确保回调是一个函数。
- en: 'Exercise 17: Working with Callbacks'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习17：使用回调
- en: Your team is building an API that is based around callbacks. To prevent runtime
    errors, you need to validate that the callback arguments passed into the callbackAPI
    functions are valid callable functions. Create a function for your API. In the
    body of that function, validate that the callback argument is a function. If it
    is not a function, throw an error. After a delay, log the data passed into the
    API function and call the callback.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您的团队正在构建一个基于回调的API。为了防止运行时错误，您需要验证传递给回调API函数的回调参数是否是有效的可调用函数。为您的API创建一个函数。在该函数的主体中，验证回调参数是否是一个函数。如果不是一个函数，抛出一个错误。延迟后，记录传递给API函数的数据并调用回调。
- en: 'To build a callback API with callbacks function, perform the following steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个具有回调函数的回调API，请执行以下步骤：
- en: Write a function called `higherOrder` that takes in two arguments; an object
    called `data` and a callback function called `cb`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`higherOrder`的函数，该函数接受两个参数；一个名为`data`的对象和一个名为`cb`的回调函数。
- en: In the function, check that the callback is a function argument (`cb`) is a
    function.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中，检查回调是否是一个函数参数（`cb`是一个函数）。
- en: If `cb` does not exist or it is not of type `function`, then throw an error.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`cb`不存在或者不是`function`类型，则抛出一个错误。
- en: In the function, log the `data` object.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中，记录`data`对象。
- en: In the function, call the `callback` function after a timeout of 10 ms.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中，延迟10毫秒后调用`callback`函数。
- en: Outside the function, create a `try-catch` block.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数外部，创建一个`try-catch`块。
- en: Inside the try section, call the `higherOrder` function with a data object and
    no callback function.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在try部分内，使用一个数据对象和没有回调函数调用`higherOrder`函数。
- en: Inside the catch section, catch the error and log the error message we got.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在catch部分内，捕获错误并记录我们收到的错误消息。
- en: After the `try-catch` block, call the `higherOrder` function with a data object
    and a `callback` function. The callback function should log the string `Callback
    Called!`
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`try-catch`块之后，使用一个数据对象和一个`callback`函数调用`higherOrder`函数。回调函数应记录字符串`Callback
    Called!`
- en: '**Code**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: Index.js
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Index.js
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Snippet 2.13: Implementing callbacks'
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码片段2.13：实现回调
- en: https://bit.ly/2VTGG9L
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2VTGG9L
- en: '**Outcome**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '![Figure 2.7: Callback output'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7：回调输出'
- en: '](image/Figure_2.7.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.7.jpg)'
- en: 'Figure 2.7: Callback output'
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.7：回调输出
- en: You have successfully built a callback API with callback functions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功构建了一个具有回调函数的回调API。
- en: Promises
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺
- en: In JavaScript, a **promise** is an object that wraps an asynchronous operation
    and notifies the program when the asynchronous operation completes. The promise
    object represents the eventual completion or failure of the wrapped operation.
    A promise is a proxy for a value not necessarily known. Instead of providing the
    value immediately, like a synchronous program, it promises to provide a value
    at some point in the future. Promises allow you to associate success and error
    handlers with an asynchronous action. These handlers are called at the completion
    or failure of the wrapped asynchronous process.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，**promise**是一个包装异步操作并在异步操作完成时通知程序的对象。承诺对象表示包装操作的最终完成或失败。承诺是一个代理值，不一定是已知的。它承诺在将来的某个时刻提供一个值，而不是立即提供值，就像同步程序一样。承诺允许您将成功和错误处理程序与异步操作关联起来。这些处理程序在包装的异步过程完成或失败时被调用。
- en: Promises States
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 承诺状态
- en: Every promise has a state. A promise can only succeed with a value or fail with
    an error once. The state of a promise defines where the promise is in its work
    towards the resolution of a value.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个promise都有一个状态。一个promise只能成功一次，带有一个值，或者失败一次，带有一个错误。promise的状态定义了promise在朝向值的解决过程中的工作状态。
- en: 'A promise comes in three states: **pending**, **fulfilled**, or **rejected**.
    A promise starts in the pending state. This means that the async operation being
    done inside the promise is not complete. Once the asynchronous operation completes,
    the promise is considered settled and will enter either the fulfilled or rejected
    state.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一个promise有三种状态：**pending**，**fulfilled**或**rejected**。一个promise开始于pending状态。这意味着promise内部进行的异步操作尚未完成。一旦异步操作完成，promise被视为已解决，并将进入fulfilled或rejected状态。
- en: When a promise enters the fulfilled state, it means that the async operation
    has completed without an error. The promise is fulfilled and a value is available.
    The value generated by the async operation has been returned and can be used.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个promise进入完成状态时，意味着异步操作已经完成，没有错误。promise已经完成，并且有一个值可用。异步操作生成的值已经返回，并且可以使用。
- en: When a promise enters the rejected state, it means that the async operation
    has completed with an error. When a promise is rejected, no future work will be
    done and no value will be provided. The error from the asynchronous operation
    has been returned and can be referenced from the promise object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个promise进入拒绝状态时，意味着异步操作已经以错误完成。当一个promise被拒绝时，将不会进行任何未来的工作，也不会提供任何值。异步操作的错误已经返回，并可以从promise对象中引用。
- en: Resolving or Rejecting a Promise
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决或拒绝一个promise
- en: 'A promise is created by instantiating a new object of the `Promise` class.
    The promise constructor accepts a single argument, a function. This function must
    have two arguments: **resolve** and **reject**. An example of promise creation
    is shown in the following snippet:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实例化`Promise`类的新对象来创建一个promise。promise构造函数接受一个参数，一个函数。这个函数必须有两个参数：**resolve**和**reject**。下面的片段展示了promise的创建示例：
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Snippet 2.14: Promise creation syntax'
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.14：promise创建语法
- en: 'The main asynchronous work of the promise will be done in the body of the function
    passed into the constructor. The two arguments, `resolve` and `reject`, are functions
    that can be used to complete the promise.. To complete the promise with an error,
    call the reject function with the error as its argument. To mark the promise as
    successful, call the `resolve` function and pass in the result in to resolve as
    a parameter. Examples of promise rejection and resolution are shown in the following two
    snippets:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: promise的主要异步工作将在传递给构造函数的函数体中完成。`resolve`和`reject`是可以用来完成promise的函数。要完成带有错误的promise，调用带有错误作为参数的reject函数。要标记promise为成功，调用`resolve`函数并将结果作为参数传递给resolve。下面的两个片段展示了promise的拒绝和解决的例子：
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Snippet 2.15: Rejecting a promise'
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.15：拒绝一个promise
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Snippet 2.16: Resolving a promise'
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.16：解决一个promise
- en: 'An example of resolving a promise that performs asynchronous work, is shown
    in the following snippet:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的片段展示了解决执行异步工作的promise的示例：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Snippet 2.17: Resolving a promise'
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.17：解决一个promise
- en: Using Promises
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Promises
- en: The promise class has three member functions that can be used to handle promise
    fulfillment and rejection. These functions are called promise handlers. These
    functions are `then()`, `catch()`, and `finally()`. When a promise completes,
    one of the handler functions is called. If the promise fulfills, the `then()`
    function is called. If the promise is rejected, either the `catch()` function
    is called, or the `then()` function with a rejection handler is called.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: promise类有三个成员函数，可以用来处理promise的完成和拒绝。这些函数被称为promise处理程序。这些函数是`then()`，`catch()`和`finally()`。当一个promise完成时，其中一个处理程序函数被调用。如果promise完成，将调用`then()`函数。如果promise被拒绝，要么调用`catch()`函数，要么调用带有拒绝处理程序的`then()`函数。
- en: 'The `then()` member function is designed to handle and get the promise fulfillment
    or rejection result. The `then` function takes in two function arguments, a fulfillment
    callback and a rejection callback. This is shown in the following example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`then()`成员函数旨在处理并获取promise的完成或拒绝结果。`then`函数接受两个函数参数，一个完成回调和一个拒绝回调。下面的例子展示了这一点：'
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Snippet 2.18: Promise.then() syntax'
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.18：Promise.then()语法
- en: 'The first argument in the `then()` function is the promise fulfillment handler.
    If the promise is fulfilled with a value, the promise fulfillment handler callback
    is called. The promise fulfillment handler takes one argument. The value of this
    argument will be the value passed in to the fulfilled callback in the promise
    function body. An example of this is shown in the following snippet:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`then()`函数中的第一个参数是promise完成处理程序。如果promise以一个值完成，将调用promise完成处理程序回调。promise完成处理程序接受一个参数。这个参数的值将是传递给promise函数体中完成回调的值。下面的片段展示了一个例子：'
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Snippet 2.19: Promise.then() with resolved promise'
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.19：使用已解决的promise的Promise.then()
- en: 'The second argument in the `then()` function is the promise rejection handler.
    If the promise is rejected with an error, the promise rejection handler callback
    is called. The promise rejection handler takes one argument. The value of this
    argument is the value passed in to the reject callback in the promise function
    body. An example of this is shown in the following snippet:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`then()`函数中的第二个参数是promise拒绝处理程序。如果promise以一个错误被拒绝，将调用promise拒绝处理程序回调。promise拒绝处理程序接受一个参数。这个参数的值是传递给promise函数体中reject回调的值。下面的片段展示了一个例子：'
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Snippet 2.20: Promise rejection with Promise.then()'
  id: totrans-217
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.20：使用Promise.then()拒绝promise
- en: 'Exercise 18: Creating and Resolving Your First Promise'
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习18：创建和解决你的第一个promise
- en: 'To build our first asynchronous promise, perform the following steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们的第一个异步promise，请执行以下步骤：
- en: Create a promise and save it into a variable called `myPromise`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个promise并将其保存到名为`myPromise`的变量中。
- en: Inside the body of the promise, log `Starting asynchronous work!`
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在promise的主体内，记录`开始异步工作！`
- en: Inside the body of the promise, do asynchronous work with a timeout.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在promise的主体内，使用超时进行异步工作。
- en: Have the `timeout` callback fire after 1000 ms. Inside the `timeout` callback
    function, call the promise resolution function and pass in the value `Done!`
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让`timeout`回调在1000毫秒后触发。在`timeout`回调函数内，调用promise解决函数并传入值`完成！`
- en: Attach a then handler to the promise saved in `myPromise`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个then处理程序附加到保存在`myPromise`中的promise。
- en: Pass a function into the then handler that takes in one parameter and logs the
    value of the parameter.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个函数传递给then处理程序，该函数接受一个参数并记录参数的值。
- en: '**Code**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: Index.js
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Index.js
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Snippet 2.21: Promise rejection with Promise.then()'
  id: totrans-229
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.21：使用Promise.then()拒绝Promise
- en: https://bit.ly/2TVQNcz
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2TVQNcz
- en: '**Outcome**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '![Figure 2.8: Scope outputs'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8：作用域输出'
- en: '](image/Figure_2.8.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.8.jpg)'
- en: 'Figure 2.8: Scope outputs'
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.8：作用域输出
- en: You have successfully utilized the syntax you just learned to build our first
    asynchronous promise.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你已成功利用你刚学到的语法来构建我们的第一个异步promise。
- en: Handling Promises
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理Promise
- en: 'When `Promise.then()` is called, it returns a new promise in the pending state.
    After the promise handler for fulfilled or rejected has been called, the handlers
    in `Promise.then()` get called asynchronously. When the handler called from `Promise.then()`
    returns a value, that value is used to resolve or reject the promise returned
    by `promise.then()`. The following table provides the action taken if the handler
    function returns a value, an error, or a promise at any stage:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`Promise.then()`时，它会返回一个处于挂起状态的新promise。在已调用完成或拒绝的promise处理程序之后，`Promise.then()`中的处理程序会异步调用。当从`Promise.then()`调用的处理程序返回一个值时，该值将用于解决或拒绝`promise.then()`返回的promise。以下表格提供了处理程序函数在任何阶段返回值、错误或promise时所采取的操作：
- en: '![Figure 2.9: Returning a promise](image/Figure_2.9.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9：返回一个promise](image/Figure_2.9.jpg)'
- en: 'Figure 2.9: Returning a promise'
  id: totrans-239
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.9：返回一个promise
- en: '`Promise.catch` takes in one argument, a handler function, to handle the promise
    rejection value. When `Promise.catch` is called, internally it calls `Promise.then(
    undefined, rejectHandler )`. This means that internally, the `Promise.then()`
    handler is called with only the promise rejection callback, `rejectHandler`, and
    no promise fulfillment callback. `Promise.catch()` returns the value of the internal
    `Promise.then()` call:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.catch`接受一个参数，一个处理程序函数，用于处理promise的拒绝值。当调用`Promise.catch`时，内部会调用`Promise.then(
    undefined, rejectHandler )`。这意味着在内部，只调用了`Promise.then()`处理程序，只有promise拒绝回调`rejectHandler`，没有promise完成回调。`Promise.catch()`返回内部`Promise.then()`调用的值：'
- en: '[PRE21]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Snippet 2.22: Promise rejection with Promise.then()'
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.22：使用Promise.then()拒绝Promise
- en: 'The promise member function, `Promise.finally()`, is a promise handler that
    is used to catch all promise completion cases. A `Promise.finally()` handler will
    be called for both promise rejections and resolutions. It takes in a single function
    argument that is called when the promise is rejected or fulfilled. `Promise.finally()`
    will catch both rejected and resolved promises, and run the specified function.
    It provides us with a catch all handler to handle either fulfillment case. `Promise.finally()`
    should be used to prevent duplication of code between the then and catch handlers.
    The function passed in to `Promise.finally()` does not take in any arguments,
    so any value passed in to a promise''s resolution or rejection will be ignored.
    Because there is no way to reliably distinguish between a rejection and a fulfillment
    when using `Promise.finally()`, `Promise.finally()` should only be used when we
    do not care if the promise has been rejected or fulfilled. An example of this
    is shown in the following snippet:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: promise成员函数`Promise.finally()`是一个用于捕获所有promise完成情况的promise处理程序。`Promise.finally()`处理程序将被用于处理promise的拒绝和解决。它接受一个单一函数参数，在promise被拒绝或解决时调用。`Promise.finally()`将捕获被拒绝和解决的promise，并运行指定的函数。它为我们提供了一个捕获所有情况的处理程序来处理任何完成情况。`Promise.finally()`应该用于防止在then和catch处理程序之间重复代码。传递给`Promise.finally()`的函数不接受任何参数，因此忽略了传递给promise的解决或拒绝的任何值。因为在使用`Promise.finally()`时没有可靠的区分拒绝和解决的方法，所以只有在我们不关心promise是否被拒绝或解决时才应该使用`Promise.finally()`。以下片段中显示了一个示例：
- en: '[PRE22]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Snippet 2.23: Promise.then()'
  id: totrans-245
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.23：Promise.then()
- en: 'When using promises, there are times when we may want to create a promise that
    is already in the fulfilled state. The Promise class has two static member functions
    that allow us to do this. These functions are `Promise.reject()` and `Promise.resolve()`.
    `Promise.reject()` takes a single argument and returns a promise that has been
    rejected with the value passed in to the reject function. `Promise.resolve()`
    takes in a single argument and returns a promise that has been resolved with the
    value passed in to resolve:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用promise时，有时我们可能希望创建一个已经处于完成状态的promise。Promise类有两个静态成员函数，允许我们这样做。这些函数是`Promise.reject()`和`Promise.resolve()`。`Promise.reject()`接受一个参数，并返回一个已经被拒绝的带有传入拒绝函数值的promise。`Promise.resolve()`接受一个参数，并返回一个已经被解决的带有传入解决值的promise。
- en: '[PRE23]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Snippet 2.24: Promise.then()'
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.24：Promise.then()
- en: Promise Chaining
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Promise链
- en: 'When using promises, we can run into **promise hell**. This is very similar
    to callback hell. When a promise body needs to do more async work after the value
    is obtained, another promise can be nested. The nested promise calls can get difficult
    to follow when the nesting chain gets very deep. To avoid promise hell, we can
    chain promises together. `Promise.then()`, `Promise.catch()`, and `Promise.finally()`
    all return promises that get fulfilled or rejected with the result of the handler
    functions. This means we can tack on another then handler to this promise and
    make a promise chain to handle the newly returned promise. This is shown in the
    following snippet:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用承诺时，我们可能会遇到**承诺地狱**。这与回调地狱非常相似。当承诺主体在获得值后需要执行更多的异步工作时，可以嵌套另一个承诺。当嵌套链变得非常深时，嵌套的承诺调用可能变得难以跟踪。为了避免承诺地狱，我们可以将承诺链接在一起。`Promise.then()`、`Promise.catch()`和`Promise.finally()`都返回承诺，这些承诺将根据处理程序函数的结果被实现或拒绝。这意味着我们可以在这个承诺上附加另一个then处理程序，并创建一个承诺链来处理新返回的承诺。这在以下片段中显示：
- en: '[PRE24]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Snippet 2.25: Promise chaining example'
  id: totrans-252
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.25：承诺链接示例
- en: In the preceding example, we created two functions, `apiCall1()` and `apiCall2()`.
    These functions returned a promise that does more asynchronous work. The async
    work has been omitted from this example for brevity. When the original promise,
    `myPromise`, completes, the `Promise.then()` handler calls `apiCall1()`, which
    returns another promise. The second `Promise.then()` handler is applied to this
    newly returned promise. When the promise returned by `apiCall1()` is resolved,
    the handler function calls `apiCall2()`, which also returns a promise. When the
    promise returned by `apiCall2()` is returned, the final `Promise.then()` handler
    is called. If these handler functions with asynchronous work were nested, it could
    get very difficult to follow the program. With callback chaining, it becomes very
    easy to follow the program flow.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了两个函数`apiCall1()`和`apiCall2()`。这些函数返回一个承诺，执行更多的异步工作。出于简洁起见，此示例中省略了异步工作。当原始承诺`myPromise`完成时，`Promise.then()`处理程序调用`apiCall1()`，它返回另一个承诺。第二个`Promise.then()`处理程序应用于这个新返回的承诺。当`apiCall1()`返回的承诺被解析时，处理程序函数调用`apiCall2()`，它也返回一个承诺。当`apiCall2()`返回的承诺被返回时，将调用最终的`Promise.then()`处理程序。如果这些具有异步工作的处理程序函数被嵌套，那么跟踪程序将变得非常困难。通过回调链接，跟踪程序流程变得非常容易。
- en: When chaining promises, it is possible for the promise handler to return a value
    instead of a new promise. If a value is returned, the value gets passed as an
    input to the next `Promise.then()` handler in the chain.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接承诺时，承诺处理程序可以返回一个值，而不是一个新的承诺。如果返回一个值，该值将作为输入传递给链中的下一个`Promise.then()`处理程序。
- en: For example, the first promise completes and calls the `Promise.then()` handler.
    This handler does synchronous work and returns the number 10\. The next `promise.then()`
    handler will have the input parameter set to 10 and can continue doing the asynchronous
    work. This allows you to embed synchronous steps into the promise chain.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，第一个承诺完成并调用`Promise.then()`处理程序。此处理程序执行同步工作并返回数字10。下一个`promise.then()`处理程序将输入参数设置为10，并可以继续执行异步工作。这允许您将同步步骤嵌入到承诺链中。
- en: 'When chaining promises, we must be careful with catch handlers. When a promise
    is rejected, it jumps to the next promise rejection handler. This can be the second
    argument in a `then` handler or a `catch` handler. All fulfillment handlers between
    where the promise is rejected, and the next rejection handlers, will be ignored.
    When the catch handler completes, the promise returned by `catch()` will be fulfilled
    with the returned value of the rejection handler. This means that the following
    promise fulfillment handler will be given a value to run with. If the `catch`
    handler is not the last handler in the promise chain, the promise chain will continue
    to run with the returned value of the `catch` handler. This can be a tricky error
    to debug; however, it allows us to catch a promise rejection, handle the error
    in a specific way, and continue with the promise chain. It allows the promise
    chain to handle a reject or accept in different ways, then continue with the async
    work. This is shown in the following snippet:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接承诺时，我们必须小心处理catch处理程序。当承诺被拒绝时，它会跳转到下一个承诺拒绝处理程序。这可以是`then`处理程序的第二个参数或`catch`处理程序。在承诺被拒绝的地方和下一个拒绝处理程序之间的所有实现处理程序都将被忽略。当catch处理程序完成时，由`catch()`返回的承诺将以拒绝处理程序的返回值被实现。这意味着下一个承诺实现处理程序将获得一个值来运行。如果`catch`处理程序不是承诺链中的最后一个处理程序，承诺链将继续以`catch`处理程序的返回值运行。这可能是一个棘手的错误调试；然而，它允许我们捕获承诺拒绝，以特定方式处理错误，并继续承诺链。它允许承诺链以不同的方式处理拒绝或接受，然后继续进行异步工作。这在以下片段中显示：
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Snippet 2.26: Handle error and continue'
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.26：处理错误并继续
- en: In the preceding snippet, we have a promise chain with three asynchronous API
    calls in a row, after the resolution of `myPromise`. The first API call will reject
    the promise with an error. The rejected promise is handled by the second then
    handler. Since the promise is rejected, it ignores `apiCall2()` and routes to
    the `errorHandler1()` function. `errorHandler1()` will do some work and return
    a value or promise. That value or promise is passed to the next handler, which
    calls `apiCall3()`, which returns a resolved promise. Since the promise is resolved
    and there are no more `then` handlers, the promise chain ends. The final catch
    is ignored.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们有一个承诺链，其中有三个连续的异步API调用，在`myPromise`解决后。第一个API调用将拒绝带有错误的承诺。拒绝的承诺由第二个then处理程序处理。由于承诺被拒绝，它忽略了`apiCall2()`并路由到`errorHandler1()`函数。`errorHandler1()`将执行一些工作并返回一个值或承诺。该值或承诺传递给下一个处理程序，该处理程序调用`apiCall3()`，它返回一个解决的承诺。由于承诺已解决且没有更多的`then`处理程序，承诺链结束。最终的catch被忽略。
- en: To skip from one rejection handler to the next rejection handler, we need to
    throw an error inside the rejection `handler` function. This will cause the returned
    promise to be rejected with the error thrown and skip to the next `catch` handler.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个拒绝处理程序跳到下一个拒绝处理程序，我们需要在拒绝处理程序函数内部抛出一个错误。这将导致返回的promise被拒绝，并跳到下一个`catch`处理程序。
- en: 'If we wish to exit the promise chain early and not continue when a promise
    is rejected, you should only include a single catch handler at the end of the
    chain. When a promise is rejected, the rejection is handled by the first handler
    found. If this handler is the last handler in the promise chain, the chain ends.
    This is shown in the following snippet:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在promise被拒绝时提前退出promise链并且不继续，应该只在链的末尾包含一个catch处理程序。当promise被拒绝时，拒绝会被找到的第一个处理程序处理。如果这个处理程序是promise链中的最后一个处理程序，链就结束了。如下面的片段所示：
- en: '[PRE26]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Snippet 2.27: Handle error at end of chain to abort'
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.27：在链的末尾处理错误以中止
- en: In the promise chain shown in the preceding snippet, when myPromise is resolved
    with a value, and the first `then` handler is called. `apiCall1()` is called and
    it returns a rejected promise. Since the next two `then` handlers do not have
    an argument to handle promise rejection, the rejection is passed to the `catch`
    handler. The catch handler calls `errorHandler1` and then the promise chain ends.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面片段中显示的promise链中，当myPromise解析为一个值时，第一个`then`处理程序被调用。`apiCall1()`被调用并返回一个被拒绝的promise。由于接下来的两个`then`处理程序没有处理promise拒绝的参数，拒绝被传递给`catch`处理程序。catch处理程序调用`errorHandler1`，然后promise链结束。
- en: 'Chaining promises is used to ensure that all promises complete in the order
    of the chain. If promises need not be completed in order, we can use the `Promise.all()`
    static member function. The `Promise.all()` function is not created on instances
    of the promise class. It is a static class function. `Promise.all()` takes in
    an array of promises and when all of the promises have been resolved, the `then`
    handler will be called. The `then` handler function''s parameter will be an array
    with the resolve value of each promise in the original `Promise.all()` call. The
    array of the resolution values will match the order of the array of the input
    to `Promise.all()`. This is shown in the following snippet:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 链接promise用于确保所有promise按照链的顺序完成。如果promise不需要按顺序完成，我们可以使用`Promise.all()`静态成员函数。`Promise.all()`函数不是在promise类的实例上创建的。它是一个静态类函数。`Promise.all()`接受一个promise数组，当所有promise都解决时，将调用then处理程序。then处理程序函数的参数将是原始`Promise.all()`调用中每个promise的解决值的数组。解决值的数组将与输入到`Promise.all()`的数组的顺序匹配。如下面的片段所示：
- en: '[PRE27]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Snippet 2.28: Promise.all() example'
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.28：Promise.all()示例
- en: In the preceding example, we created three promises that resolve after 100ms,
    200ms, and 10ms respectively. We then pass these promises into the `Promise.all()`
    function. Once all of the promises have resolved, the then handler attached to
    the function `Promise.all()` is called. This handler logs the results of the promises.
    Notice that the order of the result array matches the order of the promise array,
    not the completion order of the promises.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们创建了三个promise，分别在100ms、200ms和10ms后解决。然后将这些promise传递给`Promise.all()`函数。一旦所有promise都解决了，附加到`Promise.all()`函数的then处理程序将被调用。此处理程序记录promise的结果。请注意，结果数组的顺序与promise数组的顺序匹配，而不是promise的完成顺序。
- en: 'If one or many of the promises in the `Promise.all()` call are rejected, the
    `reject` handler will be called with the rejection value of the first promise.
    All of the other promises will run to completion but rejections or resolutions
    of these promises will not call any of the `then` or `catch` handlers of the `P``romise.all()`
    promise chain. This is shown in the following snippet:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Promise.all()`调用中的一个或多个promise被拒绝，`reject`处理程序将被调用，并且会使用第一个promise的拒绝值。所有其他promise将继续运行，但是这些promise的拒绝或解决不会调用`Promise.all()`
    promise链的任何`then`或`catch`处理程序。如下面的片段所示：
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Snippet 2.29: Promise.all() rejection'
  id: totrans-271
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.29：Promise.all()拒绝
- en: In this example, we create three promises that log the promise number and then
    are all rejected with various errors. We pass these promises into a `Promise.all`
    call. `Promise3` has the shortest timeout and therefore is the first promise to
    be rejected. When `Promise3` is rejected, the promise rejection is passed to the
    nearest error handler (`.catch()`) which logs the promise rejection. Promises
    1 and 2 complete running shortly thereafter and are both rejected. The rejection
    handler is not called again for these promises.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了三个promise，记录了promise编号，然后都被不同的错误拒绝。我们将这些promise传递给`Promise.all`调用。`Promise3`的超时时间最短，因此是第一个被拒绝的promise。当`Promise3`被拒绝时，promise拒绝被传递给最近的错误处理程序（`.catch()`），它记录了promise的拒绝。之后不久，promise1和promise2都完成运行，并且都被拒绝。对于这些promise，拒绝处理程序不会再次被调用。
- en: A last function that exists to handle multiple promises is the `Promise.race()`
    function. The `Promise.race()` function is designed to handle only the first promise
    fulfilled or rejected.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 处理多个promise的最后一个函数是`Promise.race()`函数。`Promise.race()`函数设计用来处理第一个被完成或拒绝的promise。
- en: Note
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If for some reason, your program has an intentional race condition or multiple
    code paths that should only cause a successful response handler to be called once,
    `Promise.race()` is the perfect solution.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，您的程序存在有意的竞争条件或多个代码路径，只应该在成功的响应处理程序被调用一次时，`Promise.race()`是完美的解决方案。
- en: 'Like `Promise.all()`, `Promise.race()` is passed an array of promises; however,
    `Promise.race()` only calls the promise fulfillment handler for the first promise
    completed. It then proceeds with the promise chain as normal. The results from
    the other promises are discarded, whether they are rejected or resolved. Promise
    rejection handling with `Promise.race()` works the same way as `Promise.all()`.
    Only the first rejected promise is handled. The other promises are ignored, regardless
    of the fulfillment state. An example of `Promise.race()` is shown in the following
    snippet:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 像`Promise.all()`一样，`Promise.race()`传递一个承诺数组；然而，`Promise.race()`只调用第一个完成的承诺的承诺完成处理程序。然后它按照正常的承诺链继续。其他承诺的结果被丢弃，无论它们是拒绝还是解决。使用`Promise.race()`处理承诺拒绝的方式与`Promise.all()`相同。只处理第一个拒绝的承诺。其他承诺被忽略，无论完成状态如何。`Promise.race()`的示例如下所示：
- en: '[PRE29]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Snippet 2.30: Promise.race() example'
  id: totrans-278
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.30：Promise.race()示例
- en: In the preceding example, we created three promises. These promises all resolve
    after various timeouts. `Promise3` resolves first because it has the shortest
    timeout. When `promise3` resolves, the then handler is called and the result of
    `promise3` is logged. When `promise1` and `promise2` resolve, their results are
    ignored.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们创建了三个承诺。这些承诺在各种超时后都会解决。`Promise3`首先解决，因为它的超时时间最短。当`promise3`解决时，then处理程序被调用，并记录了`promise3`的结果。当`promise1`和`promise2`解决时，它们的结果被忽略。
- en: Promises and Callbacks
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 承诺和回调
- en: 'Promises and callbacks should never be mixed together. Writing code that utilizes
    both callbacks and promises to do asynchronous work can get very complicated and
    lead to errors that are extremely difficult to debug. To prevent mixing callback
    logic and promise logic, we must add shims in our code to handle callbacks as
    promises and promises as callbacks. There are two ways to do this: promises can
    be wrapped in callbacks or callbacks can be wrapped in promises.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺和回调永远不应该混合在一起。编写同时利用回调和承诺进行异步工作的代码可能会变得非常复杂，并导致极其难以调试的错误。为了防止混合回调逻辑和承诺逻辑，我们必须在我们的代码中添加Shim来处理回调作为承诺和承诺作为回调。有两种方法可以做到这一点：承诺可以包装在回调中，或者回调可以包装在承诺中。
- en: Note
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A shim is a code file used to add missing functionality to a code base. Shims
    are usually used to ensure cross-browser compatibility for web applications.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Shim是用于向代码库添加缺失功能的代码文件。Shim通常用于确保Web应用程序的跨浏览器兼容性。
- en: Wrapping Promises in Callbacks
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将承诺包装在回调中
- en: 'To wrap a promise function in a callback, we simply create a wrapper function
    that takes the `promise` function, the arguments, and a `callback`. Inside the
    `wrapper` function, we call the `promise` function and pass in the provided arguments.
    We attach `then` and `catch` handlers. When these handlers resolve, we call the
    `callback` function with the result or the error returned by the promise. This
    is shown in the following snippet:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要将承诺函数包装在回调中，我们只需创建一个包装器函数，该函数接受`promise`函数、参数和`callback`。在`wrapper`函数内部，我们调用`promise`函数并传入提供的参数。我们附加`then`和`catch`处理程序。当这些处理程序解决时，我们调用`callback`函数并传递承诺返回的结果或错误。这在下面的片段中显示：
- en: '[PRE30]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Snippet 2.31: Wrap promise in a callback'
  id: totrans-287
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.31：在回调中包装承诺
- en: In the preceding example, we called the callback with the result of the promise.
    If the promise is resolved with a value, we pass that value into the callback
    with the error field set to null. If the promise is rejected, we pass the error
    into the callback with a null result field.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们使用承诺的结果调用了回调。如果承诺以一个值解决，我们将该值传递到回调中，错误字段设置为null。如果承诺被拒绝，我们将错误传递到回调中，结果字段为null。
- en: 'To wrap a callback-based function in a promise, we simply create a wrapper
    function that takes the function to wrap and the function arguments. Inside the
    wrapper function, we call the function being wrapped inside a new promise. When
    the callback returns a result or error, we reject the promise if there is an error,
    or we resolve the promise if there is no error. This is shown in the following
    snippet:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要将基于回调的函数包装在承诺中，我们只需创建一个包装器函数，该函数接受要包装的函数和函数参数。在包装器函数内部，我们在一个新的承诺中调用被包装的函数。当回调返回结果或错误时，如果有错误，我们拒绝承诺，如果没有错误，我们解决承诺。这在下面的片段中显示：
- en: '[PRE31]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Snippet 2.32: Wrap callback in a promise'
  id: totrans-291
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.32：在承诺中包装回调
- en: In the preceding example, we created a wrapper function that takes in a function
    and that function's arguments. We return a promise that calls this function and
    depending on the result, rejects or resolves the promise. Since this function
    returns a promise, it can be embedded in a promise chain or can have a then or
    catch handler attached to it.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们创建了一个包装器函数，该函数接受一个函数和该函数的参数。我们返回一个调用此函数的承诺，并根据结果拒绝或解决承诺。由于此函数返回一个承诺，因此它可以嵌入在承诺链中，或者可以附加then或catch处理程序。
- en: '**Conclusion**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**'
- en: Promises are another way to handle asynchronous programming in JavaScript. When
    created, a promise starts in the pending state and enters the fulfilled or the
    rejected state depending on the result of the asynchronous work. To handle the
    result of a promise, we use the `.then()`, `.catch()`, and `.finally()` member
    functions. The `.then()` function takes in two handler functions, one for promise
    fulfillment and one for promise rejection. The `.catch()` function takes in only
    one function and handles promise rejection. `Promise.finally()` takes in one function
    and is called for either a promise fulfillment or rejection.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是处理JavaScript中异步编程的另一种方式。创建时，承诺处于挂起状态，并根据异步工作的结果进入完成或拒绝状态。为了处理承诺的结果，我们使用`.then()`、`.catch()`和`.finally()`成员函数。`.then()`函数接受两个处理程序函数，一个用于承诺完成，一个用于承诺拒绝。`.catch()`函数只接受一个函数并处理承诺拒绝。`Promise.finally()`接受一个函数，并在承诺完成或拒绝时调用。
- en: When multiple promises need to be run but order does not matter, we can use
    the `Promise.all()` and `Promise.race()` static functions. The `Promise.all()`
    resolution handler is called when all of the promises have finished running. The
    `Promise.race()` resolution handler is called when the first promise has finished
    running.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要运行多个promise但顺序不重要时，我们可以使用`Promise.all()`和`Promise.race()`静态函数。当所有promise都完成运行时，将调用`Promise.all()`解析处理程序。当第一个promise完成运行时，将调用`Promise.race()`解析处理程序。
- en: Promises and callback are not compatible and should never be mixed in the body
    of a program. To allow for compatibility between functions and modules using promises
    or callback functions, we can write a wrapper function. We can wrap a callback
    in a promise or a promise in a callback. This allows us to shim third-party modules
    to be compatible with our code.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Promises和回调不兼容，不应该在程序主体中混合使用。为了允许使用promises或回调函数的函数和模块之间的兼容性，我们可以编写一个包装函数。我们可以将回调包装在promise中，或将promise包装在回调中。这使我们能够使第三方模块与我们的代码兼容。
- en: 'Exercise 19: Working with Promises'
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习19：使用Promises
- en: You are building a promise-based API. In your API, you must validate user input
    to ensure data passed into your database models is of the right type. Write a
    function that returns a promise. This promise should validate that the data value
    passed into the API function is not a number. If the user passes a number into
    the function, reject the promise with an error. If the user passes a non-number
    into the API function, resolve the promise with the word `Success!`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在构建一个基于promise的API。在您的API中，您必须验证用户输入，以确保传递到数据库模型的数据是正确的类型。编写一个返回promise的函数。这个promise应该验证传递给API函数的数据值不是一个数字。如果用户将数字传递给函数，用错误拒绝promise。如果用户将非数字传递给API函数，用单词`Success!`解析promise。
- en: 'To build a function that uses promises for real scenarios, perform the following
    steps:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个使用实际场景的promise的函数，执行以下步骤：
- en: Write a function called `promiseFunction` that takes in one data argument and
    returns a promise.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`promiseFunction`的函数，它接受一个数据参数并返回一个promise。
- en: Pass a function that takes in two arguments, resolve and reject, into the constructor
    of the promise.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个接受两个参数resolve和reject的函数传递到promise的构造函数中。
- en: In the promise, start doing asynchronous work by creating a timeout that runs
    after 10ms.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在promise中，通过创建一个在10ms后运行的超时来开始执行异步工作。
- en: In the `timeout` callback function, log the input data that was provided to
    `promiseFunction`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`timeout`回调函数中，记录提供给`promiseFunction`的输入数据。
- en: In the `timeout` callback, check that the type of data is a number. If it is,
    reject the promise with an error, otherwise resolve the promise with the string
    `Success!`.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`timeout`回调中，检查数据的类型是否为数字。如果是，用错误拒绝promise，否则用字符串`Success!`解析promise。
- en: Run `promiseFunction` and provide a number as the parameter. Attach a `then()`
    handler and a `catch()` handler to the promise returned by the function.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`promiseFunction`并提供一个数字作为参数。将`then()`处理程序和`catch()`处理程序附加到函数返回的promise上。
- en: Note
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The `then` handler should log the promise resolution value. The `catch` handler
    should log the error's message property.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`then`处理程序应记录promise解析值。`catch`处理程序应记录错误的消息属性。'
- en: '**Code**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: Index.js
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Index.js
- en: '[PRE32]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Snippet 2.33: Implementing promises'
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.33：实现promises
- en: https://bit.ly/2SRZapq
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2SRZapq
- en: '**Outcome**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '![Figure 2.10: Scope outputs](image/Figure_2.10.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10：作用域输出](image/Figure_2.10.jpg)'
- en: 'Figure 2.10: Scope outputs'
  id: totrans-315
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.10：作用域输出
- en: Async/Await
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步/等待
- en: '**Async/await** is a new syntax form added to simplify code that uses promises.
    Async/await introduces two new keywords: `async` and `await`. Async is added to
    function declarations and await is used inside an `async` function. It is surprisingly
    easy to understand and use. In its simplest form, async/await allows us to write
    promise-based asynchronous code that looks almost identical to the synchronous
    code that does the same task. We will use async/await to simplify code using promises
    and make it even easier to read and understand.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步/等待**是一种新的语法形式，用于简化使用promises的代码。异步/等待引入了两个新关键字：`async`和`await`。`async`添加到函数声明中，`await`用于`async`函数内部。这是令人惊讶地易于理解和使用。在其最简单的形式中，异步/等待允许我们编写基于promise的异步代码，看起来几乎与执行相同任务的同步代码相同。我们将使用异步/等待来简化使用promises的代码，并使其更容易阅读和理解。'
- en: Async/Await Syntax
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步/等待语法
- en: 'The `async` keyword is added to function declarations; it must precede the
    function keyword. An `async` function declaration defines an asynchronous function.
    An example declaration of an `async` function is shown in the following snippet:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`关键字被添加到函数声明中；它必须在函数关键字之前。`async`函数声明定义了一个异步函数。以下是`async`函数声明的示例声明：'
- en: '[PRE33]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Snippet 2.34: Implementing promises'
  id: totrans-321
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.34：实现promises
- en: 'An `async` function implicitly returns a promise, no matter what the return
    value is specified to be. If the return value is specified as a non-promise type,
    JavaScript automatically creates a promise and resolves that promise with the
    returned value. This means that all async functions can have the `Promise.then()`
    and `Promise.catch()` handlers applied to the return value. This allows for very
    easy integration with existing promise-based code. This is shown in the following
    snippet:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`函数隐式返回一个promise，无论指定的返回值是什么。如果返回值被指定为非promise类型，JavaScript会自动创建一个promise，并用返回的值解析该promise。这意味着所有异步函数都可以对返回值应用`Promise.then()`和`Promise.catch()`处理程序。这允许与现有基于promise的代码非常轻松地集成。这在以下片段中显示：'
- en: '[PRE34]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Snippet 2.35: Async function output'
  id: totrans-324
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.35：异步函数输出
- en: The `await` keyword can only be used inside of an `async` function. Await tells
    JavaScript to wait until the associated promise settles and returns its result.
    This means that JavaScript pauses execution of that block of code, waits for the
    promise to be resolved while doing other async work, then resumes that block of
    code once the promise settles. This makes the awaited block of code run like a
    synchronous function, but it does not cost any resources because the JavaScript
    engine can still do other work, such as run scripts or handle events, while the
    asynchronous code is being awaited. An example of the await keyword is shown in
    the following snippet.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`关键字只能在`async`函数内部使用。Await告诉JavaScript等待相关的承诺解决并返回其结果。这意味着JavaScript暂停执行该代码块，等待承诺被解决，同时做其他异步工作，然后在承诺解决后恢复该代码块。这使得等待的代码块像同步函数一样运行，但不会消耗任何资源，因为JavaScript引擎仍然可以做其他工作，比如运行脚本或处理事件，而异步代码正在等待。下面的片段中展示了`await`关键字的示例。'
- en: Note
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Even though async/await functionality makes JavaScript code look and act as
    if it were synchronous, JavaScript is still running the code asynchronously with
    the event loop.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管async/await功能使JavaScript代码看起来和行为上都像是同步的，但JavaScript仍然通过事件循环异步运行代码。
- en: '[PRE35]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Snippet 2.36: Await keyword'
  id: totrans-329
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.36：等待关键字
- en: In the preceding example, we defined an `async` function, `awaitExample()`.
    Since it is an `async` function, we can use the await keyword. Inside the function,
    we create a promise that does asynchronous work. In this case, it simply waits
    100 milliseconds and then resolves the promise with the string `done!`. We then
    await the created promise. When the promise is resolved with a value, the await
    takes that value and returns it, and the value is saved in the variable result.
    We then log the value of result to the console. Instead of using a then handler
    on the promise to get the resolution value, we simply await the value. The await
    block of this code looks similar to a synchronous code block.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了一个`async`函数`awaitExample()`。由于它是一个`async`函数，我们可以使用await关键字。在函数内部，我们创建一个进行异步工作的承诺。在这种情况下，它只是等待100毫秒，然后用字符串`done!`解决承诺。然后我们等待创建的承诺。当承诺以一个值解决时，await获取该值并返回它，该值保存在变量result中。然后我们将result的值记录在控制台中。我们不是使用then处理程序来获取解决值，而是简单地等待该值。这段代码的await块看起来类似于同步代码块。
- en: Asnyc/Await Promise Rejection
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步/等待承诺拒绝
- en: 'Now that we know how to handle promise fulfillment with async/await, how can
    we handle promise rejection? Error rejection with async/await is very simple and
    works fantastically with the standard JavaScript error handling. If a promise
    is rejected, the await statement waiting for that promise resolution throws an
    error. When an error is thrown inside an `async` function, it is caught automatically
    by the JavaScript engine and the promise returned by the `async` function is rejected
    with that error. This sounds slightly complicated, but it is very simple. These
    relations are shown in the following snippet:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何处理异步/等待的承诺兑现，那么我们如何处理承诺的拒绝呢？使用异步/等待处理错误拒绝非常简单，并且与标准的JavaScript错误处理非常契合。如果一个承诺被拒绝，等待该承诺解决的await语句会抛出一个错误。当在`async`函数内部抛出错误时，JavaScript引擎会自动捕获，并且由`async`函数返回的承诺会被拒绝并携带该错误。这听起来有点复杂，但实际上非常简单。这些关系在下面的片段中展示：
- en: '[PRE36]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Snippet 2.37: Async/await promise rejection'
  id: totrans-334
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.37：异步/等待承诺拒绝
- en: In the preceding snippet, we created three async functions. In the first function,
    `errorExample1()`, we return a promise that is rejected with the string `Rejected!`.
    In the second function, `errorExample2()`, we throw the string `Rejected!`. Since
    this is an error thrown inside an `async` function, the `async` function wraps
    it in a promise and returns a promise rejected with the thrown value. In this
    case, it returns a promise rejected with the string `Rejected!`. In the third
    function, `errorExmaple3`, we await a rejected promise. Awaiting rejected promises
    causes JavaScript to throw the promise rejection value, which is `Rejected!`.
    The `async` function then catches the error thrown with this value,, wraps it
    in a promise, rejects the promise with that value, and returns the rejected promise.
    All three example functions return a promise rejected with the same value.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们创建了三个异步函数。在第一个函数`errorExample1()`中，我们返回一个被拒绝的承诺，携带字符串`Rejected!`。在第二个函数`errorExample2()`中，我们抛出字符串`Rejected!`。由于这是在`async`函数内部抛出的错误，`async`函数会将其包装在一个承诺中并返回一个携带抛出值的被拒绝的承诺。在这种情况下，它返回一个携带字符串`Rejected!`的被拒绝的承诺。在第三个函数`errorExmaple3`中，我们等待一个被拒绝的承诺。等待被拒绝的承诺会导致JavaScript抛出承诺拒绝值，即`Rejected!`。然后`async`函数捕获抛出的错误值，将其包装在一个承诺中，拒绝该承诺，并返回被拒绝的承诺。所有三个示例函数都返回一个携带相同值的被拒绝的承诺。
- en: 'Since await throws an error if the awaited promise is rejected, we can simply
    use the standard try/catch error handling mechanism in JavaScript to handle the
    async errors. This is very useful because it allows us to handle all errors in
    the same manner, whether asynchronous or synchronous. This is shown in the following
    example:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 由于如果等待的承诺被拒绝，await会抛出一个错误，我们可以简单地使用JavaScript中的标准try/catch错误处理机制来处理异步错误。这非常有用，因为它允许我们以相同的方式处理所有错误，无论是异步还是同步的。这在下面的示例中展示：
- en: '[PRE37]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Snippet 2.38: Error handling'
  id: totrans-338
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.38：错误处理
- en: In the preceding example, we created an async function that tries to do asynchronous
    work. The function tries to await three promises in a row. The final one is rejected,
    which causes an error to be thrown. This error is caught and handled by the `catch`
    block.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个尝试进行异步工作的async函数。该函数尝试连续等待三个承诺。最后一个被拒绝，导致抛出一个错误。这个错误被`catch`块捕获和处理。
- en: 'Since errors are wrapped in promises and rejected by async functions, and await
    throws errors when a promise is rejected, async/await function error propagate
    upwards to the highest level await call. This means that unless an error needs
    to be handled in a special manner at various nesting levels, we can simply use
    a single try catch block for the outermost error. The error will propagate up
    the async/await function stack through rejected promises, and only needs to be
    caught by the top-level await block. This is shown in the following snippet:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 由于错误被包裹在承诺中，并且被异步函数拒绝，当一个承诺被拒绝时，等待会抛出错误，异步/等待函数错误向最高级别的等待调用传播。这意味着除非需要在各种嵌套级别上以特殊方式处理错误，否则我们可以简单地在最外层错误处使用一个try
    catch块。错误将通过被拒绝的承诺在异步/等待函数堆栈上传播，并且只需要被顶层等待块捕获。这在以下片段中显示：
- en: '[PRE38]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Snippet 2.39: Nested error handling'
  id: totrans-342
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.39：嵌套错误处理
- en: In the preceding example, we created several async functions that await the
    result of another async function. They are called in the order `nextedErrorExample()
    -> nested3() -> nested2() -> nested1()`. The body of `nested1()` awaits a rejected
    promise, which throws an error. `Nested1()` catches this error and returns a promise
    rejected with that error. The body of `nested2()` awaits the promise returned
    by `nested1()`. The promise returned by `nested1()` was rejected with the original
    error, so the await in `nested2()` throws an error, which is wrapped in a promise
    by `nested2()`. This propagates down until the `await` in `nestedErrorExample()`.
    The `await` in the nested error example throws an error, which is caught and handled.
    Since we only need to handle the error at the highest level, we put the try/catch
    block at the outermost await call and allow the error to propagate upward until
    it hits that try/catch block.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了几个异步函数，它们等待另一个异步函数的结果。它们按顺序调用`nextedErrorExample() -> nested3()
    -> nested2() -> nested1()`。`nested1()`的主体等待一个被拒绝的承诺，这会引发错误。`Nested1()`捕获此错误并返回一个被拒绝的承诺。`nested2()`的主体等待`nested1()`返回的承诺。`nested1()`返回的承诺被原始错误拒绝，因此`nested2()`中的等待引发错误，并被`nested2()`包装在一个承诺中。这一直传播到`nestedErrorExample()`中的`await`。嵌套错误示例中的`await`引发错误，被捕获和处理。由于我们只需要在最高级别处理错误，因此我们将try/catch块放在最外层的等待调用处，并允许错误向上传播，直到遇到该try/catch块。
- en: Using Async Await
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用异步等待
- en: Now that we know how to use async/await, we need to integrate it into our promise
    code. To convert our promise code to use async/await, we simply need to break
    the promise chains into async functions and await each step. The chain of promise
    handlers is separated at each handler function (`then()`, `catch()`, and so on).
    The value returned by the promise is caught with an `await` statement and saved
    into a variable. This value is then passed into the `callback` function of the
    first promise `then()` promise handler, and the result of the function should
    be caught with an `await` statement and saved into a new variable. This is done
    for each `then()` handler in the promise chain.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用异步/等待，我们需要将其集成到我们的承诺代码中。要将我们的承诺代码转换为使用异步/等待，我们只需要将承诺链分解为异步函数，并等待每个步骤。承诺处理程序链在每个处理程序函数（`then()`，`catch()`等）处分开。承诺返回的值用`await`语句捕获并保存到一个变量中。然后将此值传递给第一个承诺`then()`承诺处理程序的`回调`函数，并且函数的结果应该用`await`语句捕获并保存到一个新变量中。对于承诺链中的每个`then()`处理程序都是如此。
- en: 'To handle the errors and promise rejections, we surround the entire block with
    a try catch block. An example of this is shown in the following snippet:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理错误和承诺拒绝，我们用try catch块包围整个块。以下片段中显示了一个例子：
- en: '[PRE39]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Snippet 2.40: Integrating async/await'
  id: totrans-348
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.40：集成异步/等待
- en: As we can see in the promise chain, we chain three API calls and an error handler
    on to the resolution of `myPromise`. At each promise chain step, a promise is
    returned and a new `Promise.then()` handler is attached. If one of the promise
    chain steps is rejected, the catch handler is called.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在承诺链中看到的，我们将三个API调用和一个错误处理程序链接到“myPromise”的解决方案上。在每个承诺链步骤中，都会返回一个承诺，并附加一个新的`Promise.then()`处理程序。如果承诺链的某个步骤被拒绝，将调用catch处理程序。
- en: In the async/await example, we break the promise chain at each `Promise.then()`
    handler. We then convert the `then` handlers into functions that return promises.
    In this case, `apiCall1()`, `apiCall2()`, and `apiCall3()` already return promises.
    We then await each API call step. To handle a promise rejection, we must surround
    the entire block with a try catch statement.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步/等待示例中，我们在每个`Promise.then()`处理程序处中断承诺链。然后，我们将`then`处理程序转换为返回承诺的函数。在这种情况下，`apiCall1()`，`apiCall2()`和`apiCall3()`已经返回承诺。然后我们等待每个API调用步骤。要处理承诺的拒绝，我们必须用try
    catch语句包围整个块。
- en: Much like with promise chains with multiple chained then handlers, an `async`
    function with multiple await calls will run each await call one at a time, not
    starting the next await call until the previous await call has received a value
    from the associated promise. This can slow down asynchronous work if we are trying
    to complete several asynchronous tasks at the same time. We must wait for each
    step to complete before starting the next step. To avoid this, we can use `Promise.all`
    with `await`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 就像承诺链中有多个链接的then处理程序一样，具有多个等待调用的`async`函数将依次运行每个等待调用，直到前一个等待调用从相关承诺中接收到一个值为止，才开始下一个等待调用。如果我们试图同时完成几个异步任务，这可能会减慢异步工作的速度。我们必须等待每个步骤完成，然后才能开始下一步。为了避免这种情况，我们可以使用`Promise.all`和`await`。
- en: 'As we learned earlier, `Promise.all` runs all the child promises at the same
    time and returns a pending promise that is not fulfilled until all of the child
    promises have been resolved with a value. We can await a `Promise.all` much like
    we would attach a then handler to a `Promise.all`. The value returned by an await
    `Promise.all` call will only be available when all the child promises have completed.
    This is shown in the following snippet:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，`Promise.all` 同时运行所有子承诺，并返回一个未完成的承诺，直到所有子承诺都以一个值解决。我们可以像附加 then 处理程序到
    `Promise.all` 一样等待 `Promise.all`。通过等待 `Promise.all` 调用返回的值，只有当所有子承诺都完成时才能使用。这在下面的片段中显示：
- en: '[PRE40]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Snippet 2.41: Parallel await promises'
  id: totrans-354
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.41：并行等待承诺
- en: As we can see from the preceding example, we created several promises, pass
    those promises into a `Promise.all` call, then await the resolution of the promise
    returned by `Promise.all`. This follows the rules of async/await just as we would
    expect it to. This same logic can be applied to `Promise.race` as well.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中可以看出，我们创建了几个承诺，将这些承诺传递给 `Promise.all` 调用，然后等待 `Promise.all` 返回的承诺的解决。这遵循了
    async/await 的规则，就像我们期望的那样。这个逻辑也可以应用到 `Promise.race`。
- en: 'An example of a promise race is shown in the following snippet:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的片段中显示了一个 promise 竞赛的示例：
- en: '[PRE41]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Snippet 2.42: Promise race example'
  id: totrans-358
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段2.42：Promise 竞赛示例
- en: '**Conclusion**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**'
- en: Async/await is an amazing new syntax format that helps us simplify promise-based
    code. It allows us to write code that looks like synchronous code. Async/await
    introduces two keywords, **async** and **await**. Async is used to denote an `async`
    function. It prepends the function keyword when declaring functions. Async functions
    always return a promise. The await keyword can only be used inside async functions
    on promises. It tells the JavaScript engine to wait on a promise resolution, and
    on rejection or fulfillment, throws an error or returns the value. Async/await
    error handling is done through thrown errors and rejected promises. An `async`
    function automatically catches thrown errors and returns a promise rejected with
    that error. Awaited promises throw errors on rejection. This allows error handling
    to be coupled easily with the standard JavaScript try/catch error handling. Async/await
    is very easy to integrate into your promise-based code and can make it very easy
    to read.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Async/await 是一个令人惊奇的新语法格式，它帮助我们简化基于承诺的代码。它允许我们编写看起来像同步代码的代码。Async/await 引入了两个关键字，**async**
    和 **await**。Async 用于表示一个 `async` 函数。在声明函数时，它在函数关键字之前添加。Async 函数总是返回一个承诺。await
    关键字只能在承诺上的 async 函数中使用。它告诉 JavaScript 引擎等待承诺解决，并在拒绝或实现时抛出错误或返回值。Async/await 错误处理通过抛出的错误和拒绝的承诺来完成。`async`
    函数自动捕获抛出的错误并返回一个以该错误拒绝的承诺。等待的承诺在拒绝时抛出错误。这使得错误处理可以轻松地与标准的 JavaScript try/catch
    错误处理相结合。Async/await 非常容易集成到基于承诺的代码中，并且可以使其非常易于阅读。
- en: 'Activity 2: Using Async/Await'
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动2：使用 Async/Await
- en: 'You have been tasked to build a server that interfaces with a database. You
    must write code to create and look up basic user objects in the database. Import
    the `simple_db.js` file. Using the `get` and `insert` commands, write the following
    program using async/await syntax:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求构建一个与数据库交互的服务器。你必须编写代码在数据库中创建和查找基本用户对象。导入 `simple_db.js` 文件。使用 `get` 和 `insert`
    命令，使用 async/await 语法编写以下程序：
- en: Look up the `john` key and if it exists, log the age field of the result object.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 `john` 键，如果存在，记录结果对象的年龄字段。
- en: Look up the `sam` key and if it exists, log the age of the result object.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 `sam` 键，如果存在，记录结果对象的年龄。
- en: Look up your name. If it does not exist, insert your name. If you must add an
    object, look up the new object and log the age.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找你的名字。如果不存在，插入你的名字。如果必须添加一个对象，查找新对象并记录年龄。
- en: For any `db.get` operation that fails, save the key into an array. At the end
    of the program, print the keys that failed.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何失败的 `db.get` 操作，将键保存到数组中。在程序结束时，打印失败的键。
- en: 'DB API:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: DB API：
- en: '`db.get( index ):`'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.get( index ):`'
- en: This takes in an index and returns a promise. A promise is fulfilled with the
    `db` entry associated with that index. If the index does not exist, the lookup
    fails, or the key is not specified, the promise is rejected with an error.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一个索引并返回一个承诺。如果索引不存在，查找失败，或者未指定键，则承诺将以错误拒绝。
- en: '`db.insert( index, insertData ):`'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.insert( index, insertData ):`'
- en: This takes in an index and data, and returns a promise. The promise is fulfilled
    with the key inserted if the operation completes. If the operation fails, or there
    is no key or insert data specified, the promise is rejected with an error.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一个索引和数据，并返回一个承诺。如果操作完成，承诺将以插入的键实现。如果操作失败，或者没有指定键或插入数据，承诺将以错误拒绝。
- en: 'To utilize promises and async/await syntax to build a program, perform the
    following steps:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 利用承诺和 async/await 语法构建程序，执行以下步骤：
- en: Write an `async` function called `main`. All operations will go in here.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `main` 的 `async` 函数。所有操作都将在这里进行。
- en: Create an array to keep track of keys that cause db errors.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数组来跟踪导致 db 错误的键。
- en: Catch all errors and log them.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获所有错误并记录它们。
- en: Outside all of the try-catch blocks, at the end of the `main` function, return
    the array.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有 try-catch 块之外，在 `main` 函数的末尾，返回数组。
- en: Call the main function and attach a `then()` and `catch()` handler to the returned promise.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用主函数并附加 `then()` 和 `catch()` 处理程序到返回的承诺。
- en: '**Outcome**'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '![Figure 2.11: Scope outputs'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.11：作用域输出'
- en: '](image/Figure_2.11.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.11.jpg)'
- en: 'Figure 2.11: Scope outputs'
  id: totrans-381
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.11：作用域输出
- en: You successfully used promises and async/await syntax to build a program that
    accesses a database.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 您成功地使用了承诺和 async/await 语法来构建一个访问数据库的程序。
- en: Note
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 282.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第282页找到。
- en: Summary
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: JavaScript is an asynchronous, event-driven, single-threaded language. Instead
    of hanging during a long-running operation to another resource, JavaScript does
    work on other operations if any work is pending. JavaScript accomplishes this
    with the event loop. The event loop is composed of the call stack, heap, event
    queue, and main event loop. These four components work together to schedule when
    JavaScript runs different parts of the code. To leverage JavaScript's asynchronous
    nature, we use callbacks or promises. Callbacks are simply functions passed as
    arguments into other functions. Promises are special classes with event handler
    functions. When an asynchronous operation finishes, the JavaScript engine runs
    the callback or calls the promise handler attached to that operation's complete
    event. This is asynchronous JavaScript in its simplest form.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种异步、事件驱动、单线程的语言。JavaScript不会在长时间运行的操作中挂起到另一个资源，而是在任何待处理的工作时进行其他操作。JavaScript通过事件循环实现这一点。事件循环由调用堆栈、堆、事件队列和主事件循环组成。这四个组件共同工作，安排JavaScript何时运行代码的不同部分。为了利用JavaScript的异步特性，我们使用回调或者Promise。回调只是作为参数传递给其他函数的简单函数。Promise是具有事件处理函数的特殊类。当异步操作完成时，JavaScript引擎运行回调或调用与该操作的完成事件相关联的Promise处理程序。这就是JavaScript异步的最简单形式。
- en: In the next chapter, we will learn about the **Document Object Model** (DOM),
    the **JavaScript event object**, and the **jQuery library**.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习**文档对象模型**（DOM）、**JavaScript事件对象**和**jQuery库**。
