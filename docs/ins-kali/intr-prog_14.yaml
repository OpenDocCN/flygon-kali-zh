- en: Java Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java集合
- en: This chapter will help the reader to become more familiar with the most commonly
    used Java collections. The code examples illustrate their functionality and allow
    an experimentation that emphasizes the difference between different collection
    types and their implementations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助读者更熟悉最常用的Java集合。代码示例说明了它们的功能，并允许进行实验，强调了不同集合类型及其实现之间的差异。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are collections?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是集合？
- en: List and ArrayList
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表和ArrayList
- en: Set and HashSet
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Set和HashSet
- en: Map and HashMap
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Map和HashMap
- en: Exercise – EnumSet methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-EnumSet方法
- en: What are collections?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是集合？
- en: When you read about the Java Collection Framework, you may assume there is something
    special about such an assemblage. Meanwhile, the word framework is quite overloaded
    and misused, as the word technology is one we have refused to use already. In
    the English language, the word framework means *a basic structure underlying a
    system, concept, or text.* In computer programming, a framework is a software
    system constructed so that its functionality can be customized by additional user-written
    code or configuration settings in order to fit the application-specific requirements.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读关于Java集合框架的内容时，你可能会认为这样的集合有些特殊。与此同时，框架这个词被滥用了，就像技术这个词一样，我们已经拒绝使用了。在英语中，框架这个词的意思是“系统、概念或文本的基本结构”。在计算机编程中，框架是一个软件系统，它的功能可以通过额外的用户编写的代码或配置设置来定制，以满足特定应用程序的要求。
- en: But then we look closer into the content of the Java Collection Framework and
    realize that all its members belong to the `java.util` package, which is part
    of the Java Class Library, or Java standard library, as we have described it in
    the previous chapter. And, at the other extreme, the graphic user interfaces in
    the packages `java.awt`, `javax.swing`, or `javafx` have all the signs of a framework;
    they just provide gadgets and other graphic elements, which have to be filled
    by the application-specific content. And yet they belong to the Java Class Library
    too.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们仔细研究Java集合框架的内容时，我们意识到它的所有成员都属于`java.util`包，这是Java类库的一部分，正如我们在前一章中所描述的。而另一方面，`java.awt`、`javax.swing`或`javafx`包中的图形用户界面具有框架的所有特征；它们只提供小工具和其他图形元素，这些元素必须由特定应用程序的内容填充。然而，它们也属于Java类库。
- en: That's why we avoid using the word framework and mention it here only to explain
    what is hiding behind the title Java Collection Framework.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们避免使用框架这个词，并且只在这里提到它，以解释Java集合框架标题背后隐藏的东西。
- en: The java.util package
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`java.util`包'
- en: 'The following interfaces and classes of the package `java.util` compose the
    Java Collections Framework:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util`包中的以下接口和类组成了Java集合框架：'
- en: 'The interfaces that extend `java.util.Collection` (which in turn extends the `java.lang.Iterable`
    interface): `List`, `Set`, and `Queue`, to name the most popular ones'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`java.util.Collection`接口的接口（它又扩展了`java.lang.Iterable`接口）：`List`、`Set`和`Queue`，这些是最流行的接口之一
- en: 'The classes that implement the fore mentioned interfaces: `ArrayList`, `HashSet`,
    `Stack`, and `LinkedList`, as an example'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现上述接口的类：`ArrayList`、`HashSet`、`Stack`和`LinkedList`，作为示例
- en: The classes that implement interface `java.util.Map` and its children: `HashMap`,
    `HashTable`, and `TreeMap`, to name just three of the most commonly used
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`java.util.Map`接口及其子类的类：`HashMap`、`HashTable`和`TreeMap`，只是其中最常用的三个
- en: As you can see, the Java Collection Framework, or just Java Collections, are
    composed of the interfaces that extend the `java.util.Collection` interface or
    the `java.util.Map` interface and the classes that implement these interfaces
    – all are contained in the `java.util` package.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Java集合框架，或者只是Java集合，由扩展`java.util.Collection`接口或`java.util.Map`接口的接口和实现这些接口的类组成-所有这些都包含在`java.util`包中。
- en: Notice that those classes that implement—directly or indirectly—the `Collection`
    interface also implement the `Iterable` interface and thus can be used in iteration
    statements as described in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，那些直接或间接实现`Collection`接口的类也实现了`Iterable`接口，因此可以在迭代语句中使用，如[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)中所述的“控制流语句”。
- en: Apache Commons collections
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache Commons集合
- en: Project Apache Commons contains (in the package `org.apache.commons.collections`)
    multiple implementations of Java collection interfaces that complement the implementations
    in the `java.util` package. But, unless you work on an application that requires
    a particular collection algorithm, you probably won't need to use them. Nevertheless,
    we recommend that you look through the `org.apache.commons.collections` package
    API, so that you know its content in case you encounter a need to use it in the
    future.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Commons项目包含了（在`org.apache.commons.collections`包中）多个Java集合接口的实现，这些实现补充了`java.util`包中的实现。但是，除非你在一个需要特定集合算法的应用程序上工作，否则你可能不需要使用它们。尽管如此，我们建议你浏览一下`org.apache.commons.collections`包的API，这样你就知道它的内容，以防将来遇到需要使用它的情况。
- en: Collections vs arrays
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合与数组
- en: 'All collections are data structures similar to arrays in the sense that they
    also contain elements, and each is represented by an object of a class. There
    are two significant differences between arrays and collections, though:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合都是类似于数组的数据结构，因为它们也包含元素，并且每个元素都由一个类的对象表示。不过，数组和集合之间有两个重要的区别：
- en: An array requires assigning a size when instantiated, while a collection increases
    and decreases in size automatically when elements are added or removed.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组在实例化时需要分配一个大小，而集合在添加或删除元素时会自动增加和减少大小。
- en: 'An element of a collection cannot be a value of a primitive type, but only
    a reference type, including wrapper classes such as `Integer` or `Double`. The
    good news is that you can add a primitive value:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合的元素不能是原始类型的值，而只能是引用类型，包括包装类，如“Integer”或“Double”。好消息是您可以添加原始值：
- en: '```java'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List list = new ArrayList();
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: List list = new ArrayList();
- en: list.add(42);
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(42);
- en: '```'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The boxing conversion (see [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*) in the preceding statement will be applied
    to the primitive value automatically.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的语句中，装箱转换（请参阅[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)，“运算符、表达式和语句”）将自动应用于原始值。
- en: Although arrays are expected to provide better performance while accessing its
    elements, in practice, modern algorithms make the differences in performance of
    arrays and collections negligible, except in some very specialized cases. That
    is why the only reason you would have to use arrays is when some algorithms or
    methods require it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数组在访问其元素时预计会提供更好的性能，但实际上，现代算法使数组和集合的性能差异可以忽略不计，除了一些非常专业的情况。这就是为什么您必须使用数组的唯一原因是当一些算法或方法需要它时。
- en: Here is what we are going to discuss
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这是我们将要讨论的内容
- en: 'In the following subsections, we will discuss the most popular interfaces and
    classes of Java collections from standard libraries:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将讨论Java集合标准库中最受欢迎的接口和类：
- en: The `List` interface and the `ArrayList` class – they preserve the order of
    the elements
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “List”接口和“ArrayList”类-它们保留元素的顺序
- en: The `Set` interface and the `HashSe` class –  they do not allow duplicate elements
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Set”接口和“HashSe”类-它们不允许重复元素
- en: The `Map` and `HashMap` interfaces – they store objects by with a key and thus
    allow key-to-value mapping
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Map”和“HashMap”接口-它们通过键存储对象，因此允许键值映射
- en: Please notice that most of the methods described in the following sections come
    from the `java.util.Collection` interface – the parent interface of almost all
    the collections, except those that implement the `java.util.Map` interface.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下小节中描述的大多数方法都来自“java.util.Collection”接口-几乎所有集合的父接口，除了实现“java.util.Map”接口的集合。
- en: List - ArrayList preserves order
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: List-ArrayList保留顺序
- en: '`List` is an interface, while the `ArrayList` class is its most often used
    implementation. Both are residing in the `java.util` package. The `ArrayList` class
    has a few more methods - in addition to those declared in the `List` interface.
    The `removeRange()` method, for example, is not present in the `List` interface
    but available in the `ArrayList` API.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: “List”是一个接口，“ArrayList”类是其最常用的实现。两者都驻留在“java.util”包中。“ArrayList”类有一些额外的方法-除了“List”接口中声明的方法之外。例如，“removeRange()”方法在“List”接口中不存在，但在“ArrayList”API中可用。
- en: Prefer variable type List
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更喜欢变量类型List
- en: 'It is a good practice, while creating an object of an `ArrayList`, to assign
    its reference to a variable of type `List`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建“ArrayList”对象时，将其引用分配给“List”类型的变量是一个很好的做法：
- en: '```java'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List listOfNames = new ArrayList();
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: List listOfNames = new ArrayList();
- en: '```'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'More likely than not, using a variable of type `ArrayList` will not change
    anything in your program, not today, nor in the future:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，在您的程序中使用“ArrayList”类型的变量不会改变任何内容，无论是今天还是将来：
- en: '```java'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: ArrayList listOfNames = new ArrayList();
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayList listOfNames = new ArrayList();
- en: '```'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The preceding reference can still be passed to any method that accepts a parameter
    of type `List`. However, coding to an interface (that is what we do when we make
    the variable of an interface type) is a good habit in general because you never
    know when the requirements to your code might change and you would need to use
    another implementation of `List`, like the `LinkedList` class, for example. If
    the variable type was `List`, switching an implementation is easy. But if the
    variable type was `ArrayList`, changing it to `List` or to `LinkedList` requires
    tracking down all the places the variable was used and run various tests to make
    sure that `ArrayList` methods were not called anywhere. And if the code is complex,
    one can never be sure that all possible execution paths were checked and the code
    will not break in production. That's why we prefer to use an interface type for
    the variable that holds the reference to an object, unless you really need it
    to be the class type. We talked about this extensively in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml),
    *Object-Oriented Design (OOD) Principles*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的引用仍然可以传递给接受“List”类型参数的任何方法。但是，通常编码为接口（当我们将变量设置为接口类型时）是一个很好的习惯，因为您永远不知道代码的要求何时可能会更改，您可能需要使用另一个“List”的实现，例如“LinkedList”类。如果变量类型是“List”，切换实现很容易。但是，如果变量类型是“ArrayList”，将其更改为“List”或“LinkedList”需要跟踪变量使用的所有位置并运行各种测试，以确保没有在任何地方调用“ArrayList”方法。如果代码很复杂，人们永远无法确定是否已检查了所有可能的执行路径，并且代码不会在生产中中断。这就是为什么我们更喜欢使用接口类型来保存对对象的引用的变量，除非您确实需要它成为类类型。我们在[第8章](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml)中广泛讨论了这一点，“面向对象设计（OOD）原则”。
- en: Why is it called ArrayList?
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么叫ArrayList？
- en: 'The `ArrayList` class is named so because its implementation is based on an
    array. It actually uses an array behind the scenes. If you right-click on `ArrayList` in
    IDE and view the source code, here is what you are going to see:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: “ArrayList”类之所以被命名为ArrayList，是因为它的实现是基于数组的。它实际上在幕后使用数组。如果在IDE中右键单击“ArrayList”并查看源代码，您将看到以下内容：
- en: '```java'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 私有静态最终对象[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
- en: public ArrayList() {
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: public ArrayList() {
- en: this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
- en: '}'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It is just a wrapper around the array `Object[]`. And here is how method `add(E)`
    is implemented, for example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是数组“Object[]”的包装器。例如，这是方法“add(E)”的实现方式：
- en: '```java'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public boolean add(E e) {
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean add(E e) {
- en: modCount++;
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: modCount++;
- en: add(e, elementData, size);
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: add(e, elementData, size);
- en: return true;
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 返回true;
- en: '}'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private void add(E e, Object[] elementData, int s) {
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: private void add(E e, Object[] elementData, int s) {
- en: if (s == elementData.length)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: if (s == elementData.length)
- en: elementData = grow();
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: elementData = grow();
- en: elementData[s] = e;
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: elementData[s] = e;
- en: size = s + 1;
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: size = s + 1;
- en: '}'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And if you study the source code more and look inside the method `grow()`,
    you will see how it increases the size of the array when new elements are added
    to the list:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 'And if you study the source code more and look inside the method `grow()`,
    you will see how it increases the size of the array when new elements are added
    to the list:'
- en: '```java'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: private Object[] grow() {  return grow(size + 1); }
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: private Object[] grow() {  return grow(size + 1); }
- en: private Object[] grow(int minCapacity) {
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: private Object[] grow(int minCapacity) {
- en: return elementData = Arrays.copyOf(elementData,
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: return elementData = Arrays.copyOf(elementData,
- en: newCapacity(minCapacity));
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: newCapacity(minCapacity));
- en: '}'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private static final int DEFAULT_CAPACITY = 10;
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: private static final int DEFAULT_CAPACITY = 10;
- en: private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
- en: private int newCapacity(int minCapacity) {
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: private int newCapacity(int minCapacity) {
- en: // overflow-conscious code
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: // overflow-conscious code
- en: int oldCapacity = elementData.length;
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: int oldCapacity = elementData.length;
- en: int newCapacity = oldCapacity + (oldCapacity >> 1);
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: int newCapacity = oldCapacity + (oldCapacity >> 1);
- en: if (newCapacity - minCapacity <= 0) {
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: if (newCapacity - minCapacity <= 0) {
- en: if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
- en: return Math.max(DEFAULT_CAPACITY, minCapacity);
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: return Math.max(DEFAULT_CAPACITY, minCapacity);
- en: if (minCapacity < 0) // overflow
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: if (minCapacity < 0) // overflow
- en: throw new OutOfMemoryError();
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: throw new OutOfMemoryError();
- en: return minCapacity;
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: return minCapacity;
- en: '}'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return (newCapacity - MAX_ARRAY_SIZE <= 0)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: return (newCapacity - MAX_ARRAY_SIZE <= 0)
- en: '? newCapacity'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '? newCapacity'
- en: ': hugeCapacity(minCapacity);'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ': hugeCapacity(minCapacity);'
- en: '}'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, when the allocated array size is not enough for storing another
    element, the new array is created with a minimum capacity of 10\. All the already
    existing elements are copied to the new array using the `Arrays.copyOf()` method
    (we will talk about the `Arrays` class later in this chapter).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: As you can see, when the allocated array size is not enough for storing another
    element, the new array is created with a minimum capacity of 10\. All the already
    existing elements are copied to the new array using the `Arrays.copyOf()` method
    (we will talk about the `Arrays` class later in this chapter).
- en: And that is why `ArrayList` was so named.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: And that is why `ArrayList` was so named.
- en: For using `List` and `ArrayList`, you do not need to know all that, unless you
    have to process really big lists of elements and the frequent copying of the underlying
    array affects the performance of your code. In such a case, consider using different
    data structures that have been designed specifically for the type of processing
    you need. But that is already outside the scope of this book. Besides, the vast
    majority of mainstream programmers have probably never used any collections that
    are not in the `java.util` package.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: For using `List` and `ArrayList`, you do not need to know all that, unless you
    have to process really big lists of elements and the frequent copying of the underlying
    array affects the performance of your code. In such a case, consider using different
    data structures that have been designed specifically for the type of processing
    you need. But that is already outside the scope of this book. Besides, the vast
    majority of mainstream programmers have probably never used any collections that
    are not in the `java.util` package.
- en: Adding elements
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Adding elements
- en: 'The `List` interface provides two methods for adding an element:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `List` interface provides two methods for adding an element:'
- en: '`add(E)`: This adds the element to the end of the list'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add(E)`: This adds the element to the end of the list'
- en: '`add(index, E)`: This inserts the element into the specified (by index, starting
    with zero) position in the list by shifting the element the specified position
    (if any) and any subsequent elements to the right by adding 1 to their indices'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add(index, E)`: This inserts the element into the specified (by index, starting
    with zero) position in the list by shifting the element the specified position
    (if any) and any subsequent elements to the right by adding 1 to their indices'
- en: Both methods can throw a `RuntimeException` if something goes wrong. So, putting
    a try-catch block around the method makes the code more robust (if the catch block
    does not simply rethrow the exception but does something meaningful). Read the
    documentation of the `List` interface API online and see what the names of the
    exceptions these methods can throw are and under which conditions they can happen.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Both methods can throw a `RuntimeException` if something goes wrong. So, putting
    a try-catch block around the method makes the code more robust (if the catch block
    does not simply rethrow the exception but does something meaningful). Read the
    documentation of the `List` interface API online and see what the names of the
    exceptions these methods can throw are and under which conditions they can happen.
- en: The `add(E)` method also returns a Boolean value (`true`/`false`) that indicates
    the success of the operation. This method overrides the method in the `Collection`
    interface, so all Java collections that extend or implement the `Collection` interface
    have it. In the case of `List` implementations, this method most likely always
    returns `true` because list allows duplicate entries. By contrast, the implementations
    of the `Set` interface return `false` if such an element is present already because
    `Set` does not allow duplicates. We will discuss this in subsequent sections,
    as well as how the code determines if two elements are the same.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: The `add(E)` method also returns a Boolean value (`true`/`false`) that indicates
    the success of the operation. This method overrides the method in the `Collection`
    interface, so all Java collections that extend or implement the `Collection` interface
    have it. In the case of `List` implementations, this method most likely always
    returns `true` because list allows duplicate entries. By contrast, the implementations
    of the `Set` interface return `false` if such an element is present already because
    `Set` does not allow duplicates. We will discuss this in subsequent sections,
    as well as how the code determines if two elements are the same.
- en: 'Now, let''s look at the examples of the `add()` method of the `List` interface''s
    usage:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'Now, let''s look at the examples of the `add()` method of the `List` interface''s
    usage:'
- en: '```java'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List list = new ArrayList();
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: List list = new ArrayList();
- en: list.add(null);
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(null);
- en: list.add(1);
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(1);
- en: list.add("ss");
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("ss");
- en: list.add(new A());
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(new A());
- en: list.add(new B());
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(new B());
- en: 'System.out.println(list);  //prints: [null, 1, ss, A, B]'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list);  //prints: [null, 1, ss, A, B]'
- en: list.add(2, 42);
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(2, 42);
- en: 'System.out.println(list);  //prints: [null, 1, 42, ss, A, B]'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list);  //prints: [null, 1, 42, ss, A, B]'
- en: '```'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the preceding list, we have mixed up in the same list values of different
    types. The classes `A` and `B`, used in the preceding code, have parent-child
    relations:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'In the preceding list, we have mixed up in the same list values of different
    types. The classes `A` and `B`, used in the preceding code, have parent-child
    relations:'
- en: '```java'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class A {
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: class A {
- en: '@Override'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String toString() { return "A"; }
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() { return "A"; }
- en: '}'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class B extends A {
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: class B extends A {
- en: '@Override'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String toString() { return "B"; }
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() { return "B"; }
- en: '}'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, we have added the `toString()` method to each of them, so we
    can see their objects printed in an expected format.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经为它们的每个添加了`toString()`方法，这样我们就可以看到它们的对象以预期的格式打印出来。
- en: size(), isEmpty(), clear()
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: size(), isEmpty(), clear()
- en: 'These three methods are straightforward:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法很简单：
- en: '`size()`: This returns count of elements in the list'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`: 这返回列表中的元素数量'
- en: '`isEmpty()`: This returns `true` if there is no elements in the list (`size()`
    returns 0)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty()`: 如果列表中没有元素，则返回`true`（`size()`返回0）'
- en: '`clear()`: This removes  all elements from the list so that `isEmpty()` returns
    `true` and `size()` returns 0'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 这将从列表中移除所有元素，使`isEmpty()`返回`true`，`size()`返回0'
- en: Iterate and stream
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历和流
- en: 'Every collection that implements the `Collection` interface (which extends
    the `Iterable` interface) can be iterated over using the enhanced `for` statement
    discussed in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*. Here is an example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Collection`接口（它扩展了`Iterable`接口）的每个集合都可以使用[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)中讨论的增强`for`语句进行迭代。以下是一个示例：
- en: '```java'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List list = new ArrayList();
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: List list = new ArrayList();
- en: list.add(null);
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(null);
- en: list.add(1);
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(1);
- en: list.add("ss");
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("ss");
- en: list.add(new A());
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(new A());
- en: list.add(new B());
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(new B());
- en: 'for(Object o: list){'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(Object o: list){'
- en: //code that does something with each element
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: //对每个元素执行某些操作的代码
- en: '}'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `Iterable` interface also adds the following three methods to the `List`
    interface:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterable`接口还向`List`接口添加了以下三种方法：'
- en: '`forEach(Consumer function)`: It applies the provided function to each collection
    element'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach(Consumer function)`: 它将提供的函数应用于每个集合元素'
- en: '`iterator()`: It returns an object of class `Iterator` that allows walking
    through (iterating) each element of the collection and manipulating each of them
    as needed'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterator()`: 它返回一个`Iterator`类的对象，允许遍历集合的每个元素并根据需要操作每个元素'
- en: '`splititerator()`: It returns an object of class `Splititerator` that allows
    splitting the collection for parallel processing (discussion of this functionality is
    outside the scope of this book)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splititerator()`: 它返回一个`Splititerator`类的对象，允许将集合拆分以进行并行处理（讨论此功能的范围超出了本书的范围）'
- en: 'In [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda Expressions
    and Functional Programming*, we will explain how the function can be passed as
    a parameter, so for now, we just show an example of the `forEach()` method''s
    usage (if we re-use the list created in the previous example):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中，*Lambda表达式和函数式编程*，我们将解释如何将函数作为参数传递，所以现在我们只展示`forEach()`方法的用法示例（如果我们重用前面示例中创建的列表）：
- en: '```java'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: list.forEach(System.out::println);
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: list.forEach(System.out::println);
- en: '```'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, the passed-in function take each element generated by the `forEach()` method
    and just prints it. It is called `Consumer` because it gets (consumes) the input
    and returns no value back it, just prints. If we run the preceding code, the result
    will be as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，传入的函数会获取`forEach()`方法生成的每个元素并将其打印出来。它被称为`Consumer`，因为它获取（消耗）输入并不返回任何值，只是打印。如果我们运行上述代码，结果将如下所示：
- en: '![](img/42802e7f-83a1-4e82-98ed-3c2ae7c83e06.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42802e7f-83a1-4e82-98ed-3c2ae7c83e06.png)'
- en: The `forEach()` method provides the same functionality as the `for` statement
    (see the previous example) but requires writing less code. That is why programmers
    love functional programming (when a function can be treated as an object), because
    after writing the same boilerplate code hundreds of times, one can enjoy the shorthand
    style.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach()`方法提供了与`for`语句相同的功能（参见前面的示例），但需要编写更少的代码。这就是为什么程序员喜欢函数式编程（当函数可以被视为对象时），因为在多次编写相同的样板代码之后，可以享受简写的风格。'
- en: 'The `Iterator` interface returned by the `iterator()` method has the following
    methods:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterator()`方法返回的`Iterator`接口具有以下方法：'
- en: '`next()`: It returns the next element in the iteration'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next()`: 它返回迭代中的下一个元素'
- en: '`hasNext ()`: It returns `true` if the iteration has more elements'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasNext()`: 如果迭代还有更多元素，则返回`true`'
- en: '`forEachRemaining (Consumer<? super E> function)`: It applies the provided
    function to each of remaining elements'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachRemaining (Consumer<? super E> function)`: 它将提供的函数应用于剩余的每个元素'
- en: '`remove()`: It removes from the underlying collection the last element returned
    by this iterator'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`: 它从基础集合中移除此迭代器返回的最后一个元素'
- en: The methods `next()` and `hasNext()` are used by `for` statements behind the
    scenes. You can also use them and in fact reproduce the `for` statement functionality.
    But why? The `for` statements are doing it already. The only reason to use the `Iterator` interface
    we could think about is to remove some objects from the list (using the `remove()` method)
    while iterating over the list. This brings us to the point of discussing a mistake
    a beginner often makes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()`和`hasNext()`方法由`for`语句在后台使用。您也可以使用它们，实际上可以重现`for`语句的功能。但是为什么呢？`for`语句已经在做这个了。我们能想到使用`Iterator`接口的唯一原因是在遍历列表时删除一些对象（使用`remove()`方法）。这让我们讨论一个初学者经常犯的错误。'
- en: 'Let''s assume we would like to remove all the objects of type `String` from
    the following list:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从以下列表中删除所有类型为`String`的对象：
- en: '```java'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List list = new ArrayList();
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: List list = new ArrayList();
- en: list.add(null);
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(null);
- en: list.add(1);
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(1);
- en: list.add("ss");
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("ss");
- en: list.add(new A());
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(new A());
- en: list.add(new B());
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(new B());
- en: '```'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Here is the code that attempts to do it, but has a defect:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是尝试执行此操作的代码，但存在缺陷：
- en: '```java'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'for(Object o: list){'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(Object o: list){'
- en: System.out.println(o);
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(o);
- en: if(o instanceof String){
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: if(o instanceof String){
- en: list.remove(o);
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: list.remove(o);
- en: '}'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we run the preceding code, the result will be as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，结果将如下所示：
- en: '![](img/b1378467-d097-4151-a4ec-64ec09d2a9e2.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1378467-d097-4151-a4ec-64ec09d2a9e2.png)'
- en: 'The `ConcurrentModificationException` was thrown because we tried to modify
    the collection while iterating over it. The `Iterator` class helps to avoid this
    problem. The following code works just fine:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentModificationException`是因为我们在迭代集合时尝试修改它。`Iterator`类有助于避免这个问题。以下代码可以正常工作：'
- en: '```java'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'System.out.println(list);  //prints: [null, 1, ss, A, B]'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list);  //prints: [null, 1, ss, A, B]'
- en: Iterator iter = list.iterator();
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Iterator iter = list.iterator();
- en: while(iter.hasNext()){
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: while(iter.hasNext()){
- en: Object o = iter.next();
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Object o = iter.next();
- en: if(o instanceof String){
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: if(o instanceof String){
- en: iter.remove();
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: iter.remove();
- en: '}'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'System.out.println(list);  //prints: [null, 1, A, B]'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list);  //prints: [null, 1, A, B]'
- en: '```'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We are not going to discuss why `Iterator` allows removing an element during
    the iteration and why the collection throws an exception in a similar situation
    for two reasons:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算讨论为什么`Iterator`允许在迭代过程中删除元素，而集合在类似情况下抛出异常的原因有两个：
- en: It requires going much deeper into the JVM implementation than an introductory
    course allows.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这需要比入门课程允许的更深入地了解JVM实现。
- en: In [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams and Pipelines*,
    we will demonstrate a more compact way to do it using Java functional programming.
    Such a code looks so clean and elegant that many programmers working with Java
    8 and higher almost never use `for` statements while working with collections
    and other data structures that generate streams.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第18章](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml)中，*流和管道*，我们将演示使用Java函数式编程更紧凑的方法。这样的代码看起来如此清晰和优雅，以至于许多使用Java
    8及更高版本的程序员在处理生成流的集合和其他数据结构时几乎不再使用`for`语句。
- en: 'There are also four other ways to iterate over a list of elements:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他四种遍历元素列表的方法：
- en: '`listIterator()` and `listIterator(index)`: Both return `ListIterator`, which
    is very similar to `Iterator` but allows going back and forth along the list (`Iterator` allows
    only going forth, as you have seen). These methods are rarely used, so we are
    going to skip their demonstration. But if you need to use them, look at the preceding `Iterator`
    example. The usage of `ListIterator` is very similar.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listIterator()`和`listIterator(index)`：两者都返回`ListIterator`，它与`Iterator`非常相似，但允许沿着列表来回移动（`Iterator`只允许向前移动，正如你所见）。这些方法很少使用，所以我们将跳过它们的演示。但是如果你需要使用它们，看一下前面的`Iterator`示例。`ListIterator`的使用非常相似。'
- en: '`stream()` and `parallelStream()`: Both return the `Stream` object, which we
    are going to discuss in more detail in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams
    and Pipelines.*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream()`和`parallelStream()`：两者都返回`Stream`对象，我们将在[第18章](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml)中更详细地讨论*流和管道*。'
- en: Add using generics
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型添加
- en: Sometimes having different types in the same list is exactly what we want. But,
    most of the time, we would like the list to contain values of the same type. Meanwhile,
    code may have logical errors that allow a different type to be added to the list,
    which can have unexpected consequences. If it leads to throwing an exception,
    it is not as bad as some default conversion and incorrect results at the end,
    which may not be noticed for a long time, if ever.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在同一个列表中具有不同类型的情况正是我们想要的。但是，大多数情况下，我们希望列表包含相同类型的值。同时，代码可能存在逻辑错误，允许添加不同类型到列表中，这可能会产生意想不到的后果。如果导致抛出异常，那就不像一些默认转换和不正确的结果那么糟糕，这可能很长时间甚至永远不会被注意到。
- en: 'To avoid such a problem, one can use generics that allow defining the expected
    type of the collection elements, so that the compiler can check and fail the case
    when a different type is added. Here is an example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这样的问题，可以使用允许定义集合元素期望类型的泛型，这样编译器可以检查并在添加不同类型时失败。这里是一个例子：
- en: '```java'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Integer> list1 = new ArrayList<>();
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: List<Integer> list1 = new ArrayList<>();
- en: list1.add(null);
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: list1.add(null);
- en: list1.add(1);
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: list1.add(1);
- en: //list1.add("ss");          //compilation error
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: //list1.add("ss");          //compilation error
- en: //list1.add(new A());       //compilation error
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: //list1.add(new A());       //compilation error
- en: //list1.add(new B());       //compilation error
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: //list1.add(new B());       //compilation error
- en: 'System.out.println(list1);  //prints: [null, 1]'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list1);  //prints: [null, 1]'
- en: list1.add(2, 42);
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: list1.add(2, 42);
- en: 'System.out.println(list1);  //prints: [null, 1, 42]'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list1);  //prints: [null, 1, 42]'
- en: '```'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, a `null` value can be added anyway, because it is a default
    value of any reference type, while, as we have pointed out at the beginning of
    this section already, the elements of any Java collection can only be of a reference
    type.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`null`值无论如何都可以被添加，因为它是任何引用类型的默认值，而正如我们在本节开头已经指出的那样，任何Java集合的元素只能是引用类型。
- en: 'Since a subclass has a type of any of its superclasses, the generic `<Object>`
    does not help to avoid the previously described problem, because every Java object
    has the `Object` class as its parent:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子类具有任何其父类的类型，泛型`<Object>`并不能帮助避免先前描述的问题，因为每个Java对象都将`Object`类作为其父类：
- en: '```java'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Object> list2= new ArrayList<>();
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: List<Object> list2= new ArrayList<>();
- en: list2.add(null);
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: list2.add(null);
- en: list2.add(1);
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: list2.add(1);
- en: list2.add("ss");
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: list2.add("ss");
- en: list2.add(new A());
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: list2.add(new A());
- en: list2.add(new B());
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: list2.add(new B());
- en: 'System.out.println(list2);    //prints: [null, 1, ss, A, B]'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list2);    //prints: [null, 1, ss, A, B]'
- en: list2.add(2, 42);
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: list2.add(2, 42);
- en: 'System.out.println(list2);    //prints: [null, 1, 42, ss, A, B]'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list2);    //prints: [null, 1, 42, ss, A, B]'
- en: '```'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But, the following generics are more restrictive:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，以下泛型更加严格：
- en: '```java'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<A> list3= new ArrayList<>();
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: List<A> list3= new ArrayList<>();
- en: list3.add(null);
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: list3.add(null);
- en: //list3.add(1);            //compilation error
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: //list3.add(1);            //compilation error
- en: //list3.add("ss");         //compilation error
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: //list3.add("ss");         //compilation error
- en: list3.add(new A());
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: list3.add(new A());
- en: list3.add(new B());
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: list3.add(new B());
- en: 'System.out.println(list3); //prints: [null, A, B]'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list3); //prints: [null, A, B]'
- en: list3.add(2, new A());
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: list3.add(2, new A());
- en: 'System.out.println(list3); //prints: [null, A, A, B]'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list3); //prints: [null, A, A, B]'
- en: List<B> list4= new ArrayList<>();
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: List<B> list4= new ArrayList<>();
- en: list4.add(null);
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: list4.add(null);
- en: //list4.add(1);            //compilation error
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: //list4.add(1);            //compilation error
- en: //list4.add("ss");         //compilation error
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: //list4.add("ss");         //编译错误
- en: //list4.add(new A());      //compilation error
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: //list4.add(new A());      //编译错误
- en: list4.add(new B());
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: list4.add(new B());
- en: 'System.out.println(list4); //prints: [null, B]'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list4); //打印：[null, B]
- en: list4.add(2, new B());
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: list4.add(2, new B());
- en: 'System.out.println(list4); //prints: [null, B, B]'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list4); //打印：[null, B, B]
- en: '```'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The only case when you might use a generic `<Object>` is when you would like
    to allow values of different types to be added to the list, but you do not want
    to allow the reference to the list itself to refer to a list with other generics:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的情况是当您可能使用泛型`<Object>`的情况是，当您希望允许添加不同类型的值到列表中，但不希望允许列表本身的引用引用具有其他泛型的列表时：
- en: '```java'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List list = new ArrayList();
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: List list = new ArrayList();
- en: List<Integer> list1 = new ArrayList<>();
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: List<Integer> list1 = new ArrayList<>();
- en: List<Object> list2= new ArrayList<>();
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: List<Object> list2= new ArrayList<>();
- en: list = list1;
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: list = list1;
- en: //list2 = list1;   //compilation error
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: //list2 = list1;   //编译错误
- en: '```'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, the list without generics (called raw type) allows its reference
    to refer to any other list with any generics, while the list with a generic `<Object>`
    does not allow its variable to refer to a list with any other generics.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，没有泛型的列表（称为原始类型）允许其引用引用任何其他具有任何泛型的列表，而具有泛型`<Object>`的列表不允许其变量引用具有任何其他泛型的列表。
- en: 'The Java collection also allows a wildcard generic, `<?>`, which allows only
    `null` to be assigned to the collection:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Java集合还允许通配符泛型`<?>`，它只允许将`null`分配给集合：
- en: '```java'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<?> list5= new ArrayList<>();
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: List<?> list5= new ArrayList<>();
- en: list5.add(null);
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: list5.add(null);
- en: //list5.add(1);            //compilation error
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: //list5.add(1);            //编译错误
- en: //list5.add("ss");         //compilation error
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: //list5.add("ss");         //编译错误
- en: //list5.add(new A());      //compilation error
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: //list5.add(new A());      //编译错误
- en: //list5.add(new B());      //compilation error
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: //list5.add(new B());      //编译错误
- en: 'System.out.println(list5); //prints: [null]'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list5); //打印：[null]
- en: //list5.add(1, 42);        //compilation error
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: //list5.add(1, 42);        //编译错误
- en: '```'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'An example of the usage of the wildcard generics can be demonstrated as follows.
    Let''s assume that we write a method that has `List` (or any collection, for that
    matter) as a parameter but we would like to ensure that this list will be not
    modified inside the method, which changes the original list. Here is an example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 可以演示通配符泛型的用法示例。假设我们编写一个具有`List`（或任何集合）作为参数的方法，但我们希望确保此列表在方法内部不会被修改，而这会更改原始列表。这是一个例子：
- en: '```java'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void doSomething(List<B> list){
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: void doSomething(List<B> list){
- en: //some othe code goes here
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: //some othe code goes here
- en: list.add(null);
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(null);
- en: list.add(new B());
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(new B());
- en: list.add(0, new B());
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(0, new B());
- en: //some other code goes here
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: //some other code goes here
- en: '}'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we use the preceding method, we get an undesirable side effect:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用前面的方法，我们会得到一个不良的副作用：
- en: '```java'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<B> list= new ArrayList<>();
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: List<B> list= new ArrayList<>();
- en: 'System.out.println(list); //prints: [B]'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list); //打印：[B]
- en: list.add(0, null);
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(0, null);
- en: 'System.out.println(list); //prints: [null, B]'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list); //打印：[null, B]
- en: doSomething(list);
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: doSomething(list);
- en: System.out.println(list); //[B, null, B, null, B]
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list); //[B, null, B, null, B]
- en: '```'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To avoid the side effect, one can write:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免副作用，可以编写：
- en: '```java'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void doSomething(List<?> list){
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: void doSomething(List<?> list){
- en: list.add(null);
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(null);
- en: //list.add(1);            //compilation error
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: //list.add(1);            //编译错误
- en: //list.add("ss");         //compilation error
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: //list.add("ss");         //编译错误
- en: //list.add(new A());      //compilation error
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: //list.add(new A());      //编译错误
- en: //list.add(new B());      //compilation error
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: //list.add(new B());      //编译错误
- en: //list.add(0, 42);        //compilation error
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: //list.add(0, 42);        //编译错误
- en: '}'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, this way the list cannot be modified, except by adding `null`.
    Well, it comes at a price of removing the generic, `<B>`. Now, it is possible
    that the passed-in list contains objects of different types, and the typecasting
    `(B)` will throw `ClassCastException`. Nothing comes free, but the possibilities
    are available.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这种方式列表无法修改，除了添加`null`。好吧，这是以删除泛型`<B>`的代价。现在，可能传入的列表包含不同类型的对象，类型转换`(B)`将抛出`ClassCastException`。没有免费的东西，但可能性是可用的。
- en: As in the case of an encapsulation, the best practice recommends using as many
    narrow (or specialized) a types for generics as possible. This ensures much lower
    chances of unexpected behavior.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 就像封装一样，最佳实践建议尽可能使用尽可能窄（或专门的）类型的泛型。这可以确保意外行为的机会大大降低。
- en: To prevent the collection from being modified inside the method, it is possible
    to make the collection immutable. It can be done inside or outside the method
    (before passing it as the parameter). We will show you how to do it in the [Chapter
    14](5c3dd438-a957-4fcc-b8e8-045ea7b43277.xhtml), *Managing Collections and Arrays*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止集合在方法内部被修改，可以使集合不可变。可以在方法内部或外部（在将其作为参数传递之前）进行。我们将向您展示如何在[第14章](5c3dd438-a957-4fcc-b8e8-045ea7b43277.xhtml)中执行此操作，*管理集合和数组*。
- en: Add collection
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加集合
- en: 'Two methods of the `List` interface allow adding the whole collection of objects
    to the existing list:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`接口的两种方法允许将整个对象集合添加到现有列表中：'
- en: '`addAll(Collection<? extends E> collection)`: It adds the provided collection
    of objects to the end of the list.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addAll(Collection<? extends E> collection)`: 它将提供的对象集合添加到列表的末尾。'
- en: '`addAll(int index, Collection<? extends E> collection)`: It inserts the provided
    elements into the list at the specified position. The operation shifts the element
    currently at that position (if any) and any subsequent elements to the right (increases
    their indices by the size of the provided collection).'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addAll(int index, Collection<? extends E> collection)`: 它将提供的元素插入到列表的指定位置。该操作将当前在该位置的元素（如果有）和任何后续元素向右移动（将它们的索引增加提供的集合的大小）。'
- en: 'Both methods throw several `RuntimeExceptions` if something goes wrong. Also,
    both methods return a Boolean value:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，这两种方法都会抛出几个`RuntimeExceptions`。此外，这两种方法都返回一个布尔值：
- en: '`false`: If the list has not changed after this method invocation'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`：如果此方法调用后列表未更改'
- en: '`true`: If the list has changed'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`：如果列表已更改'
- en: As in the case of adding a single element, all `List` implementations of these
    methods most likely always return true because `List` allows duplicates, which
    is not the case for `Set` (we will discuss this shortly).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 与添加单个元素的情况一样，这些方法的所有`List`实现很可能总是返回true，因为`List`允许重复，而`Set`不允许（我们将很快讨论这一点）。
- en: 'If you have read the description of generics a few pages back, you can guess
    what the notation `Collection<? extends E>` means.  The generic `<? extends E>`
    means a type that is either `E` or a child of `E`, where `E` is the type used
    as the generics of the collection. To relate to our previous examples, observe
    the following, classes, `A` and `B`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在几页前阅读了泛型的描述，您可以猜到符号`Collection<? extends E>`的含义。泛型`<? extends E>`表示的是`E`或`E`的子类类型，其中`E`是用作集合泛型的类型。与我们之前的例子相关，观察以下类`A`和`B`：
- en: '```java'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class A {
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: class A {
- en: '@Override'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String toString() { return "A"; }
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() { return "A"; }
- en: '}'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class B extends A {
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: class B extends A {
- en: '@Override'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String toString() { return "B"; }
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() { return "B"; }
- en: '}'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We can add to `List<A>` objects of classes `A` and of `B`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向`List<A>`对象添加`A`类和`B`类的对象。
- en: The notation `addAll(Collection<? extends E> collection)` means this method
    allows the addition to `List<E>` objects of type `E` or any subtype of `E`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 符号`addAll(Collection<? extends E> collection)`表示此方法允许向`List<E>`对象添加类型为`E`或`E`的任何子类型的对象。
- en: 'As an example, we can do the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以这样做：
- en: '```java'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<A> list = new ArrayList<>();
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: List<A> list = new ArrayList<>();
- en: list.add(new A());
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(new A());
- en: List<B> list1 = new ArrayList<>();
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: List<B> list1 = new ArrayList<>();
- en: list1.add(new B());
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: list1.add(new B());
- en: list.addAll(list1);
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: list.addAll(list1);
- en: 'System.out.println(list);    //prints: [A, B]'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list);    //输出：[A, B]
- en: '```'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `addAll(int index, Collection<? extends E> collection)` method acts very
    similar, but only starting from the specified index. And, of course, the value
    of the provided index should be equal to 0 or less than the length of the list.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`addAll(int index, Collection<? extends E> collection)`方法的作用非常相似，但是只从指定的索引开始。当然，提供的索引值应该等于0或小于列表的长度。'
- en: For the `addAll(int index, Collection<? extends E> collection)` method, the
    value of the provided index should be equal to 0 or less than the length of the
    list.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`addAll(int index, Collection<? extends E> collection)`方法，提供的索引值应该等于0或小于列表的长度。
- en: Implementing equals() and hashCode()
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现equals()和hashCode()
- en: This is a very important subsection because, more often than not, while creating
    a class, programmers are focused on the main functionality and forget to implement
    the `equals()` and `hashCode()` methods. It does not cause any problems until
    objects are compared using the `equals()` method or added to a collection and
    then searched or assumed to be unique (in the case of `Set`).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的子部分，因为在创建类时，程序员往往会专注于主要功能，忘记实现`equals()`和`hashCode()`方法。直到使用`equals()`方法比较对象或将对象添加到集合并进行搜索或假定为唯一（在`Set`的情况下）时，才会出现问题。
- en: As we demonstrated in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*, the `equals()` method can be used for
    object identification. If a class does not override the default implementation
    of the `equals()` method in the base class `Object`, then every object is unique.
    Even if two objects of the same class have the same state, the default `equals()` method
    reports them as different. So, if you need two objects of the same class with
    the same state being treated as equal, you have to implement the `equals()` method
    in that class, so that it overrides the default implementation in `Object`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)中所演示的，*运算符、表达式和语句*，`equals()`方法可用于对象标识。如果一个类没有覆盖基类`Object`中`equals()`方法的默认实现，那么每个对象都是唯一的。即使两个相同类的对象具有相同的状态，默认的`equals()`方法也会将它们报告为不同。因此，如果您需要将相同状态的同一类的两个对象视为相等，您必须在该类中实现`equals()`方法，以覆盖`Object`中的默认实现。
- en: Since every Java collection is using the `equals()` method while searching for
    the object among its elements, you have to implement it, because a typical business
    logic requires including the object state or at least some of the state values
    into consideration during the object identification process. You also have to
    decide on which level of the class inheritance chain two children should be considered
    equal, as we discussed in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*, while comparing objects of the classes  `PersonWithHair`
    and `PersonWithHairDressed`; both extend the `Person` class. We decided then that
    the objects of these classes represent the same person if they are equal according
    to the `equals()` method implemented in the `Person` class. We also decided to
    consider for the purpose of the identification (equality) only the fields `age`
    and `name`, although the `Person` class may have had several other fields (such
    as `currentAddress`, for example) which are not relevant for the person's identification.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个Java集合在搜索其元素时都使用`equals()`方法，因此您必须实现它，因为典型的业务逻辑要求在对象标识过程中包含对象状态或至少一些状态值。您还必须决定在类继承链的哪个级别应该将两个子类视为相等，就像我们在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)中讨论的那样，*运算符、表达式和语句*，比较`PersonWithHair`和`PersonWithHairDressed`类的对象时；两者都扩展了`Person`类。我们当时决定，如果这些类的对象根据`Person`类中实现的`equals()`方法相等，则这些类的对象代表同一个人。我们还决定仅考虑`age`和`name`字段，尽管`Person`类可能有其他几个字段（例如`currentAddress`），这些字段对于人的标识并不相关。
- en: 'So, if you expect that the class you create will be used for generating objects
    that will be used as members of some Java collection, you''d better implement
    the `equals()` method. To do it, you have to make two decisions:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您期望创建的类将用于生成将用作某些Java集合成员的对象，则最好实现`equals()`方法。要做到这一点，您必须做出两个决定：
- en: On which level of the class inheritance hierarchy to implement the method
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类继承层次结构的哪个级别实现该方法
- en: Which fields of the object (which aspects of the object state, in other words)
    to include into the consideration
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的哪些字段（换句话说，对象状态的哪些方面）包括在考虑中
- en: The `equals()` method is used by Java collections for the element identification.
    While implementing the `equals()` method, consider doing it in one of the parent classes
    and decide which fields to use while comparing two objects.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals()`方法被Java集合用于元素识别。在实现`equals()`方法时，考虑在一个父类中进行，并决定在比较两个对象时使用哪些字段。'
- en: 'The method `hashCode()` is not used by the `List` implementation, so we will
    discuss it in more detail in relation to the implementations of the interfaces
    `Set` and `Map` in the following code. But since we are on the topic here, we
    would like to mention that the best Java programming practices recommend implementing
    the `hashCode()` method every time the `equals()` method is implemented. While
    doing it, use the same fields that the `equals()` method uses. For example, the
    `Person` class we implemented in  [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators,
    Expressions, and Statements*, should look like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashCode()`方法未被`List`实现使用，因此我们将在接下来的代码中更详细地讨论它与接口`Set`和`Map`的实现相关。但是，由于我们正在讨论这个话题，我们想提到最佳的Java编程实践建议在实现`equals()`方法时每次都实现`hashCode()`方法。在这样做时，使用`equals()`方法使用的相同字段。例如，我们在[第9章](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml)中实现的`Person`类，应该如下所示：'
- en: '```java'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class Person{
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 类人{
- en: private int age;
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: private int age;
- en: private String name, currentAddress;
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: private String name, currentAddress;
- en: public Person(int age, String name, String currAddr) {
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: public Person(int age, String name, String currAddr) {
- en: this.age = age;
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: this.age = age;
- en: this.name = name;
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: this.name = name;
- en: this.currentAddress = currAddr;
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: this.currentAddress = currAddr;
- en: '}'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public boolean equals(Object o) {
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean equals(Object o) {
- en: if (this == o) return true;
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: if (this == o) return true;
- en: if (o == null) return false;
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: if (o == null) return false;
- en: if(!(o instanceof Person)) return false;
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果(!(o instanceof Person)) return false;
- en: Person person = (Person)o;
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Person person = (Person)o;
- en: return age == person.getAge() &&
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: return age == person.getAge() &&
- en: Objects.equals(name, person.getName());
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Objects.equals(name, person.getName());
- en: '}'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public int hashCode(){
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: public int hashCode(){
- en: return Objects.hash(age, name);
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: return Objects.hash(age, name);
- en: '}'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, we have added an implementation of the `hashCode()` method based
    on the `hash()` method of the `Objects` class, which we will discuss later in
    this chapter. We have also added a new field, but will not use it in either the `equals()` method nor
    in the `hashCode()` method, because we think it is not relevant for a person's
    identification.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经根据`Objects`类的`hash()`方法添加了`hashCode()`方法的实现，我们将在本章后面讨论。我们还添加了一个新字段，但是在`equals()`方法和`hashCode()`方法中都不会使用它，因为我们认为它与人的身份无关。
- en: Every time you implement the `equals()` method, implement the `hashCode()` method
    as well, because the object of the class you create may be used not only in a
    `List` but in `Set` or `Map` too, which requires `hashCode()` to be implemented.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 每次实现`equals()`方法时，也要实现`hashCode()`方法，因为您创建的类的对象可能不仅在`List`中使用，还可能在`Set`或`Map`中使用，这就需要实现`hashCode()`。
- en: We will talk about the motivation of the `hashCode()` method's implementation
    for `Set` and `Map` in the corresponding sections of this chapter. We will also
    explain why we cannot use `hashCode()` for the purpose of the object identification,
    similar to like when we use the `equals()` method.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的相应部分讨论`Set`和`Map`的`hashCode()`方法实现的动机。我们还将解释为什么我们不能像使用`equals()`方法一样使用`hashCode()`来进行对象识别的目的。
- en: Locating element
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位元素
- en: 'There are three methods in the `List` interface that allow checking the presence
    and location of an element in the list:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`接口中有三种方法允许检查列表中元素的存在和位置：'
- en: '`contains(E)`: It returns `true` if the provided element is present in the
    list.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains(E)`:如果列表中存在提供的元素，则返回`true`。'
- en: '`indexOf(E)`: It returns an index (position) of the provided element in the
    list. If  there are several such elements in the list, the smallest index is returned
    – the index of the first element from the left that equals the provided element.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexOf(E)`:它返回列表中提供的元素的索引（位置）。如果列表中有几个这样的元素，则返回最小的索引-等于提供的元素的最左边的第一个元素的索引。'
- en: '`lastIndexOf(E)`: It returns an index (position) of the provided element in
    the list. If there are several such elements in the list, the biggest index is
    returned – the index of the last element from the left that equals the provided
    element.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastIndexOf(E)`:它返回列表中提供的元素的索引（位置）。如果列表中有几个这样的元素，则返回最大的索引-等于提供的元素的最后一个元素的索引。'
- en: 'Here is the code that shows how to use these methods:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示如何使用这些方法的代码：
- en: '```java'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = new ArrayList<>();
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList<>();
- en: list.add("s1");
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s1");
- en: list.add("s2");
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s2");
- en: list.add("s1");
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s1");
- en: 'System.out.println(list.contains("s1"));    //prints: true'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list.contains("s1")); //打印：true
- en: 'System.out.println(list.indexOf("s1"));     //prints: 0'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list.indexOf("s1")); //打印：0
- en: 'System.out.println(list.lastIndexOf("s1")); //prints: 2'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list.lastIndexOf("s1")); //打印：2
- en: '```'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'There are two things worth noticing:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件事值得注意：
- en: The first element in the list has an index of 0 (like an array, too)
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表中的第一个元素的索引为0（也像数组一样）
- en: The preceding methods rely on the implementation of the `equals()` method to
    identify the provided object in the list
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的方法依赖于`equals()`方法的实现来识别列表中提供的对象
- en: Retrieving elements
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索元素
- en: 'There are two methods in the `List` interface that allow element retrieval:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`接口中有两种允许检索元素的方法：'
- en: '`get(index)`: It returns the element that has the provided index'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(index)`: 它返回具有提供索引的元素'
- en: '`sublist(index1, index2)`: It returns the list of elements starting with `index1`
    until (but not including) the element that has `index2`'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sublist(index1, index2)`: 它返回从`index1`开始的元素列表，直到`index2`之前的元素'
- en: 'The following code demonstrates how these methods can be used:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何使用这些方法：
- en: '```java'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = new ArrayList<>();
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList<>();
- en: list.add("s1");
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s1");
- en: list.add("s2");
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s2");
- en: list.add("s3");
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s3");
- en: 'System.out.println(list.get(1));       //prints: s2'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list.get(1));       //prints: s2'
- en: 'System.out.println(list.subList(0,2)); //prints: [s1, s2]'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list.subList(0,2)); //prints: [s1, s2]'
- en: '```'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Removing elements
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除元素
- en: 'There are four methods in the `List` interface that remove (delete) elements
    from the list:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`接口中有四种方法可以删除列表中的元素：'
- en: '`remove(index)`: It removes an element that has the provided index and returns
    the removed element'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(index)`: 它删除具有提供索引的元素并返回被删除的元素'
- en: '`remove(E)`: It removes the provided element and returns `true` if the list
    contained it'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(E)`: 它删除提供的元素并返回`true`，如果列表包含它'
- en: '`removeAll(Collection)`: It removes the provided elements and returns `true` if
    the list has changed'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeAll(Collection)`: 它删除提供的元素并返回`true`，如果列表已更改'
- en: '`retainAll(Collection)`: It removes all the elements that are not in the provided
    collection and returns `true` if the list has changed'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retainAll(Collection)`: 它删除不在提供的集合中的所有元素，并返回`true`，如果列表已更改'
- en: 'Two points we would like to make about these methods:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要提出这些方法的两点：
- en: The last three methods use the `equals()` method to identify the elements to
    be removed or retained
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后三种方法使用`equals()`方法来识别要删除或保留的元素
- en: If one or more elements were removed from the list, the indices of the remaining
    elements are recalculated
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果列表中有一个或多个元素被移除，剩余元素的索引将被重新计算
- en: 'Let''s look at the code examples now:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看代码示例：
- en: '```java'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = new ArrayList<>();
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList<>();
- en: list.add("s1");
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s1");
- en: list.add("s2");
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s2");
- en: list.add("s3");
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s3");
- en: list.add("s1");
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s1");
- en: 'System.out.println(list.remove(1));    //prints: s2'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list.remove(1));    //prints: s2'
- en: 'System.out.println(list);              //prints: [s1, s3, s1]'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list);              //prints: [s1, s3, s1]'
- en: //System.out.println(list.remove(5));  //throws IndexOutOfBoundsException
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: //System.out.println(list.remove(5));  //throws IndexOutOfBoundsException
- en: 'System.out.println(list.remove("s1")); //prints: true'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list.remove("s1")); //prints: true'
- en: 'System.out.println(list);              //prints: [s3, s1]'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list);              //prints: [s3, s1]'
- en: 'System.out.println(list.remove("s5")); //prints: false'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list.remove("s5")); //prints: false'
- en: 'System.out.println(list);              //prints: [s3, s1]'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list);              //prints: [s3, s1]'
- en: '```'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the preceding code, it is worth noticing that the list has two elements, `s1`
    but only the first from the left is removed by the statement `list.remove("s1")`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，值得注意的是列表有两个元素`s1`，但是只有左边的第一个被语句`list.remove("s1")`移除：
- en: '```java'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = new ArrayList<>();
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList<>();
- en: list.add("s1");
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s1");
- en: list.add("s2");
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s2");
- en: list.add("s3");
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s3");
- en: list.add("s1");
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s1");
- en: System.out.println(list.removeAll(List.of("s1", "s2", "s5")));   //true
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list.removeAll(List.of("s1", "s2", "s5")));   //true
- en: System.out.println(list);                                        //[s3]
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list);                                        //[s3]
- en: System.out.println(list.removeAll(List.of("s5")));               //false
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list.removeAll(List.of("s5")));               //false
- en: System.out.println(list);                                        //[s3]
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list);                                        //[s3]
- en: '```'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To save space, we have used the `of()` method to create a list, which we will
    discuss in [Chapter 14](5c3dd438-a957-4fcc-b8e8-045ea7b43277.xhtml), *Managing
    Collections and Arrays*. By contrast with the previous example, the statement
    `list.removeAll("s1","s2","s5")` in the preceding code removed both elements `s1`
    from the list:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，我们使用`of()`方法创建一个列表，我们将在[第14章](5c3dd438-a957-4fcc-b8e8-045ea7b43277.xhtml)中讨论，*管理集合和数组*。与前面的例子相比，在前面的代码中语句`list.removeAll("s1","s2","s5")`移除了列表中的两个元素`s1`：
- en: '```java'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = new ArrayList<>();
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList<>();
- en: list.add("s1");
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s1");
- en: list.add("s2");
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s2");
- en: list.add("s3");
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s3");
- en: list.add("s1");
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s1");
- en: System.out.println(list.retainAll(List.of("s1","s2","s5"))); //true
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list.retainAll(List.of("s1","s2","s5"))); //true
- en: System.out.println(list);                                    //[s1, s2, s1]
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list);                                    //[s1, s2, s1]
- en: System.out.println(list.retainAll(List.of("s1","s2","s5"))); //false
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list.retainAll(List.of("s1","s2","s5"))); //false
- en: System.out.println(list);                                    //[s1, s2, s1]
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list);                                    //[s1, s2, s1]
- en: System.out.println(list.retainAll(List.of("s5")));           //true
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list.retainAll(List.of("s5")));           //true
- en: System.out.println(list);                                    //[]
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list);                                    //[]
- en: '```'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Please note in the preceding code how the `retainAll()` method returns `false`
    the second time because the list was not changed. Also, notice how the statement
    `list.retainAll(List.of("s5")` clears the list because none of its elements were
    equal to any of the provided elements.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在前面的代码中，`retainAll()`方法第二次返回`false`，因为列表没有更改。还要注意语句`list.retainAll(List.of("s5")`如何清除列表，因为它的元素都不等于提供的元素。
- en: Replacing elements
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换元素
- en: 'There are two methods in the `List` interface that allow replacing elements
    in the list:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`接口中有两种允许替换列表中元素的方法：'
- en: '`set(index, E)`: It replaces the element that has the provided index with the
    provided element'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set(index, E)`: 它用提供的元素替换具有提供索引的元素'
- en: '`replaceAll(UnaryOperator<E>)`: It replaces each element of the list with the
    result returned by the provided operation'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replaceAll(UnaryOperator<E>)`: 它用提供的操作返回的结果替换列表的每个元素'
- en: 'Here is an example of the usage of the method `set()`:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`set（）`方法的示例：
- en: '```java'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = new ArrayList<>();
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList<>();
- en: list.add("s1");
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: list.add（“s1”）;
- en: list.add("s2");
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: list.add（“s2”）;
- en: list.set(1, null);
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: list.set（1，null）;
- en: 'System.out.println(list);    //prints: [s1, null]'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（list）;    //打印：[s1，null]
- en: '```'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It is pretty straightforward and doesn't seem to require any comments.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，似乎不需要任何评论。
- en: 'The second method, `replaceAll()`, is based on the function `UnaryOperator<E>`
    – one of the Java functional interfaces introduced in Java 8\. We will discuss
    it in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda Expressions
    and Functional Programming*. For now, we would just like to show the code examples.
    They seem quite simple, so you should be able to understand how it works. Let''s
    assume we start with the following list:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法`replaceAll（）`基于函数`UnaryOperator <E>`-Java 8中引入的Java功能接口之一。我们将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中讨论它，*Lambda表达式和函数式编程*。现在，我们只是想展示代码示例。它们似乎相当简单，所以您应该能够理解它是如何工作的。假设我们从以下列表开始：
- en: '```java'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = new ArrayList<>();
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList<>();
- en: list.add("s1");
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: list.add（“s1”）;
- en: list.add("s2");
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: list.add（“s2”）;
- en: list.add("s3");
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: list.add（“s3”）;
- en: list.add("s1");
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: list.add（“s1”）;
- en: '```'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And here are a few possible element modifications (just remember that the `replaceAll()`
    method replaces each element with the result returned by the provided function):'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可能的元素修改（只需记住`replaceAll（）`方法用提供的函数返回的结果替换每个元素）：
- en: '```java'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: list.replaceAll(s -> s.toUpperCase()); //cannot process null
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: list.replaceAll（s->s.toUpperCase（））; //无法处理null
- en: 'System.out.println(list);    //prints: [S1, S2, S3, S1]'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list);    //打印：[S1，S2，S3，S1]
- en: 'list.replaceAll(s -> ("S1".equals(s) ? "S5" : null));'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: list.replaceAll（s->（“S1”。equals（s）？“S5”：null））;
- en: 'System.out.println(list);    //prints: [S5, null, null, S5]'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（list）;    //打印：[S5，null，null，S5]
- en: list.replaceAll(s -> "a");
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: list.replaceAll（s->“a”）;
- en: 'System.out.println(list);    //prints: [a, a, a, a]'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（list）;    //打印：[a，a，a，a]
- en: list.replaceAll(s -> {
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: list.replaceAll（s->{
- en: String result;
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: String result;
- en: //write here any code you need to get the value
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: //在这里写任何你需要获取值的代码
- en: // for the variable result based in the value of s
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: //基于s的值返回变量结果
- en: System.out.println(s);   //prints "a" four times
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（s）;   //打印四次“a”
- en: result = "42";
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 结果=“42”;
- en: return result;
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 返回结果;
- en: '});'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '}）;'
- en: 'System.out.println(list);    //prints: [42, 42, 42, 42]'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（list）;    //打印：[42，42，42，42]
- en: '```'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the last example, we have put the body of the operation in braces `{}` and
    added an explicit `return` statement, so you can see what we mean when we say
    the operation returns the result.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，我们将操作的主体放在大括号`{}`中，并添加了一个显式的`return`语句，这样您就可以看到我们所说的操作返回的结果。
- en: While comparing the elements of a collection with a `String` literal or any
    other object using the `equals()` method, it is a good habit to invoke `equals()`
    on the literal, such as `"s1".equals(element)`, or on the object you use to compare
    with, such as `someObject.equals(element)`. It helps to avoid `NullPointerException`
    in case the collection has a `null` value.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`equals（）`方法将集合的元素与`String`文字或任何其他对象进行比较时，习惯上在文字上调用`equals（）`，例如`"s1"。equals（element）`，或者在您用来比较的对象上调用`equals（element）`，例如`someObject.equals（element）`。这有助于避免`NullPointerException`，以防集合具有`null`值。
- en: 'The preceding examples of functions can be re-written as follows:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将上述函数的示例重写如下：
- en: '```java'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: UnaryOperator<String> function = s -> s.toUpperCase();
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: UnaryOperator<String> function = s->s.toUpperCase（）;
- en: list.replaceAll(function);
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: list.replaceAll(function);
- en: 'function = s -> ("S1".equals(s) ? "S5" : null);'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: function = s ->（“S1”。equals（s）？“S5”：null）;
- en: list.replaceAll(function);
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: list.replaceAll（function）;
- en: function = s -> "a";
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: function = s -> "a";
- en: list.replaceAll(function);
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: list.replaceAll（function）;
- en: function = s -> {
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: function = s->{
- en: String result;
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: String result;
- en: //write here any code you need to get the value
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: //在这里写任何你需要获取值的代码
- en: // for the variable result based in the value of s
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: //基于s的值返回变量结果
- en: System.out.println(s);   //prints "a" four times
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（s）;   //打印四次“a”
- en: result = "42";
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 结果=“42”;
- en: return result;
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 返回结果;
- en: '};'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: list.replaceAll(function);
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: list.replaceAll（function）;
- en: '```'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This way, they can be passed around as any other parameters, and that is the
    power of functional programming. But again, we will talk more about it and explain
    all the syntax in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda
    Expressions and Functional Programming*.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，它们可以像任何其他参数一样传递，这就是函数式编程的威力。但是，我们将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中更多地讨论它，并解释所有的语法，*Lambda表达式和函数式编程*。
- en: Sorting String and numeral types
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序字符串和数字类型
- en: As we have mentioned already, a collection of type `List` preserves an order
    of the elements, so, naturally, it has also an ability to sort the elements, and
    the `sort(Comparator<E>)` method serves this purpose. This method became possible
    after functional programming was introduced with Java 8\. We will talk about it
    in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda Expressions
    and Functional Programming*.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，类型为`List`的集合保留了元素的顺序，因此自然地，它也有对元素进行排序的能力，`sort（Comparator <E>）`方法就是为此而服务的。这种方法是在Java
    8引入函数式编程后才可能的。我们将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中讨论它，*Lambda表达式和函数式编程*。
- en: 'Now, we will just show you a few examples and point where to look for the standard
    comparators. We start with the following list:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向您展示一些示例，并指出标准比较器的位置。我们从以下列表开始：
- en: '```java'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = new ArrayList<>();
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList<>();
- en: list.add("s3");
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: list.add（“s3”）;
- en: list.add("s2");
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: list.add（“s2”）;
- en: list.add("ab");
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: list.add（“ab”）;
- en: //list.add(null); //throws NullPointerException for sorting
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: //list.add（null）; //对于排序会抛出NullPointerException
- en: //     String.CASE_INSENSITIVE_ORDER
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: //     String.CASE_INSENSITIVE_ORDER
- en: //     Comparator.naturalOrder()
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: //     Comparator.naturalOrder()
- en: //     Comparator.reverseOrder()
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: //     Comparator.reverseOrder()```
- en: list.add("a");
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: list.add（“a”）;
- en: list.add("Ab");
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: list.add（“Ab”）;
- en: System.out.println(list);                //[s3, s2, ab, a, Ab]
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（list）;                //[s3，s2，ab，a，Ab]
- en: '```'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And here are a few examples of sorting:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些排序的示例：
- en: '```java'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: list.sort(String.CASE_INSENSITIVE_ORDER);
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: list.sort(String.CASE_INSENSITIVE_ORDER);
- en: System.out.println(list);                //[a, ab, Ab, s2, s3]
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list); //[a, ab, Ab, s2, s3]
- en: list.sort(Comparator.naturalOrder());
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: list.sort(Comparator.naturalOrder());
- en: System.out.println(list);               //[Ab, a, ab, s2, s3]
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list); //[Ab, a, ab, s2, s3]
- en: list.sort(Comparator.reverseOrder());
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: list.sort(Comparator.reverseOrder());
- en: System.out.println(list);               //[Ab, a, ab, s2, s3]
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list); //[Ab, a, ab, s2, s3]
- en: '```'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The preceding sortings are not null-safe, as the preceding comments point out.
    You can know this by reading API documentation about the preceding comparators
    or just by experimenting with them. One often tries various edge cases even after
    reading the documentation, to understand the described functionality better and
    to see if you understand the description correctly.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的排序不是空安全的，正如前述的注释所指出的。您可以通过阅读有关前述比较器的API文档或仅通过尝试来了解这一点。即使在阅读文档后，人们通常也会尝试各种边缘情况，以更好地理解所描述的功能，并查看自己是否正确理解了描述。
- en: 'There are also comparators that handle `null` values:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 还有处理`null`值的比较器：
- en: '```java'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: list.add(null);
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(null);
- en: list.sort(Comparator.nullsFirst(Comparator.naturalOrder()));
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: list.sort(Comparator.nullsFirst(Comparator.naturalOrder()));
- en: System.out.println(list);              //[null, Ab, a, ab, s2, s3]
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list); //[null, Ab, a, ab, s2, s3]
- en: list.sort(Comparator.nullsLast(Comparator.naturalOrder()));
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: list.sort(Comparator.nullsLast(Comparator.naturalOrder()));
- en: System.out.println(list);              //[Ab, a, ab, s2, s3, null]
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list); //[Ab, a, ab, s2, s3, null]
- en: '```'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, many popular comparators can be found as static methods of
    class `java.util.Comparator`. But if you do not see a ready-to-use comparator
    you need, you can also write your own. For example, let''s assume we need to sort
    null value so as if it is `String` value "null". For such a case, we can write
    a  custom comparator:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，许多流行的比较器都可以在`java.util.Comparator`类的静态方法中找到。但是，如果您找不到所需的现成比较器，也可以编写自己的比较器。例如，假设我们需要对空值进行排序，使其像`String`值“null”一样。对于这种情况，我们可以编写一个自定义比较器：
- en: '```java'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Comparator<String> comparator = (s1, s2) ->{
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: Comparator<String> comparator =（s1，s2） - > {
- en: 'String s = (s1 == null ? "null" : s1);'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串s =（s1 == null？"null"：s1）;
- en: return s.compareTo(s2);
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: return s.compareTo(s2);
- en: '};'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: list.sort(comparator);
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: list.sort(comparator);
- en: System.out.println(list);              //[Ab, a, ab, null, s2, s3]
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list); //[Ab, a, ab, null, s2, s3]
- en: '```'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'There are also comparators for various number types in `Comparator` class:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparator`类中还有各种数字类型的比较器：'
- en: '`comparingInt(ToIntFunction<? super T> keyExtractor)`'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comparingInt(ToIntFunction<? super T> keyExtractor)`'
- en: '`comparingLong(ToLongFunction<? super T> keyExtractor)`'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comparingLong(ToLongFunction<? super T> keyExtractor)`'
- en: '`comparingDouble(ToDoubleFunction<? super T> keyExtractor)`'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comparingDouble(ToDoubleFunction<? super T> keyExtractor)`'
- en: We leave them for the readers to study on their own if they need to use these
    methods for numbers comparison. However, it seems that most mainstream programmers
    never use them; the ready-to-use comparators we have demonstrated are usually
    more than enough.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将它们留给读者自行研究，如果需要使用这些方法进行数字比较。但是，似乎大多数主流程序员从不使用它们；我们演示的现成比较器通常已经足够了。
- en: Sorting custom objects
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序自定义对象
- en: 'One of the more frequently encountered cases is the need to sort custom objects,
    such as `Car`, or `Person` type, for example. To do it, there are two options:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个经常遇到的情况是需要对自定义对象进行排序，例如`Car`或`Person`类型。为此，有两种选择：
- en: Implement the `Comparable` interface. It has only one method, `compareTo(T)`,
    which accepts an object of the same type and returns a negative integer, zero,
    or a positive integer if this object is less than, equal to, or greater than the
    specified object. Such an implementation is called a natural ordering because
    objects that implement the `Comparable` interface can be ordered by the method
    `sort()` of a collection. Many of the examples of the previous subsection demonstrated
    how it works for the objects of type `String`. Comparators are returned by the
    methods `naturalOrder()`, `reverseOrder()`, `nullFirst()`, and `nullLast()` –
    they all are based on using the `compareTo()` implementation.
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Comparable`接口。它只有一个方法`compareTo（T）`，它接受相同类型的对象并返回负整数，零或正整数，如果此对象小于，等于或大于指定对象。这样的实现称为自然排序，因为实现`Comparable`接口的对象可以通过集合的`sort()`方法进行排序。前一小节的许多示例演示了它如何适用于`String`类型的对象。比较器由方法`naturalOrder()`，`reverseOrder()`，`nullFirst()`和`nullLast()`返回-它们都基于使用`compareTo()`实现。
- en: Implement an external comparator that compares two objects of the type of collection
    elements using the static `comparing()` method of the `Comparator` class.
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个外部比较器，使用`Comparator`类的静态`comparing()`方法比较集合元素类型的两个对象。
- en: 'Let''s see the code examples for each of the preceding options and discuss
    the pros and cons of each approach. First, let enhance the classes `Person`, `PersonWithHair`,
    and `PersonWithHairDressed` and implement the `Comparable` interface:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个前述选项的代码示例，并讨论每种方法的利弊。首先，增强`Person`，`PersonWithHair`和`PersonWithHairDressed`类，并实现`Comparable`接口：
- en: '```java'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class Person implements Comparable<Person> {
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: class Person implements Comparable<Person> {
- en: private int age;
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: private int age;
- en: private String name, address;
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: private String name, address;
- en: public Person(int age, String name, String address) {
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: public Person(int age, String name, String address) {
- en: this.age = age;
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: this.age = age;
- en: 'this.name = name == null ? "" : name;'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: this.name = name == null？""：name;```
- en: this.address = address;
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: this.address = address;
- en: '}'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public int compareTo(Person p){
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: public int compareTo(Person p){
- en: return name.compareTo(p.getName());
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: return name.compareTo(p.getName());
- en: '}'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public boolean equals(Object o) {
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean equals(Object o) {
- en: if (this == o) return true;
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: if（this == o）返回true;
- en: if (o == null) return false;
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: if（o == null）返回false;
- en: if(!(o instanceof Person)) return false;
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: if（！（o instanceof Person））返回false;
- en: Person person = (Person)o;
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: Person person =（Person）o;
- en: return age == person.getAge() &&
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: return age == person.getAge() &&
- en: Objects.equals(name, person.getName());
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: Objects.equals(name, person.getName());
- en: '}'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public int hashCode(){ return Objects.hash(age, name); }
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: public int hashCode(){ return Objects.hash(age, name); }
- en: '@Override'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String toString() { return "Person{age=" + age +
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() { return "Person{age=" + age +
- en: '", name=" + name + "}";'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '", name=" + name + "}";'
- en: '}'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, we have added another instance field, `address`, but do not
    use it in either the  `equals()`, `hashCode()`, or `compareTo()` methods. We did
    it just to show that it is completely up to you how to define the identity of
    the object of class `Person` and its children.  We also implemented the `toString()` method
    (which prints only the fields included in the identity), so we can identify each
    object when they are displayed. And we have implemented the method of the `Comparable`
    interface, `compareTo()`, which is going to be used for sorting. Right now it
    takes into account only the name, so when sorted, the objects will be ordered
    by name.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: As you can see, we have added another instance field, `address`, but do not
    use it in either the  `equals()`, `hashCode()`, or `compareTo()` methods. We did
    it just to show that it is completely up to you how to define the identity of
    the object of class `Person` and its children.  We also implemented the `toString()` method
    (which prints only the fields included in the identity), so we can identify each
    object when they are displayed. And we have implemented the method of the `Comparable`
    interface, `compareTo()`, which is going to be used for sorting. Right now it
    takes into account only the name, so when sorted, the objects will be ordered
    by name.
- en: 'The children of class `Person` did not change:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 'The children of class `Person` did not change:'
- en: '```java'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class PersonWithHair extends Person {
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: class PersonWithHair extends Person {
- en: private String hairstyle;
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: private String hairstyle;
- en: public PersonWithHair(int age, String name,
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: public PersonWithHair(int age, String name,
- en: String address, String hairstyle) {
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: String address, String hairstyle) {
- en: super(age, name, address);
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: super(age, name, address);
- en: this.hairstyle = hairstyle;
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: this.hairstyle = hairstyle;
- en: '}'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class PersonWithHairDressed extends PersonWithHair{
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: class PersonWithHairDressed extends PersonWithHair{
- en: private String dress;
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: private String dress;
- en: public PersonWithHairDressed(int age, String name,
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: public PersonWithHairDressed(int age, String name,
- en: String address, String hairstyle, String dress) {
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: String address, String hairstyle, String dress) {
- en: super(age, name, address, hairstyle);
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: super(age, name, address, hairstyle);
- en: this.dress = dress;
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: this.dress = dress;
- en: '}'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Now we can create the list that we are going to sort:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 'Now we can create the list that we are going to sort:'
- en: '```java'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> list = new ArrayList<>();
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list = new ArrayList<>();
- en: list.add(new PersonWithHair(45, "Bill", "27 Main Street",
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(new PersonWithHair(45, "Bill", "27 Main Street",
- en: '"Pompadour"));'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '"Pompadour"));'
- en: list.add(new PersonWithHair(42, "Kelly","15 Middle Street",
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(new PersonWithHair(42, "Kelly","15 Middle Street",
- en: '"Ponytail"));'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '"Ponytail"));'
- en: list.add(new PersonWithHairDressed(34, "Kelly", "10 Central Square",
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(new PersonWithHairDressed(34, "Kelly", "10 Central Square",
- en: '"Pompadour", "Suit"));'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '"Pompadour", "Suit"));'
- en: list.add(new PersonWithHairDressed(25, "Courtney", "27 Main Street",
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: list.add(new PersonWithHairDressed(25, "Courtney", "27 Main Street",
- en: '"Ponytail", "Tuxedo"));'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '"Ponytail", "Tuxedo"));'
- en: list.forEach(System.out::println);
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: list.forEach(System.out::println);
- en: '```'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Execution of the preceding code produces the following output:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 'Execution of the preceding code produces the following output:'
- en: '```java'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person{age=45, name=Bill}
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=45, name=Bill}
- en: Person{age=42, name=Kelly}
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=42, name=Kelly}
- en: Person{age=34, name=Kelly}
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=34, name=Kelly}
- en: Person{age=25, name=Courtney}
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=25, name=Courtney}
- en: '```'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The persons are printed in the order they were added to the list. Now, let''s
    sort them:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 'The persons are printed in the order they were added to the list. Now, let''s
    sort them:'
- en: '```java'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: list.sort(Comparator.naturalOrder());
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: list.sort(Comparator.naturalOrder());
- en: list.forEach(System.out::println);
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: list.forEach(System.out::println);
- en: '```'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The new order looks as follows:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 'The new order looks as follows:'
- en: '```java'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person{age=45, name=Bill}
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=45, name=Bill}
- en: Person{age=25, name=Courtney}
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=25, name=Courtney}
- en: Person{age=42, name=Kelly}
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=42, name=Kelly}
- en: Person{age=34, name=Kelly}
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=34, name=Kelly}
- en: '```'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The objects are ordered alphabetically by name – that is how we have implemented
    the `compareTo()` method.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: The objects are ordered alphabetically by name – that is how we have implemented
    the `compareTo()` method.
- en: 'If we use the `reverseOrder()` comparator, the order shown be reversed:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 'If we use the `reverseOrder()` comparator, the order shown be reversed:'
- en: '```java'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: list.sort(Comparator.reverseOrder());
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: list.sort(Comparator.reverseOrder());
- en: list.forEach(System.out::println);
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: list.forEach(System.out::println);
- en: '```'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This is what we see if we run the preceding code:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 'This is what we see if we run the preceding code:'
- en: '```java'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person{age=42, name=Kelly}
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=42, name=Kelly}
- en: Person{age=34, name=Kelly}
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=34, name=Kelly}
- en: Person{age=25, name=Courtney}
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=25, name=Courtney}
- en: Person{age=45, name=Bill}
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=45, name=Bill}
- en: '```'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The order was reversed.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: The order was reversed.
- en: 'We can change our implementation of the `compareTo()` method and order the
    objects by age:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 'We can change our implementation of the `compareTo()` method and order the
    objects by age:'
- en: '```java'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '@Override'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public int compareTo(Person p){
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: public int compareTo(Person p){
- en: return age - p.getAge();
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: return age - p.getAge();
- en: '}'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Or we can implement it so that the `Person` objects will be sorted by both
    fields – first by name, then by age:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 'Or we can implement it so that the `Person` objects will be sorted by both
    fields – first by name, then by age:'
- en: '```java'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '@Override'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public int compareTo(Person p){
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: public int compareTo(Person p){
- en: int result = this.name.compareTo(p.getName());
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: int result = this.name.compareTo(p.getName());
- en: if (result != 0) {
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: if (result != 0) {
- en: return result;
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: return result;
- en: '}'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return this.age - p.getAge();
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: return this.age - p.getAge();
- en: '}'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we sort the list in natural order now, the result will be:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 'If we sort the list in natural order now, the result will be:'
- en: '```java'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person{age=45, name=Bill}
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=45, name=Bill}
- en: Person{age=25, name=Courtney}
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=25, name=Courtney}
- en: Person{age=34, name=Kelly}
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=34, name=Kelly}
- en: Person{age=42, name=Kelly}
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: Person{age=42, name=Kelly}
- en: '```'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You can see that the objects are ordered by name, but two persons with the same
    name Kelly are ordered by age too.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: You can see that the objects are ordered by name, but two persons with the same
    name Kelly are ordered by age too.
- en: That is the advantage of implementing the `Comparable` interface – the sorting
    is always performed the same way. But this is also a disadvantage because to change
    the order, one has to re-implement the class. Besides, it might be not possible
    if the `Person` class comes to us from a library, so we cannot modify its code.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: That is the advantage of implementing the `Comparable` interface – the sorting
    is always performed the same way. But this is also a disadvantage because to change
    the order, one has to re-implement the class. Besides, it might be not possible
    if the `Person` class comes to us from a library, so we cannot modify its code.
- en: In such cases, the second option—using the `Comparator.comparing()` method—comes
    to the rescue. And, by the way, we can do it even when the `Person` class does
    not implement the `Comparable` interface.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: In such cases, the second option—using the `Comparator.comparing()` method—comes
    to the rescue. And, by the way, we can do it even when the `Person` class does
    not implement the `Comparable` interface.
- en: 'The `Comparator.comparing()` method accepts a function as parameter. We will
    talk about functional programming in more detail in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming*. For now, we will just say that
    the `Comparator.comparing()` method generates a comparator based on the field
    (of the class to be sorted) passed in as a parameter. Let''s see an example:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparator.comparing()`方法接受一个函数作为参数。我们将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中更详细地讨论函数式编程，*Lambda表达式和函数式编程*。现在，我们只会说`Comparator.comparing()`方法基于传递的字段（要排序的类的字段）生成一个比较器。让我们看一个例子：'
- en: '```java'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: list.sort(Comparator.comparing(Person::getName));
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: list.sort(Comparator.comparing(Person::getName));
- en: list.forEach(System.out::println);
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: list.forEach(System.out::println);
- en: '```'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The preceding code sorts `Person` objects by name. The only modification we
    had to do was adding the `getName()` method to the `Person` class. Similarly,
    if we add the `getAge()` method,  we can sort the `Person` objects by age:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码按名称对`Person`对象进行排序。我们唯一需要做的修改是向`Person`类添加`getName()`方法。同样，如果我们添加`getAge()`方法，我们可以按年龄对`Person`对象进行排序：
- en: '```java'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: list.sort(Comparator.comparing(Person::getAge));
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: list.sort(Comparator.comparing(Person::getAge));
- en: list.forEach(System.out::println);
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: list.forEach(System.out::println);
- en: '```'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Or we can sort them by both fields – exactly the same way we did it when implemented
    the `Comparable` interface:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以按照两个字段对它们进行排序 - 正如我们在实现`Comparable`接口时所做的那样：
- en: '```java'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: list.sort(Comparator.comparing(Person::getName).thenComparing(Person::getAge));
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: list.sort(Comparator.comparing(Person::getName).thenComparing(Person::getAge));
- en: list.forEach(System.out::println);
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: list.forEach(System.out::println);
- en: '```'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You can see in the preceding code how the sorting methods can be chained using
    `thenComparing()`.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到在前面的代码中如何使用`thenComparing()`链接排序方法。
- en: Most of the classes usually have getters to access the fields value, so adding
    getters typically is not needed and any library class can be sorted this way.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类通常都有getter来访问字段值，因此通常不需要添加getter，任何库类都可以这样排序。
- en: Comparing with another collection
  id: totrans-707
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与另一个集合进行比较
- en: 'Every Java collection implements the `equals()` method, which compares it with
    another collection. In the case of `List`, two lists are considered equal (the
    method `list1.equals(list2)` returns `true`) when:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Java集合都实现了`equals()`方法，用于将其与另一个集合进行比较。在`List`的情况下，当两个列表被认为是相等的（方法`list1.equals(list2)`返回`true`）时：
- en: Each collection is of type `List`
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个集合的类型都是`List`
- en: Each element of one list is equal to the element of another list in the same
    position
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个列表的每个元素都等于另一个列表中相同位置的元素
- en: 'Here is the code that illustrates it:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是说明它的代码：
- en: '```java'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list1 = new ArrayList<>();
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list1 = new ArrayList<>();
- en: list1.add("s1");
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: list1.add("s1");
- en: list1.add("s2");
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: list1.add("s2");
- en: List<String> list2 = new ArrayList<>();
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list2 = new ArrayList<>();
- en: list2.add("s1");
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: list2.add("s1");
- en: list2.add("s2");
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: list2.add("s2");
- en: 'System.out.println(list1.equals(list2)); //prints: true'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list1.equals(list2)); //prints: true'
- en: list2.sort(Comparator.reverseOrder());
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: list2.sort(Comparator.reverseOrder());
- en: 'System.out.println(list2);               //prints: [s2, s1]'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list2);               //prints: [s2, s1]'
- en: 'System.out.println(list1.equals(list2)); //prints: false'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list1.equals(list2)); //prints: false'
- en: '```'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If two lists are equal, their `hashCode()` methods return the same integer value.
    But the equality of `hashCode()` results does not guarantee that the lists are
    equal. We will talk about the reason for that while discussing the `hashCode()`
    method implementation for the elements of the `Set` collection in the next section.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个列表相等，它们的`hashCode()`方法返回相同的整数值。但是`hashCode()`结果的相等并不能保证列表相等。我们将在下一节讨论`Set`集合中元素的`hashCode()`方法实现时讨论这个原因。
- en: The `containsAll(Collection)` method of the `List` interface (or any collection
    that implements the `Collection` interface) returns `true` only if all elements
    of the provided collection are present in the list. If the size of the list and
    the size of the provided collection are equal, we can be sure that the same (well,
    equal) elements compose each of the compared collections. It does not guarantee
    though that the elements are of the same type, because they might be children
    of different generations with the `equals()` method implemented only in the common
    parent.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`接口（或实现`Collection`接口的任何集合）的`containsAll(Collection)`方法只有在提供的集合的所有元素都存在于列表中时才返回`true`。如果列表的大小和提供的集合的大小相等，我们可以确定比较的每个集合由相同（好吧，相等）的元素组成。但是它并不保证元素是相同类型的，因为它们可能是具有`equals()`方法的不同代的子类。'
- en: 'If not, we can find the difference using the methods `retainAll(Collection)`
    and `removeAll(Collection)`, described earlier in this section. Let''s assume
    we have two lists as follows:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，我们可以使用前面在本节中描述的`retainAll(Collection)`和`removeAll(Collection)`方法找到差异。假设我们有两个如下的列表：
- en: '```java'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list1 = new ArrayList<>();
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list1 = new ArrayList<>();
- en: list1.add("s1");
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: list1.add("s1");
- en: list1.add("s1");
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: list1.add("s1");
- en: list1.add("s2");
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: list1.add("s2");
- en: list1.add("s3");
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: list1.add("s3");
- en: list1.add("s4");
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: list1.add("s4");
- en: List<String> list2 = new ArrayList<>();
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list2 = new ArrayList<>();
- en: list2.add("s1");
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: list2.add("s1");
- en: list2.add("s2");
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: list2.add("s2");
- en: list2.add("s2");
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: list2.add("s2");
- en: list2.add("s5");
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: list2.add("s5");
- en: '```'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can find which elements in one list are not present in the other:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以找出一个列表中哪些元素不在另一个列表中：
- en: '```java'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = new ArrayList<>(list1);
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList<>(list1);
- en: list.removeAll(list2);
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: list.removeAll(list2);
- en: 'System.out.println(list);    //prints: [s3, s4]'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list);    //prints: [s3, s4]'
- en: list = new ArrayList<>(list2);
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: list = new ArrayList<>(list2);
- en: list.removeAll(list1);
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: list.removeAll(list1);
- en: 'System.out.println(list);    //prints: [s5]'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(list);    //prints: [s5]'
- en: '```'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice how we have created a temporary list to avoid corruption of the original
    one.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们创建了一个临时列表以避免破坏原始列表。
- en: 'But this difference does not tell us about possibly duplicate elements present
    in each of the list. To find it, we can use the `retainAll(Collection)` method:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个差异并不能告诉我们每个列表中可能存在的重复元素。为了找到它，我们可以使用`retainAll(Collection)`方法：
- en: '```java'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = new ArrayList<>(list1);
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList<>(list1);
- en: list.retainAll(list2);
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: list.retainAll(list2);
- en: 'System.out.println(list);    //prints: [s1, s1, s2]'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list);    //输出：[s1, s1, s2]
- en: list = new ArrayList<>(list2);
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: list = new ArrayList<>(list2);
- en: list.retainAll(list1);
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: list.retainAll(list1);
- en: 'System.out.println(list);    //prints: [s1, s2, s2]'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(list);    //输出：[s1, s2, s2]
- en: '```'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Now we have the full picture of the differences between the two lists.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完整地了解了这两个列表之间的区别。
- en: Also, please, notice that the `retainAll(Collection)` method can be used to
    identify the elements that belong to each of the lists.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，`retainAll(Collection)`方法可以用于识别属于每个列表的元素。
- en: But neither `retainAll(Collection)` nor `removeAll(Collection)` guarantee that
    the compared list and the collection passed in contain elements of the same type.
    They might be a mix of children with a common parent that have the `equals()` method implemented
    in the parent only, and the parent type is the type of the list and the collection
    passed in.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`retainAll(Collection)`和`removeAll(Collection)`都不能保证比较的列表和传入的集合包含相同类型的元素。它们可能是具有共同父级的子级混合，只在父级中实现了`equals()`方法，而父类型是列表和传入集合的类型。
- en: Converting to array
  id: totrans-762
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为数组
- en: 'There are two methods that allow converting a list to an array:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法允许将列表转换为数组：
- en: '`toArray()`: It converts the list to array `Object[]`'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toArray()`：它将列表转换为数组`Object[]`'
- en: '`toArray(T[])`: It converts the list to array `T[]`, where `T` is the type
    of the elements in the list'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toArray(T[])`：它将列表转换为数组`T[]`，其中`T`是列表中元素的类型'
- en: 'Both methods preserve the order of the elements. Here is the demo code that
    shows how to do it:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都保留了元素的顺序。这是演示代码，显示了如何做到这一点：
- en: '```java'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = new ArrayList<>();
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList<>();
- en: list.add("s1");
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s1");
- en: list.add("s2");
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s2");
- en: Object[] arr1 = list.toArray();
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: Object[] arr1 = list.toArray();
- en: 'for(Object o: arr1){'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(Object o: arr1){'
- en: 'System.out.print(o);       //prints: s1s2'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(o);       //输出：s1s2
- en: '}'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: String[] arr2 = list.toArray(new String[list.size()]);
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr2 = list.toArray(new String[list.size()]);
- en: 'for(String s: arr2){'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(String s: arr2){'
- en: 'System.out.print(s);      //prints: s1s2'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(s);      //输出：s1s2
- en: '}'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Yet, there is another way to convert a list or any collection for that matter
    to an array – using a stream and functional programming:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有另一种将列表或任何集合转换为数组的方法 - 使用流和函数式编程：
- en: '```java'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Object[] arr3 = list.stream().toArray();
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: Object[] arr3 = list.stream().toArray();
- en: 'for (Object o : arr3) {'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (Object o : arr3) {'
- en: 'System.out.print(o);       //prints: s1s2'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(o);       //输出：s1s2
- en: '}'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: String[] arr4 = list.stream().toArray(String[]::new);
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: arr4 = list.stream().toArray(String[]::new);
- en: 'for (String s : arr4) {'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (String s : arr4) {'
- en: 'System.out.print(s);       //prints: s1s2'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(s);       //输出：s1s2
- en: '}'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Streams and functional programming have made many traditional coding solutions
    obsolete. We will discuss this in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming* and in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml),
    *Streams and Pipeline*.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 流和函数式编程使许多传统的编码解决方案过时了。我们将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)
    *Lambda表达式和函数式编程*和[第18章](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml) *流和管道*中讨论这一点。
- en: List implementations
  id: totrans-792
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表实现
- en: 'There are many classes that implement the `List` interface for various purposes:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类实现了`List`接口，用于各种目的：
- en: '`ArrayList`: As we have discussed in this section, it is by far the most popular
    `List` implementation'
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayList`：正如我们在本节中讨论的那样，它是迄今为止最受欢迎的`List`实现'
- en: '`LinkedList`: Provides fast adding and removing of the elements at the end
    of the list'
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedList`：提供快速添加和删除列表末尾的元素'
- en: '`Stack`: Provides a **last-in-first-out** (**LIFO**) storage for objects'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stack`：为对象提供**后进先出**（**LIFO**）存储'
- en: Many other classes referred to in the online documentation of the `List` interface.
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`List`接口的在线文档中引用了许多其他类。
- en: Set - HashSet does not allow duplicates
  id: totrans-798
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Set - HashSet不允许重复
- en: There was a reason for the creation of the `Set` interface; it was designed
    not to allow duplicate elements. A duplicate is identified using the `equals()` method,
    implemented in the class whose objects are elements of the set.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`接口的创建是有原因的；它的设计目的是不允许重复元素。重复是使用`equals()`方法来识别的，该方法在类中实现，该类的对象是集合的元素。'
- en: Preferring variable type Set
  id: totrans-800
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更喜欢变量类型Set
- en: As in the case of `List`, using type `Set` for the variable that holds a reference
    to the object of the class that implements the `Set` interface is a good programming
    practice called coding to an interface. It assures independence of the client
    code from any particular implementation. So, it is a good habit to write `Set<Person>
    persons = new HashSet<>()`, for example.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 与`List`一样，对于保存对实现`Set`接口的类的对象引用的变量，使用类型`Set`是一种良好的编程实践，称为编码到接口。它确保客户端代码独立于任何特定的实现。因此，例如，编写`Set<Person>
    persons = new HashSet<>()`是一个好习惯。
- en: Why is it called HashSet?
  id: totrans-802
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么叫HashSet？
- en: In programming, a hash value is a 32-bit signed integer that represents some
    data. It is used in such data structures as a `HashTable`. After a record is created
    in a `HashTable`, its hash value can be used later to quickly find and retrieve
    the stored data. A hash value is also called a hash code, digest, or simply hash.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，哈希值是一个代表一些数据的32位有符号整数。它在`HashTable`等数据结构中使用。在`HashTable`中创建记录后，其哈希值可以在以后快速找到和检索存储的数据。哈希值也称为哈希码、摘要或简单哈希。
- en: In Java, the `hashCode()` method in the base `Object` class returns a hash value
    as the object representation, but it it does not take into account the values
    of any children's fields. This means that if you need the hash value to include
    the child object state, you need to implement the `hashCode()` method in that
    child class.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，基本`Object`类中的`hashCode()`方法返回一个哈希值作为对象表示，但它不考虑任何子级字段的值。这意味着如果需要哈希值包括子对象状态，需要在该子类中实现`hashCode()`方法。
- en: A hash value is an integer that represents some data. In Java, it represents
    an object.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值是一个代表一些数据的整数。在Java中，它代表一个对象。
- en: The `HashSet` class uses hash value as a unique key to store and retrieve an
    object. Although the number of possible integers is big, the variety of objects
    is still bigger. So, it is quite possible that two not-equal objects have the
    same hash value. That is why each hash value in `HashSet` refers not to an individual
    object, but potentially a group of objects (called a bucket or bin). `HashSet`
    resolves this clash using the `equals()` method.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet`类使用哈希值作为唯一键来存储和检索对象。尽管可能的整数数量很大，但对象的种类更多。因此，两个不相等的对象可能具有相同的哈希值。这就是为什么`HashSet`中的每个哈希值不是指向单个对象，而是潜在地指向一组对象（称为桶）。`HashSet`使用`equals()`方法解决这种冲突。'
- en: For example, there are several objects of class `A` stored in a `HashSet` object
    and you want to know if a particular object of class `A` is there. You call the `contains(object
    of A)` method on the `HashSet` object. The method calculates the hash value of
    the provided object and looks for a bucket with such a key. If none was found,
    the `contains()` method returns `false`. But if a bucket with such hash value
    exists, it may contain several objects of class `A`. That is when the `equals()` method
    comes into play. The code compares each of the objects in the bucket with the
    provided one using the `equals()` method. If one of the calls to `equals()` returns
    `true`, the `contains()` method returns `true`, thus confirming that such an object
    is stored in the already.  Otherwise, it returns `false`.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`HashSet`对象中存储了类`A`的多个对象，你想知道类`A`的特定对象是否存在。你可以在`HashSet`对象上调用`contains(object
    of A)`方法。该方法计算提供的对象的哈希值，并查找具有这样一个键的桶。如果没有找到，则`contains()`方法返回`false`。但是，如果存在具有这样的哈希值的桶，它可能包含多个类`A`的对象。这时就需要使用`equals()`方法。代码使用`equals()`方法将桶中的每个对象与提供的对象进行比较。如果其中一个`equals()`调用返回`true`，`contains()`方法返回`true`，从而确认已经存在这样的对象。否则，它返回`false`。
- en: That is why, as we have already stated while discussing the `List` interface,
    it is very important that, if the objects of the class you are creating are going
    to be elements of a collection, both methods—`equals()` and `hashCode()`—have
    to be implemented and use the same instance fields. Since `List` does not use
    a hash value, it is possible to get away using the `List` interface for the objects
    that do not have the `hashCode()` method implemented in a child of `Object`. But
    any collection that has "Hash" in its name will work incorrectly without it. Thus,
    the name.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们在讨论`List`接口时已经提到的那样，如果你创建的类的对象将成为集合的元素，那么实现`equals()`和`hashCode()`方法并使用相同的实例字段非常重要。由于`List`不使用哈希值，因此可以使用`List`接口来处理在`Object`的子类中没有实现`hashCode()`方法的对象。但是，任何在名称中带有“Hash”的集合如果没有实现`hashCode()`方法将无法正常工作。因此，名称。
- en: Adding elements
  id: totrans-809
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加元素
- en: 'The `Set` interface provides only one method for adding a single element:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`接口只提供了一个方法来添加单个元素：'
- en: '`add(E)`: It adds the provided element `E1` to the set if there is not already
    such an element `E2` there such that the statement `Objects.equals(E1, E2)` returns
    `true`'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add(E)`：如果集合中不存在这样一个元素`E2`，使得语句`Objects.equals(E1, E2)`返回`true`，则将提供的元素`E1`添加到集合中'
- en: The `Objects` class is a utility class located in the package `java.util`. Its
    `equals()` method compares two objects in a null-safe manner by returning `true`
    when both objects are `null` and using the `equals()` method otherwise. We will
    talk more about utility class `Objects` in this chapter in an upcoming section.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '`Objects`类是一个位于`java.util`包中的实用类。它的`equals()`方法以一种空安全的方式比较两个对象，当两个对象都为`null`时返回`true`，否则使用`equals()`方法。我们将在本章的后续部分更多地讨论实用类`Objects`。'
- en: The `add()` method can throw a `RuntimeException` if something goes wrong. So,
    putting a try-catch block around the method makes the code more robust (if the
    catch block does not simply rethrow the exception but does something meaningful).
    Read the description of the `Set` interface API online and see what the names
    of the exceptions this method throws are and under which conditions they can occur.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()`方法可能会在出现问题时抛出`RuntimeException`。因此，在该方法周围放置try-catch块可以使代码更加健壮（如果catch块不仅仅是重新抛出异常，而是执行一些有意义的操作）。在线上阅读`Set`接口API的描述，看看这个方法抛出的异常的名称以及它们可能发生的条件。'
- en: 'The `add(E)` method also returns a Boolean value (`true`/`false`) that indicates
    the success of the operation. This method overrides the method in the `Collection` interface,
    so all Java collections that extend or implement the `Collection` interface have
    it. Let''s look at an example:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '`add(E)`方法也返回一个布尔值（`true`/`false`），表示操作的成功。这个方法覆盖了`Collection`接口中的方法，因此所有扩展或实现`Collection`接口的Java集合都有这个方法。让我们看一个例子：'
- en: '```java'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Set<String> set = new HashSet<>();
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set = new HashSet<>();
- en: 'System.out.println(set.add("s1"));  //prints: true'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set.add("s1"));  //输出：true
- en: 'System.out.println(set.add("s1"));  //prints: false'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set.add("s1"));  //输出：false
- en: 'System.out.println(set.add("s2"));  //prints: true'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set.add("s2"));  //输出：true
- en: 'System.out.println(set.add("s3"));  //prints: true'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set.add("s3"));  //输出：true
- en: 'System.out.println(set);            //prints: [s3, s1, s2]'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set);            //输出：[s3, s1, s2]
- en: '```'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Notice, first, how the `add()` method returns `false` when we try to add element
    `s1` the second time. Then look at the last line of the code above and observe
    the following:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们尝试第二次添加元素`s1`时，`add()`方法返回`false`。然后看上面代码的最后一行，观察以下内容：
- en: Only one element `s1` was added to the set
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个元素`s1`被添加到集合中
- en: The order of the elements is not preserved
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素的顺序不被保留
- en: The last observation is important. The Java Specification explicitly states
    that, by contrast with `List`, `Set` does not guarantee the order of the elements.
    It can be different when the same code is run on different JVM instances or even
    at different runs on the same instance. The factory methods `Set.of()` shuffle
    the unordered collections a bit while creating them (we will talk about collections
    factory methods in [Chapter 14](5c3dd438-a957-4fcc-b8e8-045ea7b43277.xhtml), *Managing
    Collections and Arrays)*. This way, an inappropriate reliance on a certain order
    of the elements of `Set` and other unordered collections can be discovered earlier,
    before the code is deployed to the production environment.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点观察很重要。Java规范明确规定，与`List`相反，`Set`不保证元素的顺序。当在不同的JVM实例上运行相同的代码，甚至在同一实例的不同运行时，顺序可能会有所不同。工厂方法`Set.of()`在创建无序集合时会对其进行轻微的洗牌（我们将在[第14章](5c3dd438-a957-4fcc-b8e8-045ea7b43277.xhtml)中讨论集合工厂方法和数组）。这样，可以在将代码部署到生产环境之前更早地发现对`Set`和其他无序集合元素特定顺序的不恰当依赖。
- en: size(), isEmpty(), and clear()
  id: totrans-827
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: size()，isEmpty()和clear()
- en: 'These three methods are straightforward:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法很直接：
- en: '`size()`: It returns count of elements in the set'
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`: 它返回集合中元素的数量'
- en: '`isEmpty()`: It returns `true` if there is no elements in the list (`size()` returns
    0)'
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty()`: 如果列表中没有元素，则返回`true`（`size()`返回0）'
- en: '`clear()`: It removes  all elements from the list, so that `isEmpty()` returns `true` and `size()` returns
    0'
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 它从列表中删除所有元素，使`isEmpty()`返回`true`，`size()`返回0'
- en: Iterate and stream
  id: totrans-832
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代和流
- en: 'This `Set` functionality is not different from `List` as described previously,
    because every collection that implements the `Collection` interface also implements
    the `Iterable` interface (because `Collection` extends `Iterable`) Set can be
    iterated using a traditional enhanced `for` statement or its own method `forEach()`:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Set`功能与之前描述的`List`没有区别，因为实现`Collection`接口的每个集合也实现了`Iterable`接口（因为`Collection`扩展了`Iterable`）。可以使用传统的增强`for`语句或其自己的方法`forEach()`来迭代`Set`：
- en: '```java'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Set set = new HashSet();
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: Set set = new HashSet();
- en: set.add(null);
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: set.add(null);
- en: set.add(1);
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: set.add(1);
- en: set.add("ss");
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: set.add("ss");
- en: set.add(new A());
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: set.add(new A());
- en: set.add(new B());
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: set.add(new B());
- en: 'for(Object o: set){'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 对于set中的每个对象：
- en: System.out.println(o);
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(o);
- en: '}'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: set.forEach(System.out::println);
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: set.forEach(System.out::println);
- en: '```'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda Expressions
    and Functional Programming*, we will explain how the function can be passed as
    a parameter of the method `forEach()`. The result of both iteration styles is
    the same:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中，*Lambda表达式和函数式编程*，我们将解释如何将函数作为`forEach()`方法的参数传递。两种迭代样式的结果是相同的：
- en: '![](img/acd75458-ede5-4fa8-938a-ec78ec470e33.png)'
  id: totrans-847
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acd75458-ede5-4fa8-938a-ec78ec470e33.png)'
- en: 'The other related methods that come from the interface `Iterable` are the same
    as in the `List` interface too:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 与`List`一样，来自`Iterable`接口的其他相关方法也与`List`接口中的方法相同：
- en: '`iterator()`: It returns an object of class `Iterator` that allows walking
    through (iterate) each element of the collection and manipulating each of them
    as needed'
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterator()`: 它返回一个`Iterator`类的对象，允许遍历（迭代）集合的每个元素并根据需要操作每个元素'
- en: '`splititerator()`: It returns an object of class `Splititerator` that allows
    splitting the collection for parallel processing (discussion of this functionality is
    outside the scope of this book)'
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splititerator()`: 它返回一个`Splititerator`类的对象，允许对集合进行并行处理（讨论此功能超出了本书的范围）'
- en: 'The `Iterator` interface returned by the `iterator()` method has the following
    methods:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterator()`方法返回的`Iterator`接口具有以下方法：'
- en: '`next()`: It returns the next element in the iteration'
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next()`: 它返回迭代中的下一个元素'
- en: '`hasNext ()`: It returns `true` if the iteration has more elements'
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasNext ()`: 如果迭代还有更多元素，则返回`true`'
- en: '`forEachRemaining (Consumer<? super E> function)`: It applies the provided
    function to each of remaining elements'
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachRemaining (Consumer<? super E> function)`: 它将提供的函数应用于剩余的每个元素'
- en: '`remove()`: It removes from the underlying collection the last element returned
    by this iterator'
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`: 它从基础集合中删除迭代器返回的最后一个元素'
- en: The `next()` and `hasNext()` methods are used by `for` statements behind the
    scenes.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()`和`hasNext()`方法是由`for`语句在后台使用的。'
- en: It is also possible to iterate over collection elements using objects of the
    `Stream` class that can be obtained by the methods `stream()` and `parallelStream()`.
    We will show you how to do this in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams
    and Pipelines.*
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`Stream`类的对象对集合元素进行迭代，这可以通过`stream()`和`parallelStream()`方法获得。我们将在[第18章](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml)中展示如何做到这一点，*流和管道*。
- en: Adding using generics
  id: totrans-858
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型添加
- en: As in the case of `List`, generics can be used with `Set`, too (or any collection
    for that matter). The rules and `Set` behavior with generics are exactly the same
    as described for `List` in the section *List – ArrayList preserves order* (subsection
    *Add using generics*).
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 与`List`一样，泛型也可以与`Set`一起使用（或者任何集合都可以）。泛型的规则和`Set`的行为与在*List - ArrayList保留顺序*部分中描述的`List`完全相同。
- en: Adding collection
  id: totrans-860
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加集合
- en: The `addAll(Collection<? extends E> collection)` method adds the provided collection
    of objects to a set, but only those that are not present already in the set. The
    method returns the Boolean value `true` if the set was changed, and `false` otherwise.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '`addAll(Collection<? extends E> collection)`方法将提供的对象集合添加到集合中，但仅添加那些尚未存在于集合中的对象。如果集合发生了变化，则该方法返回布尔值`true`，否则返回`false`。'
- en: The generic `<? extends E>` means type `E` or any subtype of `E`.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型`<? extends E>`表示类型`E`或`E`的任何子类型。
- en: 'As an example, we can do the following:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以这样做：
- en: '```java'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Set<String> set1 = new HashSet<>();
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set1 = new HashSet<>();
- en: set1.add("s1");
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: set1.add("s1");
- en: set1.add("s2");
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: set1.add("s2");
- en: set1.add("s3");
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: set1.add("s3");
- en: List<String> list = new ArrayList<>();
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList<>();
- en: list.add("s1");
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s1");
- en: 'System.out.println(set1.addAll(list)); //prints: false'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(set1.addAll(list)); //prints: false'
- en: 'System.out.println(set1);              //prints: [s3, s1, s2]'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(set1);              //prints: [s3, s1, s2]'
- en: list.add("s4");
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s4");
- en: 'System.out.println(set1.addAll(list)); //prints: true'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(set1.addAll(list)); //prints: true'
- en: 'System.out.println(set1);              //prints: [s3, s4, s1, s2]'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(set1);              //prints: [s3, s4, s1, s2]'
- en: '```'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Implementing equals() and hashCode()
  id: totrans-877
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现equals()和hashCode()
- en: We have talked about implementing the methods `equals()` and `hashCode()` several
    times already and here will only repeat that, if your class is going to be used
    as a `Set` element, both methods have to be implemented. See the explanation in
    the preceding *Why is it called HashSet?* section.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次谈到了实现`equals()`和`hashCode()`方法，这里只会重复一遍，如果你的类要作为`Set`元素使用，那么这两个方法都必须被实现。在前面的*为什么叫HashSet？*部分有解释。
- en: Locating element
  id: totrans-879
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位元素
- en: The only `Set` functionality related to the location of a particular element
    directly is provided by the `contains(E)` method, which returns `true` if the
    provided element is present in the set. You can also iterate and locate the element
    this way, using the `equals()` method, but it is not a direct location.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 与`List`相比，`Set`与直接定位特定元素相关的唯一功能是由`contains(E)`方法提供的，如果提供的元素存在于集合中，则返回`true`。您也可以迭代并以这种方式定位元素，使用`equals()`方法，但这不是直接定位。
- en: Retrieving elements
  id: totrans-881
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索元素
- en: By contrast with `List`, it is not possible to retrieve an element from `Set`
    directly, because you cannot use index or another way to point to the object.
    But it is possible to iterate through the set as was described previously, in
    the subsection *Iterate and stream*.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 与`List`相比，不可能直接从`Set`中检索元素，因为您不能使用索引或其他方式指向对象。但是可以像之前描述的那样遍历集合，即在*迭代和流*子节中。
- en: Removing elements
  id: totrans-883
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除元素
- en: 'There are four methods in the `Set` interface that remove (delete) elements:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`接口中有四种删除元素的方法：'
- en: '`remove(E)`: It removes the provided element and returns `true` if the list
    contained it'
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(E)`: 它删除提供的元素并返回`true`如果列表包含它'
- en: '`removeAll(Collection)`: It removes the provided elements and returns `true` if
    the list has changed'
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeAll(Collection)`: 它删除提供的元素并返回`true`如果列表已更改'
- en: '`retainAll(Collection)`: It removes all the elements that are not in the provided
    collection and returns `true` if the list has changed'
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retainAll(Collection)`: 它删除不在提供的集合中的所有元素并返回`true`如果列表已更改'
- en: '`removeIf(Predicate<? super E> filter)`: It removes all the elements that for
    which the provided predicate returns `true`'
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeIf(Predicate<? super E> filter)`: 它删除所有满足提供的谓词返回`true`的元素'
- en: The first three methods behave the same way as with the `List` collection, so
    we will not repeat the explanations(see the subsection *Remove elements* of the
    section *List – ArrayList preserves order*).
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 前三种方法的行为方式与`List`集合相同，因此我们不会重复解释（请参见*删除元素*部分的*List - ArrayList保留顺序*部分）。
- en: As for the last of the listed methods, a predicate is a function that returns
    a Boolean value. It is another example of a functional interface (an interface
    that has only one abstract method) and functional programming.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 至于列出的方法中的最后一个，谓词是返回布尔值的函数。这是函数接口（只有一个抽象方法的接口）和函数式编程的另一个例子。
- en: The notation `Predicate<? super E>` means a function that accepts a parameter
    of type `E` or any of its base (parent) class and returns a Boolean value.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 符号`Predicate<? super E>`表示接受类型为`E`或其基类（父类）的参数并返回布尔值的函数。
- en: 'We will talk more about functions in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming*. Meanwhile, the following example
    shows how the `removeIf()` method can be used:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中更多地讨论函数，*Lambda表达式和函数式编程*。与此同时，以下示例显示了如何使用`removeIf()`方法：
- en: '```java'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Set<String> set = new HashSet();
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set = new HashSet();
- en: set.add(null);
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: set.add(null);
- en: set.add("s1");
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: set.add("s1");
- en: set.add("s1");
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: set.add("s1");
- en: set.add("s2");
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: set.add("s2");
- en: set.add("s3");
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: set.add("s3");
- en: set.add("s4");
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: set.add("s4");
- en: System.out.println(set);    //[null, s3, s4, s1, s2]
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set);    //[null, s3, s4, s1, s2]
- en: set.removeIf(e -> "s1".equals(e));
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: set.removeIf(e -> "s1".equals(e));
- en: System.out.println(set);   //[null, s3, s4, s2]
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set);   //[null, s3, s4, s2]
- en: set.removeIf(e -> e == null);
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: set.removeIf(e -> e == null);
- en: System.out.println(set);    //[s3, s4, s2]
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set);    //[s3, s4, s2]
- en: '```'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Please, notice how we put `s1` first when trying to find the element `e` that
    equals `s1`. It does not match the way we express it in English, but it helps
    to avoid `NullPointerException` in case one of the elements is `null` (as it was
    in our case).
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当尝试查找等于`s1`的元素`e`时，我们将`s1`放在第一位。这与我们在英语中表达的方式不一样，但它有助于避免`NullPointerException`，以防其中一个元素是`null`（就像我们的情况一样）。
- en: Replacing elements
  id: totrans-908
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换元素
- en: 'By contrast with `List`, it is not possible to replace an element in `Set` directly,
    because you cannot use index or another way to point to the object. But it is
    possible to iterate through the set as was described previously, or by using a `Stream` object
    (we will discuss this in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams
    and Pipelines)* and check each element and see if this is the one you are looking
    to replace. Those elements that did not match the criteria, you can add to a new
    set. And those you would like to replace, skip and add another object (that will
    replace the one you skip) to the new set:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 与`List`相反，不可能直接替换`Set`中的元素，因为您不能使用索引或其他方式指向对象。但是可以像之前描述的那样遍历集合，或者使用`Stream`对象（我们将在[第18章](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml)中讨论这一点，*流和管道)*，检查每个元素并查看这是否是您要替换的元素。那些不符合条件的元素，您可以添加到一个新的集合。而那些您想要替换的元素，则跳过并将另一个对象（将替换您跳过的对象）添加到新集合中：
- en: '```java'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Set<String> set = new HashSet();
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set = new HashSet();
- en: set.add(null);
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: set.add(null);
- en: set.add("s2");
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: set.add("s2");
- en: set.add("s3");
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: set.add("s3");
- en: System.out.println(set);    //[null, s3, s2]
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set);    //[null, s3, s2]
- en: //We want to replace s2 with s5
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: //我们想用s5替换s2
- en: Set<String> newSet = new HashSet<>();
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> newSet = new HashSet<>();
- en: set.forEach(s -> {
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: set.forEach(s -> {
- en: if("s2".equals(s)){
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: if("s2".equals(s)){
- en: newSet.add("s5");
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: newSet.add("s5");
- en: '} else {'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: newSet.add(s);
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: newSet.add(s);
- en: '}'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: set = newSet;
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: set = newSet;
- en: System.out.println(set);    //[null, s3, s5]
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set);    //[null, s3, s5]
- en: '```'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: After we switch reference from original set to a new set (`set = newSet`), the
    original set will be eventually removed from memory by the garbage collector and
    the result will be the same as if we have just replaced that one element in the
    original set.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从原始集合切换到新集合的引用后（`set = newSet`），原始集合最终将被垃圾收集器从内存中删除，结果将与我们只是替换原始集合中的一个元素一样。
- en: Sorting
  id: totrans-929
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: The `Set` interface does not allow sorting and does not guarantee order preservation.
    If you need these features added to the set, you can use the interfaces `java.util.SortedSet` or
    `java.util.NavigableSet` and their implementations `java.util.TreeSet` or `java.util.ConcurrentSkipListSet`.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`接口不允许排序，也不保证顺序保留。如果需要将这些功能添加到集合中，可以使用接口`java.util.SortedSet`或`java.util.NavigableSet`及其实现`java.util.TreeSet`或`java.util.ConcurrentSkipListSet`。'
- en: Comparing with another collection
  id: totrans-931
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与另一个集合进行比较
- en: 'Every Java collection implements the `equals()` method, which compares it with
    another collection. In the case of `Set`, two sets are considered equal (`set1.equals(set2)` returns `true`)
    when:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Java集合都实现了`equals()`方法，用于将其与另一个集合进行比较。在`Set`的情况下，当两个集合被认为是相等的（`set1.equals(set2)`返回`true`）时：
- en: Each collection is of type `Set`
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个集合的类型都是`Set`
- en: They have the same size
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的大小相同
- en: Each element of one set is contained in another set
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个集合的每个元素都包含在另一个集合中
- en: 'The following code illustrates the definition:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码说明了定义：
- en: '```java'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Set<String> set1 = new HashSet<>();
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set1 = new HashSet<>();
- en: set1.add("s1");
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: set1.add("s1");
- en: set1.add("s2");
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: set1.add("s2");
- en: List<String> list = new ArrayList<>();
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = new ArrayList<>();```
- en: list.add("s2");
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s2");
- en: list.add("s1");
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: list.add("s1");
- en: 'System.out.println(set1.equals(list)); //prints: false'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(set1.equals(list)); //prints: false'
- en: '```'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The preceding collections are not equal because they are of different types.
    Now, let''s compare two sets:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的集合不相等，因为它们的类型不同。现在，让我们比较两个集合：
- en: '```java'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Set<String> set2 = new HashSet<>();
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set2 = new HashSet<>();
- en: set2.add("s3");
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: set2.add("s3");
- en: set2.add("s1");
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: set2.add("s1");
- en: 'System.out.println(set1.equals(set2)); //prints: false'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(set1.equals(set2)); //prints: false'
- en: set2.remove("s3");
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: set2.remove("s3");
- en: set2.add("s2");
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: set2.add("s2");
- en: 'System.out.println(set1.equals(set2)); //prints: true'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(set1.equals(set2)); //prints: true'
- en: '```'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The preceding sets are equal or not depending on the composition of their elements,
    even if the size of the sets is the same.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的集合根据其元素的组成而不同，即使集合的大小相同。
- en: If two sets are equal, their `hashCode()` methods return the same integer value.
    But the equality of the `hashCode()` result does not guarantee that the sets are
    equal. We have talked about the reason for that while discussing the `hashCode()` method's
    implementation in the preceding subsection *Implement equals() and hashCode()*.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个集合相等，则它们的`hashCode()`方法返回相同的整数值。但`hashCode()`结果的相等并不保证集合相等。我们已经在前面的子节*实现equals()和hashCode()*中讨论了这个原因。
- en: The `containsAll(Collection)` method of the `Set` interface (or any collection
    that implements the `Collection` interface for that matter) returns `true` only
    if all elements of the provided collection are present in the set. If the size
    of the set and the size of the provided collection are equal, we can be sure that
    the same (well, equal) elements compose each of the compared collections. It does
    not guarantee though that the elements are of the same type, because they might
    be children of different generations with the `equals()` method implemented only
    in the common parent.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`接口的`containsAll(Collection)`方法（或者任何实现`Collection`接口的集合）仅在提供的集合的所有元素都存在于集合中时才返回`true`。如果集合的大小和提供的集合的大小相等，我们可以确定比较的集合的每个元素是相同的（好吧，相等的）。但这并不保证元素是相同类型的，因为它们可能是具有`equals()`方法的不同代的子代。'
- en: 'If not, we can find the difference using the methods `retainAll(Collection)`
    and `removeAll(Collection)`, described earlier in this section. Let''s assume
    we have two lists as follows:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是，我们可以使用`retainAll(Collection)`和`removeAll(Collection)`方法来查找差异，这些方法在本节前面已经描述过。假设我们有两个列表如下：
- en: '```java'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Set<String> set1 = new HashSet<>();
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set1 = new HashSet<>();
- en: set1.add("s1");
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: set1.add("s1");
- en: set1.add("s1");
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: set1.add("s1");
- en: set1.add("s2");
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: set1.add("s2");
- en: set1.add("s3");
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: set1.add("s3");
- en: set1.add("s4");
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: set1.add("s4");
- en: Set<String> set2 = new HashSet<>();
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set2 = new HashSet<>();
- en: set2.add("s1");
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: set2.add("s1");
- en: set2.add("s2");
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: set2.add("s2");
- en: set2.add("s2");
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: set2.add("s2");
- en: set2.add("s5");
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: set2.add("s5");
- en: '```'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can find which elements in one set are not present in the other:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以找到一个集合中不在另一个集合中的元素：
- en: '```java'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Set<String> set = new HashSet<>(set1);
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set = new HashSet<>(set1);
- en: set.removeAll(set2);
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: set.removeAll(set2);
- en: 'System.out.println(set);    //prints: [s3, s4]'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(set);    //prints: [s3, s4]'
- en: set = new HashSet<>(set2);
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: set = new HashSet<>(set2);
- en: set.removeAll(set1);
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: set.removeAll(set1);
- en: 'System.out.println(set);    //prints: [s5]'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(set);    //prints: [s5]'
- en: '```'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice how we have created a temporary set to avoid corruption of the original
    one.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们创建了一个临时集合以避免破坏原始集合。
- en: 'Since `Set` does not allow duplicate elements, there is no need to use the
    `retainAll(Collection)` method for the purpose of finding more differences between
    the sets, like we did for `List`. Instead, the `retainAll(Collection)` method
    can be used to find common elements in two sets:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Set`不允许重复元素，因此无需使用`retainAll(Collection)`方法来查找集合之间的更多差异，就像我们为`List`所做的那样。相反，`retainAll(Collection)`方法可用于查找两个集合中的公共元素：
- en: '```java'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Set<String> set = new HashSet<>(set1);
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set = new HashSet<>(set1);
- en: set.retainAll(set2);
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: set.retainAll(set2);
- en: 'System.out.println(set);    //prints: [s1, s2]'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(set);    //prints: [s1, s2]'
- en: set = new HashSet<>(set2);
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: set = new HashSet<>(set2);
- en: set.retainAll(set1);
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: set.retainAll(set1);
- en: 'System.out.println(set);    //prints: [s1, s2]'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(set);    //prints: [s1, s2]'
- en: '```'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can from the preceding code, to find the common elements between two
    sets, it is enough to use the `retainAll()` method only once, no matter which
    set is the main and which one is used as a parameter.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前面的代码中可以看到的，要找到两个集合之间的公共元素，只需要使用`retainAll()`方法一次就足够了，无论哪个集合是主集合，哪个是参数集合。
- en: Also, please notice that neither the `retainAll(Collection)` nor the `removeAll(Collection)`
    method guarantee that the compared set and the collection passed in contain elements
    of the same type. They might be a mix of children with a common parent that have
    the `equals()` method implemented in the parent only, and the parent type is the
    type of the set and the collection passed in.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，`retainAll(Collection)`方法和`removeAll(Collection)`方法都不能保证比较的集合和传入的集合包含相同类型的元素。它们可能是具有共同父类的子类的混合体，只有父类中实现了`equals()`方法，而父类类型是集合和传入的集合的类型。
- en: Converting to array
  id: totrans-994
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为数组
- en: 'There are two methods that allow converting a set to an array:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法允许将集合转换为数组：
- en: '`toArray()`: It converts the set to array `Object[]`'
  id: totrans-996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toArray()`: 将集合转换为数组`Object[]`'
- en: '`toArray(T[])`: It converts the set to array `T[]`, where `T` is the type of
    the elements in the set'
  id: totrans-997
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toArray(T[])`: 将集合转换为数组`T[]`，其中`T`是集合中元素的类型'
- en: 'Both methods preserve the order of the elements only in the case the set preserves
    order too, such as `SortedSet` or `NavigableSet`, for example. Here is the demo
    code that shows how to do it:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法只有在集合保持顺序的情况下才能保留元素的顺序，例如`SortedSet`或`NavigableSet`。以下是演示代码，显示了如何执行此操作：
- en: '```java'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Set<String> set = new HashSet<>();
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set = new HashSet<>();
- en: set.add("s1");
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: set.add("s1");
- en: set.add("s2");
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: set.add("s2");
- en: Object[] arr1 = set.toArray();
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: Object[] arr1 = set.toArray();
- en: 'for(Object o: arr1){'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(Object o: arr1){'
- en: 'System.out.print(o);       //prints: s1s2'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(o);       //打印：s1s2
- en: '}'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: String[] arr2 = set.toArray(new String[set.size()]);
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr2 = set.toArray(new String[set.size()]);
- en: 'for(String s: arr2){'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(String s: arr2){'
- en: 'System.out.print(s);     //prints: s1s2'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(s);     //打印：s1s2
- en: '}'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Yet, there is another way to convert a set, or any collection for that matter,
    to an array – using a stream and functional programming:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有另一种将集合或任何集合转换为数组的方法——使用流和函数式编程：
- en: '```java'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Object[] arr3 = set.stream().toArray();
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: Object[] arr3 = set.stream().toArray();
- en: 'for (Object o : arr3) {'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (Object o : arr3) {'
- en: 'System.out.print(o);       //prints: s1s2'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(o);       //打印：s1s2
- en: '}'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: String[] arr4 = set.stream().toArray(String[]::new);
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr4 = set.stream().toArray(String[]::new);
- en: 'for (String s : arr4) {'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (String s : arr4) {'
- en: 'System.out.print(s);       //prints: s1s2'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(s);       //打印：s1s2
- en: '}'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Streams and functional programming have made many traditional coding solutions
    obsolete. We will discuss them in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming* and in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams
    and Pipeline*.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 流和函数式编程使许多传统的编码解决方案过时。我们将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)
    *Lambda表达式和函数式编程*和[第18章](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml) *流和管道*中讨论它们。
- en: Set implementations
  id: totrans-1024
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合实现
- en: 'There are many classes that implement the `Set` interface for various purposes:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多实现`Set`接口的类，用于各种目的：
- en: We have discussed the `HashMap` class in this section; it is by far the most
    popular `Set` implementation
  id: totrans-1026
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在本节讨论了`HashMap`类；它是迄今为止最受欢迎的`Set`实现
- en: The `LinkedHashSet` class stores unique elements in order
  id: totrans-1027
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedHashSet`类按顺序存储唯一元素'
- en: The `TreeSet` class orders its elements based on their values natural order
    or using the `Comparator` provided at creation time
  id: totrans-1028
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TreeSet`类根据其值的自然顺序或在创建时提供的`Comparator`对其元素进行排序'
- en: Many other classes referred in the online documentation of the `Set` interface
  id: totrans-1029
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set`接口的在线文档中引用了许多其他类'
- en: Map – HashMap stores/retrieves objects by key
  id: totrans-1030
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map – HashMap通过键存储/检索对象
- en: 'The `Map` interface itself is not related to the `Collection` interface directly,
    but it uses the `Set` interface for its keys and `Collection` for its values.
    For example, for `Map<Integer, String> map`:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`接口本身与`Collection`接口没有直接关联，但它使用`Set`接口作为其键和`Collection`作为其值。例如，对于`Map<Integer,
    String> map`：'
- en: '`Set<Integer> keys = map.keySet();`'
  id: totrans-1032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set<Integer> keys = map.keySet();`'
- en: '`Collection<String> values = map.values();`'
  id: totrans-1033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<String> values = map.values();`'
- en: 'Each value is stored in a map with a unique key that is passed in along with
    the value when added to the map. In the case of `Map<Integer, String> map`:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 每个值都存储在一个具有唯一键的映射中，当添加到映射中时，该键与值一起传递。在`Map<Integer, String> map`的情况下：
- en: '```java'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: map.put(42, "whatever");        //42 is the key for the value "whatever"
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(42, "whatever");        //42是值"whatever"的键
- en: '```'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Then later, the value can be retrieved by its key:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，稍后可以通过其键检索值：
- en: '```java'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String v = map.get(42);
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: String v = map.get(42);
- en: 'System.out.println(v);     //prints: whatever'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(v);     //打印：whatever
- en: '```'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: These are the basic map operations that convey the `Map` interface's purpose
    – to provide a storage for key-value pairs, where both—key and value—are objects
    and the class used as the key implements the `equals()` and  `hashCode()` methods,
    which override the default implementations in the `Object` class.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是传达`Map`接口目的的基本映射操作——提供键值对的存储，其中键和值都是对象，并且用作键的类实现了`equals()`和`hashCode()`方法，这些方法覆盖了`Object`类中的默认实现。
- en: Now, let's take a closer look at the `Map` interface, its implementation, and
    usage.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看`Map`接口、它的实现和用法。
- en: Preferring variable type Map
  id: totrans-1045
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更喜欢变量类型Map
- en: As in the case of `List` and `Set`, using type `Map` for the variable that holds
    a reference to the object of the class that implements the `Map` interface is
    a good programming practice called coding to an interface. It assures independence
    of the client code from any particular implementation. So, it is a good habit
    to write `Map<String, Person> persons = new HashMap<>()` to store all persons
    as values by their key – a social security number, for example.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 与`List`和`Set`一样，使用类型`Map`来保存对实现`Map`接口的类的对象的引用的变量是一种良好的编程实践，称为编码到接口。它确保客户端代码不依赖于任何特定的实现。因此，将所有人员存储为值的`Map<String,
    Person> persons = new HashMap<>()`是一个很好的习惯-以他们的键-例如社会安全号码。
- en: Why is it called HashMap?
  id: totrans-1047
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么称为HashMap？
- en: By now, it should be already obvious to you that the reason the `HashMap` class
    has "Hash" in its name that it stores the keys using their hash values, calculated
    by the `hashCode()` method. Since we have already discussed it at great length
    in the previous sections, we are not going to talk here about hash value and its
    usage; you can refer back to the subsection *Why is it called HashSet?* in the
    previous section of this chapter.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经很明显地意识到`HashMap`类之所以有“Hash”在其名称中，是因为它使用它们的哈希值存储键，这些哈希值是由`hashCode()`方法计算得出的。由于我们在前面的章节中已经对此进行了详细讨论，所以我们不打算在这里讨论哈希值及其用法；你可以回到本章的前一节*为什么称为HashSet？*中参考。
- en: Adding and maybe replace
  id: totrans-1049
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和可能替换
- en: The `Map` interface stores key-value pairs, also called entries, because in
    a `Map`, each key-value pair is also represented by the `Entry` interface, which
    is a nested interface of `Map` and thus referred as `Map.Entry`.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`接口存储键值对，也称为条目，因为在`Map`中，每个键值对也由`Entry`接口表示，它是`Map`的嵌套接口，因此被称为`Map.Entry`。'
- en: 'A key-value pair or an entry can be added to a `Map` using the following methods:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下方法向`Map`添加键值对或条目：
- en: '`V put(K, V)`: It adds a key-value pair (or creates a key-value association).
    If the provided key exists already, the method overrides the old value and returns
    it (if the old value was `null`, then `null` is returned). If the provided key
    is not in the map already, the method returns `null`.'
  id: totrans-1052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V put(K, V)`: 它添加一个键值对（或创建一个键值关联）。如果提供的键已经存在，则该方法覆盖旧值并返回它（如果旧值为`null`，则返回`null`）。如果提供的键尚未在映射中，则该方法返回`null`。'
- en: '`V putIfAbsent(K, V)`: It adds a key-value pair (or creates a key-value association).
    If the provided key exists already and the associated value is not `null`, the
    method does not override the old value but just returns it. If the provided key
    is not in the map already or if the associated value is `null`, the method overrides
    the old value and returns `null`.'
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V putIfAbsent(K, V)`: 它添加一个键值对（或创建一个键值关联）。如果提供的键已经存在并且关联的值不是`null`，则该方法不会覆盖旧值，而只是返回它。如果提供的键尚未在映射中或者关联的值为`null`，则该方法将覆盖旧值并返回`null`。'
- en: 'The following code demonstrates the described functionality:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了所描述的功能：
- en: '```java'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, String> map = new HashMap<>();
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map = new HashMap<>();
- en: 'System.out.println(map.put(1, null));  //prints: null'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.put(1, null));  //输出：null
- en: 'System.out.println(map.put(1, "s1"));  //prints: null'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.put(1, "s1"));  //输出：null
- en: 'System.out.println(map.put(2, "s1"));  //prints: null'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.put(2, "s1"));  //输出：null
- en: 'System.out.println(map.put(2, "s2"));  //prints: s1'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.put(2, "s2"));  //输出：s1
- en: 'System.out.println(map.put(3, "s3"));  //prints: null'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.put(3, "s3"));  //输出：null
- en: 'System.out.println(map);               //prints: {1=s1, 2=s2, 3=s3}'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map);               //输出：{1=s1, 2=s2, 3=s3}
- en: 'System.out.println(map.putIfAbsent(1, "s4"));  //prints: s1'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.putIfAbsent(1, "s4"));  //输出：s1
- en: 'System.out.println(map);               //prints: {1=s1, 2=s2, 3=s3}'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map);               //输出：{1=s1, 2=s2, 3=s3}
- en: 'System.out.println(map.put(1, null));  //prints: s1'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.put(1, null));  //输出：s1
- en: 'System.out.println(map);               //prints: {1=null, 2=s2, 3=s3}'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map);               //输出：{1=null, 2=s2, 3=s3}
- en: 'System.out.println(map.putIfAbsent(1, "s4"));  //prints: null'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.putIfAbsent(1, "s4"));  //输出：null
- en: 'System.out.println(map);               //prints: {1=s4, 2=s2, 3=s3}'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map);               //输出：{1=s4, 2=s2, 3=s3}
- en: 'System.out.println(map.putIfAbsent(4, "s4"));  //prints: null'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.putIfAbsent(4, "s4"));  //输出：null
- en: 'System.out.println(map);               //prints: {1=s4, 2=s2, 3=s3, 4=s4}'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map);               //输出：{1=s4, 2=s2, 3=s3, 4=s4}
- en: '```'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that in a case where the returned value is `null`, there is some ambiguity
    about the result - whether the new entry was added (and replaced the entry with
    value `null`) or not. So, one has to pay attention while using the described methods
    on the maps that may contain a `null` value.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在返回值为`null`的情况下，结果存在一些歧义-新条目是否已添加（并替换了值为`null`的条目）或者没有。因此，在使用描述的方法时，必须注意可能包含`null`值的映射。
- en: There are also the `compute()` and `merge()` methods, which allow you to add
    and modify data in the map, but their usage is much too complex for the introductory
    course, so we will leave them out of this discussion. Besides, they are not very
    often used in mainstream programming.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`compute()`和`merge()`方法，它们允许您向映射中添加和修改数据，但它们的使用对于入门课程来说过于复杂，因此我们将它们排除在讨论之外。此外，它们在主流编程中并不经常使用。
- en: size(), isEmpty(), and clear()
  id: totrans-1074
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: size()，isEmpty()和clear()
- en: 'These three methods are straightforward:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法很简单：
- en: '`size()`: It returns count of key-value pairs (entries) in the map'
  id: totrans-1076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`: 它返回映射中键值对（条目）的计数'
- en: '`isEmpty()`: It returns `true` if there is nokey-value pairs (entries) in the
    map (`size()` returns 0)'
  id: totrans-1077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty()`: 如果映射中没有键值对（条目），则返回`true`（`size()`返回0）'
- en: '`clear()`: It removes  allkey-value pairs (entries) from the map, so that `isEmpty()`
    returns `true` and `size()` returns 0'
  id: totrans-1078
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 它从映射中删除所有键值对（条目），使得`isEmpty()`返回`true`，`size()`返回0'
- en: Iterate and stream
  id: totrans-1079
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代和流
- en: 'There are several ways to iterate over the map content using the following
    `Map` methods, for example:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以使用以下`Map`方法对映射内容进行迭代，例如：
- en: '`Set<K> keySet()`: It returns the keys associated with the values stored in
    the map. One can iterate over this set and retrieve from the map the value for
    each key (see the preceding section for who to iterate over a set).'
  id: totrans-1081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set<K> keySet()`: 它返回与地图中存储的值相关联的键。可以遍历此集合，并从地图中检索每个键的值（请参阅前面的部分，了解如何遍历集合）。'
- en: '`Collection<V> values()`: It returns the values stored in the map. One can
    iterate over this collection.'
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<V> values()`: 它返回地图中存储的值。可以遍历此集合。'
- en: '`Set<Map.Entry<K,V>> entrySet()`: It returns the entries (key-value pairs)
    stored in the map. One can iterate over this set and get the key and the value
    from each entry.'
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set<Map.Entry<K,V>> entrySet()`: 它返回地图中存储的条目（键值对）。可以遍历此集合，并从每个条目中获取键和值。'
- en: '`forEach (BiConsumer<? super K,? super V> action)`: It iterates over key-value
    pairs stored in the map and provides them as an input into the function `BiConsumer`,
    which accepts two parameters of the map key and value types and returns `void`.'
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach (BiConsumer<? super K,? super V> action)`: 它遍历存储在地图中的键值对，并将它们作为输入提供给函数`BiConsumer`，该函数接受地图键和值类型的两个参数，并返回`void`。'
- en: 'Here is how to read the notation `BiConsumer<? super K,? super V>`: It describes
    a function. The `Bi` in the function''s name indicates that it accepts two parameters:
    one of type `K` or any of its superclasses and another of type `V` or any of its
    superclasses. The `Consumer` in the functions name indicates that it returns nothing
    (`void`).'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何阅读符号`BiConsumer<? super K,? super V>`的方法：它描述了一个函数。函数名称中的`Bi`表示它接受两个参数：一个是类型为`K`或其任何超类的参数，另一个是类型为`V`或其任何超类的参数。函数名称中的`Consumer`表示它不返回任何内容（`void`）。
- en: We will talk more about functional programming in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming*.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中更多地讨论函数式编程，*Lambda表达式和函数式编程*。
- en: 'To demonstrate the preceding methods, we are going to use the following map:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示前面的方法，我们将使用以下地图：
- en: '```java'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, String> map = new HashMap<>();
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map = new HashMap<>();
- en: map.put(1, null);
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(1, null);
- en: map.put(2, "s2");
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(2, "s2");
- en: map.put(3, "s3");
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(3, "s3");
- en: '```'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And here is how this map can be iterated:'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何迭代此地图的方法：
- en: '```java'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'for(Integer key: map.keySet()){'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(Integer key: map.keySet()){'
- en: System.out.println("key=" + key + ", value=" + map.get(key));
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("key=" + key + ", value=" + map.get(key));
- en: '}'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: map.keySet().stream()
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: map.keySet().stream()
- en: .forEach(k->System.out.println("key=" + k + ", value=" + map.get(k)));
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(k->System.out.println("key=" + k + ", value=" + map.get(k)));
- en: 'for(String value: map.values()){'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(String value: map.values()){'
- en: System.out.println("value=" + value);
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("value=" + value);
- en: '}'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: map.values().stream().forEach(System.out::println);
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: map.values().stream().forEach(System.out::println);
- en: map.forEach((k,v) -> System.out.println("key=" + k + ", value=" + v));
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: map.forEach((k,v) -> System.out.println("key=" + k + ", value=" + v));
- en: map.entrySet().forEach(e -> System.out.println("key=" + e.getKey() +
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: map.entrySet().forEach(e -> System.out.println("key=" + e.getKey() +
- en: '", value=" + e.getValue()));'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '", value=" + e.getValue()));'
- en: '```'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: All the preceding methods produce the same results, except the `values()` method,
    which returns only values. Which one to use is a matter of style, but it seems
    that `map.forEach()` requires fewer keystrokes to implement the iteration.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的方法产生相同的结果，除了`values()`方法，它只返回值。使用哪一个取决于风格，但似乎`map.forEach()`需要较少的按键来实现迭代。
- en: Adding using generics
  id: totrans-1110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型添加
- en: From our examples, you have seen already how generics can be used with `Map`.
    It provides a valuable help to a programmer by allowing the compiler to check
    the match between the map and the objects one tries to store in it.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的示例中，您已经看到了如何将泛型与`Map`一起使用。它通过允许编译器检查地图和尝试存储在其中的对象之间的匹配，为程序员提供了宝贵的帮助。
- en: Adding another Map
  id: totrans-1112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加另一个地图
- en: 'The `putAll(Map<? extends K, ? extends V> map)` method adds each key-value
    pair from the provided map the same way the `put(K, V)` method does for one pair:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '`putAll(Map<? extends K, ? extends V> map)`方法从提供的地图中添加每个键值对，就像`put(K, V)`方法对一个键值对一样：'
- en: '```java'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, String> map1 = new HashMap<>();
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map1 = new HashMap<>();
- en: map1.put(1, null);
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: map1.put(1, null);
- en: map1.put(2, "s2");
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: map1.put(2, "s2");
- en: map1.put(3, "s3");
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: map1.put(3, "s3");
- en: Map<Integer, String> map2 = new HashMap<>();
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map2 = new HashMap<>();
- en: map2.put(1, "s1");
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: map2.put(1, "s1");
- en: map2.put(2, null);
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: map2.put(2, null);
- en: map2.put(4, "s4");
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: map2.put(4, "s4");
- en: map1.putAll(map2);
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: map1.putAll(map2);
- en: 'System.out.println(map1); //prints: {1=s1, 2=null, 3=s3, 4=s4}'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map1); //打印：{1=s1, 2=null, 3=s3, 4=s4}
- en: '```'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, the `putAll()` method adds a new pair or overrides a value in
    the existing pair (based on the key) and does not return anything.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`putAll()`方法添加了一个新的键值对，或者覆盖了现有键值对中的值（基于键），并且不返回任何内容。
- en: Implementing equals() and hashCode()
  id: totrans-1127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现equals()和hashCode()
- en: If you are going to use the class you are writing as a key in a `Map`, implementing
    both the `equals()` and `hashCode()` methods is very important. See the explanation
    in the preceding section, *Why is it called HashSet?* In our examples, we have
    used objects of the `Integer` class as keys. This class has an implementation
    of both these methods based on the integer value of the class.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要将您编写的类用作`Map`中的键，实现`equals()`和`hashCode()`方法非常重要。请参阅前面部分中的解释，*为什么称为HashSet？*在我们的示例中，我们已经使用了`Integer`类的对象作为键。该类根据类的整数值实现了这两种方法。
- en: The class that is going to be stored as a value in a `Map` has to implement
    the `equals()` method, at least (see the next subsection, *Locate element*).
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`Map`中的值存储的类必须至少实现`equals()`方法（请参阅下一小节*定位元素*）。
- en: Locating element
  id: totrans-1130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位元素
- en: 'The following two methods answer the question if the particular key of value
    is present in the map:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两种方法回答了特定键或值是否存在于地图中的问题：
- en: '`containsKey(K)`: It returns `true`, if the provided key is present already'
  id: totrans-1132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containsKey(K)`: 如果提供的键已经存在，则返回`true`'
- en: '`containsValue(V)`: It returns `true`, if the provided value is present already'
  id: totrans-1133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containsValue(V)`: 如果提供的值已经存在，则返回`true`'
- en: Both methods rely on the `equals()` method to identify the match.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都依赖于`equals()`方法来识别匹配项。
- en: Retrieving elements
  id: totrans-1135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索元素
- en: 'To retrieve elements from a `Map`, you can use any of the following four methods:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`Map`中检索元素，可以使用以下四种方法之一：
- en: '`V get(Object K)`: It returns the value by the provided key, or `null` if the
    provided key is not in the map'
  id: totrans-1137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V get(Object K)`:它返回提供的键的值，如果提供的键不在地图中，则返回`null`'
- en: '`V getOrDefault(K, V)`: It returns the value by the provided key, or the provided
    (default) value if the provided key is not in the map'
  id: totrans-1138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V getOrDefault(K, V)`:它返回提供的键的值，如果提供的键不在地图中，则返回提供的(默认)值'
- en: '`Map.Entry<K,V> entry(K,V)`: A static method that converts the provided key-value
    pair into an immutable object of `Map.Entry` (immutable means it can be read,
    but cannot be changed)'
  id: totrans-1139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map.Entry<K,V> entry(K,V)`:将提供的`键-值对`转换为`Map.Entry`的不可变对象的静态方法(不可变意味着可以读取，但不能更改)'
- en: '`Map<K,V> ofEntries(Map.Entry<? extends K,? extends V>... entries)`: It creates
    an immutable map based on the provided entries'
  id: totrans-1140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map<K,V> ofEntries(Map.Entry<? extends K,? extends V>... entries)`:它基于提供的条目创建一个不可变的地图'
- en: 'The following code demonstrates these methods:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了这些方法：
- en: '```java'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, String> map = new HashMap<>();
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map = new HashMap<>();
- en: map.put(1, null);
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(1, null);
- en: map.put(2, "s2");
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(2, "s2");
- en: map.put(3, "s3");
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(3, "s3");
- en: 'System.out.println(map.get(2));                 //prints: s2'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.get(2)); //打印：s2
- en: 'System.out.println(map.getOrDefault(2, "s4"));  //prints: s2'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.getOrDefault(2, "s4")); //打印：s2
- en: 'System.out.println(map.getOrDefault(4, "s4"));  //prints: s4'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.getOrDefault(4, "s4")); //打印：s4
- en: Map.Entry<Integer, String> entry = Map.entry(42, "s42");
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: Map.Entry<Integer, String> entry = Map.entry(42, "s42");
- en: 'System.out.println(entry);      //prints: 42=s42'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(entry); //打印：42=s42
- en: Map<Integer, String> entries =
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> entries =
- en: Map.ofEntries(entry, Map.entry(43, "s43"));
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: Map.ofEntries(entry, Map.entry(43, "s43"));
- en: 'System.out.println(entries);   //prints: {42=s42, 43=s43}'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(entries); //打印：{42=s42, 43=s43}
- en: '```'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: And it is always possible to retrieve elements of a map by iterating, as we
    have described in the subsection *Iterate and stream*.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 并且始终可以通过迭代来检索地图的元素，就像我们在*迭代和流*的子节中描述的那样。
- en: Removing elements
  id: totrans-1157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除元素
- en: 'Two methods allow the direct removal of Map elements:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法允许直接删除Map元素：
- en: '`V remove(Object key)`: It removes an object associated with the key and returns
    its value, or, if such a key is not present in the map, returns `null`'
  id: totrans-1159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V remove(Object key)`:它删除与键关联的对象并返回其值，或者，如果地图中不存在这样的键，则返回`null`'
- en: '`boolean remove(Object key, Object value)`: It removes an object associated
    with the key only if the current value associated with the key equals the provided
    one; returns `true`, if the element was removed'
  id: totrans-1160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean remove(Object key, Object value)`:它只有在当前与键关联的值等于提供的值时，才删除与键关联的对象；如果元素被删除，则返回`true`'
- en: 'Here is the code that illustrates the described behavior:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是说明所述行为的代码：
- en: '```java'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, String> map = new HashMap<>();
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map = new HashMap<>();
- en: map.put(1, null);
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(1, null);
- en: map.put(2, "s2");
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(2, "s2");
- en: map.put(3, "s3");
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(3, "s3");
- en: 'System.out.println(map.remove(2));        //prints: s2'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.remove(2)); //打印：s2
- en: 'System.out.println(map);                  //prints: {1=null, 3=s3}'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map); //打印：{1=null, 3=s3}
- en: 'System.out.println(map.remove(4));        //prints: null'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.remove(4)); //打印：null
- en: 'System.out.println(map);                  //prints: {1=null, 3=s3}'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map); //打印：{1=null, 3=s3}
- en: 'System.out.println(map.remove(3, "s4"));  //prints: false'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.remove(3, "s4")); //打印：false
- en: 'System.out.println(map);                  //prints: {1=null, 3=s3}'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map); //打印：{1=null, 3=s3}
- en: 'System.out.println(map.remove(3, "s3"));  //prints: true'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.remove(3, "s3")); //打印：true
- en: 'System.out.println(map);                  //prints: {1=null}'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map); //打印：{1=null}
- en: '```'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'There is also another way to remove a `Map` element by key. If the key from
    the map is removed, the corresponding value is removed too. Here is the code that
    demonstrates it:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种通过键删除`Map`元素的方法。如果从地图中删除了键，则相应的值也将被删除。以下是演示它的代码：
- en: '```java'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, String> map = new HashMap<>();
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map = new HashMap<>();
- en: map.put(1, null);
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(1, null);
- en: map.put(2, "s2");
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(2, "s2");
- en: map.put(3, "s3");
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(3, "s3");
- en: Set<Integer> keys = map.keySet();
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: Set<Integer> keys = map.keySet();
- en: 'System.out.println(keys.remove(2));      //prints: true'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(keys.remove(2)); //打印：true
- en: 'System.out.println(map);                 //prints: {1=null, 3=s3}'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map); //打印：{1=null, 3=s3}
- en: 'System.out.println(keys.remove(4));      //prints: false'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(keys.remove(4)); //打印：false
- en: 'System.out.println(map);                 //prints: {1=null, 3=s3}'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map); //打印：{1=null, 3=s3}
- en: '```'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Similarly, the methods `removeAll(Collection)`, `retainAll(Collection)`, and `removeIf(Predicate<?
    super E> filter)` from the `Set` interface, described in the subsection *Remove
    elements* of the section *Set - HashSet does not allow duplicates**,* can be used
    too.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，还可以使用`Set`接口中的`removeAll(Collection)`、`retainAll(Collection)`和`removeIf(Predicate<?
    super E> filter)`方法，这些方法在*删除元素*的子节中有描述，*Set - HashSet不允许重复**,*也可以使用。
- en: Replacing elements
  id: totrans-1189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换元素
- en: 'To replace elements of the `Map`, one can use the following methods:'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换`Map`的元素，可以使用以下方法：
- en: '`V replace(K, V)`: It replaces the value with the provided one only if the
    provided key is present in the map; returns the previous (replaced) value if such
    a key is present or `null` if such a key is not in the map'
  id: totrans-1191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V replace(K, V)`:它只有在提供的键存在于地图中时，才用提供的值替换值；如果这样的键存在，则返回先前(替换的)值，如果这样的键不存在，则返回`null`'
- en: '`boolean  replace(K, oldV, newV) `: It replaces the current value (`oldV`)
    with a new one (`newV`) only if the provided key is present in the map and is
    currently associated with the provided value `oldV`; returns `true` if the value
    was replaced'
  id: totrans-1192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean  replace(K, oldV, newV) `:它只有在提供的键存在于地图中并且当前与提供的值`oldV`关联时，才用新值`newV`替换当前值(`oldV`)；如果值被替换，则返回`true`'
- en: '`void replaceAll(BiFunction<? super K, ? super V, ? extends V> function)`:
    It allows you to replace the values using a provided function that takes two parameters—key
    and value—and returns a new value that will replace the current one in this key-value
    pair'
  id: totrans-1193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void replaceAll(BiFunction<? super K, ? super V, ? extends V> function)`:
    它允许您使用提供的函数替换值，该函数接受两个参数 - 键和值 - 并返回一个新值，该新值将替换此键值对中的当前值'
- en: 'Here is how to read the notation `BiFunction<? super K, ? super V, ? extends
    V>`: It describes a function. The `Bi` in the function''s name indicates that
    it accepts two parameters: one of type `K` or any of its superclasses and another
    of type V or any of its superclasses. The `Function` part in the functions name
    indicates that it returns something. The returned value is listed the last. In
    this case, it is `<? extends V>`, which means value of type `V` or any of its
    subclasses.'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何阅读符号“BiFunction<? super K, ? super V, ? extends V>”：它描述了一个函数。“Bi”中的函数名称表示它接受两个参数：一个是类型“K”或任何其超类，另一个是类型V或任何其超类。函数名称中的“Function”部分表示它返回某些东西。返回的值是最后列出的。在这种情况下，它是“<?
    extends V>”，这意味着类型“V”或其子类的值。
- en: 'Let''s assume that the map we are going to change is as follows:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们要更改的地图如下：
- en: '```java'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, String> map = new HashMap<>();
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map = new HashMap<>();
- en: map.put(1, null);
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(1, null);
- en: map.put(2, "s2");
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(2, "s2");
- en: map.put(3, "s3");
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(3, "s3");
- en: '```'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Then, the code that illustrates the first two methods looks like this:'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，说明前两种方法的代码如下：
- en: '```java'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'System.out.println(map.replace(1, "s1"));   //prints: null'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.replace(1, "s1")); //打印：null
- en: 'System.out.println(map);                    //prints: {1=s1, 2=s2, 3=s3}'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map); //打印：{1=s1, 2=s2, 3=s3}
- en: 'System.out.println(map.replace(4, "s1"));   //prints: null'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.replace(4, "s1")); //打印：null
- en: 'System.out.println(map);                    //prints: {1=s1, 2=s2, 3=s3}'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map); //打印：{1=s1, 2=s2, 3=s3}
- en: 'System.out.println(map.replace(1, "s2", "s1"));   //prints: false'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.replace(1, "s2", "s1")); //打印：false
- en: 'System.out.println(map);                    //prints: {1=s1, 2=s2, 3=s3}'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map); //打印：{1=s1, 2=s2, 3=s3}
- en: 'System.out.println(map.replace(1, "s1", "s2"));   //prints: true'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map.replace(1, "s1", "s2")); //打印：true
- en: 'System.out.println(map);                    //prints: {1=s2, 2=s2, 3=s3}'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map); //打印：{1=s2, 2=s2, 3=s3}
- en: '```'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And here is the code that helps to understand how the last of the listed replacing
    methods works:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是帮助理解列出的最后一个替换方法的代码：
- en: '```java'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, String> map = new HashMap<>();
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map = new HashMap<>();
- en: map.put(1, null);
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(1, null);
- en: map.put(2, null);
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(2, null);
- en: map.put(3, "s3");
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: map.put(3, "s3");
- en: 'map.replaceAll((k,v) -> v == null? "s" + k : v);'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 'map.replaceAll((k,v) -> v == null? "s" + k : v);'
- en: 'System.out.println(map);                 //prints: {1=s1, 2=s2, 3=s3}'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map); //打印：{1=s1, 2=s2, 3=s3}
- en: 'map.replaceAll((k,v) -> k == 2? "n2" : v);'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 'map.replaceAll((k,v) -> k == 2? "n2" : v);'
- en: 'System.out.println(map);                 //prints: {1=s1, 2=n2, 3=s3}'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map); //打印：{1=s1, 2=n2, 3=s3}
- en: 'map.replaceAll((k,v) -> v.startsWith("s") ? "s" + (k + 10) : v);'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 'map.replaceAll((k,v) -> v.startsWith("s") ? "s" + (k + 10) : v);'
- en: 'System.out.println(map);                 //prints: {1=s11, 2=n2, 3=s13}'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map); //打印：{1=s11, 2=n2, 3=s13}
- en: '```'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Notice that we were able to use the `v.startsWith()` method only after we had
    replaced all the `null` values with something else. Otherwise, this line could
    throw a `NullPointerException` and we would need to change it for the following
    one:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只能在用其他东西替换所有“null”值之后才能使用“v.startsWith()”方法。否则，这行可能会抛出“NullPointerException”，我们需要将其更改为以下行：
- en: '```java'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: map.replaceAll((k,v) -> (v != null && v.startsWith("s")) ?
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: map.replaceAll((k,v) -> (v != null && v.startsWith("s")) ?
- en: '"s" + (k + 10) : v);'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: '"s" + (k + 10) : v);'
- en: '```'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Sorting
  id: totrans-1231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: The `Map` interface does not allow sorting and does not guarantee order preservation.
    If you need these features added to the map, you can use the interfaces `java.util.SortedMap`
    or `java.util.NavigableMap`, and their implementations `java.util.TreeMap` or
    `java.util.ConcurrentSkipListMap`.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: “Map”接口不允许排序，也不保证顺序保留。如果您需要将这些功能添加到地图中，可以使用接口“java.util.SortedMap”或“java.util.NavigableMap”，以及它们的实现“java.util.TreeMap”或“java.util.ConcurrentSkipListMap”。
- en: Comparing with another collection
  id: totrans-1233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与另一个集合比较
- en: 'Every Java collection implements the `equals()` method, which compares it with
    another collection. In the case of `Map`, two maps are considered equal (`map1.equals(map2)` returns `true`)
    when:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Java集合都实现了“equals()”方法，它将其与另一个集合进行比较。在“Map”的情况下，当两个地图被认为是相等的（“map1.equals(map2)”返回“true”）时：
- en: Both are `Map` objects
  id: totrans-1235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者都是“Map”对象
- en: One map has the same set of key-value pairs as another map
  id: totrans-1236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个地图具有与另一个地图相同的键值对集
- en: 'Here is the code that illustrates the definition:'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是说明定义的代码：
- en: '```java'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Map<Integer, String> map1 = new HashMap<>();
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map1 = new HashMap<>();
- en: map1.put(1, null);
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: map1.put(1, null);
- en: map1.put(2, "s2");
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: map1.put(2, "s2");
- en: map1.put(3, "s3");
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: map1.put(3, "s3");
- en: Map<Integer, String> map2 = new HashMap<>();
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, String> map2 = new HashMap<>();
- en: map2.put(1, null);
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: map2.put(1, null);
- en: map2.put(2, "s2");
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: map2.put(2, "s2");
- en: map2.put(3, "s3");
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: map2.put(3, "s3");
- en: 'System.out.println(map2.equals(map1)); //prints: true'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map2.equals(map1)); //打印：true
- en: map2.put(1, "s1");
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: map2.put(1, "s1");
- en: 'System.out.println(map2.equals(map1)); //prints: false'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map2.equals(map1)); //打印：false
- en: '```'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If you think about it, the `map1.equals(map2)` method returns exactly the same
    result as the `map1.entrySet().equals(map2.entrySet())` method, because the `entrySet()` method
    returns `Set<Map.Entry<K,V>` and we know (see the subsection *Compare with another
    collection* for `Set`) that two sets are equal when each element of one set is
    contained in another set.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想一想，“map1.equals(map2)”方法返回的结果与“map1.entrySet().equals(map2.entrySet())”方法返回的结果完全相同，因为“entrySet()”方法返回“Set<Map.Entry<K,V>`，我们知道（请参见子部分*与另一个集合比较*）两个集合相等当一个集合的每个元素都包含在另一个集合中。
- en: If two maps are equal, their `hashCode()` methods return the same integer value.
    But the equality of `hashCode()` results does not guarantee that the maps are
    equal. We have talked about the reason for that while discussing the `hashCode()` method's
    implementation for the elements of the `Set` collection in the previous section.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个地图相等，则它们的`hashCode()`方法返回相同的整数值。但是，`hashCode()`结果的相等并不保证地图相等。我们在讨论`hashCode()`方法的实现时已经谈到了这一点，这是在上一节中讨论`Set`集合的元素时。
- en: 'If two maps are not equal and there is a need to find out exactly what the
    difference is, there are a variety of ways to do it:'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个地图不相等，并且需要找出确切的差异，有多种方法可以做到这一点：
- en: '```java'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: map1.entrySet().containsAll(map2.entrySet());
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: map1.entrySet().containsAll(map2.entrySet());
- en: map1.entrySet().retainAll(map2.entrySet());
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: map1.entrySet().retainAll(map2.entrySet());
- en: map1.entrySet().removeAll(map2.entrySet());
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: map1.entrySet().removeAll(map2.entrySet());
- en: map1.keySet().containsAll(map2.keySet());
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: map1.keySet().containsAll(map2.keySet());
- en: map1.keySet().retainAll(map2.keySet());
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: map1.keySet().retainAll(map2.keySet());
- en: map1.keySet().removeAll(map2.keySet());
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: map1.keySet().removeAll(map2.keySet());
- en: map1.values().containsAll(map2.values());
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: map1.values().containsAll(map2.values());
- en: map1.values().retainAll(map2.values());
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: map1.values().retainAll(map2.values());
- en: map1.values().removeAll(map2.values());
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: map1.values().removeAll(map2.values());
- en: '```'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Using any combination of these methods, one can get the full picture of the
    difference between the two maps.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法的任意组合，可以全面了解两个地图之间的差异。
- en: Map implementations
  id: totrans-1266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图实现
- en: 'There are many classes that implement the `Map` interface for various purposes:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类实现了`Map`接口，用于各种目的：
- en: '`HashMap`, which we have discussed in this section; it is by far the most popular `Map` implementation'
  id: totrans-1268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在本节中讨论的`HashMap`；它是迄今为止最流行的`Map`实现
- en: The `LinkedHashMap` class stores its key-value pairs in their insertion order
  id: totrans-1269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedHashMap`类按其插入顺序存储其键值对'
- en: The `TreeMap` class orders its key-value pairs based on the keys natural order
    or using the `Comparator` provided at creation time
  id: totrans-1270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TreeMap`类根据键的自然顺序或在创建时提供的`Comparator`对其键值对进行排序'
- en: Many other classes referred to in the online documentation of the `Map` interface.
  id: totrans-1271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多其他类在`Map`接口的在线文档中有所提及。
- en: Exercise – EnumSet methods
  id: totrans-1272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习-EnumSet方法
- en: 'We did not talk about the collection `java.util.EnumSet`. It is lesser known
    but very useful class in cases where you need to work with some `enum` values. Look
    up its API online and write code that demonstrates the usage of its four methods:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有讨论`java.util.EnumSet`集合。它是一个较少人知道但非常有用的类，在需要使用一些`enum`值时。在线查找其API并编写代码来演示其四种方法的用法：
- en: '`of()`'
  id: totrans-1274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of()`'
- en: '`complementOf()`'
  id: totrans-1275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complementOf()`'
- en: '`allOf()`'
  id: totrans-1276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allOf()`'
- en: '`range()`'
  id: totrans-1277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range()`'
- en: Answer
  id: totrans-1278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Assuming the `enum` class looks like the following:'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`enum`类看起来像下面这样：
- en: '```java'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: enum Transport { AIRPLANE, BUS, CAR, TRAIN, TRUCK }
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举运输{AIRPLANE，BUS，CAR，TRAIN，TRUCK}
- en: '```'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Then the code that demonstrates the four methods of `EnumSet` may look like
    this:'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，演示`EnumSet`的四种方法的代码可能如下所示：
- en: '```java'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: EnumSet<Transport> set1 = EnumSet.allOf(Transport.class);
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: EnumSet<Transport> set1 = EnumSet.allOf(Transport.class);
- en: 'System.out.println(set1);   //prints: [AIRPLANE, BUS, CAR, TRAIN, TRUCK]'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set1); //打印：[AIRPLANE，BUS，CAR，TRAIN，TRUCK]
- en: EnumSet<Transport> set2 = EnumSet.range(Transport.BUS, Transport.TRAIN);
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: EnumSet<Transport> set2 = EnumSet.range(Transport.BUS, Transport.TRAIN);
- en: 'System.out.println(set2);   //prints: [BUS, CAR, TRAIN]'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set2); //打印：[BUS，CAR，TRAIN]
- en: EnumSet<Transport> set3 = EnumSet.of(Transport.BUS, Transport.TRUCK);
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: EnumSet<Transport> set3 = EnumSet.of(Transport.BUS, Transport.TRUCK);
- en: 'System.out.println(set3);   //prints: [BUS, TRUCK]'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set3); //打印：[BUS，TRUCK]
- en: EnumSet<Transport> set4 = EnumSet.complementOf(set3);
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: EnumSet<Transport> set4 = EnumSet.complementOf(set3);
- en: 'System.out.println(set4);   //prints: [AIRPLANE, CAR, TRAIN]'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(set4); //打印：[AIRPLANE，CAR，TRAIN]
- en: '```'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Summary
  id: totrans-1294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has made the reader familiar with the Java collections and the
    most popular ones - the `List`, `Set`, and `Map` interfaces. The code examples
    made their functionality more clear. The comments of the code attracted the reader's
    attention to the possible pitfalls and other useful details.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使读者熟悉了Java集合和最流行的集合接口-`List`，`Set`和`Map`。代码示例使它们的功能更加清晰。代码的注释吸引了读者对可能的陷阱和其他有用细节的注意。
- en: In the next chapter, we will continue to overview the most popular classes of
    the Java Standard Library and Apache Commons. Most of them are utilities, such
    as `Objects`, `Collections`, `StringUtils`, and `ArrayUtils`. Others are just
    classes, such as `StringBuilder`, `StringBuffer`, and `LocalDateTime`. Some help
    to manage collections; others, objects. What is common among them is that they
    belong to the small set of tools that every Java programmer has to master before
    they can become effective coders.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续概述Java标准库和Apache Commons中最流行的类。其中大多数是实用程序，例如`Objects`，`Collections`，`StringUtils`和`ArrayUtils`。其他只是类，例如`StringBuilder`，`StringBuffer`和`LocalDateTime`。有些帮助管理集合；其他帮助管理对象。它们的共同之处在于它们属于每个Java程序员在成为有效编码人员之前必须掌握的一小组工具。
