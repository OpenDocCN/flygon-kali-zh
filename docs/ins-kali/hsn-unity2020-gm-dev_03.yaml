- en: '*Chapter 3*: Working with Scenes and GameObjects'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：使用场景和游戏对象'
- en: Welcome to the third chapter of the book—here is where the hard work starts!
    In this chapter, we will develop some base knowledge of Unity in order to edit
    a project. We will see how to use several Unity Editor windows to manipulate our
    first scene and its objects. Also, we will learn how an object or Game Object
    is created and composed and how to manage complex scenes with multiple objects
    using Hierarchies and Prefabs. Finally, we will review how we can properly save
    all our work to continue working on it later.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本书的第三章—这里是艰苦工作开始的地方！在本章中，我们将开发一些关于Unity的基础知识，以便编辑项目。我们将看到如何使用几个Unity编辑器窗口来操作我们的第一个场景及其对象。此外，我们将学习如何创建和组合对象或游戏对象，以及如何使用层次结构和预制件来管理具有多个对象的复杂场景。最后，我们将回顾如何正确保存所有工作，以便以后继续工作。
- en: 'Specifically, we will examine the following concepts in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，我们将研究以下概念：
- en: Manipulating scenes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作场景
- en: GameObjects and components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏对象和组件
- en: Object hierarchies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象层次结构
- en: Prefabs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预制件
- en: Saving scenes and projects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存场景和项目
- en: Manipulating scenes
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作场景
- en: 'A **scene** is one of the several kinds of files (also known as **Assets**)
    in our project. A scene can mean different things according to the type of project
    or the way a company is used to working, but the most common use case is to separate
    your game into whole sections, the most common ones being the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**是我们项目中几种文件（也称为**资源**）之一。根据项目类型或公司习惯的工作方式，场景可能意味着不同的事情，但最常见的用例是将游戏分成整个部分，最常见的部分包括以下内容：'
- en: Main Menu
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主菜单
- en: Level 1, Level 2, Level 3, …, Level N
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1关，第2关，第3关，…，第N关
- en: Victory Screen, Lose Screen
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胜利画面，失败画面
- en: Splash Screen, Loading Screen
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动画面，加载画面
- en: 'In this section, we will cover the following concepts related to scenes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖与场景相关的以下概念：
- en: The purpose of a scene
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景的目的
- en: The Scene View
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景视图
- en: Our first GameObject
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的第一个游戏对象
- en: Navigating the Scene View
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航场景视图
- en: Manipulating GameObjects
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作游戏对象
- en: The purpose of a scene
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景的目的
- en: The idea of separating your game into scenes is that you will process and load
    just the data needed for the scene; so, if you are in the Main Menu you will have
    only the textures, music, and objects that that particular scene needs—there's
    no need to have the Level 10 Boss loaded in **random-access memory** (**RAM**)
    if you don't need it right now. That's why loading screens exist, just to fill
    the time between unloading the Assets needed in one scene and loading the ones
    needed in another. Maybe you are thinking that open-world games such as **Grand
    Theft Auto** (**GTA**) don't have loading screens while you roam around in the
    world, but they are actually loading and unloading chunks of the world in the
    background as you move, and those chunks are different scenes that are designed
    to be connected to each other.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将游戏分成场景的想法是，您将处理并加载场景所需的数据；因此，如果您在主菜单中，您将只有该特定场景需要的纹理、音乐和对象—如果您现在不需要，就没有必要在**随机存取内存**（**RAM**）中加载第10关的Boss。这就是加载画面存在的原因，只是为了填补在卸载一个场景中需要的资源和加载另一个场景中需要的资源之间的时间。也许您会认为像**侠盗猎车手**（**GTA**）这样的开放世界游戏在您漫游世界时没有加载画面，但实际上，它们在您移动时实际上在后台加载和卸载世界的块，而这些块是设计为彼此连接的不同场景。
- en: The difference between the Main Menu and a regular level scene are the objects
    (also known as GameObjects) they have. In a menu, you will find objects such as
    a background, music, buttons, and logos, and in a level you will have the player,
    enemies, platforms, health boxes, and so on. So, it is up to you and the GameObjects
    you put in the scene to decide what that scene means for your game.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 主菜单和常规关卡场景之间的区别在于它们拥有的对象（也称为游戏对象）。在菜单中，您会找到背景、音乐、按钮和标志等对象，在关卡中，您将拥有玩家、敌人、平台、生命值盒等。因此，取决于您和放置在场景中的游戏对象来决定该场景对于您的游戏意味着什么。
- en: But how can we create a scene? Let's start with the Scene View.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何创建一个场景呢？让我们从场景视图开始。
- en: The Scene View
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景视图
- en: 'When you open a Unity project, you will see the Unity Editor. It will be composed
    of several windows or **panels**, each one helping you to change different aspects
    of your game. In this chapter, we will be looking at the windows that help you
    author scenes. The Unity Editor is shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开一个Unity项目时，您将看到Unity编辑器。它将由几个窗口或**面板**组成，每个面板都可以帮助您更改游戏的不同方面。在本章中，我们将看看帮助您编写场景的窗口。Unity编辑器如下截图所示：
- en: '![Figure 3.1 – Unity Editor'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – Unity编辑器'
- en: '](img/Figure_3.01_B14199.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.01_B14199.jpg)'
- en: Figure 3.1 – Unity Editor
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Unity编辑器
- en: 'If you have ever programmed any kind of application before, you are probably
    used to having a starting function, such as **Main**, where you start writing
    code to create several objects needed for your app, and if we are talking about
    games, you probably create all the objects for the scene here. The problem with
    this approach is that in order to ensure all objects are created properly, you
    will need to run the program to see the results, and if something is misplaced
    you will need to manually change the coordinates of the object, which is a slow
    and painful process. Luckily, in Unity, we have the **Scene** View, an example
    of which is shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前曾经编写过任何类型的应用程序，您可能习惯于拥有一个起始函数，比如**Main**，在那里您开始编写代码来创建应用程序所需的多个对象，如果我们谈论游戏，您可能会在这里创建场景中的所有对象。这种方法的问题在于，为了确保所有对象都被正确创建，您需要运行程序以查看结果，如果有什么错位，您将需要手动更改对象的坐标，这是一个缓慢而痛苦的过程。幸运的是，在Unity中，我们有**场景**视图，以下是其示例截图：
- en: '![Figure 3.2 – Scene View'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 场景视图'
- en: '](img/Figure_3.02_B14199.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.02_B14199.jpg)'
- en: Figure 3.2 – Scene View
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 场景视图
- en: This window is an implementation of the classic **WYSIWYG (What You See Is What
    You Get)** concept. Here, you can create objects and place them all over the scene,
    all through a scene previsualization where you can see how the scene will look
    when you hit **Play**. But before learning how to use this scene, we need to have
    an object in the scene, so let's create our first object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口是经典**WYSIWYG（所见即所得）**概念的实现。在这里，您可以创建对象并将它们放置在整个场景中，通过场景预览，您可以看到当您点击**播放**时场景将会呈现什么样子。但在学习如何使用这个场景之前，我们需要在场景中有一个对象，所以让我们创建我们的第一个对象。
- en: Our first GameObject
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个游戏对象
- en: 'The Unity **Universal Render Pipeline** (**URP**) template comes with a construction
    site test scene, but let''s create our own empty scene to start exploring this
    new concept. To do that, you can simply use the **File** | **New Scene** menu
    options to create an empty new scene, as illustrated in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Unity **通用渲染管线**（**URP**）模板带有一个建筑工地测试场景，但让我们创建一个空的场景来开始探索这个新概念。为此，您可以简单地使用**文件**
    | **新建场景**菜单选项来创建一个空的新场景，如下截图所示：
- en: '![Figure 3.3 – Creating a new scene'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 创建一个新场景'
- en: '](img/Figure_3.03_B14199.png)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.03_B14199.png)'
- en: Figure 3.3 – Creating a new scene
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 创建一个新场景
- en: 'We will learn several ways of creating GameObjects throughout the book, but
    now, let''s start using some basic templates Unity provides us. In order to create
    them, we will need to open the **GameObject** menu at the top of the Unity window,
    and it will show us several template categories, such as **3D Object**, **2D Object**,
    **Effects**, and so on, as illustrated in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将学习创建游戏对象的几种方法，但现在，让我们开始使用Unity提供的一些基本模板。为了创建它们，我们需要在Unity窗口顶部打开**GameObject**菜单，它将显示我们几个模板类别，如**3D对象**，**2D对象**，**特效**等，如下截图所示：
- en: '![Figure 3.4 – Creating a cube'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – 创建一个立方体'
- en: '](img/Figure_3.4_B14199.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.4_B14199.jpg)'
- en: Figure 3.4 – Creating a cube
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 创建一个立方体
- en: Under the **3D Object** category, we will see several 3D primitives such as
    **Cube**, **Sphere**, **Cylinder**, and so on, and while using them is not as
    exciting as using beautiful downloaded 3D models, remember that we are prototyping
    our level, also known as gray-boxing. This means that we will use lots of prototyping
    primitive shapes to model our level so that we can quickly test it and see whether
    our idea is good enough to start the complex work of converting it to a final
    version.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在**3D对象**类别下，我们将看到几个3D基本形状，如**立方体**，**球体**，**圆柱体**等，虽然使用它们不如使用精美的下载的3D模型令人兴奋，但请记住，我们正在原型化我们的关卡，也就是灰盒模型。这意味着我们将使用大量的原型形状来模拟我们的关卡，以便我们可以快速测试它，并查看我们的想法是否足够好，可以开始将其转换为最终版本的复杂工作。
- en: I recommend you pick the **Cube** object to start with because it is a versatile
    shape that can represent lots of objects. So, now that we have a scene with an
    object to edit, the first thing we need to learn to do with the scene view is
    to navigate through the scene.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您选择**立方体**对象开始，因为它是一个多功能的形状，可以代表许多对象。因此，现在我们有一个带有要编辑的对象的场景，我们需要学习使用场景视图的第一件事就是浏览场景。
- en: Navigating the Scene View
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览场景视图
- en: 'In order to manipulate a scene, we need to learn how to move through it to
    view the results from different perspectives. There are several ways to navigate
    it, so let''s start with the most common one: the first-person view. This view
    allows you to move through the scene using first-person-shooter-like navigation,
    using the mouse and the *WASD* keys. To navigate like this, you will need to press
    and hold the right mouse button, and while doing so, you can move the mouse to
    rotate the camera and press the *WASD* keys to move it. You can also press *Shift*
    to move faster and press the *Q* and *E* keys to move up and down.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操作一个场景，我们需要学习如何在其中移动以从不同的角度查看结果。有几种导航方式，让我们从最常见的一种开始：第一人称视角。这个视图允许您使用类似第一人称射击游戏的导航方式在场景中移动，使用鼠标和*WASD*键。要像这样导航，您需要按住鼠标右键，然后在这样做的同时，您可以移动鼠标来旋转相机，并按下*WASD*键来移动它。您还可以按下*Shift*键以加快移动速度，并按下*Q*和*E*键来上下移动。
- en: 'Another common way of moving is to click an object to select it (the selected
    object will have an orange outline), and then press the *F* key to focus it, making
    the Scene View camera immediately move into a position where we to look at that
    object more closely. After that, we can press and hold the left *Alt* key and
    the left mouse button, and start moving the mouse to "orbit" around the object
    and see different angles to check that every part of it is properly placed, as
    demonstrated in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的移动方式是单击对象以选择它（所选对象将有橙色轮廓），然后按下*F*键将其聚焦，使场景视图相机立即移动到一个位置，我们可以更仔细地查看该对象。之后，我们可以按住左侧*Alt*键和鼠标左键，开始移动鼠标以围绕对象“轨道”，看到不同的角度来检查它的每个部分是否放置正确，如下截图所示：
- en: '![Figure 3.5 – Selecting an object'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – 选择一个对象'
- en: '](img/Figure_3.05_B14199.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.05_B14199.jpg)'
- en: Figure 3.5 – Selecting an object
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 选择一个对象
- en: Now that we can move freely through the scene, we can start using the Scene
    View to manipulate GameObjects.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以自由地在场景中移动，我们可以开始使用场景视图来操作游戏对象。
- en: Manipulating GameObjects
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作游戏对象
- en: 'Another use of the Scene View is to manipulate the locations of objects. In
    order to do so, we first need to select an object, and then press the *Y* key
    on the keyboard or the sixth button to the right in the top-left corner of the
    Unity Editor, shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 场景视图的另一个用途是操作对象的位置。为了这样做，我们首先需要选择一个对象，然后按键盘上的*Y*键或Unity编辑器左上角的第六个按钮，如下截图所示：
- en: '![Figure 3.6 – Changing the transformation tool'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 – 更改变换工具'
- en: '](img/Figure_3.06_B14199.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.06_B14199.jpg)'
- en: Figure 3.6 – Changing the transformation tool
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 更改变换工具
- en: 'This will show what is called the **Transform Gizmo** over the selected object,
    which allows us to change the position, rotation, and scale of the object, as
    illustrated in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示所选对象上的**变换标尺**，它允许我们改变对象的位置、旋转和缩放，如下截图所示：
- en: '![Figure 3.7 – Transform Gizmo'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 – 变换标尺'
- en: '](img/Figure_3.07_B14199.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.07_B14199.jpg)'
- en: Figure 3.7 – Transform Gizmo
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 变换标尺
- en: 'Let''s start translating the object, which is accomplished by dragging the
    red, green, and blue arrows inside the Gizmo´s sphere. While you do this, you
    will see how the object will be moving along the selected axis. An interesting
    concept to explore here is the meaning of the color of those arrows. If you pay
    attention to the top-right area of the Scene View, you will see an axis Gizmo
    that serves as a reminder of those colors'' meaning, as illustrated in the following
    screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始翻译物体，通过在标尺球内拖动红色、绿色和蓝色箭头来完成。在你这样做的时候，你会看到物体沿着选定的轴移动。这里有一个有趣的概念需要探索，那就是这些箭头颜色的含义。如果你注意场景视图右上角的区域，你会看到一个轴标尺，它作为这些颜色含义的提醒，如下截图所示：
- en: '![Figure 3.8 – Axis Gizmo'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 – 轴标尺'
- en: '](img/Figure_3.08_B14199.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.08_B14199.jpg)'
- en: Figure 3.8 – Axis Gizmo
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 轴标尺
- en: Computer graphics use the classic 3D **Cartesian coordinate system** to represent
    objects' locations. The red color is associated with the *x* axis of the object,
    green with the *y* axis, and blue with the *z* axis. But what does each axis mean?
    If you come from another 3D authoring program, this can be different, but in Unity,
    the *z* axis (blue) represents the **Forward Vector**, which means that the arrow
    is pointing along the front of the object; the *x* axis is the **Right Vector**,
    and the *y* axis represents the **Up Vector**. Consider that those axes are **local**,
    meaning that if you rotate the object, they will change the direction they face
    because the orientation of the object changes the way the object is facing. Unity
    can show those axes in **global** coordinates if necessary, but for now, let's
    stick with local.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机图形学使用经典的3D笛卡尔坐标系来表示物体的位置。红色与物体的x轴相关联，绿色与y轴相关联，蓝色与z轴相关联。但每个轴代表什么意思呢？如果你来自另一个3D制作程序，这可能会有所不同，但在Unity中，z轴（蓝色）代表着**前向矢量**，这意味着箭头指向物体的前方；x轴是**右向矢量**，y轴代表**上向矢量**。需要考虑这些轴是**本地**的，这意味着如果你旋转物体，它们会改变它们面对的方向，因为物体的方向改变了物体面对的方式。Unity可以在必要时显示这些轴的**全局**坐标，但现在让我们坚持使用本地坐标。
- en: 'In order to be sure that we are working with local coordinates, make sure **Local**
    mode is activated, as shown in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们正在使用本地坐标，确保**本地**模式已激活，如下截图所示：
- en: '![Figure 3.9 – Switching between pivot and local coordinates'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 – 在枢轴和本地坐标之间切换'
- en: '](img/Figure_3.9_B14199.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.9_B14199.jpg)'
- en: Figure 3.9 – Switching between pivot and local coordinates
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 在枢轴和本地坐标之间切换
- en: If you see **Global** instead of **Local** as the right button, just click it
    and it will change. By the way, try to keep the left button as **Pivot**. If it
    says **Center**, just click it to change it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到**全局**而不是**本地**作为右侧按钮，只需点击它就会改变。顺便说一下，尽量保持左侧按钮为**枢轴**。如果它显示**中心**，只需点击它进行更改。
- en: I know—we are editing a cube, so there is no clear front or right side, but
    when you work with real 3D models such as cars and characters, they will certainly
    have those sides, and they must be properly aligned with those axes. If by any
    chance in the future you import a car into Unity and the front of the car is pointing
    along the red axis (X), you will need to fix that because our future moving code
    will rely on that convention, but let's keep that for later.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道——我们正在编辑一个立方体，所以没有明显的前面或右侧，但当你使用真实的3D模型，比如汽车和角色时，它们肯定会有这些面，而且它们必须与这些轴正确对齐。如果将来你在Unity中导入一辆汽车，汽车的前面指向红轴（X轴），你需要修正它，因为我们未来的移动代码将依赖于这个约定，但让我们留到以后再说。
- en: Now, let's use this Transform Gizmo to rotate the object using the three colored
    circles around it. If you click and drag, for example, the red circle, you will
    rotate the object along the *x* rotation axis. Here is another interesting tip
    to consider. If you want to rotate the object horizontally, based on the color-coding
    we previously discussed, you will probably pick the *x* axis—the one that is used
    to move horizontally—but, sadly, that's wrong.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个变换标尺来旋转物体，使用它周围的三个彩色圆圈。例如，如果你点击并拖动红色圆圈，你会沿着x旋转轴旋转物体。这里还有一个有趣的提示需要考虑。如果你想根据我们之前讨论的颜色编码来水平旋转物体，你可能会选择x轴——用于水平移动的轴——但很遗憾，那是错误的。
- en: 'A good way to look at rotation is like the accelerator of a bike: you need
    to take it and roll it. If you rotate the *x* axis like this, you will rotate
    the object up and down. So, in order to rotate horizontally, you would need to
    use the green circle or the *y* axis. The process is illustrated in the following
    screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转的一个好方法就像自行车的加速器：你需要拿着它并转动。如果你像这样旋转x轴，你会使物体上下旋转。所以，为了水平旋转，你需要使用绿色圆圈或y轴。这个过程如下截图所示：
- en: '![Figure 3.10 – Rotating an object'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 – 旋转物体'
- en: '](img/Figure_3.10_B14199.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.10_B14199.jpg)'
- en: Figure 3.10 – Rotating an object
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 旋转物体
- en: 'Finally, we have scaling, which is done through the colored cubes on the outer
    side of the Transform Gizmo sphere. If you click and drag those, you will see
    how our cube is stretched over those axes, allowing you to change the size of
    the object. Also, you will have a gray cube in the center of the gizmo that allows
    you to change the size of the object uniformly along all the axes. The process
    is illustrated in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有缩放，通过变换标尺球外侧的彩色立方体来完成。如果你点击并拖动它们，你会看到我们的立方体沿着这些轴被拉伸，允许你改变物体的大小。此外，你会看到标尺中心有一个灰色立方体，它允许你统一沿着所有轴改变物体的大小。这个过程如下截图所示：
- en: '![Figure 3.11 – Scaling an object'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 – 缩放对象'
- en: '](img/Figure_3.11_B14199.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.11_B14199.jpg)'
- en: Figure 3.11 – Scaling an object
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 缩放对象
- en: Remember that scaling objects is usually a bad practice in many cases. In the
    final versions of your scene, you will use models with the proper size and scale,
    and they will be designed in a modular way so that you can plug them one next
    to the other. If you scale them, several bad things can happen, such as textures
    being stretched and becoming pixelated, and modules that no longer plug properly.
    There are some exceptions to this rule, such as placing lots of instances of the
    same tree in a forest and changing its scale slightly to simulate variation, and,
    in the case of gray-boxing, it is perfectly fine to take cubes and change the
    scale to create floors, walls, ceilings, columns, and so on, because in the end,
    those cubes will be replaced with real 3D models.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在许多情况下，缩放对象通常是一个不好的做法。在你场景的最终版本中，你将使用适当大小和比例的模型，并且它们将以模块化的方式设计，这样你可以将它们一个接一个地连接起来。如果你对它们进行缩放，可能会发生一些不好的事情，比如纹理被拉伸并变得像素化，以及不再正确连接的模块。当然也有一些例外，比如在森林中放置大量相同树木的实例，并稍微改变它的比例以模拟变化，以及在灰盒阶段，将立方体改变比例以创建地板、墙壁、天花板、柱子等是完全可以的，因为最终，这些立方体将被真正的3D模型替换。
- en: CHALLENGE
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战
- en: 'Create a room composed of a floor, three regular walls, and a fourth wall with
    a hole for a door (three cubes). In the following screenshot, you can see how
    it should look:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个由地板、三面普通墙和一个带门洞的第四面墙（三个立方体）组成的房间。在下面的截图中，你可以看到它应该是什么样子的：
- en: '![Figure 3.12 – Room task finished'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 – 房间任务完成'
- en: '](img/Figure_3.12_B14199.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.12_B14199.jpg)'
- en: Figure 3.12 – Room task finished
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 房间任务完成
- en: Now that we can edit an object's location, let's see how we can edit all its
    other aspects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编辑对象的位置，让我们看看如何编辑它的其他方面。
- en: GameObjects and components
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏对象和组件
- en: We talked about our project being composed of Assets, and that a Scene (a specific
    type of Asset) is composed of GameObjects; so, how can we create an object? Through
    the composition of **components**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈到我们的项目由资源组成，场景（一种特定类型的资源）由游戏对象组成；那么，我们如何创建一个对象呢？通过**组件**的组合。
- en: 'In this section, we will cover the following concepts related to components:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖与组件相关的以下概念：
- en: Components
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件
- en: Manipulating components
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作组件
- en: Components
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: 'A **component** is one of several pieces a Game Object can be made of; each
    one is in charge of different features of the object. There are several components
    that solve different tasks, such as playing a sound, rendering a mesh, applying
    physics, and so on, and even if Unity has a large number of components, we will
    eventually need to create custom components, sooner or later. In the following
    screenshot, you can see what Unity shows us when we select a Game Object:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件**是游戏对象可以由多个部分组成的其中之一；每个组件负责对象的不同特性。有几个组件可以解决不同的任务，比如播放声音，渲染网格，应用物理等等，即使Unity有大量的组件，我们最终还是需要创建自定义组件，迟早会用到。在下面的截图中，你可以看到当我们选择一个游戏对象时Unity向我们展示的内容：'
- en: '![Figure 3.13 – The Inspector panel'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 – 检视面板'
- en: '](img/Figure_3.13_B14199.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.13_B14199.jpg)'
- en: Figure 3.13 – The Inspector panel
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – 检视面板
- en: 'In the previous screenshot, we can see the **Inspector** panel, and if we needed
    to guess what it does, right now we could say it is showing all the properties
    of the selected object and that we can configure them to change the behavior of
    the object, such as the position and rotation, whether it will project shadows
    or not, and so on. That is true, but we are missing a key element: those properties
    don''t belong to the object; they belong to the components of the object. We can
    see some titles in bold before a group of properties, such as **Transform** and
    **Box Collider**, and so on. Those are the components of the object.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到**检视**面板，如果我们需要猜测它的作用，我们现在可以说它显示了所选对象的所有属性，并且我们可以配置它们来改变对象的行为，比如位置和旋转，是否投射阴影等等。这是正确的，但我们缺少一个关键元素：这些属性不属于对象；它们属于对象的组件。我们可以在一组属性之前看到一些标题加粗，比如**变换**和**盒碰撞器**等等。这些是对象的组件。
- en: In this case, our object has a **Transform**, a **Mesh Filter**, a **Mesh Renderer**,
    and a **Box Collider** component, so let's review each one of those. **Transform**
    just has location information, such as the position, rotation, and scale of the
    object, and by itself it does nothing—it's just a point in our game—but as we
    add components to the object, that position starts to have more meaning. That's
    because some components will interact with **Transform** and other components,
    each one affecting the other.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的对象有一个**变换**、一个**网格过滤器**、一个**网格渲染器**和一个**盒碰撞器**组件，所以让我们逐个审查这些。**变换**只有位置信息，比如对象的位置、旋转和比例，它本身什么也不做——它只是我们游戏中的一个点——但当我们向对象添加组件时，那个位置开始变得更有意义。这是因为一些组件将与**变换**和其他组件互动，每一个都会影响其他。
- en: An example of that would be the case of **Mesh Filter** and **Mesh Renderer**,
    both of those being in charge of rendering a 3D model. **Mesh Renderer** will
    render the mesh specified in the **Mesh Filter** in the position specified in
    the Transform component, so **Mesh Renderer** needs to get data from those other
    components and can't work without them. Another example would be the **Box Collider**.
    This represents the physical shape of the object, so when the physics calculates
    collisions between objects, it checks whether that shape is colliding with other
    shapes based on the position specified in the Transform.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是**网格过滤器**和**网格渲染器**，它们都负责渲染3D模型。**网格渲染器**将在**网格过滤器**中指定的网格在**变换**组件中指定的位置上渲染，所以**网格渲染器**需要从这些其他组件获取数据，没有它们就无法工作。另一个例子是**盒碰撞器**。它代表了对象的物理形状，所以当物理计算对象之间的碰撞时，它会检查该形状是否与其他形状基于**变换**中指定的位置发生碰撞。
- en: We don't want to explore physics and rendering right now. The takeaway from
    this section is that a GameObject is a collection of components, each component
    adding a specific behavior to our object, and each one interacting with the others
    to accomplish the desired task. To further reinforce this, let's see how we can
    convert a cube into a sphere that falls using physics.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不想探索物理和渲染。本节的要点是GameObject是一组组件，每个组件为我们的对象添加特定的行为，并且每个组件与其他组件互动以完成所需的任务。为了进一步加强这一点，让我们看看如何将一个立方体转换成一个使用物理下落的球体。
- en: Manipulating components
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作组件
- en: The tool to edit an object's components is the **Inspector**. It not only allows
    us to change components' properties, but also lets us add and remove components.
    In this case, we want to convert a cube to a sphere, so we need to change several
    aspects of those components. We can start by changing the visual shape of the
    object, so we need to change the rendered model or **Mesh**. The component that
    specifies the Mesh to be rendered is the **MeshFilter** component. If we look
    at it, we can see a **Mesh** property that says **Cube** and that has a little
    circle with a dot to its right.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑对象组件的工具是**检视器**。它不仅允许我们更改组件的属性，还允许我们添加和移除组件。在这种情况下，我们想要将一个立方体转换成一个球体，因此我们需要改变这些组件的几个方面。我们可以从改变对象的视觉形状开始，因此我们需要改变渲染模型或**网格**。指定要渲染的网格的组件是**MeshFilter**组件。如果我们看一下，我们可以看到一个说**Cube**的**Mesh**属性，右边有一个带点的小圆圈。
- en: Important note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you don''t see any property such as the Mesh we just mentioned, try to click
    the triangle at the left of the component''s name. Doing this will expand and
    collapse all the component''s properties. This is illustrated in the following
    screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到任何像我们刚提到的网格的属性，请尝试点击组件名称左侧的三角形。这样做将展开和折叠所有组件的属性。这在下面的截图中有所说明：
- en: '![Figure 3.14 – Disabling a component'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14 – 禁用组件'
- en: '](img/Figure_3.14_B14199.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.14_B14199.jpg)'
- en: Figure 3.14 – Disabling a component
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – 禁用组件
- en: 'If we click it, the **Select Mesh** window will pop up, allowing us to pick
    several Mesh options; so, in this case, select the **Sphere** component. In the
    future, we will add more 3D models to our project so that the window will have
    more options. The mesh selector is shown in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击它，**选择网格**窗口将弹出，允许我们选择几个网格选项；因此，在这种情况下，选择**Sphere**组件。在将来，我们将向我们的项目添加更多的3D模型，以便该窗口将有更多的选项。网格选择器显示在下面的截图中：
- en: '![Figure 3.15 – Mesh selector'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15 – 网格选择器'
- en: '](img/Figure_3.15_B14199.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.15_B14199.jpg)'
- en: Figure 3.15 – Mesh selector
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – 网格选择器
- en: 'Okay—it looks like a sphere, but will it behave like a sphere? Let''s find
    out. In order to do so, we can add a `Rigidbody` in the search box at the top
    of the window. The following screenshot illustrates how to add a component:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，看起来像一个球体，但它会像一个球体一样行为吗？让我们找出来。为了这样做，我们可以在窗口顶部的搜索框中添加一个`Rigidbody`。下面的截图说明了如何添加一个组件：
- en: '![Figure 3.16 – Adding components'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.16 – 添加组件'
- en: '](img/Figure_3.16_B14199.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.16_B14199.jpg)'
- en: Figure 3.16 – Adding components
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 – 添加组件
- en: 'If you hit the Play button in the top-middle part of the editor, you can test
    your sphere physics using the **Game** panel. That panel will be automatically
    focused when you hit Play and will show you how the player will see the game.
    One problem that can happen here is that maybe you won''t see anything, and that
    can happen if the game camera is not pointing to where our sphere is located.
    The playback controls are shown in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击编辑器顶部中间的播放按钮，您可以使用**游戏**面板测试您的球体物理。当您点击播放时，该面板将自动聚焦，并向您展示玩家将如何看到游戏。这里可能出现的一个问题是，也许您看不到任何东西，如果游戏摄像机没有指向我们的球体所在的位置，那就可能会发生这种情况。播放控制显示在下面的截图中：
- en: '![Figure 3.17 – Playback controls'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.17 – 播放控制'
- en: '](img/Figure_3.17_B14199.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.17_B14199.jpg)'
- en: Figure 3.17 – Playback controls
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 – 播放控制
- en: 'Here, you can just use the Transform Gizmo to rotate and position your camera
    in such a way that it looks at our sphere. While you are moving, you can check
    the little preview in the bottom-right part of the scene window to check out the
    new camera perspective. Another alternative would be to select the camera in the
    **Hierarchy** and use the shortcut *Ctrl* + *Shift* + *F* (or *command* + *Shift*
    + *F* on a Mac). The camera preview is shown in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用变换图标来旋转和定位摄像机，使其以某种方式看向我们的球体。在移动时，您可以在场景窗口的右下部分检查小预览，以查看新的摄像机视角。另一种选择是在**层次结构**中选择摄像机，然后使用快捷键*Ctrl*
    + *Shift* + *F*（或Mac上的*command* + *Shift* + *F*）。摄像机预览显示在下面的截图中：
- en: '![Figure 3.18 – Camera preview'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.18 – 摄像机预览'
- en: '](img/Figure_3.18_B14199.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.18_B14199.jpg)'
- en: Figure 3.18 – Camera preview
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – 摄像机预览
- en: 'Now, to test whether Physics collisions are executing properly, let''s create
    a cube, scale it until it has the shape of a ramp, and put that ramp below our
    sphere, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试物理碰撞是否执行正常，让我们创建一个立方体，将其缩放直到它呈坡道形状，并将该坡道放在我们的球体下方，如下所示：
- en: '![Figure 3.19 – Ball and ramp objects'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.19 – 球和坡道对象'
- en: '](img/Figure_3.19_B14199.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.19_B14199.jpg)'
- en: Figure 3.19 – Ball and ramp objects
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 – 球和坡道对象
- en: 'If you hit Play now, you will see the sphere colliding with our ramp, but in
    a strange way. It looks like it''s bouncing, but that''s not the case. If you
    expand the **Box Collider** component of our sphere, you will see that even if
    our object looks like a sphere, the green box gizmo is showing us that our sphere
    is actually a box in the Physics world, as illustrated in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在点击播放，您将看到球体与我们的坡道发生碰撞，但方式很奇怪。看起来像是在弹跳，但实际并非如此。如果您展开球体的**Box Collider**组件，您将看到即使我们的物体看起来像一个球体，绿色的框图标显示我们的球体实际上是一个盒子在物理世界中，如下面的截图所示：
- en: '![Figure 3.20 – Object with sphere graphic and box collider'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.20 – 具有球体图形和盒碰撞器的对象'
- en: '](img/Figure_3.20_B14199.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.20_B14199.jpg)'
- en: Figure 3.20 – Object with sphere graphic and box collider
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 - 具有球形图形和盒碰撞器的对象
- en: Nowadays, video cards can handle rendering highly detailed models (with high
    polygon counts), but the Physics system is executed in the **central processing
    unit** (**CPU**) and it needs to do complex calculations in order to detect collisions.
    To get decent performance in our game (at least 30 **frames per second** (**FPS**))
    the Physics system works using simplified collision shapes that may differ from
    the actual shape the player sees on the screen. That's why we have **Mesh Filter**
    and the different types of Collider components separated—one handles visual shape
    and the other the physics shape.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，视频卡可以处理渲染高度详细的模型（具有高多边形数量），但是物理系统是在**中央处理单元**（**CPU**）中执行的，它需要进行复杂的计算以侦测碰撞。为了在我们的游戏中获得良好的性能（至少30**帧每秒**（**FPS**）），物理系统使用简化的碰撞形状来工作，这些形状可能与玩家在屏幕上看到的实际形状不同。这就是为什么我们有**Mesh
    Filter**和不同类型的碰撞器组件分开——一个处理视觉形状，另一个处理物理形状。
- en: 'Again, the idea of this section is not to deep dive into those Unity systems,
    so let''s just move on for now. How can we solve this? Simple: by modifying our
    components! In this case, **BoxCollider** can just represent a box shape, unlike
    **MeshFilter**, which supports any shape. So, first, we need to remove it by right-clicking
    the component''s title and selecting the **Remove Component** option, as illustrated
    in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，本节的目的不是深入研究这些Unity系统，所以让我们继续前进。我们如何解决这个问题呢？简单：通过修改我们的组件！在这种情况下，**BoxCollider**可以表示一个盒子形状，不像**MeshFilter**，它支持任何形状。因此，首先我们需要通过右键单击组件的标题并选择**移除组件**选项来移除它，如下面的屏幕截图所示：
- en: '![Figure 3.21 – Removing components'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.21 - 移除组件'
- en: '](img/Figure_3.21_B14199.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.21_B14199.jpg)'
- en: Figure 3.21 – Removing components
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 - 移除组件
- en: 'Now, we can again use the **Add Component** menu to select a **Physics** component,
    this time selecting the **Sphere Collider** component. If you look at the Physics
    components, you will see other types of colliders that can be used to represent
    other shapes, but we will look at them later in [*Chapter 15*](B14199_15_Final_SK_ePub.xhtml#_idTextAnchor194)*,
    Physics Collisions and Health System*. The **Sphere Collider** component can be
    seen in the following screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以再次使用**添加组件**菜单来选择一个**物理**组件，这次选择**球体碰撞器**组件。如果您查看物理组件，您将看到其他类型的碰撞器，可以用来表示其他形状，但我们将在[*第15章*](B14199_15_Final_SK_ePub.xhtml#_idTextAnchor194)*，物理碰撞和健康系统*中进行讨论。**球体碰撞器**组件可以在下面的屏幕截图中看到：
- en: '![Figure 3.22 – Adding a Sphere Collider component'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.22 - 添加一个球体碰撞器组件'
- en: '](img/Figure_3.22_B14199.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.22_B14199.jpg)'
- en: Figure 3.22 – Adding a Sphere Collider component
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 - 添加一个球体碰撞器组件
- en: 'So, if you hit Play now, you will see that our sphere not only looks like a
    sphere, but also behaves as one. Remember: the main idea of this section of the
    book is understanding that in Unity you can create whatever object you want just
    by adding, removing, and modifying components, and we will be doing a lot of this
    throughout the book.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您现在点击播放，您将看到我们的球体不仅外观像一个球体，而且行为也像一个球体。记住：本书本节的主要思想是理解在Unity中，您可以通过添加、移除和修改组件来创建任何您想要的对象，我们将在整本书中大量使用这种方法。
- en: Now, components are not the only thing needed in order to create objects. Complex
    objects may be composed of several sub-objects, so let's see how that works.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，组件不是创建对象所需的唯一内容。复杂的对象可能由多个子对象组成，因此让我们看看它是如何工作的。
- en: Object hierarchies
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象层次结构
- en: Some complex objects may need to be separated in sub-objects, each one with
    its own components. Those sub-objects need to be somehow attached to the main
    object and work together to create the necessary object behavior.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一些复杂的对象可能需要分成子对象，每个子对象都有自己的组件。这些子对象需要以某种方式附加到主对象，并共同工作以创建必要的对象行为。
- en: 'In this section, we will cover the following concepts related to components:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖与组件相关的以下概念：
- en: Parenting of objects
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的父子关系
- en: Possible uses
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的用途
- en: Parenting of objects
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象的父子关系
- en: '**Parenting** consists of making an object the child of another, meaning that
    those objects will be related to each other. One type of relationship that happens
    is a **Transform relationship**, meaning that a child object will be affected
    by the parent''s Transform. In simple terms, the child object will follow the
    parent, as if it is attached to it. In an example, imagine a player with a hat
    on their head. The hat can be a child of the player''s head, making the hat follow
    the head while they are attached.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**父子关系**包括使一个对象成为另一个对象的子对象，这意味着这些对象将彼此相关联。发生的一种关系类型是**变换关系**，意味着子对象将受到父对象变换的影响。简单来说，子对象将跟随父对象，就像它附加在上面一样。举个例子，想象一个戴着帽子的玩家。帽子可以是玩家头部的子对象，使帽子在附着时跟随头部移动。'
- en: 'In order to try this, let''s create a capsule that represents an enemy and
    a cube that represents the weapon of the enemy. Remember that in order to do,
    so you can use the **GameObject** | **3D Object** | **Capsule** and **Box** options.
    An example capsule can be seen in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试这个，让我们创建一个代表敌人的胶囊体和一个代表敌人武器的立方体。请记住，为了这样做，您可以使用**GameObject** | **3D Object**
    | **Capsule**和**Box**选项。一个示例胶囊体可以在下面的屏幕截图中看到：
- en: '![Figure 3.23 – A capsule representing a human and box representing a weapon'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.23 - 代表人类的胶囊体和代表武器的盒子'
- en: '](img/Figure_3.23_B14199.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.23_B14199.jpg)'
- en: Figure 3.23 – A capsule representing a human and box representing a weapon
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 - 代表人类的胶囊体和代表武器的盒子
- en: 'If you move the enemy object (the capsule), the weapon (the box) will keep
    its position, not following our enemy. So, in order to prevent that, we can simply
    drag the weapon to the enemy object in the **Hierarchy** window, as illustrated
    in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您移动敌人对象（胶囊体），武器（盒子）将保持其位置，而不会跟随我们的敌人。因此，为了防止这种情况发生，我们可以简单地将武器拖到**层次结构**窗口中的敌人对象上，如下面的屏幕截图所示：
- en: '![Figure 3.24 – Parenting the cube weapon to the capsule character'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.24 - 将立方体武器作为胶囊角色的父对象'
- en: '](img/Figure_3.24_B14199.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.24_B14199.jpg)'
- en: Figure 3.24 – Parenting the cube weapon to the capsule character
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24 - 将立方体武器作为胶囊角色的父对象
- en: Now, if you move the enemy, you will see the gun moving, rotating, and being
    scaled along with it. So, basically, the gun transform also has the effects of
    the enemy Transform component.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你移动敌人，你会看到枪也随之移动、旋转和缩放。所以，基本上，枪的变换也受到敌人变换组件的影响。
- en: Now that we have done some basic parenting, let's explore other possible uses.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做了一些基本的父子关系，让我们继续探索其他可能的用途。
- en: Possible uses
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可能的用途
- en: There are some other uses of parenting aside from creating complex objects.
    Another common usage for it is to organize the project Hierarchy. Right now, our
    scene is simple, but in time it will grow, so keeping track of all the objects
    will become difficult. So, to prevent this, we can create empty GameObjects (in
    **GameObject** | **Create Empty**) to act as containers, putting objects into
    them just to organize our scene. Try to use this with caution, because this has
    a performance cost if you abuse it. Generally, having one or two levels of parenting
    when organizing a scene is fine, but more than that can have a performance hit.
    Consider that you can—and will—have deeper parenting for the creation of complex
    objects; the proposed limit is just for scene organization.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建复杂对象之外，父子关系还有一些其他常见的用途。其中一个常见的用途是组织项目的层次结构。现在，我们的场景很简单，但随着时间的推移，它会变得更加复杂，因此跟踪所有对象将变得困难。为了防止这种情况发生，我们可以创建空的游戏对象（在**GameObject**
    | **Create Empty**中），充当容器，将对象放入其中，以便组织我们的场景。请谨慎使用这个功能，因为如果滥用，会有性能成本。通常情况下，在组织场景时，有一到两级的父子关系是可以接受的，但超过这个数量可能会影响性能。请考虑，你可以并且将会在创建复杂对象时有更深层次的父子关系；所提出的限制只是用于场景组织。
- en: 'To keep improving on our previous example, duplicate the enemy a couple of
    times all around the scene, create an empty Game Object called **Enemies**, and
    drag all the enemies into it so that it will act as a container. This is illustrated
    in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不断改进我们之前的示例，在整个场景中复制敌人几次，创建一个名为**敌人**的空游戏对象，并将所有敌人拖放到其中，使其充当容器。如下截图所示：
- en: '![Figure 3.25 – Grouping enemies in a parent object'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.25 - 将敌人分组在父对象中'
- en: '](img/Figure_3.25_B14199.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.25_B14199.jpg)'
- en: Figure 3.25 – Grouping enemies in a parent object
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.25 - 将敌人分组在父对象中
- en: Another common usage of parenting is to change the **pivot** or center of an
    object. Right now, if we try to rotate our gun with the Transform Gizmo, it will
    rotate around its center because the creator of that cube decided to put the center
    there. Normally, that's okay, but let's consider the case where we need to make
    the weapon aim at the point where our enemy is looking. In this case, we need
    to rotate the weapon around the weapon handle; so, in the case of this "box" weapon,
    it would be the closest end to the enemy. The problem here is that we cannot change
    the center of an object, so one solution would be to create another "weapon" 3D
    model or mesh with another center, which will lead to lots of duplicated versions
    of the weapon if we consider other possible gameplay requirements such as a rotating
    weapon pickup. We can fix this easily using parenting.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 父子关系的另一个常见用途是改变对象的**枢轴**或中心。现在，如果我们尝试用变换控件旋转我们的枪，它会围绕它的中心旋转，因为立方体的创建者决定将中心放在那里。通常情况下，这是可以接受的，但让我们考虑这样一种情况，即我们需要让武器瞄准敌人所看的点。在这种情况下，我们需要围绕武器手柄旋转武器；所以，在这个"盒子"武器的情况下，它将是最接近敌人的一端。问题在于我们无法改变对象的中心，因此一个解决方案是创建另一个具有不同中心的"武器"3D模型或网格，这将导致大量重复的武器版本，如果我们考虑到其他可能的游戏需求，比如旋转武器拾取物品。我们可以很容易地使用父子关系来解决这个问题。
- en: 'The idea is to create an empty GameObject and locate it where we want the new
    pivot of our object to be. After that, we can simply drag our weapon inside this
    empty GameObject, and, from now on, consider the empty object as the actual weapon.
    If you rotate or scale this weapon container, you will see that the weapon mesh
    will apply those transformations around this container, so we can say the pivot
    of the weapon has changed (actually, it hasn''t, but our container simulates the
    change). The process is illustrated in the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是创建一个空的游戏对象，并将其放在我们希望对象的新枢轴的位置。之后，我们可以简单地将我们的武器拖放到这个空的游戏对象中，并且从现在开始，将空对象视为实际的武器。如果你旋转或缩放这个武器容器，你会发现武器网格会围绕这个容器应用这些变换，所以我们可以说武器的枢轴已经改变了（实际上并没有，但我们的容器模拟了这种变化）。这个过程如下截图所示：
- en: '![Figure 3.26 – Changing the weapon pivot'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.26 - 改变武器的枢轴'
- en: '](img/Figure_3.26_B14199.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.26_B14199.jpg)'
- en: Figure 3.26 – Changing the weapon pivot
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.26 - 改变武器的枢轴
- en: Now, let's continue seeing different ways of managing GameObjects, using Prefabs
    this time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看看不同的管理游戏对象的方法，这次使用预制体。
- en: Prefabs
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预制体
- en: In the previous example, we created lots of copies of our enemy around the scene,
    but in doing so, we have created a new problem. Let's imagine we need to change
    our enemy and add a **Rigidbody** component to it, but because we have several
    copies of the same object, we need to take them one by one and add the same component
    to all of them. Maybe later, we will need to change the mass of each enemy, so
    again, we need to go over each one of the enemies and make the change, and here
    we can start to see a pattern.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在场景中创建了许多敌人的副本，但在这样做的过程中，我们创建了一个新问题。让我们想象一下，我们需要改变我们的敌人并给它添加一个**Rigidbody**组件，但因为我们有几个相同对象的副本，我们需要逐个将它们添加相同的组件。也许以后，我们需要改变每个敌人的质量，所以再一次，我们需要逐个地去改变每一个敌人，这里我们可以开始看到一个模式。
- en: One solution could be to select all the enemies using the *Ctrl* key (*option*
    on a Mac) and modify all of them at once, but that solution won't be of any use
    if we have enemy copies in other scenes. So, here is where Prefabs come in.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案可能是使用*Ctrl*键（Mac上的*option*键）选择所有的敌人并一次修改它们，但如果我们在其他场景中有敌人的副本，这个解决方案就没有用了。这就是预制体的用武之地。
- en: 'In this section, we will cover the following concepts related to Prefabs:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖与预制体相关的以下概念：
- en: Creating Prefabs
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建预制体
- en: Prefab-instance relationship
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预制体实例关系
- en: Prefab variants
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预制体变体
- en: Creating Prefabs
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建预制体
- en: '**A Prefab** is a Unity tool that allows us to convert custom-made objects,
    such as our enemy, into an Asset that defines how they can be created. We can
    use them to create new copies of a custom object easily, without needing to create
    its components and sub-objects all over again.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**预制体**是Unity工具，允许我们将自定义对象，比如我们的敌人，转换为定义它们如何创建的资源。我们可以使用它们轻松地创建自定义对象的新副本，而不需要再次创建其组件和子对象。'
- en: 'In order to create a Prefab, we can simply drag our custom object from the
    **Hierarchy** window to the **Project** window, and after doing that you will
    see a new Asset in your project files. The **Project** window is where you can
    navigate and explore all your project files; so, in this case, our Prefab is the
    first Asset we ever created. Now, you can simply drag the Prefab from the **Project**
    window into the Scene to easily create new Prefab copies, as illustrated in the
    following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个预制体，我们可以简单地将自定义对象从**层次结构**窗口拖动到**项目**窗口，这样做之后，你会在项目文件中看到一个新的资源。**项目**窗口是你可以浏览和探索所有项目文件的地方；所以，在这种情况下，我们的预制体是我们创建的第一个资源。现在，你可以简单地将预制体从**项目**窗口拖到场景中，轻松地创建新的预制体副本，如下面的截图所示：
- en: '![Figure 3.27 – Creating a Prefab'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.27 - 创建预制体'
- en: '](img/Figure_3.27_B14199.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.27_B14199.jpg)'
- en: Figure 3.27 – Creating a Prefab
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.27 - 创建预制体
- en: 'Now, we have a little problem here. If you pay attention to the **Hierarchy**
    window, you will see the original Prefab objects and all the new copies with its
    names in blue, while the enemies created before the Prefab will have its names
    in black. The blue in a name means that the object is an **instance** of a Prefab,
    meaning that the object was created based on a Prefab. We can select those blue
    named objects and click the **Select** button in the **Inspector** to select the
    original Prefab that created that object. This is illustrated in the following
    screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个小问题。如果你注意**层次结构**窗口，你会看到原始预制体对象和所有新副本，它们的名称是蓝色的，而在预制体之前创建的敌人的名称是黑色的。名称中的蓝色表示该对象是预制体的**实例**，意味着该对象是基于预制体创建的。我们可以选择这些蓝色命名的对象，并在**检视器**中点击**选择**按钮，选择创建该对象的原始预制体。这在下面的截图中有所说明：
- en: '![Figure 3.28 – Detecting Prefabs in the hierarchy'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.28 - 在层次结构中检测预制体'
- en: '](img/Figure_3.28_B14199.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.28_B14199.jpg)'
- en: Figure 3.28 – Detecting Prefabs in the hierarchy
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.28 - 在层次结构中检测预制体
- en: So, the problem here is that the previous copies of the Prefab are not instances
    of the original Prefab, and sadly there's no way to make them be connected to
    the Prefab. So, in order to make that happen, we need to simply destroy the old
    copies and replace them with copies created with the Prefab. At first, not having
    all copies as instances doesn't seem to be a problem, but it will be in the next
    section of this chapter, where we will explore the relationship between the Prefabs
    and their instances.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，问题在于之前的预制体副本不是原始预制体的实例，遗憾的是没有办法使它们与预制体连接起来。因此，为了实现这一点，我们需要简单地销毁旧的副本，并用预制体创建的副本替换它们。起初，没有所有副本都作为实例似乎不是一个问题，但在本章的下一节中，我们将探讨预制体和它们的实例之间的关系。
- en: Prefab-instance relationship
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预制体实例关系
- en: An instance of a Prefab has a binding to the Prefab that helps to revert and
    apply changes easily between them. If you take a Prefab and make some modifications
    to it, those changes will be automatically applied to all instances across all
    the scenes in the project, so we can easily create a first version of the Prefab,
    use it all around the project, and then experiment with changes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 预制体的实例具有与预制体的绑定，有助于在它们之间轻松地恢复和应用更改。如果你拿一个预制体并对其进行一些修改，这些更改将自动应用到项目中所有场景中的所有实例，因此我们可以轻松地创建预制体的第一个版本，在整个项目中使用它，然后尝试进行更改。
- en: 'To practice this, let''s say we want to add a **Rigidbody** component to the
    enemies so that they can fall. In order to do so, we can simply double-click the
    Prefab file and we will enter Prefab Edit Mode, where we can edit the Prefab isolated
    from the rest of the scene. Here, we can simply take the Prefab root object and
    add the **Rigidbody** component to it. After that, we can simply click on the
    **Scenes** button in the top-left part of the **Scene** window to get back to
    the scene we were editing, and now, we can see that all the Prefab instances of
    the enemy have a **Rigidbody** component, as illustrated in the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习这一点，假设我们想要给敌人添加一个**Rigidbody**组件，以便它们可以下落。为了做到这一点，我们可以简单地双击预制体文件，进入预制体编辑模式，在这里，我们可以编辑预制体，与场景中的其余部分隔离开来。在这里，我们可以简单地取出预制体根对象，并向其添加**Rigidbody**组件。之后，我们可以简单地点击**场景**窗口左上角的**场景**按钮，回到我们正在编辑的场景，现在，我们可以看到所有敌人的预制体实例都有**Rigidbody**组件，如下面的截图所示：
- en: '![Figure 3.29 – Prefab Edit Mode'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.29 - 预制体编辑模式'
- en: '](img/Figure_3.29_B14199.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.29_B14199.jpg)'
- en: Figure 3.29 – Prefab Edit Mode
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.29 - 预制体编辑模式
- en: 'Now, what happens if we change a Prefab instance instead? Let''s say we want
    one specific enemy to fly, so they won''t suffer the effect of gravity. We can
    do that by simply selecting the specific Prefab and unchecking the **Use Gravity**
    checkbox in the **Rigidbody** component. After doing that, if we play the game,
    we will see that only that specific instance will float. That''s because changes
    of an instance of a Prefab became an **override**, and we can see that clearly
    if you see how the **Use** **Gravity** property of that instance becomes bold
    in the **Inspector**. Let''s take another object and change its **Scale** property
    to make it bigger. Again, we will see how the **Scale** property becomes bold,
    and with a little bar at its left. The **Use Gravity** checkbox can be seen in
    the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们改变了一个预制体实例会发生什么呢？比如说我们想让一个特定的敌人飞行，这样他们就不会受到重力的影响。我们只需选择特定的预制体，取消**刚体**组件中的**使用重力**复选框。这样做后，如果我们玩游戏，我们会看到只有那个特定实例会飘浮。这是因为预制体实例的更改变成了**覆盖**，如果你看**检视器**中的该实例的**使用重力**属性变成了粗体，你就可以清楚地看到这一点。让我们拿另一个对象，改变它的**缩放**属性使其变大。同样，我们会看到**缩放**属性变成了粗体，并且左侧有一个小条。**使用重力**复选框可以在下面的截图中看到：
- en: '![Figure 3.30 – Use Gravity being highlighted as an override'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.30 – 使用重力被突出显示为覆盖'
- en: '](img/Figure_3.30_B14199.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.30_B14199.jpg)'
- en: Figure 3.30 – Use Gravity being highlighted as an override
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.30 – 使用重力被突出显示为覆盖
- en: 'The overrides have precedence over the Prefab, so if we change the scale of
    the original Prefab, the one that has a scale override won''t change, keeping
    its own version of the scale, as illustrated in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖优先于预制体，因此如果我们改变原始预制体的缩放，具有缩放覆盖的预制体不会改变，保持其自己的缩放版本，如下截图所示：
- en: '![Figure 3.31 – One Prefab instance with an scale override'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.31 – 一个带有缩放覆盖的预制体实例'
- en: '](img/Figure_3.31_B14199.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.31_B14199.jpg)'
- en: Figure 3.31 – One Prefab instance with an scale override
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.31 – 一个带有缩放覆盖的预制体实例
- en: 'We can easily locate all overrides of an instance using the **Overrides** dropdown
    in the **Inspector**, locating all the changes our object has. It not only allows
    us to see all the overrides, but also reverts any override we don''t want and
    applies the ones we want. Let''s say we regretted the lack of gravity of that
    specific Prefab—no problem! We can just locate the override and revert it. The
    process is illustrated in the following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**检视器**中的**覆盖**下拉菜单轻松定位实例的所有覆盖，找到我们对象的所有更改。它不仅允许我们查看所有覆盖，还可以撤销我们不想要的任何覆盖并应用我们想要的覆盖。比如说，我们后悔了特定预制体缺乏重力，没问题！我们只需找到覆盖并撤销它。该过程如下截图所示：
- en: '![Figure 3.32 – Reverting a single override'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.32 – 撤销单个覆盖'
- en: '](img/Figure_3.32_B14199.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.32_B14199.jpg)'
- en: Figure 3.32 – Reverting a single override
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.32 – 撤销单个覆盖
- en: 'Also, let''s imagine that we really liked the new scale of that instance, so
    we want all instances to have that scale—great! We can simply hit the **Apply**
    button, select the specific change, and all instances will have that scale (except
    the ones with an override), as illustrated in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，假设我们真的喜欢那个实例的新缩放，所以我们希望所有实例都具有那个缩放—太棒了！我们只需点击**应用**按钮，选择特定的更改，所有实例都会具有那个缩放（除了具有覆盖的实例），如下截图所示：
- en: '![Figure 3.33 – The Apply button'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.33 – 应用按钮'
- en: '](img/Figure_3.33_B14199.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.33_B14199.jpg)'
- en: Figure 3.33 – The Apply button
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.33 – 应用按钮
- en: Also, we have the **Revert All** and **Apply All** buttons, but use them with
    caution, because you can easily revert and apply changes that you are not aware
    of.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有**撤销所有**和**应用所有**按钮，但要谨慎使用，因为你可能会轻易撤销和应用你不知道的更改。
- en: So, as you can see, Prefab is a really useful Unity tool to keep track of all
    similar objects and apply changes to all of them, and also have specific instances
    with few variations. Talking about variations, there are other cases where you
    will want to have several instances of a Prefab with the same set of variations—as
    an example, flying enemies and grounded enemies—but if you think about that, we
    will have the same problem we had when we didn't use Prefabs, so we need to manually
    update those varied versions one by one.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如你所看到的，预制体是一个非常有用的Unity工具，可以跟踪所有相似的对象并对它们应用更改，并且还可以具有具有少量变化的特定实例。谈到变化，还有其他情况，你会希望有几个具有相同变化集的预制体实例，比如飞行敌人和地面敌人，但是如果你考虑一下，我们在不使用预制体时遇到的问题是一样的，所以我们需要手动逐个更新这些不同版本。
- en: 'Here, we have two options: one is to create a brand new Prefab just to have
    another version with that variation. This leads to the problem that if we want
    all types of enemies to suffer changes, we need to manually apply the changes
    to each possible Prefab. The second option is to create a Prefab variant. Let''s
    review the latter.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个选择：一个是创建一个全新的预制体，只是为了有另一个带有那种变化的版本。这会导致一个问题，如果我们希望所有类型的敌人都受到更改，我们需要手动将更改应用到每个可能的预制体。第二个选择是创建一个预制体变体。让我们来看看后者。
- en: Prefab variants
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预制体变体
- en: A **Prefab variant** is the act of creating a new Prefab but based on an existing
    one, so the new one **inherits** the features of the base Prefab. This means that
    our new Prefab can have differences with the base one, but the features that they
    have in common are still connected.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**预制体变体**是创建一个新的预制体，但基于现有预制体的行为，因此新的预制体**继承**了基础预制体的特性。这意味着我们的新预制体可以与基础预制体有所不同，但它们共有的特性仍然是相连的。'
- en: 'To illustrate this, let''s create a variation of the enemy Prefab that can
    fly: the flying enemy Prefab. In order to do that, we can select an existing enemy
    Prefab instance in the **Hierarchy** window, name it **Flying Enemy**, and drag
    it again to the **Project** window, and this time we will see a prompt, asking
    which kind of Prefab we want to create. This time, we need to choose **Prefab
    Variant**, as illustrated in the following screenshot:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们创建一个可以飞行的敌人预制件的变体：飞行敌人预制件。为此，我们可以在“层次结构”窗口中选择现有的敌人预制件实例，将其命名为“飞行敌人”，然后再次将其拖到“项目”窗口中，这次会看到一个提示，询问我们要创建哪种预制件。这次，我们需要选择“预制件变体”，如下截图所示：
- en: '![Figure 3.34 – Creating Prefab variants'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.34 - 创建预制件变体
- en: '](img/Figure_3.34_B14199.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.34_B14199.jpg)'
- en: Figure 3.34 – Creating Prefab variants
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.34 - 创建预制件变体
- en: 'Now, we can enter the Prefab Edit Mode of the variant by double-clicking it,
    and then add a cube as the jet pack of our enemy, and also uncheck the **Use Gravity**
    property for the enemy. If we get back to the Scene, we will see the variant instance
    being changed, and the base enemies aren''t changed. You can see this in the following
    screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过双击进入变体的预制件编辑模式，然后添加一个立方体作为我们敌人的喷气背包，并取消敌人的“使用重力”属性。如果我们返回到场景，我们将看到变体实例已经更改，而基本敌人没有改变。您可以在下面的截图中看到这一点：
- en: '![Figure 3.35 – Prefab variant instance'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.35 - 预制件变体实例
- en: '](img/Figure_3.35_B14199.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.35_B14199.jpg)'
- en: Figure 3.35 – Prefab variant instance
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.35 - 预制件变体实例
- en: 'Now, imagine you want to add a hat to all our types of enemies. We can simply
    enter the Prefab Edit Mode of the base enemy Prefab by double-clicking it, and
    add a cube as a hat. Now, we will see that change applied to all the enemies,
    because remember: the **Flying Enemy** Prefab is a variant of the base enemy Prefab,
    meaning that it will inherit all the changes of that one.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下您想要为我们所有类型的敌人添加一个帽子。我们只需双击基本敌人预制件进入预制件编辑模式，然后添加一个立方体作为帽子。现在，我们将看到该更改应用于所有敌人，因为请记住：“飞行敌人”预制件是基本敌人预制件的变体，这意味着它将继承所有更改。
- en: We have created lots of content so far, but if our PC turns off for some reason,
    we will certainly lose it all, so let's see how we can save our progress.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了大量内容，但是如果我们的电脑因某种原因关闭，我们肯定会丢失所有内容，所以让我们看看如何保存我们的进度。
- en: Saving scenes and projects
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存场景和项目
- en: As in any other program, we need to save our progress. The difference here is
    that we don't have just one giant file with all the project Assets, but several
    files for each Asset.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他程序一样，我们需要保存我们的进度。不同之处在于，我们不只有一个包含所有项目资产的巨大文件，而是每个资产都有几个文件。
- en: 'In this section, we will cover the following concepts related to saving:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下与保存相关的概念：
- en: Saving our changes
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存我们的更改
- en: Project structure
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目结构
- en: Saving our changes
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存我们的更改
- en: 'Let''s start saving our progress by saving the scene, which is pretty straightforward.
    We can simply go to `Assets` folder of our project, but never outside that folder.
    That will generate a new Asset in the **Project** window: a scene file, as illustrated
    in the following screenshot:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始通过保存场景来保存我们的进度，这非常简单。我们只需转到项目的“资产”文件夹，但永远不要超出该文件夹。这将在“项目”窗口中生成一个新的资产：一个场景文件，如下截图所示：
- en: '![Figure 3.36 – Scene files'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.36 - 场景文件
- en: '](img/Figure_3.36_B14199.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.36_B14199.jpg)'
- en: Figure 3.36 – Scene files
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.36 - 场景文件
- en: We can create a folder to save our scene in that dialog, or, if you already
    saved the scene, you can create a folder using the **Create** | **Folder** option
    in the **Project** window and drag the created scene to that folder. Now, if you
    create another Scene with the **File** | **New Scene** menu option, you can get
    back to the previous scene just by double-clicking the Asset in the **Project**
    window.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在对话框中创建一个文件夹来保存我们的场景，或者，如果您已经保存了场景，可以在“项目”窗口中使用“创建”|“文件夹”选项创建一个文件夹，并将创建的场景拖到该文件夹中。现在，如果您使用“文件”|“新建场景”菜单选项创建另一个场景，您可以通过在“项目”窗口中双击资产来返回到先前的场景。
- en: This only saved the Scene, but any change in Prefabs and another kind of Assets
    are not saved with that option. Instead, if you want to save every change on the
    Assets except Scenes, you can use the **File** | **Save Project** option. It can
    be a little bit confusing, but if you want to save all your changes, you need
    to both save the scenes and the project, as saving just the project won't save
    the changes on Scenes. Sometimes, the best way to be sure everything is saved
    is just by closing Unity, which is recommended when you try to move your project
    between computers or folders. Let's talk about that in the next section.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这只保存了场景，但是对预制件和其他类型的资产的任何更改都不会使用该选项保存。相反，如果您想保存除场景之外的所有资产的每个更改，可以使用“文件”|“保存项目”选项。这可能有点令人困惑，但是如果您想保存所有更改，您需要同时保存场景和项目，因为仅保存项目不会保存场景上的更改。有时，确保一切都已保存的最佳方法就是关闭Unity，这在尝试在计算机或文件夹之间移动项目时是推荐的。让我们在下一节中讨论这个问题。
- en: Project structure
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'Now that we have saved all our changes, we are ready to move the project between
    computers or to another folder (if you someday need to). You can close Unity to
    make sure everything is saved and just copy the entire project folder. If you
    don''t remember where you saved your project, you can just right-click the `Assets`
    folder in the **Project** window and select **Show in Explorer** (**Reveal in
    Finder** on a Mac), as illustrated in the following screenshot:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经保存了所有更改，我们准备好将项目在计算机之间或到另一个文件夹中移动（如果有需要的话）。您可以关闭Unity以确保一切都已保存，并只需复制整个项目文件夹。如果您不记得在哪里保存了项目，您可以右键单击“项目”窗口中的“资产”文件夹，然后选择“在资源管理器中显示”（Mac上的“显示在Finder中”），如下截图所示：
- en: '![Figure 3.37 – Locating the project folder'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.37 - 定位项目文件夹
- en: '](img/Figure_3.37_B14199.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.37_B14199.jpg)'
- en: Figure 3.37 – Locating the project folder
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.37 - 定位项目文件夹
- en: 'Let''s take the opportunity, now that we are in the project folder, to explore
    a little bit. We will find several folders and files in a full project, but not
    all the files are necessary to copy in order to move the project elsewhere. The
    most important folders are `Assets`, `ProjectSettings`, and `Packages`. These
    folders can be seen in the following screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在项目文件夹中，让我们抓住机会稍微探索一下。在一个完整的项目中，我们会发现几个文件夹和文件，但并非所有文件都需要复制以便将项目移动到其他地方。最重要的文件夹是`Assets`、`ProjectSettings`和`Packages`。这些文件夹可以在以下截图中看到：
- en: '![Figure 3.38 –  Project folder structure'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.38 - 项目文件夹结构'
- en: '](img/Figure_3.38_B14199.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.38_B14199.jpg)'
- en: Figure 3.38 –  Project folder structure
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.38 - 项目文件夹结构
- en: '`ProjectSettings` folder contains several configurations of different Unity
    systems we will fiddle with later in this book, but even if we didn''t change
    any settings, it''s always a good idea to bring that folder with us. `.unitypackage`
    files used to be, but let''s discuss that later. So far, it''s important to note
    that that folder will have settings about which packages our project is using,
    so remember to also bring that one with you.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProjectSettings`文件夹包含了我们将在本书后面玩弄的不同Unity系统的几个配置，但即使我们没有更改任何设置，带上这个文件夹总是一个好主意。`.unitypackage`文件曾经是，但让我们稍后讨论。到目前为止，重要的是要注意，该文件夹将包含关于我们的项目正在使用哪些包的设置，因此也记得带上它。'
- en: No other folders/files are necessary because some are them are temporary and
    others can be regenerated, such as **Library**, where all the converted versions
    of our Assets will live. By converted, we mean externally generated files, such
    as 3D models, images, sounds, and so on. Unity needs to convert those files to
    a Unity-compatible format. The original will live in **Assets** and the converted
    ones in **Library** so that they can be easily regenerated if necessary. Later,
    in [*Chapter 5*](B14199_05_Final_SK_ePub.xhtml#_idTextAnchor085)*, Importing and
    Integrating Assets*, we will discuss integrating externally generated content.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 其他文件夹/文件都不是必需的，因为其中一些是临时的，另一些可以重新生成，比如**Library**，那里存放着我们资产的转换版本。通过转换，我们指的是外部生成的文件，比如3D模型、图像、声音等。Unity需要将这些文件转换为Unity兼容的格式。原始文件将存放在**Assets**中，转换后的文件将存放在**Library**中，以便在必要时可以轻松重新生成。稍后，在[*第5章*](B14199_05_Final_SK_ePub.xhtml#_idTextAnchor085)*，导入和集成资产*中，我们将讨论如何集成外部生成的内容。
- en: 'Now, let''s imagine you have compressed those three folders, copied them to
    a flash drive, and then decompressed the folders into another computer. How can
    we open the project again? As you can see, a project doesn''t have a project file
    or anything like that—it''s just a bunch of folders. In order to open a project,
    the easiest way would be to find a scene file in the `Assets` folder and double-click
    it so that Unity will open the project in that scene. Another option would be
    to use the `Assets` folder). So, we will add that project to the list of our computer
    projects, and later, we can just click the name in that list to open it. The following
    screenshot illustrates this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象一下，你已经压缩了这三个文件夹，将它们复制到U盘中，然后在另一台电脑上解压这些文件夹。我们如何再次打开项目呢？正如你所看到的，项目没有项目文件或类似的东西
    - 它只是一堆文件夹。为了打开一个项目，最简单的方法是在`Assets`文件夹中找到一个场景文件，然后双击它，这样Unity就会在那个场景中打开项目。另一个选项是使用`Assets`文件夹。因此，我们将把该项目添加到我们计算机项目的列表中，稍后，我们只需点击列表中的名称即可打开它。以下截图说明了这一点：
- en: '![Figure 3.39 – Reopening a project'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.39 - 重新打开项目'
- en: '](img/Figure_3.39_B14199.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.39_B14199.jpg)'
- en: Figure 3.39 – Reopening a project
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.39 - 重新打开项目
- en: Now, we have all the base Unity knowledge we need in order to start diving into
    how to use the different Unity systems so that we can start creating a real game!
    Let's do that in the next chapter!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经掌握了开始学习如何使用不同的Unity系统所需的所有基本Unity知识，以便开始创建一个真正的游戏！让我们在下一章中做到这一点！
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw a quick introduction of essential Unity concepts. We
    reviewed all the Unity windows and how we can use all of them to edit a full scene,
    from navigating it and creating premade objects, to manipulating them to create
    our own types of objects using GameObjects and Components. We also discussed how
    to use the **Hierarchy** window to parent GameObjects to create complex object
    hierarchies, as well as creating Prefabs to reutilize and manipulate large amounts
    of the same type of objects. Finally, we discussed how we can save our progress
    and move the project, reviewing the structure of it and which folders are the
    essential ones.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了基本的Unity概念。我们回顾了所有Unity窗口以及如何使用它们来编辑一个完整的场景，从导航和创建预制对象，到操纵它们以创建我们自己类型的对象，使用游戏对象和组件。我们还讨论了如何使用**Hierarchy**窗口将游戏对象进行父子关系，以创建复杂的对象层次结构，以及创建预制件以重用和操纵大量相同类型的对象。最后，我们讨论了如何保存我们的进度并移动项目，回顾了项目的结构以及哪些文件夹是必不可少的。
- en: In the next chapter, we will learn about the different tools that we will use
    to create the first prototype of our game's level.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用不同的工具来创建游戏关卡的第一个原型。
