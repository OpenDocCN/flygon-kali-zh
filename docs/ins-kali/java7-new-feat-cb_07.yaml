- en: Chapter 7. Graphical User Interface Improvements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章.图形用户界面改进
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Mixing heavyweight and lightweight components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合重量级和轻量级组件
- en: Managing window types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理窗口类型
- en: Managing the opacity of a window
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理窗口的不透明度
- en: Creating a varying gradient translucent window
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建变化的渐变半透明窗口
- en: Managing the shape of a window
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理窗口的形状
- en: Using the new border types in Java 7
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java 7中使用新的边框类型
- en: Handling multiple file selection in the FileDialog class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在FileDialog类中处理多个文件选择
- en: Controlling the print dialog box type
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制打印对话框类型
- en: Using the new JLayer decorator for a password field
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的JLayer装饰器为密码字段
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The ability to develop applications that have a **Graphical User Interface**
    (**GUI**) interface has been enhanced in Java 7\. Some of these are minor improvements
    and are discussed in this introduction. Others, such as using the `javax.swing.JLayer`
    decorator class are more involved and are discussed in separate recipes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中增强了开发具有**图形用户界面**（**GUI**）界面的应用程序的能力。其中一些是较小的改进，并在本介绍中进行了讨论。其他的，如使用`javax.swing.JLayer`装饰器类，更为复杂，分别在单独的配方中进行了讨论。
- en: It is now possible to mix heavyweight and lightweight components in an application
    without adding special code to make it work as desired. This improvement is largely
    transparent to users of Java 7\. However, the essence of this approach, and special
    situations that might arise from their use, are detailed in the *Mixing heavyweight
    and lightweight components* recipe.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在应用程序中混合重量级和轻量级组件，而无需添加特殊代码来使其按预期工作。这一改进对Java 7的用户来说基本上是透明的。然而，这种方法的本质以及可能由于它们的使用而出现的特殊情况在*混合重量级和轻量级组件*配方中有详细介绍。
- en: To ease the development of applications, three basic window types have been
    introduced. These should simplify the creation of certain types of applications
    and are discussed in the *Managing window types* recipe.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化应用程序的开发，引入了三种基本的窗口类型。这些应该简化某些类型应用程序的创建，并在“管理窗口类型”配方中进行了讨论。
- en: The overall appearance of an application may include such characteristics as
    its opacity and shape. The *Managing the opacity of a window* recipe illustrates
    how to control a window's opacity and the *Creating a varying gradient translucent
    window* recipe looks into creating gradients for such windows. Controlling the
    shape of a window, such as making it round or some irregular shape, is detailed
    in the *Managing the shape of a window* recipe.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的整体外观可能包括其不透明度和形状等特征。*管理窗口的不透明度*配方说明了如何控制窗口的不透明度，*创建变化的渐变半透明窗口*配方则探讨了为这样的窗口创建渐变。详细介绍了控制窗口的形状，例如使其圆形或某种不规则形状，*管理窗口的形状*配方中有详细说明。
- en: The translucency-related capabilities were added originally as part of the **Java
    6 Update 10** release. However, they were implemented as part of the private `com.sun.awt.AWTUtilities`
    class. This capability has been moved to the `java.awt` package.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与**Java 6 Update 10**发布一起，透明度相关的功能最初是作为私有的`com.sun.awt.AWTUtilities`类的一部分添加的。然而，这些功能已经移动到了`java.awt`包中。
- en: '`Javax.swing.JComponents` have borders whose appearance can be controlled.
    In Java 7, several new borders have been added. These are illustrated in the *Using
    the new border types in Java 7* recipe.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Javax.swing.JComponents`具有可以控制外观的边框。在Java 7中，添加了几种新的边框。这些在*在Java 7中使用新的边框类型*配方中有详细说明。'
- en: Improvements have also been made in the use of the file dialog and print dialog
    boxes. These enhancements are discussed in the *Handling multiple file selection
    in the FileDialog class* and *Controlling the print dialog box type* recipes,
    respectively.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对话框和打印对话框的使用也进行了改进。这些增强功能分别在*处理文件对话框类中的多个文件选择*和*控制打印对话框类型*配方中进行了讨论。
- en: The ability to draw over a `JComponent` has been added. This allows the use
    of special effects, which were not easily achieved in earlier versions of Java.
    The *Using the new JLayer decorator for a password field* recipe illustrates this
    process and also demonstrates how to create a watermark for windows.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在`JComponent`上绘制。这允许使用特殊效果，这在早期版本的Java中并不容易实现。*使用新的JLayer装饰器为密码字段*配方说明了这个过程，并演示了如何为窗口创建水印。
- en: 'All the recipes of this chapter use a `JFrame-based` application. The following
    is the code used to develop a minimal window-based application, upon which the
    recipe''s examples are based. An `ApplicationDriver` class is used to start and
    display the `JFrame-derived ApplicationWindow` class. The `ApplicationDriver`
    class is shown as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有配方都使用了基于`JFrame`的应用程序。以下是用于开发基于最小窗口的应用程序的代码，这些代码是配方示例的基础。使用`ApplicationDriver`类来启动和显示`JFrame`派生的`ApplicationWindow`类。`ApplicationDriver`类如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `invokeLater` method uses an inner class to create and then display the
    `ApplicationWindow`. This window is set up in its constructor. It is a simple
    window that has an **Exit** button, which we will use to close the application
    and enhance in later recipes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeLater`方法使用内部类来创建并显示`ApplicationWindow`。这个窗口在其构造函数中设置。这是一个简单的窗口，有一个**退出**按钮，我们将在后续的配方中用来关闭应用程序并进行增强：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When this code is executed, the output should appear as shown in the following
    screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此代码时，输出应该如下截图所示：
- en: '![Introduction](img/5627_07_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Introduction](img/5627_07_01.jpg)'
- en: There are a number of minor improvements introduced in Java 7\. For example,
    the protected static `java.awt.Cursor` array has been deprecated. Instead, use
    the `getPredefinedCursor` method. This method takes an integer argument and returns
    a `Cursor` object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中引入了一些较小的改进。例如，受保护的静态`java.awt.Cursor`数组已被弃用。而是使用`getPredefinedCursor`方法。此方法接受一个整数参数并返回一个`Cursor`对象。
- en: 'A new **HSV** tab was introduced to the `java.swing.JColorChooser` dialog box.
    It appears as shown in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.swing.JColorChooser`对话框引入了一个新的**HSV**选项卡。如下截图所示：'
- en: '![Introduction](img/5627_07_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Introduction](img/5627_07_02.jpg)'
- en: 'Also in Java 7, it is possible to customize a dragged JApplet''s title and
    to specify whether it should be decorated or not. This is accomplished from a
    `script` tag as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中，可以自定义拖动的JApplet的标题，并指定是否应该装饰。这是通过`script`标签来实现的：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `java_decorated_frame` parameter is set to `true` to specify that the window
    should be decorated. The title of the window is specified using the `java_applet_title`
    parameter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`java_decorated_frame`参数设置为`true`，以指定窗口应该装饰。使用`java_applet_title`参数指定窗口的标题。'
- en: This example is adapted from [http://download.oracle.com/javase/tutorial/deployment/applet/draggableApplet.html](http://download.oracle.com/javase/tutorial/deployment/applet/draggableApplet.html).
    More details on how to create draggable applets can be found at that site.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例改编自[http://download.oracle.com/javase/tutorial/deployment/applet/draggableApplet.html](http://download.oracle.com/javase/tutorial/deployment/applet/draggableApplet.html)。可以在该网站上找到有关如何创建可拖动小程序的更多详细信息。
- en: A couple of miscellaneous changes need to be noted. The **Nimbus Look and Feel**
    has been moved from the `com.sun.java.swing` package to the `javax.swing` package.
    The `isValidateRoot` method has been added to the `Applet` class to indicate that
    the container is a valid root. Lastly, a new **Java2D** graphics pipeline based
    upon the **X11 XRender** extension has been added to provide better access to
    **Graphical Processing Units** (**GPU**).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意一些杂项更改。**Nimbus外观**已从`com.sun.java.swing`包移动到`javax.swing`包。`isValidateRoot`方法已添加到`Applet`类中，以指示容器是有效的根。最后，基于**X11
    XRender**扩展的新**Java2D**图形管道已添加，以提供更好的访问**图形处理单元**（**GPU**）。
- en: Mixing heavyweight and lightweight components
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合重量级和轻量级组件
- en: 'Java provides two basic sets of components for developing GUI applications:
    **Abstract Window Toolkit** (**AWT**) and **Swing**. AWT is dependent upon the
    native systems'' underlying code, and these components are therefore referred
    to as heavyweight components. Swing components, on the other hand, operate fully
    independent of the native system, are completely implemented in Java code, and
    are thus referred to as lightweight components. In previous versions of Java,
    it was inefficient and troublesome to mix heavyweight and lightweight components.
    In `Java 6 Update 12`, and continuing into Java 7, the JVM handles the mixing
    of heavyweight and lightweight components.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了两种基本的组件集用于开发GUI应用程序：**抽象窗口工具包**（**AWT**）和**Swing**。 AWT依赖于本地系统的底层代码，因此这些组件被称为重量级组件。另一方面，Swing组件完全独立于本地系统运行，完全由Java代码实现，因此被称为轻量级组件。在以前的Java版本中，混合重量级和轻量级组件是低效且麻烦的。在`Java
    6 Update 12`中，并持续到Java 7，JVM处理了重量级和轻量级组件的混合。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'If you are working with code that implements both heavyweight and lightweight
    components, there is no need to make any changes to the code, as Java 7 automatically
    handles the components. We are going to modify code from the beginning of this
    chapter to demonstrate this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用同时实现重量级和轻量级组件的代码，无需对代码进行任何更改，因为Java 7会自动处理这些组件。我们将修改本章开头的代码来演示这一点：
- en: Create a new application using the code examples from the introduction section.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用介绍部分的代码示例创建一个新的应用程序。
- en: Modify the code to use both heavyweight and lightweight examples.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改代码以使用重量级和轻量级示例。
- en: Run the application using an older version of Java and then again using Java
    7.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用旧版本的Java运行应用程序，然后再次使用Java 7运行。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new window application as specified in the introduction to this chapter.
    Add the following section of code to the `ApplicationWindow` constructor:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照本章的介绍指定创建一个新的窗口应用程序。将以下代码段添加到`ApplicationWindow`构造函数中：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, modify the declaration of the **Exit** button so that you are now using
    a heavyweight `Button` rather than a lightweight `JButton` as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改**Exit**按钮的声明，使其现在使用重量级的`Button`而不是轻量级的`JButton`，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Execute the application. You need to run the application using a version of
    Java prior to **Java 6 Build 10** or the overlapping issue will not display. When
    the window opens, click on the menu and notice that, although the menu item overlaps
    the **Exit** button, the button shows through and covers the menu text. The following
    is an example of the overlap:![How to do it...](img/5627_07_03.jpg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您需要使用**Java 6 Build 10**之前的版本运行应用程序，否则重叠问题将不会显示。当窗口打开时，点击菜单，注意虽然菜单项重叠了**Exit**按钮，但按钮显示出来并覆盖了菜单文本。以下是重叠的示例：![如何做...](img/5627_07_03.jpg)
- en: 'Now, run the application again using Java 7\. When you click on the menu this
    time, you should notice the overlapping issue has been resolved, as shown in the
    following screenshot:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用Java 7再次运行应用程序。当您这次点击菜单时，您应该注意到重叠问题已经解决，如下面的截图所示：
- en: '![How to do it...](img/5627_07_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5627_07_04.jpg)'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The JVM handles the mixing of components automatically. In this example, we
    created a scenario to illustrate the overlapping problem, and then showed how
    it was resolved in the latest Java releases. However, it is a good practice to
    call the `validate` method on the top-level frame to ensure that all shapes are
    redrawn properly. There is also the potential that previous work-arounds for mixing
    components may need to be removed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JVM会自动处理组件的混合。在这个例子中，我们创建了一个场景来说明重叠问题，然后展示了如何在最新的Java版本中解决了这个问题。然而，调用顶层框架的`validate`方法以确保所有形状正确重绘是一个好的做法。以前用于混合组件的解决方法也可能需要被移除。
- en: There's more...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The following are some specific areas to consider, when using mixed components
    with Java 7:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Java 7时，有一些特定的地方需要考虑，当使用混合组件时。
- en: Advanced swing events may not work correctly, particularly those events maintained
    by a `javax.swing.InputMap`.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级Swing事件可能无法正常工作，特别是由`javax.swing.InputMap`维护的事件。
- en: Partially transparent lightweight components that are intended to allow heavyweight
    components to be seen through them are not supported. The heavyweight items will
    not be displayed beneath translucent pixels.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持部分透明的轻量级组件，这些组件旨在允许重量级组件透过它们看到。重量级项目将不会显示在半透明像素下面。
- en: Heavyweight components must be created as part of the frame's or applet's process.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重量级组件必须作为框架或小程序的一部分创建。
- en: If the mixing of heavyweight and lightweight components has already been handled
    in your application and the Java 7 additions have caused problems, you can use
    the private `sun.awt.disableMixing` system property to turn off mixing support.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在您的应用程序中已经处理了重量级和轻量级组件的混合，并且Java 7的新增功能引起了问题，您可以使用私有的`sun.awt.disableMixing`系统属性来关闭混合支持。
- en: Managing window types
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理窗口类型
- en: The `JFrame` class supports a `setType` method, which configures the general
    appearance of a window to one of the three types. This can simplify the setting
    of a window's appearance. In this recipe we will examine these types and their
    appearance on Windows and Linux platforms.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`JFrame`类支持`setType`方法，该方法将窗口的一般外观配置为三种类型之一。这可以简化窗口外观的设置。在本教程中，我们将研究这些类型及其在Windows和Linux平台上的外观。'
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To set the window type, use the `setType` method with one of the three window
    types, as found in the `java.awt.Window` class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置窗口类型，使用`setType`方法，其中包括`java.awt.Window`类中的三种窗口类型之一：
- en: '`Type.NORMAL:` This represents a normal window and is the default value for
    windows'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Type.NORMAL:` 这代表一个正常的窗口，是窗口的默认值'
- en: '`Type.POPUP:` This is a temporary window intended to be used for small areas,
    such as tool tips'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Type.POPUP:` 这是一个临时窗口，用于小区域，如工具提示'
- en: '`Type.UTILITY:` This is also a small window for objects, such as a palette'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Type.UTILITY:` 这也是一个用于对象的小窗口，例如调色板'
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new window application as specified in the introduction to this chapter.
    Add the following statement before the **Exit** button is created:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照本章介绍中的说明创建一个新的窗口应用程序。在**退出**按钮创建之前添加以下语句：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Execute the application. On a Windows system, the window should appear as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。在Windows系统上，窗口应如下所示：
- en: '![How to do it...](img/5627_07_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5627_07_05.jpg)'
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The use of the method is simple enough. The `Type` enumeration is found in
    the `java. awt` package. On Windows, the windows appear as shown in the following
    screenshots. The normal and popup styles have the same appearance. The utility
    type is missing the minimize and maximize buttons:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的使用相当简单。`Type`枚举可以在`java.awt`包中找到。在Windows上，窗口显示如下截图所示。正常和弹出样式具有相同的外观。实用程序类型缺少最小化和最大化按钮：
- en: The following screenshot shows an example of the window type `Type.NORMAL:`
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`Type.NORMAL`窗口类型的示例：
- en: '![How it works...](img/5627_07_06.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5627_07_06.jpg)'
- en: The following screenshot shows an example of the window type `Type.POPUP:`
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`Type.POPUP`窗口类型的示例：
- en: '![How it works...](img/5627_07_07.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5627_07_07.jpg)'
- en: The following screenshot shows an example of the window type `Type.UTILITY:`
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`Type.UTILITY`窗口类型的示例：
- en: '![How it works...](img/5627_07_08.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5627_07_08.jpg)'
- en: 'On Ubuntu, the windows appear as shown in the following screenshots. The normal
    and utility have the same appearance, while the popup type is missing its buttons:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu上，窗口显示如下截图所示。正常和实用程序具有相同的外观，而弹出类型缺少其按钮：
- en: The following screenshot shows an example of the window type `Type.NORMAL:`
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`Type.NORMAL`窗口类型的示例：
- en: '![How it works...](img/5627_07_09.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5627_07_09.jpg)'
- en: The following screenshot shows an example of the window type `Type.POPUP:`
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`Type.POPUP`窗口类型的示例：
- en: '![How it works...](img/5627_07_10.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5627_07_10.jpg)'
- en: The following screenshot shows an example of the window type `Type.UTILITY:`
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`Type.UTILITY`窗口类型的示例：
- en: '![How it works...](img/5627_07_11.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5627_07_11.jpg)'
- en: Managing the opacity of a window
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理窗口的不透明度
- en: The opacity of a window refers to how transparent the window is. When a window
    is completely opaque, then nothing behind the window on the screen can be seen.
    A partially opaque window allows the background to bleed through. In this recipe
    we will learn how to control the opacity of a window.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的不透明度指的是窗口的透明程度。当窗口完全不透明时，屏幕上窗口后面的东西是看不见的。部分不透明的窗口允许背景透过。在本教程中，我们将学习如何控制窗口的不透明度。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To control the opacity of a window, use the `JFrame` class' `setOpacity` method
    with a float value representing how opaque the window should be.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制窗口的不透明度，使用`JFrame`类的`setOpacity`方法，使用表示窗口应该有多不透明的浮点值。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new standard GUI application as described in the chapter''s introduction.
    Replace the `invokeLater` method invocation with the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照本章介绍中的说明创建一个新的标准GUI应用程序。将`invokeLater`方法调用替换为以下代码：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Execute the application. The window should appear as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。窗口应如下所示：
- en: '![How to do it...](img/5627_07_12.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5627_07_12.jpg)'
- en: Notice how the window behind this application can be seen. In this case, the
    background is the code for the application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个应用程序后面的窗口是可以看到的。在这种情况下，背景是应用程序的代码。
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `setOpacity` used `0.75f` to set the opacity of the window. This results
    in it being 75 percent transparent, as can be seen by the code bleed through.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`setOpacity`使用`0.75f`来设置窗口的不透明度。这导致它变得75％透明，可以通过代码看到。'
- en: 'The range of values for opacity is 0.0f through 1.0f. A value of 1.0f represents
    a completely opaque window, and a value of 0.0f represents a completely transparent
    window. If the opacity is set to 0.0f, the mouse may or may not be enabled. This
    is determined by the underlying system. To set a value less than 1.0f:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不透明度的值范围是0.0f到1.0f。值为1.0f表示完全不透明的窗口，值为0.0f表示完全透明的窗口。如果不透明度设置为0.0f，则可能启用或禁用鼠标。这由底层系统决定。要设置小于1.0f的值：
- en: Translucency must be supported
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须支持透明度
- en: The window must be undecorated
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口必须是无装饰的
- en: The window cannot be in full screen mode
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口不能处于全屏模式
- en: To determine whether translucency is supported or not is covered in the next
    section. The `getOpacity` method can be used to determine what the current level
    of opacity is.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍如何确定是否支持透明度。`getOpacity`方法可用于确定当前不透明度级别。
- en: There's more...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To determine if the platform supports opacity, we need to use an instance of
    the `java.awt.GraphicsDevice` class. The `java.awt.GraphicsEnvironment` class
    contains a list of `GraphicsDevice` objects for the current platform. A `GraphicsDevice`
    normally refers to the screens available, but can include printers or image buffers.
    Each `GraphicsDevice` may also contain a set of `GraphicsConfiguration` objects
    that specify the configurations possible for a device, such as its resolution
    and what color model it supports.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定平台是否支持不透明度，我们需要使用`java.awt.GraphicsDevice`类的一个实例。`java.awt.GraphicsEnvironment`类包含当前平台的`GraphicsDevice`对象列表。`GraphicsDevice`通常指的是可用的屏幕，但也可以包括打印机或图像缓冲区。每个`GraphicsDevice`还可以包含一组`GraphicsConfiguration`对象，用于指定设备可能的配置，例如分辨率和支持的颜色模型。
- en: 'In the following code sequence, we get an instance of the `GraphicsEnvironment`
    object and then use its `getDefaultScreenDevice` method to get a `GraphicsDevice`
    object. The `isWindowTranslucencySupported` method is used against the `GraphicsDevice`
    object to determine if transparency is supported:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码序列中，我们获取`GraphicsEnvironment`对象的一个实例，然后使用它的`getDefaultScreenDevice`方法获取一个`GraphicsDevice`对象。使用`isWindowTranslucencySupported`方法针对`GraphicsDevice`对象来确定是否支持透明度：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `GraphicsDevice.WindowTranslucency` enumeration represents the types of
    transparency that may be supported by the platform. Its values are summarized
    in the following table. The alpha value refers to the level of transparency:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`GraphicsDevice.WindowTranslucency`枚举表示平台可能支持的透明度类型。其值总结在以下表中。alpha值指的是透明度级别：'
- en: '| Value | Meaning |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 意义 |'
- en: '| --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PERPIXEL_TRANSLUCENT` | Represents the system support for some of the pixels
    to be set with potentially different alpha values |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `PERPIXEL_TRANSLUCENT` | 表示系统支持一些像素设置为可能不同的alpha值 |'
- en: '| `PERPIXEL_TRANSPARENT` | Represents the system support for all of the pixels
    to be set to either 0.0f or 1.0f |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `PERPIXEL_TRANSPARENT` | 表示系统支持所有像素设置为0.0f或1.0f |'
- en: '| `TRANSLUCENT` | Represents the system support for all of the pixels to be
    set with an alpha value |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `TRANSLUCENT` | 表示系统支持所有像素设置为alpha值 |'
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using the new JLayer Decorator for a password field* recipe addresses how
    to draw over the top of a `JComponent`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用新的JLayer装饰器为密码字段*配方解决了如何在`JComponent`上绘制。'
- en: Creating a varying gradient translucent window
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个变化的渐变半透明窗口
- en: There are instances when an application window can be aesthetically enhanced
    by the addition of special graphics features. Java 7 supports the use of gradient
    translucent windows, and the translucency can be both visually interesting as
    well as functional.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，通过添加特殊的图形特性，应用程序窗口可以在美学上得到增强。Java 7支持使用渐变半透明窗口，透明度既可以在视觉上有趣，也可以在功能上有用。
- en: This recipe will demonstrate using both the transparency feature as well as
    a color gradient on a window.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将演示如何在窗口上同时使用透明度特性和颜色渐变。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to create a translucent, gradient color window, you need to:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个半透明的渐变颜色窗口，您需要：
- en: Perform a check to ensure that the system environment supports per-pixel translucency.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行检查以确保系统环境支持每像素半透明。
- en: Set the background color, such that the window initially is completely transparent.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置背景颜色，使窗口最初完全透明。
- en: Create a `java.awt.GradientPaint` object to specify the color and position of
    the gradient.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`java.awt.GradientPaint`对象来指定渐变的颜色和位置。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new standard GUI application as described in the chapter''s introduction.
    Add the following code to the `ApplicationDriver` class, before the start of the
    thread:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照本章介绍中的描述创建一个新的标准GUI应用程序。在线程开始之前，将以下代码添加到`ApplicationDriver`类中：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, replace the body of the `ApplicationWindow` constructor with the following
    code sequence:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，用以下代码序列替换`ApplicationWindow`构造函数的主体：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Execute the application. Your window should resemble the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您的窗口应该类似于以下内容：
- en: '![How to do it...](img/5627_07_13.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5627_07_13.jpg)'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we added code to the `ApplicationDriver` class to test whether per-pixel
    translucency was supported by the system. In our example, if it were not supported,
    the application would exit. This is discussed in more detail in the *There's more..*.
    section of the *Managing the opacity of a window* recipe.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`ApplicationDriver`类中添加了代码，以测试系统是否支持每像素半透明。在我们的示例中，如果不支持，应用程序将退出。这在*还有更多...*部分的*管理窗口的不透明度*配方中有更详细的讨论。
- en: Gradients should not be used on decorated windows. We called the `setDefaultLookAndFeelDecorated`
    method to ensure that the default look and feel is used. When executed on Windows
    7, this results in an undecorated window.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不应在装饰窗口上使用渐变。我们调用`setDefaultLookAndFeelDecorated`方法来确保使用默认外观。在Windows 7上执行时，这会导致一个无装饰的窗口。
- en: In the `ApplicationDriver` class, we first set the background color of the window.
    We used `(0, 0, 0, 0)` to specify the saturation levels of each color, red, green,
    and blue, and the alpha value, as zero. Color values can be any integer between
    0 and 255, but we want to start our window without any color. The alpha value
    of zero means our window will be completely transparent.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ApplicationDriver`类中，我们首先设置了窗口的背景颜色。我们使用`(0, 0, 0, 0)`来指定每种颜色的饱和度级别，红色、绿色和蓝色的alpha值都为零。颜色值可以是0到255之间的任何整数，但我们希望我们的窗口起始时没有颜色。alpha值为零意味着我们的窗口将完全透明。
- en: Next, we created a new `JPanel`. Within the `JPanel`, we overrode the `paintComponent`
    method and created a new `GradientPaint` object. There are four constructors for
    the `GradientPaint` class. We chose to use the one requiring floating numbers
    for the X and Y coordinates of the points referenced in the gradient, and the
    `Color` objects to specify the color of the gradient. You also have the option
    of passing `Point2D` objects rather than floating point numbers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个新的`JPanel`。在`JPanel`中，我们重写了`paintComponent`方法，并创建了一个新的`GradientPaint`对象。`GradientPaint`类有四个构造函数。我们选择使用需要浮点数的X和Y坐标以及`Color`对象来指定渐变颜色的构造函数。您还可以选择传递`Point2D`对象而不是浮点数。
- en: The first points specified, either by floating point number or `Point2D` objects,
    represent the start of the gradient. The second two, in our example, determined
    by the `getWidth` and `getHeight` methods, determine the ending points of the
    gradient. The result in our example was a gradient that started out light in the
    upper-left-hand corner, and became progressively darker as it moved down and to
    the right.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先指定的点，可以是浮点数，也可以是`Point2D`对象，表示渐变的起点。在我们的示例中，第二个点由`getWidth`和`getHeight`方法确定，确定了渐变的终点。在我们的示例中，结果是一个从左上角开始浅色，随着向下和向右移动逐渐变暗的渐变。
- en: Finally, we cast the gradient as a `Graphics2D` object and called the `setPaint`
    and `fillRect` method to paint our gradient across the window.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将渐变强制转换为`Graphics2D`对象，并调用`setPaint`和`fillRect`方法在整个窗口上绘制我们的渐变。
- en: See also
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The use of the `GraphicsDevice` object to determine the level of transparency
    support is discussed in more detail in the *There's more..*. section of the *Managing
    the opacity of a window* recipe.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GraphicsDevice`对象来确定透明度支持级别的讨论在*还有更多..*部分的*管理窗口的不透明度*配方中有更详细的介绍。
- en: Managing the shape of a window
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理窗口的形状
- en: There are times in application development when it can be fun and useful to
    create specially-shaped windows. This feature is now available in Java as of version
    7\. In this recipe we will develop a stop sign shape window to ensure that the
    user wants to continue some operation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发中，有时创建特殊形状的窗口可能很有趣和有用。从Java 7版本开始，这个功能现在已经可用。在这个配方中，我们将开发一个停止标志形状的窗口，以确保用户想要继续某些操作。
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To create a specially-shaped window, you must:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个特殊形状的窗口，您必须：
- en: Verify that per-pixel translucency is supported on the given system.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证给定系统是否支持逐像素透明度。
- en: Create a component listener to catch `componentResized` events.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个组件监听器来捕获`componentResized`事件。
- en: Create an instance of a shape and pass it to the `setShape` method.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个形状的实例并将其传递给`setShape`方法。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new standard GUI application as described in the chapter''s introduction.
    In the `main` method, prior to starting the thread, test to ensure that shaped
    windows are supported on the system by adding the following code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照本章介绍中描述的方式创建一个新的标准GUI应用程序。在`main`方法中，在启动线程之前，通过添加以下代码来测试系统是否支持有形窗口：
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a new class called `StopPanel` that is derived from `JPanel` and add
    the following constructor to it:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`StopPanel`的新类，它是从`JPanel`派生的，并向其添加以下构造函数：
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You also need to implement a `paintComponent` method for the `StopPanel` class.
    It is responsible for displaying text to our window. The following is one way
    to implement this method:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还需要为`StopPanel`类实现一个`paintComponent`方法。它负责在我们的窗口中显示文本。以下是实现此方法的一种方式：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Within the `ApplicationWindow` class, create a new instance of a `StopPanel`
    before the **Exit** button is created. Next, create a new instance of a `Shape`.
    In our example, we created a `Polygon` object by using the `getPolygon` method
    as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ApplicationWindow`类中，在创建**Exit**按钮之前，创建一个`StopPanel`的新实例。接下来，创建一个`Shape`的新实例。在我们的示例中，我们使用`getPolygon`方法创建了一个`Polygon`对象，如下所示：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then add a `componentListener` in front of the code to create the **Exit**
    button to catch the `componentResized` event. Within the listener, invoke the
    `setShape` method against the `Shape` object. We will also set the foreground
    and background colors at this point:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在创建**Exit**按钮的代码前添加一个`componentListener`来捕获`componentResized`事件。在监听器中，对`Shape`对象调用`setShape`方法。我们还将在这一点上设置前景色和背景色：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Add a call to the `setUndecorated` method and set the property to `true:`
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个调用`setUndecorated`方法并将属性设置为`true:`
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, add the `getPolygon` method to the class. This method creates an octagon
    using the two arrays of integers in conjunction with the `addPoint` method of
    the `Polygon` class:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`getPolygon`方法添加到类中。该方法使用两个整数数组和`Polygon`类的`addPoint`方法创建一个八边形：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When the application is executed, you should see an octagonal window formatted
    like the following one:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序执行时，您应该看到一个八边形窗口，格式如下：
- en: '![How to do it...](img/5627_07_14.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5627_07_14.jpg)'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our initial test to verify per-pixel translucency allowed us to tailor the application
    to the needs of the system it is running on. In our example, if the property was
    not supported we simply exited the application, though in a real-world environment
    you would probably want to open a less sophisticated window. Detecting the operating
    system support is discussed in more detail in the *There's more..*. section of
    the *Managing the opacity of a window* recipe.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的测试验证了逐像素的透明度，使我们能够根据系统的需求定制应用程序。在我们的例子中，如果该属性不受支持，我们只是退出应用程序，尽管在现实世界的环境中，您可能希望打开一个不太复杂的窗口。在*更多内容*部分的*管理窗口的不透明度*配方中更详细地讨论了检测操作系统支持的内容。
- en: The `StopPanel` class implemented the `JPanel` interface and allowed us to add
    the custom text and buttons we used in our window. Because we were using a special
    shape for our window, we chose to call the `setLayout` method with a `null` argument,
    which in turn allowed us to use the `setBounds` methods to explicitly place our
    buttons where we wanted them on the window. It is important to note that although
    the window is displayed as an octagon, or whatever other shape you choose, in
    actuality the window is still a rectangle, as specified by the `setSize` method.
    Therefore, buttons and other objects may be placed on the window, but not visible
    if they are outside the bounds set by your shape.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`StopPanel`类实现了`JPanel`接口，并允许我们在窗口中添加自定义文本和按钮。因为我们在窗口中使用了特殊的形状，所以我们选择使用`null`参数调用`setLayout`方法，这样就可以使用`setBounds`方法来明确地放置我们想要的按钮在窗口上。重要的是要注意，虽然窗口显示为八边形，或者您选择的其他形状，但实际上窗口仍然是一个矩形，由`setSize`方法指定。因此，按钮和其他对象可以放置在窗口上，但如果它们超出了您的形状设置的边界，它们就不可见了。'
- en: The `paintComponent` method was used to customize the text on the window. Within
    this method, we set the size, style, and location of the text, and called the
    `drawString` method to actually paint it to the screen.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`paintComponent`方法用于自定义窗口上的文本。在这个方法中，我们设置了文本的大小、样式和位置，并调用`drawString`方法将其实际绘制到屏幕上。'
- en: To actually create an octagonal window, we created our `getPolygon` method and
    manually drew the polygon. However, if you wanted to use a window with a shape
    already defined by a class implementing the `Shape` interface, you would not need
    to create a separate method. You simply pass the `Shape` object to the `setShape`
    method. If the `setShape` method's argument is `null`, the window will resize
    to the default for the given system, typically a rectangle.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际创建一个八边形窗口，我们创建了我们的`getPolygon`方法并手动绘制了多边形。然而，如果您想要使用一个已经由实现`Shape`接口的类定义形状的窗口，您就不需要创建一个单独的方法。您只需将`Shape`对象传递给`setShape`方法。如果`setShape`方法的参数是`null`，窗口将调整为给定系统的默认大小，通常是一个矩形。
- en: It is important to execute the `setShape` method within a `componentResized`
    event. This ensures that anytime the window is redrawn, the `setShape` method
    will be called and the shape will be maintained. It is also important to call
    the `setUndecorated` method because, at the present time, decorations will be
    lost with specially-shaped windows. Also, the window may not be in full-screen
    mode.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`componentResized`事件中执行`setShape`方法非常重要。这确保了每次窗口被重绘时，`setShape`方法都会被调用并且形状会被保持。调用`setUndecorated`方法也很重要，因为目前，特殊形状的窗口会丢失装饰。此外，窗口可能不是全屏模式。
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The use of the `GraphicsDevice` object to determine the level of transparency
    support is discussed in more detail in the *There's more..*. section of the *Managing
    the opacity of a window* recipe.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GraphicsDevice`对象来确定透明度支持的级别在*更多内容*部分的*管理窗口的不透明度*配方中有更详细的讨论。
- en: Using the new border types in Java 7
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java 7中使用新的边框类型
- en: Borders are used for the outline of swing components. In Java 7, several new
    border options are available. In this recipe we will develop a simple application
    to demonstrate how to create borders and how these borders appear.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 边框用于swing组件的轮廓。在Java 7中，有几种新的边框选项可用。在这个配方中，我们将开发一个简单的应用程序来演示如何创建边框以及这些边框的外观。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To create and use a border:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和使用边框：
- en: Create a new border using a `javax.swing.BorderFactory` method.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`javax.swing.BorderFactory`方法创建一个新的边框。
- en: Use the border object as an argument of the `setBorder` method applied against
    a `JComponent` object.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将边框对象作为`setBorder`方法的参数应用于`JComponent`对象。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new standard GUI application as described in the chapter''s introduction.
    Modify the `ApplicationWindow` class to replace the following lines:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照本章介绍中的描述创建一个新的标准GUI应用程序。修改`ApplicationWindow`类以替换以下行：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the following code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Execute the application. The window should appear as follows:![How to do it...](img/5627_07_15.jpg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。窗口应该如下所示：![如何做...](img/5627_07_15.jpg)
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `setBorder` method changed the border of the `JPanel` to a raised soft-beveled
    border. The `BorderFactory` method possesses a number of static methods to create
    borders. The following table summarizes the new borders available in Java 7:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`setBorder`方法将`JPanel`的边框更改为凸起的软斜角边框。`BorderFactory`方法具有许多静态方法来创建边框。下表总结了Java
    7中可用的新边框：'
- en: '| Method | Visual effect |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 视觉效果 |'
- en: '| --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| The default border | ![How it works...](img/5627_07_16.jpg) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 默认边框 | ![它是如何工作的...](img/5627_07_16.jpg) |'
- en: '| `createRaisedSoftBevelBorder()` | ![How it works...](img/5627_07_17.jpg)
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `createRaisedSoftBevelBorder()` | ![它是如何工作的...](img/5627_07_17.jpg) |'
- en: '| `createLineBorder(Color.BLACK, 1, true)`The first argument is the color of
    the border. The second is its thickness, while the third argument specifies whether
    the corners should be rounded or not. | ![How it works...](img/5627_07_18.jpg)
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `createLineBorder(Color.BLACK, 1, true)`第一个参数是边框的颜色。第二个是它的厚度，而第三个参数指定边角是否应该是圆角的。
    | ![它是如何工作的...](img/5627_07_18.jpg) |'
- en: '| `createLoweredSoftBevelBorder()` | ![How it works...](img/5627_07_19.jpg)
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `createLoweredSoftBevelBorder()` | ![它是如何工作的...](img/5627_07_19.jpg) |'
- en: '| `createSoftBevelBorder(BevelBorder.LOWERED)`This has the same effect as `createLoweredSoftBevelBorder()`
    | ![How it works...](img/5627_07_20.jpg) |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `createSoftBevelBorder(BevelBorder.LOWERED)`这与`createLoweredSoftBevelBorder()`具有相同的效果。|
    ![工作原理...](img/5627_07_20.jpg) |'
- en: '| `createSoftBevelBorder(BevelBorder.RAISED)`This has the same effect as `createRaisedSoftBevelBorder()`
    | ![How it works...](img/5627_07_21.jpg) |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `createSoftBevelBorder(BevelBorder.RAISED)`这与`createRaisedSoftBevelBorder()`具有相同的效果。|
    ![工作原理...](img/5627_07_21.jpg) |'
- en: '| `createSoftBevelBorder(BevelBorder.LOWERED, Color.lightGray, Color.yellow)`The
    first argument is the type of border: `RAISED` or `LOWERED.` The second argument
    is the color of the outer highlighted areaThe third argument is the color of the
    inner edge | ![How it works...](img/5627_07_22.jpg) |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `createSoftBevelBorder(BevelBorder.LOWERED, Color.lightGray, Color.yellow)`第一个参数是边框的类型：`RAISED`或`LOWERED`。第二个参数是外部突出区域的颜色。第三个参数是内边缘的颜色。|
    ![工作原理...](img/5627_07_22.jpg) |'
- en: '| `createSoftBevelBorder(BevelBorder.RAISED,Color.lightGray, Color.yellow)`The
    same arguments as `createSoftBevelBorder` | ![How it works...](img/5627_07_23.jpg)
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `createSoftBevelBorder(BevelBorder.RAISED,Color.lightGray, Color.yellow)`与`createSoftBevelBorder`相同的参数。|
    ![工作原理...](img/5627_07_23.jpg) |'
- en: '| `createSoftBevelBorder(BevelBorder.LOWERED, Color.lightGray, Color.lightGray,
    Color.white, Color.orange)`The arguments are used for the inner and outer edges
    of the highlighted and shadowed areas of the border | ![How it works...](img/5627_07_24.jpg)
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `createSoftBevelBorder(BevelBorder.LOWERED, Color.lightGray, Color.lightGray,
    Color.white, Color.orange)`这些参数用于边框的高亮和阴影区域的内部和外部边缘。| ![工作原理...](img/5627_07_24.jpg)
    |'
- en: '| `createStrokeBorder(new BasicStroke(1.0f))`A second overloaded method takes
    a `Paint` object as a second argument, and is used to generate a color | ![How
    it works...](img/5627_07_25.jpg) |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `createStrokeBorder(new BasicStroke(1.0f))`第二个重载的方法将`Paint`对象作为第二个参数，并用于生成颜色。|
    ![工作原理...](img/5627_07_25.jpg) |'
- en: '| `createDashedBorder(Color.red)` | ![How it works...](img/5627_07_26.jpg)
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `createDashedBorder(Color.red)` | ![工作原理...](img/5627_07_26.jpg) |'
- en: '| `createDashedBorder(Color.red, 4.0f, 1.0f)`The second argument is the relative
    length of a dash line and the third parameter is the relative length of a space.
    | ![How it works...](img/5627_07_27.jpg) |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `createDashedBorder(Color.red, 4.0f, 1.0f)`第二个参数是虚线的相对长度，第三个参数是空格的相对长度。|
    ![工作原理...](img/5627_07_27.jpg) |'
- en: '| `createDashedBorder(Color.red, 2.0f, 10.0f, 1.0f, true)`The second parameter
    specifies the thickness of the line. The third and fourth parameters specify the
    length and spacing respectively, while the last Boolean parameter determines whether
    the ends are rounded or not. | ![How it works...](img/5627_07_28.jpg) |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `createDashedBorder(Color.red, 2.0f, 10.0f, 1.0f, true)`第二个参数指定线条的厚度。第三和第四个参数分别指定长度和间距，而最后的布尔参数确定端点是否是圆形的。|
    ![工作原理...](img/5627_07_28.jpg) |'
- en: The border can be changed for any `JComponent` class. However, the appearance
    is not always acceptable. As we did in this example, it is sometimes better to
    change the border on an enclosing `JPanel` object.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 边框可以更改为任何`JComponent`类。然而，外观并不总是令人满意。就像我们在这个例子中所做的那样，有时最好在一个封闭的`JPanel`对象上更改边框。
- en: Handling multiple file selection in the FileDialog class
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在FileDialog类中处理多个文件选择
- en: The ability to select two or more files or directories in a file dialog box
    is achieved using the *Ctrl* and/or *Shift* keys in conjunction with the mouse.
    In Java 7, the file dialog box enables or disables this capability using the `java.awt.FileDialog`
    class' `setMultipleMode` method. This simple enhancement is illustrated in this
    recipe.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Ctrl*和/或*Shift*键与鼠标结合来在文件对话框中选择两个或多个文件或目录。在Java 7中，文件对话框使用`java.awt.FileDialog`类的`setMultipleMode`方法启用或禁用此功能。这个简单的增强功能在这个示例中有所体现。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To enable or disable the selection of multiple files in a print dialog box:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印对话框中启用或禁用多个文件的选择：
- en: Create a new `FileDialog` object.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`FileDialog`对象。
- en: Use its `setMultipleMode` method to determine its behavior.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用其`setMultipleMode`方法来确定其行为。
- en: Display the dialog box.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示对话框。
- en: Use the return value to determine which files were selected.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用返回值来确定选择了哪些文件。
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new standard GUI application as described in the chapter''s introduction.
    Modify the `ApplicationWindow` class to add a button to display a file dialog
    box as shown in the following code. In an anonymous inner class, we will display
    the dialog box:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照本章介绍中的描述创建一个新的标准GUI应用程序。修改`ApplicationWindow`类以添加一个按钮来显示文件对话框，如下面的代码所示。在匿名内部类中，我们将显示对话框：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Execute the application. The application window should appear as follows:![How
    to do it...](img/5627_07_29.jpg)
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。应用程序窗口应该如下所示：![如何操作...](img/5627_07_29.jpg)
- en: Select the **File Dialog** button and the following dialog box should appear.
    Navigate to a directory and select a few files. In the window that follows, two
    files of the `/home/music` directory have been selected:![How to do it...](img/5627_07_30.jpg)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件对话框**按钮，应该出现以下对话框。转到一个目录并选择一些文件。在接下来的窗口中，已选择了`/home/music`目录的两个文件：![如何操作...](img/5627_07_30.jpg)
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `fileDialog` class' `setMultipleMode` method was executed with an argument
    of `true`. This enabled multiple selections of files. An anonymous inner class
    was created to handle the selection of the file button event. In the `actionPerformed`
    method, the dialog box was made visible.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`fileDialog`类的`setMultipleMode`方法使用`true`参数执行。这使得可以选择多个文件。创建了一个匿名内部类来处理文件按钮事件的选择。在`actionPerformed`方法中，对话框被显示出来。'
- en: There's more...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To determine which files were selected, we can use the `fileDialog` class''
    `getFiles` method. Add the following code after the `fileDialog` class'' `setVisible`
    method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定选择了哪些文件，我们可以使用`fileDialog`类的`getFiles`方法。在`fileDialog`类的`setVisible`方法之后添加以下代码：
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The method returns an array of `File` objects. Using a for each loop, we can
    display the name of each file selected. Execute the application and select a few
    files. The output for the selected music files should appear as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回一个`File`对象数组。使用for each循环，我们可以显示每个选定文件的名称。执行应用程序并选择几个文件。所选音乐文件的输出应如下所示：
- en: '**File: Future Setting A.mp3**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：Future Setting A.mp3**'
- en: '**File: Space Machine A.mp3**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：Space Machine A.mp3**'
- en: Controlling the print dialog box type
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制打印对话框类型
- en: The standard print dialog that comes as part of the `java.awt.PrintJob` class
    allows the use of both a common and a native dialog box. This provides the ability
    to better tailor the application to a platform. The specification of the dialog
    box type is simple.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.awt.PrintJob`类的标准打印对话框允许使用通用和本机对话框。这提供了更好地适应平台的能力。对话框类型的规范很简单。'
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To specify the print dialog type and to use the print dialog, the following
    steps need to be followed:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定打印对话框类型并使用打印对话框，需要按照以下步骤进行：
- en: Create a `javax.print.attribute.PrintRequestAttributeSet` object.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`javax.print.attribute.PrintRequestAttributeSet`对象。
- en: Assign the dialog type desired to this object.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的对话框类型分配给此对象。
- en: Create a `PrinterJob` object.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`PrinterJob`对象。
- en: Use the `PrintRequestAttributeSet` object as an argument to the `PrinterJob`
    class' `printDialog` method.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PrintRequestAttributeSet`对象用作`PrinterJob`类的`printDialog`方法的参数。
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new standard GUI application as described in the chapter''s introduction.
    Modify the `ApplicationWindow` class to add a button to display a print dialog
    shown as follows. In an anonymous inner class, we will display a printer dialog
    box:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的标准GUI应用程序，如章节介绍中所述。修改`ApplicationWindow`类以添加一个按钮，显示如下所示的打印对话框。在一个匿名内部类中，我们将显示一个打印对话框：
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Execute the application and select the **Print** button. The dialog box that
    appears should use the common appearance type, as shown in the following screenshot:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序并选择**打印**按钮。出现的对话框应该使用通用外观类型，如下面的屏幕截图所示：
- en: '![How to do it...](img/5627_07_31.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5627_07_31.jpg)'
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A new **Print** button was created allowing the user to display a print dialog
    box. In the anonymous inner class used to handle the button''s action event, we
    created a `PrintRequestAttributeSet` object based on the `javax.print.attribute.HashPrintRequestAttributeSet`
    class. This permitted us to add the `DialogTypeSelection.NATIVE` attribute to
    the set. The `DialogTypeSelection` class is new to Java 7 and provides two fields:
    `COMMON` and `NATIVE`.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个新的**打印**按钮，允许用户显示打印对话框。在用于处理按钮动作事件的匿名内部类中，我们创建了一个基于`javax.print.attribute.HashPrintRequestAttributeSet`类的`PrintRequestAttributeSet`对象。这使我们能够向集合添加`DialogTypeSelection.NATIVE`属性。`DialogTypeSelection`类是Java
    7中的新类，提供了两个字段：`COMMON`和`NATIVE`。
- en: 'Next, we created a `PrinterJob` object and executed the `printDialog` method
    against this object. The print dialog box was then displayed. If we had used the
    `NATIVE` type instead, shown as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个`PrinterJob`对象，并对该对象执行了`printDialog`方法。然后打印对话框将显示出来。如果我们使用了`NATIVE`类型，将如下所示：
- en: '[PRE22]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then the print dialog would appear as follows on a Windows platform:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在Windows平台上，打印对话框将如下所示：
- en: '![How it works...](img/5627_07_32.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5627_07_32.jpg)'
- en: Using the new JLayer decorator for a password field
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的JLayer装饰器为密码字段
- en: Java 7 supports the decoration of GUI components, such as textboxes and panels.
    Decoration is the process of drawing on top of the component to give it a special
    appearance. For example, we may want to watermark an interface to show that it
    is a beta version, or possibly to provide an indication of an error with a graphical
    X in a text field that is not otherwise possible.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7支持装饰GUI组件，如文本框和面板。装饰是在组件顶部绘制的过程，使其具有特殊外观。例如，我们可能希望在界面上加水印，以显示它是测试版，或者可能为文本框中的错误提供图形X的指示，而这在其他情况下是不可能的。
- en: The `javax.swing.JLayer` class provided a way of tying components of a display,
    the drawing of extra graphics over the components, and the interception of the
    events together. The handling of the events and the display is delegated to a
    `javax.swing.plaf.LayerUI` derived object. When an event occurs, a method to handle
    the event will be executed. When the component is drawn, the `LayerUI` derived
    object's `paint` method will be executed displaying graphics as needed.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`javax.swing.JLayer`类提供了一种将显示的组件、在组件上绘制额外图形以及拦截事件的方法绑定在一起的方式。事件的处理和显示被委托给一个`javax.swing.plaf.LayerUI`派生对象。当事件发生时，将执行一个处理事件的方法。当组件被绘制时，将执行`LayerUI`派生对象的`paint`方法，根据需要显示图形。'
- en: In this recipe we will learn how Java supports this capability. In the first
    section, we will demonstrate how to display an error message for a password field.
    In the *There's more..*. section, we will show how to create a watermark for a
    window.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习Java如何支持此功能。在第一部分中，我们将演示如何为密码字段显示错误消息。在*还有更多..*部分，我们将展示如何为窗口创建水印。
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To decorate a component:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要装饰一个组件：
- en: Create the components to be decorated.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建要装饰的组件。
- en: Create a `LayerUI` derived class that implements the decoration graphics operations.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现装饰图形操作的`LayerUI`派生类。
- en: Create a `JLayer` object based on the component and the `LayerUI` derived class.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于组件和`LayerUI`派生类的`JLayer`对象。
- en: Add the `JLayer` object to the application.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`JLayer`对象添加到应用程序中。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new standard GUI application as described in the chapter''s introduction.
    Use the following `ApplicationWindow`. In its constructor, we will perform the
    essential steps using a `getPanel` method to return our password `JPanel` object.
    When the user enters a password, the window will be decorated with a message indicating
    that the password is too short, until at least six characters are entered:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照本章介绍中的描述创建一个新的标准GUI应用程序。使用以下`ApplicationWindow`。在它的构造函数中，我们将使用`getPanel`方法执行必要的步骤来返回我们的密码`JPanel`对象。当用户输入密码时，窗口将被装饰，显示密码太短的消息，直到至少输入六个字符：
- en: '[PRE23]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, create the `PasswordLayerUI` class as shown in the following code. The
    `paint` method will perform the actual decoration. The remaining methods are used
    to enable keyboard events and handle them as they occur:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按照以下代码创建`PasswordLayerUI`类。`paint`方法将执行实际的装饰。其余的方法用于启用键盘事件并在发生时处理它们：
- en: '[PRE24]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Execute the application. Enter a few characters in the textbox. Your window
    should appear similar to the following:![How to do it...](img/5627_07_33.jpg)
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。在文本框中输入一些字符。您的窗口应该看起来类似于以下内容：![操作步骤...](img/5627_07_33.jpg)
- en: 'Enter at least six characters. At that point the decoration should disappear
    as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入至少六个字符。此时装饰应该消失如下：
- en: '![How to do it...](img/5627_07_34.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](img/5627_07_34.jpg)'
- en: How it works...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the `ApplicationWindow`, we created an instance of the `PasswordLayerUI`
    class. We used this object along with the `JPanel` returned by the `getPanel`
    method to create `JLayer` object. The `JLayer` object was then added to the window.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ApplicationWindow`中，我们创建了`PasswordLayerUI`类的一个实例。我们使用这个对象以及`getPanel`方法返回的`JPanel`来创建`JLayer`对象。然后将`JLayer`对象添加到窗口中。
- en: Notice the use of generics for the `LayerUI` and `JLayer` objects. This was
    used to ensure that the elements are all compatible. We used `JPanel` because
    that was the composite component we were decorating.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`LayerUI`和`JLayer`对象中使用泛型。这是为了确保元素都是兼容的。我们使用`JPanel`，因为这是我们要装饰的组合组件。
- en: The `JLayer` class provided a way of tying the password box, the display of
    the error message, and the interception of the key events together. The handling
    of the key events and the display of the error message was delegated to the `PasswordLayerUI`
    object. When a key was pressed, the `processKeyEvent` method was executed. When
    the component was drawn, the `paint` method was executed displaying the error
    message by the password box.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`JLayer`类提供了一种将密码框、错误消息的显示和键盘事件拦截绑定在一起的方法。键盘事件的处理和错误消息的显示被委托给了`PasswordLayerUI`对象。按下键时，将执行`processKeyEvent`方法。当组件被绘制时，将执行`paint`方法，通过密码框显示错误消息。'
- en: In the `PasswordLayerUI` class, we declared a private `String` variable to hold
    our error message. It was declared at this level, because it was used in more
    than one method.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PasswordLayerUI`类中，我们声明了一个私有的`String`变量来保存我们的错误消息。它被声明在这个级别，因为它在多个方法中被使用。
- en: The `paint` method does the actual decorating. It was passed a `Graphics` object
    representing the area that we can draw to, and a `JComponent` component, which
    in this case was a `JPanel`. In the `paint` method, we used both the component's
    font and we also created a new `font` for the error message. The `height` and
    `width` of the component and the error string were calculated and used to position
    the error string that was displayed.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`paint`方法执行实际的装饰。它接收一个代表我们可以绘制的区域的`Graphics`对象，以及一个组件`JComponent`，在这种情况下是一个`JPanel`。在`paint`方法中，我们使用了组件的字体，还为错误消息创建了一个新的`font`。计算并使用了组件和错误字符串的高度和宽度来定位显示的错误字符串。'
- en: The `installUI` and `uninstallUI` methods were concerned with performing any
    initialization required to perform decoration. In this case, they were used to
    enable keyboard events to be intercepted and processed by the class. The `setLayerEventMask`
    method was used with the `AWTEvent.KEY_EVENT_MASK` argument to enable the processing
    of keyboard events. The `processKeyEvent` method performed the actual processing
    of keyboard events. In this method, the length of the password text field contents
    was used to determine which error message was to be displayed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`installUI`和`uninstallUI`方法用于执行装饰所需的任何初始化。在这种情况下，它们被用来使键盘事件能够被拦截并由该类处理。`setLayerEventMask`方法与`AWTEvent.KEY_EVENT_MASK`参数一起使用，以启用键盘事件的处理。`processKeyEvent`方法执行实际的键盘事件处理。在这个方法中，密码文本字段内容的长度被用来确定要显示哪个错误消息。'
- en: There's more...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This example could conceivably be performed using a label instead. However,
    this example was intended to provide a simple demonstration of how to use decorations.
    The creation of other decorations, such as a watermark is not as easily performed
    without the use of `JLayer` and `LayerUI` classes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以考虑使用标签来执行。然而，这个例子旨在提供如何使用装饰的简单演示。创建其他装饰，比如水印，如果没有使用`JLayer`和`LayerUI`类，就不容易执行。
- en: 'Add the following code before the `dispose` method. This sequence will add
    a watermark to the window indicating that this is a beta version of the interface.
    The `Castellar` font is used to provide a more stenciled look to the text. A `Composite`
    object is used to change the alpha value for the string. This effectively controls
    the transparency of the string displayed. The `getComposite` method is used to
    get the current composite for the window, and is then used to determine the rule
    being used. The rule along with an alpha value of `0.25f` is used to allow the
    watermark to fade into the background as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dispose`方法之前添加以下代码。这个序列将在窗口上添加一个水印，指示这是界面的测试版。使用`Castellar`字体提供更多的模板化文本外观。使用`Composite`对象来改变字符串的alpha值。这有效地控制了显示的字符串的透明度。`getComposite`方法用于获取窗口的当前复合体，然后用于确定正在使用的规则。规则以及`0.25f`的alpha值用于使水印淡入背景，如下所示：
- en: '[PRE25]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When executed, your application should appear similar to the following screenshot.
    Notice that the watermark is in all caps. This is the result of using the `Castellar`
    font, which is an all-capital letter font patterned after the letters used on
    a Roman column dedicated to Augustus.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '当执行时，您的应用程序应该看起来类似于以下屏幕截图。请注意，水印是全大写的。这是使用“Castellar”字体的结果，这是 一种全大写字母字体，模仿了奥古斯都纪念罗马柱上使用的字母。'
- en: '![There''s more...](img/5627_07_35.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/5627_07_35.jpg)'
