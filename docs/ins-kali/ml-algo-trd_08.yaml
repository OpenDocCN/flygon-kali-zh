- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: The ML4T Workflow – From Model to Strategy Backtesting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ML4T工作流程-从模型到策略回测
- en: Now, it's time to **integrate the various building blocks** of the **machine
    learning for trading** (**ML4T**) workflow that we have so far discussed separately.
    The goal of this chapter is to present an end-to-end perspective of the process
    of designing, simulating, and evaluating a trading strategy driven by an ML algorithm.
    To this end, we will demonstrate in more detail how to backtest an ML-driven strategy
    in a historical market context using the Python libraries backtrader and Zipline.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候**整合各种构建模块**了，这些构建模块是我们迄今为止分别讨论过的**交易机器学习**（ML4T）工作流程。本章的目标是从端到端的角度呈现设计、模拟和评估由ML算法驱动的交易策略的过程。为此，我们将更详细地演示如何使用Python库backtrader和Zipline在历史市场环境中回测ML驱动的策略。
- en: 'The **ultimate objective of the ML4T workflow** is to gather evidence from
    historical data. This helps us decide whether to deploy a candidate strategy in
    a live market and put financial resources at risk. This process builds on the
    skills you developed in the previous chapters because it relies on your ability
    to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**ML4T工作流程的最终目标**是从历史数据中收集证据。这有助于我们决定是否在实时市场中部署候选策略并冒险投入财务资源。这个过程建立在您在前几章中发展的技能基础上，因为它依赖于您的能力：'
- en: Work with a diverse set of data sources to engineer informative factors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多样的数据源来设计信息丰富的因子
- en: Design ML models that generate predictive signals to inform your trading strategy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计生成预测信号的ML模型，以指导您的交易策略
- en: Optimize the resulting portfolio from a risk-return perspective
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从风险回报的角度优化结果投资组合
- en: A realistic simulation of your strategy also needs to faithfully represent how
    security markets operate and how trades are executed. Therefore, the institutional
    details of exchanges, such as which order types are available and how prices are
    determined, also matter when you design a backtest or evaluate whether a backtesting
    engine includes the requisite features for accurate performance measurements.
    Finally, there are several methodological aspects that require attention to avoid
    biased results and false discoveries that will lead to poor investment decisions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 真实模拟您的策略还需要忠实地表现证券市场的运作方式以及交易的执行方式。因此，在设计回测或评估回测引擎是否包含准确的性能测量特性时，交易所的机构细节，例如可用的订单类型以及价格确定方式也很重要。最后，有几个方法论方面需要注意，以避免偏见结果和导致糟糕的投资决策的虚假发现。
- en: 'More specifically, after working through this chapter, you will be able to:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，通过本章的学习，您将能够：
- en: Plan and implement end-to-end strategy backtesting
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划和实施端到端策略回测
- en: Understand and avoid critical pitfalls when implementing backtests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解并避免在实施回测时的关键陷阱
- en: Discuss the advantages and disadvantages of vectorized versus event-driven backtesting
    engines
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论矢量化与事件驱动回测引擎的优缺点
- en: Identify and evaluate the key components of an event-driven backtester
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和评估事件驱动回测器的关键组件
- en: Design and execute the ML4T workflow using data sources at both minute and daily
    frequencies, with ML models trained separately or as part of the backtest
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分钟和日频率的数据源设计和执行ML4T工作流程，分别训练ML模型或作为回测的一部分
- en: Use Zipline and backtrader
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Zipline和backtrader
- en: You can find the code samples for this chapter and links to additional resources
    in the corresponding directory of the GitHub repository. The notebooks include
    color versions of the images.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub存储库的相应目录中找到本章的代码示例和其他资源的链接。笔记本包括图像的彩色版本。
- en: How to backtest an ML-driven strategy
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何回测ML驱动的策略
- en: 'In a nutshell, the ML4T workflow, illustrated in *Figure 8.1*, is about backtesting
    a trading strategy that leverages machine learning to generate trading signals,
    select and size positions, or optimize the execution of trades. It involves the
    following steps, with a specific investment universe and horizon in mind:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*图8.1*中所示的ML4T工作流程是关于回测一个利用机器学习生成交易信号、选择和确定头寸，或优化交易执行的交易策略。它涉及以下步骤，考虑特定的投资范围和时间跨度：
- en: Source and prepare market, fundamental, and alternative data
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取和准备市场、基本和替代数据
- en: Engineer predictive alpha factors and features
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计预测性的alpha因子和特征
- en: Design, tune, and evaluate ML models to generate trading signals
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计，调整和评估ML模型以生成交易信号
- en: Decide on trades based on these signals, for example, by applying rules
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据这些信号决定交易，例如通过应用规则
- en: Size individual positions in the portfolio context
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在投资组合背景下确定个别头寸的规模
- en: Simulate the resulting trades triggered using historical market data
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟使用历史市场数据触发的结果交易
- en: Evaluate how the resulting positions would have performed
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估结果头寸的表现
- en: '![](img/B15439_08_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15439_08_01.png)'
- en: 'Figure 8.1: The ML4T workflow'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：ML4T工作流程
- en: When we discussed the ML process in *Chapter 6*, *The Machine Learning Process*,
    we emphasized that the model's learning should generalize well to new applications.
    In other words, the predictions of an ML model trained on a given set of data
    should perform equally well when provided new input data. Similarly, the (relative)
    **backtest performance of a strategy should be indicative of future market performance**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*第6章*“机器学习过程”中讨论ML过程时，我们强调模型的学习应该对新应用有很好的泛化能力。换句话说，在给定一组数据进行训练的ML模型的预测在提供新的输入数据时应该表现同样良好。同样，策略的（相对）**回测表现应该预示着未来的市场表现**。
- en: Before we take a look at how backtesting engines run historical simulations,
    we need to review several methodological challenges. Failing to properly address
    them will render results unreliable and lead to poor decisions about the strategy's
    live implementation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看如何回测引擎运行历史模拟之前，我们需要审查几个方法论挑战。未能妥善解决这些挑战将使结果不可靠，并导致对策略实时实施的错误决定。
- en: Backtesting pitfalls and how to avoid them
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回测陷阱及如何避免
- en: Backtesting simulates an algorithmic strategy based on historical data, with
    the goal of producing performance results that generalize to new market conditions.
    In addition to the generic uncertainty around predictions in the context of ever-changing
    markets, several implementation aspects can bias the results and increase the
    risk of mistaking in-sample performance for patterns that will hold out-of-sample.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 回测模拟基于历史数据的算法策略，旨在产生适用于新市场条件的绩效结果。除了在不断变化的市场环境中对预测的一般不确定性外，几个实施方面可能会使结果产生偏差，并增加误将样本内绩效误认为将在样本外持续的风险。
- en: These aspects are under our control and include the selection and preparation
    of data, unrealistic assumptions about the trading environment, and the flawed
    application and interpretation of statistical tests. The risks of false backtest
    discoveries multiply with increasing computing power, bigger datasets, and more
    complex algorithms that facilitate the misidentification of apparent signals in
    a noisy sample.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方面在我们的控制范围内，包括数据的选择和准备、对交易环境的不切实际假设以及对统计测试的错误应用和解释。随着计算能力的增加、数据集的扩大以及更复杂的算法，使得在嘈杂的样本中误识别明显信号的风险增加，错误的回测发现也会增加。
- en: In this section, we will outline the most serious and common methodological
    mistakes. Please refer to the literature on multiple testing for further detail,
    in particular, a series of articles by Marcos Lopez de Prado collected in *Advances
    in Financial Machine Learning (2018)*. We will also introduce the deflated **Sharpe
    ratio** (**SR**), which illustrates how to adjust metrics that result from repeated
    trials when using the same set of financial data for your analysis.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将概述最严重和常见的方法论错误。请参考有关多重检验的文献以获取更多细节，特别是Marcos Lopez de Prado在《金融机器学习进展（2018）》中收集的一系列文章。我们还将介绍通货紧缩的夏普比率（SR），以说明如何调整使用相同一组金融数据进行分析时产生的重复试验的指标。
- en: Getting the data right
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取正确的数据
- en: Data issues that undermine the validity of a backtest include **look-ahead bias**,
    **survivorship bias**, **outlier control**, as well as the **selection of the
    sample period**. We will address each of these in turn.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏回测有效性的数据问题包括**前瞻偏差**、**生存偏差**、**异常值控制**以及**样本期的选择**。我们将依次解决这些问题。
- en: Look-ahead bias – use only point-in-time data
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前瞻偏差-仅使用时点数据
- en: At the heart of an algorithmic strategy are trading rules that trigger actions
    based on data. Look-ahead bias emerges when we develop or evaluate trading rules
    **using historical information before it was known or available**. The resulting
    performance measures will be misleading and not representative of the future when
    data availability differs during live strategy execution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 算法策略的核心是基于数据触发操作的交易规则。当我们使用**先前已知或可用的历史信息**开发或评估交易规则时，就会出现前瞻偏差。由此产生的绩效指标将是误导性的，不代表未来，当实时策略执行期间数据可用性不同时。
- en: A common cause of this bias is the failure to account for corrections or restatements
    of reported financials after their initial publication. Stock splits or reverse
    splits can also generate look-ahead bias. For example, when computing the earnings
    yield, **earnings-per-share** (**EPS**) data is usually reported on a quarterly
    basis, whereas market prices are available at a much higher frequency. Therefore,
    adjusted EPS and price data need to be synchronized, taking into account when
    the available data was, in fact, released to market participants.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种偏差的常见原因是未能考虑在初始发布后对报告的财务数据进行更正或重新说明。股票拆分或反向拆分也可能产生前瞻偏差。例如，当计算收益率时，**每股收益**（EPS）数据通常以季度为基础报告，而市场价格则以更高的频率可用。因此，需要同步调整的EPS和价格数据，考虑到可用数据实际上是何时发布给市场参与者的。
- en: The **solution** involves the careful validation of the timestamps of all data
    that enters a backtest. We need to guarantee that conclusions are based only on
    point-in-time data that does not inadvertently include information from the future.
    High-quality data providers ensure that these criteria are met. When point-in-time
    data is not available, we need to make (conservative) assumptions about the lag
    in reporting.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**涉及仔细验证进入回测的所有数据的时间戳。我们需要确保结论仅基于时点数据，不会无意中包含未来信息。高质量的数据提供商确保满足这些标准。当时点数据不可用时，我们需要对报告滞后进行（保守的）假设。'
- en: Survivorship bias – track your historical universe
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生存偏差-跟踪您的历史宇宙
- en: Survivorship bias arises when the backtest data contains only securities that
    are currently active while **omitting assets that have disappeared** over time,
    due to, for example, bankruptcy, delisting, or acquisition. Securities that are
    no longer part of the investment universe often did not perform well, and failing
    to include these cases positively skew the backtest result.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 生存偏差是指回测数据仅包含当前活跃的证券，**而忽略了随时间消失的资产**，例如破产、退市或收购。不再属于投资宇宙的证券通常表现不佳，而未能包括这些情况会使回测结果产生正向偏差。
- en: The **solution**, naturally, is to verify that datasets include all securities
    available over time, as opposed to only those that are still available when running
    the test. In a way, this is another way of ensuring the data is truly point-in-time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**自然是验证数据集是否包含随时间可用的所有证券，而不仅仅是在测试运行时仍然可用的证券。在某种程度上，这是确保数据真正是时点数据的另一种方式。'
- en: Outlier control – do not exclude realistic extremes
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常值控制-不要排除现实极端情况
- en: Data preparation typically includes some treatment of outliers such as winsorizing,
    or clipping, extreme values. The challenge is to **identify outliers that are
    truly not representative** of the period under analysis, as opposed to any extreme
    values that are an integral part of the market environment at that time. Many
    market models assume normally distributed data when extreme values are observed
    more frequently, as suggested by fat-tailed distributions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数据准备通常包括对异常值的处理，例如winsorizing或剪切极端值。挑战在于**识别那些真正不代表分析期的异常值**，而不是那些在那个时候是市场环境的一个组成部分的极端值。许多市场模型假设当频繁观察到极端值时，数据呈正态分布，如厚尾分布所示。
- en: The **solution** involves a careful analysis of outliers with respect to the
    probability of extreme values occurring and adjusting the strategy parameters
    to this reality.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**涉及对异常值进行仔细分析，以确定极端值发生的概率，并根据这一现实调整策略参数。'
- en: Sample period – try to represent relevant future scenarios
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样本期间 - 尝试代表相关的未来情景
- en: A backtest will not yield representative results that generalize to the future
    if the sample data does not **reflect the current (and likely future) environment**.
    A poorly chosen sample data might lack relevant market regime aspects, for example,
    in terms of volatility or volumes, fail to include enough data points, or contain
    too many or too few extreme historical events.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果样本数据不**反映当前（和可能的未来）环境**，回测将无法产生代表性的结果。选择不当的样本数据可能缺乏相关的市场制度方面，例如波动性或成交量，未能包含足够的数据点，或包含太多或太少的极端历史事件。
- en: The **solution** involves using sample periods that include important market
    phenomena or generating synthetic data that reflects the relevant market characteristics.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案涉及使用包括重要市场现象的样本期间或生成反映相关市场特征的合成数据。
- en: Getting the simulation right
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确进行模拟
- en: 'Practical issues related to the implementation of the historical simulation
    include:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实施历史模拟涉及的实际问题包括：
- en: Failure to **mark to market** to accurately reflect market prices and account
    for drawdowns
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未能**按市场价值**准确反映市场价格并考虑回撤
- en: '**Unrealistic assumptions** about the availability, cost, or market impact
    of trades'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对可用性、成本或交易市场影响的**不切实际假设**
- en: Incorrect **timing of signals and trade execution**
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的**信号时机和交易执行**
- en: Let's see how to identify and address each of these issues.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何识别和解决这些问题。
- en: Mark-to-market performance – track risks over time
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按市场价值表现 - 随时间跟踪风险
- en: A strategy needs to **meet investment objectives and constraints at all times**.
    If it performs well over the course of the backtest but leads to unacceptable
    losses or volatility over time, this will (obviously) not be practical. Portfolio
    managers need to track and report the value of their positions, called mark to
    market, on a regular basis and possibly in real time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 策略需要**始终满足投资目标和约束条件**。如果它在回测过程中表现良好，但随着时间的推移导致无法接受的损失或波动，这显然是不切实际的。投资组合经理需要定期追踪和报告其头寸的价值，称为按市场价值计算，并可能是实时的。
- en: The solution involves plotting performance over time or calculating (rolling)
    risk metrics, such as the **value at risk** (**VaR**) or the Sortino ratio.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案涉及随时间绘制绩效或计算（滚动）风险指标，如**风险价值**（VaR）或Sortino比率。
- en: Transaction costs – assume a realistic trading environment
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交易成本 - 假设一个真实的交易环境
- en: Markets do not permit the execution of all trades at all times or at the targeted
    price. A backtest that assumes **trades that may not actually be available** or
    would have occurred at less favorable terms will produce biased results.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 市场不允许在任何时候以任何价格执行所有交易。假设**实际上可能不可用的交易**或以不利的条件发生的交易的回测将产生偏见的结果。
- en: Practical shortcomings include a strategy that assumes short sales when there
    may be no counterparty, or one that underestimates the market impact of trades
    (slippage) that are large or deal in less liquid assets, or the costs that arise
    due to broker fees.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 实际缺陷包括一种假设在没有交易对手时进行空头交易的策略，或者低估了交易的市场影响（滑点），这些交易规模较大或交易较少流动性资产，或者由于经纪费而产生的成本。
- en: The **solution** includes a limitation to a liquid universe and/or realistic
    parameter assumptions for trading and slippage costs. This also safeguards against
    misleading conclusions from unstable factor signals that decay fast and produce
    a high portfolio turnover.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**包括对流动性范围的限制和/或对交易和滑点成本的现实参数假设。这也可以防止不稳定因子信号产生高投资组合周转率的误导性结论。'
- en: Timing of decisions – properly sequence signals and trades
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 决策的时机 - 正确地顺序信号和交易
- en: Similar to look-ahead bias, the simulation could make **unrealistic assumptions
    about when it receives and trades on signals**. For instance, signals may be computed
    from close prices when trades are only available at the next open, with possibly
    quite different prices. When we evaluate performance using the close price, the
    backtest results will not represent realistic future outcomes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于前瞻性偏差，模拟可能会对其何时接收和交易信号**做出不切实际的假设**。例如，当交易仅在下一个开盘时才可用时，可能会从收盘价格计算信号，而这时的价格可能会有很大的不同。当我们使用收盘价格评估绩效时，回测结果将无法代表现实的未来结果。
- en: The **solution** involves careful orchestration of the sequence of signal arrival,
    trade execution, and performance evaluation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**涉及对信号到达、交易执行和绩效评估的顺序进行仔细协调。'
- en: Getting the statistics right
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确进行统计
- en: The most prominent challenge when backtesting validity, including published
    results, is the discovery of spurious patterns due to multiple testing. Selecting
    a strategy based on the tests of different candidates on the same data will bias
    the choice. This is because a positive outcome is more likely caused by the stochastic
    nature of the performance measure itself. In other words, the strategy overfits
    the test sample, producing deceptively positive results that are unlikely to generalize
    to future data that's encountered during live trading.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 回测有效性的最突出挑战，包括已发表的结果，是由于多次测试而发现虚假模式。基于对相同数据的不同候选人的测试选择策略将偏向于选择。这是因为积极的结果更可能是由于绩效度量本身的随机性。换句话说，策略过度拟合了测试样本，产生了具有欺骗性的积极结果，不太可能推广到实际交易中遇到的未来数据。
- en: Hence, backtest performance is only informative if the number of trials is reported
    to allow for an assessment of the risk of selection bias. This is rarely the case
    in practical or academic research, inviting doubts about the validity of many
    published claims.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只有在报告试验次数以允许评估选择偏差风险的情况下，回测性能才具有信息价值。在实际或学术研究中很少出现这种情况，这引发了对许多已发表声明有效性的怀疑。
- en: Furthermore, the risk of backtest overfitting does not only arise from running
    numerous tests but also affects strategies designed based on prior knowledge of
    what works and doesn't. Since the risks include the knowledge of backtests run
    by others on the same data, backtest-overfitting is very hard to avoid in practice.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，回测过度拟合的风险不仅来自进行大量测试，而且还影响基于先前知识的工作和不工作的策略。由于风险包括他人在相同数据上运行的回测知识，回测过度拟合在实践中很难避免。
- en: Proposed **solutions** include prioritizing tests that can be justified using
    investment or economic theory, rather than arbitrary data-mining efforts. It also
    implies testing in a variety of contexts and scenarios, including possibly on
    synthetic data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的**解决方案**包括优先考虑可以用投资或经济理论来证明的测试，而不是任意的数据挖掘努力。它还意味着在各种情境和场景中进行测试，包括可能在合成数据上进行测试。
- en: The minimum backtest length and the deflated SR
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小回测长度和通货紧缩SR
- en: Marcos Lopez de Prado ([http://www.quantresearch.info/](http://www.quantresearch.info/))
    has published extensively on the risks of backtesting and how to detect or avoid
    it. This includes an online simulator of backtest-overfitting ([http://datagrid.lbl.gov/backtest/](http://datagrid.lbl.gov/backtest/),
    *Bailey, et al. 2015*).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Marcos Lopez de Prado（[http://www.quantresearch.info/](http://www.quantresearch.info/)）在回测风险以及如何检测或避免它方面发表了大量文章。这包括一个回测过度拟合的在线模拟器（[http://datagrid.lbl.gov/backtest/](http://datagrid.lbl.gov/backtest/)，*Bailey等，2015年*）。
- en: Another result includes an estimate of the minimum length of the backtest period
    that an investor should require to avoid selecting a strategy that achieves a
    certain SR for a given number of in-sample trials, but has an expected out-of-sample
    SR of zero. The result implies that, for example, 2 years of daily backtesting
    data does not support conclusions about more than seven strategies. 5 years of
    data expands this number to 45 strategy variations. See *Bailey, Borwein, and
    Prado (2016)* for implementation details.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个结果包括对投资者应要求的回测期最小长度的估计，以避免选择一种在样本内试验次数给定的情况下实现一定SR的策略，但在样本外预期SR为零的策略。该结果意味着，例如，2年的每日回测数据不支持对超过七种策略的结论。5年的数据将这一数字扩大到45种策略变体。有关实施细节，请参阅*Bailey，Borwein和Prado（2016年）*。
- en: '*Bailey and Prado (2014)* also derived a deflated SR to compute the probability
    that the SR is statistically significant while controlling for the inflationary
    effect of multiple testing, non-normal returns, and shorter sample lengths. (See
    the `multiple_testing` subdirectory for the Python implementation of `deflated_sharpe_ratio.py`
    and references for the derivation of the related formulas.)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bailey和Prado（2014年）*还推导出了一个通货紧缩SR，用于计算SR在控制多次测试、非正态收益和较短样本长度的通货膨胀效应的情况下是否具有统计显著性的概率。（有关`deflated_sharpe_ratio.py`的Python实现以及相关公式的推导，请参见`multiple_testing`子目录。）'
- en: Optimal stopping for backtests
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回测的最佳停止点
- en: In addition to limiting backtests to strategies that can be justified on theoretical
    grounds as opposed to mere data-mining exercises, an important question is when
    to stop running additional tests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将回测限制在可以在理论上证明的策略而不是仅仅是数据挖掘练习上，一个重要的问题是何时停止运行额外的测试。
- en: One way to answer this question relies on the solution to the **secretary problem**
    from the optimal stopping theory. This problem assumes we are selecting an applicant
    based on interview results and need to decide whether to hold an additional interview
    or choose the most recent candidate. In this context, the optimal rule is to always
    reject the first *n*/*e* candidates and then select the first candidate that surpasses
    all the previous options. Using this rule results in a 1/*e* probability of selecting
    the best candidate, irrespective of the size *n* of the candidate pool.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 回答这个问题的一种方法依赖于最优停止理论中的**秘书问题**的解决方案。这个问题假设我们根据面试结果选择申请人，并需要决定是否进行额外的面试或选择最近的候选人。在这种情况下，最佳规则是始终拒绝前*n*/*e*个候选人，然后选择超过所有先前选项的第一个候选人。使用这个规则会导致以1/*e*的概率选择最佳候选人，而不管候选人池的大小*n*如何。
- en: 'Translating this rule directly to the backtest context produces the following
    **recommendation**: test a random sample of 1/*e* (roughly 37 percent) of reasonable
    strategies and record their performance. Then, continue with the tests until a
    strategy outperforms those tested before. This rule applies to tests of several
    alternatives, with the goal of choosing a near-best as soon as possible while
    minimizing the risk of a false positive. See the resources listed on GitHub for
    additional information.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个规则直接转化为回测环境产生以下**建议**：测试一个随机样本的1/*e*（大约37%）合理策略，并记录它们的表现。然后，继续测试，直到一种策略胜过之前测试过的策略。这个规则适用于测试几种替代方案，目标是尽快选择一个接近最佳的策略，同时最小化虚假阳性的风险。有关更多信息，请参阅GitHub上列出的资源。
- en: How a backtesting engine works
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回测引擎的工作原理
- en: Put simply, a backtesting engine iterates over historical prices (and other
    data), passes the current values to your algorithm, receives orders in return,
    and keeps track of the resulting positions and their value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，回测引擎迭代历史价格（和其他数据），将当前值传递给您的算法，接收订单，并跟踪结果头寸及其价值。
- en: In practice, there are numerous requirements for creating a realistic and robust
    simulation of the ML4T workflow that was depicted in *Figure 8.1* at the beginning
    of this chapter. The difference between vectorized and event-driven approaches
    illustrates how the faithful reproduction of the actual trading environment adds
    significant complexity.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，要创建一个真实和强大的ML4T工作流程的模拟，需要满足许多要求，这些要求在本章开始时的*图8.1*中描述了矢量化和事件驱动方法之间的差异，说明了忠实地再现实际交易环境增加了重要的复杂性。
- en: Vectorized versus event-driven backtesting
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矢量化与事件驱动回测
- en: A vectorized backtest is the most basic way to evaluate a strategy. It simply
    multiplies a signal vector that represents the target position size with a vector
    of returns for the investment horizon to compute the period performance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量化回测是评估策略的最基本方法。它只是将代表目标头寸大小的信号向量与投资期间的回报向量相乘，以计算该时期的绩效。
- en: Let's illustrate the vectorized approach using the daily return predictions
    that we created using ridge regression in the previous chapter. Using a few simple
    technical factors, we predicted the returns for the next day for the 100 stocks
    with the highest recent dollar trading volume (see *Chapter 7*, *Linear Models
    – From Risk Factors to Return Forecasts*, for details).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用在上一章中使用岭回归创建的每日回报预测来说明矢量化方法。使用一些简单的技术因素，我们预测了最近美元交易量最高的100只股票的下一天的回报（有关详细信息，请参见*第7章*，*线性模型-从风险因素到回报预测*）。
- en: 'We''ll transform the predictions into signals for a very simple strategy: on
    any given trading day, we will go long on the 10 highest positive predictions
    and go short on the lowest 10 negative predictions. If there are fewer positive
    or negative predictions, we''ll hold fewer long or short positions. The notebook
    `vectorized_backtest` contains the following code example, and the script `data.py`
    creates the input data stored in `backtest.h5`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把预测转换为一个非常简单的策略的信号：在任何交易日，我们将在最高的10个正预测上做多，并在最低的10个负预测上做空。如果正预测或负预测较少，我们将持有较少的多头或空头头寸。笔记本`vectorized_backtest`包含以下代码示例，脚本`data.py`创建了存储在`backtest.h5`中的输入数据。
- en: 'First, we load the data for our strategy, as well as S&P 500 prices (which
    we convert into daily returns) to benchmark the performance:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载我们策略的数据，以及标准普尔500的价格（我们将其转换为每日回报）以进行绩效基准：
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The data combines daily return predictions and OHLCV market data for 253 distinct
    stocks over the 2014-17 period, with 100 equities for each day. Now, we can compute
    the daily forward returns and convert these and the predictions into wide format,
    with one ticker per column:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据结合了2014-17年期间253只不同股票的每日回报预测和OHLCV市场数据，每天100只股票。现在，我们可以计算每日的前向回报，并将这些回报和预测转换为宽格式，每列一个股票代码：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next step is to select positive and negative predictions, rank them in
    descending and ascending fashion, and create long and short signals using an integer
    mask that identifies the top 10 on each side with identifies the predictions outside
    the top 10 with a one, and a zero:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是选择正预测和负预测，按降序和升序排名，并使用整数掩码创建多头和空头信号，该掩码在每一侧上标识前10个预测，用1标识在前10个预测之外的预测，用0标识：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can then multiply the binary DataFrames with the forward returns (using
    their negative inverse for the shorts) to get the daily performance of each position,
    assuming equal-sized investments. The daily average of these returns corresponds
    to the performance of equal-weighted long and short portfolios, and the sum reflects
    the overall return of a market-neutral long-short strategy:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将二进制数据框与前向回报相乘（对于空头，使用它们的负逆数）以获得每个头寸的每日绩效，假设投资相等。这些回报的每日平均值对应于等权重多头和空头组合的绩效，总和反映了市场中性多空策略的整体回报：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we compare the results, as shown in *Figure 8.2*, our strategy performed
    well compared to the S&P 500 for the first 2 years of the period – that is, until
    the benchmark catches up and our strategy underperforms during 2017.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们比较结果时，如*图8.2*所示，我们的策略在该时期的前两年表现良好，即直到基准赶上并且我们的策略在2017年表现不佳。
- en: 'The strategy returns are also less volatile with a standard deviation of 0.002
    compared to 0.008 for the S&P 500; the correlation is low and negative at -0.093:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准偏差为0.008的标准普尔500相比，该策略的回报也不太波动，标准偏差为0.002；相关性较低，为-0.093：
- en: '![](img/B15439_08_02.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15439_08_02.png)'
- en: 'Figure 8.2: Vectorized backtest results'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：矢量化回测结果
- en: 'While this approach permits a quick back-of-the-envelope evaluation, it misses
    important features of a robust, realistic, and user-friendly backtest engine;
    for example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法允许快速的估算，但它错过了一个强大、现实和用户友好的回测引擎的重要特征；例如：
- en: We need to manually align the timestamps of predictions and returns (using pandas' built-in
    capabilities) and do not have any safeguards against inadvertent look-ahead bias.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要手动对齐预测和回报的时间戳（使用pandas内置功能），并且没有任何防止无意中的前瞻性偏见的保障。
- en: There is no explicit position sizing and representation of the trading process
    that accounts for costs and other market realities, or an accounting system that
    tracks positions and their performance.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有明确的头寸大小和交易过程的表示，也没有考虑成本和其他市场现实的会计系统，也没有跟踪头寸及其绩效的会计系统。
- en: There is also no performance measurement other than what we compute after the
    fact, and risk management rules like stop-loss are difficult to simulate.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了事后计算的绩效测量之外，也没有其他绩效测量，而且风险管理规则如止损很难模拟。
- en: That's where event-driven backtesting comes in. An event-driven backtesting
    engine explicitly simulates the time dimension of the trading environment and
    imposes significantly more structure on the simulation. This includes the use
    of historical calendars that define when trades can be made and when quotes are
    available. The enforcement of timestamps also helps to avoid look-ahead bias and
    other implementation errors mentioned in the previous section (but there is no
    guarantee).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是事件驱动的反向测试的用武之地。事件驱动的反向测试引擎明确模拟了交易环境的时间维度，并对模拟施加了更多结构。这包括使用历史日历来定义何时可以进行交易以及何时可以获得报价。时间戳的强制执行还有助于避免前瞻性偏见和前一节中提到的其他实施错误（但不能保证）。
- en: Generally, event-driven systems aim to capture the actions and constraints encountered
    by a strategy more closely and, ideally, can readily be converted into a live
    trading engine that submits actual orders.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，事件驱动系统旨在更紧密地捕捉策略遇到的行动和限制，并且理想情况下可以轻松转换为提交实际订单的实时交易引擎。
- en: Key implementation aspects
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键实施方面
- en: The requirements for a realistic simulation may be met by a **single platform**
    that supports all steps of the process in an end-to-end fashion, or by **multiple
    tools** that each specialize in different aspects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 实现真实模拟的要求可以通过**支持整个过程的单一平台**以端到端方式实现，也可以通过**专门化不同方面的多个工具**来实现。
- en: For instance, you could handle the design and testing of ML models that generate
    signals using generic ML libraries like scikit-learn, or others that we will encounter
    in this book, and feed the model outputs into a separate backtesting engine. Alternatively,
    you could run the entire ML4T workflow end-to-end on a single platform like Quantopian
    or QuantConnect.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用通用的ML库（如scikit-learn）处理ML模型的设计和测试，或者使用本书中将遇到的其他库，并将模型输出馈送到单独的反向测试引擎。另一种方法是在Quantopian或QuantConnect等单一平台上端到端地运行整个ML4T工作流程。
- en: The following sections highlight key items and implementation details that need
    to be addressed to put this process into action.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分突出了需要解决的关键问题和实施细节，以将该流程付诸实施。
- en: Data ingestion – format, frequency, and timing
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据摄入-格式、频率和时间
- en: The first step in the process concerns the sources of data. Traditionally, algorithmic
    trading strategies focused on market data, namely the OHLCV price and volume data
    that we discussed in *Chapter 2*, *Market and Fundamental Data – Sources and Techniques*.
    Today, data sources are more diverse and raise the question of how many different
    **storage formats and data types** to support, and whether to use a proprietary
    or custom format or rely on third-party or open source formats.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的第一步涉及数据来源。传统上，算法交易策略侧重于市场数据，即我们在*第2章*中讨论的OHLCV价格和成交量数据。今天，数据来源更加多样化，引发了如何支持多少不同的**存储格式和数据类型**以及是使用专有或自定义格式，还是依赖第三方或开源格式的问题。
- en: Another aspect is the **frequency of data sources** that can be used and whether
    sources at different frequencies can be combined. Common options in increasing
    order of computational complexity and memory and storage requirements include
    daily, minute, and tick frequency. Intermediate frequencies are also possible.
    Algorithmic strategies tend to perform better at higher frequencies, even though
    quantamental investors are gaining ground, as discussed in *Chapter 1*, *Machine
    Learning for Trading – From Idea to Execution*. Regardless, institutional investors
    will certainly require tick frequency.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方面是可以使用的**数据源频率**，以及不同频率的数据源是否可以合并。按照计算复杂性和内存存储需求递增的常见选项包括每日、分钟和tick频率。也可以使用中间频率。尽管量化基金投资者正在崛起，但算法策略在更高频率下往往表现更好，如*第1章*中所讨论的《交易的机器学习-从构想到执行》。无论如何，机构投资者肯定需要tick频率。
- en: Finally, data ingestion should also address **point-in-time constraints** to
    avoid look-ahead bias, as outlined in the previous section. The use of trading
    calendars helps limit data to legitimate dates and times; adjustments to reflect
    corporate actions like stock splits and dividends or restatements that impact
    prices revealed at specific times need to be made prior to ingestion.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，数据摄入还应解决**时间点限制**，以避免前瞻性偏见，如前一节所述。使用交易日历有助于限制数据在合法日期和时间内；需要在摄入之前进行调整，以反映影响特定时间点价格的公司行为，如股票拆分和股利或重述。
- en: Factor engineering – built-in factors versus libraries
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 因子工程-内置因子与库
- en: To facilitate the engineering of alpha factors for use in ML models, many backtesting
    engines include computational tools suitable for numerous standard transformations
    like moving averages and various technical indicators. A key advantage of **built-in
    factor engineering** is the easy conversion of the backtesting pipeline into a
    live trading engine that applies the same computations to the input data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于为ML模型工程化alpha因子，许多反向测试引擎包括适用于许多标准转换的计算工具，如移动平均线和各种技术指标。**内置因子工程**的一个关键优势是将反向测试管道轻松转换为应用相同计算于输入数据的实时交易引擎。
- en: The **numerical Python libraries** (pandas, NumPy, TA-Lib) presented in *Chapter
    4*, *Financial Feature Engineering – How to Research Alpha Factors*, are an alternative
    to **pre-compute factors**. This can be efficient when the goal is to reuse factors
    in various backtests that amortize the computational cost.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*第4章*中介绍的**数值Python库**（pandas、NumPy、TA-Lib）是**预先计算因子**的替代方案。当目标是在各种反向测试中重复使用因子以摊销计算成本时，这可能是有效的。'
- en: ML models, predictions, and signals
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ML模型、预测和信号
- en: As mentioned earlier, the ML workflow discussed in *Chapter 6*, *The Machine
    Learning Process*, can be embedded in an end-to-end platform that integrates the
    model design and evaluation part into the backtesting process. While convenient,
    this is also costly because model training becomes part of the backtest when the
    goal is perhaps to fine-tune trading rules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，*第6章*中讨论的ML工作流程*，*机器学习过程*，可以嵌入到一个端到端平台中，将模型设计和评估部分整合到回测过程中。虽然方便，但这也很昂贵，因为当目标可能是优化交易规则时，模型训练成为回测的一部分。
- en: Similar to factor engineering, you can decouple these aspects and design, train,
    and evaluate ML models using generic libraries for this purpose, and also provide
    the relevant predictions as inputs to the backtester. We will mostly use this
    approach in this book because it makes the exposition more concise and less repetitive.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与因子工程类似，您可以解耦这些方面，并使用通用库设计、训练和评估ML模型，并将相关预测作为输入提供给回测器。在本书中，我们将主要使用这种方法，因为它使表述更简洁，减少了重复。
- en: Trading rules and execution
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交易规则和执行
- en: A realistic strategy simulation requires a faithful representation of the trading
    environment. This includes access to relevant exchanges, the availability of the
    various order types discussed in *Chapter 2*, *Market and Fundamental Data – Sources
    and Techniques*, and the accounting for transaction costs. Costs include broker
    commissions, bid-ask spreads, and slippage, giving us the difference between the
    target execution price and the price that's eventually obtained. It is also important
    to ensure trades execute with delays that reflect liquidity and operating hours.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现实的策略模拟需要对交易环境进行忠实的再现。这包括访问相关交易所，可用于*第2章*中讨论的各种订单类型，*市场和基本数据-来源和技术*，以及考虑交易成本。成本包括经纪佣金，买卖价差和滑点，给出了目标执行价格和最终获得价格之间的差异。还很重要的是确保交易执行的延迟反映了流动性和营业时间。
- en: Performance evaluation
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绩效评估
- en: Finally, a backtesting platform needs to facilitate performance evaluation.
    It can provide standard metrics derived from its accounting of transactions, or
    provide an output of the metrics that can be used with a library like **pyfolio**
    that's suitable for this purpose.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个回测平台需要便于性能评估。它可以提供从交易记录中得出的标准指标，或者提供可以与**pyfolio**这样的库一起使用的指标输出，这对于这个目的是合适的。
- en: In the next two sections, we will explore two of the most popular backtesting
    libraries, namely backtrader and Zipline.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两节中，我们将探讨两种最流行的回测库，即backtrader和Zipline。
- en: backtrader – a flexible tool for local backtests
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: backtrader-用于本地回测的灵活工具
- en: '**backtrader** is a popular, flexible, and user-friendly Python library for
    local backtests with great documentation, developed since 2015 by Daniel Rodriguez.
    In addition to a large and active community of individual traders, there are several
    banks and trading houses that use backtrader to prototype and test new strategies
    before porting them to a production-ready platform using, for example, Java. You
    can also use backtrader for live trading with several brokers of your choice (see
    the backtrader documentation and *Chapter 23*, *Conclusions and Next Steps*).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**backtrader**是一个流行的、灵活的、用户友好的Python库，自2015年由Daniel Rodriguez开发以来，拥有很好的文档。除了有一个庞大而活跃的个人交易者社区外，还有一些银行和交易公司使用backtrader来原型和测试新策略，然后将它们移植到一个生产就绪的平台，例如Java。您还可以选择使用backtrader进行实时交易，与您选择的几家经纪商合作（请参阅backtrader文档和*第23章*，*结论和下一步*）。'
- en: We'll first summarize the key concepts of backtrader to clarify the big picture
    of the backtesting workflow on this platform, and then demonstrate its usage for
    a strategy driven by ML predictions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先总结backtrader的关键概念，以澄清在该平台上的回测工作流程的整体情况，然后演示其用于由ML预测驱动的策略的用法。
- en: Key concepts of backtrader's Cerebro architecture
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: backtrader Cerebro架构的关键概念
- en: backtrader's **Cerebro** (Spanish for "brain") architecture represents the key
    components of the backtesting workflow as (extensible) Python objects. These objects
    interact to facilitate processing input data and the computation of factors, formulate
    and execute a strategy, receive and execute orders, and track and measure performance.
    A Cerebro instance orchestrates the overall process from collecting inputs, executing
    the backtest bar by bar, and providing results.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: backtrader的**Cerebro**（西班牙语意为“大脑”）架构将回测工作流程的关键组件表示为（可扩展的）Python对象。这些对象相互作用，以便处理输入数据和因子的计算，制定和执行策略，接收和执行订单，以及跟踪和衡量绩效。一个Cerebro实例编排整个过程，从收集输入，逐根杆进行回测，到提供结果。
- en: The library uses conventions for these interactions that allow you to omit some
    detail and streamline the backtesting setup. I highly recommend browsing the documentation
    to dive deeper if you plan on using backtrader to develop your own strategies.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该库使用这些交互的约定，允许您省略一些细节并简化回测设置。如果您打算使用backtrader开发自己的策略，我强烈建议浏览文档以深入了解。
- en: '*Figure 8.3* outlines the key elements in the Cerebro architecture, and the
    following subsections summarize their most important functionalities:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.3*概述了Cerebro架构的关键要素，以下各小节总结了它们最重要的功能：'
- en: '![](img/B15439_08_03.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15439_08_03.png)'
- en: 'Figure 8.3: The backtrader Cerebro architecture'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：backtrader Cerebro架构
- en: Data feeds, lines, and indicators
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据源、线和指标
- en: Data feeds are the raw material for a strategy and contain information about
    individual securities, such as OHLCV market data with a timestamp for each observation,
    but you can customize the available fields. backtrader can ingest data from various
    sources, including CSV files and pandas DataFrames, and from online sources like
    Yahoo Finance. There are also extensions you can use to connect to online trading
    platforms like Interactive Brokers to ingest live data and execute transactions.
    The compatibility with DataFrame objects implies that you can load data from accessible
    by pandas, ranging from databases to HDF5 files. (See the demonstration in the
    *How to use backtrader in practice* section; also, see the *I/O* section of the
    pandas documentation.)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源是策略的原材料，包含有关个别证券的信息，例如带有每次观察的时间戳的OHLCV市场数据，但您可以自定义可用字段。backtrader可以从各种来源摄取数据，包括CSV文件和pandas
    DataFrames，以及来自Yahoo Finance等在线来源。还有扩展可以用于连接到像交互经纪这样的在线交易平台，以摄取实时数据并执行交易。与DataFrame对象的兼容性意味着您可以从pandas可访问的数据源加载数据，从数据库到HDF5文件都可以（请参阅*如何在实践中使用backtrader*部分；还请参阅pandas文档的*I/O*部分）。
- en: Once loaded, we add the data feeds to a Cerebro instance, which, in turn, makes
    it available to one or more strategies in the order received. Your strategy's
    trading logic can access each data feed by name (for example, the ticker) or sequence
    number and retrieve the current and past values of any field of the data feed.
    Each field is called a **line**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 加载完毕后，我们将数据源添加到Cerebro实例中，然后按顺序提供给一个或多个策略。您的策略交易逻辑可以通过名称（例如股票代码）或序列号访问每个数据源，并检索数据源的任何字段的当前值和历史值。每个字段称为**线**。
- en: backtrader comes with over 130 common technical **indicators** that allow you
    to compute new values from lines or other indicators for each data feed to drive
    your strategy. You can also use standard Python **operations** to derive new values.
    Usage is fairly straightforward and well explained in the documentation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: backtrader配备了超过130种常见的技术**指标**，允许您从线或其他指标计算每个数据源的新值，以驱动您的策略。您还可以使用标准的Python**操作**来推导新值。使用方法非常简单，并且在文档中有很好的解释。
- en: From data and signals to trades – strategy
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从数据和信号到交易 - 策略
- en: The **Strategy** object contains your trading logic that places orders based
    on data feed information that the Cerebro instance presents at every bar during
    backtest execution. You can easily test variations by configuring a Strategy to
    accept arbitrary parameters that you define when adding an instance of your Strategy
    to your Cerebro.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**策略**对象包含您的交易逻辑，根据Cerebro实例在回测执行期间的每个柱状图呈现的数据源信息下达订单。您可以通过配置策略接受您在将策略实例添加到Cerebro时定义的任意参数来轻松测试变化。'
- en: For every bar of a backtest, the Cerebro instance calls either the `.prenext()`
    or `.next()` method of your Strategy instance. The role of `.prenext()` is to
    address bars that do not yet have complete data for all feeds, for example, before
    there are enough periods to compute an indicator like a built-in moving average
    or if there is otherwise missing data. The default is to do nothing, but you can
    add trading logic of your choice or call `next()` if your main Strategy is designed
    to handle missing values (see the *How to use backtrader in practice* section).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在回测的每个柱状图中，Cerebro实例调用您的策略实例的`.prenext()`或`.next()`方法。`.prenext()`的作用是处理尚未为所有数据源提供完整数据的柱状图，例如，在足够的周期计算内置移动平均线指标之前，或者数据缺失的情况下。默认情况下不执行任何操作，但您可以添加自己选择的交易逻辑，或者在您的主策略设计为处理缺失值时调用`next()`（请参阅*如何在实践中使用backtrader*部分）。
- en: You can also use backtrader without defining an explicit Strategy and instead
    use a simplified Signals interface. The Strategy API gives you more control and
    flexibility, though; see the backtrader documentation for details on how to use
    the Signals API.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在不定义显式策略的情况下使用backtrader，而是使用简化的信号接口。尽管策略API给您更多的控制和灵活性；有关如何使用信号API的详细信息，请参阅backtrader文档。
- en: 'A Strategy outputs orders: let''s see how backtrader handles these next.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 策略输出订单：让我们看看backtrader如何处理这些订单。
- en: Commissions instead of commission schemes
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 佣金而不是佣金方案
- en: Once your Strategy has evaluated current and past data points at each bar, it
    needs to decide which orders to place. backtrader lets you create several standard
    **order** types that Cerebro passes to a Broker instance for execution and provides
    a notification of the result at each bar.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的策略在每个柱状图评估了当前和过去的数据点，它需要决定下达哪些订单。backtrader允许您创建几种标准的**订单**类型，Cerebro将这些订单传递给经纪人实例进行执行，并在每个柱状图提供结果通知。
- en: 'You can use the Strategy methods `buy()` and `sell()` to place market, close,
    and limit orders, as well as stop and stop-limit orders. Execution works as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用策略方法`buy()`和`sell()`来下市价、平仓和限价订单，以及止损和止损限价订单。执行方式如下：
- en: '**Market order**: Fills at the next open bar'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**市价订单**：在下一个开盘柱状图填充'
- en: '**Close order**: Fills at the next close bar'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平仓订单**：在下一个收盘柱状图填充'
- en: '**Limit order**: Executes only if a price threshold is met (for example, only
    buy up to a certain price) during an (optional) period of validity'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限价订单**：仅在达到价格阈值时执行（例如，仅在某个价格范围内购买）在（可选的）有效期内'
- en: '**Stop order**: Becomes a market order if the price reaches a given threshold'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**止损订单**：如果价格达到给定阈值，则变为市价订单'
- en: '**Stop limit order**: Becomes a limit order once the stop is triggered'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**止损限价订单**：一旦触发止损，就变为限价订单'
- en: In practice, stop orders differ from limit orders because they cannot be seen
    by the market prior to the price trigger. backtrader also provides target orders
    that compute the required size, taking into account the current position to achieve
    a certain portfolio allocation in terms of the number of shares, the value of
    the position, or the percentage of portfolio value. Furthermore, there are **bracket
    orders** that combine, for a long order, a buy with two limit sell orders that
    activate as the buy executes. Should one of the sell orders fill or cancel, the
    other sell order also cancels.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，停止订单与限价订单不同，因为在价格触发之前市场看不到它们。backtrader还提供了目标订单，计算所需的大小，考虑当前持仓以实现特定的投资组合分配，包括股票数量、头寸价值或投资组合价值的百分比。此外，还有**bracket
    orders**，它们为多头订单组合了一个买入和两个限价卖出订单，当买入执行时激活。如果其中一个卖出订单成交或取消，另一个卖出订单也会取消。
- en: The **Broker** handles order execution, tracks the portfolio, cash value, and
    notifications and implements transaction costs like commission and slippage. The
    Broker may reject trades if there is not enough cash; it can be important to sequence
    buys and sells to ensure liquidity. backtrader also has a `cheat_on_open` feature
    that permits looking ahead to the next bar, to avoid rejected trades due to adverse
    price moves by the next bar. This feature will, of course, bias your results.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**Broker**处理订单执行，跟踪投资组合、现金价值和通知，并实施佣金和滑点等交易成本。如果现金不足，经纪人可能会拒绝交易；确保买卖顺序以确保流动性可能很重要。backtrader还有一个`cheat_on_open`功能，允许向前看到下一个柱状图，以避免由于下一个柱状图的不利价格变动而拒绝交易。当然，这个功能会使你的结果产生偏差。'
- en: In addition to **commission schemes** like a fixed or percentage amount of the
    absolute transaction value, you can implement your own logic, as demonstrated
    later, for a flat fee per share.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像固定或百分比的绝对交易价值的佣金方案之外，您还可以实现自己的逻辑，正如后面演示的那样，每股收取固定费用。
- en: Making it all happen – Cerebro
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让一切发生- Cerebro
- en: The Cerebro control system synchronizes the data feeds based on the bars represented
    by their timestamp, and runs the trading logic and broker actions on an event-by-event
    basis accordingly. backtrader does not impose any restrictions on the frequency
    or the trading calendar and can use multiple time frames in parallel.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Cerebro控制系统根据它们的时间戳表示的柱状图同步数据源，并根据事件逐事件地运行交易逻辑和经纪人操作。backtrader不对频率或交易日历施加任何限制，并且可以并行使用多个时间框架。
- en: It also vectorizes the calculation for indicators if it can preload source data.
    There are several options you can use to optimize operations from a memory perspective
    (see the Cerebro documentation for details).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以预先加载源数据，它还会对指标的计算进行矢量化。您可以使用几种选项来优化内存操作（有关详细信息，请参阅Cerebro文档）。
- en: How to use backtrader in practice
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在实践中使用backtrader
- en: We are going to demonstrate backtrader using the daily return predictions from
    the ridge regression from *Chapter 7*, *Linear Models – From Risk Factors to Return
    Forecasts*, as we did for the vectorized backtest earlier in this chapter. We
    will create the Cerebro instance, load the data, formulate and add the Strategy,
    run the backtest, and review the results.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用从*第7章*，*线性模型-从风险因素到收益预测*中的岭回归得到的每日收益预测来演示backtrader，就像我们在本章早些时候进行的矢量化回测一样。我们将创建Cerebro实例，加载数据，制定并添加策略，运行回测，并审查结果。
- en: The notebook `backtesting_with_backtrader` contains the following code examples
    and some additional details.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本`backtesting_with_backtrader`包含以下代码示例和一些额外的细节。
- en: How to load price and other data
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何加载价格和其他数据
- en: 'We need to ensure that we have price information for all the dates on which
    we would like to buy or sell stocks, not only for the days with predictions. To
    load data from a pandas DataFrame, we subclass backtrader''s `PandasData` class
    to define the fields that we will provide:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保我们对于想要买卖股票的所有日期都有价格信息，而不仅仅是预测的日期。为了从pandas DataFrame加载数据，我们子类化backtrader的`PandasData`类来定义我们将提供的字段：
- en: '[PRE4]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then instantiate a `Cerebro` class and use the `SignalData` class to add
    one data feed for each ticker in our dataset that we load from HDF5:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实例化一个`Cerebro`类，并使用`SignalData`类为我们从HDF5加载的数据集中的每个股票添加一个数据源：
- en: '[PRE5]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we are ready to define our Strategy.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备定义我们的策略。
- en: How to formulate the trading logic
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何制定交易逻辑
- en: 'Our `MLStrategy` subclasses backtrader''s `Strategy` class and defines parameters
    that we can use to modify its behavior. We also create a log file to create a
    record of the transactions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`MLStrategy`子类化backtrader的`Strategy`类，并定义可以用来修改其行为的参数。我们还创建一个日志文件来记录交易：
- en: '[PRE6]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The core of the strategy resides in the `.next()` method. We go long/short
    on the `n_position` stocks with the highest positive/lowest negative forecast,
    as long as there are at least `min_positions` positions. We always sell any existing
    positions that do not appear in the new long and short lists and use `order_target_percent`
    to build equal-weights positions in the new targets (log statements are omitted
    to save some space):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 策略的核心在于`.next()`方法。我们对具有最高正向/最低负向预测的`n_position`股票进行多头/空头操作，只要至少有`min_positions`个头寸。我们总是卖出任何不在新的多头和空头列表中出现的现有头寸，并使用`order_target_percent`来在新目标中建立等权头寸（为了节省空间，省略了日志记录）：
- en: '[PRE7]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we need to configure our `Cerebro` instance and add our `Strategy`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要配置我们的`Cerebro`实例并添加我们的`Strategy`。
- en: How to configure the Cerebro instance
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何配置Cerebro实例
- en: 'We use a custom commission scheme that assumes we pay a fixed amount of $0.02
    per share that we buy or sell:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个自定义佣金方案，假设我们每股支付固定金额的$0.02：
- en: '[PRE8]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we define our starting cash amount and configure the broker accordingly:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义我们的起始现金金额并相应地配置经纪人：
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, all that''s missing is adding the `MLStrategy` to our `Cerebro` instance,
    providing parameters for the desired number of positions and the minimum number
    of long/shorts. We''ll also add a pyfolio analyzer so we can view the performance
    tearsheets we presented in *Chapter 5*, *Portfolio Optimization and Performance
    Evaluation*:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，唯一缺少的是将`MLStrategy`添加到我们的`Cerebro`实例中，为所需的头寸数量和多头/空头的最小数量提供参数。我们还将添加一个pyfolio分析器，这样我们就可以查看我们在*第5章*
    *组合优化和绩效评估*中呈现的绩效泪痕：
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The backtest uses 869 trading days and takes around 45 seconds to run. The following
    figure shows the cumulative return and the evolution of the portfolio value, as
    well as the daily value of long and short positions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 回测使用了869个交易日，运行时间约为45秒。下图显示了累积收益和组合价值的演变，以及多头和空头头寸的每日价值。
- en: Performance looks somewhat similar to the preceding vectorized test, with outperformance
    relative to the S&P 500 benchmark during the first half and poor performance thereafter.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 绩效看起来与前面的矢量化测试有些相似，在前半段相对于标普500指数表现出色，而在后半段表现不佳。
- en: 'The `backtesting_with_backtrader` notebook contains the complete pyfolio results:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`backtesting_with_backtrader`笔记本包含完整的pyfolio结果：'
- en: '![](img/B15439_08_04.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15439_08_04.png)'
- en: 'Figure 8.4: backtrader results'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：backtrader结果
- en: backtrader summary and next steps
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: backtrader摘要和下一步
- en: backtrader is a very straightforward yet flexible and performant backtesting
    engine for local backtesting. You can load any dataset at the frequency you desire
    from a broad range of sources due to pandas compatibility. `Strategy` lets you
    define arbitrary trading logic; you just need to ensure you access the distinct
    data feeds as needed. It also integrates well with pyfolio for quick yet comprehensive
    performance evaluation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: backtrader是一个非常简单但灵活且高性能的本地回测引擎。由于与pandas兼容，您可以从广泛的来源加载任何频率的数据集。`Strategy`允许您定义任意交易逻辑；您只需要确保根据需要访问不同的数据源。它还与pyfolio很好地集成，可以快速而全面地进行绩效评估。
- en: In the demonstration, we applied our trading logic to predictions from a pre-trained
    model. We can also train a model during backtesting because we can access data
    prior to the current bar. Often, however, it is more efficient to decouple model
    training from strategy selection and avoid duplicating model training.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示中，我们将我们的交易逻辑应用于预训练模型的预测。我们也可以在回测期间训练模型，因为我们可以访问当前柱之前的数据。然而，通常更有效的做法是将模型训练与策略选择分离，避免重复模型训练。
- en: One of the reasons for backtrader's popularity is the ability to use it for
    live trading with a broker of your choosing. The community is very lively, and
    code to connect to brokers or additional data sources, including for cryptocurrencies,
    is readily available online.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: backtrader受欢迎的原因之一是能够与您选择的经纪人进行实时交易。社区非常活跃，可以在线轻松获得连接经纪人或其他数据源的代码，包括加密货币。
- en: Zipline – scalable backtesting by Quantopian
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zipline - Quantopian的可扩展回测
- en: The backtesting engine Zipline powers Quantopian's online research, backtesting,
    and live (paper) trading platform. As a hedge fund, Quantopian aims to identify
    robust algorithms that outperform, subject to its risk management criteria. To
    this end, they use competitions to select the best strategies and allocate capital
    to share profits with the winners.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 回测引擎Zipline支持Quantopian的在线研究、回测和实时（模拟）交易平台。作为对冲基金，Quantopian旨在确定优于其风险管理标准的稳健算法。为此，他们使用竞赛来选择最佳策略，并分配资金与赢家分享利润。
- en: Quantopian first released Zipline in 2012 as version 0.5, and the latest version,
    1.3, dates from July 2018\. Zipline works well with its sister libraries Alphalens,
    pyfolio, and empyrical that we introduced in *Chapter 4,* *Financial Feature Engineering
    – How to Research Alpha Factors* and *Chapter 5,* *Portfolio Optimization and
    Performance Evaluation*, and integrates well with NumPy, pandas, and numeric libraries,
    but may not always support the latest version.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Quantopian于2012年首次发布了版本0.5的Zipline，最新版本1.3的发布日期为2018年7月。Zipline与我们在*第4章* *金融特征工程-如何研究Alpha因子*和*第5章*
    *组合优化和绩效评估*中介绍的姐妹库Alphalens、pyfolio和empyrical以及NumPy、pandas和数值库很好地集成，但可能并不总是支持最新版本。
- en: Zipline is designed to operate at the scale of thousands of securities, and
    each can be associated with a large number of indicators. It imposes more structure
    on the backtesting process than backtrader to ensure data quality by eliminating
    look-ahead bias, for example, and optimize computational efficiency while executing
    a backtest. We'll take a look at the key concepts and elements of the architecture,
    shown in *Figure 8.5,* before we demonstrate how to use Zipline to backtest ML-driven
    models on the data of your choice.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Zipline旨在以数千种证券的规模运作，每种证券都可以与大量指标相关联。它对回测过程施加了比backtrader更多的结构，以确保通过消除向前偏差等方式保证数据质量，并在执行回测时优化计算效率。在我们演示如何使用Zipline对您选择的数据进行ML驱动模型的回测之前，我们将先看一下架构的关键概念和元素，如*图8.5*所示。
- en: Calendars and the Pipeline for robust simulations
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日历和Pipeline用于稳健模拟
- en: 'Key features that contribute to the goals of scalability and reliability are
    data bundles that store OHLCV market data with on-the-fly adjustments for splits
    and dividends, trading calendars that reflect operating hours of exchanges around
    the world, and the powerful Pipeline API (see the following diagram). We will
    discuss their usage in the following sections to complement the brief Zipline
    introduction we gave in earlier chapters:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于可扩展性和可靠性目标的关键特性是存储OHLCV市场数据的数据包，可以在飞行中进行拆分和股利调整，反映全球交易所营业时间的交易日历，以及强大的Pipeline
    API（见下图）。我们将在接下来的章节中讨论它们的用法，以补充我们在前几章中对Zipline的简要介绍：
- en: '![](img/B15439_08_05.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15439_08_05.png)'
- en: 'Figure 8.5: The Zipline architecture'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：Zipline架构
- en: Bundles – point-in-time data with on-the-fly adjustments
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据包 - 具有即时调整的时点数据
- en: The principal data store is a **bundle** that resides on disk in compressed,
    columnar bcolz format for efficient retrieval, combined with metadata stored in
    an SQLite database. Bundles are designed to contain only OHLCV data and are limited
    to daily and minute frequency. A great feature is that bundles store split and
    dividend information, and Zipline computes **point-in-time adjustments**, depending
    on the time period you pick for your backtest.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 主要数据存储是一个**bundle**，以压缩的、列式的bcolz格式存储在磁盘上，以实现高效检索，同时与存储在SQLite数据库中的元数据结合。bundles旨在仅包含OHLCV数据，并且仅限于每日和分钟频率。一个很棒的功能是bundles存储了分割和股利信息，而Zipline根据您选择的回测时间段计算**时点调整**。
- en: Zipline relies on the **TradingCalendar** library (also maintained by Quantopian)
    for operational details on exchanges around the world, such as time zone, market
    open and closing times, or holidays. Data sources have domains (for now, these
    are countries) and need to conform to the assigned exchange calendar. Quantopian
    is actively developing support for international securities, and these features
    may evolve.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Zipline依赖于**TradingCalendar**库（也由Quantopian维护）来获取世界各地交易所的运营细节，如时区、市场开盘和收盘时间，或者假期。数据源具有域（目前为国家），需要符合指定的交易所日历。Quantopian正在积极开发对国际证券的支持，这些功能可能会不断发展。
- en: After installation, the command `zipline ingest -b bundle` lets you install
    the Quandl Wiki dataset (daily frequency) right away. The result ends up in the
    `.zipline` directory, which, by default, resides in your home folder. In addition,
    you can design your own bundles, as we'll see.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，命令`zipline ingest -b bundle`让您立即安装Quandl Wiki数据集（每日频率）。结果将出现在`.zipline`目录中，默认情况下位于您的主文件夹中。此外，您还可以设计自己的bundles，我们将会看到。
- en: In addition to bundles, you can provide OHCLV data to an algorithm as a pandas
    DataFrame or Panel. (Panel is recently deprecated, but Zipline is a few pandas
    versions behind.) However, bundles are more convenient and efficient.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了bundles，您还可以将OHCLV数据作为pandas DataFrame或Panel提供给算法。（Panel最近已被弃用，但Zipline落后于几个pandas版本。）然而，bundles更加方便和高效。
- en: 'A shortcoming of bundles is that they do not let you store data other than
    price and volume information. However, two alternatives let you accomplish this:
    the `fetch_csv()` function downloads DataFrames from a URL and was designed for
    other Quandl data sources, for example, fundamentals. Zipline reasonably expects
    the data to refer to the same securities for which you have provided OHCLV data
    and aligns the bars accordingly. It''s very easy to patch the library to load
    a local CSV or HDF5 using pandas, and the GitHub repository provides some guidance
    on how to do so.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: bundles的一个缺点是它们不允许您存储除价格和成交量信息之外的数据。然而，有两种替代方法可以实现这一点：`fetch_csv()`函数从URL下载DataFrame，旨在用于其他Quandl数据源，例如基本面数据。Zipline合理地期望数据与您提供的OHCLV数据引用相同的证券，并相应地对齐条形图。很容易通过补丁库来加载本地CSV或HDF5文件，GitHub存储库提供了如何操作的一些指导。
- en: In addition, `DataFrameLoader` and `BlazeLoader` permit you to feed additional
    attributes to a Pipeline (see the `DataFrameLoader` demo later in this chapter).
    `BlazeLoader` can interface with numerous sources, including databases. However,
    since the Pipeline API is limited to daily data, `fetch_csv()` will be critical
    to adding features at a minute frequency, as we will do in later chapters.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`DataFrameLoader`和`BlazeLoader`允许您向Pipeline提供额外的属性（请参见本章后面的`DataFrameLoader`演示）。`BlazeLoader`可以与包括数据库在内的多种来源进行接口。然而，由于Pipeline
    API仅限于每日数据，`fetch_csv()`将对于在分钟频率上添加功能至关重要，这将在后面的章节中进行。
- en: The Algorithm API – backtests on a schedule
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法API - 按计划进行回测
- en: The `TradingAlgorithm` class implements the Zipline Algorithm API and operates
    on `BarData` that has been aligned with a given trading calendar. After the initial
    setup, the backtest runs for a specified period and executes its trading logic
    as specific events occur. These events are driven by the daily or minutely trading
    frequency, but you can also schedule arbitrary functions to evaluate signals,
    place orders, and rebalance your portfolio, or log information about the ongoing
    simulation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`TradingAlgorithm`类实现了Zipline算法API，并在给定的交易日历上操作已对齐的`BarData`。在初始设置之后，回测将在指定的期间运行，并在特定事件发生时执行其交易逻辑。这些事件由每日或每分钟的交易频率驱动，但您也可以安排任意函数来评估信号、下订单、重新平衡您的投资组合，或记录有关正在进行的模拟的信息。'
- en: You can execute an algorithm from the command line, in a Jupyter Notebook, or
    by using the `run_algorithm()` method of the underlying `TradingAlgorithm` class.
    The algorithm requires an `initialize()` method that is called once when the simulation
    starts. It keeps state through a context dictionary and receives actionable information
    through a data variable containing point-in-time current and historical data.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过命令行、Jupyter Notebook或使用底层`TradingAlgorithm`类的`run_algorithm()`方法来执行算法。该算法需要一个`initialize()`方法，在模拟开始时调用一次。它通过上下文字典保持状态，并通过包含时点当前和历史数据的数据变量接收可操作信息。
- en: You can add properties to the context dictionary, which is available to all
    other `TradingAlgorithm` methods, or register pipelines that perform more complex
    data processing, such as computing alpha factors and filtering securities accordingly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向上下文字典添加属性，该字典对所有其他`TradingAlgorithm`方法都可用，或者注册执行更复杂数据处理的Pipeline，例如计算alpha因子并相应地过滤证券。
- en: Algorithm execution occurs through optional methods that are either scheduled
    automatically by Zipline or at user-defined intervals. The method `before_trading_start()`
    is called daily before the market opens and primarily serves to identify a set
    of securities the algorithm may trade during the day. The method `handle_data()`
    is called at the given trading frequency, for example, every minute.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 算法执行通过Zipline自动安排或用户定义的间隔的可选方法进行。`before_trading_start()`方法在市场开盘前每天调用，主要用于确定算法可能在当天交易的证券集。`handle_data()`方法按给定的交易频率调用，例如，每分钟调用一次。
- en: Upon completion, the algorithm returns a DataFrame containing portfolio performance
    metrics if there were any trades, as well as user-defined metrics. As demonstrated
    in *Chapter 5,* *Portfolio Optimization and Performance Evaluation*, the output
    is compatible with pyfolio so that you can quickly create performance tearsheets.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，如果有任何交易，算法将返回一个包含投资组合绩效指标的DataFrame，以及用户定义的指标。正如*第5章* *投资组合优化和绩效评估*中所演示的，输出与pyfolio兼容，因此您可以快速创建绩效报表。
- en: Known issues
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已知问题
- en: Zipline currently requires the presence of Treasury curves and the S&P 500 returns
    for benchmarking ([https://github.com/quantopian/zipline/issues/2480](https://github.com/quantopian/zipline/issues/2480)).
    The latter relies on the IEX API, which now requires registration to obtain a
    key. It is easy to patch Zipline to circumvent this and download data from the
    Federal Reserve, for instance. The GitHub repository describes how to go about
    this. Alternatively, you can move the SPY returns provided in `zipline/resources/market_data/SPY_benchmark.csv`
    to your `.zipline` folder, which usually lives in your home directory, unless
    you changed its location.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Zipline目前需要存在国库曲线和标准普尔500回报以进行基准测试（[https://github.com/quantopian/zipline/issues/2480](https://github.com/quantopian/zipline/issues/2480)）。后者依赖于IEX
    API，现在需要注册以获取密钥。很容易修补Zipline以规避此问题，并从联邦储备系统下载数据，例如。GitHub存储库描述了如何解决此问题。或者，您可以将`zipline/resources/market_data/SPY_benchmark.csv`中提供的SPY回报移动到您的`.zipline`文件夹中，该文件夹通常位于您的主目录中，除非您更改了其位置。
- en: Live trading ([https://github.com/zipline-live/zipline](https://github.com/zipline-live/zipline))
    your own systems is only available with Interactive Brokers and is not fully supported
    by Quantopian.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 实时交易（[https://github.com/zipline-live/zipline](https://github.com/zipline-live/zipline)）只能在Interactive
    Brokers上使用，并且Quantopian不完全支持。
- en: Ingesting your own bundles with minute data
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分钟数据摄取您自己的bundles
- en: 'We will use the NASDAQ100 2013-17 sample provided by AlgoSeek that we introduced
    in *Chapter 2,* *Market and Fundamental Data – Sources and Techniques**,* to demonstrate
    how to write your own custom bundle. There are four steps:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用AlgoSeek提供的NASDAQ100 2013-17样本，该样本在*第2章* *市场和基本数据-来源和技术*中介绍，来演示如何编写自己的自定义bundle。有四个步骤：
- en: Divide your OHCLV data into one file per ticker and store metadata and split
    and dividend adjustments.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的OHCLV数据分成每个支票一个文件，并存储元数据和拆分和股利调整。
- en: Write a script to pass the result to an `ingest()` function, which, in turn,
    takes care of writing the bundle to bcolz and SQLite format.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个脚本将结果传递给`ingest()`函数，该函数负责将bundle写入bcolz和SQLite格式。
- en: Register the bundle in an extension.py script that lives in your `.zipline`
    directory in your home folder, and symlink the data sources.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在位于您的主目录中的`.zipline`目录中的extension.py脚本中注册bundle，并创建数据源的符号链接。
- en: For AlgoSeek data, we also provide a custom TradingCalendar because it includes
    trading activity outside NYSE market hours.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于AlgoSeek数据，我们还提供了自定义TradingCalendar，因为它包括了纽约证券交易所以外的交易活动。
- en: The directory `custom_bundles` contains the code examples for this section.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`custom_bundles`目录包含本节的代码示例。'
- en: Getting your data ready to be bundled
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备好捆绑您的数据
- en: In *Chapter 2, Market and Fundamental Data – Sources and Techniques*, we parsed
    the daily files containing the AlgoSeek NASDAQ 100 OHLCV data to obtain a time
    series for each ticker. We will use this result because Zipline also stores each
    security individually.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章，市场和基本数据-来源和技术*中，我们解析了包含AlgoSeek纳斯达克100 OHLCV数据的每日文件，以获得每个支票的时间序列。我们将使用这个结果，因为Zipline也将每个证券单独存储。
- en: In addition, we obtain equity metadata using the pandas DataReader `get_nasdaq_symbols()`
    function. Finally, since the Quandl Wiki data covers the NASDAQ 100 tickers for
    the relevant period, we extract the split and dividend adjustments from that bundle's
    SQLite database.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用pandas DataReader的`get_nasdaq_symbols()`函数获取股票元数据。最后，由于Quandl Wiki数据涵盖了相关时期的纳斯达克100支票，我们从该bundle的SQLite数据库中提取拆分和股利调整。
- en: The result is an HDF5 store containing price and volume data on some 135 tickers,
    as well as the corresponding meta and adjustment data. The script `algoseek_preprocessing.py`
    illustrates this process.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个HDF5存储，包含大约135个支票的价格和成交量数据，以及相应的元数据和调整数据。脚本`algoseek_preprocessing.py`说明了这个过程。
- en: Writing your custom bundle ingest function
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写您自己的bundle摄取函数
- en: The Zipline documentation outlines the required parameters for an `ingest()`
    function, which kicks off the I/O process, but does not provide a lot of practical
    detail. The script `algoseek_1min_trades.py` shows how to get this part to work
    for minute data.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Zipline文档概述了`ingest()`函数的必需参数，该函数启动I/O过程，但没有提供很多实际细节。脚本`algoseek_1min_trades.py`展示了如何使分钟数据工作。
- en: There is a `load_equities()` function that provides the metadata, a `ticker_generator()`
    function that feeds symbols to a `data_generator()`, which, in turn, loads and
    format each symbol's market data, and an `algoseek_to_bundle()` function, which
    integrates all the pieces and returns the desired `ingest()` function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`load_equities()`函数提供元数据，一个`ticker_generator()`函数将符号提供给`data_generator()`，后者加载和格式化每个符号的市场数据，以及一个`algoseek_to_bundle()`函数，它整合所有部分并返回所需的`ingest()`函数。
- en: Time zone alignment matters because Zipline translates all data series to UTC;
    we add US/Eastern time zone information to the OHCLV data and convert it to UTC.
    To facilitate execution, we create symlinks for this script and the `algoseek.h5`
    data in the `custom_data` folder in the `.zipline` directory, which we'll add
    to the `PATH` in the next step so Zipline can find this information.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 时区对齐很重要，因为Zipline将所有数据系列转换为UTC；我们为OHCLV数据添加US/Eastern时区信息并将其转换为UTC。为了方便执行，我们在`.zipline`目录中的`custom_data`文件夹中为此脚本和`algoseek.h5`数据创建符号链接，我们将在下一步中将其添加到`PATH`中，以便Zipline可以找到这些信息。
- en: Registering your bundle
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册您的bundle
- en: Before we can run `zipline ingest -b algoseek`, we need to register our custom
    bundle so Zipline knows what we are talking about. To this end, we'll add the
    following lines to an `extension.py` script in the `.zipline` file, which you
    may have to create first, alongside some inputs and settings (see the `extension.py`
    example).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行`zipline ingest -b algoseek`之前，我们需要注册我们的自定义捆绑包，以便Zipline知道我们在谈论什么。为此，我们将在`.zipline`文件中的`extension.py`脚本中添加以下行，您可能需要首先创建该文件，以及一些输入和设置（请参阅`extension.py`示例）。
- en: 'The registration itself is fairly straightforward but highlights a few important
    details. First, Zipline needs to be able to import the `algoseek_to_bundle()`
    function, so its location needs to be on the search path, for example, by using
    `sys.path.append()`. Second, we reference a custom calendar that we will create
    and register in the next step. Third, we need to inform Zipline that our trading
    days are longer than the default 6 and a half hours of NYSE days to avoid misalignments:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注册本身相当简单，但突出了一些重要细节。首先，Zipline需要能够导入`algoseek_to_bundle()`函数，因此其位置需要在搜索路径上，例如通过`sys.path.append()`。其次，我们引用了一个我们将在下一步中创建和注册的自定义日历。第三，我们需要通知Zipline我们的交易日比默认的NYSE交易日的6个半小时要长，以避免不对齐：
- en: '[PRE11]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating and registering a custom TradingCalendar
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建并注册自定义TradingCalendar
- en: 'As mentioned previously, Quantopian also provides a TradingCalendar library
    to support trading around the world. The package contains numerous examples, and
    it is fairly straightforward to subclass one of the examples. Based on the NYSE
    calendar, we only need to override the open/close times and change the name:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Quantopian还提供了一个TradingCalendar库，以支持全球范围内的交易。该包含有许多示例，很容易对其中一个示例进行子类化。基于NYSE日历，我们只需要覆盖开盘/收盘时间并更改名称：
- en: '[PRE12]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We put the definition into `extension.py` and add the following registration:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义放入`extension.py`中，并添加以下注册：
- en: '[PRE13]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And now, we can refer to this trading calendar to ensure a backtest includes
    off-market hour activity.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以参考这个交易日历，以确保回测包括非市场小时的活动。
- en: The Pipeline API – backtesting an ML signal
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pipeline API - 回测ML信号
- en: The Pipeline API facilitates the definition and computation of alpha factors
    for a cross-section of securities from historical data. Pipeline significantly
    improves efficiency because it optimizes computations over the entire backtest
    period, rather than tackling each event separately. In other words, it continues
    to follow an event-driven architecture but vectorizes the computation of factors
    where possible.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Pipeline API促进了对历史数据中一组证券的alpha因子的定义和计算。Pipeline显著提高了效率，因为它优化了整个回测期间的计算，而不是分别处理每个事件。换句话说，它继续遵循事件驱动的架构，但在可能的情况下对因子的计算进行了矢量化。
- en: A pipeline uses factors, filters, and classifiers classes to define computations
    that produce columns in a table with point-in-time values for a set of securities.
    Factors take one or more input arrays of historical bar data and produce one or
    more outputs for each security. There are numerous built-in factors, and you can
    also design your own `CustomFactor` computations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Pipeline使用因子、过滤器和分类器类来定义计算，以产生一张表中的列，其中包含一组证券的时点值。因子使用一个或多个历史柱状数据输入数组，并为每个证券产生一个或多个输出。有许多内置因子，您也可以设计自己的`CustomFactor`计算。
- en: 'The following diagram depicts how loading the data using `DataFrameLoader`,
    computing the predictive `MLSignal` using the Pipeline API, and various scheduled
    activities integrate with the overall trading algorithm that''s executed via the
    `run_algorithm()` function. We''ll go over the details and the corresponding code
    in this section:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了使用`DataFrameLoader`加载数据，使用Pipeline API计算预测的`MLSignal`，以及各种计划活动如何与通过`run_algorithm()`函数执行的整体交易算法集成。我们将在本节中详细介绍细节和相应的代码：
- en: '![](img/B15439_08_06.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15439_08_06.png)'
- en: 'Figure 8.6: ML signal backtest using Zipline''s Pipeline API'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：使用Zipline的Pipeline API进行ML信号回测
- en: You need to register your pipeline with the `initialize()` method and execute
    it at each time step or on a custom schedule. Zipline provides numerous built-in
    computations, such as moving averages or Bollinger Bands, that can be used to
    quickly compute standard factors, but it also allows for the creation of custom
    factors, as we will illustrate next.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用`initialize()`方法注册您的管道，并在每个时间步骤或自定义计划上执行它。Zipline提供了许多内置计算，例如移动平均线或布林带，可以用于快速计算标准因子，但它也允许创建自定义因子，我们将在下面进行说明。
- en: Most importantly, the Pipeline API renders alpha factor research modular because
    it separates the alpha factor computation from the remainder of the algorithm,
    including the placement and execution of trade orders and the bookkeeping of portfolio
    holdings, values, and so on.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，Pipeline API使得alpha因子研究模块化，因为它将alpha因子计算与算法的其余部分（包括交易订单的放置和执行以及投资组合持仓、价值等的簿记）分开。
- en: We'll now illustrate how to load the lasso model daily return predictions, together
    with price data for our universe, into a pipeline and use a `CustomFactor` to
    select the top and bottom 10 predictions as long and short positions, respectively.
    The notebook `backtesting_with_zipline` contains the following code examples.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将说明如何将lasso模型每日回报预测与我们宇宙的价格数据一起加载到管道中，并使用`CustomFactor`来选择前10个预测作为多头头寸，后10个预测作为空头头寸。笔记本`backtesting_with_zipline`包含以下代码示例。
- en: Our goal is to combine the daily return predictions with the OHCLV data from
    our Quandl bundle, and then to go long on up to 10 equities with the highest predicted
    returns and short on those with the lowest predicted returns, requiring at least
    five stocks on either side, similar to the backtrader example above.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将每日回报预测与我们的Quandl捆绑包中的OHCLV数据相结合，然后对预测回报最高的10只股票做多，对预测回报最低的股票做空，每边至少需要五只股票，类似于上面的backtrader示例。
- en: Enabling the DataFrameLoader for our Pipeline
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为我们的Pipeline启用DataFrameLoader
- en: 'First, we load our predictions for the 2015-17 period and extract the Zipline
    IDs for the ~250 stocks in our universe during this period using the `bundle.asset_finder.lookup_symbols()`
    method, as shown in the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载了2015-17年期间的预测，并使用`bundle.asset_finder.lookup_symbols()`方法提取了此期间我们宇宙中约250只股票的Zipline
    ID，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To make the predictions available to the Pipeline API, we need to define a
    `Column` with a suitable data type for a `DataSet` with an appropriate `domain`,
    like so:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使预测可用于Pipeline API，我们需要定义一个`Column`，其数据类型适合于具有适当`domain`的`DataSet`，如下所示：
- en: '[PRE15]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'While the bundle''s OHLCV data can rely on the built-in `USEquityPricingLoader`,
    we need to define our own `DataFrameLoader`, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然bundle的OHLCV数据可以依赖内置的`USEquityPricingLoader`，但我们需要定义自己的`DataFrameLoader`，如下所示：
- en: '[PRE16]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In fact, we need to slightly modify the Zipline library's source code to bypass
    the assumption that we will only load price data. To this end, we add a `custom_loader`
    parameter to the `run_algorithm` method and ensure that this loader is used when
    the pipeline needs one of SignalData's `Column` instances.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们需要稍微修改Zipline库的源代码，以绕过我们只加载价格数据的假设。为此，我们向`run_algorithm`方法添加了一个`custom_loader`参数，并确保在流水线需要SignalData的`Column`实例时使用此加载器。
- en: Creating a pipeline with a custom ML factor
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建具有自定义ML因子的流水线
- en: 'Our pipeline is going to have two Boolean columns that identify the assets
    we would like to trade as long and short positions. To get there, we first define
    a `CustomFactor` called `MLSignal` that just receives the current return predictions.
    The motivation is to allow us to use some of the convenient `Factor` methods designed
    to rank and filter securities:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的流水线将有两个布尔列，用于标识我们想要作为多头和空头头寸交易的资产。为了达到这个目标，我们首先定义了一个名为`MLSignal`的`CustomFactor`，它只接收当前的回报预测。动机是允许我们使用一些方便的`Factor`方法来对证券进行排名和过滤：
- en: '[PRE17]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can set up our actual pipeline by instantiating `CustomFactor`, which
    requires no arguments other than the defaults provided. We combine its `top()`
    and `bottom()` methods with a filter to select the highest positive and lowest
    negative predictions:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过实例化`CustomFactor`来设置我们的实际流水线，它除了提供的默认值外不需要其他参数。我们将其`top()`和`bottom()`方法与一个过滤器结合起来，以选择最高的正预测和最低的负预测：
- en: '[PRE18]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next step is to initialize our algorithm by defining a few context variables,
    setting transaction cost parameters, performing schedule rebalancing and logging,
    and attaching our pipeline:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是通过定义一些上下文变量来初始化我们的算法，设置交易成本参数，执行计划再平衡和日志记录，并附加我们的流水线：
- en: '[PRE19]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Every day before the market opens, we run our pipeline to obtain the latest
    predictions:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 每天在市场开盘前，我们运行我们的流水线以获得最新的预测：
- en: '[PRE20]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After the market opens, we place orders for our long and short targets and
    close all other positions:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 市场开盘后，我们对我们的多头和空头目标下订单，并平仓所有其他头寸：
- en: '[PRE21]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we are ready to execute our backtest and pass the results to pyfolio:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备执行我们的回测并将结果传递给pyfolio：
- en: '[PRE22]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Figure 8.7* shows the plots for the strategy''s cumulative returns (left panel)
    and the rolling Sharpe ratio, which are comparable to the previous backtrader
    example.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.7*显示了策略累积收益（左侧面板）和滚动夏普比率的图表，这些图表与之前backtrader示例相当。'
- en: 'The backtest only takes around half the time, though:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管回测只需要大约一半的时间：
- en: '![](img/B15439_08_07.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15439_08_07.png)'
- en: 'Figure 8.7: Zipline backtest results'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：Zipline回测结果
- en: The notebook `backtesting_with_zipline` contains the full pyfolio tearsheet
    with additional metrics and plots.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本`backtesting_with_zipline`包含了完整的pyfolio泪表，还有额外的指标和图表。
- en: How to train a model during the backtest
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在回测期间训练模型
- en: 'We can also integrate the model training into our backtest. You can find the
    code for the following end-to-end example of our ML4T workflow in the `ml4t_with_zipline`
    notebook:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将模型训练集成到我们的回测中。您可以在`ml4t_with_zipline`笔记本中找到我们的ML4T工作流端到端示例的代码：
- en: '![](img/B15439_08_08.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15439_08_08.png)'
- en: 'Figure 8.8: Flowchart of Zipline backtest with model training'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：带有模型训练的Zipline回测流程图
- en: The goal is to roughly replicate the ridge regression daily return predictions
    we used earlier and generated in *Chapter 7,* *Linear Models – From Risk Factors
    to Return Forecasts*. We will, however, use a few additional pipeline factors
    to illustrate their usage. The principal new element is a `CustomFactor` that
    receives features and returns them as inputs to train a model and produce predictions.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是粗略复制我们之前使用的岭回归每日回报预测，并在*第7章* *线性模型 - 从风险因素到回报预测*中生成。然而，我们将使用一些额外的流水线因子来说明它们的用法。主要的新元素是一个`CustomFactor`，它接收特征并将它们作为输入来训练模型并产生预测。
- en: Preparing the features – how to define pipeline factors
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备特征 - 如何定义流水线因子
- en: To create a **pipeline factor**, we need one or more input variables, a `window_length`
    that indicates the number of most recent data points for each input and security,
    and the computation we want to conduct.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个**流水线因子**，我们需要一个或多个输入变量，一个`window_length`，表示每个输入和证券的最近数据点的数量，以及我们想要进行的计算。
- en: 'A linear price trend that we estimate using linear regression (see *Chapter
    7,* *Linear Models – From Risk Factors to Return Forecasts*) works as follows:
    we use the 252 latest close prices to compute the regression coefficient on a
    linear time trend:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用线性回归估计的线性价格趋势（请参阅*第7章* *线性模型 - 从风险因素到回报预测*）的工作方式如下：我们使用252个最新的收盘价来计算线性时间趋势上的回归系数：
- en: '[PRE23]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We will use 10 custom and built-in factors as features for our model to capture
    risk factors like momentum and volatility (see notebook `ml4t_with_zipline` for
    details). Next, we'll come up with a `CustomFactor` that trains our model.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用10个自定义和内置因子作为我们模型的特征，以捕捉动量和波动性等风险因素（有关详细信息，请参阅`ml4t_with_zipline`笔记本）。接下来，我们将设计一个训练我们模型的`CustomFactor`。
- en: How to design a custom ML factor
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何设计自定义ML因子
- en: 'Our `CustomFactor`, called `ML`, will have `StandardScaler` and a **stochastic
    gradient descent** (**SGD**) implementation of ridge regression as instance attributes,
    and we will train the model 3 days a week:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CustomFactor`称为`ML`，将具有`StandardScaler`和**随机梯度下降**（**SGD**）实现的岭回归作为实例属性，并且我们将每周训练模型3天：
- en: '[PRE24]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `compute` method generates predictions (addressing potential missing values),
    but first checks if the model should be trained:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`compute`方法生成预测（解决潜在的缺失值），但首先检查模型是否应该被训练：'
- en: '[PRE25]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `_train_model` method is the centerpiece of the puzzle. It shifts the returns
    and aligns the resulting forward returns with the factor features, removing missing
    values in the process. It scales the remaining data points and trains the linear
    `SGDRegressor`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`_train_model`方法是这个谜题的中心。它移动收益并将生成的前瞻性收益与因子特征对齐，同时消除缺失值。它将剩余的数据点进行缩放并训练线性`SGDRegressor`：'
- en: '[PRE26]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `make_ml_pipeline()` function preprocesses and combines the outcome, feature,
    and model parts into a pipeline with a column for predictions:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_ml_pipeline()`函数对结果、特征和模型部分进行预处理和组合，形成一个具有预测列的流水线：'
- en: '[PRE27]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tracking model performance during a backtest
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在回测过程中跟踪模型的表现
- en: 'We obtain new predictions using the `before_trading_start()` function, which
    runs every morning before the market opens:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`before_trading_start()`函数获取新的预测结果，该函数在市场开盘前每天早上运行：
- en: '[PRE28]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`evaluate_predictions` does exactly this: it tracks the past predictions of
    our model and evaluates them once returns for the relevant time horizon materialize
    (in our example, the next day):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`evaluate_predictions`确实做到了这一点：它跟踪我们模型的过去预测，并在相关时间范围内实现收益后对其进行评估（在我们的例子中，是第二天）：'
- en: '[PRE29]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We also record the evaluation on a daily basis so we can review it after the
    backtest:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会每天记录评估结果，这样我们就可以在回测之后进行审查：
- en: '![](img/B15439_08_09.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15439_08_09.png)'
- en: 'Figure 8.9: Model out-of-sample performance'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：模型样本外表现
- en: 'The following plots summarize the backtest performance in terms of the cumulative
    returns and the rolling SR. The results have improved relative to the previous
    example (due to a different feature set), yet the model still underperforms the
    benchmark since mid-2016:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了回测性能的累积收益和滚动SR。由于不同的特征集，结果相对于先前的示例有所改善，但自2016年中期以来，该模型仍然表现不佳：
- en: '![](img/B15439_08_10.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15439_08_10.png)'
- en: 'Figure 8.10: Zipline backtest performance with model training'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：Zipline回测性能与模型训练
- en: Please see the notebook for additional details on how we define a universe,
    run the backtest, and rebalance and analyze the results using pyfolio.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅笔记本，了解我们如何定义一个宇宙，运行回测，并使用pyfolio重新平衡和分析结果的更多细节。
- en: Instead of how to use
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 而不是如何使用
- en: The notebook `ml4t_quantopian` contains an example of how to backtest a strategy
    that uses a simple ML model in the Quantopian research environment. The key benefit
    of using Zipline in the Quantopian cloud is access to many additional datasets,
    including fundamental and alternative data. See the notebook for more details
    on the various factors that we can derive in this context.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本`ml4t_quantopian`包含了一个示例，演示了如何在Quantopian研究环境中使用简单的ML模型进行回测策略。在Quantopian云中使用Zipline的主要好处是可以访问许多额外的数据集，包括基本数据和替代数据。有关我们可以在这种情况下推导出的各种因素的更多细节，请参阅笔记本。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a much closer look at how backtesting works, what challenges
    there are, and how to manage them. We demonstrated how to use the two popular
    backtesting libraries, backtrader and Zipline.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更仔细地研究了回测的工作原理，存在哪些挑战，以及如何管理这些挑战。我们演示了如何使用两个流行的回测库，backtrader和Zipline。
- en: Most importantly, however, we walked through the end-to-end process of designing
    and testing an ML model, showed you how to implement trading logic that acts on
    the signals provided by the model's predictions, and saw how to conduct and evaluate
    backtests. Now, we are ready to continue exploring a much broader and more sophisticated
    array of ML models than the linear regressions we started with.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最重要的是，我们走过了设计和测试ML模型的端到端过程，向您展示了如何实施根据模型预测提供的信号进行交易逻辑，并了解了如何进行和评估回测。现在，我们准备继续探索比我们最初使用的线性回归更广泛和更复杂的ML模型。
- en: The next chapter will cover how to incorporate the time dimension into our models.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍如何将时间维度纳入我们的模型中。
