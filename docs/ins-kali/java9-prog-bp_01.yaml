- en: Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the process of erecting a new building, a set of blueprints helps all related
    parties communicate--the architect, electricians, carpenters, plumbers, and so
    on. It details things such as shapes, sizes, and materials. Without them, each
    of the subcontractors would be left guessing as to what to do, where to do it,
    and how. Without these blueprints, modern architecture would be almost impossible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在建造新建筑的过程中，一套蓝图帮助所有相关方进行沟通--建筑师、电工、木工、管道工等等。它详细说明了形状、大小和材料等细节。如果没有这些蓝图，每个分包商都将被迫猜测该做什么、在哪里做以及如何做。没有这些蓝图，现代建筑几乎是不可能的。
- en: What is in your hands--or on the screen in front of you--is a set of blueprints
    of a different sort. Rather than detailing exactly how to build your specific
    software system, as each project and environment has unique constraints and requirements,
    these blueprints offer examples of how to build a variety of Java-based systems,
    providing examples of how to use specific features in the **Java Development Kit**,
    or **JDK**, with a special focus on the new features of Java 9 that you can then
    apply to your specific problem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你手中的--或者你面前屏幕上的--是一套不同类型的蓝图。与其详细说明如何构建你特定的软件系统，因为每个项目和环境都有独特的约束和要求，这些蓝图提供了如何构建各种基于Java的系统的示例，提供了如何在**Java开发工具包**（或**JDK**）中使用特定功能的示例，特别关注Java
    9的新功能，然后你可以将其应用到你的具体问题上。
- en: Since it would be impossible to build an application using only the new Java
    9 features, we will also be using and highlighting many of the newest features
    in the JDK. Before we get too far into what that entails, then, let's take a brief
    moment to discuss some of these great new features from recent major JDK releases.
    Hopefully, most Java shops are already on Java 7, so we'll focus on version 8
    and, of course, version 9.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于仅使用新的Java 9功能构建应用程序是不可能的，我们还将使用和突出显示JDK中许多最新功能。在我们深入讨论这意味着什么之前，让我们简要讨论一下最近几个主要JDK版本中的一些这些伟大的新功能。希望大多数Java公司已经在Java
    7上，所以我们将专注于版本8，当然还有版本9。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: New features in Java 8
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8中的新功能
- en: New features in Java 9
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9中的新功能
- en: Projects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目
- en: New features in Java 8
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 8中的新功能
- en: Java 8, released on March 8, 2014, brought arguably two of the most significant
    features since Java 5, released in 2004--lambdas and streams. With functional
    programming gaining popularity in the JVM world, especially with the help of languages
    such as Scala, Java adherents had been clamoring for more functional-style language
    features for several years. Originally slated for release in Java 7, the feature
    was dropped from that release, finally seeing a stable release with Java 8.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8于2014年3月8日发布，自2004年发布的Java 5以来，带来了可能是两个最重要的功能--lambda和流。随着函数式编程在JVM世界中日益流行，尤其是在Scala等语言的帮助下，Java的拥护者多年来一直在呼吁更多的函数式语言特性。最初计划在Java
    7中发布，该功能在那个版本中被删除，最终在Java 8中稳定发布。
- en: While it can be hoped that everyone is familiar with Java's lambda support,
    experience has shown that many shops, for a variety of reasons, are slow to adopt
    new language versions and features, so a quick introduction might be helpful.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以希望每个人都熟悉Java的lambda支持，但经验表明，出于各种原因，许多公司都很慢地采用新的语言版本和特性，因此快速介绍可能会有所帮助。
- en: Lambdas
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda
- en: 'The term lambda, which has its roots in lambda calculus, developed by Alonzo
    Church in 1936, simply refers to an anonymous function. Typically, a function
    (or method, in more proper Java parlance), is a statically-named artifact in the
    Java source:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: lambda这个术语源自1936年由阿隆佐·邱奇开发的λ演算，简单地指的是匿名函数。通常，函数（或者更正式的Java术语中的方法）是Java源代码中的一个静态命名的实体：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This simple method is one named `add` that takes two `int` parameters as well
    as returning an `int` parameter. With the introduction of lambdas, this can now
    be written as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的方法是一个名为`add`的方法，它接受两个`int`参数，并返回一个`int`参数。引入lambda后，现在可以这样写：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, more simply as this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更简单地说：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This abbreviated syntax indicates that we have a function that takes two parameters
    and returns their sum. Depending on where this lambda is used, the types of the
    parameters can be inferred by the compiler, making the second, even more concise
    format possible. Most importantly, though, note that this method is no longer
    named. Unless it is assigned to a variable or passed as a parameter (more on this
    later), it can not be referenced--or used--anywhere in the system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简化的语法表明我们有一个函数，它接受两个参数并返回它们的总和。根据这个lambda的使用位置，参数的类型可以被编译器推断出来，使得第二种更简洁的格式成为可能。最重要的是，注意这个方法不再有名称。除非它被分配给一个变量或作为参数传递（稍后会详细介绍），否则它不能被引用--或者在系统中使用。
- en: 'This example, of course, is absurdly simple. A better example of this might
    be in one of the many APIs where the method''s parameter is an implementation
    of what is known as a **Single Abstract Method** (**SAM**) interface, which is,
    at least until Java 8, an interface with a single method. One of the canonical
    examples of a SAM is `Runnable`. Here is an example of the pre-lambda `Runnable`
    usage:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子太简单了。更好的例子可能在许多API中，其中方法的参数是所谓的**单一抽象方法**（**SAM**）接口的实现，至少在Java 8之前，这是一个只有一个方法的接口。单一抽象方法的经典例子之一是`Runnable`。以下是使用lambda之前的`Runnable`用法的示例：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With Java 8 lambdas, this code can be vastly simplified to this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有了Java 8的lambda，这段代码可以被大大简化为：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The body of the `Runnable` method is still pretty trivial, but the gains in
    clarity and conciseness should be pretty obvious.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runnable`方法的主体仍然相当琐碎，但在清晰度和简洁度方面的收益应该是相当明显的。'
- en: 'While lambdas are anonymous functions (that is, they have no names), Java lambdas,
    as is the case in many other languages, can also be assigned to variables and
    passed as parameters (indeed, the functionality would be almost worthless without
    this capability). Revisiting the `Runnable` method in the preceding code, we can
    separate the declaration and the use of `Runnable` as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然lambda是匿名函数（即，它们没有名称），但是在Java中，就像许多其他语言一样，lambda也可以被分配给变量并作为参数传递（实际上，如果没有这种能力，功能几乎没有价值）。重新访问前面代码中的`Runnable`方法，我们可以将声明和使用`Runnable`分开如下：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is intentionally more verbose than the preceding example. The stubbed out
    body of the `Runnable` method is intended to mimic, after a fashion, how a real-world
    `Runnable` may look and why one may want to assign the newly-defined `Runnable`
    method to a variable in spite of the conciseness that lambdas offer. This new
    lambda syntax allows us to declare the body of the `Runnable` method without having
    to worry about method names, signatures, and so on. It is true that any decent
    IDE would help with this kind of boilerplate, but this new syntax gives you, and
    the countless developers who will maintain your code, much less noise to have
    to parse when debugging the code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这比前面的例子更加冗长是有意的。`Runnable`方法的存根体意在模仿，以某种方式，一个真实的`Runnable`可能看起来的样子，以及为什么人们可能希望将新定义的`Runnable`方法分配给一个变量，尽管lambda提供了简洁性。这种新的lambda语法允许我们声明`Runnable`方法的主体，而不必担心方法名称、签名等。虽然任何像样的IDE都会帮助处理这种样板，但这种新语法给你和将来会维护你的代码的无数开发人员更少的噪音来调试代码。
- en: Any SAM interface can be written as a lambda. Do you have a comparator that
    you really only need to use once?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 任何SAM接口都可以被写成lambda。你有一个比较器，你只需要使用一次吗？
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How about `ActionListener`?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionListener`怎么样？'
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Additionally, you can use your own SAM interfaces in lambdas as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以在lambda中使用自己的SAM接口，如下所示：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: One of the advantages of this approach is that it not only makes the consuming
    code more concise, but it also reduces the level of effort, such as it is, in
    creating some of these concrete SAM instances. That is to say, rather than having
    to decide between an anonymous class and a concrete, named class, the developer
    can declare it inline, cleanly and concisely.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点之一是它不仅使消费代码更加简洁，而且还减少了创建一些具体SAM实例的努力水平。也就是说，开发人员不必再在匿名类和具体命名类之间做选择，可以在内联中声明它，干净而简洁。
- en: 'In addition to the SAMs Java developers have been using for years, Java 8 introduced
    a number of functional interfaces to help facilitate more functional style programming.
    The Java 8 Javadoc lists 43 different interfaces. Of these, there are a handful
    of basic function **shapes** that you should know of, some of which are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Java开发人员多年来一直在使用的SAM之外，Java 8还引入了许多功能接口，以帮助促进更多的函数式编程风格。Java 8的Javadoc列出了43个不同的接口。其中，有一些基本的函数**形状**，你应该知道其中一些如下：
- en: '| `BiConsumer<T,U>` | This represents an operation that accepts two input arguments
    and returns no result |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `BiConsumer<T,U>` | 这代表了接受两个输入参数并且不返回结果的操作 |'
- en: '| `BiFunction<T,U,R>` | This represents a function that accepts two arguments
    and produces a result |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `BiFunction<T,U,R>` | 这代表了一个接受两个参数并产生结果的函数 |'
- en: '| `BinaryOperator<T>` | This represents an operation upon two operands of the
    same type, producing a result of the same type as the operands |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `BinaryOperator<T>` | 这代表了对两个相同类型的操作数进行操作，产生与操作数相同类型的结果 |'
- en: '| `BiPredicate<T,U>` | This represents a predicate (Boolean-valued function)
    of two arguments |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `BiPredicate<T,U>` | 这代表了一个接受两个参数的谓词（布尔值函数） |'
- en: '| `Consumer<T>` | This represents an operation that accepts a single input
    argument and returns no result |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `Consumer<T>` | 这代表了接受单个输入参数并且不返回结果的操作 |'
- en: '| `Function<T,R>` | This represents a function that accepts one argument and
    produces a result |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `Function<T,R>` | 这代表了一个接受一个参数并产生结果的函数 |'
- en: '| `Predicate<T>` | This represents a predicate (Boolean-valued function) of
    one argument |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `Predicate<T>` | 这代表了一个接受一个参数的谓词（布尔值函数）|'
- en: '| `Supplier<T>` | This represents a supplier of results |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `Supplier<T>` | 这代表了一个结果的供应者 |'
- en: There are a myriad of uses for these interfaces, but perhaps the best way to
    demonstrate some of them is to turn our attention to the next big feature in Java
    8--Streams.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口有无数的用途，但也许展示其中一些最好的方法是把我们的注意力转向Java 8的下一个重大特性--Streams。
- en: Streams
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流
- en: The other major addition to Java 8, and, perhaps where lambdas shine the brightest,
    is the new **Streams API**. If you were to search for a definition of Java streams,
    you would get answers that range from the somewhat circular **a stream of data
    elements** to the more technical **Java streams are monads**, and they're probably
    both right. The Streams API allows the Java developer to interact with a stream
    of data elements via a **sequence of steps**. Even putting it that way isn't as
    clear as it could be, so let's see what it means by looking at some sample code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8的另一个重大增强，也许是lambda发挥最大作用的地方，是新的**Streams API**。如果你搜索Java流的定义，你会得到从有些循环的**数据元素流**到更技术性的**Java流是单子**的答案，它们可能都是正确的。Streams
    API允许Java开发人员通过一系列步骤与数据元素流进行交互。即使这样说也不够清晰，所以让我们通过查看一些示例代码来看看它的含义。
- en: 'Let''s say you have a list of grades for a particular class. You would like
    to know what the average grade is for the girls in the class. Prior to Java 8,
    you might have written something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个特定班级的成绩列表。你想知道班级中女生的平均成绩是多少。在Java 8之前，你可能会写出类似这样的代码：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We initialize two variables, one to store the sums and one to count the number
    of hits. Next, we loop through the grades. If the student''s gender is female,
    we increment our counter and update the sum. When the loop terminates, we then
    have the information we need to calculate the average. This works, but it''s a
    bit verbose. The new Streams API can help with that:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化两个变量，一个用于存储总和，一个用于计算命中次数。接下来，我们循环遍历成绩。如果学生的性别是女性，我们增加计数器并更新总和。当循环终止时，我们就有了计算平均值所需的信息。这样做是可以的，但有点冗长。新的Streams
    API可以帮助解决这个问题：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This new version is not significantly smaller, but the purpose of the code
    is much clearer. In the preceding pre-stream code, we have to play computer, parsing
    the code and teasing out its intended purpose. With streams, we have a clear,
    declarative means to express application logic. For each entry in the map do the
    following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新版本并没有显著变小，但代码的目的更加清晰。在之前的预流代码中，我们必须扮演计算机的角色，解析代码并揭示其预期目的。有了流，我们有了一个清晰的、声明性的方式来表达应用逻辑。对于映射中的每个条目，执行以下操作：
- en: Filter out each entry whose `gender` is not `F`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤掉`gender`不是`F`的每个条目。
- en: Map each value to the primitive int.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个值映射为原始int。
- en: Average the grades.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算平均成绩。
- en: Return the value as a double.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以double形式返回值。
- en: With the stream-based and lamba-based approach, we don't need to declare temporary,
    intermediate variables (grade count and total), and we don't need to worry about
    calculating the admittedly simple average. The JDK does all of the heavy-lifting
    for us.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有了基于流和lambda的方法，我们不需要声明临时的中间变量（成绩计数和总数），也不需要担心计算明显简单的平均值。JDK为我们完成了所有繁重的工作。
- en: The new java.time package
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的java.time包
- en: 'While lambdas and streams are extremely important game-changing updates, with
    Java 8, we were given another long-awaited change that was, at least in some circles,
    just as exciting: a new date/time API. Anyone who has worked with dates and times
    in Java knows the pain of `java.util.Calendar` and company. Clearly, you can get
    your work done, but it''s not always pretty. Many developers found the API too
    painful to use, so they integrated the extremely popular Joda Time library into
    their projects. The Java architects agreed, and engaged Joda Time''s author, Stephen
    Colebourne, to lead JSR 310, which brought a version of Joda Time (fixing various
    design flaws) to the platform. We''ll take a detailed look at how to use some
    of these new APIs in our date/time calculator later in the book.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然lambda和streams是非常重要的改变性更新，但是在Java 8中，我们得到了另一个期待已久的改变，至少在某些领域中同样令人兴奋：一个新的日期/时间API。任何在Java中使用日期和时间的人都知道`java.util.Calendar`等的痛苦。显然，你可以完成工作，但并不总是美观的。许多开发人员发现API太痛苦了，所以他们将极其流行的Joda
    Time库集成到他们的项目中。Java的架构师们同意了，并邀请了Joda Time的作者Stephen Colebourne来领导JSR 310，这将Joda
    Time的一个版本（修复了各种设计缺陷）引入了平台。我们将在本书后面详细介绍如何在我们的日期/时间计算器中使用一些这些新的API。
- en: Default methods
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认方法
- en: 'Before turning our attention to Java 9, let''s take a look at one more significant
    language feature: default methods. Since the beginning of Java, an interface was
    used to define how a class looks, implying a certain type of behavior, but was
    unable to implement that behavior. This made polymorphism much simpler in a lot
    of cases, as any number of classes could implement a given interface, and the
    consuming code treats them as that interface, rather than whatever concrete class
    they actually are.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将注意力转向Java 9之前，让我们再看看另一个重要的语言特性：默认方法。自Java开始以来，接口被用来定义类的外观，暗示一种特定的行为，但无法实现该行为。在许多情况下，这使得多态性变得更简单，因为任意数量的类都可以实现给定的接口，并且消费代码将它们视为该接口，而不是它们实际上是什么具体类。
- en: One of the problems that have confronted API developers over the years, though,
    was how to evolve an API and its interfaces without breaking existing code. For
    example, take the `ActionSource` interface from the JavaServer Faces 1.1 specification.
    When the JSF 1.2 expert group was working on the next revision of the specification,
    they identified the need to add a new property to the interface, which would result
    in two new methods--the getters and setters. They could not simply add the methods
    to the interface, as that would break every implementation of the specification,
    requiring the maintainers of the implementation to update their classes. Obviously,
    this sort of breakage is unacceptable, so JSF 1.2 introduced `ActionSource2`,
    which extends `ActionSource` and adds the new methods. While this approach is
    considered ugly by many, the 1.2 expert group had a few choices, and none of them
    were very good.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，API开发人员面临的问题之一是如何在不破坏现有代码的情况下发展API及其接口。例如，考虑JavaServer Faces 1.1规范中的`ActionSource`接口。当JSF
    1.2专家组在制定规范的下一个修订版时，他们确定需要向接口添加一个新属性，这将导致两个新方法——getter和setter。他们不能简单地将方法添加到接口中，因为那样会破坏规范的每个实现，需要实现者更新他们的类。显然，这种破坏是不可接受的，因此JSF
    1.2引入了`ActionSource2`，它扩展了`ActionSource`并添加了新方法。虽然许多人认为这种方法很丑陋，但1.2专家组有几种选择，而且都不是很好的选择。
- en: 'With Java 8, though, interfaces can now specify a default method on the interface
    definition, which the compiler will use for the method implementation if the extending
    class does not provide one. Let''s take the following piece of code as an example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过Java 8，接口现在可以在接口定义上指定默认方法，如果扩展类没有提供方法实现，编译器将使用该默认方法。让我们以以下代码片段为例：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We''ve developed our API and made it available to the public, and it''s proved
    to be really popular. Over time, though, we''ve identified an improvement we''d
    like to make: we''d like to add some convenience methods, such as `sayHello()`
    and `sayGoodbye()`, to save our users a little time. However, as discussed earlier,
    if we just add these new methods to the interface, we''ll break our users'' code
    as soon as they update to the new version of the library. Default methods allow
    us to extend the interface and avoid the breakage by defining an implementation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发了我们的API并向公众提供了它，它被证明非常受欢迎。随着时间的推移，我们发现了一个我们想要做出的改进：我们想要添加一些便利方法，比如`sayHello()`和`sayGoodbye()`，以节省我们的用户一些时间。然而，正如前面讨论的那样，如果我们只是将这些新方法添加到接口中，一旦他们更新到库的新版本，我们就会破坏我们用户的代码。默认方法允许我们扩展接口，并通过定义一个实现来避免破坏：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, when users update their library JARs, they immediately gain these new methods
    and their behavior, without making any changes. Of course, to use these methods,
    the users will need to modify their code, but they need not do so until--and if--they
    want to.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户更新他们的库JAR时，他们立即获得这些新方法及其行为，而无需进行任何更改。当然，要使用这些方法，用户需要修改他们的代码，但他们不需要在想要使用之前这样做。
- en: New features in Java 9
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9中的新功能
- en: As with any new version of the JDK, this release was packed with a lot of great
    new features. Of course, what is most appealing will vary based on your needs,
    but we'll focus specifically on a handful of these new features that are most
    relevant to the projects we'll build together. First up is the most significant,
    the Java Module System.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与JDK的任何新版本一样，这个版本也充满了许多很棒的新功能。当然，最吸引人的是基于您的需求而变化的，但我们将专注于一些最相关于我们将共同构建的项目的这些新功能。首先是最重要的，Java模块系统。
- en: Java Platform Module System/Project Jigsaw
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java平台模块系统/项目Jigsaw
- en: Despite being a solid, feature-packed release, Java 8 was considered by a fair
    number to be a bit disappointing. It lacked the much anticipated **Java Platform
    Module System** (**JPMS**), also known more colloquially, though not quite accurately,
    as Project Jigsaw. The Java Platform Module System was originally slated to ship
    with Java 7 in 2011, but it was deferred to Java 8 due to some lingering technical
    concerns. Project Jigsaw was started not only to finish the module system, but
    also to modularize the JDK itself, which would help Java SE scale down to smaller
    devices, such as mobile phones and embedded systems. Jigsaw was scheduled to ship
    with Java 8, which was released in 2014, but it was deferred yet again, as the
    Java architects felt they still needed more time to implement the system correctly.
    At long last, though, Java 9 will finally deliver this long-promised project.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Java 8是一个功能丰富的稳定版本，但许多人认为它有点令人失望。它缺乏备受期待的**Java平台模块系统**（**JPMS**），也更为通俗，尽管不太准确地称为项目Jigsaw。Java平台模块系统最初计划在2011年的Java
    7中发布，但由于一些悬而未决的技术问题，它被推迟到了Java 8。Jigsaw项目不仅旨在完成模块系统，还旨在将JDK本身模块化，这将有助于Java SE缩小到更小的设备，如手机和嵌入式系统。Jigsaw原计划在2014年发布的Java
    8中发布，但由于Java架构师认为他们仍需要更多时间来正确实现系统，因此又一次推迟了。不过，最终，Java 9将终于交付这个长期承诺的项目。
- en: That said, what exactly is it? One problem that has long haunted API developers,
    including the JDK architects, is the inability to hide implementation details
    of public APIs. A good example from the JDK of private classes that developers
    should not be using directly is the `com.sun.*/sun.*` packages and classes. A
    perfect example of this--of private APIs finding widespread public use--is the
    `sun.misc.Unsafe` class. Other than a strongly worded warning in Javadoc about
    not using these internal classes, there's little that could be done to prevent
    their use. Until now.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，它到底是什么？长期以来困扰API开发人员的一个问题，包括JDK架构师在内，就是无法隐藏公共API的实现细节。JDK中一个很好的例子是开发人员不应直接使用的私有类`com.sun.*/sun.*`包和类。私有API广泛公开使用的一个完美例子是`sun.misc.Unsafe`类。除了在Javadoc中强烈警告不要使用这些内部类之外，几乎没有什么可以阻止它们的使用。直到现在。
- en: With the JPMS, developers will be able to make implementation classes public
    so that they may be easily used inside their projects, but not expose them outside
    the module, meaning they are not exposed to consumers of the API or library. To
    do this, the Java architects have introduced a new file, `module-info.java`, similar
    to the existing `package-info.java` file, found at the root of the module, for
    example, at `src/main/java/module-info.java`. It is compiled to `module-info.class`,
    and is available at runtime via reflection and the new `java.lang.Module` class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有了JPMS，开发人员将能够使实现类公开，以便它们可以在其项目内轻松使用，但不将它们暴露给模块外部，这意味着它们不会暴露给API或库的消费者。为此，Java架构师引入了一个新文件`module-info.java`，类似于现有的`package-info.java`文件，位于模块的根目录，例如`src/main/java/module-info.java`。它被编译为`module-info.class`，并且可以通过反射和新的`java.lang.Module`类在运行时使用。
- en: 'So what does this file do, and what does it look like? Java developers can
    use this file to name the module, list its dependencies, and express to the system,
    both compile and runtime, which packages are exported to the world. For example,
    suppose, in our preceding stream example, we have three packages: `model`, `api`,
    and `impl`. We want to expose the models and the API classes, but not any of the
    implementation classes. Our `module-info.java` file may look something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这个文件是做什么的，它是什么样子的？Java开发人员可以使用这个文件来命名模块，列出其依赖关系，并向系统表达，无论是编译时还是运行时，哪些包被导出到世界上。例如，假设在我们之前的流示例中，我们有三个包：`model`，`api`和`impl`。我们想要公开模型和API类，但不公开任何实现类。我们的`module-info.java`文件可能看起来像这样：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This definition exposes the two packages we want to export, and also declares
    a dependency on the `com.foo` module. If this module is not available at compile-time,
    the project will not build, and if it is not available at runtime, the system
    will throw an exception and exit. Note that the `requires` statement does not
    specify a version. This is intentional, as it was decided not to tackle the version-selection
    issue as part of the module system, leaving that to more appropriate systems,
    such as build tools and containers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义暴露了我们想要导出的两个包，并声明了对`com.foo`模块的依赖。如果这个模块在编译时不可用，项目将无法构建，如果在运行时不可用，系统将抛出异常并退出。请注意，`requires`语句没有指定版本。这是有意的，因为决定不将版本选择问题作为模块系统的一部分来解决，而是留给更合适的系统，比如构建工具和容器。
- en: Much more could be said about the module system, of course, but an exhaustive
    discussion of all of its features and limitations is beyond the scope of this
    book. We will be implementing our applications as modules, though, so we'll see
    the system used--and perhaps explained in a bit more detail--throughout the book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，关于模块系统还可以说更多，但对其所有功能和限制的详尽讨论超出了本书的范围。我们将把我们的应用程序实现为模块，因此我们将在整本书中看到这个系统的使用——也许会更详细地解释一下。
- en: Those wanting a more in-depth discussion of the Java Platform Module System
    can search for the article, *The State of the Module System*, by Mark Reinhold.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 想要更深入讨论Java平台模块系统的人可以搜索马克·莱恩霍尔德的文章《模块系统的现状》。
- en: Process handling API
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程处理API
- en: 'In prior versions of Java, developers interacting with native operating system
    processes had to use a fairly limited API, with some operations requiring resorting
    to native code. As part of **Java Enhancement Proposal** (**JEP**) 102, the Java
    process API was extended with the following features (quoting from the JEP text):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的Java版本中，与本地操作系统进程交互的开发人员必须使用一个相当有限的API，一些操作需要使用本地代码。作为**Java Enhancement
    Proposal**（**JEP**）102的一部分，Java进程API被扩展了以下功能（引用自JEP文本）：
- en: The ability to get the pid (or equivalent) of the current Java virtual machine
    and the pid of processes created with the existing API.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前Java虚拟机的pid（或等效值）以及使用现有API创建的进程的pid。
- en: The ability to enumerate processes on the system. Information on each process
    may include its pid, name, state, and perhaps resource usage.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举系统上的进程的能力。每个进程的信息可能包括其pid、名称、状态，以及可能的资源使用情况。
- en: The ability to deal with process trees; in particular, some means to destroy
    a process tree.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理进程树的能力；特别是一些销毁进程树的方法。
- en: The ability to deal with hundreds of subprocesses, perhaps multiplexing the
    output or error streams to avoid creating a thread per subprocess.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数百个子进程的能力，可能会将输出或错误流多路复用，以避免为每个子进程创建一个线程。
- en: We will explore these API changes in our first project, the Process Viewer/Manager
    (see the following sections for details).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的第一个项目中探索这些API的变化，即进程查看器/管理器（详细信息请参见以下各节）。
- en: Concurrency changes
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发变化
- en: 'As was done in Java 7, the Java architects revisited the concurrency libraries,
    making some much needed changes, this time in order to support the reactive-streams
    specification. These changes include a new class, `java.util.concurrent.Flow`,
    with several nested interfaces: `Flow.Processor`, `Flow.Publisher`, `Flow.Subscriber`,
    and `Flow.Subscription`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java 7中所做的一样，Java架构师重新审视了并发库，做出了一些非常需要的改变，这一次是为了支持反应式流规范。这些变化包括一个新的类，`java.util.concurrent.Flow`，带有几个嵌套接口：`Flow.Processor`、`Flow.Publisher`、`Flow.Subscriber`和`Flow.Subscription`。
- en: REPL
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REPL
- en: 'One change that seems to excite a lot of people isn''t a language change at
    all. It''s the addition of a **REPL** (**Read-Eval-Print-Loop**), a fancy term
    for a language shell. In fact, the command for this new tool is `jshell`. This
    tool allows us to type or paste in Java code and get immediate feedback. For example,
    if we wanted to experiment with the Streams API discussed in the preceding section,
    we could do something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个似乎激动了很多人的变化并不是语言上的改变。它是增加了一个**REPL**（**读取-求值-打印-循环**），这是一个对语言外壳的花哨术语。事实上，这个新工具的命令是`jshell`。这个工具允许我们输入或粘贴Java代码并立即得到反馈。例如，如果我们想要尝试前一节讨论的Streams
    API，我们可以这样做：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a very welcome addition that should help Java developers rapidly prototype
    and test their ideas.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常受欢迎的补充，应该有助于Java开发人员快速原型和测试他们的想法。
- en: Projects
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目
- en: With that brief and high-level overview of what new features are available to
    use, what do these blueprints we'll cover look like? We'll build ten different
    applications, varying in complexity and kind, and covering a wide range of concerns.
    With each project, we'll pay special attention to the new features we're highlighting,
    but we'll also see some older, tried and true language features and libraries
    used extensively, with any interesting or novel usages flagged. Here, then, is
    our project lineup.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简短而高层次的概述，我们可以看到有哪些新功能可以使用，那么我们将要涵盖的这些蓝图是什么样的呢？我们将构建十个不同的应用程序，涉及各种复杂性和种类，并涵盖各种关注点。在每个项目中，我们将特别关注我们正在突出的新功能，但我们也会看到一些旧的、经过验证的语言特性和广泛使用的库，其中任何有趣或新颖的用法都会被标记出来。因此，这是我们的项目阵容。
- en: Process Viewer/Manager
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程查看器/管理器
- en: We will explore some of the improvements to the process handling APIs as we
    implement a Java version of the age old Unix tool--**top**. Combining this API
    with JavaFX, we'll build a graphical tool that allows the user to view and manage
    processes running on the system.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现一个Java版本的古老的Unix工具——**top**时，我们将探索一些进程处理API的改进。结合这个API和JavaFX，我们将构建一个图形工具，允许用户查看和管理系统上运行的进程。
- en: 'This project will cover the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将涵盖以下内容：
- en: Java 9 Process API enhancements
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9进程API增强
- en: JavaFX
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: Duplicate File Finder
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复文件查找器
- en: As a system ages, the chances of clutter in the filesystem, especially duplicated
    files, increases exponentially, it seems. Leveraging some of the new File I/O
    libraries, we'll build a tool to scan a set of user-specified directories to identify
    duplicates. Pulling JavaFX back out of the toolbox, we'll add a graphical user
    interface that will provide a more user-friendly means to interactively process
    the duplicates.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的老化，文件系统中杂乱的机会，特别是重复的文件，似乎呈指数增长。利用一些新的文件I/O库，我们将构建一个工具，扫描一组用户指定的目录以识别重复项。我们将从工具箱中取出JavaFX，添加一个图形用户界面，以提供更加用户友好的交互式处理重复项的方式。
- en: 'This project will cover the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将涵盖以下内容：
- en: Java File I/O
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java文件I/O
- en: Hashing libraries
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希库
- en: JavaFX
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: Date Calculator
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期计算器
- en: 'With the release of Java 8, Oracle integrated a new library based on a redesign
    of Joda Time, more or less, into the JDK. Officially known as JSR 310, this new
    library fixed a longstanding complaint with the JDK--the official date libraries
    were inadequate and hard to use. In this project, we''ll build a simple command-line
    date calculator that will take a date and, for example, add an arbitrary amount
    of time to it. Consider the following piece of code for example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Java 8的发布，Oracle集成了一个基于Joda Time重新设计的新库到JDK中。这个新库被官方称为JSR 310，它解决了JDK的一个长期的问题——官方的日期库不够充分且难以使用。在这个项目中，我们将构建一个简单的命令行日期计算器，它将接受一个日期，并且例如添加任意数量的时间。例如，考虑以下代码片段：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This project will cover the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将涵盖以下内容：
- en: Java 8 Date/Time APIs
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8日期/时间API
- en: Regular expressions
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Java command-line libraries
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java命令行库
- en: Social Media Aggregator
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社交媒体聚合器
- en: 'One of the problems with having accounts on so many social media networks is
    keeping tabs on what''s happening on each of them. With accounts on Twitter, Facebook,
    Google+, Instagram, and so on, active users can spend a significant amount of
    time jumping from site to site, or app to app, reading the latest updates. In
    this chapter, we''ll build a simple aggregator app that will pull the latest updates
    from each of the user''s social media accounts and display them in one place.
    The features will include the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多社交媒体网络上拥有帐户的问题之一是难以跟踪每个帐户上发生的情况。拥有Twitter、Facebook、Google+、Instagram等帐户的活跃用户可能会花费大量时间从一个站点跳转到另一个站点，或者从一个应用程序跳转到另一个应用程序，阅读最新的更新。在本章中，我们将构建一个简单的聚合应用程序，从用户的每个社交媒体帐户中获取最新的更新，并在一个地方显示它们。功能将包括以下内容：
- en: 'Multiple accounts for a variety of social media networks:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种社交媒体网络的多个帐户：
- en: Twitter
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter
- en: Pinterest
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pinterest
- en: Instagram
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Instagram
- en: Read-only, rich listings of social media posts
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读的、丰富的社交媒体帖子列表
- en: Links to the appropriate site or app for a quick and easy follow-up
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接到适当的站点或应用程序，以便快速简便地进行后续跟进
- en: Desktop and mobile versions
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面和移动版本
- en: 'This project will cover the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将涵盖以下内容：
- en: REST/HTTP clients
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST/HTTP客户端
- en: JSON processing
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON处理
- en: JavaFX and Android development
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX和Android开发
- en: 'Given the size and scope of this effort, we''ll actually do this in two chapters:
    JavaFX in the first, and Android in the second.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一努力的规模和范围，我们将在两章中实际完成这个项目：第一章是JavaFX，第二章是Android。
- en: Email filter
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件过滤
- en: Managing email can be tricky, especially if you have more than one account.
    If you access your mail from more than one location (that is, from more than one
    desktop or mobile app), managing your email rules can be trickier still. If your
    mail system doesn't support rules stored on the server, you're left deciding where
    to put the rules so that they'll run most often. With this project, we'll develop
    an application that will allow us to author a variety of rules and then run them
    via an optional background process to keep your mail properly curated at all times.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 管理电子邮件可能会很棘手，特别是如果你有多个帐户。如果您从多个位置访问邮件（即从多个桌面或移动应用程序），管理您的电子邮件规则可能会更加棘手。如果您的邮件系统不支持存储在服务器上的规则，您将不得不决定在哪里放置规则，以便它们最常运行。通过这个项目，我们将开发一个应用程序，允许我们编写各种规则，然后通过可选的后台进程运行它们，以保持您的邮件始终得到适当的管理。
- en: 'A sample `rules` file may look something like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个样本`rules`文件可能看起来像这样：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This project will cover the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将涵盖以下内容：
- en: JavaMail
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaMail
- en: JavaFX
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: JSON Processing
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON处理
- en: Operating System integration
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统集成
- en: File I/O
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件I/O
- en: JavaFX photo management
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaFX照片管理
- en: The Java Development Kit has a very robust assortment of image handling APIs.
    In Java 9, these were augmented with improved support for the TIFF specification.
    In this chapter, we'll exercise this API in creating an image/photo management
    application. We'll add support for importing images from user-specified locations
    into the configured official directory. We'll also revisit the duplicate file
    finder and reuse some of the code developed as a part of the project to help us
    identify duplicate images.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Java开发工具包有一个非常强大的图像处理API。在Java 9中，这些API得到了改进，增强了对TIFF规范的支持。在本章中，我们将使用这个API创建一个图像/照片管理应用程序。我们将添加支持从用户指定的位置导入图像到配置的官方目录。我们还将重新访问重复文件查找器，并重用作为项目一部分开发的一些代码，以帮助我们识别重复的图像。
- en: 'This project will cover the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将涵盖以下内容：
- en: The new `javax.imageio` package
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`javax.imageio`包
- en: JavaFX
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: NetBeans Rich Client Platform
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetBeans丰富的客户端平台
- en: Java file I/O
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java文件I/O
- en: A client/server note application
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端/服务器笔记应用程序
- en: Have you ever used a cloud-based note-taking application? Have you wondered
    what it would take to make your own? In this chapter, we'll create such an application,
    with complete front and backends. On the server side, we'll store our data in
    the ever popular document database, MongoDB, and we'll expose the appropriate
    parts of the business logic for the application via REST interfaces. On the client
    side, we'll develop a very basic user interface in JavaScript that will let us
    experiment with, and demonstrate how to use, JavaScript in our Java project.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经使用过基于云的笔记应用？您是否想知道制作自己的笔记应用需要什么？在本章中，我们将创建这样一个应用程序，包括完整的前端和后端。在服务器端，我们将把数据存储在备受欢迎的文档数据库MongoDB中，并通过REST接口公开应用程序的业务逻辑的适当部分。在客户端，我们将使用JavaScript开发一个非常基本的用户界面，让我们可以尝试并演示如何在我们的Java项目中使用JavaScript。
- en: 'This project will cover the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目将涵盖以下内容：
- en: Document databases (MongoDB)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档数据库（MongoDB）
- en: JAX-RS and RESTful interfaces
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RS和RESTful接口
- en: JavaFX
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: JavaScript and Vue 2
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript和Vue 2
- en: Serverless Java
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器Java
- en: Serverless, also known as **function as a service** (**FaaS**), is one of the
    hottest trends these days. It is an application/deployment model where a small
    function is deployed to a service that manages almost every aspect of the function--startup,
    shutdown, memory, and so on, freeing the developer from worrying about such details.
    In this chapter, we'll write a simple serverless Java application to see how it
    might be done, and how you might use this new technique for your own applications.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器，也被称为**函数即服务**（**FaaS**），是当今最热门的趋势之一。这是一种应用/部署模型，其中一个小函数部署到一个服务中，该服务几乎管理函数的每个方面——启动、关闭、内存等，使开发人员不必担心这些细节。在本章中，我们将编写一个简单的无服务器Java应用程序，以了解如何完成，以及如何在自己的应用程序中使用这种新技术。
- en: 'This project will cover the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目将涵盖以下内容：
- en: Creating an Amazon Web Services account
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Amazon Web Services账户
- en: Configuring AWS Lambda, Simple Notification Service, Simple Email Service, and
    DynamoDB
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置AWS Lambda、简单通知服务、简单邮件服务和DynamoDB
- en: Writing and deploying a Java function
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和部署Java函数
- en: Android desktop synchronization client
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android桌面同步客户端
- en: 'With this project, we''ll change gears a little bit and focus specifically
    on a different part of the Java ecosystem: Android. To do this, we''ll focus on
    a problem that still plagues some Android users--the synchronization of an Android
    device and a desktop (or laptop) system. While various cloud providers are pushing
    us to store more and more in the cloud and streaming that to devices, some people
    still prefer to store, for example, photos and music directly on the device for
    a variety of reasons, ranging from cost for cloud resources to unreliable wireless
    connectivity and privacy concerns.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个项目，我们将稍微改变方向，专注于Java生态系统的另一个部分：Android。为了做到这一点，我们将专注于一个仍然困扰一些Android用户的问题——Android设备与桌面（或笔记本电脑）系统的同步。虽然各种云服务提供商都在推动我们将更多内容存储在云端并将其流式传输到设备上，但一些人仍然更喜欢直接在设备上存储照片和音乐，原因各种各样，从云资源成本到不稳定的无线连接和隐私问题。
- en: In this chapter, we'll build a system that will allow users to synchronize music
    and photos between their devices and their desktop or laptop. We'll build an Android
    application that provides the user interface to configure and monitor synchronization
    from the mobile device side as well as the Android Service that will perform the
    synchronization in the background, if desired. We will also build the related
    components on the desktop--a graphical application to configure and monitor the
    process from the desktop as well as a background process to handle the synchronization
    from the desktop side.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个系统，允许用户在他们的设备和桌面或笔记本电脑之间同步音乐和照片。我们将构建一个Android应用程序，提供用户界面来配置和监视从移动设备端进行同步，以及在后台执行同步的Android服务（如果需要）。我们还将在桌面端构建相关组件——一个图形应用程序来配置和监视来自桌面端的同步过程，以及一个后台进程来处理来自桌面端的同步。
- en: 'This project will cover the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目将涵盖以下内容：
- en: Android
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android
- en: User interfaces
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面
- en: Services
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: JavaFX
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: REST
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST
- en: Getting started
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'We have taken a quick look at some of the new language features we will be
    using. We have also seen a quick overview of the projects we will be building.
    One final question remains: what tools will we be using to do our work?'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经快速浏览了一些我们将要使用的新语言特性。我们也简要概述了我们将要构建的项目。最后一个问题仍然存在：我们将使用什么工具来完成我们的工作？
- en: The Java ecosystem suffers from an embarrassment of riches when it comes to
    development tools, so we have much to choose from. The most fundamental choice
    facing us is the build tool. For our work here, we will be using Maven. While
    there is a strong and vocal community that would advocate Gradle, Maven seems
    to be the most common build tool at the moment, and seems to have more robust,
    mature, and native support from the major IDEs. If you do not have Maven already
    installed, you can visit [http://maven.apache.org](http://maven.apache.org/) and
    download the distribution for your operating system, or use whatever package management
    system is supported by your OS.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到开发工具时，Java生态系统拥有丰富的选择，因此我们有很多选择。我们面临的最基本的选择是构建工具。在这里，我们将使用Maven。虽然有一个强大而有声望的社区支持Gradle，但Maven似乎是目前最常见的构建工具，并且似乎得到了主要IDE的更健壮、更成熟和更本地的支持。如果您尚未安装Maven，您可以访问[http://maven.apache.org](http://maven.apache.org/)并下载适合您操作系统的分发版，或者使用您的操作系统支持的任何软件包管理系统。
- en: For the IDE, all screenshots, directions, and so forth will be using NetBeans--the
    free and open source IDE from Oracle. There are, of course, proponents of both
    IntelliJ IDEA and Eclipse, and they're both fine choices, but NetBeans offers
    a complete and robust development out-of-the-box, and it's fast, stable, and free.
    To download NetBeans, visit [http://netbeans.org](http://netbeans.org/) and download
    the appropriate installer for your operating system. Since we are using Maven,
    which IDEA and Eclipse both support, you should be able to open the projects presented
    here in the IDE of your choice. Where steps are shown in the GUI, though, you
    will need to adjust for the IDE you've chosen.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IDE，所有的截图、指导等都将使用NetBeans——来自Oracle的免费开源IDE。当然，也有IntelliJ IDEA和Eclipse的支持者，它们都是不错的选择，但是NetBeans提供了一个完整而强大的开发工具，并且快速、稳定且免费。要下载NetBeans，请访问[http://netbeans.org](http://netbeans.org/)并下载适合您操作系统的安装程序。由于我们使用Maven，而IDEA和Eclipse都支持，您应该能够在您选择的IDE中打开这里提供的项目。但是，当GUI中显示步骤时，您需要根据您选择的IDE进行调整。
- en: 'At the time of writing, the latest version of NetBeans is 8.2, and the best
    approach for using it to do Java 9 development is to run the IDE on Java 8, and
    to add Java 9 as an SDK. There is a development version of NetBeans that runs
    on Java 9, but, as it is a development version, it can be unstable from time to
    time. A stable NetBeans 9 should ship at roughly the same time as Java 9 itself.
    In the meantime, we''ll push forward with 8.2:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，NetBeans的最新版本是8.2，使用它进行Java 9开发的最佳方法是在Java 8上运行IDE，并将Java 9添加为SDK。有一个可以在Java
    9上运行的NetBeans开发版本，但是由于它是一个开发版本，有时可能不稳定。稳定的NetBeans 9应该会在Java 9本身发布时大致同时推出。与此同时，我们将继续使用8.2：
- en: To add Java 9 support, we will need to add a new Java platform, and we will
    do that by clicking on Tools | Platforms.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加Java 9支持，我们需要添加一个新的Java平台，我们将通过点击“工具”|“平台”来实现。
- en: 'This will bring up the Java Platform Manager screen:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开Java平台管理器屏幕：
- en: '![](img/9212fff4-28c7-4275-9304-ccf89a7720a5.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9212fff4-28c7-4275-9304-ccf89a7720a5.png)'
- en: Click on Add Platform... on the lower left side of your screen.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕左下角的“添加平台”。
- en: '![](img/12d5edc8-c463-425c-9728-8b0ec8225d09.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12d5edc8-c463-425c-9728-8b0ec8225d09.png)'
- en: We want to add a Java Standard Edition platform, so we will accept the default
    and click on Next.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要添加一个Java标准版平台，所以我们将接受默认设置并点击“下一步”。
- en: '![](img/a4bb0f81-3af0-4268-babe-5772f0880e9c.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4bb0f81-3af0-4268-babe-5772f0880e9c.png)'
- en: On the Add Java Platform screen, we will navigate to where we've installed Java
    9, select the JDK directory, and click on Next.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“添加Java平台”屏幕上，我们将导航到我们安装Java 9的位置，选择JDK目录，然后点击“下一步”。
- en: '![](img/0cf9f89c-a226-425c-835a-8b1c7d0b27ef.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cf9f89c-a226-425c-835a-8b1c7d0b27ef.png)'
- en: We need to give the new Java Platform a name (NetBeans defaults to a very reasonable
    JDK 9) so we will click on Finish and can now see our newly added Java 9 option.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要给新的Java平台命名（NetBeans默认为一个非常合理的JDK 9），所以我们将点击“完成”现在可以看到我们新添加的Java 9选项。
- en: '![](img/b1400a67-3da0-4cc6-84f0-820fe8cb437e.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1400a67-3da0-4cc6-84f0-820fe8cb437e.png)'
- en: With the project SDK set, we're ready to take these new Java 9 features for
    a spin, which we'll start doing in [Chapter 2](../Text/139d1d2c-9088-4545-a627-47b619ef035a.xhtml),
    *Managing Processes in Java*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了项目SDK后，我们准备好尝试一下这些新的Java 9功能，我们将从[第2章](../Text/139d1d2c-9088-4545-a627-47b619ef035a.xhtml)“在Java中管理进程”开始进行。
- en: If you do run NetBeans on Java 9, which should be possible by the time this
    book is published, you will already have Java 9 configured. You can, however,
    use the preceding steps to configure Java 8, should you need that version specifically.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Java 9上运行NetBeans，这本书出版时应该是可能的，您将已经配置了Java 9。但是，如果您需要特定版本，可以使用前面的步骤来配置Java
    8。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've taken a quick look at some of the great new features
    in Java 8, including lambdas, streams, the new date/time package, and default
    methods. From Java 9, we took a quick look at the Java Platform Module System
    and Project Jigsaw, the process handling APIs, the new concurrency changes, and
    the new Java REPL. For each, we've discussed the what and why, and looked at some
    examples of how these might affect the systems we write. We've also taken a look
    at the types of project we'll be building throughout the book and the tools we'll
    be using.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速浏览了Java 8中一些出色的新功能，包括lambda、streams、新的日期/时间包和默认方法。从Java 9开始，我们快速浏览了Java平台模块系统和项目Jigsaw、进程处理API、新的并发更改以及新的Java
    REPL。对于每个功能，我们都讨论了“是什么”和“为什么”，并查看了一些示例，了解了它们可能如何影响我们编写的系统。我们还看了一下本书中将要构建的项目类型和我们将要使用的工具。
- en: Before we move on, I'd like to restate an earlier point--every software project
    is different, so it is not possible to write this book in such a way that you
    can simply copy and paste large swathes of code into your project. Similarly,
    every developer writes code differently; the way I structure my code may be vastly
    different from yours. It is important, then, that you keep that in mind when reading
    this book and not get hung up on the details. The purpose here is not to show
    you the one right way to use these APIs, but to give you an example that you can
    look at to get a better sense of how they might be used. Learn what you can from
    each example, modify things as you see fit, and go build something amazing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想重申一个早前的观点——每个软件项目都是不同的，因此不可能以一种简单的方式来编写这本书，让您可以简单地将大段代码复制粘贴到您的项目中。同样，每个开发人员编写代码的方式也不同；我构建代码的方式可能与您的大不相同。因此，在阅读本书时，重要的是不要被细节困扰。这里的目的不是向您展示使用这些API的唯一正确方式，而是给您一个示例，让您更好地了解它们可能如何使用。从每个示例中学习，根据自己的需要进行修改，然后构建出令人惊叹的东西。
- en: With all of that said, let's turn our attention to our first project, the Process
    Manager, and the new process handling APIs.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，现在让我们把注意力转向我们的第一个项目，进程管理器和新的进程处理API。
