- en: Debugging and Instrumenting Application Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和为应用程序容器添加仪器
- en: Docker can remove a lot of the friction in the typical developer workflow process
    and significantly reduce the time spent on overhead tasks, such as dependency
    management and environment configuration. When developers run the changes they're
    working on using the exact same application platform where the final product will
    run, there are far fewer opportunities for deployment mistakes, and the upgrade
    path is straightforward and well-understood.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Docker可以消除典型开发人员工作流程中的许多摩擦，并显著减少在诸如依赖管理和环境配置等开销任务上花费的时间。当开发人员使用与最终产品相同的应用程序平台运行他们正在处理的更改时，部署错误的机会就会大大减少，升级路径也是直接且易于理解的。
- en: Running your application in a container during development adds another layer
    to your development environment. You'll be working with different types of assets
    such as Dockerfiles and Docker Compose files, and that experience is improved
    if your IDE supports these types. Also, there's a new runtime between the IDE
    and your app, so the debugging experience will be different. You may need to change
    your workflow to make the most of the platform benefits.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中在容器中运行应用程序会为您的开发环境增加另一层。您将使用不同类型的资产，如Dockerfiles和Docker Compose文件，如果您的集成开发环境支持这些类型，那么这种体验会得到改善。此外，在IDE和应用程序之间有一个新的运行时，因此调试体验会有所不同。您可能需要改变您的工作流程以充分利用平台的优势。
- en: 'In this chapter, I''ll look at the development process with Docker, covering
    IDE integration and debugging, and how to add instrumentation to your Dockerized
    applications. You''ll learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍使用Docker的开发过程，涵盖IDE集成和调试，以及如何为您的Docker化应用程序添加仪器。您将了解：
- en: Working with Docker in integrated development environments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集成开发环境中使用Docker
- en: Instrumentation in Dockerized applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker化应用程序中的仪器
- en: The bug fixing workflow in Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker中的故障修复工作流程
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need Docker running on Windows 10 update 18.09, or Windows Server 2019
    to follow along with the examples. The code for this chapter is available at [https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch11](https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch11).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在Windows 10更新18.09或Windows Server 2019上运行Docker，以便跟随示例。本章的代码可在[https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch11](https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch11)上找到。
- en: Working with Docker in integrated development environments
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集成开发环境中使用Docker
- en: In the previous chapter, I demonstrated a containerized *outer loop*, the compilation
    and packaging CI process that is triggered from central source control when developers
    push changes. The **integrated development environments** (**IDEs**) are beginning
    to support containerized workflows for the *inner loop*, which is the developer
    process of writing, running, and debugging applications in containers before pushing
    changes to central source control.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我演示了一个容器化的“外部循环”，即编译和打包的CI过程，当开发人员推送更改时，它会从中央源代码控制中触发。集成开发环境（IDE）开始支持容器化工作流程的“内部循环”，这是开发人员在将更改推送到中央源代码控制之前编写、运行和调试应用程序的过程。
- en: Visual Studio 2017 has native support for Docker artifacts, including IntelliSense
    and code completion for Dockerfiles. There is also runtime support for ASP.NET
    projects running in containers, both .NET Framework and .NET Core. In Visual Studio
    2017, you can hit the *F5* key and your web app will launch inside a container,
    running in Docker Desktop on Windows. The application uses the same base image
    and Docker runtime that you will use in all other environments.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2017原生支持Docker工件，包括Dockerfile的智能感知和代码完成。ASP.NET项目在容器中运行时也有运行时支持，包括.NET
    Framework和.NET Core。在Visual Studio 2017中，您可以按下*F5*键，您的Web应用程序将在Windows上的Docker桌面中运行的容器中启动。应用程序使用与您在所有其他环境中使用的相同的基本映像和Docker运行时。
- en: Visual Studio 2015 has a plugin that provides support for Docker artifacts,
    and Visual Studio Code has a very useful Docker extension. Visual Studio 2015
    and Visual Studio Code don't provide an integrated *F5* debugging experience for
    .NET apps running in Windows containers, but you can configure this manually,
    and I will demonstrate that in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2015有一个插件，提供对Docker工件的支持，Visual Studio Code有一个非常有用的Docker扩展。Visual
    Studio 2015和Visual Studio Code不提供在Windows容器中运行.NET应用程序的集成*F5*调试体验，但您可以手动配置，我将在本章中演示。
- en: There's a compromise when you debug inside a container—this means creating a
    disconnect between the inner loop and the outer loop. Your development process
    uses a different set of Docker artifacts from your **continuous integration**
    (**CI**) process to make the debugger available to the container and to map the
    application assemblies to the source code. The benefit is that you can run in
    a container in development with the same developer build and debug experience
    that you're used to. The downside is that your development Docker image is not
    the exact same image you'll be promoting to test.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内调试时存在一个折衷之处-这意味着在内部循环和外部循环之间创建了一个断开。您的开发过程使用与CI过程不同的一组Docker工件，以使调试器可用于容器，并将应用程序程序集映射到源代码。好处是您可以在开发中以相同的开发人员构建和调试体验在容器中运行。缺点是您的开发Docker映像与您将推广到测试的映像不完全相同。
- en: A good way to mitigate this is to use the local Docker artifacts for development
    when you're iterating rapidly over a feature. Then, you use the CI Docker artifacts,
    still running locally, for the final build and end-to-end tests before pushing
    your changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解这种情况的一个好方法是在快速迭代功能时，使用本地Docker工件进行开发。然后，在推送更改之前，您可以使用CI Docker工件进行最终构建和端到端测试。
- en: Docker in Visual Studio 2017
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Visual Studio 2017中的Docker
- en: 'Visual Studio 2017 has the most complete Docker support of all the .NET IDEs.
    You can open an ASP.NET Framework Web API project in Visual Studio 2017, right-click
    on the project, and select Add | Container Orchestrator Support:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2017是所有.NET IDE中对Docker支持最完整的。您可以在Visual Studio 2017中打开一个ASP.NET
    Framework Web API项目，右键单击该项目，然后选择添加|容器编排器支持：
- en: '![](Images/b3921071-0b2f-487b-9b25-193543b06c6b.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b3921071-0b2f-487b-9b25-193543b06c6b.png)'
- en: 'There''s only one orchestrator option to choose from, which is Docker Compose.
    Visual Studio then generates a set of Docker artifacts. In the `Web` project,
    it creates a Dockerfile that looks like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个编排器选项可供选择，即Docker Compose。然后，Visual Studio会生成一组Docker工件。在`Web`项目中，它创建一个看起来像这样的Dockerfile：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There's full IntelliSense support for the Dockerfile syntax, so you can hover
    over instructions and see information about them and use *Ctrl* + Spacebar to
    open a prompt for all Dockerfile instructions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile语法有完整的智能感知支持，因此您可以将鼠标悬停在指令上并查看有关它们的信息，并使用*Ctrl* +空格键打开所有Dockerfile指令的提示。
- en: The generated Dockerfile uses the `microsoft/aspnet` base image, which comes
    with ASP.NET 4.7.2, fully installed and configured. At the time of writing, the
    Dockerfile uses an old version of the Windows base image, so you need to manually
    update it to use the latest Windows Server 2019 base image, that is, `mcr.microsoft.com/dotnet/framework/aspnet:4.7.2-windowsservercore-ltsc2019`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的Dockerfile使用`microsoft/aspnet`基础镜像，其中包含已完全安装和配置的ASP.NET 4.7.2。在撰写本文时，Dockerfile使用了旧版本的Windows基础镜像，因此您需要手动更新为使用最新的Windows
    Server 2019基础镜像，即`mcr.microsoft.com/dotnet/framework/aspnet:4.7.2-windowsservercore-ltsc2019`。
- en: The Dockerfile looks odd because it uses a build argument to specify the location
    of the source folder, and then it copies the content of that folder to the web
    root directory, `C:\inetpub\wwwroot`, inside the container image.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile看起来很奇怪，因为它使用构建参数来指定源文件夹的位置，然后将该文件夹的内容复制到容器镜像内的web根目录`C:\inetpub\wwwroot`。
- en: In the solution root, Visual Studio creates a set of Docker Compose files. There
    are multiple files, and Visual Studio uses them with the Docker Compose `build`
    and `up` commands to package and run the application. This works behind the scenes
    when you run the app with the *F5* key , but it's worth looking at how Visual
    Studio uses them; it shows you how you can add this level of support to different
    IDEs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案根目录中，Visual Studio创建了一组Docker Compose文件。有多个文件，Visual Studio会使用它们与Docker
    Compose的`build`和`up`命令来打包和运行应用程序。当您按下*F5*键运行应用程序时，这些文件在后台运行，但值得看看Visual Studio如何使用它们；它向您展示了如何将此级别的支持添加到不同的IDE中。
- en: Debugging with Docker Compose in Visual Studio 2017
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Visual Studio 2017中使用Docker Compose进行调试
- en: 'The generated Docker Compose files are shown under the top-level solution object:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的Docker Compose文件显示在顶级解决方案对象下：
- en: '![](Images/0b2f32c1-dfa2-431e-8f3b-4ae277474b2a.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0b2f32c1-dfa2-431e-8f3b-4ae277474b2a.png)'
- en: 'There''s a basic `docker-compose.yml` file with the web application defined
    as a service, complete with build details for the Dockerfile:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个基本的`docker-compose.yml`文件，其中将Web应用程序定义为一个服务，并包含Dockerfile的构建细节：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There''s also a `docker-compose.override.yml` file, which adds the port and
    network configuration so that it can run locally:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`docker-compose.override.yml`文件，它添加了端口和网络配置，以便可以在本地运行：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There''s nothing here about building the application because the compilation
    is done in Visual Studio rather than in Docker. The built application binaries
    live on your development machine and are copied into the container. When you hit
    *F5*, the container is started and Visual Studio launches a browser at the container''s
    IP address. You can add breakpoints to code in Visual Studio, and when you navigate
    to that code from the browser, you''ll be taken to the debugger in Visual Studio:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有关于构建应用程序的内容，因为编译是在Visual Studio中完成而不是在Docker中。构建的应用程序二进制文件存储在您的开发计算机上，并复制到容器中。当您按下*F5*时，容器会启动，Visual
    Studio会在容器的IP地址上启动浏览器。您可以在Visual Studio中的代码中添加断点，当您从浏览器导航到该代码时，将会进入Visual Studio中的调试器：
- en: '![](Images/8a0d0f97-90fe-43fb-b674-05d152804d08.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8a0d0f97-90fe-43fb-b674-05d152804d08.png)'
- en: It's a seamless experience, but it's not clear what's happening—how does the
    Visual Studio debugger on your machine connect to the binaries inside the container?
    Fortunately, Visual Studio logs all the Docker commands it issues to the output
    windows, so you can track down how this works.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个无缝的体验，但不清楚发生了什么——Visual Studio调试器在您的计算机上如何连接到容器内的二进制文件？幸运的是，Visual Studio会将所有发出的Docker命令记录到输出窗口，因此您可以追踪它是如何工作的。
- en: 'In the build output window, you''ll see something like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建输出窗口中，您会看到类似以下的内容：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can see that the build happens first, and then the container is launched
    with `docker-compose up`. The `docker-compose.yml` and `docker-compose.override.yml`
    files we''ve already seen are used, along with a file called `docker-compose.vs.debug.g.yml`.
    Visual Studio generates that file on the build, and you need to show all the files
    in the solution to see it. It contains additional Docker Compose settings:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到首先进行构建，然后使用`docker-compose up`启动容器。我们已经看到的`docker-compose.yml`和`docker-compose.override.yml`文件与一个名为`docker-compose.vs.debug.g.yml`的文件一起使用。Visual
    Studio在构建时生成该文件，您需要显示解决方案中的所有文件才能看到它。它包含额外的Docker Compose设置：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There''s a lot going on here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情：
- en: The Docker image uses the `dev` tag to distinguish it from the release build
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker镜像使用`dev`标签来区分它与发布版本的构建
- en: The build argument for the source location specifies an empty directory
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源位置的构建参数指定一个空目录
- en: A volume is used to mount the web root in the container from the project folder
    on the host
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个卷用于从主机上的项目文件夹中挂载容器中的Web根目录
- en: A second volume is used to mount the Visual Studio remote debugger in the container
    from the host
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个卷用于从主机中挂载Visual Studio远程调试器到容器中
- en: The entrypoint launches `ServiceMonitor` to run IIS, and then launches `msvsmon`,
    which is the remote debugger
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入口点启动`ServiceMonitor`来运行IIS，然后启动`msvsmon`，这是远程调试器
- en: In debug mode, the argument for the source code environment variable is an empty
    directory. Visual Studio builds a Docker image with an empty `wwwroot` directory
    and then mounts the source code folder from the host into the web root in the
    container to populate that folder at runtime.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试模式下，源代码环境变量的参数是一个空目录。Visual Studio使用一个空的`wwwroot`目录构建Docker镜像，然后将主机中的源代码文件夹挂载到容器中的Web根目录，以在运行时填充该文件夹。
- en: 'When the container is running, Visual Studio runs some commands inside the
    container to set permissions, which allows the remote debugger tool to work. In
    the output window for Docker, you''ll see something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器运行时，Visual Studio会在容器内运行一些命令来设置权限，从而使远程调试工具能够工作。在Docker的输出窗口中，您会看到类似以下的内容：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's Visual Studio fetching the ID of the container it launched with Docker
    Compose, then running `appcmd` to set the IIS application pool to use an administrative
    account and to set the web server to allow anonymous authentication.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Visual Studio获取使用Docker Compose启动的容器的ID，然后运行`appcmd`来设置IIS应用程序池以使用管理员帐户，并设置Web服务器以允许匿名身份验证。
- en: Visual Studio 2017 keeps the container running in the background when you stop
    debugging. If you make a change to the program and rebuild, the same container
    is used so that there's no startup lag. By mounting the project location into
    the container, any changes in content or binaries are reflected when you rebuild.
    By mounting the remote debugger from the host, your image doesn't have any development
    tools baked into it; they stay on the host.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当您停止调试时，Visual Studio 2017会使容器在后台运行。如果对程序进行更改并重新构建，则仍然使用同一个容器，因此没有启动延迟。通过将项目位置挂载到容器中，重新构建时会反映出内容或二进制文件的任何更改。通过从主机挂载远程调试器，您的镜像不会包含任何开发工具；它们保留在主机上。
- en: This is the inner loop process, where you get fast feedback. Whenever you change
    and rebuild your app, you see these changes in the container. However, the Docker
    image from debug mode is not usable for the outer loop CI process; the app is
    not copied into the image; it works only if you mount the app from your local
    source into a container.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是内部循环过程，您可以获得快速反馈。每当您更改并重新构建应用程序时，您都会在容器中看到这些更改。但是，调试模式下的Docker镜像对于外部循环CI过程是不可用的；应用程序不会被复制到镜像中；只有在将应用程序从本地源挂载到容器中时才能工作。
- en: 'To support the outer loop, there''s also a Docker compose override file for
    release mode in a second hidden override file, `docker-compose.vs.release.g.yml`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持外部循环，还有一个用于发布模式的Docker Compose覆盖文件，以及第二个隐藏的覆盖文件，`docker-compose.vs.release.g.yml`。
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The difference here is that there's no volume mapping the local source location
    to the web root in the container. When you compile in release mode, the value
    of the source argument is a published location that contains the web app. Visual
    Studio builds the release image by packaging the published application into the
    container.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的区别在于没有将本地源位置映射到容器中的Web根目录。在发布模式下编译时，源参数的值是包含Web应用程序的发布位置。Visual Studio通过将发布的应用程序打包到容器中来构建发布映像。
- en: In release mode, you can still run the application in a Docker container and
    you can still debug the application. But you lose the fast feedback loop because
    to change the app, Visual Studio needs to rebuild the Docker image and start a
    new container.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布模式下，您仍然可以在Docker容器中运行应用程序，并且仍然可以调试应用程序。但是，您会失去快速反馈循环，因为要更改应用程序，Visual Studio需要重新构建Docker映像并启动新的容器。
- en: This is a fair compromise, and the Docker tooling in Visual Studio 2017 gives
    you a seamless development experience, along with the basis for your CI build.
    One thing Visual Studio 2017 doesn't do is use multi-stage builds, so the project
    compilation still happens on the host rather than inside a container. This makes
    the generated Docker artifacts less portable, so you need more than just Docker
    to build this app on a server.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个公平的妥协，而Visual Studio 2017中的Docker工具为您提供了无缝的开发体验，以及CI构建的基础。Visual Studio
    2017没有使用多阶段构建，因此项目编译仍然发生在主机而不是容器内。这使得生成的Docker工件不够便携，因此您需要不仅仅是Docker来在服务器上构建此应用程序。
- en: Docker in Visual Studio 2015
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio 2015中的Docker
- en: Visual Studio 2015 has a plugin available from the marketplace called **Visual
    Studio Tools for Docker**. This gives you syntax highlighting for Dockerfiles,
    but it doesn't integrate Visual Studio with Docker for .NET Framework apps. With
    Visual Studio 2015, you can add Docker support to a .NET Core project, but you
    need to manually write your own Dockerfile and Docker Compose files for full .NET.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2015在市场上有一个名为**Visual Studio Tools for Docker**的插件。这为Dockerfile提供了语法高亮显示，但它并没有将Visual
    Studio与.NET Framework应用程序的Docker集成。在Visual Studio 2015中，您可以为.NET Core项目添加Docker支持，但是您需要手动编写自己的Dockerfile和Docker
    Compose文件以支持完整的.NET应用程序。
- en: Also, there's no integrated debugging for applications running in Windows containers.
    You can still debug code running in a container, but you need to manually configure
    the setup. I'll demonstrate how to do this now using the same approach as Visual
    Studio 2017, and with some of the same compromises.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，没有集成的调试功能用于在Windows容器中运行的应用程序。您仍然可以调试在容器中运行的代码，但是您需要手动配置设置。我将演示如何使用与Visual
    Studio 2017相同的方法以及一些相同的妥协来做到这一点。
- en: In Visual Studio 2017, you can mount the folder containing the remote debugger
    from the host into your container. When you run the project, Visual Studio starts
    a container and executes the `msvsmon.exe` from the host that is the remote debugger
    agent. You don't need to install anything in your image to provide the debugging
    experience.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio 2017中，您可以将包含远程调试器的文件夹从主机挂载到容器中。当您运行项目时，Visual Studio会启动一个容器，并从主机执行`msvsmon.exe`，这是远程调试器代理。您不需要在图像中安装任何内容来提供调试体验。
- en: The remote debugger in Visual Studio 2015 is not so portable. You can mount
    the debugger from the host in the container, but when you try to start the agent,
    you'll see errors about missing files. Instead, you need to install the remote
    debugger into your image.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2015中的远程调试器并不是很便携。你可以从主机中将调试器挂载到容器中，但当你尝试启动代理时，你会看到有关缺少文件的错误。相反，你需要将远程调试器安装到你的镜像中。
- en: 'I have this set up in a folder called `ch11-webapi-vs2015`. In the Dockerfile
    for this image, I use a build-time argument to conditionally install the debugger
    if the `configuration` value is set to `debug.` This means that I can build locally
    with the debugger installed, but when I build for deployment, the image doesn''t
    have the debugger:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一个名为`ch11-webapi-vs2015`的文件夹中设置了这个。在这个镜像的Dockerfile中，我使用了一个构建时参数来有条件地安装调试器，如果`configuration`的值设置为`debug`。这意味着我可以在本地构建时安装调试器，但当我为部署构建时，镜像就不会有调试器了：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'I use the same approach as Visual Studio 2017 to mount the source directory
    on the host into the container when running in debug mode, but I create a custom
    website rather than using the default one:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当以调试模式运行时，我使用与Visual Studio 2017相同的方法将主机上的源目录挂载到容器中，但我创建了一个自定义网站，而不是使用默认的网站：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `:-` syntax in the `COPY` instruction specifies a default value if the
    `source` argument is not provided. The default is to copy from the published web
    application unless it is specified in the `build` command. I have a core `docker-compose.yml`
    file with the basic service definition and a `docker-compose.debug.yml` file that
    mounts the host source location, maps the debugger ports, and specifies the `configuration`
    variable:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`指令中的`:-`语法指定了一个默认值，如果未提供`source`参数。默认值是从发布的web应用程序复制，除非在`build`命令中指定了它。我有一个核心的`docker-compose.yml`文件，其中包含基本的服务定义，还有一个`docker-compose.debug.yml`文件，它挂载主机源位置，映射调试器端口，并指定`configuration`变量。'
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The label specified in the compose file attaches a key-value pair to the container.
    The value isn't visible inside the container, unlike an environment variable,
    but it is visible to external processes on the host. In this case, it is used
    by Visual Studio to identify the operating system of the container.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在compose文件中指定的标签将一个键值对附加到容器。该值在容器内部不可见，不像环境变量，但对主机上的外部进程可见。在这种情况下，它被Visual Studio用来识别容器的操作系统。
- en: 'To start the app in debug mode, I use both Compose files to start the application:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要以调试模式启动应用程序，我使用两个Compose文件来启动应用程序：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, the container is running my web app using **Internet Information Services**
    (**IIS**) inside the container, and the Visual Studio remote debugger agent is
    running as well. I can connect to a remote process in Visual Studio 2015 and use
    the IP address of the container:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，容器正在使用**Internet Information Services** (**IIS**)在容器内部运行我的web应用程序，并且Visual
    Studio远程调试器代理也在运行。我可以连接到Visual Studio 2015中的远程进程，并使用容器的IP地址：
- en: '![](Images/3909f411-ca1a-4d71-a1c8-f10ecdc8607e.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3909f411-ca1a-4d71-a1c8-f10ecdc8607e.png)'
- en: The debugger in Visual Studio attaches to the agent running in the container,
    and I can add breakpoints and view variables, just like debugging to a local process.
    In this approach, the container is using the host mount for the content of the
    web app. I can stop the debugger, make changes, rebuild the app, and see the changes
    in the same container without having to start a new container.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio中的调试器连接到容器中运行的代理，并且我可以添加断点和查看变量，就像调试本地进程一样。在这种方法中，容器使用主机挂载来获取web应用的内容。我可以停止调试器，进行更改，重新构建应用程序，并在同一个容器中看到更改，而无需启动新的容器。
- en: This approach has the same benefits and drawbacks as the integrated Docker support
    in Visual Studio 2017\. I'm running my app in a container for local debugging,
    so I get all the features of the Visual Studio debugger and my app is running
    in the same platform I'll use in other environments. But I won't be using the
    same image because the Dockerfile has conditional branches, so it produces different
    outputs for the debug and release modes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与Visual Studio 2017中集成的Docker支持具有相同的优缺点。我正在容器中运行我的应用程序进行本地调试，因此我可以获得Visual
    Studio调试器的所有功能，并且我的应用程序在其他环境中使用的平台上运行。但我不会使用相同的映像，因为Dockerfile具有条件分支，因此它会为调试和发布模式生成不同的输出。
- en: There is an advantage to manually building debugger support in your Docker artifacts.
    You can construct your Dockerfile with conditioning so that the default `docker
    image build` command produces the production-ready image without requiring any
    additional artifacts. This example still does not use a multi-stage build, though,
    so the Dockerfile is not portable and the application needs to be compiled before
    it can be packaged.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker构件中手动构建调试器支持有一个优势。您可以构建具有条件的Dockerfile，以便默认的`docker image build`命令生成无需任何额外构件即可用于生产的图像。但是，这个例子仍然没有使用多阶段构建，因此Dockerfile不具备可移植性，应用程序在打包之前需要进行编译。
- en: In development, you build the image once in debug mode, run the container, and
    then attach the debugger whenever you need to. Your integration tests build and
    run the production image, so only the inner loop has the additional debugger components.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发中，您可以以调试模式构建图像一次，运行容器，然后在需要时附加调试器。您的集成测试构建并运行生产图像，因此只有内部循环具有额外的调试器组件。
- en: Docker in Visual Studio Code
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code中的Docker
- en: Visual Studio Code is a new cross-platform IDE for cross-platform development.
    The C# extension installs a debugger that can attach to .NET Core applications,
    but there's no support for debugging full .NET Framework apps.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code是一个新的跨平台IDE，用于跨平台开发。C#扩展安装了一个可以附加到.NET Core应用程序的调试器，但不支持调试完整的.NET
    Framework应用程序。
- en: 'The Docker extension adds some very useful features, including the ability
    to add Dockerfiles and Docker Compose files to existing projects for known platforms,
    such as Go and .NET Core. You can add a Dockerfile to a .NET Core project and
    choose between using Windows or Linux containers as the base—hit *F1*, type `docker`,
    and select Add Docker Files to Workspace:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Docker扩展添加了一些非常有用的功能，包括将Dockerfiles和Docker Compose文件添加到已知平台的现有项目中，例如Go和.NET
    Core。您可以将Dockerfile添加到.NET Core项目中，并选择在Windows或Linux容器之间进行选择作为基础-点击* F1 *，键入`docker`，然后选择将Docker文件添加到工作区：
- en: '![](Images/d6ee79a9-f1d5-4c77-81bf-dbee789ba6b1.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: ！[](Images/d6ee79a9-f1d5-4c77-81bf-dbee789ba6b1.png)
- en: 'Here''s the generated Dockerfile for a .NET Core Web API project:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是.NET Core Web API项目的生成的Dockerfile：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is using an old version of the .NET Core base images, so the first step
    is to replace the `nanoserver-1803` tags in the `FROM` lines with `nanoserver-1809`.
    The extension generates a multi-stage Dockerfile, using the SDK image for the
    build and publish stages, and the ASP.NET Core runtime for the final image. VS
    Code generates more stages in the Dockerfile than you really need, but that's
    a design choice.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用旧版本的.NET Core基础映像，因此第一步是将`FROM`行中的`nanoserver-1803`标签替换为`nanoserver-1809`。该扩展程序生成了一个多阶段的Dockerfile，使用SDK映像进行构建和发布阶段，以及ASP.NET
    Core运行时用于最终映像。VS Code在Dockerfile中生成了比实际需要更多的阶段，但这是一个设计选择。
- en: VS Code also generates a `.dockerignore` file. This is a useful feature that
    speeds up your Docker image builds. In the ignore file, you list any file or directory
    paths that aren't used in your Dockerfile, and these are excluded from the build
    context. Excluding all the `bin`, `obj`, and `packages` folders means that the
    Docker CLI sends a much smaller payload to the Docker Engine when you build the
    image, and that can make the build much faster.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code还会生成一个`.dockerignore`文件。这是一个有用的功能，可以加快Docker镜像的构建速度。在忽略文件中，您列出任何在Dockerfile中未使用的文件或目录路径，并且这些文件将被排除在构建上下文之外。排除所有`bin`、`obj`和`packages`文件夹意味着当您构建图像时，Docker
    CLI向Docker Engine发送的有效负载要小得多，这可以加快构建速度。
- en: You can use F1 | docker tasks to build the image and run a container, but there's
    no functionality to generate Docker Compose files in the way that Visual Studio
    2017 does.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用F1 | docker tasks来构建图像并运行容器，但是没有功能以生成Docker Compose文件的方式，就像Visual Studio
    2017那样。
- en: Visual Studio Code has a very flexible system for running and debugging your
    projects, so you can add your own configuration to provide debugging support for
    apps running in Windows containers. You can edit the `launch.json` file to add
    a new configuration for debugging in Docker.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code具有非常灵活的系统，可以运行和调试您的项目，因此您可以添加自己的配置，为在Windows容器中运行的应用程序提供调试支持。您可以编辑`launch.json`文件，以添加新的配置以在Docker中进行调试。
- en: 'In the `ch11-webapi-vscode` folder, I have a sample .NET Core project set up
    to run the application in Docker and attach a debugger. It uses the same approach
    as Visual Studio 2017\. The debugger for .NET Core is called `vsdbg` and is installed
    with the C# extension in Visual Studio Code, so I mount the `vsdbg` folder from
    the host into the container, along with the source location using the `docker-compose.debug.yml`
    file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch11-webapi-vscode`文件夹中，我有一个示例.NET Core项目，可以在Docker中运行该应用程序并附加调试器。它使用与Visual
    Studio 2017相同的方法。.NET Core的调试器称为`vsdbg`，并且与Visual Studio Code中的C#扩展一起安装，因此我使用`docker-compose.debug.yml`文件将`vsdbg`文件夹从主机挂载到容器中，以及使用源位置：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This setup uses a specific version of the C# extension. That's 1.17.1 in my
    case, but you may have a different version. Check for the location of `vsdbg.exe`
    in the `.vscode` folder in your user directory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置使用特定版本的C#扩展。在我的情况下是1.17.1，但您可能有不同的版本。检查您的用户目录中`.vscode`文件夹中`vsdbg.exe`的位置。
- en: 'When you run the app through Docker Compose using the debug override file,
    it starts the .NET Core application and makes the debugger from the host available
    to run in the container. This is configured for a debugging experience in Visual
    Studio Code in the `launch.json` file. The `Debug Docker container` configuration
    specifies what type of application to debug and the name of the process to attach:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过使用调试覆盖文件在Docker Compose中运行应用程序时，它会启动.NET Core应用程序，并使来自主机的调试器可用于在容器中运行。这是在Visual
    Studio Code的`launch.json`文件中配置的调试体验。`Debug Docker container`配置指定要调试的应用程序类型和要附加的进程的名称：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This configuration also maps the application root in the container to the source
    code location on the host, so the debugger can associate the correct source files
    with the debug files. In addition, the debugger configuration specifies how to
    launch the debugger by running a `docker container exec` command on the named
    container:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置还将容器中的应用程序根映射到主机上的源代码位置，因此调试器可以将正确的源文件与调试文件关联起来。此外，调试器配置指定了如何通过在命名容器上运行`docker
    container exec`命令来启动调试器：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To debug my app, I need to build and run it in the debug configuration, using
    Docker Compose with the override file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试我的应用程序，我需要使用Docker Compose和覆盖文件在调试配置中构建和运行它：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, I can activate the debugger using the Debug action and selecting Debug
    Docker container:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以使用调试操作并选择调试Docker容器来激活调试器：
- en: '![](Images/64e9ad65-f404-4292-a022-36536a415a3a.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/64e9ad65-f404-4292-a022-36536a415a3a.png)'
- en: 'Visual Studio Code starts the .NET Core debugger `vsdbg` inside the container
    and attaches it to the running `dotnet` process. You''ll see the output from the
    .NET Core application being redirected into the DEBUG CONSOLE window in Visual
    Studio Code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code在容器内启动.NET Core调试器`vsdbg`，并将其附加到正在运行的`dotnet`进程。您将看到.NET Core应用程序的输出被重定向到Visual
    Studio Code中的DEBUG CONSOLE窗口中：
- en: '![](Images/c219df7a-a5ca-44a1-956d-acc2d5e697fe.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c219df7a-a5ca-44a1-956d-acc2d5e697fe.png)'
- en: At the time of writing, Visual Studio Code doesn't fully integrate with the
    debugger running inside a Windows Docker container. You can place breakpoints
    in the code and the debugger will pause the process, but control does not pass
    to Visual Studio Code. This is a known issue with running the Omnisharp debugger
    inside a Nano Server container – it's being tracked on GitHub at: [https://github.com/OmniSharp/omnisharp-vscode/issues/1001](https://github.com/OmniSharp/omnisharp-vscode/issues/1001).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Visual Studio Code尚未完全与在Windows Docker容器内运行的调试器集成。您可以在代码中设置断点，调试器将暂停进程，但控制权不会传递到Visual
    Studio Code。这是在Nano Server容器中运行Omnisharp调试器的已知问题-在GitHub上进行跟踪：[https://github.com/OmniSharp/omnisharp-vscode/issues/1001](https://github.com/OmniSharp/omnisharp-vscode/issues/1001)。
- en: Running your application in a container and being able to debug from your normal
    IDE is a huge benefit. It means your app is running on the same platform and with
    the same deployment configuration it will use in all other environments, but you
    can step into code just as if it were running locally.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中运行应用程序并能够从您的常规IDE进行调试是一个巨大的好处。这意味着您的应用程序在相同的平台上运行，并且具有与在所有其他环境中使用的相同部署配置，但您可以像在本地运行一样进入代码。
- en: Docker support in IDEs is improving rapidly so all the manual steps I've detailed
    in this chapter will be built into products and extensions soon. JetBrains Rider
    is a good example of a third-party .NET IDE that works well with Docker. It integrates
    with the Docker API and can attach its own debugger to running containers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: IDE中的Docker支持正在迅速改善，因此本章中详细介绍的所有手动步骤将很快内置到产品和扩展中。JetBrains Rider是一个很好的例子，它是一个与Docker很好配合的第三方.NET
    IDE。它与Docker API集成，并可以将自己的调试器附加到正在运行的容器中。
- en: Instrumentation in Dockerized applications
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker化应用程序中的仪器
- en: Debugging your app is what you do when the logic doesn't work as expected and
    you're trying to track down what's going wrong. You don't debug in production,
    so you need your app to record its behavior to help you trace any problems that
    occur.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 调试应用程序是在逻辑不按预期工作时所做的事情，您正在尝试跟踪出现问题的原因。您不会在生产环境中进行调试，因此您需要您的应用程序记录其行为，以帮助您跟踪发生的任何问题。
- en: Instrumentation is often neglected, but it should be a crucial component of
    your development. It's the best way to understand the health and activity of your
    app in production. Running your app in Docker provides new opportunities for centralized
    logging and instrumentation so that you can get a consistent view across the different
    parts of your application, even if they use different languages and platforms.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器经常被忽视，但它应该是您开发的一个关键组成部分。这是了解应用程序在生产环境中的健康状况和活动的最佳方式。在Docker中运行应用程序为集中日志记录和仪器提供了新的机会，这样您可以获得对应用程序不同部分的一致视图，即使它们使用不同的语言和平台。
- en: Adding instrumentation to your containers can be a straightforward process.
    Windows Server Core containers are already collecting lots of metrics in Windows
    performance counters. Docker images built with .NET or IIS will also have all
    the additional performance counters from those stacks. You can instrument containers
    just by exposing the performance counter values to a metrics server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 向您的容器添加仪表化可以是一个简单的过程。Windows Server Core容器已经在Windows性能计数器中收集了大量的指标。使用.NET或IIS构建的Docker镜像也将具有来自这些堆栈的所有额外性能计数器。您可以通过将性能计数器值暴露给指标服务器来为容器添加仪表化。
- en: Instrumentation with Prometheus
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Prometheus进行仪表化
- en: The ecosystem around Docker is very large and active, taking advantage of the
    open standards and extensibility of the platform. As the ecosystem has matured,
    a few technologies have emerged as strong candidates for inclusion in almost all
    Dockerized applications.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕Docker的生态系统非常庞大和活跃，充分利用了平台的开放标准和可扩展性。随着生态系统的成熟，一些技术已经成为几乎所有Docker化应用程序中强有力的候选项。
- en: Prometheus is an open source monitoring solution. It's a flexible component
    that you can use in different ways, but the typical implementation is to run a
    Prometheus server in a Docker container, configured to read instrumentation endpoints
    that you make available in your other Docker containers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus是一个开源的监控解决方案。它是一个灵活的组件，您可以以不同的方式使用，但典型的实现方式是在Docker容器中运行一个Prometheus服务器，并配置其读取您在其他Docker容器中提供的仪表化端点。
- en: You configure Prometheus to poll all the container endpoints and it stores the
    results in a time-series database. You can add a Prometheus endpoint to your application
    by simply adding a REST API, which responds to `GET` requests from the Prometheus
    server with a list of the metrics you're interested in collecting.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置Prometheus来轮询所有容器端点，并将结果存储在时间序列数据库中。您可以通过简单地添加一个REST API来向您的应用程序添加一个Prometheus端点，该API会响应来自Prometheus服务器的`GET`请求，并返回您感兴趣的指标列表。
- en: For .NET Framework and .NET Core projects, there is a NuGet package that does
    this for you, that is, adding a Prometheus endpoint to your application. It exposes
    a useful set of metrics by default, including the values of key .NET statistics
    and Windows performance counters. You can add Prometheus support directly to your
    application or you can run a Prometheus exporter alongside your app.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于.NET Framework和.NET Core项目，有一个NuGet包可以为您完成这项工作，即向您的应用程序添加一个Prometheus端点。它默认公开了一组有用的指标，包括关键的.NET统计数据和Windows性能计数器的值。您可以直接向您的应用程序添加Prometheus支持，或者您可以在应用程序旁边运行一个Prometheus导出器。
- en: The approach you take will depend on the type of application you want to instrument.
    If it's a legacy .NET Framework app that you're moving to Docker, you can add
    basic instrumentation by packaging a Prometheus exporter in the Docker image,
    and that will give you metrics about your application without you needing to change
    code. For new applications, you can write code to expose specific application
    metrics to Prometheus.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您采取的方法将取决于您想要为其添加仪表化的应用程序类型。如果是要将传统的.NET Framework应用程序移植到Docker中，您可以通过在Docker镜像中打包一个Prometheus导出器来添加基本的仪表化，这样就可以在不需要更改代码的情况下获得有关应用程序的指标。对于新应用程序，您可以编写代码将特定的应用程序指标暴露给Prometheus。
- en: Exposing .NET application metrics to Prometheus
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将.NET应用程序指标暴露给Prometheus
- en: The `prometheus-net` NuGet package provides a set of default metric collectors
    and a `MetricServer` class that provides the instrumentation endpoint that Prometheus
    hooks into. This package is great for adding Prometheus support to any app. The
    metrics are provided by a self-hosted HTTP endpoint, and you can provide custom
    metrics for your application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`prometheus-net` NuGet包提供了一组默认的指标收集器和一个`MetricServer`类，该类提供了Prometheus连接的仪表端点。该包非常适合为任何应用程序添加Prometheus支持。这些指标由自托管的HTTP端点提供，您可以为您的应用程序提供自定义指标。'
- en: 'In the `dockeronwindows/ch11-api-with-metrics` image, I''ve added Prometheus
    support into a Web API project. The code to configure and start the metrics endpoint
    is in the `PrometheusServer` class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dockeronwindows/ch11-api-with-metrics`镜像中，我已经将Prometheus支持添加到了一个Web API项目中。配置和启动指标端点的代码在`PrometheusServer`类中。
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This starts a new `MetricServer` instance listening on port `50505` and running
    the default set of .NET statistics and performance counter collectors that the
    `NuGet` package provides. These are on-demand collectors, which means they provide
    metrics when the Prometheus server calls into the endpoint.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个新的`MetricServer`实例，监听端口`50505`，并运行`NuGet`包提供的默认一组.NET统计和性能计数器收集器。这些是按需收集器，这意味着它们在Prometheus服务器调用端点时提供指标。
- en: 'The `MetricServer` class will also return any custom metrics you set up in
    your application. Prometheus supports different types of metrics. The simplest
    is the counter, which is just an incrementing counter—Prometheus queries your
    app for the metrics values, and the app returns a single number for each counter.
    In the `ValuesController` class, I have set up some counters to record requests
    and responses to the API:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetricServer`类还将返回您在应用程序中设置的任何自定义指标。Prometheus支持不同类型的指标。最简单的是计数器，它只是一个递增的计数器—Prometheus查询您的应用程序的指标值，应用程序返回每个计数器的单个数字。在`ValuesController`类中，我设置了一些计数器来记录对API的请求和响应：'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When requests come into the controller, the controller action method increments
    the request count for the URL and increments the status count for the response
    code by calling the `Inc()` method on the counter objects:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求进入控制器时，控制器动作方法通过在计数器对象上调用`Inc()`方法来增加URL的请求计数，并增加响应代码的状态计数：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Prometheus has various other types of metrics that you can use to record key
    information about your app—counters only increase, but gauges can increase and
    decrease, so they're useful for recording snapshots. Prometheus records each metric
    value with a timestamp and a set of arbitrary labels that you provide. In this
    case, I will add the `URL` and the `HTTP` method to the request count and the
    URL and status code to the response count. I can use these to aggregate or filter
    metrics in Prometheus.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus还有各种其他类型的指标，您可以使用它们来记录有关应用程序的关键信息—计数器只增加，但是仪表可以增加和减少，因此它们对于记录快照非常有用。Prometheus记录每个指标值及其时间戳和您提供的一组任意标签。在这种情况下，我将添加`URL`和`HTTP`方法到请求计数，以及URL和状态代码到响应计数。我可以使用这些在Prometheus中聚合或过滤指标。
- en: 'The counters I set up in the Web API controller give me a set of custom metrics
    showing which endpoints are being used and the status of the responses. These
    are exposed by the server component in the `NuGet` package, along with the default
    metrics to record the system''s performance. In the Dockerfile for this app, there
    are two additional lines for the Prometheus endpoint:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Web API控制器中设置的计数器为我提供了一组自定义指标，显示了哪些端点正在使用以及响应的状态。这些由服务器组件在`NuGet`包中公开，以及用于记录系统性能的默认指标。在此应用的Dockerfile中，还有两行额外的代码用于Prometheus端点：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first line just exposes the custom port I'm using for the metrics endpoint.
    The second line sets up the permissions that are needed for that endpoint. In
    this case, the metrics endpoint is hosted inside the ASP.NET app, so the IIS user
    account needs permissions to listen on the custom port and to access the system
    performance counters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行只是暴露了我用于度量端点的自定义端口。第二行设置了该端点所需的权限。在这种情况下，度量端点托管在 ASP.NET 应用程序内部，因此 IIS 用户帐户需要权限来监听自定义端口并访问系统性能计数器。
- en: 'You can build the Dockerfile and run a container from the image in the usual
    way, that is, by publishing all the ports with `-P`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照通常的方式构建 Dockerfile 并从镜像运行容器，即通过使用 `-P` 发布所有端口：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To check whether the metrics are being recorded and exposed, I can run some
    PowerShell commands to grab the port of the container, then make some calls to
    the API endpoint and check the metrics:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查度量是否被记录和暴露，我可以运行一些 PowerShell 命令来抓取容器的端口，然后对 API 端点进行一些调用并检查度量：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You''ll see a plain text list of metrics, grouped by name and label. Each metric
    also contains the metadata for Prometheus, including the metric name, the type,
    and a friendly description:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到按名称和标签分组的度量的纯文本列表。每个度量还包含 Prometheus 的元数据，包括度量名称、类型和友好描述：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The complete output is much larger. In this snippet, I've shown the total number
    of threads, the allocated memory and the CPU usage, which all comes from standard
    Windows and .NET performance counters inside the container. I've also shown the
    custom HTTP request and response counters.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的输出要大得多。在这个片段中，我展示了线程总数、分配的内存和 CPU 使用率，这些都来自容器内部的标准 Windows 和 .NET 性能计数器。我还展示了自定义的
    HTTP 请求和响应计数器。
- en: My custom counters in this application show the URL and the response code. In
    this case, I can see 10 requests to the root URL of the value controller, and
    ten responses with the OK status code `200`. Later in this chapter, I'll show
    you how to visualize these statistics using Grafana.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序中的自定义计数器显示了 URL 和响应代码。在这种情况下，我可以看到对值控制器的根 URL 的 10 个请求，以及带有 OK 状态码 `200`
    的十个响应。在本章后面，我将向您展示如何使用 Grafana 可视化这些统计信息。
- en: Adding the `NuGet` package to the project and running the `MetricServer` is
    a simple extension of the source code. It lets me record any kind of metric that
    is useful, but it does mean changing the app, so it's only suitable for applications
    that are under active development.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `NuGet` 包添加到项目并运行 `MetricServer` 是源代码的简单扩展。它让我记录任何有用的度量，但这意味着改变应用程序，因此只适用于正在积极开发的应用程序。
- en: In some cases, you may want to add monitoring without altering the application
    you want to instrument. In that case, you can run an **exporter** alongside your
    app. An exporter pulls metrics from your application process and exposes them
    to Prometheus. In Windows containers, you can get a lot of useful information
    from the standard performance counters.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望添加监视而不更改要检测的应用程序。在这种情况下，您可以在应用程序旁边运行一个**导出器**。导出器从应用程序进程中提取度量并将其暴露给
    Prometheus。在 Windows 容器中，您可以从标准性能计数器中获取大量有用的信息。
- en: Adding a Prometheus exporter alongside existing apps
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在现有应用程序旁边添加 Prometheus 导出器
- en: In a Dockerized solution, Prometheus will make scheduled calls to the metrics
    endpoint that are exposed from a container and will store the results. For an
    existing app, you don't need to add a metrics endpoint—you can run a console app
    alongside the current application, and host the metrics endpoint in that console
    app.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 化解决方案中，Prometheus 将定期调用从容器中暴露的度量端点，并存储结果。对于现有应用程序，您无需添加度量端点 - 您可以在当前应用程序旁边运行一个控制台应用程序，并在该控制台应用程序中托管度量端点。
- en: 'I''ve added a Prometheus endpoint to the NerdDinner web application from [Chapter
    10](e0946741-5df7-4a13-b220-ffc963f1e3d3.xhtml), *Powering a Continuous Deployment
    Pipeline with Docker*, without changing any code. In the `dockeronwindows/ch11-nerd-dinner-web-with-metrics`
    image, I''ve added a console app that exports ASP.NET performance counters and
    provides the metrics endpoint. The ASP.NET exporter app comes from a public image
    on Docker Hub. The full Dockerfile for NerdDinner copies in the binaries for the
    exporter and sets the startup command for containers:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第10章](e0946741-5df7-4a13-b220-ffc963f1e3d3.xhtml)中为NerdDinner Web应用程序添加了一个Prometheus端点，*使用Docker支持持续部署流水线*，而没有更改任何代码。在`dockeronwindows/ch11-nerd-dinner-web-with-metrics`镜像中，我添加了一个导出ASP.NET性能计数器并提供指标端点的控制台应用程序。ASP.NET导出程序应用程序来自Docker
    Hub上的公共镜像。NerdDinner的完整Dockerfile复制了导出程序的二进制文件，并为容器设置了启动命令：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `aspnet-exporter.exe` console application implements a custom metrics collector,
    which reads the performance counter values for a named process running on the
    system. It uses the same set of counters as the default collector in the NuGet
    package, but it targets a different process. The exporter reads performance counters
    for the IIS `w3wp.exe` process, and it's configured to export key IIS metrics.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`aspnet-exporter.exe`控制台应用程序实现了一个自定义的指标收集器，它读取系统上运行的命名进程的性能计数器值。它使用与NuGet包中默认收集器相同的一组计数器，但它针对不同的进程。导出程序读取IIS
    `w3wp.exe`进程的性能计数器，并配置为导出关键的IIS指标。'
- en: The source code for the exporter is all on GitHub in the `dockersamples/aspnet-monitoring`
    repository.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 导出程序的源代码都在GitHub的`dockersamples/aspnet-monitoring`存储库中。
- en: 'The console exporter is a lightweight component. It starts when the container
    starts and keeps running as long as the container is running. It only uses compute
    resources when the metrics endpoint is called, so it has minimal impact when running
    on a Prometheus schedule. I run NerdDinner in the usual way (here, I''m just running
    the ASP.NET component, not the full solution):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台导出程序是一个轻量级组件。它在容器启动时启动，并在容器运行时保持运行。只有在调用指标端点时才使用计算资源，因此在Prometheus计划运行时影响最小。我按照通常的方式运行NerdDinner（这里，我只运行ASP.NET组件，而不是完整的解决方案）：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'I can fetch the container port and browse to NerdDinner in the usual way. Then,
    I can also browse to the metrics endpoint on the exporter application''s port,
    which publishes the IIS performance counters:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以按照通常的方式获取容器端口并浏览NerdDinner。然后，我还可以浏览导出程序端口上的指标端点，该端点发布IIS性能计数器：
- en: '![](Images/45dac49c-d499-475b-b061-7b0d59893237.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/45dac49c-d499-475b-b061-7b0d59893237.png)'
- en: In this case, there are no custom counters from the application, and all the
    metrics come from standard Windows and .NET performance counters. The exporter
    application can read these performance counter values for the running `w3wp` process,
    so the application doesn't need to change to provide basic information to Prometheus.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有来自应用程序的自定义计数器，所有指标都来自标准的Windows和.NET性能计数器。导出程序应用程序可以读取运行的`w3wp`进程的这些性能计数器值，因此应用程序无需更改即可向Prometheus提供基本信息。
- en: These are runtime metrics telling you how hard IIS is working inside the container.
    You can see the number of active threads, memory usage, and the size of the IIS
    file cache. There are also metrics for the percentage of HTTP status codes IIS
    has responded with, so you can see if there are large numbers of 404 or 500 errors.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是运行时指标，告诉您IIS在容器内的工作情况。您可以看到活动线程的数量，内存使用情况以及IIS文件缓存的大小。还有关于IIS响应的HTTP状态代码百分比的指标，因此您可以看到是否有大量的404或500错误。
- en: To record custom application metrics, you need to instrument your code and explicitly
    record the data points you're interested in. You need to invest effort for that,
    but the result is an instrumented application where you can see key performance
    metrics in addition to the .NET runtime metrics.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要记录自定义应用程序度量，您需要为您的代码添加仪器，并明确记录您感兴趣的数据点。您需要为此付出努力，但结果是一个已经仪器化的应用程序，在其中您可以看到关键性能度量，除了.NET运行时度量。
- en: Adding instrumentation to your Dockerized application means providing the metrics
    endpoint for Prometheus to query. The Prometheus server itself runs in a Docker
    container, and you configure it with the services you want to monitor.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为Docker化的应用程序添加仪器意味着为Prometheus提供度量端点以进行查询。Prometheus服务器本身在Docker容器中运行，并且您可以配置它以监视您想要监视的服务。
- en: Running a Prometheus server in a Windows Docker container
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows Docker容器中运行Prometheus服务器
- en: Prometheus is a cross-platform application written in Go, so it can run in a
    Windows container or a Linux container. Like other open source projects, the team
    publishes a Linux image on Docker Hub, but you need to build your own Windows
    image. I'm using an existing image that packages Prometheus into a Windows Server
    2019 container from the same `dockersamples/aspnet-monitoring` example on GitHub
    that I used for the ASP.NET exporter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus是一个用Go编写的跨平台应用程序，因此它可以在Windows容器或Linux容器中运行。与其他开源项目一样，团队在Docker Hub上发布了一个Linux镜像，但你需要构建自己的Windows镜像。我正在使用一个现有的镜像，该镜像将Prometheus打包到了来自GitHub上相同的`dockersamples/aspnet-monitoring`示例中的Windows
    Server 2019容器中，我用于ASP.NET导出器。
- en: 'The Dockerfile for Prometheus doesn''t do anything you haven''t already seen
    plenty of times in this book—it downloads the release file, extracts it, and sets
    up the runtime environment. The Prometheus server has multiple functions: it runs
    scheduled jobs to poll metrics endpoints, it stores the data in a time-series
    database, and it provides a REST API to query the database and a simple Web UI
    to navigate the data.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus的Dockerfile并没有做任何在本书中已经看到过很多次的事情——它下载发布文件，提取它，并设置运行时环境。Prometheus服务器有多个功能：它运行定期作业来轮询度量端点，将数据存储在时间序列数据库中，并提供一个REST
    API来查询数据库和一个简单的Web UI来浏览数据。
- en: 'I need to add my own configuration for the scheduler, which I could do by running
    a container and mounting a volume for the config file, or using Docker config
    objects in swarm mode. The configuration for my metrics endpoints is fairly static,
    so it would be nice to bundle a default set of configurations into my own Prometheus
    image. I''ve done that with `dockeronwindows/ch11-prometheus:2e`, which has a
    very simple Dockerfile:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要为调度器添加自己的配置，我可以通过运行一个容器并挂载一个卷来完成，或者在集群模式下使用Docker配置对象。我的度量端点的配置相当静态，因此最好将一组默认配置捆绑到我的自己的Prometheus镜像中。我已经在`dockeronwindows/ch11-prometheus:2e`中做到了这一点，它有一个非常简单的Dockerfile：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I already have containers running from my instrumented API and NerdDinner web
    images, which expose metrics endpoints for Prometheus to consume. To monitor them
    in Prometheus, I need to specify the metric locations in the `prometheus.yml`
    configuration file. Prometheus will poll these endpoints on a configurable schedule.
    It calls this **scraping**, and I''ve added my container names and ports in the
    `scrape_configs` section:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经有从我的仪器化API和NerdDinner web镜像运行的容器，这些容器公开了供Prometheus消费的度量端点。为了在Prometheus中监视它们，我需要在`prometheus.yml`配置文件中指定度量位置。Prometheus将按可配置的时间表轮询这些端点。它称之为**抓取**，我已经在`scrape_configs`部分中添加了我的容器名称和端口：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each application to monitor is specified as a job, and each endpoint is listed
    as a target. Prometheus will be running in a container on the same Docker network,
    so I can refer to the targets by the container name.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要监视的每个应用程序都被指定为一个作业，每个端点都被列为一个目标。Prometheus将在同一Docker网络上的容器中运行，因此我可以通过容器名称引用目标。
- en: This setup is for a single Docker Engine, but you can use the same approach
    with Prometheus to monitor services running across multiple replicas, just using
    different configuration settings. I cover that in detail for Windows and Linux
    containers in my Pluralsight course, *Monitoring Containerized Application Health
    with Docker.*
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '这个设置是为单个Docker引擎设计的，但您可以使用相同的方法使用Prometheus监视跨多个副本运行的服务，只需使用不同的配置设置。我在我的Pluralsight课程*使用Docker监视容器化应用程序健康状况*中详细介绍了Windows和Linux容器。 '
- en: 'Now, I can start the Prometheus server in a container:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以在容器中启动Prometheus服务器：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Prometheus polls all the configured metrics endpoints and stores the data. You
    can use Prometheus as the backend for a rich UI component such as Grafana, building
    all your runtime KPIs into a single dashboard. For basic monitoring, the Prometheus
    server has a simple Web UI listening on port `9090`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus轮询所有配置的指标端点并存储数据。您可以将Prometheus用作丰富UI组件（如Grafana）的后端，将所有运行时KPI构建到单个仪表板中。对于基本监控，Prometheus服务器在端口`9090`上有一个简单的Web
    UI。
- en: 'I can go to the published port of the Prometheus container to run some queries
    over the data it''s scraping from my application containers. The Prometheus UI
    can present the raw data, or aggregated graphs over time. Here''s the HTTP response
    that''s sent by the REST API application:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以转到Prometheus容器的发布端口，对其从我的应用程序容器中抓取的数据运行一些查询。Prometheus UI可以呈现原始数据，或者随时间聚合的图表。这是由REST
    API应用程序发送的HTTP响应：
- en: '![](Images/51c842d2-ccef-4050-804c-944af2e34719.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/51c842d2-ccef-4050-804c-944af2e34719.png)'
- en: You can see that there are separate lines for each different label value, so
    I can see the different response codes from different URLs. These are counters
    that increase with the life of the container, so the graphs will always go up.
    Prometheus has a rich set of functions so that you can also graph the rate of
    change over time, aggregate metrics, and select projections over the data.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到每个不同标签值的单独行，因此我可以看到不同URL的不同响应代码。这些是随着容器的寿命而增加的计数器，因此图表将始终上升。Prometheus具有丰富的功能集，因此您还可以绘制随时间变化的变化率，聚合指标并选择数据的投影。
- en: 'Other counters from the Prometheus `NuGet` package are snapshots, such as performance
    counter statistics. I can see the number of requests per second that IIS is handling
    from the NerdDinner container:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Prometheus `NuGet`软件包的其他计数器是快照，例如性能计数器统计信息。我可以从NerdDinner容器中看到IIS处理的每秒请求的数量：
- en: '![](Images/9cc9e9fb-a94b-4fb5-a7ea-a988d49eb640.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9cc9e9fb-a94b-4fb5-a7ea-a988d49eb640.png)'
- en: Metric names are important in Prometheus. If I wanted to compare the memory
    usage of a .NET Console and an ASP.NET app, then I can query both sets of values
    if they have the same metric name, something like `process_working_set`. The labels
    for each metric identify which service is providing the data, so you can aggregate
    across all your services or filter to specific services. You should also include
    an identifier for each container as a metric label. The exporter app adds the
    server hostname as a label. That's actually the container ID, so when you're running
    at scale, you can aggregate for the whole service or look at individual containers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在Prometheus中，指标名称非常重要。如果我想比较.NET控制台和ASP.NET应用程序的内存使用情况，那么如果它们具有相同的指标名称，比如`process_working_set`，我可以查询两组值。每个指标的标签标识提供数据的服务，因此您可以对所有服务进行聚合或对特定服务进行筛选。您还应该将每个容器的标识符作为指标标签包括在内。导出器应用程序将服务器主机名添加为标签。实际上，这是容器ID，因此在大规模运行时，您可以对整个服务进行聚合或查看单个容器。
- en: In [Chapter 8](98e12163-b4ad-4b5d-aecc-827f5e204caa.xhtml), *Administering and
    Monitoring Dockerized Solutions*, I demonstrated **Universal Control Plane** (**UCP**),
    the **Containers-as-a-Service** (**CaaS**) platform in Docker Enterprise. The
    standard APIs to start and manage Docker containers lets this tool present a consolidated
    management and administration experience. The openness of the Docker platform
    lets open source tools take the same approach to rich, consolidated monitoring.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](98e12163-b4ad-4b5d-aecc-827f5e204caa.xhtml)中，《管理和监控Docker化解决方案》，我演示了Docker
    Enterprise中的**Universal Control Plane**（**UCP**），这是**Containers-as-a-Service**（**CaaS**）平台。启动和管理Docker容器的标准API使该工具能够提供集中的管理和管理体验。Docker平台的开放性使开源工具可以采用相同的方法进行丰富的、集中的监控。
- en: Prometheus is a good example of that. It runs as a lightweight server, which
    is well-suited to running in a container. You add support for Prometheus to your
    application either by adding a metrics endpoint to your app, or by running a metrics
    exporter alongside your existing app. The Docker Engine itself can be configured
    to export Prometheus metrics, so you can collect low-level metrics about container
    and node health.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus就是一个很好的例子。它作为一个轻量级服务器运行，非常适合在容器中运行。您可以通过向应用程序添加指标端点或在现有应用程序旁边运行指标导出器来为应用程序添加对Prometheus的支持。Docker引擎本身可以配置为导出Prometheus指标，因此您可以收集有关容器和节点健康状况的低级指标。
- en: Those metrics are all you need to power a rich dashboard that tells you about
    the health of your application at a glance.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标是您需要的全部内容，可以为您提供关于应用程序健康状况的丰富仪表板。
- en: Building application dashboards in Grafana
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Grafana中构建应用程序仪表板
- en: Grafana is a web UI for visualizing data. It can read from many data sources, including
    time-series databases, such as Prometheus, and relational databases, such as SQL
    Server. You can build dashboards in Grafana that display the health of your whole
    application estate, including business KPIs, application and runtime metrics,
    and infrastructure health.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Grafana是用于可视化数据的Web UI。它可以从许多数据源中读取，包括时间序列数据库（如Prometheus）和关系数据库（如SQL Server）。您可以在Grafana中构建仪表板，显示整个应用程序资产的健康状况，包括业务KPI、应用程序和运行时指标以及基础设施健康状况。
- en: 'You typically add Grafana in a containerized application to present the data
    from Prometheus. You run Grafana in a container too, and you can package your
    Docker image so that the dashboards, user accounts, and database connections are
    built-in. I''ve done that for the final part of this chapter, in the `dockeronwindows/ch11-grafana:2e` image.
    The Grafana team don''t publish a Windows image on Docker Hub, so my Dockerfile
    starts from a sample image and adds in all the configuration for my setup:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会将Grafana添加到容器化应用程序中，以呈现来自Prometheus的数据。您也可以在容器中运行Grafana，并且可以打包您的Docker镜像，以便内置仪表板、用户帐户和数据库连接。我已经为本章的最后部分做了这样的处理，在`dockeronwindows/ch11-grafana:2e`镜像中。Grafana团队没有在Docker
    Hub上发布Windows镜像，因此我的Dockerfile从示例镜像开始，并添加了我设置的所有配置。
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Grafana has two approaches to automating deployment. The first just uses files
    in known locations, which I use to set up the Prometheus data source, the dashboard,
    and the dashboard provider, which just points Grafana to a directory for dashboards.
    The second uses a REST API for authentication and authorization, and my `init.ps1`
    script uses that to create a read-only user with access to the dashboard.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Grafana有两种自动部署方法。第一种只是使用已知位置的文件，我用它来设置Prometheus数据源、仪表板和仪表板提供程序，它只是将Grafana指向仪表板目录。第二种使用REST
    API进行身份验证和授权，我的`init.ps1`脚本使用它来创建一个只读用户，该用户可以访问仪表板。
- en: It's simple to create your own dashboards with Grafana. You create a panel for
    a particular type of visualization—numbers, graphs, heatmaps, traffic lights,
    and tables are all supported. Then, you connect the panel to a data source and
    specify the query. Typically, you'd use the Prometheus UI to fine-tune the query
    and then add it to Grafana. To save time, my image comes with a ready-made dashboard.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Grafana创建自己的仪表板很简单。您可以为特定类型的可视化创建面板——支持数字、图形、热图、交通灯和表格。然后，您将面板连接到数据源并指定查询。通常，您会使用Prometheus
    UI来微调查询，然后将其添加到Grafana中。为了节省时间，我的镜像带有一个现成的仪表板。
- en: 'I''ll start the monitoring solution with the Docker Compose file in the `ch11`
    folder, then browse to the API and the website to generate some traffic. Now,
    I can browse to Grafana and log in with the username `viewer` and password `readonly`,
    and I''ll see the dashboard:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用`ch11`文件夹中的Docker Compose文件启动监控解决方案，然后浏览API和网站以生成一些流量。现在，我可以浏览Grafana，并使用用户名`viewer`和密码`readonly`登录，然后我会看到仪表板：
- en: '![](Images/a8ac5193-aa9c-433f-811e-5e25f9899cfa.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a8ac5193-aa9c-433f-811e-5e25f9899cfa.png)'
- en: This is just a sample dashboard, but it gives you an idea about how much information
    you can present. I have a row for the REST API, showing a breakdown of HTTP requests
    and responses, and an overall view of the CPU usage. I also have a row for NerdDinner,
    showing performance metrics from IIS and headline statistics for cache usage.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个示例仪表板，但它让您了解可以呈现多少信息。我为REST API设置了一行，显示了HTTP请求和响应的细分，以及CPU使用情况的整体视图。我还为NerdDinner设置了一行，显示了来自IIS的性能指标和缓存使用的头条统计数据。
- en: You can add instrumentation to all your applications with very little effort
    and build a detailed dashboard to give you insight into what's happening in your
    solution. What's more, you can have the exact same monitoring facility in every
    environment, so in development and test you can see the same metrics that you
    use in production. This is very useful in tracking down performance issues. Developers
    can add a new metric and visualization for a performance problem, fix the problem,
    and when the change goes live, it will include the new metric that can be tracked
    in production.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地向所有应用程序添加工具，并构建详细的仪表板，以便深入了解解决方案中发生的情况。而且，您可以在每个环境中具有完全相同的监视设施，因此在开发和测试中，您可以看到与生产中使用的相同指标。这在追踪性能问题方面非常有用。开发人员可以为性能问题添加新的指标和可视化，解决问题，当更改生效时，它将包括可以在生产中跟踪的新指标。
- en: The last thing I'll cover in this chapter is how to approach fixing bugs in
    Docker, and how containerization makes it so much easier.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章中讨论的最后一件事是如何修复Docker中的错误，以及容器化如何使这变得更加容易。
- en: The bug fixing workflow in Docker
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker中的错误修复工作流程
- en: One of the biggest difficulties in fixing production defects is replicating
    them in your development environment. This is the first step in confirming that
    you have a bug and the starting point for drilling down to find the problem. It
    can also be the most time-consuming part of the problem.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复生产缺陷时最大的困难之一是在开发环境中复制它们。这是确认您有错误并深入查找问题的起点。这也可能是问题中最耗时的部分。
- en: Large .NET projects tend to have infrequent releases because the release process
    is complex, and a lot of manual testing is needed to verify the new features and
    check for any regressions. It's not unusual to have just three or four releases
    a year and for developers to find themselves having to support multiple versions
    of an application in different parts of the release process.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 大型.NET项目往往发布不频繁，因为发布过程复杂，并且需要大量手动测试来验证新功能并检查任何回归。一年可能只有三到四次发布，并且开发人员可能发现自己不得不在发布过程的不同部分支持应用程序的多个版本。
- en: In this scenario, you may have version 1.0 in production, version 1.1 in **user
    acceptance testing** (**UAT**), and version 1.2 in system testing. Bugs could
    be raised in any of these versions that the development team needs to track down
    and fix while they're currently working on version 1.3, or even a major upgrade
    for 2.0.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可能在生产中有1.0版本，在用户验收测试（UAT）中有1.1版本，在系统测试中有1.2版本。开发团队可能需要跟踪和修复任何这些版本中提出的错误，而他们目前正在处理1.3版本，甚至是2.0的重大升级。
- en: Bug fixing before Docker
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker之前修复错误
- en: I've been in this position lots of times, having to context switch from the
    refactored 2.0 code base I'm working on back to the 1.1 code base that is due
    to be released. The context switch is expensive, but the process of setting up
    my development environment to recreate the 1.1 UAT environment is even more costly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常处于这种境地，不得不从我正在工作的重构后的2.0代码库切换回即将发布的1.1代码库。上下文切换是昂贵的，但是设置开发环境以重新创建1.1 UAT环境的过程更加昂贵。
- en: The release process may create a versioned MSI, but typically you can't just
    run that in your development environment. The installer may be packaged with the
    configuration for a specific environment. It may have been compiled in release
    mode and packaged without PDB files, so there's no option to attach a debugger,
    and it may have prerequisites that I don't have available in development, such
    as certificates or encryption keys or additional software components.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 发布过程可能会创建一个带版本号的MSI，但通常你不能在开发环境中直接运行它。安装程序可能会打包特定环境的配置。它可能已经以发布模式编译并且没有PDB文件，因此没有附加调试器的选项，它可能具有我在开发中没有的先决条件，比如证书、加密密钥或其他软件组件。
- en: Instead, I need to recompile the 1.1 version from source. Hopefully, the release
    process has enough information for me to find the exact source code that was used
    to build the release, take a branch, and clone it locally (maybe the Git commit
    ID or the TFS change set is recorded in the built assemblies). Then, the real
    problems start when I try to recreate another environment on my local development
    box.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我需要重新编译源代码中的1.1版本。希望发布过程提供了足够的信息，让我找到用于构建发布的确切源代码，然后在本地克隆它（也许Git提交ID或TFS变更集记录在构建的程序集中）。然后，当我尝试在我的本地开发环境中重新创建另一个环境时，真正的问题开始了。
- en: 'The workflow looks a little like this, where there are lots of differences
    between my setup and the 1.1 environment:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程看起来有点像这样，在我的设置和1.1环境之间存在许多差异：
- en: Compile the source locally. I'll build the app in Visual Studio, but the released
    version uses MSBuild scripts, which do a lot of extra things.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地编译源代码。我将在Visual Studio中构建应用程序，但发布版本使用的是MSBuild脚本，它做了很多额外的事情。
- en: Run the app locally. I'll be using IIS Express on Windows 10, but the release
    uses an MSI that deploys to IIS 8 on Windows Server 2012.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地运行应用程序。我将在Windows 10上使用IIS Express，但发布使用的是部署到Windows Server 2012上的IIS 8的MSI。
- en: My local SQL Server database is set up for the 2.0 schema I'm working on. The
    release has upgrade scripts from 1.0 to 1.1, but there are no downgrade scripts
    from 2.0 to 1.1, so I need to manually fix the local schema.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的本地SQL Server数据库设置为我正在使用的2.0架构。发布中有从1.0升级到1.1的升级脚本，但没有从2.0降级到1.1的脚本，因此我需要手动修复本地架构。
- en: I have stubs for any dependencies I can't run locally, such as third-party APIs.
    The release uses real application components.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我无法在本地运行的任何依赖项，例如第三方API，我有存根。发布使用真实的应用程序组件。
- en: Even if I can get the exact source code for version 1.1, my development environment
    is hugely divergent from the UAT environment. This is the best I can do, and it
    may take several hours of effort. To reduce this time, I could take shortcuts,
    such as using my knowledge of the app to run version 1.1 against the 2.0 database
    schema, but taking shortcuts means my local environment is even less like the
    target environment.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我可以获得版本1.1的确切源代码，我的开发环境与UAT环境存在巨大差异。这是我能做的最好的，可能需要数小时的努力。为了减少这段时间，我可以采取捷径，比如利用我对应用程序的了解来运行版本1.1与2.0数据库架构，但采取捷径意味着我的本地环境与目标环境更不相似。
- en: I can run the app in debug mode at this point and try to replicate the issue.
    If the bug is caused by a data problem or an environmental problem in UAT, then
    I won't be able to replicate it and it could have taken a whole day of effort
    to find that out. If I suspect that the issue is to do with the setup of UAT,
    I can't verify that in my environment; I need to work with the Ops team to look
    at the UAT configuration.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我可以以调试模式运行应用程序并尝试复制问题。如果错误是由UAT中的数据问题或环境问题引起的，那么我将无法复制它，可能需要花费整整一天的时间才能找出这一点。如果我怀疑问题与UAT的设置有关，我无法在我的环境中验证这一点；我需要与运维团队合作，查看UAT配置。
- en: But hopefully I can reproduce the issue by following the steps in the bug report.
    When I have the manual steps worked out, I can write a failing test that replicates
    the issue and be confident that I've fixed the problem when I change the code
    and the test runs green. There are differences between my environment and UAT,
    so it could be that my analysis is not correct and the fix won't fix UAT, but
    I won't find that out until the next release.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但希望我可以通过按照错误报告中的步骤重现问题。当我弄清楚手动步骤后，我可以编写一个失败的测试来复制问题，并且在更改代码并且测试运行成功时，我可以确信我已经解决了问题。我的环境与UAT之间存在差异，因此可能是我的分析不正确，修复无法修复UAT，但直到下一个发布之前我才能发现这一点。
- en: How that fix gets released into the UAT environment is another problem. Ideally,
    the full CI and packaging process is already set up for the 1.1 branch, so I just
    push my changes and a new MSI comes out that is ready to be deployed. In the worst
    case, the CI runs only from the master branch, so I need to set up a new job on
    the fix branch and try to configure that job to be the same as it was for the
    last 1.1 release.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将该修复发布到UAT环境是另一个问题。理想情况下，完整的CI和打包过程已经为1.1分支设置好，因此我只需推送我的更改，然后就会出现一个准备部署的新MSI。在最坏的情况下，CI仅从主分支运行，因此我需要在修复分支上设置一个新的作业，并尝试配置该作业与上次1.1发布时相同。
- en: If any part of the toolchain has moved on between 1.1 and 2.0, then it makes
    every step of the process more difficult, from configuring the local environment,
    running the app, analyzing the problem, and pushing the fix.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在1.1和2.0之间的任何工具链部分发生了变化，那么这将使整个过程的每一步都变得更加困难，从配置本地环境，运行应用程序，分析问题到推送修复。
- en: Bug fixing with Docker
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker修复错误
- en: The process is much simpler with Docker. To replicate the UAT environment locally,
    I just need to run containers from the same images that are running in UAT. There
    will be a Docker Compose or stack file describing the whole solution which is
    versioned, so by deploying version 1.1, I get the exact same environment as UAT
    without having to build from source.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker的过程要简单得多。要在本地复制UAT环境，我只需要从在UAT中运行的相同镜像中运行容器。将有一个描述整个解决方案的Docker Compose或堆栈文件进行版本控制，因此通过部署版本1.1，我可以获得与UAT完全相同的环境，而无需从源代码构建。
- en: I should be able to replicate the issue at this point and confirm whether it's
    a coding issue or something to do with data or the environment. If it's a configuration
    issue, then I should see the same problem as UAT, and I could test the fix with
    an updated Compose file. If it's a coding issue, then I need to dig into the code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该能够在这一点上复制问题并确认它是编码问题还是与数据或环境有关的问题。如果是配置问题，那么我应该看到与UAT相同的问题，并且我可以使用更新的Compose文件测试修复。如果是编码问题，那么我需要深入了解代码。
- en: At this point, I can clone the source from the version 1.1 tag and build the
    Docker images in debug mode, but I don't spend time doing that until I'm pretty
    sure this is a problem in the app. If I'm using multi-stage builds with all versions
    pinned in the Dockerfile, the local build will produce an identical image to the
    one running in UAT, but with the extra artifacts for debugging.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我可以从版本1.1标签中克隆源代码并以调试模式构建Docker镜像，但除非我相当确定这是应用程序中的问题，否则我不会花时间这样做。如果我在Dockerfile中使用多阶段构建，并且所有版本都在其中固定，那么本地构建将产生与在UAT中运行的相同镜像，但会有额外的用于调试的工件。
- en: Now, I can find the problem, write a test, and fix the bug. When the new integration
    test passes, it's executing against the same Dockerized solution I'll be deploying
    in UAT, so I can be very confident that the bug is fixed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以找到问题，编写测试并修复错误。当新的集成测试通过时，它是针对我将在UAT中部署的相同Docker化解决方案执行的，因此我可以非常确信该错误已经被修复。
- en: If there's no CI configured for the 1.1 branch, then setting it up should be
    straightforward because the build task will just need to run the `docker image
    build` or `docker-compose build` commands. If I want fast feedback, I can even
    push the locally built image to the registry and deploy a new UAT environment
    to verify the fix while the CI setup is being configured. That new environment
    will just be a different stack on the test cluster, so I don't need to commission
    any more infrastructure for the deployment.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果1.1分支没有配置CI，那么设置它应该很简单，因为构建任务只需要运行`docker image build`或`docker-compose build`命令。如果我想要快速反馈，我甚至可以将本地构建的镜像推送到注册表，并部署一个新的UAT环境来验证修复，同时配置CI设置。新环境将只是测试集群上的不同堆栈，因此我不需要为部署再委托更多的基础设施。
- en: The workflow with Docker is much cleaner and faster, but more importantly, there
    is far less risk. When you replicate the issue locally, you are using the exact
    same application components running on the exact same platform as the UAT environment.
    When you test your fix, you know it will work in UAT because you'll be deploying
    the same new artifacts.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的工作流程更加清洁和快速，但更重要的是，风险要小得多。当您在本地复制问题时，您使用的是与UAT环境上完全相同的应用程序组件在完全相同的平台上运行。当您测试您的修复时，您知道它将在UAT中起作用，因为您将部署相同的新构件。
- en: The time you invest in Dockerizing your application will be repaid many times
    over by the time saved in supporting multiple versions of the app.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将您投入Docker化应用程序的时间将通过节省支持应用程序多个版本的时间而多次偿还。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter looked at troubleshooting applications running in containers, along
    with debugging and instrumentation. Docker is a new application platform, but
    applications in containers run as processes on the host, so they're still suitable
    targets for remote debugging and centralized monitoring.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了在容器中运行的应用程序的故障排除，以及调试和仪器化。Docker是一个新的应用程序平台，但是容器中的应用程序作为主机上的进程运行，因此它们仍然是远程调试和集中监控的合适目标。
- en: Support for Docker is available in all the current versions of Visual Studio.
    Visual Studio 2017 has the most complete support, covering Linux and Windows containers.
    Visual Studio 2015 and Visual Studio Code currently have extensions that provide
    debugging for Linux containers. You can easily add your own support for Windows
    containers, but the full debugging experience is still evolving.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio的所有当前版本都支持Docker。Visual Studio 2017具有最完整的支持，涵盖Linux和Windows容器。Visual
    Studio 2015和Visual Studio Code目前具有提供Linux容器调试的扩展。您可以轻松添加对Windows容器的支持，但完整的调试体验仍在不断发展。
- en: In this chapter, I also introduced Prometheus, a lightweight instrumentation
    and monitoring component that you can run in a Windows Docker container. Prometheus
    stores the metrics it extracts from applications running on other containers.
    The standardized nature of containers makes monitoring solutions such as these
    very simple to configure. I used Prometheus data to drive a dashboards in Grafana,
    running in a container, which is a simple and powerful way of presenting a consolidated
    view of the health of your application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我还介绍了Prometheus，这是一个轻量级的仪器和监控组件，您可以在Windows Docker容器中运行。Prometheus存储它从其他容器中运行的应用程序提取的指标。容器的标准化性质使得配置诸如这样的监控解决方案非常简单。我使用Prometheus数据来驱动Grafana中的仪表板，该仪表板在容器中运行，这是呈现应用程序健康状况的综合视图的简单而强大的方式。
- en: The next chapter is the final chapter of this book. I'll end by sharing some
    approaches to get started with Docker in your own domain, including case studies
    where I have used Docker on Windows for existing projects.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是本书的最后一章。我将以分享一些在您自己的领域中开始使用Docker的方法结束，包括我在现有项目中在Windows上使用Docker的案例研究。
