- en: Building a Chat Room Application Using Socket.IO
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Socket.IO构建聊天室应用程序
- en: In this chapter, we are going to cover how to build an Angular chat room application
    using Socket.IO in order to delve into the ability to send messages back and forth
    between the client and server without having to establish REST APIs or through
    the use of GraphQL queries. The technology we are going to use involves the establishment
    of a long-running connection from the client to the server, making communication
    as simple as passing a message.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何使用Socket.IO构建一个Angular聊天室应用程序，以便探索在客户端和服务器之间发送消息的能力，而无需建立REST API或通过使用GraphQL查询。我们将使用的技术涉及从客户端到服务器的建立长时间运行的连接，使通信变得像传递消息一样简单。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Long-running client/server communications using Socket.IO
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Socket.IO进行长时间运行的客户端/服务器通信
- en: Creating a Socket.IO server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Socket.IO服务器
- en: Creating an Angular client and adding Socket.IO support
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Angular客户端并添加Socket.IO支持
- en: Using decorators to add client-side logging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器添加客户端日志记录
- en: Using Bootstrap in our client
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的客户端使用Bootstrap
- en: Adding Bootstrap navigation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加Bootstrap导航
- en: Signing up to Auth0 to authenticate our client
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册Auth0以对我们的客户端进行身份验证
- en: Adding Auth0 support to our client
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的客户端添加Auth0支持
- en: Adding secure Angular routing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加安全的Angular路由
- en: Hooking up to Socket.IO messages at our client and server
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的客户端和服务器上连接到Socket.IO消息
- en: Using Socket.IO namespaces to segregate messages
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Socket.IO命名空间来分隔消息
- en: Adding room support
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加房间支持
- en: Receiving and sending messages
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收和发送消息
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter06](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter06)[.](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter06)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的项目可以从[https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter06](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter06)下载。
- en: After downloading the project, you will have to install the package requirements
    using the `npm install` command.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下载项目后，您将需要使用`npm install`命令安装软件包要求。
- en: Long-running client/server communications using Socket.IO
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Socket.IO进行长时间运行的客户端/服务器通信
- en: So far, we have covered a variety of ways of communicating back and forth between
    a client and a server, but they have all had one thing in common—they were reacting
    to some form of interaction to trigger the transfer of data. Irrespective of whether
    we clicked a link or pushed a button, there was some user input that triggered
    that back and forth between the two sides.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了各种方式在客户端和服务器之间进行来回通信，但它们都有一个共同点——它们都是对某种形式的交互做出反应，以触发数据传输。无论我们点击了链接还是按下了按钮，都有一些用户输入触发了双方之间的来回交流。
- en: There are some situations, however, where we would like to keep the lines of
    communication between the client and the server open permanently so that data
    can be pushed as soon as it's available. If we were playing an online game, for
    instance, we wouldn't want to have to push a button just to get other players'
    statuses updated on our screen. What we need is a technology that maintains the
    connection for us and allows us to pass messages without issues.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下，我们希望保持客户端和服务器之间的通信线路永久打开，以便在数据可用时立即推送数据。例如，如果我们在玩在线游戏，我们不希望必须按下按钮才能更新屏幕上其他玩家的状态。我们需要的是一种能够为我们维护连接并允许我们无障碍传递消息的技术。
- en: Over the years, there have been a number of technologies that have evolved with
    a view of addressing precisely this problem. Some of these technologies, such
    as flash sockets, have fallen out of favor because they rely on proprietary systems.
    Collectively, these are known as **push technologies**, and a standard called
    **WebSocket** has emerged and become commonplace, with all the major browsers
    supporting it. What is worth knowing is that WebSocket sits alongside HTTP as
    a cooperative protocol.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，已经出现了许多旨在解决这一问题的技术。其中一些技术，如Flash套接字，因依赖专有系统而不受青睐。总称为**推送技术**，并出现了一种称为**WebSocket**的标准，并变得普遍，所有主要浏览器都支持它。值得知道的是，WebSocket与HTTP并存作为一种合作协议。
- en: Here is a piece of WebSocket trivia for you. While HTTP uses HTTP or HTTPS to
    identify the protocol, the specification for WebSockets defines **WS** or **WSS **(short
    for **WebSocket Secure**) as the protocol identifier.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个关于WebSocket的趣闻。虽然HTTP使用HTTP或HTTPS来标识协议，但WebSocket的规范定义了**WS**或**WSS**（WebSocket
    Secure的缩写）作为协议标识符。
- en: In the node world, Socket.IO has become the *de facto* standard for enabling
    WebSocket communication. We are going to use it to build a chat room application
    that keeps the chat open for all connected users.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node世界中，Socket.IO已成为启用WebSocket通信的*事实*标准。我们将使用它来构建一个保持所有连接用户聊天室应用程序。
- en: Project overview
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: The *classic* socket-based application is creating a chat room. It's almost
    the *Hello World* of socket applications. The reason that a chat room is so useful
    for this is because it allows us to explore techniques such as sending messages
    to other users, reacting to messages from other users, and using rooms to separate
    where chats are sent.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*经典*基于套接字的应用程序是创建一个聊天室。这几乎是套接字应用程序的*Hello World*。聊天室之所以如此有用，是因为它允许我们探索诸如向其他用户发送消息、对来自其他用户的消息做出反应以及使用房间来分隔消息发送位置等技术。'
- en: Material design played a large part in its development over the past couple
    of chapters, so now is a suitable time for us to return to Bootstrap 4 and see
    how we can use it to lay out the interface in an Angular application. We will
    also work with Socket.IO at the client and the server to enable bi-directional
    communication. Something that has been lacking in previous chapters has been the
    ability to authenticate the user. In this chapter, we are going to bring in authentication
    support by signing up to use Auth0 ([https://auth0.com/](https://auth0.com/)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，Material Design在其开发中起到了很大作用，所以现在是我们返回到Bootstrap 4并看看如何在Angular应用程序中使用它来布局界面的合适时机。我们还将在客户端和服务器上使用Socket.IO来实现双向通信。在以前的章节中缺少的是对用户进行身份验证的能力。在本章中，我们将通过注册使用Auth0（[https://auth0.com/](https://auth0.com/)）来引入身份验证支持。
- en: 'Working alongside the GitHub code, this chapter should take about two hours
    to complete. When completed, the application should appear as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与GitHub代码一起工作，完成本章大约需要两个小时。完成后，应用程序应如下所示：
- en: '![](assets/dc5c7471-d8bc-47a2-be5f-b0db66be0c1b.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dc5c7471-d8bc-47a2-be5f-b0db66be0c1b.png)'
- en: Now that we know what type of application we want to build, and what we want
    it to look like, we are ready to start building our application. In the next section,
    we are going to look at how to add external authentication to our application
    using Auth0.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们想要构建什么类型的应用程序，以及我们希望它看起来像什么，我们准备开始构建我们的应用程序。在下一节中，我们将看看如何使用Auth0为我们的应用程序添加外部身份验证。
- en: Getting started with Socket.IO and Angular
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Socket.IO和Angular入门
- en: Most of the requirements, such as Node.js and Mongoose, are the same as in earlier
    chapters, so we are no longer going to list the additional components. As we go
    through this chapter, we will call out any new components that we need. As always,
    the canonical place for finding out what we are using is the code in GitHub.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数要求，如Node.js和Mongoose，与前几章相同，因此我们不再列出额外的组件。在本章中，我们将指出我们需要的任何新组件。总是可以在GitHub的代码中找到我们使用的内容。
- en: As part of this chapter, we are going to use Auth0 ([https://auth0.com](https://auth0.com))
    to authenticate our users. Auth0 is one of the most popular choices available
    for authentication as it takes care of all of the infrastructure. All we need
    to provide is a secure login and information storage mechanism. The idea behind
    us using Auth0 is that we will take advantage of their APIs to verify the identity
    of someone who is using our application through the use of the **open authentication** (**OAuth**)
    framework, which allows us to automatically show or hide access to parts of our
    application based on this authentication. With OAuth, and its successor OAuth
    2, we are using a standard authorization protocol that allows authenticated users
    access to features of our application without having to sign up to our site and
    provide login information.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的一部分，我们将使用Auth0（[https://auth0.com](https://auth0.com)）来对我们的用户进行身份验证。Auth0是身份验证的最受欢迎的选择之一，因为它负责所有基础设施。我们只需要提供一个安全的登录和信息存储机制。我们使用Auth0的想法是利用他们的API来验证使用我们的应用程序的人的身份，通过使用**开放认证**（**OAuth**）框架，这使我们能够根据这种身份验证自动显示或隐藏我们应用程序的部分访问权限。使用OAuth及其后继者OAuth
    2，我们使用了一个标准的授权协议，允许经过身份验证的用户访问我们应用程序的功能，而无需注册我们的网站并提供登录信息。
- en: Initially, this chapter was going to use a passport to provide authentication
    support but, given recent high-profile security issues from companies such as
    Facebook, I decided that we would look at Auth0 to take care of and manage our
    authentication. With authentication, I find that it's best to make sure I'm using
    the best of breed when it comes to security.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，本章将使用护照提供身份验证支持，但考虑到最近来自Facebook等公司的备受关注的安全问题，我决定我们将使用Auth0来处理和管理我们的身份验证。在身份验证方面，我发现最好确保在安全性方面使用最好的技术。
- en: 'Before we write any code at all, we are going to sign up to Auth0 and create
    the infrastructure we need for a single page web application. Begin by clicking
    the Sign Up button, which will redirect you to the following URL: [https://auth0.com/signup?&signUpData=%7B%22category%22%3A%22button%22%7D](https://auth0.com/signup?&signUpData=%7B%22category%22%3A%22button%22%7D).
    I chose to sign up with my GitHub account, but you can choose any of the options
    available.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写任何代码之前，我们将注册到Auth0并创建我们需要的单页Web应用程序基础设施。首先点击“注册”按钮，这将重定向您到以下URL：[https://auth0.com/signup?&signUpData=%7B%22category%22%3A%22button%22%7D](https://auth0.com/signup?&signUpData=%7B%22category%22%3A%22button%22%7D)。我选择使用我的GitHub帐户注册，但您可以选择任何可用的选项。
- en: Auth0 provides us with a variety of premium paid-for services as well as the
    free version. We only require the basic features, so the free version is perfect
    for our needs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Auth0为我们提供了各种付费高级服务以及免费版本。我们只需要基本功能，所以免费版本非常适合我们的需求。
- en: 'Once you have signed up, you need to press the Create Application button, which
    will bring up the Create Application dialog. Give it a name and choose Single
    Page Web App before clicking the CREATE button to create the Auth0 application:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注册后，您需要按“创建应用程序”按钮，这将弹出“创建应用程序”对话框。给它一个名称，并选择“单页Web应用程序”，然后单击“创建”按钮创建Auth0应用程序：
- en: '![](assets/9f145e06-448b-4ac8-803f-133153f590d8.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9f145e06-448b-4ac8-803f-133153f590d8.png)'
- en: 'If you click the Settings tab, you should have something that looks like the
    following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您单击“设置”选项卡，您应该会看到类似以下内容的东西：
- en: '![](assets/1d372384-f3ed-4778-ad9e-73ba49ea0f4f.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1d372384-f3ed-4778-ad9e-73ba49ea0f4f.png)'
- en: There are options available for callback URLs, allowed web origins, logout URLs,
    CORS, and so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有回调URL、允许的Web起源、注销URL、CORS等选项可用。
- en: The full scope of Auth0 is outside the scope of this book, but I would recommend
    reading the documentation provided and setting these settings as appropriate for
    any applications you create.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Auth0的全部范围超出了本书的范围，但我建议阅读提供的文档，并根据您创建的任何应用程序适当地设置这些设置。
- en: 'Security note: Where I am providing details about client IDs or similar unique
    identifiers in this book, these are purely for the purpose of illustrating the
    code. Any live IDs will be deactivated as a matter of security. I would advise
    you to adopt similar good practices and not commit live identifiers or passwords
    in a public location such as GitHub.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 安全提示：在本书中，我提供有关客户端ID或类似唯一标识符的详细信息，这纯粹是为了说明代码。任何实时ID都将被停用以确保安全。我建议您采用类似的良好做法，不要在GitHub等公共位置提交实时标识符或密码。
- en: Creating a chat room application using Socket.IO, Angular, and Auth0
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Socket.IO、Angular和Auth0创建聊天室应用程序
- en: 'Before we start with our development, we should figure out what we want to
    build. Since a chat room is a common enough application, it is easy for us to
    come up with a standard set of requirements that will help us exercise the different
    aspects of Socket.IO. The requirements for the application we are going to build
    are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始开发之前，我们应该弄清楚我们想要构建什么。由于聊天室是一个足够常见的应用程序，我们很容易想出一套标准的要求，这将帮助我们练习Socket.IO的不同方面。我们要构建的应用程序的要求如下：
- en: A user will be able to send a message to be seen by all users in a general chat
    page
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够发送消息，让所有用户在通用聊天页面上看到
- en: The user will be able to log in to the application, at which point a secure
    page will be available
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够登录应用程序，此时将有一个安全页面可用
- en: Logged-in users will be able to send messages that are visible only to other
    logged-in users
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已登录用户将能够发送消息，只有其他已登录用户才能看到
- en: Old messages will be retrieved and displayed to the user when they connect
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接时，旧消息将被检索并显示给用户
- en: Creating our application
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的应用程序
- en: 'By now, creating a node application should be second nature, so we aren''t
    going to cover how to do that anymore. The `tsconfig` file that we are going to
    use is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，创建一个节点应用程序应该是驾轻就熟的，所以我们不会再覆盖如何做了。我们将使用的`tsconfig`文件如下：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The incremental flag in the settings is a new feature introduced in TypeScript
    3.4 that allows us to perform incremental builds. What this feature does is build
    something called a project graph when the code is compiled. The next time the
    code is built, the project graph is used to identify code that hasn't changed,
    meaning that it doesn't need to be rebuilt. In bigger applications, this can save
    a lot of time in terms of compiling.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 设置中的增量标志是TypeScript 3.4引入的一个新功能，它允许我们执行增量构建。这个功能的作用是在代码编译时构建一个称为项目图的东西。下次编译代码时，项目图将用于识别未更改的代码，这意味着它不需要重新构建。在更大的应用程序中，这可以节省大量编译时间。
- en: 'We are going to save messages to a database, so it''s going to come as no surprise
    that we are going to start off with the database connection code. What we are
    going to do on this occasion is move our database connection to a class decorator
    that accepts the name of the database as the parameter to the decorator factory:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把消息保存到数据库中，所以毫无疑问，我们将从数据库连接代码开始。这一次，我们要做的是将数据库连接移到一个类装饰器，该装饰器接受数据库名称作为装饰器工厂的参数：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Don't forget to install `mongoose` and `@types/mongoose` before creating this.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建之前，不要忘记安装`mongoose`和`@types/mongoose`。
- en: 'With this in place, when we create our `server` class, we simply need to decorate
    it, like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，当我们创建我们的`server`类时，我们只需要装饰它，就像这样：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That's it. When `SocketServer` is instantiated, the database will be connected
    automatically. I have to admit that I really like the simplicity of this approach.
    It's an elegant technique that can be carried over into other applications.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。当`SocketServer`被实例化时，数据库将自动连接。我必须承认，我真的很喜欢这种简单的方法。这是一种优雅的技术，可以应用到其他应用程序中。
- en: 'In the previous chapter, we built a `DataAccessBase` class to simplify the
    way we worked with data. We are going to take that class and remove some of the
    methods we aren''t going to use in this application. At the same time, we are
    going to see how we can remove the hard model constraints. Let''s start with the
    class definition:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个`DataAccessBase`类来简化我们处理数据的方式。我们将采取这个类，并删除一些在本应用程序中不会使用的方法。同时，我们将看看如何删除硬模型约束。让我们从类定义开始：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Add` method should also look familiar from the previous chapter:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add`方法在上一章中也应该看起来很熟悉：'
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the previous chapter, we had a constraint that finding a record needed to
    have a field called `Id` on it. While that was an acceptable limitation there,
    we really don''t want to force applications to have `Id` as a field. We are going
    to provide a more open implementation that will allow us to specify any criteria
    we need for retrieving records and the ability to select what fields to return:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们有一个约束，即查找记录需要有一个名为`Id`的字段。虽然那是一个可以接受的限制，但我们真的不想强制应用程序必须有`Id`作为字段。我们将提供一个更开放的实现，允许我们指定检索记录所需的任何条件以及选择要返回的字段的能力：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Just like in the previous chapter, we are going to create a `mongoose.Document`-based
    interface and a `Schema` type. This will form the message contract and will store
    details about the room, the message text, and the date when we received the message.
    These will then be combined to create the physical model that we need to use as
    our database. Let''s see how:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在上一章中一样，我们将创建一个基于`mongoose.Document`的接口和一个`Schema`类型。这将形成消息合同，并将存储有关房间、消息文本和接收消息的日期的详细信息。然后，这些将被组合以创建我们需要用作数据库的物理模型。让我们看看如何做：
- en: 'First, we define the `mongoose.Document` implementation:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义`mongoose.Document`实现：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Schema` type that corresponds to this looks like this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对应的`Schema`类型如下：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we create a `MessageModel` instance, which we will use to create the
    data access class that we will use to save and retrieve data:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`MessageModel`实例，我们将使用它来创建数据访问类，用于保存和检索数据：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding Socket.IO support to our server
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为服务器添加Socket.IO支持
- en: 'We have now reached the point where we are ready to bring Socket.IO into our
    server and create a running server implementation. Run the following command to
    incorporate Socket.IO and the related `DefinitelyTyped` definitions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到了准备将Socket.IO引入到我们的服务器并创建一个运行的服务器实现的阶段。运行以下命令来整合Socket.IO和相关的`DefinitelyTyped`定义：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With these definitions available to us, we are going to bring Socket.IO support
    into our server and begin running it, ready to receive and transmit messages:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些定义，我们将把Socket.IO支持引入到我们的服务器中，并开始运行它，准备接收和传输消息：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The parameter that our `OnConnect` method receives is the starting point for
    receiving and reacting to messages in Socket.IO. We use this to *listen* for a
    connection message that will indicate that a client has connected. When the client
    connects, it opens up what amounts to a socket for us on which to start receiving
    and sending messages. When we want to send messages directly to a particular client,
    we will use methods available from the `socket` that''s returned in the following
    code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`OnConnect`方法接收的参数是在Socket.IO中接收和响应消息的起始点。我们用这个参数来*监听*连接消息，这将表明客户端已连接。当客户端连接时，它为我们打开了一个类似套接字的东西，用于开始接收和发送消息。当我们想直接向特定客户端发送消息时，我们将使用以下代码片段中返回的`socket`可用的方法：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At this point, we need to understand that even though the name of the technology
    is Socket.IO, this is not a WebSocket implementation. While it can use web sockets,
    there is no guarantee that it actually will; for instance, corporate policies
    might prohibit the use of sockets. So, how does Socket.IO actually work? Well,
    Socket.IO is made up of a number of different cooperating technologies, one of
    which is called Engine.IO, and this provides the underlying transport mechanism.
    The first type of connection it takes, when connecting, is an HTTP long poll,
    which is a fast and efficient transport mechanism to open. During idle periods,
    Socket.IO attempts to determine whether the transport can be changed over to a
    socket and, if it can use a socket, it seamlessly and invisibly upgrades the transport
    to use sockets. As far as the client is concerned, they connect quickly, and messages
    are reliable since the Engine.IO part establishes connections even if firewalls
    and load balancers are present.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要明白，尽管技术的名称是Socket.IO，但这不是一个WebSocket实现。虽然它可以使用WebSockets，但并不能保证它实际上会使用；例如，企业政策可能禁止使用套接字。那么，Socket.IO实际上是如何工作的呢？嗯，Socket.IO由许多不同的协作技术组成，其中之一称为Engine.IO，它提供了底层的传输机制。它在连接时采用的第一种连接类型是HTTP长轮询，这是一种快速高效的传输机制。在空闲期间，Socket.IO会尝试确定传输是否可以切换到套接字，如果可以使用套接字，它会无缝地升级传输以使用套接字。对于客户端来说，它们连接得很快，消息也是可靠的，因为Engine.IO部分即使存在防火墙和负载均衡器，也能建立连接。
- en: 'One of the things we want to provide for our clients is a history of the conversations
    that have gone on beforehand. This means that we want to read and save our messages
    to the database. Inside our connection, we are going to read all of the messages
    for the room the user is currently in and return them to the user. If a user has
    not logged in, they will only be able to see messages where the room has not been
    set:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想为客户端提供的一件事是以前进行的对话的历史记录。这意味着我们希望读取并保存我们的消息到数据库中。在我们的连接中，我们将读取用户当前所在房间的所有消息并将它们返回给用户。如果用户没有登录，他们只能看到房间未设置的消息：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The syntax looks slightly strange, so we will break it down step by step. The
    call to `GetAll` is calling the general-purpose `GetAll` method from our `DataAccessBase`
    class. When we created that implementation, we discussed the need to make it more
    general purpose, and to allow the calling code to specify what fields to filter
    on as well as what fields to return. When we say `{room: room}`,  we are telling
    Mongo that we want to filter our results based on the room. We can think of the
    equivalent SQL clause as being `WHERE room = roomVariable`. We also want to indicate
    what results we want back; in this case, we only want `messageText` without the
    `_id` field, so we use the `{messageText: 1, _id: 0}` syntax. When the results
    come back, we need to send the array of messages over to the client using `socket.emit`.
    This command sends these messages to the client that opened the connection, using
    `allMessages` as the key. If the client has code to receive `allMessages`, it
    will be able to react to these messages.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '语法看起来有点奇怪，所以我们将一步一步地分解它。对`GetAll`的调用是从我们的`DataAccessBase`类中调用通用的`GetAll`方法。当我们创建这个实现时，我们讨论了需要使它更通用，并允许调用代码指定要过滤的字段以及要返回的字段。当我们说`{room:
    room}`时，我们告诉Mongo我们要根据房间来过滤我们的结果。我们可以将等效的SQL子句视为`WHERE room = roomVariable`。我们还想指示我们想要返回什么结果；在这种情况下，我们只想要`messageText`而不是`_id`字段，所以我们使用`{messageText:
    1, _id: 0}`语法。当结果返回时，我们需要使用`socket.emit`将消息数组发送到客户端。这个命令将这些消息发送到打开连接的客户端，使用`allMessages`作为键。如果客户端有代码来接收`allMessages`，它将能够对这些消息做出反应。'
- en: The event name that we choose as the message leads us on to one of the limitations
    of Socket.IO. There are certain event names that we cannot use as a message because
    they have been restricted due to them having a special meaning to Socket.IO. These
    are `error`, `connect`, `disconnect`, `disconnecting`, `newListener`, `removeListener`,
    `ping`, and `pong`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择作为消息的事件名称引出了Socket.IO的一个限制。有一些事件名称是我们不能用作消息的，因为它们由于对Socket.IO具有特殊含义而被限制。这些事件名称包括`error`、`connect`、`disconnect`、`disconnecting`、`newListener`、`removeListener`、`ping`和`pong`。
- en: There isn't much point creating the server and sending messages if we haven't
    got anything at the client end to receive them. Even though we don't have all
    of our messages in place yet, we have sufficient infrastructure in place to start
    writing our client.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在客户端没有任何东西来接收消息，那么创建服务器并发送消息就没有太大意义。即使我们还没有准备好所有的消息，但我们已经有了足够的基础设施来开始编写我们的客户端。
- en: Creating our chat room client
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的聊天室客户端
- en: 'Again, we are going to create our Angular application using the `ng new` command.
    We are going to be providing routing support, but when we get around to doing
    the routing part, we will see how we can ensure that users cannot bypass our authentication:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用`ng new`命令创建我们的Angular应用程序。我们将提供路由支持，但是当我们开始进行路由部分时，我们将看到如何确保用户无法绕过我们的身份验证：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since our Angular client will be making regular use of Socket.IO, we are going
    to bring support in for Socket.IO using an Angular-specific Socket.IO module:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的Angular客户端将经常使用Socket.IO，我们将使用一个特定于Angular的Socket.IO模块为Socket.IO提供支持：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In `app.module.ts`, we will create a connection to our Socket.IO server by
    creating a configuration that points to the server URL:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.module.ts`中，我们将通过创建一个指向服务器URL的配置来创建与我们的Socket.IO服务器的连接：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This configuration is passed into the static `SocketIoModule.forRoot` method
    when we import the module, which will configure the client-side socket for us.
    As soon as our client starts, it will establish a connection, triggering the connect
    message sequence we described in the server code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导入模块时，这个配置被传递到静态的`SocketIoModule.forRoot`方法中，这将为我们配置客户端socket。一旦我们的客户端启动，它将建立一个连接，触发我们在服务器代码中描述的连接消息序列：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using decorators to add client-side logging
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装饰器添加客户端日志
- en: 'One of the features we want to use in our client code is to be able to log
    method calls, along with the parameters that are passed into them. We have encountered
    this type of feature before when we looked at creating decorators. In this case,
    we want to create a `Log` decorator:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要在客户端代码中使用的一个功能是能够记录方法调用，以及传递给它们的参数。我们在之前创建装饰器时已经遇到过这种类型的功能。在这种情况下，我们想要创建一个`Log`装饰器：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The way that the `Log` decorator works is that it starts off by copying the
    method from `propertyDescriptor.value`. We then replace this method by creating
    a function that takes in any parameters that are passed into the method. Inside
    this inner function, we use `args.map` to create a stringified representation
    of the parameter and value, which then joins them together. After calling `method.apply` to
    run the method, we write out details pertaining to the method and parameters to
    the console. With the preceding code, we now have a simple mechanism to automatically
    log methods and parameters just by using `@Log`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Log`装饰器的工作方式是从`propertyDescriptor.value`中复制方法开始。然后，我们通过创建一个接收方法传递的任何参数的函数来替换这个方法。在这个内部函数中，我们使用`args.map`来创建参数和值的字符串表示形式，然后将它们连接在一起。在调用`method.apply`运行方法之后，我们将方法和参数的详细信息写到控制台上。有了前面的代码，我们现在有了一个简单的机制，只需使用`@Log`就可以自动记录方法和参数。'
- en: Setting up Bootstrap in Angular
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中设置Bootstrap
- en: 'Instead of using Material in Angular, we can choose to use Bootstrap to style
    our pages. Adding support is a simple enough task. We begin, as always, by installing
    the relevant packages. In this case, we are going to install Bootstrap:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们可以选择使用Bootstrap来为我们的页面添加样式，而不是使用Material。添加支持是一个相当简单的任务。我们首先要做的是安装相关的包。在这种情况下，我们将安装Bootstrap：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once we have installed Bootstrap, we simply need to add a reference to our
    Bootstrap to our `styles` section in `angular.json`, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Bootstrap之后，我们只需要在`angular.json`的`styles`部分中添加对Bootstrap的引用即可。
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With this in place, we are going to create a `navigation` bar that will sit
    at the top of our page:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，我们将创建一个位于页面顶部的`navigation`导航栏：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Before we add the `navigation` component body, we should replace the content
    of our `app.component.html` file so that it is serving up our navigation on every
    page:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加`navigation`组件主体之前，我们应该替换我们的`app.component.html`文件的内容，以便在每个页面上提供我们的导航：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Bootstrap navigation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bootstrap导航
- en: 'Bootstrap provides the `nav` component to which we can add `navigation`. Inside
    this, we are going to create a series of links. Like in the previous chapter,
    we will use `routerLink` to say what Angular should route to:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap提供了`nav`组件，我们可以在其中添加`navigation`。在其中，我们将创建一系列链接。就像在上一章中一样，我们将使用`routerLink`来告诉Angular应该路由到哪里：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Where things get interesting with routing concerns the use of authentication
    to show and hide links. If the user is authenticated, we want them to be able
    to see the Secret and Logout links. If the user has not been authenticated, we
    want them to see the Login link.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由方面变得有趣的地方涉及到使用身份验证来显示和隐藏链接。如果用户已经通过身份验证，我们希望他们能够看到秘密和注销链接。如果用户尚未通过身份验证，我们希望他们能够看到登录链接。
- en: In the navigation, we can see a number of auth references. Behind the scenes,
    these all map back to `OauthAuthorizationService`. We teased the use of this back
    when we signed up to Auth0 at the beginning of this chapter. Now, it's time for
    us to add the authorization service that will connect our users up to Auth0.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航中，我们可以看到一些auth引用。在幕后，这些都映射回`OauthAuthorizationService`。我们在本章开头注册Auth0时就提到过这个。现在，是时候为我们的用户添加连接到Auth0的授权服务了。
- en: Authorizing and authenticating users using Auth0
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Auth0对用户进行授权和认证
- en: 'Our authorization is going to consist of two parts—a service to perform the
    authorization, and a model to make working with the authorization simple. We will
    start off by creating our `Authorization` model, which contains the details we
    will receive back from a successful login. Note that the constructor brings in
    the `Socket` instance:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的授权将由两部分组成——一个执行授权的服务，以及一个使授权工作变得简单的模型。我们将首先创建我们的`Authorization`模型，其中包含我们将从成功登录中收到的详细信息。请注意，构造函数引入了`Socket`实例：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can use this to create a series of useful helper methods. The first one
    we are going to create is a method to set the public properties if the user logs
    in. We are identifying a successful login as one where we receive an access token
    and an ID token as part of the result:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个来创建一系列有用的辅助方法。我们要创建的第一个方法是在用户登录时设置公共属性。我们将一个成功的登录定义为我们收到访问令牌和ID令牌作为结果的登录：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When the user logs on, we are going to send a `loggedOn` message back to the
    server, passing over the `Email` address. We will come back to this message shortly
    when we cover sending the messages to the server and handling the responses that
    come back. Note that we are logging the method and the properties.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录时，我们将向服务器发送一个`loggedOn`消息，传递`Email`地址。当我们涵盖发送消息到服务器和处理返回的响应时，我们将很快回到这条消息。请注意，我们正在记录方法和属性。
- en: 'When the user logs off, we want to clear the values and send the `loggedOff`
    message to the server:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户注销时，我们希望清除值并向服务器发送`loggedOff`消息：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The final helper tells us whether the user has been authenticated by checking
    whether the `AccessToken` field is present, and whether the date when the ticket
    is due to expire exceeds the time when we perform the check:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的帮助程序通过检查`AccessToken`字段是否存在以及票证到期的日期是否超过我们进行检查时的时间来告诉我们用户是否已经通过身份验证：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Before we create our `OauthAuthorizationService` service, we need some means
    of communicating with Auth0, so we will bring in support for it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的`OauthAuthorizationService`服务之前，我们需要一些与Auth0通信的手段，因此我们将为其提供支持：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With this in place, we add a reference to `auth0.js` as a `script` tag:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以将`auth0.js`作为`script`标签的引用添加进来：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We now have all the pieces in place to create our service:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建我们的服务了：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The start of our service is straightforward enough. When we construct the service,
    we instantiate the helper class we just created:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务的开始是相当简单的。当我们构建服务时，我们实例化刚刚创建的帮助类：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We are now ready to hook up to Auth0\. You may recall that, when we signed
    up to Auth0, we were given a series of settings. From the settings, we require
    the client ID and domain. We are going to use these when we instantiate `WebAuth`
    from `auth0-js`, in order to uniquely identify our application. `responseType`
    tells us that we need the user''s authentication token and ID token back following
    a successful login. `scope` tells the user what features we want access to when
    they log in. If we wanted the profile, for instance, we could set the scope to
    `openid email profile`. Finally, we supply `redirectUri` to tell Auth0 what page
    we want to come back to following a successful login:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好连接到Auth0了。您可能还记得，当我们注册Auth0时，我们得到了一系列的设置。从这些设置中，我们需要客户端ID和域。我们将在实例化`auth0-js`中的`WebAuth`时使用这些设置，以便唯一标识我们的应用程序。`responseType`告诉我们，我们需要用户的身份验证令牌和ID令牌在成功登录后返回。`scope`告诉用户我们在登录时想要访问的功能。例如，如果我们想要配置文件，我们可以将范围设置为`openid
    email profile`。最后，我们提供`redirectUri`告诉Auth0我们想在成功登录后返回到哪个页面：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`redirectUri` must match precisely what is contained in the Auth0 settings
    section. I prefer to set it to a page that doesn''t exist on the site and control
    the redirection manually, so callback is a useful one for me because I can apply
    conditional logic to determine the page the user is redirected to if needs be.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`redirectUri`必须与Auth0设置部分中包含的内容完全匹配。我更喜欢将其设置为站点上不存在的页面，并手动控制重定向，因此对我来说回调是一个有用的页面，因为我可以应用条件逻辑来确定用户需要时重定向到的页面。'
- en: 'Now, we can add in our `Login` method. This uses the `authorize` method to
    load up the authentication page:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加我们的`Login`方法。这使用`authorize`方法加载身份验证页面：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Logging out is as simple as calling `logout` and then calling `Clear` on our
    helper class to reset the expiration point and clear the other properties:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 登出就像调用`logout`，然后在我们的帮助类上调用`Clear`来重置到期点并清除其他属性一样简单：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Obviously, we are going to need a means to check the authentication. The following
    method retrieves the authentication in the URL hash and parses it using the `parseHash` method.
    If the authentication is unsuccessful, the user is redirected back to the general
    page, which does not require a login. On the other hand, if the user is authenticated
    successfully, the user is directed to a secret page that is only available to
    authenticated users. Note that we are calling the `SetFromAuthorizationResult` method
    we wrote earlier to set the access token, expiry time, and so on:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要一种方法来检查身份验证。以下方法检索URL哈希中的身份验证并使用`parseHash`方法解析它。如果身份验证不成功，用户将被重定向回不需要登录的一般页面。另一方面，如果用户成功通过身份验证，用户将被引导到仅对经过身份验证的用户可用的秘密页面。请注意，我们正在调用我们之前编写的`SetFromAuthorizationResult`方法来设置访问令牌、到期时间等：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When the user comes back to the site, it''s good practice to let them access
    it again without requiring them to reauthenticate themselves. The following `Renew`
    method checks their session and, if they were successful, resets their authenticated
    status:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户回到网站时，让他们再次访问而无需重新进行身份验证是一个好的做法。以下的`Renew`方法检查他们的会话，如果成功，重置他们的身份验证状态：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This code is all well and good, but where do we use it? In `app.component.ts`,
    we bring in our authorization service and check the user authentication:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码都很好，但我们在哪里使用它呢？在`app.component.ts`中，我们引入我们的授权服务并检查用户身份验证：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Don''t forget to add a reference to  `NavigationComponent` to hook up `OauthAuthorizationService`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记添加对`NavigationComponent`的引用以连接`OauthAuthorizationService`：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using secure routing
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用安全路由
- en: 'With our authentication in place, we want to ensure that users cannot bypass
    it just by typing in the URL of the page. We wouldn''t have much security set
    up if users could easily bypass it, especially after we went to all the trouble
    of providing secure authorization. What we are going to do is put another service
    in place that the router will use to determine whether it can activate the route.
    First, we create the service, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的身份验证，我们希望确保用户不能通过输入页面的URL来绕过它。如果用户可以轻松地绕过它，尤其是在我们费了很大的劲提供安全授权之后，我们就不会设置太多安全措施。我们要做的是放置另一个服务，路由器将使用它来确定是否可以激活路由。首先，我们创建服务，如下所示：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The service itself is going to implement the `CanActivate` interface, which
    the router will use to determine whether the route can be activated. The constructor
    for this service simply takes in the router and our `OauthAuthorizationService` service:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 服务本身将实现`CanActivate`接口，路由器将使用该接口来确定是否可以激活路由。此服务的构造函数只需接收路由器和我们的`OauthAuthorizationService`服务：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The boilerplate code for the `canActivate` signature looks a lot more complicated
    than it needs to for our purposes. What we are really going to do here is check
    the authentication status and, if the user is not authenticated, we will reroute
    the user back to the general page. If the user is authenticated, we return `true`
    and the user continues on to the secured page:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`canActivate`签名的样板代码看起来比我们的目的需要复杂得多。我们真正要做的是检查认证状态，如果用户未经过身份验证，我们将重新将用户重定向到一般页面。如果用户经过了身份验证，我们返回`true`，用户继续访问受保护的页面。'
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We have two routes that we are going to follow here, as we saw in the navigation
    links. Before we add our routes, let''s create the components that we are going
    to show:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循两条路线，就像我们在导航链接中看到的那样。在添加路由之前，让我们创建要显示的组件：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we have reached the point where we are going to hook up the routes.
    As we saw in the previous chapter, adding routes is straightforward. The secret
    sauce that we are going to add is `canActivate`. With that in our route, the user
    cannot bypass our authentication:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经到达了连接路由的地步。正如我们在上一章中看到的，添加路由非常简单。我们要添加的秘密武器是`canActivate`。有了这个路由，用户无法绕过我们的认证：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Even though we have to supply a callback URL in our Auth0 configuration, we
    don't include it in our routes because we want to control the page—we do it to
    navigate to and from our authorization service.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们必须在Auth0配置中提供回调URL，但我们不在路由中包含它，因为我们想要控制页面，我们要导航到我们的授权服务。
- en: At this point, we want to start writing messages from the client to the server
    and receive messages from it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们希望从客户端向服务器发送消息并接收消息。
- en: Adding client-side chat capabilities
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加客户端聊天功能
- en: 'When we wrote our authentication code, we relied heavily on putting services
    in place to take care of it. In a similar way, we are going to provide a chat
    service that provides the central point of the client-side socket messaging:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写我们的认证代码时，我们大量依赖于放置服务来处理它。类似地，我们将提供一个聊天服务，该服务提供客户端套接字消息的中心点：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Unsurprisingly, this service will also incorporate `Socket` in the constructor:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，此服务还将在构造函数中包含`Socket`：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When we send a message from the client to the server, we use the `emit` method
    on the socket. The text that we want to send from the user will be sent over by
    means of the `message` key:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从客户端向服务器发送消息时，我们使用套接字上的`emit`方法。用户要发送的文本将通过`message`键发送过来：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Working in rooms
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在房间里工作
- en: In Socket.IO, we use rooms to segregate messages as a means to send them only
    to certain users. When a client joins a room, any messages sent to that room will
    be available. A useful way to think of this is to imagine the rooms as being like
    rooms in a house with the doors shut. When someone wants to tell you something,
    they have to be in the same room as you to tell you.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Socket.IO中，我们使用房间来隔离消息，以便只将它们发送给特定的用户。当客户端加入一个房间时，发送到该房间的任何消息都将可用。一个有用的想法是将房间想象成房子里的房间，门是关着的。当有人想告诉你什么事情时，他们必须和你在同一个房间里才能告诉你。
- en: 'Both our general and secret links will tie into rooms. The general page will
    use a blank room name that equates to the default Socket.IO room. The secret link
    will join a room called *secret* so that any messages sent to *secret* will automatically
    appear to any user on that page. To make our life easy, we will provide a helper
    method to `emit` the `joinRoom` method from the client to the server:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一般和秘密链接都将连接到房间。一般页面将使用一个空房间名称，相当于默认的Socket.IO房间。秘密链接将加入一个名为*secret*的房间，这样发送到*secret*的任何消息都将自动显示给该页面上的任何用户。为了简化我们的生活，我们将提供一个辅助方法，将`emit`方法从客户端发送到服务器的`joinRoom`方法：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When we join a room, any messages that we send using `socket.emit` are automatically
    sent to the correct room. We don't have to do anything clever since Socket.IO
    takes care of this for us automatically.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加入一个房间时，使用`socket.emit`发送的任何消息都会自动发送到正确的房间。我们不必做任何聪明的事情，因为Socket.IO会自动为我们处理这个。
- en: Getting the messages
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取消息
- en: For both the general and the secret messages pages, we are going to be getting
    the same data. We are going to use RxJS to create an observable that wraps getting
    a single message back from the server as well as getting all currently sent messages
    back from the server.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一般页面和秘密消息页面，我们将获取相同的数据。我们将使用RxJS创建一个可观察对象，该对象包装从服务器获取单个消息以及从服务器获取所有当前发送的消息。
- en: Depending on the room string that's passed in, the `GetMessages` method joins
    either a secret room, just for logged in users, or the general room, available
    to all users. Having joined the room, we return an `Observable` instance where, on a
    particular event, we react. In the case of receiving the single message, we call
    the `Observable` instance's `next` method. This will be subscribed to by the client
    component, which will write this out. Similarly, we also subscribe on the socket
    to `allMessages` in order to receive all of the previously sent messages when
    we join the room. Again, we iterate over the messages and use `next` to write
    the message out.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 根据传入的房间字符串，`GetMessages`方法加入秘密房间或一般房间。加入房间后，我们返回一个`Observable`实例，在特定事件上做出反应。在接收到单个消息时，我们调用`Observable`实例的`next`方法。客户端组件将订阅此方法，并将其写出。同样，我们还在套接字上订阅`allMessages`，以便在加入房间时接收所有先前发送的消息。同样，我们遍历消息并使用`next`将消息写出。
- en: 'My favorite part of this section is `fromEvent`. This is synonymous with the
    `socket.on` method of the `userLogOn` message and allows us to write out details
    about who logged in during the session:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的部分是`fromEvent`。这与`userLogOn`消息的`socket.on`方法是同义的，它允许我们写出有关谁在会话期间登录的详细信息：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Thus far, I have been fairly loose when using the terms *messages* and *events*
    to help with the flow of reading this chapter. In this instance, they both refer
    to the same thing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在阅读本章时，我在使用术语“消息”和“事件”时一直比较宽松。在这种情况下，它们都指的是同一件事情。
- en: Finishing the server sockets
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成服务器套接字
- en: 'Before we add the actual component implementations, we are going to add in
    the rest of our server-side socket behavior. You may remember that we added the
    ability to read all the historical records and send them back to the newly connected
    client:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加实际组件实现之前，我们将添加其余的服务器端套接字行为。您可能还记得我们添加了读取所有历史记录并将它们发送回新连接的客户端的功能：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: What we have here is the server reacting to `joinRoom` coming over from the
    client. When we receive this event, we leave the last room if it has been set
    and then join the room that's passed over from the client; again, only if it has
    been set. This allows us to get all the records and then `emit` them back on the
    current socket connection.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到服务器对来自客户端的`joinRoom`做出反应。当我们收到这个事件时，如果已经设置了上一个房间，我们就离开上一个房间，然后加入来自客户端传递过来的房间；同样，只有在已经设置的情况下。这使我们能够获取所有记录，然后在当前套接字连接上`emit`它们回去。
- en: 'When the client sends the `message` event to the server, we are going to write
    the message to the database so that it can be retrieved later on:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向服务器发送`message`事件时，我们将消息写入数据库，以便以后检索：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This method starts off by saving the message to the database. If the room is
    set, we use `io.sockets.in` to `emit` the message to all of the clients who are
    actively in the room. If there is no room set, we want to send the message to
    all the clients in the general page by using `io.emit`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法首先将消息保存到数据库中。如果设置了房间，我们使用`io.sockets.in`将消息发送给所有活跃在房间中的客户端。如果没有设置房间，我们希望通过`io.emit`将消息发送给通用页面上的所有客户端：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we have seen the primary difference between `io.` and `socket.`. When
    we want to send the message to just the currently connected client, we use the
    `socket` part. When we need to send the message to a wider number of clients,
    we use the `io` part.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经看到了`io.`和`socket.`之间的主要区别。当我们想要将消息发送给当前连接的客户端时，我们使用`socket`部分。当我们需要将消息发送给更多的客户端时，我们使用`io`部分。
- en: 'Saving the message is as simple as doing the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 保存消息就像做以下操作一样简单：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Something you might be asking yourself is why we allocate the date on the server rather
    than when we create the message at the client end. When we are running the client
    and the server on the same machine, it doesn't really matter which way we do it,
    but when we build distributed systems, we should always refer to a centralized
    time. Use of the centralized date and time means that events from all over the
    world will be coordinated as the same time zone.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己为什么我们在服务器端分配日期，而不是在客户端创建消息时分配日期。当我们在同一台机器上运行客户端和服务器时，我们做法并不重要，但是当我们构建分布式系统时，我们应该始终参考集中时间。使用集中的日期和时间意味着来自世界各地的事件将在同一时区协调。
- en: 'On the client side, we reacted to a slightly more complex log-on event. We
    create the equivalent server-side event as follows when we receive the `loggedOn`
    event, transmitting it to anyone listening in the secret room:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端上，我们对稍微复杂的登录事件做出了反应。当我们收到`loggedOn`事件时，我们创建等效的服务器端事件，将其传输给任何在秘密房间中收听的人：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We now have client infrastructure in place and the server has been completed.
    All we need to do now is add in the server-side components. Functionally speaking,
    since the `GeneralChat` and `SecretChat` components are almost identical (the
    only difference being the room they are listening to), we will concentrate on
    just one of them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了客户端基础设施，并且服务器已经完成。我们现在需要做的就是添加服务器端组件。从功能上讲，由于`GeneralChat`和`SecretChat`组件几乎相同（唯一的区别是它们监听的房间不同），我们将集中精力只关注其中一个。
- en: Namespaces in Socket.IO
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket.IO中的命名空间
- en: Imagine that we are writing a server that can be used by any number of client
    applications, and those client applications could be using any number of other
    Socket.IO servers as well. We could be introducing bugs into the client application
    if we use the same message names as the messages coming from the other Socket.IO
    servers. To circumvent this issue, Socket.IO uses a concept called **namespaces**
    to allow us to segregate our messages so that they don't conflict with other applications.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在编写一个可以被任意数量的客户端应用程序使用的服务器，而这些客户端应用程序也可以使用任意数量的其他Socket.IO服务器。如果我们使用与来自其他Socket.IO服务器的消息相同的消息名称，我们可能会向客户端应用程序引入错误。为了避免这个问题，Socket.IO使用了一个叫做**命名空间**的概念，允许我们将我们的消息隔离开来，以避免与其他应用程序冲突。
- en: 'A namespace is a convenient way to provide a unique endpoint to connect to,
    and we connect to it using code that looks as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是提供唯一端点以连接的便捷方式，我们使用以下代码连接到它：
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This code should look familiar because, apart from `io.of(...)`, it's the same
    code that we used previously to connect to a socket. What may come as a surprise
    is that our code has already been using namespaces, even though we didn't specify
    it ourselves. Unless we specify a namespace ourself, our sockets will connect
    to the default namespace, which is equivalent to `io.of('/)`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该看起来很熟悉，因为除了`io.of(...)`之外，它与我们之前用来连接套接字的代码相同。也许令人惊讶的是，我们的代码已经在使用命名空间，尽管我们自己没有指定。除非我们自己指定一个命名空间，否则我们的套接字将连接到默认命名空间，这相当于`io.of('/)`.
- en: When coming up with a name for your namespace, try to think of something that
    would be unique and meaningful. One standard I have seen adopted in the past utilizes
    the company name and the project to create the namespace. So, if your company
    was called `WonderCompany` and you were working on `Project Antelope`, you might
    use `/wonderCompany_antelope` as the namespace. Don't just assign random characters
    since they are hard for people to remember, and this would increase the possibility
    that they will make mistakes typing it in, meaning that the sockets would not
    connect.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在为命名空间想一个名称时，尽量考虑一个独特而有意义的名称。我过去见过的一个标准是利用公司名称和项目来创建命名空间。因此，如果你的公司叫做`WonderCompany`，你正在开发`Project
    Antelope`，你可以使用`/wonderCompany_antelope`作为命名空间。不要随意分配随机字符，因为这样很难记住，这会增加输入错误的可能性，意味着套接字无法连接。
- en: Finishing off our application with the GeneralchatComponent
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用GeneralchatComponent完成我们的应用程序
- en: 'Let''s start off by adding in the Bootstrap code for displaying the messages.
    We wrap the `row` message inside a Bootstrap container, or rather `container-fluid`
    in this case. In our component, we are going to be reading the messages from the
    array of messages we received over the socket:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先添加Bootstrap代码来显示消息。在这种情况下，我们将`row`消息包裹在Bootstrap容器中，或者说是`container-fluid`。在我们的组件中，我们将从通过socket接收的消息数组中读取消息：
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We are also going to add a text box to the `navigation` bar at the bottom of
    our screen. This is bound to the `CurrentMessage` field in the component. We send
    the message using `SendMessage()`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在屏幕底部的`navigation`栏中添加一个文本框。这与组件中的`CurrentMessage`字段绑定。我们使用`SendMessage()`发送消息：
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the component behind this HTML, we need to hook up to the `ChatMessageService`.
    We are going to take a `Subscription` instance and use this to populate the `messages`
    array shortly:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个HTML背后的组件中，我们需要连接到`ChatMessageService`。我们将使用`Subscription`实例，并将其用于不久后填充`messages`数组。
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When the users type in a message and press the Send button, we are going to
    send it to the server using the chat service''s `SendMessage` method. The groundwork
    we put in earlier really starts to pay off here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入消息并按下发送按钮时，我们将使用聊天服务的`SendMessage`方法将其发送到服务器。我们之前做的准备工作在这里真的开始发挥作用：
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we only have two bits left to add. In our component initialization, we
    are going to retrieve the `Observable` instance from `GetMessages` and `subscribe`
    to it. When a message comes in on this subscription, we push it onto the messages
    where the magic of Angular binding really comes into play, and the interface is
    updated with the latest message:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只剩下两个部分要添加。在我们的组件初始化中，我们将从`GetMessages`中检索`Observable`实例，并对其进行`subscribe`。当订阅中有消息时，我们将其推送到消息中，这就是Angular绑定的魔力所在，界面会随着最新消息的更新而更新：
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that the `GetMessages` method is the point where we link in the room. In
    `SecretchatComponent`, this will become `this.chatService.GetMessages('secret')`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`GetMessages`方法是我们链接到房间的地方。在`SecretchatComponent`中，这将变成`this.chatService.GetMessages('secret')`。
- en: 'One of the things we did is take a reference to the subscription. When we destroy
    the current page, we are going to clear up the subscription so that we don''t
    leak memory:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的一件事是引用订阅。当我们销毁当前页面时，我们将清除订阅，以防止内存泄漏：
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: A final note on this implementation. When we started writing the code here,
    we had to make a conscious decision about how to populate the current screen with
    the message when the user pressed Send. Effectively, we had two choices. We could
    either choose to add the current message to the end of the messages array directly and
    not send it back from the server to the client, or we could send it to the server
    and then let the server send it back to us. We could choose either method, so
    why did I choose to send it to the server and then round trip it back to the client?
    The answer to this has to do with sequencing. In most chat applications I have
    used, the messages are seen by each user in exactly the same order. The easiest
    way to do this is to let the server coordinate the messages for us.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后对这个实现做一个说明。当我们开始在这里编写代码时，我们必须对如何在用户按下发送时将当前屏幕填充消息做出有意识的决定。实际上，我们有两种选择。我们可以选择直接将当前消息添加到消息数组的末尾，而不是从服务器发送回客户端，或者我们可以将其发送到服务器，然后让服务器将其发送回给我们。我们可以选择任一种方法，那么为什么我选择将其发送到服务器，然后再回传给客户端呢？这个答案与顺序有关。在我使用过的大多数聊天应用程序中，每个用户看到的消息顺序都是完全相同的。做到这一点最简单的方法是让服务器为我们协调消息。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discovered how to write code that established a permanent
    connection between the client and server, enabling us to pass messages back and
    forth in response to messages. We also saw how to sign up to Auth0 and use this
    as the authentication mechanism for our application. Then, we learned how to write
    client-side authentication. Having spent the last couple of chapters investigating
    Material in Angular, we moved back to using Bootstrap and saw how simple it is
    to use in Angular.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了如何编写代码来在客户端和服务器之间建立永久连接，使我们能够根据消息来回传递消息。我们还看到了如何注册Auth0并将其用作应用程序的身份验证机制。然后，我们学会了编写客户端身份验证。在过去的几章中，我们一直在研究Angular中的Material，现在我们又回到了使用Bootstrap，并看到了在Angular中使用它是多么简单。
- en: In the next chapter, we are going to learn how to apply Bing maps in order to
    create a custom map-based application that lets us select and save points of interest
    in a cloud-based database that also uses location-based searches to retrieve business
    information.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何应用必应地图来创建一个自定义的基于地图的应用程序，让我们能够在基于云的数据库中选择和保存兴趣点，并使用基于位置的搜索来检索商业信息。
- en: Questions
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How would we send a message to all users?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何向所有用户发送消息？
- en: How do we send a message to just the users in a certain room?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何向特定房间中的用户发送消息？
- en: How do we send a message to all users except the user who sent the original
    message?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何向除了发送原始消息的用户之外的所有用户发送消息？
- en: Why shouldn't we use a message called connect?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们不应该使用一个名为connect的消息？
- en: What is Engine.IO?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Engine.IO？
- en: In our application, we only used a single room. Add other rooms that do not
    require the user to be authenticated prior to use and add rooms that do require
    the user to be authenticated. We also didn't store the details of who sent the
    messages. Enhance the application to store these details and transmit them both
    ways as part of the message.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们只使用了一个房间。添加其他房间，这些房间不需要用户在使用之前进行身份验证，并添加需要用户进行身份验证的房间。我们也没有存储发送消息的人的详细信息。增强应用程序以存储这些细节，并将它们作为消息的一部分双向传输。
- en: Further reading
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: If you want to find out how to use particular features of Socket.IO, I would
    recommend *Socket.IO Cookbook* by Tyson Cadenhead ([https://www.packtpub.com/web-development/socketio-cookbook](https://www.packtpub.com/web-development/socketio-cookbook)).
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想了解如何使用Socket.IO的特定功能，我建议阅读Tyson Cadenhead的《Socket.IO Cookbook》（[https://www.packtpub.com/web-development/socketio-cookbook](https://www.packtpub.com/web-development/socketio-cookbook)）。
