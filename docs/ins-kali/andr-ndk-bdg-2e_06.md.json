["```kt\n        ...\n        #include \"Types.hpp\"\n\n        #include <android_native_app_glue.h>\n        #include <GLES2/gl2.h>\n        #include <EGL/egl.h>\n        ...\n\n        class GraphicsManager {\n        public:\n            ...\n            status start();\n            void stop();\n            status update();\n\n        private:\n            ...\n            int32_t mRenderWidth; int32_t mRenderHeight;\n            EGLDisplay mDisplay; EGLSurface mSurface; EGLContext mContext;\n\n            GraphicsElement* mElements[1024]; int32_t mElementCount;\n        };\n        #endif\n        ```", "```kt\n    #include \"GraphicsManager.hpp\"\n    #include \"Log.hpp\"\n\n    GraphicsManager::GraphicsManager(android_app* pApplication) :\n        mApplication(pApplication),\n        mRenderWidth(0), mRenderHeight(0),\n        mDisplay(EGL_NO_DISPLAY), mSurface(EGL_NO_CONTEXT),\n     mContext(EGL_NO_SURFACE),\n        mElements(), mElementCount(0) {\n        Log::info(\"Creating GraphicsManager.\");\n    }\n    ...\n    ```", "```kt\n        ...\n        status GraphicsManager::start() {\n            Log::info(\"Starting GraphicsManager.\");\n            EGLint format, numConfigs, errorResult; GLenum status;\n            EGLConfig config;\n            // Defines display requirements. 16bits mode here.\n            const EGLint DISPLAY_ATTRIBS[] = {\n                EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,\n                EGL_BLUE_SIZE, 5, EGL_GREEN_SIZE, 6, EGL_RED_SIZE, 5,\n                EGL_SURFACE_TYPE, EGL_WINDOW_BIT,\n                EGL_NONE\n            };\n            // Request an OpenGL ES 2 context.\n            const EGLint CONTEXT_ATTRIBS[] = {\n                EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE\n            };\n        ...\n        ```", "```kt\n    ...\n        mDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);\n        if (mDisplay == EGL_NO_DISPLAY) goto ERROR;\n        if (!eglInitialize(mDisplay, NULL, NULL)) goto ERROR;\n\n        if(!eglChooseConfig(mDisplay, DISPLAY_ATTRIBS, &config, 1,\n            &numConfigs) || (numConfigs <= 0)) goto ERROR;\n    ...\n    ```", "```kt\n    ...\n        if (!eglGetConfigAttrib(mDisplay, config,\n            EGL_NATIVE_VISUAL_ID, &format)) goto ERROR;\n        ANativeWindow_setBuffersGeometry(mApplication->window, 0, 0,\n            format);\n\n        mSurface = eglCreateWindowSurface(mDisplay, config,\n            mApplication->window, NULL);\n        if (mSurface == EGL_NO_SURFACE) goto ERROR;\n        mContext = eglCreateContext(mDisplay, config, NULL,\n            CONTEXT_ATTRIBS);\n        if (mContext == EGL_NO_CONTEXT) goto ERROR;\n    ...\n    ```", "```kt\n    ...\n        if (!eglMakeCurrent(mDisplay, mSurface, mSurface, mContext)\n       || !eglQuerySurface(mDisplay, mSurface, EGL_WIDTH, &mRenderWidth)\n       || !eglQuerySurface(mDisplay, mSurface, EGL_HEIGHT, &mRenderHeight)\n       || (mRenderWidth <= 0) || (mRenderHeight <= 0)) goto ERROR;\n\n        glViewport(0, 0, mRenderWidth, mRenderHeight);\n        glDisable(GL_DEPTH_TEST);\n        return STATUS_OK;\n\n    ERROR:\n        Log::error(\"Error while starting GraphicsManager\");\n        stop();\n        return STATUS_KO;\n    }\n    ...\n    ```", "```kt\n    ...\n    void GraphicsManager::stop() {\n        Log::info(\"Stopping GraphicsManager.\");\n\n        // Destroys OpenGL context.\n        if (mDisplay != EGL_NO_DISPLAY) {\n            eglMakeCurrent(mDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE,\n                           EGL_NO_CONTEXT);\n            if (mContext != EGL_NO_CONTEXT) {\n                eglDestroyContext(mDisplay, mContext);\n                mContext = EGL_NO_CONTEXT;\n            }\n            if (mSurface != EGL_NO_SURFACE) {\n                eglDestroySurface(mDisplay, mSurface);\n                mSurface = EGL_NO_SURFACE;\n            }\n            eglTerminate(mDisplay);\n            mDisplay = EGL_NO_DISPLAY;\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    status GraphicsManager::update() {\n        static float clearColor = 0.0f;\n        clearColor += 0.001f;\n        glClearColor(clearColor, clearColor, clearColor, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        if (eglSwapBuffers(mDisplay, mSurface) != EGL_TRUE) {\n            Log::error(\"Error %d swapping buffers.\", eglGetError());\n            return STATUS_KO;\n        } else {\n            return STATUS_OK;\n        }\n    }\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n\n    include $(CLEAR_VARS)\n\n    LS_CPP=$(subst $(1)/,,$(wildcard $(1)/*.cpp))\n    LOCAL_MODULE := droidblaster\n    LOCAL_SRC_FILES := $(call LS_CPP,$(LOCAL_PATH))\n    LOCAL_LDLIBS := -landroid -llog -lEGL -lGLESv2\n    LOCAL_STATIC_LIBRARIES := android_native_app_glue\n\n    include $(BUILD_SHARED_LIBRARY)\n\n    $(call import-module,android/native_app_glue)\n    ```", "```kt\n    #ifndef _PACKT_RESOURCE_HPP_\n    #define _PACKT_RESOURCE_HPP_\n\n    #include \"Types.hpp\"\n\n    #include <android_native_app_glue.h>\n\n    class Resource {\n    public:\n        Resource(android_app* pApplication, const char* pPath);\n\n        const char* getPath() { return mPath; };\n\n        status open();\n        void close();\n        status read(void* pBuffer, size_t pCount);\n\n        bool operator==(const Resource& pOther);\n\n    private:\n        const char* mPath;\n        AAssetManager* mAssetManager;\n        AAsset* mAsset;\n    };\n\n    #endif\n    ```", "```kt\n    #include \"Resource.hpp\"\n\n    #include <sys/stat.h>\n\n    Resource::Resource(android_app* pApplication, const char* pPath):\n        mPath(pPath),\n        mAssetManager(pApplication->activity->assetManager),\n        mAsset(NULL) {\n    }\n    ...\n    ```", "```kt\n    ...\n    status Resource::open() {\n        mAsset = AAssetManager_open(mAssetManager, mPath,\n                                    AASSET_MODE_UNKNOWN);\n        return (mAsset != NULL) ? STATUS_OK : STATUS_KO;\n    }\n    ...\n    ```", "```kt\n    ...\n    void Resource::close() {\n        if (mAsset != NULL) {\n            AAsset_close(mAsset);\n            mAsset = NULL;\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    status Resource::read(void* pBuffer, size_t pCount) {\n        int32_t readCount = AAsset_read(mAsset, pBuffer, pCount);\n        return (readCount == pCount) ? STATUS_OK : STATUS_KO;\n    }\n\n    bool Resource::operator==(const Resource& pOther) {\n        return !strcmp(mPath, pOther.mPath);\n    }\n    ```", "```kt\n    AAssetDir* AAssetManager_openDir(AAssetManager* mgr,\n                                     const char* dirName);\n    ```", "```kt\n    const char* AAssetDir_getNextFileName(AAssetDir* assetDir);\n    ```", "```kt\n    void AAssetDir_rewind(AAssetDir* assetDir);\n    ```", "```kt\n    void AAssetDir_close(AAssetDir* assetDir);\n    ```", "```kt\n    AAsset* AAssetManager_open(AAssetManager* mgr,\n                               const char* filename, int mode);\n    ```", "```kt\n    int AAsset_read(AAsset* asset, void* buf, size_t count);\n    ```", "```kt\n    off_t AAsset_seek(AAsset* asset, off_t offset, int whence);\n    ```", "```kt\n    void AAsset_close(AAsset* asset);\n    ```", "```kt\n    const void* AAsset_getBuffer(AAsset* asset);\n    ```", "```kt\n    off_t AAsset_getLength(AAsset* asset);\n    ```", "```kt\n    off_t AAsset_getRemainingLength(AAsset* asset);\n    ```", "```kt\n    int AAsset_openFileDescriptor(AAsset* asset, off_t* outStart, off_t* outLength);\n    ```", "```kt\n    int AAsset_isAllocated(AAsset* asset);\n    ```", "```kt\n    LOCAL_PATH:= $(call my-dir)\n\n    include $(CLEAR_VARS)\n\n    LS_C=$(subst $(1)/,,$(wildcard $(1)/*.c))\n\n    LOCAL_MODULE := png\n    LOCAL_SRC_FILES := \\\n        $(filter-out example.c pngtest.c,$(call LS_C,$(LOCAL_PATH)))\n    LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)\n    LOCAL_EXPORT_LDLIBS := -lz\n\n    include $(BUILD_STATIC_LIBRARY)\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n\n    include $(CLEAR_VARS)\n\n    LS_CPP=$(subst $(1)/,,$(wildcard $(1)/*.cpp))\n    LOCAL_MODULE := droidblaster\n    LOCAL_SRC_FILES := $(call LS_CPP,$(LOCAL_PATH))\n    LOCAL_LDLIBS := -landroid -llog -lEGL -lGLESv2\n    LOCAL_STATIC_LIBRARIES := android_native_app_glue png\n\n    include $(BUILD_SHARED_LIBRARY)\n\n    $(call import-module,android/native_app_glue)\n    $(call import-module,libpng)\n\n    ```", "```kt\n        ...\n        #include \"Resource.hpp\"\n        #include \"Types.hpp\"\n        ...\n\n        struct TextureProperties {\n            Resource* textureResource;\n            GLuint texture;\n            int32_t width;\n            int32_t height;\n        };\n        ...\n        ```", "```kt\n    ...\n    class GraphicsManager {\n    public:\n        ...\n        status start();\n        void stop();\n        status update();\n\n        TextureProperties* loadTexture(Resource& pResource);\n\n    private:\n        ...\n        int32_t mRenderWidth; int32_t mRenderHeight;\n        EGLDisplay mDisplay; EGLSurface mSurface; EGLContext mContext;\n\n        TextureProperties mTextures[32]; int32_t mTextureCount;\n        GraphicsElement* mElements[1024]; int32_t mElementCount;\n    };\n    #endif\n    ```", "```kt\n    #include \"GraphicsManager.hpp\"\n    #include \"Log.hpp\"\n\n    #include <png.h>\n\n    GraphicsManager::GraphicsManager(android_app* pApplication) :\n        mApplication(pApplication),\n        mRenderWidth(0), mRenderHeight(0),\n        mDisplay(EGL_NO_DISPLAY), mSurface(EGL_NO_CONTEXT),\n        mContext(EGL_NO_SURFACE),\n     mTextures(), mTextureCount(0),\n        mElements(), mElementCount(0) {\n        Log::info(\"Creating GraphicsManager.\");\n    }\n    ...\n    ```", "```kt\n    ...\n    void GraphicsManager::stop() {\n        Log::info(\"Stopping GraphicsManager.\");\n        for (int32_t i = 0; i < mTextureCount; ++i) {\n            glDeleteTextures(1, &mTextures[i].texture);\n        }\n        mTextureCount = 0;\n\n        // Destroys OpenGL context.\n        if (mDisplay != EGL_NO_DISPLAY) {\n            ...\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    void callback_readPng(png_structp pStruct,\n        png_bytep pData, png_size_t pSize) {\n        Resource* resource = ((Resource*) png_get_io_ptr(pStruct));\n        if (resource->read(pData, pSize) != STATUS_OK) {\n            resource->close();\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    TextureProperties* GraphicsManager::loadTexture(Resource& pResource) {\n        for (int32_t i = 0; i < mTextureCount; ++i) {\n            if (pResource == *mTextures[i].textureResource) {\n                Log::info(\"Found %s in cache\", pResource.getPath());\n                return &mTextures[i];\n            }\n        }\n    ...\n    ```", "```kt\n    ...\n        Log::info(\"Loading texture %s\", pResource.getPath());\n        TextureProperties* textureProperties; GLuint texture; GLint format;\n        png_byte header[8];\n        png_structp pngPtr = NULL; png_infop infoPtr = NULL;\n        png_byte* image = NULL; png_bytep* rowPtrs = NULL;\n        png_int_32 rowSize; bool transparency;\n\n        if (pResource.open() != STATUS_OK) goto ERROR;\n        Log::info(\"Checking signature.\");\n        if (pResource.read(header, sizeof(header)) != STATUS_OK)\n            goto ERROR;\n        if (png_sig_cmp(header, 0, 8) != 0) goto ERROR;\n    ...\n    ```", "```kt\n    ...\n        Log::info(\"Creating required structures.\");\n        pngPtr = png_create_read_struct(PNG_LIBPNG_VER_STRING,\n            NULL, NULL, NULL);\n        if (!pngPtr) goto ERROR;\n        infoPtr = png_create_info_struct(pngPtr);\n        if (!infoPtr) goto ERROR;\n\n        // Prepares reading operation by setting-up a read callback.\n        png_set_read_fn(pngPtr, &pResource, callback_readPng);\n        // Set-up error management. If an error occurs while reading,\n        // code will come back here and jump\n        if (setjmp(png_jmpbuf(pngPtr))) goto ERROR;\n    ...\n    ```", "```kt\n    ...\n        // Ignores first 8 bytes already read.\n        png_set_sig_bytes(pngPtr, 8);\n        // Retrieves PNG info and updates PNG struct accordingly.\n        png_read_info(pngPtr, infoPtr);\n        png_int_32 depth, colorType;\n        png_uint_32 width, height;\n        png_get_IHDR(pngPtr, infoPtr, &width, &height,\n            &depth, &colorType, NULL, NULL, NULL);\n    ...\n    ```", "```kt\n    ...\n        // Creates a full alpha channel if transparency is encoded as\n        // an array of palette entries or a single transparent color.\n        transparency = false;\n        if (png_get_valid(pngPtr, infoPtr, PNG_INFO_tRNS)) {\n            png_set_tRNS_to_alpha(pngPtr);\n            transparency = true;\n        }\n        // Expands PNG with less than 8bits per channel to 8bits.\n        if (depth < 8) {\n            png_set_packing (pngPtr);\n        // Shrinks PNG with 16bits per color channel down to 8bits.\n        } else if (depth == 16) {\n            png_set_strip_16(pngPtr);\n        }\n        // Indicates that image needs conversion to RGBA if needed.\n        switch (colorType) {\n        case PNG_COLOR_TYPE_PALETTE:\n            png_set_palette_to_rgb(pngPtr);\n            format = transparency ? GL_RGBA : GL_RGB;\n            break;\n        case PNG_COLOR_TYPE_RGB:\n            format = transparency ? GL_RGBA : GL_RGB;\n            break;\n        case PNG_COLOR_TYPE_RGBA:\n            format = GL_RGBA;\n            break;\n        case PNG_COLOR_TYPE_GRAY:\n            png_set_expand_gray_1_2_4_to_8(pngPtr);\n            format = transparency ? GL_LUMINANCE_ALPHA:GL_LUMINANCE;\n            break;\n        case PNG_COLOR_TYPE_GA:\n            png_set_expand_gray_1_2_4_to_8(pngPtr);\n            format = GL_LUMINANCE_ALPHA;\n            break;\n        }\n        // Validates all transformations.\n        png_read_update_info(pngPtr, infoPtr);\n    ...\n    ```", "```kt\n    ...\n        // Get row size in bytes.\n        rowSize = png_get_rowbytes(pngPtr, infoPtr);\n        if (rowSize <= 0) goto ERROR;\n        // Ceates the image buffer that will be sent to OpenGL.\n        image = new png_byte[rowSize * height];\n        if (!image) goto ERROR;\n        // Pointers to each row of the image buffer. Row order is\n        // inverted because different coordinate systems are used by\n        // OpenGL (1st pixel is at bottom left) and PNGs (top-left).\n        rowPtrs = new png_bytep[height];\n        if (!rowPtrs) goto ERROR;\n        for (int32_t i = 0; i < height; ++i) {\n            rowPtrs[height - (i + 1)] = image + i * rowSize;\n        }\n    ...\n    ```", "```kt\n    ...\n        // Reads image content.\n        png_read_image(pngPtr, rowPtrs);\n        // Frees memory and resources.\n        pResource.close();\n        png_destroy_read_struct(&pngPtr, &infoPtr, NULL);\n        delete[] rowPtrs;\n    ```", "```kt\n    ...\n    ERROR:\n        Log::error(\"Error loading texture into OpenGL.\");\n        pResource.close();\n        delete[] rowPtrs; delete[] image;\n        if (pngPtr != NULL) {\n            png_infop* infoPtrP = infoPtr != NULL ? &infoPtr: NULL;\n            png_destroy_read_struct(&pngPtr, infoPtrP, NULL);\n        }\n        return NULL;\n    }\n    ```", "```kt\n    ...\n        png_destroy_read_struct(&pngPtr, &infoPtr, NULL);\n        delete[] rowPtrs;\n\n     GLenum errorResult;\n     glGenTextures(1, &texture);\n     glBindTexture(GL_TEXTURE_2D, texture);\n     // Set-up texture properties.\n     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,\n     GL_NEAREST);\n     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,\n     GL_NEAREST);\n     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,\n     GL_CLAMP_TO_EDGE);\n     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,\n     GL_CLAMP_TO_EDGE);\n    ...\n    ```", "```kt\n    ...\n        // Loads image data into OpenGL.\n     glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format,\n     GL_UNSIGNED_BYTE, image);\n     // Finished working with the texture.\n     glBindTexture(GL_TEXTURE_2D, 0);\n     delete[] image;\n     if (glGetError() != GL_NO_ERROR) goto ERROR;\n     Log::info(\"Texture size: %d x %d\", width, height);\n    ...\n    ```", "```kt\n    ...\n        // Caches the loaded texture.\n     textureProperties = &mTextures[mTextureCount++];\n     textureProperties->texture = texture;\n     textureProperties->textureResource = &pResource;\n     textureProperties->width = width;\n     textureProperties->height = height;\n     return textureProperties;\n\n    ERROR:\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    #include \"PhysicsManager.hpp\"\n    #include \"Resource.hpp\"\n    #include \"Ship.hpp\"\n    #include \"TimeManager.hpp\"\n    #include \"Types.hpp\"\n\n    class DroidBlaster : public ActivityHandler {\n        ...\n    private:\n        ...\n        EventLoop mEventLoop;\n\n        Resource mAsteroidTexture;\n        Resource mShipTexture;\n\n        Asteroid mAsteroids;\n        Ship mShip;\n    };\n    #endif\n    ```", "```kt\n    ...\n    DroidBlaster::DroidBlaster(android_app* pApplication):\n        mTimeManager(),\n        mGraphicsManager(pApplication),\n        mPhysicsManager(mTimeManager, mGraphicsManager),\n        mEventLoop(pApplication, *this),\n\n        mAsteroidTexture(pApplication, \"droidblaster/asteroid.png\"),\n        mShipTexture(pApplication, \"droidblaster/ship.png\"),\n\n        mAsteroids(pApplication, mTimeManager, mGraphicsManager,\n                mPhysicsManager),\n        mShip(pApplication, mGraphicsManager) {\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    status DroidBlaster::onActivate() {\n        Log::info(\"Activating DroidBlaster\");\n\n        if (mGraphicsManager.start() != STATUS_OK) return STATUS_KO;\n        mGraphicsManager.loadTexture(mAsteroidTexture);\n        mGraphicsManager.loadTexture(mShipTexture);\n\n        mAsteroids.initialize();\n        mShip.initialize();\n\n        mTimeManager.reset();\n        return STATUS_OK;\n    }\n    ...\n    ```", "```kt\n    ...\n    class GraphicsComponent {\n    public:\n        virtual status load() = 0;\n        virtual void draw() = 0;\n    };\n    ...\n    ```", "```kt\n    ...\n    class GraphicsManager {\n    public:\n        GraphicsManager(android_app* pApplication);\n        ~GraphicsManager();\n\n        int32_t getRenderWidth() { return mRenderWidth; }\n        int32_t getRenderHeight() { return mRenderHeight; }\n        GLfloat* getProjectionMatrix() { return mProjectionMatrix[0]; }\n\n     void registerComponent(GraphicsComponent* pComponent);\n\n        status start();\n        void stop();\n        status update();\n\n        TextureProperties* loadTexture(Resource& pResource);\n        GLuint loadShader(const char* pVertexShader,\n     const char* pFragmentShader);\n\n    private:\n        struct RenderVertex {\n     GLfloat x, y, u, v;\n        };\n\n        android_app* mApplication;\n\n        int32_t mRenderWidth; int32_t mRenderHeight;\n        EGLDisplay mDisplay; EGLSurface mSurface; EGLContext mContext;\n        GLfloat mProjectionMatrix[4][4];\n\n        TextureProperties mTextures[32]; int32_t mTextureCount;\n        GLuint mShaders[32]; int32_t mShaderCount;\n\n        GraphicsComponent* mComponents[32]; int32_t mComponentCount;\n    };\n    #endif\n    ```", "```kt\n    ...\n    GraphicsManager::GraphicsManager(android_app* pApplication) :\n        mApplication(pApplication),\n        mRenderWidth(0), mRenderHeight(0),\n        mDisplay(EGL_NO_DISPLAY), mSurface(EGL_NO_CONTEXT),\n        mContext(EGL_NO_SURFACE),\n        mProjectionMatrix(),\n        mTextures(), mTextureCount(0),\n        mShaders(), mShaderCount(0),\n        mComponents(), mComponentCount(0) {\n        Log::info(\"Creating GraphicsManager.\");\n    }\n\n    GraphicsManager::~GraphicsManager() {\n        Log::info(\"Destroying GraphicsManager.\");\n    }\n\n    void GraphicsManager::registerComponent(GraphicsComponent* pComponent)\n    {\n        mComponents[mComponentCount++] = pComponent;\n    }\n    ...\n    ```", "```kt\n    ...\n    status GraphicsManager::start() {\n        ...\n        glViewport(0, 0, mRenderWidth, mRenderHeight);\n        glDisable(GL_DEPTH_TEST);\n\n        // Prepares the projection matrix with viewport dimesions.\n     memset(mProjectionMatrix[0], 0, sizeof(mProjectionMatrix));\n     mProjectionMatrix[0][0] =  2.0f / GLfloat(mRenderWidth);\n     mProjectionMatrix[1][1] =  2.0f / GLfloat(mRenderHeight);\n     mProjectionMatrix[2][2] = -1.0f; mProjectionMatrix[3][0] = -1.0f;\n     mProjectionMatrix[3][1] = -1.0f; mProjectionMatrix[3][2] =  0.0f;\n     mProjectionMatrix[3][3] =  1.0f;\n\n     // Loads graphics components.\n     for (int32_t i = 0; i < mComponentCount; ++i) {\n     if (mComponents[i]->load() != STATUS_OK) {\n     return STATUS_KO;\n            }\n        }\n        return STATUS_OK;\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    void GraphicsManager::stop() {\n        Log::info(\"Stopping GraphicsManager.\");\n        for (int32_t i = 0; i < mTextureCount; ++i) {\n            glDeleteTextures(1, &mTextures[i].texture);\n        }\n        mTextureCount = 0;\n\n        for (int32_t i = 0; i < mShaderCount; ++i) {\n     glDeleteProgram(mShaders[i]);\n     }\n     mShaderCount = 0;\n\n        // Destroys OpenGL context.\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    status GraphicsManager::update() {\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        for (int32_t i = 0; i < mComponentCount; ++i) {\n     mComponents[i]->draw();\n        }\n\n        if (eglSwapBuffers(mDisplay, mSurface) != EGL_TRUE) {\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    GLuint GraphicsManager::loadShader(const char* pVertexShader,\n            const char* pFragmentShader) {\n        GLint result; char log[256];\n        GLuint vertexShader, fragmentShader, shaderProgram;\n\n        // Builds the vertex shader.\n        vertexShader = glCreateShader(GL_VERTEX_SHADER);\n        glShaderSource(vertexShader, 1, &pVertexShader, NULL);\n        glCompileShader(vertexShader);\n        glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &result);\n        if (result == GL_FALSE) {\n            glGetShaderInfoLog(vertexShader, sizeof(log), 0, log);\n            Log::error(\"Vertex shader error: %s\", log);\n            goto ERROR;\n        }\n\n        // Builds the fragment shader.\n        fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\n        glShaderSource(fragmentShader, 1, &pFragmentShader, NULL);\n        glCompileShader(fragmentShader);\n        glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &result);\n        if (result == GL_FALSE) {\n            glGetShaderInfoLog(fragmentShader, sizeof(log), 0, log);\n            Log::error(\"Fragment shader error: %s\", log);\n            goto ERROR;\n        }\n    ...\n    ```", "```kt\n        ...\n            shaderProgram = glCreateProgram();\n            glAttachShader(shaderProgram, vertexShader);\n            glAttachShader(shaderProgram, fragmentShader);\n            glLinkProgram(shaderProgram);\n            glGetProgramiv(shaderProgram, GL_LINK_STATUS, &result);\n            glDeleteShader(vertexShader);\n            glDeleteShader(fragmentShader);\n            if (result == GL_FALSE) {\n                glGetProgramInfoLog(shaderProgram, sizeof(log), 0, log);\n                Log::error(\"Shader program error: %s\", log);\n                goto ERROR;\n            }\n\n            mShaders[mShaderCount++] = shaderProgram;\n            return shaderProgram;\n\n        ERROR:\n            Log::error(\"Error loading shader.\");\n            if (vertexShader > 0) glDeleteShader(vertexShader);\n            if (fragmentShader > 0) glDeleteShader(fragmentShader);\n            return 0;\n        }\n        ...\n        ```", "```kt\n        #ifndef _PACKT_GRAPHICSSPRITE_HPP_\n        #define _PACKT_GRAPHICSSPRITE_HPP_\n\n        #include \"GraphicsManager.hpp\"\n        #include \"Resource.hpp\"\n        #include \"Types.hpp\"\n\n        #include <GLES2/gl2.h>\n\n        class SpriteBatch;\n\n        class Sprite {\n            friend class SpriteBatch;\n        public\n            struct Vertex {\n                GLfloat x, y, u, v;\n            };\n\n            Sprite(GraphicsManager& pGraphicsManager,\n                Resource& pTextureResource, int32_t pHeight, int32_t pWidth);\n\n            void setAnimation(int32_t pStartFrame, int32_t pFrameCount,\n                float pSpeed, bool pLoop);\n            bool animationEnded() { return mAnimFrame > (mAnimFrameCount-1); }\n\n            Location location;\n\n        protected:\n            status load(GraphicsManager& pGraphicsManager);\n            void draw(Vertex pVertex[4], float pTimeStep);\n        ...\n        ```", "```kt\n        ...\n        private:\n            Resource& mTextureResource;\n            GLuint mTexture;\n            // Frame.\n            int32_t mSheetHeight, mSheetWidth;\n            int32_t mSpriteHeight, mSpriteWidth;\n            int32_t mFrameXCount, mFrameYCount, mFrameCount;\n            // Animation.\n            int32_t mAnimStartFrame, mAnimFrameCount;\n            float mAnimSpeed, mAnimFrame;\n            bool mAnimLoop;\n        };\n        #endif\n        ```", "```kt\n    #include \"Sprite.hpp\"\n    #include \"Log.hpp\"\n\n    Sprite::Sprite(GraphicsManager& pGraphicsManager,\n            Resource& pTextureResource,\n        int32_t pHeight, int32_t pWidth) :\n        location(),\n        mTextureResource(pTextureResource), mTexture(0),\n        mSheetWidth(0), mSheetHeight(0),\n        mSpriteHeight(pHeight), mSpriteWidth(pWidth),\n        mFrameCount(0), mFrameXCount(0), mFrameYCount(0),\n        mAnimStartFrame(0), mAnimFrameCount(1),\n        mAnimSpeed(0), mAnimFrame(0), mAnimLoop(false)\n    {}\n    ...\n    ```", "```kt\n    ...\n    status Sprite::load(GraphicsManager& pGraphicsManager) {\n        TextureProperties* textureProperties =\n                pGraphicsManager.loadTexture(mTextureResource);\n        if (textureProperties == NULL) return STATUS_KO;\n        mTexture = textureProperties->texture;\n        mSheetWidth = textureProperties->width;\n        mSheetHeight = textureProperties->height;\n\n        mFrameXCount = mSheetWidth / mSpriteWidth;\n        mFrameYCount = mSheetHeight / mSpriteHeight;\n        mFrameCount = (mSheetHeight / mSpriteHeight)\n                    * (mSheetWidth / mSpriteWidth);\n        return STATUS_OK;\n    }\n    ...\n    ```", "```kt\n    ...\n    void Sprite::setAnimation(int32_t pStartFrame,\n        int32_t pFrameCount, float pSpeed, bool pLoop) {\n        mAnimStartFrame = pStartFrame;\n        mAnimFrame = 0.0f, mAnimSpeed = pSpeed, mAnimLoop = pLoop;\n        mAnimFrameCount = pFrameCount;\n    }\n    ...\n    ```", "```kt\n    ...\n    void Sprite::draw(Vertex pVertices[4], float pTimeStep) {\n        int32_t currentFrame, currentFrameX, currentFrameY;\n        // Updates animation in loop mode.\n        mAnimFrame += pTimeStep * mAnimSpeed;\n        if (mAnimLoop) {\n            currentFrame = (mAnimStartFrame +\n                             int32_t(mAnimFrame) % mAnimFrameCount);\n        } else {\n            // Updates animation in one-shot mode.\n            if (animationEnded()) {\n                currentFrame = mAnimStartFrame + (mAnimFrameCount-1);\n            } else {\n                currentFrame = mAnimStartFrame + int32_t(mAnimFrame);\n            }\n        }\n        // Computes frame X and Y indexes from its id.\n        currentFrameX = currentFrame % mFrameXCount;\n        // currentFrameY is converted from OpenGL coordinates\n        // to top-left coordinates.\n        currentFrameY = mFrameYCount - 1\n                      - (currentFrame / mFrameXCount);\n    ...\n    ```", "```kt\n    ...\n        // Draws selected frame.\n        GLfloat posX1 = location.x - float(mSpriteWidth / 2);\n        GLfloat posY1 = location.y - float(mSpriteHeight / 2);\n        GLfloat posX2 = posX1 + mSpriteWidth;\n        GLfloat posY2 = posY1 + mSpriteHeight;\n        GLfloat u1 = GLfloat(currentFrameX * mSpriteWidth)\n                        / GLfloat(mSheetWidth);\n        GLfloat u2 = GLfloat((currentFrameX + 1) * mSpriteWidth)\n                        / GLfloat(mSheetWidth);\n        GLfloat v1 = GLfloat(currentFrameY * mSpriteHeight)\n                        / GLfloat(mSheetHeight);\n        GLfloat v2 = GLfloat((currentFrameY + 1) * mSpriteHeight)\n                        / GLfloat(mSheetHeight);\n\n        pVertices[0].x = posX1; pVertices[0].y = posY1;\n        pVertices[0].u = u1;    pVertices[0].v = v1;\n        pVertices[1].x = posX1; pVertices[1].y = posY2;\n        pVertices[1].u = u1;    pVertices[1].v = v2;\n        pVertices[2].x = posX2; pVertices[2].y = posY1;\n        pVertices[2].u = u2;    pVertices[2].v = v1;\n        pVertices[3].x = posX2; pVertices[3].y = posY2;\n        pVertices[3].u = u2;    pVertices[3].v = v2;\n    }\n    ```", "```kt\n        #ifndef _PACKT_GRAPHICSSPRITEBATCH_HPP_\n        #define _PACKT_GRAPHICSSPRITEBATCH_HPP_\n\n        #include \"GraphicsManager.hpp\"\n        #include \"Sprite.hpp\"\n        #include \"TimeManager.hpp\"\n        #include \"Types.hpp\"\n\n        #include <GLES2/gl2.h>\n\n        class SpriteBatch : public GraphicsComponent {\n        public:\n            SpriteBatch(TimeManager& pTimeManager,\n                    GraphicsManager& pGraphicsManager);\n            ~SpriteBatch();\n\n            Sprite* registerSprite(Resource& pTextureResource,\n                int32_t pHeight, int32_t pWidth);\n\n            status load();\n            void draw();\n\n        private:\n            TimeManager& mTimeManager;\n            GraphicsManager& mGraphicsManager;\n\n            Sprite* mSprites[1024]; int32_t mSpriteCount;\n            Sprite::Vertex mVertices[1024]; int32_t mVertexCount;\n            GLushort mIndexes[1024]; int32_t mIndexCount;\n            GLuint mShaderProgram;\n            GLuint aPosition; GLuint aTexture;\n            GLuint uProjection; GLuint uTexture;\n        };\n        #endif\n        ```", "```kt\n    #include \"SpriteBatch.hpp\"\n    #include \"Log.hpp\"\n\n    #include <GLES2/gl2.h>\n\n    SpriteBatch::SpriteBatch(TimeManager& pTimeManager,\n            GraphicsManager& pGraphicsManager) :\n        mTimeManager(pTimeManager),\n        mGraphicsManager(pGraphicsManager),\n        mSprites(), mSpriteCount(0),\n        mVertices(), mVertexCount(0),\n        mIndexes(), mIndexCount(0),\n        mShaderProgram(0),\n        aPosition(-1), aTexture(-1), uProjection(-1), uTexture(-1)\n    {\n        mGraphicsManager.registerComponent(this);\n    }\n\n    SpriteBatch::~SpriteBatch() {\n        for (int32_t i = 0; i < mSpriteCount; ++i) {\n            delete mSprites[i];\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    Sprite* SpriteBatch::registerSprite(Resource& pTextureResource,\n            int32_t pHeight, int32_t pWidth) {\n        int32_t spriteCount = mSpriteCount;\n        int32_t index = spriteCount * 4; // Points to 1st vertex.\n\n        // Precomputes the index buffer.\n        GLushort* indexes = (&mIndexes[0]) + spriteCount * 6;\n        mIndexes[mIndexCount++] = index+0;\n        mIndexes[mIndexCount++] = index+1;\n        mIndexes[mIndexCount++] = index+2;\n        mIndexes[mIndexCount++] = index+2;\n        mIndexes[mIndexCount++] = index+1;\n        mIndexes[mIndexCount++] = index+3;\n\n        // Appends a new sprite to the sprite array.\n        mSprites[mSpriteCount] = new Sprite(mGraphicsManager,\n                pTextureResource, pHeight, pWidth);\n        return mSprites[mSpriteCount++];\n    }\n    ...\n    ```", "```kt\n    ...\n    static const char* VERTEX_SHADER =\n       \"attribute vec4 aPosition;\\n\"\n       \"attribute vec2 aTexture;\\n\"\n       \"varying vec2 vTexture;\\n\"\n       \"uniform mat4 uProjection;\\n\"\n       \"void main() {\\n\"\n       \"    vTexture = aTexture;\\n\"\n       \"    gl_Position =  uProjection * aPosition;\\n\"\n       \"}\";\n\n    static const char* FRAGMENT_SHADER =\n        \"precision mediump float;\\n\"\n        \"varying vec2 vTexture;\\n\"\n        \"uniform sampler2D u_texture;\\n\"\n        \"void main() {\\n\"\n        \"  gl_FragColor = texture2D(u_texture, vTexture);\\n\"\n        \"}\";\n    ...\n    ```", "```kt\n    ...\n    status SpriteBatch::load() {\n        GLint result; int32_t spriteCount;\n\n        mShaderProgram = mGraphicsManager.loadShader(VERTEX_SHADER,\n                FRAGMENT_SHADER);\n        if (mShaderProgram == 0) return STATUS_KO;\n        aPosition = glGetAttribLocation(mShaderProgram, \"aPosition\");\n        aTexture = glGetAttribLocation(mShaderProgram, \"aTexture\");\n        uProjection = glGetUniformLocation(mShaderProgram,\"uProjection\");\n        uTexture = glGetUniformLocation(mShaderProgram, \"u_texture\");\n\n        // Loads sprites.\n        for (int32_t i = 0; i < mSpriteCount; ++i) {\n            if (mSprites[i]->load(mGraphicsManager)\n                    != STATUS_OK) goto ERROR;\n        }\n        return STATUS_OK;\n\n    ERROR:\n        Log::error(\"Error loading sprite batch\");\n        return STATUS_KO;\n    }\n    ...\n    ```", "```kt\n    ...\n    void SpriteBatch::draw() {\n        glUseProgram(mShaderProgram);\n        glUniformMatrix4fv(uProjection, 1, GL_FALSE,\n                mGraphicsManager.getProjectionMatrix());\n        glUniform1i(uTexture, 0);\n    ...\n    ```", "```kt\n    ...\n        glEnableVertexAttribArray(aPosition);\n        glVertexAttribPointer(aPosition, // Attribute Index\n                              2, // Size in bytes (x and y)\n                              GL_FLOAT, // Data type\n                              GL_FALSE, // Normalized\n                              sizeof(Sprite::Vertex),// Stride\n                              &(mVertices[0].x)); // Location\n        glEnableVertexAttribArray(aTexture);\n        glVertexAttribPointer(aTexture, // Attribute Index\n                              2, // Size in bytes (u and v)\n                              GL_FLOAT, // Data type\n                              GL_FALSE, // Normalized\n                              sizeof(Sprite::Vertex), // Stride\n                              &(mVertices[0].u)); // Location\n    ...\n    ```", "```kt\n    ...\n        glEnable(GL_BLEND);\n        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    ...\n    ```", "```kt\n    ...\n        const int32_t vertexPerSprite = 4;\n        const int32_t indexPerSprite = 6;\n        float timeStep = mTimeManager.elapsed();\n        int32_t spriteCount = mSpriteCount;\n        int32_t currentSprite = 0, firstSprite = 0;\n        while (bool canDraw = (currentSprite < spriteCount)) {\n            // Switches texture.\n            Sprite* sprite = mSprites[currentSprite];\n            GLuint currentTexture = sprite->mTexture;\n            glActiveTexture(GL_TEXTURE0);\n            glBindTexture(GL_TEXTURE_2D, sprite->mTexture);\n    ...\n    ```", "```kt\n    ...\n            // Generate sprite vertices for current textures.\n            do {\n                sprite = mSprites[currentSprite];\n                if (sprite->mTexture == currentTexture) {\n                    Sprite::Vertex* vertices =\n                            (&mVertices[currentSprite * 4]);\n                    sprite->draw(vertices, timeStep);\n                } else {\n                    break;\n                }\n            } while (canDraw = (++currentSprite < spriteCount));\n    ...\n    ```", "```kt\n    ...\n            glDrawElements(GL_TRIANGLES,\n                    // Number of indexes\n                    (currentSprite - firstSprite) * indexPerSprite,\n                    GL_UNSIGNED_SHORT, // Indexes data type\n                    // First index\n                    &mIndexes[firstSprite * indexPerSprite]);\n\n            firstSprite = currentSprite;\n        }\n    ...\n    ```", "```kt\n    ...\n        glUseProgram(0);\n        glDisableVertexAttribArray(aPosition);\n        glDisableVertexAttribArray(aTexture);\n        glDisable(GL_BLEND);\n    }\n    ```", "```kt\n    #include \"GraphicsManager.hpp\"\n    #include \"Sprite.hpp\"\n\n    class Ship {\n    public:\n        ...\n        void registerShip(Sprite* pGraphics);\n        ...\n    private:\n        GraphicsManager& mGraphicsManager;\n        Sprite* mGraphics;\n    };\n    #endif\n    ```", "```kt\n    ...\n    void Ship::registerShip(Sprite* pGraphics) {\n        mGraphics = pGraphics;\n    }\n    ...\n    ```", "```kt\n    ...\n    #include \"Resource.hpp\"\n    #include \"Ship.hpp\"\n    #include \"SpriteBatch.hpp\"\n    #include \"TimeManager.hpp\"\n    #include \"Types.hpp\"\n\n    class DroidBlaster : public ActivityHandler {\n        ...\n    private:\n        ...\n        Asteroid mAsteroids;\n        Ship mShip;\n        SpriteBatch mSpriteBatch;\n    };\n    #endif\n    ```", "```kt\n    ...\n    static const int32_t SHIP_SIZE = 64;\n    static const int32_t SHIP_FRAME_1 = 0;\n    static const int32_t SHIP_FRAME_COUNT = 8;\n    static const float SHIP_ANIM_SPEED = 8.0f;\n\n    static const int32_t ASTEROID_COUNT = 16;\n    static const int32_t ASTEROID_SIZE = 64;\n    static const int32_t ASTEROID_FRAME_1 = 0;\n    static const int32_t ASTEROID_FRAME_COUNT = 16;\n    static const float ASTEROID_MIN_ANIM_SPEED = 8.0f;\n    static const float ASTEROID_ANIM_SPEED_RANGE = 16.0f;\n\n    DroidBlaster::DroidBlaster(android_app* pApplication):\n       ...\n        mAsteroids(pApplication, mTimeManager, mGraphicsManager,\n                mPhysicsManager),\n        mShip(pApplication, mGraphicsManager),\n        mSpriteBatch(mTimeManager, mGraphicsManager) {\n        Log::info(\"Creating DroidBlaster\");\n\n        Sprite* shipGraphics = mSpriteBatch.registerSprite(mShipTexture,\n     SHIP_SIZE, SHIP_SIZE);\n     shipGraphics->setAnimation(SHIP_FRAME_1, SHIP_FRAME_COUNT,\n     SHIP_ANIM_SPEED, true);\n        mShip.registerShip(shipGraphics);\n\n        // Creates asteroids.\n        for (int32_t i = 0; i < ASTEROID_COUNT; ++i) {\n            Sprite* asteroidGraphics = mSpriteBatch.registerSprite(\n     mAsteroidTexture, ASTEROID_SIZE, ASTEROID_SIZE);\n     float animSpeed = ASTEROID_MIN_ANIM_SPEED\n     + RAND(ASTEROID_ANIM_SPEED_RANGE);\n     asteroidGraphics->setAnimation(ASTEROID_FRAME_1,\n     ASTEROID_FRAME_COUNT, animSpeed, true);\n            mAsteroids.registerAsteroid(\n                    asteroidGraphics->location, ASTEROID_SIZE,\n                    ASTEROID_SIZE);\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    status DroidBlaster::onActivate() {\n        Log::info(\"Activating DroidBlaster\");\n\n        if (mGraphicsManager.start() != STATUS_OK) return STATUS_KO;\n\n        // Initializes game objects.\n        mAsteroids.initialize();\n        mShip.initialize();\n\n        mTimeManager.reset();\n        return STATUS_OK;\n    }\n\n    void DroidBlaster::onDeactivate() {\n        Log::info(\"Deactivating DroidBlaster\");\n        mGraphicsManager.stop();\n    }\n    ...\n    ```", "```kt\n    ...\n    class GraphicsManager {\n    public:\n        ...\n        GLuint loadShader(const char* pVertexShader,\n                const char* pFragmentShader);\n        GLuint loadVertexBuffer(const void* pVertexBuffer,\n     int32_t pVertexBufferSize);\n\n    private:\n        ...\n        GLuint mShaders[32]; int32_t mShaderCount;\n        GLuint mVertexBuffers[32]; int32_t mVertexBufferCount;\n\n        GraphicsComponent* mComponents[32]; int32_t mComponentCount;\n    };\n    #endif\n    ```", "```kt\n    ...\n    GraphicsManager::GraphicsManager(android_app* pApplication) :\n        ...\n        mTextures(), mTextureCount(0),\n        mShaders(), mShaderCount(0),\n        mVertexBuffers(), mVertexBufferCount(0),\n        mComponents(), mComponentCount(0) {\n        Log::info(\"Creating GraphicsManager.\");\n    }\n\n    ...\n\n    void GraphicsManager::stop() {\n        Log::info(\"Stopping GraphicsManager.\");\n        ...\n\n        for (int32_t i = 0; i < mVertexBufferCount; ++i) {\n     glDeleteBuffers(1, &mVertexBuffers[i]);\n     }\n     mVertexBufferCount = 0;\n\n        // Destroys OpenGL context.\n        ...\n    }\n    ...\n    ```", "```kt\n        ...\n        GLuint GraphicsManager::loadVertexBuffer(const void* pVertexBuffer,\n                int32_t pVertexBufferSize) {\n            GLuint vertexBuffer;\n            // Upload specified memory buffer into OpenGL.\n            glGenBuffers(1, &vertexBuffer);\n            glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);\n            glBufferData(GL_ARRAY_BUFFER, pVertexBufferSize, pVertexBuffer,\n                    GL_STATIC_DRAW);\n            // Unbinds the buffer.\n            glBindBuffer(GL_ARRAY_BUFFER, 0);\n            if (glGetError() != GL_NO_ERROR) goto ERROR;\n\n            mVertexBuffers[mVertexBufferCount++] = vertexBuffer;\n            return vertexBuffer;\n\n        ERROR:\n            Log::error(\"Error loading vertex buffer.\");\n            if (vertexBuffer > 0) glDeleteBuffers(1, &vertexBuffer);\n            return 0;\n        }\n        ...\n        ```", "```kt\n        #ifndef _PACKT_STARFIELD_HPP_\n        #define _PACKT_STARFIELD_HPP_\n\n        #include \"GraphicsManager.hpp\"\n        #include \"TimeManager.hpp\"\n        #include \"Types.hpp\"\n\n        #include <GLES2/gl2.h>\n\n        class StarField : public GraphicsComponent {\n        public:\n            StarField(android_app* pApplication, TimeManager& pTimeManager,\n                    GraphicsManager& pGraphicsManager, int32_t pStarCount,\n                    Resource& pTextureResource);\n\n            status load();\n            void draw();\n\n        private:\n            struct Vertex {\n                GLfloat x, y, z;\n            };\n\n            TimeManager& mTimeManager;\n            GraphicsManager& mGraphicsManager;\n\n            int32_t mStarCount;\n            Resource& mTextureResource;\n\n            GLuint mVertexBuffer; GLuint mTexture; GLuint mShaderProgram;\n            GLuint aPosition; GLuint uProjection;\n            GLuint uTime; GLuint uHeight; GLuint uTexture;\n        };\n        #endif\n        ```", "```kt\n    #include \"Log.hpp\"\n    #include \"StarField.hpp\"\n\n    StarField::StarField(android_app* pApplication,\n        TimeManager& pTimeManager, GraphicsManager& pGraphicsManager,\n        int32_t pStarCount, Resource& pTextureResource):\n            mTimeManager(pTimeManager),\n            mGraphicsManager(pGraphicsManager),\n            mStarCount(pStarCount),\n            mTextureResource(pTextureResource),\n            mVertexBuffer(0), mTexture(-1), mShaderProgram(0),\n            aPosition(-1),\n            uProjection(-1), uHeight(-1), uTime(-1), uTexture(-1) {\n        mGraphicsManager.registerComponent(this);\n    }\n    ...\n    ```", "```kt\n    ...\n    static const char* VERTEX_SHADER =\n       \"attribute vec4 aPosition;\\n\"\n       \"uniform mat4 uProjection;\\n\"\n       \"uniform float uHeight;\\n\"\n       \"uniform float uTime;\\n\"\n       \"void main() {\\n\"\n       \"    const float speed = -800.0;\\n\"\n       \"    const float size = 8.0;\\n\"\n       \"    vec4 position = aPosition;\\n\"\n       \"    position.x = aPosition.x;\\n\"\n       \"    position.y = mod(aPosition.y + (uTime * speed * aPosition.z),\"\n       \"                                              uHeight);\\n\"\n       \"    position.z = 0.0;\\n\"\n       \"    gl_Position =  uProjection * position;\\n\"\n       \"    gl_PointSize = aPosition.z * size;\"\n       \"}\";\n    ...\n    ```", "```kt\n    ...\n    static const char* FRAGMENT_SHADER =\n        \"precision mediump float;\\n\"\n        \"uniform sampler2D uTexture;\\n\"\n        \"void main() {\\n\"\n        \"  gl_FragColor = texture2D(uTexture, gl_PointCoord);\\n\"\n        \"}\";\n    ...\n    ```", "```kt\n    ...\n    status StarField::load() {\n        Log::info(\"Loading star field.\");\n        TextureProperties* textureProperties;\n\n        // Allocates a temporary buffer and populate it with point data:\n        // 1 vertices composed of 3 floats (X/Y/Z) per point.\n        Vertex* vertexBuffer = new Vertex[mStarCount];\n        for (int32_t i = 0; i < mStarCount; ++i) {\n            vertexBuffer[i].x = RAND(mGraphicsManager.getRenderWidth());\n            vertexBuffer[i].y = RAND(mGraphicsManager.getRenderHeight());\n            vertexBuffer[i].z = RAND(1.0f);\n        }\n        // Loads the vertex buffer into OpenGL.\n        mVertexBuffer = mGraphicsManager.loadVertexBuffer(\n            (uint8_t*) vertexBuffer, mStarCount * sizeof(Vertex));\n        delete[] vertexBuffer;\n        if (mVertexBuffer == 0) goto ERROR;\n    ...\n    ```", "```kt\n    ...\n        // Loads the texture.\n        textureProperties =\n                mGraphicsManager.loadTexture(mTextureResource);\n        if (textureProperties == NULL) goto ERROR;\n        mTexture = textureProperties->texture;\n\n        // Creates and retrieves shader attributes and uniforms.\n        mShaderProgram = mGraphicsManager.loadShader(VERTEX_SHADER,\n                FRAGMENT_SHADER);\n        if (mShaderProgram == 0) goto ERROR;\n        aPosition = glGetAttribLocation(mShaderProgram, \"aPosition\");\n        uProjection = glGetUniformLocation(mShaderProgram,\"uProjection\");\n        uHeight = glGetUniformLocation(mShaderProgram, \"uHeight\");\n        uTime = glGetUniformLocation(mShaderProgram, \"uTime\");\n        uTexture = glGetUniformLocation(mShaderProgram, \"uTexture\");\n\n        return STATUS_OK;\n\n    ERROR:\n        Log::error(\"Error loading starfield\");\n        return STATUS_KO;\n    }\n    ...\n    ```", "```kt\n    ...\n    void StarField::draw() {\n        glDisable(GL_BLEND);\n\n        // Selects the vertex buffer and indicates how data is stored.\n        glBindBuffer(GL_ARRAY_BUFFER, mVertexBuffer);\n        glEnableVertexAttribArray(aPosition);\n        glVertexAttribPointer(aPosition, // Attribute Index\n                              3, // Number of components\n                              GL_FLOAT, // Data type\n                              GL_FALSE, // Normalized\n                              3 * sizeof(GLfloat), // Stride\n                              (GLvoid*) 0); // First vertex\n\n        // Selects the texture.\n        glActiveTexture(GL_TEXTURE0);\n        glBindTexture(GL_TEXTURE_2D, mTexture);\n\n        // Selects the shader and passes parameters.\n        glUseProgram(mShaderProgram);\n        glUniformMatrix4fv(uProjection, 1, GL_FALSE,\n                mGraphicsManager.getProjectionMatrix());\n        glUniform1f(uHeight, mGraphicsManager.getRenderHeight());\n        glUniform1f(uTime, mTimeManager.elapsedTotal());\n        glUniform1i(uTexture, 0);\n\n        // Renders the star field.\n        glDrawArrays(GL_POINTS, 0, mStarCount);\n\n        // Restores device state.\n        glBindBuffer(GL_ARRAY_BUFFER, 0);\n        glUseProgram(0);\n    }\n    ```", "```kt\n    ...\n    #include \"Ship.hpp\"\n    #include \"SpriteBatch.hpp\"\n    #include \"StarField.hpp\"\n    #include \"TimeManager.hpp\"\n    #include \"Types.hpp\"\n\n    class DroidBlaster : public ActivityHandler {\n        ...\n    private:\n        ...\n        Resource mAsteroidTexture;\n        Resource mShipTexture;\n        Resource mStarTexture;\n\n        Asteroid mAsteroids;\n        Ship mShip;\n        StarField mStarField;\n        SpriteBatch mSpriteBatch;\n    };\n    #endif\n    ```", "```kt\n    ...\n\n    static const int32_t STAR_COUNT = 50;\n\n    DroidBlaster::DroidBlaster(android_app* pApplication):\n        mTimeManager(),\n        mGraphicsManager(pApplication),\n        mPhysicsManager(mTimeManager, mGraphicsManager),\n        mEventLoop(pApplication, *this),\n\n        mAsteroidTexture(pApplication, \"droidblaster/asteroid.png\"),\n        mShipTexture(pApplication, \"droidblaster/ship.png\"),\n        mStarTexture(pApplication, \"droidblaster/star.png\"),\n\n        mAsteroids(pApplication, mTimeManager, mGraphicsManager,\n                mPhysicsManager),\n        mShip(pApplication, mGraphicsManager),\n        mStarField(pApplication, mTimeManager, mGraphicsManager,\n                STAR_COUNT, mStarTexture),\n        mSpriteBatch(mTimeManager, mGraphicsManager) {\n        Log::info(\"Creating DroidBlaster\");\n        ...\n    }\n    ```", "```kt\n    float pointSizeRange[2];\n    glGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, pointSizeRange);\n    ```", "```kt\n        ...\n        class GraphicsManager {\n        public:\n            ...\n            int32_t getRenderWidth() { return mRenderWidth; }s\n            int32_t getRenderHeight() { return mRenderHeight; }\n            int32_t getScreenWidth() { return mScreenWidth; }\n         int32_t getScreenHeight() { return mScreenHeight; }\n            GLfloat* getProjectionMatrix() { return mProjectionMatrix[0]; }\n\n        ...\n        ```", "```kt\n        ...\n        private:\n            status initializeRenderBuffer();\n\n         struct RenderVertex {\n         GLfloat x, y, u, v;\n            };\n\n            android_app* mApplication;\n\n            int32_t mRenderWidth; int32_t mRenderHeight;\n            int32_t mScreenWidth; int32_t mScreenHeight;\n            EGLDisplay mDisplay; EGLSurface mSurface; EGLContext mContext;\n            GLfloat mProjectionMatrix[4][4];\n            ...\n\n            // Rendering resources.\n         GLint mScreenFrameBuffer;\n         GLuint mRenderFrameBuffer; GLuint mRenderVertexBuffer;\n         GLuint mRenderTexture; GLuint mRenderShaderProgram;\n         GLuint aPosition; GLuint aTexture;\n         GLuint uProjection; GLuint uTexture;\n        };\n        #endif\n        ```", "```kt\n    #include \"GraphicsManager.hpp\"\n    #include \"Log.hpp\"\n\n    #include <png.h>\n\n    GraphicsManager::GraphicsManager(android_app* pApplication) :\n        ...\n        mComponents(), mComponentCount(0),\n        mScreenFrameBuffer(0),\n     mRenderFrameBuffer(0), mRenderVertexBuffer(0),\n     mRenderTexture(0), mRenderShaderProgram(0),\n     aPosition(0), aTexture(0),\n     uProjection(0), uTexture(0) {\n        Log::info(\"Creating GraphicsManager.\");\n    }\n    ...\n    ```", "```kt\n    ...\n    status GraphicsManager::start() {\n        ...\n        Log::info(\"Initializing the display.\");\n        mSurface = eglCreateWindowSurface(mDisplay, config,\n            mApplication->window, NULL);\n        if (mSurface == EGL_NO_SURFACE) goto ERROR;\n        mContext = eglCreateContext(mDisplay, config, NULL,\n            CONTEXT_ATTRIBS);\n        if (mContext == EGL_NO_CONTEXT) goto ERROR;\n\n        if (!eglMakeCurrent(mDisplay, mSurface, mSurface, mContext)\n       || !eglQuerySurface(mDisplay, mSurface, EGL_WIDTH, &mScreenWidth)\n     || !eglQuerySurface(mDisplay, mSurface, EGL_HEIGHT, &mScreenHeight)\n     || (mScreenWidth <= 0) || (mScreenHeight <= 0)) goto ERROR;\n\n     // Defines and initializes offscreen surface.\n     if (initializeRenderBuffer() != STATUS_OK) goto ERROR;\n\n        glViewport(0, 0, mRenderWidth, mRenderHeight);\n        glDisable(GL_DEPTH_TEST);\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    static const char* VERTEX_SHADER =\n        \"attribute vec2 aPosition;\\n\"\n        \"attribute vec2 aTexture;\\n\"\n        \"varying vec2 vTexture;\\n\"\n        \"void main() {\\n\"\n        \"    vTexture = aTexture;\\n\"\n        \"    gl_Position = vec4(aPosition, 1.0, 1.0 );\\n\"\n        \"}\";\n\n    static const char* FRAGMENT_SHADER =\n        \"precision mediump float;\"\n        \"uniform sampler2D uTexture;\\n\"\n        \"varying vec2 vTexture;\\n\"\n        \"void main() {\\n\"\n        \"  gl_FragColor = texture2D(uTexture, vTexture);\\n\"\n        \"}\\n\";\n    ...\n    ```", "```kt\n    ...\n    const int32_t DEFAULT_RENDER_WIDTH = 600;\n\n    status GraphicsManager::initializeRenderBuffer() {\n        Log::info(\"Loading offscreen buffer\");\n        const RenderVertex vertices[] = {\n            { -1.0f, -1.0f, 0.0f, 0.0f },\n            { -1.0f,  1.0f, 0.0f, 1.0f },\n            {  1.0f, -1.0f, 1.0f, 0.0f },\n            {  1.0f,  1.0f, 1.0f, 1.0f }\n        };\n\n        float screenRatio = float(mScreenHeight) / float(mScreenWidth);\n        mRenderWidth = DEFAULT_RENDER_WIDTH;\n        mRenderHeight = float(mRenderWidth) * screenRatio;\n        glGetIntegerv(GL_FRAMEBUFFER_BINDING, &mScreenFrameBuffer);\n    ...\n    ```", "```kt\n    ...\n        glGenTextures(1, &mRenderTexture);\n        glBindTexture(GL_TEXTURE_2D, mRenderTexture);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,\n                GL_CLAMP_TO_EDGE);\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,\n                GL_CLAMP_TO_EDGE);\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, mRenderWidth,\n                mRenderHeight, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, NULL);\n    ...\n    ```", "```kt\n    ...\n        glGenFramebuffers(1, &mRenderFrameBuffer);\n        glBindFramebuffer(GL_FRAMEBUFFER, mRenderFrameBuffer);\n        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,\n                GL_TEXTURE_2D, mRenderTexture, 0);\n        glBindTexture(GL_TEXTURE_2D, 0);\n        glBindFramebuffer(GL_FRAMEBUFFER, 0);\n    ...\n    ```", "```kt\n    ...\n        mRenderVertexBuffer = loadVertexBuffer(vertices,\n                sizeof(vertices));\n        if (mRenderVertexBuffer == 0) goto ERROR;\n\n        mRenderShaderProgram = loadShader(VERTEX_SHADER, FRAGMENT_SHADER);\n        if (mRenderShaderProgram == 0) goto ERROR;\n        aPosition = glGetAttribLocation(mRenderShaderProgram,\"aPosition\");\n        aTexture = glGetAttribLocation(mRenderShaderProgram, \"aTexture\");\n        uTexture = glGetUniformLocation(mRenderShaderProgram,\"uTexture\");\n\n        return STATUS_OK;\n\n    ERROR:\n        Log::error(\"Error while loading offscreen buffer\");\n        return STATUS_KO;\n    }\n    ...\n    ```", "```kt\n    ...\n    void GraphicsManager::stop() {\n        ...\n\n        if (mRenderFrameBuffer != 0) {\n     glDeleteFramebuffers(1, &mRenderFrameBuffer);\n     mRenderFrameBuffer = 0;\n     }\n     if (mRenderTexture != 0) {\n     glDeleteTextures(1, &mRenderTexture);\n     mRenderTexture = 0;\n     }\n\n        // Destroys OpenGL context.\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    status GraphicsManager::update() {\n        glBindFramebuffer(GL_FRAMEBUFFER, mRenderFrameBuffer);\n     glViewport(0, 0, mRenderWidth, mRenderHeight);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        // Render graphic components.\n        for (int32_t i = 0; i < mComponentCount; ++i) {\n            mComponents[i]->draw();\n        }\n    ...\n    ```", "```kt\n        ...\n            glBindFramebuffer(GL_FRAMEBUFFER, mScreenFrameBuffer);\n         glClear(GL_COLOR_BUFFER_BIT);\n         glViewport(0, 0, mScreenWidth, mScreenHeight);\n\n         glActiveTexture(GL_TEXTURE0);\n         glBindTexture(GL_TEXTURE_2D, mRenderTexture);\n         glUseProgram(mRenderShaderProgram);\n         glUniform1i(uTexture, 0);\n\n         // Indicates to OpenGL how position and uv coordinates are stored.\n         glBindBuffer(GL_ARRAY_BUFFER, mRenderVertexBuffer);\n         glEnableVertexAttribArray(aPosition);\n         glVertexAttribPointer(aPosition, // Attribute Index\n         2, // Number of components (x and y)\n         GL_FLOAT, // Data type\n         GL_FALSE, // Normalized\n         sizeof(RenderVertex), // Stride\n         (GLvoid*) 0); // Offset\n         glEnableVertexAttribArray(aTexture);\n         glVertexAttribPointer(aTexture, // Attribute Index\n         2, // Number of components (u and v)\n         GL_FLOAT, // Data type\n         GL_FALSE, // Normalized\n         sizeof(RenderVertex), // Stride\n         (GLvoid*) (sizeof(GLfloat) * 2)); // Offset\n        ...\n        ```", "```kt\n    ...\n        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n     glBindBuffer(GL_ARRAY_BUFFER, 0);\n\n        // Shows the result to the user.\n        if (eglSwapBuffers(mDisplay, mSurface) != EGL_TRUE) {\n        ...\n    }\n    ...\n    ```"]