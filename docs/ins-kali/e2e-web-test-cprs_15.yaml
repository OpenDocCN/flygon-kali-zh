- en: '*Chapter 12*: Visual Testing in Cypress'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：Cypress中的视觉测试'
- en: Before we get started with visual testing, you should have an idea of the other
    forms of testing and how we can use Cypress to accomplish this. The previous chapters
    of this book covered, at a basic to intermediate level, how to easily get started
    with Cypress, how to configure Cypress, and how you can optimize your use of Cypress
    to develop a more creative workflow for your test writing process. The background
    information in the previous chapters will provide you with the context required
    to tackle this chapter. Our focus in this last chapter of this book will be on
    visual testing using Cypress.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始进行视觉测试之前，您应该了解其他形式的测试以及我们如何使用Cypress来完成这些测试。本书的前几章介绍了如何轻松入门Cypress，如何配置Cypress，以及如何优化您使用Cypress来为测试编写过程开发更有创意的工作流程。前几章的背景信息将为您提供解决本章所需的上下文。本书的最后一章将重点介绍使用Cypress进行视觉测试。
- en: In this chapter, we will cover the basics of visual testing and understand why
    we need it. We will also learn about some of the tools we can use to carry out
    visual testing. The topics in this chapter will help you, as an engineer or a
    tester, understand why visual testing is important for web applications and how
    we can leverage it to write better tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍视觉测试的基础知识，并了解为什么我们需要它。我们还将学习一些工具，可以用来进行视觉测试。本章的主题将帮助你作为工程师或测试人员理解为什么视觉测试对于Web应用程序很重要，以及我们如何利用它来编写更好的测试。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下关键主题：
- en: Visual testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉测试
- en: Understanding viewports
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解视口
- en: Visual testing tools in Cypress tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypress测试中的视觉测试工具
- en: Once you've worked through each of these topics, you will be ready to start
    your journey into the automation testing world with Cypress as your tool of choice.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了每个主题，您将准备好开始使用Cypress作为您的选择工具进入自动化测试世界的旅程。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get started, we recommend that you clone the GitHub repository for this book,
    which contains the source code and all the tests, exercises, and solutions that
    we will be writing in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请克隆本书的GitHub存储库，其中包含本章中将编写的所有源代码、测试、练习和解决方案。
- en: The GitHub repository for this chapter can be found at [https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress](https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的GitHub存储库可以在[https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress](https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress)找到。
- en: The source code for this chapter can be found in the `chapter-12` directory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在`chapter-12`目录中找到。
- en: Inside our GitHub repository, we have a finance test application that we will
    use for the different examples and exercises in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的GitHub存储库中，我们有一个金融测试应用程序，我们将在本章的不同示例和练习中使用它。
- en: 'Important note: Running commands in Windows'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：在Windows中运行命令
- en: 'NB: The default Windows Command Prompt and PowerShell do not correctly resolve
    the directory locations.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注：默认的Windows命令提示符和PowerShell无法正确解析目录位置。
- en: Kindly follow the Windows commands listed further that work exclusively on Windows
    operating systems suffixed with the word `*windows`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请遵循以下列出的Windows命令，这些命令仅适用于Windows操作系统，并以`*windows`结尾。
- en: 'To make sure the test application is running on your machine, run the following
    commands from the root folder directory of the repository on your machine''s terminal:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保测试应用程序在您的计算机上运行，请从存储库的根文件夹目录中在您计算机的终端上运行以下命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Important note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We have our tests in the `chapter-12` directory and the test application located
    in the root directory of the repository. To run our tests properly, we have to
    run both our application and the Cypress tests since the tests run on the live
    application, which has to run locally on our machines. It is important to note
    that the test application will require the use of port `3000` for the frontend
    application and port `3001` for the server application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试位于`chapter-12`目录中，测试应用程序位于存储库的根目录中。为了正确运行我们的测试，我们必须同时运行我们的应用程序和Cypress测试，因为测试是在实时应用程序上运行的，而这个应用程序必须在我们的计算机上本地运行。重要的是要注意，测试应用程序将需要使用端口`3000`用于前端应用程序和端口`3001`用于服务器应用程序。
- en: The first command will navigate us to the `cypress-realworld-app` directory,
    which is where our application is located. The `npm run cypress-init` command
    will install the dependencies that the application requires to run, while the
    `npm run cypress-app` command will start the application. Optionally, you can
    reset the application state using the `npm run cypress-app-reset` command. Resetting
    the application removes any data that was added that was not part of the application,
    thus taking the application's state back to when you cloned the repository.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令将导航到`cypress-realworld-app`目录，这是我们的应用程序所在的位置。`npm run cypress-init`命令将安装应用程序运行所需的依赖项，而`npm
    run cypress-app`命令将启动应用程序。可选地，您可以使用`npm run cypress-app-reset`命令重置应用程序状态。重置应用程序会删除任何不属于应用程序的已添加数据，从而将应用程序状态恢复到克隆存储库时的状态。
- en: Visual testing
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉测试
- en: Whether you are a web developer or a tester, there is a need to ensure that
    the application under development retains the look and feel that was intended
    at project conception. As a developer, you may want to verify that there are no
    visual aspects about your application that changed between releases. As a tester,
    you may want to validate that the application's user interface remains consistent
    between releases and is consistent with the design.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是Web开发人员还是测试人员，都需要确保正在开发的应用程序保留了项目概念时预期的外观和感觉。作为开发人员，您可能希望验证应用程序在发布之间没有发生视觉方面的变化。作为测试人员，您可能希望验证应用程序的用户界面在发布之间保持一致，并且与设计一致。
- en: '**Functional testing** can be used to check for visual aspects, such as validating
    that a button or an input box is present. However, this may involve a lot of code
    being written and, most of the time, will not allow you to test every aspect of
    the application, such as CSS changes when we use it to validate user interface
    elements. Visual testing is the ability to verify visual aspects of an application''s
    user interface and ensure that they are consistent with the expectations.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能测试**可以用来检查视觉方面，比如验证按钮或输入框是否存在。然而，这可能需要编写大量代码，并且大多数情况下，它不会允许您测试应用程序的每个方面，比如在验证用户界面元素时使用CSS更改。视觉测试是验证应用程序用户界面的视觉方面，并确保它们与预期一致的能力。'
- en: In this section, we will learn what visual testing is, what the different types
    of visual testing are, the differences between manual and automated visual testing,
    and when to use different types of visual testing approaches.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习什么是视觉测试，视觉测试的不同类型是什么，手动和自动视觉测试之间的区别，以及何时使用不同类型的视觉测试方法。
- en: Why visual testing?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要进行视觉测试？
- en: Visual testing takes a practical approach as you must directly map the visual
    aspects of a page and compare those aspects to the expected designs. It is possible
    to dismiss the idea of visual testing because we think that our eyes are accurate
    enough for validation purposes, which is a flawed assumption. While the naked
    eye can notice visible page changes, it is a little bit more difficult for the
    eye to detect minute details, such as a change in the CSS properties that made
    an input element move by several pixels or minimal pixel changes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉测试采取了实际的方法，因为您必须直接映射页面的视觉方面，并将这些方面与预期的设计进行比较。我们可能会忽略视觉测试的想法，因为我们认为我们的眼睛对于验证目的足够准确，这是一个错误的假设。虽然肉眼可以注意到可见的页面变化，但对于眼睛来说，检测微小的细节，比如改变CSS属性导致输入元素移动了几个像素或者像素变化很小，可能会更加困难。
- en: Visual testing exists to give both developers and testers confidence that a
    web page's user interface was not broken by any developer changes that were made.
    For instance, with visual testing, there is no need to fear if a version of the
    application that was deployed to the production environment is missing a signup
    button while previous versions of the application had it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉测试的存在是为了让开发人员和测试人员确信网页的用户界面没有被任何开发人员的更改破坏。例如，通过视觉测试，如果部署到生产环境的应用程序版本缺少注册按钮，而以前的应用程序版本有该按钮，就不需要担心。
- en: 'There are two types of visual testing, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的视觉测试，如下所示：
- en: Manual visual testing
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动视觉测试
- en: Automated visual testing
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化视觉测试
- en: These two types of visual testing will open our worlds up to how important visual
    testing is, as well as how we can take advantage of these two testing methods
    to write better tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型的视觉测试将向我们展示视觉测试的重要性，以及我们如何利用这两种测试方法来编写更好的测试。
- en: Manual visual testing
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动视觉测试
- en: 'Manual visual testing involves using the naked eye to validate whether the
    changes that were made by the development team did not break any visible user
    interface functionality. Manual visual testing involves either the testers or
    the development team visually testing the developed user interface and comparing
    it to the designs that were initially created. The process of visually testing
    the application confirms that there are no changes in the behavior, look, and
    feel of the user interface that were not intended. Manual visual testing is good
    and suitable for small changes in the user interface, but this may not be a very
    accurate way of validating an application with a lot of pages and visual elements
    or different viewports. To identify the limitations of manual visual testing,
    the following image, by *Atlantide Phototravel*, shows a side-by-side comparison
    of the Eiffel tower. They are very similar but minute details have been omitted
    in the second frame. Take a few seconds to compare the images and try to find
    the visual differences without looking at the rounded regions in the second image:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 手动视觉测试涉及使用肉眼验证开发团队所做的更改是否破坏了任何可见的用户界面功能。手动视觉测试要么由测试人员，要么由开发团队进行，他们会对开发的用户界面进行视觉测试，并将其与最初创建的设计进行比较。通过视觉测试应用程序的过程确认了行为、外观和用户界面的变化是否符合预期。手动视觉测试适用于用户界面的小改变，但这可能不是一种非常准确的验证应用程序的方式，特别是对于具有许多页面和视觉元素或不同视口的应用程序。为了识别手动视觉测试的局限性，以下图片由*Atlantide
    Phototravel*显示了埃菲尔铁塔的并排比较。它们非常相似，但第二帧中省略了微小的细节。花几秒钟比较这些图像，试图找出视觉上的差异，而不看第二张图像中的圆形区域：
- en: '![Figure 12.1 – Spotting the differences in the Eiffel Tower image'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 - 发现埃菲尔铁塔图像中的差异'
- en: '](image/Figure_12.1_B15616.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.1_B15616.jpg)'
- en: Figure 12.1 – Spotting the differences in the Eiffel Tower image
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 - 发现埃菲尔铁塔图像中的差异
- en: Even to the trained eye, there are details such as bird patterns, missing people,
    and even missing clouds that could make it almost visually impossible to tell
    if there is actually a difference between the two photographs. By applying the
    same idea of manual visual testing, it is very possible to miss details and not
    be able to find any differences between them, even when some elements are missing
    or have been added to the applications under test.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于训练有素的眼睛来说，也有一些细节，比如鸟的图案、缺少的人和甚至缺少的云，这几乎让人无法通过视觉来判断两张照片之间是否真的有差异。通过应用手动视觉测试的相同想法，很可能会忽略细节，无法找到它们之间的任何差异，即使一些元素在测试应用程序中丢失或添加了。
- en: Automated visual testing
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化视觉测试
- en: Automated visual testing involves testing the visual elements of the page. Instead
    of using a manual approach, an automated process to check the consistency of the
    application pages is used. To run automated visual tests properly, we must save
    and define our desired user interface as a **baseline**. We can then use this
    in our tests to check whether we need to update the baseline or modify the changes
    made to our application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化视觉测试涉及测试页面的视觉元素。与手动方法不同，使用自动化流程来检查应用程序页面的一致性。要正确运行自动化视觉测试，我们必须将所需的用户界面保存和定义为基线。然后我们可以在测试中使用这个基线来检查是否需要更新基线或修改应用程序所做的更改。
- en: Automated visual testing has its roots in functional testing. Instead of asserting
    every element in a page and also checking the properties of the elements in a
    page, automated visual testing takes the approach of checking the entire page
    with a single assertion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化视觉测试源于功能测试。自动化视觉测试采用了检查整个页面的方法，而不是断言页面中的每个元素并检查元素的属性。
- en: 'There are two types of automated visual testing:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化视觉测试有两种类型：
- en: Snapshot testing
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照测试
- en: Visual AI testing
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉AI测试
- en: Let's look at each of them in detail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每一种。
- en: Snapshot testing
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 快照测试
- en: Snapshot testing is a type of automated visual testing where a raster graphic
    or a bitmap of a specific screen is recorded when the test is running. The recorded
    bitmap is then checked against the baseline bitmap that was recorded previously
    (baseline). The algorithms in the snapshot testing tools only check whether there
    are pixel differences in the bitmap by comparing **hex color codes**. If any color
    code differences are identified, then a snapshot bug is reported or an image showing
    visual differences is generated.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 快照测试是一种自动化视觉测试，当测试运行时，记录特定屏幕的光栅图形或位图。然后检查记录的位图与先前记录的基线位图（基线）是否一致。快照测试工具中的算法仅通过比较十六进制颜色代码来检查位图中是否存在像素差异。如果识别出任何颜色代码差异，则报告快照错误或生成显示视觉差异的图像。
- en: Snapshot testing is a significantly quicker way to identify bugs in user interfaces
    compared to manual testing. Snapshot testing is the preferred way of testing web
    applications if the application is somewhat static in nature and does not have
    a lot of dynamic content changes in the user interface. Snapshot testing does
    not handle dynamic content properly as the algorithm detects any change in content
    as a visual difference due to pixel changes. With all visual changes being identified
    as a visual difference or a potential bug, it would be impossible to have consistent
    snapshot images of pages that contain dynamic data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动测试相比，快照测试是识别用户界面中的错误的一种更快的方法。如果应用程序在某种程度上是静态的，并且用户界面中没有太多的动态内容更改，那么快照测试是测试Web应用程序的首选方式。快照测试无法正确处理动态内容，因为算法将内容中的任何更改都视为视觉差异，由于像素更改。由于所有视觉变化都被识别为视觉差异或潜在的错误，因此在包含动态数据的页面上拥有一致的快照图像将是不可能的。
- en: Visual AI testing
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 视觉AI测试
- en: Visual AI testing is the new generation of automated visual testing and makes
    use of **AI** (**AI**). The main goal of visual AI testing is to improve on the
    shortcomings of snapshot testing, such as handling dynamic content when testing
    applications. By using computer vision, visual AI algorithms can identify images
    and areas where our tests can run and even in the event of dynamic content, they
    can identify the regions where our content is allowed to be dynamic and the regions
    that should remain unchanged.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉AI测试是自动化视觉测试的新一代，利用了人工智能（AI）。视觉AI测试的主要目标是改进快照测试的缺点，例如在测试应用程序时处理动态内容。通过使用计算机视觉，视觉AI算法可以识别图像和测试可以运行的区域，甚至在动态内容的情况下，它们可以识别内容允许动态的区域和应保持不变的区域。
- en: Visual AI testing also makes it easier for developers and testers to perform
    cross-browser testing. With cross-browser applications, the user can write a single
    test that can then be run in different **viewports** that are supported by the
    application. **Viewport testing** is a handy tool as it removes the burden of
    the developer – or the tester writing snapshot tests for every device – checking
    every viewport to verify that there are no visual changes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉AI测试还使开发人员和测试人员更容易进行跨浏览器测试。对于跨浏览器应用程序，用户可以编写单个测试，然后在应用程序支持的不同视口中运行该测试。视口测试是一个方便的工具，因为它消除了开发人员或测试人员为每个设备编写快照测试的负担，以验证是否存在视觉变化。
- en: Recap – visual testing
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾-视觉测试
- en: In this section, we learned about what visual testing is, the different types
    of visual testing, and when to use each type of visual testing. We learned the
    difference between automated visual testing and manual visual testing, and we
    also learned about the different types of automated visual testing. We then learned
    why visual testing is a preferred approach to manual testing and why there is
    a new generation of visual testing that improves on the shortcomings that were
    present in the first-generation visual testing tools. Now that we know all about
    visual testing, in the next section, we will explore more areas that require visual
    testing by understanding what viewports are and how to test them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了什么是视觉测试，不同类型的视觉测试以及何时使用每种类型的视觉测试。我们了解了自动化视觉测试和手动视觉测试之间的区别，还了解了不同类型的自动化视觉测试。然后我们了解了为什么视觉测试是手动测试的首选方法，以及为什么有一种新一代的视觉测试工具改进了第一代视觉测试工具存在的缺点。现在我们已经了解了关于视觉测试的一切，在下一节中，我们将通过了解视口是什么以及如何测试它们来探索更多需要视觉测试的领域。
- en: Understanding viewports
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解视口
- en: A viewport is the visible area of a user's web page. Therefore, the term viewport
    is used to measure the rectangular viewing region on a user's device. When computers
    were first invented, there were only a few available viewports, though that has
    significantly increased due to more devices being created. At the time of writing,
    new viewports are being created by devices such as folding phones or flipping
    screens, and smart televisions with different dimensions, so it is up to developers
    to ensure that their applications are compatible with the user's devices. With
    different viewports, new challenges arise in terms of making applications compatible
    with such viewports, and this is even a greater nightmare for testers as it is
    practically not possible to test an application through every available viewport.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 视口是用户网页的可见区域。因此，视口这个术语用于测量用户设备上的矩形查看区域。当计算机首次发明时，只有少数可用的视口，但由于创建了更多的设备，这种情况已经显著增加。在撰写本文时，由折叠手机或翻转屏幕以及具有不同尺寸的智能电视等设备创建了新的视口，因此开发人员需要确保他们的应用与用户的设备兼容。使用不同的视口，会出现新的挑战，使应用与这些视口兼容，这对测试人员来说是一个更大的噩梦，因为几乎不可能通过每个可用的视口测试应用。
- en: In this section, we will explore the importance of viewports, how to approach
    testing in different viewports, and the role of viewports in visual testing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将探讨视口的重要性，如何在不同的视口中进行测试以及视口在视觉测试中的作用。
- en: Viewports and testing
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视口和测试
- en: Viewports play a major role when it comes to testing web applications as they
    show how the actual users will view the web application that is under test. At
    the time of writing, mobile viewports are the most commonly used viewports. This
    is because phones have been evolving to become the most powerful pieces of technology
    that are both portable and handheld. To provide good experiences for users, viewport
    testing should be a top priority. With viewport testing, we can check for qualities
    such as how responsive the web application is to different screen sizes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 视口在测试网页应用程序时起着重要作用，因为它们显示了实际用户将如何查看正在测试的网页应用程序。在撰写本文时，移动视口是最常用的视口。这是因为手机已经发展成为最强大的便携式技术设备。为了为用户提供良好的体验，视口测试应该是首要任务。通过视口测试，我们可以检查网页应用对不同屏幕尺寸的响应性等特性。
- en: Developing responsive web applications provides an advantage over non-responsive
    web applications as they take less time and resources to develop compared to standalone
    mobile applications, which are either on iOS or Android and performing the same
    functions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 开发响应式网页应用程序比非响应式网页应用程序具有优势，因为与独立的iOS或Android移动应用程序相比，它们需要更少的时间和资源来开发，并且执行相同的功能。
- en: 'All modern browsers allow us check and test for responsiveness when building
    applications. The following screenshot shows an iPhone 6 viewport rendered on
    a Chrome browser showing how the Cypress documentation page would appear on a
    mobile phone:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代浏览器都允许我们在构建应用时检查和测试响应性。下面的截图显示了在Chrome浏览器上呈现的iPhone 6视口，显示了Cypress文档页面在手机上的呈现方式：
- en: '![Figure 12.2 – iPhone 6 mobile viewport'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2- iPhone 6移动视口'
- en: '](image/Figure_12.2_B15616.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.2_B15616.jpg)'
- en: Figure 12.2 – iPhone 6 mobile viewport
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2- iPhone 6移动视口
- en: 'We can use the **toggle device toolbar** on the browser to toggle between the
    normal web view and the mobile device view. This allows us to see how different
    web applications are rendered on different viewports. In instances where the web
    applications are responsive, there will be no issue testing the different viewports
    as the applications will automatically adapt to the changing viewports. However,
    this is not the case for non-responsive web applications. In the following screenshot,
    you can see the options for the current viewports, as well as the ability to add
    custom viewports that have not been defined by the browser:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在浏览器上使用**切换设备工具栏**在正常网页视图和移动设备视图之间切换。这使我们能够看到不同的网页应用在不同视口上的呈现方式。在网页应用响应的情况下，测试不同视口不会有问题，因为应用会自动适应不同的视口。然而，对于不响应的网页应用来说情况就不同了。在下面的截图中，您可以看到当前视口的选项，以及添加浏览器未定义的自定义视口的能力：
- en: '![Figure 12.3 – Browser viewport selection'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3-浏览器视口选择'
- en: '](image/Figure_12.3_B15616.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.3_B15616.jpg)'
- en: Figure 12.3 – Browser viewport selection
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3-浏览器视口选择
- en: As shown in the preceding screenshot, it is possible to add new test viewports
    that do not exist in the Chrome browser's list of devices.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，可以添加Chrome浏览器设备列表中不存在的新测试视口。
- en: When choosing a viewport, the Chrome web area automatically adjusts the content
    that's visible on the browser. As a developer or a tester, it is easy to find
    out whether changes are required for the application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择视口时，Chrome网页区域会自动调整浏览器上可见的内容。作为开发人员或测试人员，很容易找出应用是否需要进行更改。
- en: Viewports and automated visual testing
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视口和自动化视觉测试
- en: Considering the number of viewports shown in the preceding screenshot, it is
    cumbersome to manually test every single viewport and verify that there were no
    changes that broke the user interface of the application, or any that introduced
    unnecessary changes that were not intended. To ensure that the viewports are tested,
    we can use automated visual testing to check for consistency in the application
    through different viewports. With visual testing, we can validate that no unintended
    changes were made to our application in the different viewports that we configure
    in our tests.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面截图中显示的视口数量，手动测试每个单独的视口并验证是否有破坏应用用户界面或引入不必要的未预期变化的变化是很繁琐的。为了确保视口被测试，我们可以使用自动化视觉测试来检查应用在不同视口下的一致性。通过视觉测试，我们可以验证我们的应用在测试中配置的不同视口中是否发生了意外变化。
- en: Recap – viewports
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾-视口
- en: Viewports are a critical aspect of visual testing, especially since most of
    the major issues regarding web applications responsiveness are a result of viewport
    bugs. In this section, we learned about different types of viewports and how we
    can check the responsiveness of our web applications using the browser's toggle
    option, which switches between different device viewports and the normal computer
    viewport. We also learned that by using automated visual testing, we can automate
    different test cases for different viewports and automatically know whether unintended
    changes were made to the application. In the next section, we will explore how
    we can use Cypress to write automated visual tests using an automated Visual AI
    tool and Percy, which utilizes snapshots to record visual tests.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 视口是视觉测试的关键方面，特别是因为大多数关于Web应用响应性的主要问题都是由于视口错误造成的。在本节中，我们了解了不同类型的视口以及如何使用浏览器的切换选项来检查我们的Web应用的响应性，该选项可以在不同设备视口和正常计算机视口之间切换。我们还了解到，通过使用自动化视觉测试，我们可以为不同的视口自动化不同的测试用例，并自动知道应用程序是否发生了意外更改。在下一节中，我们将探讨如何使用Cypress编写自动化视觉测试，使用自动化视觉AI工具和Percy，后者利用快照记录视觉测试。
- en: Automated visual testing tools
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化视觉测试工具
- en: Visual testing is an important part of Cypress as it is a transition from what
    we are familiar with, which is functional testing. With visual testing, Cypress
    presents a new world of opportunities regarding how we can test user interfaces
    without necessarily writing hundreds of lines of functional code to assert individual
    elements on a page.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉测试是Cypress的重要组成部分，因为它是从我们熟悉的功能测试转变而来的。通过视觉测试，Cypress为我们提供了一个新的机会，可以在不必为了断言页面上的单个元素而编写数百行功能代码的情况下测试用户界面。
- en: In this section, we will dive into working with two automated visual testing
    tools by integrating them with Cypress, and then learn how we can achieve our
    goals of visually testing applications using them. One of these tools uses snapshots
    that record a **baseline bitmap** and compare the bitmap image pixels one after
    the other, checking for whether there are any discrepancies in the hex colors.
    The other tool uses AI algorithms to compare snapshots from our web application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究如何通过将它们与Cypress集成来使用两个自动化视觉测试工具，然后学习如何使用它们来实现我们的视觉测试应用程序的目标。其中一个工具使用快照记录一个**基线位图**，并逐个比较位图图像像素，检查十六进制颜色是否存在任何差异。另一个工具使用AI算法来比较来自我们Web应用程序的快照。
- en: By the end of this section, we will have an idea of what tool to use, when and
    how Cypress plays a role in creating simple integrations of the testing tools,
    and the tests themselves. The two tools we will look at are Applitools Eyes SDK
    and Percy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，我们将了解使用什么工具，在什么时候以及Cypress如何在创建测试工具和测试本身的简单集成中发挥作用。我们将研究的两个工具是Applitools
    Eyes SDK和Percy。
- en: Percy
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Percy
- en: Percy is a visual testing and review platform that integrates with testing tools.
    This enables developers and QA engineers identify visual bugs that would otherwise
    have been difficult to identify and report. Percy makes visual testing a walk
    in the park – all you need to do is to download the Percy npm module, configure
    **BrowserStack**, and add Percy to your tests. Once you've done all the necessary
    configuration, you can copy the **TOKEN** that Percy provides, which will be used
    as an environment variable in your machine and is required if you wish to upload
    your test snapshots to the Browserstack cloud to review and identify visual differences,
    if any.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Percy是一个与测试工具集成的视觉测试和审查平台。这使开发人员和质量保证工程师能够识别视觉错误，否则这些错误将很难识别和报告。Percy使视觉测试变得轻而易举
    - 您只需要下载Percy npm模块，配置**BrowserStack**，并将Percy添加到您的测试中。完成所有必要的配置后，您可以复制Percy提供的**TOKEN**，该TOKEN将作为环境变量在您的机器上使用，如果您希望上传您的测试快照到Browserstack云以审查和识别可能存在的视觉差异。
- en: Important note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Browserstack is a visual testing and review tool, and it owns the **Percy**
    tool. To configure Percy, you need to configure Browserstack; all the configurations
    will be synced between the two platforms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Browserstack是一个视觉测试和审查工具，拥有**Percy**工具。要配置Percy，您需要配置Browserstack；所有配置将在两个平台之间同步。
- en: Percy mainly relies on the Firefox and Chrome browsers. To test an application,
    Percy runs it through a set of browsers in various viewports, and any changes
    that have been made to the various viewports are recorded. When the first image
    is recorded and saved, Percy then makes the image in your test **baseline**, and
    will use the image to check for any changes in the subsequent test runs for similar
    images before highlighting any visual differences that may have occurred.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Percy主要依赖于Firefox和Chrome浏览器。为了测试应用程序，Percy会在各种视口中运行一组浏览器，并记录各种视口的任何更改。当第一张图像被记录并保存时，Percy会将图像作为您的测试**基线**，并在后续测试运行中使用该图像来检查类似图像的任何更改，然后突出显示可能发生的任何视觉差异。
- en: Setting up Percy
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置Percy
- en: 'Setting up Percy is not complicated and involves the following steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Percy并不复杂，涉及以下步骤：
- en: Create an account with BrowserStack ([https://www.browserstack.com/](https://www.browserstack.com/)).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用BrowserStack创建一个帐户（[https://www.browserstack.com/](https://www.browserstack.com/)）。
- en: Verify your BrowserStack email address.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您的BrowserStack电子邮件地址。
- en: Create an organization in the Browserstack dashboard.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Browserstack仪表板中创建一个组织。
- en: Log into the Percy dashboard using your BrowserStack account.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的BrowserStack帐户登录Percy仪表板。
- en: Create a project on the Percy dashboard.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Percy仪表板上创建一个项目。
- en: Configure Percy on your local project using the instructions on the Percy website
    ([https://docs.percy.io/docs/cypress](https://docs.percy.io/docs/cypress)).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Percy网站上的说明在本地项目上配置Percy（[https://docs.percy.io/docs/cypress](https://docs.percy.io/docs/cypress)）。
- en: Add a Percy TOKEN to your local machine as an environment variable.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Percy TOKEN添加到您的本地机器作为环境变量。
- en: Voila! You are now ready to write your tests!
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哇！您现在已经准备好编写您的测试了！
- en: Once *steps 1 - 4* have been completed, Percy provides you with a TOKEN that
    you must add to your machine environment variable before executing your tests.
    You can visit the Percy documentation ([https://docs.percy.io/docs/cypress](https://docs.percy.io/docs/cypress))
    for more information on how to set up Percy using Cypress.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 完成*步骤1-4*后，Percy会提供一个令牌，您必须在执行测试之前将其添加到机器环境变量中。您可以访问Percy文档（[https://docs.percy.io/docs/cypress](https://docs.percy.io/docs/cypress)）了解如何使用Cypress设置Percy的更多信息。
- en: 'Once everything has been set up, we can run our first test, which will involve
    checking whether we can see visual differences on our login page when the content
    is changed. As shown in the following screenshot, we have run our test by entering
    a username and a password on the login page:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都设置好后，我们可以运行第一个测试，这将涉及检查当内容更改时我们的登录页面是否有视觉差异。如下截图所示，我们在登录页面上输入用户名和密码运行了我们的测试：
- en: '![Figure 12.4 – Percy – new snapshot'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 – Percy – 新快照'
- en: '](image/Figure_12.4_B15616.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.4_B15616.jpg)'
- en: Figure 12.4 – Percy – new snapshot
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – Percy – 新快照
- en: Here, we can see the snapshot image that was uploaded to the Percy dashboard.
    The uploaded snapshot is our login page. Immediately after uploading the snapshot,
    Percy gives us the option to toggle the Chrome and Firebox browsers so that we
    can check the consistency of the snapshots. On the main Percy dashboard, we have
    the option to approve all our snapshots, reject and accept a single snapshot,
    and even toggle between the desktop viewport and the mobile viewport presented
    to us.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到上传到Percy仪表板的快照图像。上传的快照是我们的登录页面。在上传快照后，Percy让我们可以切换Chrome和Firebox浏览器，以便我们可以检查快照的一致性。在主Percy仪表板上，我们可以批准所有快照，拒绝和接受单个快照，甚至在桌面视口和移动视口之间切换。
- en: Important note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Percy only uploads the snapshots to the dashboard when the test's execution
    is terminated and the terminal running the tests is closed. This is different
    from the Applitools tool, which continuously uploads the test snapshots immediately
    when the tests have finished execution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当测试执行结束并关闭运行测试的终端时，Percy才会将快照上传到仪表板。这与Applitools工具不同，后者在测试执行结束后立即连续上传测试快照。
- en: 'As we mentioned earlier, we can use Percy to compare bitmap images of our recorded
    baseline images and the newly generated bitmap images. The algorithm involved
    then checks for pixel by pixel differences, which are then recorded as visual
    differences when the baseline image is not similar to the newly generated image
    that was generated in the second run of our test application. The following screenshot
    shows a second build of our tests on the Percy dashboard. Here, we have omitted
    some of the characters in the username and password fields and we want to check
    whether Percy identifies these discrepancies:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们可以使用Percy来比较我们记录的基准图像和新生成的位图图像。然后涉及的算法逐像素检查差异，当基准图像与在测试应用程序的第二次运行中生成的新图像不相似时，这些差异被记录为视觉差异。以下截图显示了我们在Percy仪表板上测试的第二次构建。在这里，我们省略了用户名和密码字段中的一些字符，并且我们想检查Percy是否识别出这些差异：
- en: '![Figure 12.5 – Percy pixel differences'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – Percy像素差异'
- en: '](image/Figure_12.5_B15616.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.5_B15616.jpg)'
- en: Figure 12.5 – Percy pixel differences
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – Percy像素差异
- en: As shown in the preceding screenshot, once we ran our second build, we omitted
    some of the characters in both our username and password fields. When the snapshots
    are uploaded to Percy, the program identifies the visual differences by checking
    the pixels of the different images and provides us with the region where the pixel
    differences were identified. On our second run, when we *approve* these changes,
    Percy adopts our second image as the **baseline**. If we *Request changes* on
    the image, Percy will then retain our first image as the baseline for this particular
    snapshot.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，当我们运行第二个构建时，我们省略了用户名和密码字段中的一些字符。当快照上传到Percy时，程序通过检查不同图像的像素来识别视觉差异，并为我们提供识别出像素差异的区域。在我们的第二次运行中，当我们*批准*这些更改时，Percy采用我们的第二个图像作为**基准**。如果我们在图像上*请求更改*，Percy将保留我们的第一个图像作为此特定快照的基准。
- en: Upon closer inspection, our first snapshot login username was *Kathe*, while
    in our second snapshot, the login username was *Kat*. The omission of some characters
    in the password and some characters in the username is what triggers Percy to
    show these visual differences. This gives us the option to either accept the changes
    and change our baseline or request changes from the developers if the change is
    not consistent with our expectations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查后，我们发现第一个快照的登录用户名是*Kathe*，而在第二个快照中，登录用户名是*Kat*。密码中的一些字符和用户名中的一些字符的省略是触发Percy显示这些视觉差异的原因。这使我们可以选择接受更改并更改我们的基准，或者如果更改与我们的期望不一致，则向开发人员请求更改。
- en: Reminder
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: For you to successfully run tests and upload the snapshots to the Percy dashboard,
    you need to create an account with BrowserStack, create an organization in BrowserStack,
    sign in with Browserstack on your Percy dashboard, create a project in Percy,
    and add the token provided on the Percy project dashboard to your machine's environment
    variables.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功运行测试并将快照上传到Percy仪表板，您需要在BrowserStack上创建一个帐户，在BrowserStack中创建一个组织，在Percy仪表板上使用Browserstack登录，创建一个Percy项目，并将Percy项目仪表板上提供的令牌添加到机器的环境变量中。
- en: 'Percy is quick to set up, both locally on the machine and also on the tests.
    To invoke Percy, only a single line needs to be added to the test. The following
    code block shows the first and second snapshots being generated, as well as the
    arguments that are passed to the `cy.percySnapshot()` command for naming the snapshots:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Percy在本地机器上和测试中都很容易设置。要调用Percy，只需要在测试中添加一行代码。以下代码块显示了生成第一和第二快照，以及传递给`cy.percySnapshot()`命令的参数来命名快照：
- en: '[PRE1]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first test in the preceding code block was run in the first build, while
    the second test was run in the second build along with the modified username and
    password details to provide the pixel differences in our login page. To run these
    tests yourself, all you need to do is obtain the Percy token by following the
    Percy setup process mentioned previously and add your Percy project token as an
    environment variable of your machine. The complete source code for these tests
    can be obtained from this book's GitHub repository, in the `chapter-12` directory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个构建中运行了前面代码块中的第一个测试，而第二个测试是在第二个构建中运行的，同时修改了用户名和密码详细信息，以提供我们登录页面中的像素差异。要自行运行这些测试，您只需要按照之前提到的Percy设置过程获取Percy令牌，并将您的Percy项目令牌添加为计算机的环境变量。这些测试的完整源代码可以从本书的GitHub存储库中的`chapter-12`目录中获取。
- en: Exercise 1
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1
- en: 'In this exercise, we are going to practice what we learned in the previous
    section: we will learn how to use Percy to perform visual testing and then interact
    with the Percy configuration and dashboard. Follow these steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将练习之前学到的知识：学习如何使用Percy进行视觉测试，然后与Percy配置和仪表板进行交互。按照以下步骤：
- en: Using Percy and Cypress, log into our test application and navigate to the dashboard.
    Then, using the `Percy` command, take a snapshot of the public transactions page.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Percy和Cypress，登录到我们的测试应用程序并导航到仪表板。然后，使用`Percy`命令，对公共交易页面进行快照。
- en: Add a new transaction by clicking the **New transactions** button on the application
    and add the transaction details.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击应用程序上的**新交易**按钮并添加交易详细信息来添加新交易。
- en: Take another snapshot and use Percy to compare the transactions page's differences
    when another transaction is added.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拍摄另一个快照，并使用Percy比较添加另一个交易时的交易页面差异。
- en: Important note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember to add your Percy **TOKEN** variable, which can be obtained from the
    Percy project dashboard, to your local machine before running your tests so that
    the snapshots taken by Percy can be successfully uploaded to the Percy dashboard.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试之前，记得将您的Percy **TOKEN**变量添加到本地计算机，以便Percy拍摄的快照可以成功上传到Percy仪表板。
- en: The solutions to this exercise can be found in `chapter-12/cypress/integration/percy/percy-excercise.spec.js`
    directory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的解决方案可以在`chapter-12/cypress/integration/percy/percy-excercise.spec.js`目录中找到。
- en: By going through this exercise and being able to properly set up Percy in Cypress,
    I believe you now understand how you can use Percy to identify visual differences
    in your tests, as well as quickly identify discrepancies when your application's
    user interfaces change. You can do this by doing a pixel-by-pixel comparison of
    the bitmap images of our application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习并能够在Cypress中正确设置Percy，我相信你现在了解了如何使用Percy来识别测试中的视觉差异，以及在应用程序用户界面发生变化时快速识别差异。你可以通过对我们应用程序的位图图像进行逐像素比较来实现这一点。
- en: Applitools
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Applitools
- en: Applitools is a tool that utilizes AI to visually test and monitor applications.
    Just like Percy, Applitools is easy to set up using Cypress and focuses on improving
    the shortcomings of tools such as Percy. Percy identifies visual differences by
    comparing individual pixels, while Applitools identifies visual differences by
    using its AI powered algorithms to check whether the changes are expected changes
    or bugs. With Applitools, it is easier to test dynamic changes as we can omit
    areas where we do not want Applitools to check for visual differences.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Applitools是一种利用人工智能来进行视觉测试和监控应用程序的工具。就像Percy一样，使用Cypress设置Applitools很容易，并专注于改进Percy等工具的不足之处。Percy通过比较单个像素来识别视觉差异，而Applitools通过使用其AI算法来检查变化是否是预期的变化或错误来识别视觉差异。使用Applitools，更容易测试动态变化，因为我们可以省略我们不希望Applitools检查视觉差异的区域。
- en: The ability to identify bugs by specifying regions that should be checked, and
    others that should be ignored, is what makes Applitools a better tool when it
    comes to testing applications that involve dynamic content.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定应该检查的区域和应该忽略的区域来识别错误的能力，使Applitools成为测试涉及动态内容的应用程序时更好的工具。
- en: Setting up Applitools
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置Applitools
- en: 'Just like Percy, the Applitools Eyes SDK is relatively easy to set up with
    Cypress. This can be achieved by performing the following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Percy一样，使用Cypress设置Applitools Eyes SDK相对容易。可以通过以下步骤实现：
- en: Create an account with Applitools ([https://auth.applitools.com/users/register](https://auth.applitools.com/users/register)).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Applitools创建一个帐户（[https://auth.applitools.com/users/register](https://auth.applitools.com/users/register)）。
- en: Verify your Applitools email address.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您的Applitools电子邮件地址。
- en: Navigate to the Applitools dashboard to obtain the API key.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到Applitools仪表板以获取API密钥。
- en: Configure Applitools on your local project.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地项目上配置Applitools。
- en: Add the Applitools **APPLITOOLS_API_KEY** to your local machine as an environment
    variable.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Applitools的**APPLITOOLS_API_KEY**添加到您的本地计算机作为环境变量。
- en: Party!
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派对！
- en: Once *steps 1* and *2* have been completed, Applitools provides you with an
    **APPLITOOLS_API_KEY**, similar to the Percy **TOKEN**, that you must add as an
    environment variable to your machine before executing your tests. You can visit
    the Applitools and Cypress documentation ([https://applitools.com/tutorials/cypress.html](https://applitools.com/tutorials/cypress.html))
    to find out more about how to set up the Applitools Eyes SDK using Cypress.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦*步骤1*和*步骤2*完成，Applitools会为您提供一个**APPLITOOLS_API_KEY**，类似于Percy的**TOKEN**，您必须在执行测试之前将其添加为计算机的环境变量。您可以访问Applitools和Cypress文档（[https://applitools.com/tutorials/cypress.html](https://applitools.com/tutorials/cypress.html)）了解有关如何使用Cypress设置Applitools
    Eyes SDK的更多信息。
- en: 'Once everything has been set up, we can now run our first test using Cypress
    and the Applitools Eyes SDK. Applitools is a very rich tool, so we will not be
    able to cover all the features that it comes bundled with. Instead, we will focus
    on the advantages of Applitools in terms of using it as a visual testing tool.
    In the following screenshot, we have the same login test that we ran in our Percy
    example but modified for Applitools Eyes tests:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都设置好后，我们现在可以使用Cypress和Applitools Eyes SDK运行我们的第一个测试。Applitools是一个非常丰富的工具，所以我们无法涵盖它捆绑的所有功能。相反，我们将专注于Applitools作为视觉测试工具的优势。在下面的屏幕截图中，我们有相同的登录测试，我们在Percy示例中运行了该测试，但修改为Applitools
    Eyes测试：
- en: '![Figure 12.6 – Applitools login page snapshot'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6 – Applitools登录页面快照'
- en: '](image/Figure_12.6_B15616.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.6_B15616.jpg)'
- en: Figure 12.6 – Applitools login page snapshot
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – Applitools登录页面快照
- en: Here, we can see the snapshot representing the first login page snapshot that
    the Applitools Eyes SDK took and uploaded to the Applitools dashboard. Applitools
    uses three commands to control Cypress tests. The first command, `cy.eyesOpen()`,
    is for initializing and starting the test, the second command, `cy.eyesCheckWindow()`,
    is responsible for taking screenshots, as in the previous case, and the third
    command, `eyesClose()`, completes the Applitools Eyes session and uploads the
    screenshots to the dashboard.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到代表Applitools Eyes SDK拍摄并上传到Applitools仪表板的第一个登录页面快照的快照。Applitools使用三个命令来控制Cypress测试。第一个命令`cy.eyesOpen()`用于初始化和启动测试，第二个命令`cy.eyesCheckWindow()`负责拍摄屏幕截图，就像前面的情况一样，第三个命令`eyesClose()`完成Applitools
    Eyes会话并将屏幕截图上传到仪表板。
- en: 'Our login test can be written in the following format. This opens the Applitools
    Eyes SDK, takes a screenshot, and closes the SDK before uploading the screenshots
    to the Applitools dashboard so that they can be compared visually by the Applitools
    AI algorithms. The following code block shows the second build provided in the
    preceding screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的登录测试可以以以下格式编写。这会打开Applitools Eyes SDK，拍摄屏幕截图，并在上传屏幕截图到Applitools仪表板之前关闭SDK，以便Applitools
    AI算法可以通过视觉比较进行比较。以下代码块显示了前面屏幕截图中提供的第二个构建：
- en: '[PRE2]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we can observe that to run the tests, we need to initialize the Applitools
    Eyes SDK, then take the screenshot before closing our tests. All three methods
    that the Eyes SDK utilizes can have configuration parameters that can be changed,
    depending on your needs. In our code block, for example, we have configured the
    `cy.eyesOpen()` command so that we have our test batch name and the configuration
    of the browser window visible.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以观察到，为了运行测试，我们需要初始化Applitools Eyes SDK，然后在关闭测试之前拍摄屏幕截图。Eyes SDK使用的所有三种方法都可以具有配置参数，这些参数可以根据您的需求进行更改。例如，在我们的代码块中，我们已配置`cy.eyesOpen()`命令，以便我们有测试批次名称和浏览器窗口可见的配置。
- en: 'Applitools goes a step further when it comes to reporting errors. In Percy,
    we identified that due to its pixel-by-pixel comparisons, any change in the user
    interface is detected as a visual difference and potentially a user interface
    bug. In the following screenshot, we can see how, after running a similar test
    with different user interface renderings, we can tell Applitools to ignore certain
    regions in our screens and mark our test as passed:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在报告错误方面，Applitools更进一步。在Percy中，我们发现由于其逐像素比较，用户界面的任何更改都被检测为视觉差异，可能是用户界面错误。在下面的屏幕截图中，我们可以看到，在使用不同用户界面渲染运行类似测试后，我们可以告诉Applitools忽略屏幕中的某些区域，并将我们的测试标记为通过：
- en: '![Figure 12.7 – Applitools ignore region options'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7 – Applitools忽略区域选项'
- en: '](image/Figure_12.7_B15616.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.7_B15616.jpg)'
- en: Figure 12.7 – Applitools ignore region options
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – Applitools忽略区域选项
- en: Here, we can see the different options that Applitools provides. Even when different
    regions have different visual elements, it is possible to ignore such regions
    if they are not visual bugs or if they have been generated from dynamic content.
    After ignoring the region with visual differences, we proceeded to mark the screenshot
    as accepted.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到Applitools提供的不同选项。即使不同区域有不同的视觉元素，如果它们不是视觉错误，或者它们是从动态内容生成的，也可以忽略这些区域。在忽略具有视觉差异的区域后，我们继续将屏幕截图标记为已接受。
- en: Important note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember to add your **APPLITOOLS_API_KEY** variable, which was obtained from
    the Applitools dashboard, to your local machine as an environment variable before
    running your tests. This token ensures that the snapshots taken by the Applitools
    Eyes SDK are successfully uploaded to your Applitools dashboard.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住在运行测试之前将**APPLITOOLS_API_KEY**变量添加到本地机器作为环境变量，该变量是从Applitools仪表板获取的。此令牌确保Applitools
    Eyes SDK拍摄的快照成功上传到Applitools仪表板。
- en: 'The following screenshot shows Cypress rerunning the test and now passing it
    locally. It''s doing this because we have instructed the Applitools Eyes SDK to
    accept the visual changes present compared to our baseline snapshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了Cypress重新运行测试并在本地通过测试。这是因为我们已指示Applitools Eyes SDK接受与我们基准快照相比存在的视觉变化：
- en: '![Figure 12.8 – Passing the test after ignoring the test regions in the Applitools
    dashboard'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8 – 在Applitools仪表板中忽略测试区域后通过测试'
- en: '](image/Figure_12.8_B15616.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.8_B15616.jpg)'
- en: Figure 12.8 – Passing the test after ignoring the test regions in the Applitools
    dashboard
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 在Applitools仪表板中忽略测试区域后通过测试
- en: Voila – our test passed! Any changes that are made to the Applitools test dashboard
    are reflected on the local test runs. This is made possible by the API key that
    you must add to your environment variables before running your Applitools visual
    tests. You can read more about Applitools Eyes ([https://applitools.com/tutorials/cypress.html](https://applitools.com/tutorials/cypress.html))
    to learn more about how to use Applitools to test user interfaces on the dynamic
    modern web.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们的测试通过了！对Applitools测试仪表板所做的任何更改都会反映在本地测试运行中。这是通过在运行Applitools视觉测试之前必须添加到环境变量中的API密钥实现的。您可以阅读更多关于Applitools
    Eyes的信息（[https://applitools.com/tutorials/cypress.html](https://applitools.com/tutorials/cypress.html)）以了解如何使用Applitools在动态现代网页上测试用户界面。
- en: Exercise 2
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2
- en: 'In this exercise, we will test our knowledge of the Applitools Eyes SDK tool
    and how we can use it to perform visual testing. This exercise will help us practically
    implement the theoretical section of this chapter, and also find out how to use
    Cypress and Applitools to write visual tests. Perform the following steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将测试我们对Applitools Eyes SDK工具的了解以及如何使用它进行视觉测试。这个练习将帮助我们实际实施本章的理论部分，并找出如何使用Cypress和Applitools编写视觉测试。执行以下步骤：
- en: Using Applitools and Cypress, log into our test application and navigate to
    the dashboard. Then, using `Applitools Eyes SDK` snapshot command, take a snapshot
    of the public transactions page.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Applitools和Cypress，登录到我们的测试应用程序并导航到仪表板。然后，使用`Applitools Eyes SDK`的快照命令，对公共交易页面进行快照。
- en: Add another new transaction by clicking the new transactions button on the application
    and add the transaction details.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击应用程序上的新交易按钮并添加交易详细信息来添加另一个新交易。
- en: Take another snapshot and use Applitools to compare the transactions page differences
    from when the new transaction was created.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次拍摄快照，并使用Applitools比较交易页面的差异，从新交易创建时起。
- en: Ignore the region in the Applitools dashboard where the new transactions are
    created and rerun the test with the ignore region.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 忽略Applitools仪表板中新交易创建的区域，并使用忽略区域重新运行测试。
- en: The solutions to the preceding exercise can be found in the `chapter-12/cypress/integration/applitools/applitools-excercise.spec.js`
    directory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面练习的解决方案可以在`chapter-12/cypress/integration/applitools/applitools-excercise.spec.js`目录中找到。
- en: With that, I believe that you have learned how to use Applitools' automated
    visual testing and that this exercise has helped you harness your skills and knowledge
    of automated visual testing using Cypress. With that, we have come to the end
    of this book and by the power vested in me, I declare you a qualified "bug hunter!"
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我相信您已经学会了如何使用Applitools的自动化视觉测试，并且这个练习已经帮助您掌握了使用Cypress进行自动化视觉测试的技能和知识。通过这样，我们已经到达了本书的结尾，我宣布您是一名合格的“bug猎手”！
- en: Recap – automated visual testing tools
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结-自动化视觉测试工具
- en: In this section, we learned about two automated visual testing tools, Percy
    and Applitools, and how they can be integrated with Cypress tests. We then learned
    the differences between Percy and Applitools and how Percy, using the snapshot
    way of testing, is different from Applitools, which uses AI to analyze visual
    differences in tests. Finally, we learned where we can utilize testing by using
    tools such as Applitools. We did this by understanding how the content on browsers
    has changed with time and how more dynamic websites are demanding tools that can
    "adapt" to the dynamic content on the modern web.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了两种自动化视觉测试工具，Percy和Applitools，以及它们如何与Cypress测试集成。然后，我们了解了Percy和Applitools之间的区别，以及Percy使用快照测试方式与Applitools使用AI分析测试中的视觉差异的不同之处。最后，我们了解了我们可以如何利用诸如Applitools之类的工具进行测试。我们通过了解浏览器上的内容随时间变化以及更多动态网站需要能够“适应”现代网页上动态内容的工具来实现这一点。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we set out to understand how to do visual testing and its importance,
    as well as the viewports and tools we can use to carry out automated visual testing.
    Throughout this chapter, we've learned how to properly carry out visual testing.
    This involved understanding how to create viewports, how to test on different
    viewports, and also why we need automated visual tests to run on multiple viewports.
    We then explored two testing tools, Percy and the Applitools Eyes SDK, and extensively
    covered their use cases, their setup processes, and how to write Cypress tests
    using them. Finally, we worked on some exercises to improve our familiarity and
    interaction with these tools.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们着手了解如何进行视觉测试及其重要性，以及我们可以使用的视口和工具来进行自动化视觉测试。在本章中，我们学习了如何正确进行视觉测试。这涉及理解如何创建视口，如何在不同的视口上进行测试，以及为什么我们需要在多个视口上运行自动化视觉测试。然后，我们探讨了两种测试工具，Percy和Applitools
    Eyes SDK，并广泛涵盖了它们的用例、设置过程以及如何使用它们编写Cypress测试。最后，我们进行了一些练习，以提高我们对这些工具的熟悉度和互动性。
- en: With that, we have come to the end of this book. If you have been consistently
    reading all the chapters in this book, I am confident that you have more Cypress
    knowledge than you started out with. I hope that this book has challenged the
    way you think, made you develop a love for Cypress as a testing tool, and also
    changed you in terms of becoming a better tester or developer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经到达了本书的结尾。如果您一直在阅读本书的所有章节，我相信您现在对Cypress的了解比起开始时更加深入。我希望这本书挑战了您的思维方式，让您对Cypress作为测试工具产生了热爱，并且在成为更好的测试人员或开发人员方面也有所改变。
