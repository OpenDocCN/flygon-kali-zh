- en: Other Peoples' Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他人的代码
- en: Humans, being complex and fickle, create complex and fickle things. However,
    dealing with other people and their code is an unavoidable part of being a programmer.
    Whether we deal with libraries and frameworks constructed by someone else or inherit
    entire legacy code bases, the challenges are similar. The first step should always
    be to seek an understanding of the code and its paradigms. When we have a full
    understanding of the code, we can begin to interface with it in a clean way, enabling
    us to create new functionality or make improvements on top of existing work. In
    this chapter, we'll be exploring this topic in more detail and, through the lens
    of clean code, considering how we can individually take actions to make other
    people's code less of a pain to deal with.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 人类是复杂而善变的，创造出复杂而善变的东西。然而，处理其他人和他们的代码是作为程序员不可避免的一部分。无论是处理他人构建的库和框架，还是继承整个遗留代码库，挑战都是相似的。第一步应该始终是寻求对代码及其范例的理解。当我们完全理解代码时，我们可以开始以清晰的方式与之交互，使我们能够在现有工作的基础上创建新功能或进行改进。在本章中，我们将更详细地探讨这个主题，并通过清晰的代码视角考虑我们可以采取的行动，使其他人的代码处理起来不那么痛苦。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Inheriting code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承代码
- en: Dealing with third-party code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理第三方代码
- en: Inheriting code
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承代码
- en: When we join a new team or take on a new project, we are usually inheriting
    a large amount of code. Our ability to be productive in these inherited code bases
    is dependent on our understanding of them. So, before we even seek to make the
    first change, we need to build in our minds a conceptual model of how things work.
    It's not necessary for it to be exhaustive and complete, but it must enable us,
    at a very minimum, to make a change and understand exactly what effect that change
    may have on all the moving parts of the code base.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加入一个新团队或接手一个新项目时，通常会继承大量代码。我们在这些继承的代码库中的生产力取决于我们对它们的理解。因此，在我们寻求进行第一次更改之前，我们需要在脑海中建立一个关于事物如何运作的概念模型。它不需要是详尽和完整的，但它必须使我们至少能够进行更改并准确理解这些更改可能对代码库的所有组成部分产生的影响。
- en: Exploring and understanding
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索和理解
- en: Understanding a code base fully is not strictly necessary to make use of it
    nor to make changes to it, but if we don't have a sufficient understanding of
    the complexity of all its interrelated parts, then we can fall into a trap. The
    trap occurs when we, believing we have a good understanding, start making changes.
    Without understanding the full effects of our actions, we can end up wasting time,
    implementing things poorly, and producing accidental bugs. Therefore, it is vital
    that we become properly informed. To do this, we must first gauge how complete
    or incomplete our *view* is of the complexity of the system or code base.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完全理解代码基础并不是必须的，也不是必须的，但如果我们对所有相互关联部分的复杂性没有足够的理解，那么我们就会陷入陷阱。当我们相信自己已经很好地理解时，开始进行更改时，陷阱就会出现。如果不理解我们行为的全部影响，我们最终会浪费时间，实现不完善的东西，并产生意外的错误。因此，我们必须充分了解情况。为了做到这一点，我们必须首先评估我们对系统或代码基础复杂性的*视图*是完整还是不完整。
- en: '![](assets/54e09dd6-a47a-400a-ae30-b5ec6e93ba46.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/54e09dd6-a47a-400a-ae30-b5ec6e93ba46.png)'
- en: 'Often the things we cannot see are completely unknown to us, and we are therefore
    unaware that we lack any understanding at all. This is encapsulated by the common
    expression *we don''t know what we don''t know*. It''s therefore helpful, when
    exploring a new code base, to proactively and enthusiastically push to discover
    and highlight our areas of ignorance. We can do this by following a three-step
    process:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们看不见的事情对我们来说是完全未知的，因此我们不知道自己根本没有任何理解。这就是常见表达式*我们不知道自己不知道什么*所概括的。因此，在探索新的代码库时，积极主动地努力去发现和突出我们的无知领域是有帮助的。我们可以通过以下三个步骤来做到这一点：
- en: '**Gather available information**: Talk to informed colleagues, read documentation,
    use the software, internalize the conceptual structures and hierarchies, and read
    the source code.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收集可用信息**：与知情的同事交谈，阅读文档，使用软件，内化概念结构和层次结构，阅读源代码。'
- en: '**Make informed assumptions**: Fill the gaps of what you aren''t sure about
    with informed assumptions. If you''re told that the app has a registration page,
    you can intuitively assume that this means user registration involves typical
    personal data fields such as name, email, password, and so on.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**做出知情的假设**：用知情的假设填补你不确定的地方。如果有人告诉你应用程序有注册页面，你可以直观地假设这意味着用户注册涉及典型的个人数据字段，如姓名、电子邮件、密码等。'
- en: '**Prove or disprove assumptions**: Seek to prove or disprove your assumptions
    by inquiring the system directly (for example, writing and executing tests), or
    asking someone who is informed (for example, a colleague who has experience of
    the code base).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证明或否定假设**：寻求通过直接查询系统（例如编写和执行测试）或询问有经验的人（例如对代码库有经验的同事）来证明或否定你的假设。'
- en: There are a few specific approaches that are worth employing when it comes to
    creating and expanding an understanding of a new code base. These include making
    a flowchart, internalizing the timeline of changes, stepping through the code
    with a debugger, and confirming your assumptions via tests. We'll explore each
    of these individually.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建和扩展对新代码库的理解时，有一些特定的方法值得采用。这些方法包括制作流程图，内化变更的时间线，使用调试器逐步执行代码，并通过测试确认你的假设。我们将逐个探讨这些方法。
- en: Making a flowchart
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作流程图
- en: 'One useful method we can employ almost immediately when encountering a new
    code base is to populate a mind map or flowchart that highlights not only the
    things we know but the things we aren''t yet sure about. Here''s a simplified
    example of such a diagram for a piece of medical software I once worked on:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到一个新的代码库时，我们几乎可以立即采用的一个有用的方法是填充一个心智图或流程图，突出显示我们知道的事情以及我们尚不确定的事情。以下是我曾经在一款医疗软件上使用的这种图表的简化示例：
- en: '![](assets/d8683dc7-070c-4423-8444-2af714c11deb.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d8683dc7-070c-4423-8444-2af714c11deb.png)'
- en: As you can see, I have tried to outline my *current* understanding of the user
    flow and have also added questions or areas of confusion I am personally experiencing
    in the *cloud* annotations. Over time, as my understanding grows, I can add to
    this flowchart.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我已经尝试概述了我对用户流程的*当前*理解，并在*云*注释中添加了我个人在其中遇到的困惑或问题。随着我的理解的增长，我可以补充这个流程图。
- en: People learn in a huge variety of ways. This visual aid may be more useful for
    some people but less for others. There are also countless ways of composing such
    flowcharts. For the goal of personal understanding, it is best to *use whatever
    works for you*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 人们以各种方式学习。这种视觉辅助可能对某些人更有用，但对其他人可能不那么有用。还有无数种组成这样的流程图的方式。为了达到个人理解的目的，最好*使用任何对你有效的方法*。
- en: Finding structure and observing history
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找结构和观察历史
- en: 'Imagine you''re faced with a large JavaScript application code base that includes
    several specialized types of *views* or *components*. We''ve been tasked with
    adding a new drop-down to one of the payment forms within the application. We
    do a quick search through the code base and identify a number of different dropdown-related
    components:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你面对一个包含几种专门类型的*视图*或*组件*的大型JavaScript应用程序代码库。我们的任务是在应用程序中的一个付款表单中添加一个新的下拉菜单。我们快速搜索代码库，并确定了许多不同的下拉菜单相关组件：
- en: '`GenericDropdownComponent`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GenericDropdownComponent`'
- en: '`DropdownDataWidget`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DropdownDataWidget`'
- en: '`EnhancedDropdownDataWidget`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnhancedDropdownDataWidget`'
- en: '`TextDropdown`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextDropdown`'
- en: '`ImageDropdown`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageDropdown`'
- en: They're confusingly named and so we'd like to get a better understanding of
    them before making changes or utilizing them. To do this, we can just open the
    source code of each component to establish how it may relate to the others (or
    how it does not relate).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的命名令人困惑，因此在进行更改或使用它们之前，我们希望更好地了解它们。为了做到这一点，我们可以打开每个组件的源代码，以确定它可能与其他组件有何关联（或者没有关联）。
- en: 'We end up discovering that `TextDropdown` and `ImageDropdown`, for example,
    both appear to inherit from `GenericDropdownComponent`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最终我们发现，例如`TextDropdown`和`ImageDropdown`都似乎继承自`GenericDropdownComponent`：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We also observe that both `DropdownDataWidget` and `EnhancedDropdownDataWidget`
    are sub-classes of `TextDropdown`. The naming of the *enhanced* drop-down widget
    might confuse us, and it may be something that we seek to change in the near future,
    but, for now, we'll need to hold our breath and just work on doing the work we've
    been tasked with.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还观察到`DropdownDataWidget`和`EnhancedDropdownDataWidget`都是`TextDropdown`的子类。*增强*下拉小部件的命名可能会让我们困惑，这可能是我们在不久的将来想要更改的内容，但是，目前，我们需要屏住呼吸，只需专注于完成我们被分配的工作。
- en: Avoid getting side tracked when you're completing a task within a legacy or
    unfamiliar code base. Many things may appear odd or wrong, but your task must
    remain the most important thing. Early on, it is unlikely that you have the level
    of exposure to the code base that would be necessary to make informed changes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成遗留或不熟悉的代码库中的任务时，避免走神。许多事情可能看起来奇怪或错误，但你的任务必须始终是最重要的事情。在早期，你可能没有足够的接触代码库的经验来做出明智的更改。
- en: 'By stepping through each dropdown-related source file, we can build up a solid
    understanding of them without having to make any changes. If the code base employs
    source control, then we can also *blame* each file to discover who originally
    authored it and when. This can inform us how things have changed over time. In
    our case, we discover the following timeline of changes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐个查看每个与下拉菜单相关的源文件，我们可以在不进行任何更改的情况下建立对它们的深入理解。如果代码库使用源代码控制，那么我们还可以*责备*每个文件，以发现最初是谁编写的以及何时编写的。这可以告诉我们事物是如何随时间变化的。在我们的情况下，我们发现了以下变更时间线：
- en: '![](assets/9c313041-fba8-4a0d-910b-2653a05fadaf.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9c313041-fba8-4a0d-910b-2653a05fadaf.png)'
- en: This is incredibly helpful to us. We can see how, originally, there was only
    one class (named `DropdownComponent`), which later got changed to `GenericDropdownComponent`
    with two sub-classes, `TextDropdownComponent` and `ImageDropdownComponent`. Each
    of these got renamed to `TextDropdown` and `ImageDropdown`. Over time, these various
    changes illuminate the *why* of how things are at the present time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们非常有帮助。最初只有一个类（名为`DropdownComponent`），后来改为`GenericDropdownComponent`，有两个子类`TextDropdownComponent`和`ImageDropdownComponent`。每个都改名为`TextDropdown`和`ImageDropdown`。随着时间的推移，这些各种变化阐明了现在事物的原因。
- en: When looking at a code base, we often make an implicit assumption that it was
    created *all at once* and with complete foresight; however, as our timeline illustrates,
    the truth is far more complex. Code bases change over time in reaction to new
    needs. The set of people who work on a code base also changes, and each individual
    will inevitably have their own way of solving problems. Our acceptance of the
    slowly evolving nature of every code base will help us to come to terms with its
    imperfections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看代码库时，我们经常会假设它是一次性创建的，并且有完整的远见；然而，正如我们的时间线所示，事实要复杂得多。代码库随着时间的推移而变化，以应对新的需求。参与代码库工作的人员也在变化，每个人都不可避免地有自己解决问题的方式。我们接受每个代码库缓慢演变的本质，将有助于我们接受它的不完美之处。
- en: Stepping through the code
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐步查看代码
- en: 'When building an understanding of a singular piece of code within a large application,
    we can use tooling to debug and study how it functions. In JavaScript, we can
    simply place a `debugger;` statement, and then execute the part of the application
    that we know activates that particular code. We can then step through the code,
    line by line, to answer the following questions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型应用程序中建立对单个代码片段的理解时，我们可以使用工具来调试和研究其功能。在JavaScript中，我们可以简单地放置一个`debugger;`语句，然后执行我们知道会激活特定代码的应用程序部分。然后，我们可以逐行查看代码，以回答以下问题：
- en: '**Where is this code called****?** A clear expectation of how an abstraction
    is activated can help us to build up a model of the *flow* or *order* of the application
    in our head, enabling us to make more accurate judgements about how to fix or
    change certain things.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这段代码被调用在哪里？**对于一个抽象如何被激活的明确期望可以帮助我们在脑海中建立应用程序的*流*或*顺序*的模型，使我们能够更准确地判断如何修复或更改某些东西。'
- en: '**What is passed to this code?** An example of what input an abstraction receives
    can help us to build up a clear concept about what it does, and how it expects
    to be interfaced with. This can directly guide our usage of the abstraction.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这段代码接收了什么？**抽象接收的输入示例可以帮助我们建立一个清晰的概念，了解它的功能，以及它期望如何被接口化。这可以直接指导我们使用这个抽象。'
- en: '**What is outputted by this code?** Seeing the output of an abstraction, partnered
    with its input, can give us a really solid idea of what it does, computationally,
    and can help us to discern how we may wish to go about using it.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这段代码输出了什么？**观察一个抽象的输出，以及它的输入，可以让我们对它的计算方式有一个非常明确的概念，并且可以帮助我们判断我们可能希望如何使用它。'
- en: '**What levels of misdirection or complexity exist here?** Observing complex
    and tall stack traces (meaning that, *functions that are called by functions that
    are called by functions, ad infinitum...*) can indicate that we may have difficulty
    in navigating and understanding the flow of control and information within a certain
    area. This would tell us that we may need to augment our understanding with additional
    documentation or communication with informed colleagues.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这里存在什么级别的误导或复杂性？**观察复杂和高的堆栈跟踪（意味着*被函数调用的函数被函数调用，无限循环...*）可以表明我们在某个区域内导航和理解控制和信息流的困难。这将告诉我们，我们可能需要通过额外的文档或与知情的同事沟通来增加我们的理解。'
- en: 'Here is an example of doing so in a browser environment (using Chrome Inspector):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在浏览器环境中这样做的一个例子（使用Chrome Inspector）：
- en: '![](assets/27b23d2e-e4c0-4dd3-a74c-11c43c095c7c.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/27b23d2e-e4c0-4dd3-a74c-11c43c095c7c.png)'
- en: You can use Chrome's debugger even if you're implementing server-side JavaScript
    in Node.js. To do this, use the `--inspect` flag when executing your JavaScript, for
    example, `node --inspect index.js`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在Node.js中实现服务器端JavaScript，您也可以使用Chrome的调试器。要做到这一点，在执行JavaScript时使用`--inspect`标志，例如，`node
    --inspect index.js`。
- en: Using a debugger like this can present us with a *call stack* or *stack trace*,
    informing us of what path was taken through the code base to get to our `debugger;`
    statement. If we are trying to understand how an unfamiliar class or module fits
    into the larger picture of a code base, this can be very helpful.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用调试器可以为我们呈现*调用堆栈*或*堆栈跟踪*，告诉我们通过代码库采取了哪条路径到达我们的`debugger;`语句。如果我们试图了解陌生类或模块如何适应代码库的整体情况，这将非常有帮助。
- en: Asserting your assumptions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证您的假设
- en: 'One of the best ways to expand our knowledge of unfamiliar code is to write
    tests to confirm that the code behaves in the way we believe it does. Imagine
    we are given this piece of obscure code to maintain:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展我们对陌生代码的了解的最佳方法之一是编写测试来确认代码的行为方式。想象一下，我们被要求维护这段晦涩的代码：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code is only used in a couple of places, but the various inputs are dynamically
    generated in a difficult-to-debug area of the application. Additionally, there
    is no documentation and absolutely no tests. It is quite unclear exactly what
    this code does, but, as we study the code line by line, we can begin to make some
    basic assumptions and encode these assumptions as assertions. For example, we
    can plainly see that the `makeExtractor` static function itself returns a function.
    We can specify this truth as a test:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只在几个地方使用，但各种输入是在应用程序的难以调试的区域动态生成的。此外，没有文档，绝对没有测试。这段代码到底做了什么还不太清楚，但是，当我们逐行研究代码时，我们可以开始做一些基本的假设，并将这些假设编码为断言。例如，我们可以清楚地看到`makeExtractor`静态函数本身返回一个函数。我们可以将这个事实规定为一个测试：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also see some type of regular expression replacement occurring; it seemingly
    looks for patterns where the letter `o` is followed by a string of digits (`\bo(\d+?)\b`).
    We can begin to explore this extraction functionality by writing a simple assertion
    in which we give the extractor a string matching that pattern:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到某种正则表达式替换发生；它似乎在寻找字母`o`后面跟着一串数字的模式（`\bo(\d+?)\b`）。我们可以通过编写一个简单的断言来开始探索这个提取功能，其中我们给提取器一个匹配该模式的字符串：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can add additional assertions as we slowly discover what the code does.
    We may never arrive at 100% understanding, but this is OK. Here, we''re asserting
    the fact that the extractor is able to correctly extract multiple OOIDs present
    within a single string:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们慢慢发现代码的功能，我们可以添加额外的断言。我们可能永远无法达到100%的理解，但这没关系。在这里，我们断言提取器能够正确提取单个字符串中存在的多个OOID：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When running these tests, we observe the following successful results:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些测试时，我们观察到以下成功的结果：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note how we're still not entirely sure what the original code does. We have
    only scraped the surface, but in doing so, we are building a valuable foundation
    of understanding that will make it far easier for us to interface with or change
    this code in the future. With each new successful assertion, we get closer to
    a complete and accurate understanding of what the code does. And if we commit
    these assertions as a new test, then we are also improving the test coverage of
    the code base and providing assistance for future colleagues who may have been
    similarly confused by the code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们仍然不完全确定原始代码的作用。我们只是触及了表面，但这样做，我们正在建立一个有价值的理解基础，这将使我们将来更容易地与这段代码进行交互或更改。随着每个新的成功断言，我们离完整和准确地理解代码的目标更近。如果我们将这些断言作为新的测试提交，那么我们也正在提高代码库的测试覆盖率，并为将来可能同样被这段代码困惑的同事提供帮助。
- en: Now that we have a solid grasp of how to explore and understand an inherited
    piece of code, we can now look into how we might *make changes* to that code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经牢固掌握了如何探索和理解继承的代码，我们现在可以研究如何对该代码进行*更改*。
- en: Making changes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行更改
- en: 'Once we have a good level of understanding about an area of a code base, we
    can begin to make changes. Even at this stage, however, we should be cautious.
    We are still relatively new to the code base and the system it relates to and
    so we''re probably still unaware of many of its parts. Any change could potentially
    create unforeseen effects. To move forward we must, therefore, go slowly and considerately,
    ensuring our code is well designed and well-tested. There are two specific methodologies
    we should be aware of here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对代码库的某个区域有了很好的理解水平，我们就可以开始进行更改。然而，即使在这个阶段，我们也应该谨慎。我们对代码库和相关系统仍然相对较新，所以我们可能仍然不了解其中许多部分。任何更改都可能造成意想不到的影响。因此，为了继续前进，我们必须慢慢和谨慎地进行，确保我们的代码设计良好并经过充分测试。在这里，我们应该注意两种具体的方法：
- en: The delicate *surgical* process of making isolated changes in an unfamiliar
    setting
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在陌生环境中进行孤立更改的精细*手术*过程
- en: The confirmation of changes via tests
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过测试确认更改
- en: Let's explore these, one by one.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一探讨这些。
- en: Minimally invasive surgery
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小侵入手术
- en: When changes are needed in an area of the code base that is old or unfamiliar,
    it can be useful to imagine that you are performing a kind of *minimally invasive
    surgery*. The aim in doing this is to maximize the positive effect of a change
    while minimizing the footprint of the change itself, ensuring not to damage or
    have too much impact on other parts of the code base. The hope with doing this
    is that we will be able to produce the necessary changes (*upsides*) without exposing
    ourselves too much to the possibility of breakages or bugs (*downsides*). This
    is also useful when we aren't sure whether the change is entirely necessary, so
    we want to only expend minimal effort on it initially.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要在旧的或陌生的代码库中进行更改时，可以想象自己在进行一种*最小侵入手术*。这样做的目的是最大化更改的积极影响，同时最小化更改本身的影响范围，确保不会对代码库的其他部分造成损害或影响过大。这样做的希望是，我们将能够产生必要的更改（*优势*），而不会过多地暴露自己于破坏或错误的可能性（*劣势*）。当我们不确定更改是否完全必要时，这也是有用的，因此我们最初只想在其上花费最少的精力。
- en: 'Let''s imagine that we have inherited a `GalleryImage` component that is responsible
    for rendering singular images. There are many places in our web application where
    it is used. The task is to add the ability for videos to be rendered when the
    URL of the asset indicates that it is a video. The two types of CDN URLs are as
    follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们继承了一个负责呈现单个图像的`GalleryImage`组件。在我们的Web应用程序中有许多地方使用它。任务是在资产的URL指示其为视频时，添加呈现视频的能力。两种CDN
    URL的类型如下：
- en: '`https://cdn.example.org/VIDEO/{ID}`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://cdn.example.org/VIDEO/{ID}`'
- en: '`https://cdn.example.org/IMAGE/{ID}`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://cdn.example.org/IMAGE/{ID}`'
- en: As you can see, there is a clear difference between image and video URLs. This
    gives us an easy way of differentiating how we render these pieces of media on
    the page. Ideally, it is reasonable to say that we should implement a new component
    named `GalleryVideo` to handle this new type of media. A new component like this
    would be able to cater uniquely to the *problem domain* of a video, which is notably
    different from that of an image. At the very least, a video must be rendered via
    a `<VIDEO>` element, while an image must be rendered via `<IMG>`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，图像和视频URL之间存在明显的区别。这为我们提供了一种在页面上呈现这些媒体的简单方法。理想情况下，我们应该实现一个名为`GalleryVideo`的新组件来处理这种新类型的媒体。这样的新组件将能够独特地满足视频的*问题域*，这显然与图像的问题域不同。至少，视频必须通过`<VIDEO>`元素呈现，而图像必须通过`<IMG>`呈现。
- en: We discover that many of the situations where `GalleryImage` is used are not
    well tested and some rely on obscure internal implementation details that would
    be difficult to discern in bulk (for example, it would be hard to do a find and
    replace if we wanted to change all `GalleryImage` usages).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现`GalleryImage`的许多用法都没有经过充分测试，有些依赖于隐晦的内部实现细节，这些细节如果要大规模辨别将会很困难（例如，如果我们想要更改所有`GalleryImage`的用法，进行查找和替换将会很困难）。
- en: 'Our available options are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可用选项如下：
- en: 'Create a *container* `GalleryAsset` component that itself makes a decision
    about whether to render a `GalleryImage` or `GalleryVideo` based on the CDN URL.
    This would involve having to replace every current usage of `GalleryImage`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个*容器*`GalleryAsset`组件，它本身根据CDN URL决定是否呈现`GalleryImage`或`GalleryVideo`。这将涉及替换每个当前使用`GalleryImage`的情况：
- en: 'Time estimate: **1-2 weeks**'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间估计：**1-2周**
- en: 'Footprint across the code base: **Significant**'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码库中的影响：**显著**
- en: 'Possibility of unforeseen breakages: **Significant**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能出现意想不到的破坏：**显著**
- en: 'Architectural *cleanliness*: **High**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构*清洁度*：**高**
- en: 'Add a condition within `GalleryImage` that optionally renders a `<video>` instead
    of an `<img>` tag based on the  CDN URL:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GalleryImage`中添加一个条件，根据CDN URL可选择呈现`<video>`而不是`<img>`标签：
- en: Time estimate: **1-2 days**
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间估计：**1-2天**
- en: 'Footprint across the code base: **Minimal**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码库中的影响：**最小**
- en: 'Possibility of unforeseen breakages: **Minimal**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能出现意想不到的破坏：**最小**
- en: 'Architectural *cleanliness*: **Medium**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构*清洁度*：**中等**
- en: In ideal circumstances, if we consider the long-term architecture of the code
    base, it is clear that the first option of creating a new `GalleryAsset` component
    is the best one. It gives us a clearly defined abstraction that intuitively caters
    to the two cases of images and videos and also provides us with the possibility
    of adding different asset types in the future (for example, *audio*). It will,
    however, take longer to implement, and carries quite a significant amount of risk.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，如果考虑代码库的长期架构，很明显创建一个新的`GalleryAsset`组件是最好的选择。它为我们提供了一个清晰定义的抽象，直观地满足了图片和视频的两种情况，并为我们提供了在将来添加不同资产类型（例如*音频*）的可能性。然而，它需要更长的时间来实现，并且带有相当大的风险。
- en: 'The second option is far simpler to implement. In fact, it may only involve
    the following four-line change set:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项要简单得多。实际上，它可能只涉及以下四行更改集：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is not necessarily a good long-term choice, but it gives us something we
    can immediately ship to users, fulfilling their needs and the needs of our stakeholders.
    Once shipped, we can then plan future time to complete the larger necessary change.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这不一定是一个好的长期选择，但它给了我们一些可以立即交付给用户的东西，满足他们的需求和我们利益相关者的需求。一旦交付，我们可以计划未来的时间来完成更大的必要更改。
- en: To reiterate, the value of a *minimally invasive* change like this is that it
    reduces the immediate downsides (*risks*) to the code base in terms of implementation
    time and potential breakages. Obviously it is vital to ensure that we are balancing
    short-term gains with long-term. Often, stakeholders will pressure programmers
    to implement a change quickly, but if there is no *technical* *dept* or reconciliation
    process, then all of these *minimally invasive *changes can gather into quite
    a terrifying beast.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一下，*最小侵入性*更改的价值在于它减少了代码库在实施时间和潜在破坏方面的立即不利因素（*风险*）。显然，确保我们在短期利益和长期利益之间取得平衡是至关重要的。利益相关者通常会向程序员施加压力，要求他们快速实施更改，但如果没有*技术*
    *债务*或协调过程，那么所有这些*最小侵入性*的更改可能会积聚成一个相当可怕的怪物。
- en: To ensure that the code we change is not too delicate or liable to future regressions,
    it is wise to write tests alongside them, encoding our expectations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们更改的代码不太脆弱或容易出现未来的回归，最好是在更改的同时编写测试，编码我们的期望。
- en: Encoding changes as tests
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将更改编码为测试
- en: We've already explored how we can write tests to discover and specify current
    functionality, and, in previous chapters, we discussed the obvious benefits of
    following a **Test-Driven-Development** (**TDD**) approach. It follows that we
    should, when operating in an unfamiliar code base, always confirm our changes
    via cleanly written tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何编写测试来发现和指定当前功能，而且在之前的章节中，我们讨论了遵循**测试驱动开发**（**TDD**）方法的明显好处。因此，当在一个陌生的代码库中操作时，我们应该始终通过清晰编写的测试来确认我们的更改。
- en: Writing tests alongside your changes is definitely a need when there are no
    existing tests. Writing the first test in an area of code can be burdensome in
    terms of setting up libraries and necessary mocks, but it is absolutely worth
    it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有现有测试的情况下，与您的更改一起编写测试绝对是必要的。在代码区域编写第一个测试可能会很繁重，因为需要设置库和必要的模拟，但这绝对是值得的。
- en: 'In our previous example of introducing the capability of rendering videos to
    `GalleryImage`, it would be wise to add a simple test to confirm that `<VIDEO>`
    is correctly rendered when the URL contains the `"/VIDEO/"` substring. This prevents
    the possibility of future regressions and gives us a strong level of confidence
    that it works as expected:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前介绍的向`GalleryImage`引入渲染视频功能的示例中，明智的做法是添加一个简单的测试来确认当URL包含`"/VIDEO/"`子字符串时，`<VIDEO>`被正确渲染。这可以防止未来的回归，并给我们带来了强大的信心，表明它按预期工作：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a rather simple test; however, it completely encodes the expectations
    we have after making our changes. When making small and self-contained changes
    or larger systemic changes, it's so incredibly valuable to verify and communicate
    our intent via tests like these. As well as preventing regressions, they aid our
    colleagues in terms of immediate code review, and the entire team in terms of
    documentation and general reliability. As such, it's quite normal and preferable
    to have a team mandate or policy that says *you cannot commit a change if it does
    not come with a test*. Enforcing this will, over time, create a code base that
    produces more reliable functionality for users and is more pleasant to work with
    for fellow programmers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的测试；然而，它完全编码了我们在进行更改后的期望。在进行小型和自包含的更改或更大的系统性更改时，通过这样的测试验证和传达我们的意图是非常有价值的。除了防止回归，它们还在立即的代码审查方面帮助我们的同事，以及在文档和整体可靠性方面帮助整个团队。因此，拥有一个团队强制执行或政策，即*如果没有测试，就不能提交更改*是相当正常和可取的。长期执行这一政策将使代码库产生更可靠的功能，对用户更加友好，对其他程序员更加愉快。
- en: We've now completed the section on *Inheriting code*, and so you should have
    a good foundational knowledge of how to deal with such a situation. Another challenge
    in dealing with *other people's code* is the selection and integration of third-party
    code, meaning libraries and frameworks. We'll explore this now.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了关于*继承代码*的部分，所以你应该对如何处理这种情况有了良好的基础知识。在处理*其他人的代码*时，另一个挑战是选择和集成第三方代码，即库和框架。我们现在将探讨这个问题。
- en: Dealing with third-party code
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理第三方代码
- en: The landscape of JavaScript is filled with a myriad of frameworks and libraries
    that can ease the burden of implementing all types of functionality. In [Chapter
    12](5df59321-fd46-4504-93ed-5e8555b33b01.xhtml), *Real-World Challenges,* we had
    a look at the difficulties involved in including external dependencies in our
    JavaScript projects. The modern JavaScript ecosystem provides a rich variety of
    solutions here, and so dealing with third-party code is far less burdensome than
    it was before. Nonetheless, the nature of having to interface with this code hasn't
    really changed. We must still hope that our selected third-party library or framework
    provides an interface that is intuitive and well-documented, and functionality
    that fulfills our requirements.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的领域充斥着各种框架和库，可以减轻实现各种功能的负担。在[第12章](5df59321-fd46-4504-93ed-5e8555b33b01.xhtml)中，*真实挑战*，我们看到了在JavaScript项目中包含外部依赖项所涉及的困难。现代JavaScript生态系统在这里提供了丰富的解决方案，因此处理第三方代码的负担要比以前少得多。尽管如此，与这些代码进行接口的本质并没有真正改变。我们仍然必须希望我们选择的第三方库或框架提供直观和良好文档的接口，以及满足我们需求的功能。
- en: When dealing with third-party code, there are two crucial processes that will
    define the ongoing risks or benefits we receive. The first is the *selection*
    process, where we make a choice as to which library to use, and the second is
    our integration and adaptation of the library into our code base. We'll now go
    over both of these in detail.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理第三方代码时，有两个关键的过程将决定我们所获得的持续风险或收益。第一个是*选择*过程，我们在这个过程中选择要使用的库，第二个是我们将库集成和适应到我们的代码库中。现在我们将详细讨论这两点。
- en: Selection and understanding
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择和理解
- en: 'Picking a library or framework can be a risky decision. Pick the wrong one
    and it can end up driving much of the architecture of your system. Frameworks
    are especially notorious for this because, by their nature, they dictate the structure
    and conceptual underpinning of your architecture. Picking the wrong one and then
    seeking to change it can be a considerable effort; one that involves changes to
    almost every single piece of code within an application. As such, it is vital
    to practice the skill of careful consideration and selection of third-party code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个库或框架可能是一个冒险的决定。选择错误的库可能最终会驱动系统的大部分架构。框架尤其以此闻名，因为它们的本质决定了架构的结构和概念基础。选择错误的库然后试图更改它可能是一个相当大的工作量；这需要对应用程序中几乎每一行代码的更改。因此，认真考虑和选择第三方代码的技能至关重要：
- en: '![](assets/85b09dc5-0500-4a1d-90d6-4b9c8a36e280.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85b09dc5-0500-4a1d-90d6-4b9c8a36e280.png)'
- en: 'There are a number of useful considerations we can make in order to help us
    in the process of selection:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择过程中，我们可以考虑一些有用的考虑因素：
- en: '**Functionality**: The library or framework must fulfill a set of fixed functional
    expectations. It''s important to specify these in a sufficiently detailed way
    so that different options can be quantifiably compared.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能性**：库或框架必须满足一组固定的功能期望。重要的是以足够详细的方式指定这些功能，以便可以量化比较不同的选项。'
- en: '**Compatibility**: The library or framework must be mostly compatible with
    the way the code base currently works, and must be able to integrate in a way
    that it is technically simple and easy to understand for colleagues.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容性：库或框架必须与当前代码库的工作方式大部分兼容，并且必须能够以技术简单易懂的方式集成，以便同事们能够理解。
- en: '**Usability**: The library or framework must be easily usable and understandable.
    It should have good documentation and a level of intuitiveness that allows immediate
    productivity without pain or confusion. The consideration of what occurs when
    you have a problem or question related to usage is also under the umbrella of
    usability.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：库或框架必须易于使用和理解。它应该有良好的文档和一定程度的直观性，可以在没有痛苦或困惑的情况下立即提高生产力。对于使用相关问题或疑问的考虑也属于可用性范畴。'
- en: '**Maintenance and security**: The library or framework should be maintained
    and have a clear and trusted process for reporting and resolving bugs, especially
    those that may have security ramifications. The changelogs should be exhaustive.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护和安全性**：库或框架应该得到维护，并且有一个清晰可信的流程来报告和解决错误，特别是那些可能具有安全影响的错误。变更日志应该是详尽的。'
- en: The four criteria here can be informed, as well, by heuristics such as *who
    is the project backed by?*, *how many people are making use of the project?*,
    or *am I familiar with the team who built it?*. Be warned though, these are only
    heuristics and so are not perfect ways of measuring the suitability of *third-party
    code*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的四个标准也可以通过启发式来指导，比如*项目由谁支持？*，*有多少人在使用该项目？*，或者*我是否熟悉构建它的团队？*。但请注意，这些只是启发式，因此并不是衡量*第三方代码*适用性的完美方式。
- en: 'Even using these four criteria, however, we may fall into traps. If you''ll
    recall, in [Chapter 3](4aede822-c58b-4e6b-81cd-ba27582e9aa7.xhtml), *The Enemies
    of Clean Code*, we discussed the most notable *Self* (or *ego*) and *The cargo
    cult*. These are also relevant when selecting third-party code. Remember to specifically
    watch out for the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使使用这四个标准，我们可能会陷入陷阱。如果你还记得，在[第3章](4aede822-c58b-4e6b-81cd-ba27582e9aa7.xhtml)中，*清洁代码的敌人*，我们讨论了最显著的*自我*（或*自负*）和*物质崇拜*。在选择第三方代码时，这些也是相关的。请特别注意以下内容：
- en: '**Powerful opinions**: It''s crucial to separate ourselves from the decision
    process as much as possible, and to be very wary of our ignorances and biases.
    Programmers are well known for their opinionated nature. It''s important in these
    moments to step back from ourselves and reason with pure logic about what we believe
    would be best. It''s key to give everyone a voice as well, and to weigh people''s
    opinions and anecdotes according to their own merits, not according to their seniority
    (or other personal characteristics).'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强烈的观点**: 尽可能地与决策过程分开，并非常谨慎地对待我们的无知和偏见。程序员以他们的固执著称。在这些时刻，重要的是要从自己身上退后一步，用纯粹的逻辑来推理出我们认为最好的是什么。给每个人一个发言的机会同样很重要，根据他们自身的价值观和轶事来权衡人们的意见，而不是根据他们的资历（或其他个人特征）。'
- en: '**The popularity cult**: Don''t get too swayed by popularity. It''s easy to
    get drawn into a popular abstraction due to the size and zealotry of its community,
    but once again, it is vital to take a step back and consider the merits of the
    framework in isolation. Naturally, popularity may indicate an ease of integration
    and more abundant learning resources, so in that way, it is reasonable to talk
    about, but just be wary of using popularity as a sole indicator of superiority.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流行文化**: 不要被流行所左右。由于其社区的规模和狂热，很容易被流行的抽象所吸引，但再次，重要的是要退一步，考虑框架本身的优点。当然，流行可能表明易于集成和更丰富的学习资源，所以在这方面，谈论它是合理的，但要小心使用流行作为优越性的唯一指标。'
- en: '**Analysis paralysis**: There are a lot of choices out there, so it is possible
    to end up in a situation where you are seemingly unable to make a choice out of
    fear of making the wrong one. Most of the time, these decisions are reversible,
    so it''s not the end of the world to make a less than optimal choice. It''s easy
    to end up in a situation where a lot of time is being used up deciding which framework
    or library to pick when it would be far more efficient to just pick *anything*
    and then iterate or pivot according to changing needs at a later point.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析瘫痪**: 有很多选择，所以有可能陷入一种似乎无法做出选择的情况，因为害怕做出错误选择。大多数情况下，这些决定是可逆的，所以做出不太理想的选择并不是世界末日。很容易陷入这样一种情况，花费大量时间来决定选择哪个框架或库，而更有效的方法是只是选择*任何东西*，然后根据以后的需求进行迭代或转变。'
- en: The key thing when making decisions about third-party libraries is to fully
    appreciate their eventual effects on the code base. The amount of time we sink
    into making a decision should be proportional to their potential effects. Deciding
    on a client-side framework for component rendering may be a rather impactful choice
    as it may prescribe a significant portion of the code base, whereas, for example,
    a small URL-parsing utility does not have a great impact and can be easily swapped
    out in the future.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在做关于第三方库的决定时，关键是要充分意识到它们对代码库的最终影响。我们花在做决定上的时间应该与它们的潜在影响成比例。决定客户端框架用于组件渲染可能是一个相当重要的选择，因为它可能规定了代码库的一个重要部分，而例如一个小的URL解析实用程序并没有很大的影响，并且可以在将来轻松替换。
- en: Next, we can discuss how we might integrate and encapsulate a piece of third-party
    code, following a well-informed selection process.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以讨论如何集成和封装第三方代码，遵循一个知情的选择过程。
- en: Encapsulating and adapting third-party code
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装和适应第三方代码
- en: The downside of picking a third-party abstraction, especially a framework, is
    that you can end up changing your code base to suit the arbitrary conventions
    and design decisions of the abstraction's authors. Often, we are made to *speak
    the same language* of these third-party interfaces, instead of having them *speak
    our language*. Indeed, in many cases, it may be the abstraction's conventions
    and design that is appealing to us, and so we are more than happy for it to drive
    the design and nature of our code base. But, in other situations, we may want
    to be more protected from our chosen abstractions. We may want the option to easily
    swap them out for other abstractions in the future, or we may already have a set
    of conventions that we prefer to use.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 选择第三方抽象，特别是框架的缺点是，你最终可能会改变你的代码库以适应抽象的作者的任意约定和设计决策。通常情况下，我们被迫*说同样的语言*，而不是让它们*说我们的语言*。确实，在许多情况下，可能是抽象的约定和设计吸引了我们，所以我们更愿意让它驱动我们的代码库的设计和性质。但在其他情况下，我们可能希望更多地受到我们选择的抽象的保护。我们可能希望在将来轻松地将它们替换为其他抽象，或者我们可能已经有一套我们更愿意使用的约定。
- en: In such cases, it may be useful to encapsulate these third-party abstractions
    and deal with them purely through an abstraction layer of our own. Such a layer
    would typically be called an *Adapter:*
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，封装这些第三方抽象并纯粹通过我们自己的抽象层来处理它们可能是有用的。这样的层通常被称为*适配器*：
- en: '![](assets/d6120549-ec8a-4d87-9b7f-600f3e363ec3.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d6120549-ec8a-4d87-9b7f-600f3e363ec3.png)'
- en: 'Very simply, an *Adapter* will provide an interface that we design, and will
    then delegate to the third-party abstraction to accomplish its tasks. Imagine
    if we wished to use a URL-parsing utility called `YOORL`. We''ve decided it works
    perfectly for our needs, and has complete compliance with RFC 3986 (the URI standard).
    The only issue is that its API is rather burdensome and verbose:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单地说，*适配器*将提供一个我们设计的接口，然后委托给第三方抽象来完成其任务。想象一下，如果我们希望使用一个名为`YOORL`的URL解析实用程序。我们已经决定它完全符合我们的需求，并且完全符合RFC
    3986（URI标准）。唯一的问题是它的API相当繁琐和冗长。
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This would return the following *Object*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下*对象*：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We would prefer it if the API was far simpler. The length and complexity of
    the current API, we feel, would expose our code base to needless complexity and
    risk (the risk of calling it the wrong way, for example). Using an *Adapter* would
    allow us to wrap up this non-ideal interface into an interface of our own design:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望API更简单。我们认为当前API的长度和复杂性会使我们的代码库面临不必要的复杂性和风险（例如错误调用）。使用*适配器*可以让我们将这个不理想的接口封装成我们自己设计的接口。
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This means that any modules within our code base can now interface with this
    simplified *Adapter, *insulating them from the unideal API of YOORL:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们代码库中的任何模块现在都可以与这个简化的*适配器*进行接口，使它们与YOORL的不理想API隔离开来。
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adapters can be thought of as *translation mediums*, allowing our code base
    to *speak the language* of its choice, not having to be slowed down by the arbitrary
    and inconsistent design decisions of third-party libraries. This not only aids
    the usability and intuitiveness of the code base but also enables us to very easily
    make changes to the underlying third-party library without having to change many
    lines of code at all.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器可以被视为*翻译媒介*，使我们的代码库能够*使用其选择的语言*，而不必受到第三方库的任意和不一致的设计决策的拖累。这不仅有助于代码库的可用性和直观性，还使我们能够非常轻松地对基础第三方库进行更改，而无需改变太多代码。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have explored the tricky topic of *other people's code*.
    We've considered how we can deal with legacy code that we inherit; how we can
    build our understanding of it, how we can debug and make changes without difficult,
    and how we can confirm our changes with a good testing approach. We've also covered
    the difficulty of dealing with third-party code, including how to select it and
    how to interface with it in a risk-averse way via the *Adapter* pattern. There
    are plenty of other things that we could have spoken about in this chapter, but
    hopefully the topics and principles we have been able to explore have given you
    a sufficient understanding of how to navigate other people's code with an eye
    toward a clean code base.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了*其他人的代码*这个棘手的话题。我们考虑了如何处理我们继承的遗留代码；我们如何建立对它的理解，如何进行调试和进行改变而不困难，以及如何通过良好的测试方法确认我们的改变。我们还涵盖了处理第三方代码的困难，包括如何选择它以及如何通过*适配器*模式以风险规避的方式与其进行接口。在本章中我们还可以谈论许多其他事情，但希望我们能够探讨的主题和原则已经让您充分了解如何以干净的代码库为目标来处理其他人的代码。
- en: In the next chapter, we will cover the topic of communication. It may not appear
    relevant but communication, both within our workplaces and toward our users, is
    an absolutely vital skill for the programmer, and without it there is little possibility
    of clean code. We'll specifically be exploring how to plan and set requirements,
    how to collaborate and communicate with colleagues, and how to drive change within
    our projects and workplaces.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖沟通的主题。这可能看起来不相关，但对于程序员来说，沟通在我们的工作场所内部和向用户之间都是一项绝对重要的技能，没有它，干净的代码几乎不可能存在。我们将具体探讨如何规划和设定要求，如何与同事合作和沟通，以及如何在我们的项目和工作场所内推动变革。
