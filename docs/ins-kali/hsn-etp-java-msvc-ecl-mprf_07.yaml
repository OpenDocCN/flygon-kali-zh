- en: MicroProfile Metrics and OpenTracing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile指标和OpenTracing
- en: 'Once developers have written code and it is put into production, there is a
    need to observe what the code is doing, how well it is performing, and what resources
    it is using. MicroProfile has created two specifications to deal with these concerns:
    Metrics and (integration with) OpenTracing.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开发人员编写了代码并将其投入生产，就需要观察代码的运行情况，性能如何，以及它使用了哪些资源。MicroProfile已经创建了两个规范来处理这些问题：指标和（与）OpenTracing。
- en: 'Starting off with the Metrics section, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从指标部分开始，我们将讨论以下主题：
- en: The rationale behind specifications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范背后的原理
- en: Exposition formats of metrics on an enabled server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启用服务器上的指标的暴露格式
- en: Providing metrics from within your application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从应用程序内部提供指标
- en: Using Prometheus, a cloud-native time series database, to retrieve and analyze
    metric data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Prometheus，一个云原生时间序列数据库，来检索和分析指标数据
- en: 'In the OpenTracing section, we will discuss the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenTracing部分，我们将讨论以下内容：
- en: An introduction to the tracing domain
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪领域的介绍
- en: Configuration properties ...
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置属性...
- en: MicroProfile Metrics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile指标
- en: MicroProfile Metrics exposes the metric data (often called **telemetry**) of
    the running server, for example, CPU and memory usage, and the thread count. This
    data is then often fed into charting systems to visualize metrics over time or
    to serve capacity-planning purposes; of course, they also serve to notify DevOps
    people when the values go outside a predefined threshold range.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile指标公开了运行服务器的指标数据（通常称为**遥测**），例如CPU和内存使用情况，以及线程计数。然后，这些数据通常被馈送到图表系统中，以便随时间可视化指标，或者用于容量规划的目的；当值超出预定义的阈值范围时，它们也用于通知DevOps人员。
- en: The Java Virtual Machine had a way to expose data for a long time via MBeans
    and the MBeanServer. Java SE 6 saw the introduction of an (RMI-based) remote protocol
    for all VMs defining how to access the MBean Server from remote processes. Dealing
    with this protocol is difficult and does not fit in with today's HTTP-based interactions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java虚拟机通过MBeans和MBeanServer长期以来一直有一种暴露数据的方式。Java SE 6引入了一个（基于RMI的）远程协议，用于定义如何从远程进程访问MBean服务器。处理这个协议很困难，不符合今天基于HTTP的交互方式。
- en: The other pain point is that many globally existing servers have different properties
    exposed under different names. It is thus not easy to set up monitoring of different
    kinds of server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个痛点是，许多全球存在的服务器在不同名称下公开了不同的属性。因此，设置不同类型服务器的监视并不容易。
- en: MicroProfile has created a monitoring specification that addresses these two
    points via an HTTP-based API permitting access by monitoring agents and a Java
    API that allows application-specific metrics to be exported on top of a set of
    servers and JVM metrics.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile已经创建了一个监控规范，通过基于HTTP的API允许监控代理访问，并且允许在一组服务器和JVM指标之上导出特定于应用程序的指标的Java
    API。
- en: MicroProfile Metrics is developing the 2.x version of the specification that
    has some breaking changes to 1.x. The following sections talk about 1.x – the
    changes in 2.0 are discussed in the *New in MP-Metrics 2.0* section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile指标正在开发规范的2.x版本，对1.x有一些重大变化。以下部分讨论了1.x - 2.0中的更改在*MP-Metrics 2.0中的新内容*部分中讨论。
- en: 'The specification defines three scopes for metrics:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 规范定义了指标的三个范围：
- en: 'Base: These are metrics, mostly JVM statistics, that every compliant vendor
    has to support.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础：这些是大多数JVM统计信息的指标，每个符合规范的供应商都必须支持。
- en: 'Vendor: Optional vendor-specific metrics that are not portable.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商：可选的供应商特定的不可移植的指标。
- en: 'Application: Optional metrics from deployed applications. The Java API will
    be shown in the *Supplying application-specific metrics* section.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序：部署的应用程序的可选指标。Java API将在*提供特定于应用程序的指标*部分中显示。
- en: Another issue with the classic JMX approach, which MicroProfile Metrics addresses,
    is the lack of metadata information about the semantics of a metric.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile指标解决了经典JMX方法的另一个问题，即缺乏有关指标语义的元数据信息。
- en: Metadata
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元数据
- en: Metadata is a very important part of MicroProfile Metrics. While it is possible
    to expose a metric `foo` with a value of `142`, it is not self-describing. An
    operator seeing that metric can't tell what this is about, what the unit is, and
    whether `142` is a good value or not.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据是MicroProfile指标的一个非常重要的部分。虽然可能会暴露一个值为`142`的指标`foo`，但它并不是自描述的。看到该指标的操作员无法知道这是关于什么的，单位是什么，以及`142`是否是一个好值。
- en: 'Metadata is used to provide units and also a description of the metric so that
    the preceding could now be `foo: runtime; 142` seconds. This now allows for correct
    scaling on the display to *two minutes and 22 seconds*. And the user receiving
    an alert relating to this metric can understand that it refers to some runtime
    timing.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '元数据用于提供单位，以及指标的描述，以便前面的内容现在可以是`foo: runtime; 142`秒。这现在允许在显示上正确地缩放到*两分钟22秒*。接收与此指标相关的警报的用户可以理解它指的是某个运行时计时。'
- en: Retrieving metrics from the server
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器检索指标
- en: MicroProfile Metrics exposes metrics via a REST interface, by default, under
    the `/metrics` context root. You can find the code at [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter05-metrics](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter05-metrics).
    Follow the `README.md` file to build the code, run it, and hit the [http://localhost:8080/book-metrics/hello](http://localhost:8080/book-metrics/hello)
    and [http://localhost:8080/book-metrics](http://localhost:8080/book-metrics) endpoints
    a few times with your browser to generate some data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Metrics通过REST接口公开度量标准，默认情况下，在`/metrics`上下文根下。您可以在[https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter05-metrics](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter05-metrics)找到代码。跟随`README.md`文件构建代码，运行它，并在浏览器中多次点击[http://localhost:8080/book-metrics/hello](http://localhost:8080/book-metrics/hello)和[http://localhost:8080/book-metrics](http://localhost:8080/book-metrics)端点，以生成一些数据。
- en: As of MicroProfile 1.3/2.0, there is nothing in the specifications about securing
    that endpoint. This is thus left to the individual implementation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从MicroProfile 1.3/2.0开始，规范中没有关于保护该端点的内容。这留给了个别的实现。
- en: 'Using this REST interface, it is easy to retrieve the data, for example, via
    the following `curl` command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个REST接口，可以很容易地检索数据，例如，通过以下`curl`命令：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command shows the Metrics 1.x output in Prometheus text format (abbreviated):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令以Prometheus文本格式（缩写）显示Metrics 1.x的输出：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you do not provide a media type, the default output format is the Prometheus
    text format (which can also be rendered nicely in the browser). The Prometheus
    format exposes additional metadata to the values in the `# TYPE` and `# HELP`
    lines. You can also see in the previous example how the scopes (base, vendor,
    and application) are prepended to the actual metrics name.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不提供媒体类型，默认的输出格式是Prometheus文本格式（也可以在浏览器中很好地呈现）。Prometheus格式将附加元数据公开到`# TYPE`和`#
    HELP`行中的值。您还可以在前面的例子中看到，作用域（基本、供应商和应用程序）是如何前置到实际度量标准名称中的。
- en: 'Alternatively, it is possible to retrieve data in the JSON format by providing
    an `HAccept` header (again abbreviated):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过提供`HAccept`头来以JSON格式检索数据（再次缩写）：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This command results in the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的结果如下：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case, the pure data is exposed; the scopes form a top level, and respective
    metrics are nested inside. Matching metadata can be retrieved via an HTTP `XOPTIONS`
    call:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，纯数据被公开；范围形成顶层，相应的度量标准嵌套在内。匹配的元数据可以通过HTTP `XOPTIONS`调用来检索：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output now contains the metadata as a map:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 输出现在包含元数据作为一个映射：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have seen how we can retrieve different types of data and metadata,
    we will have a quick look at how we can limit retrieval to specific scopes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了如何检索不同类型的数据和元数据，我们将快速看一下如何将检索限制到特定的范围。
- en: Accessing specific scopes
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问特定范围
- en: 'It is also possible to retrieve data for only a single scope by appending the
    scope name to the path. In the following example, we only retrieve metrics for
    the base scope:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过在路径后附加范围名称来仅检索单个范围的数据。在下面的例子中，我们只检索基本范围的度量标准：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This now only shows metrics for the base scope:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只显示基本范围的度量标准：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this section, we have seen how to retrieve metrics from a MicroProfile Metrics-enabled
    server. Metrics in base and vendor scopes are predefined by the server. Metrics
    in the application scope can be defined by the user, which we are going to explore
    in the next section. ...
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们已经看到如何从MicroProfile Metrics启用的服务器中检索度量标准。基本和供应商范围内的度量标准由服务器预定义。应用程序范围内的度量标准可以由用户定义，我们将在下一节中探讨。
- en: Supplying application-specific metrics
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供特定于应用程序的度量标准
- en: Applications can choose to expose metric data via a CDI programming model. This
    model was inspired by DropWizard Metrics, so that it is easier to transition applications
    to MP-Metrics. It also uses the annotations from DropWizard Metrics, which have
    been augmented to support metadata.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以选择通过CDI编程模型公开度量标准数据。这个模型受DropWizard Metrics的启发，因此更容易将应用程序转换为MP-Metrics。它还使用了来自DropWizard
    Metrics的注释，这些注释已经增强以支持元数据。
- en: 'Let’s start with an example by defining a counter that is then incremented
    in code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个例子开始，通过定义一个计数器，然后在代码中递增它：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, we are registering a counter by getting it injected into the
    `hCount` variable:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过将它注入到`hCount`变量中来注册一个计数器：
- en: The `@Metric` annotation provides additional information, such as the description,
    and also indicates that the name is the variable name without an additional package
    (`absolute=true`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Metric`注释提供了额外的信息，比如描述，并且还指示名称是变量名称，没有额外的包（`absolute=true`）。'
- en: 'In the following example, we let the implementation do the counting for us.
    This implements the common use case of counting the number of invocations of a
    method or REST endpoint:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们让实现为我们计数。这实现了计算方法或REST端点调用次数的常见用例：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `monotonic` attribute of `@Counted` says to keep increasing the counter,
    otherwise it will be decreased when leaving the method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Counted`的`monotonic`属性表示保持增加计数器，否则当离开方法时会减少。'
- en: More types of metric
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多类型的度量标准
- en: Counters are only one type of metric that can be exposed and, very often, more
    complex types are needed, for example, to record the distribution of the duration
    of method calls.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器只是一种可以公开的度量标准，很多时候，更复杂的类型是需要的，例如，记录方法调用持续时间的分布。
- en: Let's have a quick look at these. Most follow the pattern of `@Counted`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下这些。大多数遵循`@Counted`的模式。
- en: Gauges
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标尺
- en: 'A gauge is a metric whose value arbitrarily goes up and down. Gauges are always
    backed by a method that supplies the value of the gauge:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标尺是一个值任意上下浮动的度量标准。标尺总是由一个方法支持，该方法提供标尺的值：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The gauge's value is computed, like all other values, when a client requests
    the values. This requires the implementation of the gauge method to be very quick,
    so that a caller is not blocked.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 计量器的值是在客户端请求值时计算的，与所有其他值一样。这要求计量器方法的实现非常快，以便不会阻塞调用者。
- en: Meter
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计量器
- en: 'A meter measures the rate at which the decorated method is called over time.
    For a JAX-RS endpoint, this would be the number of requests per second. Meters
    can be declared via an annotation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 计量器测量装饰方法随时间调用的速率。对于JAX-RS端点，这将是每秒的请求数。计量器可以通过注释声明：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When a client requests the data from the meter, the server supplies the mean
    rate, as well as one-, five-, and fifteen-minute moving averages. The latter may
    be familiar to some readers from the Unix/Linux `uptime` command.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端请求来自仪表的数据时，服务器会提供平均速率，以及一分钟、五分钟和十五分钟的移动平均值。后者可能对一些读者来说很熟悉，因为它们来自Unix/Linux的`uptime`命令。
- en: Histograms
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直方图
- en: 'A histogram is a type of metric that samples the distribution of data. It is
    mostly used to record the distribution of the time it takes to execute the decorated
    method. Histograms cannot be declared via dedicated annotation, unlike other types,
    but a timer, for example, includes histogram data. To use a histogram on its own,
    you need to register and update it in code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是一种对数据分布进行采样的指标类型。它主要用于记录执行装饰方法所需的时间分布。与其他类型不同，直方图不能通过专用注释声明，但是计时器，例如，包括直方图数据。要单独使用直方图，您需要在代码中注册和更新它：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This way of using metrics in code is feasible for the other types as well.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在代码中使用指标的方式对其他类型也是可行的。
- en: Timers
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器
- en: 'A timer basically is a combination of a histogram and a meter and can again
    be declared via an annotation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器基本上是直方图和计量器的组合，可以通过注释再次声明：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code in this example waits for a small random amount of time to make the
    output a bit more interesting.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的代码等待一个小的随机时间，以使输出更有趣。
- en: Tagging
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记
- en: Tags or labels are a way to additionally organize information. These became
    popular with Docker and Kubernetes. Within MicroProfile Metrics 1.x, they are
    directly forwarded to the output without further ado and do not serve to distinguish
    metrics. MicroProfile Metrics supports server-wide and per-metrics tags, which
    are then merged together in the output.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 标签或标签是另一种额外组织信息的方式。这在Docker和Kubernetes中变得流行。在MicroProfile Metrics 1.x中，它们直接转发到输出，无需其他操作，不用来区分指标。MicroProfile
    Metrics支持服务器范围和每个指标的标签，然后在输出中合并在一起。
- en: Server-wide tags
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器范围的标签
- en: 'Server-wide tags are set via the environment variable, `MP_METRICS_TAGS`, as
    shown:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器范围的标签是通过环境变量`MP_METRICS_TAGS`设置的，如下所示：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These tags will be added to all metrics defined in the server and also added
    to the respective output format.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签将被添加到服务器中定义的所有指标，并且还将被添加到相应的输出格式中。
- en: 'So, given the preceding command, a counter, `@Counted(absolute=true) int myCount;`,
    would end up in Prometheus as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定前面的命令，一个计数器，`@Counted(absolute=true) int myCount;`，将以以下方式出现在Prometheus中：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Per-metrics tags
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个指标的标签
- en: 'Tags can also be supplied on a per-metric basis:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 标签也可以在每个指标的基础上提供：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This example defines two labels, `version=v1` and `commit=abcde`, on the metric
    with the name `doSomething`. Those will be merged with the global tags for the
    output. With the preceding global tag, there would thus be three tags in the output.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在名为`doSomething`的指标上定义了两个标签，`version=v1`和`commit=abcde`。这些标签将与输出的全局标签合并。因此，在前面的全局标签中，输出中将有三个标签。
- en: In this section, we have seen how to add labels to metrics to provide additional
    metadata. These can be global, for all metrics exposed from a server, or application-specific,
    for one single metric.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经看到如何向指标添加标签以提供额外的元数据。这些可以是全局的，用于从服务器暴露的所有指标，也可以是特定于应用程序的，用于单个指标。
- en: Using Prometheus to retrieve metrics
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Prometheus检索指标
- en: Now that we have seen what metrics are exposed and how we can define our own,
    let's have a look at how we can collect them in a **time series database** (**TSDB**).
    For this purpose, we use Prometheus, a CNCF ([https://www.cncf.io/](https://www.cncf.io/))
    project that has gained widespread adoption in the cloud-native world.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了暴露了哪些指标以及我们如何定义自己的指标，让我们来看看我们如何在时间序列数据库（TSDB）中收集它们。为此，我们使用了Prometheus，这是一个在云原生世界中得到广泛采用的CNCF（[https://www.cncf.io/](https://www.cncf.io/)）项目。
- en: You can download Prometheus from [https://prometheus.io](https://prometheus.io/)
    or on macOS via `brew install prometheus`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://prometheus.io](https://prometheus.io/)或在macOS上通过`brew install prometheus`下载Prometheus。
- en: 'Once Prometheus is downloaded, we need a configuration file that defines which
    targets to scrape and can then start the server. For our purposes, we will use
    the following simple file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦下载了Prometheus，我们需要一个配置文件，定义要抓取的目标，然后可以启动服务器。为了我们的目的，我们将使用以下简单的文件：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: New in MP-Metrics 2.0
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MP-Metrics 2.0中的新功能
- en: 'NOTE: MicroProfile Metrics 2.0 may not be released when you read this, and
    the content may have changed slightly depending on feedback from early users/implementors.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当您阅读本文时，MicroProfile Metrics 2.0可能尚未发布，内容可能会根据早期用户/实施者的反馈略有变化。
- en: Change for counters – introducing ConcurrentGauge
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数器的变化-引入ConcurrentGauge
- en: 'Counters in Metrics 1.x had two functions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Metrics 1.x中的计数器有两个功能：
- en: To provide a measure for the number of concurrent invocations
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供并发调用次数的度量
- en: As a metric that can count up to the number of transactions committed, for example
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个可以计数到提交的交易数量的指标，例如
- en: Unfortunately, the first way was the default when using the annotation without
    specifying the `monotonic` keyword, which is unexpected and was confusing a lot
    of users. The second version of this also had its issues, as a counter value could
    also decrease at will, which violates the understanding that a counter is a monotonically
    increasing metric.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当使用注释而没有指定`monotonic`关键字时，第一种方式是默认的，这是出乎意料的，也让很多用户感到困惑。这个的第二个版本也有它的问题，因为计数器的值也可以随意减少，这违反了计数器是一个单调递增的指标的理解。
- en: For this reason, the Metrics working group has decided to change the behavior
    of counters so they only work as monotonically increasing metrics and to defer
    the ...
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，指标工作组决定改变计数器的行为，使其只作为单调递增的指标工作，并推迟...
- en: Tagging
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记
- en: 'Tags now also serve to distinguish metrics with the same name and type, but
    different tags. They could be used to support many metrics `result_code` on a
    REST endpoint to count the number of (un)successful calls:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 标签现在也用于区分具有相同名称和类型但不同标签的指标。它们可以用于支持在REST端点上计算（不）成功调用的`result_code`的数量：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Under the covers, metrics are no longer only keyed by name and type, but also
    by their tags. For this, new `MetricID` has been introduced to host the name and
    the tags.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，指标不再仅仅由名称和类型来标识，还有它们的标签。为此，引入了新的`MetricID`来承载名称和标签。
- en: Changes in data output format
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据输出格式的更改
- en: The introduction of multi-tag metrics in MicroProfile Metrics 2.0 necessitated
    changes in the format of metric data that is made available to clients.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在MicroProfile Metrics 2.0中引入多标签指标需要对向客户端提供的指标数据格式进行更改。
- en: 'The Prometheus format also had some inconsistencies, so we decided to revamp
    the formats in sometimes incompatible ways:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus格式也存在一些不一致之处，因此我们决定以有时不兼容的方式重新设计格式：
- en: The colon (:) as a separator between the scope and metric name has been changed
    to an underscore (_).
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域和指标名称之间的分隔符冒号（:）已更改为下划线（_）。
- en: The Prometheus output format no longer requires that camelCase is turned into
    snake_case.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus输出格式不再要求camelCase转换为snake_case。
- en: The format of the base metrics for garbage collectors has changed and now uses
    tags for the various garbage collectors.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集器的基本指标格式已经改变，现在使用标签来表示各种垃圾收集器。
- en: Please consult the release notes in the MicroProfile 2.0 specification at [https://github.com/eclipse/microprofile-metrics/releases/tag/2.0
    ...](https://github.com/eclipse/microprofile-metrics/releases/tag/2.0)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅MicroProfile 2.0规范中的发布说明[https://github.com/eclipse/microprofile-metrics/releases/tag/2.0
    ...](https://github.com/eclipse/microprofile-metrics/releases/tag/2.0)
- en: MicroProfile OpenTracing
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing
- en: In the modern world of microservices, a single request can traverse multiple
    processes running on different machines, data centers, or even geographical regions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代微服务的世界中，单个请求可以遍历运行在不同机器、数据中心甚至地理区域的多个进程。
- en: The observability of such systems is a challenging task but, when done right,
    it allows us to *tell the story* about each individual request as opposed to the
    overall state of the system derived from signals such as metrics and logs. In
    this chapter, we will introduce you to distributed tracing and explain OpenTracing
    with its integration in MicroProfile OpenTracing 1.3.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这类系统的可观察性是一项具有挑战性的任务，但是，如果做得正确，它可以让我们*讲述*每个单独请求的故事，而不是从指标和日志等信号中推导出的系统整体状态。在本章中，我们将向您介绍分布式跟踪，并解释MicroProfile
    OpenTracing 1.3中的OpenTracing集成。
- en: In the previous section, we learned about metrics and how they observe an application
    or each individual component. This information is no doubt very valuable and provides
    a macro view of the system, but, at the same time, it says very little about each
    individual request that traverses multiple components. Distributed tracing shows
    a micro view of what happened with a request end to end so that we can retrospectively
    understand the behavior of each individual component of the application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们了解了指标以及它们如何观察应用程序或每个单独的组件。这些信息无疑非常有价值，并提供了系统的宏观视图，但同时，它对于遍历多个组件的每个单独请求的行为说得很少。分布式跟踪展示了请求端到端发生了什么，以便我们可以回顾地了解应用程序的每个单独组件的行为。
- en: 'Distributed tracing is action-based; in other words, it records everything
    related to an action in the system. For example, it captures detailed information
    of a request and all causally related activities. We will not go through the details
    of how this tracing works, but, in a nutshell, we can state the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式跟踪是基于动作的；换句话说，它记录了系统中与某个动作相关的一切。例如，它捕获了请求的详细信息以及所有因果相关的活动。我们不会详细介绍这种追踪是如何工作的，但简而言之，我们可以陈述如下：
- en: The tracing infrastructure attaches contextual metadata to each request, typically,
    a set of unique IDs – `traceId`, `spanId`, and `parentId`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追踪基础设施会为每个请求附加上下文元数据，通常是一组唯一的ID - `traceId`，`spanId`和`parentId`。
- en: The instrumentation layer records profiling data and propagates metadata inside
    and between processes.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表层记录了性能数据并在进程内部和进程之间传播元数据。
- en: The captured profiling data contains metadata and causality references to preceding
    events.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获的性能数据包含了元数据和与之前事件的因果关系引用。
- en: 'Based on the captured data, distributed tracing systems usually offer the following
    functionality:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 基于捕获的数据，分布式跟踪系统通常提供以下功能：
- en: Root-cause analysis
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根本原因分析
- en: Latency optimization – critical path analysis
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟优化 - 关键路径分析
- en: Distributed context propagation – baggage
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式上下文传播 - 随行物品
- en: Contextualized logging
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文化日志记录
- en: Service dependency analysis
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务依赖分析
- en: Before we delve into MicroProfile OpenTracing, let's briefly look at OpenTracing
    so that we can better understand what the API offers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解MicroProfile OpenTracing之前，让我们简要地了解一下OpenTracing，以便更好地理解API提供了什么。
- en: OpenTracing project
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenTracing项目
- en: The OpenTracing project ([https://opentracing.io](https://opentracing.io/))
    provides a vendor-neutral specification [(https://github.com/opentracing/specification)](https://github.com/opentracing/specification) and
    polyglot APIs for describing distributed transactions. Vendor neutrality is important
    because code instrumentation is the most time-consuming and challenging task when
    enabling distributed tracing in large organizations. We would like to stress that
    OpenTracing is just an API. A real deployment will require a plugged tracer implementation
    that runs inside the monitored process and sends data to a tracing system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTracing项目（[https://opentracing.io](https://opentracing.io/)）提供了一个供应商中立的规范（[https://github.com/opentracing/specification](https://github.com/opentracing/specification)）和多语言API，用于描述分布式事务。供应商中立性很重要，因为在大型组织中启用分布式跟踪时，代码仪器化是最耗时和具有挑战性的任务。我们想强调OpenTracing只是一个API。实际部署将需要一个插入的跟踪器实现，运行在受监视的进程内，并将数据发送到跟踪系统。
- en: 'From an API perspective, there are three key concepts: Tracer, Span, and SpanContext.
    Tracer is a singleton object available to the application that can be used to
    model a ...'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从API的角度来看，有三个关键概念：跟踪器、跨度和跨度上下文。跟踪器是应用程序可用的单例对象，可用于建模...
- en: Configuration properties
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置属性
- en: OpenTracing is vendor-neutral and can, therefore, work with any vendor's tracing
    implementation that uses this API. Each tracer implementation will be configured
    differently. Therefore, the configuration is outside the scope of the MicroProfile
    OpenTracing specification. However, the specification itself exposes a couple
    of configuration properties to adjust the tracing scope or generated data. The
    configuration leverages the MicroProfile Config specification to provide a consistent
    means for all supported configuration options.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTracing是供应商中立的，因此可以与使用此API的任何供应商的跟踪实现一起工作。每个跟踪器实现将被配置不同。因此，配置不在MicroProfile
    OpenTracing规范的范围之内。然而，规范本身公开了一些配置属性，以调整跟踪范围或生成的数据。配置利用了MicroProfile Config规范，为所有支持的配置选项提供了一致的手段。
- en: 'Currently, the specification exposes the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，规范公开了以下内容：
- en: '`mp.opentracing.server.skip-pattern`: A skip pattern to avoid the tracing of
    selected REST endpoints.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mp.opentracing.server.skip-pattern`：用于避免跟踪选定REST端点的跳过模式。'
- en: '`mp.opentracing.server.operation-name-provider`: This specifies the operation
    name provider for server spans. Possible values are `http-path` and `class-method`.
    The default value is `class-method`, which fully uses a qualified class name concatenated
    with a method name; for example, `GET:org.eclipse.Service.get`. The `http-path`
    uses a value of `@Path` annotation as an operation name.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mp.opentracing.server.operation-name-provider`：这指定了服务器跨度的操作名称提供程序。可能的值是 `http-path`
    和 `class-method`。默认值是 `class-method`，它完全使用合格的类名与方法名连接；例如，`GET:org.eclipse.Service.get`。`http-path`
    使用 `@Path` 注解的值作为操作名称。'
- en: Automatic instrumentation
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动仪器化
- en: The motivation here is to have tracing automatically capture all crucial performance
    information and also automatically propagate tracing context between runtimes.
    The second part is especially crucial because it ensures that traces are not broken
    and we are able to investigate end-to-end invocation. For successful tracing,
    every communication technology between runtimes has to be instrumented. In the
    case of MicroProfile, it is JAX-RS and MicroProfile Rest Client.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的动机是自动捕获所有关键性能信息，并自动在运行时传播跟踪上下文。第二部分尤其关键，因为它确保跟踪不会中断，我们能够调查端到端的调用。为了成功跟踪，运行时之间的每种通信技术都必须被仪器化。在MicroProfile的情况下，这是JAX-RS和MicroProfile
    Rest Client。
- en: JAX-RS
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAX-RS
- en: MicroProfile OpenTracing automatically traces all inbound JAX-RS endpoints.
    However, the JAX-RS client side is more tricky and requires the registration API, `org.eclipse.microprofile.opentracing.ClientTracingRegistrar.configure(ClientBuilder
    clientBuilder)`, to be called to add tracing capability. MicroProfile implementation
    can enable tracing for all client interfaces globally; however, it is recommended
    to use the registration API for better portability.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing自动跟踪所有入站JAX-RS端点。然而，JAX-RS客户端端更加棘手，需要调用注册API `org.eclipse.microprofile.opentracing.ClientTracingRegistrar.configure(ClientBuilder
    clientBuilder)` 来添加跟踪能力。MicroProfile实现可以全局启用所有客户端接口的跟踪；然而，建议使用注册API以获得更好的可移植性。
- en: 'The default tracing behavior can be modified by disabling the tracing of specific
    requests or changing operation names of produced server spans. For more information,
    refer to the *Configuration properties* section later in this chapter. The instrumentation
    layer automatically adds the following request-scoped information to each span:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的跟踪行为可以通过禁用特定请求的跟踪或更改生成的服务器跨度的操作名称来修改。有关更多信息，请参阅本章后面的*配置属性*部分。仪器化层自动向每个跨度添加以下请求范围信息：
- en: '`http.method`: The HTTP method of the request.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.method`：请求的HTTP方法。'
- en: '`http.status_code`: The status code of the request.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.status_code`：请求的状态码。'
- en: '`http.url`: The URL of the request.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.url`：请求的URL。'
- en: '`component`: The name of the instrumented component, `jaxrs`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`：被仪器化组件的名称，`jaxrs`。'
- en: '`span.kind`: The client or server.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`span.kind`：客户端或服务器。'
- en: '`error` – `true` or `false`. This is optional and, if present, instrumentation
    also adds an exception as `error.object` to span logs.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`错误` - `true` 或 `false`。这是可选的，如果存在，仪器还会将异常添加为 `error.object` 到跨度日志。'
- en: 'All these tags can be used to query data via the tracing system user interface,
    or they can be used for data analytics jobs that many tracing systems provide.
    Additional metadata can be added to the current active span via an injected tracer
    instance. This can be conducted globally in filters or locally in rest handlers,
    as shown in the following code example, by adding a user agent header to the server
    span (1):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些标签都可以用于通过跟踪系统用户界面查询数据，或者它们可以用于许多跟踪系统提供的数据分析作业。可以通过注入的跟踪器实例向当前活动跨度添加附加元数据。这可以在过滤器中全局进行，也可以在rest处理程序中局部进行，如下面的代码示例所示，通过向服务器跨度添加用户代理标头（1）：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By default, server-side spans have the operation name `http_method:package.className.method`.
    However, this can be changed locally by using the `@Traced` annotation (2), or
    globally via the configuration property (refer to the configuration section).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，服务器端span的操作名称为`http_method:package.className.method`。但是，可以通过使用`@Traced`注解（2）在本地更改，或者通过配置属性全局更改（参见配置部分）。
- en: MicroProfile Rest Client
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile Rest Client
- en: As was mentioned in the previous section, all REST client interfaces are, by
    default, automatically traced with no additional configuration required. This
    behavior can be changed by applying the `@Traced` annotation to the interface
    or method to disable tracing. When applied to the interface, all methods are skipped
    from tracing. Note that the tracing context is not being propagated. Therefore,
    if the request continues to an instrumented runtime, a new trace is started.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，默认情况下，所有REST客户端接口都会自动跟踪，无需额外配置。可以通过将`@Traced`注解应用于接口或方法来更改此行为以禁用跟踪。当应用于接口时，所有方法都将跳过跟踪。请注意，跟踪上下文不会被传播。因此，如果请求继续到一个被仪器化的运行时，将启动一个新的跟踪。
- en: Explicit instrumentation
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式仪器
- en: Sometimes, the automatic instrumentation does not capture all critical timing
    information and, therefore, additional trace points are needed. For example, we
    would like to trace an invocation of a business layer or initialize third-party
    instrumentation provided by the OpenTracing project ([https://github.com/opentracing-contrib](https://github.com/opentracing-contrib)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，自动仪器无法捕获所有关键的时间信息，因此需要额外的跟踪点。例如，我们希望跟踪业务层的调用或初始化由OpenTracing项目提供的第三方仪器（[https://github.com/opentracing-contrib](https://github.com/opentracing-contrib)）。
- en: 'The explicit instrumentation can be done in three ways:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 显式仪器可以通过三种方式完成：
- en: Add the `@Traced` annotation on **Context and Dependency Injection** (**CDI**)
    beans.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**上下文和依赖注入**（**CDI**）bean上添加`@Traced`注解。
- en: Inject the tracer and create spans manually.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入跟踪器并手动创建span。
- en: Initialize third-party instrumentation. The initialization of external instrumentation
    depends on its own initialization requirements. MicroProfile just has to provide
    a tracer instance, which is covered in the previous bullet point.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化第三方仪器。外部仪器的初始化取决于其自身的初始化要求。MicroProfile只需提供一个跟踪器实例，这在前面的项目中已经涵盖了。
- en: Let's now discuss these in detail.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们详细讨论这些。
- en: '@Traced annotation'
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Traced注解'
- en: MicroProfile OpenTracing defines an `@Traced` annotation that can be used to
    enable tracing on CDI beans or disable tracing on automatically traced interfaces.
    The annotation can also be used to override the operation name on other automatically
    traced components – JAX-RS endpoints.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing定义了一个`@Traced`注解，可以用于在CDI bean上启用跟踪或在自动跟踪的接口上禁用跟踪。该注解还可以用于覆盖其他自动跟踪组件（如JAX-RS端点）上的操作名称。
- en: 'The following code example shows how the `@Traced` annotation can be used to
    enable tracing on a CDI bean. `(1)` enables tracing for all methods the bean defines.
    `(2)` overrides the default operation name (`package.className.method`) to `get_all_users`.
    `(3)` disables tracing of the health method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了如何使用`@Traced`注解在CDI bean上启用跟踪。`(1)` 启用了bean定义的所有方法的跟踪。`(2)` 覆盖了默认操作名称（`package.className.method`）为`get_all_users`。`(3)`
    禁用了health方法的跟踪。
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tracer injection
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪器注入
- en: The application can inject an `io.opentracing.Tracer` bean that exposes the
    full OpenTracing API. This allows application developers to leverage more advanced
    use cases, such as adding metadata to the currently active span, manually creating
    spans, using baggage for context propagation, or initializing additional third-party
    instrumentation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以注入一个公开完整OpenTracing API的`io.opentracing.Tracer` bean。这允许应用程序开发人员利用更高级的用例，例如向当前活动的span添加元数据，手动创建span，使用行李传播上下文，或初始化其他第三方仪器。
- en: 'The following code shows how the tracer is used to attach data to the currently
    active span, `(1)`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了跟踪器如何用于将数据附加到当前活动的span中，`(1)`：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This can be useful for adding business-related data to spans, but also to log
    exceptions or any other profiling information.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于向span添加与业务相关的数据很有用，还可以记录异常或任何其他分析信息。
- en: Tracing with Jaeger
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jaeger进行跟踪
- en: So far, we have only talked about different aspects of the instrumentation.
    However, to run the full tracing infrastructure, we need a tracing backend. In
    this section, we will use Jaeger ([https://www.jaegertracing.io/](https://www.jaegertracing.io/))
    to demonstrate how collected tracing data is presented in a tracing system. We
    have chosen Jaeger because Thorntail provides direct integration with Jaeger.
    Other vendors can provide integrations with other systems, for instance, Zipkin,
    and Instana. Almost every tracing system offers a Gannt chart style view (or timeline)
    of a trace. This view might be overwhelming for tracing novices, but it is a great
    tool to systematically analyze an invocation in a distributed system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只谈到了仪器的不同方面。然而，要运行完整的跟踪基础设施，我们需要一个跟踪后端。在本节中，我们将使用Jaeger ([https://www.jaegertracing.io/](https://www.jaegertracing.io/))
    来演示跟踪数据在跟踪系统中的呈现方式。我们选择了Jaeger，因为Thorntail直接集成了Jaeger。其他供应商可以提供与其他系统的集成，例如Zipkin和Instana。几乎每个跟踪系统都提供了一个Gannt图样式的视图（或时间轴）来显示跟踪。这种视图可能会让跟踪新手感到不知所措，但它是一个系统分析分布式系统中调用的强大工具。
- en: The following screenshot shows ...
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示...
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the observability of servers and applications.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了服务器和应用程序的可观察性。
- en: Metrics, or telemetry, can help to pinpoint the performance characteristics
    of a server or an application. MicroProfile offers, via the Metrics specification,
    a way to export Metrics in standardized ways. Application writers can use MicroProfile
    Metrics to expose their data to monitoring clients decoratively via annotations
    or via calls to the Metrics API.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 度量标准或遥测可以帮助精确定位服务器或应用程序的性能特征。MicroProfile通过度量标准规范提供了一种以标准化方式导出度量标准的方法。应用程序编写者可以使用MicroProfile度量标准，通过注解或调用度量标准API将其数据装饰性地暴露给监控客户端。
- en: The chapter further explained how OpenTracing integration in MicroProfile provides
    an end-to-end view for each individual transaction going through the system. We
    went through the configuration properties, showcasing tracing for JAX-RS, and
    finally investigating data in the Jaeger system.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本章进一步解释了MicroProfile中OpenTracing集成如何为系统中经过的每个单独事务提供端到端视图。我们介绍了配置属性，展示了对JAX-RS的跟踪，并最终调查了Jaeger系统中的数据。
- en: In the next chapter, we will learn how to document (REST) APIs via OpenAPI and
    call those APIs via the type-safe REST client.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过OpenAPI记录（REST）API，并通过类型安全的REST客户端调用这些API。
- en: Questions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between distributed tracing and metrics?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式跟踪和度量之间有什么区别？
- en: What functionality do distributed tracing systems usually provide?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式跟踪系统通常提供哪些功能？
- en: What parts of the system are automatically traced in MicroProfile OpenTracing?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MicroProfile OpenTracing中，系统的哪些部分会自动被跟踪？
- en: Which tags are added for every REST request by MicroProfile OpenTracing?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing为每个REST请求添加了哪些标签？
- en: How can explicit instrumentation be added to the business code?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何向业务代码添加显式的仪器？
- en: What are scopes in Metrics and what is their rationale?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 度量标准中的范围是什么，它们的基本原理是什么？
- en: What determines the output format of a REST request to the Metrics API?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是什么决定了对度量标准API的REST请求的输出格式？
- en: What ways are available to export metrics within a user application?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户应用程序中有哪些可用的方式来导出指标？
