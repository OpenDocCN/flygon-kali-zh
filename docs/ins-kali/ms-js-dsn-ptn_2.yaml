- en: Part I. Classical Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分。经典设计模式
- en: Organizing Code
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 组织代码
- en: Creational Patterns
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 创造模式
- en: Structural Patterns
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 结构模式
- en: Behavioral Patterns
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式
- en: Chapter 2. Organizing Code
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。组织代码
- en: In this chapter we'll look at how to organize JavaScript code into reusable,
    understandable chunks. The language itself doesn't lend itself well to this sort
    of modularization but a number of methods of organizing JavaScript code have emerged
    over the years. This chapter will argue for the need to break down code and then
    work through the methods of creating JavaScript modules.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何将JavaScript代码组织成可重用、可理解的代码块。语言本身并不适合这种模块化，但多年来出现了许多组织JavaScript代码的方法。本章将论证需要拆分代码，然后逐步介绍创建JavaScript模块的方法。
- en: 'We will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Global scope
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局范围
- en: Objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Prototype inheritance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型继承
- en: ECMAScript 2015 classes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 2015类
- en: Chunks of code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码块
- en: The first thing anybody learns to program is the ubiquitous Hello World application.
    This simple application prints some variation of "hello world" to the screen.
    Depending on who you ask, the phrase hello world dates back to the early 1970s
    where it was used to demonstrate the B programming language or even to 1967 where
    it appears in a BCL programming guide. In such a simple application there is no
    need to worry about the structure of code. Indeed, in many programming languages,
    hello world needs no structure at all.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人学习编程的第一件事就是无处不在的Hello World应用程序。这个简单的应用程序将“hello world”的某种变体打印到屏幕上。取决于你问的人，hello
    world这个短语可以追溯到20世纪70年代初，当时它被用来演示B编程语言，甚至可以追溯到1967年，当时它出现在BCL编程指南中。在这样一个简单的应用程序中，无需担心代码的结构。事实上，在许多编程语言中，hello
    world根本不需要结构。
- en: 'For Ruby, it is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ruby，情况如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For JavaScript (via Node.js), it is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript（通过Node.js），情况如下：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Programming modern computers was originally done using brutally simplistic techniques.
    Many of the first computers had problems they were attempting to solve hard-wired
    into them. They were not general purpose computing machines like the ones we have
    today. Instead they were built to solve just one problem such as decoding encrypted
    texts. Stored program computers were first developed in the late 1940s.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最初使用极其简单的技术来编程现代计算机。许多最初的计算机在解决问题时都被硬编码。它们不像我们今天拥有的通用计算机那样。相反，它们被构建为仅解决一个问题，例如解码加密文本。存储程序计算机最早是在1940年代末开发的。
- en: The languages used to program these computers were complicated at first, usually
    very closely tied to the binary. Eventually higher and higher-level abstractions
    were created to make programming more accessible. As these languages started to
    take shape through the 50s and 60s it quickly became apparent that there needed
    to be some way to divide up large blocks of code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最初用于编程这些计算机的语言通常非常复杂，通常与二进制密切相关。最终，创建了越来越高级的抽象，使编程更加易于访问。随着这些语言在50年代和60年代开始形成，很快就显而易见地需要一些方法来划分大块代码。
- en: In part this was simply to maintain the sanity of programmers who could not
    keep an entire, large program in their heads at any one time. However, creating
    reusable modules also allowed for code to be shared within an application and
    even between applications. The initial solution was to make use of statements,
    which jumped the flow control of the program from one place to another. For a
    number of years these GOTO statements were heavily relied upon. To a modern programmer
    who has been fed a continual stream of warnings about the use of GOTO statements
    this seems like insanity. However it was not until some years after the first
    programming languages emerged that structured programming grew to replace the
    GOTO syntax.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 部分原因是为了保持程序员的理智，他们无法一次记住整个大型程序。然而，创建可重用的模块也允许在应用程序内部甚至在应用程序之间共享代码。最初的解决方案是利用语句，它们跳转程序的流程控制从一个地方到另一个地方。多年来，这些GOTO语句被大量依赖。对于一个不断受到有关使用GOTO语句的警告的现代程序员来说，这似乎是疯狂的。然而，直到第一批编程语言出现几年后，结构化编程才发展成为取代GOTO语法的形式。
- en: 'Structured programming is based on the Böhm-Jacopini theorem, which states
    that there is a rather large class of problems, the answer to which can be computed
    using three very simple constructs:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化编程基于Böhm-Jacopini定理，该定理指出有一类相当大的问题，其答案可以使用三个非常简单的构造来计算：
- en: Sequential execution of sub-programs
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子程序的顺序执行
- en: Conditional execution of two sub-programs
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个子程序的条件执行
- en: Repeated execution of a sub-program until a condition is true
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复执行子程序，直到条件为真
- en: Astute readers will recognize these constructs as being the normal flow of execution,
    a branch or `if` statement, and a loop.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的读者会认识到这些构造是正常的执行流程，一个分支或`if`语句和一个循环。
- en: Fortran was one of the earliest languages and was initially built without support
    for structured programming. However structured programming was soon adopted as
    it helped to avoid spaghetti code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Fortran是最早的语言之一，最初构建时没有支持结构化编程。然而，结构化编程很快被采纳，因为它有助于避免意大利面式代码。
- en: Code in Fortran was organized into modules. Modules were loosely coupled collections
    of procedures. For those coming from a modern object oriented language, the closest
    concept might be that a module was like a class that contains only static methods.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Fortran中的代码被组织成模块。模块是松散耦合的过程集合。对于那些来自现代面向对象语言的人来说，最接近的概念可能是模块就像一个只包含静态方法的类。
- en: Modules were useful for dividing code into logical groupings. However, it didn't
    provide for any sort of structure for the actual applications. The structure for
    object-oriented languages, that is classes and subclasses, can be traced to a
    1967 paper written by Ole-Johan Dahl and Kristen Nygaard. This paper would go
    on to form the basis of Simula-67, the first language with support for object
    oriented programming.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模块对于将代码分成逻辑分组非常有用。但是，它并没有为实际应用程序提供任何结构。面向对象语言的结构，即类和子类，可以追溯到Ole-Johan Dahl和Kristen
    Nygaard在1967年撰写的一篇论文。这篇论文将成为Simula-67的基础，这是第一种支持面向对象编程的语言。
- en: While Simula-67 was the first language to have classes, the language most talked
    about in relation to early object oriented programming is Smalltalk. This language
    was developed behind closed doors at the famous Xerox **Palo Alto Research Center**
    ( **PARC** ) during the 1970s. it was released to the public in 1980 as Smalltalk-80
    (it seems like all historically relevant programming languages where prefixed
    with the year of release as a version number). What Smalltalk brought was that
    everything in the language was an object, even literal numbers like 3 could have
    operations performed on them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Simula-67是第一种具有类的语言，但与早期面向对象编程相关的最多讨论的语言是Smalltalk。这种语言是在20世纪70年代在著名的施乐**帕洛阿尔托研究中心**（**PARC**）秘密开发的。它于1980年作为Smalltalk-80向公众发布（似乎所有具有历史意义的编程语言都以发布年份作为版本号的前缀）。Smalltalk带来的是语言中的一切都是对象，甚至像3这样的文字数字也可以对它们执行操作。
- en: Almost every modern programming language has some concept of classes to organize
    code. Often these classes will fall into a higher-level structure commonly called
    a namespace or module. Through the use of these structures, even very large programs
    can be divided into manageable and understandable chunks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每种现代编程语言都有一些类的概念来组织代码。通常，这些类将属于一个称为命名空间或模块的更高级结构。通过使用这些结构，即使是非常大的程序也可以分成可管理和可理解的块。
- en: Despite the rich history and obvious utility of classes and modules, JavaScript
    did not support them as first class constructs until just recently. To understand
    why, one has to simply look back at the history of JavaScript from [Chapter 1](text00014.html#ch01
    "Chapter 1. Designing for Fun and Profit") , *Designing For Fun and Profit* ,
    and realize that for its original purpose having such constructs would have been
    overkill. Classes were a part of the ill-fated ECMAScript 4 standard and they
    finally became part of the language with the release of the ECMAScript 2015 standard.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管类和模块具有丰富的历史和明显的实用性，JavaScript直到最近才支持它们作为一流构造。要理解为什么，只需简单地回顾一下JavaScript的历史，从[第1章](text00014.html#ch01
    "第1章。为了乐趣和利润而设计")，*为了乐趣和利润而设计*，并意识到对于其最初的目的来说，拥有这样的构造将是多余的。类是注定要失败的ECMAScript
    4标准的一部分，它们最终成为了ECMAScript 2015标准的一部分。
- en: In this chapter we'll explore some of the ways to recreate the well worn class
    structure of other modern programming languages in JavaScript.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些在JavaScript中重新创建其他现代编程语言中的经典类结构的方法。
- en: What's the matter with global scope anyway?
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局范围有什么问题？
- en: In browser based JavaScript every object you create is assigned to the global
    scope. For the browser, this object is simply known as **window** . It is simple
    to see this behavior in action by opening up the development console in your favorite
    browser.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于浏览器的JavaScript中，您创建的每个对象都分配给全局范围。对于浏览器，这个对象简单地称为**window**。通过在您喜欢的浏览器中打开开发控制台，可以很容易地看到这种行为。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Opening the Development Console**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**打开开发控制台**'
- en: Modern browsers have, built into them, some very advanced debugging and auditing
    tools. To access them there is a menu item, which is located under **Tools** |
    **Developer Tools in Chrome** | **Tools** | **Web Developer in Firefox** , and
    directly under the menu as **F12 Developer Tools** in Internet Explorer. Keyboard
    shortcuts also exist for accessing the tools. On Windows and Linux, *F12* is standard
    and, on OSX, `Option` + `Command` + `I` is used.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器内置了一些非常先进的调试和审计工具。要访问它们，有一个菜单项，位于**工具** | **Chrome开发者工具** | **工具** | **Firefox
    Web开发者**下，以及直接在菜单下方的**F12开发者工具**在Internet Explorer中。还存在用于访问工具的键盘快捷键。在Windows和Linux上，*F12*是标准的，在OSX上，使用`Option`
    + `Command` + `I`。
- en: Within the developer tools is a console window that provides direct access to
    the current page's JavaScript. This is a very handy place to test out small snippets
    of code or to access the page's JavaScript.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 开发工具中有一个控制台窗口，可以直接访问当前页面的JavaScript。这是一个非常方便的地方，可以测试小代码片段或访问页面的JavaScript。
- en: 'Once you have the console open, enter the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 打开控制台后，输入以下代码：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result of this will be `hello world` printed to the console. By declaring
    words globally it is automatically attached to the top level container: window.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致`hello world`打印到控制台。通过全局声明单词，它会自动附加到顶层容器：window。
- en: In Node.js the situation is somewhat different. Assigning a variable in this
    fashion will actually attach it to the current module. Not including the `var`
    object will attach the variable to the `global` object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，情况有些不同。以这种方式分配变量实际上会将其附加到当前模块。不包括`var`对象将会将变量附加到`global`对象上。
- en: For years you've likely heard that making use of global variables is a bad thing.
    This is because globals are very easily polluted by other code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，您可能听说过使用全局变量是一件坏事。这是因为全局变量很容易被其他代码污染。
- en: Consider a very commonly named variable such as `index` . It is likely that
    in any application of appreciable size that this variable name would be used in
    several places. When either piece of code makes use of the variable it will cause
    unexpected results in the other piece of code. It is certainly possible to reuse
    variables, and it can even be useful in systems with very limited memory such
    as embedded systems, but in most applications reusing variables to mean different
    things within a single scope is difficult to understand and a source of errors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个非常常见的变量名，比如`index`。在任何规模可观的应用程序中，这个变量名可能会在多个地方使用。当任一代码片段使用该变量时，它会导致另一代码片段出现意外结果。重用变量是可能的，甚至在内存非常有限的系统中也可能很有用，比如嵌入式系统，但在大多数应用程序中，在单个范围内重用变量以表示不同的含义是难以理解的，也是错误的根源。
- en: Applications that make use global scoped variables also open themselves up to
    being attacked on purpose by other code. It is trivial to alter the state of global
    variables from other code, which could expose secrets like login information to
    attackers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局作用域变量的应用程序也容易受到其他代码的攻击。从其他代码改变全局变量的状态是微不足道的，这可能会使攻击者暴露登录信息等机密信息。
- en: Finally global variables add a great deal of complexity to applications. Reducing
    the scope of variables to a small section of code allows developers to more easily
    understand the ways in which the variable is used. When the scope is global then
    changes to that variable may have an effect far outside of the one section of
    code. A simple change to a variable can cascade into the entire application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，全局变量给应用程序增加了很多复杂性。将变量的范围减小到代码的一小部分可以让开发人员更容易理解变量的使用方式。当范围是全局时，对该变量的更改可能会影响到代码的其他部分。对变量的简单更改可能会影响整个应用程序。
- en: As a general rule global variables should be avoided.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，应该避免使用全局变量。
- en: Objects in JavaScript
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的对象
- en: 'JavaScript is an object oriented language but most people don''t make use of
    the object oriented features of it except in passing. JavaScript uses a mixed
    object model in that it has some primitives as well as objects. JavaScript has
    five primitive types:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种面向对象的语言，但大多数人在使用它时并不会充分利用其面向对象的特性。JavaScript使用混合对象模型，它既有原始值，也有对象。JavaScript有五种原始类型：
- en: undefined
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: 'null'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值
- en: boolean
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: string
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: number
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: 'Of these five, only two are what we would expect to be an object anyway. The
    other three, boolean, string, and number all have wrapped versions, which are
    objects: Boolean, String, and Number. They are distinguished by starting with
    uppercase. This is the same sort of model used by Java, a hybrid of objects and
    primitives.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这五个值中，只有两个是我们期望的对象。另外三个，布尔值、字符串和数字都有包装版本，它们是对象：Boolean、String和Number。它们以大写字母开头进行区分。这与Java使用的模型相同，是对象和原始值的混合。
- en: JavaScript will also box and unbox the primitives as needed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还会根据需要对原始值进行装箱和未装箱。
- en: 'In this code you can see the boxed and unboxed versions of JavaScript primitives
    at work:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，您可以看到JavaScript原始值的装箱和未装箱版本在工作：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Creating objects in JavaScript is trivial. This can be seen in this code for
    creating an object in JavaScript:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中创建对象是微不足道的。可以在这段代码中看到在JavaScript中创建对象的过程：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because JavaScript is a dynamic language, adding properties to objects is also
    quite easy. This can be done even after the object has been created. This code
    creates the object:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因为JavaScript是一种动态语言，向对象添加属性也非常容易。甚至可以在创建对象之后进行。这段代码创建了对象：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Objects contain both data and functionality. We''ve only seen the data part
    so far. Fortunately in JavaScript, functions are first class objects. Functions
    can be passed around and functions can be assigned to variables. Let''s try adding
    some functions to the object we''re creating in this code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对象包含数据和功能。到目前为止，我们只看到了数据部分。幸运的是，在JavaScript中，函数是一等对象。函数可以传递并且函数可以分配给变量。让我们尝试向我们在这段代码中创建的对象添加一些函数：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This syntax is a bit painful, building up objects an assignment at a time.
    Let''s see if we can improve upon the syntax for creating objects:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法有点痛苦，一次分配一个对象。让我们看看是否可以改进创建对象的语法：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This syntax seems, at least to me, to be a much cleaner, more traditional way
    of building objects. Of course it is possible to mix data and functionality in
    an object in this fashion:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法看起来，至少对我来说，是一种更清晰、更传统的构建对象的方式。当然，可以以这种方式在对象中混合数据和功能：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are a couple of things to note in this piece of code. The first is that
    the different items in the object are separated using a comma and not a semi-colon.
    Those coming from other languages such as C# or Java are likely to make this mistake.The
    next item of interest is that we need to make use of the `this` qualifier to address
    the `greeting` variable from within the `doThings` function. This would also be
    true if we had a number of functions within the object as shown here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中有几点需要注意。首先，对象中的不同项使用逗号而不是分号分隔。那些来自其他语言如C#或Java的人可能会犯这个错误。下一个值得注意的是，我们需要使用`this`限定符来从`doThings`函数内部访问`greeting`变量。如果我们在对象中有多个函数，情况也是如此，如下所示：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `this` keyword behaves differently in JavaScript than you might expect coming
    from other C-syntax languages. `this` is bound to the owner of the function in
    which it is found. However, the owner of the function is sometimes not what you
    expect. In the preceding example `this` is bound to the `functionObject` object,
    however if the function were declared outside of an object this would refer to
    the global object. In certain circumstances, typically event handlers, this is
    rebound to the object firing the event.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字在JavaScript中的行为与您从其他C语法语言中所期望的不同。`this`绑定到函数的所有者中。但是，函数的所有者有时并不是您所期望的。在前面的示例中，`this`绑定到`functionObject`对象，但是如果函数在对象之外声明，这将指向全局对象。在某些情况下，通常是事件处理程序，`this`会重新绑定到触发事件的对象。'
- en: 'Let''s look at the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`this` takes on the value of target. Getting used to the value of `this` is,
    perhaps, one of the trickiest things in JavaScript.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`采用目标的值。熟悉`this`的值可能是JavaScript中最棘手的事情之一。'
- en: 'ECMAScript-2015 introduces the `let` keyword which can replace the `var` keyword
    for declaring variables. `let` uses block level scoping which is the scoping you''re
    likely to use from most languages. Let''s see an example of how they differ:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript-2015引入了`let`关键字，可以替代`var`关键字来声明变量。`let`使用块级作用域，这是大多数语言中常用的作用域。让我们看一个它们之间的例子：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the var scoped version you can see that the variable lives on outside of
    the block. This is because behind the scenes the declaration of `varScoped` is
    hoisted to the beginning of the code block. With the `let` scoped version of the
    code `letScoped` is scoped just within the `for` loop so, once we leave the loop,
    `letScoped` is undefined. When given the option of using `let` or `var` we would
    tend to err on the side of always using `let` . There are some cases when you
    actually would want to use var scoping but they are few and far between.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用var作用域版本，您可以看到变量在块外继续存在。这是因为在幕后，`varScoped`的声明被提升到代码块的开头。在代码的`let`作用域版本中，`letScoped`仅在`for`循环内部作用域，因此一旦离开循环，`letScoped`就变为未定义。在使用`let`或`var`的选择时，我们倾向于始终使用`let`。有些情况下，您确实希望使用var作用域，但这些情况寥寥无几。
- en: 'We have built up a pretty complete model of how to build objects within JavaScript.
    However, objects are not the same thing as classes. Objects are instances of classes.
    If we want to create multiple instances of our `functionObject` object we''re
    out of luck. Attempting to do so will result in an error. In the case of Node.js
    the error will be as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建立了一个相当完整的模型，来展示如何在JavaScript中构建对象。但是，对象并不等同于类。对象是类的实例。如果我们想要创建多个`functionObject`对象的实例，我们就没那么幸运了。尝试这样做将导致错误。在Node.js的情况下，错误将如下所示：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The stack trace here shows an error in a module called `repl` . This is the
    read-execute-print loop that is loaded by default when starting Node.js.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的堆栈跟踪显示了一个名为`repl`的模块中的错误。这是在启动Node.js时默认加载的读取-执行-打印循环。
- en: 'Each time that a new instance is required, the object must be reconstructed.
    To get around this we can define the object using a function as can be seen here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每次需要一个新实例时，都必须重新构建对象。为了避免这种情况，我们可以使用函数来定义对象，就像这样：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This syntax allows for a constructor to be defined and for new objects to be
    created from this function. Constructors without return values are functions that
    are called as an object is created. In JavaScript the constructor actually returns
    the object created. You can even assign internal properties using the constructor
    by making them part of the initial function like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法允许定义构造函数，并从该函数创建新对象。没有返回值的构造函数是在创建对象时调用的函数。在JavaScript中，构造函数实际上返回创建的对象。您甚至可以通过将它们作为初始函数的一部分来使用构造函数来分配内部属性，就像这样：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Build me a prototype
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给我建立一个原型
- en: 'As previously mentioned, there was, until recently, no support for creating
    true classes in JavaScript. While ECMAScript-2015 brings some syntactic sugar
    to classes, the underlying object system is still as it has been in the past,
    so it remains instructive to see how we would have created objects without this
    sugar. Objects created using the structure in the previous section have a fairly
    major drawback: creating multiple objects is not only time consuming but also
    memory intensive. Each object is completely distinct from other objects created
    in the same fashion. This means that the memory used to hold the function definitions
    is not shared between all instances. What is even more fun is that you can redefine
    individual instances of a class without changing all of the instances. This is
    demonstrated in this code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，直到最近，JavaScript没有支持创建真正的类。虽然ECMAScript-2015为类带来了一些语法糖，但底层的对象系统仍然与过去一样，因此看到我们如何在没有这些语法糖的情况下创建对象仍然具有指导意义。使用前一节中的结构创建的对象有一个相当大的缺点：创建多个对象不仅耗时，而且占用内存。以相同方式创建的每个对象都是完全独立的。这意味着用于保存函数定义的内存不会在所有实例之间共享。更有趣的是，您甚至可以重新定义类的单个实例，而不改变所有实例。这在这段代码中得到了证明：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Altering the functionality of a single instance or really of any already defined
    object in this fashion is known as **monkey** **patching** . There is some division
    over whether or not this is a good practice. It can certainly be useful when dealing
    with library code but it adds great confusion. It is generally considered better
    practice to extend the existing class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式改变单个实例的功能，或者实际上是以任何已定义的对象的方式，被称为**monkey** **patching**。人们对这是否是一种良好的做法存在分歧。在处理库代码时，它肯定是有用的，但它会带来很大的混乱。通常认为更好的做法是扩展现有类。
- en: 'Without a proper class system JavaScript, of course, has no concept of inheritance.
    However, it does have a prototype. At the most basic level an object in JavaScript
    is an associative array of keys and values. Each property or function on an object
    is simply defined as part of this array. You can even see this in action by accessing
    members of an object using array syntax as is shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有适当的类系统的情况下，JavaScript当然没有继承的概念。但是，它确实有一个原型。在JavaScript中，对象在最基本的层面上是一个键和值的关联数组。对象上的每个属性或函数都简单地定义为这个数组的一部分。您甚至可以通过使用数组语法访问对象的成员来看到这一点，就像这里所示的那样：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Accessing members of an object using array syntax can be a very handy way to
    avoid using the eval function. For instance, if I had the name of the function
    I wanted to call in a string called `funcName` and I wanted to call it on an object,
    `obj1` , then I could do so by doing `obj1[funcName]()` instead of using a potentially
    dangerous call to eval. Eval allows for arbitrary code to be executed. Allowing
    this on a page means that an attacker may be able to enter malicious scripts on
    other people's browsers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组语法访问对象的成员可以是一种非常方便的方法，可以避免使用eval函数。例如，如果我有一个名为`funcName`的字符串，我想在对象`obj1`上调用它，那么我可以这样做`obj1[funcName]()`，而不是使用可能危险的eval调用。Eval允许执行任意代码。在页面上允许这样做意味着攻击者可能能够在其他人的浏览器上输入恶意脚本。
- en: 'When an object is created, its definition is inherited from a prototype. Weirdly
    each prototype is also an object so even prototypes have prototypes. Well, except
    for the object which is the top-level prototype. The advantage to attaching functions
    to the prototype is that only a single copy of the function is created; saving
    on memory. There are some complexities to prototypes but you can certainly survive
    without knowing about them. To make use of a prototype you need to simply assign
    functions to it as is shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建对象时，它的定义是从原型继承的。奇怪的是，每个原型也是一个对象，所以甚至原型也有原型。好吧，除了作为顶级原型的对象。将函数附加到原型的优势在于只创建一个函数的副本；节省内存。原型有一些复杂性，但您肯定可以在不了解它们的情况下生存。要使用原型，您只需将函数分配给它，如下所示：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: One thing to note is that only the functions are assigned to the prototype.
    Instance variables such as `name` are still assigned to the instance. As these
    are unique to each instance there is no real impact on the memory usage.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件事是只有函数分配给原型。诸如`name`之类的实例变量仍然分配给实例。由于这些对每个实例都是唯一的，因此对内存使用没有真正的影响。
- en: In many ways a prototypical language is more powerful than a class-based inheritance
    model.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，原型语言比基于类的继承模型更强大。
- en: 'If you make a change to the prototype of an object at a later date then all
    the objects which share that prototype are updated with the new function. This
    removes some of the concerns expressed about monkey typing. An example of this
    behavior is shown here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以后更改对象的原型，则共享该原型的所有对象都将使用新函数进行更新。这消除了关于猴子打字的一些担忧。此行为的示例如下：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When building up objects you should be sure to take advantage of the prototype
    object whenever possible.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建对象时，您应该确保尽可能利用原型对象。
- en: 'Now we know about prototypes there is an alternative approach to building objects
    in JavaScript and that is to use the `Object.create` function. This is a new syntax
    introduced in ECMAScript 5\. The syntax is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了原型，JavaScript中构建对象的另一种方法是使用`Object.create`函数。这是ECMAScript 5中引入的新语法。语法如下：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The create syntax will build a new object based on the given prototype. You
    can also pass in a `propertiesObject` object that describes additional fields
    on the created object. These descriptors consist of a number of optional fields:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建语法将基于给定的原型构建一个新对象。您还可以传递一个`propertiesObject`对象，该对象描述了创建的对象上的附加字段。这些描述符包括许多可选字段：
- en: '`writable` : This dictates whether the field should be writable'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`可写`：这决定了字段是否可写'
- en: '`configurable` : This dictates whether the files should be removable from the
    object or support further configuration after creation'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`可配置`：这决定了文件是否应该从对象中移除或在创建后支持进一步配置'
- en: '`enumerable` : This dictates whether the property can be listed during an enumeration
    of the object''s properties'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`可枚举`：这决定了属性在对象属性枚举期间是否可以被列出'
- en: '`value` : This dictates the default value of the field'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`值`：这决定了字段的默认值'
- en: It is also possible to assign a `get` and `set` functions within the descriptor
    that act as getters and setters for some other internal property.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在描述符中分配`get`和`set`函数，这些函数充当其他内部属性的getter和setter。
- en: 'Using `object.create` for our castle we can build an instance using `Object.create`
    like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`object.create`为我们的城堡，我们可以像这样使用`Object.create`构建一个实例：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You''ll notice that we explicitly define the `name` field. `Object.create`
    bypasses the constructor so the initial assignment we described in the preceding
    code won''t be called. You might also notice that writeable is set to `false`
    . The result of this is that the reassignment of `name` to `Highgarden` has no
    effect. The output is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们明确定义了`name`字段。`Object.create`绕过了构造函数，因此我们在前面的代码中描述的初始赋值不会被调用。您可能还注意到`writeable`设置为`false`。其结果是对`name`的重新分配为`Highgarden`没有效果。输出如下：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Inheritance
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: One of the niceties of objects is that they can be built upon to create increasingly
    complex objects. This is a common pattern, which is used for any number of things.
    There is no inheritance in JavaScript because of its prototypical nature. However,
    you can combine functions from one prototype into another.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的一个好处是可以构建更复杂的对象。这是一个常见的模式，用于任何数量的事情。JavaScript中没有继承，因为它是原型的性质。但是，您可以将一个原型中的函数组合到另一个原型中。
- en: 'Let''s say that we have a base class called `Castle` and we want to customize
    it into a more specific class called `Winterfell` . We can do so by first copying
    all of the properties from the `Castle` prototype onto the `Winterfell` prototype.
    This can be done like so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`Castle`的基类，并且我们想将其定制为一个更具体的类`Winterfell`。我们可以通过首先将所有属性从`Castle`原型复制到`Winterfell`原型来实现。可以这样做：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Of course this is a very painful way to build objects. You''re forced to know
    exactly which functions the base class has to copy them. It can be abstracted
    in a rather naïve fashion like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一种非常痛苦的构建对象的方式。您被迫确切地知道基类有哪些函数来复制它们。可以像这样天真地抽象化：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you are into object diagrams this shows how **Winterfell** extends **Castle**
    in this diagram:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对对象图表感兴趣，这显示了**Winterfell**在这个图表中如何扩展**Castle**：
- en: '![Inheritance](Image00004.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![继承](Image00004.jpg)'
- en: 'This can be used quite simply as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以很简单地使用如下：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We say that this is naïve because it fails to take into account a number of
    potential failure conditions. A fully-fledged implementation is quite extensive.
    The jQuery library provides a function called `extend` which implements prototype
    inheritance in a robust fashion. It is about 50 lines long and deals with deep
    copies and null values. The function is used extensively, internally in jQuery
    but it can be a very useful function in your own code. We mentioned that prototype
    inheritance is more powerful than the traditional methods of inheritance. This
    is because it is possible to mix and match bits from many base classes to create
    a new class. Most modern languages only support single inheritance: a class can
    have only one direct parent. There are some languages with multiple inheritance
    however, it is a practice that adds a great deal of complexity when attempting
    to decide which version of a method to call at runtime. Prototype inheritance
    avoids many of these issues by forcing selection of a method at assembly time.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说这是天真的，因为它没有考虑到许多潜在的失败条件。一个完整的实现是相当广泛的。jQuery库提供了一个名为`extend`的函数，它以健壮的方式实现了原型继承。它大约有50行代码，处理深层复制和空值。这个函数在jQuery内部被广泛使用，但它也可以成为你自己代码中非常有用的函数。我们提到原型继承比传统的继承方法更强大。这是因为可以从许多基类中混合和匹配位来创建一个新的类。大多数现代语言只支持单一继承：一个类只能有一个直接的父类。有一些语言支持多重继承，然而，这是一种在运行时决定调用哪个版本的方法时增加了很多复杂性的做法。原型继承通过在组装时强制选择方法来避免许多这些问题。
- en: Composing objects in this fashion permits taking properties from two or more
    different bases. There are many times when this can be useful. For example a class
    representing a wolf might take some of its properties from a class describing
    a dog and some from another class describing a quadruped.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式组合对象允许从两个或更多不同的基类中获取属性。有许多时候这是很有用的。例如，代表狼的类可能从描述狗的类和描述四足动物的另一个类中获取一些属性。
- en: By using classes built in this way we can meet pretty much all of the requirements
    for constructing a system of classes including inheritance. However inheritance
    is a very strong form of coupling. In almost all cases it is better to avoid inheritance
    in favor of a looser form of coupling. This will allow for classes to be replaced
    or altered with a minimum impact on the rest of the system.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用以这种方式构建的类，我们可以满足几乎所有构建类系统包括继承的要求。然而，继承是一种非常强的耦合形式。在几乎所有情况下，最好避免继承，而选择一种更松散的耦合形式。这将允许类在对系统的其余部分影响最小的情况下被替换或更改。
- en: Modules
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: Now that we have a complete class system it would be good to address the global
    namespace discussed earlier. Again there is no first class support for namespaces
    but we can easily isolate functionality to the equivalent of a namespace. There
    are a number of different approaches to creating modules in JavaScript. We'll
    start with the simplest and add some functionality as we go along.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个完整的类系统，很好地解决了之前讨论过的全局命名空间问题。同样，JavaScript没有对命名空间的一流支持，但我们可以很容易地将功能隔离到等同于命名空间的东西中。在JavaScript中有许多不同的创建模块的方法。我们将从最简单的开始，并随着进展逐渐添加一些功能。
- en: 'To start we simply need to attach an object to the global namespace. This object
    will contain our root namespace. We''ll name our namespace `Westeros` ; the code
    simply looks like:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只需要将一个对象附加到全局命名空间。这个对象将包含我们的根命名空间。我们将命名我们的命名空间为`Westeros`；代码看起来就像这样：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This object is, by default, attached to the top level object so we need not
    do anything more than that. A typical usage is to first check if the object already
    exists and use that version instead of reassigning the variable. This allows you
    to spread your definitions over a number of files. In theory you could define
    a single class in each file and then bring them all together as part of the build
    process before delivering them to the client or using them in an application.
    The short form of this is:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象默认附加到顶层对象，所以我们不需要做更多的事情。一个典型的用法是首先检查对象是否已经存在，然后使用该版本而不是重新分配变量。这允许你将你的定义分散在许多文件中。理论上，你可以在每个文件中定义一个单一的类，然后在交付给客户或在应用程序中使用之前，在构建过程的一部分将它们全部汇集在一起。这个简短的形式是：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once we have the object, it is simply a question of assigning our classes as
    properties of that object. If we continue to use the `Castle` object then it would
    look like:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个对象，只需要将我们的类分配为该对象的属性。如果我们继续使用`Castle`对象，那么它看起来会像这样：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we want to build a hierarchy of namespaces that is more than a single level
    deep, that too is easily accomplished, as seen in this code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要构建一个多于单层深度的命名空间层次结构，也很容易实现，就像这段代码中所示的那样：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This class can be instantiated and used in a similar way to previous examples:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以被实例化并且以类似于之前例子的方式使用：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Of course with JavaScript there is more than one way to build the same code
    structure. An easy way to structure the preceding code is to make use of the ability
    to create and immediately execute a function:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用JavaScript有多种构建相同代码结构的方法。构建前面的代码的一种简单方法是利用创建并立即执行函数的能力：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This code seems to be a bit longer than the previous code sample but I find
    it easier to follow due to its hierarchical nature. We can create a new castle
    using them in the same structure as shown in the preceding code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码似乎比之前的代码示例要长一些，但由于其分层性质，我觉得更容易理解。我们可以像前面的代码中所示的那样，在相同的结构中使用它们来创建一个新的城堡：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Inheritance using this structure is also relatively easily done. If we were
    to define a `BaseStructure` class which was to be in the ancestor of all structures,
    then making use of it would look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构进行继承也相对容易。如果我们定义了一个`BaseStructure`类，它是所有结构的祖先，那么使用它会像这样：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You''ll note that the base structure is passed into the `Castle` object when
    the closure is evaluated. The highlighted line of code makes use of a helper method
    called `__extends` . This method is responsible for copying the functions over
    from the base prototype to the derived class. This particular piece of code was
    generated from a TypeScript compiler which also, helpfully, generated an `extends`
    method which looks like:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，当闭包被评估时，基本结构被传递到`Castle`对象中。代码中的高亮行使用了一个叫做`__extends`的辅助方法。这个方法负责将函数从基本原型复制到派生类中。这段特定的代码是由TypeScript编译器生成的，它还生成了一个看起来像这样的`extends`方法：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can continue the rather nifty closure syntax we''ve adopted for a class
    to implement an entire module. This is shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续使用我们采用的相当巧妙的闭包语法来实现整个模块。如下所示：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Within this structure you can see the same code for creating modules that we
    explored earlier. It is also relatively easy to define multiple classes inside
    a single module. This can be seen in this code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，您可以看到我们之前探讨过的创建模块的相同代码。在单个模块中定义多个类也相对容易。这可以在这段代码中看到：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The highlighted code creates a second class inside of the module. It is also
    perfectly permissible to define one class in each file. Because the code checks
    to get the current value of `Westeros` before blindly reassigning it, we can safely
    split the module definition across multiple files.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮代码在模块内创建了第二个类。在每个文件中定义一个类也是完全允许的。因为代码在盲目重新分配之前检查`Westeros`的当前值，所以我们可以安全地将模块定义分割成多个文件。
- en: The last line of the highlighted section shows exposing the class outside of
    the closure. If we want to make private classes that are only available within
    the module then we only need to exclude that line. This is actually known as the
    revealing module pattern. We only reveal the classes that need to be globally
    available. It is a good practice to keep as much functionality out of the global
    namespace as possible.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮部分的最后一行显示了在闭包之外暴露类。如果我们想要创建只在模块内部可用的私有类，那么我们只需要排除那一行。这实际上被称为揭示模块模式。我们只暴露需要全局可用的类。尽可能将功能保持在全局命名空间之外是一个很好的做法。
- en: ECMAScript 2015 classes and modules
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript 2015类和模块
- en: 'We''ve seen so far that it is perfectly possible to build classes and even
    modules in pre ECMAScript -2015 JavaScript. The syntax is, obviously, a bit more
    involved than in a language such as C# or Java. Fortunately ECMAScript-2015, brings
    support for some syntactic sugar for making classes:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到在ECMAScript-2015之前的JavaScript中完全可以构建类甚至模块。显然，这种语法比如C#或Java等语言更复杂。幸运的是，ECMAScript-2015为创建类提供了一些语法糖的支持：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'ECMAScript-2015 also brings a well thought out module system for JavaScript.
    There''s also syntactic sugar for creating modules which looks like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript-2015还为JavaScript带来了一个经过深思熟虑的模块系统。还有一些用于创建模块的语法糖，看起来像这样：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As modules can contain functions they can, of course, contain classes. ECMAScript-2015
    also defines a module import syntax and support for retrieving modules from remote
    locations. Importing a module looks like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块可以包含函数，当然也可以包含类。ECMAScript-2015还定义了模块导入语法和支持从远程位置检索模块。导入模块看起来像这样：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Some of this syntactic sugar is available in any environment which has full
    ECMAScript-2015 support. At the time of writing, all major browser vendors have
    very good support for the class portion of ECMAScript-2015 so there is almost
    no reason not to use it if you don't have to support ancient browsers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这种语法糖在任何支持完整ECMAScript-2015的环境中都是可用的。在撰写本文时，所有主要浏览器供应商对ECMAScript-2015的类部分都有很好的支持，所以几乎没有理由不使用它，除非你不得不支持古老的浏览器。
- en: Best practices and troubleshooting
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践和故障排除
- en: In an ideal world everybody would get to work on greenfield projects where they
    can put in standards right from the get go. However that isn't the case. Frequently
    you may find yourself in a situation where you have a bunch of non-modular JavaScript
    code as part of a legacy system.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界中，每个人都可以在从一开始就制定标准的绿地项目上工作。然而，情况并非如此。经常情况下，你可能会发现自己处于一个遗留系统的一部分，其中有一堆非模块化的JavaScript代码。
- en: In these situations it may be advantageous to simply ignore the non-modular
    code until there is an actual need to upgrade it. Despite the popularity of JavaScript,
    much of the tooling for JavaScript is still immature making it difficult to rely
    on a compiler to find errors introduced by JavaScript refactoring. Automatic refactoring
    tools are also complicated by the dynamic nature of JavaScript. However, for new
    code, proper use of modular JavaScript can be very helpful to avoid namespace
    conflicts and improve testability.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，简单地忽略非模块化的代码直到真正需要升级它可能是有利的。尽管JavaScript很受欢迎，但JavaScript的许多工具仍然不够成熟，这使得很难依赖编译器来找出JavaScript重构引入的错误。自动重构工具也受到JavaScript动态特性的复杂性的影响。然而，对于新代码，正确使用模块化的JavaScript可以非常有助于避免命名空间冲突并提高可测试性。
- en: How to arrange JavaScript is an interesting question. From a web perspective
    I have taken the approach of arranging my JavaScript in line with the web pages.
    So each page has an associated JavaScript file, which is responsible for the functionality
    of that page. In addition, components which are common between pages, say a grid
    control, are placed into a separate file. At compile time all the files are combined
    into a single JavaScript file. This helps strike a balance between having a small
    code file with which to work and reducing the number of requests to the server
    from the browser.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如何安排JavaScript是一个有趣的问题。从网页的角度来看，我采取了将JavaScript与网页保持一致的方法。因此，每个页面都有一个关联的JavaScript文件，负责该页面的功能。此外，页面之间共同的组件，比如网格控件，被放置在一个单独的文件中。在编译时，所有文件都被合并成一个单独的JavaScript文件。这有助于在保持小型代码文件的同时减少浏览器向服务器发出的请求次数。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: It has been said that there are only two really hard things in computing science.
    What those issues are varies depending on who is speaking. Frequently it is some
    variation of cache invalidation and naming. How to organize your code is a large
    part of that naming problem.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有人说计算机科学中只有两件真正困难的事情。这些问题的具体内容因说话者而异。经常是一些与缓存失效和命名有关的变体。如何组织代码是其中很大一部分的命名问题。
- en: As a group we seem to have settled quite firmly on the idea of namespaces and
    classes. As we've seen, there is no direct support for either of these two concepts
    in JavaScript. However there are myriad ways to work around the problem, some
    of which actually provide more power than one would get through a traditional
    namespace/class system.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个团体，我们似乎已经坚定地接受了命名空间和类的概念。正如我们所见，JavaScript中没有直接支持这两个概念。然而，有无数种方法可以解决这个问题，其中一些方法实际上提供的功能比传统的命名空间/类系统更强大。
- en: The primary concern with JavaScript is to avoid polluting the global namespace
    with a large number of similarly named, unconnected objects. Encapsulating JavaScript
    into modules is a key step on the road toward writing maintainable and reusable
    code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的主要问题是要避免用大量名称相似但不相关的对象污染全局命名空间。将JavaScript封装成模块是朝着编写可维护和可重用代码的关键步骤。
- en: As we move forward we'll see that many of the patterns which are quite complex
    arrangements of interfaces become far simpler in the land of JavaScript. Prototype-based
    inheritance, which seems difficult at the outset, is a tremendous tool for aiding
    in the simplification of design patterns.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的前进，我们会看到许多复杂的接口排列在JavaScript的世界中变得更加简单。原型继承，起初似乎很困难，但它是简化设计模式的巨大工具。
- en: Chapter 3. Creational Patterns
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。创建模式
- en: In the last chapter we took a long look at how to fashion a class. In this chapter
    we'll look at how to create instances of classes. On the surface it seems like
    a simple concern but how we create instances of a class can be of great importance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们详细研究了如何构建一个类。在本章中，我们将研究如何创建类的实例。表面上看，这似乎是一个简单的问题，但我们如何创建类的实例可能非常重要。
- en: We take great pains in creating our code so that it be as decoupled as possible.
    Ensuring that classes have minimal dependence on other classes is the key to building
    a system that can change fluently with the changing needs of those using the software.
    Allowing classes to be too closely related means that changes ripple through them
    like, well, ripples.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常努力地创建我们的代码，使其尽可能解耦。确保类对其他类的依赖最小是构建一个可以随着使用软件的人的需求变化而流畅变化的系统的关键。允许类之间关系过于紧密意味着变化会像涟漪一样在它们之间传播。
- en: 'One ripple isn''t a huge problem but, as you throw more and more changes into
    the mix, the ripples add up and create interference patterns. Soon the once placid
    surface is an unrecognizable mess of additive and destructive nodes. This same
    problem occurs in our applications: the changes magnify and interact in unexpected
    ways. One place where we tend to forget about coupling is in the creation of objects:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个涟漪并不是一个巨大的问题，但随着你不断引入更多的变化，涟漪会累积并产生干涉模式。很快，曾经平静的表面就变成了无法辨认的添加和破坏节点的混乱。我们的应用程序中也会出现同样的问题：变化会放大并以意想不到的方式相互作用。我们经常忽视耦合的一个地方就是在对象的创建中：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can see in this class that the Ruler''s house is strongly coupled to the
    class `Targaryen` . If this were ever to change then this tight coupling would
    have to change in a great number of places. This chapter discusses a number of
    patterns, which were originally presented in the gang of four book, *Design Patterns:
    Elements of Reusable Object-Oriented Software* . The goal of these patterns is
    to improve the degree of coupling in applications and increase the opportunities
    for code reuse. The patterns are as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，你可以看到统治者的家与`Targaryen`类紧密耦合。如果这种情况发生改变，那么这种紧密耦合就必须在很多地方进行改变。本章讨论了一些模式，这些模式最初是在《设计模式：可复用面向对象软件的元素》一书中提出的。这些模式的目标是改善应用程序中的耦合程度，并增加代码重用的机会。这些模式如下：
- en: Abstract factory
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: Builder
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建造者
- en: Factory method
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法
- en: Singleton
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: Prototype
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型
- en: Of course not all of these are applicable to JavaScript, but we'll see all about
    that as we work through the creational patterns.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非所有这些都适用于JavaScript，但随着我们逐步了解创建模式，我们会了解到这一切。
- en: Abstract factory
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: The first pattern presented here is a method for creating kits of objects without
    knowing the concrete types of the objects. Let's continue with the system presented
    in the preceding section for ruling a kingdom.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍的第一个模式是一种创建对象套件的方法，而不需要知道对象的具体类型。让我们继续使用前一节中介绍的统治王国的系统。
- en: For the kingdom in question the ruling house changes with some degree of frequency.
    In all likelihood there is a degree of battling and fighting during the change
    of house but we'll ignore that for the moment. Each house will rule the kingdom
    differently. Some value peace and tranquility and rule as benevolent leaders,
    while others rule with an iron fist. The rule of a kingdom is too large for a
    single individual so the king defers some of his decisions to a second in command
    known as the hand of the king. The king is also advised on matters by a council,
    which consists of some of the more savvy lords and ladies of the land.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所讨论的王国，统治家族的更换频率相当高。很可能在更换家族时会有一定程度的战斗和斗争，但我们暂且不予理会。每个家族都会以不同的方式统治王国。有些人看重和平与宁静，以仁慈的领导者统治，而另一些则以铁腕统治。一个王国的统治对于一个人来说太大了，所以国王会将一些决定交给一个叫做国王之手的副手。国王也会在一些事务上得到一个由一些精明的领主和贵妇组成的议会的建议。
- en: 'A diagram of the classes in our description look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述的类的图表如下：
- en: '![Abstract factory](Image00005.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![抽象工厂](Image00005.jpg)'
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Unified Modeling Language** ( **UML** ) is a standardized language developed
    by the Object Management Group, which describes computer systems. There is vocabulary
    in the language for creating user interaction diagrams, sequence diagrams, and
    state machines, amongst others. For the purposes of this book we''re most interested
    in class diagrams, which describe the relationship between a set of classes.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一建模语言**（**UML**）是由对象管理组开发的标准化语言，用于描述计算机系统。该语言中有用于创建用户交互图、序列图和状态机等的词汇。对于本书的目的，我们最感兴趣的是类图，它描述了一组类之间的关系。'
- en: The entire UML class diagram vocabulary is extensive and is beyond the scope
    of this book. However, the Wikipedia article available at [https://en.wikipedia.org/wiki/Class_diagram](https://en.wikipedia.org/wiki/Class_diagram)
    acts as a great introduction as does Derek Banas' excellent video tutorial on
    class diagrams available at [https://www.youtube.com/watch?v=3cmzqZzwNDM](https://www.youtube.com/watch?v=3cmzqZzwNDM)
    .
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 整个UML类图词汇量很大，超出了本书的范围。然而，维基百科上的文章[https://en.wikipedia.org/wiki/Class_diagram](https://en.wikipedia.org/wiki/Class_diagram)以及Derek
    Banas的优秀视频教程[https://www.youtube.com/watch?v=3cmzqZzwNDM](https://www.youtube.com/watch?v=3cmzqZzwNDM)都是很好的介绍。
- en: An issue is that, with the ruling family, and even the member of the ruling
    family on the throne, changing so frequently, coupling to a concrete family such
    as Targaryen or Lannister makes our application brittle. Brittle applications
    do not fare well in an ever-changing world.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，由于统治家族甚至统治家族成员经常变动，与Targaryen或Lannister等具体家族耦合会使我们的应用程序变得脆弱。脆弱的应用程序在不断变化的世界中表现不佳。
- en: An approach to fixing this is to make use of the abstract factory pattern. The
    abstract factory declares an interface for creating each of the various classes
    related to the ruling family.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是利用抽象工厂模式。抽象工厂声明了一个接口，用于创建与统治家族相关的各种类。
- en: 'The class diagram of this pattern is rather daunting:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的类图相当令人生畏：
- en: '![Abstract factory](Image00006.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![抽象工厂](Image00006.jpg)'
- en: The abstract factory class may have multiple implementations for each of the
    various ruling families. These are known as concrete factories and each of them
    will implement the interface provided by the abstract factory. The concrete factories,
    in return, will return concrete implementations of the various ruling classes.
    These concrete classes are known as products.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂类可能对统治家族的各个实现有多个。这些被称为具体工厂，它们每个都将实现抽象工厂提供的接口。具体工厂将返回各种统治类的具体实现。这些具体类被称为产品。
- en: Let's start by looking at the code for the interface for the abstract factory.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下抽象工厂接口的代码。
- en: 'No code? Well, actually that is exactly the case. JavaScript''s dynamic nature
    precludes the need for interfaces to describe classes. Instead of having interfaces
    we''ll just create the classes right off the bat:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 没有代码？实际上确实如此。JavaScript的动态特性消除了描述类所需的接口的需要。我们将直接创建类，而不是使用接口：
- en: '![Abstract factory](Image00007.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![抽象工厂](Image00007.jpg)'
- en: Instead of interfaces, JavaScript trusts that the class you provide implements
    all the appropriate methods. At runtime the interpreter will attempt to call the
    method you request and, if it is found, call it. The interpreter simply assumes
    that if your class implements the method then it is that class. This is known
    as **duck typing** .
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript不使用接口，而是相信您提供的类实现了所有适当的方法。在运行时，解释器将尝试调用您请求的方法，并且如果找到该方法，就会调用它。解释器只是假设如果您的类实现了该方法，那么它就是该类。这就是所谓的**鸭子类型**。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Duck typing**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**鸭子类型**'
- en: 'The name duck typing comes from a 2000 post to the *comp.lang.python* news
    group by Alex Martelli in which he wrote:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型的名称来源于Alex Martelli在2000年发布的一篇文章，他在*comp.lang.python*新闻组中写道：
- en: '*In other words, don''t check whether it IS-a duck: check whether it QUACKS-like-a
    duck, WALKS-like-a duck, and so on, depending on exactly what subset of duck-like
    behavior you need to play your language-games with.*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*换句话说，不要检查它是否是一只鸭子：检查它是否像一只鸭子一样嘎嘎叫，像一只鸭子一样走路，等等，具体取决于您需要用来玩语言游戏的鸭子行为的子集。*'
- en: I enjoy the possibility that Martelli took the term from the witch-hunt sketch
    from *Monty Python and the Holy Grail* . Although I can find no evidence of that,
    I think it quite likely as the Python programming language takes its name from
    Monty Python.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢Martelli可能是从*Monty Python and the Holy Grail*的巫师狩猎片段中借用了这个术语。虽然我找不到任何证据，但我认为这很可能，因为Python编程语言的名称就来自于Monty
    Python。
- en: 'Duck typing is a powerful tool in dynamic languages allowing for much less
    overhead in implementing a class hierarchy. It does, however, introduce some uncertainty.
    If two classes implement an identically named method which have radically different
    meanings then there is no way to know if the one being called is the correct one.
    Consider for example this code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型是动态语言中的强大工具，可以大大减少实现类层次结构的开销。然而，它确实引入了一些不确定性。如果两个类实现了具有根本不同含义的同名方法，那么就无法知道调用的是正确的方法。例如，考虑以下代码：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Both classes have a `punch()` method but they clearly have different meanings.
    The JavaScript interpreter has no idea that they are different classes and will
    happily call punch on either class, even when one doesn't make sense.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类都有一个`punch()`方法，但显然意义不同。JavaScript解释器不知道它们是不同的类，并且会愉快地在任何一个类上调用punch，即使其中一个没有意义。
- en: Some dynamic languages support a generic method, which is called whenever an
    undefined method is called. Ruby, for instance, has `missing_method` , which has
    proven to be very useful in a number of scenarios. As of writing, there is currently
    no support for `missing_method` in JavaScript. However, ECMAScript 2016, the follow
    up to ECMAScript 2015, defines a new construct called `Proxy` which will support
    dynamically wrapping objects, with this one could implement an equivalent of `missing_method`
    .
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一些动态语言支持一种通用方法，当调用未定义的方法时会调用该方法。例如，Ruby有`missing_method`，在许多情况下都被证明非常有用。截至目前，JavaScript目前不支持`missing_method`。然而，ECMAScript
    2016，即ECMAScript 2015的后续版本，定义了一个称为`Proxy`的新构造，它将支持动态包装对象，借助它可以实现一个等价的`missing_method`。
- en: Implementation
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'To demonstrate an implementation of the Abstract Factory the first thing we''ll
    need is an implementation of the `King` class. This code provides that implementation:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示抽象工厂的实现，我们首先需要一个`King`类的实现。这段代码提供了该实现：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This code does not include the module structure suggested in [Chapter 2](text00019.html#page
    "Chapter 2. Organizing Code") , *Organizing Code* . Including the boiler-plate
    module code in every example is tedious and you're all smart cookies so you know
    to put this in modules if you're going to actually use it. The fully modularized
    code is available in the distributed source code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不包括[第2章](text00019.html#page "第2章。组织代码")*组织代码*中建议的模块结构。在每个示例中包含模块代码是乏味的，你们都是聪明的人，所以如果你们要真正使用它，就知道把它放在模块中。完全模块化的代码可以在分发的源代码中找到。
- en: 'This is just a regular concrete class and could really contain any implementation
    details. We''ll also need an implementation of the `HandOfTheKing` class which
    is equally unexciting:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个普通的具体类，实际上可以包含任何实现细节。我们还需要一个同样不起眼的`HandOfTheKing`类的实现：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The concrete factory method looks like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的工厂方法如下：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This code simply instantiates new instances of each of the required classes
    and returns them. An alternative implementation for a different ruling family
    would follow the same general form and might look like:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只是实例化所需类的新实例并返回它们。不同统治家族的另一种实现将遵循相同的一般形式，可能如下所示：
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The implementation of the Abstract Factory in JavaScript is much easier than
    in other languages. However the penalty for this is that you lose the compiler
    checks, which force a full implementation of either the factory or the products.
    As we proceed through the rest of the patterns, you'll notice that this is a common
    theme. Patterns that have a great deal of plumbing in statically typed languages
    are far simpler but create a greater risk of runtime failure. Appropriate unit
    tests or a JavaScript compiler can ameliorate this situation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中实现抽象工厂比其他语言要容易得多。然而，这样做的代价是失去了编译器检查，它强制要求对工厂或产品进行完整的实现。随着我们继续学习其他模式，你会注意到这是一个常见的主题。在静态类型语言中有很多管道的模式要简单得多，但会增加运行时失败的风险。适当的单元测试或JavaScript编译器可以缓解这种情况。
- en: 'To make use of the Abstract Factory we''ll first need a class that requires
    the use of some ruling family:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用抽象工厂，我们首先需要一个需要使用某个统治家族的类：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can now call this `CourtSession` class and inject different functionality
    depending on which factory we pass in:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用这个`CourtSession`类，并根据传入的工厂注入不同的功能：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Despite the differences between a static language and JavaScript, this pattern
    remains applicable and useful in JavaScript applications. Creating a kit of objects,
    which work together, is useful in a number of situations; any time a group of
    objects need to collaborate to provide functionality but may need to be replaced
    wholesale. It may also be a useful pattern when attempting to ensure that a set
    of objects be used together without substitutions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管静态语言和JavaScript之间存在差异，但这种模式在JavaScript应用程序中仍然适用且有用。创建一组共同工作的对象对于许多情况都是有用的；每当一组对象需要协作提供功能但可能需要整体替换时。当试图确保一组对象一起使用而不进行替换时，这也可能是一个有用的模式。
- en: Builder
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建造者
- en: In our fictional world we sometimes have some rather complicated classes, which
    need to be constructed. The classes contain different implementations of an interface
    depending on how they are constructed. In order to simplify the building of these
    classes and encapsulate the knowledge about building the class away from the consumers,
    a builder may be used. Multiple concrete builders reduce the complexity of the
    constructor in the implementation. When new builders are required, a constructor
    does not need to be added, a new builder just needs to be plugged in.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的虚构世界中，有时需要构建一些相当复杂的类。这些类包含了根据构建方式不同的接口实现。为了简化这些类的构建并将构建类的知识封装在消费者之外，可以使用建造者。多个具体建造者降低了实现中构造函数的复杂性。当需要新的建造者时，不需要添加构造函数，只需要插入一个新的建造者。
- en: 'Tournaments are an example of a complicated class. Each tournament has a complicated
    setup involving the events, the attendees, and the prizes. Much of the setup for
    these tournaments is similar: each one has a joust, archery, and a melee. Creating
    a tournament from multiple places in the code means that the responsibility for
    knowing how to construct a tournament is distributed. If there is a need to change
    the initiation code then it must be done in a lot of different places.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 锦标赛是一个复杂类的例子。每个锦标赛都有一个复杂的设置，涉及事件、参与者和奖品。这些锦标赛的大部分设置都是相似的：每一个都有比武、射箭和混战。从代码中的多个位置创建锦标赛意味着构建锦标赛的责任被分散。如果需要更改初始化代码，那么必须在许多不同的地方进行更改。
- en: 'Employing a builder pattern avoids this issue by centralizing the logic necessary
    to build the object. Different concrete builders can be plugged into the builder
    to construct different complicated objects. The relationship between the various
    classes in the builder pattern is shown here:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用构建器模式，可以避免这个问题，因为它集中了构建对象所需的逻辑。不同的具体构建器可以插入到构建器中，以构建不同的复杂对象。构建器模式中各个类之间的关系如下所示：
- en: '![Builder](Image00008.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![构建器](Image00008.jpg)'
- en: Implementation
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'Let''s drop in and look at some of the code. To start with, we''ll create a
    number of utility classes, which will represent the parts of a tournament as shown
    in the following code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进去看一些代码。首先，我们将创建一些实用类，它们将表示比赛的各个部分，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The tournament itself is a very simple class as we don''t need to assign any
    of the public properties explicitly:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 比赛本身是一个非常简单的类，因为我们不需要显式地分配任何公共属性：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We''ll implement two builders which create different tournaments. This can
    be seen in the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现两个创建不同比赛的构建器。下面的代码中可以看到：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally the director, or as we''re calling it `TournamentBuilder` , simply
    takes a builder and executes it:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，导演，或者我们称之为`TournamentBuilder`，只需拿起一个构建器并执行它：
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Again you'll see that the JavaScript implementation is far simpler than the
    traditional implementation due to there being no need for interfaces.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您会看到JavaScript的实现比传统的实现要简单得多，因为不需要接口。
- en: Builders need not return a fully realized object. This means that you can create
    a builder which partially hydrates an object then allows the object to be passed
    on to another builder for it to finish. A good real world analogy might be the
    manufacturing process for a car. Each station along the assembly line builds just
    a part of the car before passing it onto the next station to build another part.
    This approach allows for dividing the work of building an object amongst several
    classes with limited responsibility. In our example above we could have a builder
    that is responsible for populating the events and another that is responsible
    for populating the attendees.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器不需要返回一个完全实现的对象。这意味着您可以创建一个部分填充对象的构建器，然后允许对象传递给另一个构建器来完成。一个很好的现实世界类比可能是汽车的制造过程。在装配线上的每个工位都只组装汽车的一部分，然后将其传递给下一个工位组装另一部分。这种方法允许将构建对象的工作分配给几个具有有限责任的类。在我们上面的例子中，我们可以有一个负责填充事件的构建器，另一个负责填充参与者的构建器。
- en: Does the builder pattern still make sense in view of JavaScript's prototype
    extension model? I believe so. There are still cases where a complicated object
    needs to be created according to different approaches.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript的原型扩展模型中，构建器模式是否仍然有意义？我认为是的。仍然存在需要根据不同的方法创建复杂对象的情况。
- en: Factory method
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法
- en: 'We''ve already looked at the Abstract Factory and a builder. The Abstract Factory
    builds a family of related classes and the builder creates complicated objects
    using different strategies. The factory method pattern allows a class to request
    a new instance of an interface without the class making decisions about which
    implementation of the interface to use. The factory may use some strategy to select
    which implementation to return:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过抽象工厂和构建器。抽象工厂构建了一组相关的类，而构建器使用不同的策略创建复杂对象。工厂方法模式允许类请求接口的新实例，而不是类决定使用接口的哪个实现。工厂可能使用某种策略来选择要返回的实现：
- en: '![Factory method](Image00009.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![工厂方法](Image00009.jpg)'
- en: Sometimes this strategy is simply to take a string parameter or to examine some
    global setting to act as a switch.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这种策略只是接受一个字符串参数或检查一些全局设置来充当开关。
- en: Implementation
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: In our example world of Westeros there are plenty of times when we would like
    to defer the choice of implementation to a factory. Just like the real world,
    Westeros has a vibrant religious culture with dozens of competing religions worshiping
    a wide variety of gods. When praying in each religion, different rules must be
    followed. Some religions demand sacrifices while others demand only that a gift
    be given. The prayer class doesn't want to know about all the different religions
    and how to construct them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Westworld示例世界中，有很多时候我们希望将实现的选择推迟到工厂。就像现实世界一样，Westworld拥有丰富多彩的宗教文化，有数十种不同的宗教崇拜各种各样的神。在每种宗教中祈祷时，必须遵循不同的规则。有些宗教要求献祭，而其他宗教只要求给予礼物。祈祷类不想知道所有不同的宗教以及如何构建它们。
- en: 'Let''s start with creating a number of different gods to which prayers can
    be offered. This code creates three gods including a default god to whom prayers
    fall if no other god is specified:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一些不同的神，可以向他们献祷。这段代码创建了三个神，包括一个默认的神，如果没有指定其他神，祷告就会落在他身上：
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'I''ve avoided any sort of implementation details for each god. You may imagine
    whatever traditions you want to populate the `prayTo` methods. There is also no
    need to ensure that each of the gods implements an `IGod` interface. Next we''ll
    need a factory, which is responsible for constructing each of the different gods:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我避免了为每个神明的任何实现细节。您可以想象任何您想要填充`prayTo`方法的传统。也没有必要确保每个神都实现了`IGod`接口。接下来，我们需要一个工厂，负责构建不同的神：
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can see that in this example we''re taking in a simple string to decide
    how to create a god. It could be done via a global or via a more complicated object.
    In some polytheistic religions in Westeros, gods have defined roles as gods of
    courage, beauty, or some other aspect. The god to which one must pray is determined
    by not just the religion but the purpose of the prayer. We can represent this
    with a `GodDeterminant` class as is shown here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，在这个例子中，我们接受一个简单的字符串来决定如何创建一个神。它可以通过全局或更复杂的对象来完成。在Westeros的一些多神教中，神明有明确定的角色，如勇气之神、美丽之神或其他方面的神。必须祈祷的神不仅由宗教决定，还由祈祷的目的决定。我们可以用`GodDeterminant`类来表示这一点，如下所示：
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The factory would be updated to take this class instead of the simple string.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂将被更新以接受这个类，而不是简单的字符串。
- en: 'Finally, the last step is to see how this factory would be used. It is quite
    simple, we just need to pass in a string that denotes which religion we wish to
    observe and the factory will construct the correct god and return it. This code
    demonstrates how to call the factory:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一步是看看这个工厂将如何被使用。这很简单，我们只需要传入一个表示我们希望观察的宗教的字符串，工厂将构造正确的神并返回它。这段代码演示了如何调用工厂：
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Once again there is certainly need for a pattern such as this in JavaScript.
    There are plenty of times where separating the instantiation from the use is useful.
    Testing the instantiation is also very simple thanks to the separation of concerns
    and the ability to inject a fake factory to allow testing of `Prayer` is also
    easy.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，JavaScript中肯定需要这样的模式。有很多时候，将实例化与使用分开是有用的。由于关注点的分离和注入假工厂以允许测试`Prayer`也很容易，测试实例化也非常简单。
- en: Continuing the trend of creating simpler patterns without interfaces, we can
    ignore the interface portion of the pattern and work directly with the types,
    thanks to duck typing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建不带接口的更简单模式的趋势，我们可以忽略模式的接口部分，直接使用类型，这要归功于鸭子类型。
- en: 'Factory Method is a very useful pattern: it allows classes to defer the selection
    of the implementation of an instantiation to another class. This pattern is very
    useful when there are multiple similar implementations such as the strategy pattern
    (see [Chapter 5](text00044.html#page "Chapter 5. Behavioral Patterns") , *Behavioral
    Patterns* ) and is commonly used in conjunction with the Abstract Factory pattern.
    The Factory Method is used to build the concrete objects within a concrete implementation
    of the abstract factory. An Abstract Factory pattern may contain a number of Factory
    Methods. Factory Method is certainly a pattern that remains applicable in the
    land of JavaScript.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法是一种非常有用的模式：它允许类将实例化的实现选择推迟到另一个类。当存在多个类似的实现时，这种模式非常有用，比如策略模式（参见[第5章](text00044.html#page
    "第5章。行为模式") ，*行为模式*），并且通常与抽象工厂模式一起使用。工厂方法用于在抽象工厂的具体实现中构建具体对象。抽象工厂模式可能包含多个工厂方法。工厂方法无疑是一种在JavaScript领域仍然适用的模式。
- en: Singleton
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例
- en: The Singleton pattern is perhaps the most overused pattern. It is also a pattern
    that has fallen out of favor in recent years. To see why people are starting to
    advise against using Singleton let's take a look at how the pattern works.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式可能是最常被滥用的模式。它也是近年来不受青睐的模式。为了看到为什么人们开始建议不要使用单例模式，让我们看看这个模式是如何工作的。
- en: Singleton is used when a global variable is desirable, but Singleton provides
    protection against accidentally creating multiple copies of complex objects. It
    also allows for the deferral of object instantiation until the first use.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要全局变量时使用单例是可取的，但单例提供了防止意外创建复杂对象的保护。它还允许推迟对象实例化直到第一次使用。
- en: 'The UML diagram for Singleton looks like the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 单例的UML图如下所示：
- en: '![Singleton](Image00010.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![单例](Image00010.jpg)'
- en: It is clearly a very simple pattern. The Singleton acts as a wrapper around
    an instance of the class and the singleton itself lives as a global variable.
    When accessing the instance we simply ask the Singleton for the current instance
    of the wrapped class. If the class does not yet exist within the Singleton it
    is common to create a new instance at that time.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一种非常简单的模式。单例充当类的实例的包装器，单例本身作为全局变量存在。在访问实例时，我们只需向单例请求包装类的当前实例。如果类在单例中尚不存在，通常会在那时创建一个新实例。
- en: Implementation
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: Within our ongoing example in the world of Westeros, we need to find a case
    where there can only ever be one of something. Unfortunately, it is a land with
    frequent conflicts and rivalries, and so my first idea of using the king as the
    Singleton is simply not going to fly. This split also means that we cannot make
    use of any of the other obvious candidates (capital city, queen, general, and
    so on). However, in the far north of Westeros there is a giant wall constructed
    to keep an ancient enemy at bay. There is only one of these walls and it should
    pose no issue having it in the global scope.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在维斯特洛大陆的持续示例中，我们需要找到一个只能有一个东西的情况。不幸的是，这是一个经常发生冲突和敌对的土地，所以我最初想到的将国王作为单例的想法根本行不通。这也意味着我们不能利用其他明显的候选人（首都，王后，将军等）。然而，在维斯特洛大陆的最北部，有一堵巨大的墙，用来阻挡一位古老的敌人。这样的墙只有一堵，将其放在全局范围内应该没有问题。
- en: 'Let''s go ahead and create a singleton in JavaScript:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在JavaScript中创建一个单例：
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The code creates a lightweight representation of the Wall. The Singleton is
    demonstrated in the two highlighted sections. In a language like C# or Java we
    would normally just set the constructor to be private so that it could only be
    called by the static method `getInstance` . However, we don''t have that ability
    in JavaScript: constructors cannot be private. Thus we do the best we can and
    return the current instance from the constructor. This may appear strange but
    in the way we''ve constructed our classes the constructor is no different from
    any other method so it is possible to return something from it.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码创建了墙的轻量级表示。单例在两个突出显示的部分中进行了演示。在像C#或Java这样的语言中，我们通常会将构造函数设置为私有，以便只能通过静态方法`getInstance`来调用它。然而，在JavaScript中我们没有这个能力：构造函数不能是私有的。因此，我们尽力而为，从构造函数中返回当前实例。这可能看起来很奇怪，但在我们构造类的方式中，构造函数与任何其他方法没有区别，因此可以从中返回一些东西。
- en: In the second highlighted section we set a static variable, `_instance` , to
    be a new instance of the Wall when one is not already there. If that `_instance`
    already exists, we return that. In C# and Java, there would need to be some complicated
    locking logic in this function to avoid race conditions as two different threads
    attempted to access the instance at the same time. Fortunately, there is no need
    to worry about this in JavaScript where the multi-threading story is different.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个突出部分中，我们将静态变量`_instance`设置为Wall的新实例（如果还没有）。如果`_instance`已经存在，我们将返回它。在C#和Java中，这个函数需要一些复杂的锁定逻辑，以避免两个不同的线程同时尝试访问实例时出现竞争条件。幸运的是，在JavaScript中不需要担心这个问题，因为多线程的情况不同。
- en: Disadvantages
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: Singletons have gained something of a bad reputation in the last few years.
    They are, in effect, glorified global variables. As we've discussed, global variables
    are ill conceived and the potential cause of numerous bugs. They are also difficult
    to test with unit tests as the creation of the instance cannot easily be overridden
    and any form of parallelism in the test runner can introduce difficult-to-diagnose
    race conditions. The single largest concern I have with them is that singletons
    have too much responsibility. They control not just themselves but also their
    instantiation. This is a clear violation of the single responsibility principle.
    Almost every problem that can be solved by using a Singleton is better solved
    using some other mechanism.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 单例在过去几年中声名狼藉。它们实际上是被吹捧的全局变量。正如我们讨论过的，全局变量是不合理的，可能导致许多错误。它们也很难通过单元测试进行测试，因为实例的创建不能轻易被覆盖，测试运行器中的任何并行性都可能引入难以诊断的竞争条件。我对它们最大的担忧是单例承担了太多的责任。它们不仅控制自己，还控制它们的实例化。这是对单一责任原则的明显违反。几乎每一个可以使用单例解决的问题，都可以通过其他机制更好地解决。
- en: JavaScript makes the problem even worse. It isn't possible to create a clean
    implementation of the Singleton due to the restrictions on the constructor. This,
    coupled with the general problems around the Singleton, lead me to suggest that
    the Singleton pattern should be avoided in JavaScript.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript使问题变得更糟。由于构造函数的限制，无法创建单例的清晰实现。这与单例的一般问题结合在一起，使我建议在JavaScript中应避免使用单例模式。
- en: Prototype
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型
- en: 'The final creational pattern in this chapter is the Prototype pattern. Perhaps
    this name sounds familiar. It certainly should: it is the mechanism through which
    JavaScript inheritance is supported.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的最后一个创建模式是原型模式。也许这个名字听起来很熟悉。它确实应该：这是JavaScript支持继承的机制。
- en: We looked at prototypes for inheritance but the applicability of prototypes
    need not be limited to inheritance. Copying existing objects can be a very useful
    pattern. There are numerous cases where being able to duplicate a constructed
    object is handy. For instance, maintaining a history of the state of an object
    is easily done by saving previous instances created by leveraging some sort of
    cloning.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了用于继承的原型，但原型的适用性不一定局限于继承。复制现有对象可以是一个非常有用的模式。有许多情况下，能够复制构造对象是很方便的。例如，通过保存利用某种克隆创建的先前实例，很容易地维护对象状态的历史。
- en: Implementation
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'In Westeros, we find that members of a family are frequently very similar;
    as the adage goes: "like father, like son". As each generation is born it is easier
    to create the new generation through copying and modifying an existing family
    member than to build one from scratch.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛，我们发现家庭成员经常非常相似；正如谚语所说：“有其父必有其子”。随着每一代的诞生，通过复制和修改现有家庭成员来创建新一代比从头开始建造要容易得多。
- en: 'In [Chapter 2](text00019.html#page "Chapter 2. Organizing Code") , *Organizing
    Code* , we looked at how to copy existing objects and presented a very simple
    piece of code for cloning:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](text00019.html#page "第2章。组织代码")中，*组织代码*，我们看了如何复制现有对象，并介绍了一个非常简单的克隆代码：
- en: '[PRE56]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This code can easily be altered to be used inside a class to return a copy
    of itself:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以很容易地改变，以便在类内部使用，返回自身的副本：
- en: '[PRE57]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The highlighted section of code is the modified clone method. It can be used
    as such:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的突出部分是修改后的克隆方法。它可以这样使用：
- en: '[PRE58]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The Prototype pattern allows for a complex object to be constructed only once
    and then cloned into any number of objects that vary only slightly. If the source
    object is not complicated there is little to be gained from taking a cloning approach.
    Care must be taken when using the prototype approach to think about dependent
    objects. Should the clone be a deep one?
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式允许只构造一次复杂对象，然后克隆成任意数量的仅略有不同的对象。如果源对象不复杂，那么采用克隆方法就没有太多好处。在使用原型方法时，必须注意依赖对象。克隆是否应该是深层的？
- en: Prototype is obviously a useful pattern and one that forms an integral part
    of JavaScript from the get go. As such it is certainly a pattern that will see
    some use in any JavaScript application of appreciable size.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 原型显然是一个有用的模式，也是JavaScript从一开始就形成的一个组成部分。因此，它肯定是任何规模可观的JavaScript应用程序中会看到一些使用的模式。
- en: Tips and tricks
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: Creational patterns allow for specialized behavior in creating objects. In many
    cases, such as the factory, they provide extension points into which crosscutting
    logic can be placed. That is to say logic that applies to a number of different
    types of objects. If you're looking for a way to inject, say, logging throughout
    your application, then being able to hook into a factory is of great utility.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模式允许在创建对象时实现特定行为。在许多情况下，比如工厂，它们提供了可以放置横切逻辑的扩展点。也就是说，适用于许多不同类型对象的逻辑。如果你想要在整个应用程序中注入日志，那么能够连接到工厂是非常有用的。
- en: For all the utility of these creational patterns they should not be used very
    frequently. The vast majority of your object instantiations should still be just
    the normal method of improving the objects. Although it is tempting to treat everything
    as a nail when you've got a new hammer, the truth is that each situation needs
    to have a specific strategy. All these patterns are more complicated than simply
    using `new` and complicated code is more liable to have bugs than simple code.
    Use `new` whenever possible.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些创建模式非常有用，但不应该经常使用。您的大部分对象实例化仍应该是改进对象的正常方法。虽然当你有了新的工具时，把一切都视为钉子是很诱人的，但事实是每种情况都需要有一个具体的策略。所有这些模式都比简单使用`new`更复杂，而复杂的代码更容易出现错误。尽量使用`new`。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter presented a number of different strategies for creating objects.
    These methods provide abstractions over the top of typical methods for creating
    objects. The Abstract Factory provides a method for building interchangeable kits
    or collections of related objects. The Builder pattern provides a solution to
    telescoping parameters issues. It makes the construction of large complicated
    objects easier. The Factory Method, which is a useful complement to Abstract Factory,
    allows different implementations to be created though a static factory. Singleton
    is a pattern for providing a single copy of a class that is available to the entire
    solution. It is the only pattern we've seen so far which has presented some questions
    around applicability in modern software. The Prototype pattern is a commonly used
    pattern in JavaScript for building objects based on other existing objects.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了创建对象的多种不同策略。这些方法提供了对创建对象的典型方法的抽象。抽象工厂提供了构建可互换的工具包或相关对象集合的方法。建造者模式提供了解决参数问题的解决方案。它使得构建大型复杂对象变得更加容易。工厂方法是抽象工厂的有用补充，允许通过静态工厂创建不同的实现。单例是一种提供整个解决方案可用的类的单个副本的模式。这是迄今为止我们所见过的唯一一个在现代软件中存在一些适用性问题的模式。原型模式是JavaScript中常用的一种模式，用于基于其他现有对象构建对象。
- en: We'll continue our examination of classical design patterns in the next chapter
    by looking at structural patterns.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章继续对经典设计模式进行考察，重点关注结构模式。
- en: Chapter 4. Structural Patterns
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 结构模式
- en: In the previous chapter, we looked at a number of ways to create objects in
    order to optimize for reuse. In this chapter, we'll take a look at structural
    patterns; these are patterns that are concerned with easing the design by describing
    simple ways in which objects can interact.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了多种创建对象的方法，以便优化重用。在本章中，我们将研究结构模式；这些模式关注于通过描述对象可以相互交互的简单方式来简化设计。
- en: Again, we will limit ourselves to the patterns described in the GoF book. There
    are a number of other interesting structural patterns that have been identified
    since the publication of the GoF and we'll look at those in part 2 of the book.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将限制自己只研究GoF书中描述的模式。自GoF出版以来，已经确定了许多其他有趣的结构模式，我们将在本书的第二部分中进行研究。
- en: 'The patterns we''ll examine here are:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里研究的模式有：
- en: Adapter
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器
- en: Bridge
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接
- en: Composite
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Decorator
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: Façade
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观
- en: Flyweight
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元
- en: Proxy
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Once again, we'll discuss whether the patterns that were described years ago
    are still relevant for a different language and a different time.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次讨论多年前描述的模式是否仍然适用于不同的语言和不同的时代。
- en: Adapter
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器
- en: 'From time to time there is a need to fit a round peg in a square hole. If you''ve
    ever played with a child''s shape sorting toy then you may have discovered that
    you can, in fact, put a round peg in a square hole. The hole is not completely
    filled and getting the peg in there can be difficult:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要将圆销子放入方孔中。如果你曾经玩过儿童的形状分类玩具，你可能会发现实际上可以把圆销子放入方孔中。孔并没有完全填满，把销子放进去可能会很困难：
- en: '![Adapter](Image00011.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![适配器](Image00011.jpg)'
- en: 'To improve the fit of the peg an adapter can be used. This adapter fills the
    hole in completely resulting in a perfect fit:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改善销子的适配，可以使用适配器。这个适配器完全填满了孔，结果非常完美：
- en: '![Adapter](Image00012.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![适配器](Image00012.jpg)'
- en: In software a similar approach is often needed. We may need to make use of a
    class that does not perfectly fit the required interface. The class may be missing
    methods or may have additional methods we would like to hide. This occurs frequently
    when dealing with third party code. In order to make it comply with the interface
    needed in your code, an adapter may be required.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中经常需要类似的方法。我们可能需要使用一个不完全符合所需接口的类。该类可能缺少方法，或者可能有我们希望隐藏的额外方法。在处理第三方代码时经常会出现这种情况。为了使其符合您代码中所需的接口，可能需要使用适配器。
- en: 'The class diagram for an adapter is very simple as can be seen here:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器的类图非常简单，如下所示：
- en: '![Adapter](Image00013.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![适配器](Image00013.jpg)'
- en: The interface of the implementation does not look the way we would like it to
    for use in our code. Normally the solution to this is to simply refactor the implementation
    so it looks the way we would like it to. However, there are a number of possible
    reasons that cannot be done. Perhaps the implementation exists inside third party
    code to which we have no access. It is also possible that the implementation is
    used elsewhere in the application where the interface is exactly as we would like
    it to be.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的接口看起来不符合我们在代码中想要的样子。通常的解决方法是简单地重构实现，使其看起来符合我们的要求。然而，有一些可能的原因无法这样做。也许实现存在于我们无法访问的第三方代码中。还有可能实现在应用程序的其他地方使用，接口正好符合我们的要求。
- en: The adapter class is a thin piece of code that implements the required interface.
    It typically wraps a private copy of the implementation class and proxy calls
    through to it. The adapter pattern is frequently used to change the abstraction
    level of the code. Let's take a look at a quick example.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器类是一个薄薄的代码片段，实现所需的接口。它通常包装实现类的私有副本，并通过代理调用它。适配器模式经常用于改变代码的抽象级别。让我们来看一个快速的例子。
- en: Implementation
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: In the land of Westeros, much of the trade and travel is done by boat. It is
    not only more dangerous to travel by ship than to walk or travel by horse, but
    also riskier due to the constant presence of storms and pirates. These ships are
    not the sort which might be used by Royal Caribbean to cruise around the Caribbean;
    they are crude things which might look more at home captained by 15th century
    European explorers.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在Westeros的土地上，许多贸易和旅行都是通过船只进行的。乘船旅行不仅比步行或骑马更危险，而且由于风暴和海盗的不断出现，也更加危险。这些船只不是皇家加勒比公司用来在加勒比海周游的那种船只；它们是粗糙的东西，看起来更像是15世纪欧洲探险家所驾驶的。
- en: 'While I am aware that ships exist, I have very little knowledge of how they
    work or how I might go about navigating one. I imagine that many people are in
    the same ( *cough!* ) boat as me. If we look at the interface for a Ship in Westeros,
    it looks intimidating:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我知道船只存在，但我对它们的工作原理或如何操纵船只几乎一无所知。我想很多人和我一样。如果我们看看Westeros的船只接口，它看起来很吓人：
- en: '[PRE59]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'I would really like a much simpler interface that abstracts away all the fiddly
    little details. Ideally something like the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的希望有一个更简单的接口，可以抽象掉所有繁琐的细节。理想情况下是这样的：
- en: '[PRE60]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This looks like something I could probably figure out even living in a city
    that is over 1000 kilometers from the nearest ocean. In short, what I'm looking
    for is a higher-level abstraction around the Ship. In order to transform a Ship
    into a SimpleShip we need an adapter.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是我可能会弄清楚的东西，即使我住在离最近的海洋有1000公里远的城市。简而言之，我想要的是对船只进行更高级别的抽象。为了将船只转换为SimpleShip，我们需要一个适配器。
- en: 'The adapter will have the interface of SimpleShip but it will perform actions
    on a wrapped instance of Ship. The code might look something like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器将具有SimpleShip的接口，但它将在Ship的包装实例上执行操作。代码可能看起来像这样：
- en: '[PRE61]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In reality these functions would be far more complex, but it should not matter
    much because we've got a nice simple interface to present to the world. The presented
    interface can also be set up so as to restrict access to certain methods on the
    underlying type. When building library code, adapters can be used to mask the
    internal method and only present the limited functions needed to the end user.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些功能会更加复杂，但这并不重要，因为我们有一个简单的接口来展示给世界。所呈现的接口也可以设置为限制对基础类型的某些方法的访问。在构建库代码时，适配器可用于隐藏内部方法，只向最终用户呈现所需的有限功能。
- en: 'To use this pattern, the code might look like:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式，代码可能看起来像这样：
- en: '[PRE62]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You would likely not want to use adapter in the name of your client class as
    it leaks some information about the underlying implementation. Clients should
    be unaware they are talking to an adapter.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不想在客户端类的名称中使用适配器，因为它泄露了一些关于底层实现的信息。客户端不应该知道它们正在与适配器交谈。
- en: The adapter itself can grow to be quite complex to adjust one interface to another.
    In order to avoid creating very complex adapters, care must be taken. It is certainly
    not inconceivable to build several adapters, one atop another. If you find an
    adapter becoming too large then it is a good idea to stop and examine if the adapter
    is following the single responsibility principle. That is to say, ensure that
    each class has only one thing for which it has some responsibility. A class that
    looks up users from a database should not also contain functionality for sending
    e-mails to these users. That is too much responsibility. Complex adapters can
    be replaced with a composite object, which will be explored later in this chapter.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器本身可能会变得非常复杂，以调整一个接口到另一个接口。为了避免创建非常复杂的适配器，必须小心。构建几个适配器是完全可以想象的，一个在另一个之上。如果发现适配器变得太大，那么最好停下来检查适配器是否遵循单一责任原则。也就是说，确保每个类只负责一件事。一个从数据库中查找用户的类不应该包含向这些用户发送电子邮件的功能。这责任太大了。复杂的适配器可以被复合对象替换，这将在本章后面探讨。
- en: From the testing perspective, adapters can be used to totally wrap third party
    dependencies. In this scenario they provide a place into which to hook tests.
    Unit tests should avoid testing libraries but they can certainly test the adapters
    to ensure that they are proxying through the correct calls.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试的角度来看，适配器可以用来完全包装第三方依赖。在这种情况下，它们提供了一个可以挂接测试的地方。单元测试应该避免测试库，但它们可以确保适配器代理了正确的调用。
- en: The adapter is a very powerful pattern for simplifying code interfaces. Massaging
    interfaces to better match a requirement is useful in countless places. The pattern
    is certainly useful in JavaScript. Applications written in JavaScript tend to
    make use of a large number of small libraries. By wrapping up these libraries
    in adapters I'm able to limit the number of places I interact with the libraries
    directly; this means that the libraries can easily be replaced.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器是简化代码接口的非常强大的模式。调整接口以更好地满足需求在无数地方都是有用的。这种模式在JavaScript中肯定很有用。用JavaScript编写的应用程序往往会使用大量的小型库。通过将这些库封装在适配器中，我能够限制我直接与库交互的地方的数量；这意味着可以轻松替换这些库。
- en: The adapter pattern can be slightly modified to provide consistent interfaces
    over a number of different implementations. This is usually known as the bridge
    pattern.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式可以稍微修改，以在许多不同的实现上提供一致的接口。这通常被称为桥接模式。
- en: Bridge
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接
- en: The bridge pattern takes the adapter pattern to a new level. Given an interface,
    we can build multiple adapters, each one of which acts as an intermediary to a
    different implementation.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 桥梁模式将适配器模式提升到一个新的水平。给定一个接口，我们可以构建多个适配器，每个适配器都充当到不同实现的中介。
- en: 'An excellent example that I''ve run across, is dealing with two different services
    that provide more or less the same functionality and are used in a failover configuration.
    Neither service provides exactly the interface required by the application and
    both services provide different APIs. In order to simplify the code, adapters
    are written to provide a consistent interface. The adapters implement a consistent
    interface and provide fills so that each API can be called consistently. To expand
    on the shape sorter metaphor a bit more, we can imagine that we have a variety
    of different pegs we would like to use to fill the square hole. Each adapter fills
    in the missing bits and helps us get a good fit:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到的一个很好的例子是，处理两个提供几乎相同功能并且在故障转移配置中使用的不同服务。两个服务都没有提供应用程序所需的确切接口，并且两个服务提供不同的API。为了简化代码，编写适配器以提供一致的接口。适配器实现一致的接口并提供填充，以便可以一致地调用每个API。再举一个形状分类器的比喻，我们可以想象我们有各种不同的销子，我们想用它们来填充方形孔。每个适配器填补了缺失的部分，并帮助我们得到一个良好的适配：
- en: '![Bridge](Image00014.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![Bridge](Image00014.jpg)'
- en: 'The bridge is a very useful pattern. Let''s take a look at how to implement
    it:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 桥梁是一个非常有用的模式。让我们来看看如何实现它：
- en: '![Bridge](Image00015.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![Bridge](Image00015.jpg)'
- en: The adapters shown in the preceding diagram sit between the implementation and
    the desired interface. They modify the implementation to fit in with the desired
    interface.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中显示的适配器位于实现和所需接口之间。它们修改实现以适应所需的接口。
- en: Implementation
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: We've already discussed that in the land of Westeros the people practice a number
    of disparate religions. Each one has a different way of praying and making offerings.
    There is a lot of complexity around making the correct prayers at the correct
    time and we would like to avoid exposing this complexity. Instead we'll write
    a series of adapters that can simplify prayers.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过，在维斯特洛大陆上，人们信仰多种不同的宗教。每个宗教都有不同的祈祷和献祭方式。在正确的时间进行正确的祈祷有很多复杂性，我们希望避免暴露这种复杂性。相反，我们将编写一系列可以简化祈祷的适配器。
- en: 'The first thing we need is a number of different gods to which we can pray:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的第一件事是一些不同的神，我们可以向他们祈祷：
- en: '[PRE63]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'These classes should look familiar as they are basically the same classes found
    in the previous chapter where they were used as examples for the factory method.
    You may notice, however, that the signature for the `prayTo` method for each religion
    is slightly different. This proves to be something of an issue when building a
    consistent interface like the one shown in pseudo code here:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类应该看起来很熟悉，因为它们基本上是在上一章中找到的相同类，它们被用作工厂方法的示例。但是，您可能会注意到，每种宗教的“prayTo”方法的签名略有不同。当构建像这里的伪代码中所示的一致接口时，这可能会成为一个问题：
- en: '[PRE64]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'So let''s slot in a few adapters to act as a bridge between the classes we
    have and the signature we would like the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们插入一些适配器，作为我们拥有的类和我们想要的签名之间的桥梁：
- en: '[PRE65]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Each one of these adapters implements the `God` interface we wanted and abstracts
    away the complexity of dealing with three different interfaces, one for each god:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这些适配器中的每一个都实现了我们想要的“God”接口，并抽象了处理三种不同接口的复杂性，每种接口对应一个神。
- en: 'To use the Bridge pattern, we could write code like so:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用桥梁模式，我们可以编写如下代码：
- en: '[PRE66]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This code uses the bridges to provide a consistent interface to the gods such
    that they can all be treated as equals.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用桥梁为众神提供一致的接口，以便它们可以被视为平等的。
- en: In this case we are simply wrapping the individual gods and proxying method
    calls through to them. The adapters could each wrap a number of objects and this
    is another useful place in which to use the adapter. If a complex series of objects
    needs to be orchestrated, then an adapter can take some responsibility for that
    orchestration providing a simpler interface to other classes.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只是包装了单个神并通过代理方法调用它们。适配器可以包装多个对象，这是另一个有用的地方可以使用适配器。如果需要编排一系列复杂的对象，那么适配器可以承担一些责任，为其他类提供更简单的接口。
- en: You can imagine how useful the bridge pattern is. It can be used well in conjunction
    with the factory method pattern presented in the previous chapter.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象桥梁模式是多么有用。它可以与上一章介绍的工厂方法模式很好地结合使用。
- en: This pattern certainly remains a very useful one for use in JavaScript. As I
    mentioned at the start of this section, it is handy for dealing with different
    APIs in a consistent fashion. I have used it for swapping in different third party
    components such as different graphing libraries or phone system integration points.
    If you're building applications on a mobile platform using JavaScript, then the
    bridge pattern is going to be a great friend for you, allowing you to separate
    your common and platform specific code cleanly. Because there are no interfaces
    in JavaScript, the bridge pattern is far closer to the adapter in JavaScript than
    in other languages. In fact, it is basically exactly the same.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在JavaScript中仍然非常有用。正如我在本节开始时提到的，它对于以一致的方式处理不同的API非常有用。我已经用它来交换不同的第三方组件，比如不同的图形库或电话系统集成点。如果您正在使用JavaScript在移动平台上构建应用程序，那么桥梁模式将成为您的好朋友，可以帮助您清晰地分离通用代码和特定于平台的代码。因为JavaScript中没有接口，所以桥梁模式比其他语言中的适配器更接近JavaScript。实际上，它基本上是一样的。
- en: A bridge also makes testing easier. We are able to implement a fake bridge and
    use this to ensure that the calls into the bridge are correct.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 桥梁还可以使测试变得更容易。我们可以实现一个虚拟桥梁，并使用它来确保对桥梁的调用是正确的。
- en: Composite
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: In the previous chapter I mentioned that we would like to avoid coupling our
    objects together tightly. Inheritance is a very strong form of coupling and I
    suggested that, instead, composites should be used. The composite pattern is a
    special case of this in which the composite is treated as interchangeable with
    the components. Let's explore how the composite pattern works.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我提到我们希望避免对象之间的紧密耦合。继承是一种非常强的耦合形式，我建议使用组合代替。组合模式是这种情况的一个特例，其中组合被视为可与组件互换。让我们探讨一下组合模式的工作原理。
- en: 'The following class diagram contains two different ways to build a composite
    component:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图包含了构建复合组件的两种不同方式：
- en: '![Composite](Image00016.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![Composite](Image00016.jpg)'
- en: In the first one, the composite component is built from a fixed number of a
    variety of components. The second component is constructed from a collection of
    indeterminate length. In both cases the components contained within the parent
    composition could be of the same type as the composition. So a composition may
    contain instances of its own type.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个中，复合组件由各种组件的固定数量构建。第二个组件是由一个不确定长度的集合构建的。在这两种情况下，父组合中包含的组件可以与组合的类型相同。因此，一个组合可以包含其自身类型的实例。
- en: The key feature of the composite pattern is the interchangeability of a component
    with its children. So, if we have a composite which implements `IComponent` ,
    then all of the components of the composite will also implement `IComponent` .
    This is, perhaps, best illustrated with an example.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式的关键特征是组件与其子组件的可互换性。因此，如果我们有一个实现了`IComponent`的组合，那么组合的所有组件也将实现`IComponent`。这可能最好通过一个例子来说明。
- en: Example
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: Tree structures are very useful in computing. It turns out that a hierarchical
    tree can represent many things. A tree is made up of a series of nodes and edges
    and is a cyclical. In a binary tree, each node contains a left and right child
    until we get down to the terminal nodes known as leaves.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 树结构在计算中非常有用。事实证明，分层树可以表示许多事物。树由一系列节点和边组成，是循环的。在二叉树中，每个节点包含左右子节点，直到我们到达称为叶子的终端节点。
- en: 'While life is difficult in Westeros there is an opportunity for taking joy
    in things like religious holidays or weddings. At these events there is typically
    a great deal of feasting on delicious foods. The recipes for these foods is much
    as you would find in your own set of recipes. A simple dish like baked apples
    contains a list of ingredients:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然维斯特洛的生活很艰难，但也有机会享受宗教节日或婚礼等事物。在这些活动中，通常会大量享用美味食物。这些食物的食谱与您自己的食谱一样。像烤苹果这样的简单菜肴包含一系列成分：
- en: Baking apple
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 烘焙苹果
- en: Honey
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蜂蜜
- en: Butter
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄油
- en: Nuts
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坚果
- en: Each one of these ingredients implements an interface which we'll refer to as
    `IIngredient` . More complex recipes contain more ingredients, but in addition
    to that, more complex recipes may contain complex ingredients that are themselves
    made from other ingredients.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成分中的每一个都实现了一个我们称之为`IIngredient`的接口。更复杂的食谱包含更多的成分，但除此之外，更复杂的食谱可能包含复杂的成分，这些成分本身是由其他成分制成的。
- en: 'A popular dish in a southern part of Westeros is a dessert which is not at
    all unlike what we would call tiramisu. It is a complex recipe with ingredients
    such as:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛南部，一道受欢迎的菜肴是一种甜点，与我们所说的提拉米苏非常相似。这是一个复杂的食谱，其中包含以下成分：
- en: Custard
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奶油
- en: Cake
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛋糕
- en: Whipped cream
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打发奶油
- en: Coffee
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 咖啡
- en: 'Of course custard itself is made from:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，奶油本身是由以下成分制成的：
- en: Milk
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 牛奶
- en: Sugar
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 糖
- en: Eggs
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鸡蛋
- en: Vanilla
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 香草
- en: Custard is a composite as is coffee and cake.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 奶油是一个复合成分，咖啡和蛋糕也是。
- en: Operations on the composite object are typically proxied through to all of the
    contained objects.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 组合对象上的操作通常会通过代理传递给所有包含的对象。
- en: Implementation
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'A simple ingredient, one which would be a leaf node, is shown in this code:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了一个简单的成分，即叶子节点：
- en: '[PRE67]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'It can be used interchangeably with a compound ingredient which has a list
    of ingredients:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以与具有成分列表的复合成分互换使用：
- en: '[PRE68]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The composite ingredient loops over its internal ingredients and performs the
    same operation on each of them. There is, of course, no need to define an interface
    due to the prototype model.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 复合成分循环遍历其内部成分，并对每个成分执行相同的操作。当然，由于原型模型，无需定义接口。
- en: 'To make use of this compound ingredient we might do:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种复合成分，我们可以这样做：
- en: '[PRE69]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Of course this only shows part of the power of the pattern. We could use rice
    pudding as an ingredient in an even more complicated recipe: rice pudding stuffed
    buns (they have some strange foods in Westeros). As both the simple and compound
    version of the ingredient have the same interface, the caller does not need to
    know that there is any difference between the two ingredient types.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只显示了模式的一部分。我们可以将米布丁用作更复杂食谱的成分：米布丁馅饼（在维斯特洛有一些奇怪的食物）。由于简单和复合版本的成分具有相同的接口，调用者不需要知道两种成分类型之间有任何区别。
- en: 'Composite is a heavily used pattern in JavaScript code that deals with HTML
    elements, as they are a tree structure. For example, the jQuery library provides
    a common interface if you have selected a single element or a collection of elements.
    When a function is called it is actually called on all the children, for instance:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是JavaScript代码中广泛使用的模式，用于处理HTML元素，因为它们是树结构。例如，jQuery库提供了一个通用接口，如果您选择了单个元素或一组元素。当调用函数时，实际上是在所有子元素上调用，例如：
- en: '[PRE70]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This will hide all the links on a page regardless of how many elements are actually
    found by calling `$("a")` . The composite is a very useful pattern for JavaScript
    development.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这将隐藏页面上的所有链接，而不管调用`$("a")`实际找到多少元素。组合是JavaScript开发中非常有用的模式。
- en: Decorator
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者
- en: The decorator pattern is used to wrap and augment an existing class. Using a
    decorator pattern is an alternative to subclassing an existing component. Subclassing
    is typically a compile time operation and is a tight coupling. This means that
    once subclassing is performed, there is no way to alter it at runtime. In cases
    where there are many possible subclassings that can act in combination, the number
    of combinations of subclassings explodes. Let's look at an example.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式用于包装和增强现有类。使用装饰器模式是对现有组件进行子类化的替代方法。子类化通常是一个编译时操作，是一种紧密耦合。这意味着一旦子类化完成，就无法在运行时进行更改。在存在许多可能的子类化可以组合的情况下，子类化的组合数量会激增。让我们看一个例子。
- en: 'The armor worn by knights in Westeros can be quite configurable. Armor can
    be fabricated in a number of different styles: scale, lamellar, chainmail, and
    so on. In addition to the style of armor, there is also a variety of different
    face guards, knee, and elbow joints, and, of course, colors. The behavior of armor
    made from lamellar and a grille is different from chainmail with a face visor.
    You can see, however, that there is a large number of possible combinations; far
    too many combinations to explicitly code.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: Westeros骑士所穿的盔甲可以是非常可配置的。盔甲可以以多种不同的风格制作：鳞甲、板甲、锁子甲等等。除了盔甲的风格之外，还有各种不同的面罩、膝盖和肘部关节，当然还有颜色。由板甲和面罩组成的盔甲的行为与带有面罩的锁子甲是不同的。然而，你可以看到，存在大量可能的组合；明显太多的组合无法显式编码。
- en: 'What we do instead is implement the different styles of armor using the decorator
    pattern. A decorator works using a similar theory to the adapter and bridge patterns,
    in that it wraps another instance and proxy calls through. The decorator pattern,
    however, performs the redirections at runtime by having the instance to wrap passed
    into it. Typically, a decorator will act as a simple pass through for some methods
    and for others it will make some modifications. These modifications could be limited
    to performing an additional action before passing the call off to the wrapped
    instance or could go so far as to change the parameters passed in. A UML representation
    of the decorator pattern looks like the following diagram:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是使用装饰器模式实现不同风格的盔甲。装饰器使用与适配器和桥接模式类似的理论，它包装另一个实例并通过代理调用。然而，装饰器模式通过将要包装的实例传递给它来在运行时执行重定向。通常，装饰器将作为一些方法的简单传递，对于其他方法，它将进行一些修改。这些修改可能仅限于在将调用传递给包装实例之前执行附加操作，也可能会改变传入的参数。装饰器模式的UML表示如下图所示：
- en: '![Decorator](Image00017.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![Decorator](Image00017.jpg)'
- en: This allows for very granular control over which methods are altered by the
    decorator and which remain as mere pass-through. Let's take a look at an implementation
    of the pattern in JavaScript.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许对装饰器修改哪些方法进行非常精细的控制，哪些方法保持为简单的传递。让我们来看一下JavaScript中该模式的实现。
- en: Implementation
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'In this code we have a base class, `BasicArmor` , and it is then decorated
    by the `ChainMail` class:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们有一个基类`BasicArmor`，然后由`ChainMail`类进行装饰：
- en: '[PRE71]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `ChainMail` armor takes in an instance of armor that complies with an interface,
    such as:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChainMail`装甲接受符合接口的装甲实例，例如：'
- en: '[PRE72]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: That instance is wrapped and calls proxied through. The method `GetArmorIntegiry`
    modifies the result from the underlying class while `CalculateDamageFromHit` modifies
    the arguments that are passed into the decorated class. This `ChainMail` class
    could, itself, be decorated with several more layers of decorators until a long
    chain of methods is actually called for each method call. This behavior, of course,
    remains invisible to outside callers.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 该实例被包装并通过代理调用。`GetArmorIntegiry`方法修改了基础类的结果，而`CalculateDamageFromHit`修改了传递给装饰类的参数。这个`ChainMail`类本身可以被装饰多层装饰器，直到实际为每个方法调用调用了一长串方法。当然，这种行为对外部调用者来说是不可见的。
- en: 'To make use of this armor decorator, look at the following code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个装甲装饰器，请看下面的代码：
- en: '[PRE73]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It is tempting to make use of JavaScript's ability to rewrite individual methods
    on classes to implement this pattern. Indeed, in an earlier draft of this section
    I had intended to suggest just that. However, doing so is syntactically messy
    and not a common way of doing things. One of the most important things to keep
    in mind when programming is that code must be maintainable, not only by you but
    also by others. Complexity breeds confusion and confusion breeds bugs.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 利用JavaScript重写类的单个方法来实现这种模式是很诱人的。事实上，在本节的早期草案中，我本打算建议这样做。然而，这样做在语法上很混乱，不是一种常见的做法。编程时最重要的事情之一是要记住代码必须是可维护的，不仅是对你自己，也是对其他人。复杂性会导致混乱，混乱会导致错误。
- en: The decorator pattern is a valuable pattern for scenarios where inheritance
    is too limiting. These scenarios still exist in JavaScript, so the pattern remains
    useful.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式是一种对继承过于限制的情况非常有价值的模式。这些情况在JavaScript中仍然存在，因此该模式仍然有用。
- en: Façade
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Façade
- en: 'The façade pattern is a special case of the Adapter pattern that provides a
    simplified interface over a collection of classes. I mentioned such a scenario
    in the section on the adapter pattern but only within the context of a single
    class, `SimpleShip` . This same idea can be expanded to provide an abstraction
    around a group of classes or an entire subsystem. The façade pattern in UML form
    looks like the following diagram:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Façade模式是适配器模式的一种特殊情况，它在一组类上提供了简化的接口。我在适配器模式的部分提到过这样的情景，但只在`SimpleShip`类的上下文中。这个想法可以扩展到提供一个抽象，围绕一组类或整个子系统。Façade模式在UML形式上看起来像下面的图表：
- en: '![Façade](Image00018.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![Façade](Image00018.jpg)'
- en: Implementation
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'If we take the same `SimpleShip` as before and expand it to an entire fleet,
    we have a great example of a use for creating a façade. If it was difficult to
    sail a single ship it would be far more difficult to command an entire fleet of
    ships. There is a great deal of nuance required, commands to individual ships
    would have to be made. In addition to the individual ships there must also be
    a fleet Admiral and a degree of coordination between the ships in order to distribute
    supplies. All of this can be abstracted away. If we have a collection of classes
    representing the aspects of a fleet such as these:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将之前的`SimpleShip`扩展为整个舰队，我们就有了一个创建外观的绝佳示例。如果操纵一艘单独的船很困难，那么指挥整个舰队将更加困难。需要大量微妙的操作，必须对单独的船只下达命令。除了单独的船只外，还必须有一位舰队上将，并且需要在船只之间协调以分发补给。所有这些都可以被抽象化。如果我们有一系列代表舰队方面的类，比如这些：
- en: '[PRE74]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then we might build a façade as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们可以构建一个外观，如下所示：
- en: '[PRE75]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Façades are very useful abstractions, especially in dealing with APIs. Using
    a façade around a granular API can create an easier interface. The level of abstraction
    at which the API works can be raised so that it is more in sync with how your
    application works. For instance, if you''re interacting with the Azure blob storage
    API you could raise the level of abstraction from working with individual files
    to working with collections of files. Instead of writing the following:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 外观在处理API时非常有用。在细粒度API周围使用外观可以创建一个更简单的接口。API的抽象级别可以提高，使其更符合应用程序的工作方式。例如，如果您正在与Azure
    blob存储API交互，您可以将抽象级别从处理单个文件提高到处理文件集。而不是编写以下内容：
- en: '[PRE76]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'A façade could be written which encapsulates all of these calls and provides
    an interface, like:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编写一个外观，封装所有这些调用并提供一个接口，如下所示：
- en: '[PRE77]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As you can see façades remain useful in JavaScript and should be a pattern that
    remains in your toolbox.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，外观在JavaScript中仍然很有用，并且应该是您工具箱中保留的模式。
- en: Flyweight
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蝇量级
- en: In boxing there is a light weight division between 49-52 kg known as the flyweight
    division. It was one of the last divisions to be established and was named, I
    imagine, for the fact that the fighters in it were tiny, like flies.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 拳击中有一个49-52公斤之间的轻量级级别，被称为蝇量级。这是最后一个建立的级别之一，我想它之所以被命名为蝇量级，是因为其中的拳击手很小，就像苍蝇一样。
- en: The flyweight pattern is used in instances when there are a large number of
    instances of objects which vary only slightly. I should perhaps pause here to
    mention that a large number, in this situation, is probably in the order of 10,000
    objects rather than 50 objects. However, the cutoff for the number of instances
    is highly dependent on how expensive the object is to create.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 蝇量级模式用于对象实例非常多，而这些实例之间只有轻微差异的情况。在这种情况下，大量通常指的是大约10,000个对象，而不是50个对象。然而，实例数量的截止点高度依赖于创建对象的成本。
- en: In some cases, the object may be so expensive that only a handful are required
    before they overload the system. In this case introducing flyweight at a smaller
    number would be beneficial. Maintaining a full object for each object consumes
    a lot of memory. It seems that the memory is largely consumed wastefully too,
    as most of the instances have the same value for their fields. Flyweight offers
    a way to compress this data by only keeping track of the values that differ from
    some prototype in each instance.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，对象可能非常昂贵，系统在超载之前只需要少数对象。在这种情况下，引入蝇量级在较小数量上将是有益的。为每个对象维护一个完整的对象会消耗大量内存。似乎大部分内存也被浪费地消耗掉了，因为大多数实例的字段具有相同的值。蝇量级提供了一种通过仅跟踪与每个实例中的某个原型不同的值来压缩这些数据的方法。
- en: JavaScript's prototype model is ideal for this scenario. We can simply assign
    the most common value to the prototype and have individual instances override
    them as needed. Let's see how that looks with an example.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的原型模型非常适合这种情况。我们可以简单地将最常见的值分配给原型，并在需要时覆盖各个实例。让我们看一个例子。
- en: Implementation
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'Returning once more to Westeros (aren''t you glad I''ve opted for a single
    overarching problem domain?) we find that armies are full of ill-equipped fighting
    people. Within this set of people there is really very little difference from
    the perspective of the generals. Certainly each person has their own life, ambitions,
    and dreams but they have all been adapted into simple fighting automatons in the
    eyes of the general. The general is only concerned with how well the soldiers
    fight, if they''re healthy, and if they''re well fed. We can see the simple set
    of fields in this code:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回到维斯特洛（你是否为我选择了一个单一的主要问题领域感到高兴？），我们发现军队中充满了装备不足的战斗人员。在这些人中，从将军的角度来看，实际上没有太大的区别。当然，每个人都有自己的生活、抱负和梦想，但在将军眼中，他们都已经成为简单的战斗自动机。将军只关心士兵们打得多好，他们是否健康，是否吃饱。我们可以在这段代码中看到简单的字段集：
- en: '[PRE78]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Of course, with an army of 10,000 soldiers, keeping track of all of this requires
    quite some memory. Let''s take a different approach and use a class:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于一支由10,000名士兵组成的军队，跟踪所有这些需要相当多的内存。让我们采用另一种方法并使用一个类：
- en: '[PRE79]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Using this approach, we are able to defer all requests for the soldier''s health
    to the prototype. Setting the value is easy too:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以将对士兵健康的所有请求推迟到原型。设置值也很容易：
- en: '[PRE80]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You'll note that we make a call to delete to remove the property override and
    return the value back to the parent value.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们调用删除来删除属性覆盖，并将值返回到父值。
- en: Proxy
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: 'The final pattern presented in this chapter is the proxy. In the previous section
    I mentioned how it is expensive to create objects and how we would like to avoid
    creating too many of them. The proxy pattern provides a method of controlling
    the creation and use of expensive objects. The UML of the proxy pattern looks
    like the following diagram:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的最后一个模式是代理。在前一节中，我提到创建对象是昂贵的，我们希望避免创建过多的对象。代理模式提供了一种控制昂贵对象的创建和使用的方法。代理模式的UML如下图所示：
- en: '![Proxy](Image00019.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![代理](Image00019.jpg)'
- en: 'As you can see, the proxy mirrors the interface of the actual instance. It
    is substituted in for the instance in all the clients and, typically, wraps a
    private instance of the class. There are a number of places where the proxy pattern
    can be of use:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，代理模式反映了实际实例的接口。它被替换为所有客户端中的实例，并且通常包装类的私有实例。代理模式可以在许多地方发挥作用：
- en: Lazy instantiation of an expensive object
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 昂贵对象的延迟实例化
- en: Protection of secret data
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护秘密数据
- en: Stubbing for remote method invocation
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程方法调用的存根
- en: Interposing additional actions before or after method invocation
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法调用之前或之后插入额外的操作
- en: Often an object is expensive to instantiate and we don't want to have instances
    created before they're actually used. In this case the proxy can check its internal
    instance and, if not yet initiated, create it before passing on the method call.
    This is known as lazy instantiation.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 通常一个对象实例化是昂贵的，我们不希望在实际使用之前就创建实例。在这种情况下，代理可以检查它的内部实例，并且如果尚未初始化，则在传递方法调用之前创建它。这被称为延迟实例化。
- en: If a class has been designed without any security in mind but now requires some,
    this can be provided through the use of a proxy. The proxy will check the call
    and only pass on the method call in cases where the security checks out.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类在设计时没有考虑到安全性，但现在需要一些安全性，可以通过使用代理来提供。代理将检查调用，并且只有在安全检查通过的情况下才会传递方法调用。
- en: The proxy may be used to simply provide an interface to methods that are invoked
    somewhere else. In fact, this is exactly how a number of web socket libraries
    function, proxying calls back to the web server.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 代理可以简单地提供一个接口，用于调用其他地方调用的方法。事实上，这正是许多网络套接字库的功能，将调用代理回到Web服务器。
- en: Finally, there may be cases where it is useful to interpose some functionality
    into the method invocation. This could be logging of parameters, validating of
    parameters, altering results, or any number of things.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可能有些情况下，将一些功能插入到方法调用中是有用的。这可能是参数日志记录，参数验证，结果更改，或者其他任何事情。
- en: Implementation
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: Let's take a look at a Westeros example where method interposition is needed.
    As tends to happen, the units of measurement for liquids vary greatly from one
    side of the land to the other. In the north, one might buy a pint of beer, while
    in the south, one would buy it by the dragon. This causes no end of confusion
    and code duplication, but can be solved by wrapping classes that care about measurement
    in proxies.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个需要方法拦截的Westeros示例。通常情况下，液体的计量单位在这片土地的一边和另一边差异很大。在北方，人们可能会买一品脱啤酒，而在南方，人们会用龙来购买。这导致了很多混乱和代码重复，但可以通过包装关心计量的类来解决。
- en: 'For example, this code is for a barrel calculator which estimates the number
    of barrels needed to ship a quantity of liquid:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这段代码是用于估算运输液体所需的桶数的桶计算器：
- en: '[PRE81]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Although it is not well documented, here this version takes pints as a volume
    parameter. A proxy is created which deals with the transformation thusly:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它没有很好的文档记录，但这个版本以品脱作为体积参数。创建一个代理来处理转换：
- en: '[PRE82]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Equally we might create another proxy for a pint-based barrel calculator:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可能为基于品脱的桶计算器创建另一个代理：
- en: '[PRE83]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This proxy class does the unit conversion for us and helps alleviate some confusion
    around units. Some languages, such as F#, support the concept of units of measure.
    In effect it is a typing system which is overlaid over simple data types such
    as integers, preventing programmers from making mistakes such as adding a number
    representing pints to one representing liters. Out of the box in JavaScript there
    is no such capability. Using a library such as JS-Quantities ([http://gentooboontoo.github.io/js-quantities/](http://gentooboontoo.github.io/js-quantities/)
    ) is an option however. If you look at it, you'll see the syntax is quite painful.
    This is because JavaScript doesn't permit operator overloading. Having seen how
    weird adding things such as an empty array to an empty array are (it results in
    an empty string), I think perhaps we can be thankful that operator overloading
    isn't supported.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代理类为我们做了单位转换，并帮助减轻了一些关于单位的混乱。一些语言，比如F#，支持单位的概念。实际上，它是一种类型系统，覆盖在简单的数据类型上，如整数，防止程序员犯错，比如将表示品脱的数字加到表示升的数字上。在JavaScript中，没有这样的能力。然而，使用JS-Quantities（[http://gentooboontoo.github.io/js-quantities/](http://gentooboontoo.github.io/js-quantities/)）这样的库是一个选择。如果你看一下，你会发现语法非常痛苦。这是因为JavaScript不允许操作符重载。看到像将一个空数组添加到另一个空数组一样奇怪的事情（结果是一个空字符串），也许我们可以感谢JavaScript不支持操作符重载。
- en: 'If we wanted to protect against accidentally using the wrong sort of calculator
    when we have pints and think we have dragons, then we could stop with our primitive
    obsession and use a type for the quantity, a sort of poor person''s units of measure:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要防止在有品脱而认为有龙时意外使用错误类型的计算器，那么我们可以停止使用原始类型，并为数量使用一种类型，一种类似于贫穷人的计量单位：
- en: '[PRE84]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This can then be used as a guard in the proxy:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以作为代理中的一个保护使用：
- en: '[PRE85]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: As you can see, we end up with pretty much what JS-Quantities does but in a
    more ES6 form.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们最终得到了基本上与JS-Quantities相同的东西，但是以更ES6的形式。
- en: The proxy is absolutely a useful pattern within JavaScript. I already mentioned
    that it is used by web socket libraries when generating stubs but it finds itself
    useful in countless other locations.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式在JavaScript中绝对是一个有用的模式。我已经提到它在生成存根时被Web套接字库使用，但它在无数其他位置也很有用。
- en: Hints and tips
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: Many of the patterns presented in this chapter provide methods of abstracting
    functionality and of molding interfaces to look the way you want. Keep in mind
    that with each layer of abstraction a cost is introduced. Function calls take
    longer but it is also much more confusing for people who need to understand your
    code. Tooling can help a little but tracking a function call through nine layers
    of abstraction is never fun.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的许多模式提供了抽象功能和塑造接口的方法。请记住，每一层抽象都会引入成本。函数调用会变慢，但对于需要理解您的代码的人来说，这也更加令人困惑。工具可以帮助一点，但跟踪一个函数调用穿过九层抽象从来都不是一件有趣的事情。
- en: Also be wary of doing too much in the façade pattern. It is very easy to turn
    the façade into a fully-fledged management class and that degrades easily into
    a God object that is responsible for coordinating and doing everything.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 同时要小心在外观模式中做得太多。很容易将外观转化为一个完全成熟的管理类，这很容易变成一个负责协调和执行一切的上帝对象。
- en: Summary
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we've looked at a number of patterns used to structure the interaction
    between objects. Some of them are quite similar to each other but they are all
    useful in JavaScript, although the bridge is effectively reduced to an adapter.
    In the next chapter we'll finish our examination of the original GoF patterns
    by looking at behavioral patterns.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看了一些用于构造对象之间交互的模式。它们中的一些模式相互之间相当相似，但它们在JavaScript中都很有用，尽管桥接模式实际上被简化为适配器。在下一章中，我们将通过查看行为模式来完成对原始GoF模式的考察。
- en: Chapter 5. Behavioral Patterns
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 行为模式
- en: In the last chapter we looked at structural patterns that describe ways in which
    objects can be constructed to ease interaction.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了描述对象如何构建以便简化交互的结构模式。
- en: 'In this chapter we''ll take a look at the final, and largest, grouping of GoF
    patterns: behavioral patterns. These patterns are ones that provide guidance on
    how objects share data or, from a different perspective, how data flows between
    objects.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下GoF模式的最后一个，也是最大的分组：行为模式。这些模式提供了关于对象如何共享数据或者从不同的角度来看，数据如何在对象之间流动的指导。
- en: 'The patterns we''ll look at are as follows:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的模式如下：
- en: Chain of responsibility
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链
- en: Command
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Interpreter
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器
- en: Iterator
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Mediator
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中介者
- en: Memento
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录
- en: Observer
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: State
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: Strategy
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略
- en: Template method
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法
- en: Visitor
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者
- en: Once again there are a number of more recently identified patterns that could
    well be classified as behavioral patterns. We'll defer looking at those until
    a later chapter, instead keeping to the GoF patterns.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，有许多最近确定的模式可能很好地被归类为行为模式。我们将推迟到以后的章节再来看这些模式，而是继续使用GoF模式。
- en: Chain of responsibility
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链
- en: 'We can think of a function call on an object as sending that object a message.
    Indeed this message passing mentality is one that dates back to the days of Smalltalk.
    The chain of responsibility pattern describes an approach in which a message tickles
    down from one class to another. A class can either act on the message or allow
    it to be passed on to the next member of the chain. Depending on the implementation
    there are a few different rules that can be applied to the message passing. In
    some situations only the first matching link in the chain is permitted to act.
    In others, every matching link acts on the message. Sometimes the links are permitted
    to stop processing or even to mutate the message as it continues down the chain:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将对象上的函数调用看作是向该对象发送消息。事实上，这种消息传递的思维方式可以追溯到Smalltalk的时代。责任链模式描述了一种方法，其中消息从一个类传递到另一个类。一个类可以对消息进行操作，也可以将其传递给链中的下一个成员。根据实现，可以对消息传递应用一些不同的规则。在某些情况下，只允许链中的第一个匹配链接对消息进行操作。在其他情况下，每个匹配的链接都对消息进行操作。有时允许链接停止处理，甚至在消息继续传递下去时改变消息：
- en: '![Chain of responsibility](Image00020.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![责任链](Image00020.jpg)'
- en: 'Let''s see if we can find a good example of this pattern in our go-to example:
    the land of Westeros.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们常用的例子中是否能找到这种模式的一个很好的例子：维斯特洛大陆。
- en: Implementation
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: There is very little in the way of a legal system in Westeros. Certainly there
    are laws and even city guards who enforce them but the judicial system is scant.
    The law of the land is really decided by the king and his advisors. Those with
    the time and money can petition for an audience with the king who will listen
    to their complaint and pass a ruling. This ruling is law. Of course any king who
    spent his entire day listening to the complaints of peasants would go mad. For
    this reason many of the cases are caught and solved by his advisors before they
    reach his ears.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛大陆，法律制度几乎不存在。当然有法律，甚至有执行它们的城市警卫，但司法系统很少。这片土地的法律实际上是由国王和他的顾问决定的。有时间和金钱的人可以向国王请愿，国王会听取他们的投诉并作出裁决。这个裁决就是法律。当然，任何整天听农民的投诉的国王都会发疯。因此，许多案件在传到国王耳朵之前就被他的顾问们抓住并解决了。
- en: 'To represent this in code we''ll need to start by thinking about how the chain
    of responsibility would work. A complaint comes in and it starts with the lowest
    possible person who can solve it. If that person cannot or will not solve the
    problem it tickles up to a more senior member of the ruling class. Eventually
    the problem reaches the king who is the final arbiter of disputes. We can think
    of him as the default dispute solver who is called upon when all else fails. The
    chain of responsibility is visible in the following diagram:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在代码中表示这一点，我们需要首先考虑责任链将如何工作。投诉进来，从能够解决问题的最低可能的人开始。如果那个人不能或不愿解决问题，它就会上升到统治阶级的更高级成员。最终问题会达到国王，他是争端的最终仲裁者。我们可以把他看作是默认的争端解决者，当一切都失败时才会被召唤。责任链在下图中可见：
- en: '![Implementation](Image00021.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![实施](Image00021.jpg)'
- en: 'We''ll start with an interface to describe those who might listen to complaints:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个描述可能听取投诉的接口开始：
- en: '[PRE86]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The interface requires two methods. The first is a simple check to see if the
    class is able to resolve a given complaint. The second listens to and resolves
    the complaint. Next we''ll need to describe what constitutes a complaint:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 接口需要两个方法。第一个是一个简单的检查，看看类是否能够解决给定的投诉。第二个是听取和解决投诉。接下来，我们需要描述什么构成了投诉：
- en: '[PRE87]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next we need a couple of different classes which implement `ComplaintListener`
    and are able to solve complaints:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些不同的类来实现`ComplaintListener`，并且能够解决投诉：
- en: '[PRE88]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Each one of these classes implements a different approach to solving the complaint.
    We need to chain them together making sure that the king is in the default position.
    This can be seen in this code:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类中的每一个都实现了解决投诉的不同方法。我们需要将它们链接在一起，确保国王处于默认位置。这可以在这段代码中看到：
- en: '[PRE89]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This code will work its way through each of the listeners until it finds one
    that is interested in hearing the complaint. In this version the result is returned
    immediately, halting any further processing. There are variations of this pattern
    in which multiple listeners could fire, even allowing the listeners to mutate
    the parameters for the next listener. The following diagram shows multiple listeners
    configured:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将逐个遍历每个监听器，直到找到一个对听取投诉感兴趣的监听器。在这个版本中，结果会立即返回，停止任何进一步的处理。这种模式有多种变体，其中多个监听器可以触发，甚至允许监听器改变下一个监听器的参数。以下图表显示了多个配置的监听器：
- en: '![Implementation](Image00022.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![实施](Image00022.jpg)'
- en: Chain of responsibility is a highly useful pattern in JavaScript. In browser-based
    JavaScript the events that fire fall through a chain of responsibility. For instance
    you can attach multiple listeners to the click event on a link and each of them
    will fire and then, finally, the default navigation listener. It is likely that
    you're using chain of responsibility in much of your code without even knowing
    it.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链在JavaScript中是一个非常有用的模式。在基于浏览器的JavaScript中，触发的事件会经过一条责任链。例如，您可以将多个监听器附加到链接的单击事件上，每个监听器都会触发，最后是默认的导航监听器。很可能您在大部分代码中都在使用责任链，甚至自己都不知道。
- en: Command
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令
- en: The command pattern is a method of encapsulating both the parameters to a method,
    as well as the current object state, and which method is to be called. In effect
    the command pattern packs up everything needed to call a method at a later date
    into a nice little package. Using this approach one can issue a command and wait
    until a later date to decide which piece of code will execute the command. This
    package can then be queued or even serialized for later execution. Having a single
    point of command execution also allows for easily adding functionality such as
    undo or command logging.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式是一种封装方法参数、当前对象状态以及要调用的方法的方法。实际上，命令模式将调用方法所需的一切打包到一个很好的包中，可以在以后的某个日期调用。使用这种方法，可以发出命令，并等到以后再决定哪段代码将执行该命令。然后可以将此包排队或甚至序列化以供以后执行。具有单一的命令执行点还允许轻松添加功能，如撤消或命令记录。
- en: 'This pattern can be a bit difficult to imagine so let''s break it down into
    its components:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可能有点难以想象，所以让我们把它分解成其组成部分：
- en: '![Command](Image00023.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![命令](Image00023.jpg)'
- en: Command message
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令消息
- en: The first component of the command pattern is, predictably, the command itself.
    As I mentioned, the command encapsulates everything needed to invoke a method.
    This includes the method name, the parameters, and any global state. As you can
    imagine keeping track of global state in each command is very difficult. What
    happens if the global state changes after the command has been created? This dilemma
    is yet another reason why using a global state is problematic and should be avoided.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式的第一个组件是，可预测地，命令本身。正如我提到的，命令封装了调用方法所需的一切。这包括方法名、参数和任何全局状态。可以想象，在每个命令中跟踪全局状态是非常困难的。如果全局状态在命令创建后发生变化会发生什么？这个困境是使用全局状态的另一个原因，它是有问题的，应该避免使用。
- en: There are a couple of options for setting up commands. At the simple end of
    the scale all that is needed is to track a function and a set of parameters. Because
    functions are first class objects in JavaScript, they can easily be saved into
    an object. We can also save the parameters to the function into a simple array.
    Let's build a command using this very simple approach.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 设置命令有几种选择。在简单的一端，只需要跟踪一个函数和一组参数。因为JavaScript中函数是一等对象，它们可以很容易地保存到对象中。我们还可以将函数的参数保存到一个简单的数组中。让我们使用这种非常简单的方法构建一个命令。
- en: The deferred nature of commands suggests an obvious metaphor in the land of
    Westeros. There are no methods of communicating quickly in Westeros. The best
    method is to attach small messages to birds and release them. The birds have a
    tendency to want to return to their homes, so each lord raises a number of birds
    in their home and, when they come of age, sends them to other lords who might
    wish to communicate with them. The lords keep an aviary of birds and retain records
    of which bird will travel to which other lord. The king of Westeros sends many
    of his commands to his loyal lords through this method.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的延迟性质在维斯特洛大陆中有一个明显的隐喻。在维斯特洛大陆中没有快速通信的方法。最好的方法是将小消息附加到鸟上并释放它们。这些鸟倾向于想要返回自己的家，因此每个领主在自己的家中饲养一些鸟，当它们成年时，将它们发送给其他可能希望与他们交流的领主。领主们保留一群鸟并记录哪只鸟将飞往哪个其他领主。维斯特洛国王通过这种方法向他忠诚的领主发送了许多命令。
- en: The commands sent by the king contain all necessary instructions for the lords.
    The command may be something like bring your troops and the arguments to that
    command may be a number of troops, a location, and a date by which the command
    must be carried out.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 国王发送的命令包含了领主所需的所有指令。命令可能是像带领你的部队这样的东西，而该命令的参数可能是部队的数量、位置和命令必须执行的日期。
- en: 'In JavaScript the simplest way of representing this is through an array:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，最简单的表示方法是通过数组：
- en: '[PRE90]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This array can be passed around and invoked at will. To invoke it, a generic
    function can be used:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组可以随意传递和调用。要调用它，可以使用一个通用函数：
- en: '[PRE91]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'As you can see, this function only works for commands with three arguments.
    You can, of course, expand this to any number:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个函数只适用于具有三个参数的命令。当然，您可以将其扩展到任意数量：
- en: '[PRE92]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The additional parameters are undefined, but the function doesn't use them so
    there are no ill effects. Of course, this is not at all an elegant solution.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 附加参数是未定义的，但函数不使用它们，因此没有任何不良影响。当然，这绝不是一个优雅的解决方案。
- en: It is desirable to build a class for each sort of command. This allows you to
    ensure the correct arguments have been supplied and easily distinguish the different
    sorts of commands in a collection. Typically, commands are named using the imperative,
    as they are instructions. Examples of this are BringTroops, Surrender, SendSupplies,
    and so on.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 为每种类型的命令构建一个类是可取的。这样可以确保正确的参数已被提供，并且可以轻松区分集合中的不同类型的命令。通常，命令使用祈使句命名，因为它们是指令。例如，BringTroops、Surrender、SendSupplies等。
- en: 'Let''s transform our ugly simple command into a proper class:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们丑陋的简单命令转换成一个合适的类：
- en: '[PRE93]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We may wish to implement some logic to ensure that the parameters passed into
    the constructor are correct. This will ensure that the command fails on creation
    instead of on execution. It is easier to debug the issue during creation rather
    than during execution as execution could be delayed, even for days. The validation
    won't be perfect, but even if it catches only a small portion of the errors it
    is helpful.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望实现一些逻辑来确保传递给构造函数的参数是正确的。这将确保命令在创建时失败，而不是在执行时失败。在执行期间可能会延迟，甚至可能延迟几天。验证可能不完美，但即使它只能捕捉到一小部分错误，也是有帮助的。
- en: As mentioned these commands can be saved for later use in memory or even written
    to disk.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，这些命令可以保存在内存中以供以后使用，甚至可以写入磁盘。
- en: Invoker
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用者
- en: 'The invoker is the part of the command pattern which instructs the command
    to execute its instructions. The invoker can really be anything: a timed event,
    a user interaction, or just the next step in the process may all trigger invocation.
    When we executed the `simpleCommand` command in the preceding section, we were
    playing at being the invoker. In a more rigorous command the invoker might look
    something like the following:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者是命令模式的一部分，指示命令执行其指令。调用者实际上可以是任何东西：定时事件，用户交互，或者只是流程中的下一步都可能触发调用。在前面的部分中执行`simpleCommand`命令时，我们在扮演调用者的角色。在更严格的命令中，调用者可能看起来像下面这样：
- en: '[PRE94]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'As you can see, invoking a command is very easy. Commands may be invoked at
    once or at some later date. One popular approach is to defer the execution of
    the command to the end of the event loop. This can be done in a node with:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，调用命令非常容易。命令可以立即调用，也可以在以后的某个时间调用。一种流行的方法是将命令的执行推迟到事件循环的末尾。这可以在节点中完成：
- en: '[PRE95]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The function `process.nextTick` defers the execution of a command to the end
    of the event loop such that, if it is executed next time the process has nothing
    to do.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`process.nextTick`将命令的执行推迟到事件循环的末尾，以便在下次进程没有事情可做时执行。
- en: Receiver
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收者
- en: 'The final component in the command pattern is the receiver. This is the target
    of the command execution. In our example we created a receiver called `LordInstructions`
    :'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式中的最后一个组件是接收者。这是命令执行的目标。在我们的例子中，我们创建了一个名为`LordInstructions`的接收者：
- en: '[PRE96]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The receiver knows how to perform the action that the command has deferred.
    There need not be anything special about the receiver, in fact it may be any class
    at all.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者知道如何执行命令推迟的操作。实际上，接收者可能是任何类，而不必有任何特殊之处。
- en: Together these components make up the command pattern. A client will generate
    a command, pass it off to an invoker that may delay the command or execute it
    at once, and the command will act upon a receiver.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件共同构成了命令模式。客户端将生成一个命令，将其传递给一个调用者，该调用者可以延迟命令的执行或立即执行，然后命令将作用于接收者。
- en: In the case of building an undo stack, the commands are special, in that they
    have both an `Execute` and an `Undo` method. One takes the application state forward
    and the other takes it backwards. To perform an undo, simply pop the command off
    the undo stack, execute the `Undo` function, and push it onto a redo stack. For
    redo, pop from redo, execute `Execute` , and push to the undo stack. Simple as
    that, although one must make sure all state mutations are performed through commands.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建撤销堆栈的情况下，命令是特殊的，因为它们既有`Execute`方法，也有`Undo`方法。一个将应用程序状态推进，另一个将其推回。要执行撤销，只需从撤销堆栈中弹出命令，执行`Undo`函数，并将其推到重做堆栈上。对于重做，从重做中弹出，执行`Execute`，并推到撤销堆栈上。就是这么简单，尽管必须确保所有状态变化都是通过命令执行的。
- en: The GoF book outlines a slightly more complicated set of players for the command
    pattern. This is largely due to the reliance on interfaces that we've avoided
    in JavaScript. The pattern becomes much simpler thanks to the prototype inheritance
    model in JavaScript.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 《设计模式》一书概述了命令模式的一组稍微复杂的玩家。这在很大程度上是由于我们在JavaScript中避免了接口的依赖。由于JavaScript中的原型继承模型，该模式变得简单得多。
- en: The command pattern is a very useful one for deferring the execution of some
    piece of code. We'll actually explore the command pattern and some useful companion
    patterns in [Chapter 10](text00087.html#page "Chapter 10. Messaging Patterns")
    , *Messaging Patterns* .
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式是一个非常有用的模式，用于推迟执行某段代码。我们将在《第10章 消息模式》中实际探讨命令模式和一些有用的伴生模式。
- en: Interpreter
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释器
- en: The interpreter pattern is an interesting pattern as it allows for the creation
    of your own language. This might sound like something of a crazy idea, we're already
    writing JavaScript, why would we want to create a new language? Since the publication
    of the GoF book **Domain specific languages** ( **DSLs** ) have had something
    of a renaissance. There are situations where it is quite useful to create a language
    that is specific to one requirement. For instance the **Structured Query** **Language**
    ( **SQL** ) is very good at describing the querying of relational databases. Equally,
    regular expressions have proven themselves to be highly effective for the parsing
    and manipulation of text.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器模式是一种有趣的模式，因为它允许你创建自己的语言。这可能听起来有点疯狂，我们已经在写JavaScript了，为什么还要创建一个新的语言？自《设计模式》一书以来，领域特定语言（DSL）已经有了一些复兴。有些情况下，创建一个特定于某一需求的语言是非常有用的。例如，结构化查询语言（SQL）非常擅长描述对关系数据库的查询。同样，正则表达式已被证明在解析和操作文本方面非常有效。
- en: 'There are many scenarios in which being able to create a simple language is
    useful. That''s really the key: a simple language. Once the language gets more
    complicated, the advantages are quickly lost to the difficulty of creating what
    is, in effect, a compiler.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，能够创建一个简单的语言是有用的。这才是关键：一个简单的语言。一旦语言变得更加复杂，优势很快就会因为创建实际上是一个编译器的困难而丧失。
- en: This pattern is different from those we've seen to this point as there is no
    real class structure that is defined by the pattern. You can design your language
    interpreter however you wish.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式与我们到目前为止看到的模式不同，因为它没有真正由模式定义的类结构。你可以按照自己的意愿设计你的语言解释器。
- en: Example
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'For our example let us define a language which can be used to describe historical
    battles in the land of Westeros. The language must be simple for clerics to write
    and easy to read. We''ll start by creating a simple grammar:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，让我们定义一种语言，用于描述维斯特洛大陆上的历史战斗。这种语言必须简单易懂，便于文职人员编写。我们将从创建一个简单的语法开始：
- en: '[PRE97]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Here you can see that we''re just writing out a rather nice syntax that will
    let people describe battles. A battle between Robert Baratheon and RhaegarTargaryen
    at the river Trident would look like the following:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们只是写出了一个相当不错的语法，让人们描述战斗。罗伯特·拜拉席恩和雷加·坦格利安在三叉戟河之间的战斗将如下所示：
- en: '[PRE98]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Using this grammar we would like to build some code which is able to query a
    list of battles for answers. In order to do this we're going to rely on regular
    expressions. For most languages this wouldn't be a good approach as the grammar
    is too complicated. In those cases one might wish to create a lexor and a parser
    and build up syntax trees, however, by that point you may wish to re-examine if
    creating a DSL is really a good idea. For our language the syntax is very simple
    so we can get away with regular expressions.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种语法，我们希望构建一些能够查询战斗列表的代码。为了做到这一点，我们将依赖于正则表达式。对于大多数语言来说，这不是一个好的方法，因为语法太复杂。在这种情况下，人们可能希望创建一个词法分析器和一个解析器，并构建语法树，然而，到了那个时候，你可能会希望重新审视一下是否创建DSL真的是一个好主意。对于我们的语言，语法非常简单，所以我们可以使用正则表达式。
- en: Implementation
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'The first thing we establish is a JavaScript data model for the battle like
    so:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为战斗建立一个JavaScript数据模型，如下所示：
- en: '[PRE99]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Next we need a parser:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要一个解析器：
- en: '[PRE100]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'It is likely best that you don''t think too much about that regular expression.
    However, the class does take in a list of battles (one per line) and using `next
    Battle` , allows one to parse them. To use the class we simply need to do the
    following:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要太在意那个正则表达式。然而，这个类确实接受一系列战斗（每行一个），并使用`next Battle`，允许解析它们。要使用这个类，我们只需要做以下操作：
- en: '[PRE101]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'This will be the output:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是输出：
- en: '[PRE102]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This data structure can now be queried like one would for any other structure
    in JavaScript.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以像查询JavaScript中的任何其他结构一样查询这个数据结构了。
- en: As I mentioned earlier there is no fixed way to implement this pattern, so the
    implementation done in the preceding code is provided simply as an example. Your
    implementation will very likely look very different and that is just fine.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，实现这种模式没有固定的方式，因此在前面的代码中所做的实现只是提供了一个例子。你的实现很可能会看起来非常不同，这也是可以的。
- en: Interpreter can be a useful pattern in JavaScript. It is, however, a pretty
    infrequently used pattern in most situations. The best example of a language interpreted
    in JavaScript is the less language that is compiled, by JavaScript, to CSS.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器在JavaScript中可能是一个有用的模式。然而，在大多数情况下，这是一个相当少用的模式。JavaScript中解释的最佳示例是编译为CSS的语言。
- en: Iterator
  id: totrans-558
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: Traversing collections of objects is an amazingly common problem. So much so
    that many languages provide for special constructs just for moving through collections.
    For example C# has a `foreach` loop and Python has `for x in` . These looping
    constructs are frequently built on top of an iterator. An iterator is a pattern
    that provides a simple method for selecting, sequentially, the next item in a
    collection.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历对象集合是一个非常常见的问题。以至于许多语言都提供了专门的构造来遍历集合。例如，C#有`foreach`循环，Python有`for x in`。这些循环构造经常建立在迭代器之上。迭代器是一种模式，提供了一种简单的方法，按顺序选择集合中的下一个项目。
- en: 'The interface for an iterator looks like this:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的接口如下：
- en: '[PRE103]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Implementation
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'In the land of Westeros there is a well-known sequence of people in line for
    the throne in the very unlikely event that the king was to die. We can set up
    a handy iterator over the top of this collection and simply call `next` on it
    should the ruler die:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛大陆，有一个众所周知的人们排队等候王位的序列，以备国王不幸去世的情况。我们可以在这个集合上设置一个方便的迭代器，如果统治者去世，只需简单地调用`next`：
- en: '[PRE104]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This is primed with an array and then we can call it:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用一个数组初始化的，然后我们可以调用它：
- en: '[PRE105]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'An interesting application of iterators is to not iterate over a fixed collection.
    For instance an iterator can be used to generate sequential members of an infinite
    set like the fibonacci sequence:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的一个有趣的应用是不仅仅迭代一个固定的集合。例如，迭代器可以用来生成无限集合的顺序成员，比如斐波那契序列：
- en: '[PRE106]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'This is used like so:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这样使用：
- en: '[PRE107]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Iterators are handy constructs allowing for exploring not just arrays but any
    collection or even any generated list. There are a ton of places where this can
    be used to great effect.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是方便的构造，允许探索不仅仅是数组，而且是任何集合，甚至是任何生成的列表。有很多地方可以大量使用这个。
- en: ECMAScript 2015 iterators
  id: totrans-572
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ECMAScript 2015迭代器
- en: 'Iterators are so useful that they are actually part of the next generation
    of JavaScript. The iterator pattern used in ECMAScript 2015 is a single method
    that returns an object that contains `done` and `value` . `done` is `true` when
    the iterator is at the end of the collection. What is nice about the ECMAScript
    2015 iterators is that the array collection in JavaScript will support the iterator.
    This opens up a new syntax which can largely replace the `for` loop:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是如此有用，以至于它们实际上是JavaScript下一代的一部分。ECMAScript 2015中使用的迭代器模式是一个返回包含`done`和`value`的对象的单个方法。当迭代器在集合的末尾时，`done`为`true`。ECMAScript
    2015迭代器的好处是JavaScript中的数组集合将支持迭代器。这开辟了一种新的语法，可以在很大程度上取代`for`循环：
- en: '[PRE108]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Iterators are a syntactic nicety that has long been missing from JavaScript.
    Another great feature of ECMAScript-2015 are generators. This is, in effect, a
    built in iterator factory. Our fibonacci sequence could be rewritten like the
    following:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是JavaScript长期以来一直缺少的一种语法上的美好。ECMAScript-2015的另一个很棒的特性是生成器。这实际上是一个内置的迭代器工厂。我们的斐波那契序列可以重写如下：
- en: '[PRE109]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This is used like so:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这样使用：
- en: '[PRE110]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Mediator
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介者
- en: Managing many-to-many relationships in classes can be a complicated prospect.
    Let's consider a form that contains a number of controls, each of which wants
    to know if other controls on the page are valid before performing their action.
    Unfortunately, having each control know about each other control creates a maintenance
    nightmare. Each time a new control is added, each other control needs to be modified.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中管理多对多关系可能是一个复杂的前景。让我们考虑一个包含多个控件的表单，每个控件都想在执行操作之前知道页面上的其他控件是否有效。不幸的是，让每个控件都知道其他控件会创建一个维护噩梦。每次添加一个新控件，都需要修改每个其他控件。
- en: 'A mediator will sit between the various components and act as a single place
    in which message routing changes can be made. By doing so the mediator simplifies
    the otherwise complex work needed to maintain the code. In the case of controls
    on a form, the mediator is likely to be the form itself. The mediator acts much
    like a real life mediator would, clarifying and routing information exchange between
    a number of parties:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者将坐在各种组件之间，并作为一个单一的地方，可以进行消息路由的更改。通过这样做，中介者简化了维护代码所需的复杂工作。在表单控件的情况下，中介者很可能是表单本身。中介者的作用很像现实生活中的中介者，澄清和路由各方之间的信息交流：
- en: '![Mediator](Image00024.jpg)'
  id: totrans-582
  prefs: []
  type: TYPE_IMG
  zh: '![中介者](Image00024.jpg)'
- en: Implementation
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: In the land of Westeros there are many times when a mediator is needed. Frequently
    the mediator ends up deceased, but I'm sure that won't be the case with our example.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛大陆，经常需要中介者。中介者经常会死去，但我相信这不会发生在我们的例子中。
- en: There are a number of great families in Westeros who own large castles and vast
    tracts of land. Lesser lords swear themselves to the great houses forming an alliance,
    frequently supported through marriage.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛大陆有许多伟大的家族拥有大城堡和广阔的土地。次要领主们向大家族宣誓效忠，形成联盟，经常通过婚姻得到支持。
- en: When coordinating the various houses sworn to them, the great lord will act
    as a mediator, communicating information back and forth between the lesser lords
    and resolving any disputes they may have amongst themselves.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在协调各家族的时候，大领主将充当中介者，来回传递信息并解决他们之间可能发生的任何争端。
- en: 'In this example we''ll greatly simplify the communication between the houses
    and say that all messages pass through the great lord. In this case we''ll use
    the house of Stark as our great lord. They have a number of other houses which
    talk with them. Each of the houses looks roughly like the following:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将大大简化各家之间的通信，并说所有消息都通过大领主传递。在这种情况下，我们将使用史塔克家作为我们的大领主。他们有许多其他家族与他们交谈。每个家族看起来大致如下：
- en: '[PRE111]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'They have two functions, one of which receives messages from a third party
    and one of which sends messages out to their great lord, which is set upon instantiation.
    The `HouseStark` class looks like the following:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有两个函数，一个接收来自第三方的消息，一个发送消息给他们的大领主，这是在实例化时设置的。`HouseStark`类如下所示：
- en: '[PRE112]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: By passing all messages through the `HouseStark` class the various other houses
    do not need to concern themselves with how their messages are routed. This responsibility
    is handed off to `HouseStark` which acts as the mediator.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`HouseStark`类传递所有消息，其他各个家族不需要关心它们的消息是如何路由的。这个责任被交给了`HouseStark`，它充当了中介。
- en: Mediators are best used when the communication is both complex and well defined.
    If the communication is not complex then the mediator adds extra complexity. If
    the communication is ill defined then it becomes difficult to codify the communication
    rules in a single place.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者最适合用于通信既复杂又明确定义的情况。如果通信不复杂，那么中介者会增加额外的复杂性。如果通信不明确定义，那么在一个地方对通信规则进行编码就变得困难。
- en: 'Simplifying communication between many-to-many objects is certainly useful
    in JavaScript. I would actually argue that in many ways jQuery acts as a mediator.
    When acting on a set of items on the page, it serves to simplify communication
    by abstracting away code''s need to know exactly which objects on the page are
    being changed. For instance:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，简化多对多对象之间的通信肯定是有用的。我实际上认为在许多方面，jQuery充当了中介者。在页面上操作一组项目时，它通过抽象掉代码需要准确知道页面上哪些对象正在被更改来简化通信。例如：
- en: '[PRE113]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Is jQuery shorthand for toggling the visibility of all the elements on the page
    which have the `error` class?
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是切换页面上所有具有`error`类的元素的可见性的简写吗？
- en: Memento
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备忘录
- en: 'In the section on the command pattern we talked briefly about the ability to
    undo operations. Creating reversible commands is not always possible. For many
    operations there is no apparent reversing operation which can restore the original
    state. For instance, imagine code which squares a number:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令模式的部分，我们简要讨论了撤销操作的能力。创建可逆命令并非总是可能的。对于许多操作，没有明显的逆向操作可以恢复原始状态。例如，想象一下对一个数字进行平方的代码：
- en: '[PRE114]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Giving this code -9 will result in 81 but giving it 9 will also result in 81\.
    There is no way to reverse this command without additional information.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 给这段代码-9将得到81，但给它9也将得到81。没有办法在没有额外信息的情况下撤销这个命令。
- en: The memento pattern provides an approach to restore the state of objects to
    a previous state. The memento keeps a record of the previous values of a variable
    and provides the functionality to restore them. Keeping a memento around for each
    command allows for easy restoration of non-reversible commands.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录模式提供了一种恢复对象状态到先前状态的方法。备忘录记录了变量先前的值，并提供了恢复它们的功能。为每个命令保留一个备忘录可以轻松恢复不可逆转的命令。
- en: 'In addition to an undo-stack there are many instances where having the ability
    to roll back the state of an object is useful. For instance doing what-if analysis
    requires that you make some hypothetical changes to state and then observe how
    things change. The changes are generally not permanent so they could be rolled
    back using the memento pattern or, if the projects are desirable, left in place.
    A diagram of the memento pattern can be seen here:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 除了撤销堆栈之外，还有许多情况下，具有回滚对象状态的能力是有用的。例如，进行假设分析需要对状态进行一些假设性的更改，然后观察事物如何变化。这些更改通常不是永久性的，因此可以使用备忘录模式进行回滚，或者如果项目是可取的，可以保留下来。备忘录模式的图表可以在这里看到：
- en: '![Memento](Image00025.jpg)'
  id: totrans-602
  prefs: []
  type: TYPE_IMG
  zh: '![备忘录](Image00025.jpg)'
- en: 'A typical memento implementation involves three players:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的备忘录实现涉及三个角色：
- en: '**Originator** : The originator holds some form of state and provides an interface
    for generating new mementos.'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始对象**：原始对象保存某种状态并提供生成新备忘录的接口。'
- en: '**Caretaker** : This is the client of the pattern, it is what requests that
    new mementos be taken and governs when they are to be restored.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**看护者**：这是模式的客户端，它请求获取新备忘录并管理何时进行恢复。'
- en: '**Memento** : This is a representation of the saved state of the originator.
    This is what can be persisted to storage to allow for rolling back.'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备忘录**：这是原始对象保存状态的表示。这可以持久化到存储中以便进行回滚。'
- en: It can help to think of the members of the memento pattern as a boss and a secretary
    taking notes. The boss (caretaker) dictates some memo to the secretary (originator)
    who writes notes in a notepad (memento). From time to time the boss may request
    that the secretary cross out what he has just written.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 将备忘录模式的成员想象成老板和秘书做笔记可能会有所帮助。老板（看护者）向秘书（原始对象）口述备忘录，秘书在记事本（备忘录）上写下笔记。偶尔老板可能会要求秘书划掉他刚刚写的内容。
- en: The involvement of the caretaker can be varied slightly with the memento pattern.
    In some implementation the originator will generate a new memento each time a
    change is made to its state. This is commonly known as copy on write, as a new
    copy of the state is created and the change applied to it. The old version can
    be saved to a memento.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 与备忘录模式相关的看护者的参与可以有所不同。在某些实现中，原始对象在其状态发生变化时会生成一个新的备忘录。这通常被称为写时复制，因为会创建状态的新副本并应用变化。旧版本可以保存到备忘录中。
- en: Implementation
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: In the land of Westeros there are a number of soothsayers, foretellers of the
    future. They work by using magic to peer into the future and examine how certain
    changes in the present will play out in the future. Often there is need for numerous
    foretelling with slightly different starting conditions. When setting their starting
    conditions, a memento pattern is invaluable.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛大陆上有许多预言者，他们是未来的预言者。他们通过使用魔法来窥视未来，并检查当前的某些变化将如何在未来发挥作用。通常需要进行许多略有不同起始条件的预测。在设置起始条件时，备忘录模式是非常宝贵的。
- en: 'We start off with a world state which gives information on the state of the
    world for a certain starting point:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个世界状态开始，它提供了某个特定起点的世界状态信息：
- en: '[PRE115]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: This `WorldState` class is responsible for tracking all the conditions that
    make up the world. It is what is altered by the application every time a change
    to the starting conditions is made. Because this world state encompasses all the
    states for the application, it can be used as a memento. We can serialize this
    object and save it to disk or send it back to some history server somewhere.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`WorldState`类负责跟踪构成世界的所有条件。每当对起始条件进行更改时，应用程序都会修改它。因为这个世界状态包含了应用程序的所有状态，所以它可以被用作备忘录。我们可以将这个对象序列化并保存到磁盘上，或者发送回某个历史服务器。
- en: 'The next thing we need is a class which provides the same state as the memento
    and allows for the creation and restoration of mementos. In our example we''ve
    called this as `WorldStateProvider` :'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要一个类，它提供与备忘录相同的状态，并允许创建和恢复备忘录。在我们的示例中，我们将其称为`WorldStateProvider`：
- en: '[PRE116]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Finally we need a client for the foretelling, which we''ll call `Soothsayer`
    :'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个预言者的客户端，我们将称之为`Soothsayer`：
- en: '[PRE117]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This class provides a number of convenience methods which alter the state of
    the world and then run a foretelling. Each of these methods pushes the previous
    state into the history array, `startingPoints` . There is also a method, `tryADifferentChange`
    , which undoes the previous state change ready to run another foretelling. The
    undo is performed by loading back the memento which is stored in an array.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了一些方便的方法，它们改变了世界的状态，然后运行了一个预言。这些方法中的每一个都将先前的状态推入历史数组`startingPoints`。还有一个方法`tryADifferentChange`，它撤销了先前的状态更改，准备运行另一个预言。撤销是通过加载存储在数组中的备忘录来执行的。
- en: Despite a great pedigree it is very rare that client side JavaScript applications
    provide an undo function. I'm sure there are various reasons for this, but for
    the most part it is likely that people do not expect such functionality. However
    in most desktop applications, having an undo function is expected. I imagine that,
    as client side applications continue to grow in their capabilities, undo functionality
    will become more important. When it does, the memento pattern is a fantastic way
    of implementing the undo stack.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管客户端JavaScript应用有很高的血统，但提供撤销功能却非常罕见。我相信这其中有各种原因，但大部分原因可能是人们并不期望有这样的功能。然而，在大多数桌面应用程序中，撤销功能是被期望的。我想，随着客户端应用程序在功能上不断增强，撤销功能将变得更加重要。当这种情况发生时，备忘录模式是实现撤销堆栈的一种绝妙方式。
- en: Observer
  id: totrans-620
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者
- en: The observer pattern is perhaps the most used pattern in the JavaScript world.
    The pattern is used especially with modern single pages applications; it is a
    big part of the various libraries that provide **Model View View-Model** ( **MVVM**
    ) functionality. We'll explore those patterns in some detail in [Chapter 7](text00067.html#page
    "Chapter 7. Reactive Programming") , *Reactive Programming* .
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式可能是JavaScript世界中使用最多的模式。这种模式特别在现代单页应用程序中使用；它是提供**模型视图视图模型**（**MVVM**）功能的各种库的重要组成部分。我们将在[第7章](text00067.html#page
    "第7章。响应式编程")中详细探讨这些模式，*响应式编程*。
- en: 'It is frequently useful to know when the value on an object has changed. In
    order to do so you could wrap up the property of interest with a getter and setter:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 经常有必要知道对象的值何时发生了变化。为了做到这一点，您可以用getter和setter包装感兴趣的属性：
- en: '[PRE118]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The setter function can now be augmented with a call to some other object which
    is interested in knowing that a value has changed:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: setter函数现在可以增加对其他对值发生变化感兴趣的对象的调用：
- en: '[PRE119]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This setter will now notify the listener that a property change has occurred.
    In this case both the old and new value have been included. This is not necessary
    as the listener can be tasked with keeping track of the previous value.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个setter将通知监听器属性已发生变化。在这种情况下，旧值和新值都已包括在内。这并不是必要的，因为监听器可以负责跟踪先前的值。
- en: 'The observer pattern generalizes and codifies this idea. Instead of having
    a single call to the listener, the observer pattern allows interested parties
    to subscribe to change notifications. Multiple subscribers can be seen in the
    following diagram:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式概括和规范了这个想法。观察者模式允许感兴趣的各方订阅变化通知，而不是只有一个调用监听器的单个调用。多个订阅者可以在下图中看到：
- en: '![Observer](Image00026.jpg)'
  id: totrans-628
  prefs: []
  type: TYPE_IMG
  zh: '![Observer](Image00026.jpg)'
- en: Implementation
  id: totrans-629
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: The court of Westeros is a place of great intrigue and trickery. Controlling
    who is on the throne and what moves they make is a complex game. Many of the players
    in the game of thrones employ numerous spies to discover what moves others are
    making. Frequently these spies are employed by more than one player and must report
    what they have found to all of the players.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 维斯特洛的法庭是一个充满阴谋和诡计的地方。控制谁坐在王位上，以及他们的行动，是一个复杂的游戏。权力的游戏中的许多玩家雇佣了许多间谍来发现其他人的行动。这些间谍经常被多个玩家雇佣，并必须向所有玩家报告他们所发现的情况。
- en: The spy is a perfect place to employ the observer pattern. In our particular
    example, the spy being employed is the official doctor to the king and the players
    are very interested in how much painkiller is being prescribed to the ailing king.
    Knowing this can give a player advanced knowledge of when the king might die –
    a most useful piece of information.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍是使用观察者模式的理想场所。在我们的特定示例中，被雇佣的间谍是国王的官方医生，玩家们非常关心给这位患病的国王开了多少止痛药。知道这一点可以让玩家提前知道国王可能何时去世
    - 这是一个非常有用的信息。
- en: 'The spy looks like the following:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍看起来像下面这样：
- en: '[PRE120]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'In other languages, the subscriber usually has to comply with a certain interface
    and the observer will call only the interface method. This encumbrance doesn''t
    exist with JavaScript and, in fact, we just give the `Spy` class a function. This
    means that there is no strict interface required for the subscriber. This is an
    example:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，订阅者通常必须遵守某个接口，观察者只会调用接口方法。这种负担在JavaScript中不存在，事实上，我们只给`Spy`类一个函数。这意味着订阅者不需要严格的接口。这是一个例子：
- en: '[PRE121]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'This can be used like so:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 可以这样使用：
- en: '[PRE122]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This provides a very simple and highly effective way of building observers.
    Having subscribers decouples the subscriber from the observable object.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一种非常简单和高效的构建观察者的方法。订阅者使订阅者与可观察对象解耦。
- en: The observer pattern can also be applied to methods as well as properties. In
    so doing you can provide hooks for additional behavior to happen. This is a common
    method of providing a plugin infrastructure for JavaScript libraries.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式也可以应用于方法和属性。通过这样做，可以提供用于发生附加行为的钩子。这是为JavaScript库提供插件基础设施的常见方法。
- en: 'In browsers all the event listeners on various items in the DOM are implemented
    using the observer pattern. For instance, using the popular jQuery library, one
    can subscribe to all the `click` events on buttons on a page by doing the following:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，DOM中各种项目上的所有事件监听器都是使用观察者模式实现的。例如，使用流行的jQuery库，可以通过以下方式订阅页面上所有按钮的`click`事件：
- en: '[PRE123]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Even in vanilla JavaScript the same pattern applies:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在纯JavaScript中，相同的模式也适用：
- en: '[PRE124]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Clearly the observer pattern is very useful when dealing with JavaScript. There
    is no need to change the pattern in any significant fashion.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，观察者模式在处理JavaScript时非常有用。没有必要以任何重大方式改变模式。
- en: State
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: 'State machines are an amazingly useful device in computer programming. Unfortunately
    they are not used very frequently by most programmers. I''m sure that at least
    some of the objection to state machines is that many people implement them as
    a giant `if` statement like so:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机在计算机编程中是一个非常有用的设备。不幸的是，大多数程序员并不经常使用它们。我相信对状态机的一些反对意见至少部分是因为许多人将它们实现为一个巨大的`if`语句，如下所示：
- en: '[PRE125]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This is just a sample of what could be much longer. The `if` statements of this
    length are painful to debug and highly error prone. Simply flipping a greater
    than sign is enough to drastically change how the `if` statement works.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个可能更长的示例。这样长的`if`语句很难调试，而且容易出错。只需翻转一个大于号就足以大大改变`if`语句的工作方式。
- en: 'Instead of using a single giant `if` statement block we can make use of the
    state pattern. The state pattern is characterized by having a state manager which
    abstracts away the internal state and proxies a message through to the appropriate
    state which is implemented as a class. All the logic within states and governing
    state transitions is governed by the individual state classes. The state manager
    pattern can be seen in the following diagram:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用单个巨大的`if`语句块，我们可以利用状态模式。状态模式的特点是有一个状态管理器，它抽象了内部状态，并将消息代理到适当的状态，该状态实现为一个类。所有状态内部的逻辑和状态转换的控制都由各个状态类管理。状态管理器模式可以在以下图表中看到：
- en: '![State](Image00027.jpg)'
  id: totrans-650
  prefs: []
  type: TYPE_IMG
  zh: '![State](Image00027.jpg)'
- en: Splitting state into a class per state allows for much smaller blocks of code
    to debug and makes testing much easier.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态分为每个状态一个类允许更小的代码块进行调试，并且使测试变得更容易。
- en: The interface for the state manager is fairly simple and usually just provides
    the methods needed to communicate with the individual states. The manager may
    also contain some shared state variables.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理器的接口非常简单，通常只提供与各个状态通信所需的方法。管理器还可以包含一些共享状态变量。
- en: Implementation
  id: totrans-653
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: As alluded to in the `if` statement example, Westeros has a banking system.
    Much of it is centered on the island of Braavos. Banking there runs in much the
    same way as banking here, with accounts, deposits, and withdrawals. Managing the
    state of a bank account involves keeping an eye on all of the transactions and
    changing the state of the bank account in accordance with the transactions.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在`if`语句示例中所暗示的，维斯特洛有一个银行系统。其中大部分集中在布拉沃斯岛上。那里的银行业务与这里的银行业务基本相同，包括账户、存款和取款。管理银行账户的状态涉及监视所有交易并根据交易改变银行账户的状态。
- en: 'Let''s take a look at some of the code which is needed to manage a bank account
    at the Iron Bank of Braavos. First is the state manager:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看管理布拉沃斯银行账户所需的一些代码。首先是状态管理器：
- en: '[PRE126]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The `BankAccountManager` class provides a state for the current balance and
    also the current state. To protect the balance, it provides an accessory for reading
    the balance and another for adding to the balance. In a real banking application,
    I would rather expect the function that sets the balance, have more protection
    than this. In this version of `BankManager` , the ability to manipulate the current
    state is accessible to the states. They have the responsibility to change states.
    This functionality can be centralized in the manager but that increases the complexity
    of adding new states.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '`BankAccountManager`类提供了当前余额和当前状态的状态。为了保护余额，它提供了一个用于读取余额的辅助工具，另一个用于增加余额。在真实的银行应用程序中，我更希望设置余额的功能比这个更有保护性。在这个`BankManager`版本中，操作当前状态的能力对状态是可访问的。它们有责任改变状态。这个功能可以集中在管理器中，但这会增加添加新状态的复杂性。'
- en: 'We''ve identified three simple states for the bank account: `Overdrawn` , `OnHold`
    , and `GoodStanding` . Each one is responsible for dealing with withdrawals and
    deposits when in that state. The `GoodStandingstate` class looks like the following:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为银行账户确定了三种简单的状态：`Overdrawn`，`OnHold`和`GoodStanding`。每个状态在该状态下负责处理取款和存款。`GoodStandingstate`类如下所示：
- en: '[PRE127]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The `OverdrawnState` class looks like the following:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '`OverdrawnState`类如下所示：'
- en: '[PRE128]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Finally, the `OnHold` state looks like the following:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`OnHold`状态如下所示：
- en: '[PRE129]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: You can see that we've managed to reproduce all the logic of the confusing `if`
    statement in a number of simple classes. The amount of code here looks to be far
    more than the `if` statement but, in the long run, encapsulating the code into
    individual classes will pay off.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们已经成功地将混乱的`if`语句的所有逻辑重现在一些简单的类中。这里的代码量看起来比`if`语句要多得多，但从长远来看，将代码封装到单独的类中将会得到回报。
- en: 'There is plenty of opportunity to make use of this pattern within JavaScript.
    Keeping track of state is a typical problem in most applications. When the transitions
    between the states are complex, then wrapping it up in a state pattern is one
    method of simplifying things. It is also possible to build up a simple workflow
    by registering events as sequential. A nice interface for this might be a fluent
    one so that you could register states like the following:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中有很多机会可以利用这种模式。跟踪状态是大多数应用程序中的典型问题。当状态之间的转换很复杂时，将其封装在状态模式中是简化事情的一种方法。还可以通过按顺序注册事件来构建简单的工作流程。这样做的一个好接口可能是流畅的，这样你就可以注册以下状态：
- en: '[PRE130]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Strategy
  id: totrans-667
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略
- en: 'It has been said that there is more than one way to skin a cat. I have, wisely,
    never looked into how many ways there are. The same is frequently true for algorithms
    in computer programming. Frequently there are numerous versions of an algorithm
    that trades off memory usage for CPU usage. Sometimes there are different approaches
    that provide different levels of fidelity. For example, performing a geo-location
    on a smart phone typically uses one of three different sources of data:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 有人说过有很多种方法可以剥猫皮。我明智地从未研究过有多少种方法。在计算机编程中，算法也经常如此。通常有许多版本的算法，它们在内存使用和CPU使用之间进行权衡。有时会有不同的方法提供不同级别的保真度。例如，在智能手机上执行地理定位通常使用三种不同的数据来源之一：
- en: GPS chip
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPS芯片
- en: Cell phone triangulation
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手机三角定位
- en: Nearby WiFi points
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附近的WiFi点
- en: Using the GPS chip provides the highest level of fidelity however it is also
    the slowest and requires the most battery. Looking at the nearby WiFi points requires
    very little energy and is very quick, however it provides poor fidelity.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GPS芯片提供了最高级别的保真度，但也是最慢的，需要最多的电池。查看附近的WiFi点需要非常少的能量，速度非常快，但提供的保真度较低。
- en: 'The strategy pattern provides a method of swapping these strategies out in
    a transparent fashion. In a traditional inheritance model each strategy would
    implement the same interface which would allow for any of the strategies to be
    swapped in. The following diagram shows multiple strategies that could be swapped
    in:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式提供了一种以透明方式交换这些策略的方法。在传统的继承模型中，每个策略都会实现相同的接口，这将允许任何策略进行交换。下图显示了可以进行交换的多个策略：
- en: '![Strategy](Image00028.jpg)'
  id: totrans-674
  prefs: []
  type: TYPE_IMG
  zh: '![策略](Image00028.jpg)'
- en: Selecting the correct strategy to use can be done in a number of different ways.
    The simplest method is to select the strategy statically. This can be done through
    a configuration variable or even hard coded. This approach is best for times when
    the strategy changes infrequently or is specific to a single customer or user.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的策略可以通过多种不同的方式来完成。最简单的方法是静态选择策略。这可以通过配置变量或甚至硬编码来完成。这种方法最适合策略变化不频繁或特定于单个客户或用户的情况。
- en: Alternately an analysis can be run on the dataset on which the strategy is to
    be run and then a proper strategy selected. If it is known that strategy A works
    better than strategy B when the data passed in is clustered around a mean, then
    a fast algorithm for analyzing spread could be run first and then the appropriate
    strategy selected.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可以对要运行策略的数据集进行分析，然后选择合适的策略。如果已知策略A在数据传入时比策略B更好，那么可以首先运行一个快速的分析传播的算法，然后选择适当的策略。
- en: If a particular algorithm fails on data of a certain type, this too can be taken
    into consideration when choosing a strategy. In a web application this can be
    used to call a different API depending on the shape of data. It can also be used
    to provide a fallback mechanism should one of the API endpoints be down.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 如果特定算法在某种类型的数据上失败，这也可以在选择策略时考虑进去。在Web应用程序中，这可以用于根据数据的形状调用不同的API。它还可以用于在API端点之一宕机时提供备用机制。
- en: Another interesting approach is to use progressive enhancement. The fastest
    and least accurate algorithm is run first to provide rapid user feedback. At the
    same time a slower algorithm is also run and, when it is finished, the superior
    results are used to replace the existing results. This approach is frequently
    used in the GPS situation outlined above. You may notice when using a map on a
    mobile device your location is updated a moment after the map loads; this is an
    example of progressive enhancement.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有趣的方法是使用渐进增强。首先运行最快且最不准确的算法以提供快速的用户反馈。同时也运行一个较慢的算法，当它完成时，优越的结果将用于替换现有的结果。这种方法经常用于上面概述的GPS情况。您可能会注意到，在移动设备上使用地图时，地图加载后一会儿您的位置会更新；这是渐进增强的一个例子。
- en: Finally, the strategy can be chosen completely at random. It sounds like a strange
    approach but can be useful when comparing the performance of two different strategies.
    In this case, statistics would be gathered about how well each approach works
    and an analysis run to select the best strategy. The strategy pattern can be the
    foundation for A/B testing.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，策略可以完全随机选择。这听起来像是一种奇怪的方法，但在比较两种不同策略的性能时可能会有用。在这种情况下，将收集关于每种方法的表现如何的统计数据，并进行分析以选择最佳策略。策略模式可以成为A/B测试的基础。
- en: Selecting which strategy to use can be an excellent place to apply the factory
    pattern.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要使用的策略可以是应用工厂模式的绝佳地方。
- en: Implementation
  id: totrans-681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'In the land of Westeros there are no planes, trains, or automobiles but there
    is still a wide variety of different ways to travel. One can walk, ride a horse,
    sail on a seagoing vessel, or even take a boat down the river. Each one has different
    advantages and drawbacks but in the end they still take a person from point A
    to point B. The interface might look something like the following:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛大陆，没有飞机、火车或汽车，但仍然有各种不同的旅行方式。人们可以步行、骑马、乘船航行，甚至可以坐船沿河而下。每种方式都有不同的优点和缺点，但最终它们都能把一个人从A点带到B点。接口可能看起来像下面这样：
- en: '[PRE131]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The travel result communicates back to the caller some information about the
    method of travel. In our case we track how long the trip will take, what the risks
    are, and how much it will cost:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行结果向调用者传达了一些关于旅行方式的信息。在我们的情况下，我们追踪旅行需要多长时间，风险是什么，以及费用是多少：
- en: '[PRE132]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: In this scenario we might like to have an additional method which predicts some
    of the risks to allow for automating selection of a strategy.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能希望有一个额外的方法来预测一些风险，以便自动选择策略。
- en: 'Implementing the strategies is as simple as the following:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 实现策略就像下面这样简单：
- en: '[PRE133]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: In a traditional implementation of the strategy pattern the method signature
    for each strategy should be the same. In JavaScript there is a bit more flexibility
    as excess parameters to a function are ignored and missing parameters can be given
    default values.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 在策略模式的传统实现中，每个策略的方法签名应该相同。在JavaScript中，函数的多余参数会被忽略，缺少的参数可以给出默认值，因此有更多的灵活性。
- en: 'Obviously, the actual calculations around risk, cost, and duration would not
    be hard coded in an actual implementation. To make use of these one needs only
    to do the following:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，实际实现中风险、成本和持续时间的实际计算不会硬编码。要使用这些方法，只需要做以下操作：
- en: '[PRE134]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'To improve the level of abstraction for this strategy we might replace the
    specific strategies with more generally named ones that describe what it is we''re
    optimizing for:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高这种策略的抽象级别，我们可以用更一般的名称替换具体的策略，描述我们要优化的内容：
- en: '[PRE135]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Strategy is a very useful pattern in JavaScript. We''re also able to make the
    approach much simpler than in a language which doesn''t use prototype inheritance:
    there is no need for an interface. We don''t need to return the same shaped object
    from each of the different strategies. So long as the caller is somewhat aware
    that the returned object may have additional fields, this is a perfectly reasonable,
    if difficult to maintain, approach.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式在JavaScript中是一个非常有用的模式。我们能够使这种方法比在不使用原型继承的语言中更简单：不需要接口。我们不需要从不同的策略中返回相同形状的对象。只要调用者有点意识到返回的对象可能有额外的字段，这是一个完全合理的，虽然难以维护的方法。
- en: Template method
  id: totrans-695
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法
- en: 'The strategy pattern allows for replacing an entire algorithm with a complimentary
    one. Frequently, replacing the entire algorithm is overkill: the vast majority
    of the algorithm remains the same in every strategy with only minor variations
    in specific sections.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式允许用一个互补的算法替换整个算法。经常替换整个算法是过度的：绝大部分算法在每个策略中仍然保持相同，只有特定部分有轻微的变化。
- en: 'The template method pattern is an approach which allows for some sections of
    an algorithm to be shared and other sections implemented using different approaches.
    These farmed out sections can be implemented by any one of a family of methods:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式是一种方法，允许共享算法的一些部分，并使用不同的方法实现其他部分。这些外包部分可以由方法家族中的任何一个方法来实现：
- en: '![Template method](Image00029.jpg)'
  id: totrans-698
  prefs: []
  type: TYPE_IMG
  zh: '![模板方法](Image00029.jpg)'
- en: The template class implements parts of the algorithm and leaves other parts
    as abstract to later be overridden by classes which extend it. The inheritance
    hierarchy can be several layers deep, with each level implementing more and more
    of the template class.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 模板类实现了算法的部分，并将其他部分留作抽象，以便稍后由扩展它的类来覆盖。继承层次结构可以有几层深，每个级别都实现了模板类的更多部分。
- en: Tip
  id: totrans-700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: An abstract class is one that contains abstract methods. Abstract methods are
    simply methods that have no body to them. The abstract class cannot be used directly
    and must, instead, be extended by another class that implements the abstract methods.
    An abstract class may extend another abstract class so that not all methods need
    to be implemented by the extending class.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是包含抽象方法的类。抽象方法只是没有方法体的方法。抽象类不能直接使用，必须由另一个实现抽象方法的类来扩展。抽象类可以扩展另一个抽象类，以便不需要所有方法都由扩展类实现。
- en: 'This approach applies the principles of progressive enhancement to an algorithm.
    We move closer and closer to a fully implemented algorithm and, at the same time,
    build up an interesting inheritance tree. The template method helps keep identical
    code to a single location while still allowing for some deviation. A chain of
    partial implementations can be seen in the following diagram:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将渐进增强的原则应用到算法中。我们越来越接近一个完全实现的算法，同时建立一个有趣的继承树。模板方法有助于将相同的代码保持在一个位置，同时允许一些偏差。部分实现的链可以在下图中看到：
- en: '![Template method](Image00030.jpg)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
  zh: '![模板方法](Image00030.jpg)'
- en: Overriding methods left as abstract is a quintessential part of object oriented
    programming. It is likely that this pattern is one which you've used frequently
    without even being aware that it had a name.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 重写留作抽象的方法是面向对象编程的一个典型部分。很可能你经常使用这种模式，甚至没有意识到它有一个名字。
- en: Implementation
  id: totrans-705
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: I have been told, by those in the know, that there are many different ways to
    produce beer. These beers differ in their choice of ingredients and in their method
    of production. In fact beer does not even need to contain hops – it can be made
    from any number of grains. However there are similarities between all beers. They
    are all created through the fermentation process and all proper beers contain
    some alcohol content.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经被知情人告知，有许多不同的酿造啤酒的方法。这些啤酒在选择原料和生产方法上有所不同。事实上，啤酒甚至不需要含有啤酒花 - 它可以由任意数量的谷物制成。然而，所有啤酒之间都存在相似之处。它们都是通过发酵过程制作的，所有合格的啤酒都含有一定的酒精含量。
- en: 'In Westeros there are a great number of craftsmen who pride themselves on creating
    top notch beers. We would like to describe their processes as a set of classes,
    each one describing a different beer making methodology. We start with a simplified
    implementation of creating a beer:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛有许多自豪地制作顶级啤酒的工匠。我们想将他们的工艺描述为一组类，每个类描述一种不同的酿造啤酒的方法。我们从一个简化的酿造啤酒的实现开始：
- en: '[PRE136]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'As there is no concept of abstract in JavaScript we''ve added exceptions to
    the various methods which must be overridden. The remaining methods can be changed
    but do not require it. An implementation of this for a raspberry beer would look
    like the following:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript中没有抽象的概念，我们已经为必须被覆盖的各种方法添加了异常。剩下的方法可以更改，但不是必须的。树莓啤酒的实现如下所示：
- en: '[PRE137]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Additional sub-classing may be performed at this stage for more specific raspberry
    beers.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段可能会进行更具体的树莓啤酒的子类化。
- en: The template method remains a fairly useful pattern in JavaScript. There is
    some added syntactic sugar around creating classes, but it isn't anything we haven't
    already seen in a previous chapter. The only warning I would give is that the
    template method uses inheritance and thus strongly couples the inherited classes
    with the parent class. This is generally not a desirable state of affairs.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，模板方法仍然是一个相当有用的模式。在创建类时有一些额外的语法糖，但这并不是我们在之前章节中没有见过的。我唯一要提醒的是，模板方法使用继承，因此将继承类与父类紧密耦合。这通常不是一种理想的状态。
- en: Visitor
  id: totrans-713
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者
- en: The final pattern in this section is the visitor pattern. The visitor provides
    a method of decoupling an algorithm from the object structure on which it operates.
    If we wanted to perform some action over a collection of objects which differ
    in type and we want to perform a different action depending on the object type,
    we would typically need to make use of a large `if` statement.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的最后一个模式是访问者模式。访问者提供了一种将算法与其操作的对象结构解耦的方法。如果我们想对不同类型的对象集合执行某些操作，并且根据对象类型执行不同的操作，通常需要使用大量的`if`语句。
- en: 'Let''s get right into an example of this in Westeros. An army is made up of
    a few different classes of fighting person (it is important that we be politically
    correct as there are many notable female fighters in Westeros). However, each
    member of the army implements a hypothetical interface called `IMemberOfArmy`
    :'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立刻在维斯特洛进行一个示例。一个军队由几个不同类别的战斗人员组成（重要的是我们要政治正确，因为维斯特洛有许多著名的女战士）。然而，军队的每个成员都实现了一个名为`IMemberOfArmy`的假设接口：
- en: '[PRE138]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'A simple implementation of this might be the following:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这个的简单实现可能是这样的：
- en: '[PRE139]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Now we have a collection of these different types, we can use an `if` statement
    to only call the `printName` function on the knights:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些不同类型的集合，我们可以使用`if`语句只在骑士上调用`printName`函数：
- en: '[PRE140]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Except, if you run this code, you''ll actually find that all we get is the
    following:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你运行这段代码，你实际上会发现我们得到的只是以下内容：
- en: '[PRE141]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This is because, despite an object being a knight, it is still an object and
    `typeof` will return object in all cases.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，尽管一个对象是骑士，但它仍然是一个对象，`typeof`在所有情况下都会返回对象。
- en: 'An alternative approach is to use `instanceof` instead of `typeof` :'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`instanceof`而不是`typeof`：
- en: '[PRE142]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The instance of approach works great until we run into somebody who makes use
    of the `Object.create` syntax:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法的方法在遇到使用`Object.create`语法的人时效果很好：
- en: '[PRE143]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Despite being a knight this will return `false` when asked if it is an instance
    of `Knight` .
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管是骑士，当被问及是否是`Knight`的实例时，它将返回`false`。
- en: This poses something of a problem for us. The problem is exacerbated by the
    visitor pattern as it requires that the language supports method overloading.
    JavaScript does not really support this. There are various hacks which can be
    used to make JavaScript somewhat aware of overloaded methods but the usual advice
    is to simply not bother and create methods with different names.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们来说是一个问题。访问者模式使问题变得更加严重，因为它要求语言支持方法重载。JavaScript实际上并不支持这一点。可以使用各种技巧来使JavaScript在某种程度上意识到重载的方法，但通常的建议是根本不要费心，而是创建具有不同名称的方法。
- en: 'Let''s not abandon this pattern just yet, though; it is a useful pattern. What
    we need is a way to reliably distinguish one type from another. The simplest approach
    is to just define a variable on the class which denotes its type:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还不要放弃这种模式；它是一个有用的模式。我们需要一种可靠地区分一种类型和另一种类型的方法。最简单的方法是在类上定义一个表示其类型的变量：
- en: '[PRE144]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Given the new `_type` variable we can now fake having real method overrides:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 有了新的`_type`变量，我们现在可以伪造真正的方法覆盖：
- en: '[PRE145]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Given this approach we can now implement a visitor. The first step is to expand
    our various members of the army to have a generic method on them which takes a
    visitor and applies it:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这种方法，我们现在可以实现一个访问者。第一步是扩展我们军队的各种成员，使其具有一个接受访问者并应用它的通用方法：
- en: '[PRE146]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Now we need to build a visitor. This code approximates the `if` statements
    we had in the preceding code:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要构建一个访问者。这段代码近似于我们在前面的代码中的`if`语句：
- en: '[PRE147]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'This visitor would be used as such:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 这个访问者将被用作下面这样：
- en: '[PRE148]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'As you can see we''ve pushed the decisions about the type of the item in the
    collection down to the visitor. This decouples the items themselves from the visitor
    as can be seen in the following diagram:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经将集合中项目的类型的决定推迟到了访问者。这将项目本身与访问者解耦，如下图所示：
- en: '![Visitor](Image00031.jpg)'
  id: totrans-741
  prefs: []
  type: TYPE_IMG
  zh: '![Visitor](Image00031.jpg)'
- en: If we allow the visitor to make decisions about what methods are called on the
    visited objects there is a fair bit of trickery required. If we can provide a
    constant interface for the visited objects then all the visitor needs do is call
    the interface method. This does, however, move logic from the visitor into the
    objects that are visited, which is contrary to the idea that the objects shouldn't
    know they are part of a visitor.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们允许访问者决定对访问对象调用哪些方法，那么就需要一些技巧。如果我们可以为访问对象提供一个恒定的接口，那么访问者只需要调用接口方法。然而，这将逻辑从访问者移到被访问的对象中，这与对象不应该知道自己是访问者的一部分的想法相矛盾。
- en: Whether suffering through the trickery is worthwhile is really an exercise for
    you. Personally I would tend to avoid using the visitor pattern in JavaScript
    as the requirements to get it working are complicated and non-obvious.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 是否值得忍受这种欺诈行为，这实际上是一个练习。就我个人而言，我倾向于避免在JavaScript中使用访问者模式，因为使其工作的要求很复杂且不明显。
- en: Hints and tips
  id: totrans-744
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: 'Here are a couple of brief tips to keep in mind about some of the patterns
    we''ve seen in this chapter:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于本章中一些模式的简短提示：
- en: When implementing the interpreter pattern you may be tempted to use JavaScript
    proper as your DSL and then use the `eval` function to execute the code. This
    is actually a very dangerous idea as `eval` opens up an entire world of security
    issues. It is generally considered to be very bad form to use `eval` in JavaScript.
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现解释器模式时，您可能会被诱惑使用JavaScript本身作为您的DSL，然后使用`eval`函数来执行代码。这实际上是一个非常危险的想法，因为`eval`会带来整个安全问题的世界。在JavaScript中使用`eval`通常被认为是非常不好的做法。
- en: If you find yourself in the position to audit the changes to data in your project,
    then the memento pattern can easily be modified to suit. Instead of keeping track
    of just the state changes, you can also track when the change was made and who
    changed it. Saving these mementos to disk somewhere allows you to go back and
    rapidly build an audit log pointing to precisely what happened to change the object.
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您发现自己需要审计项目中的数据更改，则可以轻松地修改备忘录模式以适应。您不仅可以跟踪状态更改，还可以跟踪更改的时间和更改者。将这些备忘录保存到磁盘的某个地方，可以让您回溯并快速构建指向更改对象的审计日志。
- en: The observer pattern is notorious for causing memory leaks when listeners aren't
    properly unregistered. This can happen even in a memory managed environment such
    as JavaScript. Be wary of failing to unhook observers.
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式因为监听器没有正确注销而导致内存泄漏而臭名昭著。即使在JavaScript这样的内存管理环境中，这种情况也可能发生。要警惕未能取消观察者。
- en: Summary
  id: totrans-749
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we've looked at a bunch of behavioral patterns. Some of these
    patterns such as observer and iterator will be ones you'll use almost every day,
    while others such as interpreter you might use no more than a handful of times
    in your entire career. Learning about these patterns should help you identify
    well-defined solutions to common problems.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看过了一堆行为模式。其中一些模式，比如观察者和迭代器，几乎每天都会用到，而另一些模式，比如解释器，你可能在整个职业生涯中只会用到几次。了解这些模式应该有助于您找到常见问题的明确定义解决方案。
- en: Most of the patterns are directly applicable to JavaScript and some of them,
    such as the strategy pattern, become more powerful in a dynamic language. The
    only pattern we found that has some limitations is the visitor pattern. The lack
    of static classes and polymorphism makes this pattern difficult to implement without
    breaking proper separation of concerns.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数模式都直接适用于JavaScript，其中一些模式，比如策略模式，在动态语言中变得更加强大。我们发现的唯一有一些限制的模式是访问者模式。缺乏静态类和多态性使得这个模式难以实现，而不破坏适当的关注点分离。
- en: These aren't, by any means, all of the behavioral patterns in existence. The
    programming community has spent the past two decades building on the ideas of
    the GoF book and identifying new patterns. The remainder of this book is dedicated
    to these newly identified patterns. The solutions may be very old ones but not
    generally recognized as common solutions until more recently. As far as I'm concerned
    this is the point where the book starts to get very interesting as we start looking
    at less well known and more JavaScript-specific patterns.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并不是存在的所有行为模式。编程社区在过去的二十年里一直在基于GoF书中的思想并识别新的模式。本书的其余部分致力于这些新识别的模式。解决方案可能是非常古老的，但直到最近才被普遍认为是常见解决方案。就我而言，这是书开始变得非常有趣的地方，因为我们开始研究不太知名和更具JavaScript特色的模式。
