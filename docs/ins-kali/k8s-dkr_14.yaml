- en: '*Chapter 11*: Extending Security Using Open Policy Agent'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：使用Open Policy Agent扩展安全性'
- en: So far, we have covered Kubernetes' built in authentication and authorization
    capabilities, which help to secure a cluster. While this will cover most use cases,
    it doesn't cover all of them. Several security best practices that Kubernetes
    can't handle are pre-authorizing container registries and ensuring that resource
    requests are on all **Pod** objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了Kubernetes内置的身份验证和授权功能，这有助于保护集群。虽然这将涵盖大多数用例，但并非所有用例都能涵盖。Kubernetes无法处理的几个安全最佳实践包括预授权容器注册表以及确保资源请求在所有**Pod**对象上。
- en: These tasks are left to outside systems and are called dynamic admission controllers.
    The **Open Policy Agent** (**OPA**), and its Kubernetes native sub-project, GateKeeper,
    are one of the most popular ways to handle these use cases. This chapter will
    detail the deployment of OPA and GateKeeper, how it's architected, and how to
    develop policies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务留给外部系统，称为动态准入控制器。**Open Policy Agent**（**OPA**）及其Kubernetes本地子项目GateKeeper是处理这些用例的最流行方式之一。本章将详细介绍OPA和GateKeeper的部署方式，其架构以及如何开发策略。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to validating webhooks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证Webhook简介
- en: What is OPA and how does it work?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OPA是什么以及它是如何工作的？
- en: Using Rego to write policies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rego编写策略
- en: Enforcing memory constraints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制内存约束
- en: Enforcing Pod security policies using OPA
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OPA强制执行Pod安全策略
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete the hands-on exercises in this chapter, you will require an Ubuntu
    18.04 server, running a KinD cluster with the configuration from [*Chapter 8*](B15514_08_Final_ASB_ePub.xhtml#_idTextAnchor228),
    *RBAC Policies and Auditing*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的实践练习，您需要一个运行着来自[*第8章*](B15514_08_Final_ASB_ePub.xhtml#_idTextAnchor228)的配置的Ubuntu
    18.04服务器，运行着一个KinD集群，*RBAC Policies and Auditing*。
- en: 'You can access the code for this chapter at the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter11.](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter11
    )'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下GitHub存储库中访问本章的代码：[https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter11.](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter11
    )
- en: Introduction to dynamic admission controllers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态准入控制器简介
- en: 'There are two ways to extend Kubernetes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种扩展Kubernetes的方式：
- en: Build a custom resource definition so that you can define your own objects and
    APIs.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自定义资源定义，以便您可以定义自己的对象和API。
- en: Implement a webhook that listens for requests from the API server and responds
    with the necessary information. You may recall that in [*Chapter 7*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203),
    *Integrating Authentication into Your Cluster*, we explained that a custom webhook
    was used to validate tokens.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个监听来自API服务器的请求并以必要信息响应的Webhook。您可能还记得在[*第7章*](B15514_07_Final_ASB_ePub.xhtml#_idTextAnchor203)中，*将身份验证集成到您的集群*，我们解释了使用自定义Webhook来验证令牌。
- en: Starting in Kubernetes 1.9, a webhook can be defined as a dynamic admission
    controller, and in 1.16, the dynamic admission controller API became **Generally
    Available** (**GA**).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kubernetes 1.9开始，可以将Webhook定义为动态准入控制器，在1.16中，动态准入控制器API变为**通用可用**（**GA**）。
- en: The protocol is very straightforward. Once a dynamic admission controller is
    registered for a specific object type, the webhook is called with an HTTP post
    every time an object of that type is created or edited. The webhook is then expected
    to return JSON that represents whether it is allowed or not.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议非常简单。一旦为特定对象类型注册了动态准入控制器，每当创建或编辑该类型的对象时，Webhook就会被调用进行HTTP post。然后期望Webhook返回代表是否允许的JSON。
- en: Important note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: As of 1.16, **admission.k8s.io/v1** is at GA. All examples will use the GA version
    of the API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 截至1.16版本，**admission.k8s.io/v1**已经是GA。所有示例将使用API的GA版本。
- en: 'The request submitted to the webhook is made up of several sections:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 提交给webhook的请求由几个部分组成：
- en: '**Object Identifiers**: The **resource** and **subResource** attributes identify
    the object, API, and group. If the version of the object is being upgraded, then
    **requestKind**, **requestResource**, and **requestSubResource** are specified.
    Additionally, **namespace** and **operation** are provided to know where the object
    is and whether it is a **CREATE**, **UPDATE**, **DELETE**, or **CONNECT** operation.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象标识符：**资源**和**subResource**属性标识对象、API和组。如果对象的版本正在升级，则会指定**requestKind**、**requestResource**和**requestSubResource**。此外，还提供了**namespace**和**operation**，以了解对象所在的位置以及它是**CREATE**、**UPDATE**、**DELETE**还是**CONNECT**操作。
- en: '**Submitter Identifiers**: The **userInfo** object identifies the user and
    groups of the submitter. The submitter and the user who created the original request
    are not always the same. For instance, if a user creates a **Deployment**, then
    the **userInfo** object won''t be for the user who created the original **Deployment**;
    it will be for the **ReplicaSet** controller''s service account because the **Deployment**
    creates a **ReplicaSet** that creates the **Pod**.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交者标识符**：**userInfo**对象标识提交者的用户和组。提交者和创建原始请求的用户并不总是相同的。例如，如果用户创建了一个**Deployment**，那么**userInfo**对象将不是为创建原始**Deployment**的用户而是为**ReplicaSet**控制器的服务账户，因为**Deployment**创建了一个创建**Pod**的**ReplicaSet**。'
- en: '**Object**: **object** represents the JSON of the object being submitted, where
    **oldObject** represents what is being replaced if this is an update. Finally,
    **options** specifies additional options for the request.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：**object**表示正在提交的对象的JSON，其中**oldObject**表示如果这是一个更新，则被替换的内容。最后，**options**指定了请求的附加选项。'
- en: The response from the webhook will simply have two attributes, the original
    **uid** from the request, and **allowed**, which can be **true** or **false**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 来自webhook的响应将简单地具有两个属性，即来自请求的原始**uid**和**allowed**，可以是**true**或**false**。
- en: The **userInfo** object can create complications quickly. Since Kubernetes often
    uses multiple layers of controllers to create objects, it can be difficult to
    track usage creation based on a user who interacts with the API server. It's much
    better to authorize based on objects in Kubernetes, such as namespace labels or
    other objects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**userInfo**对象可能会很快产生复杂性。由于Kubernetes通常使用多层控制器来创建对象，因此很难跟踪基于与API服务器交互的用户创建的使用情况。基于Kubernetes中的对象（如命名空间标签或其他对象）进行授权要好得多。'
- en: A common use case is to allow developers to have a "sandbox" that they are administrators
    in, but that has very limited capacity. Instead of trying to validate the fact
    that a particular user doesn't try to request too much memory, annotate a personal
    namespace with a limit so that the admission controller has something concrete
    to reference regardless of whether the user submits a **Pod** or a **Deployment**.
    This way, the policy will check the **annotation** on the **namespace** instead
    of the individual user. To ensure that only the user who owns the namespace is
    able to create something in it, use RBAC to limit access.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的用例是允许开发人员拥有一个“沙盒”，他们是其中的管理员，但容量非常有限。与其尝试验证特定用户不会请求太多内存，不如使用限制注释个人命名空间，这样准入控制器就有具体的参考对象，无论用户提交**Pod**还是**Deployment**。这样，策略将检查**命名空间**上的**注释**，而不是个别用户。为了确保只有拥有命名空间的用户能够在其中创建东西，使用RBAC来限制访问。
- en: 'One final point on generic validating webhooks: there is no way to specify
    a key or password. It''s an anonymous request. While in theory, a validating webhook
    could be used to implement updates, it is not recommended.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于通用验证Webhook的最后一点是：没有办法指定密钥或密码。这是一个匿名请求。虽然从理论上讲，验证Webhook可以用于实现更新，但不建议这样做。
- en: Now that we've covered how Kubernetes implements dynamic access controllers,
    we'll look at one of the most popular options in OPA.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了Kubernetes如何实现动态访问控制器，我们将看看OPA中最受欢迎的选项之一。
- en: What is OPA and how does it work?
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OPA是什么，它是如何工作的？
- en: OPA is a lightweight authorization engine that fits well in Kubernetes. It didn't
    get its start in Kubernetes, but it's certainly found a home there. There's no
    requirement to build dynamic admission controllers in OPA, but it's very good
    at it and there are extensive resources and existing policies that can be used
    to start your policy library.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: OPA是一个轻量级的授权引擎，在Kubernetes中表现良好。它并不是从Kubernetes开始的，但它在那里找到了家园。在OPA中没有构建动态准入控制器的要求，但它非常擅长，并且有大量资源和现有策略可用于启动您的策略库。
- en: This section provides a high-level overview of OPA and its components with the
    rest of the chapter getting into the details of an OPA implementation in Kubernetes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了OPA及其组件的高级概述，本章的其余部分将深入介绍在Kubernetes中实施OPA的细节。
- en: OPA architecture
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OPA架构
- en: 'OPA is comprised of three components – the HTTP listener, the policy engine,
    and the database:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: OPA由三个组件组成-HTTP监听器、策略引擎和数据库：
- en: '![Figure 11.1 – OPA architecture'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1-OPA架构'
- en: '](image/Fig_11.1_B15514.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_11.1_B15514.jpg)'
- en: Figure 11.1 – OPA architecture
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1-OPA架构
- en: 'The database used by OPA is in memory and ephemeral. It doesn''t persist information
    used to make policy decisions. On the one hand, this makes OPA very scalable since
    it is essentially an authorization microservice. On the other hand, this means
    that every instance of OPA must be maintained on its own and must be kept in sync
    with authoritative data:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: OPA使用的数据库是内存和临时的。它不会保留用于制定策略决策的信息。一方面，这使得OPA非常可扩展，因为它本质上是一个授权微服务。另一方面，这意味着每个OPA实例必须自行维护，并且必须与权威数据保持同步：
- en: '![Figure 11.2 – OPA in Kubernetes'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2-OPA在Kubernetes中'
- en: '](image/Fig_11.2_B15514.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_11.2_B15514.jpg)'
- en: Figure 11.2 – OPA in Kubernetes
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2-OPA在Kubernetes中
- en: When used in Kubernetes, OPA populates its database using a side car, called
    *kube-mgmt*, which sets up watches on the objects you want to import into OPA.
    As objects are created, deleted, or changed, *kube-mgmt* updates the data in its
    OPA instance. This means that OPA is "eventually consistent" with the API server,
    but it won't necessarily be a real-time representation of the objects in the API
    server. Since the entire etcd database is essentially being replicated over and
    over again, great care needs to be taken in order to refrain from replicating
    sensitive data, such as **Secrets**, in the OPA database.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中使用时，OPA使用一个名为*kube-mgmt*的side car来填充其数据库，该side car在您想要导入到OPA的对象上设置监视。当对象被创建、删除或更改时，*kube-mgmt*会更新其OPA实例中的数据。这意味着OPA与API服务器是“最终一致”的，但它不一定是API服务器中对象的实时表示。由于整个etcd数据库基本上是一遍又一遍地被复制，因此需要非常小心，以免在OPA数据库中复制敏感数据，例如**Secrets**。
- en: Rego, the OPA policy language
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rego，OPA策略语言
- en: 'We''ll cover the details of Rego in the next section in detail. The main point
    to mention here is that Rego is a policy evaluation language, not a generic programming
    language. This can be difficult for developers who are used to languages such
    as Golang, Java, or JavaScript, which support complex logic such as iterators
    and loops. Rego is designed to evaluate policy and is streamlined as such. For
    instance, if you wanted to write code in Java to check that all the container
    images in a **Pod** starting with one of a list of registries, it would look something
    like the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节详细介绍Rego的细节。这里要提到的主要观点是，Rego是一种策略评估语言，而不是通用编程语言。对于习惯于支持复杂逻辑的开发人员来说，这可能有些困难，比如Golang、Java或JavaScript等语言，这些语言支持迭代器和循环。Rego旨在评估策略，并且被简化为这样。例如，如果您想在Java中编写代码来检查**Pod**中所有以注册表列表中的一个开头的容器图像，它看起来会像下面这样：
- en: public boolean validRegistries(List<Container> containers,List<String> allowedRegistries)
    {
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean validRegistries(List<Container> containers,List<String> allowedRegistries)
    {
- en: 'for (Container c : containers) {'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (Container c : containers) {'
- en: boolean imagesFromApprovedRegistries = false;
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: boolean imagesFromApprovedRegistries = false;
- en: 'for (String allowedRegistry : allowedRegistries) {'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 'for (String allowedRegistry : allowedRegistries) {'
- en: imagesFromApprovedRegistries =  imagesFromApprovedRegistries  || c.getImage().startsWith(allowedRegistry);
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: imagesFromApprovedRegistries =  imagesFromApprovedRegistries  || c.getImage().startsWith(allowedRegistry);
- en: '}'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if (! imagesFromApprovedRegistries) {
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: if (! imagesFromApprovedRegistries) {
- en: return false;
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: return false;
- en: '}'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return true;
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: return true;
- en: '}'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'This code iterates over every container and every allowed registry to make
    sure that all of the images conform to the correct policy. The same code in Rego
    is much smaller:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码遍历每个容器和每个允许的注册表，以确保所有图像符合正确的策略。在Rego中相同的代码要小得多：
- en: invalidRegistry {
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: invalidRegistry {
- en: ok_images = [image | startswith(input_images[j],input.parameters.registries[_])
    ; image = input_images[j] ]
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ok_images = [image | startswith(input_images[j],input.parameters.registries[_])
    ; image = input_images[j] ]
- en: count(ok_images) != count(input_images)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: count(ok_images) != count(input_images)
- en: '}'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The preceding rule will evaluate to **true** if any of the images on the containers
    come from unauthorized registries. We'll cover the details as to how this code
    works later in the chapter. The key to understanding why this code is so much
    more compact is that much of the boilerplate of loops and tests are inferred in
    Rego. The first line generates a list of conforming images, and the second line
    makes sure that the number of conforming images matches the number of total images.
    If they don't match, then one or more of the images must come from invalid registries.
    The ability to write compact policy code is what makes Rego so well suited for
    admission controllers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器中的任何图像来自未经授权的注册表，则前面的规则将评估为true。我们将在本章后面详细介绍此代码的工作原理。理解此代码之所以如此紧凑的关键在于，Rego中推断了许多循环和测试的样板文件。第一行生成一个符合条件的图像列表，第二行确保符合条件的图像数量与总图像数量相匹配。如果它们不匹配，那么一个或多个图像必须来自无效的注册表。编写紧凑的策略代码的能力使Rego非常适合准入控制器。
- en: GateKeeper
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GateKeeper
- en: Thus far, everything discussed has been generic to OPA. It was mentioned in
    the beginning of the chapter that OPA didn't get its start in Kubernetes. Early
    implementations had a sidecar that kept the OPA database in sync with the API
    server, but you had to manually create policies as **ConfigMap** objects and manually
    generate responses for webhooks. In 2018, Microsoft debuted GateKeeper, [https://github.com/open-policy-agent/gatekeeper](https://github.com/open-policy-agent/gatekeeper),
    to provide a Kubernetes-native experience.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，讨论的内容都是关于OPA的通用性。在本章的开头提到，OPA并非起源于Kubernetes。早期的实现中有一个边车，它将OPA数据库与API服务器同步，但您必须手动创建**ConfigMap**对象作为策略，并手动为webhook生成响应。2018年，微软推出了GateKeeper，[https://github.com/open-policy-agent/gatekeeper](https://github.com/open-policy-agent/gatekeeper)，以提供基于Kubernetes的体验。
- en: In addition to moving from **ConfigMap** objects to proper custom resources,
    GateKeeper adds an audit function that lets you test policies against existing
    objects. If an object violates a policy, then a violation entry is created to
    track it. This way, you can get a snapshot of the existing policy violations in
    your cluster or know whether something was missed during GateKeeper downtime due
    to an upgrade.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从**ConfigMap**对象转移到适当的自定义资源之外，GateKeeper还添加了一个审计功能，让您可以针对现有对象测试策略。如果对象违反策略，那么将创建一个违规条目来跟踪它。这样，您可以快速了解集群中现有策略违规情况的快照，或者在GateKeeper因升级而停机期间是否有遗漏的情况。
- en: A major difference between GateKeeper and generic OPA is that in GateKeeper,
    OPA's functionality is not exposed via an API anyone can call. OPA is embedded,
    with GateKeeper calling OPA directly to execute policies and keep the database
    up to date. Decisions can only be made based on data in Kubernetes or by pulling
    data at evaluation time.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: GateKeeper和通用的OPA之间的一个主要区别是，在GateKeeper中，OPA的功能不是通过任何人都可以调用的API公开的。OPA是嵌入式的，GateKeeper直接调用OPA来执行策略并保持数据库更新。决策只能基于Kubernetes中的数据或在评估时拉取数据。
- en: Deploying GateKeeper
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署GateKeeper
- en: 'The examples that will be used will assume the use of GateKeeper instead of
    a generic OPA deployment. Based on the directions from the GateKeeper project,
    use the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的示例将假定使用GateKeeper而不是通用的OPA部署。根据GateKeeper项目的指示，使用以下命令：
- en: $ kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/master/deploy/gatekeeper.yaml
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: $ kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/master/deploy/gatekeeper.yaml
- en: This launches the GateKeeper namespace **Pods**, and creates the validating
    webhook. Once deployed, move on to the next section. We'll cover the details of
    using GateKeeper throughout the rest of this chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动GateKeeper命名空间的**Pods**，并创建验证webhook。部署完成后，继续下一节。我们将在本章的其余部分介绍如何使用GateKeeper的详细信息。
- en: Automated testing framework
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化测试框架
- en: OPA has a built-in automated testing framework for your policies. This is one
    of the most valuable aspects of OPA. Being able to test policies consistently
    before deployment can save you hours of debugging time. When writing policies,
    have a file with the same name as your policies file, but with **_test** in the
    name. For instance, to have test cases associated with **mypolicies.rego**, have
    the test cases in **mypolicies_test.rego** in the same directory. Running **opa
    test** will then run your test cases. We'll show how to use this to debug your
    code in the next section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: OPA具有内置的自动化测试框架，用于测试您的策略。这是OPA最有价值的方面之一。在部署之前能够一致地测试策略可以节省您大量的调试时间。在编写策略时，有一个与策略文件同名的文件，但名称中带有**_test**。例如，要将测试用例与**mypolicies.rego**关联，将测试用例放在同一目录中的**mypolicies_test.rego**中。运行**opa
    test**将运行您的测试用例。我们将在下一节中展示如何使用这个功能来调试您的代码。
- en: Having covered the basics of OPA and how it is constructed, the next step is
    to learn how to use Rego to write policies.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了OPA及其构造基础之后，下一步是学习如何使用Rego编写策略。
- en: Using Rego to write policies
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Rego编写策略
- en: 'Rego is a language specifically designed for policy writing. It is different
    to most languages you have likely written code in. Typical authorization code
    will look something like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Rego是一种专门用于编写策略的语言。它与您可能编写过代码的大多数语言不同。典型的授权代码看起来可能是以下内容：
- en: //assume failure
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: //假定失败
- en: boolean allowed = false;
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: boolean allowed = false;
- en: //on certain conditions allow access
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: //在某些条件下允许访问
- en: if (someCondition) {
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（someCondition）{
- en: allowed = true;
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: allowed = true;
- en: '}'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //are we authorized?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: //我们被授权了吗？
- en: if (allowed) {
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（allowed）{
- en: doSomething();
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: doSomething();
- en: '}'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Authorization code will generally default to unauthorized, with a specific condition
    having to happen in order to allow the final action to be authorized. Rego takes
    a different approach. Rego is generally written to authorize everything unless
    a specific set of conditions happens.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 授权代码通常会默认为未经授权，必须发生特定条件才能允许最终操作获得授权。Rego采用了不同的方法。Rego通常编写为授权一切，除非发生特定一组条件。
- en: 'Another major difference between Rego and more general programming languages
    is that there are no explicit "**if**/**then**/**else**" control statements. When
    a line of Rego is going to make a decision, the code is interpreted as "if this
    line is false, stop execution." For instance, the following code in Rego says
    "if the image starts with **myregistry.lan/**, then stop execution of the policy
    and pass this check, otherwise generate an error message":'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Rego和更一般的编程语言之间的另一个主要区别是没有明确的“if”/“then”/“else”控制语句。当Rego的一行代码要做出决定时，代码被解释为“如果这行是假的，停止执行”。例如，Rego中的以下代码表示“如果图像以**myregistry.lan/**开头，则停止执行策略并通过此检查，否则生成错误消息”：
- en: not startsWith(image,"myregistry.lan/")
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不以(image，“myregistry.lan/”)开头
- en: msg := sprintf("image '%v' comes from untrusted registry", [image])
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: msg := sprintf("image '%v' comes from untrusted registry", [image])
- en: 'The same code in Java might look as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，相同的代码可能如下所示：
- en: if (! image.startsWith("myregistry.lan/")) {
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（！image.startsWith("myregistry.lan/")）{
- en: throw new Exception("image " + image + " comes from untrusted registry");
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: throw new Exception("image " + image + " comes from untrusted registry");
- en: '}'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: This difference between inferred control statements and explicit control statements
    is often the steepest part of the learning curve when learning Rego. Where this
    can produce a steeper learning curve than other languages, Rego more than makes
    up for it by making it easy to test and build policies in an automated and manageable
    way.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 推断控制语句和显式控制语句之间的差异通常是学习Rego时最陡峭的部分。尽管这可能产生比其他语言更陡峭的学习曲线，但Rego通过以自动化和可管理的方式轻松测试和构建策略来弥补这一点。
- en: OPA can be used to automate the testing of policies. This is incredibly important
    when writing code that the security of your cluster relies upon. Automating your
    testing will help speed your development and will increase your security by catching
    any bugs introduced into previously working code by means of new working code.
    Next, let's work through the life cycle of writing an OPA policy, testing it,
    and deploying it to our cluster.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: OPA可用于自动化测试策略。在编写集群安全性依赖的代码时，这非常重要。自动化测试将有助于加快您的开发速度，并通过新的工作代码捕获先前工作代码中引入的任何错误，从而提高您的安全性。接下来，让我们来学习编写OPA策略、测试它并将其部署到我们的集群的生命周期。
- en: Developing an OPA policy
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发OPA策略
- en: 'A common example of using OPA is to limit which registries a Pod can come from.
    This is a common security measure in clusters to help restrict which Pods can
    run on a cluster. For instance, we''ve mentioned Bitcoin miners a few times. If
    the cluster won''t accept **Pods** except from your own, internal registry, then
    that''s one more step that needs to be taken for a bad actor to abuse your cluster.
    First, let''s write our policy, taken from the OPA documentation website (https://www.openpolicyagent.org/docs/latest/kubernetes-introduction/):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: OPA的一个常见示例是限制Pod可以来自哪些注册表。这是集群中常见的安全措施，可以帮助限制哪些Pod可以在集群上运行。例如，我们已经多次提到比特币矿工。如果集群不接受除了您自己内部注册表之外的Pod，那么这就是需要采取的另一步措施，以防止不良行为者滥用您的集群。首先，让我们编写我们的策略，取自OPA文档网站（https://www.openpolicyagent.org/docs/latest/kubernetes-introduction/）：
- en: package k8sallowedregistries
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: k8sallowedregistries包
- en: invalidRegistry {
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: invalidRegistry {
- en: input_images[image]
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: input_images[image]
- en: not startswith(image, "quay.io/")
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: not startswith(image, "quay.io/")
- en: '}'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: input_images[image] {
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: input_images[image] {
- en: image := input.review.object.spec.containers[_].image
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: image := input.review.object.spec.containers[_].image
- en: '}'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: input_images[image] {
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: input_images[image] {
- en: image := input.review.object.spec.template.spec.containers[_].image
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: image := input.review.object.spec.template.spec.containers[_].image
- en: '}'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The first line in this code declares the **package** our policy is in. Everything
    is stored in OPA in a package, both data and policies. Packages in OPA are like
    directories on a filesystem. When you place a policy in a package, everything
    is relative to that package. In this case, our policy is in the **k8sallowedregistries**
    package.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的第一行声明了我们策略所在的包。在OPA中，所有内容都存储在一个包中，包括数据和策略。OPA中的包类似于文件系统上的目录。当您将策略放入包中时，一切都是相对于该包的。在这种情况下，我们的策略在k8sallowedregistries包中。
- en: The next section defines a rule. This rule ultimately will be **undefined**
    if our **Pod** has an image that comes from **quay.io**. If the **Pod** doesn't
    have an image from **quay.io**, the rule will return **true**, signifying that
    the registry is invalid. GateKeeper will interpret this as a failure and return
    **false** to the API server when the **Pod** is evaluated during a dynamic admission
    review.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分定义了一个规则。如果我们的Pod具有来自quay.io的镜像，这个规则最终将是未定义的。如果Pod没有来自quay.io的镜像，规则将返回true，表示注册表无效。GateKeeper将把这解释为失败，并在动态准入审查期间对API服务器返回false。
- en: 'The next two rules look very similar. The first of the **input_images** rules
    says "evaluate the calling rule against every **container** in the object''s **spec.container**",
    matching **Pod** objects directly submitted to the API server, and extract all
    the **image** values for each **container**. The second **input_images** rule
    states: "evaluate the calling rule against every **container** in the object''s
    **spec.template.spec.containers**" to short circuit **Deployment** objects and
    **StatefulSets**.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个规则看起来非常相似。input_images规则中的第一个规则是“针对对象的spec.container中的每个容器评估调用规则”，直接匹配直接提交给API服务器的Pod对象，并提取每个容器的image值。第二个input_images规则说明：“针对对象的spec.template.spec.containers中的每个容器评估调用规则”，以短路Deployment对象和StatefulSets。
- en: 'Finally, we add the rule that GateKeeper requires to notify the API server
    of a failed evaluation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了GateKeeper需要通知API服务器评估失败的规则：
- en: 'violation[{"msg": msg, "details": {}}] {'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 'violation[{"msg": msg, "details": {}}] {'
- en: invalidRegistry
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: invalidRegistry
- en: msg := "Invalid registry"
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: msg := "无效的注册表"
- en: '}'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: This rule will return an empty **msg** if the registry is valid. It's a good
    idea to break up your code into code that makes policy decisions and code that
    responds with feedback. This makes it easier to test, which we'll do next.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注册表有效，此规则将返回一个空的msg。将代码分解为制定策略的代码和响应反馈的代码是一个好主意。这样可以更容易进行测试，接下来我们将进行测试。
- en: Testing an OPA policy
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试OPA策略
- en: 'Once we have written our policy, we want to set up an automated test. Just
    as with testing any other code, it''s important that your test cases cover both
    expected and unexpected input. It''s also important to test both positive and
    negative outcomes. It''s not enough to corroborate that our policy allowed a correct
    registry; we also need to make sure it stops an invalid one. Here are eight test
    cases for our code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 编写策略后，我们希望设置自动化测试。与测试任何其他代码一样，重要的是您的测试用例涵盖预期和意外的输入。测试积极和消极的结果也很重要。仅证实我们的策略允许正确的注册表是不够的；我们还需要确保它能阻止无效的注册表。以下是我们代码的八个测试用例：
- en: package k8sallowedregistries
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: package k8sallowedregistries
- en: test_deployment_registry_allowed {
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: test_deployment_registry_allowed {
- en: not invalidRegistry with input as {"apiVersion"...
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 输入为{"apiVersion"...的invalidRegistry
- en: '}'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: test_deployment_registry_not_allowed {
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: test_deployment_registry_not_allowed {
- en: invalidRegistry with input as {"apiVersion"...
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输入为{"apiVersion"...的invalidRegistry
- en: '}'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: test_pod_registry_allowed {
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: test_pod_registry_allowed {
- en: not invalidRegistry with input as {"apiVersion"...
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 输入为{"apiVersion"...的invalidRegistry
- en: '}'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: test_pod_registry_not_allowed {
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: test_pod_registry_not_allowed {
- en: invalidRegistry with input as {"apiVersion"...
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输入为{"apiVersion"...的invalidRegistry
- en: '}'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: test_cronjob_registry_allowed {
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: test_cronjob_registry_allowed {
- en: not invalidRegistry with input as {"apiVersion"...
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输入为{"apiVersion"...的invalidRegistry
- en: '}'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: test_cronjob_registry_not_allowed {
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: test_cronjob_registry_not_allowed {
- en: invalidRegistry with input as {"apiVersion"...
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 输入为{"apiVersion"...的invalidRegistry
- en: '}'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: test_error_message_not_allowed {
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: test_error_message_not_allowed {
- en: control := {"msg":"Invalid registry","details":{}}
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: control := {"msg":"无效的注册表","details":{}}
- en: result = violation with input as {"apiVersion":"admissi…
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: result = 违规，输入为{"apiVersion":"admissi…
- en: result[_] == control
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: result[_] == control
- en: '}'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: test_error_message_allowed {
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: test_error_message_allowed {
- en: result = violation with input as {"apiVersion":"admissi…
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: result = 违规，输入为{"apiVersion":"admissi…
- en: control := {"msg":"Invalid registry","details":{}}
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: control := {"msg":"无效的注册表","details":{}}
- en: '}'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: There are eight tests in total; two tests to make sure that the proper error
    message is returned when there's an issue, and six tests covering two use cases
    for three input types. We're testing simple **Pod** definitions, **Deployment**,
    and **CronJob**. To validate success or failure as expected, we have included
    definitions that have **image** attributes that include **docker.io** and **quay.io**
    for each input type. The code is abbreviated for print, but can be downloaded
    from [https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter11/simple-opa-policy/rego/](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter11/simple-opa-policy/rego/).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有八个测试；两个测试确保在出现问题时返回正确的错误消息，六个测试涵盖了三种输入类型的两个用例。我们正在测试简单的**Pod**定义，**Deployment**和**CronJob**。为了验证预期的成功或失败，我们已包含了具有**docker.io**和**quay.io**的**image**属性的定义。代码已经缩写打印，但可以从[https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter11/simple-opa-policy/rego/](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter11/simple-opa-policy/rego/)下载。
- en: 'To run the tests, first install the OPA command-line executable as per the
    OPA website – https://www.openpolicyagent.org/docs/latest/#running-opa. Once downloaded,
    go to the **simple-opa-policy/rego** directory and run the tests:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，首先按照OPA网站上的说明安装OPA命令行可执行文件-https://www.openpolicyagent.org/docs/latest/#running-opa。下载后，转到**simple-opa-policy/rego**目录并运行测试：
- en: $ opa test .
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: $ opa test .
- en: 'data.kubernetes.admission.test_cronjob_registry_not_allowed: FAIL (248ns)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: data.kubernetes.admission.test_cronjob_registry_not_allowed：失败（248ns）
- en: '--------------------------------------------------------------'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '--------------------------------------------------------------'
- en: 'PASS: 7/8'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过：7/8
- en: 'FAIL: 1/8'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 失败：1/8
- en: Seven of the tests passed, but **test_cronjob_registry_not_allowed** failed.
    The **CronJob** submitted as **input** should not be allowed because its **image**
    uses *docker.io*. The reason it snuck through was because **CronJob** objects
    follow a different pattern to **Pod** and **Deployment**, so our two **input_image**
    rules won't load any of the container objects from the **CronJob**. The good news
    is that when the **CronJob** ultimately submits the **Pod**, GateKeeper will not
    validate it, thereby preventing it from running. The bad news is that no one will
    know this until the **Pod** was supposed to be run. Making sure we pick up **CronJob**
    objects in addition to our other objects with containers in them will make it
    much easier to debug because the **CronJob** won't be accepted.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 七个测试通过了，但**test_cronjob_registry_not_allowed**失败了。作为**input**提交的**CronJob**不应该被允许，因为它的**image**使用了*docker.io*。它能够通过的原因是因为**CronJob**对象遵循与**Pod**和**Deployment**不同的模式，因此我们的两个**input_image**规则不会加载**CronJob**中的任何容器对象。好消息是，当**CronJob**最终提交**Pod**时，GateKeeper将不会对其进行验证，从而阻止其运行。坏消息是，直到**Pod**应该运行时，没有人会知道这一点。确保我们除了其他包含容器的对象外，还会捕捉**CronJob**对象，这将使调试变得更加容易，因为**CronJob**将不会被接受。
- en: 'To get all tests passing, add a new **input_container** rule to the **limitregistries.rego**
    file in the Github repo that will match the container used by a **CronJob**:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使所有测试通过，向Github存储库中的**limitregistries.rego**文件添加一个新的**input_container**规则，该规则将匹配**CronJob**使用的容器：
- en: input_images[image] {
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: input_images[image] {
- en: image := input.review.object.spec.jobTemplate.spec.template.spec.containers[_].image
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: image := input.review.object.spec.jobTemplate.spec.template.spec.containers[_].image
- en: '}'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Now, running the tests will show that everything passes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行测试将显示一切都通过了：
- en: $ opa test .
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: $ opa测试。
- en: 'PASS: 8/8'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过：8/8
- en: With a policy that has been tested, the next step is to integrate the policy
    into GateKeeper.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 经过测试的策略，下一步是将策略集成到GateKeeper中。
- en: Deploying policies to GateKeeper
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将策略部署到GateKeeper
- en: 'The policies we''ve created need to be deployed to GateKeeper, which provides
    Kubernetes custom resources that policies need to be loaded into. The first custom
    resource is **ConstraintTemplate**, which is where the Rego code for our policy
    is stored. This object lets us specify parameters in relation to our policy enforcement,
    and we''ll cover this next. To keep things simple, create a template with no parameters:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的策略需要部署到GateKeeper中，GateKeeper提供了策略需要加载的Kubernetes自定义资源。第一个自定义资源是**ConstraintTemplate**，其中存储了我们策略的Rego代码。此对象允许我们指定与策略执行相关的参数，接下来我们将介绍这一点。为了保持简单，创建一个没有参数的模板：
- en: 'apiVersion: templates.gatekeeper.sh/v1beta1'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: apiVersion：templates.gatekeeper.sh/v1beta1
- en: 'kind: ConstraintTemplate'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ConstraintTemplate
- en: 'metadata:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: k8sallowedregistries'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：k8sallowedregistries
- en: 'spec:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 规范：
- en: 'crd:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: crd：
- en: 'spec:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 规范：
- en: 'names:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：
- en: 'kind: K8sAllowedRegistries'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：K8sAllowedRegistries
- en: 'listKind: K8sAllowedRegistriesList'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: listKind：K8sAllowedRegistriesList
- en: 'plural: k8sallowedregistries'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 复数形式：k8sallowedregistries
- en: 'singular: k8sallowedregistries'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 单数形式：k8sallowedregistries
- en: 'validation: {}'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 验证：{}
- en: 'targets:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 目标：
- en: '- target: admission.k8s.gatekeeper.sh'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '- 目标：admission.k8s.gatekeeper.sh'
- en: 'rego: |'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: rego：|
- en: package k8sallowedregistries
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 包k8sallowedregistries
- en: .
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: .
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: .
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: The entire source code for this template is available at [https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/chapter11/simple-opa-policy/yaml/gatekeeper-policy-template.yaml](https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/ch).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板的整个源代码可在[https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/chapter11/simple-opa-policy/yaml/gatekeeper-policy-template.yaml](https://raw.githubusercontent.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/master/ch)找到。
- en: 'Once created, the next step is to apply the policy by creating a constraint
    based on the template. Constraints are objects in Kubernetes based on the configuration
    of **ConstraintTemplate**. Notice that our template defines a custom resource
    definition. This gets added to the **constraints.gatekeeper.sh** API group. If
    you look at the list of CRDs on your cluster, you''ll see **k8sallowedregistries**
    listed:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，下一步是通过创建基于模板的约束来应用策略。约束是基于**ConstraintTemplate**的Kubernetes对象的配置的对象。请注意，我们的模板定义了自定义资源定义。这将添加到**constraints.gatekeeper.sh**
    API组。如果您查看集群上的CRD列表，您将看到**k8sallowedregistries**列出：
- en: '![Figure 11.3 – CRD created by ConstraintTemplate'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3 - 由ConstraintTemplate创建的CRD'
- en: '](image/Fig_11.3_B15514.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_11.3_B15514.jpg)'
- en: Figure 11.3 – CRD created by ConstraintTemplate
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 - 由ConstraintTemplate创建的CRD
- en: Creating the constraint means creating an instance of the object defined in
    the template.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建约束意味着创建模板中定义的对象的实例。
- en: 'To keep from causing too much havoc in our cluster, we''re going to restrict
    this policy to the **openunison** namespace:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在我们的集群中造成太多混乱，我们将限制此策略到**openunison**命名空间：
- en: 'apiVersion: constraints.gatekeeper.sh/v1beta1'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: constraints.gatekeeper.sh/v1beta1'
- en: 'kind: K8sAllowedRegistries'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：K8sAllowedRegistries
- en: 'metadata:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: restrict-openunison-registries'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: restrict-openunison-registries'
- en: 'spec:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 规格：
- en: 'match:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配：
- en: 'kinds:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：
- en: '- apiGroups: [""]'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroups: [""]'
- en: 'kinds: ["Pod"]'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：["Pod"]
- en: '- apiGroups: ["apps"]'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroups: ["apps"]'
- en: 'kinds:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：
- en: '- StatefulSet'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '- StatefulSet'
- en: '- Deployment'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '- Deployment'
- en: '- apiGroups: ["batch"]'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroups: ["batch"]'
- en: 'kinds:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：
- en: '- CronJob'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '- CronJob'
- en: 'namespaces: ["openunison"]'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：["openunison"]
- en: 'parameters: {}'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'parameters: {}'
- en: 'The constraint limits the policy we wrote to just **Deployment**, **CronJob**,
    and **Pod** objects in the OpenUnison namespace. Once created, if we try to kill
    the **openunison-operator** Pod, it will fail to successfully be recreated by
    the replica set controller because the image comes from **dockerhub.io**, not
    **quay.io**:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 该约束限制了我们编写的策略只针对OpenUnison命名空间中的**Deployment**、**CronJob**和**Pod**对象。一旦创建，如果我们尝试杀死**openunison-operator**
    Pod，它将无法成功地由副本集控制器重新创建，因为镜像来自**dockerhub.io**，而不是**quay.io**：
- en: '![Figure 11.4 – Pod fails to create because of GateKeeper policy'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4 - 由于GateKeeper策略而无法创建的Pod'
- en: '](image/Fig_11.4_B15514.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_11.4_B15514.jpg)'
- en: Figure 11.4 – Pod fails to create because of GateKeeper policy
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 - 由于GateKeeper策略而无法创建Pod
- en: 'Next, look at the policy object. You will see that there are several violations
    in the **status** section of the object:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，查看策略对象。您将看到对象的**status**部分中存在几个违规行为：
- en: '![Figure 11.5 – List of objects that violate the image registry policy'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5 - 违反镜像注册表策略的对象列表'
- en: '](image/Fig_11.5_B15514.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_11.5_B15514.jpg)'
- en: Figure 11.5 – List of objects that violate the image registry policy
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 - 违反镜像注册表策略的对象列表
- en: Having deployed your first GateKeeper policy, you may quickly notice it has
    a few issues. The first is that the registry is hardcoded. This means that we'd
    need to replicate our code for every change of registry. It's also not flexible
    for the namespace. All of Tremolo Security's images are stored in **docker.io/tremolosecurity**,
    so instead of limiting a specific registry server, we may want flexibility for
    each namespace and to allow multiple registries. Next, we'll update our policies
    to provide this flexibility.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 部署了您的第一个GateKeeper策略后，您可能很快就会注意到它存在一些问题。首先是注册表是硬编码的。这意味着我们需要为每次注册表更改复制我们的代码。它也不适用于命名空间。Tremolo
    Security的所有镜像都存储在**docker.io/tremolosecurity**，因此我们可能希望为每个命名空间提供灵活性，并允许多个注册表，而不是限制特定的注册表服务器。接下来，我们将更新我们的策略以提供这种灵活性。
- en: Building dynamic policies
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建动态策略
- en: Our current registry policy is limiting. It is static and only supports a single
    registry. Both Rego and GateKeeper provide functionality to build a dynamic policy
    that can be reused in our cluster and configured based on individual namespace
    requirements. This gives us one code base to work from and debug instead of having
    to maintain repetitive code. The code we're going to use is in [https://github.com/packtpublishing/Kubernetes-and-Docker-The-Complete-Guide/blob/master/chapter11/parameter-opa-policy/](https://github.com/packtpublishing/Kubernetes-and-Docker-The-Complete-Guide/blob/master/chapter11/pa).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的注册表策略是有限的。它是静态的，只支持单个注册表。Rego和GateKeeper都提供了构建动态策略的功能，可以在我们的集群中重复使用，并根据各个命名空间的要求进行配置。这使我们可以使用一个代码库进行工作和调试，而不必维护重复的代码。我们将要使用的代码在[https://github.com/packtpublishing/Kubernetes-and-Docker-The-Complete-Guide/blob/master/chapter11/parameter-opa-policy/](https://github.com/packtpublishing/Kubernetes-and-Docker-The-Complete-Guide/blob/master/chapter11/pa)中。
- en: 'When inspecting **rego/limitregistries.rego**, the main difference between
    the code in **parameter-opa-policy** and **simple-opa-policy** comes down to the
    **invalidRegistry** rule:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查**rego/limitregistries.rego**时，**parameter-opa-policy**和**simple-opa-policy**中代码的主要区别在于**invalidRegistry**规则：
- en: invalidRegistry {
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: invalidRegistry {
- en: ok_images = [image | startswith(input_images[i],input.parameters.registries[_])
    ; image = input_images[i] ]
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ok_images = [image | startswith(input_images[i],input.parameters.registries[_])
    ; image = input_images[i] ]
- en: count(ok_images) != count(input_images)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: count(ok_images) != count(input_images)
- en: '}'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The goal of the first line of the rule is to determine which images come from
    approved registries using a comprehension. Comprehensions provide a way to build
    out sets, arrays, and objects based on some logic. In this case, we want to only
    add images to the **ok_images** array that start with any of the allowed registries
    from **input.parameters.registries**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 规则的第一行的目标是使用推理确定来自批准注册表的图像。推理提供了一种根据某些逻辑构建集合、数组和对象的方法。在这种情况下，我们只想将以**input.parameters.registries**中任何允许的注册表开头的图像添加到**ok_images**数组中。
- en: To read a comprehension, start with the type of brace. Ours starts with a square
    bracket, so the result will be an array. Objects and sets can also be generated.
    The word between the open bracket and the pipe character, (**|**), is called the
    head and this is the variable that will be added to our array if the right conditions
    are met. Everything to the right of the pipe character, (**|**), is a set of rules
    used to determine what **image** should be and if it should have a value at all.
    If any of the statements in the rule resolve to undefined or false, the execution
    exits for that iteration.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要阅读一个推理，从大括号的类型开始。我们的推理以方括号开始，因此结果将是一个数组。对象和集合也可以生成。在开放方括号和管道字符（**|**）之间的单词称为头部，这是如果满足右侧条件将添加到我们的数组中的变量。管道字符（**|**）右侧的所有内容都是一组规则，用于确定**image**应该是什么，以及是否应该有值。如果规则中的任何语句解析为未定义或假，执行将退出该迭代。
- en: 'The first rule of our comprehension is where most of the work is done. The
    **startswith** function is used to determine whether each of our images starts
    with the correct registry name. Instead of passing two strings to the function,
    we instead pass arrays. The first array has a variable we haven''t declared yet,
    **i**, and the other uses an underscore (**_**) where the index would usually
    be. The **i** is interpreted by Rego as "do this for each value in the array,
    incrementing by 1 and let it be referenced throughout the comprehension." The
    underscore is shorthand in Rego for "do this for all values." Since we specified
    two arrays, every combination of the two arrays will be used as input to the **startswith**
    function. That means that if there are two containers and three potential pre-approved
    registries, then **startswith** will be called six times. When any of the combinations
    return **true** from **startswith**, the next rule is executed. That sets the
    **image** variable to **input_image** with index **i**, which then means that
    image is added to **ok_images**. The same code in Java would look something like
    the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解的第一个规则是大部分工作都是在这里完成的。**startswith**函数用于确定我们的每个图像是否以正确的注册表名称开头。我们不再将两个字符串传递给函数，而是传递数组。第一个数组有一个我们尚未声明的变量**i**，另一个使用下划线（**_**）代替索引。**i**被Rego解释为“对数组中的每个值执行此操作，递增1并允许在整个理解过程中引用它。”下划线在Rego中是“对所有值执行此操作”的速记。由于我们指定了两个数组，每个数组的所有组合都将被用作**startswith**函数的输入。这意味着如果有两个容器和三个潜在的预批准注册表，那么**startswith**将被调用六次。当任何组合从**startswith**返回**true**时，将执行下一个规则。这将**image**变量设置为带有索引**i**的**input_image**，这意味着该图像将被添加到**ok_images**。在Java中，相同的代码看起来可能是这样的：
- en: ArrayList<String> okImages = new ArrayList<String>();
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayList<String> okImages = new ArrayList<String>();
- en: for (int i=0;i<inputImages.length;i++) {
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于（int i=0;i<inputImages.length;i++）{
- en: for (int j=0;j<registries.length;j++) {
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于（int j=0;j<registries.length;j++）{
- en: if (inputImages[i].startsWith(registries[j])) {
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（inputImages[i].startsWith(registries[j]）{
- en: okImages.add(inputImages[i]);
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: okImages.add(inputImages[i]);
- en: '}'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: One line of Rego eliminated seven lines of mostly boilerplate code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Rego的一行消除了大部分基本代码的七行。
- en: The second line of the rule compares the number of entries in the **ok_images**
    array with the number of known container images. If they are equal, we know that
    every container contains a valid image.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 规则的第二行将**ok_images**数组中的条目数与已知容器图像的数量进行比较。如果它们相等，我们就知道每个容器都包含一个有效的图像。
- en: 'With our updated Rego rules for supporting multiple registries, the next step
    is to deploy a new policy template (if you haven''t done so already, delete the
    old **k8sallowedregistries** **ConstraintTemplate** and **restrict-openunison-registries**
    **K8sAllowedRegistries**). Here''s our updated **ConstraintTemplate**:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们更新的Rego规则来支持多个注册表，下一步是部署一个新的策略模板（如果您还没有这样做，请删除旧的**k8sallowedregistries**
    **ConstraintTemplate**和**restrict-openunison-registries** **K8sAllowedRegistries**）。这是我们更新的**ConstraintTemplate**：
- en: 'apiVersion: templates.gatekeeper.sh/v1beta1'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: apiVersion：templates.gatekeeper.sh/v1beta1
- en: 'kind: ConstraintTemplate'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ConstraintTemplate
- en: 'metadata:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: k8sallowedregistries'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：k8sallowedregistries
- en: 'spec:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 规范：
- en: 'crd:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: crd：
- en: 'spec:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 规范：
- en: 'names:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：
- en: 'kind: K8sAllowedRegistries'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：K8sAllowedRegistries
- en: 'listKind: K8sAllowedRegistriesList'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: listKind：K8sAllowedRegistriesList
- en: 'plural: k8sallowedregistries'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 复数：k8sallowedregistries
- en: 'singular: k8sallowedregistries'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 单数：k8sallowedregistries
- en: 'validation:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 验证：
- en: '**openAPIV3Schema:**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**openAPIV3Schema:**'
- en: '**          properties:**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**          properties:**'
- en: '**            registries:**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**            registries:**'
- en: '**              type: array**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**              type: array**'
- en: '**              items: string**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**              items: string**'
- en: 'targets:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 目标：
- en: '- target: admission.k8s.gatekeeper.sh'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '- 目标：admission.k8s.gatekeeper.sh'
- en: 'rego: |'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: rego：|
- en: package k8sallowedregistries
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: package k8sallowedregistries
- en: .
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: .
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: .
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: Beyond including our new rules, the highlighted section shows that we added
    a schema to our template. This will allow for the template to be reused with specific
    parameters. This schema goes into the **CustomResourceDefenition** that will be
    created and is used to validate input for the **K8sAllowedRegistries** objects
    we'll create in order to enforce our pre-authorized registry lists.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包含我们的新规则，突出显示的部分显示我们向模板添加了一个模式。这将允许模板以特定参数进行重用。这个模式进入了将要创建的**CustomResourceDefenition**，并用于验证我们将创建的**K8sAllowedRegistries**对象的输入，以强制执行我们预先授权的注册表列表。
- en: 'Finally, let''s create our policy for the **openunison** namespace. Since the
    only containers that are running in this namespace should come from Tremolo Security''s
    **dockerhub.io** registry, we''ll limit all Pods to **docker.io/tremolosecurity/**
    using the following policy:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们为**openunison**命名空间创建我们的策略。由于在这个命名空间中运行的唯一容器应该来自Tremolo Security的**dockerhub.io**注册表，我们将使用以下策略将所有Pod限制为**docker.io/tremolosecurity/**：
- en: 'apiVersion: constraints.gatekeeper.sh/v1beta1'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: constraints.gatekeeper.sh/v1beta1'
- en: 'kind: K8sAllowedRegistries'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：K8sAllowedRegistries
- en: 'metadata:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: restrict-openunison-registries'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：restrict-openunison-registries
- en: 'spec:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 规格：
- en: 'match:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配：
- en: 'kinds:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：
- en: '- apiGroups: [""]'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroups：[""]'
- en: 'kinds: ["Pod"]'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：["Pod"]
- en: '- apiGroups: ["apps"]'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroups：["apps"]'
- en: 'kinds:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：
- en: '- StatefulSet'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '- StatefulSet'
- en: '- Deployment'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '- Deployment'
- en: '- apiGroups: ["batch"]'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroups：["batch"]'
- en: 'kinds:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：
- en: '- CronJob'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '- CronJob'
- en: 'namespaces: ["openunison"]'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：["openunison"]
- en: 'parameters:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: 'registries: ["docker.io/tremolosecurity/"]'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表：["docker.io/tremolosecurity/"]
- en: 'Unlike our previous version, this policy specifies which registries are valid
    instead of embedding the policy data directly into our Rego. With our policies
    in place, let''s try to run the **busybox** container in the **openunison** namespace
    to get a shell:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的版本不同，这个策略指定了哪些注册表是有效的，而不是直接将策略数据嵌入到我们的Rego中。有了我们的策略，让我们尝试在**openunison**命名空间中运行**busybox**容器以获取一个shell：
- en: '![Figure 11.6 – Failed busybox shell'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6 – 失败的busybox shell'
- en: '](image/Fig_11.6_B15514.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_11.6_B15514.jpg)'
- en: Figure 11.6 – Failed busybox shell
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 失败的busybox shell
- en: Using this generic policy template, we can restrict which registries the namespaces
    are able to pull from. As an example, in a multi-tenant environment, you may want
    to restrict all **Pods** to the owner's own registry. If a namespace is being
    used for a commercial product, you can stipulate that only that vendor's containers
    can run in it. Before moving on to other use cases, it's important to understand
    how to debug your code and handle Rego's quirks.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个通用的策略模板，我们可以限制命名空间能够从哪些注册表中拉取。例如，在多租户环境中，您可能希望将所有**Pods**限制为所有者自己的注册表。如果一个命名空间被用于商业产品，您可以规定只有那个供应商的容器可以在其中运行。在转向其他用例之前，重要的是要了解如何调试您的代码并处理Rego的怪癖。
- en: Debugging Rego
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试Rego
- en: Debugging Rego can be challenging. Unlike more generic programming languages
    such as Java or Go, there's no way to step through code in a debugger. Take the
    example of the generic policy we just wrote for checking registries. All the work
    was done in a single line of code. Stepping through it wouldn't do much good.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 调试Rego可能是具有挑战性的。与Java或Go等更通用的编程语言不同，没有办法在调试器中逐步执行代码。以刚刚为检查注册表编写的通用策略为例。所有的工作都是在一行代码中完成的。逐步执行它不会有太大的好处。
- en: To make Rego easier to debug, the OPA project provides a trace of all failed
    tests when verbose output is set on the command line. This is another great reason
    to use OPA's built-in testing tools.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Rego更容易调试，OPA项目在命令行上设置了详细输出时提供了所有失败测试的跟踪。这是使用OPA内置测试工具的另一个很好的理由。
- en: 'To make better use of this trace, Rego has a function called **trace** that
    accepts a string. Combining this function with **sprintf** lets you more easily
    track where your code is not working as expected. In the **chapter11/paramter-opa-policy-fail/rego**
    directory, there''s a test that will fail. There is also an **invalidRegistry**
    rule with multiple trace options added:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地利用这个跟踪，Rego 有一个名为 **trace** 的函数，它接受一个字符串。将这个函数与 **sprintf** 结合使用，可以更容易地跟踪代码未按预期工作的位置。在
    **chapter11/paramter-opa-policy-fail/rego** 目录中，有一个将失败的测试。还有一个添加了多个跟踪选项的 **invalidRegistry**
    规则：
- en: invalidRegistry {
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: invalidRegistry {
- en: 'trace(sprintf("input_images : %v",[input_images]))'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '跟踪(sprintf("input_images : %v",[input_images]))'
- en: ok_images = [image |
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ok_images = [image |
- en: trace(sprintf("image %v",[input_images[j]]))
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: trace(sprintf("image %v",[input_images[j]]))
- en: startswith(input_images[j],input.parameters.registries[_]) ;
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: startswith(input_images[j],input.parameters.registries[_]) ;
- en: image = input_images[j]
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: image = input_images[j]
- en: ']'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: trace(sprintf("ok_images %v",[ok_images]))
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: trace(sprintf("ok_images %v",[ok_images]))
- en: trace(sprintf("ok_images size %v / input_images size %v",[count(ok_images),count(input_images)]))
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: trace(sprintf("ok_images size %v / input_images size %v",[count(ok_images),count(input_images)]))
- en: count(ok_images) != count(input_images)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: count(ok_images) != count(input_images)
- en: '}'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: When the test is run, OPA will output a detailed trace of every comparison and
    code path. Wherever it encounters the **trace** function, a "note" is added to
    the trace. This is the equivalent of adding print statements in your code to debug.
    The output of the OPA trace is very verbose, and far too much text to include
    in print. Running **opa test.** **-v** in this directory will give you the full
    trace you can use to debug your code.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试运行时，OPA 将输出每个比较和代码路径的详细跟踪。无论在哪里遇到 **trace** 函数，跟踪中都会添加一个“注释”。这相当于在代码中添加打印语句进行调试。OPA
    跟踪的输出非常冗长，包含的文本太多，无法包含在打印中。在此目录中运行 **opa test.** **-v** 将给你完整的跟踪，可以用来调试你的代码。
- en: Using existing policies
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用现有的政策
- en: Before moving into more advanced use cases for OPA and GateKeeper, it's important
    to understand the implications of how OPA is built and used. If you inspect the
    code we worked through in the previous section, you might notice that we aren't
    checking for **initContainers**. We're only looking for the primary containers.
    **initContainers** are special containers that are run before the containers listed
    in a **Pod** are expected to end. They're often used to prepare the filesystem
    of a volume mount and for other "initial" tasks that should be performed before
    the containers of a **Pod** have run. If a bad actor tried to launch a **Pod**
    with an **initContainers** that pulls in a Bitcoin miner (or worse), our policy
    wouldn't stop it.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入更高级的 OPA 和 GateKeeper 的用例之前，了解 OPA 的构建和使用方式非常重要。如果你检查我们在上一节中工作过的代码，你可能会注意到我们没有检查
    **initContainers**。我们只是寻找主要的容器。**initContainers** 是在预期 **Pod** 中列出的容器结束之前运行的特殊容器。它们通常用于准备卷挂载的文件系统和其他应在
    **Pod** 的容器运行之前执行的“初始”任务。如果一个坏演员试图启动一个带有拉入比特币矿工（或更糟糕）的 **initContainers** 的 **Pod**，我们的策略将无法阻止它。
- en: It's important to be very detailed in the design and implementation of policies.
    One of the ways to make sure you're not missing something when building policies
    is to use policies that already exist and have been tested. The GateKeeper project
    maintains several libraries of pre-tested policies and how to use them in its
    GitHub repo at https://github.com/open-policy-agent/gatekeeper/tree/master/library.
    Before attempting to build one of your own policies, see whether one already exists
    there first.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和实施政策时非常详细是很重要的。确保在构建政策时不会遗漏任何东西的一种方法是使用已经存在并经过测试的政策。GateKeeper项目在其GitHub存储库https://github.com/open-policy-agent/gatekeeper/tree/master/library中维护了几个经过预先测试的政策库以及如何使用它们。在尝试构建自己的政策之前，先看看那里是否已经存在一个。
- en: This section provided an overview of Rego and how it works in policy evaluation.
    It didn't cover everything, but should give you a good point of reference for
    working with Rego's documentation. Next, we'll learn how to build policies that
    rely on data from outside our request, such as other objects in our cluster.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了 Rego 及其在策略评估中的工作方式。它没有涵盖所有内容，但应该为您在使用 Rego 文档时提供一个良好的参考点。接下来，我们将学习如何构建依赖于我们请求之外的数据的策略，例如集群中的其他对象。
- en: Enforcing memory constraints
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行内存约束
- en: So far in this chapter, we've built policies that are self-contained. When checking
    whether an image is coming from a pre-authorized registry, the only data we needed
    was from the policy and the containers. This is often not enough information to
    make a policy decision. In this section, we'll work on building a policy that
    relies on other objects in your cluster to make policy decisions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们构建了自包含的策略。在检查图像是否来自预授权的注册表时，我们所需的唯一数据来自策略和容器。这通常不足以做出策略决策。在本节中，我们将致力于构建一个策略，依赖于集群中的其他对象来做出策略决策。
- en: Before diving into the implementation, let's talk about the use case. It's a
    good idea to include at least memory requirements on any **Pod** submitted to
    the API server. There are certain namespaces though where this doesn't make as
    much sense. For instance, many of the containers in the **kube-system** namespace
    don't have CPU and memory resource requests.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实施之前，让我们谈谈用例。在提交到 API 服务器的任何 **Pod** 上至少包含内存要求是一个好主意。然而，有一些命名空间，这样做就没有太多意义。例如，**kube-system**
    命名空间中的许多容器没有 CPU 和内存资源请求。
- en: There are multiple ways we could handle this. One way is to deploy a constraint
    template and apply it to every namespace we want to enforce memory resource requests
    on. This can lead to repetitive objects or require us to explicitly update policies
    to apply them to certain namespaces. Another method is to add a label to the namespace
    that lets OPA know it needs all **Pod** objects to have memory resource requests.
    Since Kubernetes already has **ResourceQuota** objects for managing memory, we
    can also establish whether a namespace has a **ResourceQuota** and, if it does,
    then we know there should be memory requests.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以处理这个问题。一种方法是部署一个约束模板，并将其应用到我们想要强制执行内存资源请求的每个命名空间。这可能会导致重复的对象，或者要求我们明确更新策略以将其应用于特定的命名空间。另一种方法是向命名空间添加一个标签，让
    OPA 知道它需要所有 **Pod** 对象都具有内存资源请求。由于 Kubernetes 已经有了用于管理内存的 **ResourceQuota** 对象，我们还可以确定一个命名空间是否有
    **ResourceQuota**，如果有的话，那么我们就知道应该有内存请求。
- en: 'For our next example, we''ll write a policy that says any **Pod** created in
    a namespace that has a **ResourceQuota** must have a memory resource request.
    The policy itself should be pretty simple. The pseudocode will look something
    like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个示例，我们将编写一个策略，该策略表示在具有 **ResourceQuota** 的命名空间中创建的任何 **Pod** 必须具有内存资源请求。策略本身应该非常简单。伪代码将看起来像这样：
- en: if (hasResourceQuota(input.review.object.metdata.namespace) &&  containers.resource.requests.memory
    == null) {
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: if (hasResourceQuota(input.review.object.metdata.namespace) &&  containers.resource.requests.memory
    == null) {
- en: generate error;
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 生成错误;
- en: '}'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The hard part here is understanding if the namespace has a **ResourceQuota**.
    Kubernetes has an API, which you could query, but that would mean either embedding
    a secret into the policy so it can talk to the API server or allowing anonymous
    access. Neither of those options are a good idea. Another issue with querying
    the API server is that it's difficult to automate testing since you are now reliant
    on an API server being available wherever you run your tests.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的难点是要了解命名空间是否有**ResourceQuota**。Kubernetes有一个API，您可以查询，但这意味着要么将秘密嵌入到策略中，以便它可以与API服务器通信，要么允许匿名访问。这两个选项都不是一个好主意。另一个查询API服务器的问题是很难自动化测试，因为现在您依赖于一个API服务器在您运行测试的任何地方都可用。
- en: We discussed earlier that OPA can replicate data from the API server in its
    own database. GateKeeper uses this functionality to create a "cache" of objects
    that can be tested against. Once this cache is populated, we can replicate it
    locally to provide test data for our policy testing.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过，OPA可以从API服务器复制数据到自己的数据库中。GateKeeper使用这个功能来创建可以进行测试的对象的“缓存”。一旦这个缓存被填充，我们可以在本地复制它，为我们的策略测试提供测试数据。
- en: Enabling the GateKeeper cache
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用GateKeeper缓存
- en: 'The GateKeeper cache is enabled by creating a **Config** object in the **gatekeeper-system**
    namespace. Add this configuration to your cluster:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在"gatekeeper-system"命名空间中创建一个**Config**对象来启用GateKeeper缓存。将此配置添加到您的集群中：
- en: 'apiVersion: config.gatekeeper.sh/v1alpha1'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: api版本：config.gatekeeper.sh/v1alpha1
- en: 'kind: Config'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：Config
- en: 'metadata:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: config'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：config
- en: 'namespace: "gatekeeper-system"'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间："gatekeeper-system"
- en: 'spec:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 规范：
- en: 'sync:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 同步：
- en: 'syncOnly:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 仅同步：
- en: '- group: ""'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '- 组：""'
- en: 'version: "v1"'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 版本："v1"
- en: 'kind: "Namespace"'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 种类："命名空间"
- en: '- group: ""'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '- 组：""'
- en: 'version: "v1"'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 版本："v1"
- en: 'kind: "ResourceQuota"'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 种类："ResourceQuota"
- en: 'This will begin replicating **Namespace** and **ResourceQuota** objects in
    GateKeeper''s internal OPA database. Let''s create a **Namespace** with a **ResourceQuota**
    and one without a **ResourceQuota**:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '这将开始在GateKeeper的内部OPA数据库中复制**Namespace**和**ResourceQuota**对象。让我们创建一个带有**ResourceQuota**和一个不带**ResourceQuota**的**Namespace**： '
- en: 'apiVersion: v1'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: api版本：v1
- en: 'kind: Namespace'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：命名空间
- en: 'metadata:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: ns-with-no-quota'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：ns-with-no-quota
- en: 'spec: {}'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 规范：{}
- en: '---'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '---'
- en: 'apiVersion: v1'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: api版本：v1
- en: 'kind: Namespace'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：命名空间
- en: 'metadata:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: ns-with-quota'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：ns-with-quota
- en: 'spec: {}'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 规范：{}
- en: '---'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '---'
- en: 'kind: ResourceQuota'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ResourceQuota
- en: 'apiVersion: v1'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: api版本：v1
- en: 'metadata:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: memory-quota'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：memory-quota
- en: 'namespace: ns-with-quota'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间：ns-with-quota
- en: 'spec:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 规范：
- en: 'hard:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 硬：
- en: 'requests.memory: 1G'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 请求.memory：1G
- en: 'limits.memory: 1G'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 限制.memory：1G
- en: After a moment, the data should be in the OPA database and ready to query.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 过一会儿，数据应该在OPA数据库中，并且准备好查询。
- en: Important note
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The GateKeeper service account has read access to everything in your cluster
    with its default installation. This includes secret objects. Be careful what you
    replicate in GateKeeper's cache as there are no security controls from inside
    a Rego policy. Your policy could very easily log secret object data if you are
    not careful. Also, make sure to control who has access to the **gatekeeper-system**
    namespace. Anyone who gets hold of the service account's token can use it to read
    any data in your cluster.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: GateKeeper服务账户在默认安装中对集群中的所有内容都有读取权限。这包括秘密对象。在GateKeeper的缓存中复制什么要小心，因为在Rego策略内部没有安全控制。如果不小心，您的策略很容易记录秘密对象数据。另外，请确保控制谁可以访问**gatekeeper-system**命名空间。任何获得服务账户令牌的人都可以使用它来读取集群中的任何数据。
- en: Mocking up test data
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟测试数据
- en: 'In order to automate testing of our policy, we need to create test data. In
    the previous examples, we used data injected into the **input** variable. Cache
    data is stored in the **data** variable. Specifically, in order to access our
    resource quota, we need to access **data.inventory.namespace["ns-with-quota"]["v1"]["ResourceQuota"]["memory-quota"]**.
    This is the standard way for you to query data from Rego in GateKeeper. Just as
    we did with input, we can inject a mocked-up version of this data by creating
    a data object. Here''s what our JSON will look like:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化测试我们的策略，我们需要创建测试数据。在之前的例子中，我们使用注入到**input**变量中的数据。缓存数据存储在**data**变量中。具体来说，为了访问我们的资源配额，我们需要访问**data.inventory.namespace["ns-with-quota"]["v1"]["ResourceQuota"]["memory-quota"]**。这是您在GateKeeper中从Rego查询数据的标准方式。就像我们对输入所做的那样，我们可以通过创建一个数据对象来注入这些数据的模拟版本。我们的JSON将如下所示：
- en: '{'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"inventory": {'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '"inventory": {'
- en: '"namespace":{'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '"namespace":{'
- en: '"ns-with-no-quota" : {},'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '"ns-with-no-quota" : {},'
- en: '"ns-with-quota":{'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '"ns-with-quota":{'
- en: '"v1":{'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '"v1":{'
- en: '"ResourceQuota": {'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '"ResourceQuota": {'
- en: '"memory-quota":{'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '"memory-quota":{'
- en: '"kind": "ResourceQuota",'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '"kind": "ResourceQuota",'
- en: '"apiVersion": "v1",'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '"apiVersion": "v1",'
- en: '"metadata": {'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '"metadata": {'
- en: '"name": "memory-quota",'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "memory-quota",'
- en: '"namespace": "ns-with-quota"'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '"namespace": "ns-with-quota"'
- en: '},'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"spec": {'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '"spec": {'
- en: '"hard": {'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '"hard": {'
- en: '"requests.memory": "1G",'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '"requests.memory": "1G",'
- en: '"limits.memory": "1G"'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '"limits.memory": "1G"'
- en: '}}}}}}}}}'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '}}}}}}}}}'
- en: When you look at **chapter11/enforce-memory-request/rego/enforcememory_test.rego**,
    you'll see the tests have **with input as {…} with data as {…}** with the preceding
    document as our control data. This lets us test our policies with data that would
    exist in GateKeeper without having to deploy our code in a cluster.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看**chapter11/enforce-memory-request/rego/enforcememory_test.rego**时，您会看到测试中有**with
    input as {…} with data as {…}**，前面的文档作为我们的控制数据。这让我们能够测试我们的策略，使用GateKeeper中存在的数据，而无需在集群中部署我们的代码。
- en: Building and deploying our policy
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和部署我们的策略
- en: 'Just as before, we''ve written test cases prior to writing our policy. Next,
    we''ll examine our policy:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 就像以前一样，在编写策略之前，我们已经编写了测试用例。接下来，我们将检查我们的策略：
- en: package k8senforcememoryrequests
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: package k8senforcememoryrequests
- en: 'violation[{"msg": msg, "details": {}}] {'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '违规[{"msg": msg, "details": {}}] {'
- en: invalidMemoryRequests
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: invalidMemoryRequests
- en: msg := "No memory requests specified"
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: msg := "未指定内存请求"
- en: '}'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: invalidMemoryRequests {
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: invalidMemoryRequests {
- en: data.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 数据。
- en: inventory
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 库存
- en: .namespace
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: .namespace
- en: '[input.review.object.metadata.namespace]'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[input.review.object.metadata.namespace]'
- en: '["v1"]'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '["v1"]'
- en: '["ResourceQuota"]'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '["ResourceQuota"]'
- en: containers := input.review.object.spec.containers
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 容器：= 输入审查对象规范容器
- en: ok_containers = [ok_container |
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ok_containers = [ok_container |
- en: containers[j].resources.requests.memory ;
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: containers[j].resources.requests.memory ;
- en: ok_container = containers[j]  ]
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: ok_container = containers[j]  ]
- en: count(containers) != count(ok_containers)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: count(containers) != count(ok_containers)
- en: '}'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: This code should look familiar. It follows a similar pattern as our earlier
    policies. The first rule, **violation**, is the standard reporting rule for GateKeeper.
    The second rule is where we test our **Pod**. The first line will fail and exit
    out if the namespace for the specified **Pod** doesn't contain a **ResourceQuota**
    object. The next line loads all of the containers of the **Pod**. After this,
    a composition is used to construct a list of containers that has memory requests
    specified. Finally, the rule will only succeed if the number of compliant containers
    doesn't match the total number of containers. If **invalidMemoryRequests** succeeds,
    this means that one or more containers does not have memory requests specified.
    This will force **msg** to be set and **violation** to inform the user of the
    issue.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该看起来很熟悉。它遵循了与我们先前策略相似的模式。第一个规则**violation**是GateKeeper的标准报告规则。第二个规则是我们测试**Pod**的地方。第一行将在指定**Pod**的命名空间不包含**ResourceQuota**对象时失败并退出。接下来的一行加载**Pod**的所有容器。之后，使用组合来构建具有指定内存请求的容器列表。最后，规则只有在符合条件的容器数量与总容器数量不匹配时才会成功。如果**invalidMemoryRequests**成功，这意味着一个或多个容器没有指定内存请求。这将强制**msg**被设置，并且**violation**通知用户存在问题。
- en: 'To deploy, add **chapter11/enforce-memory-request/yaml/gatekeeper-policy-template.yaml**
    and **chapter11/enforce-memory-request/yaml/gatekeeper-policy.yaml** to your cluster.
    To test this, create a **Pod** without memory requests in both our **ns-with-quota**
    and **ns-with-no-quota** namespaces:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署，请将**chapter11/enforce-memory-request/yaml/gatekeeper-policy-template.yaml**和**chapter11/enforce-memory-request/yaml/gatekeeper-policy.yaml**添加到您的集群中。要测试这一点，在我们的**ns-with-quota**和**ns-with-no-quota**命名空间中创建一个没有内存请求的**Pod**。
- en: '![Figure 11.7 – Creating pods without memory requests'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7 - 创建没有内存请求的Pod'
- en: '](image/Fig_11.7_B15514.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_11.7_B15514.jpg)'
- en: Figure 11.7 – Creating pods without memory requests
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 - 创建没有内存请求的Pod
- en: The first attempt to create a **Pod** in the **ns-with-quota** namespace fails
    because our **require-memory-requests** policy rejected it since **ns-with-quota**
    has a **ResourceQuota** in it. The second attempt succeeds because it is running
    in a namespace with no **ResourceQuota**.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在**ns-with-quota**命名空间中创建**Pod**的第一次尝试失败，因为我们的**require-memory-requests**策略拒绝了它，因为**ns-with-quota**中有一个**ResourceQuota**。第二次尝试成功，因为它在没有**ResourceQuota**的命名空间中运行。
- en: Most of this chapter has been spent writing policies. The final use case for
    OPA will focus on using GateKeeper's prebuilt policies to replace Pod security
    policies.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 本章大部分时间都花在编写策略上。 OPA的最终用例将专注于使用GateKeeper的预构建策略来替换Pod安全策略。
- en: Enforcing Pod Security Policies using OPA
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OPA执行Pod安全策略
- en: In [*Chapter 10*](B15514_10_Final_ASB_ePub.xhtml#_idTextAnchor260), *Creating
    Pod Security Policies*, we discussed the fact that the existing Pod security policy
    implementation for Kubernetes would never become "GA". One of the alternatives
    to using the Kubernetes implementation was to use OPA and GateKeeper to enforce
    the same policies, but in OPA instead of on the API server. This process works
    differently to the standard implemented by Kubernetes, but using it can keep your
    clusters more vendor-independent and less susceptible to the changes that will
    eventually arise with whatever comes next for Kubernetes' Pod security policies.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B15514_10_Final_ASB_ePub.xhtml#_idTextAnchor260)，*创建Pod安全策略*中，我们讨论了Kubernetes现有的Pod安全策略实现永远不会成为"GA"的事实。使用Kubernetes实现的替代方案之一是使用OPA和GateKeeper来强制执行相同的策略，但是在OPA而不是在API服务器上。这个过程与Kubernetes的标准实现方式不同，但使用它可以使您的集群更加独立于供应商，并且不太容易受到Kubernetes的Pod安全策略未来变化的影响。
- en: GateKeeper's policies are all published at [https://github.com/open-policy-agent/gatekeeper/tree/master/library/pod-security-policy](https://github.com/open-policy-agent/gatekeeper/tree/master/library/pod-security-policy).
    They're built as a series of **ConstraintTemplate** objects and example constraints.
    This approach to Pod security policies makes for some specific differences in
    how policies are implemented.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: GateKeeper的所有策略都发布在[https://github.com/open-policy-agent/gatekeeper/tree/master/library/pod-security-policy](https://github.com/open-policy-agent/gatekeeper/tree/master/library/pod-security-policy)。它们被构建为一系列**ConstraintTemplate**对象和示例约束。这种对Pod安全策略的方法导致了一些特定的差异，以及策略的实施方式。
- en: The first major difference is that using GateKeeper, you have to declare everything
    in your Pod definition so that GateKeeper has something to audit against. This
    isn't necessary with Pod security policies because Kubernetes will mutate the
    Pod definition to conform to the policy. To illustrate this, look at the **openunison-operator**,
    **Deployment**, in the **openunison** namespace in our KinD cluster. No **runAsUser**
    is declared. Now look at the actual Pod definition and you'll see that **runAsUser**
    is set to **1**. GateKeeper version 3 isn't yet capable of supporting Pod mutation,
    so in order to ensure that **Deployment** or **Pod** has **runAsUser** set, a
    separate mutating webhook needs to set the **runAsUser** attribute accordingly.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个主要区别是使用GateKeeper，您必须在Pod定义中声明所有内容，以便GateKeeper有东西可以进行审计。这在Pod安全策略中是不必要的，因为Kubernetes将改变Pod定义以符合策略。为了说明这一点，看看我们KinD集群中**openunison**命名空间中的**openunison-operator**的**Deployment**。没有声明**runAsUser**。现在看一下实际的Pod定义，您会看到**runAsUser**设置为**1**。GateKeeper版本3目前还不支持Pod变异，因此为了确保**Deployment**或**Pod**具有设置**runAsUser**，需要一个单独的变异webhook来相应地设置**runAsUser**属性。
- en: The next major difference between the Kubernetes standard policy implementation
    and using GateKeeper is how a Pod is assigned a policy. The Kubernetes standard
    implementation uses a combination of RBAC, leveraging both the account information
    of the submitter and **serviceAccount** of the **Pod**, and the capabilities requested
    by the **Pod** to determine which policy to use. This can lead to some unexpected
    results when assigning policies. GateKeeper instead provides the same matching
    criteria as any other constraint implemented by GateKeeper, using namespaces and
    label selectors.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes标准策略实现和使用GateKeeper之间的下一个主要区别是Pod分配策略的方式。Kubernetes标准实现使用RBAC的组合，利用提交者的帐户信息和**Pod**的**serviceAccount**，以及**Pod**请求的功能来确定使用哪个策略。这可能会导致一些意外的结果。相反，GateKeeper提供了与GateKeeper实施的任何其他约束相同的匹配标准，使用命名空间和标签选择器。
- en: For example, to run a Pod using a privileged constraint, you may create the
    constraint with a specific **labelSelector**. Then, when the Pod is submitted,
    that label needs to be on the **Pod** so GateKeeper knows to apply it. This makes
    it much easier to explicitly apply policies to a **Pod**. It doesn't cover how
    to enforce the labeling of resources. You may not want someone to be able to label
    their own **Pod** as privileged.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要使用特权约束来运行一个Pod，您可以使用特定的**labelSelector**创建约束。然后，当提交Pod时，该标签需要在**Pod**上，这样GateKeeper就知道要应用它。这样可以更容易地明确地将策略应用于**Pod**。它并不涵盖如何强制执行资源的标记。您可能不希望某人能够将自己的**Pod**标记为特权。
- en: Finally, GateKeeper's library of policies are broken up instead of being part
    of one object. In order to apply a policy that enforces an unprivileged container
    that runs in a certain user range, you need two separate policy constraint implementations
    and two separate constraints.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，GateKeeper的策略库被分解成多个部分，而不是作为一个对象的一部分。为了应用一个强制执行在特定用户范围内运行的非特权容器的策略，您需要两个单独的策略约束实现和两个单独的约束。
- en: As of the time of writing, you couldn't replicate what we built in [*Chapter
    10*](B15514_10_Final_ASB_ePub.xhtml#_idTextAnchor260), *Creating Pod Security
    Policies*, without significant additional work. The goal of the GateKeeper project
    is to get to that point in the future. The more complete solution is still the
    standard implementation of Pod security policies in Kubernetes.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，您无法在不进行重大额外工作的情况下复制我们在 [*第 10 章*](B15514_10_Final_ASB_ePub.xhtml#_idTextAnchor260)
    中构建的内容，即 *创建 Pod 安全策略*。GateKeeper 项目的目标是在未来达到这一点。更完整的解决方案仍然是 Kubernetes 中 Pod
    安全策略的标准实现。
- en: Summary
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored how to use GateKeeper as a dynamic admission controller
    to provide additional authorization policies on top of Kubernetes' built-in RBAC
    capabilities. We looked at how GateKeeper and OPA are architected. Finally, we
    learned how to build, deploy, and test policies in Rego.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用 GateKeeper 作为动态准入控制器，在 Kubernetes 内置的 RBAC 能力之上提供额外的授权策略。我们看了
    GateKeeper 和 OPA 的架构。最后，我们学习了如何在 Rego 中构建、部署和测试策略。
- en: Extending Kubernetes' policies leads to a stronger security profile in your
    clusters and provides greater confidence in the integrity of the workloads running
    on your cluster. Using GateKeeper can also help catch previously missed policy
    violations through its application of continuous audits. Using these capabilities
    will provide a stronger foundation for your cluster.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 Kubernetes 的策略会增强集群的安全性配置，并且可以更加确信工作负载在集群上的完整性。使用 GateKeeper 也可以通过持续审计来帮助捕获先前被忽略的策略违规行为。利用这些功能将为您的集群提供更坚实的基础。
- en: This chapter focused on whether or not to launch a **Pod**. In the next chapter,
    we'll learn how to track what **Pods** are doing once active.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论了是否启动 **Pod**。在下一章中，我们将学习一旦激活，如何跟踪 **Pods** 的活动。
- en: Questions
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Are OPA and GateKeeper the same thing?
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OPA 和 GateKeeper 是同一件事吗？
- en: A. Yes.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: A. 是的。
- en: B. NO.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: B. 不是。
- en: How is Rego code stored in GateKeeper?
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rego 代码存储在 GateKeeper 中的方式是什么？
- en: A. It is stored as **ConfigMap** objects that are watched.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: A. 它被存储为被监视的 **ConfigMap** 对象。
- en: B. Rego has to be mounted to the Pod.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: B. Rego 必须挂载到 Pod 上。
- en: C. Rego needs to be stored as secret objects.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: C. Rego 需要存储为秘密对象。
- en: D. Rego is saved as a **ConstraintTemplate**.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: D. Rego 被保存为 **ConstraintTemplate**。
- en: How do you test Rego policies?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何测试 Rego 策略？
- en: A. In production
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: A. 在生产中
- en: B. Using an automated framework built directly into OPA
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: B. 使用直接内置到 OPA 中的自动化框架
- en: C. By first compiling to Web Assembly
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: C. 首先编译为 Web Assembly
- en: In Rego, how do you write a **for** loop?
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Rego 中，如何编写 **for** 循环？
- en: A. You don't need to; Rego will identify iterative steps.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: A. 你不需要；Rego 将识别迭代步骤。
- en: B. By using the **for all** syntax.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: B. 使用 **for all** 语法。
- en: C. By initializing counters in a loop.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: C. 通过在循环中初始化计数器。
- en: D. There are no loops in Rego.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: D. Rego 中没有循环。
- en: What is the best way to debug Rego policies?
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是调试 Rego 策略的最佳方法？
- en: A. Use an IDE to attach to the GateKeeper container in a cluster.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: A. 使用 IDE 连接到集群中的 GateKeeper 容器。
- en: B. In production.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: B. 在生产中。
- en: C. Add trace functions to your code and run the **opa test** command with **-v**
    to see execution traces.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: C. 向您的代码添加跟踪函数，并使用 **-v** 运行 **opa test** 命令以查看执行跟踪。
- en: D. Include **System.out** statements.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: D. 包括 **System.out** 语句。
- en: Constraints all need to be hardcoded.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有约束都需要硬编码。
- en: A. True.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: A. 真的。
- en: B. False.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误。
- en: GateKeeper can replace Pod security policies.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GateKeeper 可以替代 Pod 安全策略。
- en: A. True.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: A. 是的。
- en: B. False.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误。
