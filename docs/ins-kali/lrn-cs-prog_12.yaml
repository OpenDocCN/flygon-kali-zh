- en: '*Chapter 12*: Multithreading and Asynchronous Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：多线程和异步编程'
- en: Since the very first personal computer, we have benefitted from the constant
    increase of CPU power—a phenomenon that heavily influenced developers' choices
    of tools, languages, and application design, while historically not putting much
    effort into programming to take advantage of multithreading.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自第一台个人电脑以来，我们已经受益于CPU功率的持续增加-这一现象严重影响了开发人员对工具、语言和应用程序设计的选择，而在历史上并没有花费太多精力来编写利用多线程的程序。
- en: On the hardware side, the prediction made by Moore's law that the density of
    the transistors in processors should double every 2 years, thus providing more
    computing power, worked for some decades, but we can already observe it slowing
    down. Even if the CPU manufacturers started producing multi-core CPUs roughly
    20 years ago, the ability to execute code concurrently was primarily used by the
    **operating systems** (**OSes**) to make executing multiple processes smoother.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件方面，摩尔定律的预测是处理器中晶体管的密度应该每2年翻一番，从而提供更多的计算能力，这个预测在一些十年内有效，但我们已经可以观察到它放缓了。即使CPU制造商大约20年前开始生产多核CPU，执行代码的能力主要由操作系统（OSes）用于使执行多个进程更加流畅。
- en: This doesn't mean that code was unable to leverage the power of concurrency,
    but just that only a small quantity of applications fully embraced the *multithreading
    paradigm*. The primary reason for this is because all the code we write is executed
    sequentially from a single thread provided by the OS infrastructure unless we
    explicitly request the creation of other threads and orchestrate their execution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着代码无法利用并发的力量，而只是只有少量的应用程序完全拥抱了*多线程范式*。这主要是因为我们编写的所有代码都是从操作系统基础设施提供的单个线程顺序执行，除非我们明确请求创建其他线程并编排它们的执行。
- en: This trend is mostly due to the fact that many programming languages do not
    provide constructs to automatically generate multithreading code. This is because
    it is extremely difficult to provide the semantics that fit any use case and efficiently
    take advantage of the concurrent processing capabilities offered by modern CPUs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种趋势主要是因为许多编程语言没有提供构造来自动生成多线程代码。这是因为很难提供适合任何用例并有效利用现代CPU提供的并发处理能力的语义。
- en: On the other hand, there are times where we don't really need to execute the
    application code concurrently, but we can't continue the execution because it
    is necessary to wait for some outstanding I/O operation. At the same time, blocking
    the code execution is also not acceptable and therefore a different strategy is
    required. This domain of problems is categorized under *asynchronous programming*
    and requires slightly different tools.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有时我们并不真正需要并发执行应用程序代码，但我们无法继续执行，因为需要等待一些未完成的I/O操作。同时，阻塞代码执行也是不可接受的，因此需要采用不同的策略。这类问题领域被归类为*异步编程*，需要稍微不同的工具。
- en: 'In this chapter, we will learn the basics of multithreading and asynchronous
    programming and look specifically at the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习多线程和异步编程的基础知识，并具体了解以下内容：
- en: What is a thread?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是线程？
- en: Creating threads in .NET
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在.NET中创建线程
- en: Understanding synchronization primitives
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解同步原语
- en: The task paradigm
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务范式
- en: By the end of this chapter, you will be familiar with multithreading techniques,
    using primitives to synchronize code execution, tasks, continuations, and cancellation
    tokens. You will also understand what the potentially dangerous operations are
    and the basic patterns to use to avoid problems when sharing resources among multiple
    threads.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将熟悉多线程技术，使用原语来同步代码执行、任务、继续和取消标记。您还将了解潜在的危险操作以及在多个线程之间共享资源时避免问题的基本模式。
- en: We will now begin familiarizing ourselves with the basic concepts needed to
    operate with multithreading and asynchronous programming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始熟悉操作多线程和异步编程所需的基本概念。
- en: What is a thread?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是线程？
- en: Every OS provides abstractions to allow multiple programs to share the same
    hardware resources, such as CPU, memory, and input and output devices. The process
    is one of those abstractions, providing a reserved virtual address space that
    its running code cannot escape from. This basic sandbox avoids the process code
    interfering with other processes, establishing the basis for a balanced ecosystem.
    The process has nothing to do with code execution, but primarily with memory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统都提供抽象来允许多个程序共享相同的硬件资源，如CPU、内存和输入输出设备。进程是这些抽象之一，提供了一个保留的虚拟地址空间，其运行代码无法逃离。这种基本的沙盒避免了进程代码干扰其他进程，为平衡生态系统奠定了基础。进程与代码执行无关，主要与内存有关。
- en: The abstraction that takes care of code execution is the **thread**. Every process
    has at least one thread, but any process code may request the creation of more
    threads that will all share the same virtual address space, delimited by the owning
    process. Running multiple threads in a single process is roughly equivalent to
    a group of woodworking friends working on the same project –they need to be coordinated,
    paying attention to each other's progress, and taking care not to block each other's
    activity.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 负责代码执行的抽象是**线程**。每个进程至少有一个线程，但任何进程代码都可以请求创建更多的线程，它们都将共享相同的虚拟地址空间，由所属进程限定。在单个进程中运行多个线程大致相当于一组木工朋友共同完成同一个项目-他们需要协调，关注彼此的进展，并注意不要阻塞彼此的活动。
- en: All modern OSes offer the preemptive multitasking strategy as opposed to cooperative
    multitasking. This means that a special component of the OS schedules the amount
    of time each thread can run, without needing any cooperation from the running
    code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代操作系统都提供抢占式多任务处理策略，而不是合作式多任务处理。这意味着操作系统的一个特殊组件安排每个线程可以运行的时间，而无需从正在运行的代码中获得任何合作。
- en: Tip
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Earlier version of Windows, such as Windows 3.x and Windows 9x, used cooperative
    multitasking, meaning that any application could hang the entire operating system
    with a simple infinite loop. This was mostly because of CPU power and capabilities
    limitations. All the later operating systems, such as Windows versions starting
    from the very first **NT 3.1 Advanced Server** and all the Unix-like OSes, have
    always used preemptive multitasking, making the OS more robust and providing a
    better user experience.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的Windows，如Windows 3.x和Windows 9x，使用协作式多任务处理，这意味着任何应用程序都可以通过简单的无限循环挂起整个操作系统。这主要是因为CPU功率和能力的限制。所有后来的操作系统，如从最初的**NT
    3.1高级服务器**开始的Windows版本和所有类Unix的操作系统，一直都使用抢占式多任务处理，使操作系统更加健壮，并提供更好的用户体验。
- en: You can see the number of threads used in each running process with either the
    Task Manager, Process Explorer, or Process Hacker tools. You will immediately
    notice that many applications, including all the .NET ones, use more than one
    single thread. This information doesn't tell us much about how the application
    is designed because modern runtimes such as the .NET CLR use background threads
    for internal processing, such as the **garbage collector**, the **finalization
    queue**, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任务管理器、Process Explorer或Process Hacker工具查看每个运行进程中使用的线程数。您会立即注意到，许多应用程序，包括所有.NET应用程序，都使用不止一个线程。这些信息并不能告诉我们太多关于应用程序的设计，因为现代运行时（如.NET
    CLR）使用后台线程进行内部处理，例如**垃圾回收器**、**终结队列**等。
- en: Tip
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In order to see the number of threads used by the running processes, open the
    **Task Manager**(*Ctrl* + *Shift* + *Esc*), click on the **Details** tab, and
    add the **Threads** column. Columns can be added by right-clicking one of the
    grid headers, selecting the **Select Columns** menu item, and finally checking
    the **Threads** voice.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看运行进程使用的线程数，请打开**任务管理器**（*Ctrl* + *Shift* + *Esc*），单击**详细信息**选项卡，并添加**线程**列。可以通过右键单击其中一个网格标题，选择**选择列**菜单项，最后勾选**线程**选项来添加列。
- en: 'The following screenshot shows a C++ console application where the user''s
    code uses a single thread and the other three threads are created by the C++ runtime:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了一个C++控制台应用程序，用户的代码使用一个线程，而其他三个线程是由C++运行时创建的：
- en: '![Figure 12.1 - The Task Manager showing NativeConsole.exe process with four
    threads'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 - 任务管理器显示具有四个线程的NativeConsole.exe进程'
- en: '](img/Figure_12.1_B12346.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.1_B12346.jpg)'
- en: Figure 12.1 – The Task Manager showing NativeConsole.exe process with four threads
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 - 任务管理器显示具有四个线程的NativeConsole.exe进程
- en: The namespace containing the primitives dealing with threads is `System.Threading`
    but later in this chapter, we will also introduce `System.Threading.Tasks` namespace.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 包含处理线程的基元的命名空间是`System.Threading`，但在本章后面，我们还将介绍`System.Threading.Tasks`命名空间。
- en: When a .NET application starts, the .NET runtime prepares our process, allocating
    memory and creating some threads, including the one that will spin the execution
    of our code, starting from the `Main` entry point.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当.NET应用程序启动时，.NET运行时会准备我们的进程，分配内存并创建一些线程，包括将从`Main`入口点开始执行我们的代码的线程。
- en: 'The following console application accesses the current thread and prints the
    current thread `Id` on the screen:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下控制台应用程序访问当前线程并在屏幕上打印当前线程的“Id”：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `ManagedThreadId` property is important when diagnosing multithreading code
    because it correlates the execution of some code with a specific thread.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagedThreadId`属性在诊断多线程代码时很重要，因为它将某些代码的执行与特定线程相关联。'
- en: 'This `Id` can only be used within the running process and is different from
    the OS thread identifier. Should you ever require access to the native identifier,
    you need to use interoperability, as demonstrated in the following Windows-only
    snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此“Id”只能在运行的进程中使用，并且与操作系统线程标识符不同。如果您需要访问本机标识符，您需要使用互操作性，如下面的仅限Windows的代码片段所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The native `Id` is the one that you can see in **Process Explorer** and the
    **Process Hacker** tools and is the one needed to interop with other native APIs.
    In the following screenshot, you can see the results printed in the console on
    the left, and the Process Hacker threads window on the right:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本机“Id”是您可以在**Process Explorer**和**Process Hacker**工具中看到的“Id”，这是与其他本机API进行交互所需的“Id”。在下面的屏幕截图中，您可以看到左侧控制台中打印的结果，右侧是Process
    Hacker线程窗口：
- en: '![Figure 12.2 - The console application side by side with Process Hacker showing
    the same native thread Id'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 - 控制台应用程序与Process Hacker并排显示相同的本机线程Id'
- en: '](img/Figure_12.2_B12346.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.2_B12346.jpg)'
- en: Figure 12.2 – The console application side by side with Process Hacker showing
    the same native thread Id
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 - 控制台应用程序与Process Hacker并排显示相同的本机线程Id
- en: 'Threads can also be created from either the OS, the .NET runtime, or some library
    without our code explicitly requesting it. For example, the following class shows
    a `FileSystemWatcher` class in action and prints the `ManagedThreadId` property
    for each filesystem operation: the `Run` method prints the ID associated with
    the main thread, while the `Wacher_Deleted` and `Watcher_Created` methods are
    executed from a thread created by the OS or the infrastructure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 线程也可以由操作系统、.NET运行时或某个库创建，而无需我们的代码明确请求。例如，以下类展示了`FileSystemWatcher`类的使用情况，并为每个文件系统操作打印了`ManagedThreadId`属性：`Run`方法打印与主线程关联的ID，而`Wacher_Deleted`和`Watcher_Created`方法是由操作系统或基础架构创建的线程执行的：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can experiment with this code by creating a console application and adding
    the following code to the `Main` method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建控制台应用程序并将以下代码添加到`Main`方法来尝试此代码：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, if you start creating and deleting some `.txt` files in the console folder,
    you will see something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您开始在控制台文件夹中创建和删除一些`.txt`文件，您将看到类似于这样的东西：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `TID` numbers you see will likely change every time you rerun the application:
    they are neither predictable nor used in the same order.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到的“TID”号码可能会在每次重新运行应用程序时发生变化：它们既不可预测，也不按相同顺序使用。
- en: We will now see how we can create a new thread, execute some code concurrently,
    and examine the main characteristics of a thread.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到如何创建一个新线程，同时执行一些代码，并检查线程的主要特征。
- en: Creating threads in .NET
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在.NET中创建线程
- en: 'Creating a raw thread is something that mostly makes sense only when you have
    a long-running operation that depends on the CPU alone. As an example, let''s
    say we want to compute prime numbers, without really caring about the possible
    optimizations:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建原始线程在大多数情况下只有在有长时间运行的操作且仅依赖于CPU时才有意义。例如，假设我们想计算质数，而不真正关心可能的优化：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Primes` class implements `IEnumerable<long>` so that we can easily enumerate
    the prime numbers in a `Max` argument is used to limit the resulting sequence,
    which is otherwise restricted by `long.MaxValue`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Primes`类实现了`IEnumerable<long>`，这样我们可以轻松枚举质数，`Max`参数用于限制结果序列，否则将受`long.MaxValue`的限制。'
- en: 'Calling the preceding code is very easy to do but, as the calculation can take
    a very long time, it totally blocks the executing thread:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 调用上述代码非常容易，但是由于计算可能需要很长时间，它会完全阻塞执行线程：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What happens here is that the main thread is busy calculating the prime numbers.
    Thanks to preemptive multitasking, this thread will be interrupted by the OS scheduler
    to give other process' threads the opportunity to run their code. However, since
    our application has no other threads executing application code, we can only wait.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是主线程正在忙于计算质数。由于抢占式多任务处理，这个线程将被操作系统调度程序中断，以便让其他进程的线程有机会运行它们的代码。然而，由于我们的应用程序没有其他线程执行应用程序代码，我们只能等待。
- en: In any desktop application, be it a console or a GUI, the user experience is
    frustrating as any interaction with the mouse and keyboard is *blocked*. Even
    worse, the GUIs cannot even redraw the content of the screen as the only thread
    was stolen by the prime number's computation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何桌面应用程序中，无论是控制台还是GUI，用户体验都会很糟糕，因为鼠标和键盘的任何交互都会*被阻塞*。更糟糕的是，GUI甚至无法重新绘制屏幕内容，因为唯一的线程被质数计算占用了。
- en: 'The very first step is to move the blocking code into a separate method so
    that we can execute it in a new and separate thread:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将阻塞代码移到一个单独的方法中，这样我们就可以在一个新的独立线程中执行它：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Thread.Sleep` method is used only to make some observations on the CPU
    usage. Then, `Sleep` tells the OS to suspend the current thread execution for
    the given amount of time, expressed in *milliseconds*. Generally, calling `Sleep`
    is not recommended in production code because it prevents that thread from being
    reused. Later in this chapter, we will discover better ways to insert delays in
    our code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.Sleep`方法仅用于观察CPU使用情况。然后，`Sleep`告诉操作系统暂停当前线程的执行一段时间，以*毫秒*为单位。通常，不建议在生产代码中调用`Sleep`，因为它会阻止线程被重用。在本章后面，我们将发现更好的方法来在我们的代码中插入延迟。'
- en: 'The `Worker` method has nothing special and it may optionally get an object
    parameter that can be used to initialize the local variables. Instead of invoking
    it directly, we just ask the infrastructure to invoke it in the context of a new
    thread:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Worker`方法没有什么特别之处，它可能会选择性地获取一个对象参数，该参数可用于初始化局部变量。我们不直接调用它，而是要求基础设施在新线程的上下文中调用它：'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see from the preceding code, the `Thread` object is created but the
    thread is not started yet. We have to explicitly call the `Start` method to make
    it happen. This is important because the `Thread` class has other important properties
    that can be set only before the thread is started.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中可以看出，创建了`Thread`对象，但线程尚未启动。我们必须显式调用`Start`方法才能启动它。这很重要，因为`Thread`类还有其他重要的属性，只能在线程启动之前设置。
- en: 'Finally, the main thread''s details are printed by using the `PrintThreadInfo`
    method. Please note that some properties are not always available. For this reason,
    we have to check whether the thread is running before printing `Priority` or `IsBackground`.
    Since the `ThreadState` enumeration has the `Flags` attribute and the `Running`
    state is zero, the official documentation (https://docs.microsoft.com/en-us/dotnet/api/system.threading.threadstate?view=netframework-4.8#remarks)
    reminds us to check if the `Stopped` and `Unstarted` bits are not set:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`PrintThreadInfo`方法打印主线程的详细信息。请注意，有些属性并不总是可用。因此，我们必须在打印`Priority`或`IsBackground`之前检查线程是否正在运行。由于`ThreadState`枚举具有`Flags`属性，而`Running`状态为零，官方文档（https://docs.microsoft.com/en-us/dotnet/api/system.threading.threadstate?view=netframework-4.8#remarks）提醒我们要检查`Stopped`和`Unstarted`位是否未设置：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result of the executing the preceding code is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码的结果如下：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Even if this is a trivial example, we must observe a few things:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这是一个微不足道的例子，我们还是必须观察一些事情：
- en: The first is that we have no guarantees about the *output order* regarding the
    `Primes calculation …` and `Id:5 …` lines. They may appear in *reversed order*.
    In order to obtain a *deterministic behavior*, you need to apply a synchronization
    technique that we will discuss later in the *Understanding synchronization primitives*
    section.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们无法保证关于`Primes calculation …`和`Id:5 …`行的*输出顺序*。它们可能以*相反的顺序*出现。为了获得*确定性行为*，您需要应用我们将在*理解同步原语*部分讨论的同步技术。
- en: 'Another important consideration is the *CPU usage*. If you open **Task Manager**,
    under the **Performance** tab, you can set the view to show a separate graph for
    each logical CPU. In the following screenshot, you can see a four-core CPU that
    has eight logical cores (thanks to the Intel Hyper-Threading technology!). You
    may also want to show kernel times (shown in a darker color) because the kernel
    mode only executes code for the OS and drivers, while the user mode (shown in
    a lighter color) just executes the code we write. This distinction will allow
    you to immediately see which application code is being executed:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个重要的考虑是*CPU使用率*。如果你打开**任务管理器**，在**性能**选项卡下，你可以设置查看每个逻辑CPU的单独图表。在下面的截图中，你可以看到一个四核CPU，有八个逻辑核心（多亏了英特尔超线程技术！）。你可能还想显示内核时间（以较深的颜色显示），因为内核模式只执行操作系统和驱动程序的代码，而用户模式（以较浅的颜色显示）只执行我们编写的代码。这种区别将使你立即看到哪个应用程序代码正在执行：
- en: '![Figure 12.3 - The Task Manager showing all the logical processors'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 - 任务管理器显示所有逻辑处理器'
- en: '](img/Figure_12.3_B12346.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.3_B12346.jpg)'
- en: Figure 12.3 – The Task Manager showing all the logical processors
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 - 任务管理器显示所有逻辑处理器
- en: 'If we now execute our code without the `Sleep` call, we will see that one of
    the CPUs will show a higher amount of CPU usage as one thread keeps consuming
    the full amount of execution time granted by the OS. This single thread impacts
    the total (100%) amount of CPU time by *100% / 8 CPUs = 12.5%*. In fact, during
    the computation, the **Details** tab of **Task Manager** will show your process
    consuming roughly 12% of the CPU:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在执行我们的代码而没有`Sleep`调用，我们会发现其中一个CPU将显示更高的CPU使用率，因为一个线程一直在消耗操作系统分配的全部执行时间。这个单个线程会影响总共（100%）CPU时间的*100%
    / 8个CPU = 12.5%*。事实上，在计算过程中，**任务管理器**的**详细信息**选项卡将显示你的进程大约消耗了CPU的12%：
- en: '![Figure 12.4 - The Task Manager showing the execution time distributed across
    all the available logical CPUs](img/Figure_12.4_B12346.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 - 任务管理器显示分布在所有可用逻辑CPU上的执行时间](img/Figure_12.4_B12346.jpg)'
- en: Figure 12.4 – The Task Manager showing the execution time distributed across
    all the available logical CPUs
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 - 任务管理器显示分布在所有可用逻辑CPU上的执行时间
- en: The thread computation is *distributed* across multiple logical CPUs. Every
    time the OS interrupts the thread, schedules some other work of another process,
    and then gets back to our thread, the thread may be executed on any other logical
    CPU.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 线程计算在多个逻辑CPU上*分布*。每当操作系统中断线程，安排另一个进程的其他工作，然后回到我们的线程时，线程可能在任何其他逻辑CPU上执行。
- en: 'Just as an experiment, you can force the execution to take place on a specific
    logical CPU by adding the following code at the very beginning of the `Worker`
    method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 只是作为一个实验，你可以通过在`Worker`方法的开头添加以下代码来强制执行在特定的逻辑CPU上进行：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code requires the following declaration inside the class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码需要在类内部进行以下声明：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Those new lines of code retrieve a list of all the `ProcessThread` objects for
    our process and then filter the `ProcessThread` object whose native ID matches
    the one that is doing the execution.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新的代码行检索了我们进程的所有`ProcessThread`对象的列表，然后过滤出与正在执行的本机ID匹配的`ProcessThread`对象。
- en: 'After setting `ProcessorAffinity`, the new execution fully loads the logical
    CPU `2` with our computation, as shown in the following screenshot (the light
    blue section of CPU `2` entirely fills the rectangle):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`ProcessorAffinity`后，新的执行将完全加载逻辑CPU `2`，如下面的截图所示（CPU `2`的浅蓝色部分完全填满了矩形）：
- en: '![Figure 12.5 – The Task Manager showing CPU 2 fully loaded with the execution
    of the sample code'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 - 任务管理器显示CPU 2完全加载了示例代码的执行'
- en: '](img/Figure_12.5_B12346.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.5_B12346.jpg)'
- en: Figure 12.5 – The Task Manager showing CPU 2 fully loaded with the execution
    of the sample code
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 - 任务管理器显示CPU 2完全加载了示例代码的执行
- en: 'Immediately before starting the thread, we have the possibility to shape the
    thread characteristics by setting one or more of these properties:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动线程之前，我们有可能通过设置一个或多个这些属性来塑造线程的特性：
- en: The `Priority` property is used from the OS scheduler to decide the slot of
    time the thread can run. Giving it a high priority will reduce the amount of time
    the thread stays suspended.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Priority`属性是由操作系统调度程序使用的，用于决定线程可以运行的时间段。给予它高优先级将减少线程挂起的时间。'
- en: The `Name` property is useful when debugging because you can see it in the Visual
    Studio Thread window.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`属性在调试时很有用，因为你可以在Visual Studio线程窗口中看到它。'
- en: We briefly discussed the `ThreadState` property, which can assume many different
    values. One of them—`WaitSleepJoin`—represents a thread that is inside a `Wait`
    method or sleeping.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简要讨论了`ThreadState`属性，它可以有许多不同的值。其中之一——`WaitSleepJoin`——代表一个正在`Wait`方法中或正在睡眠的线程。
- en: The `CurrentCulture` and `CurrentUICulture` properties are read by certain APIs
    that are *region-dependent*. For example, when you convert a number or a date
    into a string (using the `ToString` method) or the `Parse` static method for the
    opposite conversion, the current culture settings are used.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrentCulture`和`CurrentUICulture`属性由某些依赖于*区域*的API读取。例如，当你将数字或日期转换为字符串（使用`ToString`方法）或使用相反的转换的`Parse`静态方法时，当前的区域设置将被使用。'
- en: The `IsBackground` property specifies whether the thread should prevent the
    process from terminating when it is still active. When true, the process will
    not wait for the thread to finish its work. In our example, if you set it to true,
    then you can end the process by pressing any key.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsBackground`属性指定线程是否应该在仍然活动时阻止进程终止。当为true时，进程将不会等待线程完成工作。在我们的示例中，如果你将其设置为true，那么你可以通过按任意键来结束进程。'
- en: You may have noticed the `Thread` class has the `Abort` method. It should never
    be used because it may corrupt the state of the memory or prevent the correct
    disposal of managed resources.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`Thread`类有`Abort`方法。它不应该被使用，因为它可能会破坏内存状态或阻止托管资源的正确处理。
- en: The correct way to terminate a thread is to exit normally from the method it
    initially started. In our case, this is the `Worker` method. A simple `return`
    statement is all you need.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 终止线程的正确方法是从最初启动的方法中正常退出。在我们的情况下，这是`Worker`方法。你只需要一个简单的`return`语句。
- en: We have seen how to create a thread manually, but there is a more convenient
    way to run some code in a separate thread—the `ThreadPool` class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何手动创建线程，但还有一种更方便的方法可以在单独的线程中运行一些代码——`ThreadPool`类。
- en: Using the ThreadPool class
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ThreadPool类
- en: We spent some time investigating the characteristics of threads and this was
    indeed very useful because the thread is the fundamental code-execution building
    block. Manually creating a thread is correct as long as it is executing CPU-dependent
    and long-running code. Anyway, since the cost of the thread is dependent on the
    OS, it is wiser to create an adequate amount of threads and reuse them. Their
    number is very dependent on the available logical CPUs and other factors, and
    this is the reason why it is far better to use the `ThreadPool` abstraction.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了一些时间研究线程的特性，这确实非常有用，因为线程是基本的代码执行构建块。手动创建线程是正确的，只要它执行与CPU相关且运行时间长的代码。无论如何，由于线程的成本取决于操作系统，因此最好创建适量的线程并重用它们。它们的数量非常依赖于可用的逻辑CPU和其他因素，这就是为什么最好使用`ThreadPool`抽象的原因。
- en: The static `ThreadPool` class provides a pool of threads that can be used to
    run some concurrent computation. As soon as the code terminates, the thread comes
    back to the pool, becoming available for a future operation without needing to
    be destroyed and recreated.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`ThreadPool`类提供了一个线程池，可以用来运行一些并发计算。一旦代码终止，线程就会回到池中，可以在不需要销毁和重新创建的情况下，为将来的操作提供可用性。
- en: Tip
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Be warned not to modify any property of the thread picked from `ThreadPool`.
    For example, if you modify `ProcessorAffinity`, this setting will continue to
    be valid, even if the thread is reused for different purposes. If you need to
    modify the thread's properties, then manual creation is still the best choice.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意不要修改从`ThreadPool`中选择的线程的任何属性。例如，如果修改了`ProcessorAffinity`，即使线程被重用于不同的目的，此设置仍将有效。如果需要修改线程的属性，手动创建仍然是最佳选择。
- en: 'Running our `Worker` using the `ThreadPool` class is straightforward:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ThreadPool`类运行我们的`Worker`非常简单：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Please note that the delegate parameter accepted by the `Thread` class constructor
    and `QueueUserWorkItem` are different, but the one taking an object parameter
    is compatible with both.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Thread`类构造函数和`QueueUserWorkItem`接受的委托参数是不同的，但接受对象参数的委托对两者都兼容。
- en: We have seen how to start a parallel computation, but we are still not able
    to orchestrate their execution. Should an algorithm be run on a different thread,
    we need to be aware of its termination and how to access the result.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何启动并行计算，但我们仍然无法编排它们的执行。如果算法应在不同的线程上运行，我们需要知道它的终止以及如何访问结果。
- en: Tip
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '`ThreadPool` is used from many popular libraries, including the base class
    library shipped with the .NET runtime. Whenever you need to access a resource
    requiring an I/O operation that may take a while to succeed or fail, most of the
    time, `ThreadPool` comes into play. Those resources include, among others, databases,
    filesystem objects, or anything that can be accessed through the network.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPool`被许多流行的库使用，包括随.NET运行时一起提供的基类库。每当需要访问需要I/O操作的资源，而这些操作可能需要一段时间才能成功或失败时，大多数情况下会使用`ThreadPool`。这些资源包括数据库、文件系统对象或可以通过网络访问的任何资源。'
- en: Every time you need to access a resource concurrently, be it a resource retrieved
    by means of an I/O operation or an instance of an object in memory, you may need
    to synchronize its access. In the next section, we will see how to synchronize
    thread execution.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要并发访问资源时，无论是通过I/O操作检索的资源还是内存中的对象实例，都可能需要同步其访问。在下一节中，我们将看到如何同步线程执行。
- en: Understanding synchronization primitives
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解同步原语
- en: Every time you write single-threaded code, any method execution occurs sequentially
    and requires no special action from the developer. On the other hand, when some
    code is executed on a separate thread, synchronization is needed to ensure that
    we avoid two dangerous concurrency conditions—**race** and **deadlock**. These
    categories of problems must be carefully avoided during design because their detection
    is difficult and they may occur occasionally.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每当编写单线程代码时，任何方法执行都是顺序进行的，开发人员无需采取特殊操作。另一方面，当一些代码在单独的线程上执行时，需要同步以确保避免两种危险的并发条件——**竞争**和**死锁**。这些问题的类别在设计时必须小心避免，因为它们的检测很困难，而且可能偶尔发生。
- en: A **race condition** is a situation where two or more threads access an unprotected
    shared resource or when the threads' executions behave differently, depending
    on the timing and the underlying process architecture.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**竞争条件**是指两个或多个线程访问未受保护的共享资源，或者线程的执行根据时间和底层进程架构的不同而表现不同的情况。'
- en: A *deadlock condition* happens when two or more threads have a circular dependency
    on each other to access a resource.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*死锁条件*发生在两个或多个线程之间存在循环依赖以访问资源的情况。'
- en: 'The general recommendations when writing some code that may be executed from
    multiple threads are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 编写可能从多个线程执行的代码时，一般建议如下：
- en: Avoid shared resources as much as possible. Their access must be synchronized
    with a lock that will affect the execution performance.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量避免共享资源。它们的访问必须通过锁进行同步，这会影响执行性能。
- en: The stack is your friend. Every time you call a method, the local stack is private,
    ensuring the local variables will not be shared with other callers and threads.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈是你的朋友。每当调用一个方法时，局部栈是私有的，确保局部变量不会与其他调用者和线程共享。
- en: Every time you need to share a resource among multiple threads, use the documentation
    to verify whether it is thread-safe or not. Whenever it is not thread-safe, a
    lock must protect the resource or the code sequence.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当您需要在多个线程之间共享资源时，请使用文档验证它是否是线程安全的。每当它不是线程安全的时候，锁必须保护资源或代码序列。
- en: Even when the shared resource is thread-safe, you must consider whether a number
    of statements need to be executed atomically to guarantee their reliability.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使共享资源是线程安全的，您也必须考虑是否需要原子地执行一些语句，以保证它们的可靠性。
- en: The thread library has many primitives available to protect the resources, but
    we will focus more on those that are more likely to be used in the asynchronous
    context, which is the most important topic that will be covered in this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 线程库有许多可用于保护资源的原语，但我们将更多地关注那些更有可能在异步上下文中使用的原语，这是本章将涵盖的最重要的主题。
- en: 'There are two sets of synchronization primitives:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有两组同步原语：
- en: The ones implemented in *kernel mode* by the OS
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由操作系统在*内核模式*中实现的原语
- en: The ones in *user mode* provided by the .NET class library
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由.NET类库提供的*用户模式*中的同步原语
- en: The distinction is very important because every time you transition to the kernel
    mode with a system call, the OS has to save the local call and stack, which will
    be restored right after, impacting the performance of the operation. The advantage
    of kernel mode primitives is the ability to give them a name and make them shared
    across processes, providing a powerful machine-wide synchronization mechanism.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别非常重要，因为每当您通过系统调用转换到内核模式时，操作系统都必须保存本地调用和堆栈，这将在操作的性能上产生影响。内核模式原语的优势在于能够为它们命名并使它们跨进程共享，提供强大的机器级同步机制。
- en: 'The following example shows two threads from `ThreadPool` printing `Ping` and
    `Pong`. Each thread synchronizes with the other by waiting for the matching `ManualResetEventSlim`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了来自`ThreadPool`的两个线程打印`Ping`和`Pong`。每个线程通过等待匹配的`ManualResetEventSlim`来与另一个线程同步：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After having created the two events, the two threads are run and print the ID
    of the thread they are running on. Inside those threads, each execution is suspended
    in the `Wait` method, which avoids the thread consuming any CPU power. At the
    end of the listing, the `pong.Set` method starts the game and unblocks the first
    thread. Since the events are *manual*, they must be reset to the unsignaled state
    for the next hit. At this point, a message is printed, a delay simulates some
    hard work and, finally, the other event is signaled, which will cause the second
    thread to unblock.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了两个事件之后，两个线程被运行并打印它们正在运行的线程的ID。在这些线程内部，每次执行都会在`Wait`方法中暂停，这样可以避免线程消耗任何CPU资源。在清单的末尾，`pong.Set`方法启动游戏并解除第一个线程的阻塞。由于事件是*手动*的，它们必须被重置为未发信号状态以供下一次使用。此时，会打印一条消息，延迟模拟一些艰苦的工作，最后，另一个事件被发信号，这将导致第二个线程解除阻塞。
- en: 'Alternatively, we can use the `ManualResetEvent` kernel event, whose usage
    is very similar. For example, in place of `Wait`, it has the `WaitOne` method.
    But were we to use these events in a high-performance synchronization algorithm,
    there would be a huge difference. The following table shows a comparison of the
    two synchronization primitives measured with the popular Benchmark.NET micro-benchmark
    library. Both tests simply call `Set()`, followed by the `Reset()` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`ManualResetEvent`内核事件，其使用方法非常相似。例如，它具有`WaitOne`方法，而不是`Wait`。但是，如果我们在高性能同步算法中使用这些事件，将会有很大的差异。以下表格显示了使用流行的Benchmark.NET微基准库测量的两种同步原语的比较。这两个测试只是调用`Set()`，然后调用`Reset()`方法：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is a difference of roughly two orders of magnitude, which is not negligible
    at all.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者之间存在大约两个数量级的差异，这绝对不可忽视。
- en: 'Beyond the ability to use kernel events to synchronize code running in different
    processes, they can be used in conjunction with the powerful `WaitHandle.WaitAny`
    and `WaitAll` methods, as shown in the following example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够使用内核事件来同步在不同进程中运行的代码之外，它们还可以与强大的`WaitHandle.WaitAny`和`WaitAll`方法结合使用，如下例所示：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can play with the three timeouts expressed in milliseconds to see the different
    results. The main idea is to exit the wait as soon as any of the events or the
    timeout expires, whichever comes first.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以毫秒为单位表示的三个超时时间来查看不同的结果。主要思想是尽快退出等待，只要任何事件或超时到期，以先到者为准。
- en: Tip
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The kernel objects of the Windows OS can be all used inside the wait primitives.
    For example, if you want to wait for multiple processes to exit, you can just
    use the `WaitHandle` primitives, shown in the preceding code block, with the process
    handles.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Windows操作系统的内核对象可以在等待原语中全部使用。例如，如果您想等待多个进程退出，您可以使用前面代码块中显示的`WaitHandle`原语与进程句柄一起使用。
- en: We've only just scratched the surface, but the official documentation has many
    samples showing various synchronization objects in action. Instead, we will continue
    to focus on those that are more relevant for this book, such as accessing a shared
    resource from multiple threads.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是刚刚触及了表面，但官方文档中有许多示例展示了各种同步对象的使用。相反，我们将继续专注于对本书更为相关的内容，例如从多个线程访问共享资源。
- en: 'In the following example, we have a shared variable called `_shared`, a `ManualResetEvent`
    object that is used to start all the threads together, and a simple object. The
    `Shared` property makes use of `Thread.Sleep`, causing an explicit thread context
    switch on the setter. The switch is what normally happens when the OS scheduler
    preemptively gives control to another thread in the system. It''s not a trick;
    it just increases the probability that the getter and the setter are not executed
    consecutively by each thread:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们有一个名为`_shared`的共享变量，一个用于同时启动所有线程的`ManualResetEvent`对象，以及一个简单的对象。`Shared`属性利用`Thread.Sleep`，在setter上引起了显式的线程上下文切换。当操作系统调度程序在系统中将控制权预先交给另一个线程时，这种切换通常会发生。这不是一个技巧；它只是增加了getter和setter不会被每个线程连续执行的概率：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following method initializes the shared variable to `0` and creates 10
    threads, all executing the same code in the lambda:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法将共享变量初始化为`0`并创建10个线程，所有线程都执行相同的lambda中的代码：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All the threads start immediately and block the execution in the `WaitOne` event
    that is unblocked by the `Set` method. This gives more chances for many threads
    to execute the code in the lambda with the same timing. Finally, we call `Join`
    to wait for the end of the execution of each thread and print the results.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有线程立即启动并阻塞在`WaitOne`事件中，该事件由`Set`方法解除阻塞。这为许多线程以相同的时间执行lambda中的代码提供了更多机会。最后，我们调用`Join`等待每个线程的执行结束并打印结果。
- en: The synchronization problem of this code exists because the threads will read
    a value, increment the number in a CPU register, and write back the result in
    the variable. Since many threads will read the same value, the value written back
    to the variable is old and its real *current* value gets lost.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的同步问题存在于线程将读取一个值，将数字增加到CPU寄存器中，并将结果写回变量。由于许多线程将读取相同的值，写回变量的值是旧的，其真实的*当前*值丢失了。
- en: By uncommenting the lock statement, we instruct the compiler to surround the
    statements in the curly braces with a **Critical Section**, the fastest user mode
    synchronization object available. This results in serializing the access to that
    code, which has a very significant impact on the performance that is necessary
    and unavoidable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过取消注释锁定语句，我们指示编译器用**关键部分**包围大括号中的语句，这是最快的用户模式同步对象。这将导致对该代码的访问进行序列化，对性能产生非常显著的影响，这是必要且不可避免的。
- en: The empty object instance we created at the beginning should not change; otherwise,
    different threads would wait for different critical sections. Please note that
    the `lock` argument can be any reference type. For example, should you need to
    protect a collection, you can lock it directly without the help of an external
    object. Anyway, in our example, `Shared` is a value type and must be protected
    with the help of a separate reference type.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在开始时创建的空对象实例不应更改；否则，不同的线程将等待不同的临界区。请注意，`lock`参数可以是任何引用类型。例如，如果您需要保护一个集合，可以直接锁定它，而无需外部对象的帮助。无论如何，在我们的示例中，`Shared`是一个值类型，必须借助一个单独的引用类型来保护它。
- en: If you replace the `Shared` property with a simple field, the problem will be
    less likely to occur. Also, the compiler configuration (debug versus release)
    will make a great difference because *inlining* and other optimizations make it
    even more likely that a thread context switch can't happen when accessing a field
    or a simple property. The physical hardware configuration and the CPU architecture
    are other variables that may greatly influence the outcome of these tests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您用一个简单的字段替换`Shared`属性，问题发生的可能性将会降低。此外，编译器配置（调试与发布）将产生很大的差异，因为*内联*和其他优化使得在访问字段或简单属性时更有可能发生线程上下文切换。物理硬件配置和CPU架构是可能会极大影响这些测试结果的其他变量。
- en: Tip
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Unit testing is *not appropriate* to ensure the absence of issues such as race
    conditions or deadlocks. Also, be aware that virtual machines are the worst environment
    to test concurrent code in because the scheduler is more predictable than an OS
    running on the physical hardware.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试*不适合*确保不存在竞争条件或死锁等问题。此外，请注意，虚拟机是最不适合测试并发代码的环境，因为调度程序比在物理硬件上运行的操作系统更可预测。
- en: We have seen how we can ensure that a number of statements are executed atomically,
    with no interference. But if it was just for ensuring an atomic increment of the
    underlying `_shared` field, there is a more convenient tool—the `Interlocked`
    class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何确保一系列语句被原子地执行，没有干扰。但如果只是为了确保底层`_shared`字段的原子增量，有一个更方便的工具——`Interlocked`类。
- en: '`Interlocked` is a static class that exposes a few useful methods to ensure
    the atomicity of certain operations. For example, instead of the `lock` statement,
    we could use the following code, which is much faster, even if limited to the
    operations exposed by `Interlocked`. The following code shows how to atomically
    increment the `_shared` variable:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Interlocked`是一个静态类，公开了一些有用的方法来确保某些操作的原子性。例如，我们可以使用以下代码而不是`lock`语句，这样做会更快，即使只限于`Interlocked`公开的操作。以下代码显示了如何原子地增加`_shared`变量：'
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Among other things, we can use it for writing a variable and getting back the
    old value atomically (the `Exchange` method) or reading variables whose size is
    larger than the available native registers (the `Read` method).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除其他事项外，我们可以用它来原子地写入变量并获取旧值（`Exchange`方法），或者读取大小大于可用本机寄存器的变量（`Read`方法）。
- en: We have seen why synchronization is needed and what the main tools are that
    we can use to protect against these concurrent access problems. But now, it is
    time to introduce an abstraction that will make every developer's life easier—the
    task paradigm.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了为什么需要同步以及我们可以用来防止这些并发访问问题的主要工具。但现在，是时候引入一个抽象，这将使每个开发人员的生活更轻松——任务范式。
- en: The task paradigm
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务范式
- en: Concurrency is primarily about designing algorithms with very loosely coupled
    units of work, which is often not possible or extends the complexity beyond any
    possible benefit.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 并发主要是关于设计具有非常松散耦合的工作单元的算法，这通常是不可能的，或者会使复杂性超出任何可能的好处。
- en: Asynchronous programming is, instead, related to the asynchronous nature of
    the OS and the devices, whether because they fire events or because it takes time
    to fulfill the requested operation. Every time the user moves the mouse, types
    keys on the keyboard, or retrieves some data from the internet, the OS presents
    data to our process in a separate thread and our code must be ready to consume
    it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程与操作系统和设备的异步性相关，无论是因为它们触发事件还是因为完成所请求的操作需要时间。每当用户移动鼠标、在键盘上输入键或从互联网检索一些数据时，操作系统都会在一个单独的线程中向我们的进程呈现数据，我们的代码必须准备好消费它。
- en: 'One of the simplest possible examples is loading a text file from disk and
    computing the string length, which can be different from the file length, depending
    on the encoding:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的例子之一是从磁盘加载文本文件并计算字符串长度，这可能与文件长度不同，这取决于编码：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As soon as you invoke this method, the calling thread gets blocked until the
    OS and the library completes reading it. The operation may be lightning-fast or
    very slow, depending on its size and technology. The text file may be on **Network-Attached
    Storage** (**NAS**), a local disk, a corrupted USB key, or on a remote server
    accessed through a **Virtual Private Network** (**VPN**).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用此方法，调用线程将被阻塞，直到操作系统和库完成读取。该操作可能非常快速，也可能非常缓慢，这取决于其大小和技术。文本文件可能位于网络附加存储（NAS）、本地磁盘、损坏的USB键或通过虚拟专用网络（VPN）访问的远程服务器上。
- en: In the context of a desktop application, any blocking thread will cause an unpleasant
    user experience because the main thread is already responsible for redrawing the
    user interface and responding to the events coming from the input devices.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面应用程序的上下文中，任何阻塞线程都会导致不愉快的用户体验，因为主线程已经负责重绘用户界面并响应来自输入设备的事件。
- en: Server applications are no different because any blocking thread is a resource
    that cannot be used efficiently with other requests, preventing the application
    from scaling and serving other users.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应用程序也不例外，因为任何阻塞线程都是一种资源，无法有效地与其他请求一起使用，从而阻止应用程序扩展并为其他用户提供服务。
- en: For decades, the solution to this problem was to execute the long-lasting code
    by manually creating a separate thread, but more recently, the .NET runtimes introduced
    the task paradigm and the C# language introduced the `async` and `await` keywords.
    Since then, the whole .NET library has been revised to embrace this paradigm,
    providing methods that return task-based operations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，解决这个问题的方法是通过手动创建一个单独的线程来执行长时间运行的代码，但是最近，.NET运行时引入了任务范式，C#语言引入了`async`和`await`关键字。从那时起，整个.NET库已经进行了修订，以拥抱这种范式，提供返回基于任务的操作的方法。
- en: The Task Library, available in the `System.Threading.Tasks` namespace, and the
    language integration provide an abstraction that dramatically simplifies the management
    of asynchronous operations. A task represents a unit of work that performs a well-defined
    job. No matter whether you deal with concurrency or asynchronous events, a task
    defines a given job and its life cycle, going from its creation to its completion,
    the options for which include success, failure, or cancellation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 任务库，位于`System.Threading.Tasks`命名空间中，以及语言集成提供了一个抽象，大大简化了异步操作的管理。任务代表了执行明确定义的工作单元。无论您处理并发性还是异步事件，任务都定义了给定的工作及其生命周期，从创建到完成，其选项包括成功、失败或取消。
- en: Tasks can be composed by defining what other tasks should be executed right
    after a given operation. The chained task is called **continuation** and is automatically
    scheduled from the libraries by means of the **Task Scheduler**.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义其他任务应该在给定操作之后立即执行来组合任务。这个链接的任务称为**延续**，并且通过**任务调度程序**从库中自动安排。
- en: By default, the Task Library provides a default implementation (the `TaskScheduler.Default`
    static property), which most developers will never need to dig into. The default
    implementation orchestrates the task's execution using `ThreadPool` and uses the
    *work-stealing* technique to redistribute the task queue over multiple threads
    to provide load balancing and to prevent tasks from being stalled for too long.
    Be aware that this default implementation is smart enough to eventually make the
    decision to schedule the execution of tasks directly on the main thread instead
    of picking one from the pool. The bravest can experiment with the creation of
    custom schedulers to change the scheduling strategy, but it is something not many
    developers really need to do.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任务库提供了一个默认实现（`TaskScheduler.Default`静态属性），大多数开发人员永远不需要深入研究。默认实现使用`ThreadPool`来编排任务的执行，并使用*工作窃取*技术将任务队列重新分配到多个线程上，以提供负载平衡，并防止任务被阻塞太长时间。请注意，这个默认实现足够聪明，最终会决定直接在主线程上安排任务的执行，而不是从池中选择一个。勇敢的人可以尝试创建自定义调度程序来改变调度策略，但这并不是很多开发人员真正需要做的事情。
- en: Later, in the *Synchronization context* section, we will talk about **synchronization
    context**, which allows continuations to be executed in the calling thread and
    avoids the need to use the synchronization primitives described in the previous
    section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，在*同步上下文*部分，我们将讨论**同步上下文**，它允许延续在调用线程中执行，并避免使用前一节中描述的同步原语的需要。
- en: 'Let''s begin investigating tasks with the asynchronous version of reading a
    text file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从读取文本文件的异步版本开始研究任务：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This new version of the method *immediately completes* and, instead of returning
    the content of the file, returns an object representing the *ongoing* operation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的新版本*立即完成*，而不是返回文件的内容，而是返回表示*正在进行*操作的对象。
- en: 'Since we just initiated the operation that didn''t complete yet, the steps
    required to manage the completion are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们刚刚启动了尚未完成的操作，管理完成所需的步骤如下：
- en: Refactor out the code following the asynchronous operation (getting the string
    length) in a separate method. This method is equivalent to the old-style callback
    that mustn't be called before the asynchronous operation has completed.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将异步操作后面的代码（获取字符串长度）重构为一个单独的方法。这个方法相当于旧式的回调，不能在异步操作完成之前调用。
- en: Monitor the ongoing task and provide a notification when it has completed or
    failed.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监视正在进行的任务，并在完成或失败时提供通知。
- en: Once completed, retrieve the result and synchronize the execution (by means
    of **synchronization context**) on the main thread, or throw an exception if something
    has gone wrong. This step is crucial if we don't want to mess with potential race
    conditions.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，检索结果并在主线程上同步执行（通过**同步上下文**），或者如果出现问题则抛出异常。如果我们不想搞乱潜在的竞争条件，这一步是至关重要的。
- en: Invoke the callback that we refactored out at the first point.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用我们在第一个点重构出来的回调。
- en: 'Of course, we don''t have to manually manage all this machinery. The first
    interesting advantage of the Task Library is its support for continuations, which
    allow the developer to specify the code to be executed as soon as the task completes
    successfully:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不必手动管理所有这些机制。任务库的第一个有趣的优势是它支持继续，这允许开发人员指定任务成功完成后要执行的代码：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This new version is better than creating threads and manually writing the synchronization
    code, even if it can be further improved. The `ContinueWith` method contains the
    code that determines the other code to be executed as soon as the file has been
    successfully read.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新版本比创建线程和手动编写同步代码要好，即使它还可以进一步改进。`ContinueWith`方法包含了确定其他代码在文件成功读取后立即执行的代码。
- en: The `t` variable contains the task, which is either failed or completed successfully.
    If it was successful, `t.Result` contains the string content obtained from the
    `ReadAllTextAsync` method.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`t`变量包含任务，该任务要么失败，要么成功完成。如果成功，`t.Result`包含从`ReadAllTextAsync`方法获取的字符串内容。'
- en: Anyway, we still don't have the length; we just expressed how to retrieve the
    length in the *future* once the result of `ReadAllTextAsync` has been retrieved.
    This is the reason why the `lengthTask` variable is a `Task<int>`, that is, the
    promise of an integer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们仍然没有长度；我们只是表达了如何在*将来*检索`ReadAllTextAsync`的结果后检索长度。这就是为什么`lengthTask`变量是`Task<int>`，即整数的承诺。
- en: Tasks and continuations are the building blocks that I strongly recommend experimenting
    with because there are times they need to be managed directly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议尝试使用任务和继续，因为有时它们需要直接管理。
- en: But the C# language also introduced two precious keywords that further simplify
    the code we need to write. The `await` keyword is used to indicate that the result
    of the operation and everything that comes after it is part of a continuation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 但C#语言还引入了两个宝贵的关键字，进一步简化了我们需要编写的代码。`await`关键字用于指示操作的结果以及其后的所有内容都是一个继续的一部分。
- en: 'Thanks to the `await` keyword, the compiler refactors and generates new **Intermediate
    Language** (**IL**) code to provide the appropriate management of asynchronous
    operations and the continuation. The final code to asynchronously load the content
    of the file and return the string length is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`await`关键字，编译器重构并生成新的**中间语言**（**IL**）代码，以提供适当的异步操作和继续的管理。最终的代码以异步方式加载文件内容并返回字符串长度如下：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The highlighted portions of code are refactored by the compiler with more than
    just a continuation. The compiler generates a *class* to take care of the state
    machine responsible for monitoring the task progress, and a method for calling
    the appropriate code or throwing an exception, as soon as the state of the task
    changes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器重构的代码部分不仅仅是一个继续。编译器生成一个*类*来负责监视任务进度的状态机，并生成一个调用适当代码或抛出异常的方法，一旦任务状态发生变化。
- en: Tip
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to dig into more details on the generated code, you can use the
    **ILSpy** tool (https://github.com/icsharpcode/ILSpy/releases) and see the generated
    IL code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想深入了解生成的代码的更多细节，可以使用**ILSpy**工具（https://github.com/icsharpcode/ILSpy/releases）并查看生成的IL代码。
- en: Apparently, the compiler could get rid of the promise and let us work on the
    returned content, right? Not really – this code is refactored and the code we
    wrote is an artifact expressing our expectations rather than what normally and
    sequentially happens in a method.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，编译器可以摆脱承诺，让我们处理返回的内容，对吗？实际上不是 - 这段代码被重构了，我们编写的代码是表达我们的期望，而不是方法中通常和顺序发生的事情。
- en: In fact, the preceding code looks contradictory, as the `content.Length` integer
    will only be available in the future, but we return it directly from a method
    with the return type of `Task<int>`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，前面的代码看起来矛盾，因为`content.Length`整数只会在将来可用，但我们直接从返回类型为`Task<int>`的方法中返回它。
- en: 'This is where the `async` keyword comes into play:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`async`关键字发挥作用的地方：
- en: The `async` keyword is a modifier that must be specified every time we want
    to use `await` inside a method.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`关键字是一个修饰符，每次我们想在方法内部使用`await`时都必须指定。'
- en: The `async` keyword informs us that the `return` statement specifies a future
    object or value. In our case, we return `int` but `async` informs us that it is
    really a `Task<int>`.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`关键字告诉我们，`return`语句指定了一个未来的对象或值。在我们的情况下，我们返回`int`，但`async`告诉我们它实际上是一个`Task<int>`。'
- en: Should an `async` method return `void`, the return type becomes the non-generic
    `Task`.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个`async`方法返回`void`，返回类型变成了非泛型的`Task`。
- en: We now have a method that is processing the file asynchronously, but we had
    to change the signature from `int` to `Task<int>`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个异步处理文件的方法，但我们不得不将签名从`int`改为`Task<int>`。
- en: 'When you write a lambda using the `await` keyword in its body, the `async`
    keyword is required as well. For example, let''s look at the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在lambda中使用`await`关键字时，也需要使用`async`关键字。例如，让我们看一下以下代码：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using `async` on a method implies that all the callers must embrace the task
    paradigm as well because otherwise, they could not know when the operation completes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法上使用`async`意味着所有调用者也必须采用任务范式，否则他们可能无法知道操作何时完成。
- en: Synchronous implementations of asynchronous methods
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步方法的同步实现
- en: We have seen how the task paradigm impacts the method signature and we know
    how important a method signature is. When it appears on a public API or in interfaces,
    it is a contract that, in most cases, we can't change. From a design perspective,
    it can be very valuable for anticipating the possibility of a given method being
    implemented with tasks, but there are cases where asynchronicity is not needed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了任务范例如何影响方法签名，我们知道方法签名有多重要。当它出现在公共API或接口中时，它是一个合同，大多数情况下我们不能更改。从设计的角度来看，对于预期可能使用任务实现的方法的可能性，这可能非常有价值，但也有一些不需要异步性的情况。
- en: 'For those cases, the `Task` class exposes a static method allowing us to directly
    build a completed task with or without results. In the following example, the
    asynchronous method synchronously returns a completed task:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些情况，`Task`类公开了一个静态方法，允许我们直接构建一个带有或不带结果的已完成任务。在下面的示例中，异步方法同步返回一个已完成的任务：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `CompletedTask` property is created only once for the entire application
    domain; therefore, it is extremely lightweight and should not be any cause for
    concern regarding performance.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletedTask`属性仅为整个应用程序域创建一次；因此，它非常轻量级，不应引起性能方面的担忧。'
- en: 'If, instead, we need to return a value, we can use the static `FromResult`
    method, which internally creates a new completed `Task` every time it is invoked:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要返回一个值，我们可以使用静态的`FromResult`方法，它在每次调用时内部创建一个新的已完成`Task`：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Creating an object every time we add two numbers is definitely a performance
    concern because it directly impacts the amount of work the garbage collector has
    to do. For this reason, more recently, Microsoft introduced the `ValueTask` classes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们添加两个数字时创建一个对象绝对是性能问题，因为它直接影响垃圾收集器需要做的工作量。因此，最近，微软引入了`ValueTask`类。
- en: Occasionally asynchronous methods
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偶尔的异步方法
- en: The `ValueTask` immutable struct is a convenient wrapper around either a synchronous
    result or `Task`. This further abstraction is meant to simplify those cases where
    the method is required to have an asynchronous signature, but its implementation
    is just occasionally asynchronous.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueTask`不可变结构是对同步结果或`Task`的便捷包装。这种进一步的抽象旨在简化那些需要方法具有异步签名，但其实现只是偶尔异步的情况。'
- en: 'The `AddAsync` method we defined with tasks in the previous section can easily
    be converted to use the `ValueTask` struct instead:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中使用任务定义的`AddAsync`方法可以很容易地转换为使用`ValueTask`结构：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The overhead of using `Task` is clear for a trivial sum; therefore, whenever
    such a method should be called in a hot path (some performance-critical code),
    it would certainly be a performance concern.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微不足道的总和使用`Task`的开销是明显的；因此，每当在热路径（一些性能关键代码）中应该调用这样的方法时，肯定会引起性能问题。
- en: Anyway, there are cases where you may need to convert `ValueTask` into `Task`
    in order to benefit from all the utilities we will continue to discuss in the
    rest of this chapter. The conversion is available with the `AsTask` method, which
    returns the wrapped task, if any, or creates a fresh new `Task` if not.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，有些情况下，您可能需要将`ValueTask`转换为`Task`，以便从本章剩余部分讨论的所有实用工具中受益。转换可通过`AsTask`方法实现，该方法返回包装的任务（如果有），或者如果没有，则创建一个全新的`Task`。
- en: Breaking the task chain – blocking the thread
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中断任务链 - 阻塞线程
- en: Given a task, if you call the `Wait` method or access the `Result` getter property,
    they will block the thread execution until the task is either completed or canceled.
    The rationale behind the task paradigm is to avoid blocking threads so that they
    can be reused for other purposes. But blocking may also provoke very bad side
    effects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个任务，如果调用`Wait`方法或访问`Result`获取器属性，它们将阻塞线程执行，直到任务完成或取消。任务范例背后的理念是避免阻塞线程，以便它们可以被重用于其他目的。但是阻塞也可能引发非常严重的副作用。
- en: Since the default source for threads in asynchronous programming is `ThreadPool`
    (should it exhaust its threads), any further request will be automatically blocked.
    This phenomenon is known as **thread starvation**.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异步编程的默认线程来源是`ThreadPool`（如果耗尽其线程），任何进一步的请求都将自动阻塞。这种现象被称为**线程饥饿**。
- en: The general advice is to avoid waiting and use the `await` keyword or the continuations
    to complete some work.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一般建议是避免等待，而是使用`await`关键字或延续来完成一些工作。
- en: Manually creating a task
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动创建任务
- en: 'There are times when a library does not offer an asynchronous behavior but
    you don''t want to keep the current thread busy for that long. In this case, you
    can use the `Task.Run` method, which schedules the execution of the lambda, which
    will most probably occur in a separate thread. The following example shows how
    to read the length of a file if the asynchronous `ReadAllTextAsync` method that
    we used previously were not available:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有时库不提供异步行为，但您不希望保持当前线程忙碌太长时间。在这种情况下，您可以使用`Task.Run`方法，该方法安排执行lambda，这很可能会发生在一个单独的线程中。下面的示例展示了如何读取文件的长度，如果我们之前使用的异步`ReadAllTextAsync`方法不可用：
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You should always prefer the provided asynchronous version instead of using
    the `Run` method because the thread where this task is scheduled will block until
    the end of the synchronous execution.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终优先使用提供的异步版本，而不是使用`Run`方法，因为安排此任务的线程将一直阻塞，直到同步执行结束。
- en: We will now look at what the best course of action is whenever there is a very
    large amount of work to be done inside a task.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看在任务内部有大量工作要做时，采取的最佳行动方案是什么。
- en: Long-running tasks
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长时间运行的任务
- en: Even if you don't block the thread, there is still the risk of starvation whenever
    the asynchronous stack never awaits and becomes a long-running job, keeping the
    thread busy.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不阻塞线程，当异步堆栈从不等待并成为长时间运行的作业时，仍然存在饥饿的风险，使线程保持忙碌。
- en: 'These cases can be treated with two different strategies:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况可以用两种不同的策略来处理：
- en: The first is manually *creating a thread*, which we already discussed at the
    beginning of this chapter. This is the best strategy when you need more control
    or need to modify the thread properties.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种是手动“创建线程”，这是我们在本章开头已经讨论过的。当你需要更多控制或需要修改线程属性时，这是最好的策略。
- en: 'The second possibility is *informing the task scheduler* that the task is going
    to run for a long time. This way, the scheduler will take a different strategy
    and avoid the `ThreadPool` altogether. The following code shows how to run a long-running
    task:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种可能性是*通知任务调度程序*任务将要运行很长时间。这样，调度程序将采取不同的策略，完全避免`ThreadPool`。以下代码显示了如何运行一个长时间运行的任务：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The essential recommendation is to try splitting the long jobs into smaller
    units of work that can be easily transformed into tasks.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 基本建议是尝试将长时间的工作拆分成可以轻松转换为任务的较小工作单元。
- en: Breaking the task chain – fire and forget
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打破任务链 - 火而忘
- en: 'We have seen that embracing the task paradigm requires modifying the entire
    chain of callers. But there are times when this is not possible and also not desirable.
    For example, in the context of a desktop WPF application, you may have to write
    to a file inside a button-click event handler:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，拥抱任务范式需要修改整个调用链。但有时这是不可能的，也不可取。例如，在桌面WPF应用程序的上下文中，您可能需要在按钮点击事件处理程序中写入文件：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can''t change its signature to return a `Task`; moreover, this would not
    make sense for two reasons:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能改变它的签名来返回一个`Task`；而且，出于两个原因，这也没有意义：
- en: The calling library has been designed before the tasks and it would not be able
    to manage the task progress.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用库在任务之前设计过，它将无法管理任务的进度。
- en: This is one of the events designed as a **Fire-and-Forget** operation, meaning
    that you don't really care how long they will take or which result they are going
    to compute.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是设计为**火而忘**操作之一，意味着你并不真的在乎它们会花多长时间或者它们将计算出什么结果。
- en: 'For these cases, you can embrace the `async`/`await` keywords while not using
    the returning `Task` at all:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些情况，你可以拥抱`async`/`await`关键字，同时根本不使用返回的`Task`：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: But remember, when you break the task chain, you lose the possibility to know
    whether the operation will ever complete or fail.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，当你打破任务链时，你失去了知道操作是否会完成或失败的可能性。
- en: Information box
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: Every time you see `async void` in your code, you should wonder whether it could
    be a potential bug, or just that you really don't want to know what will happen
    to that task in the end. Over the years, the habit to use `async void` instead
    of `async Task` has been the primary source of bugs in asynchronous code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你在你的代码中看到`async void`时，你应该想知道它是否可能是一个潜在的错误，或者只是你真的不想知道最终会发生什么。多年来，使用`async
    void`而不是`async Task`的习惯一直是异步代码中错误的主要来源。
- en: 'Similarly, if you just invoke an asynchronous method without awaiting it (or
    using one of the `ContinueWith` methods), you will lose control of the invocation
    obtaining the same *fire-and-forget* behavior, because asynchronous methods return
    immediately after starting the asynchronous operation. Also, all the code following
    a not-awaited asynchronous operation will be executed concurrently, incurring
    the risk of race conditions or accessing data that is not yet available:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你只是调用一个异步方法而不等待它（或使用`ContinueWith`方法之一），你将失去对调用的控制，获得相同的*火而忘*行为，因为异步方法在启动异步操作后立即返回。此外，不等待异步操作之后的所有代码将同时执行，存在竞争条件或访问尚不可用的数据的风险：
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have seen how simple it is to manage an asynchronous operation when everything
    completes successfully, but the code can throw exceptions and we need to catch
    them appropriately.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了当一切顺利完成时管理异步操作是多么简单，但代码可能会抛出异常，我们需要适当地捕获它们。
- en: Task and exceptions
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务和异常
- en: There are two kinds of exceptions that can happen when something goes wrong.
    The first is before any asynchronous method gets called, while the second is related
    to exceptions happening in the asynchronous code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现问题时，有两种异常可能发生。第一种是在调用任何异步方法之前发生的，而第二种与异步代码中发生的异常有关。
- en: 'The following example shows these two cases:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了这两种情况：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the first case, we are telling the caller that we will return a `Task<int>`
    but that no asynchronous operation has begun yet. This situation is exactly what
    happens in synchronous methods and can be caught accordingly:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们告诉调用者我们将返回一个`Task<int>`，但还没有开始任何异步操作。这种情况与同步方法中发生的情况完全相同，可以相应地捕获：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'On the other hand, if the exception occurs in the continuation, the exception
    will not happen immediately; it will only happen as soon as the task is *consumed*:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果异常发生在继续执行中，异常不会立即发生；它只会在任务被“消耗”时发生：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As soon as `resultTask` has completed as *faulted*, the exception has already
    happened but the compiler-generated code caught it and assigned it to the `Task.Exception`
    property. Since there may be multiple exceptions happening at the same time inside
    `Task`, the generated code encapsulates all the captured exceptions inside a single
    `AggregateException`. The `InnerException` and `InnerExceptions` properties in
    `AggregateException` contain the original exception.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`resultTask`完成为*故障*，异常已经发生，但是编译器生成的代码捕获了它并将其分配给`Task.Exception`属性。由于在`Task`内可能同时发生多个异常，生成的代码将所有捕获的异常封装在单个`AggregateException`中。`AggregateException`中的`InnerException`和`InnerExceptions`属性包含原始异常。
- en: 'Whenever you want to handle the exceptions and resolve them immediately, you
    may want to use the continuations instead of the `await` keyword:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你想要处理异常并立即解决它们时，你可能希望使用继续而不是`await`关键字：
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we mentioned previously, the exception in a *faulted* task is thrown as soon
    as the result gets *consumed*, which we previously mentioned in the context of
    using `await`. However, this can also occur in the case where the `t.Result` property
    is accessed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，在*faulted*任务中的异常会在结果被*消耗*时立即抛出，我们之前在使用`await`的情况下提到过。然而，当访问`t.Result`属性时，这也可能发生。
- en: Tip
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The `Task` class exposes the `GetAwaiter` method, which returns the inner struct
    representing the asynchronous operation. You can get the result of the asynchronous
    operation with `task.GetAwaiter().GetResult()`, as well as `task.Result`, but
    there is a small difference. In fact, in the case of an exception, the former
    returns the original exception, while the latter returns an `AggregateException`
    containing the original exception.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`类公开了`GetAwaiter`方法，该方法返回表示异步操作的内部结构。你可以使用`task.GetAwaiter().GetResult()`来获取异步操作的结果，以及`task.Result`，但两者有一点不同。实际上，在发生异常时，前者返回原始异常，而后者返回包含原始异常的`AggregateException`。'
- en: 'Finally, it is worth mentioning that we can rewrite the `CrashAfterAsync` method
    with the static `Task.FromException<T>` method instead:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是，我们可以使用静态的`Task.FromException<T>`方法来重写`CrashAfterAsync`方法：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Similar to what we saw with `FromResult<T>`, a new `Task` is created, but this
    time, its state is initialized to *faulted* and it contains the desired exception.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在`FromResult<T>`中看到的类似，创建了一个新的`Task`，但这次，它的状态被初始化为*faulted*，并包含所需的异常。
- en: The preceding example is quite abstract but succinct enough to give you an idea
    of how to properly handle exceptions, depending on when they are thrown. There
    are many scenarios where this regularly happens. A real example of this duality
    would be an serialization exception occurring when preparing the JSON parameters
    or during the HTTP rest call as a result of a network failure.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子相当抽象，但足够简洁，让你了解如何根据抛出异常的时间来正确处理异常。有许多常见的情况会发生这种情况。这种二元性的一个真实例子是，在准备JSON参数时发生序列化异常，或者在HTTP
    rest调用期间由于网络故障而发生异常。
- en: In addition to transitioning to the faulted state, tasks can also be canceled,
    thanks to a built-in standard mechanism provided by the task paradigm.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 除了转换为故障状态，任务也可以被取消，这要归功于任务范例提供的内置标准机制。
- en: Canceling a task
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消任务
- en: Unlike faults, cancellation is requested from the callers to interrupt the execution
    of one or more tasks. Cancellation can be imperative, or simply a timeout, which
    is very useful when a given task should not take more than a given amount of time.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 与故障不同，取消是由调用者请求来中断一个或多个任务的执行。取消可以是强制性的，也可以是超时，当给定任务不应该花费超过一定时间时，这是非常有用的。
- en: 'From the caller''s perspective, the cancellation pattern originates from the
    `CancellationTokenSource` class, which provides three different constructors:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从调用者的角度来看，取消模式源自`CancellationTokenSource`类，它提供了三种不同的构造函数：
- en: The default constructor is used when you are willing to cancel tasks by imperatively
    calling the `Cancel` method.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你愿意通过强制调用`Cancel`方法来取消任务时，使用默认构造函数。
- en: The other constructors take either an `int` or a `TimeSpan`, which determine
    the maximum amount of time before a cancellation gets triggered, unless the tasks
    complete beforehand.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他构造函数接受`int`或`TimeSpan`，它们确定在触发取消之前的最长时间，除非任务在此之前完成。
- en: 'In the following example, we will experiment with canceling one of the three
    worker methods using a `CancellationToken` that has been obtained from a timed
    `CancellationTokenSource`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将使用从定时`CancellationTokenSource`获得的`CancellationToken`来取消三个工作方法中的一个：
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `Token` property returns a read-only struct that can be used by multiple
    consumers without impacting on the garbage collector or even being copied, as
    it is immutable.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`Token`属性返回一个只读结构，可以被多个消费者使用，而不会影响垃圾收集器，甚至不会被复制，因为它是不可变的。'
- en: 'The first consumer being examined here takes `CancellationToken` and correctly
    propagates it to any other method that accepts cancellations. In our example,
    there is just `Task.Delay`, a very convenient method used to instruct the infrastructure
    to trigger the continuation after 5 seconds:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里正在检查的第一个消费者接受`CancellationToken`，并将其正确传播给任何其他接受取消的方法。在我们的例子中，只有`Task.Delay`，这是一个非常方便的方法，用于指示基础设施在5秒后触发继续执行：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The result of the preceding code''s execution is the cancellation of the task,
    which is transformed into a `TaskCanceledException` by the code generated from
    the `await` keyword:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的执行结果是任务被取消，这通过从`await`关键字生成的代码转换为`TaskCanceledException`：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Another possibility is when a worker is executing only *synchronous* code and
    still needs to be canceled:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是，当工作程序只执行*同步*代码并且仍然需要被取消时：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Please note the use of `Thread.Sleep` instead of the `Delay` method, which was
    necessary because we wanted a synchronous implementation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用`Thread.Sleep`而不是`Delay`方法，这是因为我们需要同步实现。
- en: The `Thread.Sleep` method is very different because it blocks the thread entirely
    and prevents the thread from being reused anywhere else, while `Task.Delay` spawns
    a request to call the following code as a continuation as soon as the specified
    amount of time has expired.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.Sleep`方法非常不同，因为它完全阻塞线程，并防止线程在其他任何地方被重用，而`Task.Delay`会生成一个请求，在指定的时间过去后立即调用以下代码作为继续执行。'
- en: The more interesting part is testing the `IsCancellationRequested` Boolean property
    to allow a collaborative cancellation of the task. Being collaborative by explicitly
    checking that property is necessary because you may not need to interrupt the
    execution before having disposed of some resource, be it written on a database
    or anywhere else.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的部分是测试`IsCancellationRequested`布尔属性，以允许协作取消任务。通过显式检查该属性来进行协作是必要的，因为在释放某些资源之前，你可能不需要中断执行，无论是在数据库上还是其他地方。
- en: 'Once again, the result of executing the preceding method will be as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 再次执行前面的方法的结果将如下：
- en: '[PRE42]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The third and final case is when you don''t want to throw any exception, but
    just to return from the execution:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种情况是当你不想抛出任何异常，而只是从执行中返回：
- en: '[PRE43]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this case, we carefully avoided propagating `CancellationToken` to the underlying
    calls, because, by using `await`, it would have triggered the exception.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们小心地避免将`CancellationToken`传播到底层调用，因为使用`await`会触发异常。
- en: 'The execution of this final `WorkForever3Async` method does not raise any exceptions
    and lets the execution continue normally:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终的`WorkForever3Async`方法的执行不会引发任何异常，并让执行继续正常进行：
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The downside of this implementation is that the cancellation may not happen
    immediately. `Task.Delay` will need to complete regardless of the cancellation,
    which, in the worst case, can't happen before 5 seconds.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的缺点是取消可能不会立即发生。`Task.Delay`将需要完成，而不管取消，这在最坏的情况下可能在5秒之前无法发生。
- en: We have seen how the task paradigm makes running asynchronous operations dramatically
    easier, but how can we run multiple asynchronous requests at the same time? They
    can potentially be run in parallel to avoid useless waits.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到任务范式如何使运行异步操作变得极其容易，但我们如何同时运行多个异步请求呢？它们可能会并行运行，以避免无用的等待。
- en: Monitoring the progress of a task
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视任务的进度
- en: After the user starts a long-running operation, providing feedback is very important
    to avoid the user becoming frustrated. This is possible when you are in control
    of what is happening, such as with some a time-expensive algorithm. Instead, when
    the long-running operation depends on a call to an external library, monitoring
    the progress is not possible.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 用户开始长时间运行操作后，提供反馈非常重要，以避免用户变得沮丧。当你控制正在发生的事情时，比如一些耗时的算法，这是可能的。然而，当长时间运行的操作依赖于对外部库的调用时，监视进度是不可能的。
- en: The Task Library does not have specific support for monitoring progress, but
    the .NET library provides `IProgress<T>`, which can easily be used for this goal.
    This interface just provides a single member—`void Report(T value)`—which leaves
    total freedom on the implementation details. In the simplest cases, `T` would
    be an integer value representing the progress as a percentage.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 任务库没有专门支持监视进度，但.NET库提供了`IProgress<T>`，可以轻松实现这一目标。这个接口只提供一个成员——`void Report(T
    value)`——这给了实现细节完全的自由。在最简单的情况下，`T`将是一个表示进度的整数值，表示为百分比。
- en: 'For example, a load operation could be implemented as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，加载操作可以实现如下：
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The method, which in our case simulates an asynchronous operation by just calling
    `Task.Delay`, must have a prediction of the total number of steps that relates
    to 100% of the progress. After each step, the `Report` method is called to inform
    us about the current percentage, but ensure the code is protected from the progress
    being null, as the consumer may not be interested in receiving such feedback.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这个方法通过调用`Task.Delay`来模拟异步操作，必须预测与进度的100%相关的总步数。在每一步之后，调用`Report`方法来通知我们当前的百分比，但要确保代码受到保护，以防进度为空，因为消费者可能对接收这样的反馈不感兴趣。
- en: 'On the consumer side, the first thing to do is create the progress provider,
    which is simply a class implementing `IProgress<int>`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者端，首先要做的是创建进度提供程序，这只是一个实现`IProgress<int>`的类：
- en: '[PRE46]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, the caller should just pass the provider instance to the `Load` method:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用者只需将提供程序实例传递给`Load`方法：
- en: '[PRE47]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you may expect, the output is as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的那样，输出如下：
- en: '[PRE48]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The generic argument of `IProgress<T>` can potentially be used to pause the
    execution or trigger more complex logic such as pausing/resuming behavior.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`IProgress<T>`的通用参数可能被用来暂停执行或触发更复杂的逻辑，比如暂停/恢复行为。'
- en: Parallelizing tasks
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行化任务
- en: 'A common programming task is retrieving some resources from the internet. For
    example, the essential code to download a resource via HTTP is as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的编程任务是从互联网上检索一些资源。例如，通过HTTP下载资源的基本代码如下：
- en: '[PRE49]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Thanks to `EnsureSuccessStatusCode`, any failure will trigger an exception,
    leaving the responsibility of catching it to the caller. Also, we didn't even
    set any header, but it's enough for our purposes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`EnsureSuccessStatusCode`，任何失败都会触发异常，将捕获的责任留给调用者。此外，我们甚至没有设置任何标头，但对我们的目的来说已经足够了。
- en: 'We already know how to invoke this asynchronous method to download an image,
    but now the challenge is choosing the right strategy to download many of them:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何调用这个异步方法来下载图像，但现在的挑战是选择正确的策略来下载许多图像：
- en: 'The first question is: *how can we download multiple images in parallel?* If
    we need to download 10 images, we don''t want to sum the times needed to download
    each of them. Anyway, we will not enter into the discussion of how much we can
    scale if, let''s say, you need to download millions of images. This would be out
    of the scope of a discussion about asynchronous machinery.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个问题是：*我们如何并行下载多个图像？* 如果我们需要下载10张图像，我们不想将下载每张图像所需的时间相加。无论如何，我们不会讨论如果我们需要下载数百万张图像时可以扩展多少。这超出了关于异步机制的讨论范围。
- en: 'The second question is: *do we need them all at the same time?* In this case,
    we can use the `Task.WhenAll` helper method, which takes an array of tasks and
    returns a single task representing the overall operation.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个问题是：*我们需要同时使用它们吗？* 在这种情况下，我们可以使用`Task.WhenAll`辅助方法，它接受一个任务数组，并返回一个表示整体操作的单个任务。
- en: 'For these samples, we are going to use the online free service called *Lorem
    PicSum* ([https://picsum.photos/](https://picsum.photos/)). Every time you make
    a request to the URI you see in the code, a new and different image sized 200
    x 200 will be retrieved. You can, of course, use any URI of your choice:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些示例，我们将使用名为*Lorem PicSum*（[https://picsum.photos/](https://picsum.photos/)）的在线免费服务。每次你向代码中看到的URI发出请求时，都会检索到一个新的不同大小为200
    x 200的图像。当然，你可以使用你选择的任何URI：
- en: '[PRE50]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The use of `Enumerable.Range` is a nice way to repeat an action for the given
    number of times. We don't really care about the generated numbers; in fact, we
    use the `discard (_)` token instead of a variable in the `Select` method.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Enumerable.Range`是一种很好的方式，可以重复执行给定次数的操作。实际上，我们并不关心生成的数字；事实上，我们在`Select`方法中使用了`discard
    (_)`标记而不是变量。
- en: The `Select` lambda just initiates the download operations returning the corresponding
    tasks that we don't await yet. Instead, we ask the `WhenAll` method to create
    a new `Task` that will be signaled as soon as all the tasks are completed successfully.
    Should any task fail, the code generated from the `await` keyword will cause an
    exception to be thrown.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select` lambda只是启动下载操作，返回相应的任务，我们还没有等待。相反，我们要求`WhenAll`方法创建一个新的`Task`，一旦所有任务都成功完成，就会发出信号。如果任何任务失败，从`await`关键字生成的代码将导致抛出异常。'
- en: 'The task obtained from the `WhenAll` method cannot be used to retrieve the
    results, but it guarantees that we can access the `Result` properties for all
    the tasks. Therefore, after awaiting `allTask`, we iterate the `tasks` array retrieving
    the `byte[]` array for all the downloaded images. Here is the output obtained
    by awaiting all the downloads at the same time:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 从`WhenAll`方法获得的任务不能用于检索结果，但它保证我们可以访问所有任务的`Result`属性。因此，在等待`allTask`之后，我们迭代`tasks`数组，检索所有已下载图像的`byte[]`数组。以下是同时等待所有下载的输出：
- en: '[PRE51]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In many cases, this is a good strategy because we may need all the resources
    before continuing. An alternative is to wait for the first download so that we
    can start processing it, but we still want to download them all concurrently to
    save time.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，这是一个很好的策略，因为我们可能需要在继续之前获取所有资源。另一种选择是等待第一次下载，这样我们就可以开始处理它，但我们仍然希望同时下载它们以节省时间。
- en: 'This alternative strategy can be pursued with the help of the `WaitAny` method.
    In the following example, starting the downloads is no different. We just add
    a `Stopwatch` class to show the time taken in milliseconds at the end of the downloads:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代策略可以借助`WaitAny`方法来实现。在下面的示例中，开始下载没有什么不同。我们只是添加了一个`Stopwatch`类，以显示下载结束时花费的毫秒数：
- en: '[PRE52]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `while` loop is used to process all the unfinished tasks. Initially, the
    `tasks` array contains all of them, but every time `WhenAny` completes, it means
    that at least one task has completed. The completed ones are immediately printed
    on screen, together with the milliseconds elapsed since the beginning of the operation.
    The other ones are reassigned to the `tasks` variable so that we can loop back
    and process the completed tasks until the very last one. The output of this new
    method is as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环用于处理所有未完成的任务。最初，`tasks`数组包含所有任务，但每次`WhenAny`完成时，至少一个任务已完成。已完成的任务立即在屏幕上打印出来，并显示自操作开始以来经过的毫秒数。其他任务被重新分配给`tasks`变量，这样我们就可以循环回去处理已完成的任务，直到最后一个任务。这种新方法的输出如下：'
- en: '[PRE53]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Of course, you can combine these two methods together. For example, if you
    want to get as many downloaded images as possible in no more than 100 milliseconds,
    just replace the `WhenAny` line with the following one:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以将这两种方法结合起来。例如，如果你想在不超过100毫秒的时间内尽可能多地获取已下载的图像，只需用以下一行替换`WhenAny`行：
- en: '[PRE54]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In other words, we are asking to wait for any task (at least one) but not before
    100 milliseconds. The `while` loop will repeat the operation, as we did previously,
    by consuming all the remaining tasks:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们要求等待任何任务（至少一个），但不超过100毫秒。`while`循环将重复操作，就像我们之前所做的那样，消耗所有剩余的任务：
- en: '[PRE55]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When you test these code snippets, be sure to run them in a loop because the
    first run can be heavily influenced by the **Just-in-Time** compiler.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试这些代码片段时，一定要在循环中运行它们，因为第一次运行可能会受到**即时**编译器的严重影响。
- en: We have seen how the `Task` class provides a very powerful building block to
    consume asynchronous operations, but this requires libraries providing asynchronous
    behavior. In the next section, we will see how we can expose a manual task and
    trigger its completion.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到`Task`类提供了一个非常强大的构建块来消耗异步操作，但这需要提供异步行为的库。在下一节中，我们将看到如何暴露手动任务并触发其完成。
- en: Signaling tasks with the TaskCompletionSource object
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`TaskCompletionSource`对象发出任务信号
- en: Going back to the file watcher sample in the *What is a thread?* section at
    the beginning of this chapter, you may remember `FileSystemWatcher` exposing events
    and not embracing the task paradigm. You may wonder whether we write some sort
    of adapter to leverage the power of all the nice tools offered by the Task Library,
    and the answer is *yes*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 回到本章开头*什么是线程？*部分的文件监视器示例中，你可能还记得`FileSystemWatcher`暴露了事件，而没有采用任务范例。你可能会想知道我们是否编写了某种适配器来利用任务库提供的所有好工具的能力，答案是*是*。
- en: The `TaskCompletionSource` object provides an important building block that
    we can use to expose asynchronous behavior. It is created and used on the producer
    side to signal the completion of an operation, be it a success or a failure. It
    provides, via the `Task` property, the task object that must be used from the
    client to await the notification.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskCompletionSource`对象提供了一个重要的构建块，我们可以用它来暴露异步行为。它在生产者端创建和使用，以信号操作的完成，无论是成功还是失败。它通过`Task`属性提供了任务对象，客户端必须使用它来等待通知。'
- en: 'The following class uses `FileSystemWatcher` to monitor the filesystem in the
    current folder. The `Deleted` event stops the notifications and notifies the completion
    source about the successful deletion of a file. Similarly, the `Error` event sets
    the exception that will be eventually triggered on the consumer side of the `await`
    statement:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类使用`FileSystemWatcher`来监视当前文件夹中的文件系统。`Deleted`事件停止通知并通知完成源文件成功删除。类似地，`Error`事件设置了最终将在`await`语句的消费方触发的异常：
- en: '[PRE56]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Every time the `WhenDeleted` method is called, a new completion source is created,
    the file watcher is started, and the `Task` responsible for the notification is
    returned to the client.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用`WhenDeleted`方法时，都会创建一个新的完成源，启动文件监视器，并将负责通知的`Task`返回给客户端。
- en: 'From the consumer perspective, this solution is awesome because it removes
    any complexity:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 从消费者的角度来看，这个解决方案很棒，因为它消除了任何复杂性：
- en: '[PRE57]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The downside of this solution is that only a single deletion can be detected
    at one time.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案的缺点是一次只能检测到一个删除。
- en: Also, since the code inside the `Deleted` event turns off the notifications,
    calling the `WhenDeleted` method inside a loop could cause missing deletions.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于`Deleted`事件中的代码关闭了通知，循环内调用`WhenDeleted`方法可能会导致删除事件丢失。
- en: But we can fix that problem! The slightly more complex solution is to buffer
    the events in a thread-safe queue and change the `WhenDeleted` method strategy
    by dequeuing the available event, if any.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以解决这个问题！稍微复杂一点的解决方案是将事件缓冲在一个线程安全的队列中，并通过出队可用事件的方式改变`WhenDeleted`方法的策略，如果有的话。
- en: 'The following is the revised code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是修改后的代码：
- en: '[PRE58]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Once again, we could solve the problem with just the Task Library tools. Depending
    on the use case, this strategy requires recreating a new `TaskCompletionSource<T>`
    every time and since it is a reference type, it may affect the performance being
    subject to garbage collection. Should we need to reuse the same notification object,
    we can do so by creating a custom notification object.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，我们可以仅使用任务库工具来解决问题。根据用例，这种策略需要每次重新创建一个新的`TaskCompletionSource<T>`，并且由于它是一个引用类型，可能会影响性能，受到垃圾回收的影响。如果我们需要重用相同的通知对象，我们可以通过创建一个自定义通知对象来实现。
- en: In fact, the `await` keyword just needs an object implementing a method called
    `GetAwaiter`, returning an object that implements the `INotifyCompletion` interface.
    This object, in turn, must implement an `IsCompleted` property and all the required
    machinery miming the `TaskCompletionSource` behavior.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`await`关键字只需要一个实现了名为`GetAwaiter`的方法的对象，返回一个实现了`INotifyCompletion`接口的对象。这个对象又必须实现一个`IsCompleted`属性和模拟`TaskCompletionSource`行为的所有必需机制。
- en: In the *Further reading* section, you will find an interesting article called
    *await anything* from the Microsoft official blog that deep dives into this topic.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在*进一步阅读*部分，你会发现一篇有趣的文章，名为*await anything*，来自微软官方博客，深入探讨了这个主题。
- en: Synchronization context
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步上下文
- en: Depending on the application we are writing, not all threads are created equal.
    Desktop applications have a main thread that is the only one allowed to draw on
    screen and deal with graphics controls. The GUI libraries work around the concept
    of a queue of messages where every request is posted. The main thread is responsible
    for dequeueing those messages and dispatching them into the user-defined handlers
    that implement the desired behavior.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们正在编写的应用程序，不是所有的线程都是平等的。桌面应用程序有一个主线程，只允许在屏幕上绘制和处理图形控件。GUI库围绕着消息队列的概念工作，每个请求都被发布。主线程负责出队这些消息，并将它们分派到实现所需行为的用户定义处理程序中。
- en: Every time something happens on a thread different than the UI one, a marshaling
    operation must occur, which will cause a message to be posted in the queue managed
    by the main thread. Two popular examples of marshalling messages in the UI thread
    are `Control.Invoke` in the context of Windows Forms applications and `Dispatcher.Invoke`
    for Window Presentation Foundation.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在UI线程之外的线程上发生某些事件时，必须进行编组操作，这将导致消息被发布到主线程管理的队列中。在UI线程中编组消息的两个常见示例是Windows
    Forms应用程序中的`Control.Invoke`和Windows Presentation Foundation中的`Dispatcher.Invoke`。
- en: Information box
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: The very first prerelease version of WPF was multithreaded. But the code complexity
    required users to deal with multithreading, and the consequent possible bugs in
    the user's code were raising the bar too much. Even many C++ libraries, like DirectX
    and OpenGL, are mostly single-threaded to cut down the complexity.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: WPF的第一个预发布版本是多线程的。但是，代码复杂性要求用户处理多线程，并且用户代码中可能出现的bug提高了门槛。甚至许多C++库，如DirectX和OpenGL，大多数都是单线程的，以减少复杂性。
- en: On the server side, ASP.NET applications also have the context of the main thread,
    but there isn't just one—in fact, each user's request has its own main thread.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，ASP.NET应用程序也有主线程的上下文，但实际上不只有一个——事实上，每个用户的请求都有自己的主线程。
- en: '`SynchronizationContext` is the base class for an abstraction that defines
    a standard way to provide the execution of some code in the context of the *special*
    thread. This is no magic; in fact, the code that is being executed is defined
    in a lambda and posted in a queue. On the main thread, some code provided by the
    infrastructure dequeues the lambda and executes it in its context.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`SynchronizationContext`是一个抽象的基类，定义了一种在*特殊*线程上执行一些代码的标准方式。这并不是魔术；事实上，正在执行的代码是在一个lambda中定义的，并且被发布到一个队列中。在主线程上，基础设施提供的一些代码会出队lambda，并在其上下文中执行它。'
- en: This automatic marshaling is fundamental because, after executing any asynchronous
    method, such as downloading an image from the internet, you want to avoid calling
    the `Invoke` method needed to marshal the result back into the main thread, which
    is required in order to update the user interface with the returned data.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动编组是基本的，因为在执行任何异步方法之后，比如从互联网下载图像，你希望避免调用`Invoke`方法，该方法需要将结果编组回主线程，这是为了使用返回的数据更新用户界面所必需的。
- en: Every time you await some asynchronous operation, the generated code takes care
    to *capture* the current `SynchronizationContext` and make sure that the continuation
    is executed on that specific thread. Basically, you don't need to do anything
    because the infrastructure already does it for you.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你等待某个异步操作时，生成的代码会负责*捕获*当前的`SynchronizationContext`，并确保继续在特定线程上执行。基本上，你不需要做任何事情，因为基础设施已经为你做了。
- en: 'Are we done? Not really, because there are times where this does not happen.
    From what we said, the three IDs in the following example should all be the same:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了吗？实际上并没有，因为有时情况并非如此。根据我们所说，以下示例中的三个ID应该都是相同的：
- en: '[PRE59]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is not the case because it is a console application that doesn't set, by
    default, any synchronization context. The reason for this is in the Microsoft
    documentation for the `Console` class. You will see the *Thread Safety* section,
    at the end of the documentation page, stating *This type is thread safe*. In other
    words, there is no reason to go back to the original thread.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是因为它是一个默认情况下不设置任何同步上下文的控制台应用程序。这是因为在Microsoft的`Console`类的文档中有原因。您会在文档页面的末尾看到*线程安全*部分，其中指出*此类型是线程安全的*。换句话说，没有理由返回到原始线程。
- en: If you instead create a new Windows Forms application and call that code in
    a button-click handler, you will see that the ID is always the same, thanks to
    `SynchronizationContext`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建一个新的Windows Forms应用程序，并在按钮单击处理程序中调用该代码，您会发现ID始终相同，这要归功于`SynchronizationContext`。
- en: It is always important to understand what happens, in terms of threading, to
    your asynchronous code because there are times where marshalling the result back
    to the main one is not desirable because marshalling has a performance impact.
    For example, library developers must be very careful when writing asynchronous
    code because they can't know if their code will be executed in the presence or
    absence of a synchronization context.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 始终重要的是要了解异步代码在线程方面发生了什么，因为有时将结果返回到主线程不是理想的，因为返回有性能影响。例如，库开发人员在编写异步代码时必须非常小心，因为他们无法知道他们的代码是否会在有同步上下文或没有同步上下文的情况下执行。
- en: 'A clear example is when the library developer is processing chunks of data
    coming from the network. Every chunk is retrieved by means of an asynchronous
    HTTP request and the number of chunks can be very high, as in the following example:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的例子是库开发人员正在处理来自网络的数据块。每个块都是通过异步HTTP请求检索的，块的数量可能非常多，就像以下示例中一样：
- en: '[PRE60]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Unless the processing code is going to interact with the UI (or anything related
    to the main thread), disabling the synchronization context is definitely a performance
    gain and very easy to do:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 除非处理代码将与UI（或与主线程相关的任何内容）交互，禁用同步上下文绝对是性能的提升，并且非常容易实现：
- en: '[PRE61]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: By applying the `ConfigureAwait` method to the asynchronous method, the result
    of the operation will not be posted back to the main thread, and the generated
    continuation will be executed on the secondary thread (whenever the asynchronous
    operation is scheduled on a different thread).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`ConfigureAwait`方法应用于异步方法，操作的结果将不会发布回主线程，并且生成的继续将在辅助线程上执行（无论异步操作是否计划在不同的线程上）。
- en: 'This modified behavior has two consequences:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这种修改后的行为有两个后果：
- en: Posting the message in the main thread queue has a *performance impact*. For
    example, library developers may want to set `ConfigureAwait` to `false` when doing
    some internal work to improve the performance.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消息发布到主线程队列会产生*性能影响*。例如，库开发人员可能希望在进行一些内部工作时将`ConfigureAwait`设置为`false`以提高性能。
- en: Whenever you should decide to execute an asynchronous method synchronously using
    the `Wait` method or the `Result` property, you may incur a *deadlock*. This can
    happen because the synchronization context posts back the execution to the main
    thread, which is busy. While this situation should be avoided by never using `Wait`
    and `Result`, an alternative approach is to make the call finish its execution
    on the secondary thread by setting `ConfigureAwait` to `false`.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当您决定使用`Wait`方法或`Result`属性同步执行异步方法时，您可能会遇到*死锁*。这可能是因为同步上下文将执行返回到繁忙的主线程。虽然应该通过永远不使用`Wait`和`Result`来避免这种情况，但另一种方法是通过将`ConfigureAwait`设置为`false`，使调用在辅助线程上完成执行。
- en: Please note that if you really want to continue the execution on the secondary
    thread, ensure that you apply `ConfigureAwait` to all the following calls. In
    fact, the first asynchronous call executed without `ConfigureAwait` will cause
    the execution to return to the main thread.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您真的希望在辅助线程上继续执行，确保对所有后续调用应用`ConfigureAwait`。事实上，第一个异步调用在没有使用`ConfigureAwait`的情况下执行将导致执行返回到主线程。
- en: Since the code following `ConfigureAwait` is executed on a secondary thread,
    remember to manually marshal back to the main thread to avoid race conditions.
    For example, to update the UI, you must call the relevant *Windows Forms* or *WPF*
    `Invoke` method.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ConfigureAwait`后面的代码在辅助线程上执行，记得手动返回到主线程，以避免竞争条件。例如，要更新UI，您必须调用相关的*Windows
    Forms*或*WPF* `Invoke`方法。
- en: The task paradigm is a revolution in programming languages that could not exist
    without the help of the new language keyword and the compiler generation magic.
    This new feature had a great resonance in other languages as well. For example,
    ECMAScript 2017 adopted these concepts by providing both promises and async/await
    keyword support.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 任务范式是编程语言中的一场革命，如果没有新语言关键字和编译器生成的魔法，它是无法存在的。这一新特性在其他语言中也引起了很大的共鸣。例如，ECMAScript
    2017通过提供承诺和async/await关键字支持来采纳了这些概念。
- en: Throughout this long chapter, we learned the importance of asynchronous programming
    and how the Task Library makes asynchronous code intuitive and easy to write,
    while still not forcing us to bother too much about the implicit complexity. Beyond
    acquiring a general understanding of these tools, it is now important to experiment
    and dig into each aspect to master those techniques.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一漫长的章节中，我们学到了异步编程的重要性，以及任务库如何使异步代码直观且易于编写，同时又不会让我们过多地去关注隐含的复杂性。除了获得对这些工具的一般理解之外，现在重要的是要进行实验并深入研究每个方面，以掌握这些技术。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the most important tools that any developer can
    use to take advantage of the multithreading and asynchronous programming techniques.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了任何开发人员都可以利用的最重要的工具，以利用多线程和异步编程技术。
- en: The building blocks are the fundamental abstractions that allow code to run
    in a different execution context, regardless of the OS they are currently running
    on. Those primitives must be used with wisdom, but that doesn't limit the developer's
    possibilities in any way compared to native languages and libraries.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 构建块是基本的抽象，允许代码在不同的执行上下文中运行，而不管它们当前运行在哪个操作系统上。这些原语必须以智慧使用，但与本地语言和库相比，这并不以任何方式限制开发人员的可能性。
- en: In addition to this, the task paradigm offers a natural approach when it comes
    to interacting with all those events whose nature is asynchronous. The `System.Threading.Tasks`
    namespace provides all the required abstractions to interact with asynchronous
    phenomena.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，当涉及到与那些本质是异步的事件交互时，任务范式提供了一种自然的方法。`System.Threading.Tasks`命名空间提供了与异步现象交互所需的所有抽象。
- en: The library has been widely restructured and widened to support the task paradigm.
    And most importantly, the language offers the `async` and `await` keywords to
    break down the complexity and make the asynchronous world flow as if it was procedural
    code.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 该库已经被广泛重组和扩展以支持任务范式。最重要的是，该语言提供了`async`和`await`关键字来分解复杂性，并使异步世界流畅地进行，就像是过程性代码一样。
- en: In the next chapter, we will learn about the concepts of files, file streams,
    and serialization.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习文件、文件流和序列化的概念。
- en: Test what you learned
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你所学到的东西
- en: If you have a very CPU-intensive, long-lasting algorithm to run, which strategy
    out of manual thread creation, using the task library, or using the thread pool
    would you adopt?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有一个非常消耗CPU、持续时间很长的算法要运行，你会采用手动创建线程、使用任务库还是使用线程池中的哪种策略？
- en: Name a performant synchronization technique that can be used to write a file
    and increase an integer value in memory.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名一个可以用来写文件并增加内存中整数值的高效同步技术。
- en: What method should you use to pause the execution for 100 milliseconds, and
    why?
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该使用什么方法来暂停执行100毫秒，为什么？
- en: What should you do to wait for the results produced by multiple asynchronous
    operations?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该怎么做来等待多个异步操作产生的结果？
- en: How can you create a task to await a CLR event?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何创建一个等待CLR事件的任务？
- en: What should you return from a method that has `Task` in the signature but does
    not use any asynchronous method?
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个方法的签名中有`Task`但没有使用任何异步方法时，你应该返回什么？
- en: How can you create a long-running task?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何创建一个长时间运行的任务？
- en: A button-click handler is making asynchronous access to the internet to load
    some data. Should you use `Control.Invoke` to update the results on screen? Why?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个按钮点击处理程序正在异步访问互联网以加载一些数据。你应该使用`Control.Invoke`来更新屏幕上的结果吗？为什么？
- en: What are the reasons for evaluating the use of the `ConfigureAwait` method on
    a `Task`?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个`Task`上评估使用`ConfigureAwait`方法的原因是什么？
- en: Can you update the UI directly after having used `ConfigureAwait(false)`?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用了`ConfigureAwait(false)`之后，你能直接更新UI吗？
- en: Further reading
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: A very powerful library that can be used to measure the performance of some
    code is Benchmark.NET ([https://benchmarkdotnet.org/articles/overview.html](https://benchmarkdotnet.org/articles/overview.html)),
    which is also used internally by Microsoft to make optimizations on the runtime
    and the core libraries.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个非常强大的库，可以用来测量一些代码的性能是Benchmark.NET ([https://benchmarkdotnet.org/articles/overview.html](https://benchmarkdotnet.org/articles/overview.html))，这也被微软内部用来对运行时和核心库进行优化。
- en: 'If you want to build your own *awaitable* object, you cannot miss this article
    from the Microsoft team, describing how the underlying infrastructure works: [https://devblogs.microsoft.com/pfxteam/await-anything/](https://devblogs.microsoft.com/pfxteam/await-anything/).'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想构建自己的*awaitable*对象，你不能错过微软团队的这篇文章，描述了基础架构的工作原理：[https://devblogs.microsoft.com/pfxteam/await-anything/](https://devblogs.microsoft.com/pfxteam/await-anything/)。
- en: 'To dig into more details about the synchronization context and `ConfigureAwait`,
    you can read the following article: [https://devblogs.microsoft.com/dotnet/configureawait-faq/](https://devblogs.microsoft.com/dotnet/configureawait-faq/).'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要深入了解同步上下文和`ConfigureAwait`，你可以阅读以下文章：[https://devblogs.microsoft.com/dotnet/configureawait-faq/](https://devblogs.microsoft.com/dotnet/configureawait-faq/)。
