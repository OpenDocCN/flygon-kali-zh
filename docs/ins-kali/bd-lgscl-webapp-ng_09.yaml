- en: Create a Local Weather Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个本地天气Web应用程序
- en: We will be designing and building a simple Local Weather app with Angular and
    a third-party web API, using an iterative development methodology. You will focus
    on delivering value first while learning about the nuances and optimal ways of
    using Angular, TypeScript, Visual Studio Code, Reactive Programming, and RxJS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用迭代开发方法设计和构建一个简单的本地天气应用程序，使用Angular和第三方Web API。您将首先专注于交付价值，同时学习使用Angular、TypeScript、Visual
    Studio Code、响应式编程和RxJS的微妙之处和最佳方式。
- en: 'In this chapter, you will learn the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: Planning out your roadmap using Waffle as a GitHub-connected Kanban board
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Waffle作为与GitHub连接的看板板来规划您的路线图
- en: Crafting a new UI element to display current weather information using components
    and interfaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件和接口制作新的UI元素来显示当前天气信息
- en: Using Angular Services and HttpClient to retrieve data from OpenWeatherMap APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular服务和HttpClient从OpenWeatherMap API检索数据
- en: Leveraging observable streams to transform data using RxJS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用可观察流使用RxJS转换数据
- en: 'The code samples provided in this book require Angular version 5 and 6\. Angular
    5 code is runtime compatible with Angular 6\. Angular 6 will be supported in LTS
    until October 2019\. The most up-to-date versions of the code repositories may
    be found at the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的代码示例需要Angular版本5和6。 Angular 5代码与Angular 6兼容。 Angular 6将在2019年10月之前得到长期支持。可以在以下位置找到代码存储库的最新版本：
- en: LocalCast Weather, at: [Github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LocalCast Weather，网址：[Github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
- en: LemonMart, at: [Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LemonMart，网址：[Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
- en: Planning a feature road map using Waffle
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Waffle规划功能路线图
- en: Building a rough plan of action before you start coding is very important so
    that you and your colleagues or clients are aware of the road map you're planning
    to execute. Whether you're building an app for yourself or for someone else, a
    living backlog of features will always serve as a great reminder when you get
    back to a project after a break or serve as an information radiator that prevents
    constant requests for status updates.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前制定一个大致的行动计划非常重要，这样您和您的同事或客户就会意识到您计划执行的路线图。无论您是为自己还是为他人构建应用程序，功能的活动积压始终会在您休息后回到项目时作为一个很好的提醒，或者作为一个信息辐射器，防止不断请求状态更新。
- en: In Agile development, you may have used various ticketing systems or tools that
    surface or Kanban boards. My favorite tool is Waffle.io, [https://waffle.io/](https://waffle.io/),
    because it directly integrates with your GitHub repository's issues and keeps
    track of the status of issues via labels. This way, you can keep using the tool
    of your choice to interact with your repository and still, effortlessly, radiate
    information. In the next section, you will set up a Waffle project to achieve
    this goal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷开发中，您可能已经使用了各种支持或看板板的票务系统或工具。我的最爱工具是Waffle.io，[https://waffle.io/](https://waffle.io/)，因为它直接与您的GitHub存储库的问题集成，并通过标签跟踪问题的状态。这样，您可以继续使用您选择的工具与存储库进行交互，并且轻松地传达信息。在下一节中，您将设置一个Waffle项目以实现这个目标。
- en: Setting up a Waffle project
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置一个Waffle项目
- en: 'We will now set up our Waffle project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将设置我们的Waffle项目：
- en: Go to Waffle.io [https://waffle.io/](https://waffle.io/).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Waffle.io [https://waffle.io/](https://waffle.io/)。
- en: Click on Login or Get Started for Free.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击登录或免费开始。
- en: Select Public & Private Repos to allow access to all of your repositories.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择公共和私有存储库以允许访问您的所有存储库。
- en: Click on Create Project.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击创建项目。
- en: Search for the local-weather-app repository and select it.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索local-weather-app存储库并选择它。
- en: Hit Continue.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击继续。
- en: 'You will get two starter layout templates, as shown in the following image:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得两个起始布局模板，如下图所示：
- en: '![](Images/81040eee-bfed-4822-8449-2037e1cbe44e.png)Waffle.io Default Board
    Layouts'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/81040eee-bfed-4822-8449-2037e1cbe44e.png)Waffle.io默认板布局'
- en: For this simple project, you will be selecting Basic. However, the Advanced
    layout demonstrates how you can modify the default setup of Waffle, by adding
    additional columns such as Review, to account for testers or product owners participating
    in the process. You can further customize any board to fit your existing process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的项目，您将选择Basic。但是，高级布局演示了您如何修改Waffle的默认设置，例如添加额外的列，如Review，以解决参与过程的测试人员或产品所有者。您可以进一步自定义任何板以适应您现有的流程。
- en: Select the Basic layout and click on Create Project.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择基本布局，然后单击创建项目。
- en: You will see a new board created for you.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到为您创建的新板。
- en: '![](Images/ae7f8ef6-e282-4468-a474-71e05feab25b.png)Empty Waffle Board'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/ae7f8ef6-e282-4468-a474-71e05feab25b.png)空的Waffle板'
- en: By default, Waffle will serve as a Kanban board. Allowing you to move a task
    from one state to another. However, the default view will show all the issues
    that are present on the repository. To use Waffle as a Scrum board, you need to
    assign issues to GitHub milestones that will represent sprints. You can then use
    the filtering functionality to only display issues from that milestone, or put
    another way from the current sprint.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Waffle将作为看板板。允许您将任务从一个状态移动到另一个状态。但是，默认视图将显示存储库上存在的所有问题。要将Waffle用作Scrum板，您需要将问题分配给代表冲刺的GitHub里程碑。然后，您可以使用过滤功能仅显示来自该里程碑的问题，或者换句话说，来自当前冲刺的问题。
- en: On Waffle, you can attach story points to issues by clicking on the ![](Images/98c10b6b-b94d-4cca-b7aa-8992281c2ce6.jpg) scale
    icon. The columns will automatically show totals and card orders, which represent
    priority, and they will be retained from session to session. Furthermore, you
    can switch to the Metrics view to get Milestone Burndown and Throughput graphs
    and statistics.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Waffle上，您可以通过单击![](Images/98c10b6b-b94d-4cca-b7aa-8992281c2ce6.jpg)比例图标将故事点附加到问题上。列将自动显示总数和卡片顺序，代表优先级，并且将在会话之间保留。此外，您可以切换到指标视图以获取里程碑燃尽和吞吐量图表和统计信息。
- en: Creating issues for your Local Weather app
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的本地天气应用创建问题
- en: We will now create a backlog of issues that you will use to keep track of your
    progress as you implement the design of your application. When creating issues,
    you should focus on delivering functional iterations that bring some value to
    the user. The technical hurdles you must clear to achieve those results are of
    no interest to your users or clients.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个问题的积压，您将使用它来跟踪您实施应用程序设计的进度。创建问题时，您应专注于交付为用户带来一些价值的功能迭代。您必须克服的技术障碍对您的用户或客户没有兴趣。
- en: 'Here are the features we plan to be building in our first release:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们计划在第一个发布版本中构建的功能：
- en: Display Current Location weather information for the current day
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示当前位置的当天天气信息
- en: Display forecast information for current location
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示当前位置的预测信息
- en: Add city search capability so that users can see weather information from other
    cities
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加城市搜索功能，以便用户可以查看其他城市的天气信息
- en: Add a preferences pane to store the default city for the user
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加首选项窗格以存储用户的默认城市
- en: Improve the UX of the app with Angular Material
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular Material改进应用程序的UX
- en: 'Go ahead with creating your issues on Waffle or on GitHub; whichever you prefer
    is fine. While creating the scope for Sprint 1, I had some other ideas for features,
    so I just added those issues, but I did not assign them to a person or a milestone.
    I also went ahead and added story points to the issues I intended to work on.
    The following is what the board looks like, as I''m to begin working on the first
    story:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Waffle或GitHub上创建你的问题吧；无论你喜欢哪个都可以。在创建Sprint 1的范围时，我对功能有一些其他想法，所以我只是添加了这些问题，但我没有把它们分配给任何人或里程碑。我还继续为我打算处理的问题添加了故事点。以下是看板的样子，因为我要开始处理第一个故事了：
- en: '![](Images/c0baf628-599c-43ba-92f0-fb70250dff89.png)A snapshot of the initial
    state of the board at [https://waffle.io/duluca/local-weather-app](https://waffle.io/duluca/local-weather-app)Ultimately,
    Waffle provides an easy-to-use GUI so that non-technical people can easily interact
    with GitHub issues. By allowing non-technical people to participate in the development
    process on GitHub, you unlock the benefit of GitHub becoming the single source
    of information for your entire project. Questions, answers, and discussions around
    features and issues are all tracked as part of GitHub issues, instead of being
    lost in emails. You can also store wiki type documentation on GitHub, so by centralizing
    all project-related information, data, conversations, and artifacts on GitHub,
    you are greatly simplifying a potentially complicated interaction of multiple
    systems that require continued maintenance, at a high cost. For private repositories
    and on-premise Enterprise installations, GitHub has a very reasonable cost. If
    you''re sticking with open source, as we are in this chapter, all these tools
    are free.As a bonus, I created a rudimentary wiki page on my repository at [https://github.com/duluca/local-weather-app/wiki](https://github.com/duluca/local-weather-app/wiki).
    Note that you can''t upload images to `README.md` or wiki pages. To get around
    this limitation, you can create a new issue, upload an image in a comment, and
    copy and paste the URL for it to embed images to `README.md` or wiki pages. In
    the sample wiki, I followed this technique to embed the wireframe design into
    the page.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/c0baf628-599c-43ba-92f0-fb70250dff89.png)看板初始状态的快照：[https://waffle.io/duluca/local-weather-app](https://waffle.io/duluca/local-weather-app)最终，Waffle提供了一个易于使用的GUI，以便非技术人员可以轻松地与GitHub问题进行交互。通过允许非技术人员参与GitHub上的开发过程，您可以使GitHub成为整个项目的唯一信息来源的好处。关于功能和问题的问题、答案和讨论都作为GitHub问题的一部分进行跟踪，而不是在电子邮件中丢失。您还可以在GitHub上存储维基类型的文档，因此，通过在GitHub上集中所有与项目相关的信息、数据、对话和工件，您大大简化了可能需要持续维护的多个系统之间的复杂交互，成本也很高。对于私有存储库和本地企业安装，GitHub的成本非常合理。如果您像本章中一样坚持开源，所有这些工具都是免费的。作为一个额外的奖励，我在我的存储库上创建了一个基本的维基页面：[https://github.com/duluca/local-weather-app/wiki](https://github.com/duluca/local-weather-app/wiki)。请注意，您不能将图片上传到`README.md`或维基页面。为了避免这种限制，您可以创建一个新问题，在评论中上传一张图片，并复制并粘贴其URL以将图片嵌入到`README.md`或维基页面中。在示例维基中，我遵循了这种技术将线框设计嵌入到页面中。'
- en: With a concrete road map in place, you're now ready to start implementing your
    application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有了一个具体的路线图，你现在可以开始实施你的应用程序了。
- en: Crafting UI elements using components and interfaces
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件和接口来制作UI元素
- en: You will be leveraging Angular components, interfaces, and services to build
    the current weather feature in a decoupled, cohesive, and encapsulated manner.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您将利用Angular组件、接口和服务以一种解耦、内聚和封装的方式构建当前天气功能。
- en: The landing page of an Angular app, by default, resides in `app.component.html`.
    So, start by editing the template of `AppComponent` with rudimentary HTML, laying
    out the initial landing experience for the application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Angular应用的着陆页面默认位于`app.component.html`中。因此，首先通过编辑`AppComponent`的模板，使用基本的HTML布局应用程序的初始着陆体验。
- en: We are now beginning the development of Feature 1: Display Current Location
    weather information for the current day, so, you can move the card in Waffle to
    the In Progress column.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始开发Feature 1：显示当前位置的当天天气信息，因此，您可以将卡片移动到Waffle的进行中列。
- en: 'We will add a header as an `h1` tag, followed by the tagline of our app as
    a `div` and placeholders for where we may want to display the current weather,
    as demonstrated as shown in the following code block:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个标题作为`h1`标签，然后是我们应用的标语作为`div`，以及我们可能想要显示当前天气的占位符，如下面的代码块所示：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At this point, you should run `npm start` and navigate to `http://localhost:5000` on your
    browser so that you can observe the changes you're making in real time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该运行`npm start`并在浏览器中导航到`http://localhost:5000`，以便实时观察您所做的更改。
- en: Adding an Angular component
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个Angular组件
- en: We need to display the current weather information, where `<div>current weather</div>`
    is located. In order to achieve this, you need to build a component that will
    be responsible for displaying the weather data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要显示当前天气信息，位置在`<div>current weather</div>`处。为了实现这一点，您需要构建一个负责显示天气数据的组件。
- en: 'The reason behind creating a separate component is an architectural best practice
    that is codified in the **Model-View-ViewModel** (**MVVM**) design pattern. You
    may have heard of the **Model-View-Controller** (**MVC**) pattern before. Vast
    majority of web-based code written circa 2005-2015 has been written following
    the MVC pattern. MVVM differs, in important ways, from the MVC pattern. As I have
    explained in my 2013 article on DevPro:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个单独的组件的原因是一种在**Model-View-ViewModel**（**MVVM**）设计模式中规范化的架构最佳实践。您可能之前听说过**Model-View-Controller**（**MVC**）模式。大多数在2005-2015年左右编写的基于Web的代码都是按照MVC模式编写的。MVVM与MVC模式在重要方面有所不同。正如我在2013年的DevPro文章中所解释的那样。
- en: '[An effective implementation of MVVM] inherently enforces proper separation
    of concerns. Business logic is clearly separated from presentation logic. So when
    a View is developed, it stays developed, because fixing a bug in one View''s functionality
    doesn''t impact other views. On the flip side, if [you use] visual inheritance
    effectively and [create] reusable user controls, fixing a bug in one place can
    fix issues throughout the application.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[对MVVM的有效实现]本质上强制执行关注点的正确分离。业务逻辑与呈现逻辑清晰分离。因此，当开发一个视图时，它保持开发状态，因为修复一个视图功能中的错误不会影响其他视图。另一方面，如果[您使用]视觉继承有效并[创建]可重用的用户控件，修复一个地方的错误可以修复整个应用程序中的问题。'
- en: Angular provides an effective implementation of MVVM.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了MVVM的有效实现。
- en: ViewModels neatly encapsulate any presentation logic and allow for simpler View
    code by acting as a specialized version of the model. The relationship between
    a View and ViewModel is straightforward, allowing for more natural ways to wrap
    UI behavior in reusable user controls.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型整洁地封装任何呈现逻辑，并通过充当模型的专业版本，使视图代码更简单。视图和视图模型之间的关系很直接，可以更自然地将UI行为包装在可重用的用户控件中。
- en: You can read further about the architectural nuance, with illustrations, at [http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC)上阅读有关架构细微差别的更多信息，并附有插图。
- en: 'Next, you will create your very first Angular component, which will include
    the View and the ViewModel, using Angular CLI''s `ng generate` command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将创建您的第一个Angular组件，其中将包括视图和视图模型，使用Angular CLI的`ng generate`命令：
- en: In the terminal, execute `npx ng generate component current-weather`
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，执行`npx ng generate component current-weather`
- en: Ensure that you are executing `ng` commands under the `local-weather-app` folder,
    and not under the `root` project folder. In addition, note that `npx ng generate
    component current-weather` can be rewritten as `ng g c current-weather`. Going
    forward, this book will utilize the shorthand format and expect you to prepend `npx`,
    if necessary.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在`local-weather-app`文件夹下执行`ng`命令，而不是在`root`项目文件夹下执行。此外，请注意，`npx ng generate
    component current-weather`可以重写为`ng g c current-weather`。今后，本书将使用简写格式，并期望您在必要时添加`npx`。
- en: 'Observe the new files created in your `app` folder:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察您的`app`文件夹中创建的新文件：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A generated component has four parts:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的组件有四个部分：
- en: '`current-weather.component.css` contains any CSS that is specific to the component
    and is an optional file'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.css`包含特定于组件的任何CSS，并且是一个可选文件'
- en: '`current-weather.component.html` contains the HTML template that defines the
    look of the component and rendering of the bindings, and can be considered the
    View, in combination with any CSS styles used'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.html`包含定义组件外观和绑定渲染的HTML模板，并且可以与使用的任何CSS样式一起被视为视图'
- en: '`current-weather.component.spec.ts` contains Jasmine-based unit tests that
    you can extend to test your component functionality'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.spec.ts` 包含基于Jasmine的单元测试，您可以扩展以测试组件功能'
- en: '`current-weather.component.ts` contains the `@Component` decorator above the class
    definition and is the glue that ties together the CSS, HTML, and JavaScript code
    together. The class itself can be considered the ViewModel, pulling data from
    services and performing any necessary transformations to expose sensible bindings
    for the View, as shown as follows:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current-weather.component.ts`包含在类定义之上的`@Component`装饰器，并且是将CSS、HTML和JavaScript代码粘合在一起的粘合剂。类本身可以被视为ViewModel，从服务中提取数据并执行任何必要的转换以公开视图的合理绑定，如下所示：'
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the component you're planning to write is a simple one, you can rewrite it
    using inline styles and an inline template, to simplify the structure of your
    code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划编写的组件很简单，您可以使用内联样式和内联模板重写它，以简化代码结构。
- en: 'Update `CurrentWeatherComponent` with an inline template and styles:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内联模板和样式更新`CurrentWeatherComponent`：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When you executed the generate command, in addition to creating the component,
    the command also added the new module you created to `app.module.ts`, avoiding
    an otherwise tedious task of wiring up components together:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行生成命令时，除了创建组件外，该命令还将您创建的新模块添加到`app.module.ts`中，避免了繁琐的组件连接任务：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The bootstrap process of Angular is, admittedly, a bit convoluted. This is the
    chief reason Angular CLI exists. `index.html` contains an element named `<app-root>`.
    When Angular begins execution, it first loads `main.ts`, which configures the
    framework for browser use and loads the app module. App module then loads all
    its dependencies and renders within the aforementioned `<app-root>` element. In
    [Chapter 12](b49e4716-d083-4c8c-a083-bcf6cf182a6f.xhtml), *Create a Router-First
    Line-of-Business App*, when we build a line-of-business app, we will create our
    own feature modules to take advantage of the scalability features of Angular.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的引导过程，诚然有点复杂。这是Angular CLI存在的主要原因。`index.html`包含一个名为`<app-root>`的元素。当Angular开始执行时，它首先加载`main.ts`，该文件配置了用于浏览器的框架并加载了应用程序模块。应用程序模块然后加载所有其依赖项并在前述的`<app-root>`元素内呈现。在[第12章](b49e4716-d083-4c8c-a083-bcf6cf182a6f.xhtml)，*创建一个路由优先的业务应用程序*中，当我们构建业务应用程序时，我们将创建自己的功能模块，以利用Angular的可扩展性功能。
- en: 'Now, we need to display our new component on the initial `AppComponent` template,
    so it is visible to the end user:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在初始的`AppComponent`模板上显示我们的新组件，以便最终用户可以看到：
- en: 'Add the `CurrentWeatherComponent` to `AppComponent` by replacing `<div>current
    weather</div>` with `<app-current-weather></app-current-weather>`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CurrentWeatherComponent`添加到`AppComponent`中，用`<app-current-weather></app-current-weather>`替换`<div>current
    weather</div>`：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If everything worked correctly, you should see this:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切工作正常，您应该看到这个：
- en: '![](Images/73cfd796-6a00-4c6a-b790-4a736c7fa508.png)Initial render of your
    local weather appNote the icon and name in the tab of the browser window. As a
    web development norm, in the `index.html` file, update the `<title>` tag and the
    `favicon.ico` file with the name and icon of your application to customize the
    browser tab information. If your favicon doesn''t update, append the `href` attribute
    with a unique version number, such as `href="favicon.ico?v=2"`. As a result, your
    app will start looking like a real web app, instead of a CLI-generated starter
    project.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/73cfd796-6a00-4c6a-b790-4a736c7fa508.png)本地天气应用的初始渲染请注意浏览器窗口标签中的图标和名称。作为Web开发规范，在`index.html`文件中，使用应用程序的名称和图标更新`<title>`标签和`favicon.ico`文件，以自定义浏览器标签信息。如果您的favicon没有更新，请在`href`属性后附加一个唯一的版本号，例如`href="favicon.ico?v=2"`。结果，您的应用程序将开始看起来像一个真正的Web应用程序，而不是一个由CLI生成的起始项目。'
- en: Define your model using interfaces
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用接口定义您的模型
- en: 'Now that your `View` and `ViewModel` are in place, you need to define your
    `Model`. If you look back on the design, you will see that the component needs
    to display:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的`View`和`ViewModel`已经就位，您需要定义您的`Model`。如果您回顾设计，您会发现组件需要显示：
- en: City
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 城市
- en: Country
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国家
- en: Current date
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前日期
- en: Current image
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前图像
- en: Current temperature
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前温度
- en: Current weather description
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前天气描述
- en: 'You will first create an interface that represents this data structure:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先创建一个表示此数据结构的接口：
- en: In the terminal, execute `npx ng generate interface ICurrentWeather`
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，执行`npx ng generate interface ICurrentWeather`
- en: 'Observe a newly generated file named `icurrent-weather.ts` with an empty interface
    definition that looks like this:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察一个新生成的名为`icurrent-weather.ts`的文件，其中包含一个空的接口定义，看起来像这样：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is not an ideal setup, since we may add numerous interfaces to our app
    and it can get tedious to track down various interfaces. Over time, as you add
    concrete implementations of these interfaces as classes, then it will make sense
    to put classes and their interfaces in their own files.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个理想的设置，因为我们可能会向我们的应用程序添加许多接口，跟踪各种接口可能会变得乏味。随着时间的推移，当您将这些接口的具体实现作为类添加时，将把类和它们的接口放在自己的文件中是有意义的。
- en: Why not just call the interface `CurrentWeather`? This is because later on we
    may create a class to implement some interesting behavior for `CurrentWeather`.
    Interfaces establish a contract, establishing the list of available properties
    on any class or interface that implements or extends the interface. It is always
    important to be aware of when you're using a class versus an interface. If you
    follow the best practice to always start your interface names with a capital `I`,
    you will always be conscious of what type of an object you are passing around.
    Hence, the interface is named `ICurrentWeather`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接将接口命名为`CurrentWeather`？这是因为以后我们可能会创建一个类来实现`CurrentWeather`的一些有趣的行为。接口建立了一个合同，确定了任何实现或扩展接口的类或接口上可用属性的列表。始终要意识到何时使用类与接口是非常重要的。如果您遵循始终以大写`I`开头的接口名称的最佳实践，您将始终意识到您正在传递的对象的类型。因此，接口被命名为`ICurrentWeather`。
- en: Rename `icurrent-weather.ts` to `interfaces.ts`
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`icurrent-weather.ts`重命名为`interfaces.ts`
- en: Correct the capitalization of the interface name to `ICurrentWeather`
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将接口名称的大写改正为`ICurrentWeather`
- en: 'Also, implement the interface as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，按照以下方式实现接口：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This interface and its eventual concrete representation as a class is the Model
    in MVVM. So far, I have highlighted how various parts of Angular fit the MVVM
    pattern; going forward, I will be referring to these parts with their actual names.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口及其最终的具体表示作为一个类是MVVM中的模型。到目前为止，我已经强调了Angular的各个部分如何符合MVVM模式；未来，我将使用它们的实际名称来提到这些部分。
- en: Now, we can import the interface into the component and start wiring up the
    bindings in the template of `CurrentWeatherComponent`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将接口导入组件，并开始在`CurrentWeatherComponent`的模板中开始连接绑定。
- en: Import `ICurrentWeather`
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`ICurrentWeather`
- en: Switch back to the `templateUrl` and ``styleUrls``
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回`templateUrl`和`styleUrls`
- en: Define a local variable called `current` with type `ICurrentWeather`
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`current`的本地变量，类型为`ICurrentWeather`
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you just type `current: ICurrentWeather`, you can use the auto-fixer to
    automatically insert the import statement.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您只输入`current: ICurrentWeather`，您可以使用自动修复程序自动插入导入语句。'
- en: In the constructor, you will temporarily populate the current property with
    dummy data to test your bindings.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，您将临时使用虚拟数据填充当前属性以测试您的绑定。
- en: 'Implement dummy data as a JSON object and declare its adherence to `ICurrentWeather`
    using the as operator:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将虚拟数据实现为一个JSON对象，并使用`as`运算符声明其遵循`ICurrentWeather`：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `src/assets` folder, create a subfolder named `img` and place an image
    of your choice to reference in your dummy data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/assets`文件夹中，创建一个名为`img`的子文件夹，并放置一个您选择的图像以在虚拟数据中引用。
- en: 'You may forget the exact properties in the interface you created. You can get
    a quick peek at them by holding *Ctrl* + hover-over the interface name with your
    mouse, as shown:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会忘记您创建的接口中的确切属性。您可以通过将鼠标悬停在接口名称上并按住*Ctrl*来快速查看它们，如下所示：
- en: '![](Images/e15b7ab5-9e57-4aff-a18d-c38830c6e75a.png)*Ctrl* + hover-over the
    interface'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/e15b7ab5-9e57-4aff-a18d-c38830c6e75a.png)*Ctrl* + 悬停在接口上'
- en: Now you update the template to wire up your bindings with a rudimentary HTML-based
    layout.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以更新模板，将绑定与基本的基于HTML的布局连接起来。
- en: 'Implement the template:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现模板：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To change the display formatting of `current.date`, we used the `DatePipe` above,
    passing in `'fullDate'` as the format option. In Angular, various out-of-the-box
    and custom pipe `|` operators can be used to change the appearance of data without
    actually changing the underlying data. This is a very powerful, convenient, and
    flexible system to share such user interface logic without writing repetitive
    boilerplate code. In the preceding example, we could pass in `'shortDate'` if
    we wanted to represent the current date in a more compact form. For more information
    on various `DatePipe` options, refer to the documentation at [https://angular.io/api/common/DatePipe](https://angular.io/api/common/DatePipe). To
    format `current.temperature` so that no fractional values are shown, you can use
    `DecimalPipe`. The documentation is at [https://angular.io/api/common/DecimalPipe](https://angular.io/api/common/DecimalPipe).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改变`current.date`的显示格式，我们在上面使用了`DatePipe`，传入`'fullDate'`作为格式选项。在Angular中，可以使用各种内置和自定义管道`|`操作符来改变数据的外观，而不实际改变基础数据。这是一个非常强大、方便和灵活的系统，可以在不编写重复样板代码的情况下共享用户界面逻辑。在上面的例子中，如果我们想要以更紧凑的形式表示当前日期，我们可以传入`'shortDate'`。有关各种`DatePipe`选项的更多信息，请参阅[https://angular.io/api/common/DatePipe](https://angular.io/api/common/DatePipe)上的文档。要格式化`current.temperature`，以便不显示小数值，可以使用`DecimalPipe`。文档在[https://angular.io/api/common/DecimalPipe](https://angular.io/api/common/DecimalPipe)。
- en: Note that you can render ℃ and ℉ using their respective HTML codes: ![](Images/b5a76f73-bb93-4f1a-a344-5f20edef7312.png) for
    ℃ and ![](Images/a4b2101d-64f9-4302-a885-efa078718e12.png) for ℉.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以使用它们各自的HTML代码来呈现℃和℉： ![](Images/b5a76f73-bb93-4f1a-a344-5f20edef7312.png) 表示℃， ![](Images/a4b2101d-64f9-4302-a885-efa078718e12.png) 表示℉。
- en: 'If everything worked correctly, you app should be looking similar to this screenshot:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切工作正常，您的应用程序应该看起来类似于这个屏幕截图：
- en: '![](Images/b0c66fef-99c4-4b07-b2e6-0040f481527b.png)App after wiring up bindings
    with dummy data'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/b0c66fef-99c4-4b07-b2e6-0040f481527b.png)连接绑定和虚拟数据后的应用程序'
- en: Congratulations, you have successfully wired up your first component.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已成功连接了您的第一个组件。
- en: Using Angular Services and HttpClient to retrieve data
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular服务和HttpClient来检索数据
- en: 'Now you need to connect your `CurrentWeather` component to the `OpenWeatherMap`
    APIs. In the upcoming sections, we will go over the following steps to accomplish
    this goal:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要将您的`CurrentWeather`组件连接到`OpenWeatherMap` API。在接下来的部分中，我们将介绍以下步骤来实现这个目标：
- en: Create a new Angular Service
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Angular服务
- en: Import `HttpClientModule` and inject it into the service
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`HttpClientModule`并将其注入到服务中
- en: Discover the `OpenWeatherMap` API
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发现`OpenWeatherMap` API
- en: Create a new interface that conforms to the shape of the API
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个符合API形状的新接口
- en: Write a `get` request
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`get`请求
- en: Inject the new service into the `CurrentWeather` component
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新服务注入到`CurrentWeather`组件中
- en: Call the service from the `init` function of the `CurrentWeather` component
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`CurrentWeather`组件的`init`函数中调用服务
- en: Finally, map the API data to the local `ICurrentWeather` type using RxJS functions
    so that it can be consumed by your component
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用RxJS函数将API数据映射到本地的`ICurrentWeather`类型，以便组件可以使用
- en: Creating a new Angular Service
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的Angular服务
- en: Any code that touches outside of the boundaries of a component should exist
    in a service; this includes inter-component communication, unless there's a parent-child
    relationship, and API calls of any kind and any code that cache or retrieve data
    from a cookie or the browser's localStorage. This is a critical architectural
    pattern that keeps your application maintainable in the long term. I expand upon
    this idea in my DevPro MVVM article at [http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 任何触及组件边界之外的代码都应存在于服务中；这包括组件间的通信，除非存在父子关系，以及任何缓存或从cookie或浏览器的localStorage中检索数据的代码。这是一个关键的架构模式，可以使您的应用程序在长期内易于维护。我在我的DevPro
    MVVM文章中扩展了这个想法，网址是[http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC)。
- en: 'To create an Angular service, do this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Angular服务，请执行以下操作：
- en: In the terminal, execute `npx ng g s weather --flat false`
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行`npx ng g s weather --flat false`
- en: 'Observe the new `weather` folder created:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察新创建的`weather`文件夹：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A generated service has two parts:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的服务有两部分：
- en: '`weather.service.spec.ts` contains Jasmine-based unit tests that you can extend
    to test your service functionality.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weather.service.spec.ts` 包含基于Jasmine的单元测试，您可以扩展以测试您的服务功能。'
- en: '`weather.service.ts` contains the `@Injectable` decorator above the class definition,
    which makes it possible to inject this service into other components, leveraging
    Angular''s provider system. This will ensure that our service will be a singleton,
    meaning only instantiated once, no matter how many times it is injected elsewhere.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weather.service.ts` 包含在类定义之上的`@Injectable` 装饰器，这使得可以将此服务注入到其他组件中，利用Angular的提供者系统。这将确保我们的服务是单例的，意味着无论它被注入到其他地方多少次，它只会被实例化一次。'
- en: 'The service is generated, but it''s not automatically provided. To do this,
    follow these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 服务已生成，但没有自动提供。要做到这一点，请按照以下步骤操作：
- en: Open `app.module.ts`
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.module.ts`
- en: Type in `WeatherService` inside the providers array
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在providers数组中键入`WeatherService`
- en: 'Use the auto-fixer to import the class for you:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自动修复程序为您导入类：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you installed the recommended extension TypeScript Hero, the import statement
    will be automatically added for you. You won't have to use the auto-fixer to do
    it. Going forward, I will not call out the need to import modules.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您安装了推荐的扩展TypeScript Hero，导入语句将自动为您添加。您不必使用自动修复程序来执行此操作。今后，我将不再提到导入模块的需要。
- en: Inject dependencies
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入依赖项
- en: 'In order to make API calls, you will be leveraging the `HttpClient` module
    in Angular. The official documentation ([https://angular.io/guide/http](https://angular.io/guide/http))
    explains the benefits of this module succinctly:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行API调用，您将利用Angular中的`HttpClient`模块。官方文档（[https://angular.io/guide/http](https://angular.io/guide/http)）简洁地解释了这个模块的好处：
- en: '"With HttpClient, @angular/common/http provides a simplified API for HTTP functionality
    for use with Angular applications, building on top of the XMLHttpRequest interface
    exposed by browsers. Additional benefits of HttpClient include testability support,
    strong typing of request and response objects, request and response interceptor
    support, and better error handling via APIs based on Observables."'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: “使用HttpClient，@angular/common/http为Angular应用程序提供了一个简化的HTTP功能API，构建在浏览器暴露的XMLHttpRequest接口之上。HttpClient的其他好处包括可测试性支持，请求和响应对象的强类型化，请求和响应拦截器支持，以及基于Observables的API的更好的错误处理。”
- en: 'Let''s start with importing the `HttpClientModule` in to our app, so we can
    inject the `HttpClient` within the module into the `WeatherService`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将`HttpClientModule`导入到我们的应用程序中开始，这样我们就可以将`HttpClient`注入到`WeatherService`中的模块中：
- en: 'Add `HttpClientModule` to `app.module.ts`, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`HttpClientModule`添加到`app.module.ts`中，如下所示：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Inject `HttpClient` provided by the `HttpClientModule` in the  `WeatherService`, as
    follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WeatherService`中注入`HttpClient`，如下所示：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, `httpClient` is ready for use in your service.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`httpClient`已经准备好在您的服务中使用。
- en: Discover OpenWeatherMap APIs
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现OpenWeatherMap APIs
- en: Since `httpClient` is strongly typed, we need to create a new interface that
    conforms to the shape of the API we'll call. To be able to do this, you need to
    familiarize yourself with the Current Weather Data API.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`httpClient`是强类型的，我们需要创建一个符合我们将要调用的API形状的新接口。为了能够做到这一点，您需要熟悉当前天气数据API。
- en: 'Read documentation by navigating to [http://openweathermap.org/current](http://openweathermap.org/current):'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到[http://openweathermap.org/current](http://openweathermap.org/current)阅读文档：
- en: '![](Images/771e0150-f856-43e5-9da5-0704544cd618.png)OpenWeatherMap Current
    Weather Data API Documentation'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/771e0150-f856-43e5-9da5-0704544cd618.png)OpenWeatherMap当前天气数据API文档'
- en: 'You will be using the API named By city name, which allows you to get current
    weather data by providing the city name as a parameter. So, your web request will
    look like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用名为“按城市名称”的API，它允许您通过提供城市名称作为参数来获取当前天气数据。因此，您的网络请求将如下所示：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On the documentation page, click on the link under Example of API calls, and
    you will see a sample response like the following:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文档页面上，点击“API调用示例”下的链接，您将看到一个类似以下的示例响应：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Given the existing `ICurrentWeather` interface that you have already created,
    this response contains more information than you need. So you will write a new
    interface that conforms to the shape of this response, but only specify the pieces
    of data you will use. This interface will only exist in the `WeatherService` and
    we won't export it, since the other parts of the application don't need to know
    about this type.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于您已经创建的现有`ICurrentWeather`接口，此响应包含的信息比您需要的要多。因此，您将编写一个新的接口，符合此响应的形状，但只指定您将使用的数据部分。这个接口只会存在于`WeatherService`中，我们不会导出它，因为应用程序的其他部分不需要知道这种类型。
- en: Create a new interface named `ICurrentWeatherData` in `weather.service.ts` between
    the `import` and `@Injectable` statements
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`weather.service.ts`中的`import`和`@Injectable`语句之间创建一个名为`ICurrentWeatherData`的新接口
- en: 'The new interface should like this:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新接口应该像这样：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the `ICurrentWeatherData` interface, we are defining new anonymous types
    by adding children objects to the interface with varying structures. Each of these
    objects can be individually extracted out and defined as their own named interface.
    Especially, note that `weather` will be an array of the anonymous type that has
    the `description` and `icon` properties.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ICurrentWeatherData`接口，我们通过向接口添加具有不同结构的子对象来定义新的匿名类型。这些对象中的每一个都可以单独提取出来，并定义为它们自己的命名接口。特别要注意的是，`weather`将是一个具有`description`和`icon`属性的匿名类型的数组。
- en: Storing environment variables
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储环境变量
- en: 'It''s easy to miss, but the sample URL from previous sections contains a required `appid` parameter.
    You must store this key in your Angular app. You can store it in the weather service,
    but in reality, applications need to be able to target different sets of resources
    as they move from development to testing, staging, and production environments.
    Out of the box, Angular provides two environments: one `prod` and the other one
    as the default.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忽略，但前几节的示例URL包含一个必需的`appid`参数。您必须将此密钥存储在您的Angular应用中。您可以将其存储在天气服务中，但实际上，应用程序需要能够在从开发到测试、暂存和生产环境的不同资源集之间切换。Angular提供了两个环境：一个`prod`和另一个作为默认值。
- en: Before you can continue, you need to sign up for a free `OpenWeatherMap` account
    and retrieve your own `appid`. You can read the documentation for `appid` at [http://openweathermap.org/appid ](http://openweathermap.org/appid)for
    more detailed information.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您需要注册一个免费的`OpenWeatherMap`帐户并检索您自己的`appid`。您可以阅读[http://openweathermap.org/appid](http://openweathermap.org/appid)上的`appid`文档以获取更详细的信息。
- en: Copy your `appid`, which will have a long string of characters and numbers
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制您的`appid`，它将包含一长串字符和数字
- en: Store your `appid `in `environment.ts`
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的`appid`存储在`environment.ts`中
- en: 'Configure `baseUrl` for later use:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`baseUrl`以供以后使用：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In code, we use a camel-case `appId` to keep our coding style consistent. Since
    URL parameters are case-insensitive, `appId` will work as well as `appid`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们使用驼峰命名法`appId`来保持我们的编码风格一致。由于URL参数不区分大小写，`appId`和`appid`都可以使用。
- en: Implementing an HTTP GET operation
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现HTTP GET操作
- en: 'Now, we can implement the GET call in the Weather service:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在天气服务中实现GET调用：
- en: Add a new function to the `WeatherService` class named `getCurrentWeather`
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WeatherService`类中添加一个名为`getCurrentWeather`的新函数
- en: Import the `environment` object
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`environment`对象
- en: Implement the `httpClient.get` function
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`httpClient.get`函数
- en: 'Return the results of the HTTP call:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回HTTP调用的结果：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the use of ES2015's String Interpolation feature. Instead of building your
    string by appending variables to one another like `environment.baseUrl + 'api.openweathermap.org/data/2.5/weather?q='
    + city + ',' + country + '&appid=' + environment.appId`, you can use the backtick
    syntax to wrap ``your string``. Inside the backticks, you can have newlines and
    also directly embed variables into the flow of your string by wrapping them with
    the `${dollarbracket}` syntax. However, when you introduce a newline in your code,
    it will be interpreted as a literal newline—`\n`. In order to break up the string
    in your code, you may add a backslash `\`, but then the next line of your code
    can have no indentation. It is easier to just concatenate multiple templates,
    as shown in the preceding code sample.Note the use TypeScript Generics with the
    get function using the caret syntax like `<TypeName>`. Using generics is development-time
    quality of life feature. By providing the type information to the function, input
    and/or return variables types of that function will be displayed as you write
    your code and validated during development and also at compile time.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用ES2015的字符串插值功能。不要像`environment.baseUrl + 'api.openweathermap.org/data/2.5/weather?q='
    + city + ',' + country + '&appid=' + environment.appId`那样通过将变量附加到一起来构建字符串，而是可以使用反引号语法来包裹``你的字符串``。在反引号内，你可以有换行，并且还可以直接使用`${dollarbracket}`语法将变量嵌入到字符串中。但是，当你在代码中引入换行时，它将被解释为字面换行—`\n`。为了在代码中断开字符串，你可以添加一个反斜杠`\`，但是接下来的代码行不能有缩进。更容易的方法是连接多个模板，就像前面的代码示例中所示的那样。注意使用TypeScript泛型与使用尖括号语法的`get`函数。使用泛型是开发时的生活质量特性。通过向函数提供类型信息，该函数的输入和/或返回变量类型将在编写代码时显示并在开发和编译时进行验证。
- en: Retrieving service data from a component
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从组件中检索服务数据
- en: 'To be able to use the `getCurrentWeather` function in the `CurrentWeather`
    component, you need to inject the service into the component:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够在`CurrentWeather`组件中使用`getCurrentWeather`函数，您需要将服务注入到组件中：
- en: Inject the `WeatherService` into the constructor of the `CurrentWeatherComponent`
    class
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`WeatherService`注入到`CurrentWeatherComponent`类的构造函数中
- en: 'Remove the existing code that created the dummy data in the constructor:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除构造函数中创建虚拟数据的现有代码：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Call the `getCurrentWeather` function inside the `ngOnInit` function:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ngOnInit`函数内调用`getCurrentWeather`函数：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Fair warning, do not expect this code to be working just yet. You should see
    an error, so let's understand what's going in the next segment.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 公平警告，不要指望这段代码立即生效。您应该会看到一个错误，所以让我们了解接下来会发生什么。
- en: Angular components have a rich collection of lifecycle hooks that allow you
    to inject your custom behavior when a component is being rendered, refreshed,
    or destroyed. `ngOnInit()` is the most common lifecycle hook you will be using.
    It is only called once when a component is first instantiated or visited. This
    is where you will want to perform your service calls. For a deeper understanding
    of component lifecycle hooks, check out the documentation at [https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks).Note
    that the anonymous function you have passed to `subscribe` is an ES2015 arrow
    function. If you're not familiar with arrow functions, it may be confusing at
    first. Arrow functions are actually quite elegant and simple.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Angular组件具有丰富的生命周期钩子集合，允许您在组件被渲染、刷新或销毁时注入自定义行为。`ngOnInit()`是您将要使用的最常见的生命周期钩子。它只在组件首次实例化或访问时调用一次。这是您希望执行服务调用的地方。要更深入地了解组件生命周期钩子，请查看[https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)中的文档。请注意，您传递给`subscribe`的匿名函数是ES2015的箭头函数。如果您不熟悉箭头函数，一开始可能会感到困惑。箭头函数实际上非常简洁和简单。
- en: 'Consider the following arrow function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下箭头函数：
- en: '`(data) => { this.current = data }`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`(data) => { this.current = data }`'
- en: 'You can rewrite it simply as:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地重写它为：
- en: '`function(data) { this.current = data }`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`function(data) { this.current = data }`'
- en: 'There''s a special condition—when you write an arrow function that simply transforms
    a piece of data, such as this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊的条件——当你编写一个简单转换数据的箭头函数时，比如这样：
- en: '`(data) => { data.main.temp }`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`(data) => { data.main.temp }`'
- en: 'This function effectively takes `ICurrentWeatherData` as an input and returns
    the temp property. The return statement is implicit. If you rewrite it as a regular
    function, it will look like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有效地将`ICurrentWeatherData`作为输入，并返回temp属性。返回语句是隐式的。如果你将它重写为一个常规函数，它会看起来像这样：
- en: '`function(data) { return data.main.temp }`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`function(data) { return data.main.temp }`'
- en: When the `CurrentWeather` component loads, `ngOnInit` will fire once, which
    will call the `getCurrentWeather` function that returns an object with a type
    of `Observable<ICurrentWeatherData>`. An Observable, as described in the official
    documentation, *is the most basic building block of RxJS* that represents an event
    emitter, which will emit any data received over time with the type of `ICurrentWeatherData`.
    The `Observable` object by itself is benign and will not cause a network event
    to be fired unless it is being listened to. You can read more about Observables
    at [reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CurrentWeather`组件加载时，`ngOnInit`将会触发一次，它将调用`getCurrentWeather`函数，该函数返回一个类型为`Observable<ICurrentWeatherData>`的对象。Observable，如官方文档所述，*是RxJS的最基本构建块*，它代表一个事件发射器，将以`ICurrentWeatherData`类型发出随时间接收到的任何数据。`Observable`对象本身是无害的，除非被监听，否则不会引发网络事件。你可以在[reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html)上阅读更多关于Observables的信息。
- en: By calling `.subscribe` on the Observable, you're essentially attaching a listener
    to the emitter. You've implemented an anonymous function within the `subscribe`
    method, which will get executed whenever a new piece of data is received and an
    event is emitted. The anonymous function takes a data object as a parameter, and,
    the specific implementation in this case, assigns the piece of data to the local
    variable named current. Whenever current is updated, the template bindings you
    implemented earlier will pull in the new data and render it on the view. Even
    though `ngOnInit` executes only once, the subscription to the Observable persists.
    So whenever there's new data, the current variable will be updated and the view
    will re-render to display the latest data.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Observable上调用`.subscribe`，实质上是将一个监听器附加到发射器上。你在`subscribe`方法中实现了一个匿名函数，每当接收到新的数据并发出事件时，这个匿名函数就会被执行。这个匿名函数以一个数据对象作为参数，并且在这种情况下的具体实现是将数据片段分配给名为current的局部变量。每当current被更新时，你之前实现的模板绑定将拉取新数据并在视图上呈现出来。即使`ngOnInit`只执行一次，对Observable的订阅仍然存在。所以每当有新数据时，current变量将被更新，视图将重新呈现以显示最新的数据。
- en: The root cause of the error at hand is that the data that is being emitted is
    of type `ICurrentWeatherData`; however, our component only understands data that
    is shaped as described by the `ICurrentWeather` interface. In the next section,
    you will need to dig deeper into RxJS to understand how best to accomplish that
    task.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 手头错误的根本原因是被发出的数据的类型是`ICurrentWeatherData`，然而，我们的组件只理解`ICurrentWeather`接口描述的形状的数据。在下一节中，你需要更深入地了解RxJS，以了解如何最好地完成这项任务。
- en: 'Beware, VS Code and CLI sometimes stop working. As previously noted, as you
    code, the `npm start` command is running in the integrated terminal of VS Code.
    Angular CLI, in combination with the Angular Language Service plug-in, continuously
    watches for code changes and transpiles your TypeScript code to JavaScript, so
    you can observe your changes with live-reloading in the browser. The great thing
    is that when you make coding errors, in addition to the red underlining in VS
    Code, you will also see some red text in the terminal or even the browser, because
    the transpilation has failed. In most cases, when correcting the error, the red
    underlining will go away and Angular CLI will automatically retranspile your code
    and everything will work. However, under certain scenarios, you will note that
    VS Code will fail to pick typing changes in the IDE, so you won''t get autocompletion
    help or the CLI tool will get stuck with message saying webpack: Failed to compile.
    You have two main strategies to recover from such conditions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，VS Code和CLI有时会停止工作。如前所述，当您编写代码时，`npm start`命令正在VS Code的集成终端中运行。Angular CLI与Angular
    Language Service插件结合，不断监视代码更改并将您的TypeScript代码转译为JavaScript，因此您可以在浏览器中实时查看更改。很棒的一点是，当您出现编码错误时，除了在VS
    Code中的红色下划线之外，您还会在终端甚至浏览器中看到一些红色文本，因为转译失败了。在大多数情况下，纠正错误后，红色下划线将消失，Angular CLI将自动重新转译您的代码，一切都将正常工作。然而，在某些情况下，您会注意到VS
    Code无法在IDE中捕捉到输入更改，因此您将无法获得自动补全帮助，或者CLI工具将卡在显示“webpack: Failed to compile”的消息上。您有两种主要策略来从这种情况中恢复：'
- en: Click on the terminal and hit *Ctrl* + *C*to stop running the CLI task and restart
    by executing `npm start`
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击终端，按*Ctrl* + *C*停止运行CLI任务，然后通过执行`npm start`重新启动
- en: If **#1** doesn't work, quit VS Code with *Alt* + *F4* for Windows or ⌘ + *Q*
    for macOS and restart it
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**#1**不起作用，请使用*Alt* + *F4*（Windows）或⌘ + *Q*（macOS）退出VS Code并重新启动
- en: Given Angular and VS Code's monthly releases cycles, I'm confident that in time
    the tooling can only improve.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到Angular和VS Code每月发布的周期，我相信工具只会不断改进。
- en: Transform data using RxJS
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RxJS转换数据
- en: RxJS stands for Reactive Extensions, which is a modular library that enables
    reactive programming, which itself is an asynchronous programming paradigm and
    allows for manipulation of data streams through transformation, filtering, and
    control functions. You can think of reactive programming as an evolution of event-based
    programming.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS代表响应式扩展，这是一个模块化库，可以实现响应式编程，它本身是一种异步编程范式，并允许通过转换、过滤和控制函数来操作数据流。您可以将响应式编程视为事件驱动编程的演进。
- en: Understanding Reactive programming
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解响应式编程
- en: In Event-Driven programming, you would define an event handler and attach it
    to an event source. In more concrete terms, if you had a save button, which exposes
    an `onClick` event, you would implement a `confirmSave` function, which when triggered,
    would show a popup to ask the user Are you sure?. Look at the following figure
    for a visualization of this process.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动编程中，您将定义一个事件处理程序并将其附加到事件源。更具体地说，如果您有一个保存按钮，它公开了一个`onClick`事件，您将实现一个`confirmSave`函数，当触发时，将显示一个弹出窗口询问用户“您确定吗？”。查看以下图示以可视化此过程。
- en: '![](Images/1958996b-696a-4b00-971d-12e7f8537bf2.png)Event-Driven Implementation'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/1958996b-696a-4b00-971d-12e7f8537bf2.png)事件驱动实现'
- en: In short, you would have an event firing once per user action. If the user clicks
    on the save button many times, this pattern would gladly render as many popups
    as there are clicks, which doesn't make much sense.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，每次用户操作都会触发一个事件。如果用户多次点击保存按钮，这种模式会愉快地渲染出与点击次数相同的弹出窗口，这并没有太多意义。
- en: The publish-subscribe (pub/sub) pattern is a different type of event-driven
    programming. In this case, we can write multiple handlers to act on the result
    of a given event all simultaneously. Let's say that your app just received some
    updated data. The publisher will go through its list of subscribers and pass on
    the updated data to each of them. Refer to the following diagram, how can updated
    data event trigger an `updateCache` function that can update your local cache
    with new data, a `fetchDetails` function that can retrieve further details about
    the data from the server, and also a `showToastMessage` function that can inform
    the user that the app just received new data. All these events can happen asynchronously;
    however, the `fetchDetails` and `showToastMessage` functions will be receiving
    more data than they really need, and it can get really convoluted to try to compose
    these events in different ways to modify application behavior.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅（pub/sub）模式是一种不同类型的事件驱动编程。在这种情况下，我们可以编写多个处理程序同时对给定事件的结果进行操作。假设您的应用程序刚刚收到了一些更新的数据。发布者将遍历其订阅者列表，并将更新的数据传递给它们每一个。参考以下图表，更新的数据事件如何触发`updateCache`函数，该函数可以使用新数据更新本地缓存，`fetchDetails`函数可以从服务器检索有关数据的更多详细信息，并且`showToastMessage`函数可以通知用户应用程序刚刚收到新数据。所有这些事件都可以异步发生；但是，`fetchDetails`和`showToastMessage`函数将接收比它们实际需要的更多数据，并且尝试以不同的方式组合这些事件以修改应用程序行为可能会变得非常复杂。
- en: '![](Images/3526531c-0a8d-4901-887b-2128cf2c4451.png)Pub/Sub Pattern Implementation'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 发布/订阅模式实现
- en: In reactive programming, everything is treated as a stream. A stream will contain
    events that happen over time and these events can contain some data or no data.
    The following diagram visualizes a scenario where your app is listening for mouse
    clicks from the user. Uncontrolled streams of user clicks are meaningless. You
    exert some control over this stream by applying the `throttle` function to it,
    so you only get updates every 250 **milliseconds** (**ms**). If you subscribe
    to this new event, every 250 ms, you will receive a list of click events. You
    may try to extract some data from each click event, but in this case, you're only
    interested in the number of click events that happened. We can shape the raw event
    data into number of clicks using the `map` function.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式编程中，一切都被视为流。流将包含随时间发生的事件，这些事件可以包含一些数据或没有数据。以下图表可视化了一个场景，您的应用程序正在监听用户的鼠标点击。无序的用户点击流是没有意义的。通过对其应用`throttle`函数，您可以对此流施加一些控制，以便每250毫秒只获取更新。如果您订阅此新事件，每250毫秒，您将收到一个点击事件列表。您可以尝试从每个点击事件中提取一些数据，但在这种情况下，您只对发生的点击事件数量感兴趣。我们可以使用`map`函数将原始事件数据转换为点击次数。
- en: Further down the stream, we may only be interested in listening for events with
    two or more clicks in it, so we can use the `filter` function to only act on what
    is essentially a double-click event. Every time our filter event fires, it means
    that the user intended to double-click, and you can act on that information by
    popping up an alert. The true power for streams comes from the fact that you can
    choose to act on the event at any time as it passes through various control, transformation,
    and filter functions. You can choose to display click data on an HTML list using
    `*ngFor` and Angular's `async` pipe, so the user can monitor the types of click
    data being captured every 250ms.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在流的后续过程中，我们可能只对包含两次或更多次点击的事件感兴趣，因此我们可以使用`filter`函数仅对本质上是双击事件的事件进行操作。每当我们的过滤事件触发时，这意味着用户打算进行双击，您可以通过弹出警报来对此信息进行操作。流的真正力量来自于您可以选择在事件通过各种控制、转换和过滤函数时的任何时间对其进行操作。您可以选择使用`*ngFor`和Angular的`async`管道在HTML列表上显示点击数据，以便用户可以每250毫秒监视被捕获的点击数据类型。
- en: '![](Images/c16581a0-78ed-4c3c-87a6-903d7bca41d0.png)A Reactive Data Stream
    Implementation'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个响应式数据流实现
- en: Implementing Reactive transformations
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施响应式转换
- en: 'To avoid future mistakes in returning the unintended type of data from your
    service, you need to update the `getCurrentWeather` function to define the return
    type to be `Observable<ICurrentWeather>` and import the `Observable` type, as
    shown:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免将来从服务中返回意外类型的数据，您需要更新`getCurrentWeather`函数以定义返回类型为`Observable<ICurrentWeather>`，并导入`Observable`类型，如下所示：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, VS Code will let you know that Type `Observable<ICurrentWeatherData>` is
    not assignable to type `Observable<ICurrentWeather>`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，VS Code会提醒您`Observable<ICurrentWeatherData>`的类型无法赋值给`Observable<ICurrentWeather>`的类型：
- en: Write a transformation function named `transformToICurrentWeather` that can
    convert `ICurrentWeatherData` to `ICurrentWeather`
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`transformToICurrentWeather`的转换函数，可以将`ICurrentWeatherData`转换为`ICurrentWeather`
- en: 'Also, write a helper function named `convertKelvinToFahrenheit` that converts
    the API provided Kelvin temperature to Fahrenheit:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，编写一个名为`convertKelvinToFahrenheit`的辅助函数，将API提供的开尔文温度转换为华氏度：
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that you need to be converting the icon property to an image URL at this
    stage. Doing this in the service helps preserve encapsulation, binding the icon
    value to the URL in the view template will break the **Separation of concerns**
    (**SoC**) principle. If you wish to create truly modular, reusable, and maintainable
    components, you must remain vigilant and strict in terms of enforcing SoC. The
    documentation for Weather Icons and details of how the URL should be formed, including
    all the available icons can be found at [http://openweathermap.org/weather-conditions](http://openweathermap.org/weather-conditions).On
    a separate note, the argument can be made that Kelvin to Fahrenheit conversion
    is actually a view concern, but we have implemented it in the service. This argument
    holds water, especially considering that we have a planned feature to be able
    to toggle between Celsius and Fahrenheit. A counter argument would be that at
    this time, we only need to display in Fahrenheit and it is part of the job of
    the weather service to be able to convert the units. This argument makes sense
    as well. The ultimate implementation will be to write a custom Angular Pipe and
    apply it in the template. A pipe can easily bind with the planned toggle button
    as well. However, at this time, we only need to display in Fahrenheit and I would
    err on the side of *not*over-engineering a solution.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您需要在此阶段将图标属性转换为图像URL。在服务中执行此操作有助于保持封装性，将图标值绑定到视图模板中的URL将违反**关注点分离**（**SoC**）原则。如果您希望创建真正模块化、可重用和易维护的组件，您必须在强制执行SoC方面保持警惕和严格。有关天气图标的文档以及URL应如何形成的详细信息，包括所有可用的图标，可以在[http://openweathermap.org/weather-conditions](http://openweathermap.org/weather-conditions)找到。另外，可以提出Kelvin到Fahrenheit的转换实际上是一个视图关注点的论点，但我们已经在服务中实现了它。这个论点是站得住脚的，特别是考虑到我们计划的功能是能够在摄氏度和华氏度之间切换。相反的论点是，此时此刻，我们只需要以华氏度显示，并且天气服务的工作之一是能够转换单位。这个论点也是有道理的。最终的实现将是编写一个自定义的Angular管道，并在模板中应用它。管道也可以轻松地与计划中的切换按钮绑定。然而，此时此刻，我们只需要以华氏度显示，我会倾向于*不*过度设计解决方案。
- en: Update `ICurrentWeather.date` to the `number` type
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`ICurrentWeather.date`为`number`类型
- en: While writing the transformation function, you will note that the API returns
    the date as a number. This number represents time in seconds since the UNIX epoch
    (timestamp), which is January 1st, 1970 00:00:00 UTC. However, `ICurrentWeather`
    expects a `Date` object. It is easy enough to convert the timestamp by passing
    it into the constructor of the `Date` object like `new Date(data.dt)`. This is
    fine, but also unnecessary, since Angular's `DatePipe` can directly work with
    the timestamp. In the name of relentless simplicity and maximally leveraging the
    functionality of the frameworks we use, we will update `ICurrentWeather` to use
    `number`. There's also a performance and memory benefit to this approach if you're
    transforming massive amounts of data, but that concern is not applicable here. There's
    one caveat—JavaScript's timestamp is in milliseconds, but the server value is
    in seconds, so a simple multiplication during the transformation is still required.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写转换函数时，您会注意到API将日期返回为数字。这个数字代表自UNIX纪元（时间戳）以来的秒数，即1970年1月1日00:00:00 UTC。然而，`ICurrentWeather`期望一个`Date`对象。通过将时间戳传递到`Date`对象的构造函数中，像`new
    Date(data.dt)`这样转换是很容易的。这没问题，但也是不必要的，因为Angular的`DatePipe`可以直接处理时间戳。为了追求简单和充分利用我们使用的框架的功能，我们将更新`ICurrentWeather`以使用`number`。如果您正在转换大量数据，这种方法也有性能和内存上的好处，但这个问题在这里并不适用。有一个例外——JavaScript的时间戳是以毫秒为单位的，但服务器的值是以秒为单位的，因此在转换过程中仍然需要进行简单的乘法运算。
- en: 'Import the RxJS `map` operator right below the other import statements:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其他导入语句的下方导入RxJS的`map`操作符：
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It may seem odd to have to manually import the `map` operator. RxJS is a very
    capable framework with a wide API surface. Observable alone has over 200 methods
    attached to it. Including all of these methods by default creates development
    time issues with too many functions to choose from and also, it negatively impacts
    the size of the final deliverable, including app performance and memory use. So
    you must add each operator you intend to use individually.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会觉得奇怪，需要手动导入`map`操作符。RxJS是一个非常强大的框架，拥有广泛的API表面。Observable本身就有超过200个附加方法。默认包含所有这些方法会在开发时创建太多可供选择的函数，并且会对最终交付的大小、应用程序性能和内存使用产生负面影响。因此，您必须单独添加要使用的每个操作符。
- en: Apply the `map` function to data stream returned by  `httpClient.get` method
    through a `pipe`
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`pipe`将`map`函数应用于`httpClient.get`方法返回的数据流
- en: 'Pass the `data` object into the `transformToICurrentWeather` function:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`data`对象传递给`transformToICurrentWeather`函数：
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now incoming data can be transformed as it flows through the stream, ensuring
    that the `OpenWeatherMap` Current Weather API data is in the correct shape, so
    it can be consumed by the `CurrentWeather` component.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，传入的数据可以在流经时进行转换，确保`OpenWeatherMap`当前天气API数据的格式正确，以便`CurrentWeather`组件可以使用。
- en: Ensure that your app compiles successfully
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的应用程序成功编译
- en: 'Inspect the results in the browser:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中检查结果：
- en: '![](Images/9d3b92ed-4580-464f-ba40-4eb4f8b2121d.png)Displaying Live Data from
    OpenWeatherMap'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/9d3b92ed-4580-464f-ba40-4eb4f8b2121d.png)从OpenWeatherMap显示实时数据'
- en: Finally, you should see that your app is able to pull live data from `OpenWeatherMap`
    and correctly transform server data into the format you expect.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您应该看到您的应用程序能够从`OpenWeatherMap`获取实时数据，并正确地将服务器数据转换为您期望的格式。
- en: You have completed the development of Feature 1: Display Current Location weather
    information for the current day. Commit your code and move the card in Waffle
    to the Done column.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经完成了Feature 1的开发：显示当前位置的当天天气信息。提交您的代码并将卡片移动到Waffle的“完成”列。
- en: 'Finally, we can move this task to the Done column:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将此任务移动到“完成”列：
- en: '![](Images/fa81e672-d175-49db-a89c-67b6acb67a98.png)Waffle.io Kanban Board
    Status'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/fa81e672-d175-49db-a89c-67b6acb67a98.png)Waffle.io看板状态'
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations, in this chapter, you created your first Angular application
    with a flexible architecture while avoiding over-engineering. This was possible
    because we first built a road map and codified it in a Kanban board that is visible
    to your peers and colleagues. We stayed focused on implementing the first feature
    we put in progress and didn't deviate from the plan.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，在本章中，您创建了您的第一个具有灵活架构的Angular应用，同时避免了过度工程化。这是可能的，因为我们首先建立了一个路线图，并将其编码在一个可见于您的同行和同事的看板中。我们专注于实现我们正在进行中的第一个功能，并没有偏离计划。
- en: You can now use Angular CLI and an optimized VS Code development environment
    to help you reduce the amount of coding you need to do. You can leverage TypeScript
    anonymous types and observable streams to accurately reshape complicated API data
    into a simple format without having to create one-use interfaces.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用Angular CLI和优化的VS Code开发环境来帮助您减少编码量。您可以利用TypeScript匿名类型和可观察流来准确地将复杂的API数据重塑为简单的格式，而无需创建一次性接口。
- en: You learned to avoid coding mistakes by proactively declaring input and return
    types of functions and working with generic functions. You used the date and decimal
    pipes to ensure that the data is formatted as desired, while keeping formatting-related
    concerns mostly in the template, where this kind of logic belongs.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了通过主动声明函数的输入和返回类型以及使用通用函数来避免编码错误。您使用日期和小数管道来确保数据按预期格式化，同时将与格式化相关的问题大部分放在模板中，这种逻辑属于模板。
- en: Finally, you used interfaces to communicate between components and services
    without leaking the external data structure to internal components. By applying
    all these techniques in combination, which Angular, RxJS, and TypeScript have
    allowed us to do, you have ensured proper separation of concerns and encapsulation.
    As a result, the `CurrentWeather` component is now a truly reusable and composable
    component; this is not an easy feat to achieve.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您使用接口在组件和服务之间进行通信，而不会将外部数据结构泄漏给内部组件。通过结合应用所有这些技术，Angular、RxJS和TypeScript让我们能够确保关注点的正确分离和封装。因此，`CurrentWeather`组件现在是一个真正可重用和可组合的组件；这并不是一件容易的事情。
- en: If you don't ship it, it never happened. In the next chapter, we will prepare
    this Angular app for a production release by troubleshooting application errors,
    and containerizing the Angular app with Docker, so it can be published on the
    web.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不发布它，它就从来没有发生过。在下一章中，我们将通过解决应用程序错误来为生产发布准备这个Angular应用，并使用Docker对Angular应用进行容器化，以便可以在网络上发布。
