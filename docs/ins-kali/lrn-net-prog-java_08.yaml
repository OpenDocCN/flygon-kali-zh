- en: Chapter 8. Network Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。网络安全
- en: 'In this chapter, we will explore the support that Java provides to secure communications
    between applications. We will examine several topics, including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Java为应用程序之间的安全通信提供的支持。我们将研究几个主题，包括以下内容：
- en: The basic encryption process
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本加密过程
- en: Using a keystore to store keys and certificates
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用密钥库存储密钥和证书
- en: Adding encryption to a simple server/client
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在简单的服务器/客户端中添加加密
- en: Secure client/server communications using TLS\SSL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TLS\SSL进行安全的客户端/服务器通信
- en: Secure hashing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全散列
- en: Security
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: There are many security related terms whose meaning and purpose can be daunting
    when they are first encountered. Most of these terms are applicable to network
    applications. We will start with a brief overview of many of these terms. In later
    sections of this chapter, we will go into more details about the ones that are
    relevant to our discussion.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在首次遇到时，许多与安全相关的术语的含义和目的可能令人生畏。这些术语大多适用于网络应用程序。我们将从对这些术语的简要概述开始。在本章的后续部分，我们将更详细地讨论与我们讨论相关的术语。
- en: Central to most security related issues is encryption. This is the process of
    converting information that needs to be protected to an encrypted form using a
    key or a set of keys. The receiver of the encrypted information can use a key
    or set of keys to decrypt the information and revert it to its original form.
    This technique will prevent unauthorized access to the information.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对大多数与安全相关的问题至关重要的是加密。这是将需要保护的信息使用密钥或一组密钥转换为加密形式的过程。接收加密信息的接收者可以使用密钥或一组密钥来解密信息并将其恢复为其原始形式。这种技术可以防止未经授权的人访问信息。
- en: We will demonstrate the use of both **symmetric** and asymmetric encryption
    techniques. Symmetric encryption uses a single key to encrypt and decrypt messages.
    Asymmetric encryption uses a pair of keys. These keys are frequently stored in
    a file called a **keystore**, which we will demonstrate.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示对称和非对称加密技术的使用。对称加密使用单个密钥加密和解密消息。非对称加密使用一对密钥。这些密钥通常存储在一个称为**密钥库**的文件中，我们将进行演示。
- en: Symmetric encryption is usually faster but requires the sender and receiver
    of the encrypted data to share their keys in a safe and secure manner. For parties
    that are remotely dispersed, this can be a problem. Asymmetric encryption is slower,
    but it uses a public and private key pair that, as we will see, simplifies the
    sharing of keys. Asymmetric encryption is an enabling technology for digital certificates
    that provides a means of verifying the authenticity of documents.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密通常更快，但需要发送方和接收方以安全的方式共享其密钥。对于远程分散的各方来说，这可能是一个问题。非对称加密速度较慢，但使用公钥和私钥对，简化了密钥的共享，这是我们将要看到的。非对称加密是数字证书的一种使能技术，提供了验证文档真实性的手段。
- en: 'Secure commerce is common and is essential for online transactions that take
    place globally every day. The **Transport Layer Security** (**TLS**) and **Secure
    Sockets Layer** (**SSL**) are protocols that allow secure and reliable communication
    across the Internet. It is the basis for **Hyper Text Transfer Protocol Secure**
    (**HTTPS**) that is used to conduct most transactions on the Internet. This protocol
    supports the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 安全商务是常见的，对于每天在全球范围内进行的在线交易至关重要。**传输层安全**（**TLS**）和**安全套接字层**（**SSL**）是允许在互联网上进行安全可靠通信的协议。这是**超文本传输安全协议**（**HTTPS**）的基础，用于进行互联网上的大多数交易。该协议支持以下内容：
- en: Server and client authentication
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器和客户端认证
- en: Data encryption
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据加密
- en: Data integrity
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据完整性
- en: Secure hashing is a technique that is used to create certificates. A **certificate**
    is used to verify the authenticity of data, and it uses a hash value. Java provides
    support for this process, which we will demonstrate.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安全散列是一种用于创建证书的技术。**证书**用于验证数据的真实性，并使用散列值。Java提供了对这个过程的支持，我们将进行演示。
- en: Let's start with a brief introduction of common network security terms to provide
    a high-level perspective of the chapter. Specific terms are explored in more detail
    in subsequent sections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简要介绍常见网络安全术语开始，以提供本章的高层视角。具体术语将在后续章节中更详细地探讨。
- en: Secure communication terminology
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全通信术语
- en: 'There are several terms that are used when working with secure communications.
    These include the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理安全通信时使用了几个术语。这些包括以下内容：
- en: '**Authentication**: This is the process of verifying a user or system'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：这是验证用户或系统的过程'
- en: '**Authorization**: This is the process of allowing access to protected resources'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：这是允许访问受保护资源的过程'
- en: '**Encryption**: This is the process of encoding and subsequently decoding information
    to protect it from unauthorized individuals'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密**：这是对信息进行编码，然后解码以保护它免受未经授权的个人的过程'
- en: '**Hashing algorithms**: These provide a way of producing a unique value for
    a document, and they are used in support of other security techniques'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**散列算法**：这提供了为文档生成唯一值的方式，并且它们用于支持其他安全技术'
- en: '**Digital signatures**: These provide a way of digitally authenticating a document'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字签名**：这提供了一种数字验证文档的方式'
- en: '**Certificates**: These are normally used as a chain, and they support the
    confirmation of the identity of principals and other actors'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书**：这些通常用作链，并支持确认主体和其他参与者的身份'
- en: Authentication and authorization are related. Authentication is the process
    of determining whether a person or system is who they claim to be. This is commonly
    achieved using an ID and a password. However, there are other authentication techniques,
    such as smart cards, and biometric signatures, such as fingerprint, or iris scans.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和授权是相关的。认证是确定一个人或系统是否是其声称的人或系统的过程。通常使用ID和密码来实现。然而，还有其他认证技术，如智能卡，生物特征签名，如指纹或虹膜扫描。
- en: Authorization is the process of determining what resources an individual or
    system has access to. It is one thing to verify that an individual is who they
    say they are. It is another thing to ensure that the user can only access authorized
    resources.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 授权是确定个人或系统可以访问哪些资源的过程。验证个人是否是他们所说的人是一回事。确保用户只能访问授权资源是另一回事。
- en: Encryption has evolved and will continue to improve. Java supports symmetric
    and asymmetric encryption techniques. The process starts with the generation of
    keys, which are normally stored in a keystore. Applications that need to encrypt
    or decrypt data will access a keystore to retrieve the appropriate keys. The keystore
    itself needs to be protected so that it cannot be tampered with or otherwise compromised.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 加密已经发展并将继续改进。Java支持对称和非对称加密技术。这个过程从生成密钥开始，这些密钥通常存储在密钥库中。需要加密或解密数据的应用程序将访问密钥库以检索适当的密钥。密钥库本身需要受到保护，以防止被篡改或以其他方式被破坏。
- en: Hashing is the process of taking data and returning a number that represents
    the data. A hash algorithm performs this operation, and it must be fast. However,
    it is extremely difficult, if not impossible, to derive the original data when
    given only the hash value. This is called a one-way hash function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是将数据转换为代表数据的数字的过程。哈希算法执行这个操作，它必须很快。然而，只给出哈希值时，要推导出原始数据是极其困难，甚至是不可能的。这被称为单向哈希函数。
- en: The advantage of this technique is that the data can be sent along with the
    hash value to a receiver. The data is not encrypted, but the hash value is encrypted
    using a set of asymmetric keys. The receiver can then use the original hash algorithm
    to compute a hash value for the received data. If this new hash value matches
    the hash value that was sent, then the receiver can be assured that the data has
    not been modified or corrupted in the transmission. This provides a more reliable
    means of transferring data that does not need to be encrypted, but where some
    assurance that it has not been modified can be given.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的优势在于数据可以与哈希值一起发送给接收者。数据没有加密，但哈希值使用一组非对称密钥进行了加密。接收者可以使用原始哈希算法为接收到的数据计算一个哈希值。如果这个新的哈希值与发送的哈希值匹配，那么接收者可以确信数据在传输过程中没有被修改或损坏。这提供了一种更可靠的传输数据的方式，不需要加密，但可以给出一些保证它没有被修改的保证。
- en: A certificate is part of the previous process and it uses a hash function and
    asymmetric keys. A **certificate chain** provides a means of verifying that a
    certificate is valid, assuming that the root of the chain can be trusted.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 证书是前面过程的一部分，它使用哈希函数和非对称密钥。**证书链**提供了一种验证证书是否有效的方法，假设可以信任链的根。
- en: Encryption basics
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密基础
- en: In this section, we will examine how Java supports symmetric and asymmetric
    encryption. As we will see, there are various encryption algorithms that are available
    for both of these techniques.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Java如何支持对称和非对称加密。正如我们将看到的，这两种技术都有各种可用的加密算法。
- en: Symmetric encryption techniques
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对称加密技术
- en: Symmetric encryption uses a single key to encrypt and decrypt a message. This
    type of encryption is classified as either stream ciphers or block ciphers. More
    details about these algorithms can be found at [https://en.wikipedia.org/wiki/Symmetric-key_algorithm](https://en.wikipedia.org/wiki/Symmetric-key_algorithm).
    A provider provides an implementation of an encryption algorithm, and we often
    choose between them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密使用单个密钥来加密和解密消息。这种加密类型被分类为流密码或块密码。关于这些算法的更多细节可以在[https://en.wikipedia.org/wiki/Symmetric-key_algorithm](https://en.wikipedia.org/wiki/Symmetric-key_algorithm)找到。提供者提供了加密算法的实现，我们经常在它们之间进行选择。
- en: 'Symmetric algorithms that are supported by Java include the following ones
    where the key size in bits is enclosed in parentheses:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Java支持的对称算法包括以下这些，其中括号中是密钥大小（以位为单位）：
- en: AES (128)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AES（128）
- en: DES (56)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DES（56）
- en: DESede (168)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DESede（168）
- en: HmacSHA1
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HmacSHA1
- en: HmacSHA256
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HmacSHA256
- en: 'Varying lengths of data may be encrypted. Block cipher algorithms are used
    to handle large blocks of data. There are several block cipher modes of operations,
    as listed next. We will not detail how these modes work here, but additional information
    can be found at [https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可以加密不同长度的数据。块密码算法用于处理大块数据。下面列出了几种块密码操作模式。我们不会在这里详细介绍这些模式的工作原理，但可以在[https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)找到更多信息：
- en: ECB
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECB
- en: CBC
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CBC
- en: CFB
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CFB
- en: OFB
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OFB
- en: PCBC
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCBC
- en: Before we can encrypt or decrypt data, we need a key.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以加密或解密数据之前，我们需要一个密钥。
- en: Generating a key
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成密钥
- en: 'A common way of generating a key is using the `KeyGenerator` class. There are
    no public constructors for the class but an overloaded `getInstance` method will
    return a `KeyGenerator` instance. The following example uses the AES algorithm
    with the default provider. Other versions of this method allow selection of the
    provider:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 生成密钥的常见方法是使用`KeyGenerator`类。该类没有公共构造函数，但重载的`getInstance`方法将返回一个`KeyGenerator`实例。以下示例使用AES算法和默认提供者。该方法的其他版本允许选择提供者：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `generateKey` method returns an instance of an object that implements the
    `SecretKey` interface that is shown next. This is the key that is used to support
    symmetric encryption and decryption:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateKey`方法返回一个实现了`SecretKey`接口的对象实例，如下所示。这是用于支持对称加密和解密的密钥：'
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With a key, we can now encrypt data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有了密钥，我们现在可以加密数据了。
- en: Encrypting text using a symmetric key
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用对称密钥加密文本
- en: We will use the following `encrypt` method in later sections. This method is
    passed the text to encrypt and a secret key. The term **plain text** is frequently
    used to refer to the unencrypted data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的部分中使用以下的`encrypt`方法。这个方法接收要加密的文本和一个秘钥。术语**明文**经常用来指代未加密的数据。
- en: 'The `Cipher` class provides the framework for the encryption process. The `getInstance`
    method returns an instance of the class where the AES algorithm is used. The `Cipher`
    instance is initialized for encryption using `Cipher.ENCRYPT_MODE` as the first
    argument, and the secret key as the second argument. The `doFinal` method encrypts
    the plain text byte array and returns an encrypted byte array. The `Base64` class''s
    `getEncoder` returns an encoder that encodes the encrypted bytes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cipher`类提供了加密过程的框架。`getInstance`方法返回一个使用AES算法的类的实例。`Cipher`实例被初始化为使用`Cipher.ENCRYPT_MODE`作为第一个参数进行加密，秘钥作为第二个参数。`doFinal`方法加密明文字节数组并返回加密后的字节数组。`Base64`类的`getEncoder`返回一个编码器，用于编码加密后的字节：'
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Encoding an encrypted byte array is used to convert it to a string so that we
    can use it later. Encoding strings can be a useful security technique, as explained
    in [http://javarevisited.blogspot.sg/2012/03/why-character-array-is-better-than.html](http://javarevisited.blogspot.sg/2012/03/why-character-array-is-better-than.html).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 编码加密后的字节数组用于将其转换为字符串，以便以后使用。编码字符串可以是一种有用的安全技术，如[http://javarevisited.blogspot.sg/2012/03/why-character-array-is-better-than.html](http://javarevisited.blogspot.sg/2012/03/why-character-array-is-better-than.html)中所解释的那样。
- en: Decrypting text
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解密文本
- en: 'The process of decrypting text is illustrated in the decrypt method that is
    shown next. It uses a reverse process where the encrypted bytes are decoded and
    the `Cipher` class''s `init` method is initialized to decrypt the bytes using
    a secret key:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 解密文本的过程在接下来展示的解密方法中进行了说明。它使用一个反向过程，其中加密字节被解码，`Cipher`类的`init`方法被初始化为使用秘钥解密字节：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will use these methods in the echo client/server applications illustrated
    in the *Symmetric encryption client/server* section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*对称加密客户端/服务器*部分中的回显客户端/服务器应用程序中使用这些方法。
- en: Asymmetric encryption techniques
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非对称加密技术
- en: 'Asymmetric encryption uses a public and private key. The private key is held
    by one entity. The public key is made available to everyone. Data can be encrypted
    using either key:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密使用公钥和私钥。私钥由一个实体持有。公钥对所有人都是可用的。数据可以使用任一密钥加密：
- en: If the data is encrypted using the private key, then it can be decrypted using
    the public key
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据使用私钥加密，那么可以使用公钥解密。
- en: If the data is encrypted using the public key, then it can be decrypted using
    the private key
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据使用公钥加密，那么可以使用私钥解密。
- en: If the owner of the private key sends out a message that is encrypted with the
    private key, then recipients of this message can decrypt it with the public key.
    They can all read the message, but they know that only the private key owner could
    have sent this message.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果私钥所有者发送一条使用私钥加密的消息，那么接收者可以使用公钥解密。他们都可以读取消息，但他们知道只有私钥所有者才能发送这条消息。
- en: If someone else encrypts a message with the public key, then only the private
    key owner can read that message. However, the owner cannot be sure who actually
    sent the message. It could be an impostor.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他人使用公钥加密一条消息，那么只有私钥所有者可以读取该消息。然而，所有者无法确定谁实际发送了消息。可能是一个冒名顶替者。
- en: However, if both the parties have their own set of public/private keys, we can
    guarantee that only the sender and the recipient can see its content. We can also
    guarantee that the sender is who they say they are.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果双方都有自己的公钥/私钥，我们可以保证只有发送者和接收者可以看到其内容。我们还可以保证发送者就是他们所说的那个人。
- en: Let's assume that Sue wants to send a message to Bob. Sue will encrypt the message,
    M, using her private key. Let's call this message M1\. She will then encrypt M1
    using Bob's public key giving us M2\. The message, M2, is then sent to Bob. Now,
    only Bob can decrypt this message using his private key. This will return M1\.
    Bob can now use Sue's public key to decrypt M1 to get the original message, M.
    He knows that this is from Sue because only Sue's public key will work.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Sue想要给Bob发送一条消息。Sue将使用她的私钥加密消息M。我们称这条消息为M1。然后她使用Bob的公钥加密M1，得到M2。消息M2然后发送给Bob。现在，只有Bob可以使用他的私钥解密这条消息。这将返回M1。Bob现在可以使用Sue的公钥解密M1以获得原始消息M。他知道这是来自Sue的，因为只有Sue的公钥可以起作用。
- en: This process to send messages requires that both participants possess their
    own public/private keys. In addition to this, it is not as efficient as using
    a symmetric key. Another approach is to use asymmetric keys to transfer a secret
    key to the participants. The secret key can then be used for the actual message
    transfer. This is the technique that is used with SSL.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 发送消息的这个过程要求两个参与者都拥有自己的公钥/私钥。除此之外，这种方法不如使用对称密钥高效。另一种方法是使用非对称密钥来传输一个秘钥给参与者。然后这个秘钥可以用于实际的消息传输。这就是SSL中使用的技术。
- en: 'There are several asymmetric algorithms. Java supports the following encryption
    algorithms:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种非对称算法。Java支持以下加密算法：
- en: RSA
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSA
- en: Diffie-Hellman
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Diffie-Hellman
- en: DSA
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DSA
- en: 'We will demonstrate asymmetric encryption/decryption using a utility class
    called `AsymmetricKeyUtility` that is declared next. This class encapsulates methods
    to create, save, load, and retrieve public and private keys. We will explain how
    these methods work here and use them later with the asymmetric echo client/server
    application:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`AsymmetricKeyUtility`的实用类来演示非对称加密/解密。这个类封装了创建、保存、加载和检索公钥和私钥的方法。我们将在这里解释这些方法是如何工作的，并在非对称回显客户端/服务器应用程序中稍后使用它们。
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Generating and saving asymmetric keys
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成和保存非对称密钥
- en: 'The `main` method will create the keys, save them, and then test them to see
    whether they work correctly. The `KeyPairGenerator` method will generate the keys.
    To use asymmetric encryption, we get an instance of the class using the RSA algorithm.
    The `initialize` method specifies that the key uses 1,024 bits. The `generateKeyPair`
    method generates the keys, and the `getPrivate` and `getPublic` methods return
    the private and public keys, respectively:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法将创建密钥，保存它们，然后测试它们是否能正常工作。`KeyPairGenerator`方法将生成密钥。要使用非对称加密，我们使用RSA算法获取该类的实例。`initialize`方法指定密钥使用1,024位。`generateKeyPair`方法生成密钥，`getPrivate`和`getPublic`方法分别返回私钥和公钥：'
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will use a set of methods to save and retrieve these keys to separate files.
    This approach is not the most secure, but it will simplify the use of the echo
    client/server. The next statements invoke the save methods:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一组方法将这些密钥保存并检索到单独的文件中。这种方法并不是最安全的，但它将简化回声客户端/服务器的使用。下面的语句调用了保存方法：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The methods that are used to retrieve the keys are invoked here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检索密钥的方法在这里被调用：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next code sequence tests the encryption/decryption process. A message is
    created and passed to the `encrypt` method using the public key. The `decrypt`
    method is invoked to decrypt the message. The `encodedData` variable references
    the encrypted data:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码序列测试了加密/解密过程。创建了一条消息，并使用公钥将其传递给`encrypt`方法。调用`decrypt`方法来解密消息。`encodedData`变量引用了加密数据：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output of this example is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的输出如下：
- en: '**Message: The message**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息：消息**'
- en: '**Decrypted Message: The message**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**解密消息：消息**'
- en: Instead, we can use the private key for encryption and the public key for decryption
    to achieve the same results.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用私钥进行加密，使用公钥进行解密，以达到相同的结果。
- en: Encrypting/decrypting text using an asymmetric key
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用非对称密钥加密/解密文本
- en: 'Now, let''s examine the specifics of the `encrypt` and `decrypt` methods. The
    `encrypt` method uses `getInstance` to get an instance of the RSA algorithm. The
    `init` method specifies that the `Cipher` object will encrypt a message using
    a public key. The `doFinal` method performs the actual encryption and returns
    a byte array containing the encrypted message:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`encrypt`和`decrypt`方法的具体内容。`encrypt`方法使用`getInstance`获取RSA算法的实例。`init`方法指定`Cipher`对象将使用公钥加密消息。`doFinal`方法执行实际的加密并返回包含加密消息的字节数组：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `decrypt` method is described next. It specifies that the `Cipher` instance
    will decrypt a message using the private key. The encrypted message that is passed
    to it must be decoded before the `doFinal` method can decrypt it. The decrypted
    string is then returned:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来描述了`decrypt`方法。它指定`Cipher`实例将使用私钥解密消息。传递给它的加密消息在`doFinal`方法解密之前必须解码。然后返回解密的字符串：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Both of these methods catch a number of exceptions that can occur in the encryption/decryption
    process. We will not address these exceptions here.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都捕获了在加密/解密过程中可能发生的许多异常。我们在这里不讨论这些异常。
- en: Saving asymmetric keys to a file
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将非对称密钥保存到文件
- en: 'The next two methods illustrate one technique to save and retrieve a private
    key. The `PKCS8EncodedKeySpec` class supports the encoding of a private key. The
    encoded key is saved to the `private.key` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两种方法说明了保存和检索私钥的一种技术。`PKCS8EncodedKeySpec`类支持私钥的编码。编码的密钥保存到`private.key`文件中：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `getPrivateKey` method, that is described next, returns a private key from
    the file. The `KeyFactory` class''s `generatePrivate` method creates the key based
    on the `PKCS8EncodedKeySpec` specification:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来描述的`getPrivateKey`方法从文件中返回私钥。`KeyFactory`类的`generatePrivate`方法根据`PKCS8EncodedKeySpec`规范创建密钥：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The public key''s save and get methods are described next. They differ in the
    file that they use, and the use of the `X509EncodedKeySpec` class. This class
    represents public keys:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来描述了公钥的保存和获取方法。它们在使用的文件和`X509EncodedKeySpec`类的使用上有所不同。该类表示公钥：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The standard cryptographic algorithm names are found at [https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html](https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html).
    A performance comparison of symmetric algorithms is available at [http://www.javamex.com/tutorials/cryptography/ciphers.shtml](http://www.javamex.com/tutorials/cryptography/ciphers.shtml).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的加密算法名称可以在[https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html](https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html)找到。对称算法的性能比较可以在[http://www.javamex.com/tutorials/cryptography/ciphers.shtml](http://www.javamex.com/tutorials/cryptography/ciphers.shtml)找到。
- en: Creating a keystore
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建密钥库
- en: 'A keystore stores cryptographic keys and certificates and is frequently used
    in conjunction with servers and clients. A keystore is usually a file, but it
    can be a hardware device. Java supports the following types of keystore entries:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥库存储了加密密钥和证书，并经常与服务器和客户端一起使用。密钥库通常是一个文件，但也可以是硬件设备。Java支持以下类型的密钥库条目：
- en: '**PrivateKey**: This is used in asymmetric cryptography'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PrivateKey**：这用于非对称加密'
- en: '**Certificate**: This contains a public key'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书**：这包含公钥'
- en: '**SecretKey**: This is used in symmetric cryptography'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SecretKey**：这用于对称加密'
- en: 'There are five different types of keystores that are supported by Java 8: JKS,
    JCEKS, PKCS12, PKCS11, and DKS:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8支持五种不同类型的密钥库：JKS、JCEKS、PKCS12、PKCS11和DKS：
- en: '**JKS**: This is the **Java KeyStore** (**JKS**) that usually has an extension
    of `jks`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JKS**：这是通常具有扩展名`jks`的**Java密钥库**（**JKS**）。'
- en: '**JCEKS**: This is the **Java Cryptography Extension KeyStore** (**JCE**).
    It can store all three keystore entity types, provides stronger protection for
    keys, and uses a `jceks` extension.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JCEKS**：这是**Java密码扩展密钥库**（**JCE**）。它可以存储所有三种密钥库实体类型，为密钥提供更强的保护，并使用`jceks`扩展名。'
- en: '**PKCS12**: In contrast to JKS and JCEKS, this keystore can be used with other
    languages. It can store all three keystore entity types, and it uses an extension
    of `p12` or `pfx`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PKCS12**：与JKS和JCEKS相比，此密钥库可以与其他语言一起使用。它可以存储所有三种密钥库实体类型，并使用`p12`或`pfx`的扩展名。'
- en: '**PKCS11**: This is a hardware keystore type.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PKCS11**：这是一种硬件密钥库类型。'
- en: '**DKS**: This is the **Domain KeyStore** (**DKS**) that holds a collection
    of other keystores.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DKS：这是保存其他密钥库的**域密钥库**（**DKS**）。
- en: The default keystore type in Java is JKS. Keystores can be created and maintained
    using the `keytool` command line tool or with Java code. We will demonstrate `keytool`
    first.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的默认密钥库类型是JKS。可以使用`keytool`命令行工具或Java代码创建和维护密钥库。我们将首先演示`keytool`。
- en: Creating and maintaining a keystore with keytool
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用keytool创建和维护密钥库
- en: The keytool is a command line program that is used to create keystores. The
    full documentation of its use is found at [https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html).
    There are several GUI tools that are used to maintain keystores that are easier
    to use than keytool. One of these is IKEYMAN found at [http://www-01.ibm.com/software/webservers/httpservers/doc/v1312/ibm/9atikeyu.htm](http://www-01.ibm.com/software/webservers/httpservers/doc/v1312/ibm/9atikeyu.htm).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: keytool是一个用于创建密钥库的命令行程序。其完整的使用文档可在[https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html)找到。有几个GUI工具用于维护密钥库，比keytool更容易使用。其中一个是IKEYMAN，位于[http://www-01.ibm.com/software/webservers/httpservers/doc/v1312/ibm/9atikeyu.htm](http://www-01.ibm.com/software/webservers/httpservers/doc/v1312/ibm/9atikeyu.htm)。
- en: 'To use the keytool with Windows at the command prompt, you will need to configure
    the PATH environmental variable to locate its containing directory. Use a command
    similar to the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows上使用keytool，您需要配置PATH环境变量以定位其所在的目录。使用类似以下的命令：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s use the keytool to create a keystore. At the command prompt, enter the
    following command. This will start the process of creating a keystore in a file
    named `keystore.jks`. The alias is another name that you can use to reference
    the keystore:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用keytool创建一个密钥库。在命令提示符下，输入以下命令。这将开始创建名为`keystore.jks`的文件中的密钥库的过程。别名是您可以用来引用密钥库的另一个名称：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will then be prompted for several pieces of information as follows. Respond
    to the prompts as appropriate. The passwords that you enter will not be displayed.
    For the examples in this chapter, we used a password of `password`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将提示您输入以下几个信息。根据提示进行适当的回应。您输入的密码不会显示出来。在本章的示例中，我们使用了密码`password`：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will then be prompted to confirm the input as follows. Respond with `yes`
    if the values are correct:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将提示您确认输入如下。如果值正确，请回复“是”：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can assign a separate password for the key, as shown next:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为密钥分配单独的密码，如下所示：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The keystore is then created. The contents of a keystore can be displayed using
    the `–list` argument, as shown next. The `–v` option produces verbose output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建密钥库。可以使用`-list`参数显示密钥库的内容，如下所示。`-v`选项会产生详细输出：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will display the following output. The keystore password needs to be entered
    along with the alias name:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下输出。需要输入密钥库密码以及别名：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Keytool command-line arguments
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Keytool命令行参数
- en: 'Entering the information for a keystore can be tedious. One way of simplifying
    this process is to use command line arguments. The following command will create
    the previous keystore:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 输入密钥库的信息可能会很繁琐。简化此过程的一种方法是使用命令行参数。以下命令将创建先前的密钥库：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You will note that there is not a matching double quote at the end of the command
    line. It is not needed. The command-line arguments are documented at the keytool
    website that was listed earlier.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到命令行末尾没有匹配的双引号。这不是必要的。命令行参数在之前列出的keytool网站上有文档记录。
- en: This tool can create both symmetric and asymmetric keys along with certificates.
    The following series of commands demonstrate several of these types of operations.
    We will create a keystore for a pair of asymmetric keys. A pair of certificates
    will then be exported that can be used with a server and client application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具可以创建对称密钥和非对称密钥以及证书。以下一系列命令演示了其中几种类型的操作。我们将为一对非对称密钥创建一个密钥库。然后将导出一对证书，可用于服务器和客户端应用程序。
- en: 'This command will create the `serverkeystore.jck` keystore file using the RSA
    algorithm with a key size of 1,024 bits and an expiration date of 365 days:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将使用RSA算法创建`serverkeystore.jck`密钥库文件，密钥大小为1,024位，到期日为365天：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This command generates a `clientkeystore.jck` keystore to be used by the client
    application:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令生成一个名为`clientkeystore.jck`的密钥库，供客户端应用程序使用：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A certificate file for the client is created next and is placed in the `client.crt`
    file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来创建客户端的证书文件，并放在`client.crt`文件中：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The server''s certificate is exported here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的证书在此导出：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A trust store is a file that is used to verify credentials, while a keystore
    will produce credentials. Credentials usually take the form of a certificate.
    Trust stores typically hold certificates from a trusted third party to form a
    certificate chain.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 信任库是用于验证凭据的文件，而密钥库会生成凭据。凭据通常采用证书的形式。信任库通常保存来自受信任第三方的证书，以形成证书链。
- en: 'The following command creates `the clienttruststore.jck` file, which is the
    trust store for the client:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令创建`clienttruststore.jck`文件，这是客户端的信任库：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This command generates the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令生成以下输出：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The trust store for the server is created with this command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令创建服务器的信任库：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Its output is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 其输出如下：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will now demonstrate how we can perform similar operations in Java.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将演示如何在Java中执行类似的操作。
- en: Creating and maintaining a keystore with Java
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Java创建和维护密钥库
- en: Keystores, their keys, and certificates can be created directly with Java code.
    In this section, we will demonstrate how to create a keystore that contains a
    secret key. We will use this class in the *Symmetric encryption client/server*
    section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥库、它们的密钥和证书可以直接使用 Java 代码创建。在本节中，我们将演示如何创建一个包含秘密密钥的密钥库。我们将在 *对称加密客户端/服务器* 部分使用这个类。
- en: 'The `SymmetricKeyStoreCreation` class is declared as follows. The `SymmetricKeyStoreCreation`
    method creates a keystore, while the `main` method generates and stores the secret
    key:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`SymmetricKeyStoreCreation` 类声明如下。`SymmetricKeyStoreCreation` 方法创建一个密钥库，而 `main`
    方法生成并存储秘密密钥：'
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `createKeyStore` method is described next. It is passed the keystore''s
    file name and a password. A `KeyStore` instance is created, which specifies a
    JCEKS keystore. If the keystore already exists, it will return that keystore:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来描述了 `createKeyStore` 方法。它传递密钥库的文件名和密码。创建了一个 `KeyStore` 实例，指定了一个 JCEKS 密钥库。如果密钥库已经存在，它将返回该密钥库：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `main` method, a `KeyGenerator` instance is created using the AES algorithm.
    The `generateKey` method will create the `SecretKey` instance, as shown here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 方法中，使用 AES 算法创建了一个 `KeyGenerator` 实例。`generateKey` 方法将创建 `SecretKey`
    实例，如下所示：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `KeyStore.SecretKeyEntry` class represents an entry in a keystore. We need
    this and an instance of the `KeyStore.PasswordProtection` class, which represents
    the password, to store the secret key:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyStore.SecretKeyEntry` 类表示密钥库中的条目。我们需要这个类和 `KeyStore.PasswordProtection`
    类的实例，它表示密码，来存储秘密密钥：'
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `setEntry` method uses a string alias, the keystore entry object, and the
    password to store the entry, as shown here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`setEntry` 方法使用字符串别名、密钥库条目对象和密码来存储条目，如下所示：'
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This entry is then written to the keystore:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将此条目写入密钥库：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Other keystore operations are possible using Java.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 其他密钥库操作可以使用 Java 实现。
- en: Symmetric encryption client/server
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称加密客户端/服务器
- en: This section demonstrates how to use symmetric encryption/decryption in a client/server
    application. The following example implements a simple echo client/server allowing
    us to focus on the basic process without digressing into specific client/server
    issues. The server is implemented with the `SymmetricEchoServer` class and client
    using the `SymmetricEchoClient` class.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本节演示了如何在客户端/服务器应用程序中使用对称加密/解密。以下示例实现了一个简单的回显客户端/服务器，使我们能够专注于基本过程，而不会偏离特定的客户端/服务器问题。服务器使用
    `SymmetricEchoServer` 类实现，客户端使用 `SymmetricEchoClient` 类。
- en: The client will encrypt a message and send it to the server. The server will
    then decrypt the message and send it back in plain text. The response can easily
    be encrypted if needed. This one-way encryption is sufficient to illustrate the
    basic process.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将加密消息发送到服务器。服务器将解密消息并以纯文本形式发送回来。如果需要，响应可以很容易地加密。这种单向加密足以说明基本过程。
- en: 'When running the applications that are discussed in this chapter in Windows,
    you may encounter the following dialog box. Select the **Allow access** button
    to allow the applications to run:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行本章讨论的应用程序时，在 Windows 中，您可能会遇到以下对话框。选择 **允许访问** 按钮以允许应用程序运行：
- en: '![Symmetric encryption client/server](img/B04915_08_01.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![对称加密客户端/服务器](img/B04915_08_01.jpg)'
- en: We will also use the `SymmetricKeyStoreCreation` class that was developed in
    symmetric encryption techniques.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用对称加密技术中开发的 `SymmetricKeyStoreCreation` 类。
- en: Symmetric server application
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对称服务器应用程序
- en: 'The symmetric server is declared next. It possesses a `main`, `decrypt`, and
    `getSecretKey` methods. The `decrypt` method takes the encrypted message from
    the client and decrypts it. The `getSecretKey` method will extract the secret
    key from the keystore that was created in symmetric encryption techniques. The
    `main` method contains the basic socket and streams that are used to communicate
    with the client:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来声明对称服务器。它拥有 `main`、`decrypt` 和 `getSecretKey` 方法。`decrypt` 方法从客户端接收加密消息并解密。`getSecretKey`
    方法将从对称加密技术中创建的密钥库中提取秘密密钥。`main` 方法包含用于与客户端通信的基本套接字和流：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `decrypt` method is the same one that was developed in symmetric encryption
    techniques, so it will not be repeated here. The `getSecretKey` method is described
    next. The `secretkeystore.jks` file that was created in symmetric encryption techniques
    holds the secret key. This method uses many of the same classes that are used
    in the `main` method of the `SymmetricKeyStoreCreation` class. An instance of
    the `KeyStore.PasswordProtection` class is used to extract the secret key from
    the keystore. The keystore password, `keystorepassword`, is hardcoded into the
    application. This is not the best practice, but it simplifies the example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`decrypt` 方法与对称加密技术中开发的方法相同，因此这里不再重复。接下来描述了 `getSecretKey` 方法。在对称加密技术中创建的 `secretkeystore.jks`
    文件保存了秘密密钥。此方法使用了与 `SymmetricKeyStoreCreation` 类的 `main` 方法中使用的许多相同的类。使用 `KeyStore.PasswordProtection`
    类的实例从密钥库中提取秘密密钥。密钥库密码 `keystorepassword` 被硬编码到应用程序中。这不是最佳实践，但它简化了示例：'
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `main` method is very similar to the server that was developed in [Chapter
    1](ch01.html "Chapter 1. Getting Started with Network Programming"), *Getting
    Started with Network Programming*. The main difference is within the while loop.
    Input from the client is passed to the `decrypt` method along with the secret
    key, as shown next. The decrypted text is then displayed and returned to the client:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法与在[第1章](ch01.html "第1章 网络编程入门")中开发的服务器非常相似，*网络编程入门*。主要区别在于 while 循环内。来自客户端的输入与秘密密钥一起传递给
    `decrypt` 方法，如下所示。然后显示解密后的文本并返回给客户端：'
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `main` method is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法如下：'
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, let's examine the client application.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下客户端应用程序。
- en: Symmetric client application
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对称客户端应用程序
- en: 'The client application is described next and is very similar to the client
    application that was developed in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with Network Programming"), *Getting Started with Network Programming*. It uses
    the same `getSecretKey` method that is used in the server. The `encrypt` method
    that was explained in symmetric encryption techniques is used to encrypt the user''s
    message. Both of these methods are not duplicated here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来描述客户端应用程序，它与[第1章](ch01.html "第1章 网络编程入门")中开发的客户端应用程序非常相似。它使用与服务器相同的`getSecretKey`方法。使用对称加密技术中解释的`encrypt`方法对用户消息进行加密。这两种方法都不在此处重复：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `main` method differs from the version in the while loop in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Network Programming"), *Getting Started with
    Network Programming*. The following statement encrypts the user message:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法与[第1章](ch01.html "第1章 网络编程入门")中的while循环版本不同。以下语句加密用户消息：'
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `main` method is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法如下：'
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We are now ready to see how the client and server interact.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备看客户端和服务器如何交互。
- en: Symmetric client/server in action
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对称客户端/服务器正在运行
- en: 'The applications behave the same way that they did in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Network Programming"), *Getting Started with
    Network Programming*. The only difference is that the message sent to the server
    is encrypted. This encryption is not visible in the application''s output other
    than the display of the encrypted text on the client side. One possible interaction
    is as follows. The server output is shown first:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的行为方式与[第1章](ch01.html "第1章 网络编程入门")中的方式相同。唯一的区别是发送到服务器的消息是加密的。除了在客户端显示加密文本之外，此加密在应用程序的输出中是不可见的。可能的交互如下。首先显示服务器输出：
- en: '**Simple Echo Server**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 简单回显服务器
- en: '**Waiting for connection.....**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 等待连接.....
- en: '**Connected to client**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 已连接到客户端
- en: '**Client request: The first message**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端请求：第一条消息
- en: '**Client request: The second message**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端请求：第二条消息
- en: '**Simple Echo Server Terminating**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 简单回显服务器终止
- en: 'The following is the client''s application output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是客户端应用程序的输出：
- en: '**Simple Echo Client**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 简单回显客户端
- en: '**Connected to server**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 已连接到服务器
- en: '**Enter text: The first message**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文本：第一条消息
- en: '**Encrypted Text After Encryption: drkvP3bhnfMXrZluFiqKb0RgjoDqFIJMCo97YqqgNuM=**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 加密后的文本加密后：drkvP3bhnfMXrZluFiqKb0RgjoDqFIJMCo97YqqgNuM=
- en: '**Server response: drkvP3bhnfMXrZluFiqKb0RgjoDqFIJMCo97YqqgNuM=**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应：drkvP3bhnfMXrZluFiqKb0RgjoDqFIJMCo97YqqgNuM=
- en: '**Enter text: The second message**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文本：第二条消息
- en: '**Encrypted Text After Encryption: fp9g+AqsVqZpxKMVNx8IkNdDcr9IGHb/qv0qrFinmYs=**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 加密后的文本加密后：fp9g+AqsVqZpxKMVNx8IkNdDcr9IGHb/qv0qrFinmYs=
- en: '**Server response: fp9g+AqsVqZpxKMVNx8IkNdDcr9IGHb/qv0qrFinmYs=**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应：fp9g+AqsVqZpxKMVNx8IkNdDcr9IGHb/qv0qrFinmYs=
- en: '**Enter text: quit**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文本：退出
- en: We will now duplicate this functionality using asymmetric keys.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用非对称密钥复制此功能。
- en: Asymmetric encryption client/server
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非对称加密客户端/服务器
- en: The `AsymmetricKeyUtility` class developed in asymmetric encryption techniques
    is used to support the client and server applications. We will use it's `encrypt`
    and `decrypt` methods. The structure of the client and server applications is
    similar to what was used in previous sections. The client will send the server
    an encrypted message, which the server will decrypt and then respond to with plain
    text.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持客户端和服务器应用程序时，使用了非对称加密技术开发的`AsymmetricKeyUtility`类。我们将使用它的`encrypt`和`decrypt`方法。客户端和服务器应用程序的结构与之前的部分相似。客户端将向服务器发送加密消息，服务器将解密后以纯文本形式回复。
- en: Asymmetric server application
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非对称服务器应用程序
- en: 'The `AsymmetricEchoServer` class, as declared next, is used for the server.
    The `main` method is its only method. A server socket is created, which blocks
    at the `accept` method waiting for client request:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所述，`AsymmetricEchoServer`类用于服务器。它的唯一方法是`main`方法。创建了一个服务器套接字，它在`accept`方法处阻塞，等待客户端请求：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Upon the acceptance of a client connection IO, streams are established and
    an `inputLine` byte array is instantiated with a size of `171`. This is the size
    of the message that is being sent, and using this value will avoid various exceptions:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接受客户端连接IO后，建立IO流，并实例化一个大小为`171`的`inputLine`字节数组。这是正在发送的消息的大小，使用此值将避免各种异常：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To perform the decryption, we need a private key. This is obtained using the
    `getPrivateKey` method:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行解密，我们需要一个私钥。这是使用`getPrivateKey`方法获取的：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A while loop will read in an encrypted message from the client. The `decrypt`
    method is called with the message and the private key. The decrypted message is
    then displayed and sent back to the client. If the message was `quit`, then the
    server terminates:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: while循环将从客户端读取加密消息。使用消息和私钥调用`decrypt`方法。然后显示解密的消息并发送回客户端。如果消息是`quit`，则服务器终止：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, let's examine the client application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查客户端应用程序。
- en: Asymmetric client application
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非对称客户端应用程序
- en: 'The client application is found in the `AsymmetricEchoClient` class, as shown
    next. It also possesses only a single `main` method. Once the server connection
    has been made, IO streams are established:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序位于`AsymmetricEchoClient`类中，如下所示。它还只有一个`main`方法。一旦建立了服务器连接，就会建立IO流：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `Scanner` class is used to get user input. A public key is used to encrypt
    the user messages and is obtained using the `AsymmetricKeyUtility` class''s `getPublicKey`
    method:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Scanner`类获取用户输入。使用公钥加密用户消息，并使用`AsymmetricKeyUtility`类的`getPublicKey`方法获取公钥：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the following while loop, the user is prompted for a message, which is encrypted
    using the `encrypt` method. The encrypted message is then sent to the server.
    If the message was `quit`, then the program terminates:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的while循环中，提示用户输入消息，然后使用`encrypt`方法对消息进行加密。然后将加密的消息发送到服务器。如果消息是`quit`，则程序终止：
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, we can use these applications together.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将这些应用程序一起使用。
- en: Asymmetric client/server in action
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非对称客户端/服务器操作
- en: 'Start the server and then the client. The client will prompt for a series of
    messages. The following shows the output of one possible interchange. The server
    side is shown first:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器，然后启动客户端。客户端将提示一系列消息。以下显示了一种可能的交互输出。首先显示服务器端：
- en: '**Simple Echo Server**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单回显服务器**'
- en: '**Waiting for connection.....**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待连接.....**'
- en: '**Connected to client**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接到客户端**'
- en: '**Client request: The first message**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端请求：第一条消息**'
- en: '**Client request: The second message**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端请求：第二条消息**'
- en: '**Client request: quit**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端请求：退出**'
- en: '**Simple Echo Server Terminating**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单回显服务器终止**'
- en: 'The following shows the client interaction:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了客户端的交互：
- en: '**Simple Echo Client**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单回显客户端**'
- en: '**Connected to server**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接到服务器**'
- en: '**Enter text: The first message**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：第一条消息**'
- en: '**[B@6bc168e5**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**[B@6bc168e5**'
- en: '**Server response: The first message**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器响应：第一条消息**'
- en: '**Enter text: The second message**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：第二条消息**'
- en: '**[B@7b3300e5**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**[B@7b3300e5**'
- en: '**Server response: The second message**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器响应：第二条消息**'
- en: '**Enter text: quit**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入文本：退出**'
- en: '**[B@2e5c649**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**[B@2e5c649**'
- en: TLS/SSL
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS/SSL
- en: TLS/SSL is a set of protocols that is used to secure many servers on the Internet.
    SSL is the successor to TLS. However, they are not always interchangeable. SSL
    uses the **Message Authentication Code** (**MAC**) algorithm, while TLS uses the
    **Hashing for Message Authentication Code** (**HMAC**) algorithm.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: TLS/SSL是用于保护互联网上许多服务器的一组协议。SSL是TLS的后继者。然而，它们并不总是可以互换使用。SSL使用**消息认证码**（**MAC**）算法，而TLS使用**用于消息认证码的哈希**（**HMAC**）算法。
- en: SSL is often used with a number of other protocols, including **File Transfer
    Protocol** (**FTP**), Telnet, **Net News Transfer Protocol** (**NNTP**), **Lightweight
    Directory Access Protocol** (**LDAP**), and **Interactive Message Access Protocol**
    (**IMAP**).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: SSL通常与许多其他协议一起使用，包括**文件传输协议**（**FTP**）、Telnet、**网络新闻传输协议**（**NNTP**）、**轻量级目录访问协议**（**LDAP**）和**交互式消息访问协议**（**IMAP**）。
- en: TLS/SSL does incur a performance hit in providing these capabilities. However,
    as internet speeds increase, the hit is not usually significant.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: TLS/SSL在提供这些功能方面确实会带来性能损失。然而，随着互联网速度的提高，这种损失通常并不显著。
- en: 'When the HTTPS protocol is used, a user will know because the protocol is normally
    present in the address field of a browser. It is even used in places where you
    may not expect it, such as in the following Google URL:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用HTTPS协议时，用户会知道，因为该协议通常出现在浏览器的地址栏中。甚至在您可能意想不到的地方也会使用，比如在以下Google URL中：
- en: '![TLS/SSL](img/B04915_08_02.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![TLS/SSL](img/B04915_08_02.jpg)'
- en: We will not delve into the details of how the SSL protocol works. However, a
    brief discussion of this protocol can be found at [http://www.javacodegeeks.com/2013/04/understanding-transport-layer-security-secure-socket-layer.html](http://www.javacodegeeks.com/2013/04/understanding-transport-layer-security-secure-socket-layer.html).
    In this section, we will illustrate how to create and use an SSL server and the
    Java classes that are used to support this protocol.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论SSL协议的工作原理。然而，可以在[http://www.javacodegeeks.com/2013/04/understanding-transport-layer-security-secure-socket-layer.html](http://www.javacodegeeks.com/2013/04/understanding-transport-layer-security-secure-socket-layer.html)找到对该协议的简要讨论。在本节中，我们将说明如何创建和使用SSL服务器以及支持该协议的Java类。
- en: To simplify the applications, the client sends a message to the server, which
    then displays it. No response is sent back to the client. The client connects
    to and communicates with the server using SSL. Returning the message to the client
    using SSL is left as an exercise for the reader.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化应用程序，客户端向服务器发送一条消息，然后服务器显示它。不会向客户端发送响应。客户端使用SSL连接到服务器并与之通信。使用SSL将消息返回给客户端留作读者的练习。
- en: SSL server
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSL服务器
- en: 'The server is implemented in the following `SSLServer` class. All of the code
    is found in the `main` method. We will use the `keystore.jks` keystore to access
    a secret key that was created in symmetric encryption techniques. To provide access
    to the keystore, a `Provider` instance is used to specify the keystore and its
    password. Hardcoding the password in code is not a good idea, but it is used to
    simplify this example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器实现在以下`SSLServer`类中。所有代码都在`main`方法中找到。我们将使用`keystore.jks`密钥库来访问在对称加密技术中创建的秘密密钥。为了提供对密钥库的访问，使用`Provider`实例来指定密钥库及其密码。在代码中硬编码密码并不是一个好主意，但为了简化这个例子，我们使用了它：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'An instance of the `SSLServerSocket` class is used to establish communications
    between a client and a server. This instance is created using the `SSLServerSocketFactory`
    class''s `getDefault` method. Similar to previous server sockets, the `accept`
    method blocks until a client connection is established:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`SSLServerSocket`类的一个实例用于在客户端和服务器之间建立通信。使用`SSLServerSocketFactory`类的`getDefault`方法创建此实例。与以前的服务器套接字类似，`accept`方法会阻塞，直到建立客户端连接：'
- en: '[PRE51]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'A `BufferedReader` instance is then created from the socket''s output stream:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从套接字的输出流创建了一个`BufferedReader`实例：
- en: '[PRE52]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following while loop reads the client request and displays it. If the message
    is `quit`, then the server terminates:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下while循环读取客户端请求并显示它。如果消息是`退出`，则服务器终止：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The SSL socket automatically handles encryption and decryption.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: SSL套接字会自动处理加密和解密。
- en: Note
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On a Mac, the server may throw exceptions when executed. This can be avoided
    by creating a PKCS12 keystore and using the `-Djavax.net.ssl.keyStoreType=pkcs12
    VM` option.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上执行时，服务器可能会抛出异常。可以通过创建PKCS12密钥库并使用`-Djavax.net.ssl.keyStoreType=pkcs12 VM`选项来避免这种情况。
- en: SSL client
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSL客户端
- en: 'The `SSLClient` class implements the client application, as shown next. It
    uses essentially the same process as the server. The while loop handles user input
    in the same way that was performed in previous client applications:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`SSLClient`类实现了客户端应用程序，如下所示。它基本上使用与服务器相同的过程。while循环以与以前的客户端应用程序相同的方式处理用户输入：'
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Let's see how they interact.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它们是如何交互的。
- en: SSL client/server in action
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TLS/SSL客户端/服务器操作
- en: 'Start the server and then the client. In the following output, three messages
    are sent to the server and then displayed:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器，然后启动客户端。在以下输出中，向服务器发送了三条消息，然后显示：
- en: '**SSL Server Started**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSL服务器已启动**'
- en: '**Waiting for a connection**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待连接**'
- en: '**Connection established**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接已建立**'
- en: '**Receiving: The first message**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收：第一条消息**'
- en: '**Receiving: The second message**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收：第二条消息**'
- en: 'The client input is shown here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端输入如下所示：
- en: '**SSL Client Started**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSL客户端已启动**'
- en: '**Connection to SSL Server Established**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**已建立与SSL服务器的连接**'
- en: '**Enter a message: The first message**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入消息：第一条消息**'
- en: '**Sending: The first message**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送：第一条消息**'
- en: '**Enter a message: The second message**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入消息：第二条消息**'
- en: '**Sending: The second message**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送：第二条消息**'
- en: '**Enter a message: quit**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入消息：退出**'
- en: '**Sending: quit**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送：退出**'
- en: The `SSLServerSocket` class provides a simple way of implementing SSL-enabled
    servers.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`SSLServerSocket`类提供了一种简单的实现SSL启用服务器的方法。'
- en: Secure hash functions
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全哈希函数
- en: A secure hash function will generate a large number, called the hash value,
    when given a document of some sort. This document can be of almost any type. We
    will be using simple strings in our examples.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 安全哈希函数将在给定某种文档时生成一个称为哈希值的大数字。这个文档可以是几乎任何类型。我们将在我们的示例中使用简单的字符串。
- en: The function is a one-way hash function, which means that it is effectively
    impossible to recreate the document when given a hash value. When used in conjunction
    with asymmetric keys, it allows the transmission of a document with the guarantee
    that the document has not been altered.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数是单向哈希函数，这意味着在给定哈希值时，实际上不可能重新创建文档。当与非对称密钥一起使用时，它允许传输文档，并保证文档未被更改。
- en: The sender of a document will use a secure hash function to generate the hash
    value for a document. The sender will encrypt this hash value with their private
    key. The document and the key are then combined and sent to a receiver. The document
    is not encrypted.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的发送方将使用安全哈希函数为文档生成哈希值。发送方将使用他们的私钥加密此哈希值。然后将文档和密钥组合并发送给接收方。文档未加密。
- en: Upon receiving the document, the receiver will use the sender's public key to
    decrypt the hash value. The receiver will then use the same secure hash function
    against the document to obtain a hash value. If this hash value matches the decrypted
    hash value, then the receiver is guaranteed that the document has not been modified.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收文档后，接收方将使用发送方的公钥解密哈希值。然后接收方将使用相同的安全哈希函数对文档进行哈希值计算。如果此哈希值与解密的哈希值匹配，则接收方保证文档未被修改。
- en: The intent is not to encrypt the document. While possible, this approach is
    useful when it is not important to hide the document from third parties but to
    only provide a guarantee that the document has not been modified.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 意图不是加密文档。虽然可能，但当不重要隐藏文档免受第三方查看，只需提供文档未被修改的保证时，这种方法是有用的。
- en: 'Java supports the following hashing algorithms:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Java支持以下哈希算法：
- en: '**MD5**: The default size is 64 bytes'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MD5**：默认大小为64字节'
- en: '**SHA1**: The default size is 64 bytes'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SHA1**：默认大小为64字节'
- en: 'We will use the SHA hash function for our examples. This series of functions
    was developed by the **National Security Agency** (**NSA**). There are three versions
    of this hash function: SHA-0, SHA-1, and SHA-2\. The SHA-2 is the more secure
    algorithm and uses variable digest sizes: SHA-224, SHA-256, SHA-384, and SHA-512.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的示例中使用SHA哈希函数。这一系列函数是由**国家安全局**（**NSA**）开发的。这个哈希函数有三个版本：SHA-0，SHA-1和SHA-2。SHA-2是更安全的算法，并使用可变的摘要大小：SHA-224，SHA-256，SHA-384和SHA-512。
- en: 'The `MessageDigest` class works with arbitrary-sized data producing a fixed
    size hash value. There are no public constructors for this class. The `getInstance`
    method returns an instance of the class when given the name of the algorithm.
    Valid names are found at [http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest](http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest).
    In this example, we use `SHA-256`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageDigest`类处理任意大小的数据，生成固定大小的哈希值。这个类没有公共构造函数。`getInstance`方法在给定算法名称时返回类的实例。有效名称可以在[http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest](http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest)找到。在这个例子中，我们使用`SHA-256`：'
- en: '[PRE55]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The complete example, which is adapted from [http://www.mkyong.com/java/java-sha-hashing-example/](http://www.mkyong.com/java/java-sha-hashing-example/),
    is shown next. The `displayHashValue` method extracts individual hash value bytes
    and converts them to a printable format:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例，改编自[http://www.mkyong.com/java/java-sha-hashing-example/](http://www.mkyong.com/java/java-sha-hashing-example/)，如下所示。`displayHashValue`方法提取单个哈希值字节并将其转换为可打印格式。
- en: '[PRE56]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Execute the program. This will produce the following output:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 执行程序。这将产生以下输出：
- en: '**Hash Value: 83c660972991049c25e6cad7a5600fc4d7c062c097b9a75c1c4f13238375c26c**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希值：83c660972991049c25e6cad7a5600fc4d7c062c097b9a75c1c4f13238375c26c**'
- en: A more detailed examination of secure hashing functions that are implemented
    in Java can be found at [http://howtodoinjava.com/2013/07/22/how-to-generate-secure-password-hash-md5-sha-pbkdf2-bcrypt-examples/](http://howtodoinjava.com/2013/07/22/how-to-generate-secure-password-hash-md5-sha-pbkdf2-bcrypt-examples/).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中实现的安全哈希函数的更详细的介绍可以在[http://howtodoinjava.com/2013/07/22/how-to-generate-secure-password-hash-md5-sha-pbkdf2-bcrypt-examples/](http://howtodoinjava.com/2013/07/22/how-to-generate-secure-password-hash-md5-sha-pbkdf2-bcrypt-examples/)找到。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced several Java approaches to secure communications
    between applications. We started with a brief introduction to security-related
    terms and followed the introduction with a more detailed discussion later.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了几种Java应用程序之间安全通信的方法。我们从安全相关术语的简要介绍开始，然后进行了更详细的讨论。
- en: There are two common encryption/decryption approaches that are used today. The
    first is symmetric key encryption, which uses a single key that is shared between
    the applications. This approach requires that the key be transmitted between the
    applications in a secure fashion.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 今天有两种常见的加密/解密方法。第一种是对称密钥加密，它使用一个在应用程序之间共享的单个密钥。这种方法要求密钥以安全的方式在应用程序之间传输。
- en: The second approach uses asymmetric encryption. This technique uses a private
    and a public key. A message encrypted with one of these keys can be decrypted
    with the other key. Normally, the public key is distributed using a certificate
    from a trusted source. The holder of the private key needs to secure it so that
    no one else has access to it. The public key is freely shared with anyone who
    needs it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法使用非对称加密。这种技术使用私钥和公钥。使用其中一个密钥加密的消息可以用另一个密钥解密。通常，公钥是使用来自受信任来源的证书进行分发的。私钥的持有者需要确保它没有被其他人访问。公钥可以自由地与需要它的任何人分享。
- en: Cryptographic keys are usually stored in a keystore that permit programmatic
    access to the keys. The keystore is created and maintained with the keytool application.
    We demonstrated the creation and use of a keystore in several of our applications.
    In addition, we used both a symmetric key and an asymmetric key pair to support
    an echo client/server application.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 加密密钥通常存储在允许程序访问密钥的密钥库中。密钥库是使用keytool应用程序创建和维护的。我们演示了在我们的几个应用程序中创建和使用密钥库。此外，我们使用对称密钥和非对称密钥对来支持回显客户端/服务器应用程序。
- en: A more common way of creating secure clients and servers uses the `SSLServerSocket`
    class. This performs the automatic encryption and decryption of data based on
    a secret key found in a keystore. We demonstrated how the class can be used in
    a server and client application.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 创建安全客户端和服务器的更常见方法是使用`SSLServerSocket`类。这个类基于密钥库中的秘密密钥执行数据的自动加密和解密。我们演示了这个类如何在服务器和客户端应用程序中使用。
- en: We also examined the use of secure hash functions. This technique allows unencrypted
    data to be transferred and guarantees that it has not been modified. An asymmetric
    key pair is used to encrypt the hash value. We provided a simple example of this
    process.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了安全哈希函数的使用。这种技术允许未加密的数据被传输，并保证它没有被修改。非对称密钥对用于加密哈希值。我们提供了这个过程的一个简单示例。
- en: In the next chapter, we will investigate the various factors that affect the
    interaction between distributed applications.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将调查影响分布式应用程序之间交互的各种因素。
