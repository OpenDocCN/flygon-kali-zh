- en: Developing a Weather Widget
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发天气小部件
- en: Hey! Good work with the Video Call app. Hope you made some calls to your friends.
    In the previous chapter, we built a Video Call app using the SimpleWebRTC framework.
    Isn't it great to know that you can build all these cool applications with JavaScript?
    You have the power to access the user's device hardware straight from the browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿！视频通话应用做得不错。希望你已经给你的朋友打了一些电话。在上一章中，我们使用了SimpleWebRTC框架构建了一个视频通话应用。知道你可以用JavaScript构建所有这些酷炫的应用程序真是太棒了，你可以直接从浏览器访问用户设备的硬件。
- en: So far, you have been building entire applications by yourself, so you had complete
    knowledge of the app's structure, such as the classes and IDs used in HTML and
    CSS and the classes, functions, and services used in JavaScript. But in the real
    world, you seldom work alone. If anything, you work in teams of sizes ranging
    from a few members to hundreds of developers working across the globe. In this
    case, you will not have knowledge about the entire web application. For this chapter,
    you are part of a huge web application project. You are in your first week of
    work and then your manager walks in and hands you your task for the week.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在独自构建整个应用程序，所以你对应用程序的结构有完整的了解，比如在HTML和CSS中使用的类和ID，以及在JavaScript中使用的类、函数和服务。但在现实世界中，你很少是独自工作。如果有的话，你会在由几名成员到数百名开发人员组成的团队中工作。在这种情况下，你将不会对整个Web应用程序有完整的了解。
- en: Can you build a Weather Widget?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你能构建一个天气小部件吗？
- en: So, your project has around 40 developers working in different parts of the
    web application and a new requirement just popped up. They need to show a Weather
    Widget in some areas of the website. The Weather Widget needs to be responsive
    so that it can squeeze into any available space in any section of the web application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你的项目有大约40名开发人员在Web应用程序的不同部分工作，突然出现了一个新的需求。他们需要在网站的某些区域显示一个天气小部件。天气小部件需要是响应式的，这样它就可以适应Web应用程序的任何部分中的任何可用空间。
- en: We can surely build a Weather Widget but there is a problem. We have no idea
    about the rest of the web application! For example, what are the class and ID
    used in its HTML, since the styles created by CSS are always global? If we were
    to accidentally use a class that is already being used in some other part of the
    HTML in the web application, our widget will inherit the style of that DOM element,
    which we really need to avoid!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以构建一个天气小部件，但有一个问题。我们对Web应用程序的其余部分一无所知！例如，它的HTML中使用了哪些类和ID，因为CSS创建的样式总是全局的。如果我们不小心使用了在Web应用程序的其他部分中已经使用的类，我们的小部件将继承该DOM元素的样式，这是我们真的需要避免的！
- en: 'Another problem is will be that we would have created `<div>`. For example:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是我们将创建`<div>`。例如：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Along with a CSS file and some JS files, we have all the logic needed to make
    our widget work. But how are we going to deliver it to the rest of the team (given
    we didn't hopefully reuse any other used class names or IDs from the web app in
    the widget)?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CSS文件和一些JS文件，我们还需要所有必要的逻辑来使我们的小部件工作。但是我们要如何将它交付给团队的其他成员呢（假设我们没有希望在小部件中重用任何其他Web应用程序中使用的类名或ID）？
- en: If it were a simple JavaScript module, we simply build an ES6 module, which
    the team can import and use, since the scope of variables in the ES6 modules do
    not leak out (you should only use `let` and `const`; you really don't want to
    accidentally create a global variable with `var`). But it's a different story
    for HTML and CSS. Their scope is always global and they always need to be handled
    with care (you don't want some one else in the team to accidentally tamper with
    your widget)!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个简单的JavaScript模块，我们只需构建一个ES6模块，团队可以导入和使用，因为ES6模块中的变量作用域不会泄漏（你应该只使用`let`和`const`；你真的不想意外地使用`var`创建全局变量）。但对于HTML和CSS来说情况就不同了。它们的作用域总是全局的，它们总是需要小心处理（你不希望团队中的其他人意外地篡改你的小部件）！
- en: So, let's get started! We are going to think of some really random (and cool!)
    class names and IDs for the DOM elements, which no one else in your team can think
    of and then write a 10 page `readme` file to document the working of the Weather
    Widget with all the dos and don'ts and then later spend our time working on carefully
    updating the `readme` file whenever we do some enhancements and bug fixes to the
    widget. Also, be sure to memorize all the class names and the IDs!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧！我们将考虑一些真正随机（而且酷！）的类名和ID，用于DOM元素，你的团队中没有人能想到，然后编写一个10页的`readme`文件，记录天气小部件的工作原理，包括所有的注意事项，然后在我们对小部件进行一些增强和错误修复时，花时间仔细更新`readme`文件。还要记住所有的类名和ID！
- en: 'About the last paragraph, Nope! We are definitely not going to do that! I''m
    already getting goosebumps thinking about it! Instead, we are going to learn about web
    components and we are going to write a simple ES6 module, which should be imported
    by the rest of your team members and then they should simply add the following
    DOM element in their HTML file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 关于最后一段，不！我们绝对不会这样做！我已经开始想象了！相反，我们将学习web组件，并编写一个简单的ES6模块，应该由你的团队成员导入和使用，然后他们应该在他们的HTML文件中简单地添加以下DOM元素：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That's it! You need to build a DOM element (such as the `<input>`, `<p>`, and
    `<div>` elements), which will show a Weather Widget. `x-weather` is a new HTML5
    *custom element*, which we are going to build in this chapter. It is going to
    overcome all the problems we might face in the previous approach.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！你需要构建一个DOM元素（比如`<input>`、`<p>`和`<div>`元素），它将显示一个天气小部件。`x-weather`是一个新的HTML5
    *自定义元素*，我们将在本章中构建它。它将克服我们在之前方法中可能遇到的所有问题。
- en: Introduction to web components
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍web组件
- en: 'Web components are a set of four different technologies that can be used together
    or separately to build reusable user interface widgets. Just as we can create
    reusable modules using JavaScript, we can create reusable DOM elements with web
    component technologies. The four technologies that form the web components are:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Web组件是一组可以一起或分开使用的四种不同技术，用于构建可重用的用户界面小部件。就像我们可以使用JavaScript创建可重用模块一样，我们可以使用Web组件技术创建可重用的DOM元素。构成Web组件的四种技术是：
- en: Custom elements
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义元素
- en: HTML templates
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML模板
- en: Shadow DOM
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影子DOM
- en: HTML imports
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML导入
- en: The web components were created to provide developers simple APIs to build highly
    reusable DOM elements. There are many JavaScript libraries and frameworks that
    focus on providing reusability by organizing the entire web application into simpler
    components, such as React, Angular, Vue, Polymer, and so on. In the next chapter,
    we are going to build an entire web application by putting together multiple independent
    React components. However, despite all the frameworks and libraries available,
    web components hold a big advantage, since they are supported natively by the
    browser, which means no additional libraries to increase the size of your widget.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Web组件是为开发人员提供简单API以构建高度可重用DOM元素而创建的。有许多JavaScript库和框架专注于通过将整个Web应用程序组织成更简单的组件来提供可重用性，例如React、Angular、Vue、Polymer等。在下一章中，我们将通过组合多个独立的React组件来构建整个Web应用程序。然而，尽管所有可用的框架和库，Web组件具有很大的优势，因为它们受到浏览器的本地支持，这意味着不需要额外的库来增加小部件的大小。
- en: For our widget, we are going to use custom elements and shadow DOM. Before we
    start building our widget, let's take a quick look into the other two, which we
    will not use in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的小部件，我们将使用自定义元素和影子DOM。在开始构建小部件之前，让我们快速了解其他两个，这两个在本章中不会使用。
- en: Web components are a new standard and they are actively being implemented by
    all the browser vendors. However, at the time of writing this book, *only Chrome
    supports all the features of the web components*. If you want to check whether
    your browser supports web components, visit: [http://jonrimmer.github.io/are-we-componentized-yet/](http://jonrimmer.github.io/are-we-componentized-yet/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Web组件是一个新的标准，所有浏览器供应商都在积极实施。然而，在撰写本书时，*只有Chrome支持Web组件的所有功能*。如果要检查浏览器是否支持Web组件，请访问：[http://jonrimmer.github.io/are-we-componentized-yet/](http://jonrimmer.github.io/are-we-componentized-yet/)。
- en: You should only use Chrome for the project in this chapter, since other browsers
    do not yet have proper support for web components. At the end of this chapter,
    we'll discuss how to add polyfills to make web components work in all the browsers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的项目中，您应该只使用Chrome，因为其他浏览器尚未完全支持Web组件。在本章结束时，我们将讨论如何添加polyfill以使Web组件在所有浏览器中工作。
- en: HTML templates
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML模板
- en: An HTML template is a simple `<template>` tag, which we can add in our DOM.
    However, even if we add it in our HTML, the contents of the `<template>` element
    will not get rendered. If it contains any external resources, such as images,
    CSS, and JS files, they will also not get loaded into our application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: HTML模板是一个简单的`<template>`标签，我们可以将其添加到我们的DOM中。但是，即使将其添加到我们的HTML中，`<template>`元素的内容也不会被呈现。如果它包含任何外部资源，例如图像、CSS和JS文件，它们也不会加载到我们的应用程序中。
- en: 'Hence, the template element only holds some HTML content, which can be used
    later by JavaScript. For example, say you have the following template element:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模板元素只包含一些HTML内容，稍后可以由JavaScript使用。例如，假设您有以下模板元素：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This element holds `div` that will not be rendered by the browser. However,
    we can create a reference of that `div` using JavaScript, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素包含浏览器不会呈现的`div`。但是，我们可以使用JavaScript创建该`div`的引用，如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we can make any changes to this reference and add it to our DOM. Even better,
    we can make a deep copy of this element so that we can use it in multiple places.
    A deep copy is a copy of the object in which changes to the copy will not be reflected
    in the original. By default, JavaScript always makes a shallow copy of the object
    when we do an assignment using the `=` operator. `$template` is a shallow copy
    of the DOM element, which we call as a reference to the DOM element. Hence, any
    change to `$template` is reflected in the DOM. But if we make a deep copy of `$template`,
    then the changes to that deep copy will not be reflected in the DOM, since it
    won't affect `$template`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以对此引用进行任何更改，并将其添加到我们的DOM中。更好的是，我们可以对此元素进行深层复制，以便我们可以在多个地方使用它。深层复制是对象的副本，对副本的更改不会反映在原始对象中。默认情况下，当我们使用`=`运算符进行赋值时，JavaScript总是对对象进行浅层复制。`$template`是DOM元素的浅层复制，我们称之为对DOM元素的引用。因此，对`$template`的任何更改都会反映在DOM中。但是，如果我们对`$template`进行深层复制，那么对该深层复制的更改将不会反映在DOM中，因为它不会影响`$template`。
- en: 'To make a deep clone of a DOM element, we can use the `document.importNode()`
    method. It accepts two parameters: the first one is the DOM element it needs to
    clone and the second one is a boolean for whether it needs to be a deep copy.
    If the second argument is true, it will make a deep copy of the element. See the
    following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要对DOM元素进行深层克隆，我们可以使用`document.importNode()`方法。它接受两个参数：第一个是它需要克隆的DOM元素，第二个是一个布尔值，用于指定是否需要进行深层复制。如果第二个参数为true，则它将对元素进行深层复制。请参阅以下代码：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, I made a deep copy of the contents of the template element (`$template.content`)
    in the `$javascript` object and added `$javascript` to the DOM element. Any modifications
    to `$javascript` will not affect `$template`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我对模板元素（`$template.content`）的内容进行了深层复制，并将`$javascript`添加到了DOM元素。对`$javascript`的任何修改都不会影响`$template`。
- en: For a more detailed example, I have set up a JSFiddle at: [https://jsfiddle.net/tgf5Lc0v/](https://jsfiddle.net/tgf5Lc0v/).
    Do check it out to see the working of the template elements in action.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更详细的示例，我在JSFiddle上设置了一个示例：[https://jsfiddle.net/tgf5Lc0v/](https://jsfiddle.net/tgf5Lc0v/)。请查看它，以查看模板元素的工作方式。
- en: HTML imports
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML导入
- en: 'HTML imports are simple. They let you import an HTML document inside another
    HTML document in the same way as you include CSS and JS files. The import statement
    looks as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: HTML导入很简单。它们允许你以与包含CSS和JS文件相同的方式在一个HTML文档中导入另一个HTML文档。导入语句如下所示：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: HTML imports have a lot of benefits when we work in an environment that *does
    not* use a build tool such as Webpack; for example delivering the web components
    for use across the web application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们不使用Webpack等构建工具的环境中，HTML导入有很多好处；例如，为跨Web应用程序使用Web组件提供了便利。
- en: 'For more information regarding using the HTML imports feature, refer to the
    html5rocks tutorial at: [https://www.html5rocks.com/en/tutorials/webcomponents/imports/](https://www.html5rocks.com/en/tutorials/webcomponents/imports/).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用HTML导入功能的更多信息，请参考html5rocks教程：[https://www.html5rocks.com/en/tutorials/webcomponents/imports/](https://www.html5rocks.com/en/tutorials/webcomponents/imports/)。
- en: The main reason why we are not going to use HTML templates and HTML imports
    in our Weather Widget is that they are more focused on usage with HTML files.
    Our build system that we are going to use in this chapter (Webpack) works better
    with JavaScript files. So, we'll continue with the rest of the chapter, learning
    about custom elements and shadow DOM.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用HTML模板和HTML导入在我们的天气小部件中的主要原因是它们更专注于与HTML文件一起使用。我们将在本章中使用的构建系统（Webpack）更适合JavaScript文件。因此，我们将继续学习本章的其余部分，了解自定义元素和影子DOM。
- en: Building the Weather Widget
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建天气小部件
- en: For this chapter, we need a server to fetch weather information for a given
    location. In the browser, we can use navigator object to retrieve the exact geolocation
    (`latitude` and `longitude`) of the user. Then, using these coordinates, we need
    to find the name of the region and its weather information. For this purpose,
    we need to use third-party weather providers and the Google Maps API, which we
    used in [Chapter 3](part0075.html#27GQ60-f852807d0cb141b58fff8f992d32cbb7)*, Event
    Registration App*. The weather provider we are going to use in this project is
    **Dark Sky**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们需要一个服务器来获取给定位置的天气信息。在浏览器中，我们可以使用navigator对象来检索用户的确切地理位置（`纬度`和`经度`）。然后，使用这些坐标，我们需要找到该地区的名称和其天气信息。为此，我们需要使用第三方天气提供商和我们在[第3章](part0075.html#27GQ60-f852807d0cb141b58fff8f992d32cbb7)*，事件注册应用*中使用的谷歌地图API。我们在这个项目中将使用的天气提供商是**Dark
    Sky**。
- en: 'Let''s set up the server for the Weather Widget. Open up the `Chapter05\Server`
    directory in the book code. Inside the server directory, first run `npm install`
    to install all the dependencies. You need to get the API keys for both Dark Sky
    and Google Maps. You might already have the Google Map API key, since we used
    it recently. To generate your API keys for both the services, do the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为天气小部件设置服务器。打开书中代码的`Chapter05\Server`目录。在服务器目录内，首先运行`npm install`来安装所有依赖项。你需要获取Dark
    Sky和谷歌地图的API密钥。你可能已经有了谷歌地图API密钥，因为我们最近使用过它。为了为这两项服务生成API密钥，执行以下操作：
- en: '**Dark Sky**: Sign up for a free account at: [https://darksky.net/dev/](https://darksky.net/dev/),
    and then you will get a secret key.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dark Sky**：在[https://darksky.net/dev/](https://darksky.net/dev/)注册一个免费帐户，然后你将获得一个秘钥。'
- en: '**Google Maps**: Follow the steps provided at: [https://developers.google.com/maps/documentation/javascript/get-api-key](https://developers.google.com/maps/documentation/javascript/get-api-key).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谷歌地图**：按照提供的步骤进行操作：[https://developers.google.com/maps/documentation/javascript/get-api-key](https://developers.google.com/maps/documentation/javascript/get-api-key)。'
- en: 'Once you get both the keys, create a `.env` file inside the `Server` root directory
    and add the keys inside it in the following format:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了这两个密钥，就在`Server`根目录内创建一个`.env`文件，并以以下格式将密钥添加到其中：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once you have added the keys, run `npm start` in the terminal from the `Server`
    root directory to start the server. The server will be running at the `http://localhost:3000/`
    URL.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 添加完密钥后，从`Server`根目录在终端中运行`npm start`来启动服务器。服务器将在`http://localhost:3000/` URL上运行。
- en: 'We have the server ready. Let''s set up the starter files for the project.
    Open up the `Chapter05\Starter` files and then run `npm install` inside that directory
    to install all the dependencies. Create a `.env` file in the project root directory
    and add the following lines inside it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好服务器。让我们为项目设置起始文件。打开`Chapter05\Starter`文件夹，然后在该目录内运行`npm install`来安装所有依赖项。在项目根目录中创建一个`.env`文件，并在其中添加以下行：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just as we did in the previous chapter, we should set `NODE_ENV=production`
    for generating production builds. `SERVER_URL` will contain the URL of the project's
    server that we just set up. Both `NODE_ENV` and `SERVER_URL` will be available
    as global variables for the JavaScript code in our app (I have used the Webpack
    defined plugin in `webpack.config.js`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在上一章中所做的那样，我们应该设置`NODE_ENV=production`来生成生产构建。`SERVER_URL`将包含我们刚刚设置的项目服务器的URL。`NODE_ENV`和`SERVER_URL`将作为全局变量在我们应用程序的JavaScript代码中可用（我已经在`webpack.config.js`中使用了Webpack定义的插件）。
- en: 'Finally, execute `npm run watch` in the Terminal to start the Webpack dev server.
    You will have your project running in `http://localhost:8080/` (the project URL
    will be printed in the Terminal). Currently, the web app will display three texts:
    large, medium, and small. It has three containers of different sizes, which will
    hold the Weather Widget. At the end of the project, the Weather Widget will look
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在终端中执行`npm run watch`来启动Webpack开发服务器。你的项目将在`http://localhost:8080/`上运行（项目URL将在终端中打印出来）。目前，Web应用将显示三个文本：大、中、小。它有三个不同大小的容器，将容纳天气小部件。项目结束时，天气小部件将如下所示：
- en: '![](../images/00032.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00032.jpeg)'
- en: Working of the Weather Widget
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 天气小部件的工作
- en: 'Let''s strategize the working of our Weather Widget. Since our Weather Widget
    is an HTML custom element, it should work just like other native HTML elements.
    For example, consider the `<input>` element:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们规划一下我们的天气小部件的工作。由于我们的天气小部件是一个HTML自定义元素，它应该像其他原生HTML元素一样工作。例如，考虑`<input>`元素：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will render a normal text input. However, we can use the same `<input>`
    element with a different attribute, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将呈现一个普通的文本输入。但是，我们可以使用相同的`<input>`元素，具有不同的属性，如下所示：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It will render a password field instead of the text field with all the input
    text content hidden. Likewise, for our Weather Widget, we need to display the
    current weather condition for a given location. The best way to pinpoint the user's
    location is to use the HTML5 geolocation, which will get the user's current latitude
    and longitude information directly from the browser.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 它将呈现一个密码字段，而不是将所有输入文本内容隐藏的文本字段。同样，对于我们的天气小部件，我们需要显示给定位置的当前天气状况。确定用户位置的最佳方法是使用HTML5地理位置，它将直接从浏览器中获取用户当前的纬度和经度信息。
- en: 'However, we should make our widget customizable for the rest of the developers.
    They might want to manually set a location for our Weather Widget. So, we''ll
    leave the logic to retrieve the location to other developers. Instead, we can
    manually accept `latitude` and `longitude` as attributes for our Weather Widget.
    Our weather element will look as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们应该使我们的小部件可定制给其他开发人员。他们可能希望手动为我们的天气小部件设置位置。因此，我们将把检索位置的逻辑留给其他开发人员。相反，我们可以手动接受`纬度`和`经度`作为天气小部件的属性。我们的天气元素将如下所示：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we can read `latitude` and `longitude` from the respective attributes and
    set the weather information in our widget, and other developers can easily customize
    the location by simply changing the values of the `latitude` and `longitude` attributes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从各自的属性中读取`纬度`和`经度`，并在我们的小部件中设置天气信息，其他开发人员可以通过简单地更改`纬度`和`经度`属性的值来轻松定制位置。
- en: Retrieving the geolocation
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索地理位置
- en: 'Before we start building the widget, let''s take a look at the steps to retrieve
    the user''s geolocation. In your `src/js/home.js` file, you should see an import
    statement, which will import the CSS into the web application. Below that import
    statement, add the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建小部件之前，让我们看一下检索用户地理位置的步骤。在您的`src/js/home.js`文件中，您应该看到一个导入语句，该语句将CSS导入Web应用程序。在该导入语句下面，添加以下代码：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will call the `getLocation()` function when the page completes loading.
    Inside this function, we must first check whether the `navigator.geolocation`
    method is available in the browser. If it is available, we can use the `navigator.geolocation.getCurrentPosition()`
    method to retrieve the user's geolocation. This method accepts two functions as
    parameters. The first function will be called when the location is retrieved successfully
    and the second function is called if the location cannot be retrieved.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载完成时，这将调用`getLocation()`函数。在此函数内部，我们必须首先检查浏览器中是否可用`navigator.geolocation`方法。如果可用，我们可以使用`navigator.geolocation.getCurrentPosition()`方法来检索用户的地理位置。此方法接受两个函数作为参数。当成功检索位置时，将调用第一个函数，如果无法检索位置，则调用第二个函数。
- en: 'In your `home.js` file, add the following functions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`home.js`文件中，添加以下函数：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Open the app in Chrome. The page should ask you for permission to access your
    location, just as it did for accessing the camera and microphone in the previous
    chapter. If you click Allow, you should see your current `latitude` and `longitude`
    printed in Chrome's console.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome中打开应用程序。页面应该要求您允许访问您的位置，就像在上一章中访问摄像头和麦克风一样。如果单击“允许”，您应该在Chrome的控制台中看到您当前的`纬度`和`经度`。
- en: 'The preceding code does the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: First, the `getLocation()` function will use the `navigator.getlocation.getCurrentPosition(showPosition,
    errorPosition)` method to get the location of the user.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`getLocation()`函数将使用`navigator.getlocation.getCurrentPosition(showPosition,
    errorPosition)`方法获取用户的位置。
- en: If you click Allow when the page asks for permission, then it will call the `showPosition`
    function with the `position` object as a parameter.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果页面请求权限时单击“允许”，则会调用`showPosition`函数，并将`position`对象作为参数。
- en: If you click Block, then it will call the `errorPosition` function with the
    `error` object as a parameter.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您单击“Block”，则会调用`errorPosition`函数，并将`error`对象作为参数。
- en: The `position` object contains the latitude and longitude of the user in the
    `position.coords` property. This function will print the latitude and longitude
    in the console.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position`对象包含用户的纬度和经度，位于`position.coords`属性中。此函数将在控制台中打印纬度和经度。'
- en: For more information regarding the usage of the geolocation, refer to the MDN
    page: [https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用地理位置的更多信息，请参阅MDN页面：[https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation)。
- en: Creating the weather custom element
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建天气自定义元素
- en: 'We have the geolocation. So, let''s start creating the custom element. Currently,
    your folder structure will be as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经获得了地理位置。因此，让我们开始创建自定义元素。当前，您的文件夹结构将如下所示：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We want to keep our custom element to be independent of other JavaScript modules.
    Inside the `src/js` directory, create a file under the path `CustomElements/Weather/Weather.js`.
    Do note that I have used capital letters for the first letters in the folder and
    filenames (PascalCase). You can use PascalCase for files and folders, which will
    export an entire class. This is only for easily identifying classes in your project
    folder and need not be a strictly followed rule.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望保持我们的自定义元素独立于其他JavaScript模块。在`src/js`目录中，创建一个文件，路径为`CustomElements/Weather/Weather.js`。请注意，我在文件夹和文件名（PascalCase）中使用了大写字母。您可以对文件和文件夹使用PascalCase，这将导出整个类。这仅用于在项目文件夹中轻松识别类，并不需要严格遵循规则。
- en: 'Now, your folder structure will become:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的文件夹结构将变为：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Open the `Weather.js` file in VSCode. All the native HTML elements are implemented
    using the `HTMLElement` class (interface) either directly or through an interface
    that inherits it. For our custom weather element, we need to create a class that
    extends `HTMLElement`. By extending a class, we can inherit the properties and
    methods of the parent class. In your `Weather.js` file, write the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在VSCode中打开`Weather.js`文件。所有原生HTML元素都是使用`HTMLElement`类（接口）直接实现的，或者通过继承它的接口实现的。对于我们的自定义天气元素，我们需要创建一个扩展`HTMLElement`的类。通过扩展一个类，我们可以继承父类的属性和方法。在您的`Weather.js`文件中，编写以下代码：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As per the custom elements v1 spec, a custom element should be extended from
    `HTMLElement` directly only using a class. However, we are using `babel-loader`
    with the `env` preset, which converts all the classes into functions. This will
    cause a problem with the custom elements, which need to be classes. But there
    is a plugin that can be used to overcome this issue: *transform-custom-element-classes*.
    I have already added this plugin in your `webpack.config.js` file so that you
    wouldn't face any problems in this chapter. You can find it in the `.js` rules
    section of your Webpack configuration file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 根据自定义元素v1规范，自定义元素应该直接从`HTMLElement`扩展，只使用一个类。然而，我们正在使用带有`env`预设的`babel-loader`，它将所有类转换为函数。这将导致自定义元素出现问题，因为它们需要是类。但是有一个插件可以用来解决这个问题：*transform-custom-element-classes*。我已经在您的`webpack.config.js`文件中添加了这个插件，这样您在本章中就不会遇到任何问题。您可以在Webpack配置文件的`.js`规则部分找到它。
- en: 'Let''s declare the initial class variables in our `Weather` class''s constructor:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Weather`类的构造函数中声明初始类变量：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that in the constructor's first line, I have made a call to the `super()`
    method. This will call the constructor of the parent class `HTMLElement`. Whenever
    your class extends another class, always add `super()` inside your class's constructor.
    This way, the parent class will also get initialized before your class methods
    start working.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在构造函数的第一行，我调用了`super()`方法。这将调用父类`HTMLElement`的构造函数。每当您的类扩展另一个类时，始终在您的类构造函数中添加`super()`。这样，父类在您的类方法开始工作之前也会被初始化。
- en: The two class variables (properties), `this.latitude` and `this.longitude`,
    will get the value of the attributes `lat` and `long` from the custom weather
    element using the `this.getAttribute()` method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 两个类变量（属性）`this.latitude`和`this.longitude`将使用`this.getAttribute()`方法从自定义天气元素的`lat`和`long`属性中获取值。
- en: 'We also need to add HTML to our custom element. Since the `Weather` class is
    similar to the reference of a DOM element we used before, `this.innerHTML` can
    be used to add HTML for the weather element. Inside the constructor, add the following
    line:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为我们的自定义元素添加HTML。由于`Weather`类类似于我们之前使用的DOM元素的引用，`this.innerHTML`可用于为天气元素添加HTML。在构造函数中，添加以下行：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, `this.innerHTML` is an empty template string. I have already created the
    HTML and CSS needed for the custom element. You can find it in the `Chapter 05\WeatherTemplate`
    directory of the book code. Copy the contents of the `weather-template.html` file
    and paste it inside the template string.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`this.innerHTML`是一个空的模板字符串。我已经创建了自定义元素所需的HTML和CSS。您可以在书籍代码的`Chapter 05\WeatherTemplate`目录中找到它。复制`weather-template.html`文件的内容，并将其粘贴到模板字符串中。
- en: Testing the custom element
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试自定义元素
- en: 'Our custom element now contains the HTML needed for displaying the contents.
    Let''s test it. At the end of your `Weather.js` file, add the following line:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义元素现在包含了显示内容所需的HTML。让我们来测试一下。在您的`Weather.js`文件末尾，添加以下行：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will export the entire `Weather` class and make it available to be used
    inside other modules. We need to import this into our `home.js` file. Inside your
    `home.js` file, add the following code at the top:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导出整个`Weather`类，并使其可用于在其他模块中使用。我们需要将其导入到我们的`home.js`文件中。在您的`home.js`文件中，在顶部添加以下代码：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, we need to define the custom element, that is, associate the custom element
    with a tag name. Ideally, we would like to call our element `<weather>`. It would
    be nice! But according to the custom element spec, we should name the element
    so that it has a dash `-` in its name. So, for simplicity, we call our element
    `<x-weather>`. This way, whenever we see an element prefixed with `x-`, we will
    immediately know it is a custom element.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义自定义元素，也就是将自定义元素与标签名称关联起来。理想情况下，我们想要称呼我们的元素为`<weather>`。这样会很好！但根据自定义元素规范，我们应该给元素命名，使其在名称中有一个破折号`-`。因此，为了简单起见，我们将我们的元素称为`<x-weather>`。这样，每当我们看到一个以`x-`为前缀的元素，我们立刻知道它是一个自定义元素。
- en: 'The `customElements.define()` method is used for defining custom elements.
    `customElements` is available on the global `window` object. It accepts two parameters:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`customElements.define()`方法用于定义自定义元素。`customElements`可用于全局`window`对象。它接受两个参数：'
- en: The first parameter is a string that should contain the custom element name
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是一个字符串，应该包含自定义元素名称
- en: The second parameter should contain the class that implements the custom element
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数应该包含实现自定义元素的类
- en: 'Add `customElements.define(''x-weather'', Weather)` to your callback function
    of the window load event listener, which we previously added in `home.js` to get
    the geolocation. `window.addEventListener` will now look as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`home.js`中添加的用于获取地理位置的窗口加载事件侦听器的回调函数中，添加`customElements.define('x-weather',
    Weather)`。`window.addEventListener`现在将如下所示：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s add the custom element to our `index.html` file. In your `index.html`
    file, add the following line inside the `div.large-container` element:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将自定义元素添加到我们的`index.html`文件中。在您的`index.html`文件中，在`div.large-container`元素内添加以下行：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since it is a change in the HTML file, you have to manually reload the page
    in Chrome. Now, you should get a Weather Widget showing a loading message, as
    follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是HTML文件的更改，您必须在Chrome中手动重新加载页面。现在，您应该会得到一个显示加载消息的天气小部件，如下所示：
- en: '![](../images/00033.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00033.jpeg)'
- en: 'If you inspect the element using Chrome DevTools, it should be structured as
    follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Chrome DevTools检查元素，它应该结构如下：
- en: '![](../images/00034.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00034.jpeg)'
- en: 'As you can see, your HTML is now attached inside the custom element along with
    the styles. However, we are facing one serious problem here. The scopes of styles
    are always *global*. This means that, if anyone were to add style for the `.title`
    class, say `color: red;` in the page''s CSS, it will affect our Weather Widget
    too! Or, if we add styles to any class that is used in the page, say `.large-container`,
    inside our widget, it will affect the entire page! We really don''t want this
    to happen. To overcome this problem, let''s learn the last remaining topic of
    the web components.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，您的HTML现在附加在自定义元素内部，以及样式。但是，我们在这里面临一个严重的问题。样式的范围始终是*全局*的。这意味着，如果有人在页面的CSS中为`.title`类添加样式，比如`color:
    red;`，它也会影响我们的天气小部件！或者，如果我们在小部件内部添加样式到页面中使用的任何类，比如`.large-container`，它将影响整个页面！我们真的不希望发生这种情况。为了解决这个问题，让我们学习Web组件的最后一个剩下的主题。'
- en: Attaching a shadow DOM
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加影子DOM
- en: A shadow DOM provides encapsulation between DOM and CSS. A shadow DOM can be
    attached to any element and the element to which the shadow DOM is attached is
    called the shadow root. A shadow DOM is considered separate from the rest of the
    DOM tree; hence, the styles from outside the shadow root will not affect the shadow
    DOM and vice versa.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 影子DOM提供了DOM和CSS之间的封装。影子DOM可以附加到任何元素，附加影子DOM的元素称为影子根。影子DOM被视为与DOM树的其余部分分开；因此，影子根外部的样式不会影响影子DOM，反之亦然。
- en: 'To attach a shadow DOM to an element, we simply need to use the `attachShadow()`
    method on that element. Take a look at the following example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要将影子DOM附加到元素，我们只需要在该元素上使用`attachShadow()`方法。看下面的例子：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, firstly, I attached a shadow DOM named `$shadowDom` to `$element`. After
    this, I added some HTML to `$shadowDom`. Note that I used the parameter `{mode:
    ''open''}` to the `attachShadow()` method. If `{mode: ''closed''}` were to be
    used, access to the shadow DOM from the shadow root using JavaScript is closed
    and other developers will not be able to manipulate our element from the DOM using
    JavaScript.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，首先，我将一个名为`$shadowDom`的影子DOM附加到`$element`。之后，我向`$shadowDom`添加了一些HTML。请注意，我在`attachShadow()`方法中使用了参数`{mode:
    ''open''}`。如果使用`{mode: ''closed''}`，则无法从JavaScript中的影子根访问影子DOM，其他开发人员将无法使用JavaScript从DOM中操作我们的元素。'
- en: We need the developers to manipulate our element using JavaScript so that they
    can set the geolocation for the Weather Widget. Generally, the open mode is widely
    used. The closed mode is used only when you want to completely prevent others
    from making changes to your element.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要开发人员使用JavaScript来操作我们的元素，以便他们可以为天气小部件设置地理位置。通常，广泛使用开放模式。仅当您希望完全阻止其他人对您的元素进行更改时，才使用关闭模式。
- en: 'To add the shadow DOM to our custom weather element, perform the following
    steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要将影子DOM添加到我们的自定义天气元素，请执行以下步骤：
- en: 'Attach a shadow DOM to our custom element. This can be done by adding the following
    line to the constructor:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将影子DOM附加到我们的自定义元素。这可以通过在构造函数中添加以下行来完成：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Replace `this.innerHTML` with `this.$shadowRoot.innerHTML` and your code should
    now look as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`this.innerHTML`替换为`this.$shadowRoot.innerHTML`，您的代码现在应如下所示：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Open the page in Chrome. You should see the same Weather Widget; however, if
    you inspect the element using Chrome DevTools, your DOM tree will be structured
    as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Chrome中打开页面。您应该看到相同的天气小部件；但是，如果使用Chrome DevTools检查元素，则DOM树将结构如下：
- en: '![](../images/00035.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00035.jpeg)'
- en: You can see that the contents of the `<x-weather>` element will be separated
    from the rest of the DOM by specifying `x-weather` as a shadow root. Also, the
    styles defined inside the weather element will not leak out to the rest of the
    DOM and the styles outside the shadow DOM will not affect our weather element.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`<x-weather>`元素的内容将通过将`x-weather`指定为影子根与DOM的其余部分分离。此外，天气元素内部定义的样式不会泄漏到DOM的其余部分，而影子DOM外部的样式也不会影响我们的天气元素。
- en: 'Generally, to access the shadow DOM of an element, you can use the `shadowRoot`
    property of that element. For example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，要访问元素的影子DOM，可以使用该元素的`shadowRoot`属性。例如：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will print the entire shadow DOM attached to a shadow root in the console.
    However, if your shadow root is *closed*, then it will simply print `null`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台中打印附加到影子根的整个影子DOM。但是，如果您的影子根是*closed*，那么它将简单地打印`null`。
- en: Working with the custom element
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义元素
- en: We now have the UI ready for our Weather Widget. Our next step is to retrieve
    the data from the server and display it in the Weather Widget. Generally, widgets,
    such as our Weather Widget, will not be present in the HTML directly. Like with
    the tasks in our Chapter 1, *Building a ToDo List*, developers often create the
    element from JavaScript, attach attributes, and append it to the DOM. Also, if
    they need to make any changes, such as changing the geolocation, they will use
    a reference to the element in JavaScript to modify its attributes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了天气小部件的UI。我们的下一步是从服务器检索数据并在天气小部件中显示它。通常，小部件，例如我们的天气小部件，不会直接出现在HTML中。就像我们第1章中的任务*构建待办事项列表*一样，开发人员通常会从JavaScript中创建元素，附加属性，并将其附加到DOM中。此外，如果他们需要进行任何更改，例如更改地理位置，他们将使用JavaScript中对元素的引用来修改其属性。
- en: This is very common and we have been modifying a lot of DOM elements this way
    in all our projects. Now, the same will be expected from our custom weather element.
    The `HTMLElement` interface from which we extended our `Weather` class provides
    special methods called lifecycle callbacks to our `Weather` class. Lifecycle callbacks
    are methods that get called when a certain event happens.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常常见的，我们在所有项目中都以这种方式修改了许多DOM元素。现在，我们的自定义天气元素也将期望同样的行为。我们从中扩展了我们的`Weather`类的`HTMLElement`接口为我们的`Weather`类提供了称为生命周期回调的特殊方法。生命周期回调是在发生某个事件时调用的方法。
- en: 'For a custom element, four lifecycle callback methods are available:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义元素，有四个生命周期回调方法可用：
- en: '`connectedCallback()`: This is called when the element is inserted into a DOM
    or a shadow DOM.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connectedCallback()`: 当元素插入DOM或影子DOM时调用此方法。'
- en: '`attributeChangedCallback(attributeName, oldValue, newValue, namespace)`: This
    is called when an observed attribute of the element is modified.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributeChangedCallback(attributeName, oldValue, newValue, namespace)`: 当元素的观察属性被修改时调用此方法。'
- en: '`disconnectedCallback()`: This is called when the element is removed from the
    DOM or shadow DOM.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disconnectedCallback()`: 当元素从DOM或影子DOM中移除时调用此方法。'
- en: '`adoptedCallback(oldDocument, newDocument)`: This is called when an element
    is adopted into a new DOM.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adoptedCallback(oldDocument, newDocument)`: 当元素被采用到新的DOM中时调用此方法。'
- en: For our custom element, we are going to use the first three callback methods.
    *Remove* the `<x-weather />` element inside your `index.html` file. We are going
    to add it from our JavaScript code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的自定义元素，我们将使用前三个回调方法。*从*您的`index.html`文件中删除`<x-weather />`元素。我们将从我们的JavaScript代码中添加它。
- en: 'In your `home.js` file, inside the `showPosition()` function, create a new
    function name: `createWeatherElement()`. This function should accept a class name
    (the HTML class attribute) as a parameter and create a weather element with that
    class name. We already have the geolocation in the `latitude` and `longitude`
    constants. The code for the `showPosition()` function is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`home.js`文件中，在`showPosition()`函数内，创建一个名为：`createWeatherElement()`的新函数。此函数应接受一个类名（HTML类属性）作为参数，并创建一个具有该类名的天气元素。我们已经在`latitude`和`longitude`常量中有地理位置信息。`showPosition()`函数的代码如下：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This function will return a weather element with three attributes, which will
    look like the following snippet in the DOM:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将返回一个具有三个属性的天气元素，在DOM中看起来如下片段：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To add the Weather Widget inside all the large, medium, and small containers,
    add the following code after the preceding function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要在所有大、中、小容器中添加天气小部件，请在前面的函数之后添加以下代码：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should see Weather Widgets attached to all the three different sized containers.
    Our final widget should look as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到天气小部件附加到所有三个不同大小的容器上。我们的最终小部件应该如下所示：
- en: '![](../images/00036.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00036.jpeg)'
- en: 'The Weather Widget contains the following details:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 天气小部件包含以下详细信息：
- en: City name
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 城市名
- en: Weather icon
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天气图标
- en: Temperature
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 温度
- en: Time (*hours***:***minutes***:***seconds*)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间（*小时***:***分钟***:***秒*）
- en: Summary of the weather status (*Overcast*)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天气状态摘要（*阴天*）
- en: Adding dependency modules
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加依赖模块
- en: Our Weather Widget needs to make an HTTP request to the server. For this, we
    can reuse the APICall module we built previously in [Chapter 3](part0075.html#27GQ60-f852807d0cb141b58fff8f992d32cbb7),
    *Event Registration App*. Also, since we will be using the Dark Sky service for
    displaying weather information, we can use their icon library, Skycons, for displaying
    the weather icon. Currently, Skycons is not available in npm. You can get both
    the files from the book code `Chapter05\weatherdependencies` directory or from
    the completed code files.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的天气小部件需要向服务器发出HTTP请求。为此，我们可以重用我们之前在[第3章](part0075.html#27GQ60-f852807d0cb141b58fff8f992d32cbb7)中构建的APICall模块。此外，由于我们将使用Dark
    Sky服务来显示天气信息，我们可以使用他们的图标库Skycons来显示天气图标。目前，Skycons在npm中不可用。您可以从书中的`Chapter05\weatherdependencies`目录或完成的代码文件中获取这两个文件。
- en: 'Currently, your JS folder will be structured as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您的JS文件夹结构如下：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should add the `apiCall.js` file under the `CustomElements/Weather/services/api/apiCall.js`
    path and the `skycons.js` file under the `CustomElements/Weather/lib/skycons.js`
    path. Your JS folder should now look as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在`CustomElements/Weather/services/api/apiCall.js`路径下添加`apiCall.js`文件，并在`CustomElements/Weather/lib/skycons.js`路径下添加`skycons.js`文件。您的JS文件夹现在应该如下所示：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Retrieving and displaying weather information
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索和显示天气信息
- en: 'In your `weather.js` file, add the following import statements at the top:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`weather.js`文件中，在顶部添加以下导入语句：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The Skycons library will add a global variable, `Skycons`, to the window object.
    It is used to show an animated **Scalable Vector Graphics** (**SVG**) icon in
    the canvas element. Currently, all the class variables, such as `latitude` and
    `longitude`, are created in the constructor. But instead, it is better to create
    them only when the Weather Widget is added to the DOM. Let''s move the variables
    to the `connectedCallback()` method so that the variables are created only when
    the widget is added to the DOM. Your `Weather` class will now look as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Skycons库将向window对象添加一个全局变量`Skycons`。它用于在画布元素中显示一个动画**可伸缩矢量图形**（**SVG**）图标。目前，所有的类变量，比如`latitude`和`longitude`，都是在构造函数中创建的。但是，最好只在天气小部件添加到DOM时才创建它们。让我们将变量移到`connectedCallback()`方法中，这样变量只有在小部件添加到DOM时才会被创建。您的`Weather`类现在应该如下所示：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Also, just as we created the reference for elements in the DOM in the previous
    chapters, let''s create references to the elements in the shadow DOM of the Weather
    Widget. Inside the `connectedCallback()` method, add the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在之前的章节中在DOM中创建元素的引用一样，让我们在天气小部件的影子DOM中创建对元素的引用。在`connectedCallback()`方法内部，添加以下代码：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Start the server included with this chapter and let it run in the `http://localhost:3000/`
    URL. For retrieving the weather information, the API endpoint is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 启动本章附带的服务器，并让它在`http://localhost:3000/` URL上运行。用于检索天气信息的API端点如下：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, `lat` and `long` are latitude and longitude values. If your (`lat`, `long`)
    values are (`13.1358854`, `80.286841`), then your request URL will be as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`lat`和`long`是纬度和经度值。如果您的（`lat`，`long`）值为（`13.1358854`，`80.286841`），那么您的请求URL将如下所示：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The response format of the API endpoint is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: API端点的响应格式如下：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To set the weather information in the Weather Widget, create a new method inside
    the `Weather` class `setWeather()` and add the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要在天气小部件中设置天气信息，创建一个新的方法在`Weather`类内部`setWeather()`，并添加以下代码：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Also, call the preceding method by adding `this.setWeather()` at the end of
    the `connectedCallback()` method. Open the page in Chrome and you should see the
    Weather Widget working as expected! You will be able to see the city name, weather
    information, and the weather icon. The working of the `setWeather()` method is
    straightforward, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 还要在`connectedCallback()`方法的末尾添加`this.setWeather()`来调用前面的方法。在Chrome中打开页面，您应该看到天气小部件按预期工作！您将能够看到城市名称、天气信息和天气图标。`setWeather()`方法的工作方式很简单，如下所示：
- en: First, it will check whether both the latitude and longitude are available.
    Otherwise, it will be impossible to make the HTTP request.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它将检查纬度和经度是否都可用。否则，将无法进行HTTP请求。
- en: Using the `apiCall` module, a GET request is made and the `response` is available
    in the `Promise.then()` chain.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`apiCall`模块，进行GET请求并在`Promise.then()`链中获得`response`。
- en: From the `response` of the HTTP request, the required data, such as city name,
    temperature, and summary, are included in the respective DOM elements.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从HTTP请求的`response`中，所需的数据，如城市名称、温度和摘要，都包含在相应的DOM元素中。
- en: For the weather icon, the global `Skycons` variable is a constructor that creates
    an object with all the icons in a specific color. In our case, black. The instance
    of the constructor is stored in the `skycons` object.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于天气图标，全局`Skycons`变量是一个构造函数，它创建一个具有特定颜色的所有图标的对象。在我们的情况下，是黑色。构造函数的实例存储在`skycons`对象中。
- en: For adding the animated icon, we use the `add` method with the canvas element
    (`this.$icon`) as the first parameter and the icon name as the second parameter
    in the required format. For example, if the value of the icon from the API is
    `cloudy-day`, the equivalent icon is `Skycons['CLOUDY_DAY']`. For this purpose,
    we first convert the entire string to uppercase and replace `-` with `_` by using
    a replace method with regular expression `.replace(/-/g, "_")`.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了添加动画图标，我们使用`add`方法，将canvas元素（`this.$icon`）作为第一个参数，将图标名称作为第二个参数以所需的格式传入。例如，如果API中的图标值是`cloudy-day`，则相应的图标是`Skycons['CLOUDY_DAY']`。为此，我们首先将整个字符串转换为大写，并使用正则表达式`.replace(/-/g,
    "_")`将`-`替换为`_`。
- en: Adding the current time to the widget
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将当前时间添加到小部件中
- en: 'We are still missing time in our widget. Unlike other values, time does not
    depend on the HTTP request but it needs to be updated every second automatically.
    In your weather class, add the following method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小部件中仍然缺少时间。与其他值不同，时间不依赖于HTTP请求，但需要每秒自动更新。在您的天气类中，添加以下方法：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `displayTime()` method does the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayTime()`方法执行以下操作：'
- en: A date object is created using the `new Date()` constructor. The `new Date()`
    constructor creates a `date` object with all the details regarding the date and
    time passed as parameters. If no parameters are passed, it will create an object
    containing all the information regarding the current date and time (up to milliseconds).
    In our case, since we didn't pass any parameters, it contains all the details
    of the date and time in the moment it was initialized.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`new Date()`构造函数创建一个日期对象。`new Date()`构造函数使用传递的日期和时间的所有详细信息创建一个`date`对象。如果没有传递参数，它将创建一个包含有关当前日期和时间的所有信息（直到毫秒）的对象。在我们的情况下，因为我们没有传递任何参数，它包含了初始化时刻的所有日期和时间的详细信息。
- en: We get the hours, minutes, and seconds from the date object. By using template
    strings, we simply constructed the time in the required format easily and stored
    it in the `displayTime` constant.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从日期对象中获取小时、分钟和秒。通过使用模板字符串，我们简单地按照所需的格式构建了时间，并将其存储在`displayTime`常量中。
- en: Finally, it sets the time as the text content of the *p#time* (`$time`) element
    in the shadow DOM.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，将时间设置为阴影DOM中*p#time*（`$time`）元素的文本内容。
- en: the date object is an important concept and is part of everyday software development
    in JavaScript. To learn more about date objects, refer to the w3schools page at: [https://www.w3schools.com/js/js_dates.asp](https://www.w3schools.com/js/js_dates.asp).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 日期对象是一个重要的概念，是JavaScript中日常软件开发的一部分。要了解有关日期对象的更多信息，请参考w3schools页面：[https://www.w3schools.com/js/js_dates.asp](https://www.w3schools.com/js/js_dates.asp)。
- en: 'This method is used to set the time once but we need to execute this method
    every second so that users can see the exact time in the widget. JavaScript has
    a method called `setInterval()`. It is used to execute a function repeatedly in
    a specific time interval. The `setInterval()` method accepts two parameters:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法用于设置时间一次，但我们需要每秒执行一次这个方法，这样用户就可以在小部件中看到确切的时间。JavaScript有一个叫做`setInterval()`的方法。它用于在特定的时间间隔内重复执行一个函数。`setInterval()`方法接受两个参数：
- en: The first one is the function that needs to be executed in a specific time interval
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是需要在特定时间间隔内执行的函数
- en: The second one is the time interval in milliseconds
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是以毫秒为单位的时间间隔
- en: However, `setInterval()` executes the function repeatedly even if the DOM element
    is removed from the DOM for some reason. To overcome this, you should store `setInterval()`
    in a variable and then use the `disconnectedCallback()` method to execute `clearInterval(intervalVariable)`,
    which clears the interval function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`setInterval()`会重复执行函数，即使DOM元素由于某种原因被从DOM中移除。为了克服这一点，您应该将`setInterval()`存储在一个变量中，然后使用`disconnectedCallback()`方法来执行`clearInterval(intervalVariable)`，这将清除间隔函数。
- en: 'To implement this, use the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，使用以下代码：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Open up the Weather Widget in Chrome and you should see the current time in
    the widget updated for every second, which looks normal to the user.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome中打开天气小部件，您应该看到小部件中的当前时间每秒更新一次，这对用户来说看起来很正常。
- en: Responding to changes in element attributes
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应元素属性的更改
- en: 'We have a full working Weather Widget but the weather information gets loaded
    only when the widget gets added to the DOM for the first time. If you try to change
    the value of the attributes `latitude` and `longitude` either from Chrome DevTools
    or from JavaScript, the value changes but the Weather Widget will not get updated.
    To make the weather element respond to the changes in `latitude` and `longitude`,
    we need to declare them as observed attributes. To do so, inside your `Weather`
    class, add the following line:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个完全工作的天气小部件，但是只有在第一次将小部件添加到DOM时才会加载天气信息。如果您尝试从Chrome DevTools或JavaScript更改`latitude`和`longitude`属性的值，值会更改，但是天气小部件不会得到更新。为了使天气元素响应`latitude`和`longitude`的更改，我们需要将它们声明为观察属性。为此，请在您的`Weather`类中添加以下行：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will create a static getter `observedAttributes()` that will return an
    array of all the attribute names, for which the Weather Widget should listen for
    changes. Static methods are special methods of `Class` that can be accessed without
    creating a class instance object. For all the other methods, we need to create
    a new instance (object) of the class; otherwise, we won't be able to access them.
    Since static methods do not need an instance, the `this` object will be *undefined*
    inside these methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个静态`getter` `observedAttributes()`，它将返回一个数组，其中包含天气小部件应监听更改的所有属性名称。静态方法是`Class`的特殊方法，可以在不创建类实例对象的情况下访问。对于所有其他方法，我们需要创建类的新实例（对象）；否则，我们将无法访问它们。由于静态方法不需要实例，这些方法内部的`this`对象将在这些方法内部为*undefined*。
- en: Static methods are used to hold common (class variables and methods independent)
    functions associated with the class that can be used in other places outside the
    class.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法用于保存与类相关的常见（独立的类变量和方法）函数，可以在类外的其他地方使用。
- en: 'Since we marked `latitude` and `longitude` as observed attributes, whenever
    they get modified using any method, it will trigger `attributeChangedCallback()`
    with the modified attribute''s name, and the old value of that attribute and the
    new value of that attribute as parameters. So, let''s add `attributeChangedCallback()`
    inside our `Weather` class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将`latitude`和`longitude`标记为观察属性，因此每当它们使用任何方法进行修改时，它都会触发`attributeChangedCallback()`，并将修改后的属性名称以及该属性的旧值和新值作为参数。因此，让我们在`Weather`类中添加`attributeChangedCallback()`：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This method is simple. Whenever the value of the `latitude` or `longitude` attribute
    changes, it updates the respective class variable and calls `this.setWeather()`
    to update the weather to the new geolocation. You can test this by editing the
    attribute of the Weather Widget directly in the DOM tree of Chrome DevTools.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很简单。每当`latitude`或`longitude`属性的值发生变化时，它都会更新相应的类变量并调用`this.setWeather()`来将天气更新到新的地理位置。您可以通过直接在Chrome
    DevTools的DOM树中编辑天气小部件的属性来测试这一点。
- en: Using setters and getters
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`setters`和`getters`
- en: 'We use `setters` and `getters` all the time when we create a reference to the
    DOM element. If we have a reference to the weather custom element, we would simply
    want to set or get `latitude` or `longitude` as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建对DOM元素的引用时经常使用`setters`和`getters`。如果我们有一个对天气自定义元素的引用，我们只需按如下方式设置或获取`latitude`或`longitude`：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In this case, we need the widget to update if we set a new `latitude` or `longitude`.
    To do that, add the following setters and getters to your `Weather` class:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们设置了新的`latitude`或`longitude`，我们需要小部件进行更新。为此，请将以下`setters`和`getters`添加到您的`Weather`类中：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To test if the setters and getters are working properly, let''s remove (or
    comment) the line where the Weather Widget gets appended to `$smallContainer`.
    Instead of that, add the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`setters`和`getters`是否正常工作，让我们删除（或注释掉）将天气小部件附加到`$smallContainer`的行。而是添加以下代码：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You should see that after 10 seconds, the weather in the small container automatically
    changes to London. The old and new geolocation will also get printed in the Chrome
    DevTools console.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到在10秒后，小容器中的天气会自动更改为伦敦。旧的和新的地理位置也将打印在Chrome DevTools控制台中。
- en: You have successfully completed the Weather Widget! Before you use it in your
    project, you need to add polyfills, because at the time of writing this book,
    only Chrome supports all the features of the web components.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功完成了天气小部件！在将其用于您的项目之前，您需要添加polyfills，因为在撰写本书时，只有Chrome支持Web组件的所有功能。
- en: Fixing browser compatibility
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复浏览器兼容性
- en: 'To improve the browser compatibility of our Weather Widget, we need the set
    of polyfills provided by the `webcomponents.js` library in the: [https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs)
    repository. These polyfills make our widget work with most of all the modern browsers.
    To add these polyfills to our project, first run the following command in the
    Terminal from the project root folder:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进我们的天气小部件的浏览器兼容性，我们需要`webcomponents.js`库提供的一组polyfills，位于：[https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs)
    存储库中。这些polyfills使我们的小部件与大多数现代浏览器兼容。要将这些polyfills添加到我们的项目中，首先从项目根文件夹中的终端运行以下命令：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will install and add `webcomponents.js` to our project dependency. After
    that, import it in your `home.js` file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装并将`webcomponents.js`添加到我们的项目依赖项中。之后，在您的`home.js`文件中导入它：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Currently, we are initializing the project after listening to the window load event.
    `Webcomponents.js` loads the polyfills asynchronously and, once it is ready, it
    will fire a `''WebComponentsReady''` event. So, instead of the load event, we
    should now listen for this new event:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在监听窗口加载事件后初始化项目。`Webcomponents.js`异步加载polyfills，并且一旦准备就绪，它将触发`'WebComponentsReady'`事件。因此，我们现在应该监听这个新事件，而不是加载事件：
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, for the last part, you need to document how to use the weather custom element
    and the web components polyfill in a `readme` file so that the rest of the team
    will know how to add it to the project. But this time, the `readme` document will
    be less than a single page and should be simple to maintain! I'll leave the `readme`
    part to you. Bet you are celebrating the completion of the fifth chapter already.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于最后一部分，您需要记录如何在`readme`文件中使用天气自定义元素和Web组件polyfill，以便团队的其余成员知道如何将其添加到项目中。但这次，`readme`文档将不到一页，并且应该简单易于维护！我会把`readme`部分留给您。我打赌您已经在庆祝第五章的完成了。
- en: Essential things to know
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要了解的基本事项
- en: 'These are a few things to know that will come in handy when working with custom
    elements. Just as we extended the general `HTMLElement` interface, we can also
    extend inbuilt elements, such as the paragraph element `<p>`, the button element
    `<button>`, and so on. This way, we can inherit all the properties and methods
    available in the parent element. For example, to extend the button element, do
    as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些在使用自定义元素时会派上用场的事情。就像我们扩展了一般的`HTMLElement`接口一样，我们也可以扩展内置元素，比如段落元素`<p>`，按钮元素`<button>`等等。这样，我们可以继承父元素中可用的所有属性和方法。例如，要扩展按钮元素，可以按照以下步骤进行：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we are extending the `HTMLButtonElement` interface instead of the `HTMLElement`
    interface. Also, just as inbuilt elements can be extended, custom elements can
    also be extended, which means we can create another type of widget by extending
    our Weather Widget class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们扩展了`HTMLButtonElement`接口，而不是`HTMLElement`接口。同样，就像内置元素可以被扩展一样，自定义元素也可以被扩展，这意味着我们可以通过扩展我们的天气小部件类来创建另一种类型的小部件。
- en: Even though JavaScript now supports classes and extend classes, it does not
    yet support private or protected class variables and methods like other object-oriented
    languages. Currently, all the class variables and methods are public. Some developers
    add the underscore '_' prefix to variables and methods that need to be private
    so that they don't accidentally use them in the extended class.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript现在支持类和扩展类，但它还不支持私有或受保护的类变量和方法，就像其他面向对象的语言一样。目前，所有的类变量和方法都是公共的。一些开发人员在需要私有变量和方法时在变量和方法前面添加下划线'_'前缀，以防止在扩展类中意外使用它们。
- en: 'If you are interested in working more with web components, you should probably
    check out the following libraries, which are created to improve the usability
    and workflow of using web components along with inbuilt polyfills:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对更多地使用Web组件感兴趣，您可能应该查看以下库，这些库旨在改进使用内置polyfills的Web组件的可用性和工作流程：
- en: Polymer: [https://www.polymer-project.org/](https://www.polymer-project.org/)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Polymer: [https://www.polymer-project.org/](https://www.polymer-project.org/)
- en: X-Tag: [https://x-tag.github.io/](https://x-tag.github.io/)
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X-Tag: [https://x-tag.github.io/](https://x-tag.github.io/)
- en: To learn more about extending native inbuilt HTML elements, refer to the following
    tutorial on the Google Developers page: [https://developers.google.com/web/fundamentals/getting-started/primers/customelements](https://developers.google.com/web/fundamentals/getting-started/primers/customelements).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关扩展内置HTML元素的更多信息，请参考Google开发者页面上的以下教程：[https://developers.google.com/web/fundamentals/getting-started/primers/customelements](https://developers.google.com/web/fundamentals/getting-started/primers/customelements)。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you built a Weather Widget for your team while learning about
    the web components. You created a reusable HTML custom element, which uses shadow
    DOM to abstract CSS from the rest of the document, making the widget easily pluggable
    into the rest of the project. You also learned about some methods, such as geolocation
    and set intervals. But the most important thing you learned in this chapter is
    the advantage of creating independent components in a team environment. By creating
    a reusable weather component, you made the work easier for yourself and for the
    rest of the team.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您为团队构建了一个天气小部件，同时学习了有关Web组件的知识。您创建了一个可重用的HTML自定义元素，它使用影子DOM来将CSS与文档的其余部分分离，使小部件可以轻松地插入到项目的其余部分中。您还学习了一些方法，比如地理位置和设置间隔。但在本章中，您学到的最重要的事情是在团队环境中创建独立组件的优势。通过创建可重用的天气组件，您为自己和团队的其余成员简化了工作。
- en: So far, we have been working on pure JavaScript. However, there are a lot of
    modern frameworks and libraries today, which makes programming with JavaScript
    more easier, efficient, and scalable to a large extent. Most of the frameworks
    concentrate on organizing your entire application into smaller, independent, and
    reusable components, which we experienced with the web components in this chapter.
    In the next chapter, we are going to build an entire application using the awesome
    UI library created by Facebook-**React.js**.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用纯JavaScript。然而，今天有许多现代框架和库，使得使用JavaScript进行编程更加简单，高效，并且可扩展到很大程度。大多数框架都集中于将整个应用程序组织成更小、独立和可重用的组件，这正如我们在本章中体验到的Web组件一样。在下一章中，我们将使用Facebook创建的强大UI库**React.js**来构建整个应用程序。
