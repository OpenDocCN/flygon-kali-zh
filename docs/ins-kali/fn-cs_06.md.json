["```cs\npublic partial class Program \n{ \n  public static void SynchronousProcess() \n  { \n    Stopwatch sw = Stopwatch.StartNew(); \n    Console.WriteLine( \n      \"Start synchronous process now...\"); \n    int iResult = RunSynchronousProcess(); \n    Console.WriteLine( \n      \"The Result = {0}\",iResult); \n    Console.WriteLine( \n      \"Total Time = {0} second(s)!\", \n      sw.ElapsedMilliseconds/1000); \n  } \n  public static int RunSynchronousProcess() \n  { \n    int iReturn = 0; \n    iReturn += LongProcess1(); \n    iReturn += LongProcess2(); \n    return iReturn; \n  } \n  public static int LongProcess1() \n  { \n    Thread.Sleep(5000); \n    return 5; \n  } \n  public static int LongProcess2() \n  { \n    Thread.Sleep(7000); \n    return 7; \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  public static void AsynchronousProcess() \n  { \n    Stopwatch sw = Stopwatch.StartNew(); \n    Console.WriteLine( \n      \"Start asynchronous process now...\"); \n    int iResult = RunAsynchronousProcess(); \n    Console.WriteLine( \n      \"The Result = {0}\", \n      iResult); \n    Console.WriteLine( \n      \"Total Time = {0} second(s)!\", \n      sw.ElapsedMilliseconds / 1000); \n  } \n  public static int RunAsynchronousProcess() \n  { \n    int iResult1 = 0; \n    // Creating thread for LongProcess1() \n    Thread thread = new Thread( \n      () => iResult1 = LongProcess1()); \n    // Starting the thread \n    thread.Start(); \n    // Running LongProcess2() \n    int iResult2 = LongProcess2(); \n    // Waiting for the thread to finish \n    thread.Join(); \n    // Return the the total result \n    return iResult1 + iResult2; \n  } \n  public static int LongProcess1() \n  { \n    Thread.Sleep(5000); \n    return 5; \n  } \n  public static int LongProcess2() \n  { \n    Thread.Sleep(7000); \n    return 7; \n  } \n} \n\n```", "```cs\n// Creating thread for LongProcess1() \nThread thread = new Thread( \n  () => \n  iResult1 = LongProcess1()); \n// Starting the thread \nthread.Start(); \n\n```", "```cs\n// Running LongProcess2() \nint iResult2 = LongProcess2(); \n// Waiting for the thread to finish \nthread.Join(); \n\n```", "```cs\npublic partial class Program \n{ \n  public static void ThreadPoolProcess() \n  { \n    Stopwatch sw = Stopwatch.StartNew(); \n    Console.WriteLine( \n      \"Start ThreadPool process now...\"); \n    int iResult = RunInThreadPool(); \n    Console.WriteLine(\"The Result = {0}\", \n      iResult); \n    Console.WriteLine(\"Total Time = {0} second(s)!\", \n      sw.ElapsedMilliseconds / 1000); \n  } \n  public static int RunInThreadPool() \n  { \n    int iResult1 = 0; \n    // Assignin work LongProcess1() to idle thread  \n    // in the thread pool  \n    ThreadPool.QueueUserWorkItem((t) => \n      iResult1 = LongProcess1()); \n    // Running LongProcess2() \n    int iResult2 = LongProcess2(); \n    // Waiting the thread to be finished \n    // then returning the result \n    return iResult1 + iResult2; \n  } \n    public static int LongProcess1() \n  { \n    Thread.Sleep(5000); \n    return 5; \n  } \n  public static int LongProcess2() \n  { \n    Thread.Sleep(7000); \n    return 7; \n  } \n} \n\n```", "```cs\npublic int Read( \n  byte[] array, \n  int offset, \n  int count \n) \npublic IAsyncResult BeginRead( \n  byte[] array, \n  int offset, \n  int numBytes, \n  AsyncCallback userCallback, \n  object stateObject \n) \npublic int EndRead( \n  IAsyncResult asyncResult \n) \n\n```", "```cs\npublic partial class Program \n{ \n  public static void ReadFile() \n  { \n    FileStream fs = \n      File.OpenRead( \n        @\"..\\..\\..\\LoremIpsum.txt\"); \n    byte[] buffer = new byte[fs.Length]; \n    int totalBytes = \n      fs.Read(buffer, 0, (int)fs.Length); \n    Console.WriteLine(\"Read {0} bytes.\", totalBytes); \n    fs.Dispose(); \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  public static void ReadAsyncFile() \n  { \n    FileStream fs =  \n      File.OpenRead( \n        @\"..\\..\\..\\LoremIpsum.txt\"); \n    byte[] buffer = new byte[fs.Length]; \n    IAsyncResult result = fs.BeginRead(buffer, 0, (int)fs.Length,\n      OnReadComplete, fs); \n    //do other work while file is read \n    int i = 0; \n    do \n    { \n      Console.WriteLine(\"Timer Counter: {0}\", ++i); \n    } \n    while (!result.IsCompleted); \n    fs.Dispose(); \n  } \n  private static void OnReadComplete(IAsyncResult result) \n  { \n    FileStream fStream = (FileStream)result.AsyncState;\n    int totalBytes = fStream.EndRead(result);\n    Console.WriteLine(\"Read {0} bytes.\", totalBytes);fStream.Dispose(); \n  } \n} \n\n```", "```cs\n//do other work while file is read \nint i = 0; \ndo \n{ \n  Console.WriteLine(\"Timer Counter: {0}\", ++i); \n} \nwhile (!result.IsCompleted); \n\n```", "```cs\nIAsyncResult result = \n  fs.BeginRead( \n    buffer, 0, (int)fs.Length, OnReadComplete, fs); \n\n```", "```cs\npublic partial class Program \n{ \n  public static void ReadAsyncFileAnonymousMethod() \n  { \n    FileStream fs = \n      File.OpenRead( \n        @\"..\\..\\..\\LoremIpsum.txt\"); \n    byte[] buffer = new byte[fs.Length]; \n    IAsyncResult result = fs.BeginRead(buffer, 0, (int)fs.Length,\n      asyncResult => { int totalBytes = fs.EndRead(asyncResult); \n    Console.WriteLine(\"Read {0} bytes.\", totalBytes); \n      }, null); \n    //do other work while file is read \n    int i = 0; \n    do \n    { \n      Console.WriteLine(\"Timer Counter: {0}\", ++i); \n    } \n    while (!result.IsCompleted); \n    fs.Dispose(); \n  } \n} \n\n```", "```cs\nIAsyncResult result = \n  fs.BeginRead( \n    buffer, \n    0, \n    (int)fs.Length, \n    asyncResult => \n    { \n      int totalBytes = \n        fs.EndRead(asyncResult); \n      Console.WriteLine(\"Read {0} bytes.\", totalBytes); \n    }, \n  null); \n\n```", "```cs\npublic partial class Program \n{ \n  public static void ReadFileTask() \n  { \n    bool IsFinish = false; \n    FileStream fs = File.OpenRead( \n      @\"..\\..\\..\\LoremIpsum.txt\"); \n    byte[] readBuffer = new byte[fs.Length]; \n    fs.ReadAsync(readBuffer,  0,  (int)fs.Length) \n      .ContinueWith(task => { \n      if (task.Status ==  \n        TaskStatus.RanToCompletion) \n        { \n          IsFinish = true; \n          Console.WriteLine( \n          \"Read {0} bytes.\", \n          task.Result); \n        } \n        fs.Dispose();}); \n    //do other work while file is read \n    int i = 0; \n    do \n    { \n      Console.WriteLine(\"Timer Counter: {0}\", ++i); \n    } \n    while (!IsFinish); \n    Console.WriteLine(\"End of ReadFileTask() method\"); \n  } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  public static void ReadTwoFileTask() \n  { \n    bool IsFinish = false; \n    Task readFile1 = \n      ReadFileAsync( \n      @\"..\\..\\..\\LoremIpsum.txt\"); \n    Task readFile2 = \n      ReadFileAsync( \n      @\"..\\..\\..\\LoremIpsum2.txt\"); \n    Task.WhenAll(readFile1, readFile2) \n      .ContinueWith(task => \n      { \n        IsFinish = true; \n        Console.WriteLine( \n        \"All files have been read successfully.\"); \n      }); \n      //do other work while file is read \n      int i = 0; \n      do \n      { \n        Console.WriteLine(\"Timer Counter: {0}\", ++i); \n      } \n      while (!IsFinish); \n      Console.WriteLine(\"End of ReadTwoFileTask() method\"); \n    } \n    public static Task<int> ReadFileAsync(string filePath) \n    { \n      FileStream fs = File.OpenRead(filePath); \n      byte[] readBuffer = new byte[fs.Length]; \n      Task<int> readTask = \n        fs.ReadAsync( \n        readBuffer, \n        0, \n        (int)fs.Length); \n      readTask.ContinueWith(task => \n      { \n        if (task.Status == TaskStatus.RanToCompletion) \n        Console.WriteLine( \n          \"Read {0} bytes from file {1}\", \n          task.Result, \n          filePath); \n        fs.Dispose(); \n      }); \n      return readTask; \n    } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  public static void ReadTwoFileTaskWithCancellation() \n  { \n    bool IsFinish = false; \n\n    // Define the cancellation token. \n    CancellationTokenSource source = \n      new CancellationTokenSource(); \n    CancellationToken token = source.Token; \n\n    Task readFile1 = \n      ReadFileAsync( \n      @\"..\\..\\..\\LoremIpsum.txt\"); \n    Task readFile2 = \n      ReadFileAsync( \n      @\"..\\..\\..\\LoremIpsum2.txt\"); \n\n    Task.WhenAll(readFile1, readFile2) \n      .ContinueWith(task => \n      { \n        IsFinish = true; \n        Console.WriteLine( \n          \"All files have been read successfully.\"); \n      } \n      , token \n    ); \n\n    //do other work while file is read \n    int i = 0; \n    do \n    { \n      Console.WriteLine(\"Timer Counter: {0}\", ++i); \n      if (i > 10) \n      { \n        source.Cancel(); \n        Console.WriteLine( \n          \"All tasks are cancelled at i = \" + i); \n         break; \n       } \n     } \n     while (!IsFinish); \n\n     Console.WriteLine( \n       \"End of ReadTwoFileTaskWithCancellation() method\"); \n    } \n} \n\n```", "```cs\npublic partial class Program \n{ \n  public static bool IsFinish; \n  public static void WrapApmIntoTap() \n  { \n    IsFinish = false; \n    ReadFileAsync( \n      @\"..\\..\\..\\LoremIpsum.txt\"); \n      //do other work while file is read \n      int i = 0; \n    do \n    { \n      Console.WriteLine(\"Timer Counter: {0}\", ++i); \n    } \n    while (!IsFinish); \n    Console.WriteLine( \n      \"End of WrapApmIntoTap() method\"); \n  } \n  private static Task<int> ReadFileAsync(string filePath) \n  { \n    FileStream fs = File.OpenRead(filePath); \n    byte[] readBuffer = new Byte[fs.Length]; \n    Task<int> readTask = \n      Task.Factory.FromAsync( \n      (Func<byte[], \n      int, \n      int, \n      AsyncCallback, \n      object, \n      IAsyncResult>) \n    fs.BeginRead, \n    (Func<IAsyncResult, int>) \n    fs.EndRead, \n    readBuffer, \n    0, \n    (int)fs.Length, \n    null); \n    readTask.ContinueWith(task => \n    { \n      if (task.Status == TaskStatus.RanToCompletion) \n      { \n        IsFinish = true; \n        Console.WriteLine( \n          \"Read {0} bytes from file {1}\", \n          task.Result, \n          filePath); \n      } \n      fs.Dispose(); \n    }); \n    return readTask; \n  } \n} \n\n```", "```cs\nTask<int> readTask = \n  Task.Factory.FromAsync( \n    (Func<byte[], \n    int, \n    int, \n    AsyncCallback, \n    object, \n    IAsyncResult>) \n    fs.BeginRead, \n    (Func<IAsyncResult, int>) \n    fs.EndRead, \n    readBuffer, \n    0, \n    (int)fs.Length, \n  null); \n\n```", "```cs\npublic partial class Program \n{ \n  static bool IsFinish; \n  public static void AsyncAwaitReadFile() \n  { \n    IsFinish = false; \n    ReadFileAsync(); \n    //do other work while file is read \n    int i = 0; \n    do \n    { \n      Console.WriteLine(\"Timer Counter: {0}\", ++i); \n    } \n    while (!IsFinish); \n    Console.WriteLine(\"End of AsyncAwaitReadFile() method\"); \n  } \n  public static async void ReadFileAsync() \n  { \n    FileStream fs = \n      File.OpenRead( \n      @\"..\\..\\..\\LoremIpsum.txt\"); \n    byte[] buffer = new byte[fs.Length]; \n    int totalBytes = \n      await fs.ReadAsync( \n      buffer, \n      0, \n      (int)fs.Length); \n    Console.WriteLine(\"Read {0} bytes.\", totalBytes); \n    IsFinish = true; \n    fs.Dispose(); \n  } \n} \n\n```", "```cs\nint totalBytes = \n  await fs.ReadAsync( \n    buffer, \n    0, \n    (int)fs.Length); \n\n```", "```cs\npublic static async void ReadFileAsync() \n{ \n  // Implementation \n} \n\n```", "```cs\npublic async static Task<int> FunctionA( \n  int a) => await Task.FromResult(a * 1); \npublic async static Task<int> FunctionB( \n  int b) => await Task.FromResult(b * 2); \npublic async static Task<int> FunctionC( \n  int c) => await Task.FromResult(c * 3); \n\n```", "```cs\npublic static class ExtensionMethod \n{ \n  public static async Task<TResult> MapAsync<TSource, TResult>( \n    this Task<TSource> @this, \n    Func<TSource, Task<TResult>> fn) => await fn(await @this); \n} \n\n```", "```cs\npublic partial class Program \n{ \n  public async static Task<int> FunctionA( \n    int a) => await Task.FromResult(a * 1); \n  public async static Task<int> FunctionB( \n    int b) => await Task.FromResult(b * 2); \n  public async static Task<int> FunctionC( \n    int c) => await Task.FromResult(c * 3); \n  public async static void AsyncChain() \n  { \n    int i = await FunctionC(10) \n    .MapAsync(FunctionB) \n    .MapAsync(FunctionA); \n    Console.WriteLine(\"The result = {0}\", i); \n  } \n} \n\n```"]