- en: Chapter 8. Testing Concurrent Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。测试并发应用程序
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Monitoring a `Lock` interface
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视`Lock`接口
- en: Monitoring a `Phaser` class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视`Phaser`类
- en: Monitoring an Executor framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视Executor框架
- en: Monitoring a Fork/Join pool
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视Fork/Join池
- en: Writing effective log messages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写有效的日志消息
- en: Analyzing concurrent code with FindBugs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FindBugs分析并发代码
- en: Configuring Eclipse for debugging concurrency code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Eclipse以调试并发代码
- en: Configuring NetBeans for debugging concurrency code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置NetBeans以调试并发代码
- en: Testing concurrency code with MultithreadedTC
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MultithreadedTC测试并发代码
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Testing an application is a critical task. Before the application is ready for
    end users, you have to demonstrate its correctness. You use a test process to
    prove that correctness is achieved and errors are fixed. The testing phase is
    a common task in any software development and also **quality assurance** processes.
    You can find a lot of literature about testing processes and the different approaches
    you can apply to your developments. There are also a lot of libraries, such as
    `JUnit`, and applications, such as Apache `JMetter` that you can use to test your
    Java applications in an automated way. It's even more critical in a concurrent
    application development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应用程序是一项关键任务。在应用程序准备交付给最终用户之前，您必须证明其正确性。您使用测试过程来证明已经实现了正确性并修复了错误。测试阶段是任何软件开发和**质量保证**流程中的常见任务。您可以找到大量关于测试过程和您可以应用于开发的不同方法的文献。还有许多库，如`JUnit`，以及应用程序，如Apache
    `JMetter`，您可以使用它们以自动化的方式测试您的Java应用程序。这在并发应用程序开发中更加关键。
- en: The fact that concurrent applications have two or more threads that share data
    structures and interact with each other adds more difficulty to the testing phase.
    The biggest problem you will face when you test concurrent applications is that
    the execution of threads is non-deterministic. You can't guarantee the order of
    the execution of the threads, so it's difficult to reproduce errors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 并发应用程序具有两个或更多个共享数据结构并相互交互的线程，这增加了测试阶段的难度。当您测试并发应用程序时，将面临的最大问题是线程的执行是不确定的。您无法保证线程执行的顺序，因此很难重现错误。
- en: 'In this chapter, you will learn:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: How to obtain information about the elements you have in your concurrent applications.
    This information can help you test your concurrent applications.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取有关并发应用程序中的元素的信息。这些信息可以帮助您测试并发应用程序。
- en: How to use an IDE (Integrated Development Environment) and other tools such
    as FindBugs to test your concurrent applications.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用集成开发环境（IDE）和其他工具，如FindBugs，来测试并发应用程序。
- en: How to use libraries such as MultithreadedTC to automate your tests.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用诸如MultithreadedTC之类的库来自动化您的测试。
- en: Monitoring a Lock interface
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视Lock接口
- en: A `Lock` interface is one of the basic mechanisms provided by the Java concurrency
    API to get the synchronization of a block of code. It allows the definition of
    a **critical section**. A critical section is a block of code that accesses a
    shared resource and can't be executed by more than one thread at the same time.
    This mechanism is implemented by the `Lock` interface and the `ReentrantLock`
    class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lock`接口是Java并发API提供的基本机制之一，用于同步代码块。它允许定义**临界区**。临界区是访问共享资源的代码块，不能同时由多个线程执行。这个机制由`Lock`接口和`ReentrantLock`类实现。'
- en: In this recipe, you will learn what information you can obtain about a `Lock`
    object and how to obtain that information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您将学习可以获取有关`Lock`对象的哪些信息以及如何获取这些信息。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用Eclipse IDE实现。如果您使用Eclipse或其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `MyLock` that extends the `ReentrantLock` class.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyLock`的类，继承`ReentrantLock`类。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Implement the `getOwnerName()` method. This method returns the name of the thread
    that has the control of a lock (if any) using the protected method of the `Lock`
    class `getOwner()`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getOwnerName()`方法。该方法使用`Lock`类的受保护方法`getOwner()`返回控制锁的线程（如果有）的名称。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Implement the `getThreads()` method. This method returns a list of threads queued
    in a lock using the protected method of the `Lock` class`getQueuedThreads()`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getThreads()`方法。该方法使用`Lock`类的受保护方法`getQueuedThreads()`返回排队在锁中的线程列表。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Create a class named `Task` that implements the `Runnable` interface.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，实现`Runnable`接口。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Declare a private `Lock` attribute named `lock`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`lock`的私有`Lock`属性。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Implement a constructor of the class to initialize its attribute.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Implement the `run()` method. Create a loop with five steps.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。创建一个包含五个步骤的循环。
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Acquire the lock using the `lock()` method and print a message.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lock()`方法获取锁并打印一条消息。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Put the thread to sleep for 500 milliseconds. Free the lock using the `unlock()`
    method and print a message.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使线程休眠500毫秒。使用`unlock()`方法释放锁并打印一条消息。
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create the main class of the example by creating a class named `Main` with a
    `main()` method.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类和一个`main()`方法来创建示例的主类。
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create a `MyLock` object named `lock`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`lock`的`MyLock`对象。
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create an array for five `Thread` objects.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为五个`Thread`对象创建一个数组。
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Create and start five threads to execute five `Task` objects.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动五个线程来执行五个`Task`对象。
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Create a loop with 15 steps.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含15个步骤的循环。
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Write in the console the name of the owner of the lock.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中写入锁的所有者的名称。
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Display the number and the name of the threads queued for the lock.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示排队等待锁的线程的数量和名称。
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Display information about the fairness and the status of the `Lock` object.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示关于`Lock`对象的公平性和状态的信息。
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Put the thread to sleep for 1 second and close the loop and the class.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将线程休眠1秒并关闭循环和类。
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, you have implemented the `MyLock` class that extends the `ReentrantLock`
    class to return information that otherwise wouldn''t have been available – it''s
    protected data of the `ReentrantLock` class. The methods implemented by the `MyLock`
    class are:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您已经实现了`MyLock`类，该类扩展了`ReentrantLock`类，以返回原本无法获得的信息-这是`ReentrantLock`类的受保护数据。`MyLock`类实现的方法有：
- en: '`getOwnerName()`: Only one thread can execute a critical section protected
    by a `Lock` object. The lock stores the thread that is executing the critical
    section. This thread is returned by the protected `getOwner()` method of the `ReentrantLock`
    class. This method uses the `getOwner()` method to return the name of that thread.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getOwnerName()`:只有一个线程可以执行由`Lock`对象保护的临界区。锁存储正在执行临界区的线程。此线程由`ReentrantLock`类的受保护`getOwner()`方法返回。此方法使用`getOwner()`方法返回该线程的名称。'
- en: '`getThreads()`: While a thread is executing a critical section, the other threads
    that try to enter it are put to sleep until they can continue executing that critical
    section. The protected method `getQueuedThreads()` of the `ReentrantLock` class
    returns the list of threads that are waiting to execute the critical section.
    This method returns the result returned by the `getQueuedThreads()` method.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getThreads()`:当一个线程执行临界区时，试图进入它的其他线程被放到睡眠状态，直到它们可以继续执行该临界区。`ReentrantLock`类的受保护方法`getQueuedThreads()`返回等待执行临界区的线程列表。此方法返回`getQueuedThreads()`方法返回的结果。'
- en: 'We have also used other methods that are implemented in the `ReentrantLock`
    class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`ReentrantLock`类中实现的其他方法：
- en: '`hasQueuedThreads()`: This method returns a `Boolean` value indicating if there
    are threads waiting to acquire this lock'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasQueuedThreads()`:此方法返回一个`Boolean`值，指示是否有线程正在等待获取此锁'
- en: '`getQueueLength()`: This method returns the number of threads that are waiting
    to acquire this lock'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueueLength()`:此方法返回正在等待获取此锁的线程数'
- en: '`isLocked()`: This method returns a `Boolean` value indicating whether this
    lock is owned by a thread'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLocked()`:此方法返回一个`Boolean`值，指示此锁是否由线程拥有'
- en: '`isFair()`: This method returns a `Boolean` value indicating if this lock has
    the fair mode activated'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFair()`:此方法返回一个`Boolean`值，指示此锁是否已激活公平模式'
- en: There's more...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are other methods in the `ReentrantLock` class that can be used to obtain
    information about a `Lock` object:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReentrantLock`类中还有其他方法可用于获取有关`Lock`对象的信息：'
- en: '`getHoldCount()`: Returns the number of times that the current thread has acquired
    the lock'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getHoldCount()`:返回当前线程获取锁的次数'
- en: '`isHeldByCurrentThread()`: Returns a `Boolean` value indicating if the lock
    is owned by the current thread'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isHeldByCurrentThread()`:返回一个`Boolean`值，指示锁是否由当前线程拥有'
- en: See also
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Synchronizing a block of code with a lock* recipe in [Chapter 2](ch02.html
    "Chapter 2. Basic Thread Synchronization"), *Basic Thread Synchronization*
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2章“基本线程同步”中的*使用锁同步代码块*食谱
- en: The *Implementing a custom Lock class* recipe in [Chapter 7](ch07.html "Chapter 7. Customizing
    Concurrency Classes"), *Customizing Concurrency Classes*
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第7章“自定义并发类”中的*实现自定义锁类*食谱
- en: Monitoring a Phaser class
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视`Phaser`类
- en: One of the most complex and powerful functionalities offered by the Java Concurrency
    API is the ability to execute concurrent phased tasks using the `Phaser` class.
    This mechanism is useful when we have some concurrent tasks divided in steps.
    The `Phaser` class provides us the mechanism to synchronize the threads at the
    end of each step, so no thread starts its second step until all the threads have
    finished the first one.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供的最复杂和强大的功能之一是使用`Phaser`类执行并发分阶段任务的能力。当我们有一些并发任务分为步骤时，这种机制非常有用。`Phaser`类为我们提供了在每个步骤结束时同步线程的机制，因此在所有线程完成第一步之前，没有线程开始其第二步。
- en: In this recipe, you will learn what information about the status of a `Phaser`
    class you can obtain and how to obtain that information.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习有关`Phaser`类状态的信息以及如何获取该信息。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的示例是使用Eclipse IDE实现的。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to implement the example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Task` that implements the `Runnable` interface.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，实现`Runnable`接口。
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Declare a private `int` attribute named `time`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`time`的私有`int`属性。
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Declare a private `Phaser` attribute named `phaser`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`phaser`的私有`Phaser`属性。
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Implement the `run()` method. First, instruct the `phaser` attribute that the
    task starts its execution with the `arrive()` method.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。首先，使用`arrive()`方法指示`phaser`属性任务开始执行。
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Write a message in the console indicating the start of phase one, put the thread
    to sleep for the number of seconds specified by the `time` attribute, write in
    the console a message indicating the end of phase one, and synchronize with the
    rest of the tasks using the `arriveAndAwaitAdvance()` method of the `phaser` attribute.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中写入一条消息，指示第一阶段的开始，将线程休眠指定`time`属性的秒数，在控制台中写入一条消息，指示第一阶段的结束，并使用`phaser`属性的`arriveAndAwaitAdvance()`方法与其余任务同步。
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Repeat the behavior for the second and third phases. At the end of the third
    phase, use the `arriveAndDeregister()` method instead of `arriveAndAwaitAdvance()`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复第二和第三阶段的行为。在第三阶段结束时，使用`arriveAndDeregister()`方法而不是`arriveAndAwaitAdvance()`。
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并实现`main()`方法来实现示例的主类。
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Create a new `Phaser` object named `phaser` with three participants.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`phaser`的新`Phaser`对象，其中包含三个参与者。
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Create and launch three threads to execute three task objects.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动三个线程来执行三个任务对象。
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Create a loop with 10 steps to write information about the `phaser` object.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含10个步骤的循环，以写入关于`phaser`对象的信息。
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Write information about the registered parties, the phase of the phaser, the
    arrived parties, and the un-arrived parties.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入关于已注册任务、phaser阶段、已到达任务和未到达任务的信息。
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Put the thread to sleep for 1 second and close the loop and the class.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将线程休眠1秒并关闭循环和类。
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we have implemented a phased task in the `Task` class. This
    phased task has three phases and uses a `Phaser` interface to synchronize with
    other `Task` objects. The main class launches three tasks and while these tasks
    are executing their phases, it prints information about the status of the `phaser`
    object to the console. We have used the following methods to get the status of
    the `phaser` object:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们在`Task`类中实现了一个分阶段任务。这个分阶段任务有三个阶段，并使用`Phaser`接口与其他`Task`对象同步。主类启动三个任务，当这些任务执行它们的阶段时，它会在控制台上打印关于`phaser`对象状态的信息。我们使用以下方法来获取`phaser`对象的状态：
- en: '`getPhase()`: This method returns the actual phase of a `phaser` object'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPhase()`:此方法返回`phaser`对象的实际阶段'
- en: '`getRegisteredParties()`: This method returns the number of tasks that use
    a `phaser` object as a mechanism of synchronization'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRegisteredParties()`:此方法返回使用`phaser`对象作为同步机制的任务数'
- en: '`getArrivedParties()`: This method returns the number of tasks that have arrived
    at the end of the actual phase'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getArrivedParties()`:此方法返回已到达实际阶段结束的任务数'
- en: '`getUnarrivedParties()`: This method returns the number of tasks that haven''t
    yet arrived at the end of the actual phase'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUnarrivedParties()`:此方法返回尚未到达实际阶段结束的任务数'
- en: 'The following screenshot shows part of the output of the program:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了程序的部分输出：
- en: '![How it works...](img/7881_08_01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/7881_08_01.jpg)'
- en: See also
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Running concurrent phased tasks* recipe in [Chapter 3](ch03.html "Chapter 3. Thread
    Synchronization Utilities"), *Thread Synchronization Utilities*
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章 线程同步工具")的*线程同步工具*中的*运行并发分阶段任务*食谱
- en: Monitoring an Executor framework
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视执行器框架
- en: The Executor framework provides a mechanism that separates the implementation
    of tasks from the thread creation and management to execute those tasks. If you
    use an executor, you only have to implement the `Runnable` objects and send them
    to the executor. It is the responsibility of an executor to manage threads. When
    you send a task to an executor, it tries to use a pooled thread for the execution
    of this task, to avoid creating new threads. This mechanism is offered by the
    `Executor` interface and its implementing classes as the `ThreadPoolExecutor`
    class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器框架提供了一种机制，将任务的实现与线程的创建和管理分开，以执行这些任务。如果使用执行器，只需实现`Runnable`对象并将它们发送到执行器。执行器负责管理线程。当将任务发送到执行器时，它会尝试使用池化线程来执行此任务，以避免创建新线程。这种机制由`Executor`接口及其实现类`ThreadPoolExecutor`类提供。
- en: In this recipe, you're going to learn what information you can obtain about
    the status of a `ThreadPoolExecutor` executor and how to obtain it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习如何获取关于`ThreadPoolExecutor`执行器状态的信息以及如何获取它。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的示例是使用Eclipse IDE实现的。如果您使用Eclipse或其他IDE如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Task` that implements the `Runnable` interface.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的实现`Runnable`接口的类。
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Declare a private `long` attribute named `milliseconds`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`milliseconds`的私有`long`属性。
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Implement the constructor of the class to initialize its attribute.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Implement the `run()` method. Put the thread to sleep for the number of milliseconds
    specified by the `milliseconds` attribute.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。将线程休眠`milliseconds`属性指定的毫秒数。
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并实现`main()`方法来实现示例的主类。
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Create a new `Executor` object using the `newCachedThreadPool()` method of the
    `Executors` class.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Executors`类的`newCachedThreadPool()`方法创建一个新的`Executor`对象。
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Create and submit 10 `Task` objects to the executor. Initialize the objects
    with a random number.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并提交10个`Task`对象到执行器。使用随机数初始化对象。
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Create a loop with five steps. In each step, write information about the executor
    calling the `showLog()` method and put the thread to sleep for a second.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含五个步骤的循环。在每个步骤中，调用`showLog()`方法写入关于执行器的信息，并将线程休眠一秒。
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Shut down the executor using the `shutdown()` method.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法关闭执行器。
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Create another loop with five steps In each step, write information about the
    executor calling the `showLog()` method and put the thread to sleep for a second.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个包含五个步骤的循环。在每个步骤中，调用`showLog()`方法写入关于执行器的信息，并将线程休眠一秒。
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Wait for the finalization of the executor using the `awaitTermination()` method.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`awaitTermination()`方法等待执行器的完成。
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Display a message about the end of the program.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示关于程序结束的消息。
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Implement the `showLog()` method that receives `Executor` as parameter. Write
    information about the size of the pool, the number of tasks, and the status of
    the executor.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`showLog()`方法，该方法接收`Executor`作为参数。写入关于池的大小、任务数和执行器状态的信息。
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, you have implemented a task that blocks its execution thread
    for a random number of milliseconds. Then, you have sent 10 tasks to an executor
    and while you''re waiting for their finalization, you have written information
    about the status of the executor to the console. You have used the following methods
    to get the status of the `Executor` object:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在此食谱中，您已经实现了一个任务，该任务会阻塞其执行线程一段随机毫秒数。然后，您已经将10个任务发送到执行器，同时等待它们的完成，您已经将有关执行器状态的信息写入控制台。您已使用以下方法来获取`Executor`对象的状态：
- en: '`getCorePoolSize()`: This method returns an `int` number, which is the core
    number of threads. It''s the minimum number of threads that will be in the internal
    thread pool when the executor is not executing any task.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCorePoolSize()`: 此方法返回一个`int`数字，表示核心线程数。这是执行器在不执行任何任务时内部线程池中的最小线程数。'
- en: '`getPoolSize()`: This method returns an `int` value, which is the actual size
    of the internal thread pool.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPoolSize()`: 此方法返回一个`int`值，表示内部线程池的实际大小。'
- en: '`getActiveCount()`: This method returns an `int` number, which is the number
    of threads that are currently executing tasks.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getActiveCount()`: 此方法返回一个`int`数字，表示当前正在执行任务的线程数。'
- en: '`getTaskCount()`: This method returns a `long` number, which is the number
    of tasks that have been scheduled for execution.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTaskCount()`: 此方法返回一个`long`数字，表示已安排执行的任务数。'
- en: '`getCompletedTaskCount()`: This method returns a `long` number, which is the
    number of tasks that have been executed by this executor and have finished their
    execution.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCompletedTaskCount()`: 此方法返回一个`long`数字，表示已由此执行器执行并已完成执行的任务数。'
- en: '`isShutdown()`: This method returns a `Boolean` value when the `shutdown()`
    method of an executor has been called to finish its execution.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isShutdown()`: 当执行器的`shutdown()`方法已被调用以结束其执行时，此方法返回一个`Boolean`值。'
- en: '`isTerminating()`: This method returns a `Boolean` value when the executor
    is doing the `shutdown()` operation, but it hasn''t finished it yet.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminating()`: 当执行器正在执行`shutdown()`操作但尚未完成时，此方法返回一个`Boolean`值。'
- en: '`isTerminated()`: This method returns a `Boolean` value when this executor
    has finished its execution.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminated()`: 当此执行器已完成其执行时，此方法返回一个`Boolean`值。'
- en: See also
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a thread executor* recipe in [Chapter 4](ch04.html "Chapter 4. Thread
    Executors"), *Thread Executors*
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。线程执行器")的*创建线程执行器*食谱中，*线程执行器*
- en: The *Customizing the ThreadPoolExecutor class* recipe in [Chapter 7](ch07.html
    "Chapter 7. Customizing Concurrency Classes"), *Customizing Concurrency Classes*
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。自定义并发类")的*自定义ThreadPoolExecutor类*食谱中，*自定义并发类*
- en: The *Implementing a priority-based Executor class* recipe in [Chapter 7](ch07.html
    "Chapter 7. Customizing Concurrency Classes"), *Customizing Concurrency Classes*
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。自定义并发类")的*实现基于优先级的Executor类*食谱中，*自定义并发类*
- en: Monitoring a Fork/Join pool
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视Fork/Join池
- en: The Executor framework provides a mechanism that allows the separation of the
    task implementation from the creation and management of the threads that execute
    those tasks. Java 7 includes an extension of the Executor framework for a specific
    kind of problem that will improve the performance of other solutions (as using
    `Thread` objects directly or the Executor framework). It's the Fork/Join framework.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器框架提供了一种机制，允许将任务实现与执行这些任务的线程的创建和管理分离。Java 7包括执行器框架的扩展，用于一种特定类型的问题，将改善其他解决方案的性能（如直接使用`Thread`对象或执行器框架）。这就是Fork/Join框架。
- en: This framework is designed to solve those problems that can be broken into smaller
    tasks using the divide and conquer technique using the `fork()` and `join()` operations.
    The main class that implements this behavior is the `ForkJoinPool` class.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架旨在使用`fork()`和`join()`操作将问题分解为较小的任务来解决问题。实现此行为的主要类是`ForkJoinPool`类。
- en: In this recipe, you're going to learn what information you can obtain about
    a `ForkJoinPool` class and how to obtain it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在此食谱中，您将学习有关`ForkJoinPool`类的信息以及如何获取它。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Task` that extends the `RecursiveAction` class.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，该类扩展了`RecursiveAction`类。
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Declare a private `int` array attribute named `array` to store the array of
    elements you want to increment.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`int`数组属性，命名为`array`，以存储要增加的元素数组。
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Declare two private `int` attributes named `start` and `end` to store the start
    and end positions of the block of elements this task has to process.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个私有的`int`属性，命名为`start`和`end`，以存储此任务必须处理的元素块的起始和结束位置。
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Implement the `compute()` method with the main logic of the task. If the task
    has to process more than 100 elements, divide that set of elements in two parts,
    create two tasks to execute those parts, start its execution with the `fork()`
    method, and wait for its finalization with the `join()` method.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`compute()`方法实现任务的主要逻辑。如果任务需要处理超过100个元素，则将这组元素分成两部分，创建两个任务来执行这些部分，使用`fork()`方法开始执行，使用`join()`方法等待其完成。
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If the task has to process 100 elements or less, increment those elements by
    putting the thread to sleep for 5 milliseconds after each operation.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任务需要处理100个或更少的元素，则通过在每个操作后使线程休眠5毫秒来增加这些元素。
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并实现一个`main()`方法来实现示例的主类。
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Create a `ForkJoinPool` object named `pool`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`pool`的`ForkJoinPool`对象。
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Create an array of integer numbers named `array` with 10,000 elements.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`array`的整数数组，其中包含10,000个元素。
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Create a new `Task` object to process the whole array.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Task`对象来处理整个数组。
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Send the task for execution in the pool using the `execute()` method.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`execute()`方法将任务发送到池中执行。
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: While the task doesn't finish its execution, call the `showLog()` method to
    write information about the status of the `ForkJoinPool` class and put the thread
    to sleep for a second.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任务未完成执行时，调用`showLog()`方法以写入有关`ForkJoinPool`类状态的信息，并使线程休眠一秒钟。
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Shut down the pool using the `shutdown()` method.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutdown()`方法关闭池。
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Wait for the finalization of the pool using the `awaitTermination()` method.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`awaitTermination()`方法等待池的完成。
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Call the `showLog()` method to write information about the status of the `ForkJoinPool`
    class and write a message in the console indicating the end of the program.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`showLog()`方法以写入有关`ForkJoinPool`类状态的信息，并在控制台中写入程序结束的消息。
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Implement the `showLog()` method. It receives a `ForkJoinPool` object as a parameter
    and writes information about its status and the threads and tasks that are executing.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`showLog()`方法。它接收一个`ForkJoinPool`对象作为参数，并写入有关其状态以及正在执行的线程和任务的信息。
- en: '[PRE59]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, you have implemented a task that increments elements of an
    array using a `ForkJoinPool` class and a `Task` class that extends the `RecursiveAction`
    class; one of the kind of tasks that you can execute in a `ForkJoinPool` class.
    While the tasks are processing the array, you print information about the status
    of the `ForkJoinPool` class to the console. You have used the following methods
    to get the status of the `ForkJoinPool` class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您已经实现了一个任务，该任务使用`ForkJoinPool`类和扩展`RecursiveAction`类的`Task`类来增加数组的元素；这是您可以在`ForkJoinPool`类中执行的任务类型之一。在任务处理数组时，您将有关`ForkJoinPool`类状态的信息打印到控制台。您已使用以下方法来获取`ForkJoinPool`类的状态：
- en: '`getPoolSize()`: This method returns an `int` value, which is the number of
    worker threads of the internal pool of a fork join pool'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPoolSize()`:此方法返回一个`int`值，即fork join池的内部池的工作线程数'
- en: '`getParallelism()`: This method returns the desired level of parallelism established
    for a pool'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getParallelism()`:此方法返回为池建立的所需并行级别'
- en: '`getActiveThreadCount()`: This method returns the number of threads that are
    currently executing tasks'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getActiveThreadCount()`:此方法返回当前执行任务的线程数'
- en: '`getRunningThreadCount()`: This method returns the number of working threads
    that are not blocked in any synchronization mechanism'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRunningThreadCount()`:此方法返回未在任何同步机制中阻塞的工作线程数'
- en: '`getQueuedSubmissionCount()`: This method returns the number of tasks that
    have been submitted to a pool that haven''t started their execution yet'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueuedSubmissionCount()`:此方法返回已提交到池中但尚未开始执行的任务数'
- en: '`getQueuedTaskCount()`: This method returns the number of tasks that have been
    submitted to a pool that have started their execution'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getQueuedTaskCount()`:此方法返回已提交到池中并已开始执行的任务数'
- en: '`hasQueuedSubmissions()`: This method returns a `Boolean` value indicating
    if this pool has queued tasks that haven''t started their execution yet'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasQueuedSubmissions()`:此方法返回一个`Boolean`值，指示此池是否有已提交但尚未开始执行的任务'
- en: '`getStealCount()`: This method returns a `long` value with the number of times
    a worker thread has stolen a task from another thread'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getStealCount()`:此方法返回一个`long`值，表示工作线程从另一个线程中窃取任务的次数'
- en: '`isTerminated()`: This method returns a `Boolean` value indicating if the fork/join
    pool has finished its execution'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminated()`:此方法返回一个`Boolean`值，指示fork/join池是否已完成执行'
- en: See also
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a Fork/Join pool* recipe in [Chapter 5](ch05.html "Chapter 5. Fork/Join
    Framework"), *Fork/Join Framework*
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。Fork/Join Framework")中的*创建Fork/Join池*示例，*Fork/Join Framework*'
- en: The *Implementing the ThreadFactory interface to generate custom threads for
    the Fork/Join framework* recipe in [Chapter 7](ch07.html "Chapter 7. Customizing
    Concurrency Classes"), *Customizing Concurrency Classes*
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章。自定义并发类")中的*实现ThreadFactory接口以为Fork/Join框架生成自定义线程*示例，*自定义并发类*'
- en: The *Customizing tasks running in the Fork/Join framework* recipe in [Chapter
    7](ch07.html "Chapter 7. Customizing Concurrency Classes"), *Customizing Concurrency
    Classes*
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章。自定义并发类")中的*自定义Fork/Join框架中运行的任务*示例，*自定义并发类*'
- en: Writing effective log messages
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写有效的日志消息
- en: 'A **log system** is a mechanism that allows you to write information to one
    or more destinations. A **Logger** has the following components:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 日志系统是一种机制，允许您将信息写入一个或多个目的地。Logger具有以下组件：
- en: '**One or more handlers**: A handler will determine the destination and the
    format of log messages. You can write log messages to the console, a file, or
    a database.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个或多个处理程序**：处理程序将确定日志消息的目的地和格式。您可以将日志消息写入控制台、文件或数据库。'
- en: '**A name**: Usually, the name of a Logger used in a class that''s based on
    the class name and its package name.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个名称**：通常，Logger的名称基于类名和其包名。'
- en: '**A level**: Log messages have a level associated that indicates its importance.
    A Logger also has a level used to decide what messages it is going to write. It
    only writes the messages that are as important as, or more important, than its
    level.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**级别**：日志消息具有与之关联的级别，指示其重要性。Logger还具有一个级别，用于决定它将要写入哪些消息。它只会写入与其级别一样重要或更重要的消息。'
- en: 'You should use the log system with the following two main purposes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用日志系统来实现以下两个主要目的：
- en: Write as much information as you can when an exception is caught. This will
    help to localize the error and resolve it.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获异常时尽可能多地写入信息。这将有助于定位错误并解决问题。
- en: Write information about the classes and methods that the program is executing.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入程序正在执行的类和方法的信息。
- en: In this recipe, you will learn how to use the classes provided by the `java.util.logging`
    package to add a log system to your concurrent application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将学习如何使用`java.util.logging`包提供的类为你的并发应用程序添加日志系统。
- en: Getting ready
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例已经使用Eclipse IDE实现。如果你使用Eclipse或其他IDE，比如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `MyFormatter` that extends the `java.util.logging.Formatter`
    class. Implement the abstract `format()` method. It receives a `LogRecord` object
    as a parameter and returns a `String` object with the log message.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyFormatter`的类，它继承了`java.util.logging.Formatter`类。实现抽象的`format()`方法。它接收一个`LogRecord`对象作为参数，并返回一个带有日志消息的`String`对象。
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Create a class named `MyLogger`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyLogger`的类。
- en: '[PRE61]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Declare a private static `Handler` attribute named `handler`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有静态的`Handler`属性，名为`handler`。
- en: '[PRE62]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Implement the public static method `getLogger()` to create the `Logger` object
    that you're going to use to write the log messages. It receives a `String` parameter
    named `name`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现公共静态方法`getLogger()`来创建你要用来写日志消息的`Logger`对象。它接收一个名为`name`的`String`参数。
- en: '[PRE63]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Get `java.util.logging.Logger` associated with the name received as a parameter
    using the `getLogger()` method of the `Logger` class.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Logger`类的`getLogger()`方法，获取与接收的名称相关联的`java.util.logging.Logger`。
- en: '[PRE64]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Establish the log level to write all the log messages using the `setLevel()`
    method.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`setLevel()`方法将日志级别设置为写入所有日志消息。
- en: '[PRE65]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If the handler attribute has the `null` value, create a new `FileHandler` object
    to write the log messages in the `recipe8.log` file. Assign to that handler a
    `MyFormatter` object as a formatter using the `setFormatter()` object.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果handler属性的值为`null`，则创建一个新的`FileHandler`对象，将日志消息写入`recipe8.log`文件中。使用`setFormatter()`方法将一个`MyFormatter`对象分配给该handler作为格式化程序。
- en: '[PRE66]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If the `Logger` object does not have a handler associated to it, assign the
    handler using the `addHandler()` method.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`Logger`对象没有与之关联的处理程序，使用`addHandler()`方法分配处理程序。
- en: '[PRE67]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Return the `Logger` object created.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回创建的`Logger`对象。
- en: '[PRE68]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Create a class named `Task` that implements the `Runnable` interface. It will
    be the task used to test your `Logger` object.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，实现`Runnable`接口。它将是用来测试你的`Logger`对象的任务。
- en: '[PRE69]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Implement the `run()` method.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: First, declare a `Logger` object named `logger`. Initialize it using the `getLogger()`
    method of the `MyLogger` class passing the name of this class as a parameter.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，声明一个名为`logger`的`Logger`对象。使用`MyLogger`类的`getLogger()`方法初始化它，传递这个类的名称作为参数。
- en: '[PRE71]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Write a log message indicating the beginning of the execution of the method
    using the `entering()` method.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`entering()`方法编写一个日志消息，指示方法执行的开始。
- en: '[PRE72]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Write a log message indicating the end of the execution of the method using
    the `exiting()` method.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`exiting()`方法编写一个日志消息，指示方法执行的结束。
- en: '[PRE73]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并实现一个`main()`方法来实现示例的主类。
- en: '[PRE74]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Declare a `Logger` object named `logger`. Initialize it using the `getLogger()`
    method of the `MyLogger` class passing the string `Core` as a parameter.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`logger`的`Logger`对象。使用`MyLogger`类的`getLogger()`方法初始化它，传递字符串`Core`作为参数。
- en: '[PRE75]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Write a log message indicating the start of the execution of the main program
    using the `entering()` method.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`entering()`方法编写一个日志消息，指示主程序的执行开始。
- en: '[PRE76]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Create a `Thread` array to store five threads.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Thread`数组来存储五个线程。
- en: '[PRE77]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Create five `Task` objects and five threads to execute them. Write log messages
    to indicate that you're going to launch a new thread and to indicate that you
    have created the thread.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建五个`Task`对象和五个线程来执行它们。编写日志消息来指示你将要启动一个新线程，并指示你已经创建了该线程。
- en: '[PRE78]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Write a log message to indicate that you have created the threads.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一个日志消息来指示你已经创建了线程。
- en: '[PRE79]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Wait for the finalization of the five threads using the `join()` method. After
    the finalization of each thread, write a log message indicating that the thread
    has finished.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待五个线程的完成。在每个线程完成后，编写一个日志消息，指示该线程已经完成。
- en: '[PRE80]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Write a log message to indicate the end of the execution of the main program
    using the `exiting()` method.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`exiting()`方法编写一个日志消息，指示主程序的执行结束。
- en: '[PRE81]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: How it works...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, you have used the `Logger` class provided for the Java logging
    API to write log messages in a concurrent application. First of all, you have
    implemented the `MyFormatter` class to give a format to the log messages. This
    class extends the `Formatter` class that declares the abstract method `format()`.
    This method receives a `LogRecord` object with all the information of the log
    message and returns a formatted log message. In your class, you have used the
    following methods of the `LogRecord` class to obtain information about the log
    message:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你已经使用了Java日志API提供的`Logger`类来在并发应用程序中写入日志消息。首先，你实现了`MyFormatter`类来给日志消息提供格式。这个类扩展了声明了抽象方法`format()`的`Formatter`类。这个方法接收一个带有日志消息所有信息的`LogRecord`对象，并返回一个格式化的日志消息。在你的类中，你使用了`LogRecord`类的以下方法来获取有关日志消息的信息：
- en: '`getLevel()`: Returns the level of a message'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getLevel()`: 返回消息的级别'
- en: '`getMillis()`: Returns the date when a message was sent to a `Logger` object'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getMillis()`: 返回消息被发送到`Logger`对象时的日期'
- en: '`getSourceClassName()`: Returns the name of a class that sent the message to
    the Logger'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSourceClassName()`: 返回发送消息给Logger的类的名称'
- en: '`getSourceMessageName()`: Returns the name of a method that sent the message
    to the Logger'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSourceMessageName()`: 返回发送消息给Logger的方法的名称'
- en: '`getMessage()` returns the log message. The `MyLogger` class implements the
    static method `getLogger()` that creates a `Logger` object and assigns a `Handler`
    object to write log messages of the application to the `recipe8.log` file using
    the `MyFormatter` formatter. You create the `Logger` object with the static method
    `getLogger()` of that class. This method returns a different object per name that
    is passed as a parameter. You only have created one `Handler` object, so all the
    `Logger` objects will write its log messages in the same file. You also have configured
    the logger to write all the log messages, regardless of its level.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`getMessage()`返回日志消息。`MyLogger`类实现了静态方法`getLogger()`，它创建一个`Logger`对象，并分配一个`Handler`对象来将应用程序的日志消息写入`recipe8.log`文件，使用`MyFormatter`格式化程序。您可以使用该类的静态方法`getLogger()`创建`Logger`对象。此方法根据传递的名称返回不同的对象。您只创建了一个`Handler`对象，因此所有`Logger`对象都将在同一个文件中写入其日志消息。您还配置了记录器以写入所有日志消息，而不管其级别如何。'
- en: 'Finally, you have implemented a `Task` object and a main program that writes
    different log messages in the logfile. You have used the following methods:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您已实现了一个`Task`对象和一个主程序，它在日志文件中写入不同的日志消息。您已使用以下方法：
- en: '`entering()`: Write a message with the `FINER` level indicating that a method
    starts its execution'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entering()`: 用`FINER`级别写入指示方法开始执行的消息'
- en: '`exiting()`: Write a message with the `FINER` level indicating that a method
    ends its execution'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exiting()`: 用`FINER`级别写入指示方法结束执行的消息'
- en: '`log()`: Write a message with the specified level'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log()`: 用指定级别写入消息'
- en: There's more...
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When you work with a log system, you have to take into consideration two important
    points:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用日志系统时，您必须考虑两个重要点：
- en: '**Write the necessary information**: If you write too little information, the
    logger won''t be useful because it won''t fulfil its purpose. If you write too
    much information, you will generate too large logfiles that will be unmanageable
    and make it difficult to get the necessary information.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写必要的信息**：如果您写的信息太少，日志记录器将不会有用，因为它无法实现其目的。如果您写的信息太多，将生成太大的日志文件，这将使其难以管理，并且难以获取必要的信息。'
- en: '**Use the adequate level for the messages**: If you write information messages
    with the higher level or error messages with a lower level, you will confuse the
    user who looks at the logfiles. It will be more difficult to know what happened
    in an error situation or you will have too much information to know the main cause
    of the error.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用适当的消息级别**：如果您使用更高级别的信息消息或更低级别的错误消息，将会使查看日志文件的用户感到困惑。在错误情况下更难知道发生了什么，或者您将获得太多信息以知道错误的主要原因。'
- en: There are other libraries that provide a log system more complete than the `java.util.logging`
    package, such as the Log4j or slf4j libraries. But the `java.util.logging` package
    is part of the Java API and all its methods are multi-thread safe, so we can use
    it in concurrent applications without problems.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他提供比`java.util.logging`包更完整的日志系统的库，比如Log4j或slf4j库。但`java.util.logging`包是Java
    API的一部分，其所有方法都是多线程安全的，因此我们可以在并发应用中使用它而不会出现问题。
- en: See also
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using non-blocking thread-safe lists* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章 并发集合")中的*使用非阻塞线程安全列表*配方，*并发集合*'
- en: The *Using blocking thread-safe lists* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章 并发集合")中的*使用阻塞线程安全列表*配方，*并发集合*'
- en: The *Using blocking thread-safe lists ordered by priority* recipe in [Chapter
    6](ch06.html "Chapter 6. Concurrent Collections"), *Concurrent Collections*
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章 并发集合")中的*使用按优先级排序的阻塞线程安全列表*配方，*并发集合*'
- en: The *Using thread-safe lists with delayed elements* recipe in [Chapter 6](ch06.html
    "Chapter 6. Concurrent Collections"), *Concurrent Collections*
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章 并发集合")中的*使用延迟元素的线程安全列表*配方，*并发集合*'
- en: The *Using thread-safe navigable maps* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章 并发集合")中的*使用线程安全可导航映射*配方，*并发集合*'
- en: The *Generating concurrent random numbers* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章 并发集合")中的*生成并发随机数*配方，*并发集合*'
- en: Analyzing concurrent code with FindBugs
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FindBugs分析并发代码
- en: The **static code analysis tools** are a set of tools that analyze the source
    code of an application looking for potential errors. These tools, such as Checkstyle,
    PMD, or FindBugs have a set of predefined rules of good practices and parse the
    source code looking for violations of those rules. The objective is to find errors
    or places causing poor performance early, before it will be executed in production.
    Programming languages usually offer such tools and Java is not an exception. One
    of these tools to analyze Java code is FindBugs. It's an open source tool that
    includes a series of rules to analyze Java-concurrent code.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态代码分析工具**是一组分析应用程序源代码寻找潜在错误的工具。这些工具，如Checkstyle、PMD或FindBugs，具有一组预定义的最佳实践规则，并解析源代码以查找违反这些规则的情况。其目标是在应用程序执行之前尽早发现错误或导致性能不佳的地方。编程语言通常提供此类工具，Java也不例外。用于分析Java代码的工具之一是FindBugs。这是一个开源工具，包括一系列规则来分析Java并发代码。'
- en: In this recipe, you will learn how to use this tool to analyze your Java-concurrent
    applications.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，您将学习如何使用此工具分析您的Java并发应用程序。
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before stating this recipe, you should download FindBugs from the project's
    web page ([http://findbugs.sourceforge.net/](http://findbugs.sourceforge.net/)).
    You can download a standalone application or an Eclipse plugin. In this recipe,
    you will use the standalone version.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此配方之前，您应该从项目网页下载FindBugs（[http://findbugs.sourceforge.net/](http://findbugs.sourceforge.net/)）。您可以下载一个独立的应用程序或一个Eclipse插件。在此配方中，您将使用独立版本。
- en: How to do it...
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Task` that extends the `Runnable` interface.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，该类扩展了`Runnable`接口。
- en: '[PRE82]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Declare a private `ReentrantLock` attribute named `Lock`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`Lock`的私有`ReentrantLock`属性。
- en: '[PRE83]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Implement a constructor of the class.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数。
- en: '[PRE84]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Implement the `run()` method. Get the control of the lock, put the thread to
    sleep for 2 seconds and free the lock.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。获取锁的控制权，使线程休眠2秒并释放锁。
- en: '[PRE85]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Create the main class of the example by creating a class named `Main` with a
    `main()` method.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个带有`main()`方法的名为`Main`的类来创建示例的主类。
- en: '[PRE86]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Declare and create a `ReentrantLock` object named `lock`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并创建一个名为`lock`的`ReentrantLock`对象。
- en: '[PRE87]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Create 10 `Task` objects and 10 threads to execute those tasks. Start the threads
    calling the `run()` method.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建10个`Task`对象和10个线程来执行这些任务。调用`run()`方法启动线程。
- en: '[PRE88]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Export the project as a `jar` file. Call it `recipe8.jar`. Use the menu option
    of your IDE or the `javac` and `jar` commands to compile and compress your application.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目导出为`jar`文件。将其命名为`recipe8.jar`。使用IDE的菜单选项或`javac`和`jar`命令来编译和压缩应用程序。
- en: Start the FindBugs standalone application running the `findbugs.bat`**command
    in Windows or the `findbugs.sh` command in Linux.**
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`findbugs.bat`命令（Windows）或`findbugs.sh`命令（Linux）启动FindBugs独立应用程序。
- en: '**Create a new project with the **New Project** option of the **File** menu
    in the menu bar.![How to do it...](img/7881_08_02.jpg)**'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用菜单栏中的**文件**菜单中的**新建项目**选项创建新项目。![如何做...](img/7881_08_02.jpg)**'
- en: '**The **FindBugs** application shows a window to configure the project. In
    the **Project Name** field introduce the text `Recipe08`. In the **Classpath for
    analysis** field add the `jar` file with the project and in the **Source directories**
    field add the directory with the source code of the example. Refer to the following
    screenshot:![How to do it...](img/7881_08_03.jpg)**'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**FindBugs**应用程序显示了一个配置项目的窗口。在**项目名称**字段中输入文本`Recipe08`。在**分析的类路径**字段中添加带有项目的`jar`文件，在**源目录**字段中添加示例源代码的目录。参考以下屏幕截图：![如何做...](img/7881_08_03.jpg)**'
- en: '**Click on the **Analyze** button to create the new project and analyze its
    code.**'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单击**分析**按钮以创建新项目并分析其代码。**'
- en: '**The **FindBugs** application shows the result of the analysis of the code.
    In this case,it has found two bugs.**'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**FindBugs**应用程序显示了代码分析的结果。在这种情况下，它发现了两个错误。'
- en: '**Click one of the bugs and you''ll see the source code of the bug in the right-hand
    side panel and the description of the bug in the panel of the bottom of the screen.**'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单击其中一个错误，您将在右侧面板看到错误的源代码，并在屏幕底部的面板中看到错误的描述。**'
- en: '**How it works...**'
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**它是如何工作的...**'
- en: '**The following screenshot shows the result of the analysis by FindBugs:**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**以下屏幕截图显示了FindBugs的分析结果：**'
- en: '**![How it works...](img/7881_08_04.jpg)**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**![它是如何工作的...](img/7881_08_04.jpg)**'
- en: '**The analysis has detected the following two potential bugs in the application:**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析已检测到应用程序中以下两个潜在错误：**'
- en: '**One in the `run()` method of the class `Task`. If an `InterruptedExeption`
    exception is thrown, the task doesn''t free the lock because it won''t execute
    the `unlock()` method. This will probably cause a deadlock situation in the application.**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个在`Task`类的`run()`方法中。如果抛出`InterruptedExeption`异常，则任务不会释放锁，因为它不会执行`unlock()`方法。这可能会导致应用程序中的死锁情况。**'
- en: '**The other is in the `main()` method of the `Main` class because you have
    called the `run()` method of a thread directly , but not the `start()` method
    to begin the execution of the thread.**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**另一个在`Main`类的`main()`方法中，因为您直接调用了线程的`run()`方法，但没有调用`start()`方法来开始线程的执行。**'
- en: '**If you make a double-click in one of the two bugs, you will see detailed
    information about it. As you have included the source-code reference in the configuration
    of the project, you also will see the source code where the bug was detected.
    The following screenshot shows you an example of this:**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果您在两个错误中的一个上双击，您将看到有关它的详细信息。由于您已在项目的配置中包含了源代码引用，因此您还将看到检测到错误的源代码。以下屏幕截图显示了一个示例：**'
- en: '**![How it works...](img/7881_08_05.jpg)**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**![它是如何工作的...](img/7881_08_05.jpg)**'
- en: '**There''s more...**'
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**还有更多...**'
- en: '**Be aware that FindBugs can only detect some problematic situations (related
    or not with the concurrency code). For example, if you delete the `unlock()` call
    in the `run()` method of the `Task` class and repeat the analysis, FindBugs won''t
    alert you that you get the lock in the task but you never free it.**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**请注意，FindBugs只能检测一些有问题的情况（与并发代码相关或不相关）。例如，如果您在`Task`类的`run()`方法中删除`unlock()`调用并重复分析，FindBugs不会警告您在任务中获取了锁但从未释放它。**'
- en: '**Use the tools for the static code analysis as a help to improve the quality
    of your code, but do not expect to detect all the bugs in your code.**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用静态代码分析工具来帮助提高代码质量，但不要期望能够检测到代码中的所有错误。**'
- en: '**See also**'
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**另请参阅**'
- en: '**The *Configuring NetBeans for debugging concurrency code* recipe in [Chapter
    8](ch08.html "Chapter 8. Testing Concurrent Applications"), *Testing Concurrency
    Applications***'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章 测试并发应用程序")中的*配置NetBeans以调试并发代码*配方，*测试并发应用程序***'
- en: '**# Configuring Eclipse for debugging concurrency code'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**# 配置Eclipse以调试并发代码'
- en: 'Nowadays, almost every programmer, regardless of the programming language in
    use, create their applications with an IDE. They provide lots of interesting functionalities
    integrated in the same application, such as:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，几乎每个程序员，无论使用何种编程语言，都会使用IDE创建他们的应用程序。它们提供了许多有趣的功能集成在同一个应用程序中，例如：
- en: Project management
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目管理
- en: Automatic code generation
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动生成代码
- en: Automatic documentation generation
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动生成文档
- en: Integration with control version systems
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与版本控制系统集成
- en: A debugger to test the applications
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试应用程序的调试器
- en: Different wizards to create projects and elements of the applications
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建项目和应用程序元素的不同向导
- en: One of the most helpful features of an IDE is a debugger. You can execute your
    application step-by-step and analyze the values of all the objects and variables
    of your program.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: IDE最有用的功能之一是调试器。您可以逐步执行应用程序并分析程序的所有对象和变量的值。
- en: If you work with the Java programming language, Eclipse is one of the most popular
    IDEs. It has an integrated debugger that allows you to test your applications.
    By default, when you debug a concurrent application and the debugger finds a breakpoint,
    it only stops the thread that has that breakpoint while the rest of the threads
    continue with their execution.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Java编程语言，Eclipse是最受欢迎的IDE之一。它具有集成的调试器，允许您测试应用程序。默认情况下，当您调试并发应用程序并且调试器找到断点时，它只会停止具有该断点的线程，而其他线程会继续执行。
- en: In this recipe, you will learn how to change that configuration to help you
    to test concurrent applications.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇文章中，您将学习如何更改该配置，以帮助您测试并发应用程序。
- en: Getting ready
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You must have installed the Eclipse IDE. Open it and select a project with a
    concurrent application implemented in it, for example, one of the recipes implemented
    in the book.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须安装Eclipse IDE。打开它并选择一个包含并发应用程序的项目，例如，本书中实现的某个示例。
- en: How to do it...
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Select the menu option **Window** | **Preferences**.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择菜单选项**窗口**|**首选项**。
- en: In the left-hand side menu, expand the **Java** option.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，展开**Java**选项。
- en: In the left-hand side menu, select the **Debug** option. The following screenshot
    shows the appearance of that window:![How to do it...](img/7881_08_06.jpg)
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，选择**调试**选项。以下屏幕截图显示了该窗口的外观：![如何做...](img/7881_08_06.jpg)
- en: Change the value of the **Default suspend policy for new breakpoints** from
    **Suspend Thread** to **Suspend VM** (marked in red in the screenshot).
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**新断点的默认挂起策略**的值从**挂起线程**更改为**挂起VM**（在屏幕截图中标为红色）。
- en: Click on the **OK**button to confirm the change.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**确定**按钮以确认更改。
- en: How it works...
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As we mentioned in the introduction of this recipe, by default, when you debug
    a concurrent Java application in Eclipse and the debug process finds a breakpoint,
    it only suspends the thread that hit the breakpoint first while the other threads
    continue with their execution. The following screenshot shows an example of that
    situation:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本篇文章的介绍中提到的，默认情况下，在Eclipse中调试并发Java应用程序时，如果调试过程找到断点，它只会挂起首先触发断点的线程，而其他线程会继续执行。以下屏幕截图显示了这种情况的示例：
- en: '![How it works...](img/7881_08_07.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_08_07.jpg)'
- en: 'You can see that only the **worker-21** is suspended (marked in red in the
    screenshot) while the rest of the threads are running. However, if you change
    **Default suspend policy for new breakpoints** to **Suspend VM**, all the threads
    suspend their execution while you''re debugging a concurrent application and the
    debug process hits a breakpoint. The following screenshot shows an example of
    this situation:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到只有**worker-21**被挂起（在屏幕截图中标为红色），而其他线程正在运行。但是，如果将**新断点的默认挂起策略**更改为**挂起VM**，则在调试并发应用程序并且调试过程遇到断点时，所有线程都会暂停执行。以下屏幕截图显示了这种情况的示例：
- en: '![How it works...](img/7881_08_08.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_08_08.jpg)'
- en: With the change, you can see that all the threads are suspended. You can continue
    debugging any thread you want. Choose the suspend policy that best suits your
    needs.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改，您可以看到所有线程都被挂起。您可以继续调试任何您想要的线程。选择最适合您需求的挂起策略。
- en: Configuring NetBeans for debugging concurrency code
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为并发代码配置NetBeans调试
- en: In today's world, software is necessary to develop applications that work properly,
    that meet the quality standards of the company, and that will be easily modified
    in the future, in a limited time and with a cost as low as possible. To achieve
    this goal, it is essential to use an IDE that integrates under one common interface
    several tools (compilers and debuggers) that facilitate the development of applications.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的世界中，软件是必不可少的，以开发正常工作的应用程序，满足公司的质量标准，并且将来可以轻松修改，而且时间有限，成本尽可能低。为了实现这一目标，必须使用一个集成了多个工具（编译器和调试器）的IDE，以便在一个公共界面下轻松开发应用程序。
- en: If you work with the Java programming language, NetBeans is one of the most
    popular IDEs. It has an integrated debugger that allows you to test your application.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Java编程语言，NetBeans是最受欢迎的IDE之一。它具有集成的调试器，允许您测试应用程序。
- en: In this recipe, you will learn how to change that configuration to help you
    to test concurrent applications.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇文章中，您将学习如何更改该配置，以帮助您测试并发应用程序。
- en: Getting ready
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have the NetBeans IDE installed. Open it and create a new Java project.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经安装了NetBeans IDE。打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Task1` and specify that it implements the `Runnable` interface.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task1`的类，并指定它实现`Runnable`接口。
- en: '[PRE89]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Declare two private `Lock` attributes named `lock1` and `lock2`.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个私有的`Lock`属性，命名为`lock1`和`lock2`。
- en: '[PRE90]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE91]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Implement the `run()` method. First, get the control of the `lock1` object using
    the `lock()` method and write a message in the console indicating that you have
    got it.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。首先，使用`lock()`方法获取`lock1`对象的控制权，并在控制台中写入一条消息，指示您已经获得了它。
- en: '[PRE92]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Then, get the control of the `lock2` object using the `lock()` method and write
    a message in the console indicating that you have got it.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`lock()`方法获取`lock2`对象的控制权，并在控制台中写入一条消息，指示您已经获得了它。
- en: '[PRE93]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Create a class named `Task2` and specify that it implements the `Runnable` interface.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task2`的类，并指定它实现`Runnable`接口。
- en: '[PRE94]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Declare two private `Lock` attributes named `lock1` and `lock2`.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个私有的`Lock`属性，命名为`lock1`和`lock2`。
- en: '[PRE95]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE96]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Implement the `run()` method. First, get the control of the `lock2` object using
    the `lock()` method and write a message in the console indicating that you have
    got it.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。首先使用`lock()`方法获取`lock2`对象的控制权，并在控制台中写入一条消息，指示您已经获得了它。
- en: '[PRE97]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Then, get the control of the `lock1` object using the `lock()` method and write
    a message in the console indicating that you have got it.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用`lock()`方法获取`lock1`对象的控制权，并在控制台中写入一条消息，指示您已经获得了它。
- en: '[PRE98]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Finally, release the two lock objects. First, the `lock1` object and then the
    `lock2` object.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，释放两个锁对象。首先是`lock1`对象，然后是`lock2`对象。
- en: '[PRE99]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE100]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Create two lock objects named `lock1` and `lock2`.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`lock1`和`lock2`的两个锁对象。
- en: '[PRE101]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Create a `Task1` object named `task1`.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`task1`的`Task1`对象。
- en: '[PRE102]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Create a `Task2` object named `task2`.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`task2`的`Task2`对象。
- en: '[PRE103]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Execute both tasks using two threads.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个线程执行两个任务。
- en: '[PRE104]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: While the two tasks haven't finished their execution, write a message in the
    console every 500 milliseconds. Use the `isAlive()` method to check if a thread
    has finished its execution.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当两个任务尚未完成执行时，每500毫秒在控制台中写入一条消息。使用`isAlive()`方法检查线程是否已经完成执行。
- en: '[PRE105]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Add a breakpoint in the first call to the `println()` method of the `run()`
    method of the `Task1` class.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Task1`类的`run()`方法的第一个`println()`方法调用中添加断点。
- en: Debug the program. You will see the **Debugging** window in the top left-hand
    side corner of the main NetBeans window. The next screenshot presents the appearance
    of that window with the thread that executes the `Task1` object slept because
    they have arrived at the breakpoint and the other threads running:![How to do
    it...](img/7881_08_09.jpg)
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试程序。您将在NetBeans主窗口的左上角看到**调试**窗口。下一个屏幕截图显示了该窗口的外观，其中显示了执行`Task1`对象的线程因为已到达断点而休眠，而其他线程正在运行：![如何做...](img/7881_08_09.jpg)
- en: Pause the execution of the main thread. Select that thread, right-click, and
    select the **Suspend** option. The following screenshot shows the new appearance
    of the **Debugging** window. Refer to the following screenshot:![How to do it...](img/7881_08_10.jpg)
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂停主线程的执行。选择该线程，右键单击，然后选择**暂停**选项。以下屏幕截图显示了**调试**窗口的新外观。参考以下屏幕截图：![如何做...](img/7881_08_10.jpg)
- en: Resume the two paused threads. Select each thread, right-click, and select the
    **Resume** option.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复两个暂停的线程。选择每个线程，右键单击，然后选择**恢复**选项。
- en: How it works...
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While debugging a concurrent application using NetBeans, when the debugger hits
    a breakpoint, it suspends the thread that hit the breakpoint and shows the **Debugging**
    window in the top left-hand side corner with the threads that are currently running.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用NetBeans调试并发应用程序时，当调试器命中断点时，它会暂停命中断点的线程，并在左上角显示**调试**窗口，其中显示当前正在运行的线程。
- en: You can use the window to pause or resume the threads that are currently running
    using the **Pause** or **Resume** options. You can also see the values of the
    variables or attributes of the threads using the **Variables** tab.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用该窗口使用**暂停**或**恢复**选项暂停或恢复当前正在运行的线程。您还可以使用**变量**选项卡查看线程的变量或属性的值。
- en: 'NetBeans also includes a deadlock detector. When you select the **Check for
    Deadlock** option in the **Debug** menu, NetBeans performs an analysis of the
    application that you''re debugging to determine if there''s a deadlock situation.
    This example presents a clear deadlock. The first thread gets the lock `lock1`
    first and then the lock `lock2`. The second thread gets the locks just in a reverse
    manner. The breakpoint inserted provokes the deadlock, but if you use NetBeans
    deadlock detector, you''ll not find anything, so this option should be used with
    caution. Change the locks used in both tasks by the `synchronized` keyword and
    debug the program again. The code of the `Task1` will be presented as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans还包括死锁检测器。当您在**调试**菜单中选择**检查死锁**选项时，NetBeans会对您正在调试的应用程序进行分析，以确定是否存在死锁情况。此示例呈现了明显的死锁。第一个线程首先获取锁`lock1`，然后获取锁`lock2`。第二个线程以相反的方式获取锁。插入的断点引发了死锁，但如果使用NetBeans死锁检测器，您将找不到任何东西，因此应谨慎使用此选项。更改两个任务中使用的锁对象的`同步`关键字，并再次调试程序。`Task1`的代码将如下所示：
- en: '[PRE106]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The code of the `Task2` class will be analogous to this, but changes the order
    of the locks. If you debug the example again, you will obtain a deadlock again,
    but in this case, it''s detected by the deadlock detector, as you can see in the
    following screenshot:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task2`类的代码将类似于此，但更改锁的顺序。如果再次调试示例，您将再次获得死锁，但在这种情况下，它将被死锁检测器检测到，如下屏幕截图所示：'
- en: '![How it works...](img/7881_08_11.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_08_11.jpg)'
- en: There's more...
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are options to control the debugger. Select the **Options** option in
    the **Tools** menu. Then, select the **Miscellaneous** option and the **Java Debugger**
    tab. The following screenshot shows the appearance of that window:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 有选项来控制调试器。在**工具**菜单中选择**选项**选项。然后选择**其他**选项和**Java调试器**选项卡。以下屏幕截图显示了该窗口的外观：
- en: '![There''s more...](img/7881_08_12.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/7881_08_12.jpg)'
- en: 'There are two options on that window that control the behavior described earlier:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 该窗口上有两个选项，用于控制前面描述的行为：
- en: '**New breakpoints suspend**: With this option, you can configure the behavior
    of NetBeans, which finds a breakpoint in a thread. You can suspend only the thread
    that has the breakpoint or all the threads of the application.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新断点暂停**：使用此选项，您可以配置NetBeans的行为，该行为在线程中找到断点。您可以仅暂停具有断点的线程，也可以暂停应用程序的所有线程。'
- en: '**Steps resume**: With this option, you can configure the behavior of NetBeans
    when you resume a thread. You can resume only the current thread or all the threads.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤摘要**：使用此选项，您可以配置NetBeans在恢复线程时的行为。您可以只恢复当前线程或所有线程。'
- en: Both options have been marked in the screenshot presented earlier.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 两个选项都已在之前呈现的屏幕截图中标记。
- en: See also
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Configuring Eclipse for debugging concurrency code* recipe in [Chapter
    8](ch08.html "Chapter 8. Testing Concurrent Applications"), *Testing Concurrent
    Applications*
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章 测试并发应用程序")中的*为调试并发代码配置Eclipse*食谱，*测试并发应用程序*'
- en: Testing concurrency code with MultithreadedTC
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MultithreadedTC测试并发代码
- en: MultithreadedTC is a Java library for testing concurrent applications. Its main
    objective is to solve the problem of concurrent applications being non-deterministic.
    You can't control their order of execution. For this purpose, it includes an internal
    **metronome** to control the order of execution of the different threads that
    form the application. Those testing threads are implemented as methods of a class.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: MultithreadedTC是一个用于测试并发应用程序的Java库。它的主要目标是解决并发应用程序是非确定性的问题。您无法控制它们的执行顺序。为此，它包括一个内部的**节拍器**来控制应用程序的不同线程的执行顺序。这些测试线程被实现为一个类的方法。
- en: In this recipe, you will learn how to use the MultithreadedTC library to implement
    a test for `LinkedTransferQueue`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用MultithreadedTC库为`LinkedTransferQueue`实现测试。
- en: Getting ready
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You must also download the MultithreadedTC library from [http://code.google.com/p/multithreadedtc/](http://code.google.com/p/multithreadedtc/)
    and the JUnit library, Version 4.10 from [http://www.junit.org/](http://www.junit.org/).
    Add the files `junit-4.10.jar` and `MultithreadedTC-1.01.jar` to the libraries
    of the project.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须从[http://code.google.com/p/multithreadedtc/](http://code.google.com/p/multithreadedtc/)下载MultithreadedTC库和JUnit库，版本为4.10，从[http://www.junit.org/](http://www.junit.org/)。将`junit-4.10.jar`和`MultithreadedTC-1.01.jar`文件添加到项目的库中。
- en: How to do it...
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `ProducerConsumerTest` that extends the `MultithreadedTestCase`
    class.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ProducerConsumerTest`的类，它继承自`MultithreadedTestCase`类。
- en: '[PRE107]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Declare a private `LinkedTransferQueue` attribute parameterized with the `String`
    class named `queue`.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`LinkedTransferQueue`属性，参数化为`String`类，命名为`queue`。
- en: '[PRE108]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Implement the `initialize()` method. This method won't receive any parameters
    and returns no value. It calls the `initialize()` method of its parent class and
    then initializes the queue attribute.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`initialize()`方法。这个方法不接收任何参数，也不返回任何值。它调用其父类的`initialize()`方法，然后初始化队列属性。
- en: '[PRE109]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Implement the `thread1()` method. It will implement the logic of the first consumer.
    Call the `take()` method of the queue and then write the returned value in the
    console.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`thread1()`方法。它将实现第一个消费者的逻辑。调用队列的`take()`方法，然后将返回的值写入控制台。
- en: '[PRE110]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Implement the `thread2()` method. It will implement the logic of the second
    consumer. First, wait until the first thread has slept in the `take()` method
    using the `waitForTick()` method. Then, call the `take()` method of the queue
    and then write the returned value in the console.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`thread2()`方法。它将实现第二个消费者的逻辑。首先，使用`waitForTick()`方法等待第一个线程在`take()`方法中休眠。然后，调用队列的`take()`方法，然后将返回的值写入控制台。
- en: '[PRE111]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Implement the `thread3()` method. It will implement the logic of a producer.
    First, wait until the two consumers are blocked in the `take()` method using the
    `waitForTick()` method twice. Then, call the `put()` method of the queue to insert
    two `Strings` in the queue.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`thread3()`方法。它将实现生产者的逻辑。首先，使用`waitForTick()`方法两次等待两个消费者在`take()`方法中被阻塞。然后，调用队列的`put()`方法在队列中插入两个`String`。
- en: '[PRE112]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Finally, implement the `finish()` method. Write a message in the console to
    indicate that the test has finished its execution. Check that the two events have
    been consumed (so the size of the queue is `0`) using the `assertEquals()` method.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现`finish()`方法。在控制台中写入一条消息，指示测试已经完成执行。使用`assertEquals()`方法检查两个事件是否已被消耗（因此队列的大小为`0`）。
- en: '[PRE113]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Implement the main class of the example by creating a class named `Main` with
    a `main()` method.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类和一个`main()`方法来实现示例的主类。
- en: '[PRE114]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Create a `ProducerConsumerTest` object named `test`.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`test`的`ProducerConsumerTest`对象。
- en: '[PRE115]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Execute the test using the `runOnce()` method of the `TestFramework` class.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`TestFramework`类的`runOnce()`方法执行测试。
- en: '[PRE116]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: How it works...
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, you have implemented a test for the `LinkedTransferQueue` class
    using the MultithreadedTC library. You can implement a test to any concurrent
    application or class using this library and its metronome. In the example, you
    have implemented the classical producer/consumer problem with two consumers and
    a producer. You want to test that the first `String` object introduced in the
    buffer is consumed by the first consumer that arrives at the buffer and the second
    `String` object introduced in the buffer is consumed by the second consumer that
    arrives at the buffer.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您已经使用MultithreadedTC库为`LinkedTransferQueue`类实现了一个测试。您可以使用这个库及其节拍器为任何并发应用程序或类实现测试。在这个示例中，您已经实现了经典的生产者/消费者问题，其中有两个消费者和一个生产者。您希望测试第一个引入缓冲区的`String`对象是否被第一个到达缓冲区的消费者消耗，第二个引入缓冲区的`String`对象是否被第二个到达缓冲区的消费者消耗。
- en: The MultithreadedTC library is based on the JUnit library, which is the most
    often used library to implement unit tests in Java. To implement a basic test
    using the MultithreadedTC library, you have to extend the `MultithreadedTestCase`
    class. This class extends the `junit.framework.AssertJUnit` class that includes
    all the methods to check the results of the test. It doesn't extend the `junit.framework.TestCase`
    class, so you can't integrate the MultithreadedTC tests with other JUnit tests.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: MultithreadedTC库基于JUnit库，这是Java中最常用的用于实现单元测试的库。要使用MultithreadedTC库实现基本测试，您必须扩展`MultithreadedTestCase`类。此类扩展了`junit.framework.AssertJUnit`类，其中包含检查测试结果的所有方法。它不扩展`junit.framework.TestCase`类，因此无法将MultithreadedTC测试与其他JUnit测试集成。
- en: 'Then, you can implement the following methods:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以实现以下方法：
- en: '`initialize()`: The implementation of this method is optional. It''s executed
    when you start the test, so you can use it to initialize objects that are using
    the test.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()`: 此方法的实现是可选的。当您启动测试时执行，因此您可以使用它来初始化正在使用测试的对象。'
- en: '`finish()`: The implementation of this method is optional. It''s executed when
    the test has finished. You can use it to close or release resources used during
    the test or to check the results of the test.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finish()`: 此方法的实现是可选的。当测试完成时执行。您可以使用它来关闭或释放测试期间使用的资源，或者检查测试的结果。'
- en: 'Methods that implement the test: These methods have the main logic of the test
    you implement. They have to start with the `thread` keyword followed by a string.
    For example, `thread1()`.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现测试的方法：这些方法包含您实现的测试的主要逻辑。它们必须以`thread`关键字开头，后跟一个字符串。例如，`thread1()`。
- en: To control the order of execution of threads, you use the `waitForTick()` method.
    This method receives an `integer` type as a parameter and puts the thread that
    is executing the method to sleep until all threads that are running in the test
    are blocked. When they are blocked, the MultithreadedTC library resumes the threads
    that are blocked by a call to the `waitForTick()` method.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制线程执行顺序，您可以使用`waitForTick()`方法。此方法接收一个`integer`类型的参数，并使执行该方法的线程休眠，直到测试中运行的所有线程都被阻塞。当它们被阻塞时，MultithreadedTC库会恢复被`waitForTick()`方法阻塞的线程。
- en: The integer you pass as a parameter of the `waitForTick()` method is used to
    control the order of execution. The metronome of the MultithreadedTC library has
    an internal counter. When all the threads are blocked, the library increments
    that counter to the next number specified in the `waitForTick()` calls that are
    blocked.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 您传递给`waitForTick()`方法的整数参数用于控制执行顺序。MultithreadedTC库的节拍器有一个内部计数器。当所有线程都被阻塞时，库会将该计数器递增到`waitForTick()`调用中指定的下一个数字。
- en: Internally, when the MultithreadedTC library has to execute a test, first it
    executes the `initialize()` method. Then, it creates a thread per method that
    starts with the `thread` keyword (in your example, the methods `thread1()`, `thread2()`,
    and `thread3()`) and when all the threads have finished their execution, it executes
    the `finish()` method. To execute the test, you have used the `runOnce()` method
    of the `TestFramework` class.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，当MultithreadedTC库需要执行一个测试时，首先执行`initialize()`方法。然后，它为每个以`thread`关键字开头的方法创建一个线程（在您的示例中，方法`thread1()`，`thread2()`和`thread3()`），当所有线程都完成执行时，执行`finish()`方法。要执行测试，您已经使用了`TestFramework`类的`runOnce()`方法。
- en: There's more...
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If the MultithreadedTC library detects that all the threads of the test are
    blocked, but none of them are blocked in the `waitForTick()` method, the test
    is declared to be in a deadlock state and a `java.lang.IllegalStateException`
    exception is thrown.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 如果MultithreadedTC库检测到测试的所有线程都被阻塞，但没有一个线程被阻塞在`waitForTick()`方法中，那么测试将被声明为死锁状态，并且将抛出`java.lang.IllegalStateException`异常。
- en: See also
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Analyzing concurrent code with FindBugs* recipe in [Chapter 8](ch08.html
    "Chapter 8. Testing Concurrent Applications"), *Testing Concurrent Applications***
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章 测试并发应用程序")中的*使用FindBugs分析并发代码*食谱，*测试并发应用程序***
