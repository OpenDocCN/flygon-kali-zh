- en: Taking Notes with Monumentum
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Monumentum做笔记
- en: For our eighth project, we will again do something new--we'll build a web app.
    Whereas all of our other projects have been command lines, GUIs, or some combination
    thereof, this project will be a single module consisting of a REST API and a JavaScript
    frontend, all built with an eye toward the current microservice trend.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第八个项目，我们将再次做一些新的事情--我们将构建一个Web应用程序。而我们所有其他的项目都是命令行、GUI或两者的组合，这个项目将是一个单一模块，包括一个REST
    API和一个JavaScript前端，所有这些都是根据当前的微服务趋势构建的。
- en: 'To build the application, you''ll learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这个应用程序，你将学习以下主题：
- en: Some of the Java options to build microservice applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建微服务应用程序的一些Java选项
- en: Payara Micro and `microprofile.io`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Payara Micro和`microprofile.io`
- en: Java API for RESTful Web Services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于RESTful Web服务的Java API
- en: Document data stores and MongoDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档数据存储和MongoDB
- en: OAuth authentication (against Google, specifically)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth身份验证（针对Google，具体来说）
- en: '**JSON Web Tokens** (**JWT**)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON Web Tokens** (**JWT**)'
- en: As you can see, this will be, in many ways, a much different type of project
    than what we've looked at to this point.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，从许多方面来看，这将是一个与我们到目前为止所看到的项目类型大不相同的项目。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Most of us have likely used some sort of note-taking application such as EverNote,
    OneNote, or Google Keep. They're an extremely handy way of jotting down notes
    and thoughts, and having them available from just about every environment imaginable--desktop,
    mobile, and web. In this chapter, we'll build a fairly basic clone of these industry
    giants in order to exercise a number of concepts. We will call this app Monumentum,
    which is Latin for a reminder or memorial, an apt name for this type of application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人可能都使用过一些记事应用程序，比如EverNote、OneNote或Google Keep。它们是一种非常方便的方式来记录笔记和想法，并且可以在几乎所有环境中使用--桌面、移动和网络。在本章中，我们将构建一个相当基本的这些行业巨头的克隆版本，以便练习一些概念。我们将称这个应用程序为Monumentum，这是拉丁语，意思是提醒或纪念，这种类型的应用程序的一个合适的名字。
- en: 'Before we get into those, let''s take some time to list the requirements for
    our application:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论这些之前，让我们花点时间列出我们应用程序的需求：
- en: Be able to create notes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够创建笔记
- en: Be able to list notes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够列出笔记
- en: Be able to edit notes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够编辑笔记
- en: Be able to delete notes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够删除笔记
- en: Note bodies must be capable of storing/displaying rich text
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记正文必须能够存储/显示富文本
- en: Be able to create a user account
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够创建用户账户
- en: Must be able to log into the application using OAuth2 credentials against an
    existing system
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须能够使用OAuth2凭据登录到现有系统的应用程序
- en: 'Our non-functional requirements are fairly modest:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的非功能性需求相当温和：
- en: Must have a RESTful API
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一个RESTful API
- en: Must have an HTML 5/JavaScript frontend
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一个HTML 5/JavaScript前端
- en: Must have a flexible, scalable data store
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一个灵活的、可扩展的数据存储
- en: Must be easily deployable on resource-constrained systems
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须能够轻松部署在资源受限的系统上
- en: Of course, this list of non-functional requirements was chosen in part because
    they reflect real-world requirements, but they also set us up very nicely to discuss
    some of the technologies I'd like to cover in this chapter. To cut to the chase,
    we'll create a web application that provides both a REST-based API and a JavaScript
    client. It will be backed by a document data store, and built using one of the
    many microservice libraries/frameworks available to the JVM.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个非功能性需求列表的选择部分是因为它们反映了现实世界的需求，但它们也为我们提供了一个很好的机会来讨论我想在本章中涵盖的一些技术。简而言之，我们将创建一个提供基于REST的API和JavaScript客户端的Web应用程序。它将由一个文档数据存储支持，并使用JVM可用的许多微服务库/框架之一构建。
- en: So what does this stack look like? Let's take a quick survey of our options
    before we settle on a particular choice. Let's start with a look at the microservice
    frameworks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这个堆栈是什么样的？在我们选择特定选择之前，让我们快速调查一下我们的选择。让我们从微服务框架开始。
- en: Microservice frameworks on the JVM
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM上的微服务框架
- en: 'While I am reluctant to spend a great deal of time on what a microservice is
    given that most people are familiar with the topic at this point, I think it would
    be a remiss not to give at least a brief description in case you are not familiar
    with the idea. With that said, here is a nice, concise definition of microservice
    from SmartBear, a provider of software quality tools perhaps best known for their
    stewardship of the Swagger API and related libraries:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我不愿意花太多时间来解释微服务是什么，因为大多数人对这个话题都很熟悉，但我认为至少应该简要描述一下，以防你不熟悉这个概念。话虽如此，这里有一个来自SmartBear的简洁的微服务定义，SmartBear是一家软件质量工具提供商，也许最为人所知的是他们对Swagger
    API及相关库的管理：
- en: Essentially, microservice architecture is a method of developing software applications
    as a suite of independently deployable, small, modular services in which each
    service runs a unique process and communicates through a well-defined, lightweight
    mechanism to serve a business goal.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，微服务架构是一种开发软件应用程序的方法，它作为一套独立部署的、小型的、模块化的服务，每个服务运行一个独特的进程，并通过一个定义良好的、轻量级的机制进行通信，以实现业务目标。
- en: To put it another way, rather than the older, more established approach of bundling
    several related systems in one web application and deploying it to a large application
    server, such as GlassFish/Payara Server, Wildfly, WebLogic Server, or WebSphere,
    each of these systems would instead be run separately in their own JVM process.
    The benefits of this approach include easier, piecemeal upgrades, increased stability
    through process isolation, smaller resource requirements, greater machine utilization,
    and so on. The concept itself is not necessarily new, but it has certainly gained
    popularity in recent years, and continues to grow at a rapid pace.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，与将几个相关系统捆绑在一个Web应用程序中并部署到大型应用服务器（如GlassFish/Payara服务器、Wildfly、WebLogic服务器或WebSphere）的较老、更成熟的方法不同，这些系统中的每一个都将在自己的JVM进程中单独运行。这种方法的好处包括更容易的、分步的升级，通过进程隔离增加稳定性，更小的资源需求，更大的机器利用率等等。这个概念本身并不一定是新的，但它在近年来显然变得越来越受欢迎，并且以快速的速度不断增长。
- en: 'So what do our options look like on the JVM? We have several, including, in
    no particular order, the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在JVM上我们有哪些选择呢？我们有几个选择，包括但不限于以下内容：
- en: '**Eclipse Vert.x**: This is officially *a tool-kit for building reactive applications
    on the JVM*. It provides an event-driven application framework that lends itself
    well to writing microservices. Vert.x can be used in a number of languages, including
    Java, Javascript, Kotlin, Ceylon, Scala, Groovy, and Ruby. More information can
    be found at [http://vertx.io/](http://vertx.io/).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse Vert.x：这是官方的*用于在JVM上构建反应式应用程序的工具包*。它提供了一个事件驱动的应用程序框架，非常适合编写微服务。Vert.x可以在多种语言中使用，包括Java、Javascript、Kotlin、Ceylon、Scala、Groovy和Ruby。更多信息可以在[http://vertx.io/](http://vertx.io/)找到。
- en: '**Spring Boot**: This is a library to build stand alone Spring applications.
    Spring Boot applications have full access to the entire Spring ecosystem, and
    can be run using a single fat/uber JAR. Spring Boot lives at [https://projects.spring.io/spring-boot/](https://projects.spring.io/spring-boot/).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot：这是一个构建独立Spring应用程序的库。Spring Boot应用程序可以完全访问整个Spring生态系统，并可以使用单个fat/uber
    JAR运行。Spring Boot位于[https://projects.spring.io/spring-boot/](https://projects.spring.io/spring-boot/)。
- en: '**Java EE MicroProfile**: This is a community and vendor-led effort to create
    a new profile for Java EE, specifically tailored to microservices. At the time
    of writing, the profile includes **Java API for RESTful Web Services** (**JAX-RS**),
    CDI, and JSON-P, and is sponsored by several companies including Tomitribe, Payara,
    Red Hat, Hazelcast, IBM, and Fujitsu, and user groups such as London Java Community
    and SouJava. The MicroProfile home page is [http://microprofile.io/](http://microprofile.io/).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java EE MicroProfile：这是一个由社区和供应商主导的努力，旨在为Java EE创建一个新的配置文件，专门针对微服务。在撰写本文时，该配置文件包括**用于RESTful
    Web服务的Java API**（**JAX-RS**），CDI和JSON-P，并得到了包括Tomitribe、Payara、Red Hat、Hazelcast、IBM和Fujitsu在内的多家公司以及伦敦Java社区和SouJava等用户组的赞助。MicroProfile的主页是[http://microprofile.io/](http://microprofile.io/)。
- en: '**Lagom**: This fairly new framework is a reactive microservices framework
    from Lightbend, the company behind Scala. It is described as an opinionated microservice
    framework, and is built using two of Lightbend''s more famous libraries--Akka
    and Play. Lagom applications can be written either in Java or Scala. More details
    can be found at [https://www.lightbend.com/platform/development/lagom-framework](https://www.lightbend.com/platform/development/lagom-framework).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lagom：这是一个相当新的框架，是Lightbend公司（Scala背后的公司）推出的反应式微服务框架。它被描述为一种有主见的微服务框架，并使用了Lightbend更著名的两个库--Akka和Play。Lagom应用程序可以用Java或Scala编写。更多细节可以在[https://www.lightbend.com/platform/development/lagom-framework](https://www.lightbend.com/platform/development/lagom-framework)找到。
- en: '**Dropwizard**: This is a Java framework to develop ops-friendly, high-performance,
    RESTful web services. It is a framework that offers Jetty for HTTP, Jersey for
    REST services, and Jackson for JSON. It also provides support for other libraries
    such as Guava, Hibernate Validator, Freemarker, and others. You can find Dropwizard
    at [http://www.dropwizard.io/](http://www.dropwizard.io/).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dropwizard：这是一个用于开发运维友好、高性能、RESTful Web服务的Java框架。它提供了Jetty用于HTTP，Jersey用于REST服务，以及Jackson用于JSON。它还支持其他库，如Guava、Hibernate
    Validator、Freemarker等。您可以在[http://www.dropwizard.io/](http://www.dropwizard.io/)找到Dropwizard。
- en: There are a few other options, but it should be clear that, as JVM developers,
    we have a myriad of choices, which is almost always good. Since we can only build
    using one, I have chosen to use the MicroProfile. Specifically, we'll base our
    application on Payara Micro, Payara's implementation, which is based on the GlassFish
    sources (plus Payara's bug fixes, enhancements, and so on).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他选择，但很明显，作为JVM开发人员，我们有很多选择，这几乎总是好事。由于我们只能使用一个，我选择使用MicroProfile。具体来说，我们将基于Payara
    Micro构建我们的应用程序，Payara Micro是基于GlassFish源代码（加上Payara的错误修复、增强等）的实现。
- en: By choosing the MicroProfile and Payara Micro, we choose, implicitly, JAX-RS
    as the basis for our REST services. We are free, of course, to use whatever we
    want, but deviating from what the framework offers lessens the value of the framework
    itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择MicroProfile和Payara Micro，我们隐含地选择了JAX-RS作为我们REST服务的基础。当然，我们可以自由选择使用任何我们想要的东西，但偏离框架提供的内容会降低框架本身的价值。
- en: That leaves us with our choice of data store. One option we've already seen
    is the relational database. It is a tried and true choice that powers a wide swath
    of the industry. They are, however, not without their limitations and problems.
    While databases themselves can be complicated in terms of classifications and
    functionality, perhaps the most popular alternatives to relational databases are
    NoSQL databases. While these have existed for half a century, the idea had not
    gained any significant market traction until sometime in the last decade or so
    with the advent of **Web 2.0**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这留下了我们选择数据存储的余地。我们已经看到的一个选择是关系数据库。这是一个经过验证的选择，支持行业的广泛范围。然而，它们并非没有局限性和问题。虽然数据库本身在分类和功能方面可能很复杂，但与关系数据库最流行的替代方案也许是NoSQL数据库。虽然这些数据库已经存在了半个世纪，但在过去的十年左右，随着**Web
    2.0**的出现，这个想法才开始获得重要的市场份额。
- en: While the term **NoSQL** is very broad, most examples of this type of database
    tend to be key-value, document, or graph data stores, each offering distinct performance
    and behavior characteristics. A full treatment of each type of NoSQL database
    and its various implementations is beyond the scope of this book, so, in the interest
    of time and space, we'll just get straight to our selection--MongoDB. Its scalability
    and flexibility, especially in regard to document schemas, meshes well with our
    target use case.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**NoSQL**这个术语非常广泛，但这类数据库的大多数示例往往是键值、文档或图形数据存储，每种都提供独特的性能和行为特征。对每种NoSQL数据库及其各种实现的全面介绍超出了本书的范围，因此为了节约时间和空间，我们将直接选择MongoDB。它的可扩展性和灵活性，特别是在文档模式方面，与我们的目标用例非常契合。
- en: Finally, on the client side, we have a myriad of options again. Among the most
    popular are ReactJS from Facebook and Angular from Google. There is a variety
    of other frameworks, including older options such as Knockout and Backbone, as
    well as newer ones such as Vue.js. It is this latter option that we'll use. Not
    only is it a very powerful and flexible option, it also presents the least amount
    of friction getting started. Since this book is focused on Java, I felt it prudent
    to select an option that will require the least amount of setup while meeting
    our needs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在客户端，我们再次有许多选项。最受欢迎的是来自Facebook的ReactJS和来自Google的Angular。还有各种其他框架，包括较旧的选项，如Knockout和Backbone，以及较新的选项，如Vue.js。我们将使用后者。它不仅是一个非常强大和灵活的选项，而且在开始时也提供了最少的摩擦。由于本书侧重于Java，我认为选择一个在满足我们需求的同时需要最少设置的选项是明智的。
- en: Creating the application
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: 'To use Payara Micro, we create a Java web application like we normally would.
    In NetBeans, we will select File | New Project | Maven | Web Application and click
    on Next. For the project name, enter `monumentum`, select the appropriate Project
    Location, and fix up the Group ID and Package as desired:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Payara Micro，我们创建一个像平常一样的Java web应用程序。在NetBeans中，我们将选择文件|新项目|Maven|Web应用程序，然后点击下一步。对于项目名称，输入`monumentum`，选择适当的项目位置，并根据需要修复Group
    ID和Package：
- en: '![](img/17938130-2c4c-4617-af05-4a1cf8b13303.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17938130-2c4c-4617-af05-4a1cf8b13303.png)'
- en: 'The next window will ask us to choose a server, which we can leave blank, and
    a Java EE version, which we want to set to Java EE 7 Web:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的窗口将要求我们选择服务器，我们可以留空，以及Java EE版本，我们要将其设置为Java EE 7 Web：
- en: '![](img/edfd2e3b-4443-4803-be5b-3f71e61ec1d5.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edfd2e3b-4443-4803-be5b-3f71e61ec1d5.png)'
- en: 'After a few moments, we should have our project created and ready to go. Since
    we created a Java EE 7 web application, NetBeans has already added the Java EE
    API dependency to the project. Before we jump into coding, let''s add Payara Micro
    to the build to get that part ready. To do that, we need to add a plugin to the
    build. That will look something like this (though we''ve only shown the highlights
    here):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 过了一会儿，我们应该已经创建好并准备好去。由于我们创建了一个Java EE 7 web应用程序，NetBeans已经将Java EE API依赖项添加到了项目中。在我们开始编码之前，让我们将Payara
    Micro添加到构建中，以准备好这部分。为了做到这一点，我们需要向构建中添加一个插件。它看起来会像这样（尽管我们只在这里展示了重点）：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This sets up the Maven exec plugin, which is used to execute either an external
    application or, as we''ll do here, a Java application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了Maven exec插件，用于执行外部应用程序或者，就像我们在这里做的一样，执行Java应用程序：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we''re associating the execution of this plugin with Maven''s package
    phase. This means that when we run Maven to build our project, the plugin''s java
    goal will be run as Maven starts to package the project, allowing us to alter
    exactly what gets packaged in the JAR:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将该插件的执行与Maven的打包阶段相关联。这意味着当我们运行Maven构建项目时，插件的java目标将在Maven开始打包项目时运行，从而允许我们精确地修改JAR中打包的内容：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This last section configures the plugin. It will run the `PayaraMicro` class,
    passing the `--deploy <path> --outputUberJar ...` command. Effectively, we're
    telling Payara Micro how to run our application, but, rather than executing the
    package right now, we want it to create an uber JAR that will run the application
    later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一部分配置了插件。它将运行`PayaraMicro`类，传递`--deploy <path> --outputUberJar ...`命令。实际上，我们正在告诉Payara
    Micro如何运行我们的应用程序，但是，而不是立即执行包，我们希望它创建一个超级JAR，以便稍后运行应用程序。
- en: Typically, when you build your project, you get a jar file that contains only
    the classes and resources that are directly included in your project. Any external
    dependencies are left as something that the execution environment has to provide.
    With an uber JAR, all of the dependencies are included in our project's jar as
    well, which is then configured in such a way that the execution environment can
    find them as needed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当您构建项目时，您会得到一个仅包含直接包含在项目中的类和资源的jar文件。任何外部依赖项都留作执行环境必须提供的内容。使用超级JAR，我们的项目的jar中还包括所有依赖项，然后以这样的方式配置，以便执行环境可以根据需要找到它们。
- en: 'The problem with the setup is that, left as is, when we build, we''ll get an
    uber JAR, but we won''t have any easy way to run the application from NetBeans.
    To fix that, we need a slightly different plugin configuration. Specifically,
    it needs these lines:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 设置的问题是，如果保持不变，当我们构建时，我们将得到一个超级JAR，但我们将没有任何简单的方法从NetBeans运行应用程序。为了解决这个问题，我们需要稍微不同的插件配置。具体来说，它需要这些行：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These replace the preceding `deploy` and `outputUberJar` options. To help speed
    up our builds, we also don''t want the uber JAR created until we ask for it, so
    we can separate these two plugin configurations into two separate profiles, as
    follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些替换了之前的`deploy`和`outputUberJar`选项。为了加快我们的构建速度，我们也不希望在我们要求之前创建超级JAR，因此我们可以将这两个插件配置分成两个单独的配置文件，如下所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we''re ready to build the deployment artifact, we activate the uber profile
    when we execute Maven, and we''ll get our executable jar:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备构建部署工件时，我们在执行Maven时激活超级配置文件，然后我们将获得可执行的jar：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `exploded-war` profile is the configuration that we''ll use from the IDE,
    which runs Payara Micro, pointing it at the exploded war in our build directory.
    To instruct NetBeans to use that, we need to modify a couple of action configurations.
    To do that, right-click on the project in NetBeans and select Properties from
    the bottom of the context menu. Under Actions, find Run Project and select it,
    then enter `exploded-war` under Activate Profiles:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`exploded-war`配置文件是我们将从IDE中使用的配置文件，它运行Payara Micro，并将其指向我们构建目录中的解压缩war。为了指示NetBeans使用它，我们需要修改一些操作配置。为此，在NetBeans中右键单击项目，然后从上下文菜单的底部选择属性。在操作下，找到运行项目并选择它，然后在激活配置下输入`exploded-war`：'
- en: '![](img/1b56d41f-a354-4913-98f5-a0290cfbafef.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b56d41f-a354-4913-98f5-a0290cfbafef.png)'
- en: 'If we run the application now, NetBeans will complain because we haven''t selected
    a server. While this is a web application and those have typically needed a server,
    we''re using Payara Micro, so we don''t need an application server defined. Fortunately,
    NetBeans will let us tell it that, as demonstrated in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，NetBeans会抱怨因为我们还没有选择服务器。虽然这是一个Web应用程序，通常需要服务器，但我们使用的是Payara Micro，所以不需要定义应用服务器。幸运的是，NetBeans会让我们告诉它，就像下面的截图所示：
- en: '![](img/03421687-eacb-4b7a-a7cb-9664844f1d26.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03421687-eacb-4b7a-a7cb-9664844f1d26.png)'
- en: 'Select Ignore, I don''t want IDE managed deployment and click on OK, then watch
    the output window. You should see a fair amount of text scroll by, and after a
    few seconds, you should see text like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 选择忽略，我不想使用IDE管理部署，然后点击确定，然后观察输出窗口。你应该会看到大量的文本滚动过，几秒钟后，你应该会看到类似这样的文本：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once you see that, we're ready to test our application, such as it is at this
    point. In your browser, open `http://localhost:8080/monumentum-1.0-SNAPSHOT/index.html`
    and you should see a large and exciting *Hello World!* message on the page. If
    you see this, you have successfully bootstrapped a Payara Micro project. Take
    a moment to congratulate yourself, and then we'll make the application do something
    useful.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你看到这个，我们就准备测试我们的应用程序，就像现在这样。在你的浏览器中，打开`http://localhost:8080/monumentum-1.0-SNAPSHOT/index.html`，你应该会在页面上看到一个大而令人兴奋的*Hello
    World!*消息。如果你看到了这个，那么你已经成功地启动了一个Payara Micro项目。花点时间来祝贺自己，然后我们将使应用程序做一些有用的事情。
- en: Creating REST Services
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建REST服务
- en: This being basically a Java EE application, albeit one that it is packaged and
    deployed a bit differently, everything you may have learned about writing Java
    EE applications most likely still applies. Of course, you may not have ever written
    such an application, so we'll walk through the steps.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是一个Java EE应用程序，尽管它打包和部署的方式有点不同，但你可能学到的关于编写Java EE应用程序的一切可能仍然适用。当然，你可能从未编写过这样的应用程序，所以我们将逐步介绍步骤。
- en: 'REST applications in Java EE are written using JAX-RS, and our starting point
    for JAX-RS is an `Application`. The `Application` is a deployment-agnostic means
    for declaring root-level resources to the runtime. How the runtime finds the `Application`
    is, of course, dependent on the runtime itself. For a MicroProfile application
    like ours, we''ll be running in a Servlet 3.0 environment, so we need not do anything
    special, as Servlet 3.0 supports a descriptor-less deployment option. The runtime
    will scan for a class of type `Application` that is annotated with `@ApplicationPath`
    and uses that to configure the JAX-RS application, as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE中，使用JAX-RS编写REST应用程序，我们的起点是`Application`。`Application`是一种与部署无关的方式，用于向运行时声明根级资源。运行时如何找到`Application`，当然取决于运行时本身。对于像我们这样的MicroProfile应用程序，我们将在Servlet
    3.0环境中运行，因此我们无需做任何特殊的事情，因为Servlet 3.0支持无描述符的部署选项。运行时将扫描一个带有`@ApplicationPath`注解的`Application`类型的类，并使用它来配置JAX-RS应用程序，如下所示：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With the `@ApplicationPath` annotation, we specify the root URL of our application''s
    REST endpoints, which is, of course, relative to the web application''s root context
    itself. `Application` has three methods we can override, but we''re only interested
    in the one listed here: `getClasses()`. We''ll provide more details on this method
    shortly, but, for now, keep in mind that this is how we will describe to JAX-RS
    what our top-level resources are.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@ApplicationPath`注解，我们指定了应用程序的REST端点的根URL，当然，这是相对于Web应用程序的根上下文本身的。`Application`有三种我们可以重写的方法，但我们只对这里列出的一个感兴趣：`getClasses()`。我们很快会提供有关这个方法的更多细节，但是现在请记住，这是我们将向JAX-RS描述我们顶级资源的方式。
- en: 'Monumentum will have a very simple API, with the primary endpoint being that
    to interact with notes. To create that endpoint, we create a simple Java class
    and mark it up with the appropriate JAX-RS annotations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Monumentum将有一个非常简单的API，主要端点是与笔记交互。为了创建该端点，我们创建一个简单的Java类，并使用适当的JAX-RS注解标记它：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this class, we're describing an endpoint that will live at `/api/notes`
    and will produce JSON results. JAX-RS supports, for example, XML, but most REST
    developers are accustomed to JSON and are expecting nothing else, so we need not
    support anything other than JSON. The needs of your application may vary, of course,
    so you can adjust the list of supported media types as needed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个类，我们描述了一个将位于`/api/notes`的端点，并将生成JSON结果。JAX-RS支持例如XML，但大多数REST开发人员习惯于JSON，并且期望除此之外别无他物，因此我们无需支持除JSON之外的任何其他内容。当然，你的应用程序的需求可能会有所不同，所以你可以根据需要调整支持的媒体类型列表。
- en: 'While this will compile and run, and JAX-RS will attempt to handle requests
    to our endpoint, we haven''t actually defined it yet. To do that, we need to add
    some methods to our endpoint that will define the inputs and outputs of the endpoint,
    as well as the HTTP verb/method we''ll use. Let''s start with the notes collection
    endpoint:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这将编译并运行，JAX-RS将尝试处理对我们端点的请求，但我们实际上还没有定义它。为了做到这一点，我们需要向我们的端点添加一些方法，这些方法将定义端点的输入和输出，以及我们将使用的HTTP动词/方法。让我们从笔记集合端点开始：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We now have an endpoint that answers `GET` requests at `/api/notes` and returns
    a `List` of `Note` instances. There is some debate among REST developers on the
    proper return from methods like these. There are some who prefer to return the
    actual type the client will see, for example `List<Note>` in our case, as it makes
    it clear to developers reading the source, or documentation generated from it.
    Others prefer, as we've done here, to return a JAX-RS `Response` object, as that
    gives greater control over the response, including HTTP headers, status code,
    and more. I tend to prefer this second approach as we've done here. You, of course,
    are free to use either approach.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个端点，它在`/api/notes`处回答`GET`请求，并返回一个`Note`实例的`List`。在REST开发人员中，关于这类方法的正确返回有一些争论。有些人更喜欢返回客户端将看到的实际类型，例如我们的情况下的`List<Note>`，因为这样可以清楚地告诉开发人员阅读源代码或从中生成的文档。其他人更喜欢，就像我们在这里做的那样，返回一个JAX-RS
    `Response`对象，因为这样可以更好地控制响应，包括HTTP头、状态码等。我倾向于更喜欢这种第二种方法，就像我们在这里做的那样。当然，你可以自由选择使用任何一种方法。
- en: 'One last thing to note here is the way in which we build the response body:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最后需要注意的一件事是我们构建响应体的方式：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Typically, at runtime, the parameterized type of the List is lost due to type
    erasure. Using a `GenericEntity` like this allows us to capture the parameterized
    type, allowing the runtime to marshal the data. Using this allows us to avoid
    writing our own `MessageBodyWriter`. Less code is almost always a good thing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在运行时，由于类型擦除，List的参数化类型会丢失。像这样使用`GenericEntity`允许我们捕获参数化类型，从而允许运行时对数据进行编组。使用这种方法可以避免编写自己的`MessageBodyWriter`。少写代码几乎总是一件好事。
- en: 'If we run our application now, we''ll get the following response, albeit a
    very boring one:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的应用程序，我们将得到以下响应，尽管它非常无聊：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That's both satisfying, and it's not, but it does demonstrate that we're on
    the right track. Clearly, we want that endpoint to return data, but we have no
    way of adding a note, so let's fix that now.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这既令人满意，也不令人满意，但它确实表明我们正在正确的轨道上。显然，我们希望该端点返回数据，但我们没有办法添加一个笔记，所以现在让我们来修复这个问题。
- en: 'Creating a new entity via REST is accomplished by POSTing a new entity to its
    collection. That method looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过REST创建一个新的实体是通过将一个新的实体POST到它的集合中来实现的。该方法看起来像这样：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `@POST` annotation indicates the use of the HTTP POST verb. The method takes
    a `Note` instance, and returns a `Response` as we saw in the preceding code. Notice
    that we don't deal with JSON directly. By specifying a `Note` in the method signature,
    we can take advantage of one of JAX-RS's great features--POJO mapping. We've already
    seen a hint of it in the previous code with `GenericEntity`. JAX-RS will attempt
    to unmarshal--that is, convert from a serialized form to a model object--the JSON
    request body. If the client sends a JSON object in the correct format, we get
    a usable `Note` instance. If the client sends an improperly built object, it gets
    a response. This feature allows us to deal solely with our domain objects and
    not worry about JSON encoding and decoding, which can save considerable time and
    energy.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`@POST`注解表示使用HTTP POST动词。该方法接受一个`Note`实例，并返回一个`Response`，就像我们在前面的代码中看到的那样。请注意，我们不直接处理JSON。通过在方法签名中指定`Note`，我们可以利用JAX-RS的一个很棒的特性--POJO映射。我们已经在以前的代码中看到了`GenericEntity`的一点提示。JAX-RS将尝试解组--也就是将序列化的形式转换为模型对象--JSON请求体。如果客户端以正确的格式发送JSON对象，我们就会得到一个可用的`Note`实例。如果客户端发送了一个构建不当的对象，它会得到一个响应。这个特性使我们只需处理我们的领域对象，而不用担心JSON的编码和解码，这可以节省大量的时间和精力。'
- en: Adding MongoDB
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加MongoDB
- en: 'In the body of the method, we get our first glimpse of the integration with
    MongoDB. To make this compile, we need to add a dependency on the MongoDB Java
    Driver:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的主体中，我们第一次看到了与MongoDB的集成。为了使其编译通过，我们需要添加对MongoDB Java Driver的依赖：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'MongoDB deals with documents, so we need to convert our domain model to a `Document`,
    which we accomplish via a method on our model class. We haven''t looked at the
    details of the `Note` class, so let''s do that now:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB处理文档，所以我们需要将我们的领域模型转换为`Document`，我们通过模型类上的一个方法来实现这一点。我们还没有看`Note`类的细节，所以现在让我们来看一下：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is mostly just a normal POJO. We have added a constructor and an instance
    method to handle converting to and from MongoDB's `Document` type.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上只是一个普通的POJO。我们添加了一个构造函数和一个实例方法来处理与MongoDB的`Document`类型的转换。
- en: There are a couple of things to call out here. The first is how the ID of the
    MongoDB `Document` is handled. Every document stored in a MongoDB database gets
    `_id` assigned to it. In the Java API, this `_id` is represented as `ObjectId`.
    We don't want that detail exposed in our domain model, so we convert it to a `String`
    and back again.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件事情需要注意。第一点是MongoDB `Document`的ID是如何处理的。存储在MongoDB数据库中的每个文档都会被分配一个`_id`。在Java
    API中，这个`_id`被表示为`ObjectId`。我们不希望在我们的领域模型中暴露这个细节，所以我们将它转换为`String`，然后再转换回来。
- en: 'We also need to do some special handling for our date fields. We''ve chosen
    to represent the `created` and `modified` properties as `LocalDateTime` instances
    since the new date/time API is superior to the old `java.util.Date`. Unfortunately,
    the MongoDB Java Driver does not yet support Java 8, so we need to handle the
    conversion ourselves. We''ll store these dates as strings and convert them as
    needed. That conversion is handled via the `LocalDateTimeAdapter` class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对我们的日期字段进行一些特殊处理。我们选择将`created`和`modified`属性表示为`LocalDateTime`实例，因为新的日期/时间API优于旧的`java.util.Date`。不幸的是，MongoDB
    Java Driver目前还不支持Java 8，所以我们需要自己处理转换。我们将这些日期存储为字符串，并根据需要进行转换。这个转换是通过`LocalDateTimeAdapter`类处理的：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is probably a bit more complicated than you might expect, and that's because
    it's doing more than we've discussed so far. The usage we're looking at now, that
    from our model class, is not this class' primary purpose, but we'll get to that
    in a moment. That aside, the class' behavior is pretty straightforward--take a
    `String`, determine which of the two supported formats it represents, and convert
    it to a `LocalDateTime`. It also goes the other way.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能比您预期的要复杂一些，这是因为它做的事情比我们到目前为止讨论的要多。我们现在正在研究的用法，即来自我们的模型类，不是这个类的主要目的，但我们稍后会讨论到这一点。除此之外，这个类的行为非常简单--接受一个`String`，确定它表示的是两种支持的格式中的哪一种，并将其转换为`LocalDateTime`。它也可以反过来。
- en: This class' primary purpose is for JAX-RS' use. When we pass `Note` instances
    across the wire, `LocalDateTime` needs to be unmarshalled as well, and we can
    tell JAX-RS how to do this via an `XmlAdapter`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的主要目的是供JAX-RS使用。当我们通过网络传递`Note`实例时，`LocalDateTime`也需要被解组，我们可以通过`XmlAdapter`告诉JAX-RS如何做到这一点。
- en: 'With the class defined, we need to tell JAX-RS about it. We can do that in
    a couple of different ways. We could use an annotation on each property in our
    model like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这个类之后，我们需要告诉JAX-RS关于它。我们可以用几种不同的方式来做到这一点。我们可以在我们的模型中的每个属性上使用注释，就像这样：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'While this works, it''s a fairly large annotation, as far as these kinds of
    things go, and you have to put this on every `LocalDateTime` property. If you
    have several models with fields of this type, you will have to touch each property.
    Fortunately, there''s a way to associate the type with the adapter once. We can
    do that in a special Java file called `package-info.java`. Most people have never
    heard of this file, and even fewer use it, but it is simply a place for package-level
    documentation and annotations. It is this latter use case that interests us. In
    the package for our model class, create `package-info.java` and put this in it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样可以工作，但作为这类事情而言，这是一个相当大的注释，并且您必须将其放在每个`LocalDateTime`属性上。如果您有几个具有此类型字段的模型，您将不得不触及每个属性。幸运的是，有一种方法可以将类型与适配器关联一次。我们可以在一个特殊的Java文件`package-info.java`中做到这一点。大多数人从未听说过这个文件，甚至更少的人使用它，但它只是一个用于包级别文档和注释的地方。我们感兴趣的是后一种用法。在我们的模型类的包中，创建`package-info.java`并将其放入其中：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have the same annotation we saw in the preceding code, but it's wrapped in
    `@XmlJavaTypeAdapters`. The JVM allows only annotation of a given type on an element,
    so this wrapper allows us to work around that limitation. We also need to specify
    the type parameter on the `@XmlJavaTypeAdapter` annotation since it is no longer
    on the target property. With this in place, every `LocalDateTime` property will
    be handled correctly without any additional work.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码中看到了与之前相同的注释，但它包裹在`@XmlJavaTypeAdapters`中。JVM只允许在元素上注释给定类型，因此这个包装器允许我们绕过这个限制。我们还需要在`@XmlJavaTypeAdapter`注释上指定类型参数，因为它不再在目标属性上。有了这个设置，每个`LocalDateTime`属性都将被正确处理，而无需任何额外的工作。
- en: 'That''s quite a bit of setup, but we''re still not quite ready. We have everything
    set up on the REST side. We now need to get the MongoDB classes in place. To connect
    to a MongoDB instance, we start with a `MongoClient`. From the `MongoClient`,
    we then acquire a reference to a `MongoDatabase` from which we get a `MongoCollection`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当复杂的设置，但我们还不太准备好。我们已经在REST端设置好了一切。现在我们需要将MongoDB类放在适当的位置。要连接到MongoDB实例，我们从`MongoClient`开始。然后，我们从`MongoClient`获取对`MongoDatabase`的引用，然后获取`MongoCollection`：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `@PostConstruct` method runs on the bean after the constructor has run.
    In this method, we initialize our various MongoDB classes and store them in instance
    variables. With these classes ready, we can revisit, for example, `getAll()`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PostConstruct`方法在构造函数运行后在bean上运行。在这个方法中，我们初始化我们各种MongoDB类并将它们存储在实例变量中。有了这些准备好的类，我们可以重新访问，例如`getAll()`：'
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can now query the database for our notes, and with the implementation of
    `createNote()` shown in the preceding code, we can create the following notes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查询数据库中的笔记，并且通过前面代码中`createNote()`的实现，我们可以创建以下笔记：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For this to work on your machine, you'll need an instance of MongoDB running.
    You can download an installer appropriate for your operating system as well as
    find installation instructions on the MongoDB website ([https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这在您的机器上运行，您需要一个正在运行的MongoDB实例。您可以在MongoDB网站上下载适合您操作系统的安装程序，并找到安装说明（[https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)）。
- en: Before we move on to the other resource methods, let's take one last look at
    our MongoDB API instances. While instantiating the instances like we have works,
    it also puts a fair amount of work on the resource itself. Ideally, we should
    be able to move those concerns elsewhere and inject the instances. Hopefully,
    this sounds familiar to you, as this is exactly the type of concern that **dependency
    injection** (**DI**) or **inversion of control** (**IoC**) frameworks were created
    to solve.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理其他资源方法之前，让我们最后再看一下我们的MongoDB API实例。虽然像我们这样实例化实例是有效的，但它也给资源本身带来了相当多的工作。理想情况下，我们应该能够将这些问题移到其他地方并注入这些实例。希望这对你来说听起来很熟悉，因为这正是**依赖注入**（**DI**）或**控制反转**（**IoC**）框架被创建来解决的类型问题。
- en: Dependency injection with CDI
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CDI进行依赖注入
- en: 'Java EE provides a framework such as CDI. With CDI, we can inject any container-controlled
    object into another with compile-time type safety. The problem, though, is the
    objects in question need to be container controlled, which our MongoDB API objects
    are not. Fortunately, CDI provides a means by which the container can create these
    instances, a facility known as producer methods. What might this look like? Let''s
    start with the injection point, as that is the simplest piece:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE提供了诸如CDI之类的框架。有了CDI，我们可以使用编译时类型安全将任何容器控制的对象注入到另一个对象中。然而，问题在于所涉及的对象需要由容器控制，而我们的MongoDB
    API对象不是。幸运的是，CDI提供了一种方法，容器可以通过生产者方法创建这些实例。这会是什么样子呢？让我们从注入点开始，因为这是最简单的部分：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the CDI container sees `@Inject`, it inspects the element the annotation
    is on to determine the type. It will then attempt to look up an instance that
    will satisfy the injection request. If there is more than one, the injection would
    typically fail. Although, we have used a qualifier annotation to help CDI determine
    what to inject. That annotation is defined like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当CDI容器看到`@Inject`时，它会检查注解所在的元素来确定类型。然后它将尝试查找一个实例来满足注入请求。如果有多个实例，注入通常会失败。尽管如此，我们已经使用了一个限定符注解来帮助CDI确定要注入什么。该注解定义如下：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this annotation, we can pass hints to the container that will help it
    select an instance for injection. As we''ve mentioned, `MongoCollection` is not
    container-managed, so we need to fix that, which we do via the following producer
    method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个注解，我们可以向容器传递提示，帮助它选择一个实例进行注入。正如我们已经提到的，`MongoCollection`不是容器管理的，所以我们需要修复它，我们通过以下生产者方法来实现：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `@Produces` method tells CDI that this method will produce instances needed
    by the container. CDI determines the type of the injectable instance from the
    method signature. We also place the qualifier annotation on the method as an additional
    hint to the runtime as it tries to resolve our injection request.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Produces`方法告诉CDI，这个方法将产生容器需要的实例。CDI从方法签名确定可注入实例的类型。我们还在方法上放置了限定符注解，作为运行时的额外提示，因为它试图解析我们的注入请求。'
- en: In the method itself, we add `InjectionPoint` to the method signature. When
    CDI calls this method, it will provide an instance of this class, from which we
    can get information about each particular injection point as they are processed.
    From `InjectionPoint`, we get the `Collection` instance from which we can get
    the name of the MongoDB collection we're interested in. We are now ready to get
    the `MongoCollection` instance we saw earlier. The `MongoClient` and `MongoDatabase`
    instantiation is handled internally in the class and is not changed significantly
    from our earlier usage.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法本身中，我们将`InjectionPoint`添加到方法签名中。当CDI调用这个方法时，它将提供这个类的一个实例，我们可以从中获取有关每个特定注入点的信息，因为它们被处理。从`InjectionPoint`中，我们可以获取`Collection`实例，从中可以获取我们感兴趣的MongoDB集合的名称。现在我们准备获取我们之前看到的`MongoCollection`实例。`MongoClient`和`MongoDatabase`的实例化在类内部处理，与我们之前的用法没有显著变化。
- en: There is one small setup step for CDI. In order to avoid potentially expensive
    classpath scanning by the CDI container, we need to tell the system that we want
    the CDI turned on, so to speak. To do that, we need a `beans.xml` file, which
    can either be full of CDI configuration elements, or completely empty, which is
    what we'll do. For Java EE web applications, `beans.xml` needs to be in the `WEB-INF`
    directory, so we create the file in `src/main/webapp/WEB-INF`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: CDI有一个小的设置步骤。为了避免CDI容器进行潜在昂贵的类路径扫描，我们需要告诉系统我们希望打开CDI，所以要说。为此，我们需要一个`beans.xml`文件，它可以是充满CDI配置元素的，也可以是完全空的，这就是我们要做的。对于Java
    EE Web应用程序，`beans.xml`需要在`WEB-INF`目录中，所以我们在`src/main/webapp/WEB-INF`中创建文件。
- en: Make sure that the file is truly empty. If there's even a blank line, Weld,
    Payara's CDI implementation, will attempt to parse the file, giving you an XML
    parsing error.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 确保文件真的是空的。如果有空行，Weld，Payara的CDI实现，将尝试解析文件，给你一个XML解析错误。
- en: Finish the notes resource
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成笔记资源
- en: 'Before we can move on from the `Note` resource, we need to finish up a few
    operations, namely, read, update, and delete. Reading a single note is very straightforward:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以从`Note`资源中继续之前，我们需要完成一些操作，即读取、更新和删除。读取单个笔记非常简单：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've specified the use of the HTTP verb `GET` as we've already seen, but we
    have an additional annotation on this method, `@Path`. Using this annotation,
    we tell JAX-RS that this endpoint has additional path segments that the request
    needs to be matched against. In this case, we specify one additional segment,
    but we've wrapped it in curly braces. Without those braces, the match would be
    a literal match, that is to say, "Does this URL have the string 'id' on the end?"
    With the braces, though, we're telling JAX-RS that we want to match the additional
    segment, but its contents can be anything, and we want to capture that value and
    give it the name `id`. In our method signature, we instruct JAX-RS to inject the
    value via the `@PathParam` annotation, giving us access to the user-specified
    `Note` ID in our method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指定了HTTP动词`GET`，但是在这个方法上我们有一个额外的注解`@Path`。使用这个注解，我们告诉JAX-RS这个端点有额外的路径段，请求需要匹配。在这种情况下，我们指定了一个额外的段，但我们用花括号括起来。没有这些括号，匹配将是一个字面匹配，也就是说，“这个URL末尾有字符串'id'吗？”但是，有了括号，我们告诉JAX-RS我们想要匹配额外的段，但它的内容可以是任何东西，我们想要捕获这个值，并给它一个名字`id`。在我们的方法签名中，我们指示JAX-RS通过`@PathParam`注解注入这个值，让我们可以在方法中访问用户指定的`Note`
    ID。
- en: 'To retrieve the note from MongoDB, we get our first real glimpse of how one
    queries MongoDB:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要从MongoDB中检索笔记，我们将第一次真正看到如何查询MongoDB：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In a nutshell, pass `BasicDBObject` to the `find()` method on `collection`,
    which returns a `FindIterable<?>` object, on which we call `first()` to get what
    should be the only element returned (assuming there is one, of course). The interesting
    bits here are hidden in `buildQueryById()`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，将`BasicDBObject`传递给`collection`上的`find()`方法，它返回一个`FindIterable<?>`对象，我们调用`first()`来获取应该返回的唯一元素（当然，假设有一个）。这里有趣的部分隐藏在`buildQueryById()`中：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our query filter is defined using this `BasicDBObject`, which we initialize
    with a key and value. In this case, we want to filter by the `_id` field in the
    document, so we use that as a key, but note that we pass `ObjectId` as the value,
    and not just `String`. If we want to filter by more fields, we would append more
    key/value pairs to the `BasicDBObject` variable, which we will see later.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`BasicDBObject`定义查询过滤器，我们用键和值初始化它。在这种情况下，我们想要按文档中的`_id`字段进行过滤，所以我们将其用作键，但请注意，我们传递的是`ObjectId`作为值，而不仅仅是`String`。如果我们想要按更多字段进行过滤，我们将在`BasicDBObject`变量中追加更多的键/值对，我们稍后会看到。
- en: Once we've queried the collection and gotten the document the user requested,
    we convert it from `Document` to `Note` using the helper method on `Note`, and
    return it with a status code of 200 or `OK`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们查询了集合并获得了用户请求的文档，我们就使用“Note”上的辅助方法将其从“Document”转换为“Note”，并以状态码200或“OK”返回它。
- en: 'Updating a document in the database is a bit more complicated, but not excessively
    so, as you can see here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中更新文档有点复杂，但并不过分复杂，就像你在这里看到的一样：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first thing to notice is the HTTP method--`PUT`. There is some debate on
    what verb to use for updates. Some, such as Dropbox and Facebook, say `POST`,
    while others, such as Google (depending on which API you look at), say `PUT`.
    I would contend that the choice is largely up to you. Just be consistent in your
    choice. We will be completely replacing the entity on the server with what the
    client passes in, so the operation is idempotent. By choosing `PUT`, we can signal
    this fact to the client, making the API a bit more self-describing for clients.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意的第一件事是HTTP方法--`PUT`。关于更新使用什么动词存在一些争论。一些人，比如Dropbox和Facebook，说`POST`，而另一些人，比如Google（取决于你查看的API），说`PUT`。我认为选择在很大程度上取决于你。只要在你的选择上保持一致即可。我们将完全用客户端传递的内容替换服务器上的实体，因此该操作是幂等的。通过选择`PUT`，我们可以向客户端传达这一事实，使API对客户端更加自我描述。
- en: Inside the method, we start by setting the modified date to reflect the operation.
    Next, we call `Collection.updateOne()` to modify the document. The syntax is a
    little odd, but here's what's happening--we're querying the collection for the
    note we want to modify, then telling MongoDB to replace the loaded document with
    the new one we're providing. Finally, we query `UpdateResult` to see how many
    documents were updated. If none were, then the requested document doesn't exist,
    so we return `NOT_FOUND` (`404`). If it's non-zero, we return `OK` (`200`).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，我们首先设置修改日期以反映操作。接下来，我们调用`Collection.updateOne()`来修改文档。语法有点奇怪，但这里发生了什么--我们正在查询集合以获取我们想要修改的笔记，然后告诉MongoDB用我们提供的新文档替换加载的文档。最后，我们查询`UpdateResult`来查看有多少文档被更新。如果没有，那么请求的文档不存在，所以我们返回`NOT_FOUND`（`404`）。如果不为零，我们返回`OK`（`200`）。
- en: 'Finally, our delete method looks like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的删除方法如下：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We tell MongoDB to filter the collection using the same query filter we've seen
    before, then delete one document, which should be all it finds, of course, given
    our filter, but `deleteOne()` is a sensible safeguard. We could do a check like
    we did above in `updateNote()` to see if something was actually deleted, but there's
    little point--whether the document was there at the start of the request or not,
    it's not there at the end and that's our goal, so there's little to be gained
    from returning an error response.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉MongoDB使用我们之前看到的相同查询过滤器来过滤集合，然后删除一个文档，这应该是它找到的所有内容，当然，鉴于我们的过滤器，但`deleteOne()`是一个明智的保障措施。我们可以像在`updateNote()`中做的那样进行检查，看看是否实际上删除了某些东西，但这没有多大意义--无论文档在请求开始时是否存在，最终都不在那里，这是我们的目标，所以从返回错误响应中获得的收益很少。
- en: We can now create, read, update, and delete notes, but the eagle-eyed among
    you may have noticed that anyone can read every note in the system. For a multi-user
    system, that's not a good thing, so let's fix that.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建、读取、更新和删除笔记，但是你们中的敏锐者可能已经注意到，任何人都可以阅读系统中的每一条笔记。对于多用户系统来说，这不是一件好事，所以让我们来解决这个问题。
- en: Adding authentication
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加身份验证
- en: Authentication systems can easily get extremely complex. From homegrown systems,
    complete with custom user management screens, to sophisticated single sign-on
    solutions, we have a lot of options. One of the more popular options is OAuth2,
    and there are a number of options. For Monumentum, we'll implement sign in using
    Google. To do that, we need to create an application in Google's Developer Console,
    which can be found at [https://console.developers.google.com](https://console.developers.google.com).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证系统很容易变得非常复杂。从自制系统，包括自定义用户管理屏幕，到复杂的单点登录解决方案，我们有很多选择。其中一个更受欢迎的选择是OAuth2，有许多选项。对于Monumentum，我们将使用Google进行登录。为此，我们需要在Google的开发者控制台中创建一个应用程序，该控制台位于[https://console.developers.google.com](https://console.developers.google.com)。
- en: 'Once you''ve logged in, click on the project dropdown at the top of page and
    click on Create Project, which should present this screen to you:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您登录，点击页面顶部的项目下拉菜单，然后点击“创建项目”，这样应该会给您呈现这个屏幕：
- en: '![](img/d2cb8092-38cc-4ddf-97d0-6059c3263aee.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2cb8092-38cc-4ddf-97d0-6059c3263aee.png)'
- en: 'Provide Project Name, make your choices for the next two questions, then click
    on CREATE. Once the project has been created, you should be redirected to the
    Library page. Click on the Credentials link on the left, then click on Create
    credentials and select OAuth Client ID. If needed, fill out the OAuth Consent
    screen as directed. Select Web Application for Application Type, enter Name, and
    provide Authorized redirect URIs as shown in this screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 提供项目名称，为下面两个问题做出选择，然后点击“创建”。项目创建后，您应该会被重定向到库页面。点击左侧的凭据链接，然后点击“创建凭据”并选择OAuth客户端ID。如果需要，按照指示填写OAuth同意屏幕。选择Web应用程序作为应用程序类型，输入名称，并按照此屏幕截图中显示的授权重定向URI。
- en: '![](img/4b495119-fe81-4aed-b107-67c2fe04c1f4.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b495119-fe81-4aed-b107-67c2fe04c1f4.png)'
- en: 'Before this is moved to production, we will need to add a production URI to
    this screen, but this configuration will work in development just fine. When you
    click on Save, you will be shown your new client ID and client secret. Make note
    of these:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在将其移至生产环境之前，我们需要在此屏幕上添加生产URI，但是这个配置在开发中也可以正常工作。当您点击保存时，您将看到您的新客户端ID和客户端密钥。记下这些：
- en: '![](img/3222b4c9-b2b7-46f1-889d-f360a56bf828.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3222b4c9-b2b7-46f1-889d-f360a56bf828.png)'
- en: 'With this data (note that these are not my actual ID and secret, so you''ll
    have to generate your own), we are ready to start working on our authentication
    resource. We''ll start by defining the resource as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些数据（请注意，这些不是我的实际ID和密钥，所以您需要生成自己的），我们就可以开始处理我们的身份验证资源了。我们将首先定义资源如下：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We need to register this in our `Application`, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的“应用程序”中注册这个，如下所示：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To work with the Google OAuth provider, we''ll need to declare a few instance
    variables and instantiate a few Google API classes:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与Google OAuth提供程序一起工作，我们需要声明一些实例变量并实例化一些Google API类：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The variables `clientId` and `clientSecret` will hold the values that Google
    just gave us. The other two classes are necessary for the process we''re about
    to walk through, and `SCOPES` holds the permissions we want from Google, which
    is just access to the user''s profile and email. The class constructor finishes
    the setup of these items:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`clientId`和`clientSecret`将保存Google刚刚给我们的值。另外两个类对我们即将进行的流程是必需的，`SCOPES`保存了我们想要从Google获取的权限，即访问用户的个人资料和电子邮件。类构造函数完成了这些项目的设置：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first part of the authentication flow is to create an authentication URL,
    which is done like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 认证流程的第一部分是创建一个认证URL，就像这样：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Using the JAX-RS class, `UriInfo`, we create a `URI` that points to another
    endpoint in our application, `/api/auth/callback`. We then pass that to `GoogleAuthorizationCodeFlow`
    to finish building our login URL. When the user clicks on the link, the browser
    will be directed to a login dialog from Google. Upon successful authentication,
    the user will be redirected to our callback URL, which is handled by this method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JAX-RS类`UriInfo`，我们创建一个指向我们应用程序中另一个端点`/api/auth/callback`的`URI`。然后将其传递给`GoogleAuthorizationCodeFlow`以完成构建我们的登录URL。当用户点击链接时，浏览器将被重定向到Google的登录对话框。成功认证后，用户将被重定向到我们的回调URL，由此方法处理：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When Google redirects to our `callback` endpoint, it will provide a code that
    we can use to finish the authentication. We do that in the `getUserInfoJson()`
    method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当Google重定向到我们的`callback`端点时，它将提供一个代码，我们可以使用它来完成认证。我们在`getUserInfoJson()`方法中这样做：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using the authentication code we just got from Google, we send another request
    to Google, this time to get the user information. When the request returns, we
    take the JSON object in the response body and use it to build a `User` object,
    which we return.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们刚从Google获取的认证代码，我们向Google发送另一个请求，这次是为了获取用户信息。当请求返回时，我们获取响应主体中的JSON对象并用它构建一个`User`对象，然后将其返回。
- en: 'Back in our REST endpoint method, we call this method to save the user to the
    database, if needed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的REST端点方法，如果需要，我们调用此方法将用户保存到数据库中：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once we've gotten the user's information from Google, we no longer need the
    code as we do not need to interact with any other Google resources, so we do not
    persist it anywhere.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从Google获取了用户的信息，我们就不再需要代码，因为我们不需要与任何其他Google资源进行交互，所以我们不会将其持久化。
- en: Finally, we want to return something to the client --some kind of token -- which
    can be used to prove the client's identity. To do that, we'll use a technology
    called a JSON Web Token, or JWT for short. JWT is *a JSON-based open standard
    (RFC 7519) for creating access tokens that assert some number of claims*. We'll
    create a JWT using the user's email address. We'll sign it with a key only the
    server uses, so we can safely pass it to the client, which will pass it back with
    each request. Since it must be encrypted/signed with the server key, untrustworthy
    clients will not be able to alter or forge the token successfully.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想要向客户端返回一些东西 --某种令牌 --用于证明客户端的身份。为此，我们将使用一种称为JSON Web Token（JWT）的技术。JWT是*用于创建断言某些声明的访问令牌的基于JSON的开放标准（RFC
    7519）*。我们将使用用户的电子邮件地址创建一个JWT。我们将使用服务器专用的密钥对其进行签名，因此我们可以安全地将其传递给客户端，客户端将在每个请求中将其传递回来。由于它必须使用服务器密钥进行加密/签名，不可信任的客户端将无法成功地更改或伪造令牌。
- en: 'To create JWTs, we need to add the library to our project as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建JWT，我们需要将库添加到我们的项目中，如下所示：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can then write this method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以编写这个方法：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The subject of the token is the email address, our API''s base address is the
    issuer, the expiration date and time is 12 hours in the future, and the token
    is signed by a key we generate with a new class, `KeyGenerator`. When we call
    `compact()`, a URL-safe String is generated, which we return to the caller. We
    can use the JWT debugger at [http://jwt.io](http://jwt.io/) to look inside the
    token:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的主题是电子邮件地址，我们的API基地址是发行者，到期日期和时间是未来12小时，令牌由我们使用新类`KeyGenerator`生成的密钥签名。当我们调用`compact()`时，将生成一个URL安全的字符串，我们将其返回给调用者。我们可以使用[http://jwt.io](http://jwt.io/)上的JWT调试器查看令牌的内部情况：
- en: '![](img/74641548-f509-4617-883a-de28f8c7dcfc.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74641548-f509-4617-883a-de28f8c7dcfc.png)'
- en: Clearly, the claims in the token are readable, so don't store anything sensitive
    in them. What makes this secure is the use of a secret key when signing the token,
    making it impossible, in theory, to change its contents without detection.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，令牌中的声明是可读的，所以不要在其中存储任何敏感信息。使其安全的是在签署令牌时使用秘钥，理论上使其不可能在不被检测到的情况下更改其内容。
- en: 'The `KeyGenerator` class used to give us our signing key looks like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 用于给我们提供签名密钥的`KeyGenerator`类如下所示：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The class is annotated with `@Singleton`, so the container guarantees that one
    and only one instance of this bean will exist in the system. The `getKey()` method
    will use the system property `signing.key` as the key, allowing the user to specify
    a unique secret when starting the system. Of course, completely random keys are
    safer, but that adds some complexity should we ever try to scale this system out
    horizontally. We would need all instances to use the same signing key so that
    JWTs can be validated regardless of what server the client is directed to. A data
    grid solution, such as Hazelcast, would be an appropriate tool for those situations.
    As it is now, this is sufficient for our needs here.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使用`@Singleton`进行注释，因此容器保证该bean在系统中只存在一个实例。`getKey()`方法将使用系统属性`signing.key`作为密钥，允许用户在启动系统时指定唯一的秘钥。当然，完全随机的密钥更安全，但这会增加一些复杂性，如果我们尝试将该系统水平扩展。我们需要所有实例使用相同的签名密钥，以便无论客户端被定向到哪个服务器，JWT都可以被验证。在这种情况下，数据网格解决方案，如Hazelcast，将是这些情况下的合适工具。就目前而言，这对我们的需求已经足够了。
- en: Our authentication resource is now complete, but our system has not actually
    been secured yet. To do that, we need to tell JAX-RS how to authenticate requests,
    and we'll do that with a new annotation and `ContainerRequestFilter`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的身份验证资源现在已经完成，但我们的系统实际上还没有被保护。为了做到这一点，我们需要告诉JAX-RS如何对请求进行身份验证，我们将使用一个新的注解和`ContainerRequestFilter`来实现这一点。
- en: 'If we were to install a request filter with no additional information, it would
    apply to every resource, including our authentication resource. That would mean
    we''d have to authenticate in order to authenticate. Clearly that doesn''t make
    sense, so we need a way to discriminate between requests so that only requests
    for certain resources have this filter applied, and that means a new annotation:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们安装一个没有额外信息的请求过滤器，它将应用于每个资源，包括我们的身份验证资源。这意味着我们必须进行身份验证才能进行身份验证。显然这是没有意义的，所以我们需要一种方法来区分请求，以便只有对某些资源的请求才应用这个过滤器，这意味着一个新的注解：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''ve defined an annotation that is semantically meaningful. The `@NameBinding`
    annotation tells JAX-RS to apply the annotation only to certain resources, which
    are bound by name (as opposed to dynamically bound at runtime). With the annotation
    defined, we need to define the other side of things, the request filter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个语义上有意义的注解。`@NameBinding`注解告诉JAX-RS只将注解应用于特定的资源，这些资源是按名称绑定的（与在运行时动态绑定相对）。有了定义的注解，我们需要定义另一方面的东西，即请求过滤器：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We start by defining a class that implements the `ContainerRequestFilter` interface.
    We have to annotate it with `@Provider` so that JAX-RS will recognize and load
    the class. We apply the `@Secure` annotation to associate the filter with the
    annotation. We'll apply this to the resource in a moment. Finally, we apply the
    `@Priority` annotation to instruct the system that this filter should be applied
    earlier in the request cycle.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个实现`ContainerRequestFilter`接口的类。我们必须用`@Provider`对其进行注释，以便JAX-RS能够识别和加载该类。我们应用`@Secure`注解来将过滤器与注解关联起来。我们将在一会儿将其应用于资源。最后，我们应用`@Priority`注解来指示系统该过滤器应该在请求周期中较早地应用。
- en: 'Inside the filter, we inject the same `KeyGenerator` we looked at earlier.
    Since this is a singleton, we are guaranteed that the key used here and in the
    authentication method are the same. The only method on the interface is `filter()`,
    and in this method, we get the Authorization header from the request, extract
    the Bearer token, which is the JWT, and validate it using the JWT API. If we can
    decode and validate the token, then we know the user has successfully authenticated
    against the system. To tell the system about this new filter, we need to modify
    our JAX-RS `Application` as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在过滤器内部，我们注入了之前看过的相同的`KeyGenerator`。由于这是一个单例，我们可以确保在这里使用的密钥和身份验证方法中使用的密钥是相同的。接口上唯一的方法是`filter()`，在这个方法中，我们从请求中获取Authorization头，提取Bearer令牌（即JWT），并使用JWT
    API对其进行验证。如果我们可以解码和验证令牌，那么我们就知道用户已经成功对系统进行了身份验证。为了告诉系统这个新的过滤器，我们需要修改我们的JAX-RS`Application`如下：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The system knows about the filter now, but before it will do anything, we need
    to apply it to the resources that we want to secure. We do that by applying the
    `@Secure` annotation to the appropriate resources. It can either be applied at
    class level, which means that every endpoint in the class will be secured, or
    at the resource method level, which means that only those particular endpoints
    will be secured. In our case, we want every `Note` endpoint secured, so put the
    following annotation on the class:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 系统现在知道了过滤器，但在它执行任何操作之前，我们需要将其应用到我们想要保护的资源上。我们通过在适当的资源上应用`@Secure`注解来实现这一点。它可以应用在类级别，这意味着类中的每个端点都将被保护，或者在资源方法级别应用，这意味着只有那些特定的端点将被保护。在我们的情况下，我们希望每个`Note`端点都受到保护，所以在类上放置以下注解：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Just a few more steps, and our application will be secured. We need to make
    some modifications to `NoteResource` so that it knows who is logged in, and so
    that notes are associated with the authenticated user. We will start by injecting
    `User`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 只需再做几个步骤，我们的应用程序就会得到保护。我们需要对`NoteResource`进行一些修改，以便它知道谁已登录，并且便笺与经过身份验证的用户相关联。我们将首先注入`User`：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is obviously not a container-managed class, so we need to write another
    `Producer` method. There''s a small bit of work to do there, so we''ll wrap that
    in its own class:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 显然这不是一个容器管理的类，所以我们需要编写另一个`Producer`方法。在那里有一点工作要做，所以我们将其封装在自己的类中：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We define this as a request-scoped CDI bean, and inject our `KeyGenerator`,
    the `HttpServletRequest`, and our users collection. The actual work is done in
    the `Producer` method:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其定义为一个请求范围的CDI bean，并注入我们的`KeyGenerator`、`HttpServletRequest`和我们的用户集合。实际的工作是在`Producer`方法中完成的：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Using the Servlet request, we retrieve the `AUTHORIZATION` header. If it''s
    present and contains the `Bearer` string, we can process the token. If that condition
    is not true, we return null. To process the token, we extract the token value
    from the header, and then have `Jwts` parse the claims for us, which returns an
    object of type `Jws<Claims>`. We build the user in the `getUser()` method as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Servlet请求，我们检索`AUTHORIZATION`头。如果存在并包含`Bearer`字符串，我们可以处理令牌。如果条件不成立，我们返回null。要处理令牌，我们从头中提取令牌值，然后让`Jwts`为我们解析声明，返回一个`Jws<Claims>`类型的对象。我们在`getUser()`方法中构建用户如下：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With the claims parsed, we can extract the subject and use it to query our `Users`
    collection, returning either the `User` if it is found, or `null` if not.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解析声明，我们可以提取主题并用它来查询我们的`Users`集合，如果找到则返回`User`，如果找不到则返回`null`。
- en: 'Back in our `NoteResource`, we need to modify our resource methods to be `User-aware`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`NoteResource`，我们需要修改我们的资源方法以使其“用户感知”：
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We now have a complete and secured REST API. Other than a command-line tool
    like curl, we don't have any nice way to use it, so let's build a user interface.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个完整和安全的REST API。除了像curl这样的命令行工具，我们没有任何好的方法来使用它，所以让我们构建一个用户界面。
- en: Building the user interface
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: 'For a UI, we have a number of options. We''ve already looked at JavaFX and
    the NetBeans RCP in this book. While those are great options, we''ll do something
    a little different for this app and build a web-based interface. Even here, we
    have many, many options: JSF, Spring MVC, Google Web Toolkit, Vaadin, and more.
    Oftentimes, in real-world applications, while we may have a Java backend, we may
    have a JavaScript frontend, so that''s what we''ll do here, and that''s where
    your choices can get really dizzying.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户界面，我们有许多选择。在本书中，我们已经看过JavaFX和NetBeans RCP。虽然它们是很好的选择，但对于这个应用程序，我们将做一些不同的事情，构建一个基于Web的界面。即使在这里，我们也有很多选择：JSF、Spring
    MVC、Google Web Toolkit、Vaadin等等。在现实世界的应用程序中，虽然我们可能有一个Java后端，但我们可能有一个JavaScript前端，所以我们将在这里这样做，这也是你的选择可能变得非常令人眼花缭乱的地方。
- en: The two biggest players in that market at the time of the writing of this book
    are React from Facebook and Angular from Google. There are several smaller contenders,
    such as React API-compatible Preact, VueJS, Backbone, Ember, and so on. Which
    you choose will have a significant impact on the application, everything from
    architecture to the more mundane things such as building the project itself, or
    you could let architecture drive the framework if there's a compelling need for
    a specific architecture. As always, your particular environment will vary and
    should drive that decision more than what you read in a book or online.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，市场上最大的两个竞争者是Facebook的React和Google的Angular。还有一些较小的竞争者，如React API兼容的Preact、VueJS、Backbone、Ember等等。你的选择将对应用程序产生重大影响，从架构到更加平凡的事情，比如构建项目本身，或者你可以让架构驱动框架，如果有对特定架构的迫切需求。与往常一样，你的特定环境会有所不同，应该比书本或在线阅读的内容更多地驱动决策。
- en: Since this is a Java book, and I'd like to avoid getting too far into the intimate
    details of JavaScript build systems and alternate **JavaScript VM** languages,
    transpiling, and so on, I've chosen to use Vue, as it is a fast, modern, and popular
    framework that meets our needs, yet still allows us to build a simple system without
    requiring complicated build configurations. If you have experience with, or a
    preference for, another framework, it should be fairly simple for you to build
    a comparable system using the framework of your choice.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本Java书，我希望避免过多地涉及JavaScript构建系统和替代**JavaScript VM**语言、转译等细节，因此我选择使用Vue，因为它是一个快速、现代且流行的框架，满足我们的需求，但仍然允许我们构建一个简单的系统，而不需要复杂的构建配置。如果你有其他框架的经验或偏好，使用你选择的框架构建一个类似的系统应该是相当简单的。
- en: Note that I am *not* a JavaScript developer. The application we'll build in
    this part of the chapter should not be construed to be an example of best practices.
    It is merely an attempt to build a usable, albeit plain, JavaScript frontend to
    demonstrate a full stack application. Please consult the documentation for Vue
    or your framework of choice for details on how to build idiomatic applications
    with the tool.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我*不是*一个JavaScript开发者。本章中我们将构建的应用程序不应被视为最佳实践的示例。它只是一个尝试构建一个可用的，尽管简单的JavaScript前端，以演示一个完整的堆栈应用程序。请查阅Vue或您选择的框架的文档，了解如何使用该工具构建成语言应用程序的详细信息。
- en: 'Let''s start with the index page. In the project explorer window in NetBeans,
    expand the Other Sources node, right-click on the webapp node, and select New
    | Empty File, giving it the name `index.html`. The bare minimum we need in the
    file at this point is the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从索引页面开始。在NetBeans的项目资源管理器窗口中，展开其他资源节点，在webapp节点上右键单击，选择新建|空文件，将其命名为`index.html`。在文件中，我们目前所需的最低限度是以下内容：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will display a blank page at the moment, but it does import the source
    for Vue, as well as the JavaScript for our client app, `index.js`, which we need
    to create:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这将显示一个空白页面，但它确实导入了Vue的源代码，以及我们需要创建的客户端应用程序`index.js`的JavaScript代码：
- en: '[PRE50]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we deploy those changes (HINT: If the app is already running, just press
    *F11* to tell NetBeans to build; that won''t make any Java changes take effect,
    but it will copy these static resources to the output directory) and refresh the
    page in the browser, we should now see *Hello, World!* on the page.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们部署这些更改（提示：如果应用程序已经在运行，只需按下*F11*告诉NetBeans进行构建；这不会使任何Java更改生效，但它会将这些静态资源复制到输出目录），并在浏览器中刷新页面，我们现在应该在页面上看到*Hello,
    World!*。
- en: 'Roughly put, what''s happening is that we''re creating a new `Vue` object,
    anchoring to the (`el`) element with the `app` ID. We''re also defining some state
    for this component (`data`), which includes the single property, `message`. On
    the page, anywhere inside the element `app`, we can access the component''s state
    using the Mustache syntax we see in the index page--`{{ message }}`. Let''s expand
    our component a bit:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 大致上，正在发生的是我们正在创建一个新的`Vue`对象，将其锚定到具有`app` ID的(`el`)元素。我们还为这个组件(`data`)定义了一些状态，其中包括单个属性`message`。在页面上，我们可以使用Mustache语法访问组件的状态，就像我们在索引页面中看到的那样--`{{
    message }}`。让我们扩展一下我们的组件：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We''ve added three items here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加了三个项目：
- en: We've introduced a global data store, aptly called `store`
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们引入了一个名为`store`的全局数据存储
- en: We've added a new property called `isLoggedIn`, which gets its value from a
    method call
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`isLoggedIn`的新属性，它的值来自一个方法调用
- en: We've added a lifecycle method, `created`, which will load `Note` from the server
    when the component is created on the page
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个生命周期方法`created`，它将在页面上创建组件时从服务器加载`Note`
- en: 'Our data store is based on Vuex, a state-management pattern + library for `Vue.js`
    applications. It serves as a centralized store for all the components in an application,
    with rules ensuring that the state can only be mutated in a predictable fashion.
    ([https://vuex.vuejs.org](https://vuex.vuejs.org/)). To add it to our application,
    we need to add the following line of code to our page:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据存储是基于Vuex的，它是一个用于`Vue.js`应用程序的状态管理模式和库。它作为应用程序中所有组件的集中存储，通过规则确保状态只能以可预测的方式进行变化。([https://vuex.vuejs.org](https://vuex.vuejs.org/))。要将其添加到我们的应用程序中，我们需要在我们的页面中添加以下代码行：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We then add a field called `store` to our component, which you can see in the
    preceding code. Most of the work so far takes place in the `NotesActions` object:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们向我们的组件添加了一个名为`store`的字段，您可以在前面的代码中看到。到目前为止，大部分工作都是在`NotesActions`对象中进行的：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When the page loads, the application will immediately send a request to the
    backend for Notes, sending the bearer token, if there is one, in the `Authorization`
    header. When the response returns, we update the state of the `isLoggedIn` property
    in the store, and, if the request was successful, we update the list of `Notes`
    on the page. Note that we're using `fetch()`. That is the new, experimental API
    for sending XHR, or Ajax, requests in browsers. As of the writing of this book,
    it is supported in every major browser except Internet Explorer, so be careful
    using this in production apps if you can't dictate the client's browser.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载时，应用程序将立即向后端发送一个请求以获取笔记，如果有的话，将在`Authorization`标头中发送令牌。当响应返回时，我们会更新存储中`isLoggedIn`属性的状态，并且如果请求成功，我们会更新页面上的`Notes`列表。请注意，我们正在使用`fetch()`。这是用于在浏览器中发送XHR或Ajax请求的新的实验性API。截至撰写本书时，它在除Internet
    Explorer之外的所有主要浏览器中都受支持，因此如果您无法控制客户端的浏览器，请小心在生产应用程序中使用它。
- en: 'We''ve seen the store used a few times, so let''s take a look at it:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到存储器使用了几次，所以让我们来看一下它：
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The store is of type `Vuex.Store`, and we specify the various state fields
    in its `state` property. Handled properly, any Vue component bound to one of these
    state fields is automatically updated for you. You don''t need to track and manage
    state, manually reflecting changes on the page as the application state changes.
    Vue and Vuex handle that for you. Mostly. There are some situations, such as array
    mutation (or replacement), that require some special handling. Vuex offers **mutations**
    to help with that. For example, `NotesAction.fetchNotes()`, upon a successful
    request, we will make this call:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 存储器的类型是`Vuex.Store`，我们在其`state`属性中指定了各种状态字段。正确处理，任何绑定到这些状态字段之一的Vue组件都会自动更新。您无需手动跟踪和管理状态，反映应用程序状态的变化。Vue和Vuex会为您处理。大部分情况下。有一些情况，比如数组突变（或替换），需要一些特殊处理。Vuex提供了**mutations**来帮助处理这些情况。例如，`NotesAction.fetchNotes()`，在成功请求时，我们将进行此调用：
- en: '[PRE55]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding code tells the store to `commit` a mutation called `setNotes`,
    with `notes` as the payload. We define mutations like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码告诉存储器`commit`一个名为`setNotes`的mutation，并将`notes`作为有效载荷。我们像这样定义mutations：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: What we are passing into this mutation (you can probably think of this as a
    function or a method with a peculiar invocation syntax if that helps) is a JSON
    array (hopefully, we show no type checking here), so we start by clearing out
    the current list of notes, then iterating over this array, creating and storing
    new objects, and reformatting some of the data as we do so. Strictly using only
    this mutation to replace the set of notes, we can guarantee that the user interface
    is kept in sync with the changing state of the application, all for free.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给此mutation的是一个JSON数组（希望我们在这里没有显示类型检查），因此我们首先清除当前的笔记列表，然后遍历该数组，创建和存储新对象，并在此过程中重新格式化一些数据。严格使用此mutation来替换笔记集，我们可以保证用户界面与应用程序状态的变化保持同步，而且是免费的。
- en: 'So how are these notes displayed? To do that, we define a new Vue component
    and add it to the page, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这些笔记是如何显示的呢？为了做到这一点，我们定义了一个新的Vue组件并将其添加到页面中，如下所示：
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, we''ve referenced a new component called `note-list`. We''ve bound the
    template variable `notes` to the application variable of the same name, and specified
    that the component is only displayed if the user is logged. The actual component
    definition happens in JavaScript. Back in `index.js`, we have this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引用了一个名为`note-list`的新组件。我们将模板变量`notes`绑定到同名的应用程序变量，并指定只有在用户登录时才显示该组件。实际的组件定义发生在JavaScript中。回到`index.js`，我们有这样的代码：
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This component is named `note-list`; its template is found in an element with
    the `note-list-template` ID; it has two computed values: `notes` and `isLoggedIn`;
    and it provides two methods. In a typical Vue application, we would have a number
    of files, all ultimately compiled together using something like Grunt or Gulp,
    and one of these files would be our component''s template. Since we are trying
    to make this as simple as possible by avoiding the JS build processes, we have
    everything declared right on our page. In `index.html`, we can find the template
    for our component:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件名为`note-list`；其模板位于具有`note-list-template`ID的元素中；它具有两个计算值：`notes`和`isLoggedIn`；并且提供了两种方法。在典型的Vue应用程序中，我们将有许多文件，最终使用类似Grunt或Gulp的工具编译在一起，其中一个文件将是我们组件的模板。由于我们试图尽可能简化，避免JS构建过程，我们在页面上声明了所有内容。在`index.html`中，我们可以找到我们组件的模板：
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Using a `script` tag with with the `text/x-template` type, we can add the template
    to the DOM without it rendering on the page. Inside this template, the interesting
    part is the `div` tag with the `note-list` class. We have the `v-` attribute on
    it, which means the Vue template processor will iterate over the `notes` list
    using this `div` as a template for displaying each `note` in the array.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`text/x-template`类型的`script`标签，我们可以将模板添加到DOM中，而不会在页面上呈现。在此模板中，有趣的部分是带有`note-list`类的`div`标签。我们在其上有`v-`属性，这意味着Vue模板处理器将使用此`div`作为显示数组中每个`note`的模板进行迭代。
- en: Each note will be rendered using the `span` tag. Using the template markup `:title`,
    we are able to create a value for the title tag using our application state (we
    can't say because string interpolation was deprecated in Vue 2.0). The sole child
    of the `span` tag is the `{{ note.title }}` expression, which renders the title
    of the `note` list as a string. When the user clicks on the note title on the
    page, we want to react to that, so we bind the `onClick` handler to the DOM element
    via `v-on:click`. The function referenced here is the `loadNote()` function that
    we defined in the `methods` block of our component definition.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个笔记将使用`span`标签进行渲染。使用模板标记`:title`，我们能够使用我们的应用程序状态为标题标签创建一个值（我们不能说因为字符串插值在Vue
    2.0中已被弃用）。`span`标签的唯一子元素是`{{ note.title }}`表达式，它将`note`列表的标题呈现为字符串。当用户在页面上点击笔记标题时，我们希望对此做出反应，因此我们通过`v-on:click`将`onClick`处理程序绑定到DOM元素。这里引用的函数是我们在组件定义的`methods`块中定义的`loadNote()`函数。
- en: 'The `loadNote()` function calls a mutation we haven''t looked at yet:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadNote()`函数调用了一个我们还没有看过的mutation：'
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This mutation modifies the state to reflect the note that the user clicked
    on, then fires (or emits) an event called `note-clicked`. The event system is
    really quite simple. It is set up like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个mutation修改状态以反映用户点击的笔记，然后触发（或发出）一个名为`note-clicked`的事件。事件系统实际上非常简单。它是这样设置的：
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: That's literally it. This is just a bare bones, globally scoped Vue component.
    We fire events by calling `bus.$emit()` method, and register event listeners by
    calling the `bus.$on()` method. We'll see what that looks like in the note form.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。这只是一个基本的、全局范围的Vue组件。我们通过调用`bus.$emit()`方法来触发事件，并通过调用`bus.$on()`方法来注册事件监听器。我们将在note表单中看到这是什么样子的。
- en: 'We will add the note form component to the page like we did the `note-list`
    component:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像我们对`note-list`组件做的那样，将note表单组件添加到页面中：
- en: '[PRE62]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And, again, the component is defined in `index.js` as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，组件如下所示在`index.js`中定义：
- en: '[PRE63]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The template is also in `index.html`, as shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 模板也在`index.html`中，如下所示：
- en: '[PRE64]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This is mostly normal HTML form. The interesting bit is the v-model that ties
    the form element to the component's property. Changes made on the form are automatically
    reflected in the component, and changes made in the component (for example, via
    an event handler) are automatically reflected in the UI. We also attach an `onClick`
    handler via the now familiar `v-on:click` attribute.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是普通的HTML表单。有趣的部分是v-model将表单元素与组件的属性绑定在一起。在表单上进行的更改会自动反映在组件中，而在组件中进行的更改（例如，通过事件处理程序）会自动反映在UI中。我们还通过现在熟悉的`v-on:click`属性附加了一个`onClick`处理程序。
- en: 'Did you notice the reference to `CKEDITOR` in our component definition? We''ll
    use the rich text editor `CKEditor` to provide a better experience. We could go
    to `CKEditor` and download the distribution bundle, but we have a better way--WebJars.
    The WebJars project takes popular client-side web libraries and packages them
    as JARs. This makes adding supported libraries to the project very simple:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我们在组件定义中提到了`CKEDITOR`吗？我们将使用富文本编辑器`CKEditor`来提供更好的体验。我们可以去`CKEditor`并下载分发包，但我们有更好的方法--WebJars。WebJars项目将流行的客户端Web库打包为JAR文件。这使得向项目添加支持的库非常简单：
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When we package the application, this binary jar is added to the web archive.
    However, if it''s still archived, how do we access the resources? There are a
    number of options depending on the type of application you are building. We''ll
    make use of Servlet 3''s static resource handling (anything under `META-INF/resources`
    that''s packaged in the web application''s `lib` directory are automatically exposed).
    In `index.html`, we add `CKEditor` to the page with this simple line:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打包应用程序时，这个二进制jar文件将被添加到Web存档中。但是，如果它仍然被存档，我们如何访问资源呢？根据您正在构建的应用程序类型，有许多选项。我们将利用Servlet
    3的静态资源处理（打包在Web应用程序的`lib`目录中的`META-INF/resources`下的任何内容都会自动暴露）。在`index.html`中，我们使用这一简单的行将`CKEditor`添加到页面中：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`CKEditor` is now ready to use.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`CKEditor`现在可以使用了。'
- en: 'One last major piece on the frontend is enabling the user to log in. To do
    that, we''ll create another component as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 前端的最后一个重要部分是让用户能够登录。为此，我们将创建另一个组件，如下所示：
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, we will add the following component definition:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加以下组件定义：
- en: '[PRE68]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And, finally, we will add the template as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加以下模板：
- en: '[PRE69]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: When this component is **mounted** (or attached to the element in the DOM),
    we call the `getAuthUrl()` function that sends an Ajax request to the server for
    our Google login URL. Once that's fetched, the login anchor tag is updated to
    refer to the URL.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个组件被**挂载**（或附加到DOM中的元素）时，我们调用`getAuthUrl()`函数，该函数向服务器发送一个Ajax请求以获取我们的Google登录URL。一旦获取到，登录锚点标签将更新以引用该URL。
- en: There are a few more details in the JavaScript file we've not covered here explicitly,
    but interested parties can check out the source code in the repository and read
    through it for the remaining details. We do have a working JavaScript frontend
    for our note-taking app that supports listing, creating, updating, and deleting
    notes, as well as supporting multiple users. It's not a pretty application, but
    it works. Not bad for a Java guy!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这里没有明确涵盖的JavaScript文件中还有一些细节，但感兴趣的人可以查看存储库中的源代码，并阅读剩下的细节。我们已经为我们的笔记应用程序拥有了一个工作的JavaScript前端，支持列出、创建、更新和删除笔记，以及支持多个用户。这不是一个漂亮的应用程序，但它可以工作。对于一个Java程序员来说，还不错！
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now we're back to the familiar refrain--our application is **finished**. What
    have we covered in the chapter? We've created a REST API using JAX-RS that doesn't
    require direct JSON manipulation. We've learned how to apply request filters to
    JAX-RS endpoints to restrict access to authenticated users, which we authenticate
    against their Google accounts using Google's OAuth2 workflow. We've packaged the
    application using Payara Micro, a great option to develop microservices, and we've
    integrated MongoDB into our application using the MongoDB Java API. Finally, we
    built a very basic JavaScript client using Vue.js to access our application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到了熟悉的调子 - 我们的应用程序已经**完成**。在这一章中我们涵盖了什么？我们使用JAX-RS创建了一个REST API，不需要直接操作JSON。我们学习了如何将请求过滤器应用到JAX-RS端点上，以限制只有经过身份验证的用户才能访问，我们使用Google的OAuth2工作流对他们的Google帐户进行了身份验证。我们使用Payara
    Micro打包了应用程序，这是开发微服务的一个很好的选择，并且我们使用了MongoDB Java API将MongoDB集成到我们的应用程序中。最后，我们使用Vue.js构建了一个非常基本的JavaScript客户端来访问我们的应用程序。
- en: There are a lot of new concepts and technologies interacting in this application,
    which makes it interesting from a technical perspective, but there's still more
    that could be done. The application could use a great deal of styling, and support
    for embedded images and videos would be nice, as would a mobile client. There
    is lots of room for improvements and enhancements with the app, but interested
    parties have a solid foundation to start from. Although, for us, it's time to
    turn to the next chapter and a new project, where we'll jump into the world of
    cloud computing with Functions as a Service.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中有很多新的概念和技术相互作用，这使得它在技术上非常有趣，但仍然有更多可以做的事情。应用程序可以使用大量的样式，支持嵌入式图像和视频也会很好，移动客户端也是如此。这个应用程序有很多改进和增强的空间，但感兴趣的人有一个坚实的基础可以开始。虽然对我们来说，现在是时候转向下一章和一个新的项目了，在那里我们将进入云计算的世界，使用函数作为服务。
