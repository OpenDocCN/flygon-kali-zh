- en: Stacks and Queues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈和队列
- en: So far, you have learned a lot about arrays and lists. However, these structures
    are not the only ones available. Among others, there is also a group of more specialized
    data structures, which are called **limited access data structures**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学到了很多关于数组和列表的知识。然而，这些结构并不是唯一可用的。除此之外，还有一组更专业的数据结构，它们被称为**有限访问数据结构**。
- en: What does this mean? To explain the name, let's return to the topic of arrays
    for the moment, which belong to the group of **random access data structures**.
    The difference between them is only one word, that is, limited or random. As you
    already know, arrays allow you to store data and get access to various elements
    using indices. Thus, you can easily get the first, the middle, the *n*^(th), or
    the last element from the array. For this reason, it can be named as the random
    access data structure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么？为了解释这个名字，让我们暂时回到数组的话题，数组属于**随机访问数据结构**的一部分。它们之间的区别只有一个词，即有限或随机。正如您已经知道的那样，数组允许您存储数据并使用索引访问各种元素。因此，您可以轻松地从数组中获取第一个、中间、*n*^(th)或最后一个元素。因此，它可以被称为随机访问数据结构。
- en: However, what does *limited* mean? The answer is very simple—with a limited
    access data structure, you cannot access every element from the structure. Thus,
    the way of getting elements is strictly specified. For example, you can get only
    the first or the last element, but you cannot get the *n*^(th) element from the
    data structure. The popular representatives of limited access data structures
    are stacks and queues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*有限*是什么意思？答案非常简单——对于有限访问数据结构，您无法访问结构中的每个元素。因此，获取元素的方式是严格指定的。例如，您只能获取第一个或最后一个元素，但无法从数据结构中获取第*n*个元素。有限访问数据结构的常见代表是堆栈和队列。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下主题：
- en: Stacks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈
- en: Queues
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列
- en: Priority queues
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列
- en: Stacks
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈
- en: To begin, let's talk about a **stack**. It is an easy-to-understand data structure
    and can be represented using the example of a pile of many plates, each placed
    on top of the other. You can only add a new plate to the top of the pile, and
    you can only get a plate from the top of the pile. You cannot remove the seventh
    plate without taking the previous six from the top, and you cannot add a plate
    to the middle of the pile.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈**堆栈**。它是一种易于理解的数据结构，可以用许多盘子堆叠的例子来表示。您只能将新盘子添加到堆叠的顶部，并且只能从堆叠的顶部获取盘子。您无法在不从顶部取出前六个盘子的情况下移除第七个盘子，也无法在堆叠的中间添加盘子。
- en: The stack operates in exactly the same way! It allows you to add a new element
    at the top (the **push** operation) and get an element by removing it from the
    top (the **pop** operation). For this reason, a stack is consistent with the **LIFO**
    principle, which stands for **Last-In First-Out**. According to our example of
    the pile of plates, the last added plate (last-in) will be removed from the pile
    first (first-out).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈的操作方式与队列完全相同！它允许您在顶部添加新元素（**push**操作）并通过从顶部移除元素来获取元素（**pop**操作）。因此，堆栈符合**LIFO**原则，即**后进先出**。根据我们堆盘子的例子，最后添加的盘子（最后进）将首先从堆中移除（先出）。
- en: 'The diagram of a stack with push and pop operations is shown as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈的推送和弹出操作的图示如下：
- en: '![](img/a4fcda16-874b-42c5-afb0-e7012d152bcd.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4fcda16-874b-42c5-afb0-e7012d152bcd.png)'
- en: 'It seems to be very easy, doesn''t it? It really is, and you can benefit from
    the features of stacks using the built-in generic `Stack` class from the `System.Collections.Generic`
    namespace. It is worth mentioning three methods from this class, namely:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来非常简单，不是吗？的确如此，您可以通过使用`System.Collections.Generic`命名空间中的内置通用`Stack`类来从堆栈的特性中受益。值得一提的是该类中的三种方法，即：
- en: '`Push`, to insert an element at the top of the stack'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Push`，在堆栈顶部插入元素'
- en: '`Pop`, to remove an element from the top of the stack and return it'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pop`，从堆栈顶部移除元素并返回'
- en: '`Peek`, to return an element from the top of the stack without removing it'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Peek`，从堆栈顶部返回元素而不移除它'
- en: Of course, you also have access to other methods, such as for removing all elements
    from the stack (`Clear`) or for checking whether a given element is available
    in the stack (`Contains`). You can get the number of elements in the stack using
    the `Count` property.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您还可以使用其他方法，例如从堆栈中删除所有元素（`Clear`）或检查给定元素是否可用于堆栈（`Contains`）。您可以使用`Count`属性获取堆栈中的元素数量。
- en: It is worth noting that the `Push` method is an *O(1)* operation, if the capacity
    does not need to increase, or *O(n) *otherwise, where *n* is the number of elements
    in the stack. Both `Pop` and `Peek` are *O(1)* operations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果容量不需要增加，`Push`方法是*O(1)*操作，否则是*O(n)*，其中*n*是堆栈中的元素数量。`Pop`和`Peek`都是*O(1)*操作。
- en: You can find more information about the `Stack` generic class at [https://msdn.microsoft.com/library/3278tedw.aspx](https://msdn.microsoft.com/library/3278tedw.aspx).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://msdn.microsoft.com/library/3278tedw.aspx](https://msdn.microsoft.com/library/3278tedw.aspx)找到有关`Stack`通用类的更多信息。
- en: It is high time to take a look at some examples. Let's go!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看一些例子了。让我们开始吧！
- en: Example – reversing words
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-反转单词
- en: 'For the first example, let''s try to reverse a word using a stack. You can
    do this by iterating through characters that form a string, adding each at the
    top of the stack, and then removing all elements from the stack. At the end, you
    receive the reversed word, as shown in the following diagram, which presents the
    process of reversing the **MARCIN** word:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们尝试使用堆栈来反转一个单词。您可以通过迭代形成字符串的字符，将每个字符添加到堆栈的顶部，然后从堆栈中移除所有元素来实现这一点。最后，您将得到反转的单词，如下图所示，它展示了反转**MARCIN**单词的过程：
- en: '![](img/a555d667-5a6c-4e2d-b410-bcede9eda7cc.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a555d667-5a6c-4e2d-b410-bcede9eda7cc.png)'
- en: 'The implementation code, which should be added to the `Main` method within
    the `Program` class, is shown in the following code snippet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应添加到`Program`类中的`Main`方法的实现代码如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the first line, a new instance of the `Stack` class is created. It is worth
    mentioning that in this scenario, the stack can contain only `char` elements.
    Then, you iterate through all characters using the `foreach` loop and insert each
    character at the top of the stack by calling the `Push` method on the `Stack`
    instance. The remaining part of the code consists of the `while` loop, which is
    executed until the stack is empty. This condition is checked using the `Count`
    property. In each iteration, the top element is removed from the stack (by calling
    `Pop`) and written in the console (using the `Write` static method of the `Console`
    class).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，创建了`Stack`类的一个新实例。值得一提的是，在这种情况下，堆栈只能包含`char`元素。然后，您使用`foreach`循环遍历所有字符，并通过在`Stack`实例上调用`Push`方法将每个字符插入堆栈顶部。代码的剩余部分包括`while`循环，该循环执行直到堆栈为空。使用`Count`属性来检查此条件。在每次迭代中，从堆栈中移除顶部元素（通过调用`Pop`）并在控制台中写入（使用`Console`类的`Write`静态方法）。
- en: 'After running the code, you will receive the following result:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码后，您将收到以下结果：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example – Tower of Hanoi
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 汉诺塔
- en: 'The next example is a significantly more complex application of stacks. It
    is related to the mathematical game **Tower of Hanoi**. Let''s start with the
    rules. The game requires three rods, onto which you can put discs. Each disc has
    a different size. At the beginning, all discs are placed on the first rod, forming
    the stack, ordered from the smallest (at the top) to the biggest (at the bottom),
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例是堆栈的一个显着更复杂的应用。它与数学游戏**汉诺塔**有关。让我们从规则开始。游戏需要三根杆，您可以在上面放置圆盘。每个圆盘的大小都不同。开始时，所有圆盘都放在第一根杆上，形成堆栈，从最小的（顶部）到最大的（底部）排序如下：
- en: '![](img/48184ab8-6fd5-4a9e-bb5d-7a656bc8591d.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48184ab8-6fd5-4a9e-bb5d-7a656bc8591d.png)'
- en: The aim of the game is to move all the discs from the first rod (**FROM**) to
    the second one (**TO**). However, during the whole game, you cannot place a bigger
    disc on a smaller one. Moreover, you can only move one disc at a time and, of
    course, you can only take a disc from the top of any rod. How could you move discs
    between the rods to comply with the afore mentioned rules? The problem can be
    divided into sub problems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的目标是将所有圆盘从第一个杆（**FROM**）移动到第二个杆（**TO**）。然而，在整个游戏过程中，您不能将较大的圆盘放在较小的圆盘上。此外，您一次只能移动一个圆盘，当然，您只能从任何杆的顶部取一个圆盘。您如何在杆之间移动圆盘以符合上述规则？问题可以分解为子问题。
- en: Let's start with the example of moving only one disc. Such a case is trivial
    and you just need to move a disc from the **FROM** rod to the **TO** one, without
    using the **AUXILIARY** rod.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从只移动一个圆盘的示例开始。这种情况很简单，您只需要将一个圆盘从**FROM**杆移动到**TO**杆，而不使用**AUXILIARY**杆。
- en: A bit more complex scenario is moving two discs. In such a case, you should
    move one disc from the **FROM** rod to the **AUXILIARY** one. Then, you move the
    remaining disc from **FROM** to **TO**. At the end, you only need to move a disc
    from **AUXILIARY** to **TO**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微复杂一点的情况是移动两个圆盘。在这种情况下，您应该将一个圆盘从**FROM**杆移动到**AUXILIARY**杆。然后，您将剩下的圆盘从**FROM**移动到**TO**。最后，您只需要将一个圆盘从**AUXILIARY**移动到**TO**。
- en: If you want to move three discs, you should start by moving two discs from **FROM**
    to **AUXILIARY**, using the mechanism described earlier. The operation will involve
    the **TO** rod as the auxiliary one. Then, you move the remaining disc from **FROM**
    to **TO**, and then move two discs from **AUXILIARY** to the **TO** rod, using
    **FROM** as the auxiliary rod.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要移动三个圆盘，您应该从**FROM**移动两个圆盘到**AUXILIARY**，使用前面描述的机制。操作将涉及**TO**杆作为辅助杆。然后，您将剩余的圆盘从**FROM**移动到**TO**，然后从**AUXILIARY**移动两个圆盘到**TO**，使用**FROM**作为辅助杆。
- en: As you can see, you can solve the problem of moving *n* discs by moving *n-1*
    discs from **FROM** to **AUXILIARY**, using **TO** as the auxiliary rod. Then,
    you should move the remaining disc from **FROM** to **TO**. At the end, you just
    need to move *n-1* discs from **AUXILIARY** to the **TO** rod, using **FROM**
    as the auxiliary rod.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，您可以通过将*n-1*个圆盘从**FROM**移动到**AUXILIARY**，使用**TO**作为辅助杆来解决移动*n*个圆盘的问题。然后，您应该将剩余的圆盘从**FROM**移动到**TO**。最后，您只需要将*n-1*个圆盘从**AUXILIARY**移动到**TO**，使用**FROM**作为辅助杆。
- en: That's all! Now that you know the basic rules, let's proceed to the code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在您知道了基本规则，让我们继续进行代码。
- en: 'First, let''s focus on the `HanoiTower` class, which contains the logic related
    to the game. A part of the code is shown as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们专注于包含与游戏相关逻辑的`HanoiTower`类。代码的一部分如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The class contains five properties, storing the overall number of discs (`DiscsCount`),
    the number of performed moves (`MovesCount`), and the representations for the
    three rods (`From`, `To`, `Auxiliary`). The `MoveCompleted` event is declared
    as well. It will be fired after each move to inform that the user interface should
    be refreshed. Therefore, you can show the proper content, illustrating the current
    state of the rods.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含五个属性，存储总圆盘数（`DiscsCount`），执行的移动数（`MovesCount`）以及三个杆的表示（`From`，`To`，`Auxiliary`）。还声明了`MoveCompleted`事件。每次移动后都会触发它，以通知用户界面应该刷新。因此，您可以显示适当的内容，说明杆的当前状态。
- en: 'Apart from the properties and the event, the class also has the following constructor:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了属性和事件之外，该类还具有以下构造函数：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The constructor takes only one parameter, namely the number of discs (`discs`),
    and sets it as a value of the `DiscsCount` property. Then, new instances of the
    `Stack` class are created and references to them are stored in the `From`, `To`,
    and `Auxiliary` properties. At the end, the `for` loop is used to create the necessary
    number of discs and to add elements to the first stack (`From`). It is worth noting
    that `From`, `To`, and `Auxiliary` stacks only store integer values (`Stack<int>`).
    Each integer value represents a size of a particular disc. Such data is crucial
    due to the rules of moving discs between rods.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数只接受一个参数，即圆盘数量（`discs`），并将其设置为`DiscsCount`属性的值。然后，创建了`Stack`类的新实例，并将它们的引用存储在`From`、`To`和`Auxiliary`属性中。最后，使用`for`循环来创建必要数量的圆盘，并将元素添加到第一个堆栈（`From`）中。值得注意的是，`From`、`To`和`Auxiliary`堆栈只存储整数值（`Stack<int>`）。每个整数值表示特定圆盘的大小。由于移动圆盘的规则，这些数据是至关重要的。
- en: 'The operation of the algorithm is started by calling the `Start` method, whose
    code is shown in the following lines:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`Start`方法来启动算法的操作，其代码如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The method just calls the `Move` recursive method, passing the overall number
    of discs and references to three stacks as parameters. However, what happens in
    the `Move` method? Let''s look inside:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只是调用`Move`递归方法，将总圆盘数和三个堆栈的引用作为参数传递。但是，`Move`方法中发生了什么？让我们来看一下：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you already know, this method is called recursively. For this reason, it
    is necessary to specify some exit conditions to prevent the method being called
    infinitely. In this case, the method will not call itself when the value of the
    `discs` parameter is equal to or lower than zero. If such a value is greater than
    zero, then the `Move` method is called, but the order of stacks is changed. Then,
    the element is removed from the stack represented by the second parameter (`from`)
    and inserted at the top of the stack represented by the third parameter (`to`).
    In the following lines, the number of moves (`MovesCount`) is incremented and
    the `MoveCompleted` event is fired. At the end, the `Move` method is called again,
    with another configuration of rod order. By calling this method several times,
    the discs will be moved from the first (`From`) to the second (`To`) rod. The
    operations performed in the `Move` method are consistent with the description
    of the problem of moving *n* discs between rods, as explained in the introduction
    to this example.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如您已经知道的，此方法是递归调用的。因此，有必要指定一些退出条件，以防止方法被无限调用。在这种情况下，当`discs`参数的值等于或小于零时，该方法将不会调用自身。如果该值大于零，则调用`Move`方法，但是堆栈的顺序会改变。然后，从由第二个参数（`from`）表示的堆栈中移除元素，并将其插入到由第三个参数（`to`）表示的堆栈的顶部。在接下来的几行中，移动次数（`MovesCount`）递增，并触发`MoveCompleted`事件。最后，再次调用`Move`方法，使用另一种杆顺序的配置。通过多次调用此方法，圆盘将从第一个（`From`）移动到第二个（`To`）杆。`Move`方法中执行的操作与在本示例的介绍中解释的在杆之间移动*n*个圆盘的问题的描述一致。
- en: 'After the class with the logic regarding the Tower of Hanoi game is created,
    let''s see how to create the user interface that allows you to present the following
    moves of the algorithm. The necessary changes in the `Program` class are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了关于汉诺塔游戏的逻辑的类之后，让我们看看如何创建用户界面，以便呈现算法的下一步移动。`Program`类中的必要更改如下：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, two constants are declared, namely with the overall number of discs (`DISCS_COUNT`,
    set to `10`) and the delay (in milliseconds) between two following moves of the
    algorithm (`DELAY_MS`, set to `250`). Moreover, the private static field is declared,
    which represents the number of characters used to present a single rod (`_columnSize`,
    set to `30`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明了两个常量，即整体圆盘数量（`DISCS_COUNT`，设置为`10`）和算法中两次移动之间的延迟（以毫秒为单位）（`DELAY_MS`，设置为`250`）。此外，声明了一个私有静态字段，表示用于表示单个杆的字符数（`_columnSize`，设置为`30`）。
- en: 'The `Main` method in the `Program` class is shown in the following code snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program`类中的`Main`方法如下所示：'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, the width of a single column (representing a rod) is calculated with
    the use of the auxiliary `GetDiscWidth` method, whose code will be shown later.
    Then, a new instance of the `HanoiTower` class is created and it is indicated
    that the `Algorithm_Visualize` method will be called when the `MoveCompleted`
    event is fired. Next, the afore mentioned `Algorithm_Visualize` method is called
    to present the initial state of the game. Finally, the `Start` method is called
    to start moving discs between rods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用辅助的`GetDiscWidth`方法计算了单个列（表示杆）的宽度，其代码稍后将显示。然后，创建了`HanoiTower`类的新实例，并指示在触发`MoveCompleted`事件时将调用`Algorithm_Visualize`方法。接下来，调用了上述的`Algorithm_Visualize`方法来呈现游戏的初始状态。最后，调用`Start`方法来开始在杆之间移动圆盘。
- en: 'The code of the `Algorithm_Visualize` method is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Algorithm_Visualize`方法的代码如下：'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The visualization of the algorithm should present the current state of the game
    in the console. Thus, whenever a refresh is necessary, the `Algorithm_Visualize`
    method clears the current content of the console (by calling the `Clear` method).
    Then, it calls the `InitializeVisualization` method to prepare the jagged array
    with content that should be written in the console. Such content consists of three
    columns, which are prepared by calling the `PrepareColumn` method. After calling
    it, the `visualization` array contains data that should just be presented in the
    console, without any additional transformations. To do so, the `DrawVisualization`
    method is called. Of course, the header and additional explanations are written
    to the console using the `WriteLine` method of the `Console` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的可视化应该在控制台中呈现游戏的当前状态。因此，每当需要刷新时，`Algorithm_Visualize`方法清除控制台的当前内容（通过调用`Clear`方法）。然后，它调用`InitializeVisualization`方法来准备应该写入控制台的内容的交错数组。这样的内容包括三列，通过调用`PrepareColumn`方法准备。调用后，`visualization`数组包含应该只是呈现在控制台中的数据，没有任何额外的转换。为此，调用`DrawVisualization`方法。当然，标题和额外的解释使用`Console`类的`WriteLine`方法写入控制台。
- en: The important role is performed by the last line of code, where the `Sleep`
    method of the `Thread` class (from the `System.Threading` namespace) is called.
    It suspends the current thread for `DELAY_MS` milliseconds. Such a line is added
    to present the following steps of the algorithm in a convenient way for the user.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的角色由代码的最后一行执行，其中调用了`System.Threading`命名空间中`Thread`类的`Sleep`方法。它暂停当前线程`DELAY_MS`毫秒。这样一行代码被添加以便以方便的方式呈现算法的以下步骤给用户。
- en: 'Let''s take a look at the code for the `InitializeVisualization` method:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`InitializeVisualization`方法的代码：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The method declares the jagged array, with the number of rows equal to the overall
    number of discs (the `DiscsCount` property). The number of columns is equal to
    the value of the `_columnSize` field multiplied by `3` (to present three rods).
    Within the method, two `for` loops are used to iterate through the following rows
    (the first `for` loop) and through all columns (the second `for` loop). By default,
    all elements in the array are initialized with single spaces. Finally, the initialized
    array is returned.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法声明了一个交错数组，行数等于总盘数（`DiscsCount`属性）。列数等于`_columnSize`字段的值乘以`3`（表示三根杆）。在方法内部，使用两个`for`循环来迭代遍历行（第一个`for`循环）和所有列（第二个`for`循环）。默认情况下，数组中的所有元素都被初始化为单个空格。最后，初始化的数组被返回。
- en: 'To fill the afore mentioned jagged array with the illustration of the current
    state of the rod, you need to call the `PrepareColumn` method, whose code is as
    follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要用当前杆的状态的插图填充上述的交错数组，需要调用`PrepareColumn`方法，其代码如下：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, the left margin is calculated to add data in the correct section within
    the overall array, that is, within the correct range of columns. However, the
    main part of the method is the `for` loop, where the number of iterations is equal
    to the number of discs located in the given stack. In each iteration, the size
    of the current disc is read using the `ElementAt` extension method (from the `System.Linq`
    namespace). Next, you calculate an index of a row, where the disc should be shown,
    as well as the start and end indices for the columns. Finally, the `for` loop
    is used to insert the equals sign (`=`) in proper locations in the jagged array,
    passed as the `visualization` parameter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算左边距以在整体数组中的正确部分添加数据，即在正确的列范围内。然而，方法的主要部分是`for`循环，其中迭代次数等于给定堆栈中的盘数。在每次迭代中，使用`ElementAt`扩展方法（来自`System.Linq`命名空间）读取当前盘的大小。接下来，计算应该显示盘的行的索引，以及列的起始和结束索引。最后，使用`for`循环将等号（`=`）插入到作为`visualization`参数传递的交错数组的适当位置。
- en: 'The next visualization-related method is `DrawVisualization`, which is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个与可视化相关的方法是`DrawVisualization`，其代码如下：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The method just iterates through all elements of the jagged array passed as
    the `visualization` parameter and calls the `WriteLine` method for each array
    located within the jagged array. As a result, data located in the whole array
    are written to the console.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只是遍历作为`visualization`参数传递的交错数组的所有元素，并为交错数组中的每个数组调用`WriteLine`方法。结果是，整个数组中的数据被写入控制台。
- en: 'One of the auxiliary methods is `Center`. Its aim is to add additional spaces
    before and after the text, passed as the parameter, to center the text in the
    column. The code of this method is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个辅助方法是`Center`。它的目的是在参数中传递的文本之前和之后添加额外的空格，以使文本在列中居中。该方法的代码如下：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another method is `GetDiscWidth`, which just returns the number of characters
    necessary to present the disc with the size specified by the parameter. Its code
    is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方法是`GetDiscWidth`，它只返回以参数指定大小呈现的盘所需的字符数。其代码如下：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You have already added the necessary code to run the application, which will
    present the following moves in the Tower of Hanoi mathematical game. Let's launch
    the application and see it in action!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经添加了运行应用程序所需的代码，该应用程序将呈现汉诺塔数学游戏的以下移动。让我们启动应用程序并看看它的运行情况！
- en: 'Just after starting the program, you will see a result similar to the following,
    where all discs are located in the first rod (`FROM`):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序启动后，您将看到类似以下的结果，其中所有盘都位于第一根杆（`FROM`）中：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the next step, the smallest disc is moved from the top of the first rod
    (`FROM`) to the top of the third rod (`AUXILIARY`), as shown in the following
    illustration:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，最小的盘从第一根杆（`FROM`）的顶部移动到第三根杆（`AUXILIARY`）的顶部，如下图所示：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'While making many other moves, you can see how discs are moved between all
    three rods. One of the intermediate states is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行许多其他移动时，您可以看到盘在三根杆之间移动。其中一个中间状态如下：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When the necessary moves are completed, all discs are moved from the first
    disc (`FROM`) to the second one (`TO`). The final result is presented in the following
    illustration:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当完成必要的移动后，所有圆盘都从第一个圆盘（`FROM`）移动到第二个圆盘（`TO`）。最终结果如下图所示：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, it is worth mentioning the number of moves necessary to complete the
    Tower of Hanoi game. In the case of 10 discs, the number of moves is 1,023\. If
    you use only three discs, the number of moves is only seven. Generally speaking,
    the number of moves can be calculated with the formula *2^n-1*, where *n* is the
    number of discs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是完成汉诺塔游戏所需的移动次数。在10个圆盘的情况下，移动次数为1,023。如果只使用三个圆盘，移动次数只有七次。一般来说，可以用公式*2^n-1*来计算移动次数，其中*n*是圆盘的数量。
- en: That's all! In this section, you have learned the first limited access data
    structure, namely a stack. Now, it is high time that you get to know more about
    queues. Let's start!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！在本节中，您已经学习了第一个有限访问数据结构，即栈。现在，是时候更多地了解队列了。让我们开始吧！
- en: Queues
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: A **queue** is a data structure that can be presented using the example of a
    line of people waiting in a shop at the checkout. New people stand at the end
    of the line, and the next person is taken to the checkout from the beginning of
    the line. You are not allowed to choose a person from the middle and serve him
    or her in a different order.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列**是一种数据结构，可以用在商店结账时等待的人排队的例子中。新人站在队伍的末尾，下一个人从队伍的开头被带到结账处。不允许您从中间选择一个人并按不同的顺序为他或她服务。'
- en: The queue data structure operates in exactly the same way. You can only add
    new elements at the end of the queue (the **enqueue** operation) and remove an
    element from the queue only from the beginning of the queue (the **dequeue** operation).
    For this reason, this data structure is consistent with the **FIFO** principle,
    which stands for **First-In First-Out**. In the example regarding a line of people
    waiting in a shop at the checkout, people who come first (first-in) will be served
    before those who come later (first-out).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 队列数据结构的操作方式完全相同。您只能在队列的末尾添加新元素（**enqueue**操作），并且只能从队列的开头删除一个元素（**dequeue**操作）。因此，这种数据结构符合**FIFO**原则，即**先进先出**。在商店结账时等待的人排队的例子中，先来的人（先进）将在后来的人之前（先出）被服务。
- en: 'The operation of a queue is presented in the following diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的操作如下图所示：
- en: '![](img/3f5f553b-30ad-467b-bc7e-54e3f368fd89.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f5f553b-30ad-467b-bc7e-54e3f368fd89.png)'
- en: 'It is worth mentioning that a queue is a **recursive data structure**, similarly
    as a stack. This means that a queue can be either empty or consists of the first
    element and the rest of the queue, which also forms a queue, as shown in the following
    diagram (the beginning of the queue is marked in gray):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，队列是一个**递归数据结构**，与栈类似。这意味着队列可以是空的，也可以由第一个元素和其余队列组成，后者也形成一个队列，如下图所示（队列的开始标记为灰色）：
- en: '![](img/64556717-48c1-4468-b84a-4b91eec6cce8.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64556717-48c1-4468-b84a-4b91eec6cce8.png)'
- en: The queue data structure seems to be very easy to understand, as well as similar
    to a stack, apart from the way of removing an element. Does this mean that you
    can also use a built-in class to use a queue in your programs? Fortunately, yes!
    The available generic class is named `Queue` and is defined in the `System.Collections.Generic`
    namespace.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 队列数据结构似乎很容易理解，与栈类似，除了删除元素的方式。这是否意味着您也可以在程序中使用内置类来使用队列？幸运的是，可以！可用的通用类名为`Queue`，定义在`System.Collections.Generic`命名空间中。
- en: 'The `Queue` class contains a set of methods, such as:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue`类包含一组方法，例如：'
- en: '`Enqueue`, to add an element at the end of the queue'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enqueue`，在队列末尾添加一个元素'
- en: '`Dequeue`, to remove an element from the beginning and return it'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dequeue`，从开头删除一个元素并返回它'
- en: '`Peek`, to return an element from the beginning without removing it'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Peek`，从开头返回一个元素而不删除它'
- en: '`Clear`, to remove all elements from the queue'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear`，从队列中删除所有元素'
- en: '`Contains`, to check whether the queue contains the given element'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contains`，检查队列是否包含给定元素'
- en: The `Queue` class also contains the `Count` property, which returns the total
    number of elements located in the queue. It can be used to easily check whether
    the queue is empty.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue`类还包含`Count`属性，返回队列中的元素总数。它可以用于轻松检查队列是否为空。'
- en: It is worth mentioning that the `Enqueue` method is an *O(1)* operation, if
    the internal array does not need to be reallocated, or *O(n) *otherwise, where
    *n* is the number of elements in the queue. Both `Dequeue` and `Peek` are *O(1)*
    operations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，如果内部数组不需要重新分配，则`Enqueue`方法是*O(1)*操作，否则为*O(n)*，其中*n*是队列中的元素数量。`Dequeue`和`Peek`都是*O(1)*操作。
- en: You can find more information about the `Queue` class at [https://msdn.microsoft.com/library/7977ey2c.aspx](https://msdn.microsoft.com/library/7977ey2c.aspx).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://msdn.microsoft.com/library/7977ey2c.aspx](https://msdn.microsoft.com/library/7977ey2c.aspx)找到有关`Queue`类的更多信息。
- en: 'The additional comment is necessary for the scenarios where you want to use
    a queue concurrently from many threads. In such a case, it is necessary to choose
    the thread-safe variant of the queue, which is represented by the `ConcurrentQueue`
    generic class from the `System.Collections.Concurrent` namespace. This class contains
    a set of built-in methods to perform various operations of the thread-safe queue,
    such as:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在想要从多个线程同时使用队列的情况下，需要额外的注释。在这种情况下，需要选择线程安全的队列变体，即`System.Collections.Concurrent`命名空间中的`ConcurrentQueue`通用类。该类包含一组内置方法，用于执行线程安全队列的各种操作，例如：
- en: '`Enqueue`, to add an element at the end of the queue'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enqueue`，在队列末尾添加一个元素'
- en: '`TryDequeue`, to try to remove an element from the beginning and return it'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryDequeue`，尝试从开头删除一个元素并返回它'
- en: '`TryPeek`, to try to return an element from the beginning without removing
    it'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryPeek`，尝试从开头返回一个元素而不删除它'
- en: It is worth mentioning that both `TryDequeue` and `TryPeek` have a parameter
    with the `out` keyword. If the operation is successful, such methods return `true`
    and the result is returned as a value of the `out` parameter. Moreover, the `ConcurrentQueue`
    class also contains two properties, namely `Count` to get the number of elements
    stored in the collection, and `IsEmpty` to return a value indicating whether the
    queue is empty.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，`TryDequeue`和`TryPeek`都有一个带有`out`关键字的参数。如果操作成功，这些方法将返回`true`，并将结果作为`out`参数的值返回。此外，`ConcurrentQueue`类还包含两个属性，即`Count`用于获取集合中存储的元素数量，以及`IsEmpty`用于返回一个值，指示队列是否为空。
- en: You can find more information about the `ConcurrentQueue` class at [https://msdn.microsoft.com/library/dd267265.aspx](https://msdn.microsoft.com/library/dd267265.aspx).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://msdn.microsoft.com/library/dd267265.aspx](https://msdn.microsoft.com/library/dd267265.aspx)找到有关`ConcurrentQueue`类的更多信息。
- en: After this short introduction, you should be ready to proceed to two examples
    representing a queue in the context of a call center, with many callers and one
    or many consultants.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，您应该准备好继续进行两个示例，代表呼叫中心中的队列，有许多呼叫者和一个或多个顾问。
- en: Example – call center with a single consultant
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 仅有一个顾问的呼叫中心
- en: 'This first example represents the simple approach to the call center solution,
    where there are many callers (with different client identifiers), and only one
    consultant, who answers waiting calls in the same order in which they appear.
    This scenario is presented in the following diagram:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个示例代表了呼叫中心解决方案的简单方法，其中有许多呼叫者（具有不同的客户标识符），以及只有一个顾问，他按照呼叫出现的顺序接听等待的电话。这种情况在下图中呈现：
- en: '![](img/ac923287-81b8-49c7-87d8-cff86e481094.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac923287-81b8-49c7-87d8-cff86e481094.png)'
- en: 'As you can see in the preceding diagram, four calls are performed by callers.
    They are added to the queue with waiting phone calls, namely from clients **#1234**,
    **#5678**, **#1468**, and **#9641**. When the consultant is available, he or she
    answers the phone. When the call ends, the consultant can answer the next waiting
    call. According to this rule, the consultant will talk with clients in the following
    order: **#1234**, **#5678**, **#1468**, and **#9641**.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图表中所看到的，呼叫者执行了四次呼叫。它们被添加到等待电话呼叫的队列中，即来自客户**#1234**，**#5678**，**#1468**和**#9641**。当顾问可用时，他或她会接听电话。通话结束后，顾问可以接听下一个等待的电话。根据这个规则，顾问将按照以下顺序与客户交谈：**#1234**，**#5678**，**#1468**和**#9641**。
- en: 'Let''s take a look at the code of the first class, named `IncomingCall`, which
    represents a single incoming call performed by a caller. Its code is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下第一个类`IncomingCall`的代码，它代表了呼叫中心中由呼叫者执行的单个呼入呼叫。其代码如下：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The class contains six properties representing an identifier of a call (`Id`),
    a client identifier (`ClientId`), the date and time when the call was started
    (`CallTime`), when it was answered (`StartTime`), and when it was ended (`EndTime`),
    as well as the name of the consultant (`Consultant`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含六个属性，代表呼叫的标识符（`Id`），客户标识符（`ClientId`），呼叫开始的日期和时间（`CallTime`），呼叫被接听的日期和时间（`StartTime`），呼叫结束的日期和时间（`EndTime`），以及顾问的姓名（`Consultant`）。
- en: 'The most important part of this implementation is related to the `CallCenter`
    class, which represents call-related operations. Its fragment is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现中最重要的部分与`CallCenter`类相关，它代表了与呼叫相关的操作。其片段如下：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `CallCenter` class contains the `_counter` field with the identifier of
    the last call, as well as the `Calls` queue (with `IncomingCall` instances), where
    data of waiting calls are stored. In the constructor, a new instance of the `Queue`
    generic class is created, and its reference is assigned to the `Calls` property.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallCenter`类包含`_counter`字段，其中包含最后一次呼叫的标识符，以及`Calls`队列（带有`IncomingCall`实例），其中存储了等待呼叫的数据。在构造函数中，创建了`Queue`泛型类的新实例，并将其引用分配给`Calls`属性。'
- en: 'Of course, the class also contains some methods, such as `Call`, with the following
    code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，该类还包含一些方法，比如`Call`，代码如下：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, you create a new instance of the `IncomingCall` class and set values of
    its properties, namely its identifier (together with pre-incrementing the `_counter`
    field), the client identifier (using the `clientId` parameter), and the call time.
    The created instance is added to the queue by calling the `Enqueue` method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您创建了`IncomingCall`类的新实例，并设置了其属性的值，即其标识符（连同预增量`_counter`字段）、客户标识符（使用`clientId`参数）和呼叫时间。通过调用`Enqueue`方法，将创建的实例添加到队列中。
- en: 'The next method is `Answer`, which represents the operation of answering the
    call, from the person waiting in the queue for the longest time, that is, which
    is located at the beginning of the queue. The `Answer` method is shown in the
    following code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是`Answer`，它代表了回答呼叫的操作，来自队列中等待时间最长的人，也就是位于队列开头的人。`Answer`方法如下所示：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Within this method, you check whether the queue is empty. If so, the method
    returns `null`, which means that there are no phone calls that can be answered
    by the consultant. Otherwise, the call is removed from the queue (using the `Dequeue`
    method), and its properties are updated by setting the consultant name (using
    the `consultant` parameter) and start time (to the current date and time). At
    the end, the data of the call is returned.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，您检查队列是否为空。如果是，该方法返回`null`，这意味着顾问没有可以接听的电话。否则，呼叫将从队列中移除（使用`Dequeue`方法），并通过设置顾问姓名（使用`consultant`参数）和开始时间（为当前日期和时间）来更新其属性。最后，返回呼叫的数据。
- en: 'Apart from the `Call` and `Answer` methods, you should also implement the `End`
    method, which is called whenever the consultant ends a call with a particular
    client. In such a case, you just set the end time, as shown in the following piece
    of code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Call`和`Answer`方法，您还应该实现`End`方法，每当顾问结束与特定客户的通话时都会调用该方法。在这种情况下，您只需设置结束时间，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The last method in the `CallCenter` class is named `AreWaitingCalls`. It returns
    a value indicating whether there are any waiting calls in the queue, using the
    `Count` property of the `Queue` class. Its code is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallCenter`类中的最后一个方法名为`AreWaitingCalls`。它使用`Queue`类的`Count`属性返回一个值，指示队列中是否有任何等待的呼叫。其代码如下：'
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s proceed to the `Program` class and its `Main` method:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到`Program`类和它的`Main`方法：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, you create a new instance of the `Random` class (for getting random numbers),
    as well as an instance of the `CallCenter` class. Then, you simulate making a
    few calls by callers, namely with the following client identifiers: `1234`, `5678`,
    `1468`, and `9641`. The most interesting part of the code is located in the `while`
    loop, which is executed until there are no waiting calls in the queue. Within
    the loop, the consultant answers the call (using the `Answer` method) and the
    log is generated (using the `Log` auxiliary method). Then, the thread is suspended
    for a random number of milliseconds (between 1,000 and 10,000) to simulate the
    various length of a call. When this has elapsed, the call ends (by calling the
    `End` method) and the proper log is generated.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了`Random`类的一个新实例（用于获取随机数），以及`CallCenter`类的一个实例。然后，你通过呼叫者模拟了一些呼叫，即使用以下客户标识符：`1234`，`5678`，`1468`和`9641`。代码中最有趣的部分位于`while`循环中，该循环执行直到队列中没有等待的呼叫为止。在循环内，顾问接听呼叫（使用`Answer`方法），并生成日志（使用`Log`辅助方法）。然后，线程暂停一段随机毫秒数（在1,000到10,000之间）以模拟呼叫的不同长度。当时间到达后，呼叫结束（通过调用`End`方法），并生成适当的日志。
- en: 'The last part of code necessary for this example is the `Log` method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中必要的最后一部分代码是`Log`方法：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you run the example, you will receive a result similar to the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个示例时，你会收到类似以下的结果：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That's all! You have just completed the first example regarding the queue data
    structure. If you want to learn more about the thread-safe version of the queue,
    let's proceed to the next section and take a look at the next example.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！你刚刚完成了关于队列数据结构的第一个示例。如果你想了解更多关于队列的线程安全版本，让我们继续到下一部分，看看下一个示例。
- en: Example – call center with many consultants
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 带有多个顾问的呼叫中心
- en: 'The example shown in the preceding section has been intentionally simplified
    to make understanding a queue much simpler. However, it is high time you make
    it more related to real-world problems. In this section, you will see how to expand
    it to support many consultants, as shown in the following diagram:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中显示的示例被故意简化，以使理解队列变得更简单。然而，现在是时候让它更相关于现实世界的问题了。在这一部分，你将看到如何扩展它以支持多个顾问，如下图所示：
- en: '![](img/40966381-d05b-420f-bf0e-78608de68883.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40966381-d05b-420f-bf0e-78608de68883.png)'
- en: What is important is that both callers and consultants will work at the same
    time. If there are more incoming calls than available consultants, a new call
    will be added to the queue and will wait until there is a consultant who can answer
    the call. If there are too many consultants and few calls, the consultants will
    wait for a call. To perform this task, you will create a few threads, which will
    access the queue. Therefore, you need to use the thread-safe version of the queue
    using the `ConcurrentQueue` class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，呼叫者和顾问将同时工作。如果有更多的呼叫比可用的顾问多，新的呼叫将被添加到队列中，并等待直到有顾问可以接听呼叫。如果顾问过多而呼叫过少，顾问将等待呼叫。为了执行这个任务，你需要创建一些线程，它们将访问队列。因此，你需要使用`ConcurrentQueue`类的线程安全版本。
- en: 'Let''s take a look at the code! First, you need to declare the `IncomingCall`
    class, of which the code is exactly the same as in the previous example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下代码！首先，你需要声明`IncomingCall`类，其代码与前面的示例完全相同：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There are various modifications necessary in the `CallCenter` class, such as
    replacing an instance of the `Queue` class with an instance of the `ConcurrentQueue`
    generic class. The suitable fragment is shown in the following code snippet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallCenter`类中需要进行各种修改，比如用`ConcurrentQueue`泛型类的实例替换`Queue`类的实例。适当的代码片段如下所示：'
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As the `Enqueue` method is available in both the `Queue` and `ConcurrentQueue`
    classes, no changes are necessary in the most important part of the `Call` method.
    However, the small modification is introduced to return the number of waiting
    calls after adding a new call to the queue. The modified code is follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Enqueue`方法在`Queue`和`ConcurrentQueue`类中都可用，所以在`Call`方法的最重要部分不需要进行任何修改。然而，在将新呼叫添加到队列后，引入了一个小的修改来返回等待呼叫的数量。修改后的代码如下：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `Dequeue` method does not exist in the `ConcurrentQueue` class. For this
    reason, you need to slightly modify the `Answer` method to use the `TryDequeue`
    method, which returns a value indicating whether the element is removed from the
    queue. The removed element is returned using the `out` parameter. The suitable
    part of code is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentQueue`类中不存在`Dequeue`方法。因此，你需要稍微修改`Answer`方法，使用`TryDequeue`方法，该方法返回一个值，指示元素是否已从队列中移除。移除的元素使用`out`参数返回。适当的代码部分如下：'
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'No further modifications are necessary in the remaining methods declared in
    the `CallCenter` class, namely `End` and `AreWaitingCalls`. Their code is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CallCenter`类中声明的剩余方法`End`和`AreWaitingCalls`中不需要进行进一步的修改。它们的代码如下：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Significantly more changes are required in the `Program` class. Here, you need
    to start four threads. The first represents callers, while the other three represent
    consultants. First, let''s take a look at the code of the `Main` method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program`类中需要进行更多的修改。在这里，你需要启动四个线程。第一个代表呼叫者，而其他三个代表顾问。首先，让我们看一下`Main`方法的代码：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, just after the creation of the `CallCenter` instance, you start the execution
    of four actions, namely representing callers and three consultants, using the
    `Invoke` static method of the `Parallel` class from the `System.Threading.Tasks`
    namespace. The lambda expressions are used to specify methods that will be called,
    namely `CallersAction` for callers-related operations and `ConsultantAction` for
    consultant-related tasks. You can also specify additional parameters, such as
    a name and color for a given consultant.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在创建`CallCenter`实例后，您使用`System.Threading.Tasks`命名空间中`Parallel`类的`Invoke`静态方法开始执行四个操作，即代表呼叫者和三个咨询师，使用lambda表达式来指定将被调用的方法，即呼叫者相关操作的`CallersAction`和咨询师相关任务的`ConsultantAction`。您还可以指定其他参数，比如给定咨询师的名称和颜色。
- en: 'The `CallersAction` method represents operations performed in a cyclical way
    by many callers. Its code is shown in the following block:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallersAction` 方法代表了许多呼叫者循环执行的操作。其代码如下所示：'
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The most important part of the code is the `while` loop, which is executed infinitely.
    Within it, you get a random number as an identifier of a client (`clientId`) and
    the `Call` method is called. The number of waiting calls is logged, together with
    the client identifier. At the end, the callers-related thread is suspended for
    a random number of milliseconds in the range between 1,000 ms and 5,000 ms, that
    is, between 1 and 5 seconds, to simulate the delay between another call made by
    a caller.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最重要的部分是无限执行的`while`循环。在其中，您会得到一个随机数作为客户的标识符（`clientId`），并调用`Call`方法。等待呼叫的数量被记录下来，连同客户标识符。最后，呼叫者相关的线程将暂停一段随机毫秒数，范围在1,000毫秒到5,000毫秒之间，即1到5秒之间，以模拟呼叫者进行另一个呼叫之间的延迟。
- en: 'The next method is named `ConsultantAction` and is executed on a separate thread
    for each consultant. The method takes three parameters, namely an instance of
    the `CallCenter` class, as well as a name and color for the consultant. The code
    is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法名为`ConsultantAction`，并在每个咨询师的单独线程上执行。该方法接受三个参数，即`CallCenter`类的一个实例，以及咨询师的名称和颜色。代码如下：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Similar to the `CallersAction` method, the most important and interesting operations
    are performed in the infinite `while` loop. Within it, the consultant tries to
    answer the first waiting call using the `Answer` method. If there are no waiting
    calls, the thread is suspended for 100 ms. Otherwise, the log is presented in
    the proper color, depending on the current consultant. Then, the thread is suspended
    for a random period of time between 1 and 10 seconds. After this time, the consultant
    ends the call, which is indicated by calling the `End` method, and generates the
    log. At the end, the thread is suspended for the random time between 500 ms and
    1,000 ms, which represents the delay between the end of a call and the start of
    another one.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与`CallersAction`方法类似，最重要和有趣的操作是在无限的`while`循环中执行的。在其中，咨询师尝试使用`Answer`方法回答第一个等待的呼叫。如果没有等待的呼叫，线程将暂停100毫秒。否则，根据当前咨询师的情况，以适当的颜色呈现日志。然后，线程将暂停1到10秒之间的随机时间。在此时间之后，咨询师结束呼叫，通过调用`End`方法来指示，并生成日志。最后，线程将暂停500毫秒到1,000毫秒之间的随机时间，这代表了呼叫结束和另一个呼叫开始之间的延迟。
- en: 'The last auxiliary method is named `Log` and is exactly the same as in the
    previous example. Its code is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个辅助方法名为`Log`，与前一个示例中的方法完全相同。其代码如下：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When you run the program and wait for some time, you will receive a result
    similar to the one shown in the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行程序并等待一段时间后，您将收到类似于以下截图所示的结果：
- en: '![](img/0a800625-5b63-44b0-a245-6919a7f84ff7.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a800625-5b63-44b0-a245-6919a7f84ff7.png)'
- en: Congratulations! You have just completed two examples representing the application
    of a queue in the case of a call center scenario.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您刚刚完成了两个示例，代表了呼叫中心场景中队列的应用。
- en: It is a good idea to modify various parameters of the program, such as the number
    of consultants, as well as delay times, especially the delay between the following
    calls performed by the callers. Then, you will see how the algorithm works in
    the case when there are too many callers or consultants.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 修改程序的各种参数是一个好主意，比如咨询师的数量，以及延迟时间，特别是呼叫者之间的延迟时间。然后，您将看到算法在呼叫者或咨询师过多的情况下是如何工作的。
- en: However, how can you handle clients with priority support? In the current solution,
    they will wait in the same queue as clients with the standard support plan. Do
    you need to create two queues and first take clients from the prioritized queue?
    If so, what should happen if you introduce another support plan? Do you need to
    add another queue and introduce such modifications in the code? Fortunately, no!
    You can use another data structure, namely a priority queue, to support such a
    scenario, as explained in detail in the following section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如何处理具有优先支持的客户呢？在当前解决方案中，他们将与标准支持计划的客户一起等待在同一个队列中。您需要创建两个队列并首先从优先队列中取客户吗？如果是这样，如果您引入另一个支持计划会发生什么？您需要添加另一个队列并在代码中引入这样的修改吗？幸运的是，不需要！您可以使用另一种数据结构，即优先队列，来支持这样的情景，如下一节中详细解释的那样。
- en: Priority queues
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列
- en: 'A **priority queue** makes it possible to extend the concept of a queue by
    setting **priority** for each element in the queue. It is worth mentioning that
    the priority can be specified simply as an integer value. However, it depends
    on the implementation whether smaller or greater values indicate higher priority.
    Within this chapter, it is assumed that the highest priority is equal to 0, while
    lower priority is specified by 1, 2, 3, and so on. Thus, the **dequeue** operation
    will return the element with the highest priority, which has been added first
    to the queue, as shown in the following diagram:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先级队列**使得可以通过为队列中的每个元素设置**优先级**来扩展队列的概念。值得一提的是，优先级可以简单地指定为整数值。然而，较小或较大的值是否表示更高的优先级取决于实现。在本章中，假设最高优先级等于0，而较低的优先级由1、2、3等指定。因此，**出队**操作将返回具有最高优先级的元素，该元素首先添加到队列中，如下图所示：'
- en: '![](img/fc121dc6-2124-4ec7-8ba1-033cd63f35e9.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc121dc6-2124-4ec7-8ba1-033cd63f35e9.png)'
- en: Let's analyze the diagram. First, the priority queue contains two elements with
    the same priority (equal to **1**), namely **Marcin** and **Lily**. Then, the
    **Mary** element is added with higher priority (**0**), which means that this
    element is placed at the beginning of the queue, that is, before **Marcin**. In
    the next step, the **John** element is added with the lowest priority (**2**),
    so it is added at the end of the priority queue. The third column presents the
    addition of the **Emily** element with a priority equal to **1**, that is, the
    same as **Marcin** and **Lily**. For this reason, the **Emily** element is added
    just after **Lily**. According to the afore mentioned rules, you add the following
    elements, namely **Sarah** with a priority set to **0** and **Luke** with a priority
    equal to **1**. The final order is shown on the right-hand side of the preceding
    diagram.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下图表。首先，优先级队列包含两个具有相同优先级（等于**1**）的元素，即**Marcin**和**Lily**。然后，添加了具有更高优先级（**0**）的**Mary**元素，这意味着该元素位于队列的开头，即在**Marcin**之前。在下一步中，具有最低优先级（**2**）的**John**元素被添加到优先级队列的末尾。第三列显示了具有优先级等于**1**的**Emily**元素的添加，即与**Marcin**和**Lily**相同。因此，**Emily**元素在**Lily**之后添加。根据前述规则，您添加以下元素，即优先级设置为**0**的**Sarah**和优先级等于**1**的**Luke**。最终顺序显示在前述图表的右侧。
- en: Of course, it is possible to implement the priority queue on your own. However,
    you can simplify this task by using one of the available NuGet packages, namely
    `OptimizedPriorityQueue`. More information about this package is available at [https://www.nuget.org/packages/OptimizedPriorityQueue](https://www.nuget.org/packages/OptimizedPriorityQueue).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以自己实现优先级队列。但是，您可以通过使用其中一个可用的NuGet包，即`OptimizedPriorityQueue`来简化此任务。有关此包的更多信息，请访问[https://www.nuget.org/packages/OptimizedPriorityQueue](https://www.nuget.org/packages/OptimizedPriorityQueue)。
- en: 'Do you know how you can add this package to your project? If not, you should
    follow these steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道如何将此包添加到您的项目中吗？如果不知道，您应该按照以下步骤进行：
- en: Select Manage NuGet Packages from the context menu of the project node in the
    Solution Explorer window.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器窗口中的项目节点的上下文菜单中选择管理NuGet包。
- en: Choose the Browse tab in the opened window.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择打开窗口中的浏览选项卡。
- en: Type `OptimizedPriorityQueue` in the search box.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中键入`OptimizedPriorityQueue`。
- en: Click on the OptimizedPriorityQueue item.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击OptimizedPriorityQueue项目。
- en: Press the Install button on the right.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧单击安装按钮。
- en: Click on OK in the Preview Changes window.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在预览更改窗口中单击确定。
- en: Wait until the Finished message is shown in the Output window.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待直到在输出窗口中显示完成消息。
- en: 'The `OptimizedPriorityQueue` library significantly simplifies the application
    of a priority queue in various applications. Within it, the `SimplePriorityQueue`
    generic class is available, which contains a few useful methods, such as:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptimizedPriorityQueue`库显着简化了在各种应用程序中应用优先级队列。其中，可用`SimplePriorityQueue`泛型类，其中包含一些有用的方法，例如：'
- en: '`Enqueue`, to add an element to the priority queue'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enqueue`，向优先级队列中添加元素'
- en: '`Dequeue`, to remove an element from the beginning and return it'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dequeue`，从开头删除元素并返回它'
- en: '`GetPriority`, to return the priority of an element'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetPriority`，返回元素的优先级'
- en: '`UpdatePriority`, to update the priority of an element'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdatePriority`，更新元素的优先级'
- en: '`Contains`, to check whether an element exists in the priority queue'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contains`，检查优先级队列中是否存在元素'
- en: '`Clear`, to remove all elements from the priority queue'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear`，从优先级队列中删除所有元素'
- en: You can get the number of elements in the queue using the `Count` property.
    If you want to get an element from the beginning of the priority queue without
    removing it, you can use the `First` property. Moreover, the class contains a
    set of methods, which can be useful in multithreading scenarios, such as `TryDequeue`
    and `TryRemove`. It is worth mentioning that both the `Enqueue` and `Dequeue`
    methods are *O(log n)* operations.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Count`属性获取队列中元素的数量。如果要从优先级队列的开头获取元素而不将其删除，可以使用`First`属性。此外，该类包含一组方法，这些方法在多线程场景中可能很有用，例如`TryDequeue`和`TryRemove`。值得一提的是，`Enqueue`和`Dequeue`方法都是*O(log
    n)*操作。
- en: After this short introduction to the topic of priority queues, let's proceed
    to the example of a call center with priority support, which is described in the
    following section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在对优先级队列的主题进行了简短介绍之后，让我们继续介绍具有优先级支持的呼叫中心的示例，该示例在以下部分中进行了描述。
- en: Example – call center with priority support
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 具有优先级支持的呼叫中心
- en: As an example of a priority queue, let's present a simple approach to the call
    center example, where there are many callers (with different client identifiers),
    and only one consultant, who answers waiting calls, first from the priority queue
    and then from the clients with the standard support plan.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 作为优先级队列的示例，让我们介绍一种简单的方法，即呼叫中心示例，其中有许多呼叫者（具有不同的客户标识符），并且只有一个顾问，他首先从优先级队列中回答等待的呼叫，然后从具有标准支持计划的客户那里回答。
- en: 'The afore mentioned scenario is presented in the following diagram. Calls with
    the standard priority are marked with **-**, while calls with priority support
    are indicated by *****, as shown as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情景在以下图表中呈现。标有**-**的是标准优先级的呼叫，而标有*****的是优先级支持的呼叫，如下所示：
- en: '![](img/207dd920-227c-43c6-aa0d-851366641327.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/207dd920-227c-43c6-aa0d-851366641327.png)'
- en: 'Let''s take a look at the order of elements in the priority queue. Currently,
    it contains only three elements, which will be served in the following order:
    **#5678** (who has priority support), **#1234**, and **#1468**. However, the call
    from the client with the identifier **#9641** causes the order to change to **#5678**,
    **#9641** (due to the priority support), **#1234**, and **#1468**.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看优先级队列中元素的顺序。目前，它只包含三个元素，将按以下顺序提供服务：**#5678**（具有优先级支持），**#1234**和**#1468**。然而，来自标识符**#9641**的客户的呼叫导致顺序变为**#5678**，**#9641**（由于优先级支持），**#1234**和**#1468**。
- en: 'It is high time to write some code! First, do not forget to add the `OptimizedPriorityQueue`
    package to the project, as explained earlier. When the library is configured properly,
    you can proceed to the implementation of the `IncomingCall` class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候写一些代码了！首先，不要忘记将`OptimizedPriorityQueue`包添加到项目中，如前所述。当库配置正确时，您可以继续实现`IncomingCall`类：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, there is only one change in comparison to the previously presented scenario
    of the simple call center application, namely the `IsPriority` property is added.
    It indicates whether the current call has priority support (`true`) or standard
    support (`false`).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，与之前呈现的简单呼叫中心应用程序的情景相比，只有一个变化，即添加了`IsPriority`属性。它指示当前呼叫是否具有优先级支持（`true`）或标准支持（`false`）。
- en: 'Some modifications are also necessary in the `CallCenter` class, whose fragment
    is shown in the following code snippet:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallCenter`类中也需要进行一些修改，其片段如下代码片段所示：'
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see, the type of the `Calls` property has been changed from `Queue`
    to the `SimplePriorityQueue` generic class. The following changes are necessary
    in the `Call` method, with the code being presented as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Calls`属性的类型已从`Queue`更改为`SimplePriorityQueue`泛型类。在`Call`方法中需要进行以下更改，代码如下所示：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Within this method, a value of the `IsPriority` property (mentioned earlier)
    is set using the parameter. Moreover, while calling the `Enqueue` method, two
    parameters are used, not only the value of the element (an instance of the `IncomingCall`
    class), but also an integer value of the priority, namely `0` in the case of priority
    support, or `1` otherwise.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，使用参数设置了`IsPriority`属性（前面提到的）。此外，在调用`Enqueue`方法时，使用了两个参数，不仅是元素的值（`IncomingCall`类的实例），还有一个优先级的整数值，即在优先级支持的情况下为`0`，否则为`1`。
- en: 'No more changes are necessary in the methods of the `CallCenter` class, namely
    in `Answer`, `End`, and `AreWaitingCalls`. The relevant code is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CallCenter`类的方法中不需要进行更多的修改，即`Answer`，`End`和`AreWaitingCalls`方法。相关代码如下：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, let''s take a look at the code of the `Main` and `Log` methods in
    the `Program` class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看`Program`类中`Main`和`Log`方法的代码：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You may be surprised to learn that only two changes are necessary in this part
    of the code! The reason for this is that the logic regarding the used data structure
    is hidden in the `CallCenter` class. Within the `Program` class, you call some
    methods and use properties exposed by the `CallCenter` class. You just need to
    modify how you add calls to the queue, as well as adjust the log presented when
    the call is answered by the consultant to also present the call's priority. That's
    all!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会惊讶地发现，在代码的这一部分只需要进行两个更改！原因是使用的数据结构的逻辑被隐藏在`CallCenter`类中。在`Program`类中，您调用了一些方法并使用了`CallCenter`类公开的属性。您只需要修改向队列添加呼叫的方式，并调整呼叫被顾问接听时呈现的日志，以展示呼叫的优先级。就是这样！
- en: 'When you run the application, you will receive a result similar to the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时，您将收到类似以下的结果：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, the calls are served in the correct order. This means that the
    calls from clients with priority support are served earlier than calls from clients
    with the standard support plan, despite the fact that such calls need to wait
    much longer to be answered.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，呼叫按正确的顺序提供服务。这意味着具有优先级支持的客户的呼叫比具有标准支持计划的客户的呼叫更早得到服务，尽管这类呼叫需要等待更长时间才能得到答复。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned about three limited access data structures,
    namely stacks, queues, and priority queues. It is worth remembering that such
    data structures have strictly specified ways of accessing elements. All of them
    also have various real-world applications, and some have been mentioned and described
    in this book.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了三种有限访问数据结构，即栈、队列和优先级队列。值得记住的是，这些数据结构都有严格指定的访问元素的方式。它们都有各种各样的现实世界应用，本书中已经提到并描述了其中一些。
- en: First, you saw how the stack operates according to the LIFO principle. In this
    case, you can only add an element at the top of the stack (the push operation),
    and only remove an element from the top (the pop operation). The stack has been
    shown in two examples, namely for reversing a word and for solving the Tower of
    Hanoi mathematical game.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您看到了栈如何按照LIFO原则运作。在这种情况下，您只能在栈的顶部添加元素（推送操作），并且只能从顶部移除元素（弹出操作）。栈已在两个示例中展示，即用于颠倒一个单词和解决汉诺塔数学游戏。
- en: In the following part of the chapter, you got to know the queue as a data structure,
    which operates according to the FIFO principle. In this case, enqueue and dequeue
    operations were presented. The queue has been explained using two examples, both
    regarding the application simulating a call center. Furthermore, you have learned
    how to run a few threads, as well as how to use the thread-safe variant of the
    queue, which is available while developing applications in the C# language.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，您了解了队列作为一种数据结构，它根据FIFO原则运作。在这种情况下，介绍了入队和出队操作。队列已通过两个示例进行了解释，都涉及模拟呼叫中心的应用程序。此外，您还学会了如何运行几个线程，以及如何在C#语言开发应用程序时使用线程安全的队列变体。
- en: The third data structure shown in this chapter is named the priority queue and
    is an extension of the queue that supports priorities of particular elements.
    To make using this data structure easier, you have been shown how to use the external
    NuGet package. As an example, the call center scenario has been extended to handle
    two support plans.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的第三种数据结构称为优先队列，是队列的扩展，支持特定元素的优先级。为了更容易地使用这种数据结构，您已经学会了如何使用外部NuGet包。例如，呼叫中心场景已扩展为处理两种支持计划。
- en: This is just the third chapter of this book and you have already learned a lot
    about various data structures and algorithms which are useful while developing
    applications in C#! Are you interested in increasing your knowledge by learning
    about dictionaries and sets? If so, let's proceed to the next chapter and learn
    more about such data structures!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是本书的第三章，您已经学到了很多关于各种数据结构和算法的知识，这些知识在C#应用程序开发中非常有用！您是否有兴趣通过学习字典和集合来增加您的知识？如果是的话，让我们继续下一章，了解更多关于这些数据结构的知识！
