- en: IoTFW.js - I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IoTFW.js - I
- en: 'In this chapter and [Chapter 3](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee),
    *IoTFW.js - II*, we are going to develop a reference architecture for building
    various IoT solutions. The reference architecture or the IoT framework will be
    serving as a base for our future IoT solutions that we are going to be working
    on in this book. We will be calling this reference architecture or framework as
    IoTFW.js. We will be working on the following topics to bring IoTFW.js to life:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和[第3章](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee)，*IoTFW.js -
    II*中，我们将开发一个用于构建各种物联网解决方案的参考架构。该参考架构或物联网框架将作为我们未来在本书中要开发的物联网解决方案的基础。我们将称这个参考架构或框架为IoTFW.js。我们将致力于以下主题，以使IoTFW.js生动起来：
- en: Designing an IoTFW.js architecture
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计IoTFW.js架构
- en: Developing a Node.js based server-side layer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发基于Node.js的服务器端层
- en: Developing an Angular 4 based web app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个基于Angular 4的Web应用程序
- en: Developing an Ionic 3 based mobile app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个基于Ionic 3的移动应用程序
- en: Developing an Angular 4 and Electron.js desktop app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个基于Angular 4和Electron.js的桌面应用程序
- en: Setting up and installing the required dependencies on a Raspberry Pi 3
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在树莓派3上设置和安装所需的依赖关系
- en: Integrating all the pieces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合所有的部分
- en: We are going to cover some of the previous topics in this chapter and some in
    [Chapter 3](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee), *IoTFW.js
    - II*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖一些先前的主题，以及[第3章](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee)，*IoTFW.js
    - II*中的一些主题。
- en: Designing a reference architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个参考架构
- en: As we have seen in [Chapter 1](part0024.html#MSDG0-ce91715363d04669bca1c1545beb57ee),
    *The World of IoT*, all the examples we are going to work on have a common setup.
    That would be the hardware, firmware (software running on the hardware), broker,
    API engine and the user apps.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](part0024.html#MSDG0-ce91715363d04669bca1c1545beb57ee)，*物联网的世界*中所看到的，我们将要处理的所有示例都有一个共同的设置。那就是硬件、固件（在硬件上运行的软件）、代理、API引擎和用户应用程序。
- en: We will be expanding on the relevant pieces of framework as we come across it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在遇到相关框架的部分时进行扩展。
- en: As and when we need to, we will be expanding on the hardware, or mobile app,
    or the API engine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要时，我们将扩展硬件、移动应用程序或API引擎。
- en: With this reference architecture, we are going to establish a pipeline between
    the devices present in the real world to the cloud in the virtual world. In other
    words, IoT is a last mile solution between devices and the internet.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个参考架构，我们将在现实世界中的设备与虚拟世界中的云之间建立一个管道。换句话说，物联网是设备和互联网之间的最后一英里解决方案。
- en: Architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: 'A simple reference architecture with Raspberry Pi, Wi-Fi gateway, the cloud
    engine, and the user interface apps stitched together would look as shown in the
    following diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用树莓派、Wi-Fi网关、云引擎和用户界面应用程序组合在一起的简单参考架构如下图所示：
- en: '![](../images/00008.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00008.jpeg)'
- en: At a very high level, we have smart devices on the left-hand side and the user
    devices on the right-hand side. All of the communication between them happens
    through the cloud.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常高的层面上，我们在左侧有智能设备，在右侧有用户设备。它们之间的所有通信都通过云端进行。
- en: Following is a description of each key entity in the previous architecture.
    We are going to start from the left-hand side and move towards the right.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是先前架构中每个关键实体的描述。我们将从左侧开始，向右移动。
- en: Smart device
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能设备
- en: Smart devices are hardware entities that consist of a sensor, or actuator, or
    both, any micro controller or micro processor, in our case, a Raspberry pi 3.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 智能设备是硬件实体，包括传感器、执行器或两者，任何微控制器或微处理器，在我们的案例中是树莓派3。
- en: A sensor is an electronic component that can sense or measure a physical property
    and relay it back to a microcontroller or a microprocessor. The data relayed back
    can be periodic or event-driven; event-driven as in when there is change in data
    only. A temperature sensor such as an LM35 or DHT11 is an example of a sensor.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器是一种可以感知或测量物理特性并将其传回微控制器或微处理器的电子元件。传回的数据可以是周期性的或事件驱动的；事件驱动的意思是只有在数据发生变化时才会传回。温度传感器，如LM35或DHT11，就是传感器的一个例子。
- en: An actuator is also an electro-mechanical component that can trigger actions
    in the real world. Generally, the actuators do not act by themselves. A microcontroller,
    a microprocessor, or an electronic logic sends signals to the actuator. An example
    of an actuator is a mechanical relay.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器也是可以触发现实世界中动作的电机械组件。通常，执行器不会自行行动。微控制器、微处理器或电子逻辑发送信号给执行器。执行器的一个例子是机械继电器。
- en: The micro-processor we were referring would be a Raspberry Pi 3 for this book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中提到的微处理器将是树莓派3。
- en: The Raspberry Pi 3 is a single-board computer, designed and developed by the
    Raspberry Pi foundation. The Raspberry Pi 3 is the third-generation Raspberry
    Pi.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派3是由树莓派基金会设计和开发的单板计算机。树莓派3是第三代树莓派。
- en: 'In this book, we are going to use a Raspberry Pi 3 model B for all the examples.
    Some of the specifications of the Raspberry Pi 3 model B are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用树莓派3型B来进行所有示例。树莓派3型B的一些规格如下：
- en: '| **Feature** | **Specification** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **规格** |'
- en: '| Generation | 3 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 代 | 3 |'
- en: '| Release date | February 2016 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 发布日期 | 2016年2月 |'
- en: '| Architecture | ARMv8-A (64/32-bit) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 架构 | ARMv8-A（64/32位） |'
- en: '| System on a Chip (SoC) | Broadcom BCM2837 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 系统芯片（SoC） | Broadcom BCM2837 |'
- en: '| CPU | 1.2 GHz 64-bit quad-core ARM Cortex-A53 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| CPU | 1.2 GHz 64位四核 ARM Cortex-A53 |'
- en: '| Memory (SDRAM) | 1 GB (shared with GPU) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 内存（SDRAM） | 1 GB（与GPU共享） |'
- en: '| USB 2.0 ports | 4 (via the on-board 5-port USB hub) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| USB 2.0端口 | 4（通过机载5端口USB集线器） |'
- en: '| On-board network | 10/100 Mbit/s Ethernet, 802.11n wireless, Bluetooth 4.1
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 机载网络 | 10/100兆比特/秒以太网，802.11n 无线，蓝牙4.1 |'
- en: '| Low-level peripherals | 17× GPIO plus the same specific functions, and HAT
    ID bus |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 低级外围设备 | 17× GPIO加上相同的特定功能，和HAT ID总线 |'
- en: '| Power ratings | 300 mA (1.5 W) average when idle, 1.34 A (6.7 W) maximum
    under stress (monitor, keyboard, mouse, and Wi-Fi connected) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|功率评级|空闲时平均300毫安（1.5瓦），在压力下最大1.34安（6.7瓦）（监视器、键盘、鼠标和Wi-Fi连接）|'
- en: '| Power source | 5 V via MicroUSB or GPIO header |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|电源|通过MicroUSB或GPIO引脚的5V|'
- en: 'For more information on the specifications, please refer to the specifications
    of Raspberry Pi: [https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications](https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有关规格的更多信息，请参考树莓派的规格：[https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications](https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications)。
- en: Gateway
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网关
- en: The next piece in our architecture is the Wi-Fi router. A common household Wi-Fi
    router will act as a gateway for us. As we have seen in [Chapter 1](part0024.html#MSDG0-ce91715363d04669bca1c1545beb57ee),
    *The World of IoT*, in the *Clustered devices versus standalone devices* section,
    we are following the approach of standalone devices, where each device is self-sufficient
    and has a radio of its own to communicate with the outside world. All the projects
    we are going to build consist of a Raspberry Pi 3, which has a microprocessor
    as well as the radio to interface with the sensors, and actuators with the internet.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们架构中的下一个部分是Wi-Fi路由器。一个普通的家用Wi-Fi路由器将作为我们的网关。正如我们在[第1章](part0024.html#MSDG0-ce91715363d04669bca1c1545beb57ee)中所看到的，在*物联网的世界*中，*集群设备与独立设备*部分，我们遵循独立设备的方法，其中每个设备都是自给自足的，并且有自己的无线电与外界通信。我们将要构建的所有项目都包括一个树莓派3，它具有微处理器以及与传感器和执行器进行通信的无线电。
- en: MQTTS broker
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MQTTS代理
- en: 'The next important piece in our reference framework is the secure communication
    channel between the device and the cloud. We are going to use MQTT as our communication
    channel. MQTT is described in the following quote from [http://mqtt.org/faq](http://mqtt.org/faq):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们参考框架中的下一个重要部分是设备和云之间的安全通信通道。我们将使用MQTT作为我们的通信通道。MQTT在以下引用中描述：[http://mqtt.org/faq](http://mqtt.org/faq)。
- en: MQTT stands for MQ Telemetry Transport. It is a publish/subscribe, extremely
    simple and lightweight messaging protocol, designed for constrained devices and
    low-bandwidth, high-latency or unreliable networks. The design principles are
    to minimise network bandwidth and device resource requirements whilst also attempting
    to ensure reliability and some degree of assurance of delivery.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT代表MQ遥测传输。这是一种发布/订阅、非常简单和轻量级的消息传递协议，设计用于受限设备和低带宽、高延迟或不可靠网络。设计原则是尽量减少网络带宽和设备资源需求，同时也尝试确保可靠性和一定程度的传递保证。
- en: We are going to use the MQTT over SSL or MQTTS. In our architecture, we are
    going to use Mosca ([http://www.mosca.io/](http://www.mosca.io/)) as our MQTTS
    broker. Mosca is a Node.js MQTT broker. We will talk more about Mosca when we
    start working with it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用MQTT over SSL或MQTTS。在我们的架构中，我们将使用Mosca（[http://www.mosca.io/](http://www.mosca.io/)）作为我们的MQTTS代理。Mosca是一个Node.js
    MQTT代理。当我们开始使用它时，我们将更多地谈论Mosca。
- en: API engine
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API引擎
- en: An API engine is a web server application, written on Node.js, Express with
    persistence layer as MongoDB. This engine is responsible for communicating with
    Mosca as a MQTT client, persisting data into MongoDB as well as to expose APIs
    using Express. These APIs are then consumed by the apps to display the data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: API引擎是一个基于Node.js、Express编写的Web服务器应用，具有MongoDB作为持久化层。该引擎负责与Mosca通信作为MQTT客户端，将数据持久化到MongoDB，并使用Express公开API。然后应用程序使用这些API来显示数据。
- en: We will also be implementing a socket-based API for user interfaces to get notified
    in real time from the devices between the apps and the server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现基于套接字的API，用于用户界面在设备和服务器之间实时获取通知。
- en: MongoDB
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB
- en: We are going to use MongoDB as our data persistence layer. MongoDB is a NoSQL
    document database that allows us to save documents with different schemas in one
    collection. This kind of database is well suited for dealing with sensor data
    from various devices, as the data structure or the parameters vary from solution
    to solution. To know more about MongoDB, refer to [https://www.mongodb.com/](https://www.mongodb.com/).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用MongoDB作为我们的数据持久化层。MongoDB是一个NoSQL文档数据库，允许我们在一个集合中保存具有不同模式的文档。这种数据库非常适合处理来自各种设备的传感器数据，因为数据结构或参数因解决方案而异。要了解有关MongoDB的更多信息，请参阅[https://www.mongodb.com/](https://www.mongodb.com/)。
- en: Web app
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用
- en: The web app is a simple web/mobile web interface, which will implement the APIs
    exposed by the API engine. These APIs will include authentication, access a particular
    smart device, get the latest data from the smart device, and send data back to
    the smart device over APIs. We are going to use Angular 4 ([https://angular.io/](https://angular.io/))
    and Twitter Bootstrap 3 ([http://getbootstrap.com/](http://getbootstrap.com/))
    technologies to build the web app.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用是一个简单的Web/移动Web界面，将实现API引擎公开的API。这些API将包括身份验证，访问特定的智能设备，获取智能设备的最新数据，并通过API将数据发送回智能设备。我们将使用Angular
    4（[https://angular.io/](https://angular.io/)）和Twitter Bootstrap 3（[http://getbootstrap.com/](http://getbootstrap.com/)）技术来构建Web应用。
- en: Mobile app
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动应用
- en: We are going to follow a mobile hybrid approach for building our mobile app.
    The mobile app implements the APIs exposed by the API engine. These APIs will
    include authentication, access a particular smart device, get the latest data
    from the smart device and send data back to the smart device over APIs. We are
    going to use Ionic 3 ([http://ionicframework.com/](http://ionicframework.com/)),
    which is powered by Angular 4, to build the mobile app.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用混合移动方法来构建我们的移动应用。移动应用实现了API引擎公开的API。这些API将包括身份验证，访问特定的智能设备，获取智能设备的最新数据，并通过API将数据发送回智能设备。我们将使用Ionic
    3（[http://ionicframework.com/](http://ionicframework.com/)），它由Angular 4提供支持，来构建移动应用。
- en: Desktop app
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桌面应用
- en: We are going to follow a desktop hybrid approach for building our desktop app.
    The desktop app will implement the APIs exposed by the API engine. These APIs
    will include authentication, access a particular smart device, get the latest
    data from the smart device, and send data back to the smart device over APIs.
    We are going to use Electron ([https://electron.atom.io/](https://electron.atom.io/))
    as the shell for building the desktop app. We will be using Angular 4 and Twitter
    Bootstrap 3 ([http://getbootstrap.com/](http://getbootstrap.com/)) technologies
    to build the desktop app. We try and reuse as much code as possible between the
    web and desktop apps.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用桌面混合方法来构建我们的桌面应用程序。桌面应用程序将实现API引擎提供的API。这些API将包括身份验证，访问特定的智能设备，从智能设备获取最新数据，并通过API将数据发送回智能设备。我们将使用Electron
    ([https://electron.atom.io/](https://electron.atom.io/))作为构建桌面应用程序的外壳。我们将使用Angular
    4和Twitter Bootstrap 3 ([http://getbootstrap.com/](http://getbootstrap.com/))技术来构建桌面应用程序。我们会尽量在Web和桌面应用程序之间重用尽可能多的代码。
- en: Data flow
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流
- en: Now that we have an understanding of the various pieces of the architecture,
    we will now look at the data flow between the components. We are going to talk
    about the data flow from the smart device to the apps and vice versa.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了架构的各个部分，我们现在将看一下组件之间的数据流。我们将讨论从智能设备到应用程序以及反之的数据流。
- en: Smart device to the apps
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能设备到应用程序
- en: 'A simple flow of data from a sensor to a user device will be as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从传感器到用户设备的简单数据流程如下：
- en: '![](../images/00009.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00009.jpeg)'
- en: As you can see from the previous figure, the data originates at the sensor;
    this data is read by the Raspberry Pi 3 and published to the MQTTS broker (Mosca)
    via the Wi-Fi router. Once the broker receives the data, it will send the same
    to the API engine, which will persist the data to the DB. Once the data has been
    successfully saved, the API engine will send the new data to our app, to show
    the data in real time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图可以看出，数据源自传感器；树莓派3读取这些数据，并通过Wi-Fi路由器将数据发布到MQTTS代理（Mosca）。一旦代理接收到数据，它将把数据发送到API引擎，API引擎将数据持久化到数据库中。数据成功保存后，API引擎将把新数据发送到我们的应用程序，以实时显示数据。
- en: An important thing to notice here is that the API engine will act as an MQTT
    client and subscribe to topics on which the device publishes the data. We will
    look at these topics when we go over the implementation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，API引擎将充当MQTT客户端，并订阅设备发布数据的主题。我们将在实施时查看这些主题。
- en: Generally, the data in this flow would be a typical sensor transmitting data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在这种流程中的数据将是典型的传感器传输数据。
- en: App to the smart device
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序到智能设备
- en: 'The following diagram shows how the data flows from an app to the smart device:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了数据如何从应用程序流向智能设备：
- en: '![](../images/00010.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00010.jpeg)'
- en: As we can see from the previous diagram, if the app wishes to send an instruction
    to the smart device, it sends that message to the API engine. The API engine then
    persists that data into the database and publishes the same to the MQTTS broker,
    to be passed on to the device. The device then reacts to that data on the actuator.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图可以看出，如果应用程序希望向智能设备发送指令，它会将该消息发送到API引擎。然后API引擎将数据持久化到数据库，并将数据发布到MQTTS代理，以传递给设备。设备将根据这些数据做出反应。
- en: Do note that in both the flows, the MQTTS broker manages the devices and the
    API engine manages the apps.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这两种流程中，MQTTS代理管理设备，API引擎管理应用程序。
- en: Building the reference architecture
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建参考架构
- en: In this section, we are going to start putting together all the pieces and stitch
    together the required setup. We are going to start with Node.js installation,
    then the database, and after that, move on to other pieces.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始组合所有部件并组合所需的设置。我们将从Node.js安装开始，然后是数据库，之后，继续其他部件。
- en: Installing Node.js on the server
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上安装Node.js
- en: Before we continue with our development, we need Node.js on our server. The
    server here could be your own desktop, laptop, an AWS machine, or a digitalocean
    instance, which may or may not have a public IP ([https://www.iplocation.net/public-vs-private-ip-address](https://www.iplocation.net/public-vs-private-ip-address)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续开发之前，我们需要在服务器上安装Node.js。这里的服务器可以是您自己的台式机、笔记本电脑、AWS机器，或者是一个可能具有或不具有公共IP的digitalocean实例（[https://www.iplocation.net/public-vs-private-ip-address](https://www.iplocation.net/public-vs-private-ip-address)）。
- en: 'To install Node.js, navigate to [https://nodejs.org/en/](https://nodejs.org/en/)
    and download the appropriate version for your machine. Once installation is completed,
    you can test the installation by running the from a command prompt/terminal:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Node.js，转到[https://nodejs.org/en/](https://nodejs.org/en/)并下载适合您的机器的版本。安装完成后，您可以通过从命令提示符/终端运行以下命令来测试安装：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: and
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may have a later version than the one shown previously.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能拥有比之前显示的版本更新的版本。
- en: Now that we have the required software, we will continue.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所需的软件，我们将继续。
- en: Installing nodemon
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装nodemon
- en: 'Now that we have Node.js installed, we will install nodemon. This will take
    care of auto restarting our node application. Run:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Node.js，我们将安装nodemon。这将负责自动重新启动我们的节点应用程序。运行：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: MongoDB
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB
- en: You can follow one of the following two ways listed to set up the database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下列出的两种方式之一设置数据库。
- en: Local installation
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地安装
- en: We can set up MongoDB on our server as a stand-alone installation. This way,
    the DB is running on the server and the data is persisted there.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在服务器上设置MongoDB作为独立安装。这样，数据库就在服务器上运行，并且数据会持久保存在那里。
- en: Depending on your OS, you can follow the instructions provided at [https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)
    to set up the database.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的操作系统，您可以按照提供的说明在[https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)上设置数据库。
- en: 'Once you have installed the DB, to test whether everything is working fine,
    you can open a new terminal and start the Mongo daemon by running the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完数据库后，为了测试一切是否正常工作，您可以打开一个新的终端，并通过运行以下命令启动Mongo守护进程：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see something similar to the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于以下内容：
- en: '![](../images/00011.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00011.jpeg)'
- en: I am running the database on the default port `27017`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用默认端口`27017`运行数据库。
- en: 'Now we will interact with the database using the mongo shell. Open a new command
    prompt/terminal and run the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用mongo shell与数据库进行交互。打开一个新的命令提示符/终端，并运行以下命令：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will take us to the `mongo` shell, using which we can interface with the
    MongoDB. The following are a few handy commands:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们进入`mongo` shell，通过它我们可以与MongoDB进行交互。以下是一些方便的命令：
- en: '| **Description** | **Command** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | **命令** |'
- en: '| Show all databases | `show dbs` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 显示所有数据库 | `show dbs` |'
- en: '| Use a specific database | `use local` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 使用特定数据库 | `use local` |'
- en: '| Create a database | `use testdb` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 创建数据库 | `use testdb` |'
- en: '| Check database in use | `db` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 检查正在使用的数据库 | `db` |'
- en: '| Create a collection | `db.createCollection("user");` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 创建集合 | `db.createCollection("user");` |'
- en: '| Show all collections in a DB | `show collections` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 显示数据库中的所有集合 | `show collections` |'
- en: '| (Create) insert a document in a collection | `db.user.insert({"name":"arvind"});`
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| （创建）在集合中插入文档 | `db.user.insert({"name":"arvind"});` |'
- en: '| (Read) query a collection | `db.user.find({});` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| （读取）查询集合 | `db.user.find({});` |'
- en: '| (Update) modify a document in collection | `db.user.update({"name": "arvind"},
    {"name" : "arvind2"}, {"upsert":true});` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| （更新）修改集合中的文档 | `db.user.update({"name": "arvind"}, {"name" : "arvind2"},
    {"upsert":true});` |'
- en: '| (Delete) Remove a document | `db.user.remove({"name": "arvind2"});` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| （删除）删除文档 | `db.user.remove({"name": "arvind2"});` |'
- en: Using the previous commands, you can get acquainted with the Mongo shell. In
    our API engine, we are going to use Mongoose ODM ([http://mongoosejs.com/](http://mongoosejs.com/))
    to manage from the Node.js/Express--API engine.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，您可以熟悉Mongo shell。在我们的API引擎中，我们将使用Mongoose ODM（[http://mongoosejs.com/](http://mongoosejs.com/)）来管理Node.js/Express--API引擎。
- en: Using mLab
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用mLab
- en: If you don’t want to go through the hassle of setting up the DB locally, you
    can use a MongoDB as a service such as mLab ([https://mlab.com/](https://mlab.com/))
    for this. In this book, I am going to follow this approach. Instead of having
    a local database, I will be using an instance of mLab.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想费心在本地设置数据库，可以使用mLab（[https://mlab.com/](https://mlab.com/)）等MongoDB作为服务。在本书中，我将遵循这种方法。我将使用mLab的实例，而不是本地数据库。
- en: To setup an mLab MongoDB instance, first navigate to [https://mlab.com/login/](https://mlab.com/login/)
    and login. If you do not have an account, you can create one by navigating to
    [https://mlab.com/signup/](https://mlab.com/signup/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置mLab MongoDB实例，首先转到[https://mlab.com/login/](https://mlab.com/login/)并登录。如果您没有帐户，可以通过转到[https://mlab.com/signup/](https://mlab.com/signup/)来创建一个。
- en: mLab has a free tier, which we are going to leverage to build our reference
    architecture. The free tire is perfect for development and prototyping projects
    like ours. Once we are done with the actual development and we are ready for a
    production grade application, we can look at some more reliable plans. You can
    get an idea of pricing at [https://mlab.com/plans/pricing/](https://mlab.com/plans/pricing/).`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: mLab有一个免费的层，我们将利用它来构建我们的参考架构。免费层非常适合像我们这样的开发和原型项目。一旦我们完成了实际的开发，并且准备好生产级应用程序，我们可以考虑一些更可靠的计划。您可以在[https://mlab.com/plans/pricing/](https://mlab.com/plans/pricing/)上了解定价。
- en: 'Once you are logged in, click on the Create New button to create a new DB.
    Now, select amazon web services under Cloud Provider and then select the Plan
    Type as FREE, as shown in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您登录，单击“创建新”按钮以创建新的数据库。现在，在云提供商下选择亚马逊网络服务，然后选择计划类型为FREE，如下图所示：
- en: '![](../images/00012.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00012.jpeg)'
- en: And finally, name the database as `iotfwjs` and click on CREATE. And in a few
    seconds, a new MongoDB instance should be created for us.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将数据库命名为`iotfwjs`，然后单击“创建”。然后，几秒钟后，我们应该为我们创建一个新的MongoDB实例。
- en: 'Once the database has been created, open the `iotfwjs` DB. We should see a
    couple of warnings: one stating that this sandbox database should not be used
    for production, which we are aware of, and the second one that there is no database
    user present.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据库创建完成，打开`iotfwjs`数据库。我们应该看到一些警告：一个是指出这个沙箱数据库不应该用于生产，我们知道这一点，另一个是没有数据库用户存在。
- en: 'So, let''s go ahead and create one. Click on the Users tab and click on the
    Add database user button and fill in the form with the username as `admin` and
    password as `admin123` as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们继续创建一个。单击“用户”选项卡，然后单击“添加数据库用户”按钮，并使用用户名`admin`和密码`admin123`填写表单，如下所示：
- en: '![](../images/00013.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00013.jpeg)'
- en: You can choose your own username and password and update it accordingly in the
    remaining part of the book.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择自己的用户名和密码，并相应地在本书的其余部分进行更新。
- en: 'Now to test the connection to our database, use the section at the top of the
    page to connect using the `mongo` shell. In my case, it is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来测试连接到我们的数据库，使用页面顶部的部分使用`mongo` shell进行连接。在我的情况下，如下所示：
- en: '![](../images/00014.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00014.jpeg)'
- en: 'Open a new command prompt and run the following (after updating the mLab URL
    and credentials accordingly):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的命令提示符，并运行以下命令（在相应地更新mLab URL和凭据之后）：
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We should be able to log in to the shell and we can run queries from here as
    follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够登录到shell，并可以从这里运行查询，如下所示：
- en: '![](../images/00015.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00015.jpeg)'
- en: This completes our setup of MongoDB.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的MongoDB设置。
- en: MQTTS broker - Mosca
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MQTTS代理 - Mosca
- en: In this section, we are going to put together the MQTTS broker. We are going
    to use Mosca ([http://www.mosca.io/](http://www.mosca.io/)) as a standalone service
    ([https://github.com/mcollina/mosca/wiki/Mosca-as-a-standalone-service](https://github.com/mcollina/mosca/wiki/Mosca-as-a-standalone-service)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将组装MQTTS代理。我们将使用Mosca ([http://www.mosca.io/](http://www.mosca.io/))作为独立服务
    ([https://github.com/mcollina/mosca/wiki/Mosca-as-a-standalone-service](https://github.com/mcollina/mosca/wiki/Mosca-as-a-standalone-service))。
- en: 'Create a new folder named `chapter2`. Inside the `chapter2` folder, create
    a new folder named `broker` and open a new command prompt/terminal inside the
    folder. Then run the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`chapter2`的新文件夹。在`chapter2`文件夹内，创建一个名为`broker`的新文件夹，并在该文件夹内打开一个新的命令提示符/终端。然后运行以下命令：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will install Mosca and Pino globally. Pino ([https://github.com/pinojs/pino](https://github.com/pinojs/pino))
    is a Node.js logger, which logs all the messages to the console thrown by Mosca.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将全局安装Mosca和Pino。Pino ([https://github.com/pinojs/pino](https://github.com/pinojs/pino))是一个Node.js日志记录器，它记录Mosca抛出的所有消息到控制台。
- en: Now, the default version of Mosca implements MQTT. But we want to secure our
    communication between the smart device and cloud to avoid man-in-the-middle attacks.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Mosca的默认版本实现了MQTT。但我们希望在智能设备和云之间保护我们的通信，以避免中间人攻击。
- en: So, for us to set up MQTTS, we would need an SSL key and SSL certificate. To
    create the SSL key and certificate locally, we will use `openssl`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了设置MQTTS，我们需要SSL密钥和SSL证书。为了在本地创建SSL密钥和证书，我们将使用`openssl`。
- en: To check whether `openssl` is present on your machine, run `openssl version
    -a` and you should see the information about your local installation of `openssl`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查您的计算机上是否存在`openssl`，运行`openssl version -a`，您应该看到关于您的`openssl`本地安装的信息。
- en: If you don't have `openssl`, you can download the same from [https://www.openssl.org/source/](https://www.openssl.org/source/).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有`openssl`，您可以从[https://www.openssl.org/source/](https://www.openssl.org/source/)下载。
- en: 'Now, inside the `broker` folder, create another folder named `certs` and `cd`
    into that folder. Run the following to generate the required key and certificate
    file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`broker`文件夹内，创建一个名为`certs`的文件夹，并`cd`进入该文件夹。运行以下命令生成所需的密钥和证书文件：
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will prompt a few questions and you can fill in the same along the following
    lines:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提示一些问题，您可以按照以下方式填写相同的内容：
- en: '![](../images/00016.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00016.jpeg)'
- en: This will create two new files inside the `certs` folder named `key.pem` and
    `certificate.pem`. We will be using these in our Mosca setup.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`certs`文件夹内创建两个名为`key.pem`和`certificate.pem`的新文件。我们将在我们的Mosca设置中使用这些文件。
- en: 'Next, at the root of the `broker` folder, create a new file named `index.js`
    and update it as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`broker`文件夹的根目录下，创建一个名为`index.js`的新文件，并按以下方式更新它：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The previous code is the configuration with which we are going to launch Mosca.
    The config here loads the SSL certificates and keys and sets Mongo as our persistence
    layer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是我们将用于启动Mosca的配置。此配置加载SSL证书和密钥，并将Mongo设置为我们的持久层。
- en: 'Save `index.js` and head back to the terminal/prompt and `cd` into the location
    where we have the `index.js` file. Next, run the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 保存`index.js`，然后返回到终端/提示符，并`cd`到我们有`index.js`文件的位置。接下来，运行以下命令：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And we should see the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下内容：
- en: '![](../images/00017.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00017.jpeg)'
- en: As you can see from the previous, we are connected to the `iotfwjs` database
    and the broker is going to listen to port `8883` for connections.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前面看到的，我们连接到`iotfwjs`数据库，代理将监听端口`8883`以进行连接。
- en: This wraps up our setup of the MQTTS broker using Mosca.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们使用Mosca设置MQTTS代理的设置。
- en: In the next step, we will implement the API engine and at that point, we are
    going to test the integration of the MQTTS broker with the API engine.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将实现API引擎，此时我们将测试MQTTS代理与API引擎的集成。
- en: API engine - Node.js and Express
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API引擎 - Node.js和Express
- en: In this section, we are going to build the API engine. This engine interfaces
    with our apps and cascades the information from and to the smart device, connecting
    as an MQTT client with the broker.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建API引擎。该引擎与我们的应用程序进行交互，并将智能设备的信息从和到代理进行级联连接。
- en: To get started, we are going to clone a repository that we have created using
    a Yeoman ([http://yeoman.io/](http://yeoman.io/)) generator named `generator-node-express-mongo`
    ([https://www.npmjs.com/package/generator-node-express-mongo](https://www.npmjs.com/package/generator-node-express-mongo)).
    We have taken the code scaffolded by `generator-node-express-mongo` and modified
    it a bit for our needs.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将克隆一个使用Yeoman ([http://yeoman.io/](http://yeoman.io/))生成器创建的存储库，名为`generator-node-express-mongo`
    ([https://www.npmjs.com/package/generator-node-express-mongo](https://www.npmjs.com/package/generator-node-express-mongo))。我们已经使用`generator-node-express-mongo`生成的代码并根据我们的需求进行了修改。
- en: 'Somewhere on your machine, download the complete code base of this book using
    the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的计算机上的某个位置，使用以下命令下载本书的完整代码库：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Or, you can download the zip file from [https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript](https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript)
    as well.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以从[https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript](https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript)下载zip文件。
- en: Once the repository has been downloaded, `cd` into the `base` folder and make
    a copy of `api-engine-base` folder into `chapter2` folder.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦存储库被下载，`cd`进入`base`文件夹，并将`api-engine-base`文件夹复制到`chapter2`文件夹中。
- en: 'This will download the `api-engine` boilerplate code. Once the `repo` is cloned,
    `cd` into the folder and run the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载`api-engine`样板代码。一旦`repo`被克隆，`cd`进入文件夹并运行以下命令：
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will install the needed dependencies.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装所需的依赖项。
- en: 'If we open the `cloned` folder, we should see the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开`cloned`文件夹，我们应该看到以下内容：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This folder has all the bare bones needed for us to get started with our API
    engine.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件夹包含我们启动API引擎所需的所有基本内容。
- en: As you can see from the previous structure, we have a `package.json` at the
    root of the folder. This file consists of all the dependencies needed. We have
    also defined our startup script here.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的结构中可以看出，我们在文件夹的根目录中有一个`package.json`。这个文件包含了所有需要的依赖项。我们还在这里定义了我们的启动脚本。
- en: All our application files are present inside the `server` folder. Everything
    starts at `api-engine/server/app.js`. We initialize `mongoose`, `express`, `socketio`,
    `config`, `routes`, and `mqtt`. And finally, we start our server and listen to
    port `9000` on `localhost` with the help of `server.listen()`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有应用程序文件都位于`server`文件夹中。一切都始于`api-engine/server/app.js`。我们初始化`mongoose`、`express`、`socketio`、`config`、`routes`和`mqtt`。最后，我们启动服务器，并在`localhost`的`9000`端口上侦听，借助`server.listen()`。
- en: '`api-engine/server/config/express.js` has the required setup to initialize
    the Express middleware. `api-engine/server/config/socketio.js` consists of the
    logic needed to manage web sockets.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`api-engine/server/config/express.js`具有初始化Express中间件所需的设置。`api-engine/server/config/socketio.js`包含管理Web套接字所需的逻辑。'
- en: 'We will be using `api-engine/server/config/environment` to configure the environment
    variables. For most of the book, we are going to work with the development environment.
    If we open `api-engine/server/config/environment/development.js`, we should see
    the configuration for `mongo` and `mqtt`. Update them as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`api-engine/server/config/environment`来配置环境变量。在大部分的书中，我们将使用开发环境。如果我们打开`api-engine/server/config/environment/development.js`，我们应该看到`mongo`和`mqtt`的配置。更新它们如下：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Update the mongo URL as per your setup (mLab or local). Since we are going to
    connect to the Mosca broker running on our local machine, we are using `127.0.0.1`
    as the host.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的设置更新mongo URL（mLab或本地）。由于我们将连接到在本地计算机上运行的Mosca代理，我们使用`127.0.0.1`作为主机。
- en: Authorization
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: Next, we are going to look at out-of-the-box auth. We will be using **JSON Web
    Tokens** (**JWTs**) to authenticate the clients that are going to communicate
    with our API engine. We will be using Passport ([http://passportjs.org/](http://passportjs.org/))
    for authentication.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看开箱即用的身份验证。我们将使用**JSON Web Tokens**（**JWTs**）来验证要与我们的API引擎通信的客户端。我们将使用Passport（[http://passportjs.org/](http://passportjs.org/)）进行身份验证。
- en: Open `api-engine/server/auth/index.js` and we should see the Passport setup
    using `require('./local/passport').setup(User, config);` and we are creating a
    new route for authentication.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`api-engine/server/auth/index.js`，我们应该看到使用`require('./local/passport').setup(User,
    config);`设置护照，并且我们正在创建一个新的身份验证路由。
- en: The routes are configured in `api-engine/server/routes.js`. If we open `api-engine/server/routes.js`,
    we should see `app.use('/auth', require('./auth'));`. This will create a new endpoint
    named `/auth` and inside `the api-engine/server/auth/index.js`, we have added
    `router.use('/local', require('./local'));` now, if we wanted to access the `POST`
    method inside `api-engine/server/auth/local/index.js`, we would make a HTTP `POST`
    request to `/auth/local`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 路由在`api-engine/server/routes.js`中配置。如果我们打开`api-engine/server/routes.js`，我们应该看到`app.use('/auth',
    require('./auth'));`。这将创建一个名为`/auth`的新端点，在`api-engine/server/auth/index.js`中，我们已经添加了`router.use('/local',
    require('./local'));`现在，如果我们想要访问`api-engine/server/auth/local/index.js`中的`POST`方法，我们将向`/auth/local`发出HTTP
    `POST`请求。
- en: In the `api-engine`, we are using the passport local authentication strategy
    ([https://github.com/jaredhanson/passport-local](https://github.com/jaredhanson/passport-local))
    to authenticate the user using MongoDB for persistence.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`api-engine`中，我们使用护照本地认证策略（[https://github.com/jaredhanson/passport-local](https://github.com/jaredhanson/passport-local)）来使用MongoDB进行持久化验证用户。
- en: To create a new user, we are going to use the user API. If we open `api-engine/server/routes.js`,
    we should see a route defined to access the users collection `app.use('/api/v1/users',
    require('./api/user'));`. We have prefixed with `/api/v1/users` so we can version
    our API layer later on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新用户，我们将使用用户API。如果我们打开`api-engine/server/routes.js`，我们应该看到定义了一个路由来访问用户集合`app.use('/api/v1/users',
    require('./api/user'));`。我们已经添加了`/api/v1/users`前缀，以便稍后可以对我们的API层进行版本控制。
- en: 'If we open `api-engine/server/api/user/index.js`, we should the see the following
    six routes defined:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开`api-engine/server/api/user/index.js`，我们应该看到定义了以下六个路由：
- en: '`router.get(''/'', auth.hasRole(''admin''), controller.index);`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router.get(''/'', auth.hasRole(''admin''), controller.index);`'
- en: '`router.delete(''/:id'', auth.hasRole(''admin''), controller.destroy);`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router.delete(''/:id'', auth.hasRole(''admin''), controller.destroy);`'
- en: '`router.get(''/me'', auth.isAuthenticated(), controller.me);`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router.get(''/me'', auth.isAuthenticated(), controller.me);`'
- en: '`router.put(''/:id/password'', auth.isAuthenticated(), controller.changePassword);`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router.put(''/:id/password'', auth.isAuthenticated(), controller.changePassword);`'
- en: '`router.get(''/:id'', auth.isAuthenticated(), controller.show);`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router.get(''/:id'', auth.isAuthenticated(), controller.show);`'
- en: '`router.post(''/'', controller.create);`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router.post(''/'', controller.create);`'
- en: The first route is for fetching all the users in the database and, using the
    `auth.hasRole` middleware defined in `api-engine/server/auth/auth.service.js`,
    we will be checking whether the user is authenticated and has the admin role.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个路由是用于获取数据库中所有用户的路由，并使用`api-engine/server/auth/auth.service.js`中定义的`auth.hasRole`中间件，我们将检查用户是否经过身份验证并具有管理员角色。
- en: The next route is to delete a user with an ID; after that, we have a route to
    get a user's information based on the token. We have a `PUT` route to update the
    user's information; one `GET` route to get a user's information based on the user
    ID; and finally, a `POST` route to create a user. Do note that the `POST` route
    doesn't have any authentication or authorization middleware, as the user accessing
    this endpoint will be using our app for the first time (or is trying to register
    with us).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是删除具有ID的用户的路由；之后，我们有一个根据令牌获取用户信息的路由。我们有一个`PUT`路由来更新用户的信息；一个`GET`路由根据用户ID获取用户的信息；最后，一个`POST`路由来创建用户。请注意，`POST`路由没有任何身份验证或授权中间件，因为访问此端点的用户将是第一次使用我们的应用程序（或者正在尝试注册）。
- en: 'Using the `POST` route, we will be creating a new user; this is how we register
    a user: `api-engine/server/api/user/user.model.js` consists of the Mongoose schema
    for the user and `api-engine/server/api/user/user.controller.js` consists of the
    logic for the routes we have defined.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`POST`路由，我们将创建一个新用户；这就是我们注册用户的方式：`api-engine/server/api/user/user.model.js`包含了用户的Mongoose模式，`api-engine/server/api/user/user.controller.js`包含了我们定义的路由的逻辑。
- en: MQTT client
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MQTT客户端
- en: Finally, we are going to look at the MQTT client integration with our `api-engine`.
    If we open `api-engine/server/mqtt/index.js`, we should see the default setup
    of the MQTTS client.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看一下MQTT客户端与我们的`api-engine`的集成。如果我们打开`api-engine/server/mqtt/index.js`，我们应该会看到MQTTS客户端的默认设置。
- en: 'We are using the following configuration to connect to the Mosca broker over
    MQTTS:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下配置来连接到MQTTS上的Mosca经纪人：
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And we are subscribing to two events: one when the connection is established
    and the other when we receive a message. On the `connect` event, we subscribe
    to a topic named `greet` and we are publishing a simple message to that topic
    in the next line. And on the `message` event, we are listening for any messages
    from the broker and we are printing the topic and the message.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在订阅两个事件：一个是在连接建立时，另一个是在接收消息时。在`connect`事件上，我们订阅了一个名为`greet`的主题，并在下一行发布了一个简单的消息到该主题。在`message`事件上，我们正在监听来自经纪人的任何消息，并打印主题和消息。
- en: 'With this, we are aware of most of the pieces of code needed to work with `api-engine`.
    To start the `api-engine`, `cd` into the `chapter2/api-engine` folder and run
    the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经了解了与`api-engine`一起工作所需的大部分代码。要启动`api-engine`，`cd`进入`chapter2/api-engine`文件夹，并运行以下命令：
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will start a new Express server application on port `9000`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在端口`9000`上启动一个新的Express服务器应用程序。
- en: API engine testing
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API引擎测试
- en: 'To quickly check out the API that we have created, we will be using a Chrome
    extension named Postman. You can set up the Chrome extension from here: [https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速检查我们创建的API，我们将使用一个名为Postman的Chrome扩展。您可以从这里设置Chrome扩展：[https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en)。
- en: Once Postman is set up, we will be testing two API calls to validate the register
    and login methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Postman设置好，我们将测试两个API调用以验证注册和登录方法。
- en: Open Postman and enter the requested URL as `http://localhost:9000/api/v1/users`.
    Next, select the method type as `POST`. Once that is done, we will set the headers.
    Add a new header with key as `content-type` and value as `application/json`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Postman，并输入请求的URL为`http://localhost:9000/api/v1/users`。接下来，选择方法类型为`POST`。完成后，我们将设置标头。添加一个新的标头，键为`content-type`，值为`application/json`。
- en: 'Now we will construct the request body/payload. Click on the Body tab, next
    to Headers, and select Raw request. And update it with the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将构建请求体/有效载荷。点击Headers旁边的Body选项卡，选择Raw request。并更新为以下内容：
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can update the data as applicable. And then click on Send. This makes a
    request to the API engine, which will in turn save the data to the database and
    respond with the new user object, along with the auth token.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要更新数据。然后点击发送。这将向API引擎发出请求，API引擎将将数据保存到数据库，并以新用户对象和授权令牌作出响应。
- en: 'Our output should be as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出应该如下：
- en: '![](../images/00018.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00018.jpeg)'
- en: 'Now, if we hit the Send button again with the same data, we should see a validation
    error something the same as the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次点击发送按钮并使用相同的数据，我们应该会看到一个验证错误，类似于以下内容：
- en: '![](../images/00019.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00019.jpeg)'
- en: 'Now, to validate the newly registered user, we will fire a request to `http://localhost:9000/auth/local`
    with only the email and password. And we should see something the same as the
    following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了验证新注册的用户，我们将向`http://localhost:9000/auth/local`发出请求，只包含电子邮件和密码。我们应该会看到类似以下内容的东西：
- en: '![](../images/00020.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00020.jpeg)'
- en: This validates the API we have created.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这验证了我们创建的API。
- en: With this, we complete the walk-through of the API engine. In the next section,
    we are going to integrate the `api-engine` with the broker and test the connectivity
    between them.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们完成了API引擎的演练。在下一节中，我们将集成`api-engine`与经纪人，并测试它们之间的连接。
- en: Communication between broker and API engine
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经纪人和API引擎之间的通信
- en: Now that we are done with the two pieces of software on the cloud, we will be
    interfacing them. In `api-engine/server/config/environment/development.js`, we
    have defined the broker IP and port that the `api-engine` needs to connect to.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在云上完成了这两个软件，我们将对它们进行接口化。在`api-engine/server/config/environment/development.js`中，我们已经定义了`api-engine`需要连接到的经纪人IP和端口。
- en: Later on, if we deploy these two pieces on different machines, this is the place
    where we update the IP and port so the `api-engine` refers to the broker.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，如果我们将这两个部分部署到不同的机器上，这就是我们更新IP和端口的地方，以便`api-engine`引用经纪人。
- en: 'Now, to test the communication, `cd` into `chapter2/broker` folder and run
    the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试通信，`cd`进入`chapter2/broker`文件夹，并运行以下命令：
- en: '[PRE17]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And we should see the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该会看到以下内容：
- en: '![](../images/00021.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00021.jpeg)'
- en: 'Next, open a new command prompt/terminal, `cd` into `chapter2/api-engine` folder,
    and run the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开一个新的命令提示符/终端，`cd`进入`chapter2/api-engine`文件夹，并运行以下命令：
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And we should see the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该会看到以下内容：
- en: '![](../images/00022.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00022.jpeg)'
- en: The API engine connected to the mLab MongoDB instance, post that it started
    a new Express server and finally, it connected to the Mosca broker and the posted
    a message to the greet topic.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: API引擎连接到mLab MongoDB实例，然后启动了一个新的Express服务器，最后连接到了Mosca经纪人，并发布了一条消息到greet主题。
- en: 'Now, if we look at the Mosca terminal, we should see the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查看Mosca终端，我们应该会看到以下内容：
- en: '![](../images/00023.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00023.jpeg)'
- en: The broker logged the activity that has happened so far. A client connected
    with username `API_Server_Dev` and subscribed to a topic named greet with **Quality
    of Service** (**QoS**) as `0`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 经纪人记录了迄今为止发生的活动。一个客户端连接了用户名`API_Server_Dev`并订阅了一个名为greet的主题，**服务质量**（**QoS**）为`0`。
- en: With this, our integration between the broker and API engine is complete.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的经纪人和API引擎之间的集成就完成了。
- en: Next, we are going to move towards the Raspberry Pi 3 and start working on an
    MQTTS client.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转向Raspberry Pi 3，并开始使用MQTTS客户端。
- en: 'If you are new to MQTT protocol, you can refer to *MQTT Essentials: Part 1
    - Introducing MQTT* ([http://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt](http://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt))
    and the subsequent parts. To know more about QoS, refer to *MQTT Essentials Part
    6: Quality of Service 0, 1 & 2* ([https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels](https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels)).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您对MQTT协议不熟悉，可以参考*MQTT Essentials: Part 1 - Introducing MQTT* ([http://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt](http://www.hivemq.com/blog/mqtt-essentials-part-1-introducing-mqtt))以及后续部分。要了解更多关于QoS的信息，请参考*MQTT
    Essentials Part 6: Quality of Service 0, 1 & 2* ([https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels](https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels))。'
- en: Raspberry Pi software
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树莓派软件
- en: In this section, we are going to build the required software to make the Raspberry
    Pi a client to our Mosca broker via the Wi-Fi router.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将构建所需的软件，使树莓派通过Wi-Fi路由器成为我们Mosca经纪人的客户端。
- en: We have already seen in the data flow diagram how the Raspberry Pi stands between
    the sensor and the Mosca broker. Now we are going to set up the required code
    and software.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在数据流程图中看到了树莓派是如何站在传感器和Mosca经纪人之间的。现在我们将设置所需的代码和软件。
- en: Setting up Raspberry Pi
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置树莓派
- en: In this section, we will look at installing the required software on the Raspberry
    Pi.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看看如何在树莓派上安装所需的软件。
- en: A Raspberry Pi, installed with Raspbian OS ([https://www.raspberrypi.org/downloads/raspbian/](https://www.raspberrypi.org/downloads/raspbian/)),
    is a prerequisite. The Wi-Fi should have already been set up and connected before
    we continue.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派安装了Raspbian OS ([https://www.raspberrypi.org/downloads/raspbian/](https://www.raspberrypi.org/downloads/raspbian/))是必需的。在继续之前，Wi-Fi应该已经设置并连接好。
- en: If you are new to setting up a Raspberry Pi 3, refer to the *Beginner's Guide
    to Installing Node.js on a Raspberry Pi* ([http://thisdavej.com/beginners-guide-to-installing-node-js-on-a-raspberry-pi/](http://thisdavej.com/beginners-guide-to-installing-node-js-on-a-raspberry-pi/)).
    We will, however, cover the Node.js part, you can refer until you bring up the
    Pi and configure the Wi-Fi.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是第一次设置树莓派3，请参考*在树莓派上安装Node.js的初学者指南* ([http://thisdavej.com/beginners-guide-to-installing-node-js-on-a-raspberry-pi/](http://thisdavej.com/beginners-guide-to-installing-node-js-on-a-raspberry-pi/))。但是，我们将涵盖Node.js部分，您可以在启动Pi并配置Wi-Fi之前参考。
- en: Once the OS is installed, boot up the Raspberry Pi and log in to it. At this
    point in time, it will be connected to the internet over your own access point
    and you should be able to browse the internet without issues.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统安装完成后，启动树莓派并登录。此时，它将通过您自己的访问点连接到互联网，您应该能够正常浏览互联网。
- en: I am accessing my Raspberry Pi 3 from my Apple MacBook Pro using VNC Viewer.
    This way, I am not always connected to the Raspberry Pi 3.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用VNC Viewer从我的Apple MacBook Pro访问我的树莓派3。这样，我不会总是连接到树莓派3。
- en: 'We will start off by downloading Node.js. Open a new terminal and run the following
    commands:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从下载Node.js开始。打开一个新的终端并运行以下命令：
- en: '[PRE19]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will upgrade all the packages which need upgrades. Next, we will install
    the latest version of Node.js. At the time of writing, Node 7.x is the latest:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这将升级所有需要升级的软件包。接下来，我们将安装最新版本的Node.js。在撰写本文时，Node 7.x是最新版本：
- en: '[PRE20]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will take a moment to install and once your installation is done, you
    should be able to run the following commands to see the version of Node.js and
    `npm`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要一些时间来安装，一旦安装完成，您应该能够运行以下命令来查看Node.js和`npm`的版本：
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this, we are done with setting up the required software for running our
    MQTTS client on the Raspberry Pi 3.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经设置好了在Raspberry Pi 3上运行MQTTS客户端所需的软件。
- en: Raspberry Pi MQTTS client
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树莓派MQTTS客户端
- en: Now we are going to work with the MQTTS client of Node.js.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用Node.js的MQTTS客户端进行工作。
- en: On the desktop of the Raspberry Pi 3, create a folder named `pi-client`. Open
    a terminal and `cd` into the `pi-client` folder.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派3的桌面上，创建一个名为`pi-client`的文件夹。打开一个终端并`cd`到`pi-client`文件夹。
- en: 'The first thing we are going to do is create a `package.json` file. From inside
    the `pi-client` folder, run the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是创建一个`package.json`文件。从`pi-client`文件夹内部运行以下命令：
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then answer the question as applicable. Once you are done with that, next we
    will install MQTT.js ([https://www.npmjs.com/package/mqtt](https://www.npmjs.com/package/mqtt))
    on the Raspberry Pi 3\. Run the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后根据情况回答问题。完成后，我们将在Raspberry Pi 3上安装MQTT.js ([https://www.npmjs.com/package/mqtt](https://www.npmjs.com/package/mqtt))。运行以下命令：
- en: '[PRE23]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once this installation is also done, the final `package.json` will look the
    same as this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个安装也完成了，最终的`package.json`将与这个相同：
- en: '[PRE24]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Do note that we have added a start script to launch our `index.js` file. We
    will be creating the `index.js` file in a moment.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经添加了一个启动脚本来启动我们的`index.js`文件。我们将在片刻之后创建`index.js`文件。
- en: 'Next, at the root of the `pi-client` folder, create a file named `config.js`.
    Update `config.js` as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`pi-client`文件夹的根目录下，创建一个名为`config.js`的文件。更新`config.js`如下：
- en: '[PRE25]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Do notice the host property. This is set to the IP address of my MacBook and
    my MacBook is where I am going to run the Mosca broker API engine. Make sure all
    three (Mosca broker, API engine, and Raspberry Pi 3) of them are on the same Wi-Fi
    network.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意主机属性。这是设置为我的MacBook的IP地址，我的MacBook是我将运行Mosca经纪人API引擎的地方。确保它们三个（Mosca经纪人、API引擎和树莓派3）都在同一个Wi-Fi网络上。
- en: 'Next, we will write the required MQTT client code. Create a file named `index.js`
    at the root of the `pi-client` folder and update it as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写所需的MQTT客户端代码。在`pi-client`文件夹的根目录下创建一个名为`index.js`的文件，并更新如下：
- en: '[PRE26]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is the same test code we have written on the API engine to test the connectivity.
    Save all the files and move towards your Mosca broker.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在API引擎上编写的相同测试代码，用于测试连接。保存所有文件并转向您的Mosca经纪人。
- en: Communication between the broker and the Raspberry Pi
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经纪人和树莓派之间的通信
- en: In this section, we are going to communicate between the broker and the Raspberry
    Pi over MQTTS.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过MQTTS在经纪人和树莓派之间进行通信。
- en: 'Navigate to the `broker` folder and run the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`broker`文件夹并运行以下命令：
- en: '[PRE27]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, head over to the Raspberry Pi, `cd` into the `pi-client` folder, and
    run the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，转到树莓派，`cd`进入`pi-client`文件夹，并运行以下命令：
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And we should see the following message on the Raspberry Pi:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在树莓派上看到以下消息：
- en: '>![](../images/00024.jpeg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](../images/00024.jpeg)'
- en: 'And when we look at the console of Mosca, we should see the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看Mosca的控制台时，我们应该看到以下内容：
- en: '![](../images/00025.jpeg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00025.jpeg)'
- en: This wraps up our connectivity test between the Raspberry Pi 3 and the Mosca
    broker.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们在树莓派3和Mosca经纪人之间的连接测试。
- en: Troubleshooting
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If you are not able to see the previous messages, check the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法看到以前的消息，请检查以下内容：
- en: Check whether the Raspberry Pi and the machine running the broker are on the
    same Wi-Fi network
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查树莓派和运行经纪人的机器是否在同一个Wi-Fi网络上
- en: Cross-check the IP address of the machine running the broker
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查运行经纪人的机器的IP地址
- en: Communication between the Raspberry Pi, the broker and the API engine
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树莓派、经纪人和API引擎之间的通信
- en: Now we are going to integrate the Raspberry Pi, the broker, and the API engine
    and pass the data from the Pi to the API engine.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将集成树莓派、经纪人和API引擎，并将数据从树莓派传递到API引擎。
- en: The way we are going to achieve this is that we are going create a topic named
    `api-engine` and another topic named `rpi`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现这一点的方式是创建一个名为`api-engine`的主题和另一个名为`rpi`的主题。
- en: To send data from the Raspberry Pi to the API engine, we will be using the `api-engine`
    topic and when we need to send data from the API engine to the Raspberry Pi, we
    will use the `rpi` topic.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据从树莓派发送到API引擎，我们将使用`api-engine`主题，当我们需要将数据从API引擎发送到树莓派时，我们将使用`rpi`主题。
- en: In this example, we are going to get the MAC address of the Raspberry Pi and
    send that to the API engine. The API engine will acknowledge the same by sending
    the same MAC address back to the Raspberry Pi. The communication between the API
    engine and Raspberry Pi will happen over the two topics mentioned previously.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将获取树莓派的MAC地址并将其发送到API引擎。API引擎将通过将相同的MAC地址发送回树莓派来确认相同。API引擎和树莓派之间的通信将在前面提到的两个主题上进行。
- en: 'So first, we will update the `api-engine/server/mqtt/index.js` as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们将按照以下方式更新`api-engine/server/mqtt/index.js`：
- en: '[PRE29]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, once the MQTT connection is established, we are subscribing to the `api-engine`
    topic. When we receive any data from the `api-engine` topic, we will send back
    the same to the `rpi` topic.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一旦建立了MQTT连接，我们就会订阅`api-engine`主题。当我们从`api-engine`主题接收到任何数据时，我们将把相同的数据发送回`rpi`主题。
- en: 'From inside the `broker` folder, run the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在`broker`文件夹中运行以下命令：
- en: '[PRE30]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, from inside the `api-engine` folder, run the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`api-engine`文件夹中运行以下命令：
- en: '[PRE31]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, head back to the Raspberry Pi. We are going to install the `getmac` module
    ([https://www.npmjs.com/package/getmac](https://www.npmjs.com/package/getmac))
    that will help us to get the MAC address of a device.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，回到树莓派。我们将安装`getmac`模块（[https://www.npmjs.com/package/getmac](https://www.npmjs.com/package/getmac)），这将帮助我们获取设备的MAC地址。
- en: 'From inside the `pi-client` folder, run the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pi-client`文件夹中运行以下命令：
- en: '[PRE32]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once this is done, update `/home/pi/Desktop/pi-client/index.js` as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，更新`/home/pi/Desktop/pi-client/index.js`如下：
- en: '[PRE33]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the previous code, we have waited for the connection to establish between
    the Raspberry Pi and the broker. Once that is done, we have subscribed to the
    `rpi` topic. Next, we fetched the MAC address of the Raspberry Pi using `GetMac.getMac()`
    and published the same to the `api-engine` topic.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的代码中，我们等待树莓派和经纪人之间的连接建立。一旦完成，我们就订阅了`rpi`主题。接下来，我们使用`GetMac.getMac()`获取了树莓派的MAC地址，并将其发布到`api-engine`主题。
- en: In the `message` event callback, we are listening for the `rpi` topic. If we
    receive any data from the server, it will be printed here.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在`message`事件回调中，我们正在监听`rpi`主题。如果我们从服务器收到任何数据，它将在这里打印出来。
- en: 'Save the file and from inside the `pi-client` folder, run the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，并在`pi-client`文件夹中运行以下命令：
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, if we look at the broker terminal/prompt, we should see the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查看经纪人终端/提示，我们应该看到以下内容：
- en: '![](../images/00026.jpeg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00026.jpeg)'
- en: Both the devices are connected and subscribed to the topic of interest.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个设备都连接并订阅了感兴趣的主题。
- en: 'Next, if we look at the `api-engine` terminal/prompt, we should see the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们查看`api-engine`终端/提示，我们应该看到以下内容：
- en: '![](../images/00027.jpeg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00027.jpeg)'
- en: 'And finally, the Raspberry Pi terminal should look the same as this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，树莓派终端应该看起来与这个一样：
- en: '![](../images/00028.jpeg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00028.jpeg)'
- en: With this, we conclude the integration of the Raspberry Pi with the broker and
    API engine.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们完成了树莓派与经纪人和API引擎的集成。
- en: In the next section, we will implement a web application that can send and receive
    data from the Raspberry Pi through the broker and API engine.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现一个Web应用程序，该应用程序可以通过经纪人和API引擎与树莓派发送和接收数据。
- en: Web app
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序
- en: In this section, we are going to build a web app that interfaces with our API
    engine. The web app is the primary interface with which we will be interacting
    with our smart devices.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个与我们的API引擎进行交互的Web应用程序。Web应用程序是我们将与智能设备进行交互的主要界面。
- en: We are going to build the web app using Angular (4) and Twitter Bootstrap (3).
    There is no rule that the interface should be built with Angular and Bootstrap;
    it can be built using jQuery or React.js as well. All we will be doing is interfacing
    with the APIs of the API engine using JavaScript from the browser. The only reason
    we are using Angular is to keep the framework consistent across all our apps.
    Since we will be using the Ionic framework, which also follows the Angular approach,
    things will be easy for us to manage as well as reuse.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Angular (4)和Twitter Bootstrap (3)构建Web应用程序。界面不一定要使用Angular和Bootstrap构建；也可以使用jQuery或React.js。我们将做的只是使用浏览器中的JavaScript与API引擎的API进行接口。我们之所以使用Angular，只是为了保持所有应用程序的框架一致。由于我们将使用Ionic框架，它也遵循Angular的方法，因此对我们来说管理和重用都会很容易。
- en: To get started with the web application, we are going to install Angular CLI
    ([https://github.com/angular/angular-cli](https://github.com/angular/angular-cli)).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Web应用程序，我们将安装Angular CLI ([https://github.com/angular/angular-cli](https://github.com/angular/angular-cli))。
- en: On the machine that was running our broker and API engine, we will be setting
    up the web app as well.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行我们的代理和API引擎的机器上，我们也将设置Web应用程序。
- en: Setting up the app
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置应用程序
- en: 'From inside the `chapter2` folder, open a new command prompt/terminal and run
    the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 从`chapter2`文件夹内，打开一个新的命令提示符/终端，并运行以下命令：
- en: '[PRE35]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will install the Angular CLI generator. If you run `ng -v` after the installation
    is done, you should see a version number greater than or equal to 1.0.2.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装Angular CLI生成器。安装完成后运行`ng -v`，您应该看到一个大于或等于1.0.2的版本号。
- en: If you are facing any issues while setting up and running the IoTFW.js, feel
    free to drop your comment here:[https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript/issues/1](https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript/issues/1)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在设置和运行IoTFW.js时遇到任何问题，请随时在此处留下您的评论：[https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript/issues/1](https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript/issues/1)
- en: For the web app, we have already created a base project using Angular CLI and
    have added the essential pieces to integrate with the API engine. We will clone
    the project as is and then start working on top of it.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web应用程序，我们已经使用Angular CLI创建了一个基本项目，并添加了必要的部分来与API引擎集成。我们将克隆项目并在此基础上开始工作。
- en: 'To get started, we need the web app base. If you have not already cloned the
    book''s code repository, you can do so using the following command-line (anywhere
    on your machine):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要Web应用程序的基础。如果您还没有克隆该书的代码存储库，可以在您的任何位置使用以下命令行进行克隆：
- en: '[PRE36]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Or you can download the zip file from [https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript](https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript)
    as well.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您也可以从[https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript](https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript)下载zip文件。
- en: Once the repository has been downloaded, `cd` into the `base` folder and make
    a copy of `web-app-base` folder into `chapter2` folder.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦存储库被下载，`cd`进入`base`文件夹，并将`web-app-base`文件夹复制到`chapter2`文件夹中。
- en: 'Once the base has been copied, `cd` into the `web-app` folder, and run the
    following command:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 基础已经复制完成后，`cd`进入`web-app`文件夹，并运行以下命令：
- en: '[PRE37]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will install the needed dependencies.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装所需的依赖项。
- en: Project structure
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'If we open the `cloned` folder, we should see the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打开`cloned`文件夹，我们应该看到以下内容：
- en: '[PRE38]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, for the walk-through of the project structure and code setup.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下项目结构和代码设置的步骤。
- en: At a high level, we have an `src` folder, where we will have all the source
    code and unit test code, and an `e2e` folder, which consists of the end-to-end
    test.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，我们有一个`src`文件夹，其中包含所有的源代码和单元测试代码，还有一个`e2e`文件夹，其中包含端到端测试。
- en: We will be spending most of the time inside the `src/app` folder. Before we
    go into this folder, open `web-app/src/main.ts` and this is where everything begins.
    Next, we have added the Twitter Bootstrap Cosmos theme ([https://bootswatch.com/cosmo/](https://bootswatch.com/cosmo/))
    here and defined a few layout styles.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将大部分时间花在`src/app`文件夹内。在进入这个文件夹之前，打开`web-app/src/main.ts`，这是一切的开始。接下来，我们在这里添加了Twitter
    Bootstrap Cosmos主题([https://bootswatch.com/cosmo/](https://bootswatch.com/cosmo/))，并定义了一些布局样式。
- en: 'Now, the `app/src` folder: here, we have defined the root component, the root
    module, and the required components and services.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`app/src`文件夹：在这里，我们定义了根组件、根模块和所需的组件和服务。
- en: App module
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用模块
- en: Open `web-app/src/app/app.module.ts`. This file consists of the `@NgModule`
    declaration, which defines all the components and services that we are going to
    use.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`web-app/src/app/app.module.ts`。这个文件包括`@NgModule`声明，定义了我们将要使用的所有组件和服务。
- en: 'We have created the following components:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了以下组件：
- en: '`AppComponent`: Application root component that holds the router outlet'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppComponent`：应用程序根组件，包含路由出口'
- en: '`NavBarComponent`: This is the navigation bar component that appears on the
    all the pages. This component automatically detects the authentication state and
    shows the menu bar accordingly'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavBarComponent`：这是出现在所有页面上的导航栏组件。该组件会自动检测认证状态，并相应地显示菜单栏'
- en: '`LoginComponent`: This deals with the login feature'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginComponent`：处理登录功能'
- en: '`RegisterComponent`: To work with registration with the API engine'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegisterComponent`：用于与API引擎进行注册'
- en: '`HomeComponent`: This component displays all the devices attached to the current
    logged-in user'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HomeComponent`：这个组件显示当前登录用户附加的所有设备'
- en: '`DeviceComponent`: This component displays information about one device'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeviceComponent`：这个组件显示有关一个设备的信息'
- en: '`AddDeviceComponent`: This component lets us add a new component to our device
    list'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddDeviceComponent`：这个组件让我们向设备列表中添加新的组件'
- en: '`DeviceTemplateComponent`: A common template that is used to represent a device
    in our application'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeviceTemplateComponent`：用于表示应用程序中设备的通用模板'
- en: 'Apart from the previous, we have also added the required modules to the imports:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述内容，我们还添加了所需的模块到导入中：
- en: '`RouterModule`: To manage the routing'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由模块：用于管理路由
- en: '`LocalStorageModule`: To manage the user data within the browser, we are going
    to use `LocalStorgae`'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalStorageModule`：为了在浏览器中管理用户数据，我们将使用`LocalStorgae`'
- en: '`SimpleNotificationsModule` : To show the notifications using Angular 2 notifications
    ([https://github.com/flauc/angular2-notifications](https://github.com/flauc/angular2-notifications))'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleNotificationsModule`：使用Angular 2通知显示通知（[https://github.com/flauc/angular2-notifications](https://github.com/flauc/angular2-notifications)）'
- en: 'And for the services, we have the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务，我们有以下内容：
- en: '`AuthService`: To manage the authentication APIs exposed by the API engine'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthService`：管理API引擎提供的身份验证API'
- en: '`DevicesService`: To manage the device API exposed by the API engine'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DevicesService`：管理API引擎提供的设备API'
- en: '`DataService`: To manage the Data API exposed by the API engine'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataService`：管理API引擎提供的数据API'
- en: '`SocketService`: To manage web sockets that send data from the API engine in
    real time'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SocketService`：管理从API引擎实时发送数据的Web套接字'
- en: '`AuthGuard`: An Angular Guard that protects routes which need authentication.
    Read *Protecting Routes using Guards in Angular* ([https://blog.thoughtram.io/angular/2016/07/18/guards-in-angular-2.html](https://blog.thoughtram.io/angular/2016/07/18/guards-in-angular-2.html))
    for more information on Guards'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthGuard`：一个Angular守卫，用于保护需要身份验证的路由。阅读*使用Angular中的守卫保护路由*（[https://blog.thoughtram.io/angular/2016/07/18/guards-in-angular-2.html](https://blog.thoughtram.io/angular/2016/07/18/guards-in-angular-2.html)）获取有关守卫的更多信息'
- en: '`LoaderService`: That shows and hides a loader bar when an activity is going
    on'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoaderService`：在进行活动时显示和隐藏加载器栏'
- en: '`Http`: The HTTP service that we use to make HTTP requests. Here, we have not
    used the HTTP service as is, but extended the class and added our logic in between
    to manage the HTTP request experience better using the loader service'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Http`：我们用来发出HTTP请求的HTTP服务。在这里，我们没有直接使用HTTP服务，而是扩展了该类，并在其中添加了我们的逻辑，以更好地使用加载器服务来管理HTTP请求体验'
- en: Do note that at this point, the API engine does not have APIs for devices and
    data, and sockets are not set up for the data. We will be implementing in the
    API engine, once we are done with the web app completely.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此时API引擎没有设备和数据的API，并且数据的套接字未设置。一旦我们完成Web应用程序，我们将在API引擎中实现它。
- en: 'In this web application, we are going to have the following routes:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Web应用程序中，我们将有以下路由：
- en: '`login`: To let the user log in to the application'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login`：让用户登录应用程序'
- en: '`register`: To register with our application'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`register`：注册我们的应用程序'
- en: '`home`: A page that displays all the devices in a user account'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`home`：显示用户帐户中所有设备的页面'
- en: '`add-device`: A page to add a new device to the user''s device list'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add-device`：向用户的设备列表添加新设备的页面'
- en: '`view-device/:id`: A page to view one device, identified by the id parameter
    in the URL'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view-device/:id`：查看由URL中的id参数标识的一个设备的页面'
- en: '`**`: The default route is set to login'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**`：默认路由设置为登录'
- en: '`''''`: If no route matches, we redirect the user to the login page'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''''`：如果没有匹配的路由，我们将用户重定向到登录页面'
- en: Web app services
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序服务
- en: Now that we understand at a high level all that is present in this web app,
    we will walk through the services and components.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在高层次上了解了这个Web应用程序中的所有内容，我们将逐步介绍服务和组件。
- en: Open `web-app/src/app/services/http-interceptor.service.ts;` in this class,
    we have extended the `Http` class and implemented the class methods. We have added
    two methods of our own named `requestInterceptor()` and `responseInterceptor()`,
    which intercept the request and response respectively.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`web-app/src/app/services/http-interceptor.service.ts`；在这个类中，我们扩展了`Http`类并实现了类方法。我们添加了两个自己的方法，名为`requestInterceptor()`和`responseInterceptor()`，分别拦截请求和响应。
- en: When the request is about to be sent, we call the `requestInterceptor()` to
    show a loader, indicating the HTTP activity, and we use the `responseInterceptor()`
    to hide the loader once the response arrives. This way, the user is clearly aware
    if there is any background activity going on.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求即将发送时，我们调用`requestInterceptor()`来显示加载器，指示HTTP活动，我们使用`responseInterceptor()`一旦响应到达就隐藏加载器。这样，用户清楚地知道是否有任何后台活动正在进行。
- en: Next is the `LoaderService` class; open `web-app/src/app/services/loader.service.ts`
    and, as we can see from here, we have added a class property named status of the
    type `BehaviorSubject<boolean>` (to know more about `Behaviour` subject, refer
    to [https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md)).
    And we have a method, which will be called by the HTTP service or any other component
    if they would like to show or hide the loader bar and then set the value as true
    or false.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`LoaderService`类；打开`web-app/src/app/services/loader.service.ts`，从这里我们可以看到，我们添加了一个名为`status`的类属性，类型为`BehaviorSubject<boolean>`（要了解更多关于`Behavior`主题的信息，请参阅[https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md)）。我们还有一个方法，如果HTTP服务或任何其他组件希望显示或隐藏加载器栏，它们将调用该方法，然后将值设置为true或false。
- en: The required HTML for the loader service is present in `web-app/src/app/app.component.html`
    and the required styles are present in `web-app/src/app/app.component.css`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器服务所需的HTML位于`web-app/src/app/app.component.html`，所需的样式位于`web-app/src/app/app.component.css`。
- en: We are going to use web sockets for streaming data in real time between the
    web app and the API engine. Open `web-app/src/app/services/socket.service.ts`
    and we should see the constructor and the `getData()` method. We are using `socket.io-client`
    ([https://github.com/socketio/socket.io-client](https://github.com/socketio/socket.io-client))
    to manage web sockets in our web app.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Web套接字在Web应用程序和API引擎之间实时流式传输数据。打开`web-app/src/app/services/socket.service.ts`，我们应该看到构造函数和`getData()`方法。我们在我们的Web应用程序中使用`socket.io-client`（[https://github.com/socketio/socket.io-client](https://github.com/socketio/socket.io-client)）来管理Web套接字。
- en: In the constructor, we have created a new socket connection to our API engine
    and passed the auth token as a query parameter. We are going to validate the incoming
    connections via web sockets as well. And only if the token is valid will we allow
    the connection, else we close the web socket.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们已经创建了一个新的套接字连接到我们的API引擎，并将身份验证令牌作为查询参数传递。我们也将通过Web套接字验证传入的连接。只有在令牌有效的情况下，我们才允许连接，否则我们关闭Web套接字。
- en: Inside `getData()`, we subscribe to the `data:save` topic for a device. This
    is how we get notified from the API engine when there is new data available from
    a device.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getData()`内，我们订阅了设备的`data:save`主题。这是我们从API引擎得到通知的方式，当设备有新数据可用时。
- en: 'Now we will look at the three API services with which we authenticate the user,
    get the user''s devices and get data for a device:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看三个API服务，用于验证用户，获取用户设备和获取设备数据：
- en: '`AuthService`: Open `web-app/src/app/services/auth.service.ts`. Here, we have
    defined the `register()`, `login()`, and `logout()`, which takes care of managing
    the authentication state and we have `isAuthenticated()`, which returns the current
    state of authentication, as in whether the user is logged in or logged out.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthService`：打开`web-app/src/app/services/auth.service.ts`。在这里，我们已经定义了`register()`，`login()`和`logout()`，它们负责管理身份验证状态，我们还有`isAuthenticated()`，它返回当前的身份验证状态，即用户是已登录还是已注销。'
- en: '`DevicesService`: Open `web-app/src/app/services/devices.service.ts`. Here,
    we have implemented three methods: one to create, one to read, and one to delete.
    With this, we manage our devices for a user.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DevicesService`：打开`web-app/src/app/services/devices.service.ts`。在这里，我们实现了三种方法：创建一个，读取一个，删除一个。通过这样，我们为用户管理我们的设备。'
- en: '`DataService`: Open `web-app/src/app/services/data.service.ts`, which manages
    the data for a device. We have only two methods here: one to create a new data
    record and one to fetch the last 30 records of a device.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataService`：打开`web-app/src/app/services/data.service.ts`，它管理设备的数据。我们这里只有两种方法：创建一个新的数据记录和获取设备的最后30条记录。'
- en: Do notice that we are using `web-app/src/app/app.global.ts` to save all our
    constant global variables.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在使用`web-app/src/app/app.global.ts`来保存所有我们的常量全局变量。
- en: Now that we are done with the required services, we will walk through the components.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了所需的服务，我们将浏览组件。
- en: Web app components
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序组件
- en: 'We will start with the app component. The app component is the root component,
    which holds the router outlet, loader service HTML, and notification service HTML.
    You can find the same here: `web-app/src/app/app.component.html`. In `web-app/src/app/app.component.ts`,
    we have defined `showLoader` that decides whether the loader should be shown or
    not. We have also defined notification options, which stores the notification
    service configurations.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从应用程序组件开始。应用程序组件是根组件，它包含路由器出口，加载器服务HTML和通知服务HTML。您可以在这里找到相同的内容：`web-app/src/app/app.component.html`。在`web-app/src/app/app.component.ts`中，我们已经定义了`showLoader`，它决定是否应该显示加载器。我们还定义了通知选项，它存储通知服务的配置。
- en: Inside the constructor, we are listening for route change events on the router,
    so we can show a loading bar on page change. We are also listening to the loader
    service status variable. If this changes, we show or hide the loader.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数内，我们正在监听路由器上的路由更改事件，以便在页面更改时显示加载栏。我们还在监听加载器服务状态变量。如果这个变化，我们就会显示或隐藏加载器。
- en: The first page that the user lands on is the login page. The login page/component,
    `web-app/src/app/login/login.component.ts`, has only one method, the takes the
    user's email and password from `web-app/src/app/login/login.component.html` and
    authenticates the user.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 用户登陆的第一个页面是登录页面。登录页面/组件`web-app/src/app/login/login.component.ts`只有一个方法，从`web-app/src/app/login/login.component.html`获取用户的电子邮件和密码，并对用户进行身份验证。
- en: Using the register button on the home page, the user registers themself. Inside
    the `RegisterComponent` class, `web-app/src/app/register/register.component.ts`,
    we have defined `register()`, which takes the user's information and, using the
    `AuthService`, registers a user.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主页上的注册按钮，用户注册自己。在`RegisterComponent`类内，`web-app/src/app/register/register.component.ts`，我们已经定义了`register()`，它获取用户的信息，并使用`AuthService`注册用户。
- en: Once the user has been successfully authenticated, we redirect the user to the
    `LoginComponent`. In the `HomeComponent`, `web-app/src/app/home/home.component.ts`,
    we fetch all the devices associated with the user and display them on load. This
    page also has a button for adding a new device using the `AddDeviceComponent`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户成功验证，我们将用户重定向到`LoginComponent`。在`HomeComponent`，`web-app/src/app/home/home.component.ts`中，我们获取与用户关联的所有设备并在加载时显示它们。此页面还有一个按钮，用于使用`AddDeviceComponent`添加新设备。
- en: To view one device, we use the `DeviceComponent` to view one device.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看一个设备，我们使用`DeviceComponent`来查看一个设备。
- en: As of now, we do not have any APIs available to work with devices and data.
    We will revisit this page once we finish the API engine update in the next section.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们还没有任何可用于处理设备和数据的API。在下一节中完成API引擎更新后，我们将重新访问此页面。
- en: Launching the app
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动应用程序
- en: 'To run the app, open a terminal/prompt inside the `web-app` folder and run
    the following:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行应用程序，请在`web-app`文件夹内打开终端/提示符，并运行以下命令：
- en: '[PRE39]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Make sure the API engine and Mosca are running before you run the previous command.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上一个命令之前，请确保API引擎和Mosca正在运行。
- en: 'Once the webpack compilation is successful, navigate to `http://localhost:4200/login`
    and we should see the login page, this is the first page:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦webpack编译成功，导航到`http://localhost:4200/login`，我们应该看到登录页面，这是第一个页面。
- en: '![](../images/00029.jpeg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00029.jpeg)'
- en: 'We can use the account we have created while testing the API engine, using
    Postman, or we can create a new account by clicking on Register with Web App as
    follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用在测试API引擎时创建的帐户，使用Postman，或者我们可以通过点击“使用Web应用程序注册”来创建一个新帐户，如下所示：
- en: '![](../images/00030.jpeg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00030.jpeg)'
- en: 'If the registration is successful, we should be redirected to the home page
    as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注册成功，我们应该被重定向到主页，如下所示：
- en: '![](../images/00031.jpeg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00031.jpeg)'
- en: If we open the developer tools, we should see the previous message. The API
    engine does not have APIs for devices implemented, hence the previous `404s`.
    We will fix that in [Chapter 3](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee),
    *IoTFW.js - II*.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开开发者工具，应该会看到先前的消息。API引擎没有实现设备的API，因此出现了先前的“404”。我们将在[第3章](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee)中修复这个问题，*IoTFW.js
    - II*。
- en: We will also walk through the remaining part of the web app in [Chapter 3](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee),
    *IoTFW.js - II*, once we are done with the API engine update.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在[第3章](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee)中逐步完成Web应用程序的剩余部分，一旦API引擎更新完成。
- en: Summary
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have gone through the process of setting up a frame to work
    with internet of Things solutions. We have built most of the framework using only
    JavaScript as our programming language.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了建立物联网解决方案的过程。我们使用JavaScript作为编程语言构建了大部分框架。
- en: We started by understanding the architecture and data flow from a Raspberry
    Pi to an end user device such as a web app, desktop app, or mobile app. Then we
    started working on the broker using Mosca, after setting up the MongoDB. Next,
    we designed and developed the API engine and completed the basic Raspberry Pi
    setup.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先了解了从树莓派到Web应用程序、桌面应用程序或移动应用程序等最终用户设备的架构和数据流。然后我们开始使用Mosca工作代理，设置了MongoDB。接下来，我们设计并开发了API引擎，并完成了基本的树莓派设置。
- en: We have worked on the web app and set up the necessary templates to work with
    the remaining part of the application. In [Chapter 3](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee),
    *IoTFW.js - II*, we will complete the entire framework and also integrate a DHT11
    (temperature and humidity) sensor and an LED to validate the two-way data flow
    end to end.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Web应用程序上工作，并设置了必要的模板，以便与应用程序的剩余部分配合使用。在[第3章](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee)中，我们将完成整个框架，并集成DHT11（温湿度）传感器和LED，以验证端到端的双向数据流。
