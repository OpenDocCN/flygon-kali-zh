- en: 3\. Managing Your Docker Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 管理您的Docker镜像
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will look into Docker layers and analyze how caching can
    help to speed up an image build. We will also deep dive into Docker images and
    set up Docker registries to increase the reusability of the images.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究Docker层，并分析缓存如何帮助加快镜像构建。我们还将深入研究Docker镜像，并设置Docker注册表，以增加镜像的可重用性。
- en: By the end of this chapter, you will be able to demonstrate how Docker uses
    layers to build images and how image building can be sped up with caching. You
    will work with image tags and set up a tagging policy for Docker images. The chapter
    will enable you to utilize Docker Hub for your projects and differentiate between
    public and private registries. It will also help you to set up your own Docker
    Registry when working on your projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您将能够演示Docker如何使用层构建镜像以及如何通过缓存加快镜像构建。您将使用镜像标签，并为Docker镜像设置标记策略。本章将使您能够为您的项目利用Docker
    Hub，并区分公共和私有注册表。在处理项目时，它还将帮助您设置自己的Docker注册表。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Our previous chapters have done a lot of work already with Docker images. As
    you've seen, we've been able to take existing images, provided to the general
    public in Docker Hub, and have then been able to run them or reuse them after
    building on top of them for our purposes. The image itself helps us streamline
    our processes and reduce the work we need to do.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的章节已经在Docker镜像上做了很多工作。正如您所看到的，我们已经能够获取Docker Hub中提供给公众的现有镜像，并在其基础上构建后运行或重用它们以满足我们的目的。镜像本身帮助我们简化流程，并减少我们需要做的工作。
- en: In this chapter, we are going to take a more in-depth look at images and how
    to work with them on your system. We'll learn how images can be better organized
    and tagged, understand how different layers of images work, and set up registries
    that are both public and private to further reuse the images we have created.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地了解镜像以及如何在系统上使用它们。我们将学习如何更好地组织和标记镜像，了解不同层的镜像如何工作，并设置公共和私有的注册表，以进一步重用我们创建的镜像。
- en: Docker images are perfect for application development as well. The image itself
    is a self-contained version of the application, which includes everything it needs
    in order to be run. This empowers developers to build an image on their local
    machine and deploy it on a development or test environment to ensure it works
    well with the rest of the application. If all goes well, they can then push the
    same image as a release to the production environment for users to then consume.
    We need to also be consistent when using our images, especially when we start
    to work within a larger group of developers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像也非常适合应用程序开发。镜像本身是应用程序的自包含版本，其中包括运行所需的一切。这使开发人员能够在本地机器上构建镜像，并将其部署到开发或测试环境，以确保它与应用程序的其余部分良好配合。如果一切顺利，他们可以将相同的镜像作为发布推送到生产环境，供用户消费。当我们开始在更大的开发人员群体中工作时，我们需要在使用我们的镜像时保持一致。
- en: This chapter will also help you set up policies to have consistent tagging for
    your services to help limit issues and make sure you can track down or roll back
    when issues arise. Understanding how to distribute images for consumption and
    collaboration is also something we will discuss further in the chapter. So, without
    further delay, let's get started with the chapter and understand what layers and
    caching in Docker are.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将帮助您制定一致的服务标记策略，以帮助限制问题，并确保在问题出现时能够追踪或回滚。了解如何分发镜像以供消费和协作也是我们将在本章进一步讨论的内容。因此，让我们立即开始本章的学习，了解Docker中的层和缓存是什么。
- en: Docker Layers and Caching
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker层和缓存
- en: A registry is a way to store and distribute your Docker images. When you pull
    a Docker image from a registry, you might have noticed that the image is pulled
    in pieces and not as a single image. The same thing happens when you build an
    image on your system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表是存储和分发Docker镜像的一种方式。当您从注册表拉取Docker镜像时，您可能已经注意到镜像是分成多个部分而不是作为单个镜像拉取的。当您在系统上构建镜像时，同样的事情也会发生。
- en: This is because Docker images consist of layers. When you create a new image
    using a `Dockerfile`, it will create more layers on top of the existing image
    you've built from. Each command you specify in the `Dockerfile` will create a
    new layer, with each containing all of the filesystem changes that occur before
    the command was performed and then after. When you run the image as a container
    from a `Dockerfile`, you're creating readable and writable layers on top of an
    existing group of read-only layers. This writable layer is known as the **container
    layer**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Docker镜像由多层组成。当您使用`Dockerfile`创建新镜像时，它会在您已构建的现有镜像之上创建更多的层。您在`Dockerfile`中指定的每个命令都将创建一个新的层，每个层都包含在执行命令之前和之后发生的所有文件系统更改。当您从`Dockerfile`运行镜像作为容器时，您正在在只读层的顶部创建可读写的层。这个可写层被称为**容器层**。
- en: As you'll see in the following exercises, when you build a container from a
    `Dockerfile`, the output presented shows each command run in the `Dockerfile`.
    It also shows the layers that are created by running each command, which is represented
    by a randomly generated ID. Once the image has completed building, you can then
    view the layers created during the build process using the `docker history` command,
    including the image name or ID.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在接下来的练习中看到的那样，当您从`Dockerfile`构建容器时，所呈现的输出显示了在`Dockerfile`中运行的每个命令。它还显示了通过运行每个命令创建的层，这些层由随机生成的ID表示。一旦镜像构建完成，您就可以使用`docker
    history`命令查看在构建过程中创建的层，包括镜像名称或ID。
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When setting up your build environment and as you move further along in the
    development process, remember that the more layers you have, the larger your image
    will be. So, this extra storage and space can be expensive in both build times
    and the amount of disk space used in your development and production environments.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置构建环境并在开发过程中进一步进行时，请记住，层数越多，镜像就会越大。因此，这额外的存储空间在构建时间和开发和生产环境中使用的磁盘空间方面可能会很昂贵。
- en: When building an image from a `Dockerfile`, layers are created when the `RUN`,
    `ADD`, and `COPY` commands are used. All other commands in the `Dockerfile` create
    intermediate layers. These intermediate layers are 0 B in size; therefore, they
    don't increase the size of the Docker image.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Dockerfile`构建镜像时，当使用`RUN`、`ADD`和`COPY`命令时会创建层。`Dockerfile`中的所有其他命令都会创建中间层。这些中间层的大小为0
    B；因此，它们不会增加Docker镜像的大小。
- en: 'When building our Docker images, we can use the `docker history` command and
    the image name or ID to see the layers used to create the image. The output will
    provide details on commands used to generate the layer as well as the size of
    the layer:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的Docker镜像时，我们可以使用`docker history`命令和镜像名称或ID来查看用于创建镜像的层。输出将提供有关用于生成层的命令以及层的大小的详细信息：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `docker image inspect` command is useful in providing further details on
    where the layers of our images are located:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image inspect`命令在提供有关我们镜像的层位于何处的进一步详细信息方面非常有用：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Later in this part of the chapter, when we look at creating our base images,
    we will use the `docker image` command, which is used in conjunction with a TAR
    file version of the image we are creating. If we are able to access a running
    container or virtual machine, we will be able to take a copy of the running system
    and place it in a TAR archive. The output of the archive is then piped out to
    the `docker import` command as demonstrated here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，当我们看创建基本图像时，我们将使用`docker image`命令，该命令与我们正在创建的图像的TAR文件版本一起使用。如果我们能够访问正在运行的容器或虚拟机，我们将能够将运行系统的副本放入TAR存档中。然后将存档的输出传输到`docker
    import`命令中，如此处所示：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The next exercise will give you some hands-on experience of what we have learned
    so far and how to work with Docker image layers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个练习将让您亲身体验到我们迄今为止学到的知识以及如何使用Docker镜像层进行工作。
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please use `touch` command to create files and `vim` command to work on the
    file using vim editor.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用`touch`命令创建文件，使用`vim`命令使用vim编辑器处理文件。
- en: 'Exercise 3.01: Working with Docker Image Layers'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.01：使用Docker镜像层
- en: 'In this exercise, you will work with some basic `Dockerfiles` to see how Docker
    uses layers to build images. You will start by creating a `Dockerfile` and building
    a new image. You will then rebuild the image to see the advantage of using caching
    and how the build time is reduced due to its use:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用一些基本的`Dockerfiles`来看看Docker如何使用层来构建图像。您将首先创建一个`Dockerfile`并构建一个新的图像。然后重新构建图像以查看使用缓存的优势以及由于使用缓存而减少的构建时间：
- en: 'Create a new file called `Dockerfile` with your favorite text editor and add
    in the following details:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器创建一个名为`Dockerfile`的新文件，并添加以下细节：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Save the `Dockerfile` and then, from the command line, make sure you are in
    the same directory as the `Dockerfile` you have created. Use the `docker build`
    command to create the new image using the `–t` option to name it `basic-app`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`Dockerfile`，然后从命令行确保您在与您创建的`Dockerfile`相同的目录中。使用`docker build`命令使用`-t`选项为其命名为`basic-app`来创建新的镜像：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the image has built successfully, you should see an output similar to the
    following. We''ve highlighted each of the build steps in bold. Each step is built
    as an intermediate layer and if it completes successfully, it is then transferred
    to a read-only layer:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像构建成功，您应该会看到类似以下的输出。我们已经用粗体突出显示了每个构建步骤。每个步骤都作为中间层构建，如果成功完成，然后将其转移到只读层：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use the `docker history` command along with the image name of `basic-app` to
    see the different layers of the image:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker history`命令以及`basic-app`的图像名称来查看图像的不同层：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The history gives you creation details, including the size of each layer:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 历史记录提供了创建细节，包括每个层的大小：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `docker history` command shows the layer of the original image used as part
    of the `Dockerfile` `FROM` command as `<missing>`. It is showing as `missing`
    in our output as it was created on a different system and then pulled onto your
    system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker history`命令显示了作为`Dockerfile` `FROM`命令的一部分使用的原始图像的层为`<missing>`。在我们的输出中显示为`missing`，因为它是在不同的系统上创建的，然后被拉到您的系统上。'
- en: 'Run the build again without making any changes:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不做任何更改再次运行构建：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will show you the build is done using the layers stored in the Docker
    image cache, thereby speeding up our build. Although this is only a small image,
    a much larger image would show a significant increase:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示构建是使用Docker镜像缓存中存储的层完成的，从而加快了我们的构建速度。尽管这只是一个小图像，但更大的图像将显示显着的增加：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Say you forgot to install the `curl` package as part of your image creation.
    Add the following line to the `Dockerfile` from *Step 1*:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您忘记在图像创建的过程中安装`curl`包。在*步骤1*中的`Dockerfile`中添加以下行：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Build the image again, and you''ll now see the image created with a mix of
    cached layers and new layers that need to be created:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建图像，现在您将看到图像由缓存层和需要创建的新层混合而成：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Step three of the output has been highlighted to show the change made in our
    `Dockerfile` now being built:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示了输出的第三步，显示了我们在`Dockerfile`中所做的更改：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the `docker images` command again:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`docker images`命令：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will now notice the image named and tagged as `<none>` to show we have
    now created a dangling image:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在会注意到图像被命名和标记为`<none>`，以显示我们现在创建了一个悬空图像：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Dangling images, represented by `<none>` in our image list, are caused when
    a layer has no relationship to any image on our system. These dangling images
    no longer serve a purpose and will consume disk space on your system. Our example
    dangling image is only 7.48 MB, which is small, but this could add up over time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 悬空图像，在我们的图像列表中表示为`<none>`，是由于一个层与我们系统上的任何图像都没有关联而引起的。这些悬空图像不再起作用，并将占用您系统上的磁盘空间。我们的示例悬空图像只有7.48
    MB，这很小，但随着时间的推移，这可能会累积起来。
- en: 'Run the `docker image inspect` command using the image ID to see the location
    of where the dangling images are located on our system:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用图像ID运行`docker image inspect`命令，查看悬空图像在我们系统上的位置：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following output has been reduced from the actual output to only show the
    directories of the image:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出已从实际输出减少，仅显示图像的目录：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All of our images are located in the same location as the dangling image. As
    they are sharing the same directory, any dangling images would waste space on
    our system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的图像都位于与悬空图像相同的位置。由于它们共享相同的目录，任何悬空图像都会浪费我们系统上的空间。
- en: 'Run the `du` command from the command line to see the total disk space being
    used by our images:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行运行`du`命令，查看我们的图像使用的总磁盘空间：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The command will return the total disk space used by your images
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回您的图像使用的总磁盘空间
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you're using Docker Desktop, maybe on a Mac, you'll notice that you won't
    be able to see the images as Docker is run on a virtual image on your system,
    even though the `docker image inspect` command will show the same location as
    we have above.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Docker Desktop，可能是在Mac上，您会注意到您无法看到图像，因为Docker在您的系统上以虚拟图像运行，即使`docker
    image inspect`命令显示的位置与上面相同。
- en: 'Run the `docker images` command again using the `-a` option:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`docker images`命令，并使用`-a`选项：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It will also show the intermediate layers used when our image is being built:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会显示在构建我们的图像时使用的中间层：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the `docker image prune` command to remove all the dangling images. You
    could remove all the dangling images one at a time using the `docker rmi` command
    using the image ID, but the `docker image prune` command is an easier way to do
    that:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker image prune`命令以删除所有悬空图像。您可以使用`docker rmi`命令逐个删除所有悬空图像，使用图像ID，但`docker
    image prune`命令是更简单的方法：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should get output like the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下输出：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the `docker images` command again:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`docker images`命令：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You will see we no longer have the dangling image in our list of images:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到我们的图像列表中不再有悬空图像：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the `du` command again over the image''s directory:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在图像目录上运行`du`命令：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should also observe a small decrease in size:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该观察到尺寸的小幅减小：
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This exercise has shown only smaller image sizes, but this is definitely something
    to keep in mind when running production and development environments. This part
    of the chapter has provided you with the foundations of how Docker uses layers
    and caching as part of its build process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习只显示了较小的图像尺寸，但在运行生产和开发环境时，这绝对是需要牢记的事情。本章的这一部分为您提供了Docker如何在其构建过程中使用层和缓存的基础。
- en: For our next exercise, we will look further at our layers and caching to see
    how they can be used to speed up the image build process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个练习，我们将进一步研究我们的层和缓存，以查看它们如何用于加快图像构建过程。
- en: 'Exercise 3.02: Increasing Build Speed and Reducing Layers'
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.02：增加构建速度和减少层
- en: 'You have been working with smaller builds so far. However, as your applications
    increase in size and functionality, you''ll start to consider both the size and
    number of layers of the Docker images you''re creating and the speed at which
    you''re creating them. The goal of this exercise is to speed up the build times
    and reduce the size of your images, as well as use the `--cache-from` option when
    building your Docker images:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您一直在处理较小的构建。但是，随着您的应用程序在大小和功能上的增加，您将开始考虑您正在创建的Docker图像的大小和层数以及创建它们的速度。本练习的目标是加快构建时间并减小图像的大小，并在构建Docker图像时使用`--cache-from`选项：
- en: 'Create a new `Dockerfile` to demonstrate the change you are going to make,
    but first, clear up all the images on your system. Run the `docker rmi` command
    with the `-f` option to force any removals needed, and the command in brackets
    will provide a list of all image IDs on your system. Use the `-a` option to show
    all running and stopped containers and the `-q` option to only show the container
    image hash value and nothing else:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Dockerfile`来演示您将要进行的更改，但首先，请清理系统上的所有图像。使用`docker rmi`命令并带有`-f`选项来强制进行任何需要的删除，括号中的命令将提供系统上所有图像ID的列表。使用`-a`选项来显示所有正在运行和停止的容器，使用`-q`选项仅显示容器图像哈希值，而不显示其他内容。
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The command should return output like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应返回以下输出：
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It can be observed that the `hello-world: latest` image is untagged and the
    image with ID `sha256:d74fa92b37b74820ccccea601 de61d45ccb3770255b9c7dd22edf16caabafc1c`
    is removed.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到`hello-world:latest`镜像已被取消标记，并且具有ID`sha256:d74fa92b37b74820ccccea601 de61d45ccb3770255b9c7dd22edf16caabafc1c`的镜像已被删除。
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that we can remove the images using both the `rmi` and `prune` commands.
    Here, we have used the `rmi` command because `prune` was not always available
    until recently.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以使用`rmi`和`prune`命令来删除图像。在这里，我们使用了`rmi`命令，因为`prune`直到最近才可用。
- en: 'Add the following code to your `Dockerfile` (which you created in *Exercise
    3.01*). It will simulate a simple web server, as well as print the output of our
    `Dockerfile` during the build process:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的`Dockerfile`（您在*练习3.01*中创建的）。它将模拟一个简单的Web服务器，并在构建过程中打印我们的`Dockerfile`的输出：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You'll notice *line 6* of the `Dockerfile` is doing a fairly menial task (downloading
    a 100 MB file, named `100MB.bin`), which would not normally be performed in a
    `Dockerfile`. We have added it in to represent a build task or something similar
    that may be added during your build process, for example, downloading content
    or building software from a file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到`Dockerfile`的*第6行*正在执行一个相当琐碎的任务（下载一个名为`100MB.bin`的100MB文件），这在`Dockerfile`中通常不会执行。我们已经添加了它来代表一个构建任务或类似的东西，例如，下载内容或从文件构建软件。
- en: 'Download your base image using the `docker pull` command so that you can start
    with the same image for each test we do:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker pull`命令下载基本图像，以便您可以从每次测试开始使用相同的图像：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a TAR file to be added to our image as we have instructed in *line 13*
    of our `Dockerfile`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个TAR文件，以便按照我们在`Dockerfile`的*第13行*中指示的方式添加到我们的图像中：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Build a new image using the same name as `basic-app.` You will use the `time`
    command at the start of the code to allow us to gauge the time it takes to build
    our image:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与`basic-app`相同的名称构建一个新图像。您将在代码开头使用`time`命令，以便我们可以衡量构建图像所花费的时间：
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output will return the time taken to build the image:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将返回构建图像所花费的时间：
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the `docker history` command over the new `basic-app` image:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对新的`basic-app`镜像运行`docker history`命令：
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have a few extra commands in our `Dockerfile` compared to the previous exercise.
    So, there should be no surprise that we will see 12 layers in our new image:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个练习相比，我们的`Dockerfile`中有一些额外的命令。因此，我们将在新镜像中看到12层，这并不奇怪：
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can see that the `RUN`, `COPY`, and `ADD` commands in our `Dockerfile` are
    creating layers of a particular size relevant to the commands being run or files
    being added, and all the other commands in the `Dockerfile` are of size 0 B.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Dockerfile`中的`RUN`、`COPY`和`ADD`命令正在创建特定大小的层，与运行的命令或添加的文件相关，并且`Dockerfile`中的所有其他命令的大小都为0
    B。
- en: 'Reduce the number of layers in the image by combining the `RUN` commands in
    *lines 3 and 4* and combining the `CMD` commands in *lines 8 and 9* of the `Dockerfile`
    created in *step 1* of this exercise. With these changes, our `Dockerfile` should
    now look like the following:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过合并`Dockerfile`中*第3行和第4行*的`RUN`命令以及合并*第8行和第9行*的`CMD`命令，减少镜像中的层数。通过这些更改，我们的`Dockerfile`现在应该如下所示：
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Running `docker build` again will reduce the number of layers for our new image
    from 12 to 9 layers, as even though there is the same number of commands being
    run, they are chained together in *lines 3* and *7*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`docker build`将会减少新镜像的层数，从12层减少到9层，因为即使运行的命令数量相同，它们在*第3行*和*第7行*中被链接在一起。
- en: '*Lines 11*, *12*, and *13* of our `Dockerfile` are using the `COPY` and `RUN`
    commands to `copy` and `unzip` our archived file, and then remove the original
    unzipped file. Replace these lines with the `ADD` command without needing to run
    the lines that unzip and remove the `.tar` file:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*第11行*、*第12行*和*第13行*的`Dockerfile`正在使用`COPY`和`RUN`命令来`copy`和`unzip`我们的归档文件，然后删除原始的解压文件。用`ADD`命令替换这些行，而无需运行解压和删除`.tar`文件的行：'
- en: '[PRE37]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Build the image again to reduce the number of layers in your new image from
    9 to 8\. If you have been watching the builds run, you will probably notice a
    lot of the time the build run as part of *lines 3* and *5* of our `Dockerfile`,
    where we run `apk update`, then install `wget` and `curl`, and then grab content
    from a website. Doing this once or twice will not be an issue, but if we create
    our base image, which the `Dockerfile` can then run on, you will be able to remove
    these lines completely from your `Dockerfile`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建镜像，将新镜像的层数从9层减少到8层。如果您一直在观察构建过程，您可能会注意到大部分时间是在`Dockerfile`的*第3行*和*第5行*中运行，我们在那里运行`apk
    update`，然后安装`wget`和`curl`，然后从网站获取内容。这样做一两次不会有问题，但如果我们创建了基础镜像，`Dockerfile`可以在其上运行，您将能够完全从`Dockerfile`中删除这些行。
- en: 'Move into a new directory and create a new `Dockerfile` that will only pull
    the base image and run the `apk` commands, as listed here:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入一个新目录，并创建一个新的`Dockerfile`，它将只拉取基础镜像并运行`apk`命令，如下所示：
- en: '[PRE38]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Build the new base image from the preceding `Dockerfile` and name it `basic-base`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个`Dockerfile`中构建新的基础镜像，并将其命名为`basic-base`：
- en: '[PRE39]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Remove *line 3* from the original `Dockerfile` as it will no longer be needed.
    Move into the project directory and update the image that is being used in the
    `FROM` command to `basic-base` and remove the `apk` commands in *line 3*. Our
    `Dockerfile` should now look like the following code:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从原始`Dockerfile`中删除*第3行*，因为它将不再需要。进入项目目录，并将`FROM`命令中使用的镜像更新为`basic-base`，并删除*第3行*中的`apk`命令。我们的`Dockerfile`现在应该如下所示：
- en: '[PRE40]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the build again for our new `Dockerfile`. Using the `time` command again
    with our build, we now see the build complete in just over 1 second:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行新的`Dockerfile`进行构建。再次使用`time`命令进行构建，我们现在可以看到构建在1秒多钟内完成：
- en: '[PRE41]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you''ve been watching the build, you''ll notice that compared to our previous
    builds, it runs a lot quicker:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直在观看构建过程，您会注意到与我们以前的构建相比，它运行得更快：
- en: '[PRE42]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will observe that the layers of the image will remain the same as we are
    building the base image on our system, which performs the `apk` commands. It's
    a great result still to speed up the build even though we are not reducing the
    number of layers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您将观察到镜像的层将保持不变，因为我们正在在我们的系统上构建基础镜像，该系统执行`apk`命令。即使我们没有减少层数，这仍然是一个很好的结果，可以加快构建速度。
- en: 'There is a different way we can use the `basic-base` image we used earlier.
    Use the `docker build` command with the `–cache-from` option to specify the cache
    layers that will be used when the image is built. Set out the `FROM` command to
    still use the `alpine` image and use the `–cache-from` option that follows to
    make sure the layers used to build `basic-base` are being used for our current
    image:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用之前使用的`basic-base`镜像的不同方式。使用`docker build`命令和`--cache-from`选项指定构建镜像时将使用的缓存层。设置`FROM`命令仍然使用`alpine`镜像，并使用后面的`--cache-from`选项，以确保用于构建`basic-base`的层被用于我们当前的镜像：
- en: '[PRE43]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We still have some more tasks before we complete this exercise. In the following
    steps, we will look at committing changes to our image to see how it affects our
    layers. This is not something we would use often but there are times when we need
    to copy production data over to a development or test environment, and one way
    to do this is by using a Docker image with the `commit` command, which will make
    changes to the top writable layer of our running container.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成此练习之前，我们还有一些任务要完成。在接下来的步骤中，我们将查看提交对镜像的更改，以查看它如何影响我们的层。这不是我们经常使用的东西，但有时我们需要将生产数据复制到开发或测试环境中，其中一种方法是使用带有`commit`命令的Docker镜像，该命令将更改我们运行容器的顶部可写层。
- en: 'Run `basic-app` in interactive shell mode to create some production data. To
    do this, run the following `docker run` command with the `-it` option to run in
    interactive mode and use the `sh` shell to access the running container:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以交互式shell模式运行`basic-app`以创建一些生产数据。为此，请使用`-it`选项运行以下`docker run`命令以交互模式运行，并使用`sh`
    shell访问运行的容器：
- en: '[PRE44]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Use the vi text editor to create a new text file called `prod_test_data.txt`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用vi文本编辑器创建一个名为`prod_test_data.txt`的新文本文件：
- en: '[PRE45]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add the following line of text as some test data. The data in the text is not
    important; it is just a sample to show we can then copy these changes to another
    image:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下文本行作为一些测试数据。文本中的数据并不重要；这只是一个示例，表明我们可以将这些更改复制到另一个镜像中：
- en: 'This is a sample production piece of data. Exit out of the running container
    and then check the container ID using the `docker ps` command with the `-a` option:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个示例生产数据。退出运行的容器，然后使用带有`-a`选项的`docker ps`命令检查容器ID：
- en: '[PRE46]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You will get output like the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '[PRE47]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Run the `docker commit` command with the container ID to create a new image
    that will include all those changes. Make sure to add the name of the new image.
    In this example, use `basic-app-test`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker commit`命令，使用容器ID创建一个包含所有这些更改的新镜像。确保添加新镜像的名称。在本例中，使用`basic-app-test`：
- en: '[PRE48]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You will get output like the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得以下输出：
- en: '[PRE49]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the `docker history` command on the newly created image:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的镜像上运行`docker history`命令：
- en: '[PRE50]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This should now show us an extra layer where we added the sample production
    data, showing in our output as 72B in size:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这应该显示出我们添加了示例生产数据的额外层，显示在我们的输出中，大小为72B：
- en: '[PRE51]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, run the newly created `basic-app-test` image and `cat`, the new file we
    added:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行新创建的`basic-app-test`镜像和`cat`，我们添加的新文件：
- en: '[PRE52]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This should show us the output we added, showing we can reuse existing images
    if needed:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示我们添加的输出，表明我们可以在需要时重用现有镜像：
- en: '[PRE53]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As of the time of writing, the `docker build` command also allows a new experimental
    feature using the `–squash` option. The option attempts to merge all the layers
    into one layer during build time. We haven't covered this feature as it is still
    in an experimental phase.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`docker build`命令还允许使用`--squash`选项的新实验性功能。该选项尝试在构建时将所有层合并为一层。我们还没有涵盖这个功能，因为它仍处于实验阶段。
- en: This exercise demonstrated how the build cache and image layers work to improve
    the build time. We have started all our builds so far using an image we have pulled
    down from Docker Hub, but there are options to start with an image you have created
    yourself if you wish to control things even further. The next section will help
    you to create your base Docker images.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习演示了构建缓存和镜像层是如何改善构建时间的。到目前为止，我们所有的构建都是使用从Docker Hub下载的镜像开始的，但如果你希望进一步控制，也可以使用自己创建的镜像。下一节将帮助你创建自己的基础Docker镜像。
- en: Creating Base Docker Images
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基础Docker镜像
- en: Creating your base Docker image is actually straightforward. Just as we used
    the `docker commit` command previously to create an image from a running container,
    we can also create an image from a system or server we have originally been running
    our applications on. We need to remember that creating a base image still needs
    to remain small and lightweight. It is not simply a matter of moving existing
    applications running on existing servers over to Docker.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的基础Docker镜像实际上很简单。就像我们之前使用`docker commit`命令从运行的容器创建镜像一样，我们也可以从最初运行我们应用程序的系统或服务器创建镜像。我们需要记住，创建基础镜像仍然需要保持小巧和轻量级。这不仅仅是将现有应用程序从现有服务器迁移到Docker的问题。
- en: We could use the system we are specifically working on, but if you are using
    a production server, the image could actually be pretty big. If you have a small
    virtual machine you would think is perfect for a base image, you could use the
    following steps to create a base image from it. Similar to the `docker commit`
    command, this can be used for any system you can access.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们正在专门工作的系统，但如果你正在使用生产服务器，镜像实际上可能会很大。如果你有一个小型虚拟机，认为它非常适合作为基础镜像，可以使用以下步骤创建基础镜像。类似于`docker
    commit`命令，这可以用于任何你可以访问的系统。
- en: 'Exercise 3.03: Creating Your Base Docker Images'
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.03：创建自己的基础Docker镜像
- en: 'The following exercise will use the `basic-app` image we are currently running
    and show how easy it is to create a base image. These same steps would be used
    for larger, more complex environments as well:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习将使用我们当前正在运行的`basic-app`镜像，并展示创建基础镜像有多么简单。对于更大、更复杂的环境，也可以使用相同的步骤：
- en: 'Execute the `docker run` command to run the container and log in at the same
    time:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`docker run`命令以同时运行容器并登录：
- en: '[PRE54]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Run the `tar` command on the running container to create a backup of the system.
    To limit the information you have in the new image, exclude the `.proc`, `.tmp`,
    `.mnt`, `.dev`, and `.sys` directories, and create everything under the `basebackup.tar.gz`
    file:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`tar`命令在运行的容器上创建系统的备份。为了限制新镜像中的信息，排除`.proc`、`.tmp`、`.mnt`、`.dev`和`.sys`目录，并将所有内容创建在`basebackup.tar.gz`文件下：
- en: '[PRE55]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To ensure that you have data in your `basebackup.tar.gz` file, run the `du`
    command to make sure it is of substantial size:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为确保`basebackup.tar.gz`文件中有数据，请运行`du`命令，确保其大小足够大：
- en: '[PRE56]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output returns the size of the `basebackup.tar.gz` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 输出返回`basebackup.tar.gz`文件的大小：
- en: '[PRE57]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Run the `docker ps` command to find the container ID that is currently holding
    your new backup file, the `.tar` file:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker ps`命令找到当前保存新备份文件的容器ID，`.tar`文件：
- en: '[PRE58]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The command will return the container ID of the image:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回镜像的容器ID：
- en: '[PRE59]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Copy the `.tar` file onto your development system with the `docker cp` command,
    using the container ID of our running container and the location and file you
    want to copy. The following command will do this with your container ID and move
    it into your `/tmp` directory:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`.tar`文件复制到您的开发系统上，使用`docker cp`命令，使用正在运行的容器的容器ID以及要复制的位置和文件。以下命令将使用您的容器ID执行此操作，并将其移动到您的`/tmp`目录中：
- en: '[PRE60]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create a new image using the `docker import` command. Simply pipe the output
    of the `basebackup.tar.gz` file into the `docker import` command, naming the new
    image in the process. In our example, call it `mynew-base`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker import`命令创建一个新的镜像。只需将`basebackup.tar.gz`文件的输出导入`docker import`命令中，并在此过程中命名新镜像。在我们的示例中，将其命名为`mynew-base`：
- en: '[PRE61]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Use the `docker images` command with the name of your new image to verify that
    it has been created in the previous step:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的新镜像的名称运行`docker images`命令，以验证它是否已在上一步中创建：
- en: '[PRE62]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You should get output like the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下类似的输出：
- en: '[PRE63]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Run the `docker history` command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker history`命令：
- en: '[PRE64]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You will see that we only have one layer in our new image:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到我们的新镜像中只有一个层：
- en: '[PRE65]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To test your new image, run the `docker run` command on the new image, and
    list the files in your `/var/www/html/` directory:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试新镜像，请在新镜像上运行`docker run`命令，并列出您的`/var/www/html/`目录中的文件：
- en: '[PRE66]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The command should return the similar output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应返回类似的输出：
- en: '[PRE67]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: It can be seen that the image has been successfully created and there are 24
    files in the `/var/www/html/` directory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到镜像已成功创建，并且`/var/www/html/`目录中有24个文件。
- en: This exercise has shown you how to create a base image from a running system
    or environment, but if you're wanting to create a small base image, then the next
    section will show you how to use the **scratch** image.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习向您展示了如何从运行的系统或环境中创建一个基本镜像，但如果您想要创建一个小的基本镜像，那么下一节将向您展示如何使用**scratch**镜像。
- en: The Scratch Image
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空白镜像
- en: The scratch image is an image created by Docker specifically available for building
    minimal images. If you have a binary application, written in Java, C++, and so
    on, as well as compiled, that can be run by itself without any supporting applications,
    then scratch will help you run that image with one of the smallest images you
    can create.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 空白镜像是Docker专门为构建最小化镜像而创建的镜像。如果您有一个二进制应用程序，比如Java、C++等编写并编译的应用程序，可以独立运行而无需任何支持应用程序，那么空白镜像将帮助您使用您可以创建的最小镜像之一来运行该镜像。
- en: When we use the `FROM scratch` command in our `Dockerfile`, we are specifying
    that we will be using Docker's reserved minimal image, which is named `scratch`
    for building our new container image.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在我们的`Dockerfile`中使用`FROM scratch`命令时，我们指定将使用Docker保留的最小镜像，该镜像命名为`scratch`来构建我们的新容器镜像。
- en: 'Exercise 3.04: Using the Scratch Image'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.04：使用空白镜像
- en: 'In this exercise, you will create a small C application to run on the image.
    You don''t really need to know anything about the C language to complete this
    exercise. The application will be installed on your scratch base image to ensure
    the image is as small as possible. The application you create will show you how
    to create one of the most minimal base images available:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个小的C应用程序在镜像上运行。您实际上不需要了解C语言的任何内容来完成这个练习。您创建的应用程序将安装在您的空白基本镜像上，以确保该镜像尽可能小。您创建的应用程序将向您展示如何创建一个最小的基本镜像之一：
- en: 'Pull the scratch image using the `docker pull` command:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker pull`命令拉取空白镜像：
- en: '[PRE68]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You''ll notice you won''t be able to pull the image and will receive an error:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到无法拉取该镜像，并将收到错误：
- en: '[PRE69]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create a C program that you will build into the image to use in our `Dockerfile`.
    Create a program file called `test.c`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个C程序，将其构建到我们的`Dockerfile`中使用的镜像中。创建一个名为`test.c`的程序文件：
- en: '[PRE70]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Open the file and add in the following code, which will simply count from 1
    to 10 on the console:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件并添加以下代码，它将在控制台上简单地从1数到10：
- en: '[PRE71]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Build the image from the command line by running the following command to build
    the C program:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令构建C程序来从命令行构建镜像：
- en: '[PRE72]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to test it before you build it in your image, you can do so by running
    `./test` on the command line.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在构建镜像之前测试它，可以在命令行上运行“./test”来进行测试。
- en: 'Create the `Dockerfile`. The `Dockerfile` will be pretty minimal but needs
    to start with `FROM scratch`. The rest of the file will add the C program to your
    image and then run it in *line 4*:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Dockerfile`。`Dockerfile`将非常简洁，但需要以`FROM scratch`开头。文件的其余部分将把C程序添加到你的镜像，然后在*第4行*运行它：
- en: '[PRE73]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Build a new image. In this instance, call the image `scratchtest` using the
    following command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个新的镜像。在这种情况下，使用以下命令将镜像命名为`scratchtest`：
- en: '[PRE74]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Run the image from the command line:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行运行镜像：
- en: '[PRE75]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You will see the output of the test C file you created and compiled earlier
    in this exercise:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到你在这个练习中创建和编译的测试C文件的输出：
- en: '[PRE76]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Run the `docker images` command for your new image:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker images`命令查看你的新镜像：
- en: '[PRE77]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This will show you some pretty impressive results as your image is only `913
    kB` in size:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向你展示一些令人印象深刻的结果，因为你的镜像只有`913 kB`大小。
- en: '[PRE78]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'View the layers of the image using the `docker history` command:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker history`命令查看镜像的层：
- en: '[PRE79]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You will see a similar output to the following one and it has only two layers,
    the original layer from scratch and the layer where we `ADD` the test C program:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似以下的输出，它只有两层，一层是从头开始的原始层，另一层是我们“ADD”测试C程序的层：
- en: '[PRE80]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The scratch image we've created in this exercise goes part of the way to creating
    an image that is both functional and minimal, and also demonstrates that if you
    think a little about what you are trying to achieve, it will be easy to speed
    up your builds and reduce the size of your images.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中创建的scratch镜像在一定程度上创建了一个既功能齐全又最小化的镜像，并且还表明，如果你考虑一下你想要实现什么，就可以轻松加快构建速度并减小镜像的大小。
- en: We will now take a break from working with building images and take a closer
    look at naming and tagging our Docker images.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将暂停构建镜像的工作，更仔细地研究如何命名和标记我们的Docker镜像。
- en: Docker Image Naming and Tagging
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker镜像命名和标记
- en: We've touched on tags, but as we work more closely with Docker images, it's
    probably a good time to look at image tags in more depth. In simple terms, a tag
    is a label on the Docker image and should provide the user of the image with some
    useful information about the image or version of the image they are using.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了标签，但随着我们更密切地与Docker镜像一起工作，现在可能是深入了解镜像标签的好时机。简单来说，标签是Docker镜像上的标签，应该为使用该镜像的用户提供一些有用的信息，关于镜像或镜像版本。
- en: Until now, we've been working with our images as if we're solo developers, but
    when we start to work with a larger development team, a need arises to think a
    little harder about how we'll be naming and tagging our images. The following
    section of the chapter will add to your previous work and allow you to start putting
    together a naming and tagging strategy for your projects and work.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在像独立开发者一样处理我们的镜像，但当我们开始与更大的开发团队合作时，就需要更加努力地考虑如何命名和标记我们的镜像。本章的下一部分将为你的先前工作增添内容，并让你开始为你的项目和工作制定命名和标记策略。
- en: 'There are two main methods for naming and tagging your Docker images. You can
    use the `docker tag` command, or you can use the `-t` option when you build your
    image from a `Dockerfile`. To use the `docker tag` command, you specify the source
    repository name you will be using as the base and the target name and tag you
    will be creating:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要方法来命名和标记您的Docker图像。您可以使用`docker tag`命令，也可以在从`Dockerfile`构建图像时使用`-t`选项。要使用`docker
    tag`命令，您需要指定要使用的源存储库名称作为基础和要创建的目标名称和标记：
- en: '[PRE81]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'When you name your image using the `docker build` command, the `Dockerfile`
    used will create your source, and then use the `-t` option to name and tag your
    images as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`docker build`命令命名图像时，使用的`Dockerfile`将创建您的源，然后使用`-t`选项来命名和标记您的图像如下：
- en: '[PRE82]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The repository name can sometimes be prefixed with a hostname, but this is
    optional and will be used to let Docker know where the repository is located.
    We''ll demonstrate this later in this chapter when we create our own Docker Registry.
    If you''re pushing your images to Docker Hub, you also need to prefix your repository
    name with your Docker Hub username, like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库名称有时可以以主机名为前缀，但这是可选的，并且将用于让Docker知道存储库的位置。我们将在本章后面演示这一点，当我们创建自己的Docker注册表时。如果您要将图像推送到Docker
    Hub，还需要使用您的Docker Hub用户名作为存储库名称的前缀，就像这样：
- en: '[PRE83]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Using more than two prefixes in your image name is only supported in local image
    registries and is generally not used. The next exercise will guide you through
    the process of tagging Docker images.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像名称中使用两个以上的前缀仅在本地图像注册表中受支持，并且通常不使用。下一个练习将指导您完成标记Docker图像的过程。
- en: 'Exercise 3.05: Tagging Docker Images'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.05：给Docker图像打标签
- en: 'In the following exercise, you will work with a different image, using the
    lightweight `busybox` image to demonstrate the process of tagging and start to
    implement tags in your project. BusyBox is used to combine tiny versions of many
    common UNIX utilities into a single small executable:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，您将使用不同的图像，使用轻量级的`busybox`图像来演示标记的过程，并开始在项目中实施标记。BusyBox用于将许多常见的UNIX实用程序的微小版本组合成一个小的可执行文件：
- en: 'Run the `docker rmi` command to clear up the images you currently have on your
    system, so you don''t get confused with a large number of images around:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker rmi`命令来清理您当前系统上的图像，这样您就不会因为大量的图像而感到困惑：
- en: '[PRE84]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'On the command line, run the `docker pull` command to download the latest `busybox`
    container:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行上，运行`docker pull`命令以下载最新的`busybox`容器：
- en: '[PRE85]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Run the `docker images` command:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker images`命令：
- en: '[PRE86]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This will give us the information we need to start putting some tag commands
    together:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供开始组合一些标签命令所需的信息：
- en: '[PRE87]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Name and tag the image using the `tag` command. You can either use the image
    ID or repository name to tag the images. Start by using the image ID, but note
    that on your system you''ll have a different image ID. Name the repository `new_busybox`
    and include the tag `ver_1`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`tag`命令对图像进行命名和标记。您可以使用图像ID或存储库名称来标记图像。首先使用图像ID，但请注意在您的系统上，您将有一个不同的图像ID。将存储库命名为`new_busybox`，并包括标签`ver_1`：
- en: '[PRE88]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Use the repository name and image tag. Create a new repository using your name
    and tag with a new version of `ver_1.1` as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用存储库名称和图像标签。使用您的名称创建一个新的存储库，并使用`ver_1.1`的新版本如下：
- en: '[PRE89]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We have used the author's name (`vince`) in this example.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了作者的名字（`vince`）。
- en: 'Run the `docker images` command:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker images`命令：
- en: '[PRE90]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'You should see a similar output to the one that follows. Of course, your image
    IDs will be different, but the repository names and tags should be similar:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于以下内容的输出。当然，您的图像ID将是不同的，但存储库名称和标签应该是相似的：
- en: '[PRE91]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create a basic image using a `Dockerfile` and the `-t` option of the `docker
    build` command to name and tag the image. You''ve done this a few times already
    in this chapter, so from the command line, run the following command to create
    a basic `Dockerfile`, using the `new_busybox` image you named earlier. Also include
    the tag for the image name, as Docker will try to use the `latest` tag and, as
    this does not exist, it will fail:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Dockerfile`和`docker build`命令的`-t`选项来创建一个基本图像，并为其命名和打上标签。在本章中，你已经做过几次了，所以从命令行中运行以下命令来创建一个基本的`Dockerfile`，使用你之前命名的`new_busybox`图像。还要包括图像名称的标签，因为Docker将尝试使用`latest`标签，但由于它不存在，所以会失败。
- en: '[PRE92]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Run the `docker build` command to create the image while naming and tagging
    it at the same time:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker build`命令来创建图像，并同时为其命名和打上标签：
- en: '[PRE93]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Run the `docker images` command:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker images`命令：
- en: '[PRE94]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'You should now have four images available on your system. All have the same
    container ID but will have different repository names and tagged versions:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该在你的系统上有四个可用的图像。它们都有相同的容器ID，但会有不同的仓库名称和标记版本。
- en: '[PRE95]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Tagging images with a proper version that is relevant to your organization or
    team does not take too much time, especially with a little practice. This section
    of the chapter has shown you how to tag your images so they are no longer tagged
    with the default tag of the `latest`. You will see in the next section that using
    the `latest` tag and hoping it will work correctly could actually cause you some
    extra issues.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 给图像打上一个与你的组织或团队相关的适当版本的标签并不需要太多时间，尤其是经过一点练习。本章的这一部分向你展示了如何给你的图像打上标签，这样它们就不再带有`latest`的默认标签了。你将在下一节中看到，使用`latest`标签并希望它能正常工作实际上可能会给你带来一些额外的问题。
- en: Using the latest Tag in Docker
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中使用latest标签
- en: As we've been working with our tags, we've mentioned a few times not to use
    the `latest` tag, which is provided by Docker as a default tag. As you will see
    shortly, using the `latest` tag can cause a lot of issues, especially if you're
    deploying images into production environments.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用标签的过程中，我们已经多次提到不要使用`latest`标签，这是Docker提供的默认标签。正如你很快就会看到的，使用`latest`标签可能会导致很多问题，特别是在部署图像到生产环境时。
- en: The first thing we need to realize is that `latest` is simply a tag, just as
    we were using `ver_1` in our previous example. It definitely does not mean the
    latest version of our code either. It simply means the most recent build of our
    image, which did not include a tag.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要意识到的是，`latest`只是一个标签，就像我们在之前的例子中使用`ver_1`一样。它绝对不意味着我们的代码的最新版本。它只是表示我们的图像的最新构建，没有包括标签。
- en: Using the `latest` will also cause a lot of issues in large teams, deploying
    to environments multiple times a day. It also means you will have no history,
    which makes rolling back bad changes difficult. So, remember that every time you
    build or pull an image if you don't specify a tag, Docker will use the `latest`
    tag and will not do anything to ensure the image is the most up-to-date version.
    In the next exercise, we will check what issues can be caused when using the `latest`
    tag.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型团队中使用`latest`也会导致很多问题，每天多次部署到环境中。这也意味着你将没有历史记录，这会使得回滚错误更加困难。因此，请记住，每次构建或拉取图像时，如果你没有指定标签，Docker将使用`latest`标签，并不会做任何事情来确保图像是最新版本。在下一个练习中，我们将检查使用`latest`标签可能会导致什么问题。
- en: 'Exercise 3.06: Issues When Using latest'
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.06：使用latest时出现的问题
- en: 'You may still be new to both using Docker and using tags, so you may not have
    experienced any issues using the `latest` tag as yet. This exercise will give
    you some clear ideas on how using the `latest` tag could cause problems with your
    development process and provide you with reasons as to why you should avoid it.
    You created a simple `Dockerfile` in the previous exercise using the `new_busybox:ver_1`
    image. In this exercise, you will extend this file further:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能仍然是使用Docker和标签的新手，因此您可能尚未遇到使用`latest`标签时出现任何问题。这个练习将为您提供一些明确的想法，说明使用`latest`标签可能会导致您的开发过程出现问题，并为您提供应避免使用它的原因。在上一个练习中，您使用了`new_busybox:ver_1`映像创建了一个简单的`Dockerfile`。在这个练习中，您将进一步扩展此文件：
- en: Open the `Dockerfile` and amend the file to now look like the following file.
    It is a simple script that will create the `version.sh` script with simple code
    to output the latest version of our service. The new file will be called `Dockerfile_ver1`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Dockerfile`并修改文件，使其看起来像以下文件。这是一个简单的脚本，将创建带有简单代码的`version.sh`脚本，以输出我们服务的最新版本。新文件将被命名为`Dockerfile_ver1`。
- en: '[PRE96]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Build the image and name it with your name and show the image is just a test:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建映像并以您的姓名命名，并显示该映像只是一个测试：
- en: '[PRE97]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Note
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We have used `vince` as the name here, but you can use any desirable name.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了`vince`作为名称，但您可以使用任何理想的名称。
- en: 'Run the image using the `docker run` command:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run`命令运行映像：
- en: '[PRE98]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You should now see the output of the `versions.sh` script:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该看到`versions.sh`脚本的输出：
- en: '[PRE99]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Use the `docker tag` command to tag this image as `version1`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker tag`命令将此映像标记为`version1`：
- en: '[PRE100]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Open the `Dockerfile` and make the following change to *line 4*:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Dockerfile`并对*第4行*进行以下更改：
- en: '[PRE101]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Build your amended `Dockerfile` and tag it with `version2`:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建您修改后的`Dockerfile`并使用`version2`标记：
- en: '[PRE102]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Run the amended image using the `docker run` command:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run`命令运行修改后的映像：
- en: '[PRE103]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You should see your latest code changes as well:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到您最新的代码更改。
- en: '[PRE104]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This isn't the version we were looking for, was it? Without using the correct
    tag, Docker will run what is the most recent version of the image that was tagged
    with the `latest`. This image was created in *step 3*.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们要找的版本，是吗？如果不使用正确的标签，Docker将运行带有`latest`标签的最新版本的映像。此映像是在*步骤3*中创建的。
- en: 'Now, run both images with the `latest` and `version2` tags:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`latest`和`version2`标签运行两个映像：
- en: '[PRE105]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We can now see the difference in the output:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到输出的差异：
- en: '[PRE106]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: As you may have already thought, you need to specify the `version2` tag to run
    the amended version of the code. You may have seen this coming but remember this
    is going to make things more difficult to keep track of if you have multiple developers
    pushing images to a shared registry. If your team is using orchestration and using
    the `latest` version, you may end up with mixed versions of your services running
    across your production environment.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经想到的，您需要指定`version2`标签来运行修改后的代码版本。您可能已经预料到了，但请记住，如果您有多个开发人员将映像推送到共享注册表，这将使跟踪变得更加困难。如果您的团队正在使用编排并使用`latest`版本，您可能会在生产环境中运行混合版本的服务。
- en: These exercises have given you examples on how to use tags as well as showing
    you what the consequences could be if you decide to only use the `latest` tag.
    The following section will introduce tagging policies and how to implement automated
    processes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习为您提供了如何使用标签的示例，同时向您展示了如果决定仅使用`latest`标签可能会导致的后果。接下来的部分将介绍标记策略以及如何实施自动化流程。
- en: Docker Image Tagging Policies
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker映像标记策略
- en: As development teams increase in size and the projects they work on increase
    in complexity, a standardized tagging policy for your team becomes even more important.
    If your team is not getting its tagging correct, as we've demonstrated in our
    previous sections, this can cause a lot of confusion and actually cause more issues.
    It's a good habit to decide on a tagging policy early to make sure you don't run
    into any of these issues.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发团队规模的增加和他们所工作的项目复杂性的增加，团队的标记策略变得更加重要。如果您的团队没有正确使用标记，就像我们在之前的部分中所演示的那样，这可能会导致很多混乱，实际上会导致更多问题。早期制定标记策略是一个好习惯，以确保您不会遇到这些问题。
- en: In this section of the chapter, we are going to cover some of the different
    tagging policies you could use within your team with some examples on how they
    can also be implemented. There are rarely any right or wrong answers when it comes
    to setting up your tagging policy, but it is necessary to make a decision early
    and ensure everyone in the team is in agreement.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将涵盖团队内可以使用的不同标记策略，并举例说明它们如何实施。在设置标记策略时很少有对错之分，但需要及早做出决定，并确保团队中的每个人都同意。
- en: '**Semantic versioning** is a versioning system that can also be used as part
    of your tagging policy. If you''re not familiar with semantic versioning, it is
    a trusted version system that uses a three-component number in the format of `major_version.minor_version.patch`.
    For example, if you saw the semantic version of an application as 2.1.0, it would
    show version 2 as the major release version, 1 as the minor release version, and
    0 as there are no patches. Semantic versioning can be easily automated, especially
    in an automated build environment. Another option is to use a hash value, like
    the `git commit` hash for your code. This means you can match the tag back to
    your repository, so anyone can see specifically the code changes that have been
    made since the code was implemented. You could also use a date value, which can
    once again be easily automated.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**语义化版本控制**是一个版本控制系统，也可以作为标记策略的一部分使用。如果您不熟悉语义化版本控制，它是一个可信赖的版本系统，使用`major_version.minor_version.patch`格式的三部分数字。例如，如果您看到一个应用程序的语义版本是2.1.0，它将显示版本2为主要发布版本，1为次要发布版本，0为没有补丁。语义化版本控制可以很容易地自动化，特别是在自动化构建环境中。另一个选择是使用哈希值，比如您的代码的`git
    commit`哈希。这意味着您可以将标记与您的存储库匹配，这样任何人都可以具体看到自代码实施以来所做的代码更改。您还可以使用日期值，这也可以很容易地自动化。'
- en: The common theme here is that our tagging policy should be automated to ensure
    it is used, understood, and adhered to. In the following exercise, we are going
    to look at using hash values as part of your tagging policy and we will then create
    a script to build our Docker images and add semantic versioning to our tags.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的共同主题是我们的标记策略应该是自动化的，以确保它被使用、理解和遵守。在接下来的练习中，我们将研究使用哈希值作为标记策略的一部分，然后创建一个脚本来构建我们的Docker图像，并为我们的标记添加语义版本控制。
- en: 'Exercise 3.07: Automating Your Image Tagging'
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.07：自动化您的图像标记
- en: 'In this exercise, you are going to look at automating your image tagging to
    limit the amount of individual intervention needed in tagging your Docker images.
    This exercise uses the `basic-base` image again:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将研究如何自动化图像标记，以减少标记Docker图像所需的个人干预量。这个练习再次使用`basic-base`图像：
- en: 'Create the `basic-base` image again by creating the following `Dockerfile`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建以下`Dockerfile`再次创建`basic-base`图像：
- en: '[PRE107]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Build the new base image from the preceding `Dockerfile` and name it `basic-base`:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的`Dockerfile`构建新的基础图像，并将其命名为`basic-base`：
- en: '[PRE108]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'With the `basic-base` image created, set up the `Dockerfile` named `Dockerfile_ver1`
    to build a `basic-app` again. In this instance, return to the previous `Dockerfile`
    as listed here:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`basic-base`图像后，设置名为`Dockerfile_ver1`的`Dockerfile`以再次构建`basic-app`。在这种情况下，返回到此处列出的先前的`Dockerfile`：
- en: '[PRE109]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'If you''ve been using Git to track and commit the changes in your code, you
    can tag your images with the commit hash from Git using the `git log` command.
    So, build your new image, as you normally would, with the `docker build` command,
    but in this instance, add the tag to provide the short commit hash from `git`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您一直在使用Git跟踪和提交代码更改，您可以使用`git log`命令将图像标记为来自Git的提交哈希。因此，像往常一样使用`docker build`命令构建新图像，但在这种情况下，添加标签以提供来自`git`的短提交哈希：
- en: '[PRE110]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Note
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are new to using Git, it is a source control application that allows
    you to track your changes and collaborate with other users on different coding
    projects. If you have never used Git before, the following commands will initialize
    your repository, add the `Dockerfile` to the repository, and commit these changes,
    so we have a Git log present:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Git的新手，它是一个源代码控制应用程序，允许您跟踪更改并与其他用户在不同的编码项目上进行协作。如果您以前从未使用过Git，则以下命令将初始化您的存储库，将`Dockerfile`添加到存储库，并提交这些更改，以便我们有一个Git日志：
- en: '`git init; git add Dockerfile; git commit –m "initial commit"`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`git init; git add Dockerfile; git commit –m "initial commit"`'
- en: 'Use your `Dockerfile` to add arguments when your image is being built. Open
    the `Dockerfile` you''ve been using for your `basic-app` and add in the following
    two lines to set variables as unknown, and then set `LABEL` as the value offered
    at build time, using the `git-commit` build argument. Your `Dockerfile` should
    now appear as follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的`Dockerfile`在构建图像时添加参数。打开您一直在为`basic-app`使用的`Dockerfile`，并添加以下两行以将变量设置为未知，然后在构建时将`LABEL`设置为使用`git-commit`构建参数提供的值。您的`Dockerfile`现在应如下所示：
- en: '[PRE111]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Build the image again using the `--build-arg` option with the `GIT_COMMIT`
    argument, which is now equal to your `git commit` hash value:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`--build-arg`选项构建图像，并使用`GIT_COMMIT`参数，该参数现在等于您的`git commit`哈希值：
- en: '[PRE112]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Run the `docker inspect` command searching for the `"git-commit"` label:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker inspect`命令，搜索`"git-commit"`标签：
- en: '[PRE113]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'You can see the Git hash label you added at build time:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在构建时看到您添加的Git哈希标签：
- en: '[PRE114]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: This is starting to move in the direction you need, but what if you need to
    use semantic versioning as your team has decided this is the best option for your
    development? The rest of this exercise will set up a build script to both build
    and set the tag as the semantic version number.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始朝着您需要的方向发展，但是如果您需要使用语义版本控制，因为您的团队已经决定这是开发的最佳选项，该怎么办？本练习的其余部分将设置一个构建脚本，用于构建和设置标签为语义版本号。
- en: 'Alongside your `Dockerfile`, create a version file simply named `VERSION`.
    Set the new version as `1.0.0` for this build of `basic-app`:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Dockerfile`旁边，创建一个名为`VERSION`的版本文件。将`basic-app`的此构建的新版本设置为`1.0.0`：
- en: '[PRE115]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Make changes to the `Dockerfile` to remove the `GIT_COMMIT` details added previously
    and add the `VERSION` file as part of your build. Adding it into the image itself
    means users can always refer to the `VERSION` file if ever they need to verify
    the image version number:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`Dockerfile`进行更改，以删除先前添加的`GIT_COMMIT`详细信息，并将`VERSION`文件添加为构建的一部分。将其添加到图像本身意味着用户可以随时参考`VERSION`文件，以验证图像版本号：
- en: '[PRE116]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Create a build script to both build and tag your image. Call this `build.sh`
    and it will reside in the same directory as your `Dockerfile` and `VERSION` file:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个构建脚本来构建和标记您的图像。将其命名为`build.sh`，并且它将驻留在与您的`Dockerfile`和`VERSION`文件相同的目录中：
- en: '[PRE117]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Add the following details to `build.sh`. *Line 3* will be your Docker Hub username,
    and *line 4* is the name of the image or service you are building (in the following
    example, `basic-app`). The script then grabs the version number from your `VERSION`
    file and brings all your variables together to build your image with a nice name
    and tag relevant to your new semantic version:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下详细信息添加到“build.sh”。*第3行*将是您的Docker Hub用户名，*第4行*是您正在构建的图像或服务的名称（在以下示例中为“basic-app”）。然后，脚本从您的“VERSION”文件中获取版本号，并将所有变量汇集在一起，以使用与您的新语义版本相关的漂亮名称和标记构建您的图像：
- en: '[PRE118]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Make sure the build script is set to run as an executable script using the
    `chmod` command on the command line:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保构建脚本已设置为可执行脚本，使用命令行上的“chmod”命令：
- en: '[PRE119]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Run the build script from the command line. `set -xe` in *line 1* of the script
    will make sure all commands are output to the console and ensure that if any of
    the commands cause an error, the script will stop. Run the build script now, as
    follows:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行运行构建脚本。“set -xe”在脚本的*第1行*将确保所有命令都输出到控制台，并确保如果任何命令导致错误，脚本将停止。现在运行构建脚本，如下所示：
- en: '[PRE120]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Only the output of the build script is shown here as the rest of the build
    process happens as normal:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只显示了构建脚本的输出，其余的构建过程都是正常进行的：
- en: '[PRE121]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'View the image using the `docker images` command:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“docker images”命令查看图像：
- en: '[PRE122]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'It should reflect the name and tags created as part of the build script:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该反映在构建脚本中创建的名称和标记：
- en: '[PRE123]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This exercise goes a long way in automating our tagging process, and it allows
    the `build` script to be added to source control and run easily as part of a build
    pipeline. It is just a start though, and you will see in the activities at the
    end of the chapter that we will extend this build script further. For now, we
    have completed this section on the tagging and naming of our images, and it fits
    in nicely with the next section, which covers storing and publishing your Docker
    images.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这项练习在自动化我们的标记过程中起到了很大作用，并且允许将“build”脚本添加到源代码控制中，并作为构建流水线的一部分轻松运行。不过，这只是一个开始，你将在本章末尾的活动中看到，我们将进一步扩展这个构建脚本。目前，我们已经完成了关于图像的标记和命名的部分，并且它与下一部分很好地契合，该部分涵盖了存储和发布您的Docker图像。
- en: Storing and Publishing Your Docker Images
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储和发布您的Docker图像
- en: Since the early days of Docker's history, one of its main attractions has been
    a central website where users can download images, reuse and improve these images
    for their purposes, and reupload them to grant access to other users. Docker Hub
    has grown and although it has had some security issues, it is still usually the
    first place people will look when they need new images or resources for their
    projects.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 自Docker历史的早期以来，它的主要吸引力之一就是一个中央网站，用户可以在那里下载图像，重用和改进这些图像以满足他们的目的，并重新上传它们以授予其他用户访问权限。Docker
    Hub已经发展壮大，尽管它曾经存在一些安全问题，但通常仍然是人们需要新图像或项目资源时首先寻找的地方。
- en: As a public repository, Docker Hub is still one of the first places people go
    to research and use images needed to streamline or improve their new development
    project. It is also an important place for companies and developers to host their
    open-source images, available for the public to utilize. However, Docker Hub is
    not the only solution for you to store and distribute your Docker images.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个公共存储库，Docker Hub仍然是人们研究和使用图像所需的第一个地方，以简化或改进他们的新开发项目。对于公司和开发人员来说，它也是一个重要的地方，用于托管他们的开源图像，供公众利用。然而，Docker
    Hub并不是您存储和分发Docker图像的唯一解决方案。
- en: For development teams, a public repository on Docker Hub, although accessible
    and highly available, may not be the best option. These days, your team may look
    to store production images in a cloud-based registry solution such as Amazon Elastic
    Container Registry, Google Container Registry, or, as you'll see later in this
    chapter, another option would be to set up a local registry.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发团队来说，Docker Hub上的公共存储库虽然易于访问且高度可用，但可能不是最佳选择。如今，您的团队可能会考虑将生产图像存储在基于云的注册表解决方案中，例如Amazon
    Elastic Container Registry、Google Container Registry，或者正如本章后面将看到的，另一个选择是设置本地注册表。
- en: In this part of the chapter, we'll start by seeing how you can actually move
    images from machine to machine and then take a closer look at using Docker Hub.
    We'll see how to start moving our images across to Docker Hub as a publicly stored
    image. We will then look at setting up a locally hosted Docker registry on your
    development system.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将首先看看如何实际将图像从一台机器移动到另一台机器，然后更仔细地了解如何使用Docker Hub。我们将看到如何开始将我们的图像移动到Docker
    Hub作为公开存储的图像。然后，我们将看看如何在开发系统上设置一个本地托管的Docker注册表。
- en: 'The `docker save` command will be used to save the images from the command
    line. Here, we use the `-o` option to specify the output file and directory we
    are going to save our image to:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker save`命令将用于从命令行保存图像。在这里，我们使用`-o`选项来指定输出文件和目录，我们将保存图像到该目录中：'
- en: '[PRE124]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We will then be able to use the `load` command similar to the `import` command
    when we created a new base image earlier in the chapter, specifying the file we
    created previously:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将能够使用`load`命令，类似于本章前面创建新基础图像时使用的`import`命令，指定我们之前创建的文件。
- en: '[PRE125]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Keep in mind that not all images on Docker Hub should be treated the same way,
    as it comes with a mixture of both official images that have been created by Docker
    Inc. and community images created by Docker users. Official images are still open
    source images and solutions available for you to add to your projects. Community
    images are offered usually by companies or individuals wanting you to leverage
    their technology.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，并非所有Docker Hub上的图像都应该以相同的方式对待，因为它包含了由Docker Inc.创建的官方图像和由Docker用户创建的社区图像的混合物。官方图像仍然是开源图像和解决方案，可供您添加到您的项目中。社区图像通常由公司或个人提供，希望您利用他们的技术。
- en: Note
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Use caution when sourcing images, even from Docker Hub. Try to limit pulling
    images from sources that are not reputable and have not been reviewed or downloaded
    by a large number of users as they could pose a potential security risk.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是从Docker Hub获取图像时也要小心。尽量限制从不可靠来源拉取图像，并且尽量避免那些没有经过大量用户审核或下载的来源，因为它们可能构成潜在的安全风险。
- en: 'Exercise 3.08: Transporting Docker Images Manually'
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.08：手动传输Docker图像
- en: 'Sometimes, whether there are issues with firewalls or other security measures
    on your network, you may need to copy an image directly from one system to another.
    Fortunately, Docker has a way of achieving this and, in this exercise, you will
    move an image from one system to another without using a registry:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，无论是网络上的防火墙问题还是其他安全措施，您可能需要直接从一台系统复制图像到另一台系统。幸运的是，Docker有一种实现这一点的方法，在这个练习中，您将在不使用注册表的情况下将图像从一台系统移动到另一台系统：
- en: 'Run the `docker save` command with the `-o` option to save the image you created
    in the last part of this chapter. The command needs the user to specify both the
    filename and the directory. In the following example, it is `/tmp/basic-app.tar`.
    Also specify the user, image name, and tag of the image:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker save`命令和`-o`选项来保存本章最后部分创建的图像。该命令需要用户指定文件名和目录。在下面的示例中，它是`/tmp/basic-app.tar`。还要指定图像的用户、图像名称和标签。
- en: '[PRE126]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: You should now see the packaged-up image in the `/tmp` directory. You are using
    `.tar` as the extension of your filename as the `save` command creates a TAR file
    of the image. You could actually use any name for the extension of the file.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该在`/tmp`目录中看到打包的镜像。您正在使用`.tar`作为文件名的扩展名，因为`save`命令会创建镜像的TAR文件。实际上，您可以为文件的扩展名使用任何名称。
- en: 'Use the `du` command to verify that the `basic-app.tar` file has data in it:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`du`命令验证`basic-app.tar`文件中是否有数据：
- en: '[PRE127]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'You can now move the image as you need to, whether it be via `rsync`, `scp`,
    or `cp`. As it is a TAR file, you could also compress the file as a ZIP file if
    you need to save some space during the transfer. In this example, you will simply
    delete the image from your current system. Run the `docker rmi` command with the
    ID of the image you have just saved:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以根据需要移动镜像，无论是通过`rsync`、`scp`还是`cp`。由于它是一个TAR文件，如果需要在传输过程中节省一些空间，您还可以将文件压缩为ZIP文件。在这个例子中，您将简单地从当前系统中删除镜像。运行`docker
    rmi`命令，后面跟着您刚保存的镜像的ID：
- en: '[PRE128]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Load the new image back as a Docker image using the `docker load` command with
    the `-i` option, pointing to where the packaged image is located. In this case,
    it is the `/tmp` directory:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker load`命令将新镜像作为Docker镜像加载回来，使用`-i`选项，指向打包镜像的位置。在这种情况下，它是`/tmp`目录：
- en: '[PRE129]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'You should get output like the following:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下输出：
- en: '[PRE130]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Use the `docker image` command to bring up the image you have just loaded into
    your local environment:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker image`命令将您刚刚加载到本地环境中的镜像启动：
- en: '[PRE131]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'You should get output like the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下输出：
- en: '[PRE132]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: This was just a simple exercise, but it hopefully served to show you that if
    there is ever a situation where you are unable to connect to a registry, you are
    still able to transport your Docker images. The next exercises are more focused
    on the usual methods of storing, publishing, and distributing your Docker images.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的练习，但希望它能向您展示，如果有任何情况导致您无法连接到注册表，您仍然可以传输您的Docker镜像。接下来的练习更侧重于存储、发布和分发Docker镜像的常规方法。
- en: Storing and Deleting Docker Images in Docker Hub
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Docker Hub中存储和删除Docker镜像
- en: Although you can work with Docker Hub without paying any money, you need to
    know you will only get one private repository free of charge on your account.
    If you want more, you'll need to pay for a monthly plan on Docker. If Docker Hub
    is the solution your team has chosen to use, you will rarely need only one private
    repository. If you decide a free account is for you, then you get an unlimited
    number of free repositories.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以在Docker Hub上免费使用，但您需要知道，您的帐户只能免费获得一个私有存储库。如果您想要更多，您需要在Docker上支付月度计划。如果Docker
    Hub是您的团队选择使用的解决方案，您很少需要只有一个私有存储库。如果您决定免费帐户适合您，那么您将获得无限数量的免费存储库。
- en: 'Exercise 3.09: Storing Docker Images in Docker Hub and Deleting the Repository'
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.09：在Docker Hub中存储Docker镜像并删除存储库
- en: 'In this exercise, you will create a new repository for the `basic-app` that
    you''ve been working on and store the images in Docker Hub. Once you have pushed
    the images in Docker Hub, you will also look at how you can delete the repository:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将为您正在工作的`basic-app`创建一个新的存储库，并将镜像存储在Docker Hub中。一旦您将镜像推送到Docker Hub，您还将看到如何删除存储库：
- en: Note
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The following exercise will need you to have your account on Docker Hub. We
    will only be using free repositories, so you will not need to be on a paid monthly
    plan, but if you haven't signed up for a free account on Docker Hub, go to [https://hub.docker.com/signup](https://hub.docker.com/signup).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习将需要您在Docker Hub上拥有帐户。我们将只使用免费存储库，因此您不需要付费月度计划，但如果您还没有在Docker Hub上注册免费帐户，请转到[https://hub.docker.com/signup](https://hub.docker.com/signup)。
- en: 'Log in to your Docker Hub account and, under the `Repositories` section, you''ll
    have the option `Create Repository` as a blue button on the right of the screen.
    Click this button so that you can set up a repository for the `basic-app` you
    have been working on:![Figure 3.1: Creating a repository in Docker Hub'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到您的Docker Hub帐户，在`存储库`部分下，您将看到右侧的蓝色按钮`创建存储库`选项。单击此按钮，以便为您正在工作的`basic-app`设置存储库：![图3.1：在Docker
    Hub中创建存储库
- en: '](image/B15021_03_01.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_03_01.jpg)'
- en: 'Figure 3.1: Creating a repository in Docker Hub'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：在Docker Hub中创建存储库
- en: 'When creating a new repository, you''ll be presented with a page like the one
    that follows. Fill in the `Name` of the repository, which is usually the name
    of the image or service you are storing (in this case, `basic-app`). You also
    have the option to set the repository as `Public` or `Private`, and in this instance,
    select `Public`:![Figure 3.2: Repository creation screen of Docker Hub'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新存储库时，您将看到一个类似下面的页面。填写存储库的`名称`，通常是您要存储的图像或服务的名称（在本例中为`basic-app`）。您还可以选择将存储库设置为`公共`或`私有`，在这种情况下，选择`公共`：![图3.2：Docker
    Hub的存储库创建屏幕
- en: '](image/B15021_03_02.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_03_02.jpg)'
- en: 'Figure 3.2: Repository creation screen of Docker Hub'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：Docker Hub的存储库创建屏幕
- en: 'Toward the bottom on the screen, there are also options to build your images.
    Click the `Create` button at the bottom of the screen:![Figure 3.3: Repository
    creation screen of Docker Hub'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕底部，还有构建图像的选项。单击屏幕底部的`创建`按钮：![图3.3：Docker Hub的存储库创建屏幕
- en: '](image/B15021_03_03.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_03_03.jpg)'
- en: 'Figure 3.3: Repository creation screen of Docker Hub'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：Docker Hub的存储库创建屏幕
- en: 'Once your new repository is created, it will provide details on how to start
    pushing your images to your new repository. Tag your image with `<account_name>/<image_name>:tag`
    to let Docker know where it will be pushing the image and which repository Docker
    will be pushing it to:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新存储库后，它将提供有关如何开始将图像推送到新存储库的详细信息。使用`<account_name>/<image_name>:tag`标记您的图像，以便Docker知道它将推送图像的位置以及Docker将要将其推送到哪个存储库：
- en: '[PRE133]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Now, Docker on your system knows where to push the image. Push the image using
    the `docker push <account_name>/<image_name>:tag` command:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您的系统上的Docker知道在哪里推送图像。使用`docker push <account_name>/<image_name>:tag`命令推送图像：
- en: '[PRE134]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: You need to make sure you are logged in to Docker Hub from the command line
    as well as the web interface.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保您已经从命令行和Web界面登录到Docker Hub。
- en: 'Use the `docker login` command and enter the same credentials you were using
    when you logged in to create the new repository:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker login`命令，并输入创建新存储库时使用的相同凭据：
- en: '[PRE135]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Now, push your image to your new repository, as you did in *step 5* of this
    exercise, which previously failed. It should give you a successful result:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将您的图像推送到新的存储库，就像在本练习的*步骤5*中所做的那样，之前失败了。它应该给您一个成功的结果：
- en: '[PRE136]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Move back to the Docker Hub web interface and you should now see the image
    version you have pushed, sitting in your newly created repository:![Figure 3.4:
    Your newly created Docker Hub repository with image'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Docker Hub Web界面，现在您应该看到您推送的图像版本，位于您新创建的存储库中：![图3.4：您新创建的Docker Hub存储库中的图像
- en: '](image/B15021_03_04.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_03_04.jpg)'
- en: 'Figure 3.4: Your newly created Docker Hub repository with image'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：您新创建的Docker Hub存储库中的图像
- en: You now have a public repository available for anyone wanting to pull your image
    down and reuse it for their purposes. If someone needed to use your image, they
    would simply use the full name of the image, including tags with the `docker pull`
    command or `FROM` command in a `Dockerfile`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个公共存储库可供任何想要拉取您的镜像并为其目的重用的人使用。如果有人需要使用您的镜像，他们只需使用镜像的完整名称，包括`docker pull`命令或`Dockerfile`中的`FROM`命令。
- en: 'You''ll notice in the preceding image that, on the right-hand side of the screen,
    there is the `Public View` button. This gives you an option to see specifically
    what the public will see when they search for your image. Click the button and
    you should see a similar screen to the following:![Figure 3.5: The public view
    of your Docker Hub repository'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到在前面的图像中，屏幕右侧有一个“公共视图”按钮。这给了您一个选项，可以看到公众在搜索您的镜像时会看到什么。点击按钮，您应该会看到类似以下的屏幕：![图3.5：您的Docker
    Hub存储库的公共视图
- en: '](image/B15021_03_05.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_03_05.jpg)'
- en: 'Figure 3.5: The public view of your Docker Hub repository'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：您的Docker Hub存储库的公共视图
- en: This is exactly what the public will see of your repository. It's now up to
    you to make sure you have the overview up to date and ensure your image is supported
    to make sure there are no problems with anyone wanting to use your image.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是公众将看到的您的存储库。现在轮到您确保您的概述是最新的，并确保您的镜像得到支持，以确保任何想要使用您的镜像的人没有问题。
- en: 'Lastly, for this exercise, clean up the repository you''ve just created. If
    you are not still in the web interface of your repository, move back onto the
    Docker Hub web page and click the `Settings` tab at the top of the screen:![Figure
    3.6: The Settings screen of the Docker Hub repository'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在这个练习中，清理您刚刚创建的存储库。如果您还没有在存储库的网络界面中，请返回到Docker Hub网页，然后点击屏幕顶部的“设置”选项卡：![图3.6：Docker
    Hub存储库的设置屏幕
- en: '](image/B15021_03_06.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_03_06.jpg)'
- en: 'Figure 3.6: The Settings screen of the Docker Hub repository'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：Docker Hub存储库的设置屏幕
- en: Here you will have the option to make your repository private, but in this exercise,
    you will delete the repository. Click the `Delete Repository` option and confirm
    you now want to delete it.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，您将有选择使您的存储库私有，但在这个练习中，您将删除存储库。点击“删除存储库”选项，并确认您现在要删除它。
- en: As demonstrated in this exercise, Docker Hub provides you with an easy way to
    distribute images to allow other users to collaborate or utilize the work you've
    already done. A public repository is not always the best option for an enterprise,
    but just as GitHub has allowed developers to distribute their code and collaborate
    with other developers, Docker Hub can do the same for your Docker Images.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，Docker Hub为您提供了一个简单的方式来分发镜像，以便其他用户可以合作或利用您已经完成的工作。公共存储库并不总是企业的最佳选择，但就像GitHub允许开发人员分发他们的代码并与其他开发人员合作一样，Docker
    Hub也可以为您的Docker镜像做同样的事情。
- en: The Docker Registry
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Registry
- en: The Docker Registry is a service that hosts your images. Most of the time, registries
    are private and only available for the team that has access to them. There are
    a lot of great options available and one of those options is the registry image
    made available and maintained by Docker.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Registry是托管您的镜像的服务。大多数情况下，存储库是私有的，只对团队有权限访问。有很多很好的选择，其中之一是Docker提供和维护的注册表镜像。
- en: There are a few different reasons why you would want to be running your own
    Docker registry. It could be due to security issues, or you don't want your latest
    work publicly available. It could even be the simple convenience of having your
    registry running on the system you're working on. In this part of the chapter,
    we'll set up a registry on your working environment and start storing your images
    on the registry.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个不同的原因会让您想要运行自己的Docker注册表。这可能是由于安全问题，或者您不希望您的最新工作公开可用。甚至可能只是为了方便，在您正在工作的系统上运行您的注册表。在本章的这一部分，我们将在您的工作环境上设置一个注册表，并开始将您的镜像存储在注册表上。
- en: Note
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Docker simplifies things for us as they have a registry image available on
    Docker Hub to download and use for your projects. For more information on the
    image we will be using, you can find it at the following location:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Docker为我们简化了事情，因为他们在Docker Hub上提供了一个注册表镜像供您下载并用于您的项目。有关我们将要使用的镜像的更多信息，您可以在以下位置找到：
- en: '[https://hub.docker.com/_/registry](https://hub.docker.com/_/registry).'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://hub.docker.com/_/registry](https://hub.docker.com/_/registry)。'
- en: 'Exercise 3.10: Creating a Local Docker Registry'
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.10：创建本地Docker注册表
- en: 'In this exercise, you will set up a Docker registry for your images and run
    them on your system. You are not going to set up a registry available to your
    team, or the outside world. You will set up a nice domain to use on your systems
    that reflect the work you are doing. This will help you decide whether to then
    have this registry available to your team or other users:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将为您的镜像设置一个Docker注册表，并在您的系统上运行它们。您不打算为您的团队或外部世界设置一个可用的注册表。您将设置一个漂亮的域名在您的系统上使用，以反映您正在进行的工作。这将帮助您决定是否将此注册表提供给您的团队或其他用户：
- en: 'To set up your domain, add a domain for your local registry to your system
    hosts file. On a Windows system, you will need to access the hosts file at `C:\Windows\System32\drivers\etc\hosts`,
    while on a Linux or Max, it will be `/etc/hosts`. Open the `hosts` file and add
    the following line to the file:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置您的域名，请将本地注册表的域名添加到您的系统主机文件中。在Windows系统上，您需要访问`C:\Windows\System32\drivers\etc\hosts`中的主机文件，而在Linux或Max上，它将是`/etc/hosts`。打开`hosts`文件并将以下行添加到文件中：
- en: '[PRE137]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: This will allow you to use the `dev.docker.local` domain instead of using localhost
    for your local registry.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您使用`dev.docker.local`域，而不是在本地注册表中使用localhost。
- en: 'Pull the latest `registry` image down from Docker Hub:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Docker Hub拉取最新的`registry`镜像：
- en: '[PRE138]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Use the following command to run the registry container. Provide the ports
    you can access the registry with; in this case, use port `5000`. You also need
    to use the `--restart=always` option, which will make sure the container restarts
    if Docker or your system needs to restart:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令来运行注册表容器。提供您可以访问注册表的端口；在这种情况下，使用端口`5000`。您还需要使用`--restart=always`选项，这将确保容器在Docker或系统需要重新启动时重新启动：
- en: '[PRE139]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Note
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the following chapters, you will learn how to extend the file capacity of
    your Docker container by mounting a directory from your host system that will
    then run as part of your running container. To do this, you will use the `-v`
    or `--volume` option as part of your `docker run` command, providing the file
    and the mount point on the container. For example, you could run the preceding
    command to mount a directory on your host system as follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将学习如何通过挂载来自主机系统的目录来扩展Docker容器的文件容量，然后作为运行容器的一部分运行。为此，您将使用`-v`或`--volume`选项作为您的`docker
    run`命令的一部分，提供文件和容器上的挂载点。例如，您可以运行上述命令来挂载主机系统上的目录如下：
- en: '`docker run -d -p 5000:5000 --restart=always --volume <directory_name>:/var/lib/registry:rw
    --name registry`'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run -d -p 5000:5000 --restart=always --volume <directory_name>:/var/lib/registry:rw
    --name registry`'
- en: 'Run the `docker ps` command to show the `registry` container running on your
    system, which is ready to accept and store new images:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker ps`命令，显示在您的系统上运行的`registry`容器，该容器已准备好接受并存储新的映像：
- en: '[PRE140]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The command will return the output like the following:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回以下输出：
- en: '[PRE141]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Run the `docker tag` command to tag your existing images with the registry hostname
    and port `dev.docker.local:5000`.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker tag`命令，使用注册表主机名和端口`dev.docker.local:5000`对现有映像进行标记。
- en: '[PRE142]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'This will ensure that your `basic-app` image will be automatically pushed to
    the local registry:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的`basic-app`映像将自动推送到本地注册表：
- en: '[PRE143]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Delete the original images from the system you are currently working on using
    the `docker image remove` command:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker image remove`命令从您当前正在使用的系统中删除原始映像：
- en: '[PRE144]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Now, pull down the image from your local registry by including the registry
    hostname and port `dev.docker.local:5000` as part of the `pull` command:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过在`pull`命令中包含注册表主机名和端口`dev.docker.local:5000`，从本地注册表中拉取映像：
- en: '[PRE145]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: This brings us to the end of this section where we have created our registry
    to store our Docker images on our local system. The registry itself is simple
    and is not really supported but does go a long way to help you understand how
    a registry will work and how it can work with your team. If you are looking for
    a more robust and supported image, Docker also provides Docker Trusted Registry,
    which is a commercial offering by Docker.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们到本节的结束，我们已经在本地系统上创建了我们的注册表来存储我们的Docker映像。注册表本身很简单，实际上并不受支持，但它确实有助于帮助您了解注册表将如何工作以及如何与您的团队合作。如果您正在寻找更强大和受支持的映像，Docker还提供了Docker
    Trusted Registry，这是Docker提供的商业产品。
- en: It's time to test the knowledge acquired so far. In the next activity, we will
    modify the build script for the `PostgreSQL` container image to use the Git commit
    hash instead of semantic versioning.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试到目前为止所学到的知识了。在下一个活动中，我们将修改`PostgreSQL`容器映像的构建脚本，以使用Git提交哈希而不是语义版本。
- en: 'Activity 3.01: Build Scripts Using Git Hash Versioning'
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动3.01：使用Git哈希版本化的构建脚本
- en: Earlier in the chapter, you created a build script that automated the tagging
    and versioning process of your images being built. In this activity, you will
    work further with the Panoramic Trekking app and will be tasked with setting up
    a build script for the `PostgreSQL` container image. You can use the previous
    build script you created earlier, but you will need to modify the script to no
    longer use semantic versioning and instead use the current Git commit hash. Also,
    make sure that your build script pushed the built image onto your Docker registry.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，您创建了一个构建脚本，自动化了正在构建的映像的标记和版本化过程。在这个活动中，您将进一步使用全景徒步应用程序，并被要求为`PostgreSQL`容器映像设置一个构建脚本。您可以使用之前创建的构建脚本，但是您需要修改脚本，不再使用语义版本，而是使用当前的Git提交哈希。另外，请确保您的构建脚本将构建的映像推送到您的Docker注册表。
- en: 'The steps required for completion are as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所需的步骤如下：
- en: Ensure you have a running `Dockerfile` created for your `PostgreSQL` container
    image.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已经为您的`PostgreSQL`容器映像创建了一个运行的`Dockerfile`。
- en: 'Create your build script, which performs the following actions:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建您的构建脚本，执行以下操作：
- en: a) Sets the variables for your Docker registry, the service name being built,
    and the Git hash version
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: a) 设置您的Docker注册表的变量，正在构建的服务名称和Git哈希版本
- en: b) Prints the Git hash version to the screen
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: b) 将Git哈希版本打印到屏幕上
- en: c) Builds your PostgreSQL Docker images
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: c) 构建您的PostgreSQL Docker映像
- en: d) Pushes your Docker image to your registry
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: d) 将您的Docker映像推送到您的注册表
- en: Ensure that the build script runs and completes successfully.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保构建脚本运行并成功完成。
- en: 'Expected Output:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出：
- en: '[PRE146]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Note
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor323).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15021_Solution_Final_SMP.xhtml#_idTextAnchor323)找到。
- en: In the next activity, you will configure your local Docker registry storage
    by changing the `docker run` command to store it in a directory on your home directory.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，您将通过更改`docker run`命令将本地Docker注册表存储在您的主目录中的一个目录中。
- en: 'Activity 3.02: Configuring Your Local Docker Registry Storage'
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动3.02：配置本地Docker注册表存储
- en: During this chapter, you set up your registry and began using basic options
    to get it running. The registry itself is storing images on the host filesystem.
    In this activity, you want to change the `docker run` command to store it in a
    directory on your home directory. You will create a directory called `test_registry`
    and run the Docker command to store images in this `test_registry` directory in
    your home directory.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您设置了您的注册表并开始使用基本选项来使其运行。注册表本身正在主机文件系统上存储镜像。在这个活动中，您希望更改`docker run`命令以将其存储在您的主目录中的一个目录中。您将创建一个名为`test_registry`的目录，并运行Docker命令将镜像存储在您的主目录中的`test_registry`目录中。
- en: 'The steps required for completion are as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所需的步骤如下：
- en: Create a directory within your home directory to mount your local registry.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的主目录中创建一个目录来挂载您的本地注册表。
- en: Run the local registry. This time mount the newly created volume as part of
    the registry.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行本地注册表。这次将新创建的卷挂载为注册表的一部分。
- en: Test your changes by pushing a new image to the local registry.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将新镜像推送到本地注册表来测试您的更改。
- en: Hint
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Use the `-v` or `–volume` option when you run your registry container.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行注册表容器时使用`-v`或`–volume`选项。
- en: '**Expected Output:**'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出：**'
- en: 'While listing all the files in the local directory, you will be able to see
    the pushed images:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出本地目录中的所有文件时，您将能够看到推送的图像：
- en: '[PRE147]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Note
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor324).
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15021_Solution_Final_SMP.xhtml#_idTextAnchor324)找到。
- en: Summary
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter demonstrated how Docker allows users to work with images to package
    their applications together with a working environment to be moved across different
    working environments. You've seen how Docker uses layers and caching to improve
    build speed and ensure you can also work with these layers to reserve resources
    or disk space.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 本章演示了Docker如何允许用户使用镜像将其应用程序与工作环境一起打包，以便在不同的工作环境之间移动。您已经了解到Docker如何使用层和缓存来提高构建速度，并确保您也可以使用这些层来保留资源或磁盘空间。
- en: We also spent some time creating a base image with only one layer of our image.
    We've explored tagging and tagging practices you can adopt in order to counter
    issues associated with deploying and publishing your images. We also took a look
    at different ways we can publish our images and share them with other users and
    developers. We are only just getting started and still have a long way to go.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还花了一些时间创建了一个只有一个图像层的基本图像。我们探讨了标记和标记实践，您可以采用这些实践来解决部署和发布图像相关的问题。我们还看了一下我们可以发布图像和与其他用户和开发人员共享图像的不同方法。我们才刚刚开始，还有很长的路要走。
- en: In the next chapter, we'll be working further with our `Dockerfiles` to learn
    how multistage `Dockerfiles` work. We'll also find more ways in which we can optimize
    our Docker images for better performance when they're released into a production
    environment.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步使用我们的`Dockerfiles`来学习多阶段`Dockerfiles`的工作原理。我们还将找到更多优化我们的Docker镜像的方法，以便在发布到生产环境时获得更好的性能。
