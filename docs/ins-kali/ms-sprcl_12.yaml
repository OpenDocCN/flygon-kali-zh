- en: Securing an API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护API
- en: Security is one of the most commonly discussed problems related to microservices-based
    architecture. There is always one main problem for all security concerns—a network.
    With microservices, where typically there is much more communication over the
    network than there is for monolithic applications, the approach to authentication
    and authorization should be reconsidered. Traditional systems are usually secured
    at the border and then allow the frontend service full access to the backend components.
    The migration to microservices forces us to change this approach to delegated-access
    management.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是与基于微服务架构相关的最常讨论的问题之一。所有安全问题的主要问题始终是网络。在微服务中，通常网络通信要比单体应用程序多得多，因此对身份验证和授权的方法应该重新考虑。传统系统通常在边界处进行保护，然后允许前端服务完全访问后端组件。迁移到微服务需要我们改变这种委托访问管理的方法。
- en: How does Spring Framework address the security concerns of microservices-based
    architecture? It provides several projects that implement different patterns regarding
    authentication and authorization. The first of these is Spring Security, which
    is a de facto standard for secure Spring-based Java applications. It consists
    of a few submodules that help you get started with SAML, OAuth2, or Kerberos.
    There is also the Spring Cloud Security project. It provides several components
    that allow you to integrate basic Spring Security features with the main elements
    of microservices architecture, such as gateways, load balancers, and REST HTTP
    clients.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架如何解决基于微服务架构的安全问题？它提供了几个项目，实现了关于身份验证和授权的不同模式。其中之一是Spring Security，它是基于Spring的Java应用程序的安全标准。它由一些子模块组成，可帮助您开始使用SAML、OAuth2或Kerberos。还有Spring
    Cloud Security项目。它提供了几个组件，允许您将基本Spring Security功能与微服务架构的主要元素集成，如网关、负载均衡器和REST
    HTTP客户端。
- en: In this chapter, I'm going to show you how to secure all the main components
    of your microservices-based system. I will describe the particular elements relevant
    to the topic in the order of the chapters that compose the second part of this
    book. So, we would begin from service discovery with Eureka, then move on to the
    Spring Cloud Config Server and inter-service communication, and then finally discuss
    API gateway security.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您展示如何保护基于微服务的系统的所有主要组件。我将按照本书第二部分的章节顺序描述与主题相关的特定元素。因此，我们将从Eureka服务发现开始，然后转向Spring
    Cloud配置服务器和服务间通信，最后讨论API网关安全。
- en: 'Here''s what we will look at in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将要讨论的内容：
- en: Configuring a secure connection for a single Spring Boot application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为单个Spring Boot应用程序配置安全连接
- en: Enabling HTTPS communication for the most important elements of microservice-based
    architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为基于微服务架构的最重要元素启用HTTPS通信
- en: Encrypting and decrypting property values in configuration files stored on Config
    Server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置服务器上存储的配置文件中加密和解密属性值
- en: Simple in-memory based authentication with OAuth2 for microservices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对微服务的基于内存的简单身份验证与OAuth2
- en: More advanced OAuth2 configuration with JDBC backend store and JWT tokens
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JDBC后端存储和JWT令牌进行更高级的OAuth2配置
- en: Using OAuth2 authorization in inter-service communication with Feign client
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Feign客户端在服务间通信中使用OAuth2授权
- en: But first, let's begin with the basics. I'll show you how to create your first
    secure microservice that exposes an API over HTTPS.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们从基础知识开始。我将向您展示如何创建您的第一个安全微服务，通过HTTPS公开API。
- en: Enabling HTTPS for Spring Boot
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Spring Boot启用HTTPS
- en: 'If you want to use SSL and serve your RESTful APIs over HTTPS, you will need
    to generate a certificate. The fastest way to achieve this is through a self-signed
    certificate, which is enough for development mode. JRE provides a simple tool
    for certificate management—`keytool`. It is available under your `JRE_HOME\bin`
    directory. The command in the following code generates a self-signed certificate
    and puts it into the PKCS12 KeyStore. Besides KeyStore''s type, you will also
    have to set its validity, alias, and the name of the file. Before starting the
    generation process, `keytool` will ask you for your password and some additional
    information, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用SSL并通过HTTPS提供RESTful API，您需要生成证书。实现这一目标的最快方法是通过自签名证书，这对于开发模式足够了。JRE提供了一个简单的证书管理工具——`keytool`。它位于`JRE_HOME\bin`目录下。以下代码中的命令生成自签名证书并将其放入PKCS12
    KeyStore中。除了KeyStore的类型，您还必须设置其有效期、别名和文件名。在开始生成过程之前，`keytool`会要求您输入密码和一些其他信息，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I have copied the generated certificate into the `src/main/resources` directory
    inside the Spring Boot application. After building and running the application,
    it will be available on the classpath. To enable SSL, we have to provide some
    configuration settings in the `application.yml` file. SSL can be customized for
    Spring by setting the various `server.ssl.*` properties:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将生成的证书复制到Spring Boot应用程序中的`src/main/resources`目录中。构建和运行应用程序后，它将可用于类路径。要启用SSL，我们必须在`application.yml`文件中提供一些配置设置。可以通过设置各种`server.ssl.*`属性来为Spring定制SSL：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Secure discovery
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全发现
- en: As you can see, the configuration of SSL for a microservice application is not
    a very hard task. However, it is time to increase the difficulty level. We have
    already launched a single microservice that serves a RESTful API over HTTPS. Now
    we want that microservice to integrate with the discovery server. There are two
    problems that arise from this. The first of these is the need to publish information
    about the secure microservice's instance in Eureka. The second of these concerns
    exposing Eureka over HTTPS and forcing the discovery client to authenticate against
    a discovery server using a private key. Let's discuss these issues in detail.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，为微服务应用程序配置SSL并不是一项非常困难的任务。然而，现在是时候提高难度了。我们已经启动了一个提供RESTful API的单个微服务，现在我们希望该微服务与发现服务器集成。由此产生了两个问题。首先是需要在Eureka中发布有关安全微服务实例的信息。其次是涉及将Eureka暴露为HTTPS，并强制发现客户端使用私钥对发现服务器进行身份验证。让我们详细讨论这些问题。
- en: Registering a secure application
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册安全应用程序
- en: 'If your application is exposed over a secure SSL port, you should change two
    flags from the `EurekaInstanceConfig`—`nonSecurePortEnabled` to `false` and `securePortEnabled`
    to `true`. This forces Eureka to publish instance information that shows an explicit
    preference for secure communication. The Spring Cloud `DiscoveryClient` will always
    return a URL starting with HTTPS for a service that is configured this way, and
    the Eureka instance information will have a secure health check URL:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序通过安全SSL端口公开，您应该将`EurekaInstanceConfig`中的两个标志更改为`false`，将`nonSecurePortEnabled`更改为`false`，将`securePortEnabled`更改为`true`。这将强制Eureka发布显示对安全通信的明确偏好的实例信息。Spring
    Cloud `DiscoveryClient`将始终为以这种方式配置的服务返回以HTTPS开头的URL，并且Eureka实例信息将具有安全的健康检查URL：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Serving Eureka over HTTPS
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过HTTPS提供Eureka
- en: When the Eureka server starts with Spring Boot, it is deployed on an embedded
    Tomcat container, so the SSL configuration is the same as for the standard microservice.
    The difference is that we must take account of the client-side application, which
    establishes a secure connection with a discovery server over HTTPS. The discovery
    client should authenticate itself against the Eureka server and it should also
    verify the server's certificate. That communication process between client and
    server is called **two-way SSL** or **mutual authentication**. There is also one-way
    authentication, which is in fact the default option, where only the client validates
    the server's public key. Java applications use KeyStore and trustStore for storing
    private keys and certificates corresponding to public keys. The only difference
    between trustStore and KeyStore is what they store and for what purpose. When
    an SSL handshake between client and server is performed, a trustStore is used
    to verify the credentials, while a KeyStore is used to provide credentials. So
    in other words, a KeyStore keeps a private key and certificate for a given application,
    while a trustStore keeps the certificates that are used to identify it from the
    third party. Developers often do not pay much attention to those terms when configuring
    a secure connection, but a proper understanding of them helps you to easily understand
    what will happen next.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当Eureka服务器在Spring Boot上启动时，它部署在嵌入式Tomcat容器上，因此SSL配置与标准微服务相同。不同之处在于我们必须考虑客户端应用程序，该应用程序通过HTTPS与发现服务器建立安全连接。发现客户端应该对Eureka服务器进行身份验证，并且还应该验证服务器的证书。客户端和服务器之间的通信过程称为**双向SSL**或**相互认证**。还有单向认证，实际上是默认选项，其中只有客户端验证服务器的公钥。Java应用程序使用KeyStore和trustStore来存储与公钥对应的私钥和证书。trustStore和KeyStore之间唯一的区别是它们存储的内容和用途。在客户端和服务器之间执行SSL握手时，使用trustStore来验证凭据，而使用KeyStore来提供凭据。换句话说，KeyStore保存了给定应用程序的私钥和证书，而trustStore保存了用于识别来自第三方的证书。开发人员在配置安全连接时通常不太关注这些术语，但对它们的正确理解有助于您轻松理解接下来会发生什么。
- en: 'In a typical microservices-based architecture, there are plenty of independent
    applications and a single discovery server. Every application has its own private
    key stored in a KeyStore and a certificate corresponding to a discovery server''s
    public key in a trustStore. On the other hand, the server keeps all the certificates
    generated for the client-side applications. That''s enough theory for now. Let''s
    take a look at the following figure. It illustrates the current situation of our
    system that was used as an example in the previous chapters:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的基于微服务的架构中，有大量独立的应用程序和一个单一的发现服务器。每个应用程序都在KeyStore中存储自己的私钥，并在trustStore中存储与发现服务器的公钥对应的证书。另一方面，服务器保存了为客户端应用程序生成的所有证书。现在理论讲得够多了。让我们看一下下面的图。它说明了我们在前几章中用作示例的系统的当前情况：
- en: '![](img/4bdd8fff-ba4d-4694-82b7-5cd6658b7582.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bdd8fff-ba4d-4694-82b7-5cd6658b7582.png)'
- en: Keystore generation
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密钥库生成
- en: 'After discussing the basics regarding security in Java, we may proceed to the
    generation of private and public keys for our microservices. Just like before,
    we will use the command-line tool provided under JRE—`keytool`. Let''s begin with
    a well-known command for generating a `keystore` file with a key pair. One KeyStore
    is generated for a discovery server, and a second for the one selected microservice,
    in this particular case, for `account-service`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了Java安全基础知识之后，我们可以继续为我们的微服务生成私钥和公钥。就像以前一样，我们将使用JRE提供的命令行工具`keytool`。让我们从一个用于生成带有密钥对的`keystore`文件的众所周知的命令开始。一个KeyStore用于发现服务器，另一个用于所选的微服务，在这种特殊情况下是`account-service`：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, the self-signed certificate has to be exported from a KeyStore to a file—for
    example, with a `.cer` or `.crt` extension. You will then be prompted for the
    password you provided during the KeyStore''s generation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，必须将自签名证书从密钥库导出到文件中，例如，使用`.cer`或`.crt`扩展名。然后，您将被提示输入在生成密钥库时提供的密码：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The certificate corresponding to the public key has been extracted from the
    KeyStore, so now it can be distributed to all interested parties. The public certificate
    from `account-service` should be included in the discovery server''s trustStore
    and vice-versa:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与公钥对应的证书已从KeyStore中提取，现在可以分发给所有感兴趣的各方。`account-service`的公共证书应包含在发现服务器的trustStore中，反之亦然：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The same steps that were performed for `account-service `have to be repeated
    for each subsequent microservice that registers itself in the Eureka server. Here
    are the keytool''s commands used for generating SSL keys and certificates for
    `order-service`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`account-service`的相同步骤必须为在Eureka服务器中注册自己的每个后续微服务重复执行。以下是用于为`order-service`生成SSL密钥和证书的keytool命令：'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Configurating SSL for microservices and Eureka server
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为微服务和Eureka服务器配置SSL
- en: 'Each `keystore` file has been placed in the `src/main/resources` directory
    of every secure microservice and service discovery. The SSL configuration settings
    of every microservice are very similar to those from the example in the section
    titled *Enabling HTTPS for Spring Boot*. The only difference is the type of currently
    used KeyStore, which is now JKS instead of PKCS12\. However, there are more differences
    between the earlier sample and the service discovery configuration. First, I have
    enabled client certificate authentication by setting the `server.ssl.client-auth` property to
    `need`. This in turn requires us to provide a trustStore with the `server.ssl.trust-store`
    property. Here are the current SSL configuration settings in `application.yml`
    for `discovery-service`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`keystore`文件都放在每个安全微服务和服务发现的`src/main/resources`目录中。每个微服务的SSL配置设置与标题为*为Spring
    Boot启用HTTPS*的示例中的设置非常相似。唯一的区别是当前使用的KeyStore类型，现在是JKS而不是PKCS12。然而，之前的示例和服务发现配置之间还有更多的不同。首先，我通过将`server.ssl.client-auth`属性设置为`need`来启用了客户端证书验证。这反过来要求我们提供一个带有`server.ssl.trust-store`属性的trustStore。以下是`discovery-service`中`application.yml`的当前SSL配置设置：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you run the Eureka application with the preceding configuration and then
    try to visit its web dashboard available under `https://localhost:8761/`, you
    will probably get an error code like `SSL_ERROR_BAD_CERT_ALERT`. This error occurs
    because there is no trusted certificate imported to your web browser. For this
    purpose, we may import one of the client''s application KeyStores, from `account-service`,
    for example. But first, we need to convert it from JKS format to another format
    supported by a web browser, such as PKCS12\. Here''s the `keytool` command for
    the conversion of KeyStore from JKS to PKCS12 format:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用上述配置运行Eureka应用程序，然后尝试访问其位于`https://localhost:8761/`下的Web仪表板，您可能会收到类似`SSL_ERROR_BAD_CERT_ALERT`的错误代码。这是因为您的Web浏览器中没有导入受信任的证书。为此，我们可以导入客户端应用程序KeyStores之一，例如`account-service`。但首先，我们需要将其从JKS格式转换为Web浏览器支持的另一种格式，例如PKCS12。以下是将KeyStore从JKS转换为PKCS12格式的`keytool`命令：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'PKCS12 is supported by all the most popular web browsers, such as Google Chrome
    and Mozilla Firefox. You can import a PKCS12 KeyStore to Google Chrome by navigating
    to the section Settings *|* Show advanced settings... | HTTPS/SSL *|* Manage certificates.
    If you try to visit the Eureka web dashboard one more time, you should be authenticated
    successfully, and you will be able to see the list of registered services. However,
    there will be no application registered there. In order to provide secure communication
    between the discovery clients and the server, we need to create a `@Bean` of a `DiscoveryClientOptionalArgs` type for
    every microservice, which overwrites the discovery client''s implementation. What
    is interesting is that Eureka uses Jersey as a REST client. With `EurekaJerseyClientBuilder`,
    we may easily build a new client implementation and pass the `keystore` and `truststore`
    file''s location. The following is the code fragment from `account-service`, where
    we create a new `EurekaJerseyClient` object and set it as an argument of `DiscoveryClientOptionalArgs`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: PKCS12受到所有最流行的Web浏览器的支持，例如Google Chrome和Mozilla Firefox。您可以通过导航到设置*|*显示高级设置... | HTTPS/SSL
    *|* 管理证书来将PKCS12 KeyStore导入到Google Chrome。如果您再次尝试访问Eureka Web仪表板，您应该能够成功验证，并且能够看到注册服务的列表。但是，那里不会有应用程序注册。为了在发现客户端和服务器之间提供安全通信，我们需要为每个微服务创建一个`DiscoveryClientOptionalArgs`类型的`@Bean`，它覆盖了发现客户端的实现。有趣的是，Eureka使用Jersey作为REST客户端。通过`EurekaJerseyClientBuilder`，我们可以轻松地构建一个新的客户端实现，并传递`keystore`和`truststore`文件的位置。以下是`account-service`中的代码片段，我们在其中创建一个新的`EurekaJerseyClient`对象，并将其设置为`DiscoveryClientOptionalArgs`的参数：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A similar implementation should be provided for every microservice in our sample
    system. A sample application source code is available on GitHub ([https://github.com/piomin/sample-spring-cloud-security.git](https://github.com/piomin/sample-spring-cloud-security.git)).
    You may clone it and run all the Spring Boot applications with your IDE. If everything
    works, you should see the same list of registered services in the Eureka dashboard
    as you can see in the following screenshot. In case of any problem with the SSL
    connection, try and set the `-Djava.net.debug=ssl` VM argument during the boot
    of the application to be able to check out the full logs from the SSL handshake
    process:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例系统中，每个微服务都应提供类似的实现。GitHub上提供了示例应用程序源代码（[https://github.com/piomin/sample-spring-cloud-security.git](https://github.com/piomin/sample-spring-cloud-security.git)）。您可以克隆它并在IDE中运行所有Spring
    Boot应用程序。如果一切正常，您应该在Eureka仪表板中看到与以下截图中看到的相同的注册服务列表。如果SSL连接出现任何问题，请尝试在应用程序启动时设置`-Djava.net.debug=ssl`
    VM参数，以便能够检查SSL握手过程的完整日志：
- en: '![](img/450b5cda-04ec-455d-acc3-8fc21cf2d768.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/450b5cda-04ec-455d-acc3-8fc21cf2d768.png)'
- en: Secure configuration server
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全配置服务器
- en: There is one other key element in our architecture that should be considered
    during our discussion about security—the Spring Cloud Config Server. I would say
    that it is even more important to protect the config server than the discovery
    service. Why? Because we usually store their authentication credentials to the
    external systems, along with other data that should be hidden from unauthorized
    access and usage. There are several ways to properly secure your config server.
    You may configure an HTTP basic authentication, a secure SSL connection, encrypt/decrypt
    sensitive data, or use third-party tools such as those already described in [Chapter
    5](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml), Distributed Configuration with
    Spring Cloud Config. Let's take a closer look at some of them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论安全性时，我们架构中还有一个关键元素应该被考虑——Spring Cloud Config Server。我认为保护配置服务器比发现服务更重要。为什么？因为我们通常将它们的身份验证凭据存储到外部系统中，以及其他应该对未经授权的访问和使用进行隐藏的数据。有几种方法可以正确保护您的配置服务器。您可以配置HTTP基本身份验证，安全的SSL连接，加密/解密敏感数据，或者使用第三方工具，如已在[第5章](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml)中描述的那些，使用Spring
    Cloud Config进行分布式配置。让我们更仔细地看看其中一些。
- en: Encryption and decryption
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密和解密
- en: Before we begin, we have to download and install the **Java Cryptography Extension**
    (**JCE**) provided by Oracle. It consists of two JAR files (`local_policy.jar`
    and `US_export_policy.jar`), which need to override the existing policy files
    in the JRE lib/security directory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们必须下载并安装由Oracle提供的**Java密码扩展**（**JCE**）。它由两个JAR文件（`local_policy.jar`和`US_export_policy.jar`）组成，需要覆盖JRE
    lib/security目录中的现有策略文件。
- en: If the remote property sources stored on the config server contain encrypted
    data, their values should be prefixed with `{cipher}` and wrapped in quotes to
    designate it as a YAML file. Wrapping in quotes is not necessary for `.properties`
    files. If such a value cannot be decrypted, it is replaced by an additional value
    (usually `<n/a>`) under the same key prefixed with `invalid`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存储在配置服务器上的远程属性源包含加密数据，则它们的值应以`{cipher}`为前缀，并用引号括起来以指定它为YAML文件。对于`.properties`文件，不需要用引号括起来。如果无法解密此类值，则在相同的键下以`invalid`为前缀替换为附加值（通常为`<n/a>`）。
- en: In our last sample, we stored the passphrase used for protecting the `keystore`
    file in the application configuration settings. Keeping it there as a plain text
    file may not be the best idea, so it is the first candidate for encryption. The
    question is, how do we encrypt it? Fortunately, Spring Boot provides two RESTful
    endpoints that can help with that.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一个示例中，我们将用于保护`keystore`文件的密码短语存储在应用程序配置设置中。将其保留为纯文本文件可能不是最好的主意，因此它是加密的第一个候选项。问题是，我们如何加密它？幸运的是，Spring
    Boot提供了两个RESTful端点，可以帮助解决这个问题。
- en: 'Let''s see how it works. First, we need to start a config server instance.
    The simplest way for this is to activate the `--spring.profiles.active=native` profile,
    which launches the server with the property sources from the local classpath or
    filesystem. Now we may call two POST endpoints `/encrypt` and `/decrypt`. The
    `/encrypt` method takes our plain-text password as an argument. The result can
    be checked out using an inverse operation, `/decrypt`, which takes an encrypted
    password as a parameter:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。首先，我们需要启动一个配置服务器实例。最简单的方法是激活`--spring.profiles.active=native`配置文件，该配置文件启动具有来自本地类路径或文件系统的属性源的服务器。现在我们可以调用两个POST端点`/encrypt`和`/decrypt`。`/encrypt`方法将我们的明文密码作为参数。结果可以使用逆操作`/decrypt`进行检查，该操作将加密密码作为参数：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The encryption is done with the public key, while the decryption is done with
    the private key. Therefore, you need to provide only the public key in the server
    if you perform just the encryption. For testing purposes, we can create the KeyStore
    using `keytool`. We have already created some KeyStores before, so you will not
    have any problems with that. The generated file should be placed in the classpath
    and then in the `config-service` configuration settings using `encrypt.keyStore.*`
    properties:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是使用公钥完成的，而解密是使用私钥完成的。因此，如果只执行加密，您只需要在服务器上提供公钥。为了测试目的，我们可以使用`keytool`创建KeyStore。我们以前已经创建了一些KeyStores，所以您不会遇到任何问题。生成的文件应放置在类路径中，然后在`config-service`配置设置中使用`encrypt.keyStore.*`属性：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, if you move the configuration settings of each microservice to the config
    server, you can encrypt every password, as shown in the following sample fragment:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果将每个微服务的配置设置移动到配置服务器，您可以加密每个密码，如下面的示例片段所示：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Configuring authentication for a client and a server
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为客户端和服务器配置身份验证
- en: The implementation of authentication for Spring Cloud Config Server looks exactly
    the same as for the Eureka server. We can use an HTTP basic authentication basing
    on standard Spring security mechanisms. First, we need to make sure that the `spring-security`
    artifact is on the classpath. Then we should enable security with `security.basic.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config Server的身份验证实现与Eureka服务器完全相同。我们可以使用基于标准Spring安全机制的HTTP基本身份验证。首先，我们需要确保`spring-security`工件在类路径上。然后我们应该使用`security.basic`启用安全性。
- en: 'enabled` set to `true` and define a username and password. The sample configuration
    settings are visible in the following code fragment:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`enabled`设置为`true`并定义用户名和密码。示例配置设置在以下代码片段中可见：'
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The basic authentication must also be enabled on the client side. It can be
    realized in two different ways. The first of these is via the config server URL:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证也必须在客户端上启用。可以通过两种不同的方式实现。其中之一是通过配置服务器URL：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The second approach is based on separate `username` and `password` properties:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是基于单独的`username`和`password`属性：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you would like to set up SSL authentication, you need to follow the steps
    described in the section titled *Secure discovery*. After generating the KeyStores
    with private keys and certificates and setting the proper configuration, we may
    run the config server. Now, it is exposing its RESTful API over HTTPS. The only
    difference is in the implementation on the client side. This is because Spring
    Cloud Config uses a different HTTP client than Spring Cloud Netflix Eureka. As
    you may probably guess, it leverages `RestTemplate`, as it is entirely created
    within the Spring Cloud project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想设置SSL认证，您需要按照“安全发现”部分中描述的步骤进行操作。生成带有私钥和证书的KeyStores并设置适当的配置后，我们可以运行配置服务器。现在，它通过HTTPS公开其RESTful
    API。唯一的区别在于客户端的实现。这是因为Spring Cloud Config使用与Spring Cloud Netflix Eureka不同的HTTP客户端。您可能已经猜到，它利用了`RestTemplate`，因为它完全是在Spring
    Cloud项目中创建的。
- en: 'To force the client-side application to use two-way SSL authentication instead
    of a standard, nonsecure HTTP connection, first we should create a `@Configuration`
    bean implementing the `PropertySourceLocator` interface. There, we may build a
    custom `RestTemplate` that uses a secure HTTP connection factory:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制客户端应用程序使用双向SSL认证而不是标准的非安全HTTP连接，首先我们应该创建一个实现`PropertySourceLocator`接口的`@Configuration`
    bean。在那里，我们可以构建一个使用安全HTTP连接工厂的自定义`RestTemplate`：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, by default, this bean would not be created before the application
    tries to establish a connection with the config server. To change this behavior,
    we should also create the `spring.factories` file in `/src/main/resources/META-INF`
    and specify the custom bootstrap configuration class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，默认情况下，此bean将在应用程序尝试与配置服务器建立连接之前不会被创建。为了改变这种行为，我们还应该在`/src/main/resources/META-INF`中创建`spring.factories`文件，并指定自定义引导配置类：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Authorization with OAuth2
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth2授权
- en: We have already discussed some concepts and solutions related to authentication
    in a microservices environment. I have shown you the examples of basic and SSL
    authentication between microservices and a service discovery, and also between
    microservices and a config server. In inter-service communication, authorization
    seems to be more important then authentication, which is instead implemented on
    the edge of the system. It's worth understanding the difference between authentication
    and authorization. Simply put, authentication verifies who you are, while authorization
    verifies what you are authorized to do.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了与微服务环境中身份验证相关的一些概念和解决方案。我向您展示了微服务和服务发现之间的基本和SSL身份验证的示例，以及微服务和配置服务器之间的身份验证。在服务间通信中，授权似乎比身份验证更重要，后者是在系统边缘实现的。值得理解身份验证和授权之间的区别。简而言之，身份验证验证您是谁，而授权验证您被授权做什么。
- en: Currently the most popular authorization methods for RESTful HTTP APIs are OAuth2
    and **Java Web Tokens** (**JWT**). They may be mixed together as they are rather
    more complementary than other solutions. Spring provides support for OAuth providers
    and consumers. With Spring Boot and Spring Security OAuth2, we may quickly implement
    common security patterns, such as single sign-on, token relay, or token exchange.
    But before we dive into the details regarding those projects, as well as other
    development details, we need to acquire a basic knowledge of the preceding solution.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，RESTful HTTP API最流行的授权方法是OAuth2和Java Web Tokens（JWT）。它们可以混合在一起，因为它们比其他解决方案更具互补性。Spring提供了对OAuth提供者和消费者的支持。借助Spring
    Boot和Spring Security OAuth2，我们可以快速实现常见的安全模式，如单点登录、令牌中继或令牌交换。但在我们深入研究这些项目以及其他开发细节之前，我们需要先了解前面解决方案的基本知识。
- en: Introduction to OAuth2
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth2简介
- en: 'OAuth2 is the standard currently used by almost all major websites that allow
    you to access their resources through a shared API. It delegates user authentication
    to an independent service that stores user credentials and authorizes third-party
    applications to access shared information about users'' accounts. OAuth2 is used
    for giving your users access to data while protecting their account credentials.
    It provides flows for web, desktop, and mobile applications. The following are
    some basic terms and roles related to OAuth2:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2是目前几乎所有允许您通过共享API访问其资源的主要网站所使用的标准。它将用户身份验证委托给一个独立的服务，该服务存储用户凭据并授权第三方应用程序访问有关用户帐户的共享信息。OAuth2用于为用户提供对数据的访问权限，同时保护其帐户凭据。它提供了Web、桌面和移动应用程序的流程。以下是与OAuth2相关的一些基本术语和角色：
- en: '**Resource owner**: This role governs access to the resource. This access is
    limited by the scope of the granted authorization.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**：此角色管理对资源的访问。此访问受授予权限的范围限制。'
- en: '**Authorization grant**: This grants permission for access. There are various
    ways you may choose to confirm access—authorization code, implicit, resource-owner
    password credentials, and client credentials.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权授予**：这授予访问权限。您可以选择多种方式来确认访问权限——授权码、隐式、资源所有者密码凭据和客户端凭据。'
- en: '**Resource server**: This is a server that stores the owner’s resources that
    can be shared using a special token.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器**：这是存储所有者资源的服务器，可以使用特殊令牌共享这些资源。'
- en: '**Authorization server**: This manages the allocation of keys, tokens, and
    other temporary resource access codes. It also has to ensure that access is granted
    to the relevant user.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：这管理密钥、令牌和其他临时资源访问代码的分配。它还必须确保授予相关用户访问权限。'
- en: '**Access token**: This is a key that allows access to a resource.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问令牌**：这是允许访问资源的密钥。'
- en: 'In order to better understand what these terms and roles are in practice, take
    a look at the following diagram. It visualizes a typical flow of the authorization
    process using the OAuth protocol:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些术语和角色在实践中是什么，看一下以下图表。它展示了使用OAuth协议的授权流程的典型流程：
- en: '![](img/fb8ff8a6-c870-4ff5-a776-a7f0aedcc84a.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb8ff8a6-c870-4ff5-a776-a7f0aedcc84a.png)'
- en: Let's run through the further steps of interaction between the individual components
    listed previously. The application requests authorization from the resource owner
    in order to be able to access the requested service. The resource sends an authorization
    grant as the response, which is then sent by the application, together with its
    own identity, to the authorization server. The authorization server verifies the
    application identity's credentials and authorization grant, and then sends an
    access token back. The application requests the resource from the resource server
    using a received access token. Finally, if the access token is valid, the application
    is able to invoke the request service.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过之前列出的各个组件之间的进一步交互步骤。应用程序请求资源所有者的授权，以便能够访问所请求的服务。资源将授权授予作为响应发送，然后由应用程序与自身身份一起发送到授权服务器。授权服务器验证应用程序身份的凭据和授权授予，然后发送访问令牌。应用程序使用接收到的访问令牌从资源服务器请求资源。最后，如果访问令牌有效，应用程序可以调用请求服务。
- en: Building an authorization server
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建授权服务器
- en: 'After moving from monolithic applications to microservices, the obvious solution
    seems to be the centralization of the authorization effort by creating an authorization
    service. With Spring Boot and Spring Security, you may easily create, configure,
    and launch an authorization server. First, we need to include the following `starters`
    to the project dependencies:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从单体应用程序转移到微服务后，显而易见的解决方案似乎是通过创建授权服务来集中授权工作。使用Spring Boot和Spring Security，您可以轻松地创建、配置和启动授权服务器。首先，我们需要将以下`starters`包含到项目依赖项中：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The implementation of an authorization server pattern with Spring Boot is very
    easy. We just have to annotate the main class or the configuration class with
    `@EnableAuthorizationServer` and then provide `security.oauth2.client.client-id`
    and `security.oauth2.client.client-secret` properties in the `application.yml`
    file. Of course, this variant is as simple as possible, since it defines an in-memory
    implementation of the client details service.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Boot实现授权服务器模式非常简单。我们只需要在主类或配置类上注释`@EnableAuthorizationServer`，然后在`application.yml`文件中提供`security.oauth2.client.client-id`和`security.oauth2.client.client-secret`属性。当然，这种变体尽可能简单，因为它定义了客户端详细信息服务的内存实现。
- en: 'A sample application is available in the same repository as the previous samples
    in this chapter ([https://github.com/piomin/sample-spring-cloud-security.git](https://github.com/piomin/sample-spring-cloud-security.git)),
    but in a different branch, `oauth2` ([https://github.com/piomin/sample-spring-cloud-security/tree/oauth2](https://github.com/piomin/sample-spring-cloud-security/tree/oauth2)).
    The authorization server is available under the `auth-service` module. Here''s
    the main class of `auth-service`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的同一存储库中提供了一个示例应用程序（[https://github.com/piomin/sample-spring-cloud-security.git](https://github.com/piomin/sample-spring-cloud-security.git)），但在不同的分支`oauth2`（[https://github.com/piomin/sample-spring-cloud-security/tree/oauth2](https://github.com/piomin/sample-spring-cloud-security/tree/oauth2)）。授权服务器位于`auth-service`模块下。这是`auth-service`的主类：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the fragment of the application''s configuration settings. In addition
    to the client''s ID and secret, I have also set its default scope and enabled
    basic security for the whole project:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序配置设置的片段。除了客户端的ID和密钥外，我还设置了其默认范围，并为整个项目启用了基本安全性：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After running our authorization service, we may perform some tests. For example,
    we may call the `POST /oauth/token` method in order to create an access token
    using resource owner password credentials, just like in the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的授权服务后，我们可以执行一些测试。例如，我们可以调用`POST /oauth/token`方法，以使用资源所有者密码凭据创建访问令牌，就像以下命令一样：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We may also use an authorization code grant type by calling the `GET /oauth/authorize`
    endpoint from your web browser:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过从Web浏览器调用`GET /oauth/authorize`端点来使用授权码授予类型：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After that, you will be redirected to the approval page. You may confirm the
    action and finally get your access token. It will be sent to the callback URL
    passed in the `redirect_uri` parameter of the initial request. Here''s the sample
    response that I received after my test:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将被重定向到批准页面。您可以确认操作，最终获得访问令牌。它将被发送到初始请求的`redirect_uri`参数传递的回调URL。这是我在测试后收到的示例响应：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](img/7e5e41f0-0bd3-4691-aea9-a93b0ecf709a.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e5e41f0-0bd3-4691-aea9-a93b0ecf709a.png)'
- en: 'The same OAuth2 configuration that was provided within the `application.yml`
    file can be also implemented programatically. In order to achieve this, we should
    declare any `@Beans` that implements `AuthorizationServerConfigurer`. One of these
    is the `AuthorizationServerConfigurerAdapter` adapter, which provides empty methods,
    allowing you to create custom definitions of the following separated configurers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`application.yml`文件中提供的相同OAuth2配置也可以以编程方式实现。为了实现这一点，我们应该声明任何实现`AuthorizationServerConfigurer`的`@Beans`。其中之一是`AuthorizationServerConfigurerAdapter`适配器，它提供了空方法，允许您创建以下分离的配置器的自定义定义：
- en: '`ClientDetailsServiceConfigurer`: This defines the client details service.
    Client details can be initialized, or you can just refer to an existing store.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClientDetailsServiceConfigurer`：这定义了客户端详细信息服务。客户端详细信息可以被初始化，或者您可以直接引用现有存储。'
- en: '`AuthorizationServerSecurityConfigurer`: This defines the security constraints
    on the token endpoints `/oauth/token_key` and `/oauth/check_token`.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthorizationServerSecurityConfigurer`：这定义了对令牌端点`/oauth/token_key`和`/oauth/check_token`的安全约束。'
- en: '`AuthorizationServerEndpointsConfigurer`: This defines the authorization and
    token endpoints and the token services.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthorizationServerEndpointsConfigurer`：这定义了授权和令牌端点以及令牌服务。'
- en: 'This approach to the authorization server implementation gives us many more
    opportunities. For example, we may define more than one client with an ID and
    a secret, as shown in the following code fragment. I''ll show you some more advanced
    samples in the next part of this chapter:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器实现的这种方法为我们提供了更多的机会。例如，我们可以定义多个具有ID和密钥的客户端，如下面的代码片段所示。我将在本章的下一部分向您展示一些更高级的示例：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last thing that has to be configured for our authorization server is web
    security. In the class extending `WebSecurityConfigurerAdapter`, we have defined
    an in-memory user credentials store and permissions to access specific resources,
    such as a login page:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们授权服务器需要配置的最后一件事是Web安全。在扩展`WebSecurityConfigurerAdapter`类中，我们已经定义了一个内存用户凭据存储和访问特定资源的权限，例如登录页面：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Client configuration
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端配置
- en: Your application can use the OAuth2 client that is configured in two different
    ways. The first of these ways is through the `@EnableOAuth2Client` annotation,
    which creates a filter bean with an ID of `oauth2ClientContextFilter` that is
    responsible for storing the request and context. It also manages communication
    between your application and an authorization server. However, we will be looking
    at the second approach to OAuth2's client-side implementation, through `@EnableOAuth2Sso`.
    **Single sign-on** (**SSO**) is a well-known security pattern that allows a user
    to use one set of login credentials to access multiple applications. There are
    two features provided by this annotation—the OAuth2 client and the authentication.
    The authentication piece aligns your application with the typical Spring Security
    mechanisms, such as a form login. The client piece has the same functionality
    as that provided by `@EnableOAuth2Client`. So, we may think of `@EnableOAuth2Sso`
    as just a higher level annotation than `@EnableOAuth2Client`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序可以以两种不同的方式使用配置的OAuth2客户端。其中一种方式是通过`@EnableOAuth2Client`注解，它创建一个ID为`oauth2ClientContextFilter`的过滤器bean，负责存储请求和上下文。它还管理您的应用程序与授权服务器之间的通信。但是，我们将看看OAuth2客户端端实现的第二种方法，通过`@EnableOAuth2Sso`。**单点登录**（**SSO**）是一种众所周知的安全模式，允许用户使用一组登录凭据访问多个应用程序。此注解提供了两个功能——OAuth2客户端和认证。认证部分将您的应用程序与典型的Spring
    Security机制（例如表单登录）对齐。客户端部分具有与`@EnableOAuth2Client`提供的相同功能。因此，我们可以将`@EnableOAuth2Sso`视为比`@EnableOAuth2Client`更高级别的注解。
- en: 'In the following sample code fragment, I have annotated the class that extends
    `WebSecurityConfigurerAdapter` with `@EnableOAuth2Sso`. Thanks to this extension,
    Spring Boot configures the security filter chain that carries the OAuth2 authentication
    processor. In this case, requests to the `/login` page are permitted, while all
    other requests require authentication. The form login page path may be overridden
    with the `security.oauth2.sso.login-path` property. After overriding it there,
    we should also remember to change the path pattern inside `WebSecurityConfig`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例代码片段中，我已经使用`@EnableOAuth2Sso`注解了扩展`WebSecurityConfigurerAdapter`类的类。借助这个扩展，Spring
    Boot配置了携带OAuth2认证处理器的安全过滤器链。在这种情况下，对`/login`页面的请求是允许的，而所有其他请求都需要进行身份验证。表单登录页面路径可以使用`security.oauth2.sso.login-path`属性进行覆盖。在那里进行覆盖后，我们还应记得在`WebSecurityConfig`中更改路径模式：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are also some configuration settings that need to be set. First, we should
    disable basic authentication, because we use the form login method enabled together
    with the `@EnableOAuth2Sso` annotation. Then, we have to provide some basic OAuth2
    client properties, such as client credentials and the addresses of the HTTP API
    endpoints exposed by the authorization server:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些需要设置的配置设置。首先，我们应该禁用基本身份验证，因为我们使用启用了表单登录方法的`@EnableOAuth2Sso`注解。然后，我们必须提供一些基本的OAuth2客户端属性，例如客户端凭据和授权服务器公开的HTTP
    API端点的地址：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The last property from the fragment of the `application.yml` file is `security.oauth2.resource.userInfoUri`,
    which requires an additional endpoint on the server side. The endpoint implemented
    by `UserController` returns the `java.security.Principal` object, indicating the
    currently authenticated user:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`application.yml`文件片段中的最后一个属性是`security.oauth2.resource.userInfoUri`，它需要服务器端的一个额外端点。`UserController`实现的端点返回`java.security.Principal`对象，指示当前经过身份验证的用户：'
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, if you invoke any endpoint exposed by one of our microservices, you will
    be automatically redirected to the login page. Since we set an `autoApprove` option for
    our in-memory clients' details store, the authorization grant and access token
    are generated automatically without any interaction from the user. After providing
    your credentials in the login page, you should get the response from the requested
    resource.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您调用我们的微服务之一公开的任何端点，您将自动重定向到登录页面。由于我们为内存客户端的详细信息存储设置了`autoApprove`选项，授权授予和访问令牌将自动生成，无需用户进行任何交互。在登录页面提供您的凭据后，您应该会收到所请求资源的响应。
- en: Using the JDBC backend store
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JDBC后端存储
- en: In the previous sections, we configured an authentication server and client
    application, which grants access to the resources protected by the resource server.
    However, the whole authorization server configuration has been provided inside
    in-memory storage. Such a solution meets our needs during development, but it
    is not the most desirable approach in production mode. The target solution should
    store all the authentication credentials and tokens in the database. We may choose
    between many relational databases supported by Spring. In this case, I have decided
    to use MySQL.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的部分中，我们配置了一个认证服务器和客户端应用程序，该应用程序授予对资源服务器保护的资源的访问权限。但是，整个授权服务器配置都是在内存存储中提供的。这样的解决方案在开发过程中满足了我们的需求，但在生产模式下并不是最理想的方法。目标解决方案应该将所有认证凭据和令牌存储在数据库中。我们可以在Spring支持的许多关系数据库之间进行选择。在这种情况下，我决定使用MySQL。
- en: 'So, the first step is to start the MySQL database locally. The most comfortable
    way to achieve this is through a Docker container. In addition to starting the
    database, the following command also creates a schema and a user called `oauth2`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一步是在本地启动MySQL数据库。通过Docker容器实现这一点是最舒适的方式。除了启动数据库，以下命令还创建了一个名为`oauth2`的模式和用户：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once we have started MySQL, we now have to provide the connection settings
    on the client side. MySQL is available under the host address `192.168.99.100`
    if you run Docker on a Windows machine and on port `33306`. Data source properties
    should be set in the `application.yml` of `auth-service`. Spring Boot is also
    able to run some SQL scripts on the selected data source on the application''s
    startup. It''s good news for us because we have to create some tables on the schema
    dedicated for our OAuth2 process:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动了MySQL，现在我们必须在客户端提供连接设置。如果您在Windows机器上运行Docker，并且端口为`33306`，则MySQL可在主机地址`192.168.99.100`下使用。数据源属性应该在`auth-service`的`application.yml`中设置。Spring
    Boot还能够在应用程序启动时在所选的数据源上运行一些SQL脚本。这对我们来说是个好消息，因为我们必须在专门用于我们的OAuth2流程的模式上创建一些表：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The created schema contains some tables used for storing OAuth2 credentials
    and tokens—`oauth_client_details`, `oauth_client_token`, `oauth_access_token`,
    `oauth_refresh_token`, `oauth_code`, and `oauth_approvals`. The full script with
    SQL -creation commands is available inside `/src/main/resources/script/schema.sql`.
    There is also a second SQL script, `/src/main/resources/script/data.sql`, with
    some `insert` commands for test purposes. The most important thing is to add some
    client ID/client secret pairs:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的模式包含用于存储OAuth2凭据和令牌的一些表——`oauth_client_details`、`oauth_client_token`、`oauth_access_token`、`oauth_refresh_token`、`oauth_code`和`oauth_approvals`。具有SQL创建命令的完整脚本可在`/src/main/resources/script/schema.sql`中找到。还有第二个SQL脚本，`/src/main/resources/script/data.sql`，其中包含一些用于测试目的的`insert`命令。最重要的是添加一些客户端ID/客户端密钥对：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There are some differences in implementation between the current version of
    the authentication server and the version described in the basic example. The
    first important thing here is to set the default token storage to a database by
    providing a `JdbcTokenStore` bean with the default data source as a parameter.
    Although all tokens are now stored in a database, we still want to generate them
    in JWT format. That''s why the second bean, `JwtAccessTokenConverter`, has to
    be provided in that class. By overriding different `configure` methods inherited
    from the base class, we can set a default storage for OAuth2 client details and
    configure the authorization server to always verify the API key submitted in HTTP
    headers:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的认证服务器与基本示例中描述的版本之间存在一些实现上的差异。这里的第一件重要的事情是将默认的令牌存储设置为数据库，通过提供一个带有默认数据源参数的`JdbcTokenStore`
    bean来实现。尽管所有令牌现在都存储在数据库中，我们仍然希望以JWT格式生成它们。这就是为什么在该类中必须提供第二个bean，`JwtAccessTokenConverter`。通过覆盖从基类继承的不同`configure`方法，我们可以为OAuth2客户端详细信息设置默认存储，并配置授权服务器始终验证HTTP头中提交的API密钥：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The Spring application provides a custom authentication mechanism. To use it
    in the application, we must implement the `UserDetailsService` interface and override
    its `loadUserByUsername` method. In our example application, user credentials
    and authorities are also stored in the database, so we inject the `UserRepository`
    bean to the custom `UserDetailsService` class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Spring应用程序提供了自定义的身份验证机制。要在应用程序中使用它，我们必须实现`UserDetailsService`接口并覆盖其`loadUserByUsername`方法。在我们的示例应用程序中，用户凭据和权限也存储在数据库中，因此我们将`UserRepository`
    bean注入到自定义的`UserDetailsService`类中：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Inter-service authorization
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务间授权
- en: 'Inter-service communication in our sample is realized using Feign clients.
    Here''s one of the chosen implementations—in this case, from `order-service`—which
    calls the endpoint from `customer-service`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，服务之间的通信是使用Feign客户端实现的。这是所选实现之一——在这种情况下，来自`order-service`的实现——调用了`customer-service`的端点：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the same way as with the other services, all the available methods from
    `customer-service` are protected by the preauthorization mechanism based on the
    OAuth token scope. It allows us to annotate every method with `@PreAuthorize`,
    defining the required scope:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他服务一样，`customer-service`中的所有可用方法都受到基于OAuth令牌范围的预授权机制的保护。这使我们能够使用`@PreAuthorize`为每个方法进行注释，定义所需的范围：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Preauthorization is disabled by default. To enable it for API methods, we should
    use the `@EnableGlobalMethodSecurity` annotation. We should also indicate that
    such a preauthorization will be based on the OAuth2 token scope:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 预授权默认情况下是禁用的。要为API方法启用它，我们应该使用`@EnableGlobalMethodSecurity`注解。我们还应该指出这样的预授权将基于OAuth2令牌范围：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you call the account service endpoint via the Feign client, you get the
    following exception:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过Feign客户端调用帐户服务端点，则会收到以下异常：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Why does such an exception occur? Of course, `customer-service` is protected
    with a OAuth2 token authorization, but the Feign client does not send an authorization
    token in the request header. That approach may be customized by defining a custom
    configuration class for the Feign client. It allows us to declare a request interceptor.
    In that case, we can use an implementation for OAuth2 provided by `OAuth2FeignRequestInterceptor`
    from the Spring Cloud OAuth2 library. For test purposes, I decided to use a resource
    owner password grant type:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这样的异常？当然，`customer-service`受到OAuth2令牌授权的保护，但Feign客户端在请求头中没有发送授权令牌。这种方法可以通过为Feign客户端定义自定义配置类来进行定制。它允许我们声明一个请求拦截器。在这种情况下，我们可以使用Spring
    Cloud OAuth2库提供的`OAuth2FeignRequestInterceptor`来实现OAuth2的实现。为了测试目的，我决定使用资源所有者密码授权类型：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we may test the implemented solution. This time, we will create a
    JUnit automated test instead of clicking it in a web browser or sending requests
    using other tools. The test method is shown in the following code snippet. We
    use `OAuth2RestTemplate` with `ResourceOwnerPasswordResourceDetails` to perform
    a resource owner credentials grant operation and call the `POST /` API method
    from `order-service` with an OAuth2 token sent in the request header. Of course,
    before running that test, you have to start all the microservices, as well as
    the discovery and authorization server:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以测试已实施的解决方案。这次，我们将创建一个JUnit自动化测试，而不是在Web浏览器中点击或使用其他工具发送请求。测试方法如下所示。我们使用`OAuth2RestTemplate`和`ResourceOwnerPasswordResourceDetails`执行资源所有者凭据授予操作，并使用请求头中发送的OAuth2令牌调用`order-service`中的`POST
    /` API方法。当然，在运行该测试之前，您必须启动所有微服务，以及发现和授权服务器：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Enabling SSO on the API gateway
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在API网关上启用SSO
- en: 'You may enable the single sign-on feature on the API gateway just by annotating
    the main class with `@EnableOAuth2Sso`. Indeed, that is the best choice for your
    microservices architecture to force Zuul to generate or get the access token for
    the currently authenticated user:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在主类上注释`@EnableOAuth2Sso`来在API网关上启用单点登录功能。实际上，这是您的微服务架构的最佳选择，以强制Zuul为当前经过身份验证的用户生成或获取访问令牌：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: By including `@EnableOAuth2Sso`, you trigger an auto-configuration available
    for a ZuulFilter. The filter is responsible for extracting an access token from
    the currently authenticated user, and then putting it into the request header
    forwarded to the microservices hidden behind the gateway. If `@EnableResourceServer`
    is activated for those services, they will receive the expected token in the `Authorization`
    HTTP header. The authorization behavior downstream of an `@EnableZuulProxy` may
    be controlled by declaring `proxy.auth.*` properties.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含`@EnableOAuth2Sso`，您触发了ZuulFilter可用的自动配置。该过滤器负责从当前经过身份验证的用户中提取访问令牌，然后将其放入请求头中，转发到网关后面隐藏的微服务。如果为这些服务激活了`@EnableResourceServer`，它们将在`Authorization`
    HTTP头中接收到预期的令牌。在`@EnableZuulProxy`下游的授权行为可以通过声明`proxy.auth.*`属性来控制。
- en: 'When using a gateway in your architecture, you may hide an authorization server
    behind it. In this case, you should provide the additional route in Zuul''s configuration
    settings—for example, `uaa`. Then, all the messages exchanged between OAuth2 clients
    and the server go through the gateway. Here''s the proper configuration in the
    gateway''s `application.yml` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构中使用网关时，您可以将授权服务器隐藏在其后面。在这种情况下，您应该在Zuul的配置设置中提供额外的路由，例如`uaa`。然后，OAuth2客户端和服务器之间交换的所有消息都通过网关进行。以下是网关的`application.yml`文件中的正确配置：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There wouldn't have been anything wrong if I had included a security section
    in every single chapter from part two of this book. But I have decided to create
    a dedicated chapter on this subject in order to show you a step-by-step process
    of how to secure the key elements of a microservices-based architecture. The topics
    related to security are usually more advanced than other topics, so I took a bit
    more time to explain some of the basic concepts around the field. I have shown
    you samples illustrating a two-way SSL authentication, encryption/decryption of
    sensitive data, Spring Security authentication, and OAuth2 authorization with
    JWT tokens. I will leave it to you to decide which of them should be used in your
    system architecture to provide your desired level of security.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在本书第二部分的每一章中都包含了一个安全部分，那也不会有什么问题。但我决定在这个主题上创建一个专门的章节，以便向您展示如何保护基于微服务的架构的关键元素的逐步过程。与其他主题相比，与安全相关的主题通常更加高级，因此我花了更多时间来解释该领域的一些基本概念。我向您展示了一些示例，说明了双向SSL身份验证、敏感数据的加密/解密、Spring安全认证和OAuth2授权与JWT令牌。我将留给您决定在系统架构中应该使用哪些内容，以提供您期望的安全级别。
- en: After reading this chapter, you should be able to set up both the basic and
    the more advanced security configurations for your application. You should also be
    able to secure every component of your system's architecture. Of course, we have
    discussed only some of the possible solutions and frameworks. For example, you
    don't have to only rely on Spring as an authorization server provider. We may
    use third-party tools, such as Keycloak, which can act as an authorization and
    authentication server in a microservices-based system. It can also easily be integrated
    with Spring Boot applications. It provides support for all the most popular protocols,
    such as OAuth2, OpenId Connect, and SAML. So, in fact, Keycloak is a very powerful
    tool, and should be treated as an alternative to the Spring Authorization Server,
    especially for large, corporate systems and other more advanced use cases.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您应该能够为您的应用程序设置基本和更高级的安全配置。您还应该能够保护系统架构的每个组件。当然，我们只讨论了一些可能的解决方案和框架。例如，您不必仅依赖Spring作为授权服务器提供程序。我们可以使用第三方工具，如Keycloak，在基于微服务的系统中充当授权和认证服务器。它还可以轻松集成Spring
    Boot应用程序。它提供对所有最流行的协议的支持，如OAuth2、OpenId Connect和SAML。因此，实际上，Keycloak是一个非常强大的工具，应该被视为Spring授权服务器的替代品，特别是对于大型企业系统和其他更高级的用例。
- en: In the next chapter we will discuss the different strategies of microservices
    testing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论微服务测试的不同策略。
