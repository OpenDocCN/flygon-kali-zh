- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1 – Overview of OOP in .NET Core and C#
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 - .NET Core和C#中的面向对象编程概述
- en: '**What do the terms late and early binding refer to?**'
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 晚期和早期绑定这两个术语是指什么？
- en: Early binding is established when the source code is compiled while late binding
    is established while the component is running.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 早期绑定是在源代码编译时建立的，而晚期绑定是在组件运行时建立的。
- en: '**Does C# support multiple inheritance?**'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#支持多重继承吗？
- en: No. The reasoning is that multiple inheritance leads to more complex source
    code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持。原因是多重继承会导致源代码更复杂。
- en: '**In C#, what level of encapsulation could be used to prevent access to a class
    from outside of the library?**'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C#中，可以使用什么封装级别防止类被库外访问？
- en: The `internal` access modifier can be used to limit the visibility of a class
    to only within the library.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`internal`访问修饰符可用于将类的可见性限制为仅在库内部。'
- en: '**What is the difference between aggregation and composition?**'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 聚合和组合之间有什么区别？
- en: Both are types of association and the easiest way to differentiate the two is
    by whether or not the classes involved can exist without being associated. In
    a composition association, the classes involved have a tight life cycle dependency.
    This implies that, when one class is deleted, the associated classes are also
    deleted.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都是关联的类型，最容易区分的方法是涉及的类是否可以在没有关联的情况下存在。在组合关联中，涉及的类具有紧密的生命周期依赖性。这意味着当一个类被删除时，相关的类也被删除。
- en: '**Can interfaces contain properties? (This is a bit of a tricky question)**'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口可以包含属性吗？（这是一个有点棘手的问题）
- en: It is possible for an interface to define properties, but as an interface does
    have a body...
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以定义属性，但是接口没有主体...
- en: '**Do dogs eat fish?**'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 狗吃鱼吗？
- en: Dogs are lovely but they eat most things they can get in their mouth.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 狗很可爱，但它们吃它们能够放进嘴里的大多数东西。
- en: Chapter 2 – Modern Software Design Patterns and Principles
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 - 现代软件设计模式和原则
- en: '**In SOLID, what does the S stand for? What is meant by a responsibility?**'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SOLID中，S代表什么？责任是什么意思？
- en: Single Responsibility Principle. Responsibility can be viewed as a reason for
    a change.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单一责任原则。责任可以被视为变更的原因。
- en: '**What SDLC method is built around cycles: Waterfall or Agile?**'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 围绕循环构建的SDLC方法是瀑布还是敏捷？
- en: Agile is built around the concept of the development process being conducted
    in a collection of cycles.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷是围绕开发过程在一系列周期中进行的概念构建的。
- en: '**Is the decorator pattern a creational or structural pattern?**'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 装饰者模式是创建模式还是结构模式？
- en: The decorator pattern is a structural pattern that allows functionality to be
    divided between classes and is particularly useful to enhance classes at runtime.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式是一种结构模式，允许功能在类之间分配，并且特别适用于在运行时增强类。
- en: '**What does pub-sub integration stand for?**'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: pub-sub集成代表什么？
- en: Publish-Subscribe is a useful pattern where processes publish messages and other
    processes subscribe to receive the messages.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅是一种有用的模式，其中进程发布消息，其他进程订阅以接收消息。
- en: Chapter 3 – Implementing Design Patterns – Basics Part 1
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 - 实现设计模式 - 基础部分1
- en: '**In developing software for an organization, why is it sometimes difficult
    to determine requirements?**'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为组织开发软件时，有时很难确定需求的原因是什么？
- en: There are many challenges to developing software for an organization. An example
    would be that changes in the organization's industry could cause the current requirements
    to need to be altered.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为组织开发软件存在许多挑战。例如，组织行业的变化可能导致当前需求需要进行修改。
- en: '**What are two advantages and disadvantages of waterfall software development
    versus agile software development?**'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 瀑布式软件开发与敏捷软件开发相比的两个优点和缺点是什么？
- en: Waterfall software development provides an advantage over agile software development
    as it is simpler to understand and implement. In some situations, where the complexity
    and size of the project is smaller, Waterfall Software Development could be a
    better option over Agile Software Development. Waterfall Software Development,
    though, does not handle change well and, by having a larger scope, has more chance
    of requirements changing before the project is completed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 瀑布式软件开发相对于敏捷软件开发提供了优势，因为它更容易理解和实现。在某些情况下，当项目的复杂性和规模较小时，瀑布式软件开发可能是比敏捷式软件开发更好的选择。然而，瀑布式软件开发不擅长处理变化，并且由于范围更大，项目完成之前需求变化的可能性更大。
- en: '**How does dependency injection help when writing unit tests?**'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写单元测试时，依赖注入如何帮助？
- en: By injecting dependencies into a class, a class becomes easier to test as the
    dependencies are clearly known and more easily accessible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将依赖项注入类，类变得更容易测试，因为依赖项是明确已知且更容易访问的。
- en: '**Why is the following statement false? With TDD, you no longer need people
    to test a new software deployment.**'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么以下陈述是错误的？使用TDD，您不再需要人员测试新软件部署。
- en: Test-Driven Development helps to improve the quality of a solution by building
    a clear testing strategy into the software development life cycle. The tests defined,
    though, might not be complete, so there is still the need for additional resources
    to validate the delivered software.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发通过将清晰的测试策略纳入软件开发生命周期中来提高解决方案的质量。然而，定义的测试可能不完整，因此仍然需要额外的资源来验证交付的软件。
- en: Chapter 4 – Implementing Design Patterns – Basics Part 2
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 - 实现设计模式 - 基础部分2
- en: '**Provide an example to show why using a singleton would not be a good mechanism
    for limiting access to a shared resource?**'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个示例，说明为什么使用单例不是限制对共享资源访问的好机制？
- en: A singleton intentionally creates a bottleneck in an application. It is also
    one of the first patterns developers learn to use and, because of this, it is
    often used in situations where limiting access to the shared resource is not required.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 单例有意在应用程序中创建瓶颈。它也是开发人员学习使用的第一个模式之一，因此通常在不需要限制对共享资源访问的情况下使用。
- en: '**Is the following statement true? Why or why not? `ConcurrentDictionary` prevents
    items in the collection from being updated by more than one thread at a time.**'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下陈述是否正确？为什么？`ConcurrentDictionary` 防止集合中的项目被多个线程同时更新。
- en: For many C# developers, realizing that `ConcurrentDictionary` does not prevent
    items in the collection from being updated by more than one thread at a time is
    a painful lesson. `ConcurrentDictionary` protects a shared dictionary from being
    accessed and modified concurrently.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多 C# 开发人员来说，意识到 `ConcurrentDictionary` 不能防止集合中的项目被多个线程同时更新是一个痛苦的教训。`ConcurrentDictionary`
    保护共享字典免受同时访问和修改。
- en: '**What is a race condition and why should it be avoided?**'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是竞争条件，为什么应该避免？
- en: A race condition is when the order of processing of multiple threads can culminate
    in different results.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件是指多个线程的处理顺序可能导致不同的结果。
- en: '**How does the factory pattern help simplify code?**'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂模式如何帮助简化代码？
- en: The factory pattern is an effective way to decouple the creation of objects
    within an application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是在应用程序内部创建对象的有效方式。
- en: '**Do .NET Core applications require third-party IoC containers?**'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Core 应用程序需要第三方 IoC 容器吗？
- en: .NET Core has a powerful Inversion of Control built into the framework. It can
    be enhanced when required by other IoC containers, but is not required.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 具有强大的控制反转内置到框架中。在需要时可以通过其他 IoC 容器进行增强，但不是必需的。
- en: Chapter 5 – Implementing Design Patterns – .NET Core
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 - 实现设计模式 - .NET Core
- en: '**If you are not sure what type of service lifetime to use, what type is it
    best to register a class as? Why?**'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不确定要使用哪种类型的服务生命周期，最好将类注册为哪种类型？为什么？
- en: Transient lifetime services are created each time they are requested. The majority
    of classes should be lightweight, stateless services, so this is the best service
    lifetime to use.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 瞬态生命周期服务在每次请求时创建。大多数类应该是轻量级、无状态的服务，因此这是最好的服务生命周期。
- en: '**In .NET Core ASP .NET solutions, a scope is defined per web request or per
    session?**'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 .NET Core ASP .NET 解决方案中，范围是定义为每个 Web 请求还是每个会话？
- en: A scope is per web request (connection).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个范围是每个 Web 请求（连接）。
- en: '**Does registering a class as a Singleton in the .NET Core DI framework make
    it thread-safe?**'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 .NET Core DI 框架中将类注册为单例会使其线程安全吗？
- en: No, the framework will provide the same instance for subsequent requests, but
    does not make a class thread-safe.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不，框架将为后续请求提供相同的实例，但不会使类线程安全。
- en: '**Is it true that the .NET Core DI framework can only be replaced with other
    Microsoft-supplied DI frameworks?**'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Core DI 框架只能被其他由微软提供的 DI 框架替换是真的吗？
- en: Yes, there are many DI frameworks that can be used instead of the native DI
    framework.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，有许多 DI 框架可以用来替代原生 DI 框架。
- en: Chapter 6 – Implementing Design Patterns for Web Applications – Part 1
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 - 实现 Web 应用程序的设计模式 - 第1部分
- en: '**What is a web application?**'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Web 应用程序？
- en: It's a program that uses a web browser and can be accessible from anywhere if
    available over public network. This works on a client/server architecture and
    serves the client by taking an HTTP request and providing an HTTP response.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 Web 浏览器的程序，如果在公共网络上可用，可以从任何地方访问。它基于客户端/服务器架构，通过接收 HTTP 请求并提供 HTTP 响应来为客户端提供服务。
- en: '**Craft a web application of your choice and depict a pictorial view of the
    working of web application.**'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作您选择的 Web 应用程序，并描述 Web 应用程序的工作的图像。
- en: Refer to the FlixOne application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 参考 FlixOne 应用程序。
- en: '**What is Inversion of Control?**'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是控制反转？
- en: '**Inversion of Control** (**IoC**) is a container to invert or delegate the
    control. It is based on the DI framework. .NET Core has a built-in IoC container.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 控制反转（IoC）是一个容器，用于反转或委托控制。它基于 DI 框架。.NET Core 具有内置的 IoC 容器。
- en: '**What is the UI/Architectural pattern? Which pattern you would like to use
    and why?**'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 UI/架构模式？您想使用哪种模式，为什么？
- en: The UI Architectural pattern is designed to make a robust user interface to
    give user a better experience of the application. From the developer's point of
    view of point, MVC, MVP, and MVVM are the popular patterns.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: UI 架构模式旨在创建强大的用户界面，以使用户更好地体验应用程序。从开发人员的角度来看，MVC、MVP 和 MVVM 是流行的模式。
- en: Chapter 7 – Implementing Design Patterns for Web Applications – Part 2
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 - 实现 Web 应用程序的设计模式 - 第2部分
- en: '**What are authentication and authorization?**'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证和授权是什么？
- en: Authentication is a process in which a system verifies or identifies the incoming
    requests through credentials (generally a user ID and password). If the system
    finds that the provided credentials are wrong, then it notifies the user (generally
    via a message on the GUI screen) and terminates the authorization process.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是一个系统通过凭据（通常是用户 ID 和密码）验证或识别传入请求的过程。如果系统发现提供的凭据错误，那么它会通知用户（通常通过 GUI 屏幕上的消息）并终止授权过程。
- en: Authorization always comes after authentication. This is a process that allows
    the authenticated user who raised the request to access resources or data after
    verifying that they have access to the specific resources or data
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 授权始终在认证之后。这是一个过程，允许经过验证的用户在验证他们对特定资源或数据的访问权限后访问资源或数据。
- en: '**Is it safe to use authentication at the first level of a request and then
    allow incoming requests for restricted areas?**'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在请求的第一级使用认证，然后允许进入受限区域的传入请求安全吗？
- en: This is not always safe. As developers, we should take all necessary steps to
    make our application more secure. After first a level request, the authentication,
    the system should also check resource-level permissions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不总是安全的。作为开发人员，我们应该采取一切必要的步骤，使我们的应用程序更安全。在第一级请求认证之后，系统还应检查资源级别的权限。
- en: '**How you will prove that authorization always comes after authentication?**'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将如何证明授权始终在认证之后？
- en: In a simple scenario of a web application, it first validates the user by asking
    for login credentials and then authorizes the user as per role to access specific
    resource.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序的简单场景中，它首先通过请求登录凭据来验证用户，然后根据角色授权用户访问特定资源。
- en: '**What is Test-Driven Development and why do developers care about it?**'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是测试驱动开发，为什么开发人员关心它？
- en: Test-Driven Development is a way to make sure that code is tested; it is like
    testing code by writing code. TDD is also known as Red/Blue/Green concepts. Developers
    should follow it to make their code/program work without any error.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发是一种确保代码经过测试的方法；这就像通过编写代码来测试代码。TDD也被称为红/蓝/绿概念。开发人员应该遵循它，使他们的代码/程序在没有任何错误的情况下工作。
- en: '**Define TDD Katas. How does it help us to improve our TDD approach?**'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义TDD Katas。它如何帮助我们改进我们的TDD方法？
- en: 'TDD Katas are small scenarios or problems that help to learn to code by practice.
    You can take the example of Fizz Buzz Kata, where developers should apply coding
    to learn and practice TDD. If you want to practice TDD Katas, refer to this repository:
    [https://github.com/garora/TDD-Katas.](https://github.com/garora/TDD-Katas)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: TDD Katas是帮助通过实践学习编码的小场景或问题。您可以参考Fizz Buzz Kata的例子，开发人员应该应用编码来学习和练习TDD。如果您想练习TDD
    Katas，请参考此存储库：[https://github.com/garora/TDD-Katas.](https://github.com/garora/TDD-Katas)
- en: Chapter 8 – Concurrent Programming in .NET Core
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 – .NET Core中的并发编程
- en: '**What is concurrent programming?**'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是并发编程？
- en: Whenever things/tasks are happening at the same time, we say that tasks are
    happening concurrently. In our programming language, whenever any parts of our
    program run at the same time, it is concurrent programming.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每当事情/任务同时发生时，我们说任务是同时发生的。在我们的编程语言中，每当程序的任何部分同时运行时，它就是并发编程。
- en: '**How does true parallelism happen?**'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真正的并行是如何发生的？
- en: True parallelism is not possible on a single CPU machine because tasks are not
    switchable, as it has a single core. It only happens on a machine with multiple
    CPUs (multiple cores).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个CPU机器上不可能实现真正的并行，因为任务不可切换，它只在具有多个CPU（多个核心）的机器上发生。
- en: '**What is a race condition?**'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是竞争条件？
- en: The potential for more than one thread to access the same shared data and update
    it with unpredictable results can be referred to as a race condition.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 更多线程可以访问相同的共享数据并以不可预测的结果进行更新的潜力可以称为竞争条件。
- en: '**Why should we use `ConcurrentDictionary`?**'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该使用`ConcurrentDictionary`？
- en: A concurrent dictionary is a thread-safe collection class and stores key-value
    pairs. This class has implementation for a lock statement and provides a thread-safe
    class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 并发字典是一个线程安全的集合类，它存储键值对。这个类有锁语句的实现，并提供了一个线程安全的类。
- en: Chapter 9 – Functional Programming Practices – an Approach
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 – 函数式编程实践 – 一种方法
- en: '**What is functional programming?**'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: 'Functional programming is an approach to symbolic computation in the same way
    as we solve mathematical problems. Any functional programming is based on mathematical
    functions. Any functional programming style language works on solutions with two
    terms: what to solve and how to solve?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种符号计算的方法，就像我们解决数学问题一样。任何函数式编程都是基于数学函数的。任何函数式编程风格的语言都是通过两个术语来解决问题的：要解决什么和如何解决？
- en: '**What is referential transparency in functional programming?**'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式编程中的引用透明度是什么？
- en: In functional programs, once we define the variables, they do not change their
    value throughout the program. As functional programs do not have assignment statements,
    if we need to store value, there is no alternative; instead, we define new variables.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式程序中，一旦我们定义了变量，它们在整个程序中不会改变其值。由于函数式程序没有赋值语句，如果我们需要存储值，就没有其他选择；相反，我们定义新变量。
- en: '**What is `Pure` function?**'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`Pure`函数？
- en: 'The `Pure` functions are the ones that strengthen functional programming by
    saying that they are pure. These functions work on two conditions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pure`函数是通过说它们是纯净的来加强函数式编程的函数。这些函数满足两个条件：'
- en: The end result/output will always remain the same for the provided parameters.
  id: totrans-89
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的参数的最终结果/输出将始终保持不变。
- en: These will not impact the behavior of the program or the execution path of the
    application, even if they are being called a hundred times.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使调用了一百次，这些都不会影响程序的行为或应用程序的执行路径。
- en: Chapter 10 – Reactive Programming Patterns and Techniques
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 – 响应式编程模式和技术
- en: '**What is a stream?**'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是流？
- en: 'A sequence of events is called a stream. A stream can emit three things: a
    value, an error, and a signal for completion.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列事件称为流。流可以发出三种东西：一个值，一个错误和一个完成信号。
- en: '**What are reactive properties?**'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是响应式属性？
- en: Reactive properties are binding properties that react when an event triggers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件触发时，响应式属性是会做出反应的绑定属性。
- en: '**What is a reactive system?**'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是响应式系统？
- en: 'On the basis of the Reactive Manifesto, we can conclude that reactive systems
    are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 根据响应式宣言，我们可以得出结论，响应式系统如下：
- en: '**Responsive**: Reactive systems are event-based design systems because of
    this design approach; these systems are quick to respond to any request in a short
    time.'
  id: totrans-98
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式**：响应式系统是基于事件的设计系统，因此这种设计方法使得这些系统能够快速响应任何请求。'
- en: '**Scalable**: Reactive systems are reactive in nature. These systems can react
    to change the scalability rate by expanding or reducing the allocated resources.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展**：响应式系统具有响应性。这些系统可以通过扩展或减少分配的资源来对可扩展性进行调整。'
- en: '**Resilient**: A resilient system is one that would not stop, even if there
    is any failure/exception. Reactive systems are designed in such a way that, despite
    any exception or failure, the system will never die; it remains working.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：弹性系统是指即使出现任何故障/异常，也不会停止的系统。响应式系统是以这样的方式设计的，即使出现任何异常或故障，系统也不会死掉；它仍然在工作。'
- en: '**Message-based**: Any data of an item represents a message and can be sent
    to a specific destination. When a message or data has arrived at a given state,
    an event that is a signal is emitted to notify that the message has been received. Reactive
    systems rely on this message-passing.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于消息**：任何项目的数据都代表一条消息，可以发送到特定的目的地。当消息或数据到达给定状态时，会发出一个信号事件来通知消息已经被接收。响应式系统依赖于这种消息传递。'
- en: '**What is meant by merging two reactive streams?**'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合并两个响应流是什么意思？**'
- en: Merging two reactive steams is actually combining elements of two similar or
    different reactive streams into a new reactive stream. For example, if you have
    `stream1`, and `stream2` then `stream3 = stream1.merge(stream2)`, but the sequence
    of `stream3` would not be in order.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 合并两个响应流实际上是将两个相似或不同的响应流的元素组合成一个新的响应流。例如，如果你有`stream1`和`stream2`，那么`stream3 =
    stream1.merge(stream2)`，但`stream3`的顺序不会按顺序排列。
- en: '**What is the MVVM pattern?**'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是MVVM模式？**'
- en: '**Model-View-ViewModel** (**MVVM**) is one of the variations of **Model-View-Controller** (**MVC**)
    to meet the modern UI development approach, where UI development is the core responsibility
    of designer/UI-developers, rather than application developers. In this approach
    of development, a designer who is more of a graphical enthusiast and is focused
    on making the user interface more attractive may or may not bother about the development
    part of the application. Generally, designers (UI persons) use various tools to
    make the user interface more attractive. The MVVM is defined as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-视图模型**（MVVM）是**模型-视图-控制器**（MVC）的变体之一，以满足现代UI开发方法，其中UI开发是设计师/UI开发人员的核心责任，而不是应用程序开发人员。在这种开发方法中，一个更注重图形的设计师专注于使用户界面更具吸引力，可能并不关心应用程序的开发部分。通常，设计师（UI人员）使用各种工具使用户界面更具吸引力。MVVM的定义如下：'
- en: '**Model**: This is also called as a domain object and it holds data only; there
    is no business logic, validations, and so on.'
  id: totrans-106
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：也称为领域对象，它只保存数据；没有业务逻辑、验证等。'
- en: '**View**: This is a representation of data for the end user.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这是为最终用户表示数据。'
- en: '**View Model**: This separates View and Model; its main responsibility is to
    serve end users better stuff.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图模型**：这将视图和模型分开；它的主要责任是为最终用户提供更好的东西。'
- en: Chapter 11 – Advanced Database Design and Application Techniques
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 - 高级数据库设计和应用技术
- en: '**What is a ledger-style database?**'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是分类账式数据库？**'
- en: This database is meant to insert operations only; there are no updates. Then,
    you create a view that aggregates the inserts together.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据库只用于插入操作；没有更新。然后，你创建一个视图，将插入聚合在一起。
- en: '**What is CQRS?**'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是CQRS？**'
- en: Command Query Responsibility Segregation is a pattern that segregates the responsibilities
    between Query (to inserts) and Commands (to updates).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 命令查询责任分离是一种将查询（插入）和命令（更新）之间的责任分离的模式。
- en: '**When should you use CQRS?**'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**何时使用CQRS？**'
- en: CQRS can be a good pattern to apply for task-based or event-driven systems,
    especially when the solution is composed of multiple applications and not a single
    monolithic website or application. It is **a pattern and not an architecture**,
    so it should be applied in specific cases and not in all business scenarios
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS可以是一个适用于基于任务或事件驱动系统的良好模式，特别是当解决方案由多个应用程序组成而不是单个单片网站或应用程序时。它是**一种模式而不是一种架构**，因此应该在特定情况下应用，而不是在所有业务场景中应用。
- en: Chapter 12 – Coding for the Cloud
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 - 云编码
- en: '**Is this a true statement? Most patterns have been developed recently and
    only apply to cloud-based applications.**'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这是一个真实的陈述吗？大多数模式是最近开发的，只适用于基于云的应用。**'
- en: No, this is not true. Patterns have been evolving as software development changes
    but many of the core patterns have existed for decades.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这不是真的。随着软件开发的变化，模式一直在不断发展，但许多核心模式已存在几十年。
- en: '**What does an ESB stand for? What type of architecture can it be used in:
    EDA, SOA, or monolithic?**'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ESB代表什么？它可以用于哪种架构：EDA、SOA还是单片？**'
- en: It stands for Enterprise Service Bus. It can be used effectively in event-driven
    architecture and service-oriented architecture.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它代表企业服务总线。它可以有效地用于事件驱动架构和面向服务的架构。
- en: '**Is queue-based load leveling is primarily used for DevOps, scalability, or
    availability?**'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于队列的负载平衡主要用于DevOps、可伸缩性还是可用性？**'
- en: Availability. Queue-based load leveling primarily used to handle large fluctuations in
    load by acting as a buffer to reduce the chance of an application becoming unavailable.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性。基于队列的负载平衡主要用于处理负载的大幅波动，作为缓冲以减少应用程序变得不可用的机会。
- en: '**What are the benefits of CI/CD? Would it be more beneficial in a large number
    of globally dispersed teams or a single small team of collocated developers?**'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CI/CD的好处是什么？在全球分散团队的大量还是单个小型团队的共同开发人员中更有益？**'
- en: In general, CI/CD helps to identify issues early in the development life cycle
    by frequently performing merges and deployments. Larger, more complex solutions,
    tend to show the benefits more than smaller, simpler solutions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，CI/CD有助于通过频繁执行合并和部署来及早识别开发生命周期中的问题。更大、更复杂的解决方案往往比更小、更简单的解决方案更有益。
- en: '**In a website following static content hosting, does a browser retrieve images
    and static content directly through a CDN or does the web application retrieve
    the information on behalf of the browser?**'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在遵循静态内容托管的网站中，浏览器是直接通过CDN检索图像和静态内容，还是Web应用程序代表浏览器检索信息？**'
- en: A content delivery network can be used to improve performance and availability
    by caching static resources in multiple data centers, allowing for a browser to
    retrieve content directly from the closest data center.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 内容交付网络可以通过在多个数据中心缓存静态资源来提高性能和可用性，从而使浏览器可以直接从最近的数据中心检索内容。
- en: Appendix A – Miscellaneous Best Practices
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A - 杂项最佳实践
- en: '**What is a practice? Give a few examples from our routine/daily life.**'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是实践？从我们的日常生活中举几个例子。**'
- en: 'A practice may be one or more routine activities. To learn to drive, we should
    practice our driving. A practice is an activity that is not required to be memorized.
    There are a lot of examples of practice from our daily life: eating while watching
    TV shows, and so on. It does not break your rhythm to eat anything while you''re
    watching your favorite TV show.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 练习可能是一个或多个日常活动。要学会开车，我们应该练习驾驶。练习是一种不需要记忆的活动。我们日常生活中有很多练习的例子：一边看电视节目一边吃饭，等等。在你观看最喜欢的电视节目时吃东西并不会打乱你的节奏。
- en: '**We can achieve a specific coding skill with practice. Explain this.**'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们可以通过练习来掌握特定的编码技能。解释一下。**'
- en: Yes, we can achieve a specific coding skill with practice. The practice needs
    attention and consistency. For example, you want to learn Test-Driven Development.
    To do so, you need to learn it first. You can learn it by practicing TDD-Katas.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以通过练习来掌握特定的编码技能。练习需要注意力和一贯性。例如，你想学习测试驱动开发。为了做到这一点，你需要先学会它。你可以通过练习TDD-Katas来学习它。
- en: '**What is Test-Driven Development and how does it help developers to practice?**'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**什么是测试驱动开发，它如何帮助开发者练习？**'
- en: Test-Driven Development is a way to make sure that code is tested; it is like
    we are testing code by writing code. TDD is also known as Red/Blue/Green concepts.
    Developers should follow it to make their code/program work without any error.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发是一种确保代码经过测试的方法；就好像我们通过编写代码来测试代码一样。TDD也被称为红/蓝/绿概念。开发者应该遵循它，使他们的代码/程序能够在没有任何错误的情况下运行。
