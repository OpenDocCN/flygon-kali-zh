- en: '*Chapter 7*: Java Variables, Operators, and Expressions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：Java变量、运算符和表达式'
- en: In this chapter and the next, we are going to learn and practice the core fundamentals
    of Java data and how to manipulate that data. In this chapter, we will focus on
    creating and understanding the data itself, and in the next chapter, we will see
    how to manipulate and respond to it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下一章中，我们将学习和实践Java数据的核心基础知识以及如何操作这些数据。在本章中，我们将专注于创建和理解数据本身，在下一章中，我们将看到如何操作和响应它。
- en: We will also quickly recap on what we learned in the earlier chapters about
    Java, and then dive into learning how to write our very own Java code. The principles
    we are about to learn are not limited to Java but are applicable to other programming
    languages as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将快速回顾一下我们在前几章学到的关于Java的知识，然后深入学习如何编写我们自己的Java代码。我们即将学习的原则不仅适用于Java，还适用于其他编程语言。
- en: 'By the end of the chapter, you will be comfortable writing Java code that creates
    and uses data within Android. This chapter takes you through the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，你将能够舒适地编写Java代码，在Android中创建和使用数据。本章将带你了解以下主题：
- en: Understanding Java syntax and jargon
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Java语法和行话
- en: Storing and using data with variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量存储和使用数据
- en: Using variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量
- en: Changing values in variables with operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用运算符更改变量中的值
- en: Trying out expressions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试表达式
- en: Let's learn some Java.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习一些Java。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2007](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2007).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，网址为[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2007](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2007)。
- en: Java is everywhere
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java无处不在
- en: The core Java fundamentals that we are about to learn apply when working within
    classes that we inherit from (such as `AppCompatActivity`), as well as classes
    that we write ourselves (as we will start to do in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187),
    *Object-Oriented Programming*).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将学习的核心Java基础知识适用于我们从中继承的类（比如`AppCompatActivity`），以及我们自己编写的类（正如我们将在[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)，*面向对象编程*中开始做的那样）。
- en: As it is more logical to learn the basics before we write our own classes, we
    will be using an extended `Activity` class, `AppCompatActivity`, to add some Java
    code in a mini project. We will use the `Log` and `Toast` classes again to see
    the results of our coding in the overridden `onCreate` method of the `Activity`
    class, to trigger the execution of our code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写自己的类之前学习基础知识更合乎逻辑，我们将使用扩展的`Activity`类`AppCompatActivity`，在一个迷你项目中添加一些Java代码。我们将再次使用`Log`和`Toast`类，以在`Activity`类的重写`onCreate`方法中看到我们编码的结果，以触发我们代码的执行。
- en: 'When however, we move on to [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187),
    *Object-Oriented Programming* and start to write our own classes, as well as understand
    more about how classes written by others work, everything we have learned here
    will apply then too—in fact, all the Java that you learn in this chapter and the
    next will apply, if you strip it out of the `Activity` class and paste it into
    another Java environment, such as the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们转到[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)，*面向对象编程*并开始编写我们自己的类，以及更多地了解他人编写的类是如何工作的，我们在这里学到的一切也将适用于那个时候——事实上，你在本章和下一章学到的所有Java知识，如果你将它从`Activity`类中剥离出来，粘贴到另一个Java环境中，比如以下环境：
- en: Any of the major desktop operating systems
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何主要的桌面操作系统
- en: Many modern TVs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多现代电视
- en: Sat nav
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卫星导航
- en: Smart fridges
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能冰箱
- en: Java will work there too!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Java也可以在那里运行！
- en: Calling all Java gurus
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 呼唤所有的Java大师
- en: If you have already done some Java programming and understand the following
    keywords (`if`, `else`, `while`, `do while`, `switch`, and `for`), you can probably
    skip to [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187), *Object-Oriented
    Programming*. Alternatively, you might like to skim over this information as a
    refresher.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经做过一些Java编程并理解以下关键字（`if`、`else`、`while`、`do while`、`switch`和`for`），你可能可以直接跳到[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)，*面向对象编程*。或者，你可能想浏览一下这些信息作为复习。
- en: Let's get on with learning how to code in Java.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续学习如何在Java中编码。
- en: Understanding Java syntax and jargon
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Java语法和行话
- en: Throughout this book, we will use plain English to discuss some technical things.
    You will never be asked to read a technical explanation of a Java or Android concept
    that has not been previously explained in non-technical language.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用简单的英语来讨论一些技术问题。你永远不会被要求阅读一个以非技术语言解释的Java或Android概念的技术解释。
- en: So far, on a few occasions I have asked that you accept a simplified explanation
    to offer a fuller explanation at a more appropriate time, as I have done with
    classes and methods.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在一些场合我已经要求你接受一个简化的解释，以便在更合适的时候提供更充分的解释，就像我在类和方法中所做的那样。
- en: Having said that, the Java and Android communities are full of people who speak
    in technical terms, and to join in and learn from these communities, you need
    to understand the terms they use. So, the approach this book takes is to learn
    a concept or appreciate an idea using entirely plain-speaking language, but at
    the same time introduce the jargon/technical term as part of the learning.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Java和Android社区充满了讲技术术语的人，要加入并从这些社区中学习，你需要理解他们使用的术语。因此，本书的方法是使用完全通俗的语言学习一个概念或欣赏一个想法，但同时作为学习的一部分介绍术语/技术术语。
- en: Java syntax is the way we put together the language elements of Java to produce
    code that works in the Dalvik **virtual machine** (**VM**). The Java syntax is
    a combination of the words we use and the formation of those words into sentence-like
    structures that make up our code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Java语法是我们将Java语言元素组合在一起，以在Dalvik虚拟机（VM）中产生可工作的代码的方式。Java语法是我们使用的单词和将这些单词组成类似句子的结构的组合，构成我们的代码。
- en: These Java "words" are many in number, but taken in small chunks are certainly
    easier to learn than any human-spoken language. We call these words **keywords**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Java“单词”数量众多，但分成小块学习肯定比任何人类语言更容易。我们称这些单词为**关键字**。
- en: I am confident that if you can read then you can learn Java, because learning
    Java is much easier. What, then, separates someone who has finished an elementary
    Java course and an expert programmer?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信如果您能阅读，那么您就能学会Java，因为学习Java要容易得多。那么，是什么区分了完成初级Java课程的人和专业程序员呢？
- en: The exact same things that separate a student of language and a master poet.
    Expertise in Java comes not in the number of Java keywords we know how to use
    but in the way we use them. Mastery of the language comes through practice, further
    study, and using the keywords more skillfully. Many consider programming an art
    as much as a science, and there is some truth to this.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是区分语言学生和大师诗人的相同之处。精通Java并不在于我们知道如何使用多少个Java关键字，而在于我们如何使用它们。语言的精通来自于实践、进一步学习，并更加熟练地使用关键字。许多人认为编程与科学一样是一门艺术，这也有一定道理。
- en: More code comments
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多代码注释
- en: As you become more advanced at writing Java programs, the solutions you use
    to create your programs will become longer and more complicated. Furthermore,
    as we will see in later chapters, Java was designed to manage complexity by having
    us divide up our code into separate classes, very often across multiple files.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您在编写Java程序方面变得更加高级，您用来创建程序的解决方案将变得更长、更复杂。此外，正如我们将在后面的章节中看到的，Java被设计为通过让我们将代码分成单独的类，往往跨越多个文件来管理复杂性。
- en: '**Code comments** are parts of the Java program that do not have any function
    in the program execution. A compiler ignores these comments. They serve to help
    a programmer to document, explain, and clarify their code, to make it more understandable
    to themselves later or to other programmers who might need to use or change it.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码注释**是Java程序中没有任何功能的部分。编译器会忽略这些注释。它们用于帮助程序员记录、解释和澄清他们的代码，使其对自己以后或其他可能需要使用或更改代码的程序员更易理解。'
- en: 'We have already seen a single-line comment. This is reproduced here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了单行注释。这里重复一下：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding comment begins with the two `//` forward-slash characters. The
    comment ends at the end of the line. So, anything on that line is for humans only,
    whereas anything on the next line (unless it''s another comment) needs to be syntactically
    correct Java code, as illustrated here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的注释以两个`//`斜杠字符开头。注释在行末结束。因此，该行上的任何内容仅供人类阅读，而下一行上的任何内容（除非是另一个注释）都需要是语法正确的Java代码，如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can use multiple single-line comments, as illustrated here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多个单行注释，如下所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Single-line comments are also useful if we want to temporarily disable a line
    of code. We can put `//` in front of the code and it will not be included in the
    program. Remember this code, which tells Android to load our layout?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 单行注释也很有用，如果我们想暂时禁用一行代码。我们可以在代码前面加上`//`，这样它就不会包含在程序中。记住这行代码，告诉Android加载我们的布局？
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding situation, the layout will not be loaded and the app will have
    a blank screen when run, as the entire line of code is ignored by the compiler.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，当运行时布局将不会被加载，应用程序将显示空白屏幕，因为编译器会忽略整行代码。
- en: Important note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We saw this in [*Chapter 5*](B16773_05_ePub_RK.xhtml#_idTextAnchor101)*,* *Beautiful
    Layouts with CardView and ScrollView,* when we temporarily commented out one of
    our methods.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第5章*](B16773_05_ePub_RK.xhtml#_idTextAnchor101)*,* *使用CardView和ScrollView创建美观的布局*中看到了这一点，当我们暂时注释掉了其中一个方法。
- en: There is another type of comment in Java, known as a **multiline comment**.
    A multiline comment is useful for longer comments that span multiple lines and
    for adding things such as copyright information at the top of a code file. As
    with a single-line comment, a multiline comment can be used to temporarily disable
    code—in this case, usually across multiple lines.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Java中还有另一种类型的注释，称为**多行注释**。多行注释适用于跨越多行的较长注释，以及在代码文件顶部添加版权信息等内容。与单行注释一样，多行注释可以用于临时禁用代码，通常跨越多行。
- en: 'Everything in between the leading `/*` and the ending `*/` is ignored by the
    compiler. Here are some examples:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/*`和`*/`之间的所有内容都会被编译器忽略。以下是一些示例：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is no limit to the number of lines in a multiline comment; which type
    of comment is best to use will depend upon the situation. In this book, I will
    always explain every line of code explicitly in the text, but you will often find
    liberally sprinkled comments within the code itself that add further explanation,
    insight, or context. So, it's always a good idea to read all the code thoroughly
    too.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释中的行数没有限制；使用哪种类型的注释将取决于情况。在本书中，我将始终在文本中明确解释每行代码，但您通常会在代码本身中发现大量的注释，这些注释会进一步解释、洞察或提供上下文。因此，彻底阅读所有代码也是一个好主意。
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: All the best Java programmers liberally sprinkle their code with comments!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有优秀的Java程序员都会在他们的代码中大量使用注释！
- en: Storing and using data with variables
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变量存储和使用数据
- en: We can think of a `variableA`. These names are like our programmer's window
    into the memory of the user's Android device.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象一个`variableA`。这些名称就像是我们程序员对用户Android设备内存的窗口。
- en: Variables are values in memory, ready to be used or altered when necessary by
    using their name.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是内存中的值，通过使用它们的名称可以随时使用或更改。
- en: Computer memory has a highly complex system of addressing, which fortunately
    we do not need to interact with. Java variables allow us to devise our own convenient
    names for all the data we need our program to work with. The **Dalvik VM** (**DVM**)
    will handle all the technicalities to interact with the operating system, and
    the operating system will in turn interact with the physical memory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机内存具有高度复杂的寻址系统，幸运的是我们不需要与之交互。Java变量允许我们为程序需要处理的所有数据制定自己方便的名称。**Dalvik VM**（**DVM**）将处理与操作系统的交互的所有技术细节，操作系统将再与物理内存交互。
- en: 'So, we can think of our Android device''s memory as a huge warehouse, just
    waiting for us to add our variables. When we assign names to our variables, they
    are stored in the warehouse, ready for when we need them. When we use our variable''s
    name, the device knows exactly what we are referring to. We can then tell it to
    do things such as this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将我们的Android设备的内存想象成一个巨大的仓库，只等着我们添加我们的变量。当我们为变量分配名称时，它们被存储在仓库中，准备在我们需要它们时使用。当我们使用变量的名称时，设备知道我们指的是什么。然后我们可以告诉它做这样的事情：
- en: Assign a value to `variableA`
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`variableA`分配一个值
- en: Add `variableA` to `variableB`
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`variableA`添加到`variableB`
- en: Test the value of `variableB` and take an action based on the result
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`variableB`的值，并根据结果采取行动
- en: …and more, as we will soon see
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ……等等，我们很快就会看到
- en: In a typical app, we might have a variable named `unreadMessages`, perhaps to
    hold the number of unread messages a user has. We could add to it when a new message
    arrives, take away from it when the user reads a message, and show it to the user
    somewhere in the app layout so that they know how many unread messages they have.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个典型的应用程序中，我们可能会有一个名为`unreadMessages`的变量，用来保存用户未读消息的数量。当有新消息到达时，我们可以增加它，当用户阅读消息时，我们可以减少它，并在应用程序布局的某个地方向用户显示它，以便他们知道有多少未读消息。
- en: 'Here are some situations that might arise:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可能出现的一些情况：
- en: A user gets three new messages, so add `3` to the value of `unreadMessages`.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户收到三条新消息，因此将`3`添加到`unreadMessages`的值。
- en: A user logs in to the app, so use `Toast` to display a message along with the
    value stored in `unreadMessages`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户登录应用程序，因此使用`Toast`显示一条消息以及存储在`unreadMessages`中的值。
- en: A user sees that a bunch of messages are from someone they don't like, and deletes
    six messages. We could then subtract 6 from `unreadMessages`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户看到一堆消息来自他们不喜欢的人，并删除了六条消息。然后我们可以从`unreadMessages`中减去6。
- en: These are arbitrary examples of names for variables, and if you don't use any
    of the characters or keywords that Java restricts, you can actually call your
    variables whatever you like.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是变量名称的任意示例，如果您没有使用Java限制的任何字符或关键字，实际上可以随意命名变量。
- en: In practice, however, it is best to adopt a **naming convention** so that your
    variable names will be consistent. In this book, we will use a loose convention
    of variable names, starting with a lowercase letter. When there is more than one
    word in the variable's name, the second word will begin with an uppercase letter.
    This is called **camel casing**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，最好采用**命名约定**，以使您的变量名保持一致。在本书中，我们将使用一种松散的变量命名约定，以小写字母开头。当变量名中有多个单词时，第二个单词将以大写字母开头。这称为**驼峰命名法**。
- en: 'Here are some examples of this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '`unreadMessages`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unreadMessages`'
- en: '`contactName`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contactName`'
- en: '`isFriend`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFriend`'
- en: Before we look at some real Java code with some variables, we need to first
    look at the types of variables we can create and use.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看一些带有变量的真实Java代码之前，我们需要首先看一下我们可以创建和使用的变量的类型。
- en: Types of variables
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量的类型
- en: It is not hard to imagine that even a simple app will have quite a few variables.
    In the previous section, we introduced the `unreadMessages` variable as a hypothetical
    example. What if an app has a list of contacts and needs to remember each of their
    names? We might then need variables for each contact.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以想象，即使是一个简单的应用程序也会有相当多的变量。在上一节中，我们介绍了`unreadMessages`变量作为一个假设的例子。如果一个应用程序有一个联系人列表，并需要记住每个联系人的名字，那么我们可能需要为每个联系人创建变量。
- en: And what about when an app needs to know whether a contact is also a friend
    or just a regular contact? We might need code that tests for friend status and
    then adds messages from that contact into an appropriate folder so that the user
    knows if they were messages from a friend or not.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序需要知道联系人是否也是朋友还是普通联系人时怎么办？我们可能需要编写代码来测试朋友状态，然后将该联系人的消息添加到适当的文件夹中，以便用户知道这些消息是来自朋友还是其他人。
- en: Another common requirement in a computer program, including Android apps, is
    the true or wrong false.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序中另一个常见的要求，包括Android应用程序，是真或假的错误。
- en: To cover this and many other types of data you might want to store or manipulate,
    Java has **types**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了涵盖您可能想要存储或操作的各种数据类型，Java有**类型**。
- en: Primitive types
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本类型
- en: There are many types of variables, and we can even invent our own types as well.
    But for now, we will look at the most used built-in Java types, and to be fair,
    they cover just about every situation we are likely to run into for a while. Providing
    some examples is the best way to explain types.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的变量，我们甚至可以发明自己的类型。但是现在，我们将看一下最常用的内置Java类型，公平地说，它们几乎涵盖了我们可能会遇到的每种情况。提供一些示例是解释类型的最佳方式。
- en: We have already discussed the hypothetical `unreadMessages` variable. This variable
    is of course a number, so we have to tell the Java compiler this by giving it
    an appropriate type.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了假设的`unreadMessages`变量。这个变量当然是一个数字，因此我们必须告诉Java编译器这一点，给它一个适当的类型。
- en: On the other hand, the hypothetical `contactName` variable will of course hold
    the characters that make up a contact's name.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，假设的`contactName`变量当然将保存组成联系人姓名的字符。
- en: 'The type that holds a regular number is called an `int` type such as `unreadMessages`,
    meant for numbers, we will certainly run into trouble, as we can see from the
    following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 保存常规数字的类型称为`int`类型，比如`unreadMessages`，如果我们尝试将其他类型的数据存储在这样的变量中，我们肯定会遇到麻烦，正如我们从以下截图中可以看到的：
- en: '![](img/Figure_7.01_B16773.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_7.01_B16773.jpg)'
- en: Figure 7.1 – Storing contact name
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 存储联系人姓名
- en: As we can see, Java was designed to make it impossible for such errors to make
    it into a running program.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Java被设计成不可能让这些错误进入运行中的程序。
- en: 'Here are the main types of variables in Java:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Java中的主要变量类型：
- en: '`int`: An `int` type is for storing integers, whole numbers. This type uses
    32 pieces (**bits**) of memory and can therefore store values a little in excess
    of 2 billion, including negative values too.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`整数`：`整数`类型用于存储整数，即整数。这种类型使用32位（**位**）内存，因此可以存储略大于20亿的值，包括负值。'
- en: '`long`: As the name hints at, `long` data types can be used when even larger
    numbers are needed. A `long` type uses 64 bits of memory, and 2 to the power of
    63 is what we can store in this. If you want to see what that looks like, here
    it is: 9,223,372,036,854,775,807\. Perhaps surprisingly, there are uses for long
    variables, but the point is that if a smaller variable will do, we should use
    it because our program will use less memory.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`长整型`：正如名称所暗示的，当需要更大的数字时，可以使用`长整型`数据类型。`长整型`类型使用64位内存，我们可以在其中存储2的63次方。如果您想看看它是什么样子，这就是它：9,223,372,036,854,775,807。也许令人惊讶的是，长整型变量有用之处，但关键是，如果较小的变量可以胜任，我们应该使用它，因为我们的程序将使用更少的内存。'
- en: Important note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You might be wondering when you might use numbers of this size. The obvious
    examples would be math or science applications that do complex calculations, but
    another use might be for timing. When you time how long something takes, the Java
    `Date` class uses the number of milliseconds since January 1, 1970\. A millisecond
    is one-thousandth of a second, so there have been quite a few of them since 1970.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道何时会使用这些大小的数字。明显的例子可能是进行复杂计算的数学或科学应用，但另一个用途可能是用于计时。当您计算某事花费的时间时，Java `Date`类使用自1970年1月1日以来的毫秒数。毫秒是一秒的千分之一，所以自1970年以来已经有相当多的毫秒了。
- en: '`float`: This is for floating-point numbers—that is, numbers where there is
    precision beyond the decimal point. As the fractional part of a number takes memory
    space just as the whole-number part, the range of a number possible in a `float`
    type is therefore decreased compared to non-floating-point numbers. So, unless
    our variable will use the extra precision, `float` would not be our data type
    of choice.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`浮点数`：这是用于浮点数的数据类型——也就是说，小数点后有精度的数字。由于数字的小数部分占用的内存空间与整数部分一样多，因此与非浮点数相比，`float`类型中数字的范围会减少。因此，除非我们的变量需要额外的精度，否则`float`不会是我们的数据类型选择。'
- en: '`double`: When the precision in a `float` type is not enough, we have `double`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`双精度`：当`float`类型的精度不够时，我们有`double`。'
- en: '`boolean`: We will be using plenty of Booleans throughout the book. The `boolean`
    variable type can be either `true` or `false`; nothing else. Booleans answer questions
    such as the following:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`布尔`：我们将在整本书中使用大量布尔值。`布尔`变量类型可以是`true`或`false`；没有其他值。布尔值回答以下问题：'
- en: '*Is the contact a friend?*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*联系人是朋友吗？*'
- en: '*Are there any new messages?*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*有新消息吗？*'
- en: '*Are two examples for a Boolean enough?*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值的两个例子足够吗？*'
- en: '`char`: Store a single alphanumeric character in a `char` type. It''s not going
    to change the world on its own, but could be useful if we put lots of them together.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字符`：在`字符`类型中存储单个字母数字字符。它本身不会改变世界，但如果我们将它们放在一起，它可能会有用。'
- en: '`short`: This type is like a space-saving version of `int`. It can be used
    to store whole numbers with both positive and negative values, and can have mathematical
    operations performed on it. Where it differs from `int` is that it uses only 16
    bits of memory, which is just half the amount of memory compared to `int`. The
    downside to `short` is that it can only store half the range of values compared
    to `int`, from -32768 to 32767.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`：这种类型类似于`int`的节省空间的版本。它可以用来存储具有正负值的整数，并且可以对其进行数学运算。它与`int`的区别在于它只使用16位内存，这只是与`int`相比的内存量的一半。`short`的缺点是它只能存储与`int`相比一半范围的值，从-32768到32767。'
- en: '`byte`: This type is like an even more space-saving version of `short`. It
    can be used to store whole numbers with both positive and negative values, and
    can have mathematical operations performed on it. Where it differs from `int`
    and `short` is that it uses only 8 bits of memory, which is just half the amount
    of memory compared to `byte`, and quarter the memory of `int`. The downside to
    `byte` is that it can only store half the range of values compared to `int`, from
    -32768 to 32767\. Saving 8 or even 16 bits in total is unlikely to ever matter;
    however, if you needed to store millions of whole numbers in a program, then `short`
    and `byte` are worth considering.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字节`：这种类型类似于`short`的更节省空间的版本。它可以用来存储具有正负值的整数，并且可以对其进行数学运算。它与`int`和`short`的区别在于它只使用8位内存，这只是与`byte`相比的内存量的一半，与`int`相比只有四分之一的内存。`byte`的缺点是它只能存储与`int`相比一半范围的值，从-32768到32767。总共节省8或16位的内存是不太可能有影响的；但是，如果您需要在程序中存储数百万个整数，那么`short`和`byte`是值得考虑的。'
- en: Important note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: I have kept this discussion on data types to a practical level that is useful
    in the context of this book. If you are interested in how a data type's value
    is stored and why the limits are what they are, then have a look at the *Oracle
    Java Tutorials* site at http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html.
    Note that you do not need any more information than we have already discussed
    to continue with this book.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这个关于数据类型的讨论保持在一个实用的水平上，这对本书的内容是有用的。如果您对数据类型的值是如何存储以及为什么限制是什么感兴趣，那么请查看*Oracle
    Java教程*网站http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html。请注意，您不需要比我们已经讨论过的更多信息来继续阅读本书。
- en: As we just learned, each type of data that we might want to store will need
    a specific amount of memory. For this reason, we must let the Java compiler know
    the type of the variable before we begin to use it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚学到的，我们可能想要存储的每种数据类型都需要特定数量的内存。因此，我们必须在开始使用变量之前让Java编译器知道变量的类型。
- en: The variables described previously are known as **primitive** types. Most primitive
    types are used throughout different programming languages (as well as keywords),
    so if you have a good understanding of the types and keywords, then jumping into
    another language will be far easier than the first time! These types use predefined
    amounts of memory, and so, using our warehouse storage analogy, fit into predefined
    sizes of storage box.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 先前描述的变量称为**原始**类型。大多数原始类型在不同的编程语言中都被使用（以及关键字），因此，如果您对类型和关键字有很好的理解，那么跳到另一种语言将比第一次容易得多！这些类型使用预定义的内存量，因此，使用我们的仓库存储类比，适合预定义大小的存储盒。
- en: As the "primitive" label suggests, they are not as sophisticated as **reference**
    types.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如“原始”标签所示，它们不像**引用**类型那样复杂。
- en: Reference types
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用类型
- en: You might have noticed that we didn't cover the `String` variable type we previously
    used to introduce the concept of variables that hold alphanumeric data, such as
    a contact's name.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们没有涵盖我们之前用来介绍保存字母数字数据的变量类型`String`。
- en: Strings
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Strings are one example of a special type of variable, known as a **reference**
    type. They quite simply refer to a place in memory where storage of the variable
    begins, but the reference type itself does not define a specific amount of memory.
    The reason for this is straightforward: it''s because we don''t always know how
    much data will need to be stored in it until the program is run.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是特殊类型变量的一个例子，称为**引用**类型。它们简单地指向内存中存储变量的位置，但引用类型本身并不定义特定的内存量。其原因很简单：因为我们并不总是知道在程序运行之前需要存储多少数据。
- en: We can think of Strings and other reference types as continually expanding and
    contracting storage boxes. So, won't one of these `String` reference types bump
    into another variable eventually?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将字符串和其他引用类型看作是不断扩展和收缩的存储盒。那么，这些`String`引用类型中的一个不会最终碰到另一个变量吗？
- en: As we are thinking about a device's memory as a huge warehouse full of racks
    of labeled storage boxes, then you can think of a DVM as a super-efficient forklift
    truck driver that puts the different types of storage boxes in the most appropriate
    place; and, if it becomes necessary, the DVM will quickly move stuff around in
    a fraction of a second to avoid collisions. Also, when required, Dalvik, the forklift
    truck driver, will even vaporize any unneeded storage boxes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将设备的内存视为一个充满标记存储盒的巨大仓库时，您可以将DVM视为一个超级高效的叉车司机，将不同类型的存储盒放在最合适的位置；如果有必要，DVM将在几分之一秒内迅速移动物品，以避免碰撞。此外，如果需要，Dalvik，这个叉车司机，甚至会立即蒸发掉任何不需要的存储盒。
- en: This all happens at the same time as constantly unloading new storage boxes
    of all types and placing them in the best place for that type of variable. Dalvik
    keeps reference variables in a different part of the warehouse from primitive
    variables, and we will learn more details about this in [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218),
    *The Stack, the Heap, and the Garbage Collector.*
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都发生在不断卸载各种类型的新存储盒并将它们放在最适合该类型变量的地方的同时。Dalvik将引用变量保存在仓库的不同部分，我们将在[*第12章*](B16773_12_ePub_RK.xhtml#_idTextAnchor218)，*堆栈、堆和垃圾收集器*中了解更多细节。
- en: Strings can be used to store any keyboard character, like a `char` type but
    of almost any length. Anything from a contact's name to an entire book can be
    stored in a single `String` type. We will be using Strings regularly, including
    in this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以用来存储任何键盘字符，就像`char`类型，但长度几乎可以是任意的。从联系人的姓名到整本书都可以存储在单个`String`类型中。我们将经常使用字符串，包括在本章中。
- en: There are a couple more reference types we will explore as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他引用类型我们也会探讨。
- en: Arrays
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays are a way to store lots of variables of the same type, ready for quick
    and efficient access. We will look at arrays in [*Chapter 15*](B16773_15_ePub_RK.xhtml#_idTextAnchor267),
    *Arrays, Maps, and Random Numbers.*
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一种存储大量相同类型变量的方法，以便快速有效地访问。我们将在[*第15章*](B16773_15_ePub_RK.xhtml#_idTextAnchor267)，*数组、映射和随机数*中研究数组。
- en: Think of an array as an aisle in our warehouse, with all variables of a certain
    type lined up in a precise order. Arrays are reference types, so Dalvik keeps
    these in the same part of the warehouse as Strings. We might, for example, use
    an array to store dozens of contacts in.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组想象成我们仓库中的一排通道，所有特定类型的变量都按照精确的顺序排列。数组是引用类型，因此Dalvik将它们保存在与字符串相同的仓库部分。例如，我们可以使用数组来存储数十个联系人。
- en: Classes
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类
- en: Another reference type is the `class` type, which we have already discussed
    but not explained properly. We will be getting familiar with classes in [*Chapter
    10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187), *Object-Oriented Programming*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种引用类型是`class`类型，我们已经讨论过但没有正确解释。我们将在[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)，*面向对象编程*中熟悉类。
- en: Now, we know that each type of data that we might want to store will require
    an amount of memory. Hence, we must let the Java compiler know the type of the
    variable before we begin to use it. We do this with a variable **declaration**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道我们可能想要存储的每种数据类型都需要一定的内存。因此，在我们开始使用变量之前，我们必须让Java编译器知道变量的类型。我们用变量**声明**来做到这一点。
- en: Using variables
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变量
- en: That's enough theory. Let's see how we would use our variables and types. Remember
    that each primitive type needs a specific amount of real device memory. This is
    one of the reasons why the compiler needs to know what type a variable will be.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这就够理论了。让我们看看我们如何使用我们的变量和类型。请记住，每种原始类型都需要特定数量的真实设备内存。这就是为什么编译器需要知道变量的类型的原因之一。
- en: Variable declaration
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量声明
- en: 'We must first `int` with the name `unreadMessages`, we would type the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须首先使用名称`unreadMessages`声明`int`，我们将输入以下内容：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's it—simply state the type (in this case, `int`), then leave a space and
    type the name you want to use for this variable. Note also that the `;` semicolon
    at the end of the line will tell the compiler that we are done with this line
    and that what follows, if anything, is not part of the variable declaration.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——简单地声明类型（在本例中是`int`），然后留出一个空格，输入你想要用于此变量的名称。还要注意，行末的分号`;`将告诉编译器我们已经完成了这一行，接下来的内容（如果有的话）不是变量声明的一部分。
- en: Similarly, for almost all the other variable types, the declaration would occur
    in the same way. Here are some examples. The variable names in the examples are
    arbitrary. This is like reserving a labeled storage box in a warehouse.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，对于几乎所有其他变量类型，声明方式都是相同的。以下是一些示例。示例中的变量名是任意的。这就像在仓库中预留一个带标签的储物箱。
- en: 'Have a look at the following code snippet:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码片段：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice I said *almost all the other variable types*. One of the exceptions is
    variables of the `class` type. We have already seen some code declaring variables
    of the `class` type. Do you remember this code snippet from [*Chapter 3*](B16773_03_ePub_RK.xhtml#_idTextAnchor064),
    *Exploring Android Studio and the Project Structure* in the `MainActivity.java`
    file?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我说的是*几乎所有其他变量类型*。其中一个例外是`class`类型的变量。我们已经看到了一些声明`class`类型变量的代码。您还记得[*第3章*](B16773_03_ePub_RK.xhtml#_idTextAnchor064)中的这个代码片段吗？在`MainActivity.java`文件中，*探索Android
    Studio和项目结构*？
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This edited snippet of code is declaring a variable called `fab` of type `FloatingActionButton`.
    But we are off track a little, and will come back to classes in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187),
    *Object-Oriented Programming*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这段编辑过的代码片段声明了一个名为`fab`的`FloatingActionButton`类型的变量。但我们有点跑题，将在[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)
    *面向对象编程*中回到类。
- en: Variable initialization
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量初始化
- en: '**Initialization** is the next step. Here, for each type, we initialize a value
    to the variable. This is like placing a value inside a storage box in a warehouse.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化**是下一步。在这里，对于每种类型，我们将一个值初始化到变量中。这就像在仓库的储物箱中放入一个值。'
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that the `char` variable uses `'` single quotes around the initialized
    value, while the `String` type uses `"` double quotes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`char`变量在初始化值周围使用`'`单引号，而`String`类型使用`"`双引号。
- en: 'We can also combine the declaration and initialization steps. Here, we declare
    and initialize the same variables as we have previously, but in one step:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将声明和初始化步骤合并。在这里，我们声明并初始化了与之前相同的变量，但是在一步中完成：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Whether we declare and initialize separately or together is dependent upon the
    specific situation. The important thing is that we must do both at some point.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是分开声明和初始化，还是一起进行，都取决于具体情况。重要的是我们必须在某个时候都要做这两件事。
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This would cause the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下情况：
- en: '**Compiler Error: Variable a might not have been initialized**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器错误：变量a可能尚未初始化**'
- en: There is a significant exception to this rule. In certain circumstances, variables
    can have **default values**. We will see this in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187),
    *Object-Oriented Programming*; however, it is good practice to both declare and
    initialize variables.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则有一个重要的例外。在某些情况下，变量可以有**默认值**。我们将在[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)
    *面向对象编程*中看到这一点；但是，声明和初始化变量是一个好习惯。
- en: Changing values in variables with operators
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用运算符更改变量中的值
- en: Of course, in almost any program, we are going to need to "do things" with these
    variables' values. We manipulate (change) variables with **operators**. Here is
    a list of perhaps the most common Java operators that allow us to manipulate variables.
    You do not need to memorize them as we will look at every line of code as and
    when we use them for the first time. We have already seen the first operator when
    we initialized our variables, but we will see it again, this time being a bit
    more adventurous.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在几乎任何程序中，我们都需要对这些变量的值进行“操作”。我们使用**运算符**来操作（更改）变量。以下是一些最常见的Java运算符列表，它们允许我们操作变量。您不需要记住它们，因为我们将在第一次使用它们时逐行查看每行代码。我们已经在初始化变量时看到了第一个运算符，但是我们将再次看到它，这次会更加有趣。
- en: The assignment operator
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: 'This is the assignment operator: `=`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '这是赋值运算符：`=` '
- en: 'It makes the variable to the left of the operator the same as the value to
    the right—for example, like in this line of code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它使运算符左侧的变量与右侧的值相同——例如，就像这行代码中的那样：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After the previous line of code has executed, the value stored in `unreadMessages`
    will be the same as the value stored in `newMessages`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行了前一行代码之后，存储在`unreadMessages`中的值将与`newMessages`中的值相同。
- en: The addition operator
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加法运算符
- en: 'This is the addition operator: `+`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是加法运算符：`+`
- en: 'It will add together values on either side of the operator and is usually used
    in conjunction with the assignment operator. For example, it can add together
    two variables that have numeric values, like in this next line of code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它将两侧的值相加，通常与赋值运算符一起使用。例如，它可以将两个具有数值的变量相加，就像下一行代码中的那样：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once the previous code has executed the combined value of the values held by
    `newMessages` and `unreadMessages`, this is now stored in `unreadMessages`. As
    another example of the same thing, look at this line of code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦前面的代码执行了，`newMessages`和`unreadMessages`持有的值的组合值现在存储在`unreadMessages`中。作为同样事情的另一个例子，请看这行代码：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Important note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice that it is perfectly acceptable to use the same variable simultaneously
    on both sides of an operator.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，同时在运算符的两侧同时使用同一个变量是完全可以接受的。
- en: The subtraction operator
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减法运算符
- en: 'This is the subtraction operator: `-`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是减法运算符：`-`
- en: 'It will subtract the value on the right side of the operator from the value
    on the left. This is usually used in conjunction with the assignment operator,
    as in this code example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它将从左侧的值中减去右侧的值。通常与赋值运算符一起使用，就像这个代码示例中：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or, as a similar example, it is used in this line of code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为一个类似的例子，它在这行代码中使用：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After the previous line of code has executed, `accountBalance` will hold its
    original value minus whatever the value held in `withdrawals` is.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码执行后，`accountBalance`将保留其原始值减去`withdrawals`中的值。
- en: The division operator
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 除法运算符
- en: 'This is the division operator: `/`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是除法运算符：`/`
- en: 'It will divide the number on the left by the number on the right. Again, it
    is usually used in conjunction with the assignment operator. Here is an example
    line of code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 它将把左边的数字除以右边的数字。同样，它通常与赋值运算符一起使用。以下是一个示例代码行：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If in the previous line of code `numSweets` held nine sweets and `numChildren`
    held three sweets, then `fairShare` will now hold the value of three sweets.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在上一行代码中`numSweets`持有九个糖果，`numChildren`持有三个糖果，那么`fairShare`现在将持有三个糖果的价值。
- en: The multiplication operator
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 乘法运算符
- en: 'This is the multiplication operator: `*`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是乘法运算符：`*`
- en: 'It will multiply variables and numbers together and, as with many of the other
    operators, is usually used in conjunction with the assignment operator. For example,
    look at this line of code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 它将变量和数字相乘，与许多其他运算符一样，通常与赋值运算符一起使用。例如，看看下一行代码：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Alternatively, look at this line of code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，看看这行代码：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After the previous two lines of code have executed, `answer` holds the value
    100 and `biggerAnswer` holds the value 1000.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两行代码执行后，`answer`保持值100，`biggerAnswer`保持值1000。
- en: The increment operator
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递增运算符
- en: 'This is the increment operator: `++`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是递增运算符：`++`
- en: 'The increment operator is a quick way to add one to something. For example,
    look at this next line of code, which uses the addition operator:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 递增运算符是从某物中加一的快速方法。例如，看看下一行代码，它使用了加法运算符：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The previous line of code has the same result as this much more compact code
    here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码的结果与这里更紧凑的代码相同：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The decrement operator
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递减运算符
- en: 'This is the decrement operator: `--`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是递减运算符：`--`
- en: 'The decrement operator (as you probably guessed) is a quick way to subtract
    one from something. For example, look at this next line of code, which uses the
    subtraction operator:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 递减运算符（正如你可能猜到的）是从某物中减去一个的快速方法。例如，看看下一行代码，它使用了减法运算符：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The previous line of code is the same as `myVariable --;`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码与`myVariable --;`相同。
- en: Important note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The formal names for these operators are slightly different from those explained
    previously—for example, the division operator is one of the multiplicative operators.
    But the names given previously are far more useful for the purpose of learning
    Java, and if you used the term *division operator* while conversing with someone
    from the Java community, they would know exactly what you mean.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符的正式名称与之前解释的略有不同，例如，除法运算符是乘法运算符之一。但是之前给出的名称对于学习Java来说更有用，如果你在与Java社区的某人交谈时使用术语*除法运算符*，他们会完全明白你的意思。
- en: There are even more operators than this in Java. We will meet some of them in
    the next chapter, when we learn about making decisions in Java.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Java中甚至有更多的运算符。在下一章中，当我们学习在Java中做出决定时，我们将遇到其中一些。
- en: Important note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are curious about operators, there is a complete list of them on the
    *Oracle Java Tutorials* website, at [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).
    All the operators needed to complete the projects in this book will be fully explained
    in this book. The link is provided for the more curious among us.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对运算符感到好奇，在*Oracle Java教程*网站上有一个完整的运算符列表，网址为[http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html)。本书中完成项目所需的所有运算符都将在本书中得到充分解释。链接是为我们中更好奇的人提供的。
- en: Trying out expressions
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试表达
- en: Let's try using some declarations, assignments, and operators. When we bundle
    these elements together into some meaningful syntax, we call this an `Toast` and
    `Log` to check our results.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一些声明、赋值和运算符。当我们将这些元素捆绑成一些有意义的语法时，我们称之为`Toast`并`Log`以检查我们的结果。
- en: Expressing Yourself demo app
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达自己的演示应用程序
- en: Create a new project called `Expressing Yourself`, use the `/Expressing Yourself`
    folder of the download bundle.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Expressing Yourself`的新项目，使用下载包的`/Expressing Yourself`文件夹。
- en: 'Switch to the `onCreate` method, just before the `}` closing curly brace, add
    this code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到`onCreate`方法，就在`}`闭合大括号之前，添加这段代码：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Directly below the previous line of code, we will initialize a value to `numMessages`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码的下方，我们将初始化一个值为`numMessages`。
- en: 'Next, add this line of code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加这行代码：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Immediately after the previous line of code and before the `}`closing curly
    brace of `onCreate`, add the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码之后，`onCreate`的`}`闭合大括号之前，添加以下代码：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Important note
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You will need to import the `Toast` and `Log` classes, as we have done previously.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要导入`Toast`和`Log`类，就像我们之前做的那样。
- en: 'Run the app, and we can examine the output and then the code. In the logcat
    window, you will see the following output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，我们可以检查输出，然后再检查代码。在logcat窗口中，你会看到以下输出：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On the screen, you will see two pop-up `Toast` messages. The first says **Message
    from James Gosling.** The second says **Message is:Dear reader, I invented Java.**
    This is shown in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上，你会看到两个弹出的`Toast`消息。第一个说**来自詹姆斯·高斯林的消息。**第二个说**消息是：亲爱的读者，我发明了Java。**这在下面的截图中显示：
- en: '![Figure 7.2 – The second pop-up Toast message'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 - 第二个弹出的Toast消息'
- en: '](img/Figure_7.02_B16773.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.02_B16773.jpg)'
- en: Figure 7.2 – The second pop-up Toast message
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - 第二个弹出的Toast消息
- en: Let's step through the code and make sure that each line is clear before moving
    on.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行检查代码，确保每行都清晰明了，然后再继续。
- en: 'First, we declared and initialized an `int` type variable called `numMessages`.
    We could have done it on one line, but we did it like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明并初始化了一个名为`numMessages`的`int`类型变量。我们本可以在一行上完成，但我们是这样做的：
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we used `Log` to output a message. Instead of simply typing the message
    between the `""` double quote marks, this time we used the `+` operator to add
    `numMessages` onto the output, and as we saw in the console, the actual value
    of `numMessages` was output, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`Log`输出一条消息。这次，我们不是简单地在`""`双引号之间输入消息，而是使用`+`运算符将`numMessages`添加到输出中，正如我们在控制台中看到的，`numMessages`的实际值被输出，如下所示：
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Just to further prove that our `numMessages` variable is as versatile as it
    should be, we used the `++` operator, which should have increased its value by
    `1` and then added `numMessages` to itself, using `+ 1`. We then output the new
    value of `numMessages`, and indeed found its value has increased to 12 from 10,
    as illustrated in the following code snippet:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步证明我们的`numMessages`变量像它应该的那样多才多艺，我们使用了`++`运算符，这应该将它的值增加`1`，然后使用`+ 1`将`numMessages`加到自身上。然后我们输出了`numMessages`的新值，并确实发现它的值从10增加到12，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we created a `boolean`-type variable called `isFriend`, and output that
    to the console. We saw from the output that `true` was displayed. This variable
    type will fully prove its usefulness when we look at decision making in the next
    section. The code is illustrated in the following snippet:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个名为`isFriend`的`boolean`类型变量，并将其输出到控制台。我们从输出中看到`true`被显示。当我们在下一节中看到决策制定时，这种变量类型将充分证明其有用性。代码如下所示：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After this, we declared and initialized two `String`-type variables, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们声明并初始化了两个`String`类型的变量，如下所示：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, we output the `String` variables using `Toast`. We used a hardcoded
    part of the `"Message from "` message, and added the variable part of the message
    with `+ contact`. We used the same technique to form the second `Toast` message
    as well.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`Toast`输出`String`变量。我们使用了`"Message from "`消息的硬编码部分，并使用`+ contact`添加了消息的变量部分。我们也使用了相同的技术来形成第二个`Toast`消息。
- en: Tip
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When we add two Strings together to make a longer `String` type, this is called
    **concatenation**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将两个字符串连接在一起以形成一个更长的`String`类型时，这被称为**连接**。
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, we can declare variables, initialize them to a value, change them around
    a bit, and output them using `Toast` or `Log`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以声明变量，将它们初始化为一个值，稍微改变它们的值，并使用`Toast`或`Log`输出它们。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At last, we have used some serious Java. We learned about variables, declaration,
    and initialization. We saw how to use operators to change the value of variables.
    It's all right if you don't remember everything straight away as we will constantly
    be using these techniques and keywords throughout the book.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用了一些严肃的Java。我们学习了关于变量、声明和初始化。我们看到了如何使用运算符来改变变量的值。如果你不记得所有的东西，没关系，因为我们将在整本书中不断地使用这些技术和关键字。
- en: In the next chapter, let's look at how we can make decisions based on the values
    of these variables and find out how this is useful to us.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，让我们看看如何根据这些变量的值做出决定，以及这对我们有多有用。
