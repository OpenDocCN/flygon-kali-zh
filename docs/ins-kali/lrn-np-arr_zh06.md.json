["```py\n    print \"Decimal 6\", np.testing.assert_almost_equal(0.123456789, 0.123456780, decimal=7)\n    ```", "```py\n    Decimal 6 None\n    ```", "```py\n    print \"Decimal 7\", np.testing.assert_almost_equal(0.123456789, 0.123456780, decimal=8)\n    ```", "```py\n    Decimal 7\n    Traceback (most recent call last):\n     \u2026\n     raise AssertionError(msg)\n    AssertionError: \n    Arrays are not almost equal\n     ACTUAL: 0.123456789\n     DESIRED: 0.12345678\n\n    ```", "```py\nabs(actual - expected) >= 10**-(significant - 1)\n```", "```py\n    print \"Significance 8\", np.testing.assert_approx_\n    equal(0.123456789, 0.123456780,\n    significant=8)\n    ```", "```py\n    Significance 8 None\n\n    ```", "```py\n    print \"Significance 9\", np.testing.assert_approx_equal(0.123456789, 0.123456780, significant=9)\n    ```", "```py\n    Significance 9\n    Traceback (most recent call last):\n     ...\n     raise AssertionError(msg)\n    AssertionError: \n    Items are \n    not equal to 9 significant digits:\n     ACTUAL: 0.123456789\n     DESIRED: 0.12345678\n\n    ```", "```py\n|expected - actual| < 0.5 10-decimal\n```", "```py\n    print \"Decimal 8\", np.testing.assert_array_almost_equal([0, 0.123456789], [0, 0.123456780], decimal=8)\n    ```", "```py\n    Decimal 8\n    None\n    ```", "```py\n    print \"Decimal 9\", np.testing.assert_array_almost_equal([0, 0.123456789], [0, 0.123456780], decimal=9)\n    ```", "```py\n    Decimal 9\n    Traceback (most recent call last):\n     \u2026\n     assert_array_compare\n     raise AssertionError(msg)\n    AssertionError: \n    Arrays are not almost equal\n\n    (mismatch 50.0%)\n     x: array([ 0\\.        ,  0.12345679])\n     y: array([ 0\\.        ,  0.12345678])\n\n    ```", "```py\n    ipython -pylab\n\n    ```", "```py\n    In [1]: a = arange(1000)\n\n    ```", "```py\n    In [2]: %timeit searchsorted(a, 42)\n    100000 loops, best of 3: 7.58 us per loop\n\n    ```", "```py\n    import numpy\n\n    def invert(n):\n       a = numpy.matrix(numpy.random.rand(n, n))\n       return a.I\n\n    sizes = 2 ** numpy.arange(0, 12)\n    ```", "```py\n       invert(n)\n    ```", "```py\n    In [1]: %run -t invert_matrix.py\n    IPython CPU timings (estimated):\n     User   :       6.08 s.\n     System :       0.52 s.\n    Wall time:      19.26 s.\n\n    ```", "```py\n    In [2]: %run -p invert_matrix.py\n\n    852 function calls in 6.597 CPU seconds\n\n     Ordered by: internal time\n\n     ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n     12    3.228    0.269    3.228    0.269 {numpy.linalg.lapack_lite.dgesv}\n     24    2.967    0.124    2.967    0.124 {numpy.core.multiarray._fastCopyAndTranspose}\n     12    0.156    0.013    0.156    0.013 {method 'rand' of 'mtrand.RandomState' objects}\n     12    0.087    0.007    0.087    0.007 {method 'copy' of 'numpy.ndarray' objects}\n     12    0.069    0.006    0.069    0.006 {method 'astype' of 'numpy.ndarray' objects}\n     12    0.025    0.002    6.304    0.525 linalg.py:404(inv)\n     12    0.024    0.002    6.328    0.527 defmatrix.py:808(getI)\n     1    0.017    0.017    6.596    6.596 invert_matrix.py:1(<module>)\n     24    0.014    0.001    0.014    0.001 {numpy.core.multiarray.zeros}\n     12    0.009    0.001    6.580    0.548 invert_matrix.py:3(invert)\n     12    0.000    0.000    6.264    0.522 linalg.py:244(solve)\n     12    0.000    0.000    0.014    0.001 numeric.py:1875(identity)\n     1    0.000    0.000    6.597    6.597 {execfile}\n     36    0.000    0.000    0.000    0.000 defmatrix.py:279(__array_finalize__)\n     12    0.000    0.000    2.967    0.247 linalg.py:139(_fastCopyAndTranspose)\n     24    0.000    0.000    0.087    0.004 defmatrix.py:233(__new__)\n     12    0.000    0.000    0.000    0.000 linalg.py:99(_commonType)\n     24    0.000    0.000    0.000    0.000 {method '__array_prepare__' of 'numpy.ndarray' objects}\n     36    0.000    0.000    0.000    0.000 linalg.py:66(_makearray)\n     36    0.000    0.000    0.000    0.000 {numpy.core.multiarray.array}\n     12    0.000    0.000    0.000    0.000 {method 'view' of 'numpy.ndarray' objects}\n     12    0.000    0.000    0.000    0.000 linalg.py:127(_to_native_byte_order)\n     1    0.000    0.000    6.597    6.597 interactiveshell.py:2270(safe_execfile)\n\n    ```", "```py\nimport numpy\n\na = numpy.arange(7)\nprint a[8]\n```", "```py\n    In [1]: %run buggy.py\n    ---------------------------------------------------------------------------\n    IndexError                                Traceback (most recent call last)\n    .../site-packages/IPython/utils/py3compat.pyc in execfile(fname, *where)\n     173             else:\n     174                 filename = fname\n    --> 175             __builtin__.execfile(filename, *where)\n\n    .../buggy.py in <module>()\n     2 \n     3 a = numpy.arange(7)\n    ----> 4 print a[8]\n\n    IndexError: index out of bounds\n\n    ```", "```py\n    In [2]: %debug\n    > .../buggy.py(4)<module>()\n     2 \n     3 a = numpy.arange(7)\n    ----> 4 print a[8]\n\n    ```", "```py\n    ipdb> list\n     1 import numpy\n     2 \n     3 a = numpy.arange(7)\n    ----> 4 print a[8]\n\n    ```", "```py\n    ipdb> len(a)\n    7\n\n    ipdb> print a\n    [0 1 2 3 4 5 6]\n\n    ```", "```py\n    ipdb> bt\n     .../py3compat.py(175)execfile()\n     171             if isinstance(fname, unicode):\n     172                 filename = fname.encode(sys.getfilesystemencoding())\n     173             else:\n     174                 filename = fname\n    --> 175             __builtin__.execfile(filename, *where)\n\n    > .../buggy.py(4)<module>()\n     0 print a[8]\n\n    ```", "```py\n    ipdb> u\n    > .../site-packages/IPython/utils/py3compat.py(175)execfile()\n     173             else:\n     174                 filename = fname\n    --> 175             __builtin__.execfile(filename, *where)\n\n    ```", "```py\n    ipdb> d\n    > .../buggy.py(4)<module>()\n     2 \n     3 a = numpy.arange(7)\n    ----> 4 print a[8]\n\n    ```", "```py\n    def factorial(n):\n       if n == 0:\n          return 1\n\n       if n < 0:\n          raise ValueError, \"Unexpected negative value\"\n\n       return np.arange(1, n+1).cumprod()\n    ```", "```py\n        class FactorialTest(unittest.TestCase):\n           def test_factorial(self):\n              #Test for the factorial of 3 that should pass.\n              self.assertEqual(6, factorial(3)[-1])\n              np.testing.assert_equal(np.array([1, 2, 6]), factorial(3))\n\n           def test_zero(self):\n              #Test for the factorial of 0 that should pass.\n              self.assertEqual(1, factorial(0))\n\n           def test_negative(self):\n              #Test for the factorial of negative numbers that should fail.\n              # It should throw a ValueError, but we expect IndexError\n              self.assertRaises(IndexError, factorial(-10))\n        ```", "```py\n        $ python unit_test.py\n        .E.\n        ======================================================================\n        ERROR: test_negative (__main__.FactorialTest)\n        ----------------------------------------------------------------------\n        Traceback (most recent call last):\n         File \"unit_test.py\", line 26, in test_negative\n         self.assertRaises(IndexError, factorial(-10))\n         File \"unit_test.py\", line 9, in factorial\n         raise ValueError, \"Unexpected negative value\"\n        ValueError: Unexpected negative value\n\n        ----------------------------------------------------------------------\n        Ran 3 tests in 0.003s\n\n        FAILED (errors=1)\n\n        ```", "```py\n        import numpy as np\n        import unittest\n\n        def factorial(n):\n           if n == 0:\n              return 1\n\n           if n < 0:\n              raise ValueError, \"Unexpected negative value\"\n\n           return np.arange(1, n+1).cumprod()\n\n        class FactorialTest(unittest.TestCase):\n           def test_factorial(self):\n              #Test for the factorial of 3 that should pass.\n              self.assertEqual(6, factorial(3)[-1])\n              np.testing.assert_equal(np.array([1, 2, 6]), factorial(3))\n\n           def test_zero(self):\n              #Test for the factorial of 0 that should pass.\n              self.assertEqual(1, factorial(0))\n\n           def test_negative(self):\n              #Test for the factorial of negative numbers that should fail.\n              # It should throw a ValueError, but we expect IndexError\n              self.assertRaises(IndexError, factorial(-10))\n\n        if __name__ == '__main__':\n            unittest.main()\n        ```", "```py\n    easy_install nose\n\n    ```", "```py\n    pip install nose\n\n    ```", "```py\n    @setastest(False)\n    def test_false():\n       pass\n\n    @setastest(True)\n    def test_true():\n       pass\n    ```", "```py\n    @skipif(True)\n    def test_skip():\n       pass\n    ```", "```py\n    @knownfailureif(True)\n    def test_alwaysfail():\n         pass\n    ```", "```py\n    class TestClass():\n       def test_true2(self):\n          pass\n\n    class TestClass2():\n       def test_false2(self):\n          pass\n    ```", "```py\n    decorate_methods(TestClass2, setastest(False), 'test_false2')\n    ```", "```py\n    nosetests -v decorator_setastest.py\n    decorator_setastest.TestClass.test_true2 ... ok\n    decorator_setastest.test_true ... ok\n    decorator_test.test_skip ... SKIP: Skipping test: test_skipTest skipped due to test condition\n    decorator_test.test_alwaysfail ... ERROR\n\n    ======================================================================\n    ERROR: decorator_test.test_alwaysfail\n    ----------------------------------------------------------------------\n    Traceback (most recent call last):\n     File \"\u2026/nose/case.py\", line 197, in runTest\n     self.test(*self.arg)\n     File \u2026/numpy/testing/decorators.py\", line 213, in knownfailer\n     raise KnownFailureTest(msg)\n    KnownFailureTest: Test skipped due to known failure\n\n    ----------------------------------------------------------------------\n    Ran 4 tests in 0.001s\n\n    FAILED (SKIP=1, errors=1)\n\n    ```", "```py\n    from numpy.testing.decorators import setastest\n    from numpy.testing.decorators import skipif\n    from numpy.testing.decorators import knownfailureif\n    from numpy.testing import decorate_methods\n\n    @setastest(False)\n    def test_false():\n       pass\n\n    @setastest(True)\n    def test_true():\n       pass\n\n    @skipif(True)\n    def test_skip():\n       pass\n\n    @knownfailureif(True)\n    def test_alwaysfail():\n         pass\n\n    class TestClass():\n       def test_true2(self):\n          pass\n\n    class TestClass2():\n       def test_false2(self):\n          pass\n\n    decorate_methods(TestClass2, setastest(False), 'test_false2')\n    ```"]