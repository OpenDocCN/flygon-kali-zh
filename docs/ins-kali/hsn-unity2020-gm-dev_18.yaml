- en: '*Chapter 18*: Implementing Game AI for Building Enemies'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第18章*：为构建敌人实现游戏AI'
- en: What is a game if not a great challenge to the player, who needs to use their
    character's abilities to tackle different scenarios? Each game imposes different
    kinds of obstacles to the Player, and the main one in our game is the enemies.
    Creating challenging and believable enemies can be complex, they need to behave
    like real characters and to be smart enough to not be easy to kill, but also easy
    enough that they are not impossible to kill either. We are going to use basic
    but good enough AI techniques to accomplish exactly that.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有玩家需要利用角色的能力来应对不同的情景，那么游戏还有什么意义呢？每个游戏都对玩家施加不同类型的障碍，而我们游戏中的主要障碍就是敌人。创建具有挑战性和可信度的敌人可能会很复杂，它们需要像真实角色一样行为，并且足够聪明，不容易被杀死，但也不至于太容易。我们将使用基本但足够好的AI技术来实现这一点。
- en: 'In this chapter, we will examine the following AI concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下AI概念：
- en: Gathering information with sensors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传感器收集信息
- en: Making decisions with FSMs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FSM做出决策
- en: Executing FSM actions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行FSM动作
- en: Gathering information with sensors
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用传感器收集信息
- en: An AI works first by taking in info about its surroundings, then that data is
    analyzed to determine an action and finally, the chosen action is executed, and
    as you can see, we cannot do anything without information, so let's start with
    that part. There are several sources of information our AI can use, such as data
    about itself (life and bullets) or maybe some game state (winning condition or
    remaining enemies), which can be easily found with the code we saw so far, but
    one important source of information is also the AI senses. According to the needs
    of our game, we might need different senses such as sight and hearing, but in
    our case, sight will be enough, so let's learn how to code that.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: AI首先通过获取周围的信息，然后分析这些数据来确定行动，最后执行所选择的行动，正如你所看到的，没有信息我们什么也做不了，所以让我们从这部分开始。我们的AI可以使用多种信息源，比如关于自身的数据（生命和子弹）或者游戏状态（胜利条件或剩余敌人），这些都可以通过我们迄今为止看到的代码轻松找到，但一个重要的信息源也是AI的感知。根据我们游戏的需求，我们可能需要不同的感知，比如视觉和听觉，但在我们的情况下，视觉就足够了，所以让我们学习如何编写它。
- en: 'In this section, we will examine the following sensor concepts:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究以下传感器概念：
- en: Creating Three-Filters sensors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建三过滤器传感器
- en: Debugging with Gizmos
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gizmos进行调试
- en: Let's start seeing how to create a sensor with the Three-Filters approach.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始看看如何使用三过滤器方法创建传感器。
- en: Creating Three-Filters sensors
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建三过滤器传感器
- en: 'The common way to code senses is through a Three-Filters approach to discard
    enemies out of sight. The first filter is a distance filter, which will discard
    enemies too far away to be seen, then the angle check, which will check enemies
    inside our viewing cone, and finally a raycast check, which will discard enemies
    that are being occluded by obstacles such as walls. Before starting, a word of
    advice: we will be using vector mathematics here, and covering those topics in-depth
    is outside the scope of this book. If you don''t understand something, feel free
    to just copy and paste the code in the screenshot and look up those concepts online.
    Let''s code sensors the following way:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编写感知的常见方法是通过三过滤器方法来丢弃视线之外的敌人。第一个过滤器是距离过滤器，它将丢弃太远无法看到的敌人，然后是角度检查，它将检查我们视野内的敌人，最后是射线检查，它将丢弃被障碍物遮挡的敌人，比如墙壁。在开始之前，我想给出一个建议：我们将在这里使用向量数学，深入讨论这些主题超出了本书的范围。如果你不理解某些内容，可以随意复制并粘贴屏幕截图中的代码，并在网上查找相关概念。让我们按照以下方式编写传感器：
- en: Create an empty `GameObject` called `0,0,0``0,0,0)`, and `1,1,1`**)** so it
    will be aligned to the Enemy. While we can certainly just put all AI scripts directly
    in the Enemy, we did this just for separation and organization:![Figure 18.1 –
    AI scripts container
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`0,0,0``0,0,0)`和`1,1,1`的空`GameObject`，这样它就会与敌人对齐。虽然我们当然可以直接将所有AI脚本放在敌人身上，但我们之所以这样做只是为了分离和组织：![图18.1
    - AI脚本容器
- en: '](img/Figure_18.01_B14199.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.01_B14199.jpg)'
- en: Figure 18.1 – AI scripts container
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1 - AI脚本容器
- en: Create a script called `Sight` and add it to the AI child Object.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Sight`的脚本，并将其添加到AI子对象中。
- en: Create two fields of the `float` type called `distance` and `angle`, and another
    two of the `LayerMask` type called `obstaclesLayers` and `ObjectsLayers`. `distance`
    will be used as the vision distance, angle will determine the amplitude of the
    view cone, `ObstacleLayers` will be used by our obstacle check to determine which
    Objects are considered obstacles, and `ObjectsLayers` will be used to determine
    what types of Objects we want the sight to detect. We just want the sight to see
    enemies; we are not interested in Objects such as walls or power-ups. `LayerMask`
    is a property type that allows us to select one or more layers to use inside code,
    so we will be filtering Objects by layer. In a moment, you will see how we use
    it:![Figure 18.2 – Fields to parametrize our sight check
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个`float`类型的字段，分别命名为`distance`和`angle`，另外创建两个`LayerMask`类型的字段，分别命名为`obstaclesLayers`和`ObjectsLayers`。`distance`将用作视觉距离，`angle`将确定视野锥的幅度，`ObstacleLayers`将被我们的障碍物检查使用，以确定哪些对象被视为障碍物，`ObjectsLayers`将用于确定我们希望视线检测到的对象类型。我们只希望视线看到敌人；我们对墙壁或道具等对象不感兴趣。`LayerMask`是一种属性类型，允许我们在代码中选择一个或多个层，因此我们将通过层来过滤对象。稍后你将看到我们如何使用它：![图18.2
    - 用于参数化我们视线检查的字段
- en: '](img/Figure_18.02_B14199.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.02_B14199.jpg)'
- en: Figure 18.2 – Fields to parametrize our sight check
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.2 - 用于参数化我们视线检查的字段
- en: In `Update`, call `Physics.OverlapSphere` as in the next screenshot. This function
    creates an imaginary sphere in the place specified by the first parameter (in
    our case, our position) and with a radius specified in the second parameter (the
    `distance` property) to detect Objects with the layers specified in the third
    parameter (`ObjectsLayers`). It will return an array with all Objects Colliders
    found inside the sphere, these functions use Physics to do the check, so the Objects
    must have at least one collider. This is the way we will be using to get all enemies
    inside our view distance, and we will be further filtering them in the next steps.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`中，调用`Physics.OverlapSphere`，如下一个截图所示。此函数在由第一个参数指定的位置创建一个虚拟球体，并使用第二个参数（`distance`属性）中指定的半径来检测第三个参数（`ObjectsLayers`）中指定的层中的对象。它将返回一个包含在球体内找到的所有对象碰撞器的数组，这些函数使用物理学来进行检查，因此对象必须至少有一个碰撞器。这是我们将使用的方法，以获取视野距离内的所有敌人，并且我们将在接下来的步骤中进一步对它们进行过滤。
- en: Important Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Another way of accomplishing the first check is to just check the distance to
    the Player, or if looking for other kinds of Objects, to a Manager containing
    a list of them, but the way we chose is more versatile and can be used in any
    kind of Object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第一个检查的另一种方法是只检查到玩家的距离，或者如果寻找其他类型的对象，则检查到包含它们列表的管理器，但我们选择的方式更加灵活，可以用于任何类型的对象。
- en: Also, you might want to check the `Physics.OverlapSphereNonAlloc` version of
    this function, which does the same thing but is more performant by not allocating
    an array to return the results.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，您可能希望检查`Physics.OverlapSphereNonAlloc`版本的此函数，它执行相同的操作，但通过不分配数组来返回结果，因此性能更高。
- en: Iterate over the array of Objects returned by the function:![Figure 18.3 Getting
    all Objects at a certain distance](img/Figure_18.03_B14199.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历函数返回的对象数组：![图18.3 获取特定距离处的所有对象](img/Figure_18.03_B14199.jpg)
- en: Figure 18.3 – Getting all Objects at a certain distance
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.3 - 获取特定距离处的所有对象
- en: To detect whether the Object falls inside the vision cone, we need to calculate
    the angle between our viewing direction and the direction to the Object itself.
    If the angle between those two directions is less than our cone angle, we consider
    that the Object falls inside our vision. We can start detecting the direction
    toward the Object, which is calculated normalizing the difference between the
    Object position and ours, like in the following screenshot. You might notice we
    used `bounds.center` instead of `transform.position`; this way, we check the direction
    to the center of the Object instead of its pivot. Remember that the Player's pivot
    is in the ground and the ray check might collide against it before the Player:![Figure
    18.4 Calculating direction from our position toward the collider](img/Figure_18.04_B14199.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检测对象是否落在视野锥内，我们需要计算我们的观察方向和对象本身方向之间的角度。如果这两个方向之间的角度小于我们的锥角，我们认为对象落在我们的视野内。我们可以开始检测朝向对象的方向，这是通过归一化对象位置与我们位置之间的差异来计算的，就像下面的截图中所示的那样。您可能会注意到我们使用`bounds.center`而不是`transform.position`；这样，我们检查对象的中心方向而不是其枢轴。请记住，玩家的枢轴在地面上，射线检查可能会在玩家之前与其发生碰撞：![图18.4
    从我们的位置计算朝向碰撞器的方向](img/Figure_18.04_B14199.jpg)
- en: Figure 18.4 – Calculating direction from our position toward the collider
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4 - 从我们的位置计算朝向碰撞器的方向
- en: We can use the `Vector3.Angle` function to calculate the angle between two directions.
    In our case, we can calculate the angle between the direction toward the Enemy
    and our forward vector to see the angle:![Figure 18.5 Calculating the angle between
    two directions
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`Vector3.Angle`函数来计算两个方向之间的角度。在我们的情况下，我们可以计算朝向敌人的方向和我们的前向量之间的角度：![图18.5
    计算两个方向之间的角度
- en: '](img/Figure_18.05_B14199.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.05_B14199.jpg)'
- en: Figure 18.5 – Calculating the angle between two directions
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.5 - 计算两个方向之间的角度
- en: IMPORTANT INFO
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: If you want, you can instead use `Vector3.Dot`, which will execute a dot product.
    `Vector3.Angle` actually uses that one, but to convert the result of the dot product
    into an angle, it needs to use trigonometry and this can be expensive to calculate.
    Anyway, our approach is simpler and fast while you don't have a big number of
    sensors (50+, depending on the target device), which won't happen in our case.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以使用`Vector3.Dot`，它将执行点积。`Vector3.Angle`实际上使用了这个函数，但是为了将点积的结果转换为角度，它需要使用三角函数，这可能会导致昂贵的计算。无论如何，我们的方法更简单快速，只要您没有大量传感器（50+，取决于目标设备），这在我们的情况下不会发生。
- en: Now check whether the calculated angle is less than the one specified in the
    `angle` field. Consider that if we set an angle of 90 degrees, it will be actually
    180 degrees, because if the `Vector3.Angle` function returns, as an example, 30,
    it can be 30 to the left or the right. If our angle says 90 degrees, it can be
    both 90 degrees to the left or to the right, so it will detect Objects in a 180-degree
    arc.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在检查计算出的角度是否小于`angle`字段中指定的角度。请注意，如果我们设置为90度，实际上将是180度，因为如果`Vector3.Angle`函数返回，例如，30，它可以是30度向左或向右。如果我们的角度为90度，它可以是左侧或右侧的90度，因此它将检测到180度弧中的对象。
- en: Use the `Physics.Line` function to create an imaginary line between the first
    and the second parameter (our position and the collider position) to detect Objects
    with the layers specified in the third parameter (the `obstacles` layers) and
    return `boolean` indicating whether that ray hit something or not. The idea is
    to use the line to detect whether there are any obstacles between ourselves and
    the detected collider, and if there is no obstacle, this means that we have a
    direct line of sight toward the Object. Again, remember that this function depends
    on the obstacle Objects having colliders, which in our case, we have (walls, floor,
    and so on):![Figure 18.6 – Using a Line Cast to check obstacles between the sensor
    and the target Object
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Physics.Line`函数在我们的位置和碰撞体位置之间创建一条虚拟线，以检测在第三个参数中指定的层（`obstacles`层）中的对象，并返回一个`boolean`，指示该射线是否击中了某物体。这个想法是使用这条线来检测我们和检测到的碰撞体之间是否有障碍物，如果没有障碍物，这意味着我们对该对象有直线视线。再次提醒，这个函数依赖于障碍物对象有碰撞体，而在我们的情况下，我们有（墙壁、地板等）：![图18.6
    - 使用线性投射检查传感器和目标对象之间的障碍物
- en: '](img/Figure_18.06_B14199.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.06_B14199.jpg)'
- en: Figure 18.6 – Using a Line Cast to check obstacles between the sensor and the
    target Object
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.6 - 使用线性投射检查传感器和目标对象之间的障碍物
- en: If the Object passes the three checks that means that this is the Object we
    are currently seeing, so we can save it inside a field of the `Collider` type
    called `detectedObject`, to save that information for later usage by the rest
    of the AI scripts. Consider using `break` to stop `for` that is iterating the
    colliders to prevent wasting resources by checking the other Objects, and to set
    `detectedObject` to `null` before `for` to clear the result from the previous
    frame, so in case, in this frame, we don't detect anything, it will keep the null
    value so we can notice that there is nothing in the sensor:![Figure 18.7 Full
    sensor script
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对象通过了三个检查，这意味着这是我们当前看到的对象，所以我们可以将它保存在一个名为`detectedObject`的`Collider`类型字段中，以便其他AI脚本稍后使用这些信息。考虑使用`break`来停止`for`循环，以防止浪费资源检查其他对象，并在`for`之前将`detectedObject`设置为`null`，以清除上一帧的结果，所以在这一帧中，如果我们没有检测到任何东西，它将保持空值，这样我们就可以注意到传感器中没有东西：![图18.7
    完整的传感器脚本
- en: '](img/Figure_18.07_B14199.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.07_B14199.jpg)'
- en: Figure 18.7 – Full sensor script
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.7 - 完整的传感器脚本
- en: IMPORTANT INFO
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: In our case, we are using the sensor just to look for the Player, the only Object
    the sensor is in charge of looking for, but if you want to make the sensor more
    advanced, you can just keep a list of detected Objects, placing inside it every
    Object that passes the three tests instead of just the first one.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们只是使用传感器来寻找玩家，这是传感器负责寻找的唯一对象，但如果你想使传感器更高级，你可以保持一个检测到的对象列表，将通过三个测试的每个对象放入其中，而不仅仅是第一个对象。
- en: In the Editor, configure the sensor as you wish. In this case, we will set `ObjectsLayer`
    to `Player` so our sensor will focus its search on Objects with that layer, and
    `obstaclesLayer` to `Default`, the layer we used for walls and floors:![Figure
    18.8 Sensor settings
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，根据需要配置传感器。在这种情况下，我们将`ObjectsLayer`设置为`Player`，这样我们的传感器将专注于具有该层的对象，并将`obstaclesLayer`设置为`Default`，这是我们用于墙壁和地板的层：![图18.8
    传感器设置
- en: '](img/Figure_18.08_B14199.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.08_B14199.jpg)'
- en: Figure 18.8 – Sensor settings
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.8 - 传感器设置
- en: 'To test this, just place an Enemy with a movement speed of 0 in front of the
    Player, select its AI child Object and then play the game to see how the property
    is set in the Inspector. Also, try putting an obstacle between the two and check
    that the property says "None" (`null`). If you don''t get the expected result,
    double-check your script, its configuration, and whether the Player has the `Player`
    layer and the obstacles have the `Default` layer. Also, you might need to raise
    the AI Object a little bit to prevent the ray from starting below the ground and
    hitting it:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这一点，只需在玩家面前放置一个移动速度为0的敌人，选择其AI子对象，然后播放游戏，看看属性在检查器中是如何设置的。还可以尝试在两者之间放置障碍物，并检查属性是否显示为“None”（`null`）。如果没有得到预期的结果，请仔细检查你的脚本、它的配置，以及玩家是否有`Player`层，障碍物是否有`Default`层。此外，你可能需要稍微提高AI对象，以防止射线从地面下方开始并击中地面：
- en: '![Figure 18.9 The sensor capturing the Player'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图18.9 传感器捕捉玩家'
- en: '](img/Figure_18.09_B14199.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.09_B14199.jpg)'
- en: Figure 18.9 – The sensor capturing the Player
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.9 - 传感器捕捉玩家
- en: Even if we have our sensor working, sometimes checking whether it's working
    or configured properly requires some visual aids we can create using `Gizmos`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的传感器工作了，有时检查它是否工作或配置正确需要一些我们可以使用`Gizmos`创建的视觉辅助工具。
- en: Debugging with Gizmos
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Gizmos进行调试
- en: As we will create our AI, we will start to detect certain errors in edge cases,
    usually related to misconfigurations. You may think that the Player falls inside
    the sight of the Enemy but maybe you cannot see that the line of sight is occluded
    by an Object, especially as the enemies move constantly. A good way to debug those
    scenarios is through Editor-only visual aids known as `Gizmos`, which allows you
    to visualize invisible data such as the sight distance or the line casts executed
    to detect obstacles.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建我们的AI时，我们将开始检测到一些边缘情况的错误，通常与错误配置有关。你可能认为玩家在敌人的视线范围内，但也许你没有注意到视线被物体遮挡，特别是当敌人不断移动时。调试这些情况的一个好方法是通过仅在编辑器中可见的视觉辅助工具，称为`Gizmos`，它允许你可视化不可见的数据，比如视线距离或执行线性投射以检测障碍物。
- en: 'Let''s start seeing how to create `Gizmos` by drawing a sphere representing
    the sight distance by doing the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始看如何通过绘制代表视线距离的球体来创建`Gizmos`，方法如下：
- en: In the `Sight` script, create an event function called `OnDrawGizmos`. This
    event is only executed in the Editor (not in builds) and is the place Unity asks
    us to draw `Gizmos`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Sight`脚本中，创建一个名为`OnDrawGizmos`的事件函数。这个事件只在编辑器中执行（不在构建中执行），是Unity要求我们绘制`Gizmos`的地方。
- en: Use the `Gizmos.DrawWireSphere` function passing our position as the first parameter
    and the distance as the second parameter to draw a sphere in our position with
    the radius of our distance. You can check how the size of the Gizmo changes as
    you change the distance field:![Figure 18.10 Sphere Gizmo](img/Figure_18.10_B14199.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Gizmos.DrawWireSphere`函数，将我们的位置作为第一个参数，距离作为第二个参数，以在我们的位置绘制一个半径为我们距离的球体。您可以检查随着更改距离字段而Gizmo大小的变化：![图18.10
    球体Gizmo](img/Figure_18.10_B14199.jpg)
- en: Figure 18.10 – Sphere Gizmo
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.10 - 球体Gizmo
- en: Optionally, you can change the color of the Gizmo, setting `Gizmos.color` prior
    to calling the drawing functions:![Figure 18.11 Gizmos drawing code](img/Figure_18.11_B14199.jpg)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，您可以更改Gizmo的颜色，设置`Gizmos.color`然后调用绘图函数：![图18.11 Gizmos绘图代码](img/Figure_18.11_B14199.jpg)
- en: Figure 18.11 – Gizmos drawing code
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.11 - Gizmos绘图代码
- en: IMPORTANT INFO
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: Now you are drawing `Gizmos` constantly, and if you have lots of enemies, they
    can pollute the scene view with too many `Gizmos`. In that case, try the `OnDrawGizmosSelected`
    event function instead, which draws `Gizmos` only if the Object is selected.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你不断地绘制“Gizmos”，如果你有很多敌人，它们可能会用太多的“Gizmos”污染场景视图。在这种情况下，可以尝试使用`OnDrawGizmosSelected`事件函数，它只在对象被选中时绘制“Gizmos”。
- en: We can draw the lines representing the cone using `Gizmos.DrawRay`, which receives
    the origin of the line to draw and the direction of the line, which can be multiplied
    by a certain value to specify the length of the line, as in the following screenshot:![Figure
    18.12 Drawing rotated lines](img/Figure_18.12_B14199.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`Gizmos.DrawRay`来绘制代表锥体的线，它接收要绘制的线的起点和线的方向，可以乘以某个值来指定线的长度，如下面的屏幕截图所示：![图18.12
    绘制旋转线](img/Figure_18.12_B14199.jpg)
- en: Figure 18.12 – Drawing rotated lines
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.12 - 绘制旋转线
- en: 'In the screenshot, we used `Quaternion.Euler` to generate a quaternion based
    on the angles we want to rotate. If you multiply this quaternion by a direction,
    we will get the rotated direction. We are taking our forward vector and rotating
    it according to the angle field to generate our cone vision lines. Also, we multiply
    this direction by the sight distance to draw the line as far as our sight can
    see; you will see how the line matches the end of the sphere this way:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕截图中，我们使用`Quaternion.Euler`根据我们想要旋转的角度生成一个四元数。如果将这个四元数乘以一个方向，我们将得到旋转后的方向。我们正在取我们的前向矢量，并根据角度字段旋转它，以生成我们的锥体视觉线。此外，我们将这个方向乘以视距，以绘制线条，使其能够看到我们的视线有多远；您将看到线条如何与球体的末端匹配：
- en: '![Figure 18.13 Vision Angle lines](img/Figure_18.13_B14199.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图18.13 视觉角线](img/Figure_18.13_B14199.jpg)'
- en: Figure 18.13 – Vision Angle lines
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.13 - 视觉角线
- en: 'We can also draw the line casts, which check the obstacles, but as those depend
    on the current situation of the game, such as the Objects that pass the first
    two checks and their positions, we can use `Debug.DrawLine` instead, which can
    be executed in the `Update` method. This version of `DrawLine` is designed to
    be used in runtime only. The `Gizmos` we saw also executes in the Editor. Let''s
    try them the following way:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以绘制线条投射，检查障碍物，但是由于这些取决于游戏的当前情况，例如通过前两个检查的对象及其位置，因此我们可以使用`Debug.DrawLine`，它可以在`Update`方法中执行。这个版本的`DrawLine`设计为仅在运行时使用。我们在编辑器中看到的`Gizmos`也是在编辑器中执行的。让我们尝试以下方式：
- en: First, let's debug the scenario where `LineCast` didn't detect any obstacles,
    so we need to draw a line between our sensor and the Object. We can call `Debug.DrawLine`
    in the `if` statement that calls `LineCast`, as in the following screenshot:![Figure
    18.14 Drawing a line in Update
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们调试`LineCast`未检测到任何障碍物的情况，因此我们需要在我们的传感器和对象之间绘制一条线。我们可以在调用`LineCast`的`if`语句中调用`Debug.DrawLine`，如下面的屏幕截图所示：![图18.14
    在Update中绘制一条线
- en: '](img/Figure_18.14_B14199.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.14_B14199.jpg)'
- en: Figure 18.14 – Drawing a line in Update
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.14 - 在Update中绘制一条线
- en: In the next screenshot, you can see `DrawLine` in action:![Figure 18.15 Line
    toward the detected Object](img/Figure_18.15_B14199.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕截图中，您可以看到`DrawLine`的效果：![图18.15 指向检测到的对象的线](img/Figure_18.15_B14199.jpg)
- en: Figure 18.15 – Line toward the detected Object
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.15 - 指向检测到的对象的线
- en: We also want to draw a line in red when the sight is occluded by an Object.
    In this case, we need to know where the Line Cast hit, so we can use an overload
    of the function, which provides an `out` parameter that gives us more information
    about what the line collided with, such as the position of the hit and the normal
    and the collided Object, as in the following screenshot:![Figure 18.16 Getting
    information about LineCast
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当视线被对象遮挡时，我们还希望以红色绘制一条线。在这种情况下，我们需要知道Line Cast的命中位置，因此我们可以使用函数的一个重载，它提供了一个`out`参数，可以提供有关线碰撞的更多信息，例如命中的位置、法线和碰撞的对象，如下面的屏幕截图所示：![图18.16
    获取有关LineCast的信息
- en: '](img/Figure_18.16_B14199.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.16_B14199.jpg)'
- en: Figure 18.16 – Getting information about Linecast
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.16 - 获取有关Linecast的信息
- en: IMPORTANT INFO
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: Consider that `Linecast` doesn't always collide with the nearest obstacle but
    with the first Object it detects in the line, which can vary in order. If you
    need to detect the nearest obstacle, look for the `Physics.Raycast` version of
    the function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Linecast`并不总是与最近的障碍物发生碰撞，而是与它在线上检测到的第一个对象发生碰撞，这可能会按顺序变化。如果您需要检测最近的障碍物，请查找该函数的`Physics.Raycast`版本。
- en: We can use that information to draw the line from our position to the hit point
    in the `else` clause of the `if` sentence, when the line collides with something:![Figure
    18.17 Drawing a line in case we have an obstacle
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用这些信息在`else`子句中绘制从我们的位置到命中点的线，当线与某物发生碰撞时：![图18.17 在我们遇到障碍物时绘制一条线
- en: '](img/Figure_18.17_B14199.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.17_B14199.jpg)'
- en: Figure 18.17 – Drawing a line in case we have an obstacle
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.17 - 在我们遇到障碍物时绘制一条线
- en: 'In the next screenshot, you can see the results:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕截图中，您可以看到结果：
- en: '![Figure 18.18 Line when an obstacle occludes vision'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图18.18 当障碍物遮挡视线时的线'
- en: '](img/Figure_18.18_B14199.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.18_B14199.jpg)'
- en: Figure 18.18 – Line when an obstacle occludes vision
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.18 - 当障碍物遮挡视线时的线
- en: Now that we have our sensors completed, let's use the information provided by
    them to make decisions with **Finite State Machines (FSMs)**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的传感器已经完成，让我们使用它们提供的信息来使用**有限状态机（FSM）**做出决策。
- en: Making decisions with FSMs
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FSM做出决策
- en: We explored the concept of FSMs in the past when we used them in the Animator.
    We learned that an FSM is a collection of states, each one representing an action
    that an Object can be executing at a time, and a set of transitions that dictates
    how the states are switched. This concept is not only used in Animation but in
    a myriad of programming scenarios, and one of the common ones is in AI. We can
    just replace the animations with AI code in the states and we have an AI FSM.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在过去使用Animator时探讨了FSM的概念。我们了解到FSM是一组状态的集合，每个状态代表对象可以执行的动作，以及一组决定状态切换方式的转换。这个概念不仅在动画中使用，而且在许多编程场景中都有应用，其中一个常见的应用是在AI中。我们可以用AI代码替换状态中的动画，就得到了AI
    FSM。
- en: 'In this section, we will examine the following AI FSM concepts:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究以下AI FSM概念：
- en: Creating the FSM
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建FSM
- en: Creating transitions
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建转换
- en: Let's start creating our FSM skeleton.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的FSM骨架。
- en: Creating the FSM
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建FSM
- en: 'To create our own FSM, we need to recap some basic concepts. Remember that
    an FSM can have a state for each possible action it can execute and that only
    one can be executed at a time. In terms of AI, we can be Patrolling, Attacking,
    Fleeing, and so on. Also, remember that there are transitions between States that
    determine conditions to be met to change from one state to the other, and in terms
    of AI, this can be the user being near the Enemy to start attacking or life being
    low to start fleeing. In the next screenshot, you can find a simple reminder example
    of the two possible states of a door:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们自己的FSM，我们需要回顾一些基本概念。记住，FSM可以为它可以执行的每个可能动作都有一个状态，而且一次只能执行一个动作。在AI方面，我们可以巡逻，攻击，逃跑等。还要记住，状态之间存在转换，确定改变一个状态到另一个状态需要满足的条件，就AI而言，这可以是用户靠近敌人开始攻击或生命值低开始逃跑。在下一个截图中，你可以找到一个门的两种可能状态的简单提醒示例：
- en: '![Figure 18.19 FSM example'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图18.19 FSM示例'
- en: '](img/Figure_18.19_B14199.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.19_B14199.jpg)'
- en: Figure 18.19 – FSM example
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.19 - FSM示例
- en: 'There are several ways to implement FSMs for AI; you can even use the Animator
    if you want to or download some FSM system from the Asset Store. In our case,
    we are going to take the simplest approach possible, a single script with a set
    of `If` sentences, which can be basic but is still a good start to understand
    the concept. Let''s implement it by doing the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以为AI实现FSM；你甚至可以使用Animator，或者从Asset Store下载一些FSM系统。在我们的情况下，我们将采取尽可能简单的方法，一个带有一组`If`语句的单个脚本，这可能很基础，但仍然是理解概念的良好开始。让我们通过以下方式实现它：
- en: Create a script called `EnemyFSM` in the AI child Object of the Enemy.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Enemy的AI子对象中创建一个名为`EnemyFSM`的脚本。
- en: Create `enum` called `EnemyState` with the `GoToBase`, `AttackBase`, `ChasePlayer`,
    and `AttackPlayer` values. We are going to have those states in our AI.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`EnemyState`的`enum`，其中包含`GoToBase`，`AttackBase`，`ChasePlayer`和`AttackPlayer`值。我们将在我们的AI中拥有这些状态。
- en: Create a field of the `EnemyState` type called `currentState`, which will hold,
    well, the current state of our Enemy:![Figure 18.20 EnemyFSM states definition](img/Figure_18.20_B14199.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`currentState`的`EnemyState`类型字段，它将保存我们的Enemy的当前状态：![图18.20 EnemyFSM状态定义](img/Figure_18.20_B14199.jpg)
- en: Figure 18.20 – EnemyFSM states definition
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.20 - EnemyFSM状态定义
- en: Create three functions named after the states we defined.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个以我们定义的状态命名的函数。
- en: Call those functions in `Update` depending on the current state:![Figure 18.21
    If-based FSM](img/Figure_18.21_B14199.jpg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据当前状态在`Update`中调用这些函数：![图18.21 基于If的FSM](img/Figure_18.21_B14199.jpg)
- en: Figure 18.21 – If-based FSM
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.21 - 基于If的FSM
- en: IMPORTANT INFO
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: Yes, you can totally use a switch here, but I just prefer the regular `if` syntax.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你完全可以在这里使用switch，但我更喜欢常规的`if`语法。
- en: 'Test in the Editor how changing the `currentState` field will change which
    state is active, seeing the messages being printed in the console:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中测试如何改变`currentState`字段将改变哪个状态是活动的，看到在控制台中打印的消息：
- en: '![Figure 18.22 States testing](img/Figure_18.22_B14199.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图18.22 状态测试](img/Figure_18.22_B14199.jpg)'
- en: Figure 18.22 – States testing
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.22 - 状态测试
- en: As you can see, it is a pretty simple but totally functional approach, so let's
    continue with this FSM, creating its transitions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个非常简单但完全功能的方法，所以让我们继续使用这个FSM，创建它的转换。
- en: Creating transitions
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建转换
- en: 'If you remember the transitions created in the Animator Controller, those were
    basically a collection of conditions that are checked if the state the transition
    belongs to is active. In our FSM approach, this translates simply as If sentences
    that detect conditions inside the states. Let''s create the transitions between
    our proposed states as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得在Animator Controller中创建的转换，那些基本上是一组条件，如果转换所属的状态处于活动状态，则检查这些条件。在我们的FSM方法中，这简单地转换为在状态内检测条件的If语句。让我们按照以下方式创建我们提出的状态之间的转换：
- en: Add a field of the `Sight` type called `sightSensor` in our FSM script, and
    drag the AI `GameObject` to that field to connect it to the `Sight` component
    there. As the FSM component is in the same Object as `Sight`, we can also use
    `GetComponent` instead, but in advanced AIs, you might have different sensors
    that detect different Objects, so I prefer to prepare my script for that scenario,
    but pick the approach you like the most.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的FSM脚本中添加一个名为`sightSensor`的`Sight`类型字段，并将AI `GameObject`拖到该字段中，将其连接到那里的`Sight`组件。由于FSM组件与`Sight`位于同一对象中，我们也可以使用`GetComponent`，但在高级AI中，你可能有不同的传感器检测不同的对象，所以我更喜欢为这种情况准备我的脚本，但选择你最喜欢的方法。
- en: In the `GoToBase` function, check whether the detected Object of the `Sight`
    component is not `null`, meaning that something is inside our line of vision.
    If our AI is going toward the base but detects an Object in the way there, we
    must switch to the `Chase` state to pursue the Player, so we change the state,
    as in the following screenshot:![Figure 18.23 Creating transitions
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GoToBase`函数中，检查`Sight`组件检测到的对象是否不为`null`，这意味着我们的视线内有东西。如果我们的AI正在前往基地，但在路上检测到一个对象，我们必须切换到`Chase`状态以追击玩家，所以我们改变状态，如下面的屏幕截图所示：![图18.23
    创建转换
- en: '](img/Figure_18.23_B14199.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.23_B14199.jpg)'
- en: Figure 18.23 – Creating transitions
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.23 - 创建转换
- en: Also, we must change to `AttackBase` in case we are near enough the Object that
    must be damaged to decrease the base life. We can create a field of the `Transform`
    type called `baseTransform` and drag the Base Life Object there so we can check
    the distance. Remember to add a `float` field called `baseAttackDistance` to make
    that distance configurable:![Figure 18.24 Go to Base Transitions
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们必须在靠近必须受损的对象时切换到`AttackBase`。我们可以创建一个`Transform`类型的字段，称为`baseTransform`，并将基地生命对象拖放到那里，以便我们可以检查距离。记得添加一个名为`baseAttackDistance`的`float`字段，以使该距离可配置：![图18.24
    前往基地转换
- en: '](img/Figure_18.24_B14199.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.24_B14199.jpg)'
- en: Figure 18.24 – Go to Base Transitions
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.24 - 前往基地转换
- en: In the case of `ChasePlayer`, we need to check whether the Player is out of
    sight to switch back to the `GoToBase` state or whether we are near enough the
    `Player` to start attacking it. We will need another `distance` field, which determines
    the distance to attack the Player, and we might want different attack distances
    for those two targets. Consider an early return in the transition to prevent getting
    `null` reference exceptions if we try to access the position of the sensor-detected
    Object when there is none:![Figure 18.25 Chase Player Transitions
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ChasePlayer`的情况下，我们需要检查玩家是否不在视线内，以切换回`GoToBase`状态，或者我们是否足够接近玩家以开始攻击它。我们将需要另一个`distance`字段，用于确定攻击玩家的距离，我们可能希望为这两个目标设置不同的攻击距离。考虑在转换中进行早期返回，以防止在没有对象时尝试访问传感器检测到的对象的位置时出现`null`引用异常：![图18.25
    追击玩家转换
- en: '](img/Figure_18.25_B14199.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.25_B14199.jpg)'
- en: Figure 18.25 – Chase Player Transitions
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.25 - 追击玩家转换
- en: For `AttackPlayer`, we need to check whether `Player` is out of sight to get
    back to `GoToBase` or whether it is far enough to go back to chasing it. You can
    notice how we multiplied `PlayerAttackDistance` to make the stop-attacking distance
    a little bit larger than the start-attacking distance; this will prevent switching
    back and forth rapidly between attack and chase when the Player is near that distance.
    You can make it configurable instead of hardcoding `1.1`:![Figure 18.26 – Attack
    Player Transitions
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`AttackPlayer`，我们需要检查`Player`是否不在视线内，以返回到`GoToBase`，或者它是否足够远，以返回追击它。您可以注意到我们将`PlayerAttackDistance`乘以`1.1`，使停止攻击的距离比开始攻击的距离大一点；这将防止在玩家接近该距离时快速在攻击和追击之间切换。您可以使其可配置，而不是硬编码`1.1`：![图18.26
    - 攻击玩家转换
- en: '](img/Figure_18.26_B14199.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.26_B14199.jpg)'
- en: Figure 18.26 – Attack Player Transitions
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.26 - 攻击玩家转换
- en: In our case, `AttackBase` won't have any transition. Once the Enemy is near
    enough the base to attack it, it will stay like that, even if the Player starts
    shooting at it. Its only objective once there is to destroy the base.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的情况下，`AttackBase`不会有任何转换。一旦敌人靠近基地足够攻击它，即使玩家开始向它射击，它也会保持这样。一旦到达那里，它的唯一目标就是摧毁基地。
- en: Remember you can use `Gizmos` to draw the distances:![Figure 18.27 FSM Gizmos
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得你可以使用`Gizmos`来绘制距离：![图18.27 FSM小工具
- en: '](img/Figure_18.27_B14199.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.27_B14199.jpg)'
- en: Figure 18.27 – FSM Gizmos
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.27 - FSM小工具
- en: 'Test the script selecting the AI Object prior to hitting play and then move
    the Player around, checking how the states change in the inspector. You can also
    keep the original print messages in each state to see them changing in the console.
    Remember to set the attack distances and the references to the Objects. In the
    screenshot, you can see the settings we use:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击播放之前，测试选择AI对象的脚本，然后移动玩家，检查状态在检查器中的变化。您还可以保留每个状态中的原始打印消息，以在控制台中查看它们的变化。记得设置攻击距离和对象的引用。在屏幕截图中，您可以看到我们使用的设置：
- en: '![Figure 18.28 Enemy FSM settings'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图18.28 敌人FSM设置'
- en: '](img/Figure_18.28_B14199.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.28_B14199.jpg)'
- en: Figure 18.28 – Enemy FSM settings
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.28 - 敌人FSM设置
- en: A little problem that we will have now is that the spawned enemies won't have
    the needed references to make the distance calculations toward the Base Transform.
    You will notice that if you try to apply the changes on the Enemy of the scene
    to the Prefab (`None`. Remember that Prefabs cannot contain references to Objects
    in the scene, which complicates our work here. One alternative would be to create
    `BaseManager`, a Singleton that holds the reference to the damage position, so
    our `EnemyFSM` can access it. Another one could be to make use of functions such
    as `GameObject.Find` to find our Object.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将遇到的一个小问题是，生成的敌人将没有必要的引用，无法进行基地变换的距离计算。如果您尝试将场景中的敌人的更改应用到预制件（`None`），您将注意到这一点。请记住，预制件不能包含对场景中对象的引用，这使得我们的工作变得复杂。一个替代方法是创建`BaseManager`，一个保存对伤害位置的引用的单例，这样我们的`EnemyFSM`就可以访问它。另一个方法可能是利用`GameObject.Find`等函数来找到我们的对象。
- en: 'In this case, we will try the latter. Even if it can be less performant than
    the Manager version, I want to show you how to use it to expand your Unity toolset.
    In this case, just set the `baseTransform` field in `Awake` to the return of `GameObject.Find`,
    using `BaseDamagePoint` as the first parameter, which will look for an Object
    called like that, as in the following screenshot. Also, feel free to remove the
    private keyword from the `baseTransform` field; now that is set via code, it makes
    little sense to display it in the Editor other than to debug it. You will see
    that now our wave-spawned enemies will change states:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将尝试后者。即使它可能比Manager版本的性能要差一些，我还是想向你展示如何使用它来扩展你的Unity工具集。在这种情况下，只需在`Awake`中将`baseTransform`字段设置为`GameObject.Find`的返回值，使用`BaseDamagePoint`作为第一个参数，它将查找一个叫这个名字的对象，就像下面的截图一样。同时，可以自由地从`baseTransform`字段中删除private关键字；现在通过代码设置了它，将其显示在编辑器中除了用于调试之外没有太大意义。你会看到，现在我们生成的敌人将改变状态：
- en: '![Figure 18.29 Searching for an Object in the scene by name'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图18.29 按名称在场景中搜索对象'
- en: '](img/Figure_18.29_B14199.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.29_B14199.jpg)'
- en: Figure 18.29 – Searching for an Object in the scene by name
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.29 - 按名称在场景中搜索对象
- en: Now that our FSM states are coded and transition properly, let's make them do
    something.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的FSM状态已经编码并且过渡正常，让它们做点什么吧。
- en: Executing FSM actions
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行FSM动作
- en: Now we need to do the last step—make the FSM do something interesting. Here,
    we can do a lot of things such as shoot the base or the Player and move the Enemy
    toward its target (the Player or the base). We will be handling movement with
    the Unity Pathfinding system called `NavMesh`, a tool that allows our AI to calculate
    and traverse paths between two points avoiding obstacles, which needs some preparation
    to work properly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做最后一步 - 让FSM做一些有趣的事情。在这里，我们可以做很多事情，比如射击基地或玩家，并将敌人移向其目标（玩家或基地）。我们将使用Unity路径规划系统`NavMesh`来处理移动，这是一个允许我们的AI计算和穿越两点之间的路径并避开障碍物的工具，需要一些准备工作才能正常工作。
- en: 'In this section, we will examine the following FSM action concepts:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下FSM动作概念：
- en: Calculating our scene Pathfinding
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算我们场景的路径规划
- en: Using Pathfinding
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路径规划
- en: Adding final details
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加最后的细节
- en: Let's start preparing our scene for movement with Pathfinding.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为路径规划准备我们的场景。
- en: Calculating our scene Pathfinding
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算我们场景的路径规划
- en: 'Pathfinding algorithms rely on simplified versions of the scene. Analyzing
    the full geometry of a complex scene is almost impossible to do in real time.
    There are several ways to represent Pathfinding information extracted from a scene,
    such as Graphs and `NavMesh` geometries. Unity uses the latter—a simplified mesh
    similar to a 3D model that spans over all areas that Unity determines are walkable.
    In the next screenshot, you can find an example of a `NavMesh` generated in a
    scene, that is, the light blue geometry:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 路径规划算法依赖于场景的简化版本。在实时中分析复杂场景的完整几何形状几乎是不可能的。表示从场景中提取的路径规划信息的方法有很多，比如图形和`NavMesh`几何。Unity使用后者
    - 一个简化的网格，类似于跨越Unity确定为可行走区域的所有区域的3D模型。在下一个截图中，你可以找到一个在场景中生成的`NavMesh`的示例，即浅蓝色的几何体：
- en: '![Figure 18.30 NavMesh of walkable areas in the scene](img/Figure_18.30_B14199.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图18.30 场景中可行走区域的NavMesh](img/Figure_18.30_B14199.jpg)'
- en: Figure 18.30 – NavMesh of walkable areas in the scene
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.30 - 场景中可行走区域的NavMesh
- en: Generating a `NavMesh` can take from seconds to minutes depending on the size
    of the scene. That's why Unity's Pathfinding system calculates that once in the
    Editor, so when we distribute our game, the user will use the pre-generated `NavMesh`.
    Just like Lightmapping, a `NavMesh` is baked into a file for later usage. Like
    Lightmapping, the main caveat here is that the `NavMesh` Objects cannot change
    during runtime. If you destroy or move a floor tile, the AI will still walk over
    that area. The `NavMesh` on top of that didn't notice the floor isn't there anymore,
    so you are not able to move or modify those Objects in any way. Luckily, in our
    case, we won't suffer any modification of the scene during runtime, but remember
    that there are components such as `NavMeshObsacle` that can help us in those scenarios.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 生成`NavMesh`可能需要几秒到几分钟，这取决于场景的大小。这就是为什么Unity的路径规划系统在编辑器中计算一次，所以当我们分发我们的游戏时，用户将使用预先生成的`NavMesh`。就像光照贴图一样，`NavMesh`被烘焙到一个文件中以供以后使用。与光照贴图一样，主要的警告是`NavMesh`对象在运行时不能改变。如果你销毁或移动地板砖，AI仍然会走在那个区域。`NavMesh`也没有注意到地板不在了，所以你不能以任何方式移动或修改这些对象。幸运的是，在我们的情况下，我们不会在运行时遭受场景的任何修改，但是请记住，有一些组件，比如`NavMeshObsacle`，可以在这些情况下帮助我们。
- en: 'To generate a `NavMesh` for our scene, do the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的场景生成`NavMesh`，请执行以下操作：
- en: Select any walkable Object and the obstacles on top of it, such as floors, walls,
    and other obstacles, and mark them as `Static`. You might remember that the `Static`
    checkbox also affects Lightmapping, so if you want an Object not to be part of
    Lightmapping but contribute to the `NavMesh` generation, you can click the arrow
    at the left of the static check and select `NavMesh` generation speed. Making
    the Terrain navigable, in our case, will increase generation time a lot and we
    will never play in that area.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何可行走的对象以及其上的障碍物，比如地板、墙壁和其他障碍物，并将它们标记为`Static`。你可能还记得`Static`复选框也会影响光照贴图，所以如果你希望一个对象不参与光照贴图但对`NavMesh`的生成有贡献，你可以点击静态检查左侧的箭头，并选择`NavMesh`生成速度。在我们的情况下，使地形可通行会大大增加生成时间，我们永远不会在那个区域玩。
- en: Open the `NavMesh` panel in **Window | AI | Navigation**.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**窗口|AI|导航**中打开`NavMesh`面板。
- en: 'Select the `NavMesh`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`NavMesh`：
- en: '![Figure 18.31 Generating a NavMesh'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图18.31 生成NavMesh'
- en: '](img/Figure_18.31_B14199.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.31_B14199.jpg)'
- en: Figure 18.31 – Generating a NavMesh
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.31 - 生成NavMesh
- en: And that's pretty much everything you need to do. Of course, there are lots
    of settings you can fiddle around with, such as `NavMesh`, but as we have a plain
    and simple scene, the default settings will suffice.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上你需要做的就是这些。当然，还有很多设置可以调整，比如`NavMesh`，但是由于我们的场景简单明了，所以默认设置就足够了。
- en: Now, let's make our AI move around the `NavMesh`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让我们的AI在NavMesh周围移动。
- en: Using Pathfinding
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用路径规划
- en: For making an AI Object that moves with `NavMesh`, Unity provides the `NavMeshAgent`
    component, which will make our AI stick to the `NavMesh`, preventing the Object
    to go outside it. It will not only calculate the Path to a specified destination
    automatically but also will move the Object through the path with the use of Steering
    behavior algorithms that mimic the way a human would move through the path, slowing
    down on corners and turning with interpolations instead of instantaneously. Also,
    this component is capable of evading other `NavMeshAgents` running in the scene,
    preventing all of the enemies from collapsing in the same position.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作一个使用NavMesh移动的AI对象，Unity提供了NavMeshAgent组件，它将使我们的AI粘附在NavMesh上，防止对象离开它。它不仅会自动计算到指定目的地的路径，还会通过模拟人类移动方式的转向行为算法来沿着路径移动对象，在拐角处减速并使用插值进行转向，而不是瞬间转向。此外，该组件能够躲避场景中运行的其他NavMeshAgent，防止所有敌人聚集在同一位置。
- en: 'Let''s use this powerful component by doing the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下方式使用这个强大的组件：
- en: Select the Enemy Prefab and add the `NavMeshAgent` component to it. Add it to
    the root Object, the one called Enemy, not the AI child—we want the whole Object
    to move. You will see a cylinder around the Object representing the area the Object
    will occupy in the `NavMesh`. Remember that this isn't a collider, so it won't
    be used for physical collisions:![Figure 18.32 The NavMeshAgent component
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择敌人Prefab并向其添加NavMeshAgent组件。将其添加到根对象，称为Enemy，而不是AI子对象 - 我们希望整个对象移动。你会看到对象周围有一个圆柱体，表示对象在NavMesh中所占据的区域。请记住，这不是一个碰撞体，所以它不会用于物理碰撞：![图18.32
    NavMeshAgent组件
- en: '](img/Figure_18.32_B14199.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.32_B14199.jpg)'
- en: Figure 18.32 – The NavMeshAgent component
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.32 - NavMeshAgent组件
- en: Remove the `ForwardMovement` component; from now on, we will drive the movement
    of our Enemy with `NavMeshAgent`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除ForwardMovement组件；从现在开始，我们将使用NavMeshAgent来驱动我们敌人的移动。
- en: In the `Awake` event function of the `EnemyFSM` script, use the `GetComponentInParent`
    function to cache the reference of `NavMeshAgent`. This will work similar to `GetComponent`—it
    will look for a component in our `GameObject`, but if the component is not there,
    this version will try to look for that component in all parents. Remember to add
    the `using UnityEngine.AI` line to use the `NavMeshAgent` class in this script:![Figure
    18.33 Caching a parent component reference
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在EnemyFSM脚本的Awake事件函数中，使用GetComponentInParent函数来缓存NavMeshAgent的引用。这将类似于GetComponent
    - 它将在我们的GameObject中查找组件，但如果组件不存在，这个版本将尝试在所有父级中查找该组件。记得添加using UnityEngine.AI行来在这个脚本中使用NavMeshAgent类：![图18.33
    缓存父级组件引用
- en: '](img/Figure_18.33_B14199.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.33_B14199.jpg)'
- en: Figure 18.33 – Caching a parent component reference
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.33 - 缓存父级组件引用
- en: IMPORTANT INFO
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: As you can imagine, there is `GetComponentInChildren`, which searches components
    in `GameObject` first and then in all its children if necessary.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，还有一个GetComponentInChildren，它首先在GameObject中搜索组件，然后在必要时在所有子对象中搜索。
- en: In the `GoToBase` state function, call the `SetDestination` function of the
    `NavMeshAgent` reference, passing the position of the base Object as the target:![Figure
    18.34 Setting a destination of our AI](img/Figure_18.34_B14199.jpg)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GoToBase状态函数中，调用NavMeshAgent引用的SetDestination函数，传递基本对象的位置作为目标：![图18.34 设置我们的AI的目的地](img/Figure_18.34_B14199.jpg)
- en: Figure 18.34 – Setting a destination of our AI
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.34 - 设置我们的AI的目的地
- en: Save the script and test this with a few enemies in the scene or with the enemies
    spawned by the waves. You will see the problem where the enemies will never stop
    going toward the target position, entering inside the Object, if necessary, even
    if the current state of their FSMs changes when they are near enough. That's because
    we never tell `NavMeshAgent` to stop, which we can do by setting the `isStopped`
    field of the agent to `true`. You might want to tweak the Base Attack Distance
    to make the Enemy stop a little bit nearer or further:![Figure 18.35 – Stopping
    agent movement
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并在场景中测试一下，或者使用波次生成的敌人进行测试。你会看到敌人永远不会停止朝着目标位置前进，甚至在它们的有限状态机状态在靠近目标时发生变化时也会进入对象内部。这是因为我们从未告诉NavMeshAgent停止，我们可以通过将代理的isStopped字段设置为true来实现这一点。你可能想调整基本攻击距离，使敌人停下来的位置更近或更远：![图18.35
    - 停止代理移动
- en: '](img/Figure_18.35_B14199.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.35_B14199.jpg)'
- en: Figure 18.35 – Stopping agent movement
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.35 - 停止代理移动
- en: We can do the same for `ChasePlayer` and `AttackPlayer`. In `ChasePlayer`, we
    can set the destination of the agent to the Player position, and in Attack Player,
    we can stop the movement. In this scenario, Attack Player can go back again to
    `GoToBase` or `ChasePlayer`, so you need to set the `isStopped` agent field to
    `false` in those states or before doing the transition. We will pick the former,
    as that version will cover other states that also stop the agent without extra
    code. We will start with the `GoToBase` state:![Figure 18.36 Reactivating the
    agent](img/Figure_18.36_B14199.jpg)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以对ChasePlayer和AttackPlayer做同样的操作。在ChasePlayer中，我们可以将代理的目的地设置为玩家的位置，在AttackPlayer中，我们可以停止移动。在这种情况下，AttackPlayer可以再次返回到GoToBase或ChasePlayer，所以你需要在这些状态或在进行转换之前将isStopped代理字段设置为false。我们将选择前者，因为这个版本将覆盖其他也会停止代理的状态而不需要额外的代码。我们将从GoToBase状态开始：![图18.36
    重新激活代理](img/Figure_18.36_B14199.jpg)
- en: Figure 18.36 – Reactivating the agent
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.36 - 重新激活代理
- en: Then, continue with Chase Player:![Figure 18.37 Reactivating the agent and chasing
    the Player
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，继续进行Chase Player:![图18.37 重新激活代理并追逐玩家
- en: '](img/Figure_18.37_B14199.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.37_B14199.jpg)'
- en: Figure 18.37 – Reactivating the agent and chasing the Player
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.37 - 重新激活代理并追逐玩家
- en: And finally, continue with Attack Player:![Figure 18.38 Stopping the movement
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，继续进行攻击玩家:![图18.38 停止移动
- en: '](img/Figure_18.38_B14199.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.38_B14199.jpg)'
- en: Figure 18.38 – Stopping the movement
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.38 - 停止移动
- en: You can tweak the `Acceleration`, `Speed`, and `Angular Speed` properties of
    `NavMeshAgent` to control how fast the Enemy will move. Also, remember to apply
    the changes to the Prefab for the spawned enemies to be affected.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以调整`NavMeshAgent`的`Acceleration`、`Speed`和`Angular Speed`属性来控制敌人的移动速度。还记得将更改应用到生成的敌人Prefab中。
- en: Now that we have movement in our Enemy, let's finish the final details of our
    AI.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的敌人有了移动，让我们完成AI的最后细节。
- en: Adding final details
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加最后的细节
- en: 'We have two things missing here, the Enemy is not shooting any bullets and
    it doesn''t have animations. Let''s start fixing the shooting by doing the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两件事情还没有完成，敌人没有射击任何子弹，也没有动画。让我们开始通过以下方式修复射击：
- en: Add a `bulletPrefab` field of the `GameObject` type to our `EnemyFSM` script
    and a `float` field called `fireRate`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`EnemyFSM`脚本中添加一个`bulletPrefab`字段，类型为`GameObject`，以及一个名为`fireRate`的`float`字段。
- en: Create a function called `Shoot` and call it inside `AttackBase` and `AttackPlayer`:![Figure
    18.39 Shooting function calls
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Shoot`的函数，并在`AttackBase`和`AttackPlayer`中调用它：![图18.39 射击函数调用
- en: '](img/Figure_18.39_B14199.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.39_B14199.jpg)'
- en: Figure 18.39 – Shooting function calls
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.39 - 射击函数调用
- en: In the `Shoot` function, put a similar code as the one used in the `PlayerShooting`
    script to shoot bullets at a specific fire rate, as in the following screenshot.
    Remember to set the Enemy layer in your Enemy Prefab, in case you didn't before,
    to prevent the bullet from damaging the Enemy itself. You might also want to raise
    the AI script a little bit to shoot bullets in another position or, better, add
    a `shootPoint` transform field and create an empty Object in the Enemy to use
    as a spawn position. If you do that, consider making the empty Object to not be
    rotated so the Enemy rotation affects the direction of the bullet properly:![Figure
    18.40 Shooting function code
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Shoot`函数中，放置与`PlayerShooting`脚本中使用的类似代码，以特定的射击速率射击子弹，如下截图所示。记得在敌人Prefab中设置敌人层，以防止子弹伤害到敌人自身。您可能还希望稍微提高AI脚本以在另一个位置射击子弹，或者更好地，添加一个`shootPoint`变换字段，并在敌人中创建一个空对象作为生成位置。如果这样做，考虑使空对象不旋转，以便敌人的旋转正确影响子弹的方向：![图18.40
    射击函数代码
- en: '](img/Figure_18.40_B14199.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.40_B14199.jpg)'
- en: Figure 18.40 – Shooting function code
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.40 - 射击函数代码
- en: IMPORTANT INFO
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: Here, you find some duplicated shooting behavior between `PlayerShooting` and
    `EnemyFSM`. You can fix that by creating a `Weapon` behavior with a function called
    `Shoot` that instantiates bullets and takes into account the fire rate, and call
    it inside both components to re-utilize it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlayerShooting`和`EnemyFSM`之间找到了一些重复的射击行为。您可以通过创建一个名为`Weapon`的行为来修复这个问题，该行为具有一个名为`Shoot`的函数，用于实例化子弹并考虑射击速率，并在两个组件内调用它以进行重复利用。
- en: When the agent is stopped, not only does the movement stop but also the rotation.
    If the Player moves while the Enemy is attacked, we still need the Enemy to face
    it to shoot bullets in its direction. We can create a `LookTo` function that receives
    the target position to look and call it in `AttackPlayer` and `AttackBase`, passing
    the target to shoot at:![Figure 18.41 LookTo function calls
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代理停止时，不仅移动停止，而且旋转也停止。如果玩家在敌人受到攻击时移动，我们仍然需要敌人面对它以向其方向射击子弹。我们可以创建一个`LookTo`函数，该函数接收要查看的目标位置，并在`AttackPlayer`和`AttackBase`中调用它，传递要射击的目标：![图18.41
    LookTo函数调用
- en: '](img/Figure_18.41_B14199.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.41_B14199.jpg)'
- en: Figure 18.41 – LookTo function calls
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.41 - LookTo函数调用
- en: Complete the `LookTo` function by getting the direction of our parent to the
    target position, we access our parent with `transform.parent` because, remember,
    we are the child AI Object, the Object that will move is our parent. Then, we
    set the `Y` component of the direction to `0` to prevent the direction pointing
    upward or downward—we don't want our Enemy to rotate vertically. Finally, we set
    the forward vector of our parent to that direction so it will face the target
    position immediately. You can replace that with interpolation through quaternions
    to have a smoother rotation if you want to, but let's keep things as simple as
    possible for now:![Figure 18.42 – Looking toward a target
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过获取我们的父对象到目标位置的方向来完成`LookTo`函数，我们使用`transform.parent`访问我们的父对象，因为记住，我们是子AI对象，移动的对象是我们的父对象。然后，我们将方向的`Y`分量设置为`0`，以防止方向指向上方或向下方
    - 我们不希望我们的敌人垂直旋转。最后，我们将父对象的前向矢量设置为该方向，以便立即面向目标位置。如果您愿意，您可以用四元数插值替换它，以使旋转更加平滑，但现在让我们尽可能保持简单：![图18.42
    - 面向目标
- en: '](img/Figure_18.42_B14199.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.42_B14199.jpg)'
- en: Figure 18.42 – Looking toward a target
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.42 - 面向目标
- en: 'Finally, we can add animations to the Enemy using the same Animator Controller
    used in the Player and setting the parameters with other scripts in the following
    steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用与玩家相同的Animator Controller为敌人添加动画，并使用其他脚本设置参数，具体步骤如下：
- en: Add an `Animator` component to the Enemy, if it's not already there, and set
    the same Controller used in the Player; in our case, this is also called `Player`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为敌人添加一个`Animator`组件，如果还没有的话，并设置与玩家相同的控制器；在我们的情况下，这也被称为`Player`。
- en: Create and add a script to the Enemy root Object called `NavMeshAnimator`, which
    will take the current velocity of `NavMeshAgent` and will set it to the Animator
    Controller. This will work similar to the `VelocityAnimator` script and is in
    charge of updating the Animator Controller `velocity` parameter to the velocity
    of our Object. We didn't use that one here because `NavMeshAgent` doesn't use
    `Rigidbody` to move. It has its own velocity system. We can actually set `Rigidbody`
    to `kinematic` if we want because of this, since it moves but not with Physics:![Figure
    18.43 – Connecting the NavMeshAgent to our Animator Controller
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并添加一个脚本到Enemy根对象，名为`NavMeshAnimator`，它将获取`NavMeshAgent`的当前速度并将其设置到Animator控制器中。这将类似于`VelocityAnimator`脚本，并负责更新Animator控制器的`velocity`参数以匹配对象的速度。我们没有在这里使用它，因为`NavMeshAgent`不使用`Rigidbody`来移动。它有自己的速度系统。实际上，如果我们愿意，我们可以将`Rigidbody`设置为`kinematic`，因为它移动但不受物理影响：
- en: '](img/Figure_18.43_B14199.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: Figure 18.43 – Connecting the NavMeshAgent to our Animator Controller
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们结束了本书的*第二部分*，关于C#脚本。在接下来的短篇中，我们将完成游戏的最后细节，从优化开始。图18.43 - 将NavMeshAgent连接到我们的Animator控制器
- en: Cache a reference to the parent `Animator` in the `EnemyFSM` script. Just do
    the same thing we did to access `NavMeshAgent`:![Figure 18.44 Accessing the parent’s
    Animator reference
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图18.45 - 打开射击动画
- en: '](img/Figure_18.44_B14199.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经完成了所有的AI行为。当然，这个脚本足够大，值得在将来进行一些重构和拆分，一些动作，如停止和恢复动画和`NavMeshAgent`可以以更好的方式完成。但是通过这样，我们已经原型化了我们的AI，并且可以测试直到我们对它满意，然后我们可以改进这段代码。
- en: Figure 18.44 – Accessing the parent's Animator reference
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.44 - 访问父级的Animator引用
- en: Turn on the `Shooting` `animator` parameter inside the `Shoot` function to make
    sure every time we shoot, that parameter is set to `true` (checked):![Figure 18.45
    Turning on the shooting animation
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '](img/Figure_18.43_B14199.jpg)'
- en: '](img/Figure_18.45_B14199.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.46_B14199.jpg)'
- en: Figure 18.45 – Turning on the shooting animation
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_18.45_B14199.jpg)'
- en: 'Turn off `boolean` in all non-shooting states, such as `GoToBase` and `ChasePlayer`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![图18.43 - 将NavMeshAgent连接到我们的Animator控制器'
- en: '![Figure 18.46 Turning off the shooting animation'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我相当确定AI不是你想象的那样；你并没有在这里创建任何SkyNet，但我们已经为挑战我们的玩家完成了一个简单但有趣的AI，我们可以迭代和调整以适应游戏的预期行为。我们看到了如何通过传感器收集周围的信息，使用FSM做出决策并使用不同的Unity系统（如寻路和Animator）来执行这些动作。
- en: '](img/Figure_18.46_B14199.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图18.46 关闭射击动画'
- en: Figure 18.46 – Turning off the shooting animation
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EnemyFSM`脚本中缓存父级`Animator`的引用。做与访问`NavMeshAgent`相同的事情：![图18.44 访问父级的Animator引用
- en: With that, we have finished all AI behaviors. Of course, this script is big
    enough to deserve some rework and splitting in the future, and some actions such
    as stopping and resuming the animations and `NavMeshAgent` can be done in a better
    way. But with this, we have prototyped our AI, and we can test it until we are
    happy with it, and then we can improve this code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.46 - 关闭射击动画
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '](img/Figure_18.44_B14199.jpg)'
- en: I'm pretty sure AI is not what you imagined; you are not creating any SkyNet
    here, but we have accomplished a simple but interesting AI for challenging our
    Player, which we can iterate and tweak to tailor to our game's expected behavior.
    We saw how to gather our surrounding information through sensors to make decisions
    on what action to execute using FSMs, and using different Unity systems such as
    Pathfinding and Animator to make the AI execute those actions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有非射击状态（如`GoToBase`和`ChasePlayer`）中关闭`boolean`：
- en: With this, we end *Part 2* of this book, about C# scripting. In the next short
    part, we are going to finish our game's final details, starting with optimization.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Shoot`函数中打开`Shooting` `animator`参数，以确保每次射击时该参数被设置为`true`（选中）：![图18.45 打开射击动画
