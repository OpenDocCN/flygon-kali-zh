- en: Creating Java Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Java微服务
- en: 'We''ve seen a lot of theory behind microservice architecture in [Chapter 3](text00053.html)
    , *Working with Microservices* . It''s time to do some hands-on practice; we are
    going to implement our own microservice. This will be a simple REST service, accepting
    `HTTP` methods such as `GET` and `POST` to retrieve and update entities. There
    are a couple of choices when developing microservices in Java. In this chapter,
    we are going to get an overview about two main approaches, probably the most popular
    will be JEE7, and Spring Boot. We will briefly see how we can code a microservice
    using JEE JAX-RS. We will also create a microservice running on Spring Boot. In
    fact, in [Chapter 5](text00084.html) , *Creating Images with Java Applications*
    , we are going to run our Spring Boot microservice from within a Docker container.
    As we have said in [Chapter 3](text00053.html) , *Working with Microservices*
    , microservices usually communicate with the outside world using REST. Our REST
    microservice will be as simple as possible; we just need to have something to
    deploy using Docker and Kubernetes. We will not focus on advanced microservice
    features such as authentication, security, filters, and so on, as this is outside
    the scope of this book. The purpose of our examples is to give you an idea of
    how to develop REST services and then deploy them using Docker and Kubernetes.
    This chapter will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00053.html)中，我们已经看到了微服务架构背后的许多理论，*使用微服务*。现在是实践的时候；我们将要实现我们自己的微服务。这将是一个简单的REST服务，接受`GET`和`POST`等`HTTP`方法来检索和更新实体。在Java中开发微服务时有几种选择。在本章中，我们将概述两种主要方法，可能最流行的将是JEE7和Spring
    Boot。我们将简要介绍如何使用JEE JAX-RS编写微服务。我们还将创建一个在Spring Boot上运行的微服务。实际上，在[第5章](text00084.html)中，*使用Java应用程序创建图像*，我们将从Docker容器中运行我们的Spring
    Boot微服务。正如我们在[第3章](text00053.html)中所说，*使用微服务*，微服务通常使用REST与外部世界通信。我们的REST微服务将尽可能简单；我们只需要有一些东西可以使用Docker和Kubernetes部署。我们不会专注于高级微服务功能，比如身份验证、安全、过滤器等等，因为这超出了本书的范围。我们的示例的目的是让您了解如何开发REST服务，然后使用Docker和Kubernetes部署它们。本章将涵盖以下主题：
- en: Introduction to REST
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST简介
- en: Creating a REST service in Java using Java EE7 annotations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java EE7注解在Java中创建REST服务
- en: Creating a REST service using Spring Boot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot创建REST服务
- en: Running the service and then calling it with different HTTP clients
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行服务，然后使用不同的HTTP客户端调用它
- en: At the end of the chapter, we will become familiar with some useful tools- we
    will use some code generation tools such as Spring Initialzr to quickly bootstrap
    a Spring Boot service project. Before we start coding our own microservice, let's
    explain briefly what REST is.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们将熟悉一些有用的工具-我们将使用一些代码生成工具，比如Spring Initialzr，快速启动一个Spring Boot服务项目。在我们开始编写自己的微服务之前，让我们简要解释一下REST是什么。
- en: Introduction to REST
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST简介
- en: The REST acronym stands for Representational State Transfer. It's an architectural
    style and a design for network-based software. It describes how one system can
    communicate a state with another. This fits perfectly well into the microservice
    world. As you will remember from [Chapter 3](text00053.html) , *Working with Microservices*
    , the software applications based on the microservices architecture is a bunch
    of separated, independent services talking to each other.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: REST首字母缩略词代表表述性状态转移。这是一种基于网络的软件的架构风格和设计。它描述了一个系统如何与另一个系统通信状态。这非常适合微服务世界。正如您从[第3章](text00053.html)中所记得的，*使用微服务*，基于微服务架构的软件应用程序是一堆分离的、独立的服务相互通信。
- en: 'There are some concepts in REST that we need to understand, before we go further:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一些REST中的概念我们需要了解：
- en: '`resource` : This is the main concept in the REST architecture. Any information
    can be a resource. A bank account, a person, an image, a book. A representation
    of a resource must be **stateless**'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource`：这是 REST 架构中的主要概念。任何信息都可以是一个资源。银行账户、人员、图像、书籍。资源的表示必须是**无状态**的。'
- en: '`representation` : A specific way a resource can be represented. For example,
    a bank account resource can be represented using JSON, XML, or HTML. Different
    clients might request different representations of the resource, one can accept
    JSON, while others will be expecting XML'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`representation`：资源可以被表示的特定方式。例如，银行账户资源可以使用 JSON、XML 或 HTML 来表示。不同的客户端可能请求资源的不同表示，一个可以接受
    JSON，而其他人可能期望 XML。'
- en: '`server` : A service provider. It exposes services which can be consumed by
    clients'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server`：服务提供者。它公开可以被客户端消费的服务。'
- en: '`client` : A service consumer. This could be another microservice, application,
    or just a user''s web browser running an Angular application, for example'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client`：服务消费者。这可以是另一个微服务、应用程序，或者只是运行 Angular 应用程序的用户的网络浏览器'
- en: As the definition says, REST is being used to transport those resource representations
    over the network. The representation itself is being created via some media type.
    Media types can be different. Some examples of media types include JSON, XML,
    or RDF. The JSON media type is widely accepted and probably the most often used.
    In our examples, we will also use JSON to communicate with our service. Of course,
    REST is not the only option for microservices communication; there are others,
    such as Google's very good gRPC, for example, which brings a lot of advantages
    such as HTTP/2 and protobuff. In the REST architecture, resources are manipulated
    by components. In fact, these components are our microservices. Components request
    and manipulate resources via a standard uniform interface. REST is not tied to
    any specific protocol; however, REST calls are most often being made using the
    most popular `HTTP` or `HTTPS` protocol. In the case of `HTTP` , this uniform
    interface consists of standard HTTP methods such as `GET` , `PUT` , `POST` , and
    `DELETE` .
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如定义所说，REST 被用来在网络上传输这些资源表示。表示本身是通过某种媒体类型创建的。媒体类型可以不同。一些媒体类型的例子包括 JSON、XML 或
    RDF。JSON 媒体类型被广泛接受，可能是最常用的。在我们的例子中，我们也将使用 JSON 来与我们的服务进行通信。当然，REST 不是微服务通信的唯一选择；还有其他选择，比如谷歌的非常好的
    gRPC，它带来了很多优势，比如 HTTP/2 和 protobuff。在 REST 架构中，资源由组件来操作。事实上，这些组件就是我们的微服务。组件通过标准统一接口请求和操作资源。REST
    不绑定到任何特定的协议；然而，REST 调用最常使用最流行的 `HTTP` 或 `HTTPS` 协议。在 `HTTP` 的情况下，这个统一接口由标准的 HTTP
    方法组成，比如 `GET`、`PUT`、`POST` 和 `DELETE`。
- en: REST is not tied to any specific protocol.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: REST 不绑定到任何特定的协议。
- en: Before we start implementing our service that will respond to `HTTP` calls,
    it's worth knowing about the HTTP methods we are going to use. We are going to
    focus on them a little bit closer now.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现响应 `HTTP` 调用的服务之前，了解一下我们将要使用的 HTTP 方法是值得的。我们现在将更加关注它们。
- en: HTTP methods
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 方法
- en: 'The REST-based architecture uses standard HTTP methods: `PUT` , `GET` , `POST`
    , and `DELETE` . The following list gives an explanation of these operations:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 REST 的架构使用标准的 HTTP 方法：`PUT`、`GET`、`POST` 和 `DELETE`。以下列表解释了这些操作：
- en: '`GET` gives a read access to the resource. Calling `GET` should not create
    any side-effects. It means that the `GET` operation is idempotent. The resource
    is never changed via a `GET` request; for example, the request has no side effects.
    It means it''s idempotent'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` 提供对资源的读取访问。调用 `GET` 不应该产生任何副作用。这意味着 `GET` 操作是幂等的。资源永远不会通过 `GET` 请求而被改变；例如，请求没有副作用。这意味着它是幂等的。'
- en: '`PUT` creates a new resource. Similar to `GET` , it should also be idempotent'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`创建一个新资源。与`GET`类似，它也应该是幂等的。'
- en: '`DELETE` removes the resource or resources. The `DELETE` operation should not
    give different results when called repeatedly'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`移除资源。当重复调用时，`DELETE`操作不应产生不同的结果。'
- en: '`POST` will update an existing resource or create a new one'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`将更新现有资源或创建新资源。'
- en: A RESTful web service is simply a web service that is based on the `REST` resource
    concept and usage of HTTP methods. It should define the base URI for the exposed
    methods, the MIME-types supported, such as XML, text, or JSON, and the set of
    operations (`POST` , `GET` , `PUT` , and `DELETE` ) which the service handles.
    HTTP is simple and very natural for REST, according to RESTful principles. These
    principles are a set of constraints that ensure that clients (service consumers,
    other services or browsers, for example) can communicate with servers in a flexible
    way. Let's look at them now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful web服务就是基于`REST`资源概念和使用HTTP方法的web服务。它应该定义暴露方法的基本URI，支持的MIME类型，比如XML、文本或JSON，以及服务处理的一组操作（`POST`，`GET`，`PUT`和`DELETE`）。根据RESTful原则，HTTP对REST来说是简单且非常自然的。这些原则是一组约束，确保客户端（比如服务消费者、其他服务或浏览器）可以以灵活的方式与服务器通信。现在让我们来看看它们。
- en: 'In REST principles client-server communication, all applications built in the
    RESTful style must also be client-server in principle. There should be a server
    (service provider) and a client (service consumer). Having this enables loose
    coupling and independent evolution of server and client. This fits very well to
    the concept of a microservice. As you will remember from [Chapter 3](text00053.html)
    , *Working with Microservices* , they must be independent:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST原则的客户端-服务器通信中，所有以RESTful风格构建的应用程序原则上也必须是客户端-服务器的。应该有一个服务器（服务提供者）和一个客户端（服务消费者）。这样可以实现松散耦合和服务器和客户端的独立演进。这非常符合微服务的概念。正如你在[第3章](text00053.html)中所记得的，*使用微服务*，它们必须是独立的：
- en: '**Stateless** : Each `client` request to the server requires that its state
    be fully represented. The server must be able to completely understand the `client`
    request without using any server context or server session state. In other words,
    all states must be managed on the client side. Each REST service should be **stateless**
    . Subsequent requests should not depend on some data from a previous request being
    temporarily stored. Messages should be self-descriptive.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：每个客户端对服务器的请求都要求其状态完全表示。服务器必须能够完全理解客户端的请求，而不使用任何服务器上下文或服务器会话状态。换句话说，所有状态必须在客户端上管理。每个REST服务都应该是**无状态**的。后续请求不应该依赖于临时存储在先前请求中的某些数据。消息应该是自描述的。'
- en: '**Cacheable** : Response data could be marked as cacheable or non-cacheable.
    Any data marked as cacheable may be reused as the response to the same subsequent
    request. Each response should indicate if it is cacheable.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可缓存**：响应数据可以标记为可缓存或不可缓存。任何标记为可缓存的数据都可以在同一后续请求的响应中被重用。每个响应都应该指示它是否可缓存。'
- en: '**Uniform interface** : All components must interact through a single uniform
    interface. Because all component interactions occur via this interface, interaction
    with different services is very simple.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一接口**：所有组件必须通过单一统一的接口进行交互。因为所有组件的交互都通过这个接口进行，与不同服务的交互非常简单。'
- en: '**Layered system** : A consumer of the service should not assume direct connection
    to the service provider. In other words, at any time the client cannot tell if
    it is connected to the end server or to an intermediate. The intermediate layer
    helps to enforce the security policies and improve the system scalability by enabling
    load-balancing. Since requests can be cached, the client might be getting the
    cached response from a middle layer.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层系统：服务的消费者不应假定与服务提供者直接连接。换句话说，客户端在任何时候都无法确定自己是连接到最终服务器还是中间服务器。中间层有助于强制执行安全策略，并通过启用负载平衡来提高系统的可伸缩性。由于请求可以被缓存，客户端可能会从中间层获取缓存的响应。
- en: '**Manipulation of resources through representations** : A resource can have
    multiple representations. It should be possible to modify the resource through
    a message with any of these representations.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源通过表示的操作：一个资源可以有多个表示。应该可以通过任何这些表示的消息来修改资源。
- en: '**Hypermedia As The Engine Of Application State (HATEOAS)** : A consumer of
    a RESTful application should know about only one fixed service URL. All subsequent
    resources should be discoverable from the links included in the resource representations.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超媒体作为应用状态的引擎（HATEOAS）：RESTful应用的消费者应该只知道一个固定的服务URL。所有后续资源应该可以从资源表示中包含的链接中发现。
- en: 'The previous concepts represent defining characteristics of REST and differentiate
    the REST architecture from other architectures such as web services. It is useful
    to note that a REST service is a web service, but a web service is not necessarily
    a REST service. The REST microservice should represent the state of an entity.
    Let our entity be a book, for example (altogether with its properties such as
    ID, title, and an author), represented as XML, JSON, or plain text. The most basic
    way of thinking about REST is as a way of formatting the URLs of your service.
    For example, having our `book` resource, we could imagine having the following
    operations defined in the service:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前述概念代表了REST的定义特征，并将REST架构与其他架构（如Web服务）区分开来。值得注意的是，REST服务是Web服务，但Web服务不一定是REST服务。REST微服务应该代表实体的状态。例如，让我们的实体是一本书（连同其属性，如ID、标题和作者），表示为XML、JSON或纯文本。关于REST最基本的思考方式是将服务的URL格式化。例如，有了我们的`book`资源，我们可以想象在服务中定义以下操作：
- en: '`/books` would allow access of all the books'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/books`将允许访问所有书籍'
- en: '`/books/:id` would be an operation for viewing an individual book, retrieved
    based on its unique ID'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/books/:id`将是查看单个书籍的操作，根据其唯一ID检索'
- en: sending a `POST` request to `/books` would be how you would actually create
    a new book and store it in a database
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`/books`发送`POST`请求将是您实际上创建新书并将其存储在数据库中的方式
- en: sending a `PUT` request to `/books/:id` would be how you would update the attributes
    of a given book, again identified by its unique ID
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`/books/:id`发送`PUT`请求将是您如何更新给定书籍的属性，再次根据其唯一ID进行标识
- en: sending a `DELETE` request to `/books/:id` would be how you would delete a specific
    book, again identified by its unique ID
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`/books/:id`发送`DELETE`请求将是您如何删除特定书籍，再次根据其唯一ID进行标识
- en: It's worth trying to understand that REST is not HTTP. It often uses HTTP because
    in its most general form, REST is about mapping the concept of a verb against
    an arbitrary collection of nouns and fits well with HTTP methods. HTTP contains
    a useful set of generic verbs (`GET` , `POST` , `PUT` , `PATCH` , and so on).
    In REST, we do not transfer an actual object but a representation of it in a specific
    form, such as XML, text, or JSON. REST as an architectural style means it is just
    a concept. How it's implemented, is up to you. Java is suited well for developing
    REST services. Let's see how can we do it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一试的是，REST不是HTTP。它通常使用HTTP，因为在其最一般的形式中，REST是关于将动词的概念映射到任意的名词集合，并且与HTTP方法很好地契合。HTTP包含一组有用的通用动词（`GET`，`POST`，`PUT`，`PATCH`等）。在REST中，我们不传输实际对象，而是以特定形式的表示形式传输，例如XML、文本或JSON。作为一种架构风格，REST只是一个概念。它的实现方式取决于你。Java非常适合开发REST服务。让我们看看我们该如何做。
- en: REST in Java
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的REST
- en: When developing a REST service in Java, we have at least a couple of options
    for the framework we could use. The most popular will be pure JEE7 with JAX-RS
    or Spring Framework with its Spring Boot. You can use either of them or mix them
    together. Let's look at those two now in more detail, starting with JAX-RS.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中开发REST服务时，我们至少有几种框架可以选择。最流行的将是纯JEE7与JAX-RS或Spring框架与其Spring Boot。您可以选择其中任何一个，或者将它们混合在一起。现在让我们更详细地看看这两个，从JAX-RS开始。
- en: Java EE7 - JAX-RS with Jersey
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE7 - 使用Jersey的JAX-RS
- en: JAX-RS was born as a result of **Java Specification Request** (**JSR** ) 311\.
    As the official definition says, the JAX-RS is the Java API for RESTful web services.
    It's a specification that provides support in creating web services according
    to the REST architectural pattern. JAX-RS uses Java annotations, introduced in
    Java SE 5, to simplify the development and deployment of web service clients and
    endpoints. From version 1.1 on, JAX-RS is an official part of Java EE. A notable
    feature of being an official part of Java EE is that no configuration is necessary
    to start using JAX-RS.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS诞生于**Java规范请求**（**JSR**）311。正如官方定义所说，JAX-RS是用于RESTful web服务的Java API。它是一个规范，提供支持，根据REST架构模式创建web服务。JAX-RS使用Java注解，引入自Java
    SE 5，以简化web服务客户端和端点的开发和部署。从1.1版本开始，JAX-RS是Java EE的官方一部分。作为Java EE的官方一部分的一个显著特点是，无需配置即可开始使用JAX-RS。
- en: Java EE 7 with JAX-RS 2.0 brings several useful features, which further simplify
    the development of microservices. One of the most important new features of JAX-RS
    2.0 is the support for hypermedia following the HATEOAS principle of REST. `Jersey`
    , a library from Oracle, is probably the most widely known library, which implements
    this specification.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 7与JAX-RS 2.0带来了几个有用的功能，进一步简化了微服务的开发。JAX-RS 2.0最重要的新功能之一是支持遵循REST的HATEOAS原则的超媒体。`Jersey`，来自Oracle的库，可能是最广为人知的实现了这一规范的库。
- en: Jersey is the reference implementation for the JSR 311 specification.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Jersey是JSR 311规范的参考实现。
- en: The Jersey implementation provides a library to implement RESTful web services
    in a Java servlet container. On the server-side, Jersey provides a servlet implementation
    which scans predefined classes to identify RESTful resources. Jersey makes it
    a lot easier to write RESTful services. It abstracts away a lot of the low level
    coding you will need to do yourself otherwise. Using Jersey, you do it in a declarative
    way. The servlet, registered in your `web.xml` file, analyzes the incoming `HTTP`
    request and selects the correct class and method to respond to this request. It
    finds the proper method to execute by looking at the class and method level annotations.
    Annotated classes can reside in different packages, but you can instruct a Jersey
    servlet via the `web.xml` to scan certain packages for annotated classes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Jersey实现提供了一个库，用于在Java servlet容器中实现RESTful web服务。在服务器端，Jersey提供了一个servlet实现，它扫描预定义的类来识别RESTful资源。Jersey使编写RESTful服务变得更加容易。它抽象了许多低级别的编码，否则你将需要自己完成。使用Jersey，你可以以声明性的方式来完成。在`web.xml`文件中注册的servlet会分析传入的`HTTP`请求，并选择正确的类和方法来响应此请求。它通过查看类和方法级别的注解来找到要执行的正确方法。注解类可以存在于不同的包中，但是你可以通过`web.xml`指示Jersey
    servlet扫描特定的包以查找注解类。
- en: JAX-RS supports the creation of XML and JSON via the **Java Architecture for
    XML Binding** (**JAXB** ). The Jersey implementation also provides a `client`
    library to communicate with a RESTful web service.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS支持通过**Java XML绑定架构**（**JAXB**）创建XML和JSON。Jersey实现还提供了一个`client`库，用于与RESTful
    web服务进行通信。
- en: As we have said before, we develop JAX-RS applications using Java annotations.
    It's easy and pleasant to work with. Let's describe those annotations now.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，我们使用Java注解开发JAX-RS应用程序。这很容易且愉快。现在让我们来描述这些注解。
- en: JAX-RS annotations
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAX-RS注解
- en: 'The most important annotations in JAX-RS are listed in the following table:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS中最重要的注解列在下表中：
- en: '| **Annotation** | **Meaning** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '- **注解** | **含义**'
- en: '| `@PATH` | Sets the path to base `URL + /your_path` . The base URL is based
    on your application name, the servlet, and the URL pattern from the `web.xml`
    configuration file. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '- `@PATH` | 设置基本URL + /your_path的路径。基本URL基于你的应用程序名称、servlet和`web.xml`配置文件中的URL模式。'
- en: '| `@POST` | Indicates that the following method will answer to an `HTTP POST`
    request. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '- `@POST` | 表示以下方法将响应`HTTP POST`请求。'
- en: '| `@GET` | Indicates that the following method will answer to an `HTTP GET`
    request. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '- `@GET` | 表示以下方法将响应`HTTP GET`请求。'
- en: '| `@PUT` | Indicates that the following method will answer to an `HTTP PUT`
    request. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '- `@PUT` | 表示以下方法将响应`HTTP PUT`请求。'
- en: '| `@DELETE` | Indicates that the following method will answer to an `HTTP DELETE`
    request. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '- `@DELETE` | 表示以下方法将响应`HTTP DELETE`请求。'
- en: '| `@Produces` | Defines which MIME type is delivered by a method annotated
    with `@GET` . It can be `"text/plain"` , `"application/xml"` , or `"application/json"`
    for example. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '- `@Produces` | 定义了一个带有`@GET`注解的方法要传递的MIME类型。例如可以是`"text/plain"`，`"application/xml"`或`"application/json"`。'
- en: '| `@Consumes` | Defines which MIME type is consumed by this method. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '- `@Consumes` | 定义了这个方法要消耗的MIME类型。'
- en: '| `@PathParam` | Used to extract (inject) values from the URL into a method
    parameter. This way you inject, for example, the ID of a resource into the method
    to get the correct object. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '- `@PathParam` | 用于从URL中提取（注入）值到方法参数中。这样，你可以将资源的ID注入到方法中，以获取正确的对象。'
- en: '| `@QueryParam` | Used to extract (inject) the URI query parameter coming with
    the request. The **Uniform Resource Identifier** (**URI** ) is a string of characters
    used to identify a name or a resource on the Internet. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '- `@QueryParam` | 用于提取（注入）请求中携带的URI查询参数。**统一资源标识符**（**URI**）是用于在互联网上标识名称或资源的一串字符。'
- en: '| `@DefaultValue` | Specifies a default value. Useful for optional parameters.
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '`@DefaultValue` | 指定默认值。对于可选参数很有用。'
- en: '| `@CookieParam` | Annotation that allows you to inject cookies sent by a client
    request into your JAX-RS resource methods. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '`@CookieParam` | 允许您将客户端请求发送的cookie注入到JAX-RS资源方法中的注释。'
- en: '| `@Provider` | The `@Provider` annotation is used for anything that is of
    interest to the JAX-RS runtime, such as `MessageBodyReader` and `MessageBodyWriter`
    . For `HTTP` requests, `MessageBodyReader` is used to map an `HTTP` request entity
    body to method parameters. On the response side, a return value is mapped to an
    `HTTP` response entity body by using `MessageBodyWriter` . If the application
    needs to supply additional metadata, such as `HTTP` headers or a different status
    code, a method can return a response that wraps the entity and that can be built
    using `Response.ResponseBuilder` . |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '`@Provider` | `@Provider`注释用于JAX-RS运行时感兴趣的任何内容，例如`MessageBodyReader`和`MessageBodyWriter`。对于`HTTP`请求，`MessageBodyReader`用于将`HTTP`请求实体主体映射到方法参数。在响应端，返回值通过使用`MessageBodyWriter`映射到`HTTP`响应实体主体。如果应用程序需要提供额外的元数据，例如`HTTP`标头或不同的状态代码，方法可以返回一个包装实体的响应，并且可以使用`Response.ResponseBuilder`构建。'
- en: '| `@ApplicationPath` | The `@ApplicationPath` annotation is used to define
    the URL mapping for the application. The path specified by `@ApplicationPath`
    is the base URI for all resource URIs specified by `@Path` annotations in the
    `resource` class. You may only apply `@ApplicationPath` to a subclass of `javax.ws.rs.core.Application`
    . |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '`@ApplicationPath` | `@ApplicationPath`注释用于定义应用程序的URL映射。`@ApplicationPath`指定的路径是`resource`类中`@Path`注释指定的所有资源URI的基本URI。您只能将`@ApplicationPath`应用于`javax.ws.rs.core.Application`的子类。'
- en: 'The annotation names might not be clear or self-explanatory at first glance.
    Let''s look at the sample REST endpoint implementation, and it will become a lot
    clearer. The application itself is marked with the `@ApplicationPath` annotation.
    By default, during start-up of the JEE compliant server, JAX-RS will scan all
    the resources in a Java application archive to find the exposed endpoints. We
    can override the `getClasses()` method to manually register the `resource` classes
    in the application with the JAX-RS runtime. You can see it in the following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注释名称一开始可能不够清晰或不够自解释。让我们看一下示例REST端点实现，它将变得更加清晰。应用程序本身带有`@ApplicationPath`注释。默认情况下，在启动符合JEE的服务器时，JAX-RS将扫描Java应用程序存档中的所有资源，以查找公开的端点。我们可以重写`getClasses()`方法，手动向JAX-RS运行时注册应用程序中的`resource`类。您可以在以下示例中看到它：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the previous example, we just register a REST application, giving it the
    `/myApp` base URI path. There is only one `REST` method handler (endpoint), the
    `MyBeansExposure` class, which we register within the REST application. The simplified
    REST endpoint, implemented in the separate Java class can look same as this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们只是注册了一个REST应用程序，给它了`/myApp`基本URI路径。只有一个`REST`方法处理程序（端点），即`MyBeansExposure`类，我们在REST应用程序中注册它。在单独的Java类中实现的简化REST端点可以看起来与此相同：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see in the previous example, we have class-level `@Path` annotation.
    Every method marked with `@GET` , `@PUT` , `@DELETE` , or `@POST` annotations
    will respond to a call to the URI starting with the base `@Path` . Additionally,
    we can use the `@Path` annotation on a method level; it will, kind of, extend
    the URI path that the specific method responds to. In our example, the `HTTP GET`
    executed with a URI path `myApp/beans` will call the `allBeans()` method, returning
    the collection of beans in JSON format. The `GET` method executed using the `myApp/beans/12`
    URI path will call the `singleBean()` method, and the `{id}` parameter will be
    transferred to the method because of the `@PathParam` annotation. Calling the
    `HTTP DELETE` method on the `myApp|beans|12` URI will execute the `remove()` method
    with an `id` parameter value `12` . To give you almost infinite flexibility, the
    `@Path` annotation supports regular expressions. Consider the following example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一个例子中所看到的，我们有类级别的`@Path`注解。每个标记有`@GET`，`@PUT`，`@DELETE`或`@POST`注解的方法都将响应于以基本`@Path`开头的URI的调用。此外，我们可以在方法级别上使用`@Path`注解；它将扩展特定方法响应的URI路径。在我们的例子中，使用URI路径`myApp/beans`执行的`HTTP
    GET`将调用`allBeans()`方法，以JSON格式返回豆子集合。使用`myApp/beans/12` URI路径执行的`GET`方法将调用`singleBean()`方法，并且由于`@PathParam`注解，`{id}`参数将被传递给方法。在`myApp|beans|12`
    URI上调用`HTTP DELETE`方法将执行`remove()`方法，参数值为`12`。为了给你几乎无限的灵活性，`@Path`注解支持正则表达式。考虑以下例子：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the previous example, we have two `@GET` mappings, each with the same `/books/`
    path mapped. The first one, with the `/{title : [a-zA-Z][a-zA-Z_0-9]}` parameter,
    will react only to letters and numbers. The second one, with the `/{isbn : \\d+}`
    parameter, will be executed only if you provide a number when calling the URI.
    As you can see, we have mapped two identical paths, but each one will react to
    a different type of incoming path parameter.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '在上一个例子中，我们有两个`@GET`映射，每个映射都有相同的`/books/`路径映射。第一个映射，带有`/{title : [a-zA-Z][a-zA-Z_0-9]}`参数，只会对字母和数字做出反应。第二个映射，带有`/{isbn
    : \\d+}`参数，只有在调用URI时提供数字时才会执行。正如你所看到的，我们映射了两个相同的路径，但每个路径都会对不同类型的传入路径参数做出反应。'
- en: 'Apart from using `@PathParam` , we can also use `@QueryParams` to supply parameters
    using the request parameters. Take a look at the following example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`@PathParam`，我们还可以使用`@QueryParams`来使用请求参数提供参数。看看下面的例子：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous example, when calling `HTTP GET` on the `/users/query?from=1&to=100&orderBy=name`
    JAX-RS will pass the URI parameters into the `getUsers()` method parameter and
    call the injected `userService` to get the data (for example, from a database).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，当在`/users/query?from=1&to=100&orderBy=name`上调用`HTTP GET`时，JAX-RS将把URI参数传递给`getUsers()`方法参数，并调用注入的`userService`来获取数据（例如，从数据库中）。
- en: 'To package the JAX-RS application, we will need a Maven `pom.xml` file, of
    course. In its simplest form, it can look the same as the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要打包JAX-RS应用程序，我们当然需要一个Maven `pom.xml`文件。在其最简单的形式中，它可以看起来与以下内容相同：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating JEE7 REST services is quite straightforward, isn't it? By building
    the project and deploying it to a JEE compliant application server, we have a
    couple of endpoints ready and waiting to be called over `HTTP` . But there's an
    even more simple and faster approach. In the era of microservices, we would want
    to create individual components faster with a minimal overhead, after all. Here
    comes Spring Boot. Let's look at it now.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建JEE7 REST服务非常简单，不是吗？通过构建项目并将其部署到符合JEE标准的应用服务器，我们有一些端点准备好等待通过`HTTP`调用。但还有一种更简单和更快的方法。在微服务时代，我们希望以最小的开销更快地创建单独的组件。这就是Spring
    Boot的用武之地。现在让我们来看看它。
- en: Spring Boot
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot
- en: 'Spring itself is a very popular Java-based framework for building web and enterprise
    applications. It''s not only the Spring Core, which focuses on dependency injection.
    Spring Framework provides a lot of features that can make a developer''s life
    easier out of the box and allows you to deliver needed features faster. The list
    is long; here are just a few examples:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Spring本身是一个非常受欢迎的基于Java的框架，用于构建Web和企业应用程序。它不仅仅是关注依赖注入的Spring Core。Spring框架提供了许多功能，可以让开发人员的生活更轻松，并允许您更快地交付所需的功能。列表很长；这里只是一些例子：
- en: '**Spring data** : Simplifies data access from relational and NoSQL data stores'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring data：简化了与关系型和NoSQL数据存储的数据访问
- en: '**Spring batch** : Provides a powerful batch processing framework'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring batch：提供了一个强大的批处理框架
- en: '**Spring security** : Provides numerous ways to secure applications'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring security：提供了许多保护应用程序的方式
- en: '**Spring social** : Supports integration with social networking sites such
    as Twitter, Facebook, GitHub, and so on'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring social：支持与Twitter、Facebook、GitHub等社交网络站点集成
- en: '**Spring integration** : An implementation of enterprise integration patterns
    to facilitate integration with other enterprise applications using lightweight
    messaging and declarative adapters'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring integration：实现了企业集成模式，以便使用轻量级消息传递和声明性适配器与其他企业应用程序集成
- en: 'But why did Spring become so popular? There are several reasons for that:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么Spring变得如此受欢迎？有几个原因：
- en: It uses the dependency injection approach, which encourages writing testable,
    loosely coupled code
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它采用依赖注入方法，鼓励编写可测试、松耦合的代码
- en: It's easy to include database transaction management capabilities
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很容易包含数据库事务管理功能
- en: The integration with other popular Java frameworks such as JPA/Hibernate, for
    example
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他流行的Java框架集成，如JPA/Hibernate等
- en: It includes a state of the art MVC framework for building web applications faster,
    separating the view from the business logic
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包括一个用于更快地构建Web应用程序的最先进的MVC框架，将视图与业务逻辑分离。
- en: Configuring beans in the Spring framework can be done in multiple ways such
    as the XML definition file, Java annotations, and code configuration. This can
    be a tedious process. Also, we often do a lot of boilerplate configuration all
    the time, for different applications. Spring Boot was born to address the complexity
    of configuration. We can use Spring Boot for our own purposes, and develop small,
    independent services that can just be run. It can be a single runnable fat JAR
    file, with all the Java dependencies needed to run your application. There's no
    need for an application server or the complicated deployment descriptor configuration.
    In fact, behind the scenes, Spring Boot will boot up an embedded server for you.
    Of course, you are not forced to use the embedded application server. You can
    always build a WAR file to deploy it on your own Tomcat or Wildfly, for example.
    It's worth knowing, that even though most things will happen automatically when
    running a Spring Boot application, it's not a code generation framework.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring框架中配置bean可以通过多种方式进行，如XML定义文件、Java注解和代码配置。这可能是一个繁琐的过程。此外，我们经常为不同的应用程序做大量样板配置。Spring
    Boot应运而生，以解决配置的复杂性。我们可以将Spring Boot用于自己的目的，并开发可以直接运行的小型独立服务。它可以是一个单独的可运行的fat JAR文件，其中包含运行应用程序所需的所有Java依赖项。无需应用服务器或复杂的部署描述符配置。实际上，在幕后，Spring
    Boot将为您启动嵌入式服务器。当然，您并不一定要使用嵌入式应用服务器。您始终可以构建一个WAR文件，将其部署到自己的Tomcat或Wildfly上，例如。值得知道的是，即使在运行Spring
    Boot应用程序时大多数事情都会自动发生，它也不是一个代码生成框架。
- en: Does all of this remind you about the simplicity and portability of Docker containers?
    Sure it does, but on the application level. As we discussed in [Chapter 3](text00053.html)
    , *Working with Microservices* , we are moving towards architectures with smaller,
    independently deployable microservices. This means we will need to be able to
    quickly get off the ground and get running with new components. We get a lot of
    features out of the box when using Spring Boot. These features are delivered in
    the form of Maven artifacts, which you can just include in your Maven `pom.xml`
    file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些是否让你想起了Docker容器的简单性和可移植性？当然，但是在应用程序级别。正如我们在[第3章](text00053.html) *使用微服务*中讨论的那样，我们正在向着具有更小、独立部署的微服务的架构迈进。这意味着我们需要能够快速上手并运行新组件。使用Spring
    Boot时，我们可以获得很多开箱即用的功能。这些功能以Maven构件的形式提供，你只需在Maven的`pom.xml`文件中包含它们。
- en: 'The following table shows some of the important starter projects provided by
    Spring Boot we will be using:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了Spring Boot提供的一些重要起始项目，我们将使用：
- en: '| **Project** | **Description** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **项目** | **描述** |'
- en: '| `spring-boot-starter` | Base starter for Spring Boot applications. Provides
    support for auto-configuration and logging. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter` | Spring Boot应用程序的基本起始项目。提供自动配置和日志记录的支持。 |'
- en: '| `spring-boot-starter-web` | Starter project for building Spring MVC based
    web applications or RESTful applications. This uses Tomcat as the default embedded
    servlet container. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-web` | 用于构建基于Spring MVC的Web应用程序或RESTful应用程序的起始项目。这使用Tomcat作为默认的嵌入式Servlet容器。
    |'
- en: '| `spring-boot-starter-data-jpa` | Provides support for Spring Data JPA. Default
    implementation is Hibernate. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-data-jpa` | 提供对Spring Data JPA的支持。默认实现是Hibernate。 |'
- en: '| `spring-boot-starter-validation` | Provides support for Java Bean Validation
    API. Default implementation is Hibernate Validator. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-validation` | 提供对Java Bean验证API的支持。默认实现是Hibernate Validator。
    |'
- en: '| `spring-boot-starter-test` | Provides support for various unit testing frameworks,
    such as JUnit, Mockito, and Hamcrest matchers |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-test` | 提供对各种单元测试框架的支持，如JUnit、Mockito和Hamcrest matchers
    |'
- en: 'There are a lot more projects, which can be useful for you. We are not going
    to use them, but let''s look at what else is available:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多其他项目，可能对你有用。我们不打算使用它们，但让我们看看还有什么其他选择：
- en: '| `spring-boot-starter-web-services` | Starter project for developing XML based
    web services |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-web-services` | 用于开发基于XML的Web服务的起始项目 |'
- en: '| `spring-boot-starter-activemq` | Supports message based communication using
    JMS on ActiveMQ |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-activemq` | 支持使用ActiveMQ上的JMS进行基于消息的通信 |'
- en: '| `spring-boot-starter-integration` | Supports Spring Integration, framework
    that provides implementations for Enterprise Integration Patterns |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-integration` | 支持Spring Integration，这是一个提供企业集成模式实现的框架
    |'
- en: '| `spring-boot-starter-jdbc` | Provides support for using Spring JDBC. Configures
    a Tomcat JDBC connection pool by default. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-jdbc` | 提供对Spring JDBC的支持。默认情况下配置了Tomcat JDBC连接池。 |'
- en: '| `spring-boot-starter-hateoas` | HATEOAS stands for Hypermedia as the Engine
    of Application State. RESTful services that use `HATEOAS` return links to additional
    resources that are related to the current context in addition to data. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-hateoas` | HATEOAS代表超媒体作为应用状态的引擎。使用`HATEOAS`的RESTful服务返回与当前上下文相关的附加资源的链接，以及数据。
    |'
- en: '| `spring-boot-starter-jersey` | JAX-RS is the Java EE standard for developing
    REST APIs. Jersey is the default implementation. This starter project provides
    support for building JAX-RS based REST APIs. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-jersey` | JAX-RS是开发REST API的Java EE标准。Jersey是默认实现。这个起始项目提供了构建基于JAX-RS的REST
    API的支持。 |'
- en: '| `spring-boot-starter-websocket` | `HTTP` is stateless. Web sockets allow
    maintaining connection between server and browser. This starter project provides
    support for Spring WebSockets. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-websocket` | `HTTP`是无状态的。Web套接字允许在服务器和浏览器之间保持连接。这个启动器项目提供了对Spring
    WebSockets的支持。 |'
- en: '| `spring-boot-starter-aop` | Provides support for Aspect oriented programming.
    Also provides support for AspectJ for advanced Aspect oriented programming. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-aop` | 提供面向切面编程的支持。还提供了对高级面向切面编程的AspectJ的支持。 |'
- en: '| `spring-boot-starter-amqp` | With default as `RabbitMQ` , this starter project
    provides message passing with AMQP. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-amqp` | 默认为`RabbitMQ`，这个启动器项目提供了使用AMQP进行消息传递的支持。 |'
- en: '| `spring-boot-starter-security` | This starter project enables auto-configuration
    for Spring Security. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-security` | 这个启动器项目启用了Spring Security的自动配置。 |'
- en: '| `spring-boot-starter-batch` | Provides support for developing batch applications
    using Spring Batch. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-batch` | 提供使用Spring Batch开发批处理应用程序的支持。 |'
- en: '| `spring-boot-starter-cache` | Basic support for caching using Spring Framework.
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-cache` | 使用Spring Framework基本支持缓存。 |'
- en: '| `spring-boot-starter-data-rest` | Support for exposing REST services using
    Spring Data REST. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-data-rest` | 支持使用Spring Data REST公开REST服务。 |'
- en: Let's use some of these goodies to code our own Spring Boot microservice.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一些这些好东西来编写我们自己的Spring Boot微服务。
- en: Coding the Spring Boot microservice
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Spring Boot微服务
- en: 'We know that we have some starters available, so let''s make use of them to
    save some time. The service that we are going to create will be the simple REST
    microservice for storing and retrieving entities from a database: books, in our
    case. We are not going to implement authentication and security features, just
    to make it as clean and simple as possible. Books will be stored in an in-memory
    relational H2 database. We are going to build and run our bookstore with Maven,
    so let''s begin with the `pom.xml` build file.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们有一些启动器可用，所以让我们利用它们来节省一些时间。我们要创建的服务将是用于从数据库中存储和检索实体的简单REST微服务：在我们的案例中是书籍。我们不打算实现身份验证和安全功能，只是尽可能地使它简洁和简单。书籍将存储在内存关系型H2数据库中。我们将使用Maven构建和运行我们的书店，所以让我们从`pom.xml`构建文件开始。
- en: Maven build file
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven构建文件
- en: 'As you will see, the parent project for our own service is spring-boot-starter-parent.
    Spring this is the parent project providing dependency and plugin management for
    Spring Boot-based applications. This gives us a lot of features to start with.
    We also include two starters:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们自己服务的父项目是spring-boot-starter-parent。Spring这是为基于Spring Boot的应用程序提供依赖和插件管理的父项目。这为我们提供了很多功能。我们还包括两个启动器：
- en: '`spring-boot-starter-web` : This is because we are going to create our request
    mappings (similar to `@GET` or `@POST` mappings with the `@Path` annotation we
    did previously using JEE7 JAX-RS'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-web`：这是因为我们将创建我们的请求映射（类似于使用JEE7 JAX-RS之前使用`@Path`注释的`@GET`或`@POST`映射）'
- en: '`spring-boot-starter-data-jpa` : Because we are going to save our books in
    the in-memory H2 database'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-data-jpa`：因为我们将把我们的书保存在内存中的H2数据库中'
- en: 'Starters are simplified dependency descriptors customized for different purposes.
    For example, `spring-boot-starter-web` is the starter for building web and RESTful,
    applications using Spring MVC. It uses Tomcat as the default embedded container.
    We also include the Spring Boot Maven plugin, which allows us to run the applications
    in place without building a JAR or a WAR, or preparing a JAR or WAR file for future
    deployment. Our complete `pom.xml` should look the same as this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 启动器是为不同目的定制的简化的依赖描述符。例如，`spring-boot-starter-web`是用于使用Spring MVC构建Web和RESTful应用程序的启动器。它使用Tomcat作为默认的嵌入式容器。我们还包括了Spring
    Boot Maven插件，它允许我们在原地运行应用程序，而无需构建JAR或WAR，或准备JAR或WAR文件以供将来部署。我们完整的`pom.xml`应该与这个一样：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, in the `pom.xml` file, we define the parent Maven artifact. As our application
    is the Spring Boot application, we inherit our `pom.xml` from the `spring-boot-starter-parent`
    artifact. This gives us all the Spring Boot goodies out of the box, such as the
    startup mechanism, dependency injection, and so on. By adding `spring-boot-starter-data-jpa`
    as a dependency, we will be able to use all the database-related features, such
    as JDBC transaction management, JPA annotations for the entity classes, and so
    on. Having the `pom.xml` ready, let's continue and define the entry point for
    our microservice.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`pom.xml`文件中，我们定义了父Maven artifact。由于我们的应用是Spring Boot应用程序，我们从`spring-boot-starter-parent`
    artifact继承我们的`pom.xml`。这为我们提供了所有Spring Boot的好处，例如启动机制，依赖注入等。通过将`spring-boot-starter-data-jpa`作为依赖项添加，我们将能够使用所有与数据库相关的功能，例如JDBC事务管理，用于实体类的JPA注解等。有了准备好的`pom.xml`，让我们继续定义微服务的入口点。
- en: Application entry point
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序入口点
- en: 'Our application entry point will be named `BookStoreApplication` and will be
    `BookstoreApplication.java` :'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序入口点将被命名为`BookStoreApplication`，并且将是`BookstoreApplication.java`：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That''s it. The whole nine lines of code, not counting blank lines. It could
    not be more concise. The `@SpringBootApplication` is a kind of shortcut annotation,
    which is very convenient. It replaces all of the following annotations:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。整个代码只有九行，不包括空行。它不能再简洁了。`@SpringBootApplication`是一种快捷注解，非常方便。它替代了以下所有注解：
- en: '`@Configuration` : A class marked with this annotation becomes a source of
    bean definitions for the application context'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Configuration`：标有此注解的类成为应用程序上下文的bean定义源'
- en: '`@EnableAutoConfiguration` : This annotation makes Spring Boot add beans based
    on classpath settings, other beans, and various property settings'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableAutoConfiguration`：此注解使Spring Boot根据类路径设置、其他bean和各种属性设置添加bean'
- en: '`@EnableWebMvc` : Normally you would add `this one` for a Spring MVC application,
    but Spring Boot adds it automatically when it sees `spring-webmvc` on the classpath.
    This marks the application as a web application, which in turn will activate key
    behaviors such as setting up a `DispatcherServlet`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableWebMvc`：通常你会为Spring MVC应用程序添加`这个`，但是当Spring Boot在类路径上看到`spring-webmvc`时，它会自动添加它。这标志着应用程序是一个Web应用程序，从而激活关键行为，如设置`DispatcherServlet`。'
- en: '`@ComponentScan` : Tells Spring to look for other components, configurations,
    and services, allowing it to find the controllers'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ComponentScan`：告诉Spring查找其他组件、配置和服务，使其能够找到控制器'
- en: So far so good. We need some models for our service. We are going to save some
    entities in the database; this is where the `spring-boot-starter-data-jpa` starter
    will come in handy. We will be able to use JPA (implemented with Hibernate) and
    `javax.transaction-api` without even declaring it explicitly. We need an entity
    model for our bookstore.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。我们需要一些模型来为我们的服务。我们将在数据库中保存一些实体；这就是`spring-boot-starter-data-jpa`启动器派上用场的地方。我们将能够使用JPA（使用Hibernate实现）和`javax.transaction-api`，甚至无需明确声明它。我们需要一个书店的实体模型。
- en: Domain model and a repository
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域模型和仓库
- en: 'A domain model in our service will be a `Book` class, defined in the `Book.java`
    file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务中的领域模型将是一个`Book`类，在`Book.java`文件中定义：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see on the previous listing, the `Book` class is a simple POJO with
    some annotations, properties, and getters and setters. The `@Entity` annotations
    come from the `javax.persistence` package and marks the POJO as a database entity,
    to enable JPA to store or retrieve it from the H2 database. `@Column` annotations
    specify the names of database columns where the corresponding book properties
    will be stored. The `@NotNull` and `@Size` annotations will make sure that our
    entity has proper values filled in, before it goes into the database.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的清单中所看到的，`Book`类是一个简单的POJO，带有一些注解、属性和getter和setter。`@Entity`注解来自`javax.persistence`包，并将POJO标记为数据库实体，以便JPA可以从H2数据库中存储或检索它。`@Column`注解指定了数据库列的名称，对应的书籍属性将被存储在其中。`@NotNull`和`@Size`注解将确保我们的实体在进入数据库之前填入了适当的值。
- en: 'We have our entity defined; it''s now time to have a mechanism to read and
    store it in the database. We will use Spring''s `JpaRepository` for this purpose.
    The name of our repository will be `BookRepository` in the `BookRepository.java`
    file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们的实体；现在是时候有一个机制来读取和存储它在数据库中。我们将使用Spring的`JpaRepository`来实现这个目的。我们的仓库的名称将在`BookRepository.java`文件中为`BookRepository`：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The Spring Data JPA provides a repository programming model that starts with
    an interface per managed domain object. Defining this interface serves two purposes.
    First, by extending the `JPARepository` interfaces, we get a bunch of generic
    CRUD methods into our type that allows saving our entities, deleting them, and
    so on. For example, the following methods are available (declared in the `JPARepository`
    interfaces we are extending):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA提供了一个仓库编程模型，它从每个受管领域对象的接口开始。定义这个接口有两个目的。首先，通过扩展`JPARepository`接口，我们可以在我们的类型中获得一堆通用的CRUD方法，允许保存我们的实体，删除它们等等。例如，以下方法是可用的（声明在我们正在扩展的`JPARepository`接口中）：
- en: '`List<T> findAll();`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T> findAll();`'
- en: '`List<T> findAll(Sort sort);`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T> findAll(Sort sort);`'
- en: '`List<T> findAll(Iterable<ID> ids);`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T> findAll(Iterable<ID> ids);`'
- en: '`<S extends T> List<S> save(Iterable<S> entities);`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<S extends T> List<S> save(Iterable<S> entities);`'
- en: '`T getOne(ID id);`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T getOne(ID id);`'
- en: '`<S extends T> S save(S entity);`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<S extends T> S save(S entity);`'
- en: '`<S extends T> Iterable<S> save(Iterable<S> entities);`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<S extends T> Iterable<S> save(Iterable<S> entities);`'
- en: '`T findOne(ID id);`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T findOne(ID id);`'
- en: '`boolean exists(ID id);`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean exists(ID id);`'
- en: '`Iterable<T> findAll();`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterable<T> findAll();`'
- en: '`Iterable<T> findAll(Iterable<ID> ids);`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterable<T> findAll(Iterable<ID> ids);`'
- en: '`long count();`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long count();`'
- en: '`void delete(ID id);`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void delete(ID id);`'
- en: '`void delete(T entity);`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void delete(T entity);`'
- en: '`void delete(Iterable<? extends T> entities);`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void delete(Iterable<? extends T> entities);`'
- en: '`void deleteAll();`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void deleteAll();`'
- en: 'No SQL coding, no JPA-QL queries, nothing. Simply by extending the Spring `JPARepository`
    interface, all those methods are at our disposal. Of course, we are not limited
    to those. We can declare our own methods in our interface, as `findByTitle(String
    title)` , for example. It will be picked up by Spring at runtime and will find
    us a book by its title. I highly recommend reading the Spring Data project documentation
    and experimenting further; it''s very convenient to use. Using the `entity` repository
    straight from the controller is usually not very good practice, so it''s time
    to have a book service. It will be a `BookService` interface, defined in the `BookService.java`
    :'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 没有SQL编码，没有JPA-QL查询，什么都没有。只需扩展Spring的`JPARepository`接口，所有这些方法都可以随时使用。当然，我们不局限于这些。我们可以在我们的接口中声明自己的方法，比如`findByTitle(String
    title)`。它将在运行时被Spring捕获，并通过标题找到一本书。我强烈建议阅读Spring Data项目文档并进一步实验；它非常方便使用。直接从控制器使用`entity`存储库通常不是很好的做法，所以现在是时候有一个书籍服务了。它将是一个`BookService`接口，在`BookService.java`中定义：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The implementation, in the `BookServiceImpl.java` , can look the same as following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 实现，在`BookServiceImpl.java`中可以看起来与以下内容相同：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous listing presents the `BookService` implementation. Note that we
    have injected the `BookRepository` in the constructor. All the implementation
    methods, such as `saveBook()` , `getBook()` , `deleteBook()` , and `getList()`
    will use the injected `BookRepository` to operate on the book entities in the
    database. It's time for the last class, the actual controller that will wire all
    the previous classes together.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的清单介绍了`BookService`的实现。请注意，我们已经在构造函数中注入了`BookRepository`。所有实现方法，如`saveBook()`，`getBook()`，`deleteBook()`和`getList()`都将使用注入的`BookRepository`来操作数据库中的书籍实体。现在是最后一个类的时候，实际的控制器将把所有前面的类连接在一起。
- en: REST controller
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST控制器
- en: 'The REST controller defines URI paths that the service is going to respond
    to. It declares paths and corresponding `HTTP` methods that each controller method
    should react to. We define all of these using annotations. This approach is very
    similar to JAX-RS with Jersey. Our service has just one, single `book` resource,
    so we will have just a single controller for starters. It will be `BookController`
    class, defined in the `BookController.java` :'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: REST控制器定义了服务将要响应的URI路径。它声明了路径和相应的`HTTP`方法，每个控制器方法都应该对其做出反应。我们使用注解来定义所有这些。这种方法与Jersey的JAX-RS非常相似。我们的服务只有一个`book`资源，所以我们首先只会有一个控制器。它将是`BookController`类，在`BookController.java`中定义：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see in the previous example, the class is annotated with the `@RestController`
    annotation. This is what makes it a controller, actually. In fact, it''s a convenient
    annotation that is itself annotated with `@Controller` and `@ResponseBody` annotations.
    `@Controller` indicates that an annotated class is a controller (a web controller),
    also allowing for implementation classes to be autodetected through Spring''s
    classpath scanning. Every method in a controller that should respond to a call
    to a specific URI is mapped with the `@RequestMapping` annotation. `@RequestMapping`
    takes parameters, the most important ones are:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的示例中所看到的，该类使用`@RestController`注解进行了标注。这实际上是使其成为控制器的原因。事实上，这是一个方便的注解，它本身带有`@Controller`和`@ResponseBody`注解。`@Controller`表示一个被注解的类是一个控制器（Web控制器），还允许通过Spring的类路径扫描自动检测实现类。控制器中应该对特定URI的调用做出响应的每个方法都使用`@RequestMapping`注解进行映射。`@RequestMapping`接受参数，其中最重要的是：
- en: '`value` : It will specify the URI path'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：它将指定URI路径'
- en: '`method` : Specifyies the `HTTP` method to handle'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`：指定要处理的`HTTP`方法'
- en: '`headers` : The headers of the mapped request, in a format `myHeader=myValue`
    . A request will be handled by the method using the headers parameter, only if
    the incoming request header is found to have the given value'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`：映射请求的标头，格式为`myHeader=myValue`。只有当传入请求标头被发现具有给定值时，请求才会使用标头参数来处理该方法'
- en: '`consumes` : Specifies the media types the mapped request can consume, such
    as `"text/plain"` or `"application/json"` . This can be a list of media types,
    for example: `{"text/plain", "application/json"}`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`consumes`：指定映射请求可以消耗的媒体类型，例如`"text/plain"`或`"application/json"`。这也可以是媒体类型的列表，例如：`{"text/plain",
    "application/json"}`'
- en: '`produces` : Specifies the media types the mapped request can produce, such
    as `"text/plain"` or `"application/json"` . This again can be a list of media
    types, for example: `{"text/plain", "application/json"}`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`produces`：指定映射请求可以生成的媒体类型，例如`"text/plain"`或`"application/json"`。这也可以是媒体类型的列表，例如：`{"text/plain",
    "application/json"}`'
- en: '`Similar to JAX-RS` `@PathParam` and `@QueryParam` to specify the controller
    method''s input parameters`,` now we have `@PathVariable` and `@RequestParam`
    in Spring. If you need to have your method parameter come in the request body
    (as a whole JSON object that you want to save, the same as in our `saveBook()`
    method), you will need to map the parameter using the `@RequestBody` annotation.
    As for the output, the `@ResponseBody` annotation can tell our controller that
    the method return value should be bound to the web response body.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`类似于JAX-RS` `@PathParam`和`@QueryParam`用于指定控制器方法的输入参数，现在在Spring中我们有`@PathVariable`和`@RequestParam`。如果您需要使方法参数出现在请求体中（作为您想要保存的整个JSON对象，与我们的`saveBook()`方法中一样），则需要使用`@RequestBody`注释来映射参数。至于输出，`@ResponseBody`注释可以告诉我们的控制器，方法返回值应绑定到Web响应主体。'
- en: In a real-world service, you will probably have a lot of controllers with a
    lot of paths mapped. When exposing such a service to the world, it's usually a
    good practice to document the API of the service. This API documentation is the
    service contract. Doing this manually could be a tedious process. Also, if you
    make changes, it's good to have the API documentation in sync. There is a tool
    that can make it a lot easier, Swagger.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的服务中，您可能会有很多具有许多映射路径的控制器。将这样的服务暴露给世界时，通常最好记录服务的API。这个API文档就是服务合同。手动执行此操作可能会很繁琐。而且，如果您进行更改，最好将API文档同步。有一个工具可以使这变得更容易，Swagger。
- en: Documenting the API
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录API
- en: 'Before a client can consume a service, it would need a service contract. A
    service contract defines all the details about a service; for example, how the
    service can be called, the URI of the service, and what the request and response
    formats are. Your clients will need to know how to interact with your API. Swagger
    is gaining a lot of ground with support from major vendors in the last couple
    of years. Swagger''s specification presents all the details of your service resources
    and operations in a JSON format. The format of the specification is known as the
    OpenAPI specification (Swagger RESTful API documentation specification). It''s
    human and machine readable, easy for parsing, transferring, and using in integration.
    The `SpringFox` library can be used to generate Swagger documentation from the
    RESTful services code. What''s more, there is a wonderful tool called Swagger
    UI, which when integrated into the application, provides human readable documentation.
    In this section, we will generate Swagger documentation for our services. The
    `SpringFox` library, available on GitHub at [http://springfox.github.io/springfox/](http://springfox.github.io/springfox/)
    and in the Maven central, is a tool to automatically build JSON API documentation
    for APIs built with Spring. Even better, the library provides the Swagger UI tool.
    The tool will be deployed together with your service and can be used, browse the
    generated API documentation in a very convenient way. Let''s introduce Swagger
    to our service. We begin with adding the needed dependencies to our service `pom.xml`
    file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端可以使用服务之前，它需要一个服务合同。服务合同定义了有关服务的所有细节；例如，服务如何被调用，服务的URI是什么，请求和响应格式是什么。您的客户端需要知道如何与您的API进行交互。在过去几年中，Swagger得到了许多主要供应商的支持。Swagger的规范以JSON格式呈现了服务资源和操作的所有细节。规范的格式被称为OpenAPI规范（Swagger
    RESTful API文档规范）。它既可以被人类阅读，也可以被机器阅读，易于解析、传输和在集成中使用。`SpringFox`库可用于从RESTful服务代码生成Swagger文档。而且，还有一个名为Swagger
    UI的精彩工具，当集成到应用程序中时，提供人类可读的文档。在本节中，我们将为我们的服务生成Swagger文档。`SpringFox`库可在GitHub上找到[http://springfox.github.io/springfox/](http://springfox.github.io/springfox/)，并且在Maven中央库中也可以找到，它是一个用于自动构建Spring构建的API的JSON
    API文档的工具。更好的是，该库提供了Swagger UI工具。该工具将与您的服务一起部署，并且可以以非常便捷的方式浏览生成的API文档。让我们向我们的服务介绍Swagger。我们首先要向我们的服务的`pom.xml`文件添加所需的依赖项：
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Having the library available in a classpath of our application, we need to
    turn it on. The next step will be then be adding the configuration class to enable
    and generate the Swagger documentation. We do it by creating a class annotated
    with the Spring `@Configuration` annotation, the same as in the following example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序的类路径中有了该库后，我们需要将其打开。接下来的步骤将是添加配置类以启用和生成Swagger文档。我们可以通过创建一个使用Spring
    `@Configuration`注解的类来实现，就像下面的例子一样：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A couple of words of explanation here. `@Configuration` means that the annotated
    class is defining a Spring configuration, `@EnableSwagger2` turns off the Swagger
    support. The `Docket` is a builder class to configure the generation of Swagger
    documentation, configured with `DocumentationType.SWAGGER_2` to generate Swagger
    2 compatible API documentation. The `select()` method called on the `Docket` bean
    instance returns an `ApiSelectorBuilder` , which provides the `apis()` and `paths()`
    methods to filter the controllers and methods being documented using string predicates.
    In our example, we want all controllers and all mapped paths to be documented;
    that's why we use `.apis(RequestHandlerSelectors.any()).paths(PathSelectors.any())`
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里解释一下。`@Configuration`表示被注释的类定义了一个Spring配置，`@EnableSwagger2`关闭了Swagger支持。`Docket`是一个构建器类，用于配置生成Swagger文档，配置为`DocumentationType.SWAGGER_2`以生成兼容Swagger
    2的API文档。在`Docket`实例上调用的`select()`方法返回一个`ApiSelectorBuilder`，它提供了`apis()`和`paths()`方法，用于使用字符串谓词过滤要记录的控制器和方法。在我们的例子中，我们希望记录所有控制器和所有映射的路径；这就是为什么我们使用`.apis(RequestHandlerSelectors.any()).paths(PathSelectors.any())`。
- en: You could also use the `regex` parameter passed to `paths()` to provide an additional
    filter to generate documentation only for the path matching the regex expression.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用传递给`paths()`的`regex`参数来提供一个额外的过滤器，仅为与正则表达式匹配的路径生成文档。
- en: 'That''s it; it''s the simplest form of generating a documentation for your
    API. If you now run the service (we are going to do this in a short while), two
    endpoints will be available:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；这是为您的API生成文档的最简单形式。如果您现在运行服务（我们将在不久的将来这样做），将会有两个端点可用：
- en: '`http://localhost:8080/v2/api-docs`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/v2/api-docs`'
- en: '`http://localhost:8080/swagger-ui.html`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/swagger-ui.html`'
- en: 'The first one contains the Swagger 2 compatible documentation, in a JSON format,
    as you can see in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个包含了Swagger 2兼容的文档，以JSON格式呈现，如下截图所示：
- en: '![](Image00061.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00061.jpg)'
- en: 'To browse the API documentation in a lot more useful form, point your browser
    to the second URL. You will be presented with the Swagger UI tool interface:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要以更加有用的形式浏览API文档，请将浏览器指向第二个URL。您将看到Swagger UI工具界面：
- en: '![](Image00062.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00062.jpg)'
- en: 'The Swagger UI is a collection of HTML, JavaScript, and CSS assets that dynamically
    generate beautiful documentation from a Swagger-compliant API. It lists your service
    operations, and its request and response formats. Best of all, you can test your
    service using this tool, by executing specific requests. In fact, it''s a great
    tool to quickly test your service. Our documentation is not very descriptive.
    Of course, we have a listing of our exposed endpoints with their input and output
    description. It would be nice if we could enhance the documentation with some
    more specific details. We CAN do it, there are Java annotations we can use in
    the service''s code to enhance the generated documentation. The annotations come
    from the Swagger-annotation package, which will be available if you use the `springfox-swagger2`
    library in your project. For example, consider the following code snippet:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI是一组HTML、JavaScript和CSS资源，可以根据符合Swagger的API动态生成美观的文档。它列出了您的服务操作以及其请求和响应格式。最重要的是，您可以使用此工具测试您的服务，执行特定的请求。实际上，这是一个快速测试您的服务的好工具。我们的文档并不是非常描述性的。当然，我们列出了我们的暴露端点及其输入和输出描述。如果我们能用一些更具体的细节增强文档就更好了。我们可以做到这一点，我们可以在服务的代码中使用Java注解来增强生成的文档。这些注解来自Swagger-annotation包，如果您在项目中使用`springfox-swagger2`库，它将可用。例如，考虑以下代码片段：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the previous code, we use the `@ApiOperation` annotation to provide a more
    detailed description of what the operation does. There''s a lot more: `@ApiImplicitParam`
    for describing parameters, `@Authorization` to provide a name of the authorization
    scheme to be used on this resource/operation, `@License` to provide information
    about the license, and so on. All of those annotations will be picked up by `springfox-swagger2`
    and used to enhance the generated documentation. I highly recommend looking at
    the swagger-annotations JavaDoc; you will be able to document your API in a detailed,
    professional way.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`@ApiOperation`注解提供了对操作的更详细描述。还有更多：`@ApiImplicitParam`用于描述参数，`@Authorization`提供要在此资源/操作上使用的授权方案的名称，`@License`提供有关许可证的信息，等等。所有这些注解都将被`springfox-swagger2`捕获并用于增强生成的文档。我强烈建议查看swagger-annotations的JavaDoc；你将能够以详细、专业的方式记录你的API。
- en: I guess our little service is ready; it's time to bring it to life.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们的小服务已经准备好了；是时候让它活起来了。
- en: Running the application
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Because we have defined the Spring Boot plugin in our `pom.xml` build file,
    we can now start the application using Maven. All you need to have is Maven present
    on the system path, but you probably have this already as a Java developer. To
    run the application, execute the following from the command shell (terminal on
    MacOS or `cmd.exe` on Windows):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经在`pom.xml`构建文件中定义了Spring Boot插件，所以现在可以使用Maven启动应用程序。你只需要在系统路径上有Maven，但作为Java开发人员，你可能已经有了。要运行应用程序，请在命令行（MacOS上的终端或Windows上的`cmd.exe`）中执行以下操作：
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After a while, the Spring splash log will show up in the console and your microservice
    will be ready to accept `HTTP` requests. Soon, in [Chapter 5](text00084.html)
    , *Creating Images with Java Applications* , our goal will be to see the same
    coming from the Docker container:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 过一会儿，Spring的启动日志将出现在控制台上，你的微服务将准备好接受`HTTP`请求。很快，在[第5章](text00084.html)，*使用Java应用程序创建图像*，我们的目标将是从Docker容器中看到相同的情况：
- en: '![](Image00063.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00063.jpg)'
- en: If you want to, you can also run the application straight from the IDE, be it
    IntelliJ IDEA, Eclipse, or Netbeans. Our `BookstoreApplication` class has a `main()`
    method; you will just need to create a runtime configuration in your IDE and run
    it. This is different from the JEE7 JAX-RS service. It that case, you would need
    to deploy the service in a JEE compliant application server to be able to run
    it. Having the `main()` method defined is very convenient when debugging your
    service. Just start a debugging session with `BookstoreApplication` as the entry
    point. There is no need to create a remote debugging session. Having our service
    running, it's time to make some calls to its exposed endpoints.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你也可以直接从IDE（IntelliJ IDEA、Eclipse或Netbeans）运行应用程序。我们的`BookstoreApplication`类有一个`main()`方法；你只需要在你的IDE中创建一个运行时配置并运行它。这与JEE7
    JAX-RS服务不同。在那种情况下，你需要将服务部署在一个符合JEE标准的应用服务器上才能运行它。当调试服务时，定义`main()`方法非常方便。只需以`BookstoreApplication`为入口点开始调试会话。无需创建远程调试会话。服务运行后，是时候对其公开的端点进行一些调用了。
- en: Making calls
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出调用
- en: Making a call to the operation exposed from the service can be done using any
    tool or library that can execute the `HTTP` requests. The first obvious choice
    would be just a web browser. But a web browser is convenient only for executing
    `GET` requests (as for getting a list of books from our bookstore service). If
    you need to execute other methods such as `POST` or `PUT` or provide additional
    request parameters, header values, and so on, you will need to use some alternatives.
    The first choice could be cURL, a command-line tool for transferring data using
    various protocols. Let's look at other options we have.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 调用从服务中公开的操作可以使用任何可以执行`HTTP`请求的工具或库。第一个明显的选择可能只是一个网络浏览器。但是网络浏览器只方便执行`GET`请求（比如从我们的书店服务获取书籍列表）。如果你需要执行其他方法，比如`POST`或`PUT`，或者提供额外的请求参数、头部值等，你将需要使用一些替代方案。第一个选择可能是cURL，一个用于使用各种协议传输数据的命令行工具。让我们看看我们还有哪些其他选择。
- en: Spring RestTemplate
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring RestTemplate
- en: 'If you need to call a service from another service, you will need a `HTTP`
    client. Spring provides the very useful `RestTemplate` class. It gives you a synchronous
    client-side `HTTP` access, simplifies communication with HTTP servers, and enforces
    RESTful principles. It handles HTTP connections, leaving application code to provide
    URLs (with possible template variables) and extracts results. By default, `RestTemplate`
    relies on standard JDK facilities to establish HTTP connections. You can switch
    to a different HTTP library of your choice, such as Apache `HttpComponents` ,
    `Netty` , and `OkHttp` through its `setRequestFactory()` method. Calling the `REST`
    resource to get a book with `ID = 1` can be as simple as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从另一个服务调用服务，你将需要一个`HTTP`客户端。Spring提供了非常有用的`RestTemplate`类。它为你提供了同步的客户端端`HTTP`访问，简化了与HTTP服务器的通信，并强制执行RESTful原则。它处理HTTP连接，让应用程序代码提供URL（可能带有模板变量）并提取结果。默认情况下，`RestTemplate`依赖于标准的JDK设施来建立HTTP连接。你可以通过其`setRequestFactory()`方法切换到你选择的不同的HTTP库，比如Apache
    `HttpComponents`，`Netty`和`OkHttp`。调用`REST`资源以获取`ID = 1`的书可以简单地如下所示：
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, this is just a simplified client example, to present you the idea.
    You can use `RestTemplate` to create more sophisticated client calls to the REST
    resources.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个简化的客户端示例，来向你展示这个想法。你可以使用`RestTemplate`来创建更复杂的客户端调用REST资源。
- en: HTTPie
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPie
- en: 'A great command-line alternative to cURL is HTTPie, available at [https://httpie.org](https://httpie.org)
    . It''s a command-line `HTTP` client. Luckily, the `*ie*` in the name doesn''t
    come from Internet Explorer. If you prefer to work from the shell or command line,
    `HTTPie` is a just a single command which adds the following features to cUrl:
    sensible defaults, expressive and intuitive command syntax, colorized and formatted
    terminal output, built-in JSON support, persistent sessions, forms and file uploads,
    proxies and authentication support, and support for arbitrary request data and
    headers. It''s written in Python and works on Linux, macOSX, and Windows.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPie是cURL的一个很好的命令行替代品，可在[https://httpie.org](https://httpie.org)找到。它是一个命令行`HTTP`客户端。幸运的是，名字中的“ie”并不是来自于Internet
    Explorer。如果你喜欢从shell或命令行工作，`HTTPie`只是一个单一的命令，它为cUrl添加了以下功能：合理的默认设置，表达和直观的命令语法，带颜色和格式的终端输出，内置的JSON支持，持久会话，表单和文件上传，代理和认证支持，以及对任意请求数据和头部的支持。它是用Python编写的，在Linux、macOSX和Windows上都可以运行。
- en: Postman
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Postman
- en: 'Postman is a tool of choice for many developers. It''s available as the Chrome
    plugin or a standalone utility at [https://www.getpostman.com](https://www.getpostman.com)
    . Postman is very convenient for use. It''s a powerful GUI platform to make your
    API development faster and easier, from building API requests through testing,
    documentation, and sharing. You can save your `HTTP` requests for later use and
    organize them in collections. If you work in multiple environments, for example
    your localhost, when developing the service and a production environment later
    on, Postman introduces the concept of environments. Environments give you the
    ability to customize your requests using variables. This way you can easily switch
    between different setups without changing your requests. Each environment is represented
    as a set of key-value pairs. This makes working with multiple environments easy.
    It also has a very handy UI for editing your `HTTP` requests:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Postman是许多开发人员的首选工具。它可以作为Chrome插件或独立实用程序在[https://www.getpostman.com](https://www.getpostman.com)上使用。Postman非常方便使用。它是一个强大的GUI平台，可以使您的API开发更快速、更容易，从构建API请求到测试、文档编制和共享。您可以保存HTTP请求以供以后使用，并将它们组织成集合。如果您在多个环境中工作，例如在开发服务时使用本地主机和以后在生产环境中使用，Postman引入了环境的概念。环境使您能够使用变量自定义您的请求。这样，您可以轻松地在不同的设置之间切换，而不必更改您的请求。每个环境都表示为一组键值对。这使得在多个环境中工作变得容易。它还具有非常方便的UI来编辑您的HTTP请求：
- en: '![](Image00064.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00064.jpg)'
- en: 'You can define request headers, cookies, and body. If your service supports
    authentication, Postman contains a lot of authentication helpers: it can be basic
    Auth, digest Auth, and OAuth. The response body can be viewed in one of three
    views: pretty, raw, and preview. The pretty mode formats JSON or XML responses
    so that they are easier to look at and headers are displayed as key/value pairs
    in the header tab. It''s a really powerful and pleasant to use tool. If you work
    on macOS, there''s something even better.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义请求头、cookie和正文。如果您的服务支持身份验证，Postman包含许多身份验证助手：它可以是基本身份验证、摘要身份验证和OAuth。响应正文可以在三个视图中的一个中查看：漂亮、原始和预览。漂亮模式会格式化JSON或XML响应，使其更容易查看，并且标题会显示为标题选项卡中的键/值对。这是一个非常强大和愉快的工具。如果您在macOS上工作，甚至有更好的东西。
- en: Paw for Mac
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Paw for Mac
- en: '**Paw** is a full-featured `HTTP` client that lets you test the APIs you build
    or consume. It has a beautiful native OS X interface to compose requests, inspect
    server responses, and generate client code out of the box. As you can see in the
    following screenshot, it also contains a powerful editor to compose your requests:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Paw是一个功能齐全的HTTP客户端，可以让您测试构建或使用的API。它具有美丽的原生OS X界面，可以组合请求，检查服务器响应，并直接生成客户端代码。正如您在以下截图中所看到的，它还包含一个强大的编辑器来组合您的请求：
- en: '**![](Image00065.jpg)**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](Image00065.jpg)**'
- en: It also supports a lot of authentication schemas including OAuth 1 and 2, Basic
    Auth, Digest Auth, Hawk, AWS Signature Version 4, and Amazon S3\. Similar to Postman,
    Paw also allows you to organize your requests in folders. You can also define
    and switch different environments quickly. The interesting feature is that Paw
    can generate client code to execute your requests. It can generate code for cURL,
    HTTPie, Objective-C, Python, JavaScript, Ruby, PHP, Java, Go, and many others.
    And guess what? Paw can also import the Swagger documentation we have been talking
    about. You can use this feature to test the service you were given the documentation
    for.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 它还支持许多身份验证模式，包括OAuth 1和2、基本身份验证、摘要身份验证、Hawk、AWS签名版本4和Amazon S3。与Postman类似，Paw还允许您将请求组织到文件夹中。您还可以快速定义和切换不同的环境。有趣的功能是Paw可以生成客户端代码来执行您的请求。它可以为cURL、HTTPie、Objective-C、Python、JavaScript、Ruby、PHP、Java、Go等生成代码。猜猜？Paw还可以导入我们一直在谈论的Swagger文档。您可以使用此功能来测试您获得文档的服务。
- en: If you need to quickly start with your new service, there are a couple of tools
    that may come in handy. One of them is **Initializr** .
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要快速启动新服务，有一些工具可能会派上用场。其中之一是**Initializr**。
- en: Spring Initializr
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Initializr
- en: 'Spring Initializr is a web-based tool available at [https://start.spring.io](https://start.spring.io)
    . It''s a quick start generator for Spring projects. Spring Initializr can be
    used as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Initializr是一个基于Web的工具，可在[https://start.spring.io](https://start.spring.io)上使用。这是Spring项目的快速启动生成器。Spring
    Initializr的使用方法如下：
- en: From the web browser at [https://start.spring.io](https://start.spring.io)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网页浏览器访问[https://start.spring.io](https://start.spring.io)
- en: In your IDE (IntelliJ IDEA Ultimate or NetBeans, using plugins)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的IDE（IntelliJ IDEA Ultimate或NetBeans，使用插件）
- en: From the command line with the Spring Boot CLI or simply with cURL or HTTPie
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行使用Spring Boot CLI，或者简单地使用cURL或HTTPie
- en: 'Using the web application is very convenient; all you need to do is provide
    details about your application Maven archetype, such as group, artifact name,
    description, and so on:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web应用程序非常方便；您只需要提供有关您的应用程序Maven原型的详细信息，例如组、工件名称、描述等：
- en: '![](Image00066.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00066.jpg)'
- en: 'In the Dependencies section, you can enter the keywords of the features you
    would like to have included, such as JPA, web, and so on. You can also switch
    the UI to an advanced view, to have all the features listed and ready to be selected:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在“依赖项”部分，您可以输入您想要包括的功能的关键字，例如JPA、web等。您还可以切换UI以查看高级视图，以列出所有功能并准备选择：
- en: '![](Image00067.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00067.jpg)'
- en: As the output, Spring Initializr will create a ZIP archive with the base Maven
    project you want to start with. The project created by Spring Initializr is a
    Maven project and follows the standard `Maven` directory layout. This really saves
    a lot of time when creating new Spring projects. You no longer need to search
    for specific Maven archetypes and look for their versions. Initializr will generate
    the `pom.xml` for you, automatically. The presence of the dependencies in the
    `pom.xml` is important because Spring Boot will make decisions on what to create
    automatically when certain things are found on the classpath. For example, if
    the dependency for the H2 database is present and exists on the classpath when
    the application is run, Spring Boot will automatically create a data connection
    and an embedded H2 database.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出，Spring Initializr将创建一个ZIP存档，其中包含您想要开始的基本Maven项目。Spring Initializr创建的项目是一个Maven项目，并遵循标准的`Maven`目录布局。这在创建新的Spring项目时真的节省了很多时间。您不再需要搜索特定的Maven原型并寻找它们的版本。Initializr将自动为您生成`pom.xml`。`pom.xml`中的依赖项的存在很重要，因为当在类路径上发现某些内容时，Spring
    Boot将自动决定要自动创建什么。例如，如果H2数据库的依赖项存在并且在应用程序运行时存在于类路径上，Spring Boot将自动创建数据连接和嵌入式H2数据库。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you can see, developing Java microservices is not as tricky as it may sound.
    You can choose between JEE7 JAX-RS or Spring Boot, wire some classes, and a basic
    service is ready. You are not limited to using Spring MVC for creating your REST
    endpoints. If you are more familiar with the Java EE JAX-RS specification, you
    can easily integrate JAX-RS into Spring applications, especially Spring Boot applications.
    You can then take what is best for you from both.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，开发Java微服务并不像听起来那么棘手。您可以选择使用JEE7 JAX-RS或Spring Boot，连接一些类，一个基本的服务就准备好了。您并不局限于使用Spring
    MVC来创建您的REST端点。如果您更熟悉Java EE JAX-RS规范，您可以很容易地将JAX-RS集成到Spring应用程序中，特别是Spring Boot应用程序。然后您可以从两者中选择最适合您的部分。
- en: Of course, in the real world you would probably want to include some more advanced
    features such as authentication and security. Having Spring Initializr available
    can give you a serious speed boost when developing your own service. In [Chapter
    5](text00084.html) , *Creating Images with Java Applications* , we are going to
    package our bookstore service into a Docker image and run it using Docker Engine.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在现实世界中，您可能希望包括一些更高级的功能，如身份验证和安全性。有了Spring Initializr，您在开发自己的服务时可以获得严重的速度提升。在[第5章](text00084.html)中，*使用Java应用程序创建图像*，我们将把我们的书店服务打包成一个Docker镜像，并使用Docker
    Engine运行它。
