- en: Chapter 3. Working with the Different Light Sources Available in Three.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用Three.js中可用的不同光源
- en: 'In the first chapter, you learned about the basics of Three.js, and in the
    previous chapter, we looked a bit deeper at the most important parts of the scene:
    the geometries, meshes, and cameras. You might have noticed that we skipped lights
    in that chapter even though they make up an important part of every Three.js scene.
    Without lights, we won''t see anything rendered. Since Three.js contains a large
    number of lights, each of which has a specific use, we''ll use this whole chapter
    to explain the various details of the lights and prepare you for the next chapter
    on material usage.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，您学习了Three.js的基础知识，在上一章中，我们更深入地了解了场景中最重要的部分：几何体、网格和相机。您可能已经注意到，在那一章中我们跳过了灯光，尽管它们构成了每个Three.js场景的重要部分。没有灯光，我们将看不到任何渲染。由于Three.js包含大量的灯光，每种灯光都有特定的用途，我们将用整个章节来解释灯光的各种细节，并为下一章关于材质使用做好准备。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: WebGL itself doesn't have inherent support for lighting. Without Three.js, you
    would have to write specific WebGL shader programs to simulate these kinds of
    lights. A good introduction on simulating lighting in WebGL from scratch can be
    found at [https://developer.mozilla.org/en-US/docs/Web/WebGL/Lighting_in_WebGL](https://developer.mozilla.org/en-US/docs/Web/WebGL/Lighting_in_WebGL).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL本身并不直接支持照明。如果没有Three.js，您将不得不编写特定的WebGL着色器程序来模拟这些类型的灯光。您可以在[https://developer.mozilla.org/en-US/docs/Web/WebGL/Lighting_in_WebGL](https://developer.mozilla.org/en-US/docs/Web/WebGL/Lighting_in_WebGL)找到有关在WebGL中模拟照明的良好介绍。
- en: 'In this chapter, you''ll learn about the following subjects:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，您将学习以下主题：
- en: The light sources that are available in Three.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Three.js中可用的光源
- en: When a specific light source should be used
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时应该使用特定的光源
- en: How you can tune and configure the behavior of all these light sources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您如何调整和配置所有这些光源的行为
- en: As a bonus, we'll also quickly look at how you can create lens flares
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为奖励，我们还将快速看一下如何创建镜头眩光
- en: As with all the chapters, we have a lot of examples that you can use to experiment
    with the lights' behavior. The examples shown in this chapter can be found in
    the `chapter-03` folder of the supplied sources.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有章节一样，我们有很多示例供您用来实验灯光的行为。本章中展示的示例可以在提供的源代码的`chapter-03`文件夹中找到。
- en: Different kinds of lighting provided by Three.js
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Three.js提供的不同类型的照明
- en: 'There are a number of different lights available in Three.js that all have
    specific behavior and usages. In this chapter, we''ll discuss the following set
    of lights:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js中有许多不同的灯光可用，它们都具有特定的行为和用途。在这一章中，我们将讨论以下一组灯光：
- en: '| Name | Description |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.AmbientLight` | This is a basic light, the color of which is added
    to the current color of the objects in the scene. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.AmbientLight` | 这是一种基本的光，其颜色被添加到场景中对象的当前颜色中。'
- en: '| `THREE.PointLight` | This is a single point in space from which light spreads
    in all directions. This light can''t be used to create shadows. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.PointLight` | 这是空间中的一个单点，光从这个点向所有方向扩散。这种光不能用来创建阴影。'
- en: '| `THREE.SpotLight` | This light source has a cone-like effect like that of
    a desk lamp, a spot in the ceiling, or a torch. This light can cast shadows. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.SpotLight` | 这种光源具有类似台灯、天花板上的聚光灯或火炬的锥形效果。这种光可以投射阴影。'
- en: '| `THREE.DirectionalLight` | This is also called infinite light. The light
    rays from this light can be seen as parallel, like, for instance, the light from
    the sun. This light can also be used to create shadows. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.DirectionalLight` | 这也被称为无限光。这种光的光线可以被视为平行的，就像太阳的光一样。这种光也可以用来创建阴影。'
- en: '| `THREE.HemisphereLight` | This is a special light and can be used to create
    more natural-looking outdoors lighting by simulating a reflective surface and
    a faintly illuminating sky. This light also doesn''t provide any shadow-related
    functionality. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.HemisphereLight` | 这是一种特殊的光，可以用来通过模拟反射表面和微弱照亮的天空来创建更自然的室外照明。这种光也不提供任何与阴影相关的功能。'
- en: '| `THREE.AreaLight` | With this light source, instead of a single point in
    space, you can specify an area from which light emanates. `THREE.AreaLight` doesn''t
    cast any shadows. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.AreaLight` | 使用这种光源，您可以指定一个区域，而不是空间中的单个点，从这个区域发出光。`THREE.AreaLight`不会投射任何阴影。|'
- en: '| `THREE.LensFlare` | This is not a light source, but with `THREE.LensFlare`,
    you can add a lens flare effect to the lights in your scene. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.LensFlare` | 这不是一个光源，但使用`THREE.LensFlare`，您可以为场景中的灯光添加镜头眩光效果。'
- en: 'This chapter is divided into two main parts. First, we''ll look at the basic
    lights: `THREE.AmbientLight`, `THREE.PointLight`, `THREE.SpotLight`, and `THREE.DirectionalLight`.
    All these lights extend the base `THREE.Light` object, which provides shared functionality.
    The lights mentioned here are simple lights that require little setting up and
    can be used to recreate most of the required lighting scenarios. In the second
    part, we will look at a couple of special-purpose lights and effects: `THREE.HemisphereLight`,
    `THREE.AreaLight`, and `THREE.LensFlare`. You''ll probably only need these lights
    in very specific cases.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章分为两个主要部分。首先，我们将看一下基本的灯光：`THREE.AmbientLight`、`THREE.PointLight`、`THREE.SpotLight`和`THREE.DirectionalLight`。所有这些灯光都扩展了基本的`THREE.Light`对象，提供了共享功能。这里提到的灯光都是简单的灯光，需要很少的设置，并且可以用来重新创建大部分所需的照明场景。在第二部分中，我们将看一下一些特殊用途的灯光和效果：`THREE.HemisphereLight`、`THREE.AreaLight`和`THREE.LensFlare`。您可能只在非常特殊的情况下需要这些灯光。
- en: Basic lights
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本灯光
- en: 'We''ll start with the most basic of the lights: `THREE.AmbientLight`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最基本的灯光开始：`THREE.AmbientLight`。
- en: THREE.AmbientLight
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.AmbientLight
- en: When you create `THREE.AmbientLight`, the color is applied globally. There isn't
    a specific direction this light comes from, and `THREE.AmbientLight` doesn't contribute
    to any shadows. You would normally not use `THREE.AmbientLight` as the single
    source of light in a scene since it colors all the objects in the same color,
    regardless of shape. You use it together with other lighting sources, such as
    `THREE.SpotLight` or `THREE.DirectionalLight` to soften the shadows or add some
    additional color to the scene. The easiest way to understand this is by looking
    at the `01-ambient-light.html` example in the `chapter-03` folder. With this example,
    you get a simple user interface that can be used to modify `THREE.AmbientLight`
    that is available in this scene. Note that in this scene, we also have `THREE.SpotLight`,
    which adds additional lighting and provides shadows.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建`THREE.AmbientLight`时，颜色是全局应用的。这种光没有特定的方向，`THREE.AmbientLight`不会对任何阴影产生影响。你通常不会将`THREE.AmbientLight`作为场景中唯一的光源，因为它会使所有的物体都呈现相同的颜色，而不考虑形状。你会将它与其他光源一起使用，比如`THREE.SpotLight`或`THREE.DirectionalLight`，来软化阴影或为场景增加一些额外的颜色。最容易理解的方法是查看`chapter-03`文件夹中的`01-ambient-light.html`示例。通过这个示例，你可以得到一个简单的用户界面，用于修改这个场景中可用的`THREE.AmbientLight`。请注意，在这个场景中，我们还有`THREE.SpotLight`，它提供了额外的照明并产生阴影。
- en: 'In the following screenshot, you can see that we used the scene from the first
    chapter and made the color of `THREE.AmbientLight` configurable. In this example,
    you can also turn off the spotlight to see what the effect of `THREE.AmbientLight`
    is on its own:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，你可以看到我们使用了第一章的场景，并使`THREE.AmbientLight`的颜色可配置。在这个示例中，你还可以关闭聚光灯，看看`THREE.AmbientLight`单独的效果：
- en: '![THREE.AmbientLight](graphics/2215OS_03_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.AmbientLight](graphics/2215OS_03_01.jpg)'
- en: The standard color we use in this scene is `#0c0c0c`. This is a hexadecimal
    representation of a color. The first two values specify the red part of the color,
    the next two values specify the green part, and the last two values specify the
    blue part.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个场景中使用的标准颜色是`#0c0c0c`。这是颜色的十六进制表示。前两个值指定颜色的红色部分，接下来的两个值指定绿色部分，最后两个值指定蓝色部分。
- en: 'In this example, we use a very dimmed light-gray color that we mainly use to
    smoothen the hard shadows our meshes cast to the ground plane. You can change
    the color to a more prominent yellow/orange color (`#523318`) with the menu in
    the top-right corner, and then the objects will have a sun-like glow over them.
    This is shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了一个非常昏暗的浅灰色，主要用于使我们的网格投射到地面平面上的硬阴影变得柔和。你可以通过右上角的菜单将颜色更改为更显眼的黄/橙色（`#523318`），然后物体将在上面产生太阳般的光芒。这在下面的截图中显示：
- en: '![THREE.AmbientLight](graphics/2215OS_03_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.AmbientLight](graphics/2215OS_03_02.jpg)'
- en: As the preceding image shows, the yellow/orange color is applied to all the
    objects and casts a green glow over the complete scene. What you should remember
    when working with this light is that you should be very conservative with the
    color you specify. If the color you specify is too bright, you'll quickly get
    a completely oversaturated image.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的图片所示，黄/橙色应用到了所有的物体，并在整个场景上投射出绿色的光晕。在使用这种光时，你应该记住的是，你应该非常谨慎地选择颜色。如果你选择的颜色太亮，你很快就会得到一个完全过饱和的图像。
- en: 'Now that we''ve seen what it does, let''s look at how you can create and use
    `THREE.AmbientLight`. The next couple of lines of code show you how to create
    `THREE.AmbientLight` and also show how to connect this to the GUI control menu,
    which we will introduce in [Chapter 11](ch11.html "Chapter 11. Custom Shaders
    and Render Postprocessing"), *Custom Shaders and Render Post Processing*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到它的作用，让我们看看如何创建和使用`THREE.AmbientLight`。接下来的几行代码向你展示了如何创建`THREE.AmbientLight`，并展示了如何将其连接到GUI控制菜单，我们将在[第11章](ch11.html
    "Chapter 11. Custom Shaders and Render Postprocessing")中介绍，*自定义着色器和渲染后处理*：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Creating `THREE.AmbientLight` is very simple and only takes a couple of steps.
    `THREE.AmbientLight` doesn''t have a position and is applied globally, so we only
    need to specify the color (in hex), `new THREE.AmbientLight(ambiColor)`, and add
    this light to the scene, `scene.add(ambientLight)`. In the example, we bind the
    color of `THREE.AmbientLight` to the control menu. To do this, you can use the
    same kind of configuration we used in the previous two chapters. The only change
    is that instead of using the `gui.add(...)` function, we use the `gui.addColor(...)`
    function. This creates an option in the control menu, with which we can directly
    change the color of the passed-in variable. In the code, you can see that we use
    the `onChange` feature of dat.GUI: `gui.addColor(...).onChange(function(e){...})`.
    With this function, we tell `dat.GUI` to call the passed-in function each time
    the color changes. In this specific case, we set the color of `THREE.AmbientLight`
    to a new value.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`THREE.AmbientLight`非常简单，只需要几个步骤。`THREE.AmbientLight`没有位置，是全局应用的，所以我们只需要指定颜色（十六进制），`new
    THREE.AmbientLight(ambiColor)`，并将这个光添加到场景中，`scene.add(ambientLight)`。在示例中，我们将`THREE.AmbientLight`的颜色绑定到控制菜单。要做到这一点，可以使用我们在前两章中使用的相同类型的配置。唯一的变化是，我们使用`gui.addColor(...)`函数，而不是使用`gui.add(...)`函数。这在控制菜单中创建一个选项，我们可以直接改变传入变量的颜色。在代码中，你可以看到我们使用了dat.GUI的`onChange`特性：`gui.addColor(...).onChange(function(e){...})`。通过这个函数，我们告诉`dat.GUI`每次颜色改变时调用传入的函数。在这种特定情况下，我们将`THREE.AmbientLight`的颜色设置为一个新值。
- en: Using the THREE.Color object
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用THREE.Color对象
- en: 'Before we move on to the next light, here''s a quick note on using the `THREE.Color`
    object. In Three.js, when you construct an object, you can (usually) specify the
    color as either a hex string (`"#0c0c0c"`) or a hex value (`0x0c0c0c`), which
    is the preferred way of doing it, or by specifying the individual RGB values (`0.3`,
    `0.5`, `0.6`) on a scale of 0 to 1\. If you want to change the color after construction,
    you''ll have to create a new `THREE.Color` object or modify the internal properties
    of the current `THREE.Color` object. The `THREE.Color` object comes with the following
    functions to set and get information about the current object:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个光源之前，这里有一个关于使用`THREE.Color`对象的快速说明。在Three.js中，当您构造一个对象时，通常可以将颜色指定为十六进制字符串(`"#0c0c0c"`)或十六进制值(`0x0c0c0c`)，这是首选的方法，或者通过指定0到1的范围上的单独的RGB值(`0.3`，`0.5`，`0.6`)。如果您想在构造后更改颜色，您将不得不创建一个新的`THREE.Color`对象或修改当前`THREE.Color`对象的内部属性。`THREE.Color`对象具有以下函数来设置和获取有关当前对象的信息：
- en: '| Name | Description |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `set(value)` | Set the value of this color to the supplied hex value. This
    hex value may be a string, a number, or an existing `THREE.Color` instance. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `set(value)` | 将此颜色的值设置为提供的十六进制值。此十六进制值可以是字符串、数字或现有的`THREE.Color`实例。 |'
- en: '| `setHex(value)` | Set the value of this color to the supplied numeric hex
    value. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `setHex(value)` | 将此颜色的值设置为提供的数值十六进制值。 |'
- en: '| `setRGB(r,g,b)` | Set the value of this color based on the supplied RGB values.
    The values range from 0 to 1. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `setRGB(r,g,b)` | 根据提供的RGB值设置此颜色的值。值的范围从0到1。 |'
- en: '| `setHSL(h,s,l)` | Set the value of this color on the supplied HSL values.
    The values range from 0 to 1\. A good explanation of how HSL works for configuring
    colors can be found at [http://en.wikibooks.org/wiki/Color_Models:_RGB,_HSV,_HSL](http://en.wikibooks.org/wiki/Color_Models:_RGB,_HSV,_HSL).
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `setHSL(h,s,l)` | 根据提供的HSL值设置此颜色的值。值的范围从0到1。有关如何使用HSL配置颜色的良好解释可以在[http://en.wikibooks.org/wiki/Color_Models:_RGB,_HSV,_HSL](http://en.wikibooks.org/wiki/Color_Models:_RGB,_HSV,_HSL)找到。
    |'
- en: '| `setStyle(style)` | Set the value of this color based on the CSS way of specifying
    colors. For instance, you could use `"rgb(255,0,0)"`, `"#ff0000"`, `"#f00"`, or
    even `"red"`. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `setStyle(style)` | 根据指定颜色的CSS方式设置此颜色的值。例如，您可以使用`"rgb(255,0,0)"`，`"#ff0000"`，`"#f00"`，甚至`"red"`。
    |'
- en: '| `copy(color)` | Copy the color values from the `THREE.Color` instance provided
    to this color. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `copy(color)` | 将提供的`THREE.Color`实例的颜色值复制到此颜色。 |'
- en: '| `copyGammaToLinear(color)` | This is mostly used internally.Set the color
    of this object based on the `THREE.Color` instance supplied. The color is first
    converted from the gamma color space to the linear color space. The gamma color
    space also uses RGB values, but uses an exponential scale instead of a linear
    one. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `copyGammaToLinear(color)` | 这主要是在内部使用。根据提供的`THREE.Color`实例设置此对象的颜色。首先将颜色从伽马颜色空间转换为线性颜色空间。伽马颜色空间也使用RGB值，但使用的是指数比例而不是线性比例。
    |'
- en: '| `copyLinearToGamma(color)` | This is mostly used internally.Set the color
    of this object based on the `THREE.Color` instance supplied. The color is first
    converted from the linear color space to the gamma color space. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `copyLinearToGamma(color)` | 这主要是在内部使用。根据提供的`THREE.Color`实例设置此对象的颜色。首先将颜色从线性颜色空间转换为伽马颜色空间。
    |'
- en: '| `convertGammaToLinear()` | This converts the current color from the gamma
    color space to the linear color space. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `convertGammaToLinear()` | 将当前颜色从伽马颜色空间转换为线性颜色空间。 |'
- en: '| `convertLinearToGamma()` | This converts the current color from the linear
    color space to the gamma color space. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `convertLinearToGamma()` | 将当前颜色从线性颜色空间转换为伽马颜色空间。 |'
- en: '| `getHex()` | Return the value from this color object as a number: `435241`.
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `getHex()` | 以数字形式返回此颜色对象的值：`435241`。 |'
- en: '| `getHexString()` | Return the value from this color object as a hex string:
    `"0c0c0c"`. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `getHexString()` | 以十六进制字符串形式返回此颜色对象的值：`"0c0c0c"`。 |'
- en: '| `getStyle()` | Return the value from this color object as a CSS-based value:
    `"rgb(112,0,0)"`. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `getStyle()` | 以基于CSS的值返回此颜色对象的值：`"rgb(112,0,0)"`。 |'
- en: '| `getHSL(optionalTarget)` | Return the value from this color object as a HSL
    value. If you provide the `optionalTarget` object, Three.js will set the `h`,
    `s`, and `l` properties on that object. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `getHSL(optionalTarget)` | 以HSL值的形式返回此颜色对象的值。如果提供`optionalTarget`对象，Three.js将在该对象上设置`h`、`s`和`l`属性。
    |'
- en: '| `offsetHSL(h, s, l)` | Add the `h`, `s`, and `l` values provided to the `h`,
    `s`, and `l` values of the current color. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `offsetHSL(h, s, l)` | 将提供的`h`、`s`和`l`值添加到当前颜色的`h`、`s`和`l`值中。 |'
- en: '| `add(color)` | This adds the `r`, `g`, and `b` values of the color supplied
    to the current color. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `add(color)` | 将提供的颜色的`r`、`g`和`b`值添加到当前颜色。 |'
- en: '| `addColors(color1, color2)` | This is mostly used internally.Add `color1`
    and `color2`, and set the value of the current color to the result. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `addColors(color1, color2)` | 这主要是在内部使用。添加`color1`和`color2`，并将当前颜色的值设置为结果。
    |'
- en: '| `addScalar(s)` | This is mostly used internally.Add a value to the RGB components
    of the current color. Bear in mind that the internal values use a range from 0
    to 1. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `addScalar(s)` | 这主要是在内部使用。将一个值添加到当前颜色的RGB分量中。请记住，内部值使用0到1的范围。 |'
- en: '| `multiply(color)` | This is mostly used internally.Multiply the current RGB
    values with the RGB values from `THREE.Color`. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `multiply(color)` | 这主要是在内部使用。将当前RGB值与`THREE.Color`的RGB值相乘。 |'
- en: '| `multiplyScalar(s)` | This is mostly used internally.This multiplies the
    current RGB values with the value supplied. Bear in mind that the internal values
    use a range from 0 to 1. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `multiplyScalar(s)` | 这主要是在内部使用。将当前RGB值与提供的值相乘。请记住，内部值使用0到1的范围。 |'
- en: '| `lerp(color, alpha)` | This is mostly used internally.This finds the color
    that is between the color of this object and the color supplied. The alpha property
    defines how far between the current color and the supplied color you want the
    result to be. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `lerp(color, alpha)` | 这主要是在内部使用。找到介于此对象颜色和提供的颜色之间的颜色。alpha属性定义了你希望结果在当前颜色和提供的颜色之间的距离。
    |'
- en: '| `equals(color)` | This returns `true` if the RGB values of the `THREE.Color`
    instance supplied match the values of the current color. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `equals(color)` | 如果提供的`THREE.Color`实例的RGB值与当前颜色的值匹配，则返回`true`。 |'
- en: '| `fromArray(array)` | This has the same functionality as `setRGB`, but now
    the RGB values can be provided as an array of numbers. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `fromArray(array)` | 这与`setRGB`具有相同的功能，但现在RGB值可以作为数字数组提供。 |'
- en: '| `toArray` | This returns an array with three elements, `[r, g, b]`. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `toArray` | 这将返回一个包含三个元素的数组，`[r, g, b]`。 |'
- en: '| `clone()` | This creates an exact copy of this color. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `clone()` | 这将创建这种颜色的精确副本。 |'
- en: In this table, you can see that there are many ways in which you can change
    the current color. A lot of these functions are used internally by Three.js, but
    they also provide a good way to easily change the color of lights and materials.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，你可以看到有很多种方法可以改变当前的颜色。很多这些函数在Three.js内部被使用，但它们也提供了一个很好的方式来轻松改变光和材质的颜色。
- en: 'Before we move on to the discussion on `THREE.PointLight`, `THREE.SpotLight`,
    and `THREE.DirectionalLight`, let''s first highlight their main difference, that
    is, how they emit light. The following diagram shows how these three light sources
    emit light:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论`THREE.PointLight`，`THREE.SpotLight`和`THREE.DirectionalLight`之前，让我们首先强调它们的主要区别，即它们如何发光。以下图表显示了这三种光源是如何发光的：
- en: '![Using the THREE.Color object](graphics/2215OS_03_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用THREE.Color对象](graphics/2215OS_03_03.jpg)'
- en: 'You can see the following from this diagram:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这个图表中看到以下内容：
- en: '`THREE.PointLight` emits light from a specific point in all directions'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.PointLight`从一个特定点向所有方向发光'
- en: '`THREE.SpotLight` emits light from a specific point in a cone-like shape'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.SpotLight`从一个特定点发射出锥形的光'
- en: '`THREE.DirectionalLight` doesn''t emit light from a single point, but emits
    light rays from a 2D plane, where the rays are parallel to each other'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.DirectionalLight`不是从单一点发光，而是从一个二维平面发射光线，光线是平行的'
- en: We'll look at these light sources in more detail in the next couple of paragraphs;
    let's start with `THREE.Pointlight`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几段中更详细地看这些光源；让我们从`THREE.Pointlight`开始。
- en: THREE.PointLight
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.PointLight
- en: '`THREE.PointLight` in Three.js is a light source that shines light in all directions
    emanating from a single point. A good example of a point light is a signal flare
    fired in the night sky. Just as with all the lights, we have a specific example
    you can use to play around with `THREE.PointLight`. If you look at `02-point-light.html`
    in the `chapter-03` folder, you can find an example where a `THREE.PointLight`
    light is moving around a simple Three.js scene. The following screenshot shows
    an example of this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中，`THREE.PointLight`是一个从单一点发出的照射所有方向的光源。一个很好的例子是夜空中发射的信号弹。就像所有的光源一样，我们有一个具体的例子可以用来玩`THREE.PointLight`。如果你在`chapter-03`文件夹中查看`02-point-light.html`，你可以找到一个例子，其中`THREE.PointLight`在一个简单的Three.js场景中移动。以下截图显示了这个例子：
- en: '![THREE.PointLight](graphics/2215OS_03_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.PointLight](graphics/2215OS_03_04.jpg)'
- en: In this example, `THREE.PointLight` moves around the scene we already saw in
    [Chapter 1](ch01.html "Chapter 1. Creating Your First 3D Scene with Three.js"),
    *Create Your First 3D Scene with Three.js*. To make it more clear where `THREE.PointLight`
    is, we move a small orange sphere along the same path. As this light moves around,
    you'll see the red cube and blue sphere being illuminated by this light on different
    sides.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`THREE.PointLight`在我们已经在[第1章](ch01.html "第1章。使用Three.js创建你的第一个3D场景")中看到的场景中移动，*使用Three.js创建你的第一个3D场景*。为了更清楚地看到`THREE.PointLight`在哪里，我们沿着相同的路径移动一个小橙色的球体。当这个光源移动时，你会看到红色的立方体和蓝色的球体在不同的侧面被这个光源照亮。
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You might notice that we don't see any shadows in this example. In Three.js,
    `THREE.PointLight` doesn't cast shadows. Since `THREE.PointLight` emits light
    in all directions, calculating shadows is a very heavy process for the GPU.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到在这个例子中我们没有看到任何阴影。在Three.js中，`THREE.PointLight`不会投射阴影。由于`THREE.PointLight`向所有方向发光，计算阴影对于GPU来说是一个非常繁重的过程。
- en: 'With the `THREE.AmbientLight` we saw earlier, all you had to do was provide
    `THREE.Color` and add the light to the scene. With `THREE.PointLight`, however,
    we have a couple of additional configuration options:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的`THREE.AmbientLight`不同，你只需要提供`THREE.Color`并将光源添加到场景中。然而，对于`THREE.PointLight`，我们有一些额外的配置选项：
- en: '| Property | Description |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `color` | This is the color of the light. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 这是光的颜色。 |'
- en: '| `distance` | This is the distance for which the light shines. The default
    value is `0`, which means that the light''s intensity doesn''t decrease based
    on distance. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `distance` | 这是光照射的距离。默认值为`0`，这意味着光的强度不会根据距离而减少。 |'
- en: '| `intensity` | This is the intensity the light shines with. This defaults
    to `1`. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `intensity` | 这是光的强度。默认值为`1`。 |'
- en: '| `position` | This is the position of the light in `THREE.Scene`. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `position` | 这是`THREE.Scene`中光的位置。 |'
- en: '| `visible` | If this property is set to `true` (the default), this light is
    turned on, and if set it to `false`, the light is turned off. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `visible` | 如果将此属性设置为`true`（默认值），则此光源将打开，如果设置为`false`，则光源将关闭。 |'
- en: 'In the next couple of examples and screenshots, we''ll explain these properties.
    First, let''s look at how you can create `THREE.PointLight`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个例子和截图中，我们将解释这些属性。首先，让我们看看如何创建`THREE.PointLight`：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We create a light with a specific `color` property (here we use a string value;
    we could have also used a number or `THREE.Color`), set its `position` property,
    and add it to the scene.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个具有特定`color`属性的光（这里我们使用了一个字符串值；我们也可以使用一个数字或`THREE.Color`），设置了它的`position`属性，并将其添加到场景中。
- en: 'The first property we''ll look at is `intensity`. With this property, you can
    set how brightly the light shines. If you set this to `0`, you won''t see anything;
    set it to `1`, and you''ve got the default brightness; set it to `2`, and you
    get a light that shines twice as bright; and so on. In the following screenshot,
    for instance, we set the intensity of the light to `2.4`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要看的属性是 `intensity`。通过这个属性，你可以设置光的亮度。如果你将其设置为 `0`，你将看不到任何东西；将其设置为 `1`，你将得到默认的亮度；将其设置为
    `2`，你将得到两倍亮度的光；依此类推。例如，在下面的截图中，我们将光的强度设置为 `2.4`：
- en: '![THREE.PointLight](graphics/2215OS_03_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.PointLight](graphics/2215OS_03_05.jpg)'
- en: 'All you have to do to change the intensity of the light is use the intensity
    property of `THREE.PointLight`, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变光的强度，你只需要使用 `THREE.PointLight` 的 `intensity` 属性，如下所示：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or you can use the dat.GUI listener, like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用 dat.GUI 监听器，像这样：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `distance` property of `PointLight` is a very interesting one and is best
    explained with an example. In the following screenshot, you see the same scene
    again, but this time with a very high `intensity` property (we have a very bright
    light), but with a small `distance`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`PointLight` 的 `distance` 属性非常有趣，最好通过一个例子来解释。在下面的截图中，你会看到同样的场景，但这次是一个非常高的 `intensity`
    属性（我们有一个非常明亮的光），但是有一个很小的 `distance`：'
- en: '![THREE.PointLight](graphics/2215OS_03_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.PointLight](graphics/2215OS_03_06.jpg)'
- en: 'The `distance` property of `SpotLight` determines how far the light travels
    from the source before its intensity property is 0\. You can set this property
    like this: `pointLight.distance = 14`. In the preceding screenshot, the light''s
    brightness slowly decreases to `0` at a distance of `14`. That''s why, in the
    example, you can still see a brightly lit cube, but the light won''t reach the
    blue sphere. The default value for the `distance` property is `0`, which means
    that the light won''t decay over a distance.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpotLight` 的 `distance` 属性确定了光从光源传播到其强度属性为 0 的距离。你可以像这样设置这个属性：`pointLight.distance
    = 14`。在前面的截图中，光的亮度在距离为 `14` 时慢慢减弱到 `0`。这就是为什么在例子中，你仍然可以看到一个明亮的立方体，但光无法到达蓝色的球体。`distance`
    属性的默认值是 `0`，这意味着光不会随着距离的增加而减弱。'
- en: THREE.SpotLight
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.SpotLight
- en: '`THREE.SpotLight` is one of the lights you''ll use most often (especially if
    you want to use shadows). `THREE.SpotLight` is a light source that has a cone-like
    effect. You can compare this with a flashlight or a lantern. This light has a
    direction and an angle at which it produces light. The following table lists all
    the properties that apply to `THREE.SpotLight`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.SpotLight` 是你经常会使用的灯光之一（特别是如果你想要使用阴影）。`THREE.SpotLight` 是一个具有锥形效果的光源。你可以把它比作手电筒或灯笼。这种光源有一个方向和一个产生光的角度。以下表格列出了适用于
    `THREE.SpotLight` 的所有属性：'
- en: '| Property | Description |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `angle` | This determines how wide the beam emerging from this light is.
    This is measured in radians and defaults to `Math.PI/3`. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '`angle` | 这决定了从这个光源发出的光束有多宽。这是用弧度来衡量的，默认值为 `Math.PI/3`。'
- en: '| `castShadow` | If set to `true`, this light will cast shadows. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `castShadow` | 如果设置为 `true`，这个光将投射阴影。'
- en: '| `color` | This is the color of the light. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 这是光的颜色。 |'
- en: '| `distance` | This is the distance up to which the light shines. The default
    value is `0`, which means that the light''s intensity doesn''t decrease based
    on distance. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `distance` | 这是光照的距离。默认值为 `0`，这意味着光的强度不会根据距离而减弱。 |'
- en: '| `exponent` | With `THREE.SpotLight`, the emitted light''s intensity decreases
    the further away you are from the source. The `exponent` property determines how
    quickly this intensity decreases. With a low value, the light emitted from this
    source will reach faraway objects, while with a high value, it will only reach
    objects that are very near to `THREE.SpotLight`. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `exponent` | 对于 `THREE.SpotLight`，从光源越远，发出的光的强度就会减弱。`exponent` 属性确定了这种强度减弱的速度。值越低，从这个光源发出的光就会到达更远的物体，而值越高，它只会到达非常接近
    `THREE.SpotLight` 的物体。'
- en: '| `intensity` | This is the intensity the light shines with. This defaults
    to 1. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `intensity` | 这是光的强度。默认值为 1。'
- en: '| `onlyShadow` | If this property is set to `true`, this light will only cast
    a shadow and won''t add any light to the scene. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `onlyShadow` | 如果将此属性设置为 `true`，这个光将只投射阴影，不会为场景增加任何光。'
- en: '| `position` | This is the position of the light in `THREE.Scene`. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `position` | 这是光在 `THREE.Scene` 中的位置。'
- en: '| `shadowBias` | The shadow bias moves the cast shadow away or towards the
    object casting the shadow. You can use this to solve some strange effects when
    you work with very thin objects (a good example can be found at [http://www.3dbuzz.com/training/view/unity-fundamentals/lights/8-shadows-bias](http://www.3dbuzz.com/training/view/unity-fundamentals/lights/8-shadows-bias)).
    If you see strange shadow effects, small values (for example, `0.01`) for this
    property can often resolve the issue. The default value for this property is `0`.
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `shadowBias` | 阴影偏移将投射的阴影远离或靠近投射阴影的物体。你可以使用这个来解决一些在处理非常薄的物体时出现的奇怪效果（一个很好的例子可以在
    [http://www.3dbuzz.com/training/view/unity-fundamentals/lights/8-shadows-bias](http://www.3dbuzz.com/training/view/unity-fundamentals/lights/8-shadows-bias)
    找到）。如果你看到奇怪的阴影效果，这个属性的小值（例如 `0.01`）通常可以解决问题。这个属性的默认值是 `0`。'
- en: '| `shadowCameraFar` | This determines what distance from the light shadows
    should be created. The default value is `5,000`. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `shadowCameraFar` | 这确定了从光源创建阴影的距离。默认值为 `5,000`。'
- en: '| `shadowCameraFov` | This determines how large the field of view used to create
    shadows is (see the *Different cameras for different uses* section in [Chapter
    2](ch02.html "Chapter 2. Basic Components That Make Up a Three.js Scene"), *Basic
    Components That Make Up a Three.js Scene*). The default value is `50`. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `shadowCameraFov` | 这确定了用于创建阴影的视场有多大（参见[第 2 章](ch02.html "第 2 章. 三.js 场景的基本组件")中的
    *不同用途的不同相机* 部分，*三.js 场景的基本组件*）。默认值为 `50`。'
- en: '| `shadowCameraNear` | This determines what distance from the light shadows
    should be created. The default value is `50`. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `shadowCameraNear` | 这决定了从光源到阴影应该创建的距离。默认值为`50`。|'
- en: '| `shadowCameraVisible` | If this is set to `true`, you can see how and where
    this light source casts a shadow (see the example in the next section). The default
    value is `false`. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `shadowCameraVisible` | 如果设置为`true`，您可以看到这个光源是如何投射阴影的（请参见下一节的示例）。默认值为`false`。|'
- en: '| `shadowDarkness` | This defines how dark the shadow is rendered. This can''t
    be changed after the scene is rendered. The default value is `0.5`. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `shadowDarkness` | 这定义了阴影的深度。这在场景渲染后无法更改。默认值为`0.5`。|'
- en: '| `shadowMapWidth` and `shadowMapHeight` | This determines how many pixels
    are used to create the shadow. Increase this when the shadow has jagged edges
    or doesn''t look smooth. This can''t be changed after the scene is rendered. The
    default value for both is `512`. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `shadowMapWidth`和`shadowMapHeight` | 这决定了用多少像素来创建阴影。当阴影边缘有锯齿状或看起来不平滑时，增加这个值。这在场景渲染后无法更改。两者的默认值都是`512`。|'
- en: '| `target` | With `THREE.SpotLight`, the direction it is pointed in is important.
    With the `target` property, you can point `THREE.SpotLight` to look at a specific
    object or position in the scene. Note that this property requires a `THREE.Object3D`
    object (like `THREE.Mesh`). This is in contrast to the cameras we saw in the previous
    chapter that use `THREE.Vector3` in their `lookAt` function. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `target` | 对于`THREE.SpotLight`，它指向的方向很重要。使用`target`属性，您可以指定`THREE.SpotLight`瞄准场景中的特定对象或位置。请注意，此属性需要一个`THREE.Object3D`对象（如`THREE.Mesh`）。这与我们在上一章中看到的相机不同，相机在其`lookAt`函数中使用`THREE.Vector3`。|'
- en: '| `visible` | If this is set to `true` (the default), this light is turned
    on, and if this is set to `false`, the light is turned off. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `visible` | 如果设置为`true`（默认值），则此光源打开，如果设置为`false`，则关闭。|'
- en: 'Creating `THREE.SpotLight` is very easy. Just specify the color, set the properties
    you want, and add it to the scene, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`THREE.SpotLight`非常简单。只需指定颜色，设置您想要的属性，并将其添加到场景中，如下所示：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`THREE.SpotLight` is not very different from `THREE.PointLight`. The only difference
    is that we set the `castShadow` property to `true` because we want shadows, and
    we need to set the `target` property for this `SpotLight`. The `target` property
    determines where the light is aimed at. In this case, we point it at the object
    named `plane`. When you run the example (`03-spot-light.html`), you''ll see a
    scene like the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.SpotLight`与`THREE.PointLight`并没有太大的区别。唯一的区别是我们将`castShadow`属性设置为`true`，因为我们想要阴影，并且我们需要为这个`SpotLight`设置`target`属性。`target`属性确定了光的瞄准位置。在这种情况下，我们将其指向了名为`plane`的对象。当您运行示例（`03-spot-light.html`）时，您将看到如下截图所示的场景：'
- en: '![THREE.SpotLight](graphics/2215OS_03_07.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.SpotLight](graphics/2215OS_03_07.jpg)'
- en: 'In this example, you can set a number of properties specific to `THREE.SpotLight`.
    One of them is the `target` property. If we set this property to the blue sphere,
    the light will focus at the center of the sphere even if it moves around the scene.
    When we created the light, we aimed it at the ground plane, and in our example,
    we can also aim it at the other two objects. But what if you don''t want to aim
    the light at a specific object, but rather at an arbitrary point in space? You
    can do that by creating a `THREE.Object3D()` object like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您可以设置一些特定于`THREE.SpotLight`的属性。其中之一是`target`属性。如果我们将此属性设置为蓝色的球体，光将聚焦在球体的中心，即使它在场景中移动。当我们创建光时，我们将其瞄准地面平面，在我们的示例中，我们也可以将其瞄准其他两个对象。但是，如果您不想将光瞄准到特定对象，而是瞄准到空间中的任意点，您可以通过创建一个`THREE.Object3D()`对象来实现：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, set the target property of `THREE.SpotLight`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，设置`THREE.SpotLight`的`target`属性：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the table at the beginning of this section, we showed a couple of properties
    that can be used to control how the light emanates from `THREE.SpotLight`. The
    `distance` and `angle` properties define the shape of the cone of light. The `angle`
    property defines the width of the cone, and with the `distance` property, we set
    the length of the cone. The following figure explains how these two values together
    define the area that will receive light from `THREE.SpotLight`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节开始时的表格中，我们展示了一些可以用来控制`THREE.SpotLight`发出光线的属性。`distance`和`angle`属性定义了光锥的形状。`angle`属性定义了光锥的宽度，而`distance`属性则设置了光锥的长度。下图解释了这两个值如何共同定义将从`THREE.SpotLight`接收光线的区域。
- en: '![THREE.SpotLight](graphics/2215OS_03_08.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.SpotLight](graphics/2215OS_03_08.jpg)'
- en: 'Usually, you won''t really need to set these values since they come with reasonable
    defaults, but you can use these properties, for instance, to create a `THREE.SpotLight`
    that has a very narrow beam or quickly decreases in light intensity. The last
    property you can use to change the way `THREE.SpotLight` produces light is the
    `exponent` property. With this property, you set how fast the light intensity
    decreases from the center of the light cone towards the edges of the cone. In
    the following image, you can see the result of the `exponent` property in action.
    We have a very bright light (high `intensity`) that rapidly decreases in intensity
    (high `exponent`) as it moves from the center towards the sides of the cone:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您不需要设置这些值，因为它们已经有合理的默认值，但是您可以使用这些属性，例如，创建一个具有非常窄的光束或快速减少光强度的`THREE.SpotLight`。您可以使用最后一个属性来改变`THREE.SpotLight`产生光线的方式，即`exponent`属性。使用这个属性，您可以设置光强度从光锥的中心向边缘迅速减少的速度。在下面的图像中，您可以看到`exponent`属性的效果。我们有一个非常明亮的光（高`intensity`），随着它从中心向锥体的边缘移动，光强度迅速减弱（高`exponent`）：
- en: '![THREE.SpotLight](graphics/2215OS_03_09.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.SpotLight](graphics/2215OS_03_09.jpg)'
- en: You could use this to highlight a specific object or simulate a small flashlight.
    We could also have created the same focused beam effect using a small `exponent`
    value and `angle`. On a cautionary note on this second approach, remember that
    a very small angle can quickly lead to all kinds of rendering artifacts (an artifact
    is a term used in graphics for unwanted distortions and strangely rendered parts
    of the screen).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此功能来突出显示特定对象或模拟小手电筒。我们还可以使用小的`exponent`值和`angle`创建相同的聚焦光束效果。在对这种第二种方法进行谨慎说明时，请记住，非常小的角度可能会很快导致各种渲染伪影（伪影是图形中用于不需要的失真和奇怪渲染部分的术语）。
- en: 'Before moving on to the next light, we''ll quickly look at the shadow-related
    properties available to `THREE.SpotLight`. You''ve already learned that we can
    get shadows by setting the `castShadow` property of `THREE.SpotLight` to `true`
    (and, of course, making sure that we set the `castShadow` property for objects
    that should cast shadows, and that we cast the `receiveShadow` property, for objects
    that should show a shadow, on the `THREE.Mesh` objects in our scene). Three.js
    also allows you very fine-grained control on how the shadow is rendered. This
    is done by a couple of properties we explained in the table at the beginning of
    the section. With `shadowCameraNear`, `shadowCameraFar`, and `shadowCameraFov`,
    you can control how and where this light casts a shadow. This works in the same
    way as the perspective camera''s field of view we explained in the preceding chapter.
    The easiest way to see this in action is by setting `shadowCameraVisible` to `true`;
    you can do this by checking the menu''s debug checkbox. This shows, as you can
    see in the following screenshot, the area that is used to determine the shadows
    for this light:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一个光源之前，我们将快速查看`THREE.SpotLight`可用的与阴影相关的属性。您已经学会了通过将`THREE.SpotLight`的`castShadow`属性设置为`true`来获得阴影（当然，还要确保我们为应该投射阴影的对象设置`castShadow`属性，并且在我们场景中的`THREE.Mesh`对象上设置`receiveShadow`属性，以显示阴影）。Three.js还允许您对阴影的渲染进行非常精细的控制。这是通过我们在本节开头的表中解释的一些属性完成的。通过`shadowCameraNear`、`shadowCameraFar`和`shadowCameraFov`，您可以控制这种光如何在何处投射阴影。这与我们在前一章中解释的透视相机的视野工作方式相同。查看此操作的最简单方法是将`shadowCameraVisible`设置为`true`；您可以通过选中菜单中的调试复选框来执行此操作。如下截图所示，这显示了用于确定此光的阴影的区域：
- en: '![THREE.SpotLight](graphics/2215OS_03_10.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.SpotLight](graphics/2215OS_03_10.jpg)'
- en: 'I''ll end this section with a couple of pointers, just in case you run into
    issues with shadows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，我将给出一些建议，以防您在阴影方面遇到问题：
- en: Enable the `shadowCameraVisible` property. This shows the area that is affected
    by this light for shadow purposes.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用`shadowCameraVisible`属性。这显示了受此光影响的阴影区域。
- en: If the shadow looks blocky, you can either increase the `shadowMapWidth` and
    `shadowMapHeight` properties or make sure the area that is used to calculate the
    shadow tightly wraps your object. You can use the `shadowCameraNear`, `shadowCameraFar`,
    and `shadowCameraFov` properties to configure this area.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果阴影看起来很块状，您可以增加`shadowMapWidth`和`shadowMapHeight`属性，或者确保用于计算阴影的区域紧密包裹您的对象。您可以使用`shadowCameraNear`、`shadowCameraFar`和`shadowCameraFov`属性来配置此区域。
- en: Remember that you not only have to tell the light to cast shadows, but also
    have to tell each geometry whether it will receive and/or cast shadows by setting
    the `castShadow` and `receiveShadow` properties.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，您不仅需要告诉光源投射阴影，还需要通过设置`castShadow`和`receiveShadow`属性告诉每个几何体是否会接收和/或投射阴影。
- en: If you use thin objects in your scene, you might see strange artifacts when
    you render shadows. You can use the `shadowBias` property to slightly offset the
    shadows, which will often fix these kinds of issues.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在场景中使用薄物体，渲染阴影时可能会出现奇怪的伪影。您可以使用`shadowBias`属性轻微偏移阴影，这通常可以解决这类问题。
- en: You can change the darkness of the shadow cast by setting the `shadowDarkness`
    property. If your shadows are too dark or not dark enough, changing this property
    allows you to fine-tune how the shadows are rendered.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过设置`shadowDarkness`属性来改变阴影的深浅。如果您的阴影太暗或不够暗，更改此属性可以让您微调阴影的渲染方式。
- en: If you want to have softer shadows, you can set a different `shadowMapType value`
    on `THREE.WebGLRenderer`. By default, this property is set to `THREE.PCFShadowMap`;
    if you set this property to `PCFSoftShadowMap`, you get softer shadows.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想要更柔和的阴影，可以在`THREE.WebGLRenderer`上设置不同的`shadowMapType`值。默认情况下，此属性设置为`THREE.PCFShadowMap`；如果将此属性设置为`PCFSoftShadowMap`，则可以获得更柔和的阴影。
- en: THREE.DirectionalLight
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.DirectionalLight
- en: The last of the basic lights we will look at is `THREE.DirectionalLight`. This
    type of light can be considered as a light that is very far away. All the light
    rays it sends out are parallel to each other. A good example of this is the sun.
    The sun is so far away that the light rays we receive on earth are (almost) parallel
    to each other. The main difference between `THREE.DirectionalLight` and `THREE.SpotLight`
    (which we saw in the previous section) is that this light won't diminish the farther
    it gets from the target of `THREE.DirectionalLight` as it does with `THREE.SpotLight`
    (you can fine-tune this with the `distance` and `exponent` parameters). The complete
    area that is lit by `THREE.DirectionalLight` receives the same intensity of light.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.DirectionalLight`是我们将要看的基本灯光中的最后一个。这种类型的光可以被认为是非常遥远的光。它发出的所有光线都是平行的。一个很好的例子是太阳。太阳离我们如此遥远，以至于我们在地球上接收到的光线（几乎）是平行的。`THREE.DirectionalLight`和我们在上一节中看到的`THREE.SpotLight`之间的主要区别是，这种光不会像`THREE.SpotLight`那样随着距离`THREE.DirectionalLight`的目标越来越远而减弱（您可以使用`distance`和`exponent`参数来微调这一点）。`THREE.DirectionalLight`照亮的完整区域接收到相同强度的光。'
- en: 'To see this in action, look at the `04-directional-light` example, which is
    shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此操作，请查看此处显示的`04-directional-light`示例：
- en: '![THREE.DirectionalLight](graphics/2215OS_03_11.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.DirectionalLight](graphics/2215OS_03_11.jpg)'
- en: As you can see in the preceding image, there isn't a cone of light that is applied
    to the scene. Everything receives the same amount of light. Only the direction,
    the color, and the intensity of the light is used to calculate the colors and
    shadows.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上面的图像中所看到的，没有一个光锥应用到了场景中。一切都接收到了相同数量的光。只有光的方向、颜色和强度被用来计算颜色和阴影。
- en: 'Just as with `THREE.SpotLight`, there are a couple of properties you can set
    that control the intensity of the light and the way it casts shadows. `THREE.DirectionalLight`
    has a lot of properties that are the same as those of `THREE.SpotLight`: `position`,
    `target`, `intensity`, `distance`, `castShadow`, `onlyShadow`, `shadowCameraNear`,
    `shadowCameraFar`, `shadowDarkness`, `shadowCameraVisible`, `shadowMapWidth`,
    `shadowMapHeight`, and `shadowBias`. For information on those properties, you
    can look at the preceding section on `THREE.SpotLight`. The few additional properties
    are discussed in the next couple of paragraphs.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`THREE.SpotLight`一样，你可以设置一些控制光强度和投射阴影方式的属性。`THREE.DirectionalLight`有很多与`THREE.SpotLight`相同的属性：`position`、`target`、`intensity`、`distance`、`castShadow`、`onlyShadow`、`shadowCameraNear`、`shadowCameraFar`、`shadowDarkness`、`shadowCameraVisible`、`shadowMapWidth`、`shadowMapHeight`和`shadowBias`。关于这些属性的信息，你可以查看前面关于`THREE.SpotLight`的部分。接下来的几段将讨论一些额外的属性。
- en: 'If you look back at the `THREE.SpotLight` examples, you can see that we had
    to define the cone of light where shadows were applied. Since, for `THREE.DirectionalLight`,
    all the rays are parallel to each other, we don''t have a cone of light, instead,
    we have a cuboid area, as you can see in the following screenshot (if you want
    to see this for yourself, move the camera further away from the scene):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下`THREE.SpotLight`的例子，你会发现我们必须定义光锥，阴影应用的范围。因为对于`THREE.DirectionalLight`，所有的光线都是平行的，我们没有光锥，而是一个长方体区域，就像你在下面的截图中看到的一样（如果你想亲自看到这个，请将摄像机远离场景）：
- en: '![THREE.DirectionalLight](graphics/2215OS_03_12.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.DirectionalLight](graphics/2215OS_03_12.jpg)'
- en: 'Everything that falls within this cube can cast and receive shadows from the
    light. Just as for `THREE.SpotLight`, the tighter you define this area around
    the objects, the better your shadows will look. Define this cube using the following
    properties:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 落入这个立方体范围内的一切都可以从光中投射和接收阴影。就像对于`THREE.SpotLight`一样，你定义这个范围越紧密，你的阴影看起来就越好。使用以下属性定义这个立方体：
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can compare this with the way we configured the orthographic camera in the
    section on cameras in [Chapter 2](ch02.html "Chapter 2. Basic Components That
    Make Up a Three.js Scene"), *Basic Components That Make Up a Three.js Scene*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这与我们在[第2章](ch02.html "第2章.构成Three.js场景的基本组件")中关于摄像机的部分中配置正交相机的方式进行比较。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is one property that is available to `THREE.DirectionalLight` that we
    haven''t addressed yet: `shadowCascade`. This property can be used to create better
    shadows when you want to use shadows on a large area with `THREE.DirectionalLight`.
    If you set the property to `true`, Three.js will use an alternative approach to
    generate the shadows. It splits the shadow generation up to the value specified
    by `shadowCascadeCount`. This will result in more detailed shadows close to the
    viewpoint of the camera and less detailed shadows far away. To use this, you''ll
    have to experiment with the settings for `shadowCascadeCount`, `shadowCascadeBias`,
    `shadowCascadeWidth`, `shadowCascadeHeight`, `shadowCascadeNearZ`, and `shadowCascadeFarZ`.
    You can find an example where this setup is used at [http://alteredqualia.com/three/examples/webgl_road.html](http://alteredqualia.com/three/examples/webgl_road.html).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`THREE.DirectionalLight`可用的属性我们还没有讨论：`shadowCascade`。当你想在`THREE.DirectionalLight`上使用阴影时，这个属性可以用来创建更好的阴影。如果你将属性设置为`true`，Three.js将使用另一种方法来生成阴影。它将阴影生成分割到由`shadowCascadeCount`指定的值。这将导致在相机视点附近更详细的阴影，而在远处更少详细的阴影。要使用这个功能，你需要尝试不同的设置，如`shadowCascadeCount`、`shadowCascadeBias`、`shadowCascadeWidth`、`shadowCascadeHeight`、`shadowCascadeNearZ`和`shadowCascadeFarZ`。你可以在[http://alteredqualia.com/three/examples/webgl_road.html](http://alteredqualia.com/three/examples/webgl_road.html)找到一个使用了这种设置的示例。
- en: Special lights
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊灯光
- en: In this section on special lights, we'll discuss two additional lights provided
    by Three.js. First, we'll discuss `THREE.HemisphereLight`, which helps in creating
    more natural lighting for outdoor scenes, then we'll look at `THREE.AreaLight`,
    which emits lights from a large area instead of a single point, and finally, we'll
    show you how you can add a lens flare effect to your scene.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特殊灯光的部分，我们将讨论Three.js提供的另外两种灯光。首先，我们将讨论`THREE.HemisphereLight`，它有助于为室外场景创建更自然的光照，然后我们将看看`THREE.AreaLight`，它从一个大区域发出光，而不是从一个单一点发出光，最后，我们将向您展示如何在场景中添加镜头眩光效果。
- en: THREE.HemisphereLight
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.HemisphereLight
- en: 'The first special light we''re going to look at is `THREE.HemisphereLight`.
    With `THREE.HemisphereLight`, we can create more natural-looking outdoor lighting.
    Without this light, we could simulate the outdoors by creating `THREE.DirectionalLight`,
    which emulates the sun, and maybe add additional `THREE.AmbientLight` to provide
    some general color to the scene. This, however, won''t look really natural. When
    you''re outdoors, not all the light comes directly from above: much is diffused
    by the atmosphere and reflected by the ground and other objects. `THREE.HemisphereLight`
    in Three.js is created for this scenario. This is an easy way to get more natural-looking
    outdoor lighting. To see an example, look at `05-hemisphere-light.html`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要看的第一个特殊灯光是`THREE.HemisphereLight`。使用`THREE.HemisphereLight`，我们可以创建更自然的室外光照。没有这种光，我们可以通过创建`THREE.DirectionalLight`来模拟室外，它模拟太阳，也许添加额外的`THREE.AmbientLight`来为场景提供一些一般的颜色。然而，这看起来并不真实。当你在室外时，不是所有的光都直接来自上方：大部分是被大气层散射和地面以及其他物体反射的。Three.js中的`THREE.HemisphereLight`就是为这种情况而创建的。这是一个更自然的室外光照的简单方法。要查看一个示例，请看`05-hemisphere-light.html`：
- en: '![THREE.HemisphereLight](graphics/2215OS_03_13.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.HemisphereLight](graphics/2215OS_03_13.jpg)'
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this is the first example that loads additional resources and can't
    run directly from your local filesystem. So if you haven't done so, look at [Chapter
    1](ch01.html "Chapter 1. Creating Your First 3D Scene with Three.js"), *Create
    Your First 3D Scene with Three.js*, to find out how to set up a local web server
    or disable the security settings in your browser to make loading external resources
    work.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是第一个加载额外资源的示例，无法直接从本地文件系统运行。因此，如果您还没有这样做，请查看[第1章](ch01.html "第1章。使用Three.js创建您的第一个3D场景")，“使用Three.js创建您的第一个3D场景”，了解如何设置本地Web服务器或禁用浏览器中的安全设置以使加载外部资源正常工作。
- en: 'In this example, you can turn `THREE.HemisphereLight` on and off and set the
    colors and intensity. Creating a hemisphere light is just as easy as creating
    any of the other lights:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您可以打开和关闭`THREE.HemisphereLight`并设置颜色和强度。创建半球光与创建任何其他光一样简单：
- en: '[PRE8]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You just specify the color that is received from the sky, the color received
    from the ground, and the intensity of these lights. If you want to change these
    values later on, you can access them through the following properties:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需指定从天空接收到的颜色、从地面接收到的颜色以及这些光的强度。如果以后想要更改这些值，可以通过以下属性访问它们：
- en: '| Property | Description |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `groundColor` | This is the color that is emitted from the ground |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `groundColor` | 这是从地面发出的颜色 |'
- en: '| `color` | This is the color that is emitted from the sky |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 这是从天空发出的颜色 |'
- en: '| `intensity` | This is the intensity with which the light shines |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `intensity` | 这是光线照射的强度 |'
- en: THREE.AreaLight
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: THREE.AreaLight
- en: 'The last real light source we''ll look at is `THREE.AreaLight`. With `THREE.AreaLight`,
    we can define a rectangular area that emits light. `THREE.AreaLight` isn''t included
    in the standard Three.js library, but in its extensions, so we have to take a
    couple of additional steps before we can use this light source. Before we look
    at the details, let''s first look at the result we''re aiming for (`06-area-light.html`
    opens this example); the following screenshot encapsulates the result we want
    to see:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的最后一个真实光源是`THREE.AreaLight`。使用`THREE.AreaLight`，我们可以定义一个发光的矩形区域。`THREE.AreaLight`不包含在标准的Three.js库中，而是在其扩展中，因此在使用此光源之前，我们必须采取一些额外的步骤。在查看细节之前，让我们先看一下我们的目标结果（`06-area-light.html`打开此示例）；以下屏幕截图概括了我们想要看到的结果：
- en: '![THREE.AreaLight](graphics/2215OS_03_14.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.AreaLight](graphics/2215OS_03_14.jpg)'
- en: What you see in this screenshot is that we've defined three `THREE.AreaLight`
    objects, each with their own color. You can also see how these lights affect the
    whole area.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕截图中，我们定义了三个`THREE.AreaLight`对象，每个对象都有自己的颜色。您还可以看到这些灯如何影响整个区域。
- en: When we want to use `THREE.AreaLight`, we can't use `THREE.WebGLRenderer`, which
    we used in our examples until now. The reason is that `THREE.AreaLight` is a very
    complex light source that would cause a very serious performance penalty in the
    normal `THREE.WebGLRenderer` object. It uses a different approach when rendering
    a scene (it breaks it up into multiple steps) and can handle complex lights (or
    a very high number of light sources for that matter) much better than the standard
    `THREE.WebGLRenderer` object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要使用`THREE.AreaLight`时，不能使用我们之前示例中使用的`THREE.WebGLRenderer`。原因是`THREE.AreaLight`是一个非常复杂的光源，会导致普通的`THREE.WebGLRenderer`对象严重影响性能。它在渲染场景时使用了不同的方法（将其分解为多个步骤），并且可以比标准的`THREE.WebGLRenderer`对象更好地处理复杂的光（或者说非常多的光源）。
- en: 'To use `THREE.WebGLDeferredRenderer`, we have to include a couple of additional
    JavaScript sources provided by Three.js. In the head of your HTML skeleton, make
    sure you have the following set of `<script>` sources defined:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`THREE.WebGLDeferredRenderer`，我们必须包含Three.js提供的一些额外的JavaScript源。在HTML骨架的头部，确保您定义了以下一组`<script>`源：
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With these libraries included, we can use `THREE.WebGLDeferredRenderer`. We
    can use this renderer in pretty much the same way as the one we discussed in the
    other examples. It just takes a couple of extra arguments:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 包括这些库后，我们可以使用`THREE.WebGLDeferredRenderer`。我们可以以与我们在其他示例中讨论的方式使用此渲染器。只需要一些额外的参数：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Don't worry too much about what all these properties mean at the moment. In
    [Chapter 10](ch10.html "Chapter 10. Loading and Working with Textures"), *Loading
    and Working with Textures*, we'll dive deeper into `THREE.WebGLDeferredRenderer`
    and explain them to you. With the correct JavaScript libraries and a different
    renderer, we can start adding `Three.AreaLight`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不要太担心这些属性的含义。在[第10章](ch10.html "第10章。加载和使用纹理")，“加载和使用纹理”中，我们将深入探讨`THREE.WebGLDeferredRenderer`并向您解释它们。有了正确的JavaScript库和不同的渲染器，我们就可以开始添加`Three.AreaLight`。
- en: 'We do this in pretty much the same way as all the other lights:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎以与所有其他光源相同的方式执行此操作：
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this example, we create a new `THREE.AreaLight`. This light has a color
    value of `0xff0000` and an intensity value of `3`. Just like the other lights,
    we can use the `position` attribute to set its location in the scene. When you
    create `THREE.AreaLight`, it will be created as a horizontal plane. In our example,
    we created three `THREE.AreaLight` objects that are positioned vertically, so
    we need to rotate our lights `-Math.PI/2` around their *x* axis. Finally, we set
    the size of `THREE.AreaLight` using the `width` and `height` properties and add
    them to the scene. If you try this yourself for the first time, you might wonder
    why you don''t see anything where you positioned your light. This is because you
    can''t see the light source itself, only the light it emits, which you only see
    when it touches an object. If you want to recreate what I''ve shown in the example,
    you can add `THREE.PlaneGeometry` or `THREE.BoxGeometry` at the same position
    (`areaLight1.position`) to simulate the area emitting light, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个新的`THREE.AreaLight`。这个光源的颜色值为`0xff0000`，强度值为`3`。和其他光源一样，我们可以使用`position`属性来设置它在场景中的位置。当你创建`THREE.AreaLight`时，它将被创建为一个水平平面。在我们的例子中，我们创建了三个垂直放置的`THREE.AreaLight`对象，所以我们需要围绕它们的*x*轴旋转`-Math.PI/2`。最后，我们使用`width`和`height`属性设置了`THREE.AreaLight`的大小，并将它们添加到了场景中。如果你第一次尝试这样做，你可能会想知道为什么在你放置光源的地方看不到任何东西。这是因为你看不到光源本身，只能看到它发出的光，只有当它接触到物体时才能看到。如果你想重现我在例子中展示的效果，你可以在相同的位置（`areaLight1.position`）添加`THREE.PlaneGeometry`或`THREE.BoxGeometry`来模拟发光的区域，如下所示：
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can create really beautiful effects with `THREE.AreaLight`, but you''ll
    probably have to experiment a bit to get the desired effect. If you pull down
    the control panel from the top-right corner, you''ve got some controls you can
    play around with to set the color and intensity of the three lights from this
    scene and immediately see the effect, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`THREE.AreaLight`创建非常漂亮的效果，但可能需要进行一些实验来获得期望的效果。如果你从右上角拉下控制面板，你可以调整三个灯的颜色和强度，立即看到效果，如下所示：
- en: '![THREE.AreaLight](graphics/2215OS_03_15.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.AreaLight](graphics/2215OS_03_15.jpg)'
- en: LensFlare
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜头耀斑
- en: The last subject we'll explore in this chapter is **lens flares**. You are probably
    already familiar with lens flares. For instance, they appear when you take a photograph
    directly into the sun or another bright light source. In most cases, you want
    to avoid this, but for games and 3D-generated images, it provides a nice effect
    that makes scenes look a bit more realistic.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后要探讨的主题是**镜头耀斑**。你可能已经熟悉镜头耀斑了。例如，当你直接对着太阳或其他强光拍照时，它们会出现。在大多数情况下，你可能会想避免这种情况，但对于游戏和3D生成的图像来说，它提供了一个很好的效果，使场景看起来更加真实。
- en: 'Three.js also has support for lens flares and makes it very easy to add them
    to your scene. In this last section, we''re going to add a lens flare to a scene
    and create the output as you can see in the following screenshot; you can see
    this for yourself by opening `07-lensflares.html`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js也支持镜头耀斑，并且非常容易将它们添加到你的场景中。在最后一节中，我们将向场景添加一个镜头耀斑，并创建输出，你可以通过打开`07-lensflares.html`来看到：
- en: '![LensFlare](graphics/2215OS_03_16.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![LensFlare](graphics/2215OS_03_16.jpg)'
- en: 'We can create a lens flare by instantiating the `THREE.LensFlare` object. The
    first thing we need to do is create this object. `THREE.LensFlare` takes the following
    arguments:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实例化`THREE.LensFlare`对象来创建镜头耀斑。我们需要做的第一件事就是创建这个对象。`THREE.LensFlare`接受以下参数：
- en: '[PRE13]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These arguments are explained in the following table:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数在下表中有解释：
- en: '| Argument | Description |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `texture` | A texture is an image that determines the shape of the flare.
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `texture` | 纹理是决定耀斑形状的图像。 |'
- en: '| `size` | We can specify how large the flare should be. This is the size in
    pixels. If you specify `-1`, the size of the texture itself is used. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `size` | 我们可以指定耀斑的大小。这是以像素为单位的大小。如果指定为`-1`，则使用纹理本身的大小。 |'
- en: '| `distance` | This is the distance from the light source (`0`) to the camera
    (`1`). Use this to position the lens flare in the right position. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `distance` | 这是从光源（`0`）到相机（`1`）的距离。使用这个来将镜头耀斑定位在正确的位置。 |'
- en: '| `blending` | We can specify multiple textures for the flares. The blending
    mode determines how these are blended together. The default to use with `LensFlare`
    is `THREE.AdditiveBlending`. There''s more on blending in the next chapter. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `blending` | 我们可以为耀斑指定多个纹理。混合模式决定了这些纹理如何混合在一起。在`LensFlare`中默认使用的是`THREE.AdditiveBlending`。关于混合的更多内容在下一章中有介绍。
    |'
- en: '| `color` | This is the color of the flare. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 这是耀斑的颜色。 |'
- en: 'Let''s look at the code used to create this object (see `07-lensflares.html`):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看用于创建这个对象的代码（参见`07-lensflares.html`）：
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We first load a texture. For this example, I''ve used the lens flare texture
    provided by the Three.js examples, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先加载一个纹理。在这个例子中，我使用了Three.js示例提供的镜头耀斑纹理，如下所示：
- en: '![LensFlare](graphics/2215OS_03_17.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![LensFlare](graphics/2215OS_03_17.jpg)'
- en: If you compare this image with the screenshot at the beginning of this section,
    you can see that it defines what the lens flare looks like. Next, we define the
    color of the lens flare using `new THREE.Color( 0xffaacc );`, which gives the
    lens flare a red glow. With these two objects, we can create the `THREE.LensFlare`
    object. For this example, we've set the size of the flare to `350` and the distance
    to `0.0` (directly at the light source).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个图像与本节开头的截图进行比较，你会发现它定义了镜头耀斑的外观。接下来，我们使用`new THREE.Color( 0xffaacc );`来定义镜头耀斑的颜色，这会使镜头耀斑呈现红色的光晕。有了这两个对象，我们就可以创建`THREE.LensFlare`对象。在这个例子中，我们将耀斑的大小设置为`350`，距离设置为`0.0`（直接在光源处）。
- en: 'After we''ve created the `LensFlare` object, we position it at the location
    of our light and add it to the scene, which can be seen in the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了`LensFlare`对象之后，我们将它定位在光源的位置并将其添加到场景中，如下截图所示：
- en: '![LensFlare](graphics/2215OS_03_18.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![LensFlare](graphics/2215OS_03_18.jpg)'
- en: 'It already looks nice, but if you compare this with the image from the beginning
    of this chapter you''ll notice that we''re missing the small round artifacts in
    the middle of the page. We create these in pretty much the same way as we did
    the main flare, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经看起来不错，但是如果你把这个与本章开头的图像进行比较，你会注意到我们缺少页面中间的小圆形伪影。我们创建这些伪影的方式与主要的光晕几乎相同，如下所示：
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This time, though, we don''t create a new `THREE.LensFlare`, but use the `add`
    function provided by the `LensFlare` we just created. In this method, we need
    to specify the texture, size, distance, and blending mode, and that''s it. Note
    that the `add` function can take two additional parameters. You can also set the
    `color` and the `opacity` properties of the new flare to `add`. The texture we
    use for these new flares is a very light circle, as shown in the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这一次我们不创建一个新的`THREE.LensFlare`，而是使用刚刚创建的`LensFlare`提供的`add`函数。在这个方法中，我们需要指定纹理、大小、距离和混合模式，就这样。请注意，`add`函数可以接受两个额外的参数。你还可以将新的眩光的`color`和`opacity`属性设置为`add`。我们用于这些新眩光的纹理是一个非常轻的圆形，如下面的截图所示：
- en: '![LensFlare](graphics/2215OS_03_19.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![LensFlare](graphics/2215OS_03_19.jpg)'
- en: If you look at the scene again, you'll see the artifacts appearing at the positions
    you've specified with the `distance` argument.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次观察场景，你会看到伪影出现在你用`distance`参数指定的位置。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a lot of information about the different kinds of
    lights that are available in Three.js. In this chapter, you learned that configuring
    lights, colors, and shadows is not an exact science. To get to the correct result,
    you should experiment with the different settings and use a dat.GUI control to
    fine-tune your configuration. The different lights behave in different manners.
    A `THREE.AmbientLight` color is added to each and every color in the scene and
    is often used to smooth hard colors and shadows. `THREE.PointLight` emits light
    in all directions but can't be used to create shadows. `THREE.SpotLight` is a
    light that resembles a flashlight. It has a conical shape, can be configured to
    fade over distance, and is able to cast shadows. We also looked at `THREE.DirectionalLight`.
    This light can be compared with a faraway light, such as the sun, whose light
    rays travel parallel to each other, the intensity of which doesn't decrease the
    farther away it gets from the configured target. Besides the standard lights,
    we also looked at a couple of more specialized lights. For a more natural outdoor
    effect, you can use `THREE.HemisphereLight`, which takes into account ground and
    sky reflections; `THREE.AreaLight` doesn't shine from a single point, but emits
    light from a large area. We showed you how to add a photographic lens flare with
    the `THREE.LenseFlare object`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了关于Three.js中可用的不同类型的光的大量信息。在本章中，你学到了配置光线、颜色和阴影并不是一门精确的科学。为了得到正确的结果，你应该尝试不同的设置，并使用dat.GUI控件来微调你的配置。不同的光有不同的行为方式。`THREE.AmbientLight`颜色被添加到场景中的每一个颜色中，通常用于平滑硬色和阴影。`THREE.PointLight`在所有方向上发光，但不能用于创建阴影。`THREE.SpotLight`是一种类似手电筒的灯光。它呈圆锥形，可以配置为随距离衰减，并且能够投射阴影。我们还看了`THREE.DirectionalLight`。这种光可以与远处的光进行比较，比如太阳，它的光线是平行的，强度不会随着离配置的目标越远而减弱。除了标准的光，我们还看了一些更专业的光。为了获得更自然的室外效果，你可以使用`THREE.HemisphereLight`，它考虑了地面和天空的反射；`THREE.AreaLight`不是从单一点发光，而是从一个大面积发光。我们向你展示了如何使用`THREE.LensFlare`对象添加摄影镜头眩光。
- en: In the chapters so far, we already introduced a couple of different materials,
    and in this chapter, you saw that not all materials respond in the same manner
    to the available lights. In the next chapter, we'll give an overview of the materials
    that are available in Three.js.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的章节中，我们已经介绍了一些不同的材质，而在本章中，你看到并不是所有的材质对可用的光都有相同的反应。在下一章中，我们将概述Three.js中可用的材质。
