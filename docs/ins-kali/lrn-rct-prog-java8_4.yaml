- en: Chapter 4. Transforming, Filtering, and Accumulating Your Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。转换、过滤和累积您的数据
- en: Now that we have the means for creating `Observable` instances from a wide variety
    of source data, it's time to build programming logic around these instances. We
    will present the basic reactive operators that we'll use to achieve step-by-step
    computations (the reactive way of handling data).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了从各种来源数据创建`Observable`实例的手段，是时候围绕这些实例构建编程逻辑了。我们将介绍基本的响应式操作符，用于逐步计算（处理数据的响应式方式）。
- en: We will begin with transformations, using the famous `flatMap()` and `map()`
    operators, as well as some more less common transforming operators. After that
    we'll learn how to filter our data, using the `filter()` operator, skipping elements,
    receiving only elements at a given position in time. The chapter will also cover
    accumulating data with the `scan` operator. Most of these operators will be presented
    using *marble diagrams*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从转换开始，使用著名的`flatMap()`和`map()`操作符，以及一些不太常见的转换操作符。之后，我们将学习如何使用`filter()`操作符过滤我们的数据，跳过元素，仅在给定时间位置接收元素。本章还将涵盖使用`scan`操作符累积数据。大多数这些操作符将使用*大理石图示*进行演示。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Introduction to marble diagrams and transformations with mapping
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大理石图示和映射转换的介绍
- en: Filtering your data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤您的数据
- en: Accumulating values using the `scan` operator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`scan`操作符累积值
- en: Observable transformations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable转换
- en: We've used the `map()` operator in some of the previous examples. The **higher
    order functions** which transform the incoming values into something else are
    called **transformations**. The higher order functions that can be invoked on
    an `Observable` instance, producing a new `Observable` instance from it, are called
    operators. The **transforming operators** transform the elements emitted from
    the source `Observable` instance in some way.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一些先前的示例中使用了`map()`操作符。将传入的值转换为其他内容的**高阶函数**称为**转换**。可以在`Observable`实例上调用的高阶函数，从中产生新的`Observable`实例的操作符称为操作符。**转换操作符**以某种方式转换从源`Observable`实例发出的元素。
- en: 'In order to understand how the different operators work, we will be using pictures
    called **marble diagrams**. For example, this one describes the `map` operator:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解不同的操作符是如何工作的，我们将使用称为**大理石图示**的图片。例如，这个描述了`map`操作符：
- en: '![Observable transformations](img/4305_04_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Observable转换](img/4305_04_01.jpg)'
- en: The rectangle in the center of the diagram represents the operator (function).
    It transforms its input (circles) into something else (triangles). The arrow above
    the rectangle represents the source `Observable` instance, the colored circles
    on it represent `OnNext` *notifications* emitted in time, and the vertical line
    at the end is the `OnCompleted` *notification*. The arrow below the rectangle
    is the output of the `Observable` instance with its transformed elements.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图示中心的矩形代表操作符（函数）。它将其输入（圆圈）转换为其他东西（三角形）。矩形上方的箭头代表源`Observable`实例，上面的彩色圆圈代表时间发出的`OnNext`
    *通知*，末端的垂直线是`OnCompleted` *通知*。矩形下方的箭头是具有其转换元素的`Observable`实例的输出。
- en: 'So, the `map()` operator does exactly this: it transforms every ''*next*''
    value from the source to something else, defined via the function passed to it.
    Here is a little example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`map()`操作符确切地做到了这一点：它将源的每个'*next*'值转换为通过传递给它的函数定义的其他内容。这里有一个小例子：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first `map()` operator transforms every number emitted from the source to
    itself, multiplied by three. The second `map()` operator transforms every multiplied
    number to a string. The string is '`even`' if the number is even and '`odd`' otherwise.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`map()`操作符将源发出的每个数字转换为它本身乘以三。第二个`map()`操作符将每个乘数转换为一个字符串。如果数字是偶数，则字符串是'`even`'，否则是'`odd`'。
- en: Using the `map()` operator, we can transform each emitted value into a new value.
    There are more powerful transforming operators that look similar to the `map()`
    operator, but have their own usage and purpose. Let's look at them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`map()`操作符，我们可以将每个发出的值转换为一个新值。还有更强大的转换操作符，看起来类似于`map()`操作符，但具有自己的用途和目的。让我们来看看它们。
- en: Transformations with the various flatMap operators
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用各种flatMap操作符进行转换
- en: 'The `flatMap` operator is just like the `map()` operator, but with two differences:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`操作符就像`map()`操作符，但有两个不同之处：'
- en: Instead of receiving a function that transforms a value into an arbitrary type
    of value, the `flatMap` operator's argument always transforms a value or sequence
    of values into the form of an `Observable` instance.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap`操作符的参数不是接收将值转换为任意类型值的函数，而是始终将值或值序列转换为`Observable`实例的形式。'
- en: It merges the values emitted by those resulting `Observable` instances. This
    means that instead of emitting the `Observable` instances as values it emits their
    notifications.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它合并了由这些结果`Observable`实例发出的值。这意味着它不是将`Observable`实例作为值发出，而是发出它们的通知。
- en: 'Here is the marble diagram for it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的大理石图示：
- en: '![Transformations with the various flatMap operators](img/4305_04_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![使用各种flatMap操作符进行转换](img/4305_04_02.jpg)'
- en: As we can see, each value from the source `Observable` instance is turned into
    an `Observable` instance, and in the end, all the values of these *derivative
    Observables* are emitted by the resulting `Observable` instance. Note that the
    resulting `Observable` instance may emit the values of the derivative `Observable`
    instances in an interleaved fashion and even out of order.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，源`Observable`实例的每个值都被转换为一个`Observable`实例，最终，所有这些*派生Observable*的值都由结果`Observable`实例发出。请注意，结果`Observable`实例可能以交错的方式甚至无序地发出派生`Observable`实例的值。
- en: 'The `flatMap` operator is very useful for forking logic. For example, if an
    `Observable` instance represents a file system folder and emits files from it,
    we can turn each file object into an `Observable` instance using the `flatMap`
    operator and apply some operations to these *file observables*. The result will
    be a summary of these operations. Here is an example of reading some files from
    a folder and dumping them into the standard output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`运算符对于分叉逻辑非常有用。例如，如果一个`Observable`实例表示文件系统文件夹并从中发出文件，我们可以使用`flatMap`运算符将每个文件对象转换为一个`Observable`实例，并对这些*文件observables*应用一些操作。结果将是这些操作的摘要。以下是一个从文件夹中读取一些文件并将它们转储到标准输出的示例：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This piece of code introduces two methods for working with folders and files.
    We will take a short look at them and how we''ve used them in this `flatMap` example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码介绍了处理文件夹和文件的两种方法。我们将简要介绍它们以及在这个`flatMap`示例中如何使用它们：
- en: The first method, `listFolder()`, takes a folder in the form of a `Path` variable
    and a `glob` expression. It returns an `Observable` instance representing this
    folder. This `Observable` instance emits all the files in the folder, complying
    the `glob` expression as `Path` objects.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个方法`listFolder()`接受一个`Path`变量形式的文件夹和一个`glob`表达式。它返回一个代表这个文件夹的`Observable`实例。这个`Observable`实例发出符合`glob`表达式的所有文件作为`Path`对象。
- en: The method is implemented using both the `Observable.create()` and `Observable.from()`
    operators. The main idea of this implementation is that if an exception occurs,
    it should be handled and emitted by the resulting `Observable` instance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用了`Observable.create()`和`Observable.from()`运算符。这个实现的主要思想是，如果发生异常，它应该被处理并由生成的`Observable`实例发出。
- en: Note the use of the `Subscriber.add()` operator to add a new `Subscription`
    instance to the subscriber, created using the `Subscriptions.create()` operator.
    This method creates a `Subscription` instance using an action. This action will
    be executed when the `Subscription` instance is *unsubscribed*, which means when
    the `Subscriber` instance is *unsubscribed* in this case. So this is similar to
    putting the closing of the `stream` in the final block.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`Subscriber.add()`运算符将一个新的`Subscription`实例添加到订阅者，使用`Subscriptions.create()`运算符创建。这个方法使用一个动作创建一个`Subscription`实例。当`Subscription`实例被*取消订阅*时，这个动作将被执行，这意味着在这种情况下`Subscriber`实例被*取消订阅*。因此，这类似于将`stream`的关闭放在最终块中。
- en: The other method this example introduces is `Observable<String> from(Path)`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个示例介绍的另一种方法是`Observable<String> from(Path)`。
- en: It reads a file located and passed to the `path` instance line by line and emits
    the lines as `OnNext()` *notifications*. The method uses the `Subscriber.add()`
    operator on a `Subscription` instance for closing the `stream` to the file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它逐行读取位于`path`实例中的文件并将行作为`OnNext()` *通知*发出。该方法在`Subscription`实例上使用`Subscriber.add()`运算符来关闭到文件的`stream`。
- en: The example using `flatMap` creates an `Observable` instance from a folder,
    using the `listFolder()` operator, which emits two `Path` parameters to files.
    Using the `flatMap()` operator for every file, we create an `Observable` instance,
    using the `from(Path)` operator, which emits the file content as lines.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`flatMap`的示例从文件夹创建了一个`Observable`实例，使用`listFolder()`运算符，它发出两个`Path`参数到文件。对于每个文件使用`flatMap()`运算符，我们创建了一个`Observable`实例，使用`from(Path)`运算符，它将文件内容作为行发出。
- en: The result of the preceding chain will be the two file contents, printed on
    the standard output. If we used the `Scheduler` instances (see [Chapter 6](ch06.html
    "Chapter 6. Using Concurrency and Parallelism with Schedulers"), *Using Concurrency
    and Parallelism with Schedulers*) for every *file path Observable*, the content
    would be *scrambled* because the `flatMap` operator interleaves the notifications
    of the `Observable` instances that it merges.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前述链的结果将是两个文件内容，打印在标准输出上。如果我们对每个*文件路径Observable*使用`Scheduler`实例（参见[第6章](ch06.html
    "第6章。使用调度程序进行并发和并行处理"), *使用调度程序进行并发和并行处理*），内容将会*混乱*，因为`flatMap`运算符会交错合并`Observable`实例的通知。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code introducing the `Observable<String> from(final Path path)` method
    can be found at [https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L61](https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L61).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍`Observable<String> from(final Path path)`方法的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L61](https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L61)找到。
- en: The source code containing the `Observable<Path> listFolder(Path dir, String
    glob)` method can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L128](https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L128).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`Observable<Path> listFolder(Path dir, String glob)`方法的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L128](https://github.com/meddle0x53/learning-rxjava/blob/724eadf5b0db988b185f8d86006d772286037625/src/main/java/com/packtpub/reactive/common/CreateObservable.java#L128)上查看/下载。
- en: The example using the `flatMap` operator can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FlatMapAndFiles.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FlatMapAndFiles.java).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`flatMap`运算符的示例可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FlatMapAndFiles.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FlatMapAndFiles.java)上查看/下载。
- en: 'The `flatMap` operator has multiple overloads. For example, there is one that
    takes three functions—one for `OnNext`, one for `OnError`, and one for `OnComleted`.
    It transforms *errors* or *completed* events into `Observable` instances too,
    and if there is an `OnError` or `OnCompleted` event, their `Observable` instance
    transformation is merged in the resulting `Observable` instance, followed by an
    `OnCompleted` *notification*. Here is an example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`操作符有多个重载。例如，有一个接受三个函数的重载——一个用于`OnNext`，一个用于`OnError`，一个用于`OnComleted`。它还将*错误*或*完成*事件转换为`Observable`实例，如果有`OnError`或`OnCompleted`事件，则它们的`Observable`实例转换将合并到生成的`Observable`实例中，然后是一个`OnCompleted`
    *通知*。这是一个例子：'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output of that will be `-2(2/-1)` and `0` (because of the error raised by
    `2/0`). Because of the *error*, `1` won't be emitted and won't reach the `flatMap`
    operator.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出`-2(2/-1)`和`0`（因为`2/0`引发了错误）。由于*错误*，`1`不会被发出，也不会到达`flatMap`操作符。
- en: 'Another interesting overload is `Observable<R> flatMap(Func1<T, Observable<U>>,
    Func2<T, U, R>)`. Here is its marble diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的重载是`Observable<R> flatMap(Func1<T, Observable<U>>, Func2<T, U, R>)`。这是它的弹珠图：
- en: '![Transformations with the various flatMap operators](img/4305_04_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![各种flatMap操作符的转换](img/4305_04_03.jpg)'
- en: 'This one combines items from the source `Observable` instance with the `Observable`
    instance triggered by those source items and calls a user-supplied function with
    the pair of the original and derived items. The `Observable` instance will then
    emit the result of this function. Here is an example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符将源`Observable`实例的项目与由这些源项目触发的`Observable`实例的项目组合，并调用用户提供的函数，该函数使用原始和派生项目的对。然后`Observable`实例将发出此函数的结果。这是一个例子：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is because the first element emitted by the source `Observable` instance
    is `5`, the `flatMap` operator turns it into an `Observable` instance using the
    `range()` operator, which emits `5` and `6`. But this `flatMap` operator doesn''t
    stop here; for every item emitted by this range `Observable` instance, it applies
    the second function with first parameter—the original item (`5`) and second parameter—the
    range-emitted item. So we have *5 + 5* and then *5 + 6*. The same is applied for
    the second item emitted by the source `Observable` instance: `432`. It is turned
    to *432 + 432 = 864* and *432 + 433 = 865*.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为源`Observable`实例发出的第一个元素是`5`，`flatMap`操作符使用`range()`操作符将其转换为`Observable`实例，该实例发出`5`和`6`。但是这个`flatMap`操作符并不止于此；对于这个范围`Observable`实例发出的每个项目，它都应用第二个函数，第一个参数是原始项目（`5`），第二个参数是范围发出的项目。所以我们有*5
    + 5*，然后*5 + 6*。对于源`Observable`实例发出的第二个项目也是一样：`432`。它被转换为*432 + 432 = 864*和*432
    + 433 = 865*。
- en: 'This overload is useful when all of the derivative items need to have access
    to their source item and usually saves us from using some kind of **tuple** or
    **pair** classes, saving on memory and library dependencies. In the earlier example
    with files, we could prepend the name of the file to each of the outputted lines:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有派生项都需要访问其源项时，这种重载是有用的，并且通常可以避免使用某种**元组**或**对**类，从而节省内存和库依赖。在前面的文件示例中，我们可以在每个输出行之前添加文件的名称：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The operator `flatMapIterable` doesn''t take as parameter lambda that takes
    arbitrary value as a parameter and returns an `Observable` instance. Instead the
    lambda passed to it takes arbitrary value and returns an `Iterable` instance.
    All of these `Iterable` instances are flattened to values emitted by the resulting
    `Observable` instance. Let''s take a look at the following code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMapIterable`操作符不以lambda作为参数，该lambda以任意值作为参数并返回`Observable`实例。相反，传递给它的lambda以任意值作为参数并返回`Iterable`实例。所有这些`Iterable`实例都被展平为由生成的`Observable`实例发出的值。让我们看一下以下代码片段：'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This simple example merges the two lists emitted by the source `Observable`
    instance, and the result emits the four items. It is worth mentioning that invoking
    `flatMapIterable(list -> list)` is the same as invoking `flatMap(l → Observable.from(l))`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子合并了源`Observable`实例发出的两个列表，结果发出了四个项目。值得一提的是，调用`flatMapIterable(list ->
    list)`等同于调用`flatMap(l → Observable.from(l))`。
- en: 'Another form of the `flatMap` operator is the `concatMap` operator. It behaves
    just like the original `flatMap` operator, except that it concatenates rather
    than merges the resulting `Observable` instance in order to generate its own sequence.
    The following marble diagram shows how it works:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`操作符的另一种形式是`concatMap`操作符。它的行为与原始的`flatMap`操作符相同，只是它连接而不是合并生成的`Observable`实例，以生成自己的序列。以下弹珠图显示了它的工作原理：'
- en: '![Transformations with the various flatMap operators](img/4305_04_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![各种flatMap操作符的转换](img/4305_04_04.jpg)'
- en: The items from the different *derivative Observables* are not interleaved, as
    with the `flatMap` operator. A significant difference between the `flatMap` and
    `concatMap` operators is that the `flatMap` operator uses the inner `Observable`
    instances in parallel, whereas the `concatMap` operator only subscribes to one
    of the `Observable` instances at a time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 来自不同*派生Observable*的项目不会交错，就像`flatMap`操作符一样。`flatMap`和`concatMap`操作符之间的一个重要区别是，`flatMap`操作符并行使用内部`Observable`实例，而`concatMap`操作符一次只订阅一个`Observable`实例。
- en: 'The last operator similar to `flatMap` is `switchMap`. Its marble diagram looks
    like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`flatMap`的最后一个操作符是`switchMap`。它的弹珠图看起来像这样：
- en: '![Transformations with the various flatMap operators](img/4305_04_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![各种flatMap操作符的转换](img/4305_04_05.jpg)'
- en: 'It operates in similar fashion to the `flatMap` operator, except that whenever
    a new item is emitted by the source `Observable` instance, it stops mirroring
    the `Observable` instance generated from the previously emitted item and it begins
    mirroring only the current `Observable` instance. In other words, it internally
    unsubscribes from the current *derivative* `Observable` instance when the next
    one begins emitting its items. Here is an example of this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它的操作方式类似于`flatMap`操作符，不同之处在于每当源`Observable`实例发出新项时，它就会停止镜像先前发出的项生成的`Observable`实例，并且只开始镜像当前的`Observable`实例。换句话说，当下一个`Observable`实例开始发出其项时，它会在内部取消订阅当前的*派生*`Observable`实例。这是一个例子：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The source `Observable` instance is using the `Observable.interval()` operator
    to emit sequential numbers (beginning with zero) every 40 milliseconds. Using
    the `switchMap` operator, a new `Observable` instance emitting another sequence
    of numbers is created for every number. This secondary sequence of numbers begins
    from the source number that was passed to the `switchMap` operator (that's implemented
    by summing the source number with every emitted number, using the `map()` operator).
    So, every 40 milliseconds, a new sequence of numbers is being emitted (each number
    at 10-millisecond intervals).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 源`Observable`实例使用`Observable.interval()`操作符每40毫秒发出一个连续的数字（从零开始）。使用`switchMap`操作符，为每个数字创建一个发出另一个数字序列的新`Observable`实例。这个次要数字序列从传递给`switchMap`操作符的源数字开始（通过使用`map()`操作符将源数字与每个发出的数字相加来实现）。因此，每40毫秒，都会发出一个新的数字序列（每个数字间隔10毫秒）。
- en: 'The resulting output looks like:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出如下：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code for all the mapping examples can be downloaded/viewed at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/MappingExamples.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/MappingExamples.java).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所有映射示例的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/MappingExamples.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/MappingExamples.java)下载/查看。
- en: Grouping items
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组项目
- en: Items can be grouped by specific property or key.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按特定属性或键对项目进行分组。
- en: First, we'll look at the `groupBy()` operator, a method that divides a source
    `Observable` instance into multiple `Observable` instances. Each of these `Observable`
    instances emits some of the source's items depending on a grouping function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一下`groupBy()`操作符，这是一个将源`Observable`实例分成多个`Observable`实例的方法。这些`Observable`实例根据分组函数发出源的一些项。
- en: The `groupBy()` operator returns an `Observable` instance that emits `Observable`
    instances. These `Observable` instances are special; they are of type `GroupedObservable`,
    and you can retrieve their grouping keys using the `getKey()` method. Once the
    `groupBy()` operator is used, the different groups can be handled in a different
    or a common way.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupBy()`操作符返回一个发出`Observable`实例的`Observable`实例。这些`Observable`实例很特殊；它们是`GroupedObservable`类型的，您可以使用`getKey()`方法检索它们的分组键。一旦使用`groupBy()`操作符，不同的组可以以不同或相同的方式处理。'
- en: Note that when the `groupBy()` operator creates an observable that emits the
    `GroupedObservables` instances, each of them buffers its items. So, if we ignore
    any of them, this buffer will present a potential memory leak.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当`groupBy()`操作符创建发出`GroupedObservables`实例的可观察对象时，每个实例都会缓冲其项。因此，如果我们忽略其中任何一个，这个缓冲区将会造成潜在的内存泄漏。
- en: 'The marble diagram of the `groupBy()` operator looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupBy()`操作符的弹珠图如下：'
- en: '![Grouping items](img/4305_04_06.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![分组项目](img/4305_04_06.jpg)'
- en: 'Here, the form of the items is used as the common trait of the grouping. For
    a better understanding of the idea of the method, we can look at this example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，项目的形式被用作分组的共同特征。为了更好地理解这个方法的思想，我们可以看看这个例子：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The example emits some of Pink Floyd''s album titles and groups them by the
    number of words contained in them. For example `Meddle` and `More` are in the
    same group with key `1`, and `A Saucerful of Secrets` and `Wish You Were Here`
    are both in a group with the key of `4`. All these groups are presented by the
    `GroupedObservable` instances, so we can subscribe to them in the `subscribe()`
    call of the source `Observable` instance. The different groups are printed with
    different labels, depending on their keys. The output of this little program is
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例发出了一些Pink Floyd的专辑标题，并根据其中包含的单词数进行分组。例如，`Meddle`和`More`在键为`1`的同一组中，`A Saucerful
    of Secrets`和`Wish You Were Here`都在键为`4`的组中。所有这些组都由`GroupedObservable`实例表示，因此我们可以在源`Observable`实例的`subscribe()`调用中订阅它们。不同的组根据它们的键打印不同的标签。这个小程序的输出如下：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The order the items are emitted in is the same, but they are emitted by different
    `GroupedObservable` instances. Also, all the `GroupedObservable` instances are
    completed after the source completes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 发出的项目的顺序是相同的，但它们是由不同的`GroupedObservable`实例发出的。此外，所有`GroupedObservable`实例在源完成后都会完成。
- en: 'The `groupBy()` operator has another overload that takes a second, transforming
    function that transforms each of the items in a group in some way. Here is an
    example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupBy()`操作符还有另一个重载，它接受第二个转换函数，以某种方式转换组中的每个项目。这是一个例子：'
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The album titles are grouped by the number of the occurrences of the letter
    `m` in them. The text is transformed in a way that all the occurrences of the
    letter are replaced with `*`. The output is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 专辑标题按其中字母`m`的出现次数进行分组。文本被转换成所有字母出现的地方都被替换为`*`。输出如下：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code demonstrating use of the `Observable.groupBy()` operator can
    be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/UsingGroupBy.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/UsingGroupBy.java).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Observable.groupBy()`操作符的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/UsingGroupBy.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/UsingGroupBy.java)找到。
- en: Additional useful transformation operators
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他有用的转换操作符
- en: There are a few additional *transformations* worth mentioning. For example,
    there is the `cast()` operator, which is a shortcut for the `map(v -> someClass.cast(v))`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他值得一提的*转换*。例如，有`cast()`操作符，它是`map(v -> someClass.cast(v))`的快捷方式。
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The initial `Observable` instance here emits values of type `Number`, but they
    are actually `Integer` instances, so we can use the `cast()` operator to represent
    them as `Integer` instances.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的初始`Observable`实例发出`Number`类型的值，但它们实际上是`Integer`实例，所以我们可以使用`cast()`操作符将它们表示为`Integer`实例。
- en: 'Another helpful operator is the `timestamp()` operator. It adds a *timestamp*
    to each emitted value by transforming it into an instance of the `Timestamped<T>`
    class. This is helpful if, for example, we want to log the output of an `Observable`,
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的操作符是`timestamp()`操作符。它通过将每个发出的值转换为`Timestamped<T>`类的实例来为其添加*时间戳*。例如，如果我们想要记录`Observable`的输出，这将非常有用。
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, each number is being timestamped. Again, that can be implemented
    using the `map()` operator very easily. The output of the preceding example looks
    like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个数字都被时间戳标记。同样，可以使用`map()`操作符很容易地实现。前面例子的输出如下：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A similar operator is the `timeInterval` operator, but it transforms a value
    to an instance of the `TimeInterval<T>` operator instead. A `TimeInterval<T>`
    instance represents an item emitted by an `Observable` along with the amount of
    time that elapsed either since the emission of the previous item, or (if there
    was no previous item) since the subscription. This can be used for generating
    statistics, for example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类似的操作符是`timeInterval`操作符，但它将一个值转换为`TimeInterval<T>`实例。`TimeInterval<T>`实例表示`Observable`发出的项目以及自上一个项目发出以来经过的时间量，或者（如果没有上一个项目）自订阅以来经过的时间量。这可以用于生成统计信息，例如：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will output something similar to this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出类似于这样的内容：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can see that the different values are emitted roughly at 150 milliseconds,
    as they should be.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到不同的值大约在150毫秒左右发出，这是应该的。
- en: Both the `timeInterval` and `timestamp` operators work on the *immediate* scheduler
    (see [Chapter 6](ch06.html "Chapter 6. Using Concurrency and Parallelism with
    Schedulers"), *Using Concurrency and Parallelism with Schedulers*), and both of
    them keep their time information in milliseconds.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeInterval`和`timestamp`操作符都在*immediate*调度程序上工作（参见[第6章](ch06.html "第6章。使用调度程序进行并发和并行处理")，“使用调度程序进行并发和并行处理”），它们都以毫秒为单位保留其时间信息。'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code for the preceding examples can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java)找到。
- en: Filtering data
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤数据
- en: 'In the first chapter''s reactive sum example, we were filtering the user input,
    based on a special pattern. The pattern was, for example, *a: <number>*. It is
    common to filter only interesting bits of data from the data stream. For example,
    it''s useful to filter out *<enter>* key-down events only from all key-down events,
    or only lines containing a given expression from a file. That''s why it is important
    to not only be able to transform our data but also to learn how to filter it.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章的响应式求和示例中，我们根据特殊模式过滤用户输入。例如，模式是* a：<number>*。通常只从数据流中过滤出有趣的数据。例如，仅从所有按键按下事件中过滤出*<enter>*按键按下事件，或者仅从文件中包含给定表达式的行中过滤出行。这就是为什么不仅能够转换我们的数据，还能够学会如何过滤它是很重要的。
- en: 'There are many filtering operators in RxJava. The most important of these operators
    is `filter()`. Its marble diagram is very simple and is shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava中有许多过滤操作符。其中最重要的是`filter()`。它的弹珠图非常简单，如下所示：
- en: '![Filtering data](img/4305_04_07.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![过滤数据](img/4305_04_07.jpg)'
- en: 'It shows that the `filter()` operator filters the data by some property. In
    the diagram, it''s the form of the elements: it filters only circles. Like all
    the other operators, `filter()` creates a new `Observable` instance from the source.
    This `Observable` instance emits only items that comply to the condition, defined
    by the `filter()` operator. The following piece of code illustrates that:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示`filter()`操作符通过某些属性过滤数据。在图中，它是元素的形式：它只过滤圆圈。像所有其他操作符一样，`filter()`从源创建一个新的`Observable`实例。这个`Observable`实例只发出符合`filter()`操作符定义的条件的项目。以下代码片段说明了这一点：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will output only *even* numbers (`32`, `8`, and `98`), because of the filtering
    condition.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅输出*偶数*（`32`，`8`和`98`），因为满足过滤条件。
- en: 'The `filter()` operator filters elements based on a user-defined function.
    There are quite a few additional filtering operators. In order to understand them,
    let''s look at some simple examples:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`操作符根据用户定义的函数过滤元素。还有一些其他过滤操作符。为了理解它们，让我们看一些简单的例子：'
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We define three `Observable` instances to use in our examples. The first one
    emits nine numbers. The second one emits all the words from a sentence, one by
    one. The third one emits elements of different types—strings, integers, doubles,
    and longs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个`Observable`实例来用于我们的示例。第一个发出九个数字。第二个逐个发出句子中的所有单词。第三个发出不同类型的元素——字符串、整数、双精度和长整型。
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `takeLast()` operator returns a new `Observable` instance that emits only
    the last *n* items from the source `Observable` instance, only when it completes.
    This method has a few overloads. For example, there is one that emits the last
    *N* or less items from the source, emitted in a specified time window. Another
    one can receive a `Scheduler` instance in order to be executed on another thread.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`takeLast()`操作符返回一个新的`Observable`实例，只从源`Observable`实例中发出最后的*N*个项目，只有当它完成时。这个方法有一些重载。例如，有一个可以在指定的时间窗口内发出源的最后*N*个或更少的项目。另一个可以接收一个`Scheduler`实例，以便在另一个线程上执行。'
- en: 'In this example, only the last four items of the `Observable` instance will
    be filtered and output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，只有`Observable`实例的最后四个项目将被过滤和输出：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看下面的代码片段：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Observable` instance created by the `last()` operator, which outputs only
    the *last item* emitted by the source `Observable` instance when it completes.
    If the source doesn''t emit an item, a `NoSuchElementException` exception will
    be emitted as an `OnError()` *notification*. It has an overload that receives
    a predicate parameter of type `T->Boolean`. As a result, it emits only the last
    item emitted by the source, complying to the condition defined by the predicate.
    In this example, the output will be as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由`last()`操作符创建的`Observable`实例，在源`Observable`实例完成时只输出*最后一个项目*。如果源没有发出项目，将会发出`NoSuchElementException`异常作为`OnError()`
    *通知*。它有一个重载，接收一个类型为`T->Boolean`的谓词参数。因此，它只发出源发出的最后一个符合谓词定义的条件的项目。在这个例子中，输出将如下所示：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `takeLastBuffer()` method behaves much like the `takeLast()` method, but
    the `Observable` instance created by it emits only one item—a `List` instance
    containing the last *N* items from the source:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`takeLastBuffer()`方法的行为与`takeLast()`方法类似，但它创建的`Observable`实例只发出一个包含源的最后*N*个项目的`List`实例：'
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It has analogical overloads to the `takeLast()` method''s. The output here
    is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它有类似的重载。这里的输出如下：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `lastOrDefault()` operator behaves like and has the same overload with
    a predicate as the `last()` operator:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastOrDefault()`操作符的行为与`last()`操作符相似，并且具有谓词的相同重载：'
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, if the source doesn''t emit anything, the `lastOrDefault()` operator
    emits the default value instead of the `OnError` *notification*. The output of
    this example is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果源没有发出任何东西，`lastOrDefault()`操作符会发出默认值而不是`OnError` *通知*。这个例子的输出如下：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `skipLast()` operator is the exact opposite of the `takeLast()` method;
    it emits everything except the last *N* items from the source when it completes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`skipLast()`操作符是`takeLast()`方法的完全相反；它在完成时发出除了源的最后*N*个项目之外的所有内容：'
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It has similar overloads. The output of this example is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它有类似的重载。这个例子的输出如下：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `skip()` method is the same as the `skipLast()` method but skips the first
    *N* items instead of the last:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip()`方法与`skipLast()`方法相同，但是跳过前*N*个项目而不是最后一个：'
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This means that the output of the example is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着示例的输出如下：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `take()` operator is similar to the `takeLast()` operator, but instead of
    the last *N* items of the source, it emits the first *N* items.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`take()`操作符类似于`takeLast()`操作符，但是它发出源的前*N*个项目，而不是最后的*N*个项目。'
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is a commonly-used operator, cheaper than the `takeLast()` operator, because
    the `takeLast()` operator buffers its items and waits for the source to complete.
    This operator doesn''t buffer its items but emits them when it receives them.
    It is very useful for limiting infinite `Observable` instances. The output of
    the preceding example is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常用的操作符，比`takeLast()`操作符更便宜，因为`takeLast()`操作符会缓冲其项目并等待源完成。这个操作符不会缓冲其项目，而是在接收到它们时发出它们。它非常适用于限制无限的`Observable`实例。前面例子的输出如下：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看下面的代码片段：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `first()` operator is similar to the `last()` operator but emits only the
    first item emitted by the source. It emits the same `OnError` *notification* if
    there is no first item. Its predicate form has an alias— the `takeFirst()` operator.
    There is also a `firstOrDefault()` operator form of this operator. The output
    of this example is clear:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`first()`操作符类似于`last()`操作符，但只发出源发出的第一个项目。如果没有第一个项目，它会发出相同的`OnError` *通知*。它的谓词形式有一个别名——`takeFirst()`操作符。还有一个`firstOrDefault()`操作符形式。这个例子的输出很清楚：'
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看下面的代码片段：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `elementAt()` operator is similar to the `first()` and `last()` operators
    but has no predicate form. There is an `elementAtOrDefault()` form though. It
    emits only the element at the specified index in the sequence of items, emitted
    by the source `Observable` instance. This example outputs the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`elementAt()`操作符类似于`first()`和`last()`操作符，但没有谓词形式。不过有一个`elementAtOrDefault()`形式。它只发出源`Observable`实例发出的项目序列中指定索引处的元素。这个例子输出如下：'
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看下面的代码片段：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `Observable` instance produced by the `distinct()` operator emits the items
    from the source, excluding the repeated ones. There is an overload that can receive
    a function, returning a key or hash code value to be used to decide whether an
    item is distinct from another or not:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由`distinct()`操作符产生的`Observable`实例发出源的项目，排除重复的项目。有一个重载可以接收一个函数，返回一个用于决定一个项目是否与另一个项目不同的键或哈希码值：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `distinctUntilChanged()` operator is similar to the `distinct()` method,
    but the `Observable` instance that it returns emits all items emitted by the source
    `Observable` instance that are distinct from their immediate predecessors. So,
    in this example, it will emit every word, except the last one, `crew`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`distinctUntilChanged()`操作符类似于`distinct()`方法，但它返回的`Observable`实例会发出源`Observable`实例发出的所有与它们的直接前导不同的项目。因此，在这个例子中，它将发出除了最后一个`crew`之外的每个单词。'
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `ofType()` operator creates an `Observable` instance that emits only the
    items emitted by the source of a given type. It basically is a shortcut to this
    call: `filter(v -> Class.isInstance(v))`. In this example the output will be as
    follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`ofType()`操作符创建一个只发出给定类型源发出的项目的`Observable`实例。它基本上是这个调用的快捷方式：`filter(v -> Class.isInstance(v))`。在这个例子中，输出将如下所示：'
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code for all of these examples can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FilteringExamples.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FilteringExamples.java).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FilteringExamples.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/FilteringExamples.java)上查看/下载。
- en: These are the most commonly used *filtering* operators provided by RxJava. We'll
    be using some of them a lot in later examples.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是RxJava提供的最常用的*过滤*操作符。我们将在以后的示例中经常使用其中的一些。
- en: The `last` operator we'll look at in this chapter is a transformational one,
    but a bit special. It can use previously accumulated states! Let's learn more
    about it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将要看的`last`操作符是一个转换操作符，但有点特殊。它可以使用先前累积的状态！让我们了解更多。
- en: Accumulating data
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 累积数据
- en: The `scan(Func2)` operator takes a function with two arguments as a parameter.
    Its result is an `Observable` instance. The first item, emitted by the result
    of the `scan()` method, is the first item of the source `Observable` instance.
    The second item emitted is created by applying the function that was passed to
    the `scan()` method on the previous item emitted by the result `Observable` instance
    and the second item, emitted by the source `Observable` instance. The third item,
    emitted by the `scan()` method result, is created by applying the function, passed
    to the `scan()` method to the previous item, emitted by it and the third item
    emitted by the source `Observable` instance. This pattern continues in order to
    create the rest of the sequence emitted by the `Observable` instance creates by
    the `scan()` method. The function passed to the `scan()` method is called an **accumulator**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`scan(Func2)`操作符接受一个带有两个参数的函数作为参数。它的结果是一个`Observable`实例。通过`scan()`方法的结果发出的第一个项目是源`Observable`实例的第一个项目。发出的第二个项目是通过将传递给`scan()`方法的函数应用于结果`Observable`实例之前发出的项目和源`Observable`实例发出的第二个项目来创建的。通过`scan()`方法结果发出的第三个项目是通过将传递给`scan()`方法的函数应用于之前发出的项目和源`Observable`实例发出的第三个项目来创建的。这种模式继续下去，以创建`scan()`方法创建的`Observable`实例发出的序列的其余部分。传递给`scan()`方法的函数称为**累加器**。'
- en: 'Let''s look at the marble diagram of the `scan(Func2)` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`scan(Func2)`方法的弹珠图：
- en: '![Accumulating data](img/4305_04_08.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![累积数据](img/4305_04_08.jpg)'
- en: The items emitted by the `scan()` method can be generated using an accumulated
    state. In the diagram, the circle is accumulated in the triangle, and then this
    triangle-circle is accumulated in the square.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`scan()`方法发出的项目可以使用累积状态生成。在图中，圆圈在三角形中累积，然后这个三角形圆圈在正方形中累积。'
- en: 'This means that we can emit the sums of a sequence of integers, for example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以发出一系列整数的总和，例如：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first *subscription* will output all the emissions : *1, 3 (1+2), 6 (3
    + 3), 10 (6 + 4) .. 55*. But in most cases, we are interested only in the last
    emitted item—the final sum. We can use an `Observable` instance that emits only
    the last element, using the `last()` filtering operator. It''s worth mentioning
    that there is a `reduce(Func2)` operator, an alias for the `scan(Func2).last()`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个*订阅*将输出所有的发射：*1, 3 (1+2), 6 (3 + 3), 10 (6 + 4) .. 55*。但在大多数情况下，我们只对最后发出的项目感兴趣——最终总和。我们可以使用一个只发出最后一个元素的`Observable`实例，使用`last()`过滤操作符。值得一提的是，还有一个`reduce(Func2)`操作符，是`scan(Func2).last()`的别名。
- en: The `scan()` operator has one overload which can be used with a *seed/initial*
    parameter. In this case, the function passed to the `scan(T, Func2)` operator
    is applied to the first item emitted by the source and this *seed* parameter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`scan()`操作符有一个重载，可以与*seed/initial*参数一起使用。在这种情况下，传递给`scan(T, Func2)`操作符的函数被应用于源发出的第一个项目和这个*seed*参数。'
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This example counts the number of lines in a file. The file `Observable` instance
    emits the lines of the file specified by the given path, one-by-one. We use the
    `scan(T, Func2)` operator with a *seed* value of `0` to count the lines by adding
    one to the accumulated count on every line.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例计算文件中的行数。文件`Observable`实例逐行发出指定路径文件的行。我们使用`scan(T, Func2)`操作符，初始值为`0`，通过在每行上累加计数来计算行数。
- en: 'We will conclude this chapter with an example using many of the operators introduced
    in it, together. Let''s look at it:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一个示例来结束本章，其中使用了本章介绍的许多操作符。让我们来看一下：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This piece of code uses lots of operators to filter out and assemble a sentence
    hidden in a file. The file is represented by an `Observable` instance, which emits
    all the lines contained in it one by one.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了许多操作符来过滤并组装隐藏在文件中的句子。文件由一个`Observable`实例表示，它逐行发出其中包含的所有行。
- en: We don't want to operate only on the different lines; we want to emit all the
    sentences contained in the file. So, we use the `flatMap` operator to create an
    `Observable` instance which emits the file sentences by sentence (determined by
    `dot`).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不只想对不同的行进行操作；我们想发出文件中包含的所有句子。因此，我们使用`flatMap`操作符创建一个逐句发出文件句子的`Observable`实例（由`dot`确定）。
- en: We trim these sentences using the `map()` operator. It is possible for them
    to contain some leading or trailing spaces.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`map()`操作符修剪这些句子。它可能包含一些前导或尾随空格。
- en: We want to operate on the different words contained in our sentence items, so
    we turn them into arrays of words, using the `map()` operator and the `String::split`
    parameter.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望对句子中包含的不同单词进行操作，因此我们使用`map()`操作符和`String::split`参数将它们转换为单词数组。
- en: We don't care about empty sentences (if there are any), so we filter them out
    using the `filter()` operator.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不关心空句子（如果有的话），所以我们使用`filter()`操作符将它们过滤掉。
- en: We need only the first words from the sentences, so we use the `map()` operator
    to get them. The resulting `Observable` instance emits the first word of every
    sentence contained in the file.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要句子中的第一个单词，所以我们使用`map()`操作符来获取它们。生成的`Observable`实例会发出文件中每个句子的第一个单词。
- en: We don't need duplicated words, so we use the `distinct()` operator to get rid
    of them.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要重复的单词，所以我们使用`distinct()`操作符来摆脱它们。
- en: Now we want to branch our logic in a way that some of the words are treated
    differently. So we use the `groupBy()` operator and a `Boolean` key to divide
    our words into two `Observable` instances. The key is `True` for the chosen words
    and `False` for all the others.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们想以某种方式分支我们的逻辑，使一些单词被不同对待。所以我们使用`groupBy()`操作符和一个`Boolean`键将我们的单词分成两个`Observable`实例。选择的单词的键是`True`，其他的是`False`。
- en: Using the `flatMap` operator, we join our separated words, but only the chosen
    ones (with a key of `True`) are left unchanged. The rest are *decapitalized*.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`flatMap`操作符，我们连接我们分开的单词，但只有选择的单词（带有`True`键）保持不变。其余的被*小写*。
- en: We trim all the different words from leading/trailing spaces, using the `map()`
    operator.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`map()`操作符去除所有不同单词的前导/尾随空格。
- en: We use the `filter()` operator to filter out the empty ones.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`filter()`操作符来过滤掉空的句子。
- en: Using the `scan()` operator, we concatenate the words with spaces as separators.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`scan()`操作符，我们用空格作为分隔符连接单词。
- en: With the `last()` operator, our resulting `Observable` instance will emit only
    the last concatenation, containing all the words.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`last()`操作符，我们的结果`Observable`实例将只发出最后的连接，包含所有单词。
- en: One last call to the `map()` operator creates a sentence from our concatenated
    words by adding a dot.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一次调用`map()`操作符，通过添加句点从我们连接的单词中创建一个句子。
- en: If we output the single item emitted by this `Observable` instance, we'll get
    a sentence composed of the first words of all the sentences contained in the initial
    file (skipping duplicated words)!
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们输出这个`Observable`实例发出的单个项目，我们将得到一个由初始文件中所有句子的第一个单词组成的句子（跳过重复的单词）！
- en: 'And the output is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding example can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter04/VariousTransformationsDemonstration.java)找到。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The example concluding the chapter demonstrates what we've learned so far. We
    can write complex logic by chaining the `Observable` instances using a variety
    of operators. We can transform incoming data using the `map()` or `flatMap()`
    operators and can branch logic by using the `groupBy()` or `filter()` operators
    or the different `flatMap()` operators. We can join these branches again with
    the `flatMap()` operators. We can select parts of the data with the help of different
    filters and accumulate it with the `scan()` operator. Using all of these operators,
    we can write pretty decent programs in a readable and simple way. The complexity
    of the program doesn't affect the complexity of the code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结尾的示例演示了我们迄今为止学到的内容。我们可以通过链接`Observable`实例并使用各种操作符来编写复杂的逻辑。我们可以使用`map()`或`flatMap()`操作符来转换传入的数据，并可以使用`groupBy()`或`filter()`操作符或不同的`flatMap()`操作符来分支逻辑。我们可以再次使用`flatMap()`操作符将这些分支连接起来。我们可以借助不同的过滤器选择数据的部分，并使用`scan()`操作符累积数据。使用所有这些操作符，我们可以以可读且简单的方式编写相当不错的程序。程序的复杂性不会影响代码的复杂性。
- en: The next step is to learn how to combine the branches of our logic in a more
    straightforward fashion. We'll learn how to combine data coming from different
    sources too. So let's proceed with the next chapter!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是学习如何以更直接的方式组合我们逻辑的分支。我们还将学习如何组合来自不同来源的数据。所以让我们继续下一章吧！
