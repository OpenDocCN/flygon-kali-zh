- en: Chapter 10. Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。面向对象编程
- en: In this chapter, we will discover that, in Kotlin, classes are fundamental to
    just about everything and, in fact, just about everything is a class.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将发现，在Kotlin中，类对几乎所有事情都是基础的，实际上，几乎所有事情都是一个类。
- en: We have already talked about reusing other people's code, specifically the Android
    API, but in this chapter, we will really get to grips with how this works and
    learn about **object-oriented programming** (**OOP**) and how to use it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈到了重用他人的代码，特别是Android API，但在本章中，我们将真正掌握这是如何工作的，并学习**面向对象编程**（**OOP**）以及如何使用它。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to OOP and the three key topics of encapsulation, polymorphism,
    and inheritance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍OOP和封装、多态和继承的三个关键主题
- en: Basic classes, including how to write our first class including adding **properties**
    for data/variable encapsulation and functions to get things done
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本类，包括如何编写我们的第一个类，包括为数据/变量封装添加**属性**和函数以完成任务
- en: Explore **visibility modifiers** that further aid and refine encapsulation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索**可见性修饰符**，进一步帮助和完善封装。
- en: Learn about **constructors** that enable us to quickly prepare our classes to
    be turned into usable objects/instances
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解**构造函数**，使我们能够快速准备我们的类以转换为可用的对象/实例
- en: Code a Basic Classes mini app to put in to practice everything we have learned
    in this chapter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个基本的类小应用程序，以实践我们在本章学到的一切
- en: If you try to memorize this chapter (or the next), you will have to make a lot
    of room in your brain, and you will probably forget something really important
    in its place.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图记住本章（或下一章），你将不得不在你的大脑中腾出很多空间，而且你可能会忘记一些非常重要的东西。
- en: A good goal will be to try and just about get it. This way, your understanding
    will become more rounded. You can then refer to this chapter (and the next) for
    a refresher when needed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的目标是尽量理解它。这样，你的理解将变得更加全面。在需要时，你可以参考本章（和下一章）进行复习。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It doesn't matter if you don't completely understand everything in this chapter
    or the next straight away! Keep on reading and be sure to complete all the apps.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对本章或下一章的内容并不完全理解也没关系！继续阅读，并确保完成所有的应用程序。
- en: Introducing OOP
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍OOP
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Android and Kotlin"),
    *Getting Started with Android and Kotlin,* we mentioned that Kotlin was an object-oriented
    language. An object-oriented language requires us to use OOP; it isn't an optional
    extra, it's part of Kotlin.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 开始使用Android和Kotlin")中，*开始使用Android和Kotlin*，我们提到Kotlin是一种面向对象的语言。面向对象的语言要求我们使用OOP；这不是可选的额外部分，而是Kotlin的一部分。
- en: Let's find out a little bit more.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们多了解一点。
- en: What is OOP exactly?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OOP到底是什么？
- en: OOP is a way of programming that involves breaking our requirements down into
    chunks that are more manageable than the whole.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: OOP是一种编程方式，它涉及将我们的需求分解成比整体更易管理的块。
- en: Each chunk is self-contained, and potentially reusable, by other programs, while
    working together as a whole with the other chunks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个块都是自包含的，并且可能被其他程序重用，同时与其他块一起工作。
- en: These chunks are what we have been referring to as objects. When we plan/code
    an object, we do so with a class. A class can be thought of as the blueprint of
    an object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块就是我们所说的对象。当我们计划/编写一个对象时，我们使用一个类。类可以被看作是对象的蓝图。
- en: We implement an object of a class. This is called an **instance** of a class.
    Think about a house blueprint – you can't live in it, but you can build a house
    from it; so, you build an instance of it. Often, when we design classes for our
    apps, we write them to represent real-world things.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个类的对象。这被称为类的**实例**。想想一个房子的蓝图——你不能住在里面，但你可以建造一座房子；所以，你建造了它的一个实例。通常，当我们为我们的应用程序设计类时，我们写它们来代表现实世界的事物。
- en: However, OOP is more than this. It is also a way of doing things – a methodology
    that defines best practices.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，OOP不仅仅是这样。它也是一种做事情的方式——一种定义最佳实践的方法。
- en: The three core principles of OOP are **encapsulation**, **polymorphism**, and
    **inheritance**. These might sound complex but, taken a step at a time, are reasonably
    straightforward.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: OOP的三个核心原则是**封装**、**多态**和**继承**。这些听起来可能很复杂，但一步一步来说，都是相当简单的。
- en: Encapsulation
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 封装
- en: '**Encapsulation** means keeping the internal workings of your code safe from
    interference from the code that uses it, by allowing only the variables and functions
    you choose to be accessed.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装**意味着通过允许你选择的变量和函数来访问，使你的代码的内部工作免受使用它的代码的干扰。'
- en: This means that your code can always be updated, extended, or improved without
    affecting the programs that use it, provided that the exposed parts are still
    accessed in the same way.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你的代码可以随时更新、扩展或改进，而不会影响使用它的程序，只要暴露的部分仍然以相同的方式访问。
- en: 'You may recall this line of code from[Chapter 1](ch01.html "Chapter 1. Getting
    Started with Android and Kotlin"), *Getting Started with Android and Kotlin*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得来自[第1章](ch01.html "第1章. 开始使用Android和Kotlin")的这行代码，*开始使用Android和Kotlin*：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With proper encapsulation, it doesn't matter if the satellite company or the
    Android API team need to update the way their code works. If the `getLastKnownLocation`
    function signature remains the same, we don't have to worry about what goes on
    inside. Our code, as written before the update, will still work after the update.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过适当的封装，如果卫星公司或Android API团队需要更新他们的代码工作方式，也不要紧。如果`getLastKnownLocation`函数签名保持不变，我们就不必担心内部发生了什么。我们在更新之前编写的代码在更新后仍将正常工作。
- en: If the manufacturer of a car gets rid of the wheels and makes it an electrically-powered
    hover car, if it still has a steering wheel, accelerator, and brake pedal, driving
    it should not be a challenge.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一辆汽车的制造商去掉了车轮，将其变成了电动悬浮汽车，如果它仍然有方向盘、油门和刹车踏板，驾驶它不应该是一个挑战。
- en: When we use the classes of the Android API, we are doing so in the way the Android
    developers designed their classes to allow us to.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Android API的类时，我们是按照Android开发人员设计他们的类的方式来使用的。
- en: We will dig deeper into encapsulation in this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨封装。
- en: Polymorphism
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多态性
- en: '**Polymorphism** allows us to write code that is less dependent on the types
    we are trying to manipulate, making our code clearer and more efficient. Polymorphism
    means **many forms**. If the objects that we code can be more than one type of
    thing, then we can take advantage of this. Some future examples will make this
    clear. An analogy will give you a more real-world perspective. If we have car
    factories that can make vans and small trucks just by changing the instructions
    given to the robots and the parts that go onto the production line, then the factory
    is polymorphic.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性使我们能够编写的代码不太依赖于我们试图操作的类型，使我们的代码更清晰、更高效。多态性意味着**多种形式**。如果我们编码的对象可以是多种类型的东西，那么我们就可以利用这一点。一些未来的例子将会让这一点更加清晰。类比会让你更加真实地理解。如果我们有汽车工厂，只需改变给机器人的指令和装配线上的零件，就可以制造货车和小型卡车，那么这个工厂就是多态的。
- en: Wouldn't it be useful if we could write code that can handle different types
    of data without starting again? We will see some examples of this in [Chapter
    11](ch11.html "Chapter 11. Inheritance in Kotlin"), *Inheritance in Kotlin*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够编写能够处理不同类型数据的代码而无需重新开始，这不是很有用吗？我们将在[第11章](ch11.html "第11章 Kotlin中的继承")中看到一些例子，*Kotlin中的继承*。
- en: We will also find out more about polymorphism in [Chapter 12](ch12.html "Chapter 12. Connecting
    Our Kotlin to the UI and Nullability"), *Connecting Our Kotlin to the UI and Nullability*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在[第12章](ch12.html "第12章 Kotlin与UI和空值的连接")中了解更多关于多态性的内容，*Kotlin与UI和空值的连接*。
- en: Inheritance
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: 'Just like it sounds, **inheritance** means we can harness all the features
    and benefits of other peoples'' classes (including encapsulation and polymorphism)
    while further refining their code specifically to our situation. Actually, we
    have done this already, every time we used the `:` operator as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它听起来的那样，**继承**意味着我们可以利用其他人的类的所有特性和好处（包括封装和多态性），同时进一步调整他们的代码以适应我们的情况。实际上，我们已经这样做了，每次使用`:`运算符时：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `AppCompatActivity` class itself inherits from `Activity`. So, we inherited
    from `Activity` every time we created a new Android project. We can go further
    than this, and we will see how it is useful.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppCompatActivity`类本身继承自`Activity`。因此，每次创建新的Android项目时，我们都继承自`Activity`。我们可以做得更多，我们将看到这是如何有用的。'
- en: Imagine if the strongest man in the world gets together with the smartest woman
    in the world. There is a good chance that their children will have serious benefits
    from gene inheritance. Inheritance in Kotlin lets us do the same thing with another
    person's code and our own.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，世界上最强壮的男人和最聪明的女人在一起。他们的孩子很有可能会从基因遗传中获得重大好处。Kotlin中的继承让我们可以用另一个人的代码和我们自己的代码做同样的事情。
- en: We will look at inheritance in action in the next chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中看到继承的实际应用。
- en: Why do it like this?
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要这样做？
- en: When used carefully, all this OOP allows you to add new features without worrying
    as much about how they interact with existing features. When you do have to change
    a class, its self-contained (encapsulated) nature means less, or perhaps even
    zero, consequences for other parts of the program. This is the encapsulation part.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当小心使用时，所有这些面向对象编程允许你添加新功能，而不太担心它们如何与现有功能交互。当你必须更改一个类时，它的自包含（封装）性质意味着对程序的其他部分的影响较小，甚至可能为零。这就是封装的部分。
- en: You can use other people's code (such as the Android API) without knowing or
    perhaps even caring how it works. Think about the Android lifecycle, `Toast`,
    `Log`, all the UI widgets, listening to satellites, and so on. We don't know,
    and we don't need to know, how they work internally. As a more detailed example,
    the `Button` class has nearly 50 functions – do we really want to write all that
    ourselves, just for a button? It would be much better to use someone else's `Button`
    class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用其他人的代码（如Android API），而不知道甚至可能不关心它是如何工作的。想想一下Android生命周期、`Toast`、`Log`、所有的UI小部件、监听卫星等等。我们不知道，也不需要知道它们内部是如何工作的。更详细的例子是，`Button`类有将近50个函数
    - 我们真的想要为一个按钮自己写这么多吗？最好使用别人的`Button`类。
- en: OOP allows you to write apps for highly complex situations without breaking
    a sweat.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程使你能够轻松地为高度复杂的情况编写应用程序。
- en: You can create multiple similar, yet different, versions of a class without
    starting the class from scratch by using inheritance, and you can still use the
    functions intended for the original type of object with your new object because
    of polymorphism.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承，你可以创建类的多个相似但不同的版本，而无需从头开始编写类，并且由于多态性，你仍然可以使用原始类型对象的函数来处理新对象。
- en: It makes sense really. And Kotlin was designed from the start with all of this
    in mind, so we are forced into using all this OOP – however, this is a good thing.
    Let's have a quick class recap.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很有道理。而且Kotlin从一开始就考虑到了所有这些，所以我们被迫使用所有这些面向对象编程 - 然而，这是一件好事。让我们快速回顾一下类。
- en: Class recap
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类回顾
- en: A class is a container for a bunch of code that can contain functions, variables,
    loops, and all the other Kotlin syntax we have learned already. A class is part
    of a Kotlin package, and most packages will normally have multiple classes. Most
    often, although not always, each new class will be defined in its own `.kt` code
    file with the same name as the class, as with all of our activity-based classes
    so far.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 类是一堆代码的容器，可以包含函数、变量、循环和我们已经学过的其他Kotlin语法。类是Kotlin包的一部分，大多数包通常会有多个类。通常情况下，尽管不总是如此，每个新类都将在其自己的`.kt`代码文件中定义，文件名与类名相同，就像我们迄今为止所有基于活动的类一样。
- en: Once we have written a class, we can use it to make as many objects from it
    as we want. Remember, the class is the blueprint, and we make objects based on
    the blueprint. The house isn't the plan, just as the object isn't the class –
    it is an object made from the class. An object is a reference variable, just like
    a string and, later, we will discover exactly what being a reference variable
    means. For now, let's look at some actual code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了一个类，我们就可以使用它来创建任意数量的对象。记住，类是蓝图，我们根据蓝图制作对象。房子不是计划，就像对象不是类一样-它是从类制作的对象。对象是一个引用变量，就像一个字符串，稍后我们将发现引用变量的确切含义。现在，让我们看一些实际的代码。
- en: Basic classes
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类
- en: There are two main steps involved with classes. First, we must declare our class,
    and then we can bring it to life by instantiating it into an actual useable object.
    Remember, the class is just a blueprint, and you must use the blueprint to build
    an object before you can do anything with it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类涉及两个主要步骤。首先，我们必须声明我们的类，然后我们可以通过实例化它将其变成一个实际可用的对象。记住，类只是一个蓝图，你必须使用蓝图来构建一个对象，然后才能对其进行任何操作。
- en: Declaring a class
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明类
- en: Classes can be of varying sizes and complexities depending upon what its purpose
    is. Here is the absolute simplest example of a class declaration.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以根据其目的的不同而具有不同的大小和复杂性。这是一个类声明的绝对最简单的例子。
- en: Remember that we most often declare a new class in a file of its own with the
    same name as the class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们通常会在一个与类同名的文件中声明一个新的类。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will cover some exceptions to the rule throughout the rest of the book.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将介绍一些例外情况。
- en: 'Let''s have a look at three examples of declaring a class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看声明类的三个例子：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that we will do a full working project to practice at the end of this chapter.
    There are also completed classes for all the theoretical examples throughout this
    chapter in the `Chapter10/Chapter Example Classes` folder of the download bundle.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将在本章结束时进行一个完整的工作项目练习。在下载包的`Chapter10/Chapter Example Classes`文件夹中，还有本章中所有理论示例的完整类。
- en: The first thing to note in the previous code is that I have lumped together
    three class declarations. In real code, each declaration would be contained in
    its own file with the same name as the class and the `.kt` file name extension.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中要注意的第一件事是，我已经将三个类声明合并在一起。在真实的代码中，每个声明都应该包含在自己的文件中，文件名与类名相同，扩展名为`.kt`。
- en: To declare a class, we use the `class` keyword followed by the name of the class.
    Therefore, we can work out that, in the previous code, we declared a class called
    `Soldier`, a class called `Message`, and a class called `ParticleSystem`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个类，我们使用`class`关键字，后面跟着类的名称。因此，我们可以得出结论，在前面的代码中，我们声明了一个名为`Soldier`的类，一个名为`Message`的类，以及一个名为`ParticleSystem`的类。
- en: We already know that classes can, and often do, model real-world things. It
    would, therefore, be safe to assume that the three hypothetical classes will model
    a soldier (perhaps from a game), a message (perhaps from an email or text messaging
    app), and a particle system (perhaps from a scientific simulation app).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，类可以并且经常模拟现实世界的事物。因此，可以安全地假设这三个假设的类将模拟一个士兵（也许来自游戏）、一条消息（也许来自电子邮件或短信应用程序）和一个粒子系统（也许来自科学模拟应用程序）。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A particle system is a system that contains individual particles that act as
    a part of that system. In computing, they are used to model/simulate/visualize
    things such as chemical reactions/explosions and particle behavior, perhaps smoke.
    In [Chapter 21](ch21.html "Chapter 21. Threads and Starting the Live Drawing App"),
    *Threads and Starting the Live Drawing App* we will build a cool drawing app that
    uses particle systems to make the user's drawings appear to come alive.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统是一个包含个体粒子的系统，这些粒子作为该系统的一部分。在计算中，它们用于模拟/可视化化学反应/爆炸和粒子行为，也许是烟雾等事物。在[第21章](ch21.html
    "第21章。线程和启动实时绘图应用程序")中，*线程和启动实时绘图应用程序*，我们将构建一个使用粒子系统使用户的绘画看起来活灵活现的酷炫绘图应用程序。
- en: It is plain, however, that a simple declaration like the three we have just
    seen does not contain enough code to achieve any useful functionality. We will
    expand on class declarations in a moment. First, let's see how to go about using
    the classes that we have declared.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，很明显，像我们刚刚看到的三个简单声明并不包含足够的代码来实现任何有用的功能。我们将在一会儿扩展类声明。首先，让我们看看如何使用我们声明的类。
- en: Instantiating a class
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化类
- en: To build a usable object from our classes, we would turn to another code file.
    So far throughout the book we have used the `onCreate` function in the `AppCompatActivity`
    class to demonstrate different concepts. While you can instantiate a class from
    virtually anywhere in Android, because of the lifecycle functions, it is quite
    common to use `onCreate` to instantiate objects/instances of our classes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的类构建一个可用的对象，我们需要转到另一个代码文件。到目前为止，在整本书中，我们已经使用`AppCompatActivity`类中的`onCreate`函数来演示不同的概念。虽然你可以在Android的任何地方实例化一个类，但由于生命周期函数的存在，通常会使用`onCreate`来实例化我们的类的对象/实例。
- en: 'Have a look at the following code. I have highlighted the new code to focus
    on:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码。我已经突出了要关注的新代码：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code we instantiated an instance (made a usable object) from
    each of our three previously declared classes. Let''s examine the syntax more
    closely. Here is the line of code that instantiated an instance of the `Soldier`
    class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实例化了三个先前声明的类的实例（创建了一个可用的对象）。让我们更仔细地研究一下语法。这是实例化`Soldier`类的代码行：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, we decide whether we need to change our instance. As with regular variables,
    we then choose `val` or `var`. Next, we name our instance. In the preceding code,
    the object/instance is called `soldier`, but we could have called it `soldierX`,
    `marine`, `john117`, or even `squashedBanana`. The name is arbitrary, but, as
    with variables, it makes sense to call them something meaningful. Also, as with
    variables, it is convention, but not required, to use a lowercase letter at the
    start of the name and an uppercase letter for any subsequent words in the name.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们决定是否需要更改我们的实例。与常规变量一样，我们选择`val`或`var`。接下来，我们给我们的实例命名。在前面的代码中，对象/实例被称为`soldier`，但我们也可以称之为`soldierX`，`marine`，`john117`，甚至`squashedBanana`。名称是任意的，但与变量一样，给它们起一个有意义的名字是有意义的。此外，与变量一样，按照惯例，但不是必须的，以小写字母开头的名称和名称中的任何后续单词的首字母大写。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The distinction between `val` and `var` when using them to declare instances
    of classes is much more nuanced and significant. We will initially learn the details
    about classes, and in [Chapter 12](ch12.html "Chapter 12. Connecting Our Kotlin
    to the UI and Nullability"), *Connecting our Kotlin to the UI and Nullability*
    we will revisit `val` and `var` to see what is going on under the hood of our
    instances.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用它们来声明类的实例时，`val`和`var`之间的区别更加微妙和重要。我们将首先学习有关类的细节，在[第12章](ch12.html "第12章。将我们的Kotlin连接到UI和可空性")中，*将我们的Kotlin连接到UI和可空性*，我们将重新讨论`val`和`var`，以了解我们的实例底层发生了什么。
- en: The final part of the code contains the assignment operator, `=`, followed by
    the class name, `Soldier`, and an opening and closing set of brackets `()`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分包含赋值运算符`=`，后面跟着类名`Soldier`，以及一对开放和关闭的括号`()`。
- en: The assignment operator tells the Kotlin compiler to assign the result of the
    right-hand side of the code to the variable on the left. Type inference establishes
    that `soldier` is of the `Soldier` type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符告诉Kotlin编译器将代码右侧的结果赋给左侧的变量。类型推断确定`soldier`是`Soldier`类型。
- en: The curious, but perhaps familiar looking `()` after the class name implies
    that we are calling a function. We are – and it is a special function called a
    **constructor** that is provided by the Kotlin compiler. There is much to discuss
    about constructors, so we will defer the conversation to a little later in the
    chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类名后面那个看起来奇怪但也许熟悉的`()`暗示着我们在调用一个函数。我们确实在调用一个特殊的函数，称为**构造函数**，它是由Kotlin编译器提供的。关于构造函数有很多要讨论的，所以我们将把这个话题推迟到本章稍后。
- en: 'For now, all we need to know is that this next line of code creates a usable
    object of the `Soldier` type, called `soldier`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要知道，下一行代码创建了一个名为`soldier`的`Soldier`类型的可用对象：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Remember that one of the goals of OOP is that we get to reuse our code. We
    are not limited to just one object of the `Soldier` type. We can have as many
    as we choose. Have a look at this next block of code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，面向对象编程的目标之一是我们可以重用我们的代码。我们不仅限于只有一个`Soldier`类型的对象。我们可以有任意多个。看看下面的代码块：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `soldier1`, `soldier2`, and `soldier3` instances are all separate, distinct
    instances. It is true they are all the same type – but that is their only connection.
    You and your neighbor might both be human, but you are not the same human. If
    we do something to, or change something about `soldier1`, that something is only
    done to/about `soldier1`. The `soldier2` and `soldier3` instances remain unaffected.
    It is, indeed, possible to instantiate a whole army of `Soldier` objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`soldier1`，`soldier2`和`soldier3`实例都是独立的、不同的实例。它们都是同一类型 - 但这是它们唯一的联系。你和你的邻居可能都是人类，但你们不是同一个人。如果我们对`soldier1`做了什么，或者改变了`soldier1`的某些东西，那么这些操作只会影响`soldier1`。`soldier2`和`soldier3`实例不受影响。事实上，我们可以实例化一整支`Soldier`对象的军队。'
- en: The power of OOP is slowly revealing itself, but the elephant in the room at
    this stage of our discussion is that our classes don't actually *do* anything
    at all. Furthermore, our instances hold no values (data), so there is nothing
    we can change about them either.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的力量正在慢慢显现，但在我们讨论的这个阶段，房间里的大象是，我们的类实际上并没有做任何事情。此外，我们的实例不持有任何值（数据），因此我们也无法对它们进行任何更改。
- en: Classes have functions and variables (kind of)
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类有函数和变量（有点）
- en: I will explain the slightly cryptic **(kind of)** heading shortly when we get
    to the *Class variables are properties* section later in the chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章后面的*类变量是属性*部分时，我将很快解释略微神秘的**（有点）**标题。
- en: Any of the code that we learned about throughout our discussion on Kotlin can
    be used as part of a class. This is how we make our classes meaningful and our
    instances genuinely useful. Let's expand on the class declaration and add some
    variables and functions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讨论Kotlin时学到的任何代码都可以作为类的一部分使用。这就是我们使我们的类有意义，使我们的实例真正有用的方法。让我们扩展类声明并添加一些变量和函数。
- en: Using the variables of a class
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类的变量
- en: 'First, we will add some variables to our empty `Soldier` class, like in this
    next code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向我们空的`Soldier`类添加一些变量，就像下面的代码一样：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Remember, all the preceding code would go in a file named `Soldier.kt`. Now
    that we have a class declaration with some member variables, we can use them as
    shown in this next code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，所有前面的代码都将放在一个名为`Soldier.kt`的文件中。现在我们有了一个带有一些成员变量的类声明，我们可以像下面的代码中所示那样使用它们：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code, if placed in the `onCreate` function, would produce the following
    output in the logcat window:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将代码放在`onCreate`函数中，将在logcat窗口中产生以下输出：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we instantiated an instance of the `Soldier` class in
    the usual way. But now, because the `Soldier` class has some variables with values,
    we can access those values using **dot syntax**:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们以通常的方式实例化了`Soldier`类的一个实例。但现在，因为`Soldier`类有一些带有值的变量，我们可以使用**点语法**来访问这些值：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Or, we could access the values by using this specific example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过使用这个具体的例子来访问这些值：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To be clear, we use the instance name, not the class name:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要清楚的是，我们使用实例名称，而不是类名称：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As usual, there are some exceptions and variations that we will cover as we
    proceed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们将在继续进行时涵盖一些例外和变化。
- en: 'If we want to change the value of a variable, we can use the exact same dot
    syntax. Of course, if you remember back to [Chapter 7](ch07.html "Chapter 7. Kotlin
    Variables, Operators, and Expressions"), *Kotlin Variables, Operators, and Expressions*,
    variables that can be changed need to be declared as `var`, not `val`. Here is
    the `Soldier` class reworked so that we can use it slightly differently:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更改变量的值，我们可以使用完全相同的点语法。当然，如果你回想起[第7章](ch07.html "第7章 Kotlin变量、运算符和表达式")中讲到的，*Kotlin变量、运算符和表达式*，可以更改的变量需要声明为`var`，而不是`val`。这是重新设计的`Soldier`类，以便我们可以稍微不同地使用它：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can manipulate the value of the variables as if they are regular `var`
    variables by using the dot syntax:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用点语法来操纵变量的值，就像它们是常规的`var`变量一样：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code would produce the following output in the logcat window:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将在logcat窗口中产生以下输出：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding output, first we see the same three lines as before, and then
    we see three more lines indicating that Ryan is no longer missing, and has been
    promoted to `Private First Class`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，首先我们看到与之前相同的三行，然后我们看到另外三行，表明Ryan不再失踪，并且已经晋升为`列兵`。
- en: Using the functions and variables of a class
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类的函数和变量
- en: 'Now that we can give our classes data, it is time to make them even more useful
    by giving them things that they can do. To achieve this, we can give our classes
    functions. Have a look at this expanded code for the `Soldier` class. I have reverted
    the variables to `val` and highlighted the new code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以给我们的类提供数据，是时候通过给它们一些可以做的事情来使它们更有用了。为了实现这一点，我们可以给我们的类提供函数。看一下`Soldier`类的这段扩展代码。我已经将变量恢复为`val`并突出显示了新代码：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code in the `getStatus` function declares a new `String` variable called
    `status`, and initializes it using the values contained in `rank` and `name`.
    It then checks the value in `missing` with an `if` expression, and appends either
    `is missing` or `ready for duty` depending upon whether missing is `true` or `false`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`getStatus`函数中的代码声明了一个名为`status`的新`String`变量，并使用`rank`和`name`中包含的值对其进行初始化。然后，它使用`if`表达式检查`missing`中的值，并根据`missing`是`true`还是`false`附加`is
    missing`或`ready for duty`。'
- en: 'We can then use this new function as demonstrated in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以像下面的代码演示的那样使用这个新函数：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As before, we create an instance of the `Soldier` class and then use dot syntax
    on that instance to call the `getStatus` function. The preceding code would produce
    the following output in the logcat window:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们创建了`Soldier`类的一个实例，然后在该实例上使用点语法调用`getStatus`函数。前面的代码将在logcat窗口中产生以下输出：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we changed the value of `missing` to `false`, the following output would
    be produced:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`missing`的值更改为`false`，将产生以下输出：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that functions in classes can take any form that we discussed in [Chapter
    9](ch09.html "Chapter 9. Kotlin Functions"), *Kotlin Functions*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，类中的函数可以采用我们在[第9章](ch09.html "第9章 Kotlin函数")中讨论过的任何形式，*Kotlin函数*。
- en: If you are thinking that all this class stuff is great, but at the same time
    seems a little bit rigid and inflexible, you would be correct. What is the point
    of having multiple, hundreds, or thousands of `Soldier` instances if they are
    all called Ryan and they are all missing? Certainly, we have seen we can use `var`
    variables and then change them, but this could still be awkward and long-winded.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为所有这些类的东西都很棒，但同时似乎有点僵化和不灵活，那么你是正确的。如果所有`Soldier`实例都叫Ryan并且都失踪，那有什么意义呢？当然，我们已经看到我们可以使用`var`变量然后更改它们，但这可能仍然很尴尬和冗长。
- en: We need ways to better manipulate and initialize data in each instance. And,
    if we think back to the start of the chapter when we briefly discussed the topic
    of encapsulation, then we will also realize that we need to not only allow code
    to manipulate our data, but also control when and how this manipulation takes
    place.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更好地操纵和初始化每个实例中的数据的方法。如果我们回想一下本章开头时我们简要讨论了封装的主题，那么我们也会意识到我们不仅需要允许代码操纵我们的数据，还需要控制这种操纵何时以及如何进行。
- en: To gain this knowledge, we need to learn more about variables in classes, then
    a little more detail about encapsulation and visibility, and finally reveal what
    is going on with those function-like brackets `()` that we have seen at the end
    of the code when we instantiate an instance of our class.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这些知识，我们需要更多地了解类中的变量，然后更详细地了解封装和可见性，最后揭示当我们实例化类的实例时，在代码末尾看到的那些类似函数的括号`()`到底是什么意思。
- en: Class variables are properties
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类变量是属性
- en: It turns out that in Kotlin class variables are more than just plain old variables
    that we have already learned about. They are **properties**. Everything we have
    learned about how to use variables so far still holds true, but a property has
    more to it than just a value. It has **getters**, **setters**,and a special class
    variable called a **field** hidden behind the scenes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 原来在Kotlin中，类变量不仅仅是我们已经了解的普通变量。它们是**属性**。到目前为止，我们已经学到的关于如何使用变量的一切仍然成立，但是属性比值更多。它有**getter**，**setter**，以及一个特殊的类变量称为**field**隐藏在幕后。
- en: Getters and setters can be thought of as special functions that are automatically
    generated by the compiler. In fact, we have already used them without knowing
    it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Getter和setter可以被视为编译器自动生成的特殊函数。事实上，我们已经在不知情的情况下使用了它们。
- en: When we use the dot syntax on a property/variable declared in a class, Kotlin
    uses the getter to "get" the value. And when we use dot syntax to set the value,
    Kotlin uses the setter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在类中声明的属性/变量上使用点语法时，Kotlin使用getter来“获取”值。当我们使用点语法设置值时，Kotlin使用setter。
- en: The field/variable itself isn't accessed directly when we use the dot syntax
    we have just seen. The reason for this abstraction is to aid encapsulation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用刚刚看到的点语法时，并不直接访问字段/变量本身。这种抽象的原因是为了帮助封装。
- en: If you have previously done some programming in another object-oriented language
    (perhaps Java or C++) this could be confusing, but if you have used a more modern
    OOP language (perhaps C#), then this won't be entirely new to you. If Kotlin is
    your first language, then you are probably at an advantage compared to someone
    with previous experience, as you don't carry the baggage of previous learning.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前在其他面向对象的语言（也许是Java或C++）中做过一些编程，这可能会让你感到困惑，但如果你使用过更现代的面向对象语言（也许是C#），那么这对你来说不会是全新的。如果Kotlin是你的第一门语言，那么你可能比有过往经验的人更有优势，因为你不会受到以前学习的包袱。
- en: And, as you might guess, if the variable is `var` then a getter and a setter
    is provided, but if it is `val`, then just a getter is provided. Therefore, when
    the variables (which we will call properties most of the time from now on) in
    the `Soldier` class were `var` we could get and set them, but when they were `val`
    we could only get them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，你可能会猜到，如果变量是`var`，那么会提供一个getter和一个setter，但如果是`val`，那么只会提供一个getter。因此，当`Soldier`类中的变量（我们从现在开始大多数时候称之为属性）是`var`时，我们可以获取和设置它们，但当它们是`val`时，我们只能获取它们。
- en: Kotlin gives us the flexibility to **override** these getters and setters in
    order to change what happens when we get and set the value of properties and their
    associated fields.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin给了我们灵活性来**重写**这些getter和setter，以改变当我们获取和设置属性及其关联字段的值时发生的情况。
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When a property uses a field, it is called a **backing field**. As we will see,
    some properties don't require a backing field, as they can rely on the logic of
    the code in the getters and setters to make them useful.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性使用字段时，它被称为**后备字段**。正如我们将看到的，一些属性不需要后备字段，因为它们可以依赖于getter和setter中的逻辑来使它们有用。
- en: At this point, some examples using fields will make things clearer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，使用字段的一些示例将使事情更清晰。
- en: Examples using properties with their getters, setters, and fields
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用带有getter、setter和字段的属性的示例
- en: 'We can use the getters and setters to control the range of values that can
    be assigned to its backing field. For example, consider this next code being added
    to the `Soldier` class:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用getter和setter来控制可以分配给其后备字段的值范围。例如，考虑将下一行代码添加到`Soldier`类中：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code adds a new `var` property called `bullets`, and initializes
    it to 100\. Then we see some new code. The getter and the setter are overridden.
    Strip out the code from the getter and setter to see this in action in its simplest
    form:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码添加了一个名为`bullets`的新`var`属性，并将其初始化为100。然后我们看到一些新代码。getter和setter被重写了。去掉getter和setter中的代码，以便以最简单的形式看到其运行：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To be clear, the code in the getter and setter execute when we are accessing
    the value of bullet through an instance of the `Soldier` class. Take a look at
    how this might happen in this next code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 明确一点，在访问`Soldier`类的实例中的`bullet`值时，getter和setter中的代码会执行。看看下面的代码中可能会发生的情况：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, we first create an instance of the `Soldier` class, and
    then we get the value stored in the `bullet` property and print the value. This
    triggers the getter code to execute.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先创建了`Soldier`类的一个实例，然后获取存储在`bullet`属性中的值并打印出来。这触发了getter代码的执行。
- en: Next, we decrement (reduce by one) the value stored by the `bullet` property.
    Any action that attempts to change the value held by the property will trigger
    the code in the setter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们减少（减少一个）`bullet`属性存储的值。任何试图改变属性持有的值的操作都会触发setter中的代码。
- en: 'If we execute the preceding four lines of code, we will get the following output
    in the logcat window:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行前面的四行代码，将在logcat窗口中得到以下输出：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After we create a `Soldier` instance called `soldier`, we use `Log.i` to print
    the value to the logcat window. As this code accesses the value stored by the
    property, the getter code runs and prints out the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`soldier`的`Soldier`实例后，我们使用`Log.i`将值打印到logcat窗口。由于此代码访问了属性存储的值，getter代码运行并打印出以下内容：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The getter then returns the value to the `Log.i` function using this next line
    of code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后getter使用下一行代码将值返回给`Log.i`函数：
- en: '`return field`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`return field`'
- en: 'When we created the property, Kotlin created a backing field. The way that
    we access the backing field in the getter or setter is to use the name `field`.
    Therefore, the preceding line of code works the same way it would in a function
    and returns the value allowing the `Log.i` call in the calling code to print the
    value, and we will get this next line of output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建属性时，Kotlin创建了一个后备字段。在getter或setter中访问后备字段的方式是使用名称`field`。因此，前面的代码行的工作方式与在函数中的方式相同，并返回值，允许调用代码中的`Log.i`调用打印出值，我们将得到下一行输出：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next line of code is perhaps the most interesting. Here it is again for
    easy reference:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码可能是最有趣的。这里再次提供以便参考：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We might guess that this simply triggers the setter to execute, but if we examine
    the next two lines of output in the logcat, we can see that the following two
    lines of output have been generated:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会猜想这只是触发了setter的执行，但是如果我们检查logcat中的下两行输出，我们会看到生成了以下两行输出：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The action of decrementing (or incrementing) requires the use of the getter
    (to know what to decrement) and then the setter to change the value.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 减少（或增加）的操作需要使用getter（知道要减少多少）然后使用setter来改变值。
- en: Notice that the setter has a parameter named `value` that we can refer to in
    the setter's body just like a regular function parameter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，setter有一个名为`value`的参数，我们可以在setter的主体中引用它，就像普通的函数参数一样。
- en: 'Next, the instance is used to output the value held by the `bullets` property,
    and we can see that again the getter is used, and the output is generated from
    both the getter code in the class followed by the code using the instance (outside
    the class). The final two lines of output are shown again next:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实例被用来输出`bullets`属性所持有的值，我们可以看到再次使用了getter，并且输出是由类中的getter代码和实例（类外部）中的代码生成的。接下来再次显示最后两行输出：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we can look at another example of using getters and setters.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看另一个使用getter和setter的例子。
- en: 'As already mentioned, sometimes properties do not need a backing field at all.
    It is sometimes enough to allow the logic in the getters and setters to handle
    the value accessed via the property. Examine this following code that we could
    add to the `Soldier` class that demonstrates this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，有时属性根本不需要后备字段。有时，允许getter和setter中的逻辑处理通过属性访问的值就足够了。查看下面的代码，我们可以将其添加到`Soldier`类中来演示这一点：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code, we create three properties: a `var` property called
    `packWeight`, which we will change using the instance we will soon create, a `val`
    property called `gunWeight`, which we will never need to change, and another `var`
    property called `totalWeight`, which is initialized to `packWeight + gunWeight`.
    The interesting part is that we override the getter for `totalWeight` so that
    it recalculates its value using `packWeight + gunWeight`. Next, look at how we
    might use these new properties with an instance of the `Soldier` class, and then
    we will look at the output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了三个属性：一个名为`packWeight`的`var`属性，我们将使用即将创建的实例来更改它，一个名为`gunWeight`的`val`属性，我们永远不需要更改它，以及另一个名为`totalWeight`的`var`属性，它被初始化为`packWeight
    + gunWeight`。有趣的部分是，我们覆盖了`totalWeight`的getter，以便它使用`packWeight + gunWeight`重新计算其值。接下来，让我们看看如何使用`Soldier`类的实例来使用这些新属性，然后我们将看到输出：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code, we create a `Soldier` instance called `strongSoldier`.
    Next, we print the value of `totalWeight` to the logcat. The third line of code
    changes the value of `packWeight` to `300`, and then the final line of code prints
    out the value of `totalWeight`, which will use our overridden getter. Here is
    the output from those four lines of code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个名为`strongSoldier`的`Soldier`实例。接下来，我们将`totalWeight`的值打印到logcat。第三行代码将`packWeight`的值更改为`300`，然后最后一行代码打印出`totalWeight`的值，它将使用我们覆盖的getter。以下是这四行代码的输出：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can see from the output that the `totalWeight` value is entirely dependent
    on the values stored in `packWeight` and `gunWeight`. The first line of output
    is the starting value of `packWeight` (`150`) added to the value of `gunWeight`
    (`30`), and the second line of output is equal to the new value of `packWeight`
    added to `gunWeight`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，`totalWeight`的值完全取决于`packWeight`和`gunWeight`中存储的值。输出的第一行是`packWeight`的起始值（`150`）加上`gunWeight`的值（`30`），第二行输出等于`packWeight`的新值加上`gunWeight`。
- en: Just like functions, this enormously flexible system of properties will raise
    some questions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数一样，这个非常灵活的属性系统会引发一些问题。
- en: When to use overridden getters and setters
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用覆盖的getter和setter
- en: When to utilize these different techniques comes with practice and experience;
    there are no hard rules about exactly when it is appropriate for a specific technique.
    At this stage, it is just necessary to understand that variables declared in the
    body of a class (outside of a function) are actually properties, and properties
    are accessed via getters and setters. These getters and setters are not transparent
    to the user of the instance, and they are provided by default by the compiler
    unless overridden by the programmer of the class. This is the essence of encapsulation;
    the programmer of the class controls how that class works. Properties provide
    indirect access to its related value (called a backing field), although sometimes
    this backing field is not needed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 何时利用这些不同的技术需要通过实践和经验来决定；关于何时适合使用特定技术并没有硬性规定。在这个阶段，只需要理解在类的主体（函数之外）声明的变量实际上是属性，而属性是通过getter和setter访问的。这些getter和setter对于实例的用户来说并不是透明的，并且除非被类的程序员覆盖，否则编译器会默认提供它们。这就是封装的本质；类的程序员控制类的工作方式。属性提供对其相关值（称为后备字段）的间接访问，尽管有时这个后备字段是不需要的。
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is OK (and I sometimes do so) to simplify a discussion by referring to a
    property as a variable. This is especially so when the getters, setters, and field
    are not relevant to the discussion at hand.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 简化讨论时将属性称为变量是可以的（我有时这样做）。特别是当getter、setter和字段与讨论无关时。
- en: In the next section we will see more ways that we can use getters and setters,
    so let's move on to discuss visibility modifiers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到更多可以使用getter和setter的方法，所以让我们继续讨论可见性修饰符。
- en: Visibility modifiers
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可见性修饰符
- en: Visibility modifiers are used to control the access/visibility of variables,
    functions, and even whole classes. As we will see, it is possible to have variables,
    functions, and classes with different levels of access depending upon where in
    the code the access is being attempted from. This allows the designers of a class
    to practice good encapsulation and make just the functionality and data they choose
    available to users of the class. As a slightly contrived but useful example, the
    designers of a class used to talk to a satellite and get GPS data wouldn't allow
    access to the `dropOutOfTheSky` function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性修饰符用于控制变量、函数甚至整个类的访问/可见性。正如我们将看到的，根据代码中尝试访问的位置，可以有不同级别的访问权限的变量、函数和类。这允许类的设计者实践良好的封装，并且只向类的用户提供他们选择的功能和数据。举一个有点牵强但有用的例子，用于与卫星通信并获取GPS数据的类的设计者不会允许访问`dropOutOfTheSky`函数。
- en: These are the four access modifiers in Kotlin.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Kotlin中的四个访问修饰符。
- en: Public
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共
- en: Declaring classes, functions, and properties as `public` means that they are
    not hidden/encapsulated at all. In fact, the default visibility is `public` and
    everything we have seen and used so far is, therefore, public. We could make this
    explicit by using the `public` keyword before all our class, function, and property
    declarations, but it is not necessary. When something is declared `public` (or
    left at the default) no encapsulation is used. This is only occasionally what
    we want. Often the functions of a class that expose the core functionality of
    the class will be declared public.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 将类、函数和属性声明为`public`意味着它们根本不被隐藏/封装。实际上，默认可见性是`public`，因此到目前为止我们所见过和使用的一切都是公共的。我们可以通过在所有类、函数和属性声明之前使用`public`关键字来明确表示这一点，但这并不是必要的。当某物被声明为`public`（或保持默认状态）时，不使用封装。这只是偶尔我们想要的。通常，公开类的函数将公开类的核心功能。
- en: Private
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有
- en: 'The next access modifier we will discuss is `private`. Properties, functions,
    and classes can be declared `private` by prefixing the `private` keyword before
    the declaration, as shown in this next hypothetical code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的下一个访问修饰符是`private`。通过在声明之前加上`private`关键字，属性、函数和类可以被声明为`private`，如下一个假设的代码所示：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `SatelliteController` class is declared as `private`, which means that
    it is only available (can be instantiated) from within the same file. An attempt
    to instantiate an instance, perhaps from `onCreate`, would cause the following
    error:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`SatelliteController`类被声明为`private`，这意味着它只能在同一文件中使用（可以实例化）。尝试在`onCreate`中实例化一个实例可能会导致以下错误：'
- en: '![Private](img/B12806_10_01.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![Private](img/B12806_10_01.jpg)'
- en: This raises the question of whether the class can be used at all. Declaring
    a class as `private` is much less common than using one of the remaining modifiers
    that we will go on to discuss, but it does happen, and there are various techniques
    that make it a viable tactic. It is more likely, however, that a `SatelliteController`
    class would be declared with the much more accessible `public` visibility.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个问题，即类是否可以被使用。将类声明为`private`比使用我们将要讨论的剩余修饰符要少得多，但这确实会发生，并且有各种技术使其成为一种可行的策略。然而，更有可能的是，`SatelliteController`类将以更加可访问的`public`可见性进行声明。
- en: 'Moving on, we have a `private` property called `gpsCoordinates`. Assuming we
    change the `SatelliteController` class to public, we can then instantiate it and
    continue our discussion. Even when `SatelliteController` is declared (or left
    at the default) to be `public`, the private `gpsCoordinates` property is still
    not visible to instances of the class, as shown in this next screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 继续，我们有一个名为`gpsCoordinates`的`private`属性。假设我们将`SatelliteController`类更改为公共类，那么我们就可以实例化它并继续我们的讨论。即使`SatelliteController`被声明为`public`，或者保持默认状态为`public`，私有的`gpsCoordinates`属性仍然对类的实例不可见，如下一个截图所示：
- en: '![Private](img/B12806_10_02.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![Private](img/B12806_10_02.jpg)'
- en: As we can see in the preceding screenshot, the `gpsCoordinates` property is
    inaccessible because it is `private`, and, as we saw from our discussion of properties
    earlier in this chapter, when the property is left at its default it is accessible.
    The point of these access modifiers is that the designer of the class can choose
    when and what to expose. It is likely that a GPS satellite would want to share
    GPS coordinates. However, it is also very likely that it wouldn't want users of
    the class to play any part whatsoever in calculating the coordinates. This suggests
    that we would want users of the class to be able to read the data but not write/change
    it. This is an interesting situation, because a first reaction might be to make
    the property a `val` property. This way the user could get the data but couldn't
    change it. The problem with this is that GPS coordinates obviously do change,
    and it needs to be a `var` property, just not a `var` property that is changeable
    from outside the class.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中所看到的，`gpsCoordinates`属性是不可访问的，因为它是`private`的，正如我们在本章前面讨论属性时所看到的，当属性保持默认状态时，它是可访问的。这些访问修饰符的目的是，类的设计者可以选择何时以及何物来公开。很可能GPS卫星希望分享GPS坐标。然而，很可能它不希望类的用户在计算坐标方面起任何作用。这表明我们希望类的用户能够读取数据，但不能写入/更改数据。这是一个有趣的情况，因为第一反应可能是将属性设置为`val`属性。这样用户就可以获取数据，但不能更改数据。但问题是GPS坐标显然是会变化的，因此它需要是一个`var`属性，只是不希望它是一个可以从类外部更改的`var`属性。
- en: 'When we declare a property as `private`, Kotlin automatically makes the getter
    and the setter `private` too. We can change this behavior by overriding the getter
    and/or the setter. To solve our problem of needing a `var` property that is not
    changeable from outside the class, readable outside the class, and changeable
    from within the class, we would leave the default setter so it can never change
    externally, and override the getter so it can be read externally. Look at this
    re-writing of the `SatelliteController` class:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将属性声明为`private`时，Kotlin会自动将getter和setter也设为`private`。我们可以通过重写getter和/或setter来改变这种行为。为了解决我们需要一个在类外部不可改变但在类内部可改变和可读的`var`属性的问题，我们将保留默认的setter，使其无法在外部改变，并重写getter，以便在外部可读。看看下面对`SatelliteController`类的重写：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, the `SatelliteController` class and the `gpsCoordinates`
    property are `public`. Furthermore, `gpsCoordinates` is a `var` property, and
    therefore is mutable. However, look closely at the line of code after the property
    declaration, because it sets the setter to `private`, which means that code outside
    of the class can't access it to change it; but because it is a `var` property,
    code within the class can do whatever it likes to it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`SatelliteController`类和`gpsCoordinates`属性都是`public`的。此外，`gpsCoordinates`是一个`var`属性，因此是可变的。然而，仔细看一下属性声明后的代码行，因为它将setter设置为`private`，这意味着类外的代码无法访问它进行更改；但因为它是一个`var`属性，类内的代码可以对其进行任何操作。
- en: 'We could now write the following code in the `onCreate` function to use the
    class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`onCreate`函数中编写以下代码来使用该类：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that the setter is made private by the code, we cannot change the value
    from an instance, but we can happily read it, as demonstrated in the preceding
    code. Note that setters cannot have their visibility changed, but can (as we saw
    when first discussing properties) have their functionality overridden.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于代码将setter设置为私有，我们无法从实例更改值，但可以愉快地读取它，就像前面的代码演示的那样。请注意，setter不能更改其可见性，但可以（正如我们在首次讨论属性时看到的）重写其功能。
- en: 'Moving on to discuss the function of the `dropOutOfSky` function, this is `private`
    and totally inaccessible. Only code within the `SateliteController` class can
    call that function. If we want users of the class to have access to a function,
    as we have already seen, we would simply leave it at the default visibility. The
    `SatelliteController` class might have functions that look something like this
    next code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 继续讨论`dropOutOfSky`函数的功能，这是`private`且完全不可访问的。只有`SateliteController`类内部的代码才能调用该函数。如果我们希望类的用户能够访问函数，就像我们已经看到的那样，我们只需将其保留为默认可见性。`SatelliteController`类可能有类似下面代码的函数：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the previous code, a public `updateCoordinates` function was added. This
    allows the instance of the class to use the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，添加了一个公共的`updateCoordinates`函数。这允许类的实例使用以下代码：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The previous code would then trigger the execution of the `updateCoordinates`
    function, which will cause the class to internally update the property, which
    can then be accessed and provide the new value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，前面的代码将触发`updateCoordinates`函数的执行，这将导致类内部更新属性，然后可以访问并提供新值。
- en: 'This begs the question: what data should be private? The level of visibility
    that should be used can be learned partly with common sense, partly through experience,
    and partly by asking the question, "who really needs to access this data and to
    what extent?" We will be practicing these three things throughout the rest of
    the book. Here is some more hypothetical code that shows some private data and
    more private functions for the `SatelliteController` class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个问题：哪些数据应该是私有的？应该使用的可见性级别部分可以通过常识学习，部分通过经验学习，部分通过问自己这个问题：“谁真正需要访问这些数据以及在什么程度上？”我们将在本书的其余部分中练习这三件事。以下是一些更多的假设代码，显示了`SatelliteController`类的一些私有数据和更多私有函数：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, there is a new private `Boolean` property called `bigProblem`.
    It can only be accessed internally. It cannot even be read externally. There are
    three new functions, one public property called `runMaintenance`, which runs the
    two private functions, `doDiagnostics` and `calibrateSensors`. These two functions
    could access and change the value of `bigProblem` if needed. In the `runMaintenance`
    function, a check is done to see if `bigProblem` is true, and, if so, the `dropOutOfTheSky`
    function is called.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，有一个名为`bigProblem`的新私有`Boolean`属性。它只能在内部访问。甚至不能在外部读取。有三个新函数，一个名为`runMaintenance`的公共属性，它运行两个私有函数`doDiagnostics`和`calibrateSensors`。这两个函数可以访问并更改`bigProblem`的值（如果需要）。在`runMaintenance`函数中，进行了一个检查，看看`bigProblem`是否为true，如果是，则调用`dropOutOfTheSky`函数。
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Obviously, in the code for a real satellite, solutions other than dropping out
    of the sky would likely be sought first.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在真实卫星的代码中，除了掉出天空之外，可能首先会寻求其他解决方案。
- en: Let's look at the final two visibility modifiers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最后两个可见性修饰符。
- en: Protected
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受保护的
- en: When the `protected` visibility modifier is used, its effects are more nuanced
    than `public` and `private`. When a function or property is declared as `protected`,
    it is almost private – but not quite. The other key OOP topic of inheritance that
    we will explore in the next chapter allows us to write classes, and then write
    another class that inherits the functionality of that class. The `protected` modifier
    would allow functions and properties to be visible to such classes but hidden
    from all other code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`protected`可见性修饰符时，其影响比`public`和`private`更微妙。当函数或属性声明为`protected`时，它几乎是私有的
    - 但并非完全如此。我们将在下一章中探讨的另一个关键面向对象编程主题是继承，它允许我们编写类，然后编写另一个继承该类功能的类。`protected`修饰符将允许函数和属性对这些类可见，但对所有其他代码隐藏。
- en: We will explore this further throughout the book.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中进一步探讨这个问题。
- en: Internal
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部
- en: The internal modifier is nearer to public than the others. It would expose the
    property/function to any code within the same package. If you consider that some
    apps only have one package, then this is quite a loose visibility. We won't use
    it much, I just wanted to let you know about it for the sake of completeness.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 内部修饰符比其他修饰符更接近公共。它会将属性/函数暴露给同一包中的任何代码。如果考虑到一些应用程序只有一个包，那么这是相当宽松的可见性。我们不会经常使用它，我只是想让你了解一下，以便完整起见。
- en: Visibility modifiers summary
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可见性修饰符总结
- en: What we have covered, despite being several pages long, is only scratching the
    surface of visibility modifiers. The point is that they exist, and their purpose
    is to aid encapsulation and make your code less prone to bugs and more reusable.
    Combined with properties, functions, getters, and setters, Kotlin is immensely
    flexible, and we could go on all day with more examples of when and where to use
    each visibility modifier and when, where, and how to override getters and setters
    in different ways. It is much more useful to use the techniques to build working
    programs. This is what we will do throughout the book, and I will often refer
    to why we use a specific visibility modifier or why we used a getter/setter in
    a specific way. I also encourage you to do the basic classes demo app at the end
    of this chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经讨论了好几页，但我们只是触及了可见性修饰符的表面。关键是它们存在，其目的是帮助封装并使您的代码不太容易出错，并且更具可重用性。结合属性、函数、getter和setter，Kotlin非常灵活，我们可以用更多的例子来说明何时以及在何处使用每个可见性修饰符，以及何时、在何处以及如何以不同方式重写getter和setter。使用这些技术构建工作程序更有用。这是我们将在整本书中做的事情，我经常会提到为什么我们使用特定的可见性修饰符或者为什么我们以特定的方式使用getter/setter。我还鼓励您在本章末尾进行基本类演示应用。
- en: Constructors
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'Throughout this chapter we have been instantiating objects (instances of classes)
    and we have gone into some depth about the various syntax. There is one small
    part of the code we have been ignoring until now. This next code we have seen
    several times before, but I have highlighted a small part of it so we can discuss
    it further:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直在实例化对象（类的实例），并且我们已经深入讨论了各种语法。直到现在，有一小部分代码我们一直忽略。下面的代码我们以前看过几次，但我已经突出显示了一小部分，以便我们进一步讨论：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The brackets on the end of the code that initialize the object looks just like
    code from the previous chapter when we called a function (without any parameters).
    That is, in fact, exactly what is happening. When we declare a class, Kotlin provides
    (behind the scenes) a special function called a **constructor** that prepares
    the instance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 代码末尾的括号初始化对象的代码看起来就像前一章中调用函数时的代码（没有任何参数）。事实上，情况确实如此。当我们声明一个类时，Kotlin提供（在幕后）一个名为**构造函数**的特殊函数，用于准备实例。
- en: So far in this chapter, we have declared and initialized all our instances in
    a single line each. Often, we will need to use some more logic in initialization,
    and often we will need to allow the code that initializes an instance of a class
    to pass in some values (just like a function). This is the reason for constructors.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经在一行中声明和初始化了所有的实例。通常，我们需要在初始化中使用一些更多的逻辑，而且我们经常需要允许初始化类的代码传递一些值（就像一个函数）。这就是构造函数的原因。
- en: 'Often, this default constructor is all we need, and we can forget all about
    it, but sometimes we need to do more work to set up our instance so that it is
    ready for use. Kotlin allows us to declare our own constructors and gives us three
    main options: primary constructors, secondary constructors, and `init` blocks.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个默认构造函数就是我们需要的全部内容，我们可以忘记它，但有时我们需要做更多的工作来设置我们的实例，以便它准备好使用。Kotlin允许我们声明自己的构造函数，并给我们三个主要选项：主要构造函数、次要构造函数和`init`块。
- en: Primary constructors
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要构造函数
- en: 'A primary constructor is one that is declared with the class declaration. Look
    at this next code, which defines a constructor that allows the user of the class
    to pass in two values. As we have come to expect, this code would go in a file
    named `Book.kt`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 主要构造函数是在类声明中声明的构造函数。看看下面的代码，它定义了一个允许类的用户传入两个值的构造函数。正如我们所期望的那样，这段代码将放在一个名为`Book.kt`的文件中。
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code, we have declared a class called `Book` and provided a
    constructor that takes two parameters. It requires an immutable `String` value
    and a mutable `Int` value passed to it when it is initialized. Providing a constructor
    like this and then using it to instantiate an instance declares and initializes
    the `title` and `copiesSold` properties. There is no need to declare or initialize
    them in the usual way.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们声明了一个名为`Book`的类，并提供了一个接受两个参数的构造函数。当初始化时，它需要传递一个不可变的`String`值和一个可变的`Int`值。提供这样的构造函数，然后使用它来实例化一个实例，声明和初始化了`title`和`copiesSold`属性。没有必要以通常的方式声明或初始化它们。
- en: 'Look at this next code, which shows how you could instantiate an instance of
    this class:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码，它展示了如何实例化这个类的一个实例：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code, an object called `book` is instantiated using the primary
    constructor and the properties, `title` and `copiesSold`, are initialized to `Animal
    Farm` and `20000000` (twenty million) respectively.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，使用主要构造函数实例化了一个名为`book`的对象，属性`title`和`copiesSold`分别初始化为`Animal Farm`和`20000000`（两千万）。
- en: Just as with functions, you can shape constructors to have any combinations,
    types, and number of parameters.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数一样，你可以塑造构造函数，拥有任意组合、类型和数量的参数。
- en: The potential downfall of primary constructors is that the properties take their
    values from the passed in arguments without any flexibility. What if we needed
    to do some calculations with the passed in values before assigning them to the
    properties? Fortunately, there are ways we can handle this.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 主要构造函数的潜在缺点是属性从传入的参数中获取值，没有任何灵活性。如果我们需要在将它们分配给属性之前对传入的值进行一些计算怎么办？幸运的是，我们可以处理这个问题。
- en: Secondary constructors
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 次要构造函数
- en: 'A secondary constructor is one that is declared separately from the class declaration,
    but is still within the class body. A couple of things to note about secondary
    constructors is that you can''t declare properties in the parameters, and you
    must also call the primary constructor from the code of the secondary constructor.
    The advantage to a secondary constructor is that you can write some logic (code)
    to initialize your properties. Look at the following code, which shows this in
    action. We will also introduce a new keyword at the same time:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 次要构造函数是在类声明之外单独声明的构造函数，但仍然在类体内。关于次要构造函数需要注意的几件事是，你不能在参数中声明属性，而且你还必须从次要构造函数的代码中调用主要构造函数。次要构造函数的优势在于你可以编写一些逻辑（代码）来初始化你的属性。看看下面的代码，它展示了这一点。同时，我们还将介绍一个新的关键字：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code we declare a class called `Meeting`. The primary constructor
    declares two properties, one called `day` and one called `person`. Next, a property
    called `time` is declared and initialized to the value of `To be decided`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们声明了一个名为`Meeting`的类。主要构造函数声明了两个属性，一个叫做`day`，一个叫做`person`。接下来，声明了一个名为`time`的属性，并初始化为值`To
    be decided`。
- en: What follows is the secondary constructor. Notice that the parameters are preceded
    by the `constructor` keyword. You will also notice that the secondary constructor
    contains three parameters, the same two as the primary constructor and one more
    called `time`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是次要构造函数。注意参数前面有`constructor`关键字。你还会注意到，次要构造函数包含三个参数，与主要构造函数相同的两个参数，还有一个叫做`time`的参数。
- en: Note that the `time` parameter is not the same entity as the `time` property
    that was previously declared and initialized. The secondary constructor contains
    only "throw-away" parameters, they do not become persistent properties like those
    of the primary constructor. This allows us to firstly call the primary constructor
    passing in `day` and `person`, and secondly (in the body of the secondary constructor)
    assign the value passed in via the `time` parameter to the `time` property.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`time`参数与先前声明和初始化的`time`属性不是同一个实体。次要构造函数只包含“一次性”参数，它们不会成为像主构造函数那样的持久属性。这使我们首先可以调用主构造函数传递`day`和`person`，其次（在次要构造函数的主体中）将通过`time`参数传递的值分配给`time`属性。
- en: Tip
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can have multiple secondary constructors provided that the signatures are
    all different. The appropriate secondary constructor will be called by matching
    the parameters of the calling/instantiating code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提供多个次要构造函数，只要签名都不同。通过匹配调用/实例化代码的参数，将调用适当的次要构造函数。
- en: We need to talk about this
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们需要谈谈这个
- en: Literally, I mean, we need to talk about the `this` keyword. When we use `this`
    inside a class it has the effect of referring to the current instance – so it
    acts on itself.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我是说，我们需要谈谈`this`关键字。当我们在类内部使用`this`时，它会引用当前实例 - 因此它会作用于自身。
- en: Therefore the `this(day, person)` code calls the primary constructor that initializes
    the `day` and `person` properties. Furthermore, the `this.time = time` code has
    the effect of assigning the value passed in via the `time` parameter to the actual
    `time` property (`this.time`).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`this(day, person)`代码调用初始化`day`和`person`属性的主构造函数。此外，`this.time = time`代码会将通过`time`参数传递的值分配给实际的`time`属性（`this.time`）。
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just to mention in case it isn't obvious; the `Meeting` class would need additional
    functions to make it worthwhile, such as `setTime`, `getMeetingDetails`, and probably
    others to.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一句，如果不明显的话，`Meeting`类需要额外的函数才能使其有意义，比如`setTime`、`getMeetingDetails`，可能还有其他函数。
- en: Users of our class can create instances of the `Meeting` class when they don't
    know the time (via the primary constructor) or when they do know the time (via
    the secondary constructor).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户不知道时间时（通过主构造函数）或者当他们知道时间时（通过次要构造函数）可以创建`Meeting`类的实例。
- en: Using the Meeting class
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Meeting类
- en: 'We would instantiate our instances by calling either of our constructors, as
    shown in the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过调用我们的构造函数之一来实例化我们的实例，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, we initialize two instances of the `Meeting` class, one
    called `meeting` and the other called `anotherMeeting`. With the first instantiation
    we called the primary constructor because we didn't know the time and with the
    second, we called the secondary constructor because we did know the time.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们初始化了`Meeting`类的两个实例，一个叫做`meeting`，另一个叫做`anotherMeeting`。在第一次实例化时，我们调用了主构造函数，因为我们不知道时间；而在第二次实例化时，我们调用了次要构造函数，因为我们知道时间。
- en: We can have more than one secondary constructor if required, provided that they
    all call the primary constructor.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们可以有多个次要构造函数，只要它们都调用主构造函数。
- en: Init blocks
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化块
- en: 'Kotlin was designed to be a succinct language, and often there is a more succinct
    way to initialize our properties. If the class is not depending upon multiple
    different signatures, then we can stick to the more succinct primary constructor
    and provide any required initialization logic in an `init` block:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin被设计为一种简洁的语言，通常有更简洁的方法来初始化我们的属性。如果类不依赖于多个不同的签名，那么我们可以坚持使用更简洁的主构造函数，并在`init`块中提供任何必需的初始化逻辑：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: That is probably enough theory; let's use everything we have been talking about
    in a working app. Next, we will write a small app that uses classes, including
    a primary constructor and an `init` block.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是足够的理论了；让我们在一个工作应用程序中使用我们一直在谈论的一切。接下来，我们将编写一个使用类的小应用程序，包括主构造函数和`init`块。
- en: Basic classes app and using the init block
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类应用程序和使用init块
- en: You can get the completed code for this app in the code download. It is in the
    `Chapter10/Basic Classes` folder. But it is most useful to read on to create your
    own working example.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在代码下载中获取此应用程序的完整代码。它位于`Chapter10/Basic Classes`文件夹中。但是，继续阅读以创建您自己的工作示例会更有用。
- en: We will create a few different classes using what we have learned throughout
    this chapter to put the theory in to practice. We will also see our first example
    of how classes can interact with each other by passing a class as a parameter
    into the function of another class. We know how to do this in theory already,
    we just haven't seen it in practice yet.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本章学到的知识创建几个不同的类，以将理论付诸实践。我们还将看到我们的第一个示例，即类如何通过将类作为参数传递到另一个类的函数中相互交互。我们已经知道如何在理论上做到这一点，只是还没有在实践中看到它。
- en: We will also see another way to initialize our data when the class is first
    instantiated by using an `init` block.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当类首次实例化时，我们还将看到另一种初始化数据的方法，即使用`init`块。
- en: We will create a small app that plays with the idea of simulating ships, docks,
    and sea battles.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小应用程序，用于模拟船只、码头和海战的想法。
- en: Note
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The output for the apps in this chapter and the next will be just text to the
    logcat window. In [Chapter 12](ch12.html "Chapter 12. Connecting Our Kotlin to
    the UI and Nullability"), *Connecting our Kotlin to the UI and Nullability*, we
    will bring together everything we learned in the first five chapters (about the
    Android UI) and everything in the six that followed (about Kotlin) to bring our
    apps to life.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章应用程序的输出将只是文本，显示在logcat窗口中。在[第12章](ch12.html "第12章。将我们的Kotlin连接到UI和可空性")中，*将我们的Kotlin连接到UI和可空性*，我们将把我们在前五章学到的关于Android
    UI的知识和在接下来的六章中学到的关于Kotlin的知识结合起来，让我们的应用程序活起来。
- en: 'Create a project with the Empty Activity template. Call the application `Basic
    Classes`. Now we will create a new class called `Destroyer`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空活动模板创建一个名为`Basic Classes`的应用程序。现在我们将创建一个名为`Destroyer`的新类：
- en: Right-click the `com.gamecodeschool.basicclasses` (or whatever your package
    name is) folder in the project explorer window.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器窗口中右键单击`com.gamecodeschool.basicclasses`（或者您的包名）文件夹。
- en: Select **New** **|** **Kotlin File/Class**.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**新建** **|** **Kotlin文件/类**。
- en: In the **Name:** field, type `Destroyer`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**名称：**字段中，键入`Destroyer`。
- en: In the drop-down box, select **Class**.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉框中选择**类**。
- en: Click the **OK** button to add the new class to the project.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**OK**按钮将新类添加到项目中。
- en: Repeat the previous five steps and create two more classes, one called `Carrier`
    and another called `ShipYard`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复前面的五个步骤，创建另外两个类，一个叫做`Carrier`，另一个叫做`ShipYard`。
- en: The new classes are created for us with a class declaration and curly brackets
    ready for our code. The auto-generated code also includes the package declaration,
    which will be different based on your choices when you created the project. This
    is what my code looks like at this point.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类已经为我们创建了一个类声明和大括号，准备好我们的代码。自动生成的代码还包括包声明，这将根据您在创建项目时的选择而有所不同。这是我目前代码的样子。
- en: 'Inside `Destroyer.kt`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Destroyer.kt`中：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Inside `Carrier.kt`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Carrier.kt`中：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Inside `ShipYard.kt`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ShipYard.kt`中：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s start by coding the first part of the `Destroyer` class. What follows
    is the constructor, some properties, and an `init` block. Add the code to the
    project, study it, and then we will review what we have done:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写`Destroyer`类的第一部分开始。接下来是构造函数、一些属性和一个`init`块。添加代码到项目中，学习它，然后我们将回顾我们所做的事情：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first thing to notice is that the constructor receives a `String` value
    called `name`. It is not declared with a `val` or a `var` property. Therefore,
    it is not a property, it is just a regular parameter that will cease to exist
    after the initialization of the instance. We will see shortly how we can make
    use of this.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是构造函数接收一个名为`name`的`String`值。它没有声明为`val`或`var`属性。因此，它不是一个属性，只是一个在实例初始化后将不复存在的常规参数。我们很快将看到如何利用它。
- en: In the preceding code we declared some properties. Notice that most are all
    mutable `var` except `type`, which is a `String` `val` type that is initialized
    to `Destroyer`. Also notice that most are `private` access except for two.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一些属性。请注意，大多数都是可变的`var`，除了`type`，它是一个初始化为`Destroyer`的`String` `val`类型。还要注意，大多数都是`private`访问，除了两个。
- en: The `type` property is public, and therefore fully accessible via an instance
    of the class. The `name` property is also public but has a `private` setter. This
    will give access to the instance for getting the value but protect the backing
    field (value) from being altered by the instance.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`属性是公共的，因此可以通过类的实例完全访问。`name`属性也是公共的，但具有`private`的setter。这将允许实例获取值，但保护后备字段（值）不被实例更改。'
- en: The `hullIntegrity`, `ammo`, `shotPower`, and `sunk` properties are all `private`
    and inaccessible through the instance, at least, inaccessible directly. Be sure
    to make a mental note of the values assigned to and the types of these properties.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`hullIntegrity`、`ammo`、`shotPower`和`sunk`属性都是`private`的，无法通过实例直接访问。请务必记住这些属性的值和类型。'
- en: The final section of the preceding code is an `init` block, in which the `name`
    property is initialized by concatenating the type and name properties with a space
    in the middle.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的最后一部分是一个`init`块，在这个块中，`name`属性通过将类型和名称属性连接起来并在中间加上一个空格来进行初始化。
- en: 'Next, add the `takeDamage` function that follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加接下来的`takeDamage`函数：
- en: '[PRE48]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the `takeDamage` function, the `if` expression checks that the `sunk` Boolean
    is not true. If the ship isn't already sunk, then `hullIntegrity` is reduced by
    subtracting the value of `damageTaken`, which was passed in as a parameter. Therefore,
    indirectly, the instance will be affecting `hullIntegrity` even though it is `private`.
    The point is that it can only do so in a manner decided by the programmer of the
    class; in this case – us. As we will see, all the private properties will eventually
    be manipulated in some way.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在`takeDamage`函数中，`if`表达式检查`sunk`布尔值是否为false。如果船只还没有沉没，那么`hullIntegrity`将减去传入的`damageTaken`值。因此，尽管`private`，实例仍然会间接影响`hullIntegrity`。关键是它只能以程序员决定的方式来做到这一点；在这种情况下，是我们。正如我们将看到的，所有私有属性最终都将以某种方式被操作。
- en: Also, if the ship is not yet sunk, two `Log.i` calls output the damage taken
    and the remaining hull integrity information to the logcat window. Finally, in
    the not sunk scenario `(!sunk)`, a nested `if` expression checks whether `hullIntegrity`
    is less than zero. If it is, then a message is printed indicating the ship has
    been sunk, and the `sunk` Boolean is set to true.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果船还没有沉没，两个`Log.i`调用将损坏信息和剩余船体完整性信息输出到logcat窗口。最后，在未沉没的情况下`(!sunk)`，嵌套的`if`表达式检查`hullIntegrity`是否小于零。如果是，则打印一条消息表示船已经沉没，并将`sunk`布尔值设置为true。
- en: When the `damageTaken` function is called and the `sunk` variable is true, the
    `else` block will execute, and a message will be printed that the ship doesn't
    exist because it has already been sunk.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`damageTaken`函数并且`sunk`变量为true时，`else`块将执行，并打印一条消息，表示船只不存在，因为它已经沉没了。
- en: 'Next, add the `shootShell` function, which will work in conjunction with the
    `takeDamage` function. Or rather, to be more precise, the `takeDamage` function
    of one ship instance will work in conjunction with the `shootShell` function of
    other ship instances, as we will see soon:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加`shootShell`函数，它将与`takeDamage`函数一起工作。更确切地说，一个船只实例的`takeDamage`函数将与其他船只实例的`shootShell`函数一起工作，我们很快就会看到：
- en: '[PRE49]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the `shootShell` function, if the ship has any ammo, the `ammo` property
    is decreased by one, and the value of `shotPower` is returned to the calling code.
    If the ship has no ammo left (`ammo` is not greater than zero), then the value
    of `0` is returned to the calling code.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在`shootShell`函数中，如果船只有弹药，`ammo`属性将减少一个，并将`shotPower`的值返回给调用代码。如果船只没有弹药（`ammo`不大于零），则将值`0`返回给调用代码。
- en: 'Finally, for the `Destroyer` class add the `serviceShip` function, which sets
    `ammo` to `10` and `hullIntegrity` to `100` so that the ship is fully prepared
    to take damage again (via `takeDamage`) and deal damage (via `shootShell`):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`Destroyer`类添加`serviceShip`函数，将`ammo`设置为`10`，`hullIntegrity`设置为`100`，以便船只完全准备好再次承受伤害（通过`takeDamage`）并造成伤害（通过`shootShell`）：
- en: '[PRE50]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we can quickly code the `Carrier` class because it is so similar. Just
    make a note of the slight differences in the values assigned to `type` and `hullIntegrity`.
    Also notice that, instead of `ammo` and `shotPower`, we use `attacksRemaining`
    and `attackPower`. Furthermore, `shootShell` has been replaced with `launchAerialAttack`,
    which seemed more appropriate for an aircraft carrier. Add the following code
    to the `Carrier` class:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以快速编写`Carrier`类，因为它非常相似。只需注意一下分配给`type`和`hullIntegrity`的值的细微差异。还要注意，我们使用`attacksRemaining`和`attackPower`，而不是`ammo`和`shotPower`。此外，`shootShell`已被替换为`launchAerialAttack`，这似乎更适合一艘航空母舰。将以下代码添加到`Carrier`类中：
- en: '[PRE51]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The final code before we start using our new classes is the `ShipYard` class.
    It has two simple functions:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用新的类之前的最后一段代码是`ShipYard`类。它有两个简单的函数：
- en: '[PRE52]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first function, `serviceDestroyer`, takes a `Destroyer` instance as a parameter,
    and inside that function simply calls the instance's `serviceShip` function. The
    second function, `serviceCarrier`, has the same effect, but takes a `Carrier`
    instance as a parameter. While these two functions are short and simple, their
    later usage will soon reveal some quite interesting nuances to do with classes
    and their instances.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`serviceDestroyer`以`Destroyer`实例作为参数，并在该函数内部简单地调用实例的`serviceShip`函数。第二个函数`serviceCarrier`具有相同的效果，但以`Carrier`实例作为参数。虽然这两个函数很简短，但它们的后续使用很快就会揭示一些与类及其实例相关的有趣细微差别。
- en: 'Now we will create some instances and put our classes to work by simulating
    a fictional naval battle. Add this code to the `onCreate` function in the `MainActivity`
    class:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一些实例，并通过模拟一场虚构的海战来让我们的类发挥作用。将以下代码添加到`MainActivity`类的`onCreate`函数中：
- en: '[PRE53]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s review that code. The code begins by instantiating two friendly ships
    (`friendlyDestroyer` and `friendlyCarrier`) and two enemy ships (`enemyDestroyer`
    and `enemyCarrier`). In addition, a `Shipyard` instance called `friendlyShipyard`
    is also instantiated in preparation for the inevitable carnage that will follow:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下那段代码。代码首先实例化了两艘友方船只（`friendlyDestroyer`和`friendlyCarrier`）和两艘敌方船只（`enemyDestroyer`和`enemyCarrier`）。此外，还实例化了一个名为`friendlyShipyard`的`Shipyard`实例，为随之而来的不可避免的大屠杀做好准备：
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, the `friendlyDestroyer` object takes damage twice. Once from `enemyDestroyer`
    and once from `enemyCarrier`. This is achieved by the `takeDamage` function of
    `friendlyDestroyer` passing in the return value of the `shootShell` and `launchAerialAttack`
    functions, respectively, of the two enemies:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`friendlyDestroyer`对象受到两次伤害。一次来自`enemyDestroyer`，一次来自`enemyCarrier`。这是通过`friendlyDestroyer`的`takeDamage`函数传入两个敌人的`shootShell`和`launchAerialAttack`函数的返回值来实现的：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, the friendlies fight back by dealing two attacks on the `enemyCarrier`
    object, one from the `friendlyCarrier` object via `launchAerialAttack`, and one
    from the `friendlyDestroyer` object via `shootShell`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，友方部队通过对`enemyCarrier`对象进行两次攻击进行反击，一次来自`friendlyCarrier`对象通过`launchAerialAttack`，一次来自`friendlyDestroyer`对象通过`shootShell`：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The states of the two friendly ships are then output to the logcat window:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将两艘友方船只的状态输出到logcat窗口：
- en: '[PRE57]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now the appropriate function of the `Shipyard` instance is called on each of
    appropriate instances in turn. There is no `enemyShipyard` object, so they will
    not be able to repair and rearm:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，适当的`Shipyard`实例的函数依次在适当的实例上调用。没有`enemyShipyard`对象，因此它们将无法进行修复和重新武装：
- en: '[PRE58]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, the stats are printed again so that we can see the difference after a
    visit to the shipyard:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，再次打印统计数据，以便我们可以看到访问船坞后的差异：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And then, perhaps inevitably, the friendly forces finish off the enemies:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，或许是不可避免的，友方部队击败了敌人：
- en: '[PRE60]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Run the app, and then we can examine the following output in the logcat window:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，然后我们可以在logcat窗口中检查以下输出：
- en: '[PRE61]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here is the output again, this time broken up in to parts so that we can clearly
    see which code produced which lines of output.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出，这次分成几部分，以便我们清楚地看到哪些代码产生了哪些输出行。
- en: 'The friendly destroyer is attacked, leaving its hull near to breaking point:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 友好的驱逐舰遭到袭击，使其船体接近破裂点：
- en: '[PRE62]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The enemy carrier is attacked and sunk:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 敌方航空母舰遭到攻击并被击沉：
- en: '[PRE63]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The enemy carrier is attacked once more, but because it is sunk, the `else`
    block in the `takeDamage` function is executed:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 敌方航空母舰再次遭到攻击，但因为它被击沉，`takeDamage`函数中的`else`块被执行：
- en: '[PRE64]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The current ammo/available attacks stats are printed, and things are looking
    bad for the friendly forces:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的弹药/可用攻击统计数据被打印出来，友方部队的情况看起来很糟糕：
- en: '[PRE65]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A quick visit to the shipyard, and things will look much better:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 快速访问船坞，情况会好得多：
- en: '[PRE66]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Fully armed and repaired, the friendly forces finish off the remaining destroyer:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 友方部队全副武装并修复，完成了剩余驱逐舰的摧毁：
- en: '[PRE67]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Be sure to review the code and the output again if any of it doesn't seem to
    match up.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何代码或输出似乎不匹配，请务必再次查看。
- en: Introduction to references
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用介绍
- en: 'There might be a nagging thought in your mind at this point. Look at the two
    functions from the `Shipyard` class again:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 此时你可能会有一个困扰的想法。再次查看`Shipyard`类中的两个函数：
- en: '[PRE68]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When we called those functions and passed the `friendlyDestroyer` and `friendlyCarrier`
    to their appropriate `service…` function, we saw, from the before and after output,
    that the values inside the instances were changed. Usually, if we want to keep
    the result from a function, we need to use the return value. What is happening
    is that, unlike a function that has regular types as parameters, when we pass
    an instance of a class, we are really passing a **reference** to the instance
    itself – not just copies of the values within it, but the actual instance.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用那些函数并将`friendlyDestroyer`和`friendlyCarrier`传递给它们相应的`service…`函数时，我们从输出的前后看到，实例内的值已经改变了。通常，如果我们想保留函数的结果，我们需要使用返回值。发生的是，与具有常规类型参数的函数不同，当我们传递一个类的实例时，我们实际上是传递了**引用**到实例本身
    - 不仅仅是其中的值的副本，而是实际的实例。
- en: Furthermore, all the different ship-related instances were declared with `val`,
    so how did we change any of the properties at all? The short answer to this conundrum
    is that we didn't change the reference itself, just the properties within it,
    but a fuller discussion is clearly necessary.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有与船相关的不同实例都是用`val`声明的，那么我们如何改变任何属性呢？对这个谜团的简短回答是，我们并没有改变引用本身，只是其中的属性，但显然需要进行更充分的讨论。
- en: We will start our exploration of references and then dig deep into other related
    topics, such as the memory inside an Android device in [Chapter 12](ch12.html
    "Chapter 12. Connecting Our Kotlin to the UI and Nullability"), *Connecting Our
    Kotlin to the UI and Nullability*. For now, it is enough to know that, when we
    pass data to a function, if it is a class type, we are passing a reference that
    is equivalent (although not actually) to the real actual instance itself.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始探讨引用，然后深入探讨其他相关主题，比如[第12章](ch12.html "第12章。将我们的Kotlin连接到UI和可空性")中的Android设备内存，*将我们的Kotlin连接到UI和可空性*。目前，知道当我们将数据传递给函数时，如果它是一个类类型，我们传递的是一个等效的引用（虽然实际上并非如此）到真实的实例本身。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have, at last, written our first class. We have seen that we can implement
    a class in a file of the same name as the class. The class itself doesn't do anything
    until we instantiate an object/instance of the class. Once we have an instance
    of the class, we can use its special variables, called properties, and its non-private
    functions. As we proved in the Basic Classes app, every instance of a class has
    its own distinct properties, just as when you buy a car made in a factory, you
    get your very own steering wheel, satnav, and go-faster stripes. We have also
    bumped into the concept of references, which means that, when we pass an instance
    of a class to a function, the receiving function has access to the actual instance.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于写了我们的第一个类。我们已经看到我们可以在与类同名的文件中实现一个类。类本身在我们实例化一个对象/类的实例之前并不做任何事情。一旦我们有了一个类的实例，我们就可以使用它的特殊变量，称为属性，以及它的非私有函数。正如我们在基本类应用程序中证明的那样，每个类的实例都有自己独特的属性，就像当你买一辆工厂生产的汽车时，你会得到自己独特的方向盘、卫星导航和加速条纹。我们还遇到了引用的概念，这意味着当我们将一个类的实例传递给一个函数时，接收函数就可以访问实际的实例。
- en: All this information will raise more questions. OOP is like that. So, let's
    try and consolidate all this class stuff by taking a much closer look at inheritance
    in the next chapter.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都会引发更多的问题。面向对象编程就是这样。因此，让我们在下一章中通过更仔细地研究继承来巩固所有这些类的内容。
