- en: Using Kubernetes with Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java与Kubernetes
- en: In [Chapter 7](text00137.html) , *Introduction to Kubernetes* , we learned about
    the Kubernetes architecture and concepts. We know about nodes, Pods, and services.
    In this chapter, we will do some practical hands-on and deploy our Java REST service
    to a local Kubernetes cluster. For learning purposes, we will use the Minikube
    tool to create a cluster on the local machine. It's easier to learn Kubernetes
    on a local machine instead of going to the cloud in the first place. Because Minikube
    runs locally, instead of through a cloud provider, certain provider-specific features
    such as load balancers and persistent volumes, will not work out of the box. However,
    you can use `NodePort` , `HostPath` , persistent volumes and several addons such
    as DNS, or dashboard to test your apps locally before pushing to a real, production-grade
    cluster. In [Chapter 10](text00205.html) , *Deploying Java on Kubernetes in the
    Cloud* , we will run Kubernetes using **Amazon Web Services** (**AWS** ) and hosted
    Kubernetes in Google container engine.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](text00137.html)中，*Kubernetes简介*，我们了解了Kubernetes的架构和概念。我们知道节点、Pod和服务。在本章中，我们将进行一些实际的实践，并将我们的Java
    REST服务部署到本地Kubernetes集群。为了学习目的，我们将使用Minikube工具在本地机器上创建一个集群。在第一次学习时，最好在本地机器上学习Kubernetes，而不是直接去云端。因为Minikube在本地运行，而不是通过云提供商，某些特定于提供商的功能，如负载均衡器和持久卷，将无法直接使用。但是，您可以使用`NodePort`、`HostPath`、持久卷和一些插件，如DNS或仪表板，在将应用程序推送到真正的、生产级别的集群之前，在本地测试您的应用程序。在[第10章](text00205.html)中，*在云中部署Java到Kubernetes*，我们将在**Amazon
    Web Services**（**AWS**）和Google容器引擎中运行Kubernetes。
- en: 'To follow along, we will need the following tools ready:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上，我们需要准备好以下工具：
- en: '`Docker` : To build the Docker images we want to deploy'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docker`：构建我们想要部署的Docker镜像'
- en: '`minikube` : A local Kubernetes environment'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minikube`：本地Kubernetes环境'
- en: '`kubectl` : The Kubernetes command line interface'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl`：Kubernetes命令行界面'
- en: 'This chapter will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing Minikube on macOS, Windows, and Linux
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在macOS、Windows和Linux上安装Minikube
- en: Starting up the local Kubernetes cluster using Minikube
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Minikube启动本地Kubernetes集群
- en: Deploying a Java application on a local cluster
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地集群上部署Java应用程序
- en: 'Interacting with containers: scaling, autoscaling, and viewing cluster events'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与容器交互：扩展、自动扩展和查看集群事件
- en: Using the Kubernetes dashboard
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes仪表板
- en: I assume you have Docker up and running so far, so let's focus on the `minikube`
    utility. We have already mentioned `minikube` in the [Chapter 7](text00137.html)
    , *Introduction to Kubernetes;* now, we will go into some more details, starting
    with the installation process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你到目前为止已经安装并运行了Docker，所以让我们专注于`minikube`实用程序。我们已经在[第7章](text00137.html)中提到了`minikube`，*Kubernetes简介*；现在，我们将详细介绍一些内容，从安装过程开始。
- en: Installing Minikube
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Minikube
- en: The Minikube tool source code with all the documentation is available at GitHub
    at [https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube)
    .
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube工具源代码和所有文档都可以在GitHub上找到[https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube)。
- en: Installing on Mac
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mac上安装
- en: 'The following sequences of commands will download the `minikube` binary, set
    the executable flag and copy it to the `/usr/local/bin` folder, which will make
    it available in the macOS shell:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令序列将下载`minikube`二进制文件，设置可执行标志并将其复制到`/usr/local/bin`文件夹，这将使其在macOS shell中可用：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, if you use Homebrew package manager (available freely at [https://brew.sh](https://brew.sh)
    ), which is, by the way, very handy and recommended, you can just install `minikube`
    by typing:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您使用Homebrew软件包管理器（可以在[https://brew.sh](https://brew.sh)免费获得），这是非常方便和推荐的，您可以通过输入以下命令来安装`minikube`：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Installing on Windows
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装
- en: Minikube for Windows is also simply a single executable file. You can always
    find the newest version on the Minikube's site, at [https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube)
    . You just need to download the latest executable, rename it `minikube.exe` ,
    and place it in your system path to have it available from the command line.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Windows上的Minikube也只是一个可执行文件。您可以在Minikube的网站[https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube)上找到最新版本。您只需要下载最新的可执行文件，将其重命名为`minikube.exe`，并将其放在系统路径中，以便从命令行中使用。
- en: Installing on Linux
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上安装
- en: 'The installation process on Linux is identical to the macOS one. The only difference
    is the executable name. The following command will download the latest Minikube
    release, set the executable bit, and move it to the `/usr/local/bin` directory:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上的安装过程与macOS相同。唯一的区别是可执行文件的名称。以下命令将下载最新的Minikube版本，设置可执行位，并将其移动到`/usr/local/bin`目录中：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That''s all, a single Minikube and Docker is all we need to start the local
    cluster. It''s time to bring it to life:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，一个Minikube和Docker就足以启动本地集群。是时候让它活起来了：
- en: Starting up the local Kubernetes cluster
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动本地Kubernetes集群
- en: 'We''re using the local Kubernetes cluster provided by `minikube` . Start your
    cluster with:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`minikube`提供的本地Kubernetes集群。使用以下命令启动您的集群：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Minikube works on its own virtual machine. Depending on your host OS, you can
    choose between several virtualization drivers. Currently supported are `virtualbox`
    , `vmwarefusion` , `xhyve` , `hyperv` , and `kvm` (**Kernel-based virtual machine**
    ). The default VM driver is virtual box. You can override this option. This is
    the example macOS startup command line which uses `xhyve` :'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube在自己的虚拟机上运行。根据您的主机操作系统，您可以在几个虚拟化驱动程序之间进行选择。目前支持的有`virtualbox`，`vmwarefusion`，`xhyve`，`hyperv`和`kvm`（基于内核的虚拟机）。默认的VM驱动程序是virtual
    box。您可以覆盖此选项。这是使用`xhyve`的macOS启动命令行的示例：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When starting Minikube for the first time, you will see it downloading the Minikube
    ISO, so the process will take a little longer. This is, however, a one-time action.
    The Minikube configuration will be saved in the `.minikube` folder in your `home`
    directory, for example `~/.minikube` on Linux or macOS. On the first run, Minikube
    will also configure the `kubectl` command line tool (we will get back to it in
    a short while) to use the local `minikube` cluster. This setting is called a `kubectl`
    context. It determines which cluster `kubectl` is interacting with. All available
    contexts are present in the `~/.kube/config` file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首次启动Minikube时，您会看到它正在下载Minikube ISO，因此该过程将需要更长一点时间。不过，这是一次性操作。Minikube配置将保存在您的`home`目录中的`.minikube`文件夹中，例如在Linux或macOS上为`~/.minikube`。在第一次运行时，Minikube还将配置`kubectl`命令行工具（我们将在短时间内回到它）以使用本地的`minikube`集群。此设置称为`kubectl`上下文。它确定`kubectl`正在与哪个集群交互。所有可用的上下文都存在于`~/.kube/config`文件中。
- en: 'As the cluster is running now and we have the `dashboard` addon enabled by
    default, you can take a look at the (still empty) Kubernetes dashboard with the
    following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集群现在正在运行，并且我们默认启用了`dashboard`插件，您可以使用以下命令查看（仍然为空的）Kubernetes仪表板：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It will open your default browser with the URL of the cluster''s dashboard:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它将用集群仪表板的URL打开您的默认浏览器：
- en: '**![](Image00084.jpg)**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](Image00084.jpg)**'
- en: As you can see, the dashboard is empty now. If you browse to the Namespaces
    menu, you will notice that Minikube creates some namespaces, with the one available
    for our purposes named simply the default. The parts of the Minikube installation,
    such as DNS or the Dashboard, which are also running on the cluster itself, with
    separate namespaces such as kube-public and kube-system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，仪表板现在是空的。如果您浏览到命名空间菜单，您会注意到Minikube创建了一些命名空间，其中一个可用于我们的目的，简单地命名为默认。Minikube安装的部分，例如DNS或仪表板，也在集群本身上运行，具有单独的命名空间，如kube-public和kube-system。
- en: Feel free to browse the menus and sections; so far, no harm can be done, it's
    a local development cluster running nothing at the moment. We will get back to
    the dashboard in the last section of this chapter, to see how can we use it to
    deploy our services from the nice UI, if you prefer to do so, instead to using
    the shell of command line.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随意浏览菜单和部分；目前还没有造成任何伤害，这是一个本地开发集群，什么都没有运行。我们将在本章的最后一节回到仪表板，看看我们如何可以使用它来从漂亮的UI部署我们的服务，如果你更喜欢这样做，而不是使用命令行的shell。
- en: Of course, having the cluster running empty is quite useless, so we need a tool
    to manage it. While we can almost all everything using the dashboard, it's a lot
    more convenient to have a command line tool for that. `kubectl` controls the Kubernetes
    cluster. We will use the `kubectl` command line tool heavily to deploy, schedule,
    and scale our applications and microservices. The tool comes as a self-contained
    binary for Mac, Linux, and Windows. In the next section you will find installation
    instructions for different platforms.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，让集群空转是相当无用的，所以我们需要一个工具来管理它。虽然我们几乎可以使用仪表板来完成所有事情，但使用命令行工具会更方便。`kubectl`控制Kubernetes集群。我们将大量使用`kubectl`命令行工具来部署、调度和扩展我们的应用程序和微服务。该工具作为Mac、Linux和Windows的独立二进制文件提供。在下一节中，您将找到不同平台的安装说明。
- en: Installing kubectl
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装kubectl
- en: '`kubectl` is available for all major platforms. Let''s start with macOS installation.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`适用于所有主要平台。让我们从macOS安装开始。'
- en: Installing on Mac
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mac上安装
- en: 'The following sequences of command will download the `kubectl` binary, set
    the executable flag and copy it to `/usr/local/bin` folder which will make it
    available in the macOS shell:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令序列将下载`kubectl`二进制文件，设置可执行标志并将其复制到`/usr/local/bin`文件夹中，这将使其在macOS shell中可用：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Homebrew provides the most convenient way to install `kubectl` and keep it
    up to date. To install, use this command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Homebrew提供了安装`kubectl`并保持其最新的最便捷方式。要安装，请使用此命令：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To update, use the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新，请使用以下命令：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Installing on Windows
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装
- en: You can find the list of Windows `kubectl` releases on GitHub at [https://github.com/eirslett/kubectl-windows/releases](https://github.com/eirslett/kubectl-windows/releases)
    . Similar to Minikube, kubectl is just a single `.exe` file. At the time of writing
    this book it's [https://github.com/eirslett/kubectl-windows/releases/download/v1.6.3/kubectl.exe](https://github.com/eirslett/kubectl-windows/releases/download/v1.6.3/kubectl.exe)
    . You will need to download the `exe` file and place in on your system path, to
    have it available in the command line.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到Windows `kubectl`的发布列表[https://github.com/eirslett/kubectl-windows/releases](https://github.com/eirslett/kubectl-windows/releases)
    。与Minikube类似，kubectl只是一个单独的`.exe`文件。在撰写本书时，它是[https://github.com/eirslett/kubectl-windows/releases/download/v1.6.3/kubectl.exe](https://github.com/eirslett/kubectl-windows/releases/download/v1.6.3/kubectl.exe)
    。您需要下载`exe`文件并将其放在系统路径上，以便在命令行中使用。
- en: Installing on Linux
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上安装
- en: 'The installation process is, again, very similar to the macOS. The following
    commands will fetch the `kubectl` binary, give it an executable flag, and then
    move it to the `/usr/local/bin` to make it available in the shell:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程与macOS非常相似。以下命令将获取`kubectl`二进制文件，给予可执行标志，然后将其移动到`/usr/local/bin`中，以便在shell中使用：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To verify if your local cluster is up and running and `kubectl` is properly
    configured, execute the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证您的本地集群是否已启动并且`kubectl`已正确配置，请执行以下命令：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the output, you will be given basic information about the cluster, which
    includes its IP address, and running Minikube addons (we will get back to addons
    later in this chapter):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，您将获得有关集群的基本信息，包括其IP地址和运行的Minikube插件（我们将在本章后面再回到插件）：
- en: '![](Image00085.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00085.jpg)'
- en: 'To list the nodes we have running in our cluster, execute the `get nodes` command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出我们集群中正在运行的节点，执行`get nodes`命令：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Of course, this is just a single node cluster, so there is no surprise in the
    output of the previous command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个单节点集群，所以在上一个命令的输出中没有什么意外：
- en: '![](Image00086.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00086.jpg)'
- en: Our cluster is up and running; it's time to deploy our service on it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的集群已经启动运行了；现在是时候在上面部署我们的服务了。
- en: Deploying on the Kubernetes cluster
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes集群上部署
- en: We begin the process of deploying our software on the Kubernetes cluster by
    defining a service. As you remember from [Chapter 7](text00137.html) , *Introduction
    to Kubernetes* , services abstract a set of Pods as a single IP and port, allow
    simple TCP/UDP load, and allow the list of Pods to change dynamically. Let's start
    with service creation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过定义一个服务来开始在Kubernetes集群上部署我们的软件。正如您从[第7章](text00137.html) *Kubernetes简介*中记得的那样，服务将一组Pods抽象为单个IP和端口，允许简单的TCP/UDP负载，并允许Pods列表动态更改。让我们从创建服务开始。
- en: Creating a service
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务
- en: 'By default, each Pod is only accessible by its internal IP address within the
    Kubernetes cluster. To make the container accessible from outside the Kubernetes
    virtual network, we need to expose the Pod as a Kubernetes Service. To create
    a service, we are going to use the simple `.yaml` file, with a service manifest.
    YAML is a human-readable data serialization language, which is commonly used for
    configuration files. A sample service manifest for our Java `rest-example` could
    look the same as the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个Pod只能在Kubernetes集群内部通过其内部IP地址访问。为了使容器可以从Kubernetes虚拟网络外部访问，我们需要将Pod公开为Kubernetes服务。要创建一个服务，我们将使用简单的`.yaml`文件，其中包含服务清单。YAML是一种人类可读的数据序列化语言，通常用于配置文件。我们的Java
    `rest-example`的示例服务清单可能看起来与以下内容相同：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that the manifest of a service doesn''t refer to a Docker image. This
    is because, as you remember from [Chapter 7](text00137.html) , *Introduction to
    Kubernetes* , a service in Kubernetes is just an abstraction which provides a
    network connection to one or more Pods. Each service is given its own IP address
    and port, which remains constant for the lifetime of the service. Each Pod needs
    to have a specific label, to be discovered by the service, services find Pods
    to group using and labels `selectors` . In our previous example, the `selector`
    will pick up all Pods having a label `app` with the value of `rest-example` and
    a label named `tier` with a value of `backend` :'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，服务的清单不涉及Docker镜像。这是因为，正如您从[第7章](text00137.html) *Kubernetes简介*中记得的那样，Kubernetes中的服务只是一个提供网络连接给一个或多个Pod的抽象。每个服务都有自己的IP地址和端口，其在服务的生命周期内保持不变。每个Pod都需要具有特定的标签，以便服务发现，服务使用和标签`selectors`来分组查找Pods。在我们之前的示例中，`selector`将挑选出所有具有标签`app`值为`rest-example`和标签名为`tier`值为`backend`的Pods：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you remember from [Chapter 7](text00137.html) , *Introduction to Kubernetes*
    , every node in a Kubernetes cluster runs a kube-proxy process. The kube-proxy
    plays a crucial role in Kubernetes services. Its purpose is to expose a virtual
    IP for them. Since Kubernetes 1.2, the iptables proxy is the default. You have
    two options that you can use for setting up the proxy: userspace and iptables.
    Those settings refer to what actually handles the connection forwarding. In both
    cases, local iptables rules are installed to intercept outbound TCP connections
    that have a destination IP address associated with a service. There''s an important
    difference between those two modes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第7章](text00137.html)中所记得的，*Kubernetes简介*，Kubernetes集群中的每个节点都运行一个kube-proxy进程。kube-proxy在Kubernetes服务中扮演着至关重要的角色。它的目的是为它们公开虚拟IP。自Kubernetes
    1.2以来，iptables代理是默认设置。您可以使用两种选项来设置代理：用户空间和iptables。这些设置指的是实际处理连接转发的内容。在两种情况下，都会安装本地iptables规则来拦截具有与服务关联的目标IP地址的出站TCP连接。这两种模式之间有一个重要的区别：
- en: '`Proxy-mode: userspace` : In the userspace mode, the iptables rule forwards
    to a local port where kube-proxy is listening for connections. The kube-proxy,
    running in userspace, terminates the connection, establishes a new connection
    to a backend for the service, and then forwards requests to the backend and responses
    back to the local process. An advantage of the userspace mode is that because
    the connections are created from an application, if the connection is refused,
    the application can retry to a different backend.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式：用户空间：在用户空间模式下，iptables规则转发到一个本地端口，kube-proxy正在监听连接。运行在用户空间的kube-proxy终止连接，与服务的后端建立新连接，然后将请求转发到后端，并将响应返回给本地进程。用户空间模式的优势在于，因为连接是从应用程序创建的，如果连接被拒绝，应用程序可以重试到不同的后端。
- en: '`Proxy-mode: iptables` : in this mode, the iptables rules are installed to
    directly forward packets that are destined for a service to a backend for the
    service. This is more efficient than moving the packets from the kernel to kube-proxy
    and then back to the kernel so it results in higher throughput and better tail
    latency. However, unlike the userspace mode, using iptables mode makes it impossible
    to automatically retry another Pod if the one it initially selects does not respond,
    so it depends on having working readiness probes.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式：iptables：在这种模式下，iptables规则被安装直接将目的地为服务的数据包转发到服务的后端。这比将数据包从内核移动到kube-proxy然后再返回内核更有效，因此会产生更高的吞吐量和更好的尾延迟。然而，与用户空间模式不同，使用iptables模式会使得如果最初选择的Pod不响应，则无法自动重试另一个Pod，因此它依赖于工作的就绪探针。
- en: As you can see, in both cases there will be a kube-proxy binary running on the
    node. In userspace mode, it inserts itself as the proxy; in iptables mode, it
    will configure iptables rather than to proxy connections itself.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在这两种情况下，节点上都会运行kube-proxy二进制文件。在用户空间模式下，它会将自己插入为代理；在iptables模式下，它将配置iptables而不是自己代理连接。
- en: 'The service type can have the following values:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 服务类型可以具有以下值：
- en: '**NodePort** : By specifying a service type of `NodePort` , we declare to expose
    the service outside the cluster. The Kubernetes master will allocate a port from
    a flag-configured range (`default: 30000-32767` ), and each node of the cluster
    will proxy that port (the same port number on every node) into your service'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NodePort：通过指定`NodePort`服务类型，我们声明将服务暴露到集群外部。Kubernetes主节点将从配置的标志范围（默认值：30000-32767）分配一个端口，集群的每个节点将代理该端口（每个节点上的相同端口号）到您的服务。
- en: '**Load balancer** : This would create a load balancer on cloud providers which
    support external load balancers (for example, on Amazon AWS cloud). This feature
    is not available when using Minikube'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡器**：这将在支持外部负载均衡器的云提供商（例如在Amazon AWS云上）上创建负载均衡器。在使用Minikube时，此功能不可用。'
- en: '**Cluster IP** : This would expose the service only within the cluster. This
    is the default value which will be used if you don''t provide another'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cluster IP**：这将仅在集群内部公开服务。这是默认值，如果您不提供其他值，将使用此值。'
- en: 'Having our `service.yml` file ready, we can create our first Kubernetes service,
    by executing the following `kubectl` command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好我们的`service.yml`文件后，我们可以通过执行以下`kubectl`命令来创建我们的第一个Kubernetes服务：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To see if our service is created properly, we can execute the `kubectl get
    services` command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们的服务是否正确创建，我们可以执行`kubectl get services`命令：
- en: '![](Image00087.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00087.jpg)'
- en: 'We can also list other services (including the services provided by the `minikube`
    cluster itself, if you are curious) by adding the `--all-namespaces` switch:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过添加`--all-namespaces`开关来列出其他服务（包括`minikube`集群本身提供的服务，如果您感兴趣）。
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To see the details of a specific service, we use the `describe` command. Execute
    the following to see the details of our `rest-example` Java service:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 查看特定服务的详细信息，我们使用`describe`命令。执行以下命令以查看我们的`rest-example` Java服务的详细信息：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the output, we are presented with the most useful service properties, especially
    the endpoints (our internal container IP and port, just one in this case, because
    we have one Pod running in the service), service internal port, and proxied NodePort:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们呈现了最有用的服务属性，特别是端点（我们的内部容器IP和端口，在这种情况下只有一个，因为我们有一个Pod在服务中运行），服务内部端口和代理的NodePort：
- en: '![](Image00088.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00088.jpg)'
- en: 'Having all of the settings in a `.yaml` file is very convenient. Sometimes,
    though, there is a need to create a service in a more dynamic way; for example
    in some automation flows. In this case, instead of creating a `.yaml` file first,
    we can create a service manually, by providing all the parameters and options
    to the `kubectl` command itself. Before doing this, however, you will need have
    the deployment created first, because creating a service manually is just exposing
    a deployment using the `kubectl` command. After all, a service is an exposed deployment
    which, in fact, is just a set of Pods. The example of such exposure, which will
    result with service creation, looks the same as this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有设置放在`.yaml`文件中非常方便。但有时，需要以更动态的方式创建服务；例如在一些自动化流程中。在这种情况下，我们可以通过向`kubectl`命令本身提供所有参数和选项，手动创建服务，而不是首先创建`.yaml`文件。但在执行此操作之前，您需要先创建部署，因为手动创建服务只是使用`kubectl`命令公开部署。毕竟，服务是一个公开的部署，实际上只是一组Pod。这样公开的示例，将导致服务创建，看起来与这个相同：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating a deployment
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建部署
- en: 'Before creating a deployment, we need to have our Docker image ready and published
    to a registry, the same as the Docker Hub for example. Of course, it can also
    be a private repository hosted in your organization. As you remember from the
    [Chapter 7](text00137.html) , *Introduction to Kubernetes* , each Docker container
    in a Pod has its own image. By default, the kubectl process in a Pod will try
    to pull each image from the specified registry. You can change this behavior by
    specifying a value for the `imagePullPolicy` property in a deployment descriptor.
    It can have the following values:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建部署之前，我们需要准备好并发布到注册表的Docker镜像，例如Docker Hub。当然，它也可以是您组织中托管的私有存储库。正如您从[第7章](text00137.html)中记得的，*Kubernetes简介*，Pod中的每个Docker容器都有自己的镜像。默认情况下，Pod中的kubectl进程将尝试从指定的注册表中拉取每个镜像。您可以通过在部署描述符中为`imagePullPolicy`属性指定值来更改此行为。它可以具有以下值：
- en: '`IfNotPresent` : With this setting, the image will be pulled from the registry
    only if not present on the local host'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IfNotPresent`：使用此设置，仅当本地主机上不存在图像时，才会从注册表中提取图像'
- en: '`Never` : With this one, kubelet will use only local images'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Never`：使用此选项，kubelet将仅使用本地图像。'
- en: Setting `imagePullPolicy` with a value `IfNotPresent` when creating a deployment
    is useful; otherwise, Minikube will try to download the image before looking for
    an image on the local host.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建部署时，使用值`IfNotPresent`设置`imagePullPolicy`很有用；否则，Minikube将在查找本地主机上的图像之前尝试下载图像。
- en: Kubernetes uses the same syntax for images as Docker itself, including private
    registries and tags.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用与Docker本身相同的图像语法，包括私有注册表和标记。
- en: It is important that you provide a tag in the image name. Otherwise, Kubernetes
    will use the latest tag when looking for your image in a repository, the same
    as Docker does.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是您在图像名称中提供标记。否则，Kubernetes将在存储库中查找图像时使用最新标记，与Docker一样。
- en: 'Using locally built images gets a little bit tricky when working with a local
    Kubernetes cluster. Minikube runs in a separate VM, hence it will not see the
    images you''ve built locally using Docker on your machine. There''s a workaround
    for that. You can execute the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地构建图像时，与本地Kubernetes集群一起工作会有点棘手。Minikube在单独的VM中运行，因此它不会看到您在本地使用Docker在计算机上构建的图像。有一个解决方法。您可以执行以下命令：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous command will actually utilize the Docker daemon running on `minikube`
    , and build your image on the Minikube's Docker. This way, the locally built image
    will be available to the Minikube without pulling from the external registry.
    This is not very convenient, it is certainly easier to push the Docker image to
    a `remote` registry. Let's push our rest-example image into the `DockerHub` registry.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的命令实际上将利用在`minikube`上运行的Docker守护程序，并在Minikube的Docker上构建您的图像。这样，本地构建的图像将可供Minikube使用，而无需从外部注册表中提取。这并不是很方便，将Docker图像推送到`远程`注册表肯定更容易。让我们将我们的rest-example图像推送到`DockerHub`注册表。
- en: 'First, we need to log in:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要登录：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we are going to tag our image using the `docker tag` command (not that
    you will need to provide your own DockerHub username instead of `$DOCKER_HUB_USER`
    ):'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用`docker tag`命令标记我们的图像（请注意，您需要提供自己的DockerHub用户名，而不是`$DOCKER_HUB_USER`）：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The final step will be to push our image to Docker Hub using the `docker push`
    command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步将是使用`docker push`命令将我们的图像推送到Docker Hub：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have an image available in the registry, we need a deployment manifest.
    It''s again a `.yaml` file, which can look the same as this:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在注册表中有一个可用的图像，我们需要一个部署清单。这又是一个`.yaml`文件，看起来可能与此相同：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To create this deployment on the cluster using `kubectl` , you will need to
    execute the following command, which is exactly the same as when creating a service,
    with a difference in the filename:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群上使用`kubectl`创建此部署，您需要执行以下命令，与创建服务时完全相同，只是文件名不同：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](Image00089.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: ！[](Image00089.jpg)
- en: 'You can look at the deployment properties with:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看部署属性：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](Image00090.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: ！[](Image00090.jpg)
- en: 'As you can see, one Pod has been created along with a ReplicaSet and the default
    rolling update strategy. You can also look at the Pods with:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，已创建一个Pod以及一个ReplicaSet和默认的滚动更新策略。您还可以查看Pods：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of `get pods` command will give you the names of Pods running in
    the deployment. This is will be important later, because if you want to interact
    with a specific Pod, you will need to know its name:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`get pods`命令的输出将给出部署中运行的Pod的名称。稍后这将很重要，因为如果要与特定的Pod交互，您需要知道其名称：'
- en: '![](Image00091.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: ！[](Image00091.jpg)
- en: 'As an alternative to the deployment descriptor in `.yaml` file, you can create
    deployments from the command line using `kubectl run` command with options, as
    you can see in the following example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`.yaml`文件中部署描述符的替代方案，您可以使用`kubectl run`命令和选项从命令行创建部署，如下例所示：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s summarize the `kubectl` commands related to creating resources and getting
    information about them, with some examples, in a table:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下与创建资源和获取有关它们的信息相关的`kubectl`命令，以及一些示例，放在表中：
- en: '| **Example command** | **Meaning** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **示例命令** | **意义** |'
- en: '| `kubectl create -f ./service.yaml` | Create resource(s) |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl create -f ./service.yaml` | 创建资源 |'
- en: '| `kubectl create -f ./service.yaml -f ./deployment.yaml` | Create from multiple
    files |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl create -f ./service.yaml -f ./deployment.yaml` | 从多个文件创建 |'
- en: '| `kubectl create -f ./dir` | Create resource(s) in all manifest files in the
    specified directory |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl create -f ./dir` | 在指定目录中的所有清单文件中创建资源 |'
- en: '| `kubectl create -f https://sampleUrl` | Create resource(s) from URL |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl create -f https://sampleUrl` | 从URL创建资源 |'
- en: '| `kubectl run nginx --image=nginx` | Start a single instance of nginx |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl run nginx --image=nginx` | 启动nginx的单个实例 |'
- en: '| `Kubectl get pods` | Get the documentation for `pod` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `Kubectl get pods` | 获取`pod`的文档 |'
- en: '| `kubectl get pods --selector=app=rest-example` | List all the Pods that match
    the specified label `selector` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl get pods --selector=app=rest-example` | 列出与指定标签`selector`匹配的所有Pod
    |'
- en: '| `kubectl explain pods` | Show details of all Pods |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl explain pods` | 显示所有Pod的详细信息 |'
- en: '| `kubectl get services` | List all created services |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl get services` | 列出所有已创建的服务 |'
- en: '| `kubectl explain service` | Show details of specified service |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl explain service` | 显示指定服务的详细信息 |'
- en: '| `kubectl explain services` | Show details of all created services |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl explain services` | 显示所有已创建服务的详细信息 |'
- en: '| `kubectl get deployments` | List all created deployments |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl get deployments` | 列出所有已创建的部署 |'
- en: '| `kubectl get deployment` | Show details of specified service |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl get deployment` | 显示指定服务的详细信息 |'
- en: '| `kubectl explain deployment` | Show details of specified deployment |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl explain deployment` | 显示指定部署的详细信息 |'
- en: '| `kubectl explain deployments` | Show details of all created deployments |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl explain deployments` | 显示所有已创建部署的详细信息 |'
- en: '| `kubectl get nodes` | List all cluster nodes |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl get nodes` | 列出所有集群节点 |'
- en: '| `kubectl explain node` | Show details of specified node |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl explain node` | 显示指定节点的详细信息 |'
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As we have seen on the `kubectl` describe service `rest-example` command output,
    our `rest-example service` can be accessed within the cluster via port `8080`
    and the domain name `rest-example` . In our case, the complete URL of the endpoint
    would be `http://rest-example:8080` . However, to be able to execute the service
    from the outside world, we have used the `NodePort` mapping, and we know that
    it was given the port `31141` . All we need to call the service is the IP of the
    cluster. We can get it using the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`kubectl describe service rest-example`命令输出中所看到的，我们的`rest-example service`可以通过端口`8080`和域名`rest-example`在集群内部访问。在我们的情况下，端点的完整URL将是`http://rest-example:8080`。然而，为了能够从外部世界执行服务，我们使用了`NodePort`映射，并且我们知道它被赋予了端口`31141`。我们所需要的只是集群的IP来调用服务。我们可以使用以下命令获取它：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There''s a shortcut for getting to know the externally accessible service URL
    and a port number. We can use a `minikube service` command to tell us the exact
    service address:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个快捷方式可以了解外部可访问的服务URL和端口号。我们可以使用`minikube service`命令来告诉我们确切的服务地址：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The output of the previous command will be the service URL with a mapped port
    number. If you skip the `--url` switch, `minikube` will just open the service's
    URL using your default web browser. This is sometimes handy.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出将是带有映射端口号的服务URL。如果您跳过`--url`开关，`minikube`将只是使用您的默认Web浏览器打开服务的URL。这有时很方便。
- en: 'Having the complete URL of the endpoint, we can access the service, using any
    of the `HTTP` clients, such as `curl` , for example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有端点的完整URL后，我们可以使用任何`HTTP`客户端（例如`curl`）访问服务：
- en: '![](Image00092.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00092.jpg)'
- en: When the service is running, application logs can often help you understand
    what is happening inside your cluster. The logs are particularly useful for debugging
    problems and monitoring cluster activity. Let's see how we can access our container
    logs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务运行时，应用程序日志通常可以帮助您了解集群内部发生了什么。日志对于调试问题和监视集群活动特别有用。让我们看看如何访问我们的容器日志。
- en: Interacting with containers and viewing logs
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与容器交互和查看日志
- en: Most modern applications have some kind of logging mechanism. Our Java REST
    service, for example, uses slf4j to output logs from the REST controller. The
    easiest and most simple logging method for containerized applications is just
    to write to the standard output and standard error streams. Kubernetes supports
    this out of the box.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代应用程序都有某种日志记录机制。例如，我们的Java REST服务使用slf4j从REST控制器输出日志。容器化应用程序最简单和最简单的日志记录方法就是写入标准输出和标准错误流。Kubernetes支持这一点。
- en: 'Assuming we''ve sent requests to our new web service using the browser or curl,
    we should now be able to see some logs. Prior to that, we need to have a Pods
    name, created automatically during deployment. To get the Pod''s name, use the
    `kubectl get pods` command. After that, you can show logs of the specified Pod:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经使用浏览器或curl向我们的新Web服务发送了请求，现在应该能够看到一些日志。在此之前，我们需要有一个Pod的名称，在部署过程中会自动创建。要获取Pod的名称，请使用`kubectl
    get pods`命令。之后，您可以显示指定Pod的日志：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see in the following screenshot, we will get access to a well-known
    Spring Boot banner coming from a service running in a Pod:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下截图中所见，我们将访问来自Pod中运行的服务的著名Spring Boot横幅：
- en: '![](Image00093.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00093.jpg)'
- en: 'Viewing the log is not the only thing we can do with a specific Pod. Similar
    to Docker (a Pod is running Docker, actually), we can interact with a container
    by using the `kubectl exec` command. For example, to get a shell to the running
    container:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 查看日志并不是我们可以对特定Pod进行的唯一操作。与Docker类似（实际上，Pod正在运行Docker），我们可以使用`kubectl exec`命令与容器进行交互。例如，要获取正在运行的容器的shell：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The previous command will attach your shell console into the shell in the running
    container, where you can interact with it, such as listing the processes, for
    example, as you can see in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令将把您的shell控制台附加到正在运行的容器中的shell，您可以与之交互，例如列出进程，就像您在以下截图中所见的那样：
- en: '![](Image00094.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00094.jpg)'
- en: 'The syntax of a `kubectl exec` command is very similar to the `exec` command
    in Docker, with one little difference, as you remember from the [Chapter 7](text00137.html)
    , *Introduction to Kubernetes* , a Pod can run more than one container. In such
    case, we can use `--container` or `-c` command switch to specify a container in
    the `kubectl exec` command. For example, let''s suppose we have a Pod named `rest-example-3660361385-gkzb8`
    . This Pod has two containers named service and database. The following command
    would open a shell to the service container:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl exec`命令的语法与Docker中的`exec`命令非常相似，只有一个小差别，正如您从[第7章](text00137.html)中所记得的，*Kubernetes简介*，一个Pod可以运行多个容器。在这种情况下，我们可以使用`--container`或`-c`命令开关来指定`kubectl
    exec`命令中的容器。例如，假设我们有一个名为`rest-example-3660361385-gkzb8`的Pod。这个Pod有两个名为service和database的容器。以下命令将打开一个shell到service容器：'
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Having the possibility to view logs and interact with the containers gives
    you a lot of flexibility to pinpoint potential problems you may have with running
    Pods. Let''s summarize the `kubectl` commands related to viewing logs and interacting
    with the Pods in a table:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有查看日志和与容器交互的可能性为您提供了很大的灵活性，可以准确定位您在运行 Pod 时可能遇到的问题。让我们总结与查看日志和与 Pod 交互相关的 `kubectl`
    命令表：
- en: '| **Example command** | **Meaning** |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **示例命令** | **意义** |'
- en: '| `kubectl logs myPod` | Dump `pod` logs (`stdout` ) |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl logs myPod` | 转储 pod 日志（stdout） |'
- en: '| `kubectl logs myPod -c myContainer` | Dump `pod` container logs (`stdout`
    , multi-container case) |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl logs myPod -c myContainer` | 转储 pod 容器日志（stdout，多容器情况） |'
- en: '| `kubectl logs -f myPod` | Stream `pod` logs (`stdout` ) |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl logs -f myPod` | 流式传输 pod 日志（stdout） |'
- en: '| `kubectl logs -f myPod -c myContainer` | Stream `pod` container logs (`stdout`
    , multi-container case) |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl logs -f myPod -c myContainer` | 流式传输 pod 容器日志（stdout，多容器情况） |'
- en: '| `kubectl run -i --tty busybox --image=busybox -- sh` | `run pod` as interactive
    shell |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl run -i --tty busybox --image=busybox -- sh` | 以交互式 shell 运行 pod
    |'
- en: '| `kubectl attach myPod -i` | Attach to running container |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl attach myPod -i` | 连接到正在运行的容器 |'
- en: '| `kubectl port-forward myPod 8080:8090` | Forward port `8080` of Pod to your
    to `8090` on your local machine |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl port-forward myPod 8080:8090` | 将 Pod 的端口 `8080` 转发到本地机器上的 `8090`
    |'
- en: '| `kubectl exec myPod -- ls /` | `run` command in existing `pod` (one container
    case) |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl exec myPod -- ls /` | 在现有 pod 中运行命令（单容器情况） |'
- en: '| `kubectl exec myPod -c myContainer -- ls /` | `run` command in existing `pod`
    (multi-container case) |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl exec myPod -c myContainer -- ls /` | 在现有 pod 中运行命令（多容器情况） |'
- en: '| `kubectl top pod POD_NAME --containers` | Show metrics for a given `pod`
    and its containers |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl top pod POD_NAME --containers` | 显示给定 pod 及其容器的指标 |'
- en: As you already know, Pods and containers are fragile. They can crash or be killed.
    You can use `kubectl` logs to retrieve logs from a previous instantiation of a
    container with the `--previous` flag, in case the container has crashed. Let's
    say our service is running fine, but for the reasons described in the [Chapter
    7](text00137.html) , *Introduction to Kubernetes* , such as higher load, for example,
    you decide to increase the number of containers running. Kubernetes gives you
    the possibility to increase the number of Pod instances running in each service.
    This can be done manually or automatically. Let's focus on the manual scaling
    first.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的那样，Pod 和容器是脆弱的。它们可能会崩溃或被杀死。您可以使用 `kubectl` logs 命令检索具有 `--previous`
    标志的容器的先前实例化的日志，以防容器崩溃。假设我们的服务运行良好，但由于[第7章](text00137.html) *Kubernetes 简介* 中描述的原因，例如更高的负载，您决定增加运行的容器数量。Kubernetes
    允许您增加每个服务运行的 Pod 实例的数量。这可以手动或自动完成。让我们首先关注手动扩展。
- en: Scaling manually
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动扩展
- en: When the deployment has been created, the new ReplicaSet has also been created,
    automatically. As you will remember from [Chapter 7](text00137.html) , *Introduction
    to Kubernetes* , a ReplicaSet ensures that a specified number of Pod clones, known
    as `replicas` , are running at any given time. It there are too many, some of
    them will be shut down. If there is a need for more, for example if some of them
    died because of an error or crash, new Pods will be created. Note that if you
    try to scale the ReplicaSet directly, then it will (for a very short time) have
    a new count of your desired number of Pods, for example three. But if the deployment
    controller sees that you have modified the replica set to three, since it knows
    that it is supposed to be one (defined in the deployment manifest), it will reset
    it back to one. By manually modifying the replica set that was created for you,
    you are, kind of, dealing against the system controller.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 部署创建后，新的ReplicaSet也会自动创建。正如您在[第7章](text00137.html) *Kubernetes简介*中所记得的那样，ReplicaSet确保在任何给定时间运行指定数量的Pod克隆，称为`副本`。如果太多，其中一些将被关闭。如果需要更多，例如如果其中一些因错误或崩溃而死亡，将创建新的Pod。请注意，如果尝试直接扩展ReplicaSet，那么它将（在很短的时间内）具有所需的Pod数量，例如三个。但是，如果部署控制器看到您已将副本集修改为三个，因为它知道应该是一个（在部署清单中定义），它将将其重置为一个。通过手动修改为您创建的副本集，您有点违背了系统控制器。
- en: You need to scale your deployment instead of the replica set directly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 需要扩展部署而不是直接扩展副本集。
- en: 'Of course, our Java `rest-example` service keeps its data in memory so it''s
    not stateless, so it may be not the best example for scaling; if another instance
    is brought to life, it will have its own data. However, it is a Kubernetes service,
    so we can use it to demonstrate scaling anyway. To scale up our `rest-example`
    deployment from one up to three Pods, execute the following `kubectl scale` command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的Java `rest-example`服务将数据保存在内存中，因此它不是无状态的，因此它可能不是扩展的最佳示例；如果另一个实例被启动，它将拥有自己的数据。但是，它是一个Kubernetes服务，因此我们可以使用它来演示扩展。要将我们的`rest-example`部署从一个扩展到三个Pod，请执行以下`kubectl
    scale`命令：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After a short while, in order to check, execute the following commands, you
    will see that now three Pods are running in the deployment:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 过一段时间，为了检查，执行以下命令，您将看到部署中现在运行着三个Pod：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the following table, you can see some more examples of `kubectl` commands
    related to manual scaling:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下表中，您可以看到与手动扩展相关的一些`kubectl`命令的更多示例：
- en: '| **Example command** | **Meaning** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **示例命令** | **意义** |'
- en: '| `kubectl scale deployment rest-example --replicas=3` | Scale a deployment
    named `rest-example` to `3` Pods |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl scale deployment rest-example --replicas=3` | 将名为`rest-example`的部署扩展到`3`个Pod
    |'
- en: '| `kubectl scale --replicas=3 -f deployment.yaml` | Scale a resource specified
    in `deployment.yaml` file to `3` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl scale --replicas=3 -f deployment.yaml` | 将`deployment.yaml`文件中指定的资源扩展到`3`
    |'
- en: '| `kubectl scale deployment rest-example --current-replicas=2 --replicas=3`
    | If the deployment named `rest-example` current size is `2` , scale it to `3`
    Pods |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl scale deployment rest-example --current-replicas=2 --replicas=3`
    | 如果名为`rest-example`的部署当前大小为`2`，则将其扩展到`3`个Pod |'
- en: '| `kubectl scale --replicas=5 deployment/foo deployment/bar` | Scale multiple
    deployments at one time |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl scale --replicas=5 deployment/foo deployment/bar` | 一次扩展多个部署 |'
- en: Scaling can be done automatically by Kubernetes, if, for example, the service
    load increases.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务负载增加，Kubernetes可以自动进行扩展。
- en: Autoscaling
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动缩放
- en: With horizontal Pod auto scaling, Kubernetes automatically scales the number
    of Pods in a deployment or ReplicaSet based on observed CPU utilization. The Kubernetes
    controller periodically adjusts the number of Pod `replicas` in a deployment to
    match the observed average CPU utilization to the target you specified.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过水平Pod自动缩放，Kubernetes根据观察到的CPU利用率自动调整部署或ReplicaSet中Pod的数量。Kubernetes控制器定期调整部署中Pod“副本”的数量，以匹配观察到的平均CPU利用率与您指定的目标。
- en: 'The Horizontal Auto Scaler is just another type of resource in Kubernetes,
    so we can create it as any other resource, using the `kubectl` commands:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 水平自动缩放器只是Kubernetes中的另一种资源类型，因此我们可以像创建其他资源一样使用`kubectl`命令创建它：
- en: '`kubectl get hpa` : List autoscalers'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl get hpa`：列出自动缩放器'
- en: '`kubectl describe hpa` : Get detailed description'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl describe hpa`：获取详细描述'
- en: '`kubectl delete hpa` : Delete an autoscaler'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl delete hpa`：删除自动缩放器'
- en: 'Additionally, there is a special `kubectl autoscale` command for easy creation
    of a Horizontal Pod Autoscaler. An example could be:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个特殊的`kubectl autoscale`命令，用于轻松创建水平Pod自动缩放器。一个示例可能是：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The previous command will create an autoscaler for our `rest-example` deployment,
    with the target CPU utilization set to `5 0` % and the number of `replicas` between
    `1` and `10` .
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令将为我们的`rest-example`部署创建一个自动缩放器，目标CPU利用率设置为`50%`，`副本`数量在`1`和`10`之间。
- en: All cluster events are being registered, including those which come from scaling,
    either manually or automatically. Viewing cluster events can be helpful when monitoring
    what exactly is being performed on our cluster.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集群事件都被注册，包括手动或自动缩放产生的事件。查看集群事件在监视我们的集群上执行的确切操作时可能会有所帮助。
- en: Viewing cluster events
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看集群事件
- en: 'To view cluster events, type the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 查看集群事件，请输入以下命令：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It will present a huge table, with all the events registered on the cluster:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 它将呈现一个巨大的表格，其中包含集群上注册的所有事件：
- en: '![](Image00095.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00095.jpg)'
- en: The table will include the changes in the status of nodes, pulling Docker images,
    events of starting and stopping containers, and so on. It can be very handy to
    see the picture of the whole cluster.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 表格将包括节点状态的更改，拉取Docker镜像，启动和停止容器等事件。查看整个集群的情况非常方便。
- en: Using the Kubernetes dashboard
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes仪表板
- en: Kubernetes dashboard is a general purpose, web-based UI for Kubernetes clusters.
    It allows users to manage applications running in the cluster and troubleshoot
    them, as well as manage the cluster itself. We can also edit the manifest files
    of deployment, services, or Pods. The changes will be picked up immediately by
    Kubernetes, so it gives us the capability to scale down or up the deployment,
    for example.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes仪表板是Kubernetes集群的通用、基于Web的UI。它允许用户管理运行在集群中的应用程序并对其进行故障排除，以及管理集群本身。我们还可以编辑部署、服务或Pod的清单文件。更改将立即被Kubernetes接管，因此它使我们能够扩展或缩减部署，例如。
- en: 'If you open the dashboard with the `minikube dashboard` command, it will open
    your default browser with a dashboard URL. From here, you can list all the resources
    on the cluster, such as deployments, services, Pods, and so on. Our dashboard
    is no longer empty, as you can see in the following screenshot; we have one deployment
    called `rest-example` :'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`minikube dashboard`命令打开仪表板，它将在默认浏览器中打开一个仪表板URL。从这里，您可以列出集群上的所有资源，例如部署、服务、Pod等。正如您在下面的屏幕截图中所看到的，我们的仪表板不再是空的；我们有一个名为`rest-example`的部署：
- en: '![](Image00096.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00096.jpg)'
- en: 'If you click on its name, you will be taken to the deployment details page,
    which will show the same information you could get with the `kubectl describe
    deployment` command, with a nice UI:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击它的名称，您将进入部署详细信息页面，它将显示您可以使用`kubectl describe deployment`命令获取的相同信息，但具有良好的UI：
- en: '![](Image00097.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00097.jpg)'
- en: 'The dashboard is not only read-only utility. Each resource has a handy menu
    which you can use to delete it or to edit its manifest:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板不仅是只读实用程序。每个资源都有一个方便的菜单，您可以使用它来删除或编辑其清单：
- en: '![](Image00098.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00098.jpg)'
- en: 'If you pick the view/edit YAML menu option, you will be able to edit the manifest
    with a handy editor:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择查看/编辑YAML菜单选项，您将能够使用方便的编辑器编辑清单：
- en: '![](Image00099.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00099.jpg)'
- en: Note that if you change a value, for example the number of `replicas` , and
    click Update , the change will be sent to the Kubernetes and executed. This way
    you can also, for example, scale your deployment.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您更改一个值，例如`replicas`的数量，并单击“更新”，更改将被发送到Kubernetes并执行。这样，您也可以例如扩展您的部署。
- en: 'As deployment has created a ReplicaSet automatically, the ReplicaSet will also
    be visible in the dashboard:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于部署已自动创建了一个ReplicaSet，因此ReplicaSet也将显示在仪表板上：
- en: '![](Image00100.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00100.jpg)'
- en: 'The same applies to services. If you browse to the Services menu, it will present
    a list of all services created on a cluster:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 服务也是一样的。如果您浏览到服务菜单，它将显示在集群上创建的所有服务的列表：
- en: '![](Image00101.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00101.jpg)'
- en: 'Clicking on the name of service will take you to the details page:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 单击服务名称将带您转到详细信息页面：
- en: '![](Image00102.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00102.jpg)'
- en: 'On the details screen, all important information is listed. This includes label
    selector, that will be used to find Pods, port type, cluster IP, internal endpoints,
    and of course the list of Pods running inside the service. By clicking Pod''s
    name, you can see details of a running Pod, including its log output, as you can
    see in the following screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细信息屏幕上，列出了所有重要信息。这包括标签选择器，用于查找Pod的端口类型，集群IP，内部端点，当然还有运行在服务内部的Pod的列表。通过单击Pod的名称，您可以查看正在运行的Pod的详细信息，包括其日志输出，如下面的屏幕截图所示：
- en: '![](Image00103.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00103.jpg)'
- en: 'The dashboard is a very handy tool to interact with your existing deployments,
    services, and Pods. But there''s more. If you click on the Create button in the
    top right corner of the dashboard''s toolbar, you will be presented with a Deploy
    a Containerized App screen. From here, you can actually create a new deployment:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板是一个非常方便的工具，可以与现有的部署、服务和Pod进行交互。但还有更多。如果您单击仪表板工具栏右上角的“创建”按钮，将显示一个“部署容器化应用程序”屏幕。从这里，您实际上可以创建一个新的部署：
- en: '![](Image00104.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00104.jpg)'
- en: You have an opportunity to use the `.yaml` file, as we did before using the
    command line, but also you can specify details of the deployment manually, providing
    an application name, and container image to use and optionally create a service
    for the deployment. Quite handy, isn't it? The dashboard is just one of the Minikube
    add-ons available. Let's look at what else we have at our disposal.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您有机会使用`.yaml`文件，就像我们之前使用命令行一样，但是您还可以手动指定部署的详细信息，提供应用程序名称，并且可以选择创建一个服务用于部署。相当方便，不是吗？仪表板只是Minikube可用的插件之一。让我们看看我们还有什么可以使用。
- en: Minikube addons
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Minikube插件
- en: 'Minikube comes with several add-ons, such as Kubernetes dashboard, Kubernetes
    DNS, and so on. We can list the available addons by executing the following command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube带有几个插件，例如Kubernetes仪表板，Kubernetes DNS等。我们可以通过执行以下命令列出可用的插件：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output of the previous command will list the available addons with their
    current status, for example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出将列出可用的插件及其当前状态，例如：
- en: '![](Image00105.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00105.jpg)'
- en: 'To enable or disable the addon, we use `minikube addons disable` or `minikube
    addons enable` , respectively, for example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用或禁用插件，我们使用`minikube addons disable`或`minikube addons enable`，例如：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the add-on is enabled, we can the corresponding web user interface by executing
    the `addon open` command, for example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插件已启用，我们可以通过执行`addon open`命令打开相应的Web用户界面，例如：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Cleaning up
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: 'If you finish playing with your deployment and services or would like to start
    from the beginning, you can do some cluster cleaning by removing the deployment
    or services:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您完成了部署和服务的操作，或者想要从头开始，您可以通过删除部署或服务来清理集群：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This code can also be combined in one command, for example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也可以合并成一个命令，例如：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `kubectl delete` supports label `selectors` and namespaces. Let''s see
    some other examples of the command in a table:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl delete`支持标签`selectors`和命名空间。让我们在表中看一些命令的其他示例：'
- en: '| **Example command** | **Meaning** |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **示例命令** | **含义** |'
- en: '| `kubectl delete pod,service baz foo` | Delete pods and services with same
    names `baz` and `foo` |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl delete pod,service baz foo` | 删除具有相同名称`baz`和`foo`的pod和服务 |'
- en: '| `kubectl delete pods,services -l name=myLabel` | Delete pods and services
    with label `name=myLabel` |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl delete pods,services -l name=myLabel` | 删除具有标签`name=myLabel`的pod和服务
    |'
- en: '| `kubectl -n my-ns delete po,svc --all` | Delete all pods and services in
    namespace `my-ns` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `kubectl -n my-ns delete po,svc --all` | 删除命名空间`my-ns`中的所有pod和服务 |'
- en: 'To stop the `minikube` cluster, issue simply:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止`minikube`集群，只需发出：
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you would like to delete the current `minikube` cluster, you can issue the
    following command to do it:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要删除当前的`minikube`集群，可以发出以下命令来执行：
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As you can see, the Minikube is an easy way to try out Kubernetes and use it
    for local development. Running the local cluster is not as scary as it may have
    seemed at the beginning. Best of all, the local `minikube` cluster is a valid
    Kubernetes cluster. If you get to know Kubernetes by playing with it locally,
    you will be able to deploy your applications in the real cloud without any issues.
    Let's summarize the steps that we need to perform to make our Java application
    run on the Kubernetes cluster.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Minikube是尝试Kubernetes并在本地开发中使用它的简单方法。运行本地集群并不像开始时看起来那么可怕。最重要的是，本地的`minikube`集群是一个有效的Kubernetes集群。如果您通过在本地玩耍来了解Kubernetes，您将能够在真实的云中部署您的应用程序而不会遇到任何问题。让我们总结一下我们需要执行的步骤，以使我们的Java应用程序在Kubernetes集群上运行。
- en: 'First, we need to write some code for our microservice. This can be based on
    whatever you want, it can be a microservice running on Tomcat, JBoss, or Spring
    Bootstrap. It doesn''t matter, you just choose the technology you want your software
    to run with:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的微服务编写一些代码。这可以基于您想要的任何内容，可以是在Tomcat、JBoss或Spring Bootstrap上运行的微服务。没关系，您只需选择您希望软件运行的技术：
- en: Next, put the code into Docker image. You can do it by hand by creating a Dockerfile
    or you can use Docker Maven plugin to automate this
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，将代码放入Docker镜像中。您可以通过手动创建Dockerfile来完成，也可以使用Docker Maven插件来自动化此过程
- en: Create Kubernetes metadata, such as deployment manifest and service manifest
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Kubernetes元数据，如部署清单和服务清单
- en: Apply the metadata by rolling out the deployment and creating the service
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过部署和创建服务来应用元数据
- en: Scale your applications to your needs
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据您的需求扩展您的应用程序
- en: Manage your cluster either from the command line or from the dashboard
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行或仪表板管理您的集群
- en: In [Chapter 9](text00180.html) , *Working with Kubernetes API* , we will take
    a look at the Kubernetes API. This is a great way of interacting with Kubernetes
    cluster. Because of API, the possibilities are almost endless, you can create
    your own development flows, such as continuous delivery using Jenkins, for example.
    Having the API, you are not limited only to existing tools to deploy your software
    to Kubernetes. Things can get more interesting.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](text00180.html)中，*使用Kubernetes API*，我们将深入了解Kubernetes API。这是与Kubernetes集群进行交互的绝佳方式。由于API的存在，可能性几乎是无限的，您可以创建自己的开发流程，例如使用Jenkins进行持续交付。拥有API，您不仅仅局限于现有工具来部署软件到Kubernetes。事情可能会变得更有趣。
