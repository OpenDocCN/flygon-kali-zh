- en: Chapter 9. Database, Security, and System Enhancements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。数据库、安全和系统增强
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Using the RowSetFactory class
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RowSetFactory类
- en: Java 7 database enhancements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 7数据库增强
- en: Using the ExtendedSSLSession interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ExtendedSSLSession接口
- en: Using the platform MXBeans for JVM or system process load monitoring
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平台MXBeans监视JVM或系统进程负载
- en: Redirecting input and output from operating systems processes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向操作系统进程的输入和输出
- en: Embedding a JNLP file in an HTML page
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在HTML页面中嵌入JNLP文件
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter covers database, security, and system type enhancements that have
    been made to Java 7\. Some of these enhancements are minor and will be addressed
    in this introduction. Others are more significant and are detailed in this chapter's
    recipes. Due to the rather specialized nature of some topics, such as those typified
    by some of the security enhancements, they will be mentioned but not explained
    here.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Java 7中对数据库、安全和系统类型的增强。其中一些增强较小，将在本介绍中进行讨论。其他一些增强更为重要，将在本章的配方中详细介绍。由于某些主题的专业性相当特殊，比如一些安全增强的特点，它们将被提及但不在此处解释。
- en: Multiple enhancements have been made to JDBC in Java 7, which now supports **JDBC
    4.1**. Some of the improvements depend on third party driver support not available
    in early driver versions. When this happens, you may receive an `AbstractMethodException`.
    When testing the database recipes for this chapter, ensure that you are working
    with a driver that supports the JDBC 4.1 functionality. Drivers can be found at
    [http://developers.sun.com/product/jdbc/drivers](http://developers.sun.com/product/jdbc/drivers).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7中对JDBC进行了多项增强，现在支持JDBC 4.1。一些改进取决于早期驱动程序版本中不可用的第三方驱动程序支持。当发生这种情况时，您可能会收到`AbstractMethodException`。在测试本章的数据库配方时，请确保您使用支持JDBC
    4.1功能的驱动程序。驱动程序可以在[http://developers.sun.com/product/jdbc/drivers](http://developers.sun.com/product/jdbc/drivers)找到。
- en: The *Using the RowSetFactory* recipe deals with the use of the `javax.sql.rowset.RowSetFactory`
    interface and the `javax.sql.rowset.RowSetProvider` class, which permits the creation
    of any row sets as supported by a given JDBC driver. There are a number of other
    improvements in database's support included in Java 7\. These are addressed in
    the *Java 7 database enhancements* recipe, and include such issues as determining
    the name of the current schema and providing access to hidden columns. The **Derby**
    database engine will be used for the database examples. If you prefer to use other
    databases and tables, you can do so by adjusting the code for the different databases.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用RowSetFactory*配方涉及使用`javax.sql.rowset.RowSetFactory`接口和`javax.sql.rowset.RowSetProvider`类，允许根据给定的JDBC驱动程序创建任何行集。Java
    7中还包括数据库支持的其他改进。这些在*Java 7数据库增强*配方中进行了讨论，包括确定当前模式的名称和提供对隐藏列的访问。Derby数据库引擎将用于数据库示例。如果您希望使用其他数据库和表，可以通过调整不同数据库的代码来实现。'
- en: In addition to these database recipes, the try-with-resource statement can be
    used with any object that implements the `java.sql` package's `Connection, ResultSet`,
    or `Statement` interfaces. This language improvement simplifies the process of
    opening and closing resources. The general use of the try-with-resource statement
    is detailed in the *Using the try-with-resource block to improve exception handling
    code* recipe, in [Chapter 1](ch01.html "Chapter 1. Java Language Improvements"),
    *Java Language Improvements*. An example of using this with a `ResultSet-derived`
    class is shown in the *Using the RowSetFactory class* recipe.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些数据库配方之外，try-with-resource语句可以与实现`java.sql`包的`Connection, ResultSet`或`Statement`接口的任何对象一起使用。这种语言改进简化了打开和关闭资源的过程。try-with-resource语句的一般用法在[第1章](ch01.html
    "第1章。Java语言改进")的*使用try-with-resource块改进异常处理代码*配方中进行了详细介绍，*Java语言改进*。使用`ResultSet-derived`类的示例显示在*使用RowSetFactory类*配方中。
- en: The `Statement` interface has been enhanced with two new methods. The first
    method, `closeOnCompletion`, is executed to specify that the `Statement` object
    will be closed when result sets that use the connection are closed. The second
    method, `isCloseOnCompletion`, returns a Boolean value indicating whether the
    statement will be closed when this criteria is met.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Statement`接口已增强了两种新方法。第一种方法`closeOnCompletion`用于指定当使用连接的结果集关闭时，`Statement`对象将被关闭。第二种方法`isCloseOnCompletion`返回一个布尔值，指示在满足此条件时语句是否将被关闭。'
- en: 'Network enhancements to Java 7 include the addition of two methods to the `java.net.URLClassLoader`
    class:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7的网络增强包括向`java.net.URLClassLoader`类添加了两种方法：
- en: '`close:` This method will close the current `URLClassLoader`, so that it is
    no longer able to load classes or resources. This addresses a problem found on
    Windows, as detailed at [http://download.oracle.com/javase/7/docs/technotes/guides/net/ClassLoader.html](http://download.oracle.com/javase/7/docs/technotes/guides/net/ClassLoader.html)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close:`此方法将关闭当前的`URLClassLoader`，使其无法再加载类或资源。这解决了Windows上发现的问题，详细信息请参阅[http://download.oracle.com/javase/7/docs/technotes/guides/net/ClassLoader.html](http://download.oracle.com/javase/7/docs/technotes/guides/net/ClassLoader.html)'
- en: '`getResourceAsStream:` This method returns an `InputStream` for the resource
    specified by its `String` argument'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getResourceAsStream:`此方法返回由其`String`参数指定的资源的`InputStream`'
- en: Assistance is also provided to support stream connections using the **InfiniBand**
    (**IB**). This technology uses **Remote Direct Memory Access** (**RDMA**) to move
    data directly between the memories of different computers. This support is provided
    through the **Sockets Direct Protocol** (**SDP**) network protocol. The specialized
    nature of this technology precludes further discussion.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了支持使用InfiniBand（IB）的流连接的帮助。这项技术使用远程直接内存访问（RDMA）直接在不同计算机的内存之间传输数据。这种支持是通过Sockets
    Direct Protocol（SDP）网络协议提供的。这项技术的专业性使其无法进一步讨论。
- en: The *Using the platform MXBeans for JVM or system process load monitoring* recipe,
    examines the improvements made in the support of `MXBeans`. This includes different
    methods for accessing these management type beans.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用平台MXBeans监视JVM或系统进程负载*示例检查了对`MXBeans`支持的改进。这包括访问这些管理类型bean的不同方法。'
- en: The `java.lang.ProcessBuilder` class has improved redirect capabilities as introduced
    by the `ProcessBuilder.Redirect` class. This topic is explored in the *Redirecting
    input and output from operating systems processes* recipe.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.ProcessBuilder`类通过`ProcessBuilder.Redirect`类引入了改进的重定向功能。这个主题在*重定向操作系统进程的输入和输出*示例中进行了探讨。'
- en: Java 7 has also improved the way applets can be embedded in an HTML page. The
    *Embedding a JNLP file in an HTML page* recipe provides a demonstration of this
    technique.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7还改进了applet嵌入HTML页面的方式。*在HTML页面中嵌入JNLP文件*示例演示了这种技术。
- en: The **Java Secure Socket Extension** (**JSSE**) is used to secure Internet communications
    using **Secure Sockets Layer** (**SSL**) and **Transport Layer Security** (**TLS**).
    JSSE assists in data encryption, authentication, and maintaining message integrity.
    In Java 7, several enhancements have occurred. The *Using the ExtendedSSLSession
    interface* recipe uses SSL, and is used to illustrate the use of the `ExtendedSSLSession`
    interface and new security features.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java Secure Socket Extension**（**JSSE**）用于使用**安全套接字层**（**SSL**）和**传输层安全性**（**TLS**）保护互联网通信。JSSE有助于数据加密、身份验证和维护消息完整性。在Java
    7中，发生了几项增强。*使用ExtendedSSLSession接口*示例使用SSL，并用于说明如何使用`ExtendedSSLSession`接口和新的安全功能。'
- en: Security enhancements include the incorporation of **Elliptic Curve Cryptography**
    (**ECC**) algorithms. This class of encryption algorithms is more resistant to
    brute force attacks. A portable implementation of the algorithm has been provided.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安全增强包括**椭圆曲线加密**（**ECC**）算法的整合。这类加密算法更抵抗暴力攻击。提供了算法的便携式实现。
- en: New exception classes have been added or enhanced to enhance security. The new
    `java.security.cert.CertificateRevokedException`, when thrown, means that an **X.509**
    certificate has been revoked. The `java.security.cert.CertPathValidatorException`
    class has been enhanced with the addition of a new constructor that takes a `CertPathValidatorException.Reason`
    object. This object implements the `CertPathValidatorException.BasicReason` enumeration
    that enumerates the reason for the exception. The `CertPathValidatorException`
    class's `getReason` method returns a `CertPathValidatorException.Reason` object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还添加或增强了新的异常类以增强安全性。新的`java.security.cert.CertificateRevokedException`在抛出时表示**X.509**证书已被吊销。`java.security.cert.CertPathValidatorException`类通过添加一个接受`CertPathValidatorException.Reason`对象的新构造函数进行了增强。此对象实现了`CertPathValidatorException.BasicReason`枚举，列举了异常的原因。`CertPathValidatorException`类的`getReason`方法返回一个`CertPathValidatorException.Reason`对象。
- en: Java 7 also supports TLS 1.1 and 1.2 specifications and improves upon this support.
    The **Sun JSSE** provider supports TLS 1.1 and TLS 1.2 as defined in RFC 4346
    ([http://tools.ietf.org/html/rfc4346](http://tools.ietf.org/html/rfc4346)) and
    RFC 5246 ([http://tools.ietf.org/html/rfc5246](http://tools.ietf.org/html/rfc5246))
    respectively. These include support to protect against cipher block chaining attacks
    and new cryptographic algorithms.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7还支持TLS 1.1和1.2规范，并对此提供了改进支持。**Sun JSSE**提供程序支持RFC 4346（[http://tools.ietf.org/html/rfc4346](http://tools.ietf.org/html/rfc4346)）和RFC
    5246（[http://tools.ietf.org/html/rfc5246](http://tools.ietf.org/html/rfc5246)）中定义的TLS
    1.1和TLS 1.2。这包括支持防范密码块链接攻击和新的加密算法。
- en: 'In addition, there are a few other TKS-related enhancements:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些其他与TKS相关的增强：
- en: The **SSLv2Hello** protocol has been removed from the list of protocols that
    are enabled by default.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSLv2Hello**协议已从默认启用的协议列表中删除。'
- en: A flaw relating to TLS renegotiation has been fixed in Java 7\. Details regarding
    this flaw can be found at [http://www.oracle.com/technetwork/java/javase/documentation/tlsreadme2-176330.html](http://www.oracle.com/technetwork/java/javase/documentation/tlsreadme2-176330.html).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 7中已修复了与TLS重新协商相关的缺陷。有关此缺陷的详细信息，请参阅[http://www.oracle.com/technetwork/java/javase/documentation/tlsreadme2-176330.html](http://www.oracle.com/technetwork/java/javase/documentation/tlsreadme2-176330.html)。
- en: During TLS 1.1/1.2 handshaking, Java 7 has improved the process of version number
    checking.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在TLS 1.1/1.2握手期间，Java 7改进了版本号检查的过程。
- en: 'Weak cryptographic algorithms can be disabled using the `jdk.certpath.disabledAlgorithms`
    property for the **Sun** provider. By default, the MD2 algorithm is disabled.
    This property is specified in the `jre/lib/security/java.security` file. The default
    setting is shown as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用**Sun**提供程序的`jdk.certpath.disabledAlgorithms`属性来禁用弱加密算法。默认情况下，MD2算法被禁用。此属性在`jre/lib/security/java.security`文件中指定。默认设置如下所示：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is also possible to specify not only the algorithm, but restrictions on the
    key size.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以指定算法，还可以限制密钥大小。
- en: 'Algorithm restrictions can also be placed at the TLS level. This is accomplished
    using the `jdk.tls.disabledAlgorithms` security property in the `jre/lib/security/java.security`
    file. An example is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 算法限制也可以放置在TLS级别。这是通过`jre/lib/security/java.security`文件中的`jdk.tls.disabledAlgorithms`安全属性来实现的。示例如下：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Currently, this property is specific to the **Oracle JSSE** implementation and
    may not be recognized by other implementations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，此属性仅适用于**Oracle JSSE**实现，可能不被其他实现所识别。
- en: The **Server Name Indication** (**SNI**) JSSE extension (RFC 4366) enables TLS
    clients to connect to virtual servers, that is, multiple servers with different
    network names that use the same supporting network address. This is enabled to
    `true` by default, but can be set to `false` for systems where the extension is
    not supported.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器名称指示**（**SNI**）JSSE扩展（RFC 4366）使TLS客户端能够连接到虚拟服务器，即使用相同支持网络地址的不同网络名称的多个服务器。这在默认情况下设置为`true`，但可以在不支持该扩展的系统上设置为`false`。'
- en: 'The `jsse.enableSNIExtension` system property is used to control this setting.
    It can be set using the `-D` java command option shown as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsse.enableSNIExtension`系统属性用于控制此设置。可以使用如下所示的`-D`java命令选项进行设置：'
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It is also possible to set this property using the `setProperty` method shown
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用如下所示的`setProperty`方法设置此属性：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the property name may change in the future.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，属性名称可能会在将来更改。
- en: Using the RowSetFactory class
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`RowSetFactory`类
- en: 'Row sets can now be created using the new `javax.sql.rowset` package''s `RowSetFactoryInterface`
    interface and the `RowSetProvider` class. This permits the creation of any type
    of row set supported by JDBC. We will use the Derby database to illustrate the
    process of creating row sets. The `COLLEAGUES` table will be used. A description
    of how to create this table is found at [http://netbeans.org/kb/docs/ide/java-db.html](http://netbeans.org/kb/docs/ide/java-db.html).
    The SQL code to create the table is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用新的`javax.sql.rowset`包的`RowSetFactoryInterface`接口和`RowSetProvider`类来创建行集。这允许创建JDBC支持的任何类型的行集。我们将使用Derby数据库来说明创建行集的过程。将使用`COLLEAGUES`表。如何创建此表的说明可在[http://netbeans.org/kb/docs/ide/java-db.html](http://netbeans.org/kb/docs/ide/java-db.html)找到。创建表的SQL代码如下：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To create a new row set:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的行集：
- en: Create an instance of the `RowSetFactory.`
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`RowSetFactory`的实例。
- en: Use one of the several `create` methods to create a `RowSet` object.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用几种`create`方法之一来创建`RowSet`对象。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application. In the `main` method, add the following code
    sequence. We will create a new `javax.sql.rowset.JdbcRowSet` object and use it
    to display some of the fields in the `COLLEAGUES` table. Start by setting up `String`
    variables to establish connectivity to the database and create a `RowSetFactory`
    object as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。在`main`方法中，添加以下代码序列。我们将创建一个新的`javax.sql.rowset.JdbcRowSet`对象，并使用它来显示`COLLEAGUES`表中的一些字段。首先设置`String`变量以建立与数据库的连接，并创建`RowSetFactory`对象如下：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, add a try block to catch any `SQLExceptions`, and then use the `createJdbcRowSet`
    method to create the row set. Next, display the selected elements of the table.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个try块来捕获任何`SQLExceptions`，然后使用`createJdbcRowSet`方法创建行集。接下来，显示表的选定元素。
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Execute the application. The output should appear as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。输出应如下所示：
- en: '**1 - Mike**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 - Mike**'
- en: '**2 - James**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**2 - James**'
- en: '**3 - Jerilyn**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**3 - Jerilyn**'
- en: '**4 - Jonathan**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**4 - Jonathan**'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: String variables were created for the database URL, username, and password.
    The `RowSetFactory` object was created using the static `newFactory` method. Any
    exceptions generated will result in the termination of the application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为数据库URL、用户名和密码创建了字符串变量。使用静态的`newFactory`方法创建了`RowSetFactory`对象。任何生成的异常都将导致应用程序终止。
- en: In the try-with-resources block, the `createJdbcRowSet` method was used to create
    an instance of the `JdbcRowSet` class. The URL, username, and password were then
    assigned to the row set. The select command retrieved all of the fields from the
    `COLLEAGUES` table. The query was then executed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在try-with-resources块中，使用`createJdbcRowSet`方法创建了`JdbcRowSet`类的实例。然后将URL、用户名和密码分配给行集。选择命令从`COLLEAGUES`表中检索所有字段。然后执行查询。
- en: Next, a `while` loop was used to display the ID and the first name for each
    row of the row set.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`while`循环显示了行集的每一行的ID和名字。
- en: There's more...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There may be more than one `RowSetFactory` implementation available. The `newFactory`
    method will look for a `RowSetFactory` class in the following order:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有多个可用的`RowSetFactory`实现。`newFactory`方法将按以下顺序查找`RowSetFactory`类：
- en: The one specified in the system property, `javax.sql.rowset.RowSetFactory`,
    if defined.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果定义了系统属性`javax.sql.rowset.RowSetFactory`中指定的。
- en: Using the `ServiceLoader` API.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ServiceLoader` API。
- en: The platform default instance.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平台默认实例。
- en: 'In addition to the creation of a `JdbcRowSet` row set, other methods are available
    to create different types of row sets as listed in the following table:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建`JdbcRowSet`行集之外，还有其他方法可用于创建不同类型的行集，如下表所示：
- en: '| Method | Row set created |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 创建的行集 |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `createCachedRowSet` | `CachedRowSet` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `createCachedRowSet` | `CachedRowSet` |'
- en: '| `createFilteredRowSet` | `FilteredRowSet` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `createFilteredRowSet` | `FilteredRowSet` |'
- en: '| `createJdbcRowSet` | `JdbcRowSet` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `createJdbcRowSet` | `JdbcRowSet` |'
- en: '| `createJoinRowSet` | `JoinRowSet` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `createJoinRowSet` | `JoinRowSet` |'
- en: '| `createWebRowSet` | `WebRowSet` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `createWebRowSet` | `WebRowSet` |'
- en: 'A `RowSetFactory` can also be created using the overloaded `newFactory` method
    that takes two arguments, shown as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用带有两个参数的重载的`newFactory`方法创建`RowSetFactory`，如下所示：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This approach provides more control to the application, enabling it to specify
    the provider to use. When there are multiple providers found in the class path,
    this can be useful. The first argument specifies the class name of the provider
    and the second argument specifies the class loader to use. Using `null` as the
    second argument specifies that the context class loader is to be used.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法为应用程序提供了更多的控制，使其能够指定要使用的提供程序。当类路径中有多个提供程序时，这可能很有用。第一个参数指定提供程序的类名，第二个参数指定要使用的类加载器。将`null`用作第二个参数指定要使用上下文类加载器。
- en: Java 7 database enhancements
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 7数据库增强
- en: There are numerous small enhancements to the database support provided by Java
    7\. This recipe addresses these enhancements and provides examples where practical.
    Due to the immaturity of many JDBC 4.1 drives, not all of the code examples will
    be completely functional.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7提供了对数据库支持的许多小的增强。本示例介绍了这些增强，并在实际情况下提供了示例。由于许多JDBC 4.1驱动程序的不成熟，不是所有的代码示例都能完全正常运行。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Most of the examples start by:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数示例都是从以下开始：
- en: Creating a connection to a Derby database.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Derby数据库的连接。
- en: Using the connection methods to access needed functionality.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用连接方法访问所需功能。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application. In the `main` method, add the following code
    sequence. It will establish a connection to the database and determine if auto-generated
    keys will always be returned and what the current schema is:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。在`main`方法中，添加以下代码序列。它将建立与数据库的连接，并确定自动生成的键是否总是被返回，以及当前模式是什么：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When executed, your output should appear similar to the following:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行时，输出应类似于以下内容：
- en: '**Auto Generated Keys: true**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的键：true
- en: '**Schema: SchemaName**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：SchemaName**'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `Statement` interface's `getGeneratedKeys` method was introduced in Java
    1.4 and returns any auto-generated keys for that statement. The `java.sql.DatabaseMetaData`
    interface's `generatedKeyAlwaysReturned` method returned a Boolean value, indicating
    that auto-generated keys will always be returned.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Statement`接口的`getGeneratedKeys`方法是在Java 1.4中引入的，用于返回该语句的任何自动生成的键。`java.sql.DatabaseMetaData`接口的`generatedKeyAlwaysReturned`方法返回一个布尔值，指示自动生成的键将始终被返回。'
- en: It is possible to set and get the schema for a connection using the `Connection`
    interface's `setSchema` and `getSchema` methods. The `getSchema` method was executed,
    which returned the schema name.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Connection`接口的`setSchema`和`getSchema`方法来设置和获取连接的模式。执行了`getSchema`方法，返回了模式名称。
- en: There's more...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Three other topics bear further discussion:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个主题需要进一步讨论：
- en: Retrieving pseudo-columns
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索伪列
- en: Controlling the type value of the `OUT` parameter
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制`OUT`参数的类型值
- en: Other database enhancements
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他数据库增强
- en: Retrieving pseudo-columns
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索伪列
- en: 'Databases will often use hidden columns to represent a unique key for every
    row of a table. These hidden columns are sometimes called **pseudo-columns**.
    In Java 7, two new methods have been added to address pseudo-columns. The `DatabaseMetaData`
    interface''s `getPseudoColumns` method will retrieve a `ResultSet`. The method
    asks for the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库通常会使用隐藏列来表示表的每一行的唯一键。这些隐藏列有时被称为**伪列**。在Java 7中，已添加了两种新方法来处理伪列。`DatabaseMetaData`接口的`getPseudoColumns`方法将检索一个`ResultSet`。该方法要求以下内容：
- en: 'Catalog: This needs to match the catalog name used in the database. If no catalog
    is used, then use an empty string. A null value means that the catalog name will
    not be used when searching for the columns.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录：这需要与数据库中使用的目录名称匹配。如果不使用目录，则使用空字符串。空值表示在搜索列时不使用目录名称。
- en: 'Schema pattern: This needs to match the schema name used in the database. If
    no schema is used then use an empty string. A null value means that the schema
    name will not be used when searching for the columns.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式名称：这需要与数据库中使用的模式名称匹配。如果不使用模式，则使用空字符串。空值表示在搜索列时不使用模式名称。
- en: 'Table name pattern: This needs to match the table name used in the database'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表名称模式：这需要与数据库中使用的表名称匹配
- en: 'Column name pattern: This needs to match the column name used in the database'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列名称模式：这需要与数据库中使用的列名称匹配
- en: 'The `ResultSet` returned will have the following organization as shown in the
    following table:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的`ResultSet`将按照以下表格所示的组织结构：
- en: '| Column | Type | Meaning |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 类型 | 意义 |'
- en: '| --- | --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `TABLE_CAT` | String | The name of the catalog which may be null |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `TABLE_CAT` | 字符串 | 可能为空的目录名称 |'
- en: '| `TABLE_SCHEM` | String | The name of the schema which may be null |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `TABLE_SCHEM` | 字符串 | 可能为空的模式名称 |'
- en: '| `TABLE_NAME` | String | The name of the table |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `TABLE_NAME` | 字符串 | 表的名称 |'
- en: '| `COLUMN_NAME` | String | The name of the column |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `COLUMN_NAME` | 字符串 | 列的名称 |'
- en: '| `DATA_TYPE` | int | SQL type (`java.sql.Types`) |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `DATA_TYPE` | 整数 | SQL类型（`java.sql.Types`） |'
- en: '| `COLUMN_SIZE` | int | The size of the column |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `COLUMN_SIZE` | 整数 | 列的大小 |'
- en: '| `DECIMAL_DIGITS` | int | The number of fractional digits. A null value means
    there are no fractional digits. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `DECIMAL_DIGITS` | 整数 | 小数位数。空值表示没有小数位数。 |'
- en: '| `NUM_PREC_RADIX` | int | The radix |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `NUM_PREC_RADIX` | 整数 | 基数 |'
- en: '| `COLUMN_USAGE` | String | Specifies how the column is used as defined by
    the new PsuedoColumnUsage enumeration |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `COLUMN_USAGE` | 字符串 | 指定列的使用方式，由新的PsuedoColumnUsage枚举定义 |'
- en: '| `REMARKS` | String | Comment regarding the column |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `REMARKS` | 字符串 | 关于列的评论 |'
- en: '| `CHAR_OCTET_LENGTH` | int | The maximum number of characters for a char column
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `CHAR_OCTET_LENGTH` | 整数 | char列的最大字符数 |'
- en: '| `IS_NULLABLE` | String | *YES: Column can contain null**NO: Column cannot
    contain nulls**"": Unknown* |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `IS_NULLABLE` | 字符串 | *YES: 列可以包含空值**NO: 列不能包含空值**"": 未知* |'
- en: 'The hidden columns represent a unique key, which provides a fast way of accessing
    a row. Derby does not support hidden columns. However, the following code sequence
    illustrates how this can be accomplished:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏列表示一个唯一键，提供了一种快速访问行的方式。Derby不支持隐藏列。但是，以下代码序列说明了如何实现这一点：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Derby will return an empty `ResultSet` consisting of the columns listed previously.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Derby将返回一个空的`ResultSet`，其中包含先前列出的列。
- en: Controlling the type value of the OUT parameter
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制`OUT`参数的类型值
- en: 'The `java.sql.CallableStatement` has two overloaded `getObject` methods that
    return an object, which is given a column name or index. Support is currently
    limited. However, the basic approach is illustrated as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.sql.CallableStatement`有两个重载的`getObject`方法，返回一个给定列名或索引的对象。目前支持有限。但是，基本方法如下所示：'
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The query string contains a call to a stored procedure. This procedure is assumed
    to use an integer value as the first parameter to identify a record in a table.
    The second argument is to be returned and is of the type `Date`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串包含对存储过程的调用。假定该存储过程使用整数值作为第一个参数来标识表中的记录。第二个参数将被返回，并且是`Date`类型。
- en: Once the query is executed, the `getObject` method will return the specified
    column using the data type specified. The method will convert the SQL type to
    the Java data type.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦查询被执行，`getObject`方法将使用指定的数据类型返回指定的列。该方法将把SQL类型转换为Java数据类型。
- en: Other database enhancements
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他数据库增强
- en: 'The `java.sql` package''s `Driver` interface has a new method, which returns
    the parent logger for the driver. This is illustrated with the following code
    sequence:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.sql`包的`Driver`接口有一个新方法，返回驱动程序的父记录器。下面的代码序列说明了这一点：'
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, when executed, the current version of the driver will generate the
    following exception:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当执行时，当前版本的驱动程序将生成以下异常：
- en: '**Java.sql.SQLFeatureNotSupportedException: Feature not implemented: getParentLogger**.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java.sql.SQLFeatureNotSupportedException: Feature not implemented: getParentLogger**。'
- en: Derby does not use the `java.util.logging` package, so it throws this exception.
    The `javax.sql.CommonDataSource` interface has also added the `getParentLogger`
    method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Derby不使用`java.util.logging`包，因此会抛出此异常。`javax.sql.CommonDataSource`接口还添加了`getParentLogger`方法。
- en: 'In addition, when a series of database operations are performed in conjunction
    with an `Executor`, three methods are available to support those operations, which
    are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当一系列数据库操作与`Executor`一起执行时，有三种方法可用于支持这些操作，如下所示：
- en: '`abort:` This method will abort an open connection using the `Executor` passed
    to the method'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abort:`此方法将使用传递给方法的`Executor`中止打开的连接'
- en: '`setNetworkTimeout:` This method specifies the timeout period in milliseconds
    to wait for the response to a request. It also uses an `Executor` object.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setNetworkTimeout:`此方法指定等待响应的超时时间（以毫秒为单位）。它还使用一个`Executor`对象。'
- en: '`getNetworkTimeout:` This method returns the number of milliseconds that the
    connection will wait for database requests'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getNetworkTimeout:`此方法返回连接等待数据库请求的毫秒数'
- en: The last two methods are optional and are not supported by Derby.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个方法是可选的，Derby不支持它们。
- en: Using the ExtendedSSLSession interface
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ExtendedSSLSession`接口
- en: The `javax.net.ssl` package provides a series of classes used to effect secure
    socket communication. Improvements introduced in Java 7 include the addition of
    the `ExtendedSSLSession` interface, which can be used to determine the specific
    local and peer supported signature algorithms that are used. In addition, when
    an `SSLSession` is created, an endpoint identification algorithm can be used to
    ensure that the host computer's address matches that of the certificate. This
    algorithm is accessible through the `SSLParameters` class.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`javax.net.ssl`包提供了一系列用于实现安全套接字通信的类。Java 7中引入的改进包括添加了`ExtendedSSLSession`接口，该接口可用于确定所使用的特定本地和对等支持的签名算法。此外，创建`SSLSession`时，可以使用端点识别算法来确保主机计算机的地址与证书的地址匹配。这个算法可以通过`SSLParameters`类访问。'
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To demonstrate the use of the `ExtendedSSLSession` interface, we will:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`ExtendedSSLSession`接口的使用，我们将：
- en: Create an `SSLServerSocket-based EchoServer` application to accept messages
    from a client.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于`SSLServerSocket`的`EchoServer`应用程序，以接受来自客户端的消息。
- en: Create a client application, which uses a `SSLSocket` instance to communicate
    with the server.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个客户端应用程序，该应用程序使用`SSLSocket`实例与服务器通信。
- en: Use the `EchoServer` application to obtain an instance of the `ExtendedSSLSession`
    interface.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`EchoServer`应用程序获取`ExtendedSSLSession`接口的实例。
- en: Use a `SimpleConstraints` class to demonstrate the use of algorithm constraints.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SimpleConstraints`类来演示算法约束的使用。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by creating a class called `SimpleConstraints`, which is adapted
    from the **Java PKI Programmer''s Guide** ([http://download.oracle.com/javase/7/docs/technotes/guides/security/certpath/CertPathProgGuide.html](http://download.oracle.com/javase/7/docs/technotes/guides/security/certpath/CertPathProgGuide.html)).
    We will use this to associate algorithm constraints to the application. Add the
    following class to your project:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个名为`SimpleConstraints`的类，该类改编自**Java PKI程序员指南**([http://download.oracle.com/javase/7/docs/technotes/guides/security/certpath/CertPathProgGuide.html](http://download.oracle.com/javase/7/docs/technotes/guides/security/certpath/CertPathProgGuide.html))。我们将使用这个类来将算法约束关联到应用程序。将以下类添加到您的项目中：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To create the `EchoServer` application, create a new console application. Add
    the following code to the `main` method. In this initial sequence, we create and
    start up the server:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`EchoServer`应用程序，创建一个新的控制台应用程序。将以下代码添加到`main`方法中。在这个初始序列中，我们创建并启动服务器：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, add the following code sequence to set up algorithm constraints for the
    application. It also returns the name of the end point algorithm:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码序列以设置应用程序的算法约束。它还返回端点算法的名称：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following code to display local supported algorithms:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以显示本地支持的算法：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following sequence displays peer-supported algorithms:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下序列显示了对等支持的算法：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code to buffer the input stream coming from a client application:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码来缓冲来自客户端应用程序的输入流：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finish the method by adding code to display the input from the client:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加代码显示来自客户端的输入来完成该方法：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To execute the server, we need to create key store. This is accomplished from
    the command prompt by executing the following command:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行服务器，我们需要创建密钥库。这可以通过在命令提示符中执行以下命令来完成：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Provide a password and other information requested by the program. Next, navigate
    to the echo server''s location and enter the following command:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供程序请求的密码和其他信息。接下来，转到回声服务器的位置并输入以下命令：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The **password** above, is the password that you used to create the key store,
    and package, is your EchoServer''s package, if any. When the program executes,
    you get the following output:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上面的**密码**是您用来创建密钥库的密码，而**package**是您的EchoServer的包（如果有的话）。当程序执行时，您会得到以下输出：
- en: '**Waiting for a client ...**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待客户端...**'
- en: 'We now need to create a client console application called `EchoClient`. In
    the `main` method, add the following code where we create a connection to the
    server and then send the input from the keyboard to the server:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个名为`EchoClient`的客户端控制台应用程序。在`main`方法中，添加以下代码，我们创建与服务器的连接，然后将键盘输入发送到服务器：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Copy the key store file to the client application''s directory. In a separate
    command window, execute the following command:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将密钥库文件复制到客户端应用程序的目录中。在单独的命令窗口中，执行以下命令：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The **password** above, is the password that you used to create the key store,
    and package, is your EchoServer''s package, if any. When the program executes,
    enter the word **cat**, and then press the *Enter* key. In the server command
    window, you should see an end point name, which may be null, a list of local supported
    signature algorithms, and **cat** similar to the following:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上面的**密码**是您用来创建密钥库的密码，而**package**是您的EchoServer的包（如果有的话）。程序执行时，输入单词**cat**，然后按*Enter*键。在服务器命令窗口中，您应该看到一个终点名称，可能为空，一个本地支持的签名算法列表，以及类似以下内容的**cat**：
- en: '**End Point: null**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**终点：null**'
- en: '**Local Supported Signature Algorithms**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地支持的签名算法**'
- en: '**Algortihm: SHA512withECDSA**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法：SHA512withECDSA**'
- en: '**Algortihm: SHA512withRSA**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法：SHA512withRSA**'
- en: '**Algortihm: SHA384withECDSA**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法：SHA384withECDSA**'
- en: '**Algortihm: SHA384withRSA**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法：SHA384withRSA**'
- en: '**Algortihm: SHA256withECDSA**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法：SHA256withECDSA**'
- en: '**Algortihm: SHA256withRSA**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法：SHA256withRSA**'
- en: '**Algortihm: SHA224withECDSA**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法：SHA224withECDSA**'
- en: '**Algortihm: SHA224withRSA**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法：SHA224withRSA**'
- en: '**Algortihm: SHA1withECDSA**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法：SHA1withECDSA**'
- en: '**Algortihm: SHA1withRSA**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法：SHA1withRSA**'
- en: '**Algortihm: SHA1withDSA**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法：SHA1withDSA**'
- en: '**Algortihm: MD5withRSA**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法：MD5withRSA**'
- en: '**Peer Supported Signature Algorithms**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**对等支持的签名算法**'
- en: '**cat**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**cat**'
- en: As you enter more input lines, they should be reflected in the server command
    window. To terminate the program, enter a *Ctrl* + *C* in the client command window.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您输入更多的输入行时，它们应该在服务器命令窗口中反映出来。要终止程序，在客户端命令窗口中输入*Ctrl* + *C*。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `SimpleConstraints` class allows only RSA algorithms and then with keys
    that use 2048 bits or more. This was used as an argument to the `setAlgorithmConstraints`
    method. The class implemented the `java.security.AlgorithmConstraints` interface,
    which represents the restrictions of the algorithm.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleConstraints`类只允许RSA算法，然后使用2048位或更多的密钥。这被用作`setAlgorithmConstraints`方法的参数。该类实现了`java.security.AlgorithmConstraints`接口，表示算法的限制。'
- en: A `SSLServerSocketFactory` instance was created followed by the creation of
    a `SSLServerSocket`. The `accept` method was executed against the socket, which
    blocks until a client connects to it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个`SSLServerSocketFactory`实例，然后创建一个`SSLServerSocket`。对套接字执行`accept`方法，该方法会阻塞，直到客户端连接到它。
- en: Next, the `SimpleConstraints` was set followed by the use of the `getEndpointIdentificationAlgorithm`
    method, which returned an empty string. For this example, no endpoint identification
    algorithm was used.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来设置了`SimpleConstraints`，然后使用了`getEndpointIdentificationAlgorithm`方法，返回了一个空字符串。在这个例子中，没有使用终点识别算法。
- en: The local and peer supported signature algorithms were listed. The remaining
    code was concerned with reading and then displaying the string sent by a client.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列出了本地和对等支持的签名算法。剩下的代码涉及读取并显示客户端发送的字符串。
- en: The `EchoClient` application is simpler. It created an instance of the `SSLSocket`
    class and then used its `getOutputStream` method to write the user's input to
    the echo server.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`EchoClient`应用程序更简单。它创建了`SSLSocket`类的一个实例，然后使用它的`getOutputStream`方法将用户的输入写入回显服务器。'
- en: Using the platform MXBeans for JVM or system process load monitoring
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用平台MXBeans进行JVM或系统进程负载监控
- en: '**Java Management Extensions** (**JMX**) is a standard way of adding a management
    interface to an application. A **managed bean** (**MBean**) provides the management
    services for the application and is registered with a `javax.management.MBeanServer`,
    which holds and administers the MBean. A `javax.management.MXBean` is a type of
    MBean, which permits clients to access the bean without the need to access specific
    classes.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java管理扩展**（**JMX**）是一种向应用程序添加管理接口的标准方式。**托管bean**（**MBean**）为应用程序提供管理服务，并向`javax.management.MBeanServer`注册，该服务器保存和管理MBean。`javax.management.MXBean`是一种MBean类型，允许客户端访问bean而无需访问特定类。'
- en: The `java.lang.management` package's `ManagementFactory` class has added several
    new methods to gain access to an MBean. These can then be used to access process
    and load monitoring.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.management`包的`ManagementFactory`类添加了几种新方法来访问MBean。然后可以用这些方法来访问进程和负载监控。'
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To access an `MXBean:`
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`MXBean`：
- en: Use the `getPlatformMXBean` method with the `MXBean` type needed for the application.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`getPlatformMXBean`方法和应用程序所需的`MXBean`类型。
- en: Use the `MXBean` methods as required.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要使用`MXBean`方法。
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application. Use the `main` method that follows. In this
    application, we will obtain an `MXBean` for the runtime environment and display
    basic information about it:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。使用以下`main`方法。在这个应用程序中，我们将获取运行时环境的`MXBean`并显示关于它的基本信息：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Execute the application. Your output should be similar to the following:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您的输出应该类似于以下内容：
- en: '**JVM Name: 5584@name-PC**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**JVM名称：5584@name-PC**'
- en: '**JVM Specification Name: Java Virtual Machine Specification**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**JVM规范名称：Java虚拟机规范**'
- en: '**JVM Specification Version: 1.7**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**JVM规范版本：1.7**'
- en: '**JVM Implemenation Name: Java HotSpot(TM) 64-Bit Server VM**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**JVM实现名称：Java HotSpot(TM) 64位服务器VM**'
- en: '**JVM Implemenation Vendor: Oracle Corporation**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**JVM实现供应商：Oracle Corporation**'
- en: '**JVM Implemenation Version: 21.0-b17**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**JVM实现版本：21.0-b17**'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We used the `ManagementFactory` class' static `getPlatformMXBean` method with
    an argument of `RuntimeMXBean.class`. This returned an instance of a `RuntimeMXBean`.
    Specific methods of this instance were then applied and their values were displayed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`ManagementFactory`类的静态`getPlatformMXBean`方法，参数为`RuntimeMXBean.class`。这返回了一个`RuntimeMXBean`的实例。然后应用了该实例的特定方法，并显示了它们的值。
- en: There's more...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `ManagementFactory` introduced several new methods in Java 7:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagementFactory`在Java 7中引入了几种新方法：'
- en: '`getPlatformMXBean:` This is an overloaded method that returns a `PlatformManagedObject`-derived
    object supporting a particular management interface using a `Class` argument'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPlatformMXBean:` 这是一个重载的方法，它返回一个支持特定管理接口的`PlatformManagedObject`派生对象，使用`Class`参数'
- en: '`getPlatformMXBeans:` This is an overloaded method that returns a `PlatformManagedObject`-derived
    object supporting a particular management interface using an `MBeanServerConnection`
    object and a `Class` argument'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPlatformMXBeans:` 这是一个重载的方法，它返回一个支持特定管理接口的`PlatformManagedObject`派生对象，使用`MBeanServerConnection`对象和一个`Class`参数'
- en: '`getPlatformManagementInterfaces:` This method returns a set of `Class` objects
    for `PlatformManagedObject`-derived objects on the current Java platform'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPlatformManagementInterfaces:` 该方法返回当前Java平台上的`PlatformManagedObject`派生对象的`Class`对象集'
- en: In addition, a new interface was added to the `java.lang.management` package.
    The `PlatformManagedObject` interface serves as the base interface for all `MXBeans`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`java.lang.management`包中添加了一个新的接口。`PlatformManagedObject`接口用作所有`MXBeans`的基本接口。
- en: Using the getPlatformMXBeans method
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`getPlatformMXBeans`方法
- en: 'The `getPlatformMXBeans` method is passed the `MXBean` type and returns a list
    of the platform `MXBeans` that implements the `MXBean` type. In the following
    example, we obtain a list for the `OperatingSystemMXBean`. Several attributes
    of the `MXBean` are then displayed:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPlatformMXBeans`方法传递`MXBean`类型并返回实现`MXBean`类型的平台`MXBeans`列表。在下面的示例中，我们获取了`OperatingSystemMXBean`的列表。然后显示了`MXBean`的几个属性：'
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When executed, you should get an output similar to the following. The exact
    output is dependent on the operating system and hardware used to execute the application:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，您应该获得类似以下的输出。确切的输出取决于用于执行应用程序的操作系统和硬件：
- en: '**Operating System Name: Windows 7**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作系统名称：Windows 7**'
- en: '**Operating System Architecture: amd64**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作系统架构：amd64**'
- en: '**Operating System Version: 6.1**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作系统版本：6.1**'
- en: Obtaining the platform's management interfaces
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取平台的管理接口
- en: The `ManagementFactory` class' static `getPlatformManagementInterfaces` method
    returns a set of `Class` objects representing the platform-supported `MXBeans`.
    However, this method generated a `ClassCastException` on both the Windows 7 and
    the Ubuntu platforms when running the JDK 7.01 release. Future versions should
    correct this problem.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagementFactory`类的静态`getPlatformManagementInterfaces`方法返回表示平台支持的`MXBeans`的`Class`对象集。然而，在运行JDK
    7.01版本时，该方法在Windows 7和Ubuntu平台上都生成了`ClassCastException`。未来的版本应该纠正这个问题。'
- en: 'The **jconsole** application that is available as part of the JDK, provides
    an alternative technique for determining which `MXBeans` are available. The following
    is the console displaying the attributes for the operating system, specifically
    the `ProcessCpuLoad` attribute:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 作为JDK的一部分提供的**jconsole**应用程序，提供了一种确定可用的`MXBeans`的替代技术。以下是控制台显示操作系统属性，特别是`ProcessCpuLoad`属性：
- en: '![Obtaining the platform''s management interfaces](img/5627_09_01.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![获取平台的管理接口](img/5627_09_01.jpg)'
- en: Redirecting input and output from operating system's processes
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向操作系统进程的输入和输出
- en: The `java.lang.ProcessBuilder` class has several new methods that are useful
    for redirecting the input and output of external processes executed from a Java
    application. The nested `ProcessBuilder.Redirect` class has been introduced to
    provide these additional redirect capabilities. To demonstrate this process, we
    are going to send command-line arguments from a text file to a DOS prompt and
    record the output in another text file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.ProcessBuilder`类有几个有用于重定向从Java应用程序执行的外部进程的输入和输出的新方法。嵌套的`ProcessBuilder.Redirect`类已被引入以提供这些额外的重定向功能。为了演示这个过程，我们将从文本文件向DOS提示符发送命令行参数，并将输出记录在另一个文本文件中。'
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In order to control input and output from external processes, you must:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制外部进程的输入和输出，您必须：
- en: Create a new `ProcessBuilder` object.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`ProcessBuilder`对象。
- en: Direct the input and output of the process to the appropriate locations.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将进程的输入和输出定向到适当的位置。
- en: Execute the process via the `start` method.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`start`方法执行进程。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'First, create a new console application. Create three new file instances to
    represent the three files involved in our process execution: input, output, and
    errors as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的控制台应用程序。创建三个新的文件实例来表示我们的进程执行涉及的三个文件：输入，输出和错误，如下所示：
- en: '[PRE25]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create the file `ProcessCommands.txt` using the path specified for the file
    and enter the following text:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指定文件的路径创建文件`ProcessCommands.txt`并输入以下文本：
- en: '**cd C:\**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**cd C:\**'
- en: '**dir**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**dir**'
- en: '**mkdir "Test Directory"**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**mkdir "Test Directory"**'
- en: '**dir**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**dir**'
- en: Make sure that there is a carriage return after the last line.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在最后一行之后有一个回车。
- en: 'Next, create a new instance of a `ProcessBuilder`, passing the string `"cmd`"
    to the constructor to specify the external process that we want to launch, which
    is the operating system command window. Call the `redirectInput, redirectOutput`,
    and `redirectError` methods with no arguments and print out the default locations:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个`ProcessBuilder`的新实例，将字符串`"cmd"`传递给构造函数，以指定我们要启动的外部进程，即操作系统命令窗口。调用`redirectInput,
    redirectOutput`和`redirectError`方法，不带参数，并打印出默认位置：
- en: '[PRE26]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then we want to call the overloaded form of the previous methods, passing the
    respective file to each one. Once again, call the no argument form of each method
    executed using the `toString` method to verify that the IO sources have been changed:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们想调用前面方法的重载形式，将各自的文件传递给每个方法。再次调用每个方法的无参数形式，使用`toString`方法来验证IO源是否已更改：
- en: '[PRE27]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, call the `start` method to execute the process as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用`start`方法来执行进程，如下所示：
- en: '[PRE28]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the application. You should see output similar to the following:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。您应该看到类似以下的输出：
- en: '**PIPE**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**PIPE**'
- en: '**PIPE**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**PIPE**'
- en: '**PIPE**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**PIPE**'
- en: '**redirect to read from file "C:\Projects\ProcessCommands.txt"**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**重定向以从文件"C:\Projects\ProcessCommands.txt"读取**'
- en: '**redirect to write to file "C:\Projects\ProcessLog.txt"**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向以写入文件"C:\Projects\ProcessLog.txt"
- en: '**redirect to write to file "C:\Projects\ErrorLog.txt"**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向以写入文件"C:\Projects\ErrorLog.txt"
- en: 'Examine each of the text files. Your output file should have text similar to
    this:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查每个文本文件。您的输出文件应该有类似于以下文本：
- en: '**Microsoft Windows [Version 6.7601]**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Windows [版本6.7601]
- en: '**Copyright (c) 2009 Microsoft Corporation. All rights reserved.**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 版权所有(c)2009年微软公司。保留所有权利。
- en: '**C:\Users\Jenn\Documents\NetBeansProjects\ProcessBuilderExample>cd C:\**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: C:\Users\Jenn\Documents\NetBeansProjects\ProcessBuilderExample>cd C:\
- en: '**C:\>dir**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: C:\>dir
- en: '**Volume in drive C has no label.**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动器C中没有标签的卷。
- en: '**Volume Serial Number is 927A-1F77**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 卷序列号为927A-1F77
- en: '**Directory of C:\**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: C:\的目录
- en: '**03/05/2011 10:56 <DIR> Dell**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 03/05/2011 10:56 <DIR> 戴尔
- en: '**11/08/2011 16:04 <DIR> Miscellaneous**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 11/08/2011 16:04 <DIR> 其他
- en: '**11/08/2011 11:08 <DIR> MOVE**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 11/08/2011 11:08 <DIR> 移动
- en: '**10/31/2011 10:57 <DIR> MUSIC**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 10/31/2011 10:57 <DIR> 音乐
- en: '**11/08/2011 19:44 <DIR> Projects**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 11/08/2011 19:44 <DIR> 项目
- en: '**10/27/2011 21:09 <DIR> temp**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 10/27/2011 21:09 <DIR> 临时
- en: '**10/28/2011 10:46 <DIR> Users**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 10/28/2011 10:46 <DIR> 用户
- en: '**11/08/2011 17:11 <DIR> Windows**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 11/08/2011 17:11 <DIR> 窗户
- en: '**0 File(s) 0 bytes**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 0个文件 0字节
- en: '**34 Dir(s) 620,819,542,016 bytes free**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 34个目录 620,819,542,016字节可用
- en: '**C:\>mkdir "Test Directory"**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在C:\>中创建"测试目录"
- en: '**C:\>dir**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: C:\>dir
- en: '**Volume in drive C has no label.**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动器C中没有标签的卷。
- en: '**Volume Serial Number is 927A-1F77**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 卷序列号为927A-1F77
- en: '**Directory of C:\**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: C:\的目录
- en: '**03/05/2011 10:56 <DIR> Dell**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 03/05/2011 10:56 <DIR> 戴尔
- en: '**11/08/2011 16:04 <DIR> Miscellaneous**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 11/08/2011 16:04 <DIR> 其他
- en: '**11/08/2011 11:08 <DIR> MOVE**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 11/08/2011 11:08 <DIR> 移动
- en: '**10/31/2011 10:57 <DIR> MUSIC**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 10/31/2011 10:57 <DIR> 音乐
- en: '**11/08/2011 19:44 <DIR> Projects**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 11/08/2011 19:44 <DIR> 项目
- en: '**10/27/2011 21:09 <DIR> temp**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 10/27/2011 21:09 <DIR> 临时
- en: '**10/28/2011 10:46 <DIR> Test Directory**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 10/28/2011 10:46 <DIR> 测试目录
- en: '**10/28/2011 10:46 <DIR> Users**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 10/28/2011 10:46 <DIR> 用户
- en: '**11/08/2011 17:11 <DIR> Windows**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 11/08/2011 17:11 <DIR> 窗户
- en: 'Execute the program again and examine the contents of your error log. Because
    your test directory had already been created with the first process execution,
    you should now see the following error message:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次执行程序并检查您的错误日志的内容。因为您的测试目录已经在第一次进程执行时创建，所以现在应该看到以下错误消息：
- en: '**A subdirectory or file Test Directory already exists.**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 子目录或文件"测试目录"已经存在。
- en: How it works...
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created three files to handle the input and output of our process. When we
    created the instance of the `ProcessBuilder` object, we specified the application
    to launch to be the command window. The information required to perform actions
    within the application was stored in our input file.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了三个文件来处理我们进程的输入和输出。当我们创建`ProcessBuilder`对象的实例时，我们指定要启动的应用程序为命令窗口。在应用程序中执行操作所需的信息存储在我们的输入文件中。
- en: When we first called the `redirectInput, redirectOutput`, and `redirectError`
    methods, we did not pass any arguments. These methods all return a `ProcessBuilder.Redirect`
    object, which we printed. This object represents the default IO source, which
    in all three cases was `Redirect.PIPE`, one of the `ProcessBuilder.Redirect.Type`
    enumerations. A pipe takes the output of one source and sends it to another.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次调用`redirectInput, redirectOutput`和`redirectError`方法时，我们没有传递任何参数。这些方法都返回一个`ProcessBuilder.Redirect`对象，我们打印了它。这个对象代表默认的IO源，在所有三种情况下都是`Redirect.PIPE`，`ProcessBuilder.Redirect.Type`枚举值之一。管道将一个源的输出发送到另一个源。
- en: The second form of the methods that we used involved passing a `java.io.File`
    instance to the `redirectInput, redirectOutput`, and `redirectError` methods.
    These methods return a `ProcessBuilder` object as well, but they also have the
    function of setting the IO source. In our example, we then called the no argument
    form of each method once more to verify that the IO had been redirected.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的方法的第二种形式涉及将`java.io.File`实例传递给`redirectInput, redirectOutput`和`redirectError`方法。这些方法也返回一个`ProcessBuilder`对象，但它们还具有设置IO源的功能。在我们的示例中，我们再次调用了每种方法的无参数形式，以验证IO是否已被重定向。
- en: The first time the program was executed, your error log should have been empty,
    assuming you used valid file paths for each `File` object, and you have write
    permissions on your computer. The second execution was intended to display how
    the capture of errors can be directed to a separate file. If the `redirectError`
    method is not invoked, the errors will inherit the standard location and will
    be displayed in your IDE's output window. See the *There's More..*. section for
    information about inheriting standard IO locations.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 程序第一次执行时，您的错误日志应该是空的，假设您为每个`File`对象使用了有效的文件路径，并且您在计算机上有写权限。第二次执行旨在显示如何将错误捕获定向到单独的文件。如果未调用`redirectError`方法，错误将继承标准位置，并将显示在IDE的输出窗口中。有关继承标准IO位置的信息，请参阅*还有更多..*部分。
- en: It is important to note that the `start` method must be called after the redirect
    methods. Starting the process before redirecting input or output will cause the
    process to disregard your redirects and the application will execute using the
    standard IO locations.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，必须在重定向方法之后调用`start`方法。在重定向输入或输出之前启动进程将导致进程忽略您的重定向，并且应用程序将使用标准IO位置执行。
- en: There's more...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this section, we will examine the use of the `ProcessBuilder.Redirect` class
    and the `inheritIO` method.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究`ProcessBuilder.Redirect`类和`inheritIO`方法的使用。
- en: Using the ProcessBuilder.Redirect class
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ProcessBuilder.Redirect类
- en: 'The `ProcessBuilder.Redirect` class provides another way to specify how the
    IO data is redirected. Using the previous example, add a new line prior to calling
    the `start` method:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessBuilder.Redirect`类提供了另一种指定IO数据重定向的方法。使用前面的示例，在调用`start`方法之前添加一行：'
- en: '[PRE29]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This form of the `redirectError` method allows you to specify that the errors
    should be appended to the error log text file rather than overwritten. If you
    execute the application with this change, you will see two instances of the error
    when the process tries to create the `Test Directory` directory again:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`redirectError`方法的形式允许你指定错误应该追加到错误日志文本文件中，而不是覆盖。如果你使用这个改变来执行应用程序，当进程再次尝试创建`Test
    Directory`目录时，你会看到错误的两个实例：
- en: '**A subdirectory or file Test Directory already exists**.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**子目录或文件Test Directory已经存在**。'
- en: '**A subdirectory or file Test Directory already exists**.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**子目录或文件Test Directory已经存在**。'
- en: This is an example of using the overloaded form of the `redirectError` method,
    passing a `ProcessBuilder.Redirect` object instead of a file. All three methods,
    `redirectError, redirectInput`, and `redirectOutput`, have this overloaded form.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`redirectError`方法的重载形式的一个例子，传递了一个`ProcessBuilder.Redirect`对象而不是一个文件。所有三种方法，`redirectError,
    redirectInput`和`redirectOutput`，都有这种重载形式。
- en: The `ProcessBuilder.Redirect` class has two special values, namely, `Redirect.PIPE`
    and `Redirect.INHERIT. Redirect.PIPE` is the default way external process IO is
    handled, and simply means that the Java process will be connected to the external
    process via a pipe. The `Redirect.INHERIT` value means that the external process
    will have the same input or output location as the current Java process. You can
    also redirect the input or output of data using the `Redirect.to` and `Redirect.from`
    methods.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessBuilder.Redirect`类有两个特殊值，即`Redirect.PIPE`和`Redirect.INHERIT。Redirect.PIPE`是处理外部进程IO的默认方式，简单地意味着Java进程将通过管道连接到外部进程。`Redirect.INHERIT`值意味着外部进程将具有与当前Java进程相同的输入或输出位置。你也可以使用`Redirect.to`和`Redirect.from`方法重定向数据的输入或输出。'
- en: Using the inheritIO method to inherit the default IO locations
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用inheritIO方法继承默认的IO位置
- en: 'If you execute an external process from a Java application, you can set the
    location of the source and destination data to be the same as that of the current
    Java process. The `ProcessBuilder` class'' `inheritIO` method is a convenient
    way to accomplish this. If you have a `ProcessBuilder` object `pb`, executing
    the following code:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从Java应用程序执行外部进程，你可以设置源和目标数据的位置与当前Java进程的位置相同。`ProcessBuilder`类的`inheritIO`方法是实现这一点的一种便捷方式。如果你有一个`ProcessBuilder`对象`pb`，执行以下代码：
- en: '[PRE30]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then it has the same effect as executing the following three statements together:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它具有执行以下三个语句的相同效果：
- en: '[PRE31]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In both cases, the input, output, and error data will be located in the same
    places as the current Java process' input, output, and error data.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，输入、输出和错误数据将位于与当前Java进程的输入、输出和错误数据相同的位置。
- en: Embedding a JNLP file in an HTML page
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在HTML页面中嵌入JNLP文件
- en: Java 7 provides a new option to speed up the deployment of an applet in a web
    page. Prior to 7, when applets were launched using the **Java Network Launch Protocol**
    (**JNLP**), the JNLP file must first be downloaded from the network before the
    applet can be launched. With the new release, the JNLP file can be embedded directly
    into the HTML code, reducing the amount of time the applet needs to launch. In
    this example, we are going to build a basic applet and launch it using a JNLP-embedded
    HTML page.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7提供了一个新选项，可以加快在网页中部署小程序的速度。在7之前，当使用**Java网络启动协议**（**JNLP**）启动小程序时，必须先从网络下载JNLP文件，然后才能启动小程序。有了新版本，JNLP文件可以直接嵌入到HTML代码中，减少了小程序启动所需的时间。在这个例子中，我们将构建一个基本的小程序，并使用一个嵌入了JNLP的HTML页面来启动它。
- en: Getting ready
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To speed up applet launch in Java 7, you must:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快Java 7中小程序的启动速度，你必须：
- en: Create a new Applet.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的小程序。
- en: Create and encode a JNLP file.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并编码一个JNLP文件。
- en: Add the reference to the JNLP file to an HTML page.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将JNLP文件的引用添加到HTML页面。
- en: How to do it...
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First create an applet to use in an HTML window. The following is a simple
    applet that can be used for the purposes of this recipe. This applet has two input
    fields, `subtotal` and `taxRate`, and a `calculate` button is used to calculate
    the grand total:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个小程序，用于在HTML窗口中使用。以下是一个简单的小程序，可以用于本教程的目的。这个小程序有两个输入字段，`subtotal`和`taxRate`，还有一个`calculate`按钮用于计算总额：
- en: '[PRE32]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, create a JNLP file called `JNLPExample.jnlp`. The following is a sample
    JNLP file to accompany our previous applet. Notice that within the resources tag
    a JAR file is referenced. This JAR file, containing your applet, must be in the
    same location as your JNLP file and the HTML file, which we will create in a moment:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`JNLPExample.jnlp`的JNLP文件。以下是一个示例JNLP文件，用于配合我们之前的小程序。请注意，在资源标签中引用了一个JAR文件。这个JAR文件，包含你的小程序，必须与你的JNLP文件和HTML文件在同一个位置，我们马上就会创建：
- en: '[PRE33]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After you have created the JNLP file, it must be encoded. There are several
    resources available online to convert the JNLP file to BASE64, but the one used
    for this example was [http://base64encode.org/](http://base64encode.org/). Use
    the UTF-8 charset. Once you have your encoded data, you will use this in the creation
    of an HTML file. Create an HTML file shown as follows. Notice that the BASE64-encoded
    string highlighted has been shortened for purposes of brevity, but your string
    will be much longer:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建JNLP文件后，必须对其进行编码。有几种在线资源可用于将JNLP文件转换为BASE64，但本例中使用的是[http://base64encode.org/](http://base64encode.org/)。使用UTF-8字符集。一旦你有了编码的数据，你将在创建HTML文件时使用它。创建一个如下所示的HTML文件。请注意，高亮显示的BASE64编码字符串已经为简洁起见而缩短，但你的字符串会更长：
- en: '[PRE34]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Also, notice the first script tag. To avoid using a `codebase` attribute, we
    are utilizing another new feature of Java 7 by using a Development Toolkit script.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，请注意第一个脚本标签。为了避免使用`codebase`属性，我们利用了Java 7的另一个新特性，使用了一个开发工具包脚本。
- en: 'Load your application in a browser window. You may need to enable JavaScript
    depending upon your current browser settings. Your applet should load quickly
    and appear similar to the following screenshot:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器窗口中加载你的应用程序。根据你当前的浏览器设置，你可能需要启用JavaScript。你的小程序应该快速加载，并且看起来类似于以下的截图：
- en: '![How to do it...](img/5627_09_02.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![How to do it...](img/5627_09_02.jpg)'
- en: How it works...
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Embedding the JNLP file in the HTML page allowed the applet to be loaded immediately,
    rather than having to be downloaded from the server first. The JNLP file had to
    have a relative path in the `href` attribute and the `codebase` should not be
    specified. By leaving the `codebase` attribute blank, it was determined by the
    URL of the applet's web page.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 将JNLP文件嵌入HTML页面中允许applet立即加载，而不必首先从服务器下载。JNLP文件在`href`属性中必须有相对路径，而且不应该指定`codebase`。通过将`codebase`属性留空，可以由applet网页的URL确定。
- en: The `resources` tag specified the location of your JAR file and the version
    of Java to use. The path for your JAR file was assumed to be the default working
    directory as was the location of your JNLP file. Also included in your JNLP file
    was a description of your applet, surrounded by the `applet-desc` tag. The name
    of your applet and the name of your main class file was specified in this tag.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources`标签指定了JAR文件的位置和要使用的Java版本。JAR文件的路径被假定为默认工作目录，JNLP文件的位置也是如此。JNLP文件中还包括了applet的描述，被`applet-desc`标签包围。在这个标签中指定了applet的名称和主类文件的名称。'
- en: The HTML file contained information necessary to load the applet without having
    to download the applet information from a server. We first specified that we are
    going to load the application using a JavaScript call. Then, in our first script
    tag, we added a section to allow us to call the applet without a `codebase`. This
    is advantageous because the application can be loaded and tested in different
    environments without changing the `codebase` attribute. It is, instead, inherited
    from the web page that the application is running from.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文件包含了加载applet所需的信息，而不必从服务器下载applet信息。我们首先指定要使用JavaScript调用加载应用程序。然后，在我们的第一个script标签中，我们添加了一个部分，允许我们在没有`codebase`的情况下调用applet。这是有利的，因为应用程序可以在不同的环境中加载和测试，而不必更改`codebase`属性。相反，它是从应用程序所在的网页继承而来。
- en: 'There are two functions of the Deployment Toolkit that can be used to deploy
    Java applets in a web page without a `codebase` attribute: the `launchWebStartApplication`
    and `createWebStartLaunchButtonEx`. We chose to use the `createWebStartLaunchButtonEx`
    for this recipe, but the `launchWebStartApplication` option is also discussed
    as follows. In both instances, the client must have the Java SE 7 release to launch
    the applet, and if they do not, they will be directed to the Java website to download
    the most recent version.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 部署工具包有两个函数可以在没有`codebase`属性的情况下在网页中部署Java applet：`launchWebStartApplication`和`createWebStartLaunchButtonEx`。我们选择在这个示例中使用`createWebStartLaunchButtonEx`，但`launchWebStartApplication`选项也会在下文中讨论。在这两种情况下，客户端必须具有Java
    SE 7版本才能启动applet，如果没有，他们将被引导到Java网站下载最新版本。
- en: The `createWebStartLaunchButtonEx` function created a launch button for the
    application. Within the `script` tag, the `jnlpFile` variable specified the name
    of the JNLP file and was relative to the applet's web page. This filename is then
    passed to the `deployJava.createWebStartLaunchButtonEx` function.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`createWebStartLaunchButtonEx`函数创建了一个应用程序的启动按钮。在`script`标签中，`jnlpFile`变量指定了JNLP文件的名称，并且是相对于applet网页的。然后将此文件名传递给`deployJava.createWebStartLaunchButtonEx`函数。'
- en: 'Alternatively, the `launchWebStartApplication` function could be embedded in
    an HTML link. The function is invoked within an `href` tag, shown as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，`launchWebStartApplication`函数可以嵌入到HTML链接中。该函数在`href`标签中被调用，如下所示：
- en: '[PRE35]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The second `script` tag within your HTML file contained information about your
    JNLP file. The `jnlp_href` variable stored the name of the JNLP file. The JNLP
    file's encoded form was specified by the `jnlp_embedded` parameter. The BASE64
    encoder encoded binary data for instances where the data needs to be stored and
    transferred across textual mediums, such as e-mail and XML files.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文件中的第二个`script`标签包含了有关JNLP文件的信息。`jnlp_href`变量存储了JNLP文件的名称。JNLP文件的编码形式由`jnlp_embedded`参数指定。BASE64编码器对需要在文本媒介中存储和传输数据的二进制数据进行编码，比如电子邮件和XML文件。
