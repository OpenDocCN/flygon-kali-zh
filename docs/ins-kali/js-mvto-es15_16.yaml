- en: Chapter 4. Structural Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 结构模式
- en: In the previous chapter, we looked at a number of ways to create objects in
    order to optimize for reuse. In this chapter, we'll take a look at structural
    patterns; these are patterns that are concerned with easing the design by describing
    simple ways in which objects can interact.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们看了一些创建对象以优化重用的方法。在本章中，我们将看一下结构模式；这些模式关注于通过描述对象可以相互交互的简单方式来简化设计。
- en: Again, we will limit ourselves to the patterns described in the GoF book. There
    are a number of other interesting structural patterns that have been identified
    since the publication of the GoF and we'll look at those in part 2 of the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将限制自己只讨论GoF书中描述的模式。自GoF出版以来，已经发现了许多其他有趣的结构模式，我们将在本书的第2部分中讨论这些模式。
- en: 'The patterns we''ll examine here are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里研究的模式有：
- en: Adapter
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器
- en: Bridge
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接
- en: Composite
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Decorator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰者
- en: Façade
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观
- en: Flyweight
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元
- en: Proxy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Once again, we'll discuss whether the patterns that were described years ago
    are still relevant for a different language and a different time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次讨论多年前描述的模式是否仍然适用于不同的语言和不同的时代。
- en: Adapter
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器
- en: 'From time to time there is a need to fit a round peg in a square hole. If you''ve
    ever played with a child''s shape sorting toy then you may have discovered that
    you can, in fact, put a round peg in a square hole. The hole is not completely
    filled and getting the peg in there can be difficult:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔需要将圆钉放入方孔中。如果你曾经玩过儿童的形状分类玩具，你可能会发现实际上可以将圆钉放入方孔中。孔并没有完全填满，把钉子放进去可能会很困难：
- en: '![Adapter](img/00045.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![适配器](img/00045.jpeg)'
- en: 'To improve the fit of the peg an adapter can be used. This adapter fills the
    hole in completely resulting in a perfect fit:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改善钉子的适合度，可以使用适配器。这个适配器完全填满了孔，结果是完美的适合：
- en: '![Adapter](img/00046.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![适配器](img/00046.jpeg)'
- en: In software a similar approach is often needed. We may need to make use of a
    class that does not perfectly fit the required interface. The class may be missing
    methods or may have additional methods we would like to hide. This occurs frequently
    when dealing with third party code. In order to make it comply with the interface
    needed in your code, an adapter may be required.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中通常需要类似的方法。我们可能需要使用一个不完全符合所需接口的类。该类可能缺少方法，或者可能有我们想要隐藏的额外方法。在处理第三方代码时经常会出现这种情况。为了使其符合代码中所需的接口，可能需要一个适配器。
- en: 'The class diagram for an adapter is very simple as can be seen here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器的类图非常简单，如下所示：
- en: '![Adapter](img/00047.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![适配器](img/00047.jpeg)'
- en: The interface of the implementation does not look the way we would like it to
    for use in our code. Normally the solution to this is to simply refactor the implementation
    so it looks the way we would like it to. However, there are a number of possible
    reasons that cannot be done. Perhaps the implementation exists inside third party
    code to which we have no access. It is also possible that the implementation is
    used elsewhere in the application where the interface is exactly as we would like
    it to be.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的接口看起来不符合我们在代码中想要使用的样子。通常的解决方法是简单地重构实现，使其看起来符合我们想要的样子。然而，有许多可能的原因无法这样做。也许实现存在于我们无法访问的第三方代码中。还有可能实现在应用程序的其他地方使用，接口正好符合我们想要的样子。
- en: The adapter class is a thin piece of code that implements the required interface.
    It typically wraps a private copy of the implementation class and proxy calls
    through to it. The adapter pattern is frequently used to change the abstraction
    level of the code. Let's take a look at a quick example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器类是一小段代码，它实现了所需的接口。它通常包装了实现类的私有副本，并通过代理调用到它。适配器模式经常用于改变代码的抽象级别。让我们来看一个快速的例子。
- en: Implementation
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: In the land of Westeros, much of the trade and travel is done by boat. It is
    not only more dangerous to travel by ship than to walk or travel by horse, but
    also riskier due to the constant presence of storms and pirates. These ships are
    not the sort which might be used by Royal Caribbean to cruise around the Caribbean;
    they are crude things which might look more at home captained by 15th century
    European explorers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Westeros的土地上，许多贸易和旅行都是通过船只进行的。乘船不仅比步行或骑马更危险，而且由于风暴和海盗的不断出现，也更加危险。这些船只不是皇家加勒比公司用来在加勒比海周游的那种船只；它们是粗糙的东西，看起来更适合15世纪的欧洲探险家驾驶。
- en: 'While I am aware that ships exist, I have very little knowledge of how they
    work or how I might go about navigating one. I imagine that many people are in
    the same (*cough!*) boat as me. If we look at the interface for a Ship in Westeros,
    it looks intimidating:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我知道船只存在，但我对它们的工作方式或如何操纵它们知之甚少。我想很多人和我一样。如果我们看一下Westeros的船只接口，它看起来很吓人：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I would really like a much simpler interface that abstracts away all the fiddly
    little details. Ideally something like the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很想要一个更简单的接口，可以将所有繁琐的细节都抽象化。理想情况下，类似以下的东西：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This looks like something I could probably figure out even living in a city
    that is over 1000 kilometers from the nearest ocean. In short, what I'm looking
    for is a higher-level abstraction around the Ship. In order to transform a Ship
    into a SimpleShip we need an adapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是我可能会弄清楚的东西，即使我住在离最近的海洋有1000公里以上的城市。简而言之，我要找的是对船进行更高级别的抽象。为了将船转换为SimpleShip，我们需要一个适配器。
- en: 'The adapter will have the interface of SimpleShip but it will perform actions
    on a wrapped instance of Ship. The code might look something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器将具有SimpleShip的接口，但它将在Ship的包装实例上执行操作。代码可能看起来像这样：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In reality these functions would be far more complex, but it should not matter
    much because we've got a nice simple interface to present to the world. The presented
    interface can also be set up so as to restrict access to certain methods on the
    underlying type. When building library code, adapters can be used to mask the
    internal method and only present the limited functions needed to the end user.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些函数可能会更加复杂，但这并不重要，因为我们有一个简单的接口呈现给世界。呈现的接口也可以设置为限制对底层类型的某些方法的访问。在构建库代码时，适配器可以用来隐藏内部方法，只向最终用户呈现所需的有限功能。
- en: 'To use this pattern, the code might look like:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种模式，代码可能如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You would likely not want to use adapter in the name of your client class as
    it leaks some information about the underlying implementation. Clients should
    be unaware they are talking to an adapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不想在客户端类的名称中使用适配器，因为这会泄露一些关于底层实现的信息。客户端应该不知道它们正在与适配器交谈。
- en: The adapter itself can grow to be quite complex to adjust one interface to another.
    In order to avoid creating very complex adapters, care must be taken. It is certainly
    not inconceivable to build several adapters, one atop another. If you find an
    adapter becoming too large then it is a good idea to stop and examine if the adapter
    is following the single responsibility principle. That is to say, ensure that
    each class has only one thing for which it has some responsibility. A class that
    looks up users from a database should not also contain functionality for sending
    e-mails to these users. That is too much responsibility. Complex adapters can
    be replaced with a composite object, which will be explored later in this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器本身可能会变得非常复杂，以调整一个接口到另一个接口。为了避免创建非常复杂的适配器，必须小心谨慎。构建多个适配器是完全可以想象的，一个叠加在另一个之上。如果发现一个适配器变得太大，那么停下来检查一下适配器是否遵循单一职责原则是个好主意。也就是说，确保每个类只负责一件事。一个从数据库中查找用户的类不应该包含发送电子邮件给这些用户的功能。这责任太大了。复杂的适配器可以用复合对象来替换，这将在本章后面探讨。
- en: From the testing perspective, adapters can be used to totally wrap third party
    dependencies. In this scenario they provide a place into which to hook tests.
    Unit tests should avoid testing libraries but they can certainly test the adapters
    to ensure that they are proxying through the correct calls.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试的角度来看，适配器可以用来完全包装第三方依赖。在这种情况下，它们提供了一个可以挂接测试的地方。单元测试应该避免测试库，但它们肯定可以测试适配器，以确保它们正在正确地代理调用。
- en: The adapter is a very powerful pattern for simplifying code interfaces. Massaging
    interfaces to better match a requirement is useful in countless places. The pattern
    is certainly useful in JavaScript. Applications written in JavaScript tend to
    make use of a large number of small libraries. By wrapping up these libraries
    in adapters I'm able to limit the number of places I interact with the libraries
    directly; this means that the libraries can easily be replaced.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器是简化代码接口的非常强大的模式。调整接口以更好地匹配需求在无数地方都是有用的。这种模式在JavaScript中肯定是有用的。用JavaScript编写的应用程序往往会使用大量的小型库。通过用适配器封装这些库，我能够限制我直接与库交互的地方的数量；这意味着可以轻松替换这些库。
- en: The adapter pattern can be slightly modified to provide consistent interfaces
    over a number of different implementations. This is usually known as the bridge
    pattern.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式可以稍作修改，以在多种不同的实现上提供一致的接口。这通常被称为桥接模式。
- en: Bridge
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥
- en: The bridge pattern takes the adapter pattern to a new level. Given an interface,
    we can build multiple adapters, each one of which acts as an intermediary to a
    different implementation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式将适配器模式提升到一个新的水平。给定一个接口，我们可以构建多个适配器，每个适配器都作为到不同实现的中介。
- en: 'An excellent example that I''ve run across, is dealing with two different services
    that provide more or less the same functionality and are used in a failover configuration.
    Neither service provides exactly the interface required by the application and
    both services provide different APIs. In order to simplify the code, adapters
    are written to provide a consistent interface. The adapters implement a consistent
    interface and provide fills so that each API can be called consistently. To expand
    on the shape sorter metaphor a bit more, we can imagine that we have a variety
    of different pegs we would like to use to fill the square hole. Each adapter fills
    in the missing bits and helps us get a good fit:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到的一个很好的例子是，处理两个提供几乎相同功能并且在故障转移配置中使用的不同服务。两个服务都没有提供应用程序所需的确切接口，而且两个服务提供了不同的API。为了简化代码，编写了适配器以提供一致的接口。适配器实现了一致的接口，并提供填充，以便可以一致地调用每个API。再举一个形状分类器的比喻，我们可以想象我们有各种不同的销子，我们想用它们来填充方形孔。每个适配器都填补了缺失的部分，并帮助我们得到一个良好的匹配。
- en: '![Bridge](img/00048.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![桥](img/00048.jpeg)'
- en: 'The bridge is a very useful pattern. Let''s take a look at how to implement
    it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接是一个非常有用的模式。让我们看看如何实现它：
- en: '![Bridge](img/00049.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![桥](img/00049.jpeg)'
- en: The adapters shown in the preceding diagram sit between the implementation and
    the desired interface. They modify the implementation to fit in with the desired
    interface.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中显示的适配器位于实现和所需接口之间。它们修改实现以符合所需的接口。
- en: Implementation
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: We've already discussed that in the land of Westeros the people practice a number
    of disparate religions. Each one has a different way of praying and making offerings.
    There is a lot of complexity around making the correct prayers at the correct
    time and we would like to avoid exposing this complexity. Instead we'll write
    a series of adapters that can simplify prayers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过，在维斯特洛大陆上，人们信仰多种不同的宗教。每种宗教都有不同的祈祷和献祭方式。在正确的时间做出正确的祈祷是非常复杂的，我们希望避免暴露这种复杂性。相反，我们将编写一系列可以简化祈祷的适配器。
- en: 'The first thing we need is a number of different gods to which we can pray:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要一些不同的神灵来祈祷：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These classes should look familiar as they are basically the same classes found
    in the previous chapter where they were used as examples for the factory method.
    You may notice, however, that the signature for the `prayTo` method for each religion
    is slightly different. This proves to be something of an issue when building a
    consistent interface like the one shown in pseudo code here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类应该看起来很熟悉，因为它们基本上是前一章中找到的相同的类，它们被用作工厂方法的示例。然而，你可能会注意到，每种宗教的`prayTo`方法的签名略有不同。当构建一个像这里伪代码中所示的一致接口时，这可能会成为一个问题：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So let''s slot in a few adapters to act as a bridge between the classes we
    have and the signature we would like the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们插入一些适配器，作为我们拥有的类和我们想要的签名之间的桥梁：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Each one of these adapters implements the `God` interface we wanted and abstracts
    away the complexity of dealing with three different interfaces, one for each god:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些适配器中的每一个都实现了我们想要的`God`接口，并抽象了处理三种不同接口的复杂性，每种接口对应一个神：
- en: 'To use the Bridge pattern, we could write code like so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用桥接模式，我们可以编写如下代码：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code uses the bridges to provide a consistent interface to the gods such
    that they can all be treated as equals.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用桥接提供了一个一致的接口，使得所有的神都可以被视为相等。
- en: In this case we are simply wrapping the individual gods and proxying method
    calls through to them. The adapters could each wrap a number of objects and this
    is another useful place in which to use the adapter. If a complex series of objects
    needs to be orchestrated, then an adapter can take some responsibility for that
    orchestration providing a simpler interface to other classes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只是简单地包装了各个神，并通过代理方法调用它们。适配器可以包装多个对象，这是另一个有用的地方可以使用适配器。如果需要协调一系列复杂的对象，那么适配器可以承担一些责任，提供一个更简单的接口给其他类。
- en: You can imagine how useful the bridge pattern is. It can be used well in conjunction
    with the factory method pattern presented in the previous chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象桥接模式有多么有用。它可以与前一章介绍的工厂方法模式很好地结合使用。
- en: This pattern certainly remains a very useful one for use in JavaScript. As I
    mentioned at the start of this section, it is handy for dealing with different
    APIs in a consistent fashion. I have used it for swapping in different third party
    components such as different graphing libraries or phone system integration points.
    If you're building applications on a mobile platform using JavaScript, then the
    bridge pattern is going to be a great friend for you, allowing you to separate
    your common and platform specific code cleanly. Because there are no interfaces
    in JavaScript, the bridge pattern is far closer to the adapter in JavaScript than
    in other languages. In fact, it is basically exactly the same.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在JavaScript中仍然非常有用。正如我在本节开头提到的，它对于以一致的方式处理不同的API非常方便。我曾经用它来交换不同的第三方组件，比如不同的图形库或电话系统集成点。如果你正在使用JavaScript构建移动平台上的应用程序，桥接模式将成为你的好朋友，可以帮助你清晰地分离通用代码和特定平台的代码。因为JavaScript中没有接口，桥接模式在JavaScript中比其他语言更接近适配器。实际上，它基本上是一样的。
- en: A bridge also makes testing easier. We are able to implement a fake bridge and
    use this to ensure that the calls into the bridge are correct.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接还可以使测试变得更容易。我们可以实现一个虚拟的桥接，并使用它来确保对桥接的调用是正确的。
- en: Composite
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: In the previous chapter I mentioned that we would like to avoid coupling our
    objects together tightly. Inheritance is a very strong form of coupling and I
    suggested that, instead, composites should be used. The composite pattern is a
    special case of this in which the composite is treated as interchangeable with
    the components. Let's explore how the composite pattern works.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我提到我们希望避免将对象之间的耦合紧密地联系在一起。继承是一种非常强的耦合形式，我建议使用组合代替。组合模式是这种情况的一个特例，其中组合被视为可与组件互换。让我们探讨一下组合模式是如何工作的。
- en: 'The following class diagram contains two different ways to build a composite
    component:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的类图包含了两种不同的构建组合组件的方式：
- en: '![Composite](img/00050.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![组合](img/00050.jpeg)'
- en: In the first one, the composite component is built from a fixed number of a
    variety of components. The second component is constructed from a collection of
    indeterminate length. In both cases the components contained within the parent
    composition could be of the same type as the composition. So a composition may
    contain instances of its own type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，组合组件是由各种组件的固定数量构建的。第二个组件是由一个不确定长度的集合构建的。在这两种情况下，父组合中包含的组件可能与组合的类型相同。因此，一个组合可以包含其自身类型的实例。
- en: The key feature of the composite pattern is the interchangeability of a component
    with its children. So, if we have a composite which implements `IComponent`, then
    all of the components of the composite will also implement `IComponent`. This
    is, perhaps, best illustrated with an example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式的关键特点是组件与其子组件的可互换性。因此，如果我们有一个实现了`IComponent`的组合，那么组合的所有组件也将实现`IComponent`。这可能最好通过一个例子来说明。
- en: Example
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: Tree structures are very useful in computing. It turns out that a hierarchical
    tree can represent many things. A tree is made up of a series of nodes and edges
    and is a cyclical. In a binary tree, each node contains a left and right child
    until we get down to the terminal nodes known as leaves.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 树结构在计算中非常有用。事实证明，分层树可以表示许多事物。树由一系列节点和边组成，是循环的。在二叉树中，每个节点包含左右子节点，直到我们到达称为叶子的终端节点。
- en: 'While life is difficult in Westeros there is an opportunity for taking joy
    in things like religious holidays or weddings. At these events there is typically
    a great deal of feasting on delicious foods. The recipes for these foods is much
    as you would find in your own set of recipes. A simple dish like baked apples
    contains a list of ingredients:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然维斯特洛的生活很艰难，但人们有机会享受宗教节日或婚礼等事物。在这些活动中，通常会大量享用美味食物。这些食物的食谱与您自己的食谱一样。像烤苹果这样的简单菜肴包含以下成分列表：
- en: Baking apple
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 烘烤苹果
- en: Honey
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蜂蜜
- en: Butter
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄油
- en: Nuts
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坚果
- en: Each one of these ingredients implements an interface which we'll refer to as
    `IIngredient`. More complex recipes contain more ingredients, but in addition
    to that, more complex recipes may contain complex ingredients that are themselves
    made from other ingredients.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成分中的每一个都实现了一个我们将称之为`IIngredient`的接口。更复杂的食谱包含更多的成分，但除此之外，更复杂的食谱可能包含复杂的成分，这些成分本身是由其他成分制成的。
- en: 'A popular dish in a southern part of Westeros is a dessert which is not at
    all unlike what we would call tiramisu. It is a complex recipe with ingredients
    such as:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 维斯特洛南部的一道流行菜肴是一道甜点，与我们所称的提拉米苏非常相似。这是一个复杂的食谱，其中包括以下成分：
- en: Custard
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡斯塔德
- en: Cake
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蛋糕
- en: Whipped cream
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打发奶油
- en: Coffee
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 咖啡
- en: 'Of course custard itself is made from:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，卡斯塔德本身是由以下成分制成的：
- en: Milk
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 牛奶
- en: Sugar
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 糖
- en: Eggs
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鸡蛋
- en: Vanilla
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 香草
- en: Custard is a composite as is coffee and cake.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 卡斯塔德和咖啡蛋糕都是复合成分。
- en: Operations on the composite object are typically proxied through to all of the
    contained objects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 复合对象上的操作通常通过代理传递到所有包含的对象。
- en: Implementation
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'A simple ingredient, one which would be a leaf node, is shown in this code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中显示了一个简单的成分，它将是一个叶节点：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It can be used interchangeably with a compound ingredient which has a list
    of ingredients:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以与具有成分列表的复合成分交替使用：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The composite ingredient loops over its internal ingredients and performs the
    same operation on each of them. There is, of course, no need to define an interface
    due to the prototype model.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 复合成分循环遍历其内部成分，并对每个成分执行相同的操作。当然，由于原型模型，无需定义接口。
- en: 'To make use of this compound ingredient we might do:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这种复合成分，我们可能会这样做：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Of course this only shows part of the power of the pattern. We could use rice
    pudding as an ingredient in an even more complicated recipe: rice pudding stuffed
    buns (they have some strange foods in Westeros). As both the simple and compound
    version of the ingredient have the same interface, the caller does not need to
    know that there is any difference between the two ingredient types.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是显示了模式的一部分能力。我们可以将米布丁用作更复杂的食谱的一部分：米布丁馅饼（在维斯特洛有一些奇怪的食物）。由于简单和复合版本的成分具有相同的接口，因此调用者不需要知道两种成分类型之间有任何区别。
- en: 'Composite is a heavily used pattern in JavaScript code that deals with HTML
    elements, as they are a tree structure. For example, the jQuery library provides
    a common interface if you have selected a single element or a collection of elements.
    When a function is called it is actually called on all the children, for instance:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 复合是JavaScript代码中广泛使用的模式，用于处理HTML元素，因为它们是树结构。例如，jQuery库提供了一个通用接口，如果您选择了单个元素或一组元素。当调用函数时，实际上是在所有子元素上调用，例如：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will hide all the links on a page regardless of how many elements are actually
    found by calling `$("a")`. The composite is a very useful pattern for JavaScript
    development.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将隐藏页面上的所有链接，而不管调用`$("a")`实际找到了多少元素。复合对于JavaScript开发非常有用。
- en: Decorator
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: The decorator pattern is used to wrap and augment an existing class. Using a
    decorator pattern is an alternative to subclassing an existing component. Subclassing
    is typically a compile time operation and is a tight coupling. This means that
    once subclassing is performed, there is no way to alter it at runtime. In cases
    where there are many possible subclassings that can act in combination, the number
    of combinations of subclassings explodes. Let's look at an example.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式用于包装和增强现有的类。使用装饰器模式是替代对现有组件进行子类化的一种方法。子类化通常是一个编译时操作，是一种紧密的耦合。这意味着一旦进行了子类化，就无法在运行时更改它。在存在许多可能的子类化可以组合的情况下，子类化的组合数量会激增。让我们看一个例子。
- en: 'The armor worn by knights in Westeros can be quite configurable. Armor can
    be fabricated in a number of different styles: scale, lamellar, chainmail, and
    so on. In addition to the style of armor, there is also a variety of different
    face guards, knee, and elbow joints, and, of course, colors. The behavior of armor
    made from lamellar and a grille is different from chainmail with a face visor.
    You can see, however, that there is a large number of possible combinations; far
    too many combinations to explicitly code.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 维斯特洛的骑士所穿的盔甲可以是非常可配置的。盔甲可以以多种不同的风格制作：鳞甲、板甲、锁子甲等。除了盔甲的风格之外，还有各种不同的面罩、膝盖和肘部关节，当然还有颜色。由板甲和面罩制成的盔甲的行为与带有面罩的锁子甲不同。然而，您可以看到，可能的组合数量很大；远远超过了可以明确编码的组合数量。
- en: 'What we do instead is implement the different styles of armor using the decorator
    pattern. A decorator works using a similar theory to the adapter and bridge patterns,
    in that it wraps another instance and proxy calls through. The decorator pattern,
    however, performs the redirections at runtime by having the instance to wrap passed
    into it. Typically, a decorator will act as a simple pass through for some methods
    and for others it will make some modifications. These modifications could be limited
    to performing an additional action before passing the call off to the wrapped
    instance or could go so far as to change the parameters passed in. A UML representation
    of the decorator pattern looks like the following diagram:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是使用装饰器模式实现不同风格的装甲。装饰器使用与适配器和桥接模式类似的理论，它包装另一个实例并通过代理调用。然而，装饰器模式通过将要包装的实例传递给它在运行时执行重定向。通常，装饰器将作为一些方法的简单传递，对于其他方法，它将进行一些修改。这些修改可能仅限于在将调用传递给包装实例之前执行附加操作，也可能会改变传入的参数。装饰器模式的UML表示如下图所示：
- en: '![Decorator](img/00051.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Decorator](img/00051.jpeg)'
- en: This allows for very granular control over which methods are altered by the
    decorator and which remain as mere pass-through. Let's take a look at an implementation
    of the pattern in JavaScript.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许对装饰器修改的方法进行非常精细的控制，而其他方法则保持为简单的传递。让我们看一下JavaScript中模式的实现。
- en: Implementation
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'In this code we have a base class, `BasicArmor`, and it is then decorated by
    the `ChainMail` class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们有一个基类`BasicArmor`，然后由`ChainMail`类进行装饰：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `ChainMail` armor takes in an instance of armor that complies with an interface,
    such as:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChainMail`装甲接受符合接口的装甲实例，例如：'
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That instance is wrapped and calls proxied through. The method `GetArmorIntegiry`
    modifies the result from the underlying class while `CalculateDamageFromHit` modifies
    the arguments that are passed into the decorated class. This `ChainMail` class
    could, itself, be decorated with several more layers of decorators until a long
    chain of methods is actually called for each method call. This behavior, of course,
    remains invisible to outside callers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该实例被包装，并通过代理调用。方法`GetArmorIntegiry`修改了基础类的结果，而`CalculateDamageFromHit`修改了传递给装饰类的参数。`ChainMail`类本身可以被装饰多层装饰器，直到实际为每个方法调用了一长串方法。当然，这种行为对外部调用者来说是不可见的。
- en: 'To make use of this armor decorator, look at the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个装甲修饰器，请查看以下代码：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is tempting to make use of JavaScript's ability to rewrite individual methods
    on classes to implement this pattern. Indeed, in an earlier draft of this section
    I had intended to suggest just that. However, doing so is syntactically messy
    and not a common way of doing things. One of the most important things to keep
    in mind when programming is that code must be maintainable, not only by you but
    also by others. Complexity breeds confusion and confusion breeds bugs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 诱人的是利用JavaScript重写类的单个方法来实现这种模式的能力。事实上，在本节的早期草案中，我本打算建议这样做。然而，这样做在语法上很混乱，也不是一种常见的做法。编程时最重要的一点是代码必须是可维护的，不仅对你自己而且对其他人也是如此。复杂性导致混乱，混乱导致错误。
- en: The decorator pattern is a valuable pattern for scenarios where inheritance
    is too limiting. These scenarios still exist in JavaScript, so the pattern remains
    useful.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式是一种对继承过于限制的情况非常有价值的模式。这些情况在JavaScript中仍然存在，因此该模式仍然有用。
- en: Façade
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观
- en: 'The façade pattern is a special case of the Adapter pattern that provides a
    simplified interface over a collection of classes. I mentioned such a scenario
    in the section on the adapter pattern but only within the context of a single
    class, `SimpleShip`. This same idea can be expanded to provide an abstraction
    around a group of classes or an entire subsystem. The façade pattern in UML form
    looks like the following diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式是适配器模式的一种特殊情况，它在一组类上提供了简化的接口。我在适配器模式的部分提到过这样的情景，但只在`SimpleShip`类的上下文中。这个想法可以扩展到提供一个抽象，围绕一组类或整个子系统。UML形式的外观模式如下图所示：
- en: '![Façade](img/00052.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Façade](img/00052.jpeg)'
- en: Implementation
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'If we take the same `SimpleShip` as before and expand it to an entire fleet,
    we have a great example of a use for creating a façade. If it was difficult to
    sail a single ship it would be far more difficult to command an entire fleet of
    ships. There is a great deal of nuance required, commands to individual ships
    would have to be made. In addition to the individual ships there must also be
    a fleet Admiral and a degree of coordination between the ships in order to distribute
    supplies. All of this can be abstracted away. If we have a collection of classes
    representing the aspects of a fleet such as these:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将之前的`SimpleShip`扩展到整个舰队，我们就有了一个创建外观的很好的例子。如果操纵单艘船很困难，那么指挥整个舰队将更加困难。需要大量的细微差别，必须对单独的船只进行命令。除了单独的船只外，还必须有一位舰队上将以及船只之间的协调程度，以便分发补给。所有这些都可以被抽象化。如果我们有一系列类来表示舰队的各个方面，比如这些：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we might build a façade as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以构建一个如下的外观：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Façades are very useful abstractions, especially in dealing with APIs. Using
    a façade around a granular API can create an easier interface. The level of abstraction
    at which the API works can be raised so that it is more in sync with how your
    application works. For instance, if you''re interacting with the Azure blob storage
    API you could raise the level of abstraction from working with individual files
    to working with collections of files. Instead of writing the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 外观在处理API时非常有用。在粒度API周围使用外观可以创建一个更简单的接口。API的抽象级别可以提高，使其更符合应用程序的工作方式。例如，如果您正在与Azure
    blob存储API交互，您可以将抽象级别从处理单个文件提高到处理文件集。而不是编写以下内容：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A façade could be written which encapsulates all of these calls and provides
    an interface, like:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编写一个外观，封装所有这些调用并提供一个接口，如：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see façades remain useful in JavaScript and should be a pattern that
    remains in your toolbox.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，外观在JavaScript中仍然很有用，并且应该是您工具箱中保留的模式。
- en: Flyweight
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 享元
- en: In boxing there is a light weight division between 49-52 kg known as the flyweight
    division. It was one of the last divisions to be established and was named, I
    imagine, for the fact that the fighters in it were tiny, like flies.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在拳击中，有一个49-52公斤之间的轻量级级别，称为蝇量级。这是最后一个成立的级别之一，我想它之所以被命名为蝇量级，是因为其中的拳击手很小，就像苍蝇一样。
- en: The flyweight pattern is used in instances when there are a large number of
    instances of objects which vary only slightly. I should perhaps pause here to
    mention that a large number, in this situation, is probably in the order of 10,000
    objects rather than 50 objects. However, the cutoff for the number of instances
    is highly dependent on how expensive the object is to create.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象的实例数量很大且仅略有不同时，可以使用享元模式。在这种情况下，大量实例的数量可能是指1万个对象而不是50个对象。然而，实例数量的截止点高度依赖于对象的创建成本。
- en: In some cases, the object may be so expensive that only a handful are required
    before they overload the system. In this case introducing flyweight at a smaller
    number would be beneficial. Maintaining a full object for each object consumes
    a lot of memory. It seems that the memory is largely consumed wastefully too,
    as most of the instances have the same value for their fields. Flyweight offers
    a way to compress this data by only keeping track of the values that differ from
    some prototype in each instance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，对象可能非常昂贵，以至于在超载系统之前只需要少数对象。在这种情况下，以较小数量引入享元将是有益的。为每个对象维护完整的对象会消耗大量内存。似乎大部分内存也被浪费地消耗掉了，因为大多数实例的字段具有相同的值。享元通过仅跟踪与每个实例中的某个原型不同的值来压缩这些数据。
- en: JavaScript's prototype model is ideal for this scenario. We can simply assign
    the most common value to the prototype and have individual instances override
    them as needed. Let's see how that looks with an example.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的原型模型非常适合这种情况。我们可以简单地将最常见的值分配给原型，并让各个实例根据需要进行覆盖。让我们看一个例子。
- en: Implementation
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'Returning once more to Westeros (aren''t you glad I''ve opted for a single
    overarching problem domain?) we find that armies are full of ill-equipped fighting
    people. Within this set of people there is really very little difference from
    the perspective of the generals. Certainly each person has their own life, ambitions,
    and dreams but they have all been adapted into simple fighting automatons in the
    eyes of the general. The general is only concerned with how well the soldiers
    fight, if they''re healthy, and if they''re well fed. We can see the simple set
    of fields in this code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回到维斯特洛（你是否为我选择了一个单一的主要问题领域感到高兴？），我们发现军队中充满了装备不足的战斗人员。在这些人中，从将军的角度来看，实际上没有太大的区别。当然，每个人都有自己的生活、抱负和梦想，但在将军眼中，他们都已经成为简单的战斗自动机。将军只关心士兵们打得多好，他们是否健康，以及他们是否吃饱了。我们可以在这段代码中看到简单的字段集：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Of course, with an army of 10,000 soldiers, keeping track of all of this requires
    quite some memory. Let''s take a different approach and use a class:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，拥有一支由1万名士兵组成的军队，需要相当多的内存来跟踪所有这些。让我们采用不同的方法并使用一个类：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Using this approach, we are able to defer all requests for the soldier''s health
    to the prototype. Setting the value is easy too:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，我们能够将对士兵健康的所有请求推迟到原型。设置值也很容易：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You'll note that we make a call to delete to remove the property override and
    return the value back to the parent value.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，我们调用delete来删除属性覆盖，并将值返回给父值。
- en: Proxy
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: 'The final pattern presented in this chapter is the proxy. In the previous section
    I mentioned how it is expensive to create objects and how we would like to avoid
    creating too many of them. The proxy pattern provides a method of controlling
    the creation and use of expensive objects. The UML of the proxy pattern looks
    like the following diagram:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的最后一个模式是代理。在前一节中，我提到创建对象是昂贵的，我们希望避免创建太多对象。代理模式提供了一种控制创建和使用昂贵对象的方法。代理模式的UML如下图所示：
- en: '![Proxy](img/00053.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![代理](img/00053.jpeg)'
- en: 'As you can see, the proxy mirrors the interface of the actual instance. It
    is substituted in for the instance in all the clients and, typically, wraps a
    private instance of the class. There are a number of places where the proxy pattern
    can be of use:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代理反映了实际实例的接口。它替代了所有客户端中的实例，并且通常包装了类的私有实例。代理模式可以发挥作用的地方有很多：
- en: Lazy instantiation of an expensive object
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 昂贵对象的延迟实例化
- en: Protection of secret data
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护秘密数据
- en: Stubbing for remote method invocation
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于远程方法调用的存根
- en: Interposing additional actions before or after method invocation
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法调用之前或之后插入额外的操作
- en: Often an object is expensive to instantiate and we don't want to have instances
    created before they're actually used. In this case the proxy can check its internal
    instance and, if not yet initiated, create it before passing on the method call.
    This is known as lazy instantiation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，实例化对象是昂贵的，我们不希望在实际使用之前就创建实例。在这种情况下，代理可以检查其内部实例，并在传递方法调用之前，如果尚未初始化，则创建它。这被称为延迟实例化。
- en: If a class has been designed without any security in mind but now requires some,
    this can be provided through the use of a proxy. The proxy will check the call
    and only pass on the method call in cases where the security checks out.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类在设计时没有考虑任何安全性，但现在需要一些安全性，可以通过使用代理来提供。代理将检查调用，并仅在安全检查通过的情况下传递方法调用。
- en: The proxy may be used to simply provide an interface to methods that are invoked
    somewhere else. In fact, this is exactly how a number of web socket libraries
    function, proxying calls back to the web server.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 代理可以简单地提供一个接口，用于在其他地方调用方法。事实上，这正是许多Web套接字库的功能，将调用代理到Web服务器。
- en: Finally, there may be cases where it is useful to interpose some functionality
    into the method invocation. This could be logging of parameters, validating of
    parameters, altering results, or any number of things.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可能有些情况下，将一些功能插入到方法调用中是有用的。这可以是参数的日志记录，参数的验证，结果的修改，或者其他任何事情。
- en: Implementation
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: Let's take a look at a Westeros example where method interposition is needed.
    As tends to happen, the units of measurement for liquids vary greatly from one
    side of the land to the other. In the north, one might buy a pint of beer, while
    in the south, one would buy it by the dragon. This causes no end of confusion
    and code duplication, but can be solved by wrapping classes that care about measurement
    in proxies.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个需要方法插入的Westeros的例子。通常情况下，液体的计量单位在这片土地的一边和另一边有很大的差异。在北方，人们可能会买一品脱啤酒，而在南方，人们会用龙来购买。这导致了很多混乱和代码重复，但可以通过包装关心测量的类来解决代理问题。
- en: 'For example, this code is for a barrel calculator which estimates the number
    of barrels needed to ship a quantity of liquid:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这段代码是用于估算运输液体所需的桶数的桶计算器：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Although it is not well documented, here this version takes pints as a volume
    parameter. A proxy is created which deals with the transformation thusly:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它没有很好的文档记录，但这个版本将品脱作为体积参数。创建了一个处理转换的代理：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Equally we might create another proxy for a pint-based barrel calculator:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可能会为基于品脱的桶计算器创建另一个代理：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This proxy class does the unit conversion for us and helps alleviate some confusion
    around units. Some languages, such as F#, support the concept of units of measure.
    In effect it is a typing system which is overlaid over simple data types such
    as integers, preventing programmers from making mistakes such as adding a number
    representing pints to one representing liters. Out of the box in JavaScript there
    is no such capability. Using a library such as JS-Quantities ([http://gentooboontoo.github.io/js-quantities/](http://gentooboontoo.github.io/js-quantities/))
    is an option however. If you look at it, you'll see the syntax is quite painful.
    This is because JavaScript doesn't permit operator overloading. Having seen how
    weird adding things such as an empty array to an empty array are (it results in
    an empty string), I think perhaps we can be thankful that operator overloading
    isn't supported.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代理类为我们进行了单位转换，并有助于减轻一些关于单位的混乱。一些语言，比如F#，支持计量单位的概念。实际上，它是一个在简单数据类型（如整数）上叠加的类型系统，防止程序员犯错，比如将代表品脱的数字加到代表升的数字上。在JavaScript中，没有这样的能力。但可以使用JS-Quantities（[http://gentooboontoo.github.io/js-quantities/](http://gentooboontoo.github.io/js-quantities/)）这样的库。如果你看一下，你会发现它的语法非常痛苦。这是因为JavaScript不允许操作符重载。看到像将一个空数组加到另一个空数组上这样奇怪的事情（结果是一个空字符串），也许我们可以庆幸JavaScript不支持操作符重载。
- en: 'If we wanted to protect against accidentally using the wrong sort of calculator
    when we have pints and think we have dragons, then we could stop with our primitive
    obsession and use a type for the quantity, a sort of poor person''s units of measure:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要防止在有品脱而以为有龙的情况下意外使用错误类型的计算器，那么我们可以停止使用原始类型，并使用一种用于数量的类型，一种类似于贫穷人的计量单位：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This can then be used as a guard in the proxy:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以将其用作代理中的保护：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we end up with pretty much what JS-Quantities does but in a
    more ES6 form.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们最终得到了JS-Quantities所做的事情，但以更符合ES6的形式。
- en: The proxy is absolutely a useful pattern within JavaScript. I already mentioned
    that it is used by web socket libraries when generating stubs but it finds itself
    useful in countless other locations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式绝对是JavaScript中非常有用的模式。我已经提到它在生成存根时被Web套接字库使用，但它在无数其他位置也非常有用。
- en: Hints and tips
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: Many of the patterns presented in this chapter provide methods of abstracting
    functionality and of molding interfaces to look the way you want. Keep in mind
    that with each layer of abstraction a cost is introduced. Function calls take
    longer but it is also much more confusing for people who need to understand your
    code. Tooling can help a little but tracking a function call through nine layers
    of abstraction is never fun.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的许多模式提供了抽象功能和模型接口的方法。请记住，每增加一层抽象都会引入一定的成本。函数调用会变得更慢，但对于需要理解你的代码的人来说，这也会更加混乱。工具可以帮助一点，但跟踪一个函数调用穿过九层抽象从来都不是一件有趣的事情。
- en: Also be wary of doing too much in the façade pattern. It is very easy to turn
    the façade into a fully-fledged management class and that degrades easily into
    a God object that is responsible for coordinating and doing everything.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 同时要谨慎使用外观模式。很容易将外观模式转化为一个完整的管理类，这很容易变成一个负责协调和执行所有任务的上帝对象。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we've looked at a number of patterns used to structure the interaction
    between objects. Some of them are quite similar to each other but they are all
    useful in JavaScript, although the bridge is effectively reduced to an adapter.
    In the next chapter we'll finish our examination of the original GoF patterns
    by looking at behavioral patterns.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看过了许多用于构造对象之间交互的模式。它们中的一些相互之间非常相似，但它们在JavaScript中都很有用，尽管桥接模式实际上被简化为适配器。在下一章中，我们将通过研究行为模式来完成对原始GoF模式的审查。
