- en: Domain-Driven Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计
- en: This chapter sets the tone for the rest of the chapters by referring to one
    sample project. The sample project will be used to explain different microservices
    concepts from here onward. This chapter uses this sample project to drive through
    different combinations of functional and domain services, or applications to explain
    **domain-driven design** (**DDD**). It will help you to learn the fundamentals
    of DDD and its practical usage. You will also learn the concepts of designing
    domain models using REST services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过参考一个样本项目为接下来的章节设定了基调。从这里开始，将使用这个样本项目来解释不同的微服务概念。本章使用这个样本项目来介绍功能和领域服务的不同组合，或者应用来解释领域驱动设计（DDD）。它将帮助您学习DDD的基础知识及其实际用途。您还将学习使用REST服务设计领域模型的概念。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Fundamentals of DDD
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DDD基础
- en: How to design an application using DDD
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用DDD设计应用程序
- en: Domain models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域模型
- en: A sample domain model design based on DDD
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于DDD的样本领域模型设计
- en: A good software design is as much the key to the success of a product or services
    as the functionalities offered by it. It carries equal weight to the success of
    product; for example, `Amazon.com` provides the shopping platform, but its architecture
    design makes it different from other similar sites and contributes to its success.
    It shows how important a software or architecture design is for the success of
    a product/service. DDD is one of the software design practices, and we'll explore
    it with various theories and practical examples.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的软件设计对产品或服务的成功同样重要，就像它所提供的功能一样。它对产品的成功具有同等重要性；例如，“Amazon.com”提供了购物平台，但其架构设计使其与其他类似网站不同，并促成了其成功。它展示了软件或架构设计对产品/服务成功的重要性。DDD是软件设计实践之一，我们将通过各种理论和实际示例来探讨它。
- en: DDD is a key design practice that helps to design the microservices of the product
    that you are developing. Therefore, we'll first explore DDD before jumping into
    microservices development. After studying this chapter, you will understand the
    importance of DDD for microservices development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: DDD是一种关键的设计实践，有助于设计您正在开发的产品的微服务。因此，在深入研究微服务开发之前，我们将首先探讨DDD。学习本章后，您将了解DDD对微服务开发的重要性。
- en: Domain-driven design fundamentals
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计基础
- en: An enterprise, or cloud application, solves business problems and other real-world
    problems. These problems cannot be resolved without knowledge of the domain. For
    example, you cannot provide a software solution for a financial system such as
    online stock trading if you don't understand the stock exchanges and their functioning.
    Therefore, having domain knowledge is a must for solving problems. Now, if you
    want to offer a solution using software or applications, you need to design it
    with the help of domain knowledge. When we combine the domain and software design,
    it offers a software design methodology known as DDD.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 企业或云应用程序解决业务问题和其他现实世界问题。这些问题如果没有领域知识是无法解决的。例如，如果您不了解股票交易所及其运作方式，就无法为在线股票交易等金融系统提供软件解决方案。因此，具有领域知识对于解决问题是必不可少的。现在，如果您想使用软件或应用程序提供解决方案，您需要借助领域知识进行设计。当我们将领域和软件设计结合起来时，就形成了一种称为DDD的软件设计方法。
- en: When we develop software to implement real-world scenarios offering the functionalities
    of a domain, we create a model of the domain. A **model** is an abstraction, or
    a blueprint, of the domain.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发软件来实现领域的实际场景，提供领域功能时，我们创建领域的模型。一个**模型**是领域的抽象，或者蓝图。
- en: 'Eric Evans coined the term DDD in his book *Domain-Driven Design: Tackling
    Complexity in the Heart of Software*, published in 2004.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 埃里克·埃文斯在他2004年出版的书《领域驱动设计：应对软件核心的复杂性》中创造了DDD这个术语。
- en: Designing this model is not rocket science, but it does take a lot of effort,
    refining, and input from domain experts. It is the collective job of software
    designers, domain experts, and developers. They organize information, divide it
    into smaller parts, group them logically, and create modules. Each module can
    be taken up individually, and can be divided using a similar approach. This process
    can be followed until we reach the unit level, or when we cannot divide it any
    further. A complex project may have more of such iterations; similarly, a simple
    project could have just a single iteration of it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 设计这个模型并不是什么难事，但它需要大量的努力、完善和来自领域专家的输入。这是软件设计师、领域专家和开发人员的共同工作。他们组织信息，将其分成较小的部分，逻辑地分组并创建模块。每个模块都可以单独处理，并且可以使用类似的方法进行划分。这个过程可以一直持续下去，直到达到单元级别，或者无法再进一步划分为止。一个复杂的项目可能会有更多这样的迭代；同样，一个简单的项目可能只有一个迭代。
- en: Once a model is defined and well documented, it can move onto the next stage
    - code design. So, here we have a **software design**—a domain model and code
    design, and code implementation of the domain model. The domain model provides
    a high level of the architecture of a solution (software/application), and the
    code implementation gives the domain model a life, as a working model.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模型被定义并得到充分记录，它就可以进入下一个阶段——代码设计。因此，我们有了**软件设计**——领域模型和代码设计，以及领域模型的代码实现。领域模型提供了解决方案（软件/应用程序）的高层架构，而代码实现使领域模型具有了生命，成为一个可工作的模型。
- en: DDD makes design and development work together. It provides the ability to develop
    software continuously, while keeping the design up to date based on feedback received
    from the development. It solves one of the limitations offered by Agile and Waterfall
    methodologies, making software maintainable, including design and code, as well
    as keeping application minimum viable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: DDD使设计和开发工作协同合作。它提供了持续开发软件的能力，同时根据开发收到的反馈保持设计最新。它解决了敏捷和瀑布方法所提供的局限性之一，使软件可维护，包括设计和代码，同时保持应用程序的最低可行性。
- en: Design-driven development involves a developer from the initial stage, and all
    meetings where software designers discuss the domain with domain experts in the
    modeling process. It gives developers the right platform to understand the domain,
    and provides the opportunity to share early feedback of the domain model implementation.
    It removes the bottleneck that appears in later stages when stockholders wait
    for deliverables.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 设计驱动开发涉及开发人员从初始阶段开始，并且在软件设计人员与领域专家讨论领域的建模过程中的所有会议。它为开发人员提供了正确的平台来理解领域，并提供了早期分享领域模型实施的反馈的机会。它消除了在股东等待可交付成果时出现的瓶颈。
- en: Fundamentals of DDD
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DDD的基本原理
- en: 'To understand domain-driven design, we can broadly categorize these three concepts:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解领域驱动设计，我们可以广泛地将这三个概念分类：
- en: Ubiquitous language and unified model language (UML)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普遍语言和统一建模语言（UML）
- en: Multilayer architecture
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多层架构
- en: Artifacts (components)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工件（组件）
- en: The following sections explain the usage and importance of ubiquitous language
    and multilayer architecture. There will also be an explanation of the different
    artifacts to be used in the model-driven design.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将解释普遍语言和多层架构的用法和重要性。还将解释在模型驱动设计中使用的不同工件。
- en: Ubiquitous language
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 普遍语言
- en: '**Ubiquitous language** is a common language to communicate within a project.
    As we have seen, designing a model is the collective effort of software designers,
    domain experts, and developers; therefore, it requires a common language to communicate
    with. DDD makes it necessary to use ubiquitous language. Domain models use ubiquitous
    language in their diagrams, descriptions, presentations, speeches, and meetings.
    It removes the misunderstanding, misinterpretation, and communication gap among
    them. Therefore, it must be included in all diagrams, description, presentations,
    meetings, and so on—in short, in everything.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**普遍语言**是项目内部进行沟通的通用语言。正如我们所见，设计模型是软件设计人员、领域专家和开发人员的集体努力；因此，它需要一种通用语言来进行沟通。DDD使使用普遍语言成为必要。领域模型在其图表、描述、演示、演讲和会议中使用普遍语言。它消除了他们之间的误解、误解和沟通隔阂。因此，它必须包含在所有图表、描述、演示、会议等中，总之，包括在所有方面。'
- en: '**Unified Modeling Language** (**UML**) is widely used and very popular when
    creating models. It also has a few limitations; for example, when you have thousands
    of classes drawn from a paper, it''s difficult to represent class relationships
    and simultaneously understand their abstraction while taking a meaning from it.
    Also, UML diagrams do not represent the concepts of a model and what objects are
    supposed to do. Therefore, UML should always be used with other documents, code,
    or any other reference for effective communication.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一建模语言**（**UML**）在创建模型时被广泛使用并且非常受欢迎。它也有一些局限性；例如，当您从纸上绘制成千上万的类时，很难表示类之间的关系并同时理解它们的抽象，同时从中获得意义。此外，UML图表不代表模型的概念以及对象应该做什么。因此，UML应始终与其他文档、代码或任何其他参考一起使用，以实现有效的沟通。'
- en: Other ways to communicate the domain model include the use of documents, code,
    and so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其他沟通领域模型的方式包括使用文档、代码等。
- en: Multilayered architecture
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多层架构
- en: 'Multilayered architecture is a common solution for DDD. It contains four layers:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 多层架构是DDD的常见解决方案。它包含四个层：
- en: Presentation layer or **User Interface** (**UI**).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表示层或**用户界面**（**UI**）。
- en: Application layer.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用层。
- en: Domain layer.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 领域层。
- en: Infrastructure layer.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基础层。
- en: '![](img/eb42878f-3e3d-4baa-a278-53c9d626d2d3.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb42878f-3e3d-4baa-a278-53c9d626d2d3.jpg)'
- en: Layered architecture
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构
- en: You can see here that only the **Domain** layer is responsible for the domain
    model, and others are related to other components such as UI, application logic,
    and so on. This layered architecture is very important. It keeps domain-related
    code separate from other layers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到，只有**领域**层负责领域模型，其他层与其他组件（如UI、应用逻辑等）相关。这种分层架构非常重要。它将与领域相关的代码与其他层分开。
- en: In this multilayered architecture, each layer contains its respective code,
    and it helps to achieve loose coupling and avoids mixing code from different layers.
    It also helps the product/service's long-term maintainability and the ease of
    enhancements, as the change of one-layer code does not impact on other components
    if the change is intended for the respective layer only. Each layer can be switched
    with another implementation easily with multi-tier architecture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种多层架构中，每个层都包含其各自的代码，并有助于实现松耦合，避免混合来自不同层的代码。它还有助于产品/服务的长期可维护性和增强的便利性，因为一层代码的更改不会影响其他组件，如果更改仅针对相应的层。每个层都可以轻松地与多层架构中的另一个实现进行切换。
- en: Presentation layer
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示层
- en: This layer represents the UI, and provides the user interface for the interaction
    and information display. This layer could be a web application, mobile application,
    or a third-party application consuming your services.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此层代表UI，并为交互和信息显示提供用户界面。这一层可以是Web应用程序、移动应用程序或消费您服务的第三方应用程序。
- en: Application layer
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用层
- en: This layer is responsible for application logic. It maintains and coordinates
    the overall flow of the product/service. It does not contain business logic or
    UI. It may hold the state of application objects, like tasks in progress. For
    example, your product **REST services** would be part of this application layer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此层负责应用逻辑。它维护和协调产品/服务的整体流程。它不包含业务逻辑或UI。它可能保存应用对象的状态，比如正在进行的任务。例如，您的产品**REST服务**将是此应用层的一部分。
- en: Domain layer
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域层
- en: The domain layer is a very important layer, as it contains the domain information
    and business logic. It holds the state of the business object. It persists the
    state of the business objects, and communicates these persisted states to the
    infrastructure layer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 领域层是非常重要的一层，因为它包含领域信息和业务逻辑。它保存业务对象的状态。它持久化业务对象的状态，并将这些持久化的状态传达给基础层。
- en: Infrastructure layer
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础层
- en: This layer provides support to all the other layers and is responsible for communication
    among the other layers. It contains the supporting libraries that are used by
    the other layers. It also implements the persistence of business objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层为所有其他层提供支持，并负责其他层之间的通信。它包含其他层使用的支持库。它还实现了业务对象的持久化。
- en: To understand the interaction of the different layers, let us use an example
    of table booking at a restaurant. The end user places a request for a table booking
    using UI. The UI passes the request to the application layer. The application
    layer fetches the domain objects, such as the restaurant, the table, a date, and
    so on, from the domain layer. The domain layer fetches these existing persisted
    objects from the infrastructure, and invokes relevant methods to make the booking
    and persist them back to the infrastructure layer. Once domain objects are persisted,
    the application layer shows the booking confirmation to the end user.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解不同层之间的交互，让我们以餐厅的桌子预订为例。最终用户使用 UI 提出了桌子预订的请求。UI 将请求传递给应用程序层。应用程序层从领域层获取领域对象，如餐厅、桌子、日期等。领域层从基础设施中获取这些现有的持久化对象，并调用相关方法进行预订并将其持久化到基础设施层。一旦领域对象被持久化，应用程序层向最终用户显示预订确认。
- en: Artifacts of domain-driven design
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计的工件
- en: 'There are seven different artifacts used in DDD to express, create, and retrieve
    domain models:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DDD 中有七种不同的工件用于表达、创建和检索领域模型：
- en: Entities
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体
- en: Value objects
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值对象
- en: Services
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Aggregates
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合
- en: Repository
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库
- en: Factory
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂
- en: Module
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Entities
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体
- en: Entities are certain types of objects that are identifiable and remain the same
    throughout the states of the products/services. These objects are not identified
    by their attributes, but by their identity and thread of continuity. These type
    of objects are known as **entities**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 实体是可识别的并在产品/服务的状态中保持不变的某些类型的对象。这些对象不是通过它们的属性来识别的，而是通过它们的标识和连续性来识别的。这种类型的对象被称为实体。
- en: It sounds pretty simple, but it carries complexity. You need to understand how
    we can define the entities. Let's take an example of a table booking system, where
    we have a `restaurant` class with attributes such as restaurant name, address,
    phone number, establishment data, and so on. We can take two instances of the
    `restaurant` class that are not identifiable using the restaurant name, as there
    could be other restaurants with the same name. Similarly, if we go by any other
    single attribute, we will not find any attributes that can singularly identify
    a unique restaurant. If two restaurants have all the same attribute values, they
    are therefore the same and are interchangeable with each other. Still, they are
    not the same entities, as both have different references (memory addresses).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很简单，但它带有复杂性。您需要了解如何定义实体。让我们以桌子预订系统为例，我们有一个 `restaurant` 类，具有属性如餐厅名称、地址、电话号码、成立日期等。我们可以拿两个
    `restaurant` 类的实例，它们不能使用餐厅名称来识别，因为可能有其他同名的餐厅。同样，如果我们按任何其他单个属性来进行，我们将找不到可以单独标识唯一餐厅的属性。如果两家餐厅具有相同的属性值，它们因此是相同的，并且可以互换。但它们不是相同的实体，因为它们具有不同的引用（内存地址）。
- en: Conversely, let's take a class of US citizens. Each citizen has his or her own
    social security number. This number is not only unique, but remains unchanged
    throughout the life of the citizen and assures continuity. This `citizen` object
    would exist in the memory, would be serialized, and would be removed from the
    memory and stored in the database. It even exists after the person is deceased.
    It will be kept in the system for as long as the system exists. A citizen's social
    security number remains the same irrespective of its representation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们以美国公民为例。每个公民都有自己的社会安全号码。这个号码不仅是唯一的，而且在公民的一生中保持不变，并保证连续性。这个 `citizen` 对象将存在于内存中，将被序列化，并将从内存中移除并存储在数据库中。即使在人去世后，它仍然存在。它将在系统存在的时间内保留下来。公民的社会安全号码不论其表示如何都保持不变。
- en: Therefore, creating entities in a product means creating an **identity**. So,
    now give an identity to any restaurant in the previous example, then either use
    a combination of attributes such as restaurant name, establishment date, and street,
    or add an identifier such as `restaurant_id` to identify it. The basic rule is
    that two identifiers cannot be the same. Therefore, when we introduce an identifier
    for an entity, we need to be sure of it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在产品中创建实体意味着创建一个标识。因此，现在给出前面例子中任何餐厅的标识，然后使用属性的组合，如餐厅名称、成立日期和街道，或者添加一个标识符，如
    `restaurant_id` 来标识它。基本规则是两个标识符不能相同。因此，当我们为实体引入标识符时，我们需要确保它。
- en: 'There are different ways to create a unique identity for objects, described
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法来为对象创建唯一的标识，如下所述：
- en: Using the **primary key** in a table.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表中使用**主键**。
- en: Using an **automated generated ID** by a domain module. A domain program generates
    the identifier and assigns it to objects that are being persisted among different
    layers.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过领域模块使用**自动生成的 ID**。领域程序生成标识符并将其分配给在不同层之间持久化的对象。
- en: A few real-life objects carry **user-defined identifiers** themselves. For example,
    each country has its own country codes for dialing ISD calls.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些现实生活中的对象本身携带用户定义的标识符。例如，每个国家都有自己拨打 ISD 电话的国家代码。
- en: '**Composite key.** This is a combination of attributes that can also be used
    for creating an identifier, as explained for the preceding `restaurant` object.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合键。这是属性的组合，也可以用于创建标识符，如前面的 `restaurant` 对象所述。
- en: '*Entities are very important for domain models. Therefore, they should be defined
    from the initial stage of the modeling process*.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*实体对于领域模型非常重要。因此，它们应该从建模过程的初始阶段开始定义*。'
- en: When an object can be identified by its identifier and not by its attributes,
    a class representing these objects should have a simple definition, and care should
    be taken with the life cycle continuity and identity. It's imperative to identify
    objects in this class that have the same attribute values. A defined system should
    return a unique result for each object if queried. Designers should ensure that
    the model defines what it means to be the same thing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象可以通过其标识符而不是其属性来识别时，表示这些对象的类应该有一个简单的定义，并且应该注意生命周期连续性和身份。对于这个类中的对象，有相同的属性值是至关重要的。如果查询，定义的系统应该为每个对象返回一个唯一的结果。设计者应确保模型定义了什么是相同的东西。
- en: Value objects
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值对象
- en: '**Value objects (VOs)** simplify the design. Entities have traits such as identity,
    a thread of continuity, and attributes that do not define their identity. In contrast
    to entities, value objects have only attributes and no conceptual identity. A
    best practice is to keep value objects as immutable objects. If possible, you
    should even keep entity objects immutable too.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**值对象（VOs）**简化了设计。实体具有诸如身份、连续性线索和不定义其身份的属性等特征。与实体相反，值对象只有属性，没有概念上的身份。最佳实践是将值对象保持为不可变对象。如果可能的话，甚至应该将实体对象也保持为不可变对象。'
- en: Entity concepts may bias you to keep all objects as entities, as a uniquely
    identifiable object in the memory or database with life cycle continuity, but
    there has to be one instance for each object. Now, let's say you are creating
    customers as entity objects. Each customer object would represent the restaurant
    guest, and this cannot be used for booking orders for other guests. This may create
    millions of customer entity objects in the memory if millions of customers are
    using the system. Not only are there millions of uniquely identifiable objects
    that exist in the system, but each object is being tracked. Tracking as well as
    creating an identity is complex. A highly credible system is required to create
    and track these objects, which is not only very complex, but also resource heavy.
    It may result in system performance degradation. Therefore, it is important to
    use value objects instead of using entities. The reasons are explained in the
    next few paragraphs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实体概念可能会让你倾向于将所有对象都保留为实体，作为内存或数据库中具有生命周期连续性的唯一可识别对象，但每个对象都必须有一个实例。现在，假设你正在创建实体对象作为客户。每个客户对象都代表餐厅客人，这不能用于为其他客人预订订单。如果有数百万客户使用系统，这可能会在内存中创建数百万个客户实体对象。系统中存在数百万个唯一可识别的对象，而且每个对象都在被跟踪。跟踪和创建身份都很复杂。需要一个高度可信的系统来创建和跟踪这些对象，这不仅非常复杂，而且资源消耗很大。这可能导致系统性能下降。因此，重要的是使用值对象而不是实体。原因将在接下来的几段中解释。
- en: Applications don't always need to have to be trackable and have an identifiable
    customer object. There are cases when you just need to have some or all attributes
    of the domain element. These are the cases when value objects can be used by the
    application. It makes things simple and improves the performance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序并不总是需要可追踪和可识别的客户对象。有时你只需要领域元素的一些或全部属性。在这些情况下，应用程序可以使用值对象。这样做简化了事情并提高了性能。
- en: Value objects can easily be created and destroyed, owing to the absence of identity.
    This simplifies the design—it makes value objects available for garbage collection
    if no other object has referenced them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象可以很容易地创建和销毁，因为它们没有身份。这简化了设计——如果没有其他对象引用它们，值对象就可以被垃圾回收。
- en: Let's discuss the value object's immutability. Value objects should be designed
    and coded as immutable. Once they are created, they should never be modified during
    their life-cycle. If you need a different value of the VO, or any of its objects,
    then simply create a new value object, but don't modify the original value object.
    Here, immutability carries all the significance from **object-oriented programming**
    (**OOP**). A value object can be shared and used without impacting on its integrity
    if, and only if, it is immutable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下值对象的不可变性。值对象应该被设计和编码为不可变的。一旦它们被创建，它们在其生命周期内就不应该被修改。如果你需要值对象的不同值，或者它的任何对象，那么只需创建一个新的值对象，而不要修改原始值对象。在这里，不可变性从**面向对象编程**（**OOP**）中承载了所有的重要性。如果值对象是不可变的，它就可以被共享和使用，而不会影响其完整性。
- en: FAQs
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: Can a value object contain another value object?
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值对象是否可以包含另一个值对象？
- en: Yes, it can
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以的
- en: Can a value object refer to another value object or entity?
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值对象是否可以引用另一个值对象或实体？
- en: Yes, it can
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以的
- en: Can I create a value object using the attributes of different value objects
    or entities?
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以使用不同值对象或实体的属性创建一个值对象吗？
- en: Yes, you can
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以的
- en: Services
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: While creating the domain model, you may encounter various situations where
    behavior may not be related to any object specifically. These behaviors can be
    accommodated in **service objects**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建领域模型时，可能会遇到各种情况，其中行为可能与任何特定对象无关。这些行为可以容纳在**服务对象**中。
- en: Service objects are part of domain layer that does not have any internal state.
    The sole purpose of service objects is to provide behavior to the domain that
    does not belong to a single entity or value object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 服务对象是领域层的一部分，它没有任何内部状态。服务对象的唯一目的是为领域提供行为，这些行为不属于单个实体或值对象。
- en: Ubiquitous language helps you to identify different objects, identities, or
    value objects with different attributes and behaviors during the process of domain
    modeling. During the course of creating the domain model, you may find different
    behaviors or methods that do not belong to any specific object. Such behaviors
    are important, and so cannot be neglected. Neither can you add them to entities
    or value objects. It would spoil the object to add behavior that does not belong
    to it. Keep in mind, that behavior may impact on various objects. The use of object-oriented
    programming makes it possible to attach to some objects; this is known as a **service**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 普遍语言可以帮助您在领域建模过程中识别不同的对象、标识或值对象，以及它们的不同属性和行为。在创建领域模型的过程中，您可能会发现不属于任何特定对象的不同行为或方法。这些行为很重要，因此不能被忽视。也不能将它们添加到实体或值对象中。向实体或值对象添加不属于它们的行为会破坏对象。请记住，行为可能会影响各种对象。面向对象编程的使用使得可以将其附加到某些对象上；这就是所谓的**服务**。
- en: Services are common in technical frameworks. These are also used in domain layers
    in DDD. A service object does not have any internal state; the only purpose of
    it is to provide a behavior to the domain. Service objects provide behaviors that
    cannot be related to specific entities or value objects. Service objects may provide
    one or more related behaviors to one or more entities or value objects. It is
    a practice to define the services explicitly in the domain model.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 服务在技术框架中很常见。它们也在领域驱动设计中的领域层中使用。服务对象没有任何内部状态；它的唯一目的是为领域提供行为。服务对象提供的行为不能与特定实体或值对象相关联。服务对象可以为一个或多个实体或值对象提供一个或多个相关行为。在领域模型中明确定义服务是一种做法。
- en: 'While creating the services, you need to tick all of the following points:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建服务时，您需要勾选以下所有要点：
- en: Service objects' behavior performs on entities and value objects, but it does
    not belong to entities or value objects
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务对象的行为是在实体和值对象上执行的，但它不属于实体或值对象。
- en: Service objects' behavior state is not maintained, and hence, they are stateless
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务对象的行为状态不会被维护，因此它们是无状态的。
- en: Services are part of the domain model
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务是领域模型的一部分。
- en: Services may also exist in other layers. It is very important to keep domain-layer
    services isolated. It removes the complexities and keeps the design decoupled.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 服务也可能存在于其他层。将领域层服务隔离非常重要。这样可以消除复杂性并保持设计解耦。
- en: Let's take an example where a restaurant owner wants to see the report of his
    monthly table bookings. In this case, he will log in as an admin and click the
    **Display Report** button after providing the required input fields, such as duration.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，餐厅老板想要查看他的月度餐桌预订报告。在这种情况下，他将以管理员身份登录，并在提供所需的输入字段（如持续时间）后，单击**显示报告**按钮。
- en: Application layers pass the request to the domain layer that owns the report
    and templates objects, with some parameters such as report ID, and so on. Reports
    get created using the template, and data is fetched from either the database or
    other sources. Then the application layer passes through all the parameters, including
    the report ID to the business layer. Here, a template needs to be fetched from
    the database or another source to generate the report based on the ID. This operation
    does not belong to either the report object or the template object. Therefore,
    a service object is used that performs this operation to retrieve the required
    template from the database.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层将请求传递给拥有报告和模板对象的领域层，其中包括一些参数，如报告ID等。报告使用模板创建，并且数据从数据库或其他来源获取。然后应用层通过所有参数，包括报告ID，传递到业务层。在这里，需要从数据库或其他来源获取模板，以根据ID生成报告。这个操作不属于报告对象或模板对象。因此，使用服务对象执行此操作，以从数据库中检索所需的模板。
- en: Aggregates
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: Aggregate domain pattern is related to the object's life cycle, and defines
    ownership and boundaries.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合领域模式与对象的生命周期有关，并定义了所有权和边界。
- en: When you reserve a table at your favorite restaurant online using an application,
    you don't need to worry about the internal system and process that takes place
    to book your reservation, including searching for available restaurants, then
    for available tables on the given date, time, and so on and so forth. Therefore,
    you can say that a reservation application is an **aggregate** of several other
    objects, and works as a **root** for all the other objects for a table reservation
    system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在使用应用程序在线预订您最喜欢的餐厅的桌子时，您不需要担心用于预订您的预订的内部系统和流程，包括搜索可用的餐厅，然后搜索给定日期、时间等可用的桌子。因此，您可以说预订应用程序是几个其他对象的**聚合**，并且作为表预订系统的**根**。
- en: This root should be an entity that binds collections of objects together. It
    is also called the **aggregate root**. This root object does not pass any reference
    of inside objects to external worlds, and protects the changes performed within
    internal objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个根应该是将对象集合绑定在一起的实体。它也被称为**聚合根**。这个根对象不会将内部对象的任何引用传递给外部世界，并保护内部对象内部的更改。
- en: We need to understand why aggregators are required. A domain model can contain
    large numbers of domain objects. The bigger the application functionalities and
    size and the more complex its design, the greater number of objects present. A
    relationship exists between these objects. Some may have a many-to-many relationship,
    a few may have a one-to-many relationship, and others may have a one-to-one relationship.
    These relationships are enforced by the model implementation in the code, or in
    the database that ensures that these relationships among the objects are kept
    intact. Relationships are not just unidirectional; they can also be bidirectional.
    They can also increase in complexity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解为什么需要聚合器。领域模型可能包含大量的领域对象。应用功能越大，规模越大，设计越复杂，对象的数量就越多。这些对象之间存在关系。有些可能存在多对多的关系，有些可能存在一对多的关系，还有一些可能存在一对一的关系。这些关系由代码中的模型实现或数据库强制执行，以确保这些对象之间的关系保持完整。关系不仅是单向的；它们也可以是双向的。它们也可能变得更加复杂。
- en: The designer's job is to simplify these relationships in the model. Some relationships
    may exist in a real domain, but may not be required in the domain model. Designers
    need to ensure that such relationships do not exist in the domain model. Similarly,
    multiplicity can be reduced by these constraints. One constraint may do the job
    where many objects satisfy the relationship. It is also possible that a bidirectional
    relationship could be converted into a unidirectional relationship.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设计师的工作是简化模型中的这些关系。一些关系可能存在于真实领域中，但在领域模型中可能并不需要。设计师需要确保领域模型中不存在这样的关系。同样，这些约束可以减少多重性。一个约束可能可以满足多个对象之间的关系。也有可能将双向关系转换为单向关系。
- en: No matter how much simplification you input, you may still end up with relationships
    in the model. These relationships need to be maintained in the code. When one
    object is removed, the code should remove all the references to this object from
    other places. For example, a record removal from one table needs to be addressed
    wherever it has references in the form of foreign keys and such, to keep the data
    consistent and maintain its integrity. Also, invariants (rules) need to be forced
    and maintained whenever data changes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您输入多少简化，模型中可能仍然存在关系。这些关系需要在代码中进行维护。当一个对象被移除时，代码应该从其他地方移除对该对象的所有引用。例如，从一个表中删除记录需要在具有外键引用的地方进行处理，以保持数据一致性并维护其完整性。此外，不变量（规则）需要在数据发生变化时被强制执行和维护。
- en: Relationships, constraints, and invariants bring a complexity that requires
    an efficient handling in code. We find the solution by using the aggregate represented
    by the single entity known as the root**,** which is associated with the group
    of objects that maintains consistency with regards to data changes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关系、约束和不变量带来了一种需要在代码中进行高效处理的复杂性。我们通过使用由单个实体表示的聚合来找到解决方案，该实体称为根，与一组对象相关联，以保持数据变化的一致性。
- en: This root is the only object that is accessible from outside, so this root element
    works as a boundary gate that separates the internal objects from the external
    world. Roots can refer to one or more inside objects, and these inside objects
    can have references to other inside objects that may or may not have relationships
    with the root. However, outside objects can also refer to the root, and not to
    any inside objects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个根是唯一可以从外部访问的对象，因此这个根元素作为一个边界门，将内部对象与外部世界分隔开。根可以引用一个或多个内部对象，这些内部对象可以引用其他内部对象，这些内部对象可能与根具有或不具有关系。然而，外部对象也可以引用根，而不是任何内部对象。
- en: An aggregate ensures data integrity and enforces the invariant. Outside objects
    cannot make any change to inside objects; they can only change the root. However,
    they can use the root to make a change inside the object by calling exposed operations.
    The root should pass the value of inside objects to outside objects if required.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合确保数据完整性并强制不变量。外部对象不能对内部对象进行任何更改；它们只能更改根。但是，它们可以使用根来通过调用公开的操作对内部对象进行更改。如果需要，根应将内部对象的值传递给外部对象。
- en: If an aggregate object is stored in the database, then the query should only
    return the aggregate object. Traversal associations should be used to return the
    object when it is internally linked to the aggregate root. These internal objects
    may also have references to other aggregates.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个聚合对象存储在数据库中，那么查询应该只返回聚合对象。遍历关联应该用于在内部链接到聚合根时返回对象。这些内部对象可能还引用其他聚合。
- en: An aggregate root entity holds its global identity, and holds local identities
    inside their entities.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合根实体保存其全局标识，并在其实体内部保存局部标识。
- en: A simple example of an aggregate in the table booking system is the customer.
    Customers can be exposed to external objects, and their root object contains their
    internal object address and contact information.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在表预订系统中，聚合的一个简单例子是客户。客户可以暴露给外部对象，其根对象包含其内部对象地址和联系信息。
- en: 'When requested, the value object of internal objects, such as address, can
    be passed to external objects:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求时，内部对象的值对象，比如地址，可以传递给外部对象：
- en: '![](img/813a40c6-d3de-48ee-af15-123cafde5086.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/813a40c6-d3de-48ee-af15-123cafde5086.jpg)'
- en: The customer as an aggregate
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 客户作为一个聚合
- en: Repository
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储库
- en: In a domain model, at a given point in time, many domain objects may exist.
    Each object may have its own life-cycle, from the creation of objects to their
    removal or persistence. Whenever any domain operation needs a domain object, it
    should retrieve the reference of the requested object efficiently. It would be
    very difficult if you didn't maintain all of the available domain objects in a
    central object. A central object carries the references of all the objects, and
    is responsible for returning the requested object reference. This central object
    is known as the **repository**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域模型中，任何时刻可能存在许多领域对象。每个对象可能都有自己的生命周期，从对象的创建到其移除或持久化。每当任何领域操作需要领域对象时，它应该有效地检索所请求对象的引用。如果不在一个中央对象中维护所有可用的领域对象，那将会非常困难。中央对象携带所有对象的引用，并负责返回所请求的对象引用。这个中央对象被称为**存储库**。
- en: The repository is a point that interacts with infrastructures such as the database
    or file system. A repository object is the part of the domain model that interacts
    with storage such as the database, external sources, and so on, to retrieve the
    persisted objects. When a request is received by the repository for an object's
    reference, it returns the existing object's reference. If the requested object
    does not exist in the repository, then it retrieves the object from storage. For
    example, if you need a customer, you would query the repository object to provide
    the customer with ID `31`. The repository would provide the requested customer
    object if it is already available in the repository, and if not, it would query
    the persisted stores such as the database, fetch it, and provide its reference.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库是与数据库或文件系统等基础设施交互的一个点。存储库对象是领域模型的一部分，它与存储（如数据库、外部来源等）交互，以检索持久化的对象。当存储库收到关于对象引用的请求时，它会返回现有对象的引用。如果存储库中不存在请求的对象，则它会从存储中检索对象。例如，如果您需要一个客户，您可以查询存储库对象以提供ID为`31`的客户。如果存储库中已经有所请求的客户对象，存储库将提供该客户对象的引用；如果没有，它将查询持久化存储（如数据库）、提取对象，并提供其引用。
- en: The main advantage of using the repository is having a consistent way to retrieve
    objects where the requestor does not need to interact directly with the storage
    such as the database.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存储库的主要优势是以一致的方式检索对象，请求者无需直接与存储（如数据库）交互。
- en: 'A repository may query objects from various storage types, such as one or more
    databases, filesystems, or factory repositories, and so on. In such cases, a repository
    may have strategies that also point to different sources for different object
    types or categories:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库可能从各种存储类型（如一个或多个数据库、文件系统或工厂存储库等）中查询对象。在这种情况下，存储库可能具有策略，也指向不同的来源以获取不同的对象类型或类别：
- en: '![](img/b8f1ce0c-5528-4b86-9b3c-78c58bcfedfd.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8f1ce0c-5528-4b86-9b3c-78c58bcfedfd.jpg)'
- en: Repository object flow
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库对象流
- en: As shown in the repository object flow diagram, the r**epository** interacts
    with the i**nfrastructure layer,** and this interface is part of the **domain
    layer**. The **requestor** may belong to a domain layer, or an application layer.
    The r**epository** helps the system to manage the life cycle of domain objects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如存储库对象流图所示，存储库与基础设施层交互，这个接口是领域层的一部分。请求者可能属于领域层或应用层。存储库帮助系统管理领域对象的生命周期。
- en: Factory
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂
- en: A **factory** is required when a simple constructor is not enough to create
    the object. It helps to create complex objects, or an aggregate that involves
    the creation of other related objects.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当简单的构造函数不足以创建对象时，需要一个**工厂**。它有助于创建复杂的对象，或涉及创建其他相关对象的聚合。
- en: A factory is also a part of the life cycle of domain objects, as it is responsible
    for creating them. Factories and repositories are in some way related to each
    other, as both refer to domain objects. The factory refers to newly created objects,
    whereas the repository returns the already existing objects either from the memory,
    or from external storage.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂也是领域对象生命周期的一部分，因为它负责创建它们。工厂和存储库在某种程度上是相关的，因为两者都涉及领域对象。工厂指的是新创建的对象，而存储库返回已经存在的对象，无论是从内存还是外部存储中。
- en: Let's see how control flows, by using a user creation process application. Let's
    say that a user signs up with a username `user1`. This user creation first interacts
    with the factory, which creates the name `user1` and then caches it in the domain
    using the repository, which also stores it in the storage for persistence.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用用户创建过程应用程序来看看控制流。假设用户使用用户名`user1`注册。这个用户创建首先与工厂交互，工厂创建名称`user1`并将其缓存到领域中，同时存储在存储库中以进行持久化。
- en: When the same user logs in again, the call moves to the repository for a reference.
    This uses the storage to load the reference and pass it to the requestor.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当同一用户再次登录时，调用移至存储库以获取引用。这使用存储加载引用并将其传递给请求者。
- en: 'The requestor may then use this `user1` object to book the table in a specified
    restaurant, and at a specified time. These values are passed as parameters, and
    a table booking record is created in storage using the repository:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请求者随后可以使用此`user1`对象在指定的餐厅预订桌子，并在指定的时间。这些值作为参数传递，并使用存储库在存储中创建一个桌子预订记录：
- en: '![](img/3e0af162-b03b-49e1-8570-c8ad9657db94.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e0af162-b03b-49e1-8570-c8ad9657db94.jpg)'
- en: Repository object flow
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库对象流
- en: The factory may use one of the object-oriented programming patterns, such as
    the factory or abstract factory pattern, for object creation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂可以使用面向对象编程模式之一，如工厂模式或抽象工厂模式，进行对象创建。
- en: Modules
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: '**Modules** are the best way to separate related business objects. These are
    best suited to large projects where the size of domain objects is bigger. For
    the end user, it makes sense to divide the domain model into modules and set the
    relationship between these modules. Once you understand the modules and their
    relationship, you start to see the bigger picture of the domain model, thus it''s
    easier to drill down further and understand the model.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块**是分离相关业务对象的最佳方式。这些最适合于领域对象较大的大型项目。对于最终用户来说，将领域模型划分为模块并设置这些模块之间的关系是有意义的。一旦你理解了模块及其关系，你就开始看到领域模型的整体图景，因此更容易深入了解模型。'
- en: Modules also help in code that is highly cohesive, or that maintains low coupling.
    Ubiquitous language can be used to name these modules. For the table booking system,
    we could have different modules, such as user-management, restaurants and tables,
    analytics and reports, and reviews, and so on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 模块还有助于代码高度内聚或保持低耦合。通用语言可以用来命名这些模块。对于桌位预订系统，我们可以有不同的模块，如用户管理、餐厅和桌位、分析和报告、评论等。
- en: Strategic design and principles
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 战略设计和原则
- en: An enterprise model is usually very large and complex. It may be distributed
    among different departments in an organization. Each department may have a separate
    leadership team, so working and designing together can create difficulty and coordination
    issues. In such scenarios, maintaining the integrity of the domain model is not
    an easy task.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 企业模型通常非常庞大和复杂。它可能分布在组织的不同部门之间。每个部门可能有一个单独的领导团队，因此一起工作和设计可能会产生困难和协调问题。在这种情况下，维护领域模型的完整性并不是一件容易的事。
- en: In such cases, working on a unified model is not the solution, and large enterprise
    models need to be divided into different submodels. These submodels contain the
    predefined accurate relationship and contract in minute detail. Each submodel
    has to maintain the defined contracts without any exception.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，统一模型不是解决方案，大型企业模型需要分成不同的子模型。这些子模型包含了预定义的精确关系和合同的细节。每个子模型都必须在没有任何异常的情况下维护定义的合同。
- en: 'There are various principles that could be followed to maintain the integrity
    of the domain model, and these are listed as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种原则可以遵循来维护领域模型的完整性，列举如下：
- en: Bounded context
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有界上下文
- en: Continuous integration
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Context map
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文映射
- en: Shared kernel
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内核
- en: Customer-supplier
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顾客-供应商
- en: Conformist
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺从者
- en: Anticorruption layer
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反腐层
- en: Separate ways
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分道扬镳
- en: Open Host Service
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放主机服务
- en: Distillation
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蒸馏
- en: Bounded context
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有界上下文
- en: When you have different submodels, it is difficult to maintain the code when
    all submodels are combined. You need to have a small model that can be assigned
    to a single team. You might need to collect the related elements and group them.
    Context keeps and maintains the meaning of the domain term defined for its respective
    submodel by applying this set of conditions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有不同的子模型时，当所有子模型合并时，很难维护代码。你需要有一个可以分配给一个团队的小模型。你可能需要收集相关元素并对其进行分组。上下文通过应用这一系列条件保留和维护其各自子模型所定义的领域术语的含义。
- en: These domain terms define the scope of the model that creates the boundaries
    of the context.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些领域术语定义了创建上下文边界的模型范围。
- en: Bounded context seems very similar to the module that you learned about in the
    previous section. In fact, the module is part of the bounded context that defines
    the logical frame where a submodel takes place and is developed. Whereas, the
    module organizes the elements of the domain model, and is visible in the design
    document and the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有界上下文似乎与你在上一节学到的模块非常相似。事实上，模块是有界上下文的一部分，它定义了子模型发生和开发的逻辑框架。而模块组织了领域模型的元素，并且在设计文档和代码中可见。
- en: Now, as a designer, you would have to keep each submodel well-defined and consistent.
    In this way, you can refactor each model independently without affecting the other
    submodels. This gives the software designer the flexibility to refine and improve
    it at any point in time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为设计师，你需要保持每个子模型定义明确和一致。这样，你可以独立地重构每个模型，而不影响其他子模型。这给软件设计师灵活性，可以随时对其进行改进和完善。
- en: 'Now, let''s examine the table reservation example we''ve been using. When you
    started designing the system, you would have seen that the guest would visit the
    application, and would request a table reservation at a selected restaurant, date,
    and time. Then, there is the backend system that informs the restaurant about
    the booking information, and similarly, the restaurant would keep their system
    updated in regard to table bookings, given that tables can also be booked by the
    restaurant themselves. So, when you look at the system''s finer points, you can
    see two domain models:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下我们一直在使用的桌位预订示例。当你开始设计系统时，你会发现客人会访问应用程序，并请求在选定的餐厅、日期和时间预订桌位。然后，有后端系统通知餐厅有关预订信息，同样，餐厅也会根据桌位预订保持其系统更新，餐厅也可以自行预订桌位。因此，当你查看系统的细节时，你会看到两个领域模型：
- en: The online table reservation system
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线桌位预订系统
- en: The offline restaurant management system
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离线餐厅管理系统
- en: Both have their own bounded context and you need to make sure that the interface
    between them works fine.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都有自己的有界上下文，你需要确保它们之间的接口正常工作。
- en: Continuous integration
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: When you are developing, the code is scattered among many teams and various
    technologies. This code may be organized into different modules, and has applicable
    bounded context for respective submodels.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在开发时，代码分散在许多团队和各种技术中。这些代码可以组织成不同的模块，并且对于各自的子模型有适用的有界上下文。
- en: This sort of development may bring with it a certain level of complexity with
    regard to duplicate code, a code break, or maybe broken-bounded context. It happens
    not only because of the large size of code and domain model, but also because
    of other factors, such as changes in team members, new members, or not having
    a well-documented model, to name just a few of them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开发可能会带来一定程度的复杂性，涉及重复代码、代码中断或可能破坏有界上下文。这不仅是因为代码和领域模型的规模很大，还因为其他因素，比如团队成员的变化、新成员或没有良好记录的模型等等。
- en: When systems are designed and developed using DDD and Agile methodologies, domain
    models are not designed fully before coding starts, and the domain model and its
    elements evolve over a period of time with continuous improvements and refinement
    happening gradually.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用DDD和敏捷方法设计和开发系统时，领域模型并不是在编码开始之前完全设计的，领域模型及其元素会随着时间的推移而不断改进和完善。
- en: Therefore, integration continues, and this is currently one of the key reasons
    for development today, so it plays a very important role. In **continuous integration**,
    the code is merged frequently to avoid any breaks and issues with the domain model.
    Merged code not only gets deployed, but it is also tested on a regular basis.
    There are various continuous integration tools available in the market that merge,
    build, and deploy the code at scheduled times. These days, organizations put more
    emphasis on the automation of continuous integration. Hudson, TeamCity, and Jenkins
    CI are a few of the popular tools available today for continuous integration.
    Hudson and Jenkins CI are open source tools, and TeamCity is a proprietary tool.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，集成继续进行，这是当前开发的主要原因之一，因此它起着非常重要的作用。在**持续集成**中，代码经常合并以避免领域模型的任何中断和问题。合并的代码不仅被部署，而且还定期进行测试。市场上有各种持续集成工具，可以在预定的时间合并、构建和部署代码。如今，组织更加强调持续集成的自动化。Hudson、TeamCity和Jenkins
    CI是当前可用的几种流行的持续集成工具。Hudson和Jenkins CI是开源工具，而TeamCity是专有工具。
- en: Having a test suite attached to each build confirms the consistency and integrity
    of the model. A test suite defines the model from a physical point of view, whereas
    UML does it logically. It informs you of any error or unexpected outcome that
    requires a code change. It also helps to identify errors and anomalies in a domain
    model early on.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个构建附加一个测试套件可以确认模型的一致性和完整性。测试套件从物理角度定义了模型，而UML从逻辑上定义了模型。它会通知您任何需要代码更改的错误或意外结果。它还有助于及早发现领域模型中的错误和异常。
- en: Context map
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文映射
- en: The context map helps you to understand the overall picture of a large enterprise
    application. It shows how many bounded contexts are present in the enterprise
    model, and how they are interrelated. Therefore, we can say that any diagram or
    document that explains the bounded contexts and relationship between them is called
    a **context** **map**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文映射帮助您了解大型企业应用程序的整体情况。它显示了企业模型中存在多少个有界上下文，以及它们之间的相互关系。因此，我们可以说任何解释有界上下文和它们之间关系的图表或文档都被称为**上下文映射**。
- en: Context maps help all team members, whether they are on the same team or in
    a different team, to understand the high-level enterprise model in the form of
    various parts (bounded context or submodels) and relationships.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文映射帮助所有团队成员，无论他们是在同一个团队还是在不同的团队，都能理解以各种部分（有界上下文或子模型）和关系的形式呈现的高级企业模型。
- en: 'This gives individuals a clearer picture about the tasks one performs, and
    may allow him or her to raise any concern/question about the model''s integrity:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这使个人对其执行的任务有了更清晰的了解，并且可能使他或她能够提出关于模型完整性的任何关注/问题：
- en: '![](img/5347ac92-4666-4d87-99d8-12aa816036da.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5347ac92-4666-4d87-99d8-12aa816036da.jpg)'
- en: Context map example
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文映射示例
- en: The context map example diagram is a sample of a context map. Here, **Table1**
    and **Table2** both appear in the **Table Reservation Context** and also in the
    **Restaurant Ledger Context**. The interesting thing is that **Table1** and **Table2**
    have their own respective concept in each bounded context. Here, ubiquitous language
    is used to name the bounded context as **table reservation** and **restaurant
    ledger**.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文映射示例图是上下文映射的一个示例。在这里，**Table1**和**Table2**都出现在**桌位预订上下文**和**餐厅分类账上下文**中。有趣的是**Table1**和**Table2**在每个有界上下文中都有自己的概念。在这里，通用语言用于命名有界上下文，如**桌位预订**和**餐厅分类账**。
- en: In the following section, we will explore a few patterns that can be used to
    define the communication between different contexts in the context map.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将探讨一些可以用来定义上下文映射中不同上下文之间通信的模式。
- en: Shared kernel
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享内核
- en: 'As the name suggests, one part of the bounded context is shared with the other''s
    bounded context. As you can see in the following figure, the **Restaurant** entity
    is being shared between the **Table Reservation Context** and the **Restaurant
    Ledger Context**:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，有界上下文的一部分与另一个有界上下文共享。正如您在下图中所看到的，**餐厅**实体在**桌位预订上下文**和**餐厅分类账上下文**之间共享：
- en: '![](img/66176460-3b14-45e0-bd1d-986c37b642b6.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66176460-3b14-45e0-bd1d-986c37b642b6.jpg)'
- en: Shared kernel
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内核
- en: Customer-supplier
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户-供应商
- en: The customer-supplier pattern represents the relationship between two bounded
    contexts, when the output of one bounded context is required for the other bounded
    context. That is, one supplies the information to the other (known as the customer),
    who consumes the information.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 客户-供应商模式代表两个有界上下文之间的关系，当一个有界上下文的输出需要另一个有界上下文时。也就是说，一个有界上下文向另一个（称为客户）提供信息，后者消费信息。
- en: In a real-world example, a car dealer could not sell cars until the car manufacturer
    delivers them. Hence, in this domain model, the car manufacturer is the supplier
    and the dealer is the customer. This relationship establishes a customer-supplier
    relationship, because the output (car) of one bounded context (car-manufacturer)
    is required by the other bounded context (dealer).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真实的例子中，汽车经销商在汽车制造商交付汽车之前无法销售汽车。因此，在这个领域模型中，汽车制造商是供应商，经销商是客户。这种关系建立了客户-供应商关系，因为一个有界上下文（汽车制造商）的输出（汽车）被另一个有界上下文（经销商）所需。
- en: Here, both customer and supplier teams should meet regularly to establish a
    contract and form the right protocol to communicate with each other.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，客户和供应商团队应定期会面，建立合同并形成正确的协议以相互沟通。
- en: Conformist
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺从者
- en: This pattern is similar to that of the customer and the supplier, where one
    needs to provide the contract and information while the other needs to use it.
    Here, instead of bounded context, actual teams are involved in having an upstream/downstream
    relationship.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式类似于客户和供应商的模式，其中一方需要提供合同和信息，而另一方需要使用它。在这里，实际团队参与了上游/下游关系，而不是有界上下文。
- en: Moreover, upstream teams do not provide for the needs of the downstream team,
    because of their lack of motivation. Therefore, it is possible that the downstream
    team may need to plan and work on items that will never be available. To resolve
    such cases, the customer team could develop their own models if the supplier provides
    information that is not worth enough. If the supplier provided information that
    is really of worth or of partial worth, then the customer can use the interface
    or translators that can be used to consume the supplier-provided information with
    the customer's own models.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，上游团队不满足下游团队的需求，因为他们缺乏动力。因此，可能需要下游团队计划和处理永远不可用的项目。为解决这种情况，如果供应商提供的信息不够重要，客户团队可以开发自己的模型。如果供应商提供的信息真的很重要或部分重要，那么客户可以使用接口或翻译器来使用供应商提供的信息与客户自己的模型。
- en: Anticorruption layer
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反腐败层
- en: The **anticorruption layer** remains part of a domain and it is used when a
    system needs data from external systems, or from their own legacy systems. Here,
    anticorruption is the layer that interacts with external systems and uses external
    system data in the domain model without affecting the integrity and originality
    of the domain model.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: “反腐败层”仍然是领域的一部分，当系统需要来自外部系统或自己的传统系统的数据时使用。在这里，反腐败是与外部系统交互并在领域模型中使用外部系统数据而不影响领域模型的完整性和原创性的层。
- en: For the most part, a service can be used as an anticorruption layer that may
    use a facade pattern with an adapter and translator to consume external domain
    data within the internal model. Therefore, your system would always use the service
    to retrieve the data. The service layer can be designed using the facade pattern.
    This would make sure that it would work with the domain model to provide the required
    data in a given format. The service could then also use the adapter and translator
    patterns that would make sure that, whatever format and hierarchy the data is
    sent in, by external sources, the service would be provided in the desired format
    and the hierarchy would use adapters and translators.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，服务可以用作反腐败层，可能使用外观模式与适配器和翻译器来在内部模型中使用外部领域数据。因此，您的系统将始终使用服务来检索数据。服务层可以使用外观模式进行设计。这将确保它能够与领域模型一起提供所需的数据以特定格式。服务还可以使用适配器和翻译器模式，以确保无论外部来源发送数据的格式和层次结构如何，服务都将以所需的格式提供，并且层次结构将使用适配器和翻译器。
- en: Separate ways
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离方式
- en: When you have a large enterprise application and a domain where different domains
    have no common elements, and it's made of large submodels that can work independently,
    this still works as a single application for an end user.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当您拥有一个大型企业应用程序和一个不具有共同元素的领域，并且由可以独立工作的大型子模型组成时，这仍然作为最终用户的单个应用程序。
- en: In such cases, a designer could create separate models that have no relationship,
    and develop a small application on top of them. These small applications become
    a single application when merged together.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，设计师可以创建没有关系的单独模型，并在其上开发一个小应用程序。这些小应用程序在合并后成为单个应用程序。
- en: An employer's intranet application that offers various small applications, such
    as those that are HR-related, issue trackers, transport, or intra-company social
    networks, is one such application where a designer could use the **separate ways**
    pattern.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 雇主的内部网络应用程序提供各种小应用程序，例如与人力资源相关的应用程序、问题跟踪器、交通或公司内部社交网络，设计师可以使用“分离方式”模式。
- en: It would be very challenging and complex to integrate applications that were
    developed using separate models. Therefore, you should take care before implementing
    this pattern.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分开的模型开发的应用程序进行集成将非常具有挑战性和复杂。因此，在实施此模式之前，您应该小心。
- en: Open Host Service
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放主机服务
- en: A translation layer is used when two submodels interact with each other. This
    translation layer is used when you integrate models with an external system. This
    works fine when you have one submodel that uses this external system. The Open
    Host Service is required when this external system is being used by many submodels
    to remove the extra and duplicated code, because then you need to write a translation
    layer for each submodels external system.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个子模型相互交互时使用翻译层。当您将模型与外部系统集成时，将使用此翻译层。当您有一个子模型使用此外部系统时，这将起作用。当许多子模型使用此外部系统时，需要使用开放主机服务来消除额外和重复的代码，因为那时您需要为每个子模型的外部系统编写翻译层。
- en: An Open Host Service provides the services of an external system using a wrapper
    to all sub-models.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 开放主机服务使用包装器向所有子模型提供外部系统的服务。
- en: Distillation
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蒸馏
- en: As you know, **distillation** is the process of purifying liquid. Similarly,
    in DDD, distillation is the process that filters out the information that is not
    required, and keeps only the meaningful information. It helps you to identify
    the core domain and the essential concepts for your business domain. It helps
    you to filter out the generic concepts until you get the core domain concept.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，**蒸馏**是纯化液体的过程。同样，在DDD中，蒸馏是过滤掉不需要的信息，只保留有意义的信息的过程。它帮助您识别核心领域和业务领域的基本概念。它帮助您过滤掉通用概念，直到获得核心领域概念。
- en: Core domain should be designed, developed, and implemented with the highest
    attention to detail, using the developers and designers, as it is crucial to the
    success of the whole system.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 核心领域应该以最高的注意细节进行设计、开发和实施，使用开发人员和设计师，因为这对整个系统的成功至关重要。
- en: In our table reservation system example, which is not a large or complex domain
    application, it is not difficult to identify the core domain. The core domain
    here exists to share the real-time accurate vacant tables in the restaurants,
    and allows the user to reserve them in a hassle-free process.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的桌子预订系统示例中，这并不是一个庞大或复杂的领域应用程序，很容易确定核心领域。这里的核心领域存在是为了分享餐厅中实时准确的空桌，并允许用户在一个无忧无虑的过程中预订它们。
- en: Sample domain service
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例领域服务
- en: Let us create a sample domain service based on our table reservation system.
    As discussed in this chapter, the importance of an efficient domain layer is the
    key to successful products or services. Projects developed based on the domain
    layer are more maintainable, highly cohesive, and decoupled. They provide high
    scalability in terms of business requirement changes, and have a low impact on
    the design of other layers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于我们的桌子预订系统创建一个示例领域服务。正如本章讨论的那样，高效的领域层对于成功的产品或服务至关重要。基于领域层开发的项目更易于维护，高度内聚，解耦。它们在业务需求变化方面具有高可扩展性，并且对其他层的设计影响较小。
- en: Domain-driven development is based on domain, hence it is not recommended that
    you use a top-down approach where the UI would be developed first, followed by
    the rest of the layers, and finally the persistence layer. Nor should you use
    a bottom-up approach, where the persistence layer like the DB is designed first,
    followed by the rest of the layers, with the UI last.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动开发是基于领域的，因此不建议您使用自顶向下的方法，首先开发UI，然后是其他层，最后是持久层。也不应该使用自底向上的方法，首先设计持久层，然后是其他层，最后是UI。
- en: Having a domain model developed first, using the patterns described in this
    book, gives clarity to all team members functionality-wise, and an advantage to
    the software designer to build a flexible, maintainable, and consistent system
    that helps the organization to launch a world-class product with fewer maintenance
    costs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先开发一个领域模型，使用本书中描述的模式，可以使所有团队成员在功能上更加清晰，并为软件设计师提供一个灵活、易于维护和一致的系统，帮助组织推出一个世界级产品，减少维护成本。
- en: Here, you will create a restaurant service that provides the feature to add
    and retrieve restaurants. Based on implementation, you can add other functionalities,
    such as finding restaurants based on cuisine or ratings.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将创建一个餐厅服务，提供添加和检索餐厅的功能。根据实现，您可以添加其他功能，例如根据菜系或评分查找餐厅。
- en: Start with the entity. Here, the restaurant is our entity, as each restaurant
    is unique and has an identifier. You can use an interface, or set of interfaces,
    to implement the entity in our table reservation system. Ideally, if you go by
    the interface segregation principle, you will use a set of interfaces rather than
    a single interface.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从实体开始。在这里，餐厅是我们的实体，因为每家餐厅都是独一无二的，并且有一个标识符。您可以使用一个接口或一组接口来实现我们的桌子预订系统中的实体。理想情况下，如果您遵循接口隔离原则，您将使用一组接口而不是单个接口。
- en: The **Interface Segregation Principle** (**ISP**) states that clients should
    not be forced to depend upon interfaces that they do not use.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口隔离原则**（**ISP**）规定客户端不应被迫依赖于他们不使用的接口。'
- en: Entity implementation
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体实现
- en: For the first interface, you could have an abstract class or interface that
    is required by all the entities. For example, if we consider ID and name, attributes
    would be common for all entities.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个接口，您可以有一个抽象类或接口，所有实体都需要它。例如，如果我们考虑ID和名称，这些属性对所有实体都是通用的。
- en: 'Therefore, you could use the abstract class `Entity` as an abstraction of the
    entity in your domain layer:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以使用抽象类`Entity`作为领域层中实体的抽象：
- en: '[PRE0]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Based on that, you can also have another `abstract` class that inherits `Entity`,
    an abstract class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，您还可以有另一个继承`Entity`的`abstract`类：
- en: '[PRE1]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Based on the preceding abstractions, we could create the `Restaurant` entity
    for restaurant management.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的抽象，我们可以为餐厅管理创建`Restaurant`实体。
- en: Now, since we are developing the table reservation system, `Table` is another
    important entity in terms of the domain model. So, if we go by the aggregate pattern,
    `Restaurant` would work as a root, and the `Table` entity would be internal to
    the `Restaurant` entity. Therefore, the `Table` entity would always be accessible
    using the `Restaurant` entity.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们正在开发桌子预订系统，`Table`在领域模型中是另一个重要的实体。因此，如果我们按照聚合模式，`Restaurant`将作为根，`Table`实体将是`Restaurant`实体的内部。因此，`Table`实体将始终可以使用`Restaurant`实体访问。
- en: 'You can create the `Table` entity using the following implementation, and you
    can add attributes as you wish. For demonstration purposes only, basic attributes
    are used:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下实现创建`Table`实体，并根据需要添加属性。仅用于演示目的，使用了基本属性：
- en: '[PRE2]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can implement the aggregator `Restaurant` class shown as follows. Here,
    only basic attributes are used. You could add as many as you want, and you may
    also add other features:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现如下所示的聚合器`Restaurant`类。这里只使用了基本属性。您可以根据需要添加任意数量的属性，也可以添加其他功能：
- en: '[PRE3]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Repository implementation
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储库实现
- en: 'Now we can implement the repository pattern, as learned in this chapter. To
    start with, you will first create the two interfaces `Repository` and `ReadOnlyRepository`.
    The `ReadOnlyRepository` interface will be used to provide an abstraction for
    read-only operations, whereas `Repository` abstraction will be used to perform
    all types of operations:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现在本章中学到的存储库模式。首先，您将首先创建两个接口`Repository`和`ReadOnlyRepository`。`ReadOnlyRepository`接口将用于提供只读操作的抽象，而`Repository`抽象将用于执行所有类型的操作：
- en: '[PRE4]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Based on this interface, we could create the abstraction of the `Repository`,
    which would execute additional operations such as adding, removing, and updating:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个接口，我们可以创建`Repository`的抽象，它将执行额外的操作，如添加、删除和更新：
- en: '[PRE5]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Repository` abstraction, as defined previously, could be implemented,
    in a way that suits you, to persist your objects. The change in persistence code,
    which is a part of the infrastructure layer, won''t impact on your domain layer
    code, as the contract and abstraction are defined by the domain layer. The domain
    layer uses the abstraction classes and interfaces that remove the use of direct
    concrete class, and provides the loose coupling. For demonstration purposes, we
    could simply use the map that remains in the memory to persist the objects:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Repository`抽象可以以适合您的方式实现，以持久化您的对象。持久化代码的更改，作为基础层的一部分，不会影响到您的领域层代码，因为合同和抽象由领域层定义。领域层使用抽象类和接口，消除了直接使用具体类，并提供了松散耦合。为了演示目的，我们可以简单地使用保留在内存中的映射来持久化对象：
- en: '[PRE6]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Service implementation
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务实现
- en: 'In the same way as the preceding approach, you could divide the abstraction
    of domain service into two parts—main service abstraction and read-only service
    abstraction:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的方法类似，您可以将领域服务的抽象分为两部分——主服务抽象和只读服务抽象：
- en: '[PRE7]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we could use this `ReadOnlyBaseService` to create the `BaseService`. Here,
    we are using the dependency inject pattern via a constructor to map the concrete
    objects with abstraction:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个`ReadOnlyBaseService`来创建`BaseService`。在这里，我们使用了依赖注入模式，通过构造函数将具体对象映射到抽象对象：
- en: '[PRE8]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, after defining the service abstraction services, we could implement the
    `RestaurantService` in the following way:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在定义了服务抽象服务之后，我们可以以以下方式实现`RestaurantService`：
- en: '[PRE9]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Similarly, you could write the implementation for other entities. This code
    is a basic implementation, and you might add various implementations and behaviors
    in the production code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，您可以为其他实体编写实现。这段代码是一个基本实现，您可能会在生产代码中添加各种实现和行为。
- en: We can write an application class that would execute and test the sample domain
    model code that we have just written.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个应用程序类，来执行和测试我们刚刚编写的示例领域模型代码。
- en: 'The `RestaurantApp.java` file will look something like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestaurantApp.java`文件将看起来像这样：'
- en: '[PRE10]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To execute this program, either execute directly from IDE, or run using Maven.
    It prints the following output:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此程序，可以直接从IDE执行，或者使用Maven运行。它会打印以下输出：
- en: '[PRE11]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned the fundamentals of DDD. You have also explored
    multilayered architecture and different patterns that can be used to develop software
    using DDD. By this time, you should be aware that the domain model design is very
    important for the success of the software. To conclude, we demonstrated one domain
    service implementation using the restaurant table reservation system.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学习了DDD的基础知识。您还探索了多层架构和使用DDD开发软件的不同模式。到目前为止，您应该意识到领域模型设计对软件的成功非常重要。总之，我们演示了使用餐厅预订系统实现一个领域服务。
- en: In the next chapter, you will learn how to use the design to implement the sample
    project. The explanation of the design of this sample project is derived from
    the last chapter, and the DDD will be used to build the microservices. This chapter
    not only covers the coding, but also the different aspects of the microservices,
    such as build, unit testing, and packaging. By the end of the next chapter, the
    sample microservice project will be ready for deployment and consumption.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用设计来实现示例项目。这个示例项目的设计解释源自上一章，DDD将用于构建微服务。本章不仅涵盖了编码，还涵盖了微服务的不同方面，如构建、单元测试和打包。到下一章结束时，示例微服务项目将准备好部署和消费。
