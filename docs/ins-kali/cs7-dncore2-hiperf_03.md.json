["```cs\nstatic void Main(string[] args) \n{ \n  new Thread(new ThreadStart(ExecuteLongRunningOperation)).Start(); \n} \nstatic void ExecuteLongRunningOperation() \n{ \n  Thread.Sleep(100000); \n  Console.WriteLine(\"Operation completed successfully\"); \n} \n```", "```cs\nstatic void Main(string[] args) \n{ \n  new Thread(new ParameterizedThreadStart\n  (ExecuteLongRunningOperation)).Start(100000); \n} \n\nstatic void ExecuteLongRunningOperation(object milliseconds) \n{ \n  Thread.Sleep((int)milliseconds); \n  Console.WriteLine(\"Operation completed successfully\"); \n} \n```", "```cs\npublic interface IService \n{ \n  string Name { get; set; } \n  void Execute(); \n} \n\npublic class EmailService : IService \n{ \n  public string Name { get; set; } \n  public void Execute() => throw new NotImplementedException(); \n\n  public EmailService(string name) \n  { \n    this.Name = name; \n  } \n} \n\nstatic void Main(string[] args) \n{ \n  IService service = new EmailService(\"Email\"); \n  new Thread(new ParameterizedThreadStart\n  (RunBackgroundService)).Start(service); \n} \n\nstatic void RunBackgroundService(Object service) \n{ \n  ((IService)service).Execute(); //Long running task \n} \n```", "```cs\nstatic void RunBackgroundService(Object service) \n{ \n  Thread.CurrentThread.Priority = ThreadPriority.Highest;      \n  ((IService)service).Execute(); //Long running task\n}\n```", "```cs\nclass Program \n{ \n\n  static volatile bool isActive = true;  \n  static void Main(string[] args) \n  { \n    new Thread(new ParameterizedThreadStart\n    (ExecuteLongRunningOperation)).Start(1000); \n  } \n\n  static void ExecuteLongRunningOperation(object milliseconds) \n  { \n    while (isActive) \n    { \n      //Do some other operation \n      Console.WriteLine(\"Operation completed successfully\"); \n    } \n  } \n} \n```", "```cs\nclass Program \n{ \n  static void Main(string[] args) \n  { \n    ThreadPool.QueueUserWorkItem(ExecuteLongRunningOperation, 1000); \n    Console.Read(); \n  } \n  static void ExecuteLongRunningOperation(object milliseconds) \n  { \n\n    Thread.Sleep((int)milliseconds); \n    Console.WriteLine(\"Thread is executed\"); \n  } \n} \n```", "```cs\npublic class Logger \n{ \n  static Logger _instance; \n\n  private Logger() { } \n\n  public Logger GetInstance() \n  { \n    _instance = (_instance == null ? new Logger() : _instance); \n    return _instance; \n  } \n\n  public void LogMessage(string str) \n  { \n    //Log message into file system \n  } \n\n} \n```", "```cs\npublic class Logger \n{ \n\n  private static object syncRoot = new object(); \n  static Logger _instance; \n\n  private Logger() { } \n\n  public Logger GetInstance() \n  { \n    if (_instance == null) \n    { \n      lock (syncRoot) \n      { \n        if (_instance == null) \n        _instance = new Logger(); \n      } \n    } \n    return _instance; \n  } \n\n  public void LogMessage(string str) \n  { \n    //Log message into file system \n  } \n} \n```", "```cs\npublic class Job \n{ \n\n  int _jobDone; \n  object _lock = new object(); \n\n  public void IncrementJobCounter(int number) \n  { \n    Monitor.Enter(_lock); \n    // access to this field is synchronous\n    _jobDone += number; \n    Monitor.Exit(_lock); \n  } \n\n} \nIncrementJobCounter method to increment the _jobDone counter.\n```", "```cs\nJobExecutor:\u00a0\n```", "```cs\npublic class JobExecutor \n{ \n  const int _waitTimeInMillis = 10 * 60 * 1000; \n  private ArrayList _jobs = null; \n  private static JobExecutor _instance = null; \n  private static object _syncRoot = new object(); \n\n  //Singleton implementation of JobExecutor\n  public static JobExecutor Instance \n  { \n    get{ \n    lock (_syncRoot) \n    { \n      if (_instance == null) \n      _instance = new JobExecutor(); \n    } \n    return _instance; \n  } \n} \n\nprivate JobExecutor() \n{ \n  IsIdle = true; \n  IsAlive = true; \n  _jobs = new ArrayList(); \n} \n\nprivate Boolean IsIdle { get; set; } \npublic Boolean IsAlive { get; set; } \n\n//Callers can use this method to add list of jobs\npublic void AddJobItems(List<Job> jobList) \n{ \n  //Added lock to provide synchronous access. \n  //Alternatively we can also use Monitor.Enter and Monitor.Exit\n  lock (_jobs) \n  { \n    foreach (Job job in jobList) \n    { \n      _jobs.Add(job); \n    } \n    //Release the waiting thread to start executing the //jobs\n    Monitor.PulseAll(_jobs); \n  } \n} \n\n/*Check for jobs count and if the count is 0, then wait for 10 minutes by calling Monitor.Wait. Meanwhile, if new jobs are added to the list, Monitor.PulseAll will be called that releases the waiting thread. Once the waiting is over it checks the count of jobs and if the jobs are there in the list, start executing. Otherwise, wait for the new jobs */\npublic void CheckandExecuteJobBatch() \n{ \n  lock (_jobs) \n  { \n    while (IsAlive) \n    { \n      if (_jobs == null || _jobs.Count <= 0) \n      { \n        IsIdle = true; \n        Console.WriteLine(\"Now waiting for new jobs\"); \n        //Waiting for 10 minutes \n        Monitor.Wait(_jobs, _waitTimeInMillis); \n      } \n      else \n      { \n        IsIdle = false; \n        ExecuteJob(); \n      } \n    } \n  } \n} \n\n//Execute the job\nprivate void ExecuteJob() \n{ \n  for(int i=0;i< _jobs.Count;i++) \n  { \n    Job job = (Job)_jobs[i]; \n    //Execute the job; \n    job.DoSomething(); \n    //Remove the Job from the Jobs list \n    _jobs.Remove(job); \n    i--; \n  } \n} \n} \n```", "```cs\nJob class containing two properties, namely JobID and JobName, and the DoSomething method that will print the JobID on the console:\n```", "```cs\npublic class Job \n{ \n  // Properties to set and get Job ID and Name\n  public int JobID { get; set; } \n  public string JobName { get; set; } \n\n  //Do some task based on Job ID as set through the JobID        \n  //property\n  public void DoSomething() \n  { \n    //Do some task based on Job ID  \n    Console.WriteLine(\"Executed job \" + JobID);  \n  } \n} \n```", "```cs\nclass Program \n{ \n  static void Main(string[] args) \n  { \n    Thread jobThread = new Thread(new ThreadStart(ExecuteJobExecutor)); \n    jobThread.Start(); \n\n    //Starting three Threads add jobs time to time; \n    Thread thread1 = new Thread(new ThreadStart(ExecuteThread1)); \n    Thread thread2 = new Thread(new ThreadStart(ExecuteThread2)); \n    Thread thread3 = new Thread(new ThreadStart(ExecuteThread3)); \n    Thread1.Start(); \n    Thread2.Start(); \n    thread3.Start(); \n\n    Console.Read(); \n  } \n\n  //Implementation of ExecuteThread 1 that is adding three \n  //jobs in the list and calling AddJobItems of a singleton \n  //JobExecutor instance\n  private static void ExecuteThread1() \n  { \n    Thread.Sleep(5000); \n    List<Job> jobs = new List<Job>(); \n    jobs.Add(new Job() { JobID = 11, JobName = \"Thread 1 Job 1\" }); \n    jobs.Add(new Job() { JobID = 12, JobName = \"Thread 1 Job 2\" }); \n    jobs.Add(new Job() { JobID = 13, JobName = \"Thread 1 Job 3\" }); \n    JobExecutor.Instance.AddJobItems(jobs); \n  } \n\n  //Implementation of ExecuteThread2 method that is also adding \n  //three jobs and calling AddJobItems method of singleton \n  //JobExecutor instance \n  private static void ExecuteThread2() \n  { \n    Thread.Sleep(5000); \n    List<Job> jobs = new List<Job>(); \n    jobs.Add(new Job() { JobID = 21, JobName = \"Thread 2 Job 1\" }); \n    jobs.Add(new Job() { JobID = 22, JobName = \"Thread 2 Job 2\" }); \n    jobs.Add(new Job() { JobID = 23, JobName = \"Thread 2 Job 3\" }); \n    JobExecutor.Instance.AddJobItems(jobs); \n  } \n\n  //Implementation of ExecuteThread3 method that is again \n  // adding 3 jobs instances into the list and \n  //calling AddJobItems to add those items into the list to execute\n  private static void ExecuteThread3() \n  { \n    Thread.Sleep(5000); \n    List<Job> jobs = new List<Job>(); \n    jobs.Add(new Job() { JobID = 31, JobName = \"Thread 3 Job 1\" }); \n    jobs.Add(new Job() { JobID = 32, JobName = \"Thread 3 Job 2\" }); \n    jobs.Add(new Job() { JobID = 33, JobName = \"Thread 3 Job 3\" }); \n    JobExecutor.Instance.AddJobItems(jobs); \n  } \n\n  //Implementation of ExecuteJobExecutor that calls the \n  //CheckAndExecuteJobBatch to run the jobs\n  public static void ExecuteJobExecutor() \n  { \n    JobExecutor.Instance.IsAlive = true; \n    JobExecutor.Instance.CheckandExecuteJobBatch(); \n  } \n} \n```", "```cs\nExecuteLongRunningTasksmethod\u00a0using Task.Run:\n```", "```cs\nclass Program \n{ \n  static void Main(string[] args) \n  { \n    Task t = Task.Run(()=>ExecuteLongRunningTask(5000)); \n    t.Wait(); \n  } \n\n  public static void ExecuteLongRunningTask(int millis) \n  { \n    Thread.Sleep(millis); \n    Console.WriteLine(\"Hello World\"); \n\n  } \n} \nExecuteLongRunningTask method asynchronously using the\u00a0Task.Run method. The\u00a0Task.Run method returns the Task object that can be used to\u00a0further\u00a0wait for the asynchronous piece of code to be executed completely before the program ends. To wait for the task, we have used the\u00a0Wait method.\n```", "```cs\nstatic void Main(string[] args) \n{ \n  List<Template> templates = GetTemplates(); \n  IEnumerable<Task> asyncDocs = from template in templates select \n  GenerateDocumentAsync(template); \n  try \n  { \n    Task.WaitAll(asyncDocs.ToArray()); \n\n  }catch(Exception ex) \n  { \n    Console.WriteLine(ex); \n  } \n  Console.Read(); \n} \n\nprivate static async Task<int> GenerateDocumentAsync(Template template) \n{ \n  //To automate long running operation \n  Thread.Sleep(3000); \n  //Throwing exception intentionally \n  throw new Exception(); \n}\n```", "```cs\nstatic void Main(string[] args) \n{ \n  CancellationTokenSource tokenSource = new CancellationTokenSource(); \n  CancellationToken token = tokenSource.Token; \n  Task.Factory.StartNew(() => SaveFileAsync(path, bytes, token)); \n} \n\nstatic Task<int> SaveFileAsync(string path, byte[] fileBytes, CancellationToken cancellationToken) \n{ \n  if (cancellationToken.IsCancellationRequested) \n  { \n    Console.WriteLine(\"Cancellation is requested...\"); \n    cancellationToken.ThrowIfCancellationRequested      \n  } \n  //Do some file save operation \n  File.WriteAllBytes(path, fileBytes); \n  return Task.FromResult<int>(0); \n} \n```", "```cs\nstatic void Main(string[] args) \n{ \n  var progressHandler = new Progress<string>(value => \n  { \n    Console.WriteLine(value); \n  }); \n\n  var progress = progressHandler as IProgress<string>; \n\n  CancellationTokenSource tokenSource = new CancellationTokenSource(); \n  CancellationToken token = tokenSource.Token; \n\n  Task.Factory.StartNew(() => SaveFileAsync(path, bytes, \n  token, progress)); \n  Console.Read(); \n\n} \nstatic Task<int> SaveFileAsync(string path, byte[] fileBytes, CancellationToken cancellationToken, IProgress<string> progress) \n{ \n  if (cancellationToken.IsCancellationRequested) \n  { \n    progress.Report(\"Cancellation is called\"); \n    Console.WriteLine(\"Cancellation is requested...\"); \n  } \n\n  progress.Report(\"Saving File\"); \n  File.WriteAllBytes(path, fileBytes);   \n  progress.Report(\"File Saved\"); \n  return Task.FromResult<int>(0); \n\n} \n```", "```cs\nstatic void Main(string[] args) \n{ \n  var t = ExecuteLongRunningOperationAsync(100000); \n  Console.WriteLine(\"Called ExecuteLongRunningOperationAsync method, \n  now waiting for it to complete\"); \n  t.Wait(); \n  Console.Read(); \n}   \n\npublic static async Task<int> ExecuteLongRunningOperationAsync(int millis) \n{ \n  Task t = Task.Factory.StartNew(() => RunLoopAsync(millis)); \n  await t; \n  Console.WriteLine(\"Executed RunLoopAsync method\"); \n  return 0; \n} \n\npublic static void RunLoopAsync(int millis) \n{ \n  Console.WriteLine(\"Inside RunLoopAsync method\"); \n  for(int i=0;i< millis; i++) \n  { \n    Debug.WriteLine($\"Counter = {i}\"); \n  } \n  Console.WriteLine(\"Exiting RunLoopAsync method\"); \n} \n```", "```cs\nstatic void Main(string[] args) \n{ \n  var t = ExecuteTask(); \n  t.Wait(); \n  Console.Read(); \n} \n\npublic static Task<int> ExecuteTask() \n{ \n  var tcs = new TaskCompletionSource<int>(); \n  Task<int> t1 = tcs.Task; \n  Task.Factory.StartNew(() => \n  { \n    try \n    { \n      ExecuteLongRunningTask(10000); \n      tcs.SetResult(1); \n    }catch(Exception ex) \n    { \n      tcs.SetException(ex); \n    } \n  }); \n  return tcs.Task; \n\n} \n\npublic static void ExecuteLongRunningTask(int millis) \n{ \n  Thread.Sleep(millis); \n  Console.WriteLine(\"Executed\"); \n} \n```", "```cs\nstatic void Main(string[] args) \n{ \n\n  Task<int> t1 = Task.Factory.StartNew(() =>  \n  { return CreateUser(); }); \n\n  var t2=t1.ContinueWith((antecedent) => \n  { return InitiateWorkflow(antecedent.Result); }); \n  var t3 = t2.ContinueWith((antecedant) => \n  { return SendEmail(antecedant.Result); }); \n\n  Console.Read(); \n\n} \n\npublic static int CreateUser() \n{ \n  //Create user, passing hardcoded user ID as 1 \n  Thread.Sleep(1000); \n  Console.WriteLine(\"User created\"); \n  return 1; \n} \n\npublic static int InitiateWorkflow(int userId) \n{ \n  //Initiate Workflow \n  Thread.Sleep(1000); \n  Console.WriteLine(\"Workflow initiates\"); \n\n  return userId; \n} \n\npublic static int SendEmail(int userId) \n{ \n  //Send email \n  Thread.Sleep(1000); \n  Console.WriteLine(\"Email sent\"); \n\n  return userId; \n}  \n```", "```cs\nstatic void Main(string[] args) \n{ \n  //Creating two tasks t1 and t2 and starting them at the same //time\n  Task<int> t1 = Task.Factory.StartNew(() => { return Task1(); }); \n  Task<int> t2 = Task.Factory.StartNew(() => { return Task2(); }); \n\n  //Creating task 3 and used ContinueWhenAll that runs when both the \n  //tasks T1 and T2 will be completed\n  Task<int> t3 = Task.Factory.ContinueWhenAll(\n  new[] { t1, t2 }, (tasks) => { return Task3(); }); \n\n  //Task 4 and Task 5 will be started when Task 3 will be completed. \n  //ContinueWith actually creates a continuation of executing tasks \n  //T4 and T5 asynchronously when the task T3 is completed\n  Task<int> t4 = t3.ContinueWith((antecendent) => { return Task4(); }); \n  Task<int> t5 = t3.ContinueWith((antecendent) => { return Task5(); }); \n  Console.Read(); \n} \n//Implementation of Task1\npublic static int Task1() \n{ \n  Thread.Sleep(1000); \n  Console.WriteLine(\"Task 1 is executed\"); \n  return 1; \n} \n\n//Implementation of Task2 \npublic static int Task2() \n{ \n  Thread.Sleep(1000); \n  Console.WriteLine(\"Task 2 is executed\"); \n  return 1; \n} \n//Implementation of Task3 \npublic static int Task3() \n{ \n  Thread.Sleep(1000); \n  Console.WriteLine(\"Task 3 is executed\"); \n  return 1; \n} \nImplementation of Task4\npublic static int Task4() \n{ \n  Thread.Sleep(1000); \n  Console.WriteLine(\"Task 4 is executed\"); \n  return 1; \n} \n\n//Implementation of Task5\npublic static int Task5() \n{ \n  Thread.Sleep(1000); \n  Console.WriteLine(\"Task 5 is executed\"); \n  return 1; \n} \n```", "```cs\nstatic void Main(string[] args) \n{ \n  int maxColl = 10; \n  var blockingCollection = new BlockingCollection<int>(maxColl); \n  var taskFactory = new TaskFactory(TaskCreationOptions.LongRunning, \n  TaskContinuationOptions.None); \n\n  Task producer = taskFactory.StartNew(() => \n  { \n    if (blockingCollection.Count <= maxColl) \n    { \n      int imageID = ReadImageFromDB(); \n      blockingCollection.Add(imageID); \n      blockingCollection.CompleteAdding(); \n    } \n  }); \n\n  Task consumer = taskFactory.StartNew(() => \n  { \n    while (!blockingCollection.IsCompleted) \n    { \n      try \n      { \n        int imageID = blockingCollection.Take(); \n        ProcessImage(imageID); \n      } \n      catch (Exception ex) \n      { \n        //Log exception \n      } \n    } \n  }); \n\n  Console.Read(); \n\n} \n\npublic static int ReadImageFromDB() \n{ \n  Thread.Sleep(1000); \n  Console.WriteLine(\"Image is read\"); \n  return 1; \n} \n\npublic static void ProcessImage(int imageID) \n{ \n  Thread.Sleep(1000); \n  Console.WriteLine(\"Image is processed\"); \n\n} \n```", "```cs\nstatic void Main(string[] args) \n{ \n  List<Document> docs = GetUserDocuments(); \n  Parallel.ForEach(docs, (doc) => \n  { \n    ManageDocument(doc); \n  }); \n} \nprivate static void ManageDocument(Document doc) => Thread.Sleep(1000); \n```", "```cs\nstatic void Main(string[] args) \n{ \n  List<Document> docs = GetUserDocuments(); \n\n  var query = from doc in docs.AsParallel() \n  select ManageDocument(doc); \n} \n\nprivate static Document ManageDocument(Document doc) \n{ \n  Thread.Sleep(1000); \n  return doc; \n} \n```"]