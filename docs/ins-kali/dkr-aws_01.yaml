- en: Container and Docker Fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器和Docker基础知识
- en: Docker and Amazon Web Services are two of the hottest and most popular technologies
    available right now.  Docker is the most popular container platform on the planet
    right now, while Amazon Web Services is the number 1 public cloud provider.  Organizations
    both large and small are adopting containers en masse, and the public cloud is
    no longer the playground of start-ups, with large enterprises and organizations
    migrating to the cloud in droves. The good news is that this book will give you
    practical, real-world insights and knowledge of how to use both Docker and AWS
    together to help you test, build, publish, and deploy your applications faster
    and more efficiently than ever before.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Docker和Amazon Web Services是目前最炙手可热和最受欢迎的两种技术。Docker目前是全球最流行的容器平台，而Amazon Web
    Services是排名第一的公共云提供商。无论是大型还是小型组织都在大规模地采用容器技术，公共云已不再是初创企业的游乐场，大型企业和组织也纷纷迁移到云端。好消息是，本书将为您提供有关如何同时使用Docker和AWS来帮助您比以往更快更高效地测试、构建、发布和部署应用程序的实用、现实世界的见解和知识。
- en: In this chapter, we will briefly discuss the history of Docker, why Docker is
    so revolutionary, and the high level architecture of Docker.  We will describe
    the various services that support running Docker in AWS, and discuss why you might
    choose one service over another based upon the requirements of your organization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要讨论Docker的历史，为什么Docker如此革命性，以及Docker的高级架构。我们将描述支持在AWS中运行Docker的各种服务，并根据组织的需求讨论为什么您可能会选择一个服务而不是另一个服务。
- en: We will then focus on getting your local environment up-and-running with Docker,
    and install the various software prerequisites required to run the sample application
    for this book.  The sample application is a simple web application written in
    Python that stores data in a  MySQL database, and this book will use the sample
    application to help you solve real-world challenges such as testing, building,
    and publishing Docker images, as well as deploying and running Docker applications
    in a variety of container management platforms on AWS. Before you can package
    the sample application as a Docker image, you need to understand the application's
    external dependencies and the key tasks that are required to test, build, deploy,
    and run the application, and you will learn how to install application dependencies,
    run unit tests, start the application up locally, and orchestrate key operational
    tasks such as establishing the initial database schema and tables required for
    the sample application to run.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将专注于使用Docker在本地环境中运行起来，并安装运行本书示例应用程序所需的各种软件前提条件。示例应用程序是一个简单的用Python编写的Web应用程序，它将数据存储在MySQL数据库中，本书将使用示例应用程序来帮助您解决诸如测试、构建和发布Docker镜像，以及在AWS上部署和运行Docker应用程序等真实世界挑战。在将示例应用程序打包为Docker镜像之前，您需要了解应用程序的外部依赖项以及测试、构建、部署和运行应用程序所需的关键任务，并学习如何安装应用程序依赖项、运行单元测试、在本地启动应用程序，并编排诸如建立示例应用程序所需的初始数据库架构和表等关键操作任务。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to containers and Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器和Docker简介
- en: Why containers are revolutionary
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么容器是革命性的
- en: Docker architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker架构
- en: Docker in AWS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS中的Docker
- en: Setting up a local Docker environment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置本地Docker环境
- en: Installing the sample application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装示例应用程序
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following lists the technical requirements to complete this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了完成本章所需的技术要求：
- en: A computer environment that meets the minimum specifications as defined in the
    software and hardware list
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足软件和硬件清单中定义的最低规格的计算机环境
- en: The following GitHub URL contains the code samples used in this chapter: [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch1](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch1)[.](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch3)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下GitHub网址包含本章中使用的代码示例：[https://github.com/docker-in-aws/docker-in-aws/tree/master/ch1](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch1)[.](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch3)
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：
- en: '[http://bit.ly/2PEKlVQ](http://bit.ly/2PEKlVQ)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2PEKlVQ](http://bit.ly/2PEKlVQ)'
- en: Introduction to containers and Docker
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器和Docker简介
- en: In recent times, containers have become a common lingua franca in the technology
    world, and it's difficult to imagine a world where, just a mere few years ago,
    only a small portion of the technology community had even heard about containers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，容器已成为技术世界中的共同语言，很难想象仅仅几年前，只有技术界的一小部分人甚至听说过容器。
- en: To trace the origins of containers, you need to rewind way back to 1979, when
    Unix V7 introduced the chroot system call.  The chroot system call provided the
    ability to change the root directory of a running process to a different location
    in the file system, and was the first mechanism available to provide some form
    of process isolation. chroot was added to the Berkeley Software Distribution (BSD)
    in 1982 (this is an ancestor of the modern macOS operating system), and not much
    more happened in terms of containerization and isolation for a number of years,
    until a feature called FreeBSD Jails was released in 2000, which provided separate
    environments called "jails" that could each be assigned their own IP address and
    communicate independently on the network.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要追溯容器的起源，您需要倒回到1979年，当时Unix V7引入了chroot系统调用。chroot系统调用提供了将运行中进程的根目录更改为文件系统中的不同位置的能力，并且是提供某种形式的进程隔离的第一个机制。chroot于1982年添加到伯克利软件发行版（BSD）中（这是现代macOS操作系统的祖先），在容器化和隔离方面没有太多其他进展，直到2000年发布了一个名为FreeBSD
    Jails的功能，它提供了称为“jails”的单独环境，每个环境都可以分配自己的IP地址，并且可以在网络上独立通信。
- en: Later, in 2004, Solaris launched the first public beta of Solaris Containers
    (which eventually became known as Solaris Zones), which provided system resource
    separation by creating zones. This was a technology I remember using back in 2007
    to help overcome a lack of expensive physical Sun SPARC infrastructure and run
    multiple versions of an application on a single SPARC server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 2004年，Solaris推出了Solaris容器的第一个公共测试版（最终成为Solaris Zones），通过创建区域提供系统资源分离。这是我记得在2007年使用的技术，帮助克服了昂贵的物理Sun
    SPARC基础设施的缺乏，并在单个SPARC服务器上运行应用程序的多个版本。
- en: In the mid 2000s, a lot more progress in the march toward containers occurred,
    with Open Virtuozzo (Open VZ) being released in 2005, which patched the Linux
    kernel to provide operating system level virtualization and isolation.  In 2006,
    Google launched a feature called process containers (which was eventually renamed
    to control groups or cgroups) that provided the ability to restrict CPU, memory,
    network, and disk usage for a set of processes. In 2008, a feature called Linux
    namespaces, which provided the ability to isolate different types of resources
    from each other, was combined with cgroups to create Linux Containers (LXC), forming
    the initial foundation to modern containers as we know them today.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代中期，容器的进展更加显著，Open Virtuozzo（Open VZ）于2005年发布，它对Linux内核进行了补丁，提供了操作系统级的虚拟化和隔离。2006年，谷歌推出了一个名为进程容器（最终更名为控制组或cgroups）的功能，提供了限制一组进程的CPU、内存、网络和磁盘使用的能力。2008年，一个名为Linux命名空间的功能，提供了将不同类型的资源相互隔离的能力，与cgroups结合起来创建了Linux容器（LXC），形成了今天我们所知的现代容器的初始基础。
- en: In 2010, as cloud computing was starting to gain popularity, a number of Platform-as-a-Service
    (PaaS) start-ups appeared, which provided fully managed runtime environments for
    specific application frameworks such as Java Tomcat or Ruby on Rails.  One start-up
    called dotCloud was quite different, in that it was the first "polyglot" PaaS
    provider, meaning that you could run virtually any application environment you
    wanted using their service.  The technology underpinning this was Linux Containers,
    and dotCloud added a number or proprietary features to provide a fully managed
    container platform for their customers.  By 2013, the PaaS market had well and
    truly entered the Gartner hype cycle ([https://en.wikipedia.org/wiki/Hype_cycle](https://en.wikipedia.org/wiki/Hype_cycle))
    trough of disillusionment, and dotCloud was on the brink of financial collapse.
    One of the co-founders of the company, Solomon Hykes, pitched an idea to the board
    to open source their container management technology, sensing that there was huge
    potential.  The board disagreed, however Solomon and his technical team proceeded
    regardless, and the rest, as they say, is history.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，随着云计算开始流行起来，一些平台即服务（PaaS）初创公司出现了，它们为特定的应用程序框架（如Java Tomcat或Ruby on Rails）提供了完全托管的运行时环境。一家名为dotCloud的初创公司非常不同，因为它是第一家“多语言”PaaS提供商，意味着您可以使用他们的服务运行几乎任何应用程序环境。支撑这一技术的是Linux容器，dotCloud添加了一些专有功能，为他们的客户提供了一个完全托管的容器平台。到了2013年，PaaS市场已经真正进入了Gartner炒作周期的失望低谷，dotCloud濒临财务崩溃。该公司的联合创始人之一Solomon
    Hykes向董事会提出了一个开源他们的容器管理技术的想法，他感觉到有巨大的潜力。然而，董事会不同意，但Solomon和他的技术团队仍然继续前进，剩下的就是历史。
- en: After announcing Docker as a new open source container management platform to
    the world in 2013, Docker quickly rose in prominence, becoming the darling of
    the open source world and vendor community alike, and is likely one of the fastest
    growing  technologies in history.  By the end of 2014, during which time Docker
    1.0 was released, over 100 million Docker containers had been downloaded – fast
    forward to March 2018, and that number sat at *37* *billion* downloads. At the
    end of 2017, container usage amongst Fortune 100 companies sat at 71%, indicating
    that Docker and containers have become universally accepted for both start-ups
    and enterprises alike.  Today, if you are building modern, distributed applications
    based upon microservice architectures, chances are that your technology stack
    will be underpinned by Docker and containers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在2013年将Docker作为一个新的开源容器管理平台向世界宣布后，Docker迅速崛起，成为开源世界和供应商社区的宠儿，很可能是历史上增长最快的技术之一。到2014年底，Docker
    1.0发布时，已经下载了超过1亿个Docker容器 - 快进到2018年3月，这个数字已经达到了*370* *亿*次下载。到2017年底，财富100强公司中使用容器的比例达到了71%，表明Docker和容器已经成为创业公司和企业普遍接受的技术。如今，如果您正在构建基于微服务架构的现代分布式应用程序，那么您的技术栈很可能是以Docker和容器为基础。
- en: Why containers are revolutionary
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器为何是革命性的
- en: 'The brief and successful history of containers speaks for itself, which leads
    to the question, *why are containers so popular*?  The following provides some
    of the more important answers to this question:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的简短而成功的历史证明了它的价值，这引出了一个问题，*为什么容器如此受欢迎*？以下提供了这个问题的一些更重要的答案：
- en: '**Lightweight**: Containers are often compared to virtual machines, and in
    this context, containers are much more lightweight that virtual machines.  A container
    can start up an isolated and secure runtime environment for your application in
    seconds, compared with the handful of minutes a typical virtual machine takes
    to start. Container images are also much smaller than their virtual machine counterparts.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级：容器经常与虚拟机进行比较，在这种情况下，容器比虚拟机要轻量得多。与典型虚拟机需要几分钟启动时间相比，容器可以在几秒钟内为您的应用程序启动一个隔离和安全的运行时环境。容器镜像也比虚拟机镜像要小得多。
- en: '**Speed**: Containers are fast – they can be downloaded and started within
    seconds, and within a few minutes you can test, build, and publish your Docker
    image for immediate download.  This allows organizations to innovate faster, which
    is critical in today''s ever increasing competitive landscape.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度：容器很快 - 它们可以在几秒内下载和启动，并且在几分钟内您就可以测试、构建和发布您的Docker镜像以供立即下载。这使得组织能够更快地创新，这在当今竞争日益激烈的环境中至关重要。
- en: '**Portable**: Docker makes it easier than ever to run your applications on
    your local machine, in your data center, and in the public cloud.  Because Docker
    packages are complete runtime environments for your application complete with
    operating system dependencies and third-party packages, your container hosts don''t
    required any special prior setup or configuration specific to each individual
    application – all of these specific dependencies and requirements are self-contained
    within the Docker image, making comments like "But it worked on my machine!" relics
    of the past.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 便携：Docker使您能够更轻松地在本地机器、数据中心和公共云上运行应用程序。因为Docker包含了应用程序的完整运行时环境，包括操作系统依赖和第三方软件包，您的容器主机不需要任何特殊的预先设置或针对每个应用程序的特定配置
    - 所有这些特定的依赖和要求都包含在Docker镜像中，使得“但在我的机器上可以运行！”这样的评论成为过去的遗迹。
- en: '**Security**: There has been a lot of debate about the security of containers,
    but in my opinion, if implemented correctly, containers actually offer greater
    security than non-container alternative approaches.  The main reason for this
    is that containers express security context very well – applying security controls
    at the container level typically represents the right level of context for those
    controls. A lot of these security controls are provided by "default" – for example,
    namespaces are inherently a security mechanism in that they provide isolation. 
    A more explicit example is that they can apply SELinux or AppArmor profiles on
    a per container basis, making it very easy to define different profiles depending
    on specific security requirements of each container.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：关于容器安全性的讨论很多，但在我看来，如果实施正确，容器实际上比非容器替代方法提供了更高的安全性。主要原因是容器非常好地表达了安全上下文
    - 在容器级别应用安全控制通常代表了这些控制的正确上下文级别。很多这些安全控制都是“默认”提供的 - 例如，命名空间本质上是一种安全机制，因为它们提供了隔离。一个更明确的例子是，它们可以在每个容器基础上应用SELinux或AppArmor配置文件，这样很容易根据每个容器的特定安全要求定义不同的配置文件。'
- en: '**Automation**: Organizations are adopting software delivery practices such
    as continuous delivery, where automation is a fundamental requirement.  Docker
    natively supports automation – at its core, a Dockerfile is an automation specification
    of sorts that allows the Docker client to automatically build your containers,
    and other Docker tools such as Docker Compose allow you express connected multi-container
    environments that you can automatically create and tear down in seconds.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：组织正在采用诸如持续交付之类的软件交付实践，其中自动化是基本要求。Docker本身支持自动化 - 在其核心，Dockerfile是一种自动化规范，允许Docker客户端自动构建您的容器，而其他Docker工具如Docker
    Compose允许您表达连接的多容器环境，您可以在几秒钟内自动创建和拆除。'
- en: Docker architecture
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker架构
- en: As discussed in the preface of this book, I assume that you have at least a
    basic working knowledge of Docker. If you are new to Docker, then I recommend
    that you supplement your learning in this chapter by reading the Docker overview
    at [https://docs.docker.com/engine/docker-overview/](https://docs.docker.com/engine/docker-overview/),
    and running through some of the Docker tutorials at [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书前言中所讨论的，我假设您至少具有基本的Docker工作知识。如果您是Docker的新手，那么我建议您通过阅读[https://docs.docker.com/engine/docker-overview/](https://docs.docker.com/engine/docker-overview/)上的Docker概述，并通过运行一些Docker教程来补充学习本章内容。
- en: 'The Docker architecture includes several core components, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Docker架构包括几个核心组件，如下所示：
- en: '**Docker Engine**: This provides several server code components for running
    your container workloads, including an API server for communications with Docker
    clients, and the Docker daemon that provides the core runtime of Docker.  The
    daemon is responsible for the complete life cycle of your containers and other
    resources, and also ships with built-in clustering support to allow you to build
    clusters or swarms of your Docker Engines.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker引擎**：它提供了用于运行容器工作负载的几个服务器代码组件，包括用于与Docker客户端通信的API服务器，以及提供Docker核心运行时的Docker守护程序。守护程序负责完整的容器和其他资源的生命周期，并且还内置了集群支持，允许您构建Docker引擎的集群或群集。'
- en: '**Docker client**: This provides a client for building Docker images, running
    Docker containers, and managing other resources such as Docker volumes and Docker
    networks. The Docker client is the primary tool you will work with when using
    Docker, and interacts with both the Docker Engine and Docker registry components.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker客户端：这提供了一个用于构建Docker镜像、运行Docker容器以及管理其他资源（如Docker卷和Docker网络）的客户端。Docker客户端是您在使用Docker时将要使用的主要工具，它与Docker引擎和Docker注册表组件进行交互。
- en: '**Docker registry**: This is responsible for storing and distributing Docker
    images for your application.  Docker supports both public and private registries,
    and the ability to package and distribute your applications via a Docker registry
    is one of the major reasons for Docker''s success.  In this book, you will download
    third-party images from Docker Hub, and you will store your own application images
    in the private AWS registry service called **Elastic Container Registry** (**ECR**).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker注册表：这负责存储和分发您应用程序的Docker镜像。Docker支持公共和私有注册表，并且通过Docker注册表打包和分发您的应用程序是Docker成功的主要原因之一。在本书中，您将从Docker
    Hub下载第三方镜像，并将自己的应用程序镜像存储在名为弹性容器注册表（ECR）的私有AWS注册表服务中。
- en: '**Docker Swarm**: A swarm is a collection of Docker Engines that form a self-managing
    and self-healing cluster, allowing you to horizontally scale your container workloads
    and provide resiliency in the event of Docker Engine failures. A Docker Swarm
    cluster includes a number of master nodes that form the cluster control plane,
    and a number of worker nodes that actually run your container workloads.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Swarm：Swarm是一组Docker引擎，形成一个自管理和自愈的集群，允许您水平扩展容器工作负载，并在Docker引擎故障时提供弹性。Docker
    Swarm集群包括一些形成集群控制平面的主节点，以及一些实际运行您的容器工作负载的工作节点。
- en: 'When you work with the preceding components, you interact with a number of
    different types of objects in the Docker architecture:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用上述组件时，您将与Docker架构中的许多不同类型的对象进行交互：
- en: '**Images**: An image is built using a Dockerfile, which includes a number of
    instructions on how to build the runtime environment for your containers.  The
    result of executing each of these build instructions is stored as a set of layers
    and is distributed as a downloadable and installable image, and the Docker Engine
    reads the instructions in each layer to construct a runtime environment for all
    containers based on a given image.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像：镜像是使用Dockerfile构建的，其中包括一些关于如何为您的容器构建运行时环境的指令。执行每个构建指令的结果被存储为一组层，并作为可下载和可安装的镜像进行分发，Docker引擎读取每个层中的指令，以构建基于给定镜像的所有容器的运行时环境。
- en: '**Containers**: A container is the runtime manifestation of a Docker image.
    Under the hood, a container is comprised of a collection of Linux namespaces,
    control groups, and storage that collectively create an isolated runtime environment
    form which you can run a given application process.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器：容器是Docker镜像的运行时表现形式。在幕后，容器由一组Linux命名空间、控制组和存储组成，共同创建了一个隔离的运行时环境，您可以在其中运行给定的应用程序进程。
- en: '**Volumes**: By default, the underlying storage mechanism for containers is
    based upon the union file system, which allows a virtual file system to be constructed
    from the various layers in a Docker image. This approach is very efficient in
    that you can share layers and build up multiple containers from these shared layers,
    however this does have a performance penalty and does not support persistence. 
    Docker volumes provide access to a dedicated pluggable storage medium, which your
    containers can use for IO intensive applications and to persist data.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷**：默认情况下，容器的基础存储机制基于联合文件系统，允许从Docker镜像中的各个层构建虚拟文件系统。这种方法非常高效，因为您可以共享层并从这些共享层构建多个容器，但是这会带来性能损失，并且不支持持久性。
    Docker卷提供对专用可插拔存储介质的访问，您的容器可以使用该介质进行IO密集型应用程序和持久化数据。'
- en: '**Networks**: By default, Docker containers each operate in their own network
    namespace, which provides isolation between containers. However, they must still
    provide network connectivity to other containers and the outside world.  Docker
    supports a variety of network plugins that support connectivity between containers,
    which can even extend across Docker Swarm clusters.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：默认情况下，Docker容器各自在其自己的网络命名空间中运行，这提供了容器之间的隔离。但是，它们仍然必须提供与其他容器和外部世界的网络连接。
    Docker支持各种网络插件，支持容器之间的连接，甚至可以跨Docker Swarm集群进行扩展。'
- en: '**Services**: A service provides an abstraction that allows you to scale your
    applications by spinning up multiple containers or replicas of your service that
    can be load balanced across multiple Docker Engines in a Docker Swarm cluster.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：服务提供了一个抽象，允许您通过在Docker Swarm集群中的多个Docker引擎上启动多个容器或服务副本来扩展您的应用程序，并且可以在这些Docker引擎上进行负载平衡。'
- en: Running Docker in AWS
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS中运行Docker
- en: Along with Docker, the other major technology platform we will target in this
    book is AWS.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Docker之外，本书将针对的另一个主要技术平台是AWS。
- en: 'AWS is the world''s leading public cloud provider, and as such offers a variety
    of ways to run your Docker applications:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: AWS是世界领先的公共云提供商，因此提供了多种运行Docker应用程序的方式：
- en: '**Elastic Container Service (ECS)**: In 2014, AWS launched ECS, which was the
    first dedicated public cloud offering that supported Docker.  ECS provides a hybrid
    managed service of sorts, where ECS is responsible for orchestrating and deploying
    your container applications (such as the control plane of a container management
    platform), and you are responsible for providing the Docker Engines (referred
    to as ECS container instances) that your containers will actually run on.  ECS
    is free to use (you only pay for the ECS container instances that run your containers),
    and removes much of the complexity of managing container orchestration and ensuring
    your applications are always up and running. However, this does require you to
    manage the EC2 infrastructure that runs your ECS container instances.  ECS is
    considered Amazon''s flagship Docker service and as such will be the primary service
    that we will focus on in this book.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性容器服务（ECS）**：2014年，AWS推出了ECS，这是第一个支持Docker的专用公共云服务。 ECS提供了一种混合托管服务，ECS负责编排和部署您的容器应用程序（例如容器管理平台的控制平面），而您负责提供Docker引擎（称为ECS容器实例），您的容器实际上将在这些实例上运行。
    ECS是免费使用的（您只需支付运行您的容器的ECS容器实例），并且消除了管理容器编排和确保应用程序始终运行的许多复杂性。但是，这需要您管理运行ECS容器实例的EC2基础设施。
    ECS被认为是亚马逊的旗舰Docker服务，因此将是本书重点关注的主要服务。'
- en: '**Fargate**: Fargate was launched in late 2017 and provides a fully managed
    container platform that manages both the ECS control plane and ECS container instances
    for you.  With Fargate, your container applications are deployed onto shared ECS
    container instance infrastructures that you have no visibility of which AWS manages,
    allowing you to focus on building, testing, and deploying your container applications
    without having to worry about any underlying infrastructure. Fargate is a fairly
    new service that, at the time of writing this book, has limited regional availability,
    and has some constraints that mean it is not suitable for all use cases.  We will
    cover the Fargate service in Chapter 14, *Fargate and ECS Service Discovery.*'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fargate：Fargate于2017年底推出，提供了一个完全托管的容器平台，可以为您管理ECS控制平面和ECS容器实例。使用Fargate，您的容器应用程序部署到共享的ECS容器实例基础设施上，您无法看到这些基础设施，而AWS进行管理，这样您就可以专注于构建、测试和部署容器应用程序，而不必担心任何基础设施。Fargate是一个相对较新的服务，在撰写本书时，其区域可用性有限，并且有一些限制，这意味着它并不适用于所有用例。我们将在第14章《Fargate和ECS服务发现》中介绍Fargate服务。
- en: '**Elastic Kubernetes Service (EKS)**: EKS launched in June 2018 and supports
    the popular open source Kubernetes container management platform. EKS is similar
    to ECS in that it is a hybrid managed service where Amazon provides fully managed
    Kubernetes master nodes (the Kubernetes control plane), and you provide Kubernetes
    worker nodes in the form of EC2 autoscaling groups that run your container workloads. 
    Unlike ECS, EKS is not free and at the time of writing this book costs 0.20c USD
    per hour, plus any EC2 infrastructure costs associated with your worker nodes. 
    Given the ever growing popularity of Kubernetes as a cloud/infrastructure agnostic
    container management platform, along with its open source community, EKS is sure
    to become very popular, and we will provide an introduction to Kubernetes and
    EKS in [Chapter 17](6b944444-e255-4f19-abde-d9b69e20f0d3.xhtml), *Elastic Kubernetes
    Service*.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性Kubernetes服务（EKS）：EKS于2018年6月推出，支持流行的开源Kubernetes容器管理平台。EKS类似于ECS，它是一个混合托管服务，亚马逊提供完全托管的Kubernetes主节点（Kubernetes控制平面），您提供Kubernetes工作节点，以EC2自动扩展组的形式运行您的容器工作负载。与ECS不同，EKS并不免费，在撰写本书时，其费用为每小时0.20美元，加上与工作节点相关的任何EC2基础设施成本。鉴于Kubernetes作为一个云/基础设施不可知的容器管理平台以及其开源社区的不断增长的受欢迎程度，EKS肯定会变得非常受欢迎，我们将在第17章《弹性Kubernetes服务》中介绍Kubernetes和EKS。
- en: '**Elastic Beanstalk (EBS)**: Elastic Beanstalk is a popular Platform as a Service
    (PaaS) offering provided by AWS that provides a complete and fully managed environment
    that targets different types of popular programming languages and application
    frameworks such as Java, Python, Ruby, and Node.js. Elastic Beanstalk also supports
    Docker applications, allowing you to support a wide variety of applications written
    in the programming language of your choice. You will learn how to deploy a multi-container
    Docker application in Chapter 15, *Elastic Beanstalk*.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性Beanstalk（EBS）：Elastic Beanstalk是AWS提供的一种流行的平台即服务（PaaS）产品，提供了一个完整和完全托管的环境，针对不同类型的流行编程语言和应用框架，如Java、Python、Ruby和Node.js。Elastic
    Beanstalk还支持Docker应用程序，允许您支持各种使用您选择的编程语言编写的应用程序。您将在第15章《弹性Beanstalk》中学习如何部署多容器Docker应用程序。
- en: '**Docker Swarm in AWS**: Docker Swarm is the native container management and
    clustering platform built into Docker that leverages the native Docker and Docker
    Compose tool chain to manage and deploy your container applications.  At the time
    of writing this book, AWS does not provide a managed offering for Docker Swarm,
    however Docker provides a CloudFormation template (CloudFormation is a free Infrastructure
    as Code automation and management service provided by AWS) that allows you to
    quickly deploy a Docker Swarm cluster in AWS that integrates with native AWS offerings
    include the Elastic Load Balancing (ELB) and Elastic Block Store (EBS) services. 
    We will cover all of this and more in the chapter *Docker Swarm in AWS*.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AWS中的Docker Swarm：Docker Swarm是内置在Docker中的本地容器管理和集群平台，利用本地Docker和Docker Compose工具链来管理和部署容器应用程序。在撰写本书时，AWS并未提供Docker
    Swarm的托管服务，但Docker提供了一个CloudFormation模板（CloudFormation是AWS提供的免费基础设施即代码自动化和管理服务），允许您快速在AWS中部署与本地AWS提供的Elastic
    Load Balancing（ELB）和Elastic Block Store（EBS）服务集成的Docker Swarm集群。我们将在章节《在AWS中的Docker
    Swarm》中涵盖所有这些内容以及更多内容。
- en: '**CodeBuild**: AWS CodeBuild is a fully managed build service that supports
    continuous delivery use cases by providing a container-based build agent that
    you can use to test, build, and deploy your applications without having to manage
    any of the infrastructure traditionally associated with continuous delivery systems. 
    CodeBuild uses Docker as its container platform for spinning up build agents on
    demand, and you will be introduced to CodeBuild along with other continuous delivery
    tools such as CodePipeline in the chapter *Continuously Delivering ECS Applications*.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeBuild：AWS CodeBuild是一个完全托管的构建服务，支持持续交付用例，提供基于容器的构建代理，您可以使用它来测试、构建和部署应用程序，而无需管理与持续交付系统传统相关的任何基础设施。CodeBuild使用Docker作为其容器平台，以按需启动构建代理，您将在章节《持续交付ECS应用程序》中介绍CodeBuild以及其他持续交付工具，如CodePipeline。
- en: '**Batch**: AWS Batch provides a fully managed service based upon ECS that allows
    you to run container-based batch workloads without needing to worry about managing
    or maintaining any supporting infrastructure.  We will not be covering AWS Batch
    in this book, however you can learn more about this service at [https://aws.amazon.com/batch/](https://aws.amazon.com/batch/).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批处理：AWS Batch是基于ECS的完全托管服务，允许您运行基于容器的批处理工作负载，无需担心管理或维护任何支持基础设施。我们在本书中不会涵盖AWS
    Batch，但您可以在[https://aws.amazon.com/batch/](https://aws.amazon.com/batch/)了解更多关于此服务的信息。
- en: With such a wide variety of options to run your Docker applications on AWS,
    it is important to be able to choose the right solution based upon the requirements
    of your organization or specific use cases.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS上运行Docker应用程序有各种各样的选择，因此根据组织或特定用例的要求选择合适的解决方案非常重要。
- en: If you are a small to medium sized organization that wants to get up and running
    quickly with Docker on AWS, and you don't want to manage any supporting infrastructure,
    then Fargate or Elastic Beanstalk are options that you may prefer.  Fargate supports
    native integration with key AWS services, and is a building block component that
    doesn't dictate how your build, deploy, or operate your applications.  At the
    time of writing this book, Fargate is not available in all regions, is comparatively
    expensive when compared to other solutions, and has some limitations such as not
    being able to support persistent storage.  Elastic Beanstalk provides a comprehensive
    end-to-end solution for managing your Docker applications, providing a variety
    of integrations out of the box, and includes operational tooling to manage the
    complete life cycle of your applications. Elastic Beanstalk does require you to
    buy into a very opinionated framework and methodology of how to build, deploy,
    and run your applications, and can be difficult to customize to meet your needs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一家希望快速在AWS上使用Docker并且不想管理任何支持基础设施的中小型组织，那么Fargate或Elastic Beanstalk可能是您更喜欢的选项。Fargate支持与关键的AWS服务原生集成，并且是一个构建组件，不会规定您构建、部署或运行应用程序的方式。在撰写本书时，Fargate并不是所有地区都可用，与其他解决方案相比价格昂贵，并且有一些限制，比如不能支持持久存储。Elastic
    Beanstalk为管理您的Docker应用程序提供了全面的端到端解决方案，提供了各种开箱即用的集成，并包括操作工具来管理应用程序的完整生命周期。Elastic
    Beanstalk确实要求您接受一个非常有主见的框架和方法论，来构建、部署和运行您的应用程序，并且可能难以定制以满足您的需求。
- en: If you are a larger organization that has specific requirements around security
    and compliance, or just wants greater flexibility and control over the infrastructure
    that runs your container workloads, then you should consider ECS, EKS, and Docker
    Swarm. ECS is the native flagship container management platform of choice for
    AWS, and as such has a large customer base that has been running containers at
    scale for a number of years.  As you will learn in this book, ECS is integrated
    with CloudFormation, which allows you to define all of your clusters, application
    services, and container definitions using an Infrastructure as Code approach that
    can be combined with other AWS resources to provide you with the ability to deploy
    complete, complex environments with the click of a button. That said, the main
    criticism of ECS is that it is a proprietary solution specific to AWS, meaning
    that you can't use it in other cloud environments or run it on your own infrastructure. 
    Increasingly larger organizations are looking to infrastructure and cloud agnostic
    cloud management platforms, and this is where you should consider EKS or Docker
    Swarm if these are your goals. Kubernetes has taken the container orchestration
    world by storm, and is now one of the largest and most popular open source projects. 
    AWS now offers a managed Kubernetes service in the form of EKS, which makes it
    very easy to get Kubernetes up and running in AWS, and leverage core integrations
    with CloudFormation, and the Elastic Load Balancing (ELB) and Elastic Block Store
    (EBS) services. Docker Swarm is a competitor to Kubernetes, and although it seems
    to have lost the battle for container orchestration supremacy to Kubernetes, it
    does have the advantage of being a native out-of-the-box feature integrated with
    Docker which is very easy to get up and running using familiar Docker tools. 
    Docker does currently publish CloudFormation templates and support key integrations
    with AWS services that makes it very easy to get up and running in AWS. However,
    there are concerns around the longevity of such solutions given that Docker Inc.
    is a commercial entity and the ever growing popularity and dominance of Kubernetes
    may force Docker Inc. to focus solely on its paid Docker Enterprise Edition and
    other commercial offerings in the future.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一个有特定安全和合规要求的大型组织，或者只是希望对运行容器工作负载的基础架构拥有更大的灵活性和控制权，那么您应该考虑ECS、EKS和Docker
    Swarm。ECS是AWS的本地旗舰容器管理平台，因此拥有大量客户群体多年来一直在大规模运行容器。正如您将在本书中了解到的，ECS与CloudFormation集成，可以让您使用基础设施即代码的方法定义所有集群、应用服务和容器定义，这可以与其他AWS资源结合使用，让您能够通过点击按钮部署完整、复杂的环境。尽管如此，ECS的主要批评是它是AWS特有的专有解决方案，这意味着您无法在其他云环境中使用它，也无法在自己的基础设施上运行它。越来越多的大型组织正在寻找基础设施和云无关的云管理平台，如果这是您的目标，那么您应该考虑EKS或Docker
    Swarm。Kubernetes已经席卷了容器编排世界，现在是最大和最受欢迎的开源项目之一。AWS现在提供了EKS这样的托管Kubernetes服务，这使得在AWS中轻松启动和运行Kubernetes变得非常容易，并且可以利用与CloudFormation、弹性负载均衡（ELB）和弹性块存储（EBS）服务的核心集成。Docker
    Swarm是Kubernetes的竞争对手，尽管它似乎已经输掉了容器编排的霸主地位争夺战，但它有一个优势，那就是作为Docker的本地开箱即用功能与Docker集成，使用熟悉的Docker工具非常容易启动和运行。Docker目前确实发布了CloudFormation模板，并支持与AWS服务的关键集成，这使得在AWS中轻松启动和运行变得非常容易。然而，人们对这类解决方案的持久性存在担忧，因为Docker
    Inc.是一个商业实体，而Kubernetes的日益增长的流行度和主导地位可能会迫使Docker Inc.将未来的重点放在其付费的Docker企业版和其他商业产品上。
- en: As you can see, there are many considerations when it comes to choosing a solution
    that is right for you, and the great thing about this book is that you will learn
    how to use each of these approaches to deploy and run your Docker applications
    in AWS.  Regardless of which solution you think might sounds more suited to you
    right now, I encourage you to read through and complete all of the chapters in
    this book, as much of the content you will learn for one specific solution can
    be applied to the other solutions, and you will be in a much better position to
    tailor and build a comprehensive container management solution based upon your
    desired outcomes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，选择适合您的解决方案时有许多考虑因素，而本书的好处在于您将学习如何使用这些方法中的每一种来在AWS中部署和运行Docker应用程序。无论您现在认为哪种解决方案更适合您，我鼓励您阅读并完成本书中的所有章节，因为您将学到的大部分内容都可以应用于其他解决方案，并且您将更有能力根据您的期望结果定制和构建全面的容器管理解决方案。
- en: Setting up a local Docker environment
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置本地Docker环境
- en: With introductions out of the way, it is time to get started and set up a local
    Docker environment that you will use to test, build, and deploy a Docker image
    for the sample application used for this book.  For now, we will focus on getting
    Docker up and running, however note that later on we will also use your local
    environment to interact with the various container management platforms discussed
    in this book, and to manage all of your AWS resources using the AWS console, AWS
    command-line interface, and AWS CloudFormation service.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 完成介绍后，是时候开始设置本地Docker环境了，您将使用该环境来测试、构建和部署本书中使用的示例应用程序的Docker镜像。现在，我们将专注于启动和运行Docker，但请注意，稍后我们还将使用您的本地环境与本书中讨论的各种容器管理平台进行交互，并使用AWS控制台、AWS命令行界面和AWS
    CloudFormation服务来管理所有AWS资源。
- en: 'Although this book is titled Docker on Amazon Web Services, it is important
    to note that Docker containers come in two flavors:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书的标题是Docker on Amazon Web Services，但重要的是要注意Docker容器有两种类型：
- en: Linux containers
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux容器
- en: Windows containers
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows容器
- en: This book is exclusively focused on Linux containers, which are designed to
    run on a Linux-based kernel with the Docker Engine installed. When you want to
    use your local environment to build, test, and run Linux containers locally, this
    means you must have access to a local Linux-based Docker Engine.  If you are operating
    on a Linux-based system such as Ubuntu, you can install a Docker Engine natively
    in your operating system. However, if you are using Windows or macOS, this requires
    you to set up a local virtual machine that runs the Docker Engine and install
    a Docker client for your operating system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本书专注于Linux容器，这些容器旨在在安装了Docker Engine的基于Linux的内核上运行。当您想要使用本地环境来构建、测试和本地运行Linux容器时，这意味着您必须能够访问本地基于Linux的Docker
    Engine。如果您正在使用基于Linux的系统，如Ubuntu，您可以在操作系统中本地安装Docker Engine。但是，如果您使用Windows或macOS，则需要设置一个运行Docker
    Engine的本地虚拟机，并为您的操作系统安装Docker客户端。
- en: Luckily, Docker has great packaging and tooling for making this process very
    simple on Windows and macOS environments, and we will now discuss how to set up
    a local Docker environment for macOS, Windows 10, and Linux, along with other
    tools that will be used in this book such as Docker Compose and GNU Make.  For
    Windows 10 environments, I will also cover how to set up the Windows 10 Linux
    subsystem to interact with your local Docker installation, which will provide
    you with access to an environment where you can run the other Linux-based tools
    that are used throughout this book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Docker在Windows和macOS环境中有很好的打包和工具，使得这个过程非常简单，我们现在将讨论如何在macOS、Windows 10和Linux上设置本地Docker环境，以及本书中将使用的其他工具，如Docker
    Compose和GNU Make。对于Windows 10环境，我还将介绍如何设置Windows 10 Linux子系统与本地Docker安装进行交互，这将为您提供一个环境，您可以在其中运行本书中使用的其他基于Linux的工具。
- en: 'Before we continue, it''s also important to note that from a licensing perspective,
    Docker is currently available in two different editions, which you can learn more
    about at [https://docs.docker.com/install/overview/](https://docs.docker.com/install/overview/):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，还需要注意的是，从许可的角度来看，Docker目前有两个不同的版本，您可以在[https://docs.docker.com/install/overview/](https://docs.docker.com/install/overview/)了解更多信息。
- en: Community edition (CE)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区版（CE）
- en: Enterprise edition (EE)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业版（EE）
- en: We will be working exclusively with the free community edition (Docker CE),
    which includes the core Docker Engine.  Docker CE is suitable for use with all
    of the technologies and services we will cover in this book, including Elastic
    Container Service (ECS), Fargate, Docker Swarm, Elastic Kubernetes Service (EKS),
    and Elastic Beanstalk.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专门使用免费的社区版（Docker CE），其中包括核心Docker引擎。Docker CE适用于本书中将涵盖的所有技术和服务，包括弹性容器服务（ECS）、Fargate、Docker
    Swarm、弹性Kubernetes服务（EKS）和弹性Beanstalk。
- en: 'Along with Docker, we also need a few other tools to help automate a number
    of build, test, and deployment tasks that we will be performing throughout this
    book:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Docker，我们还需要其他一些工具来帮助自动化一些构建、测试和部署任务，这些任务将贯穿本书的整个过程：
- en: '**Docker Compose**: This allows you to orchestrate and run multi-container
    environments both locally and on Docker Swarm clusters'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose：这允许您在本地和Docker Swarm集群上编排和运行多容器环境
- en: '**Git**: This is required to fork and clone the sample application from GitHub
    and create your own Git repositories for the various applications and environments
    you will create in this book'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git：这是从GitHub分叉和克隆示例应用程序以及为本书中创建的各种应用程序和环境创建您自己的Git存储库所需的
- en: '**GNU Make 3.82 or higher**: This provides task automation, allowing you run
    simple commands (for example, `make test`) to execute a given task'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Make 3.82或更高版本：这提供了任务自动化，允许您运行简单命令（例如`make test`）来执行给定的任务
- en: '**jq**: A command-line utility for parsing JSON'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jq：用于解析JSON的命令行实用程序
- en: '**curl**: A command-line HTTP client'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: curl：命令行HTTP客户端
- en: '**tree**: A command-line client for displaying folder structures in the shell'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tree：用于在shell中显示文件夹结构的命令行客户端
- en: '**Python interpreter**: This is required for Docker Compose and the AWS Command-Line
    Interface (CLI) tool that we will install in a later chapter'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python解释器：这是Docker Compose和我们将在后面的章节中安装的AWS命令行界面（CLI）工具所需的
- en: '**pip**: A Python package manager for installing Python applications such as
    the AWS CLI'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pip：用于安装Python应用程序的Python包管理器，如AWS CLI
- en: Some of the tools used in this book are representative only, meaning that you
    can replace them with alternatives if you desire.  For example, you could replace
    GNU Make with another tool to provide task automation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中使用的一些工具仅代表性，这意味着如果您愿意，可以用替代工具替换它们。例如，您可以用另一个工具替换GNU Make来提供任务自动化。
- en: One other important tool that you will need is a decent text editor – Visual
    Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    and Sublime Text ([https://www.sublimetext.com/](https://www.sublimetext.com/))
    are excellent choices which are available on Windows, macOS, and Linux.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要的另一个重要工具是一个体面的文本编辑器 - Visual Studio Code（[https://code.visualstudio.com/](https://code.visualstudio.com/)）和Sublime
    Text（[https://www.sublimetext.com/](https://www.sublimetext.com/)）是在Windows、macOS和Linux上都可用的绝佳选择。
- en: 'Now, let''s discuss how to install and configure your local Docker environment
    for the following operating systems:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何为以下操作系统安装和配置本地Docker环境：
- en: macOS
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS
- en: Windows 10
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 10
- en: Linux
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux
- en: Setting up a macOS environment
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在macOS环境中设置
- en: If you are running macOS, the quickest way to get Docker up and running is to
    install Docker for Mac, which you can read more about at [https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/) and
    download from [https://store.docker.com/editions/community/docker-ce-desktop-mac](https://store.docker.com/editions/community/docker-ce-desktop-mac).  Under
    the hood, Docker for Mac leverages the native macOS  hypervisor framework, creating
    a Linux virtual machine to run the Docker Engine and installing a Docker client
    in your local macOS environment.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行macOS，最快的方法是安装Docker for Mac，您可以在[https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/)了解更多信息，并从[https://store.docker.com/editions/community/docker-ce-desktop-mac](https://store.docker.com/editions/community/docker-ce-desktop-mac)下载。在幕后，Docker
    for Mac利用本机macOS虚拟机框架，创建一个Linux虚拟机来运行Docker Engine，并在本地macOS环境中安装Docker客户端。
- en: 'You will first need to create a free Docker Hub account in order to proceed,
    and once you have completed registration and logged in, click the **Get Docker**
    button to download the latest version of Docker:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要创建一个免费的Docker Hub账户，然后完成注册并登录，点击**获取Docker**按钮下载最新版本的Docker：
- en: '![](assets/50c69c6a-219f-4dc3-9f46-ae375eeb4e3a.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/50c69c6a-219f-4dc3-9f46-ae375eeb4e3a.png)'
- en: Downloading Docker for Mac
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下载Docker for Mac
- en: 'Once you have completed the download, open the download file, drag the Docker
    icon to the Applications folder, and then run Docker:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完成下载后，打开下载文件，将Docker图标拖到应用程序文件夹中，然后运行Docker：
- en: '![](assets/edbdc313-3f39-4b8a-891f-6e0cabdc3429.png)Installing Docker'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/edbdc313-3f39-4b8a-891f-6e0cabdc3429.png)安装Docker'
- en: 'Proceed through the Docker installation wizard and once complete, you should
    see a Docker icon on your macOS toolbar:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 按照Docker安装向导进行操作，完成后，您应该在macOS工具栏上看到一个Docker图标：
- en: '![](assets/3dcb6fe2-630f-41c2-8632-1ab3a3fa1d73.png)Docker icon on macOS toolbar'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3dcb6fe2-630f-41c2-8632-1ab3a3fa1d73.png)macOS工具栏上的Docker图标'
- en: 'If you click on this icon and select **Preferences**, a Docker Preferences
    dialog will be displayed, which allows you to configure various Docker settings. 
    One setting you may want to immediately change is the memory allocated to the
    Docker Engine, which in my case I have increased from the default of 2 GB to 8
    GB:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单击此图标并选择**首选项**，将显示Docker首选项对话框，允许您配置各种Docker设置。您可能希望立即更改的一个设置是分配给Docker Engine的内存，我已将其从默认的2GB增加到8GB：
- en: '![](assets/9f33d629-86b3-4a08-a522-f9956e15e959.png)Increasing memory'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/9f33d629-86b3-4a08-a522-f9956e15e959.png)增加内存'
- en: 'At this point, you should be able to start up a Terminal and run the `docker
    info` command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该能够启动终端并运行`docker info`命令：
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also start a new container using the `docker run` command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`docker run`命令启动新的容器：
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, you must run the `alpine` image, which is based on
    the lightweight Alpine Linux distribution, and run the `echo "Hello World"` command.
    The `-it` flags specify that you need to run the container in an interactive terminal
    environment, which allows you to see standard output and also interact with the
    container via a console.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，您必须运行基于轻量级Alpine Linux发行版的`alpine`镜像，并运行`echo "Hello World"`命令。`-it`标志指定您需要在交互式终端环境中运行容器，这允许您查看标准输出并通过控制台与容器进行交互。
- en: Once the container exits, you can use the `docker ps` command to show running
    containers, and append the `-a` flag to show both running and stopped containers. 
    Finally, you can use the `docker rm` command to remove a stopped container.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器退出，您可以使用`docker ps`命令显示正在运行的容器，并附加`-a`标志以显示正在运行和已停止的容器。最后，您可以使用`docker rm`命令删除已停止的容器。
- en: Installing other tools
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装其他工具
- en: 'As discussed earlier in this section, we also require a number of other tools to
    help automate a number of build, test, and deployment tasks. On macOS, some of
    these tools are already included, and are outlined as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节前面讨论的那样，我们还需要一些其他工具来帮助自动化一些构建、测试和部署任务。在macOS上，其中一些工具已经包含在内，如下所述：
- en: '**Docker Compose**: This is already included when you install Docker for Mac.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Compose**：在安装Docker for Mac时已经包含在内。'
- en: '**Git**: When you install the Homebrew package manager (we will discuss Homebrew
    shortly), XCode command-line utilities are installed, which include Git.  If you
    use another package manager, you may need to install Git using your package manager.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git**：当您安装Homebrew软件包管理器（我们将很快讨论Homebrew）时，会安装XCode命令行实用程序，其中包括Git。如果您使用另一个软件包管理器，可能需要使用该软件包管理器安装Git。'
- en: '**GNU Make 3.82 or higher**: macOS includes Make 3.81, which doesn''t quite
    meet the requirements of version 3.82, therefore you need to install GNU Make
    using a third-party package manager such as Homebrew.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GNU Make 3.82或更高版本**：macOS包括Make 3.81，不完全满足3.82版本的要求，因此您需要使用Homebrew等第三方软件包管理器安装GNU
    Make。'
- en: '**curl**: This is included by default with macOS, and therefore requires no
    installation.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**curl**：这在macOS中默认包含，因此无需安装。'
- en: '**jq and** **tree**: These are not included by default in macOS, and therefore
    they need to be installed via a third-party package manager such as Homebrew.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**jq和tree**：这些在macOS中默认情况下不包括在内，因此需要通过Homebrew等第三方软件包管理器安装。'
- en: '**Python interpreter**: macOS includes a system installation of Python that
    you can use to run Python applications, however I recommend leaving the system
    Python installation alone and instead install Python using the Homebrew package
    manager ([https://docs.brew.sh/Homebrew-and-Python](https://docs.brew.sh/Homebrew-and-Python)).'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python解释器**：macOS包括系统安装的Python，您可以使用它来运行Python应用程序，但我建议保持系统Python安装不变，而是使用Homebrew软件包管理器安装Python（[https://docs.brew.sh/Homebrew-and-Python](https://docs.brew.sh/Homebrew-and-Python)）。'
- en: '**pip**: The system install of Python does not include the popular PIP Python
    package manager, hence you must install this separately if using the system Python
    interpreter.  If you choose to install Python using Homebrew, this will include
    PIP.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pip**：系统安装的Python不包括流行的PIP Python软件包管理器，因此如果使用系统Python解释器，必须单独安装此软件。如果选择使用Homebrew安装Python，这将包括PIP。'
- en: 'The easiest way to install the preceding tools on macOS is to first install
    a third-party package manager called Homebrew.  You can install Homebrew by simply
    browsing to the Homebrew homepage at [https://brew.sh/](https://brew.sh/):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上安装上述工具的最简单方法是首先安装一个名为Homebrew的第三方软件包管理器。您可以通过简单地浏览到Homebrew主页[https://brew.sh/](https://brew.sh/)来安装Homebrew：
- en: '![](assets/18373480-92c4-4163-80c5-87b515bbcd82.png)Installing Homebrew'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/18373480-92c4-4163-80c5-87b515bbcd82.png)安装Homebrew'
- en: 'Simply copy and paste the highlighted command into your terminal prompt, which
    will automatically install the Homebrew package manager.  Once complete, you will
    be able to install each of the previously listed utilities using the `brew` command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将突出显示的命令复制并粘贴到终端提示符中，即可自动安装Homebrew软件包管理器。完成后，您将能够使用`brew`命令安装先前列出的每个实用程序：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You must first install GNU Make using the `--with-default-names` flag, which
    will replace the system version of Make that is installed on macOS.  If you prefer
    to omit this flag, then the GNU version of make will be available via the `gmake`
    command, and the existing system version of make will not be affected.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须首先使用`--with-default-names`标志安装GNU Make，这将替换在macOS上安装的系统版本的Make。如果您喜欢省略此标志，则GNU版本的make将通过`gmake`命令可用，并且现有的系统版本的make不会受到影响。
- en: 'Finally, to install Python using Homebrew, you can run the `brew install python`
    command, which will install Python 3 and also install the PIP package manager. 
    Note that when you use `brew` to install Python 3, the Python interpreter is accessed
    via the `python3` command, while the PIP package manager is accessed via the `pip3`
    command rather than the `pip` command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要使用Homebrew安装Python，您可以运行`brew install python`命令，这将安装Python 3并安装PIP软件包管理器。请注意，当您使用`brew`安装Python
    3时，Python解释器通过`python3`命令访问，而PIP软件包管理器通过`pip3`命令访问，而不是`pip`命令：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On macOS, if you use Python which has been installed via brew or another package
    manager, you should also add the site module `USER_BASE/bin` folder to your local
    path, as this is where PIP will install any applications or libraries that you
    install with the `--user` flag (the AWS CLI is an example of such an application
    that you will install in this way later on in this book):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，如果您使用通过brew或其他软件包管理器安装的Python，还应将站点模块`USER_BASE/bin`文件夹添加到本地路径，因为这是PIP将安装任何使用`--user`标志安装的应用程序或库的位置（AWS
    CLI是您将在本书后面以这种方式安装的应用程序的一个示例）：
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Ensure that you use single quotes in the preceding example, which ensures the
    reference to `$PATH` is not expanded in your shell session and is instead written
    as a literal value to the `.bash_profile` file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在前面的示例中使用单引号，这样可以确保在您的shell会话中不会展开对`$PATH`的引用，而是将其作为文字值写入`.bash_profile`文件。
- en: In the preceding example, you call the site module with the `--user-base` flag,
    which tells you where user binaries will be installed. You can then add the `bin`
    subfolder of this path to your `PATH` variable and append this to the `.bash_profile`
    file in your home directory, which is executed whenever you spawn a new shell,
    ensuring that you will always be able to execute Python applications that have
    been installed with the `--user` flag.  Note that you can use the `source` command
    to process the `.bash_profile` file immediately without having to log out and
    log back in.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您使用`--user-base`标志调用站点模块，该标志告诉您用户二进制文件将安装在何处。然后，您可以将此路径的`bin`子文件夹添加到您的`PATH`变量中，并将其附加到您的主目录中的`.bash_profile`文件中，每当您生成新的shell时都会执行该文件，确保您始终能够执行已使用`--user`标志安装的Python应用程序。请注意，您可以使用`source`命令立即处理`.bash_profile`文件，而无需注销并重新登录。
- en: Setting up a Windows 10 environment
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Windows 10环境
- en: Just like for macOS, if you are running Windows 10, the quickest way to get
    Docker up and running is to install Docker for Windows, which you can read more
    about at [https://docs.docker.com/docker-for-windows/](https://docs.docker.com/docker-for-windows/) and
    download from [https://store.docker.com/editions/community/docker-ce-desktop-windows](https://store.docker.com/editions/community/docker-ce-desktop-windows). 
    Under the hood, Docker for Windows leverages the native Windows hypervisor called
    Hyper-V, creating a virtual machine to run the Docker Engine and installing a
    Docker client for Windows.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对于 macOS 一样，如果您正在运行 Windows 10，最快的方法是安装 Docker for Windows，您可以在[https://docs.docker.com/docker-for-windows/](https://docs.docker.com/docker-for-windows/)上了解更多信息，并从[https://store.docker.com/editions/community/docker-ce-desktop-windows](https://store.docker.com/editions/community/docker-ce-desktop-windows)下载。在幕后，Docker
    for Windows 利用了称为 Hyper-V 的本机 Windows hypervisor，创建了一个虚拟机来运行 Docker 引擎，并为 Windows
    安装了一个 Docker 客户端。
- en: You will first need to create a free Docker Hub account in order to proceed,
    and once you have completed registration and logged in, click the **Get Docker** button
    to download the latest version of Docker for Windows.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要创建一个免费的 Docker Hub 帐户，以便继续进行，一旦完成注册并登录，点击**获取 Docker**按钮下载最新版本的 Docker
    for Windows。
- en: 'Once you have completed the download, start the installation and ensure that
    the Use Windows containers option is NOT selected:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 完成下载后，开始安装并确保未选择使用 Windows 容器选项：
- en: '![](assets/8d52b74c-ecbf-40f2-83b9-24ed7c702b7a.png)Using Linux containers'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Linux 容器
- en: 'The installation will continue and you will be asked to log out of Windows
    to complete the installation. After logging back into Windows, you will be prompted
    to enable Windows Hyper-V and Containers features:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 安装将继续，并要求您注销 Windows 以完成安装。重新登录 Windows 后，您将被提示启用 Windows Hyper-V 和容器功能：
- en: '![](assets/2d4041b2-79a0-4e7f-9d52-e49cee2ee6e4.png)Enabling Hyper-V'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 Hyper-V
- en: 'Your computer will now enable the required Windows features and reboot.  Once
    you have logged back in, open the Docker for Windows application and ensure that
    you select the **Expose daemon on tcp://localhost:2375 without TLS** option:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您的计算机现在将启用所需的 Windows 功能并重新启动。一旦您重新登录，打开 Windows 的 Docker 应用程序，并确保选择**在不使用 TLS
    的情况下在 tcp://localhost:2375 上公开守护程序**选项：
- en: '![](assets/e105ce63-036f-4094-b3e5-4001996c90a5.png)Enabling legacy client
    access to Docker'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 启用对 Docker 的传统客户端访问
- en: This setting must be enabled in order to allow the Windows subsystem for Linux
    to access the Docker Engine.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 必须启用此设置，以便允许 Windows 子系统访问 Docker 引擎。
- en: Installing the Windows subsystem for Linux
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Windows 子系统
- en: Now that you have installed Docker for Windows, you next need to install the
    Windows subsystem for Linux, which provides a Linux environment where you can
    install the Docker client, Docker Compose, and the other tools we will use throughout
    this book.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了 Docker for Windows，接下来需要安装 Windows 子系统，该子系统提供了一个 Linux 环境，您可以在其中安装
    Docker 客户端、Docker Compose 和本书中将使用的其他工具。
- en: If you are using Windows, then throughout this book I am assuming that you are
    using the Windows subsystem for Linux as your shell environment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Windows，那么在本书中我假设您正在使用 Windows 子系统作为您的 shell 环境。
- en: 'To enable the Windows subsystem for Linux, you need to run PowerShell as an
    Administrator (right-click the PowerShell program and select **Run as Administrator**)
    and then run the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 Windows 子系统，您需要以管理员身份运行 PowerShell（右键单击 PowerShell 程序，然后选择**以管理员身份运行**），然后运行以下命令：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After enabling this feature, you will be prompted to reboot your machine. Once
    your machine has rebooted, you then need to install a Linux distribution.  You
    can find links to the various distributions in the article [https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10) 
    – see step 1 in [Install Your Linux Distribution of Choice](https://docs.microsoft.com/en-us/windows/wsl/install-win10#install-your-linux-distribution-of-choice).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此功能后，您将被提示重新启动您的机器。一旦您的机器重新启动，您就需要安装一个Linux发行版。您可以在文章[https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10)中找到各种发行版的链接
    - 参见[安装您选择的Linux发行版](https://docs.microsoft.com/en-us/windows/wsl/install-win10#install-your-linux-distribution-of-choice)中的第1步。
- en: 'For example, the link for Ubuntu is [https://www.microsoft.com/p/ubuntu/9nblggh4msv6](https://www.microsoft.com/p/ubuntu/9nblggh4msv6) and
    if you click on **Get the app**, you will be directed to the Microsoft Store app
    on your local machine and you can download the application for free:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Ubuntu的链接是[https://www.microsoft.com/p/ubuntu/9nblggh4msv6](https://www.microsoft.com/p/ubuntu/9nblggh4msv6)，如果您点击**获取应用程序**，您将被引导到本地机器上的Microsoft
    Store应用程序，并且您可以免费下载该应用程序：
- en: '![](assets/aeb12bd3-b610-437f-8111-a1917975729a.png)Ubuntu distribution for
    Windows'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/aeb12bd3-b610-437f-8111-a1917975729a.png)为Windows安装Ubuntu发行版'
- en: 'Once the download is complete, click on the **Launch** button, which will run
    the Ubuntu installer and install Ubuntu on the Windows subsystem for Linux.  You
    will be prompted to enter a username and password, and assuming you are using
    the Ubuntu distribution, you can run the `lsb_release -a` command to show the
    specific version of Ubuntu that was installed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，点击**启动**按钮，这将运行Ubuntu安装程序并在Windows子系统中安装Ubuntu。您将被提示输入用户名和密码，假设您正在使用Ubuntu发行版，您可以运行`lsb_release
    -a`命令来显示安装的Ubuntu的具体版本：
- en: '![](assets/5dd13091-46c1-4919-8881-e44af32e2e8b.png)Installing the Ubuntu distribution
    for WindowsThe information that has been provided is for recent versions of Windows
    10.  For older versions of Windows 10, you may need to follow the instructions
    at [https://docs.microsoft.com/en-us/windows/wsl/install-win10#for-anniversary-update-and-creators-update-install-using-lxrun](https://docs.microsoft.com/en-us/windows/wsl/install-win10#for-anniversary-update-and-creators-update-install-using-lxrun).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5dd13091-46c1-4919-8881-e44af32e2e8b.png)为Windows安装Ubuntu发行版所提供的信息适用于Windows
    10的最新版本。对于较旧的Windows 10版本，您可能需要按照[https://docs.microsoft.com/en-us/windows/wsl/install-win10#for-anniversary-update-and-creators-update-install-using-lxrun](https://docs.microsoft.com/en-us/windows/wsl/install-win10#for-anniversary-update-and-creators-update-install-using-lxrun)中的说明进行操作。'
- en: 'Note that the Windows file system is mounted into the Linux subsystem for Windows
    under `/mnt/c` (where `c` corresponds to the Windows C: drive), so in order to
    use a text editor installed on Windows to modify files that you can access in
    the Linux subsystem, you may want to change your home directory to your Windows
    home folders under `/mnt/c/Users/<user name>` as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Windows文件系统被挂载到Linux子系统下的`/mnt/c`目录（其中`c`对应于Windows C:驱动器），因此为了使用安装在Windows上的文本编辑器来修改您可以在Linux子系统中访问的文件，您可能需要将您的主目录更改为您的Windows主目录，即`/mnt/c/Users/<用户名>`，如下所示：
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that the Linux subsystem will exit immediately after entering the preceding
    command.  If you open the Linux subsystem again (click on the **Start** button
    and type **Ubuntu**), your home directory should now be your Windows home directory:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在输入上述命令后，Linux子系统将立即退出。如果您再次打开Linux子系统（点击**开始**按钮并输入**Ubuntu**），您的主目录现在应该是您的Windows主目录：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Installing Docker in the Windows subsystem for Linux
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows子系统中安装Docker for Linux
- en: Now that you have the Windows subsystem for Linux installed, you need to install
    the Docker client, Docker Compose, and other supporting tools in your distribution.
    In this section, I will assume that you are using the Ubuntu Xenial (16.04) distribution.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了Windows子系统，您需要在您的发行版中安装Docker客户端、Docker Compose和其他支持工具。在本节中，我将假设您正在使用Ubuntu
    Xenial（16.04）发行版。
- en: 'To install Docker, follow the instructions at [https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-ce](https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-ce)
    to install Docker:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker，请按照[https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-ce](https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-ce)上的说明安装Docker：
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, you must follow the various instructions to add the
    Docker CE repository to Ubuntu.  After installation is completed, you must execute
    the `docker --version` command to check the installed version, and then the `docker
    info` command to connect to the Docker Engine. Notice that this fails, as the
    Windows subsystem for Linux is a user space component that does not include the
    necessary kernel components required to run a Docker Engine.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，您必须按照各种说明将Docker CE存储库添加到Ubuntu中。安装完成后，您必须执行`docker --version`命令来检查安装的版本，然后执行`docker
    info`命令来连接到Docker引擎。请注意，这会失败，因为Windows子系统是一个用户空间组件，不包括运行Docker引擎所需的必要内核组件。
- en: The Windows subsystem for Linux is not a virtual machine technology and instead
    relies on kernel emulation features provided by the Windows kernel that makes
    the underlying Windows kernel appear like a Linux kernel.  This kernel emulation
    mode of operation does not support the various system calls that support containers,
    and hence cannot run the Docker Engine.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Windows子系统不是一种虚拟机技术，而是依赖于Windows内核提供的内核仿真功能，使底层的Windows内核看起来像Linux内核。这种内核仿真模式不支持支持容器的各种系统调用，因此无法运行Docker引擎。
- en: 'To enable the Windows subsystem for Linux to connect to the Docker Engine that
    was installed by Docker for Windows, you need to set the `DOCKER_HOST` environment
    variable to `localhost:2375`, which will configure the Docker client to connect
    to TCP port `2375` rather than attempt to connect to the default `/var/run/docker.sock`
    socket file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使Windows子系统能够连接到由Docker for Windows安装的Docker引擎，您需要将`DOCKER_HOST`环境变量设置为`localhost:2375`，这将配置Docker客户端连接到TCP端口`2375`，而不是尝试连接到默认的`/var/run/docker.sock`套接字文件：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because you enabled the **Expose daemon on tcp://localhost:2375 without TLS** option
    earlier when you installed Docker and Windows to expose local ports to the Windows
    subsystem for Linux, the Docker client can now communicate with the Docker Engine
    running in a separate Hyper-V virtual machine that was installed by Docker for
    Windows.  You also add the `export DOCKER_HOST` command to the `.bash_profile`
    file in the home directory of your user, which is executed every time you spawn
    a new shell. This ensures that your Docker client will always attempt to connect
    to the correct Docker Engine.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您在安装Docker和Windows时之前启用了**在tcp://localhost:2375上无需TLS暴露守护程序**选项，以将本地端口暴露给Windows子系统，Docker客户端现在可以与在由Docker
    for Windows安装的单独的Hyper-V虚拟机中运行的Docker引擎进行通信。您还将`export DOCKER_HOST`命令添加到用户的主目录中的`.bash_profile`文件中，每次生成新的shell时都会执行该命令。这确保您的Docker客户端将始终尝试连接到正确的Docker引擎。
- en: Installing other tools in the Windows subsystem for Linux
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows子系统中安装其他工具
- en: 'At this point, you need to install the following supporting tools that we will
    be using throughout this book in the Windows Subsystem for Linux:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您需要在Windows子系统中安装以下支持工具，我们将在本书中一直使用：
- en: Python
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: pip package manager
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pip软件包管理器
- en: Docker Compose
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Git
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: GNU Make
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Make
- en: jq
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jq
- en: Build essentials and Python development libraries (required to build dependencies
    of the sample application)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基本工具和Python开发库（用于构建示例应用程序的依赖项）
- en: 'You just need to follow the normal Linux distribution procedures for installing
    each of the preceding components.  The Ubuntu 16.04 Windows subsystem for Linux
    distribution already includes Python 3, so you can run the following commands
    to install the pip package manager, and also set up your environment to be able
    to locate Python packages that you can install as user packages with the `--user`
    flag:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 只需按照正常的Linux发行版安装程序来安装上述每个组件。Ubuntu 16.04的Linux子系统发行版已经包含了Python 3，因此您可以运行以下命令来安装pip软件包管理器，并设置您的环境以便能够定位可以使用`--user`标志安装的Python软件包：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, you can install Docker Compose by using the `pip install docker-compose
    --user` command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`pip install docker-compose --user`命令来安装Docker Compose：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, you can install Git, GNU Make, jq, tree, build essentials, and Python3
    development libraries using the `apt-get install` command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用`apt-get install`命令安装Git、GNU Make、jq、tree、构建基本工具和Python3开发库：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Setting up a Linux environment
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Linux环境
- en: 'Docker is natively supported on Linux, meaning that you can install and run
    the Docker Engine in your local operating system without needing to set up a virtual
    machine.  Docker officially supports the following Linux distributions ([https://docs.docker.com/install/](https://docs.docker.com/install/))
    for installing and running Docker CE:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Docker在Linux上有原生支持，这意味着您可以在本地操作系统中安装和运行Docker引擎，而无需设置虚拟机。Docker官方支持以下Linux发行版（[https://docs.docker.com/install/](https://docs.docker.com/install/)）来安装和运行Docker
    CE：
- en: CentOS: See [https://docs.docker.com/install/linux/docker-ce/centos/](https://docs.docker.com/install/linux/docker-ce/centos/)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CentOS：参见[https://docs.docker.com/install/linux/docker-ce/centos/](https://docs.docker.com/install/linux/docker-ce/centos/)
- en: 'Debian: See [https://docs.docker.com/install/linux/docker-ce/debian/](https://docs.docker.com/install/linux/docker-ce/debian/)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Debian：参见[https://docs.docker.com/install/linux/docker-ce/debian/](https://docs.docker.com/install/linux/docker-ce/debian/)
- en: 'Fedora: See [https://docs.docker.com/install/linux/docker-ce/fedora/](https://docs.docker.com/install/linux/docker-ce/fedora/)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fedora：参见[https://docs.docker.com/install/linux/docker-ce/fedora/](https://docs.docker.com/install/linux/docker-ce/fedora/)
- en: 'Ubuntu: See [https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu：参见[https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)
- en: 'Once you have installed Docker, you can install the various tools required
    to complete this book as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完Docker后，您可以按照以下步骤安装完成本书所需的各种工具：
- en: '**Docker Compose**: See the Linux tab at [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/). 
    Alternatively, as you require Python to install the AWS CLI tool, you can use
    the `pip` Python package manager to install Docker Compose, as demonstrated earlier
    for Mac and Windows, by running `pip install docker-compose`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Compose**：请参阅[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)上的Linux选项卡。另外，由于您需要Python来安装AWS
    CLI工具，您可以使用`pip` Python软件包管理器来安装Docker Compose，就像之前在Mac和Windows上演示的那样，运行`pip install
    docker-compose`。'
- en: '**Python**, **pip**, **Git**, **GNU Make,** **jq, tree, build essentials, and
    Python3 development libraries**: Use your Linux distribution''s package manager
    (for example, `yum` or `apt`) to install these tools. See the preceding example
    for a demonstration of this when using Ubuntu Xenial.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**，**pip**，**Git**，**GNU Make**，**jq**，**tree**，**构建基本工具**和**Python3开发库**：使用您的Linux发行版的软件包管理器（例如`yum`或`apt`）来安装这些工具。在使用Ubuntu
    Xenial时，可以参考上面的示例演示。'
- en: Installing the sample application
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装示例应用程序
- en: Now that you have set up your local environment to support Docker and the various
    tools required to complete this book, it's time to install the sample application
    for this course.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经设置好了本地环境，支持Docker和完成本书所需的各种工具，是时候为本课程安装示例应用程序了。
- en: The sample application is a simple Todo items web service called **todobackend**
    that provides a REST API that allows you to create, read, update, and delete Todo
    items (for example, *Wash the car* or *Walk the dog*).  This application is a
    Python application based on Django, which is a popular framework for creating
    web applications. You can read more about this at [https://www.djangoproject.com/](https://www.djangoproject.com/). 
    Don't worry if you are not familiar with Python – the sample application is already
    created for you and all you need to do as you read through this book is build
    and test the application, package and publish the application as a Docker image,
    and then deploy your application using the various container management platforms
    discussed in this book.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序是一个名为**todobackend**的简单的待办事项Web服务，提供了一个REST API，允许您创建、读取、更新和删除待办事项（例如*洗车*或*遛狗*）。这个应用程序是一个基于Django的Python应用程序，Django是一个用于创建Web应用程序的流行框架。您可以在[https://www.djangoproject.com/](https://www.djangoproject.com/)上了解更多信息。如果您对Python不熟悉，不用担心
    - 示例应用程序已经为您创建，您在阅读本书时需要做的就是构建和测试应用程序，将应用程序打包和发布为Docker镜像，然后使用本书中讨论的各种容器管理平台部署您的应用程序。
- en: Forking the sample application
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Forking the sample application
- en: 'To install the sample application, you will need to *fork* the application
    from GitHub (we will discuss what this means shortly), which requires you to have
    an active GitHub account.  If you already have a GitHub account, you can skip
    this step, however if you don''t have an account, you can sign up for a free account
    at [https://github.com](https://github.com):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装示例应用程序，您需要从GitHub上*fork*该应用程序（我们将很快讨论这意味着什么），这需要您拥有一个活跃的GitHub账户。如果您已经有GitHub账户，可以跳过这一步，但是如果您没有账户，可以在[https://github.com](https://github.com)免费注册一个账户：
- en: '![](assets/1101fbe8-9871-4951-b093-dd03f0c849b0.png)Signing up for GitHub'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/1101fbe8-9871-4951-b093-dd03f0c849b0.png)Signing up for GitHub'
- en: Once you have an active GitHub account, you can access the sample application
    repository at [https://github.com/docker-in-aws/todobackend](https://github.com/docker-in-aws/todobackend). 
    Rather than clone the repository, a better approach is to *fork* the repository,
    which means that a new repository will be created in your own GitHub account that
    is linked to the original `todobackend` repository (hence the term *fork*).  Forking
    is a popular pattern in the open source community, and allows you to make your
    own independent changes to the forked repository.  This is particularly useful
    for this book, as you will be making your own changes to the `todobackend` repository,
    adding a local Docker workflow to build, test, and publish the sample application
    as a Docker image, and other changes as you progress throughout this book.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您拥有一个活跃的GitHub账户，您就可以访问示例应用程序存储库[https://github.com/docker-in-aws/todobackend](https://github.com/docker-in-aws/todobackend)。与其克隆存储库，一个更好的方法是*fork*存储库，这意味着将在您自己的GitHub账户中创建一个新的存储库，该存储库与原始的`todobackend`存储库链接在一起（因此称为*fork*）。*Fork*是开源社区中的一种流行模式，允许您对*fork*存储库进行自己独立的更改。对于本书来说，这是特别有用的，因为您将对`todobackend`存储库进行自己的更改，添加一个本地Docker工作流来构建、测试和发布示例应用程序作为Docker镜像，以及在本书的进程中进行其他更改。
- en: 'To fork the repository, click on the fork button that is located in the top
    right hand corner:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要*fork*存储库，请点击右上角的*fork*按钮：
- en: '![](assets/c65f46fc-103c-4f1b-85dd-f0f4b55ad381.png)Forking the todobackend
    repository'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c65f46fc-103c-4f1b-85dd-f0f4b55ad381.png)Forking the todobackend
    repository'
- en: 'A few seconds a after clicking the fork button, a new repository should be
    created with the name `<your-github-username>/todobackend`.  At this point, you
    can now clone your fork of the repository by clicking on the Clone or download
    button.  If you have just set up a new account, choose the Clone with HTTPS option
    and copy the URL that''s presented:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 点击分叉按钮几秒钟后，将创建一个名为`<your-github-username>/todobackend`的新存储库。此时，您可以通过单击克隆或下载按钮来克隆存储库的分支。如果您刚刚设置了一个新帐户，请选择使用HTTPS克隆选项并复制所呈现的URL：
- en: '![](assets/3038ca0d-2f98-4193-88d2-522a8ec14a5c.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3038ca0d-2f98-4193-88d2-522a8ec14a5c.png)'
- en: Getting the Git URL for the todobackend repository
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 获取todobackend存储库的Git URL
- en: 'Open a new terminal and run the `git clone <repository-url>` command, where
    `<repository-url>` is the URL you copied in the preceding example, and then go into
    the newly created `todobackend` folder:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端并运行`git clone <repository-url>`命令，其中`<repository-url>`是您在前面示例中复制的URL，然后进入新创建的`todobackend`文件夹：
- en: '[PRE13]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you work through this chapter, I encourage you to commit any changes you
    make frequently, along with descriptive messages that clearly identify the changes
    you make.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章时，我鼓励您经常提交您所做的任何更改，以及清晰标识所做更改的描述性消息。
- en: The sample repository includes a branch called `final`, which represents the
    final state of the repository after completing all chapters in this took.  You
    can use this as a reference point if you run into any issues by running the command
    `git checkout final`.  You can switch back to the master branch by running `git
    checkout master`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 示例存储库包括一个名为`final`的分支，该分支代表完成本书中所有章节后存储库的最终状态。如果遇到任何问题，您可以使用`git checkout final`命令将其作为参考点。您可以通过运行`git
    checkout master`命令切换回主分支。
- en: 'If you are unfamiliar with Git, you can refer to any of the numerous tutorials
    online (for example, [https://www.atlassian.com/git/tutorials](https://www.atlassian.com/git/tutorials)),
    however in general you will need to perform the following commands when committing
    a change:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Git不熟悉，可以参考在线的众多教程（例如，[https://www.atlassian.com/git/tutorials](https://www.atlassian.com/git/tutorials)），但通常在提交更改时，您需要执行以下命令：
- en: '[PRE15]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You should always check frequently that you have the most up-to-date version
    of the repository by running the `git pull` command, as this avoids messy automatic
    merges and push failures, particularly when you are working with other people
    that may be collaborating on your project.  Next, you can use the `git diff` command
    to show, at a content level, any changes you have made to existing files, while
    the `git status` command shows, at a file level, changes to existing files and
    also identifies any new files that you may have added to the repository.  The
    `git add -A` command adds all new files to the repository, and the `git commit
    -a -m "<message>"` command commits all changes (including any files you have added
    with `git add -A`) with the specified message.  Finally, you can push your changes
    using the `git push` command – the first time you push, you must specify the remote
    branch at the origin using the `git push -u origin <branch>` command – after which
    you can just use the shorter `git push` variant to push your changes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该经常检查您是否拥有存储库的最新版本，方法是运行`git pull`命令，这样可以避免混乱的自动合并和推送失败，特别是当您与其他人一起合作时。接下来，您可以使用`git
    diff`命令显示您对现有文件所做的任何更改，而`git status`命令则显示对现有文件的文件级更改，并标识您可能已添加到存储库的任何新文件。`git
    add -A`命令将所有新文件添加到存储库，而`git commit -a -m "<message>"`命令将提交所有更改（包括您使用`git add -A`添加的任何文件）并附带指定的消息。最后，您可以使用`git
    push`命令推送您的更改-第一次推送时，您必须使用`git push -u origin <branch>`命令指定远程分支的原点-之后您可以只使用更短的`git
    push`变体来推送您的更改。
- en: A common mistake is to forget to add new files to your Git repository, which
    may not be apparent until you clone the repository to a different machine.  Always
    ensure that you run the `git status` command to identify any new files that are
    not currently being tracked before committing your changes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是忘记将新文件添加到您的Git存储库中，这可能直到您将存储库克隆到另一台机器上才会显现出来。在提交更改之前，始终确保运行`git status`命令以识别任何尚未被跟踪的新文件。
- en: Running the sample application locally
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行示例应用程序
- en: Now that you have downloaded the source code for the sample application locally,
    you can now build and run the application locally. When you are packaging an application
    into a Docker image, you need to understand at a detailed level how to build and
    run your application, so running the application locally is the first step in
    the journey of being able to build a container for your application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经在本地下载了示例应用程序的源代码，您现在可以构建和在本地运行该应用程序。当您将应用程序打包成Docker镜像时，您需要详细了解如何构建和运行您的应用程序，因此在本地运行应用程序是能够为您的应用程序构建容器的旅程的第一步。
- en: Installing application dependencies
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装应用程序依赖项
- en: 'To run the application, you need to first install any dependencies that the
    application requires. The sample application includes a file called `requirements.txt`
    in the `src` folder, which lists all required Python packages that must be installed
    for the application to run:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行该应用程序，您需要首先安装应用程序所需的任何依赖项。示例应用程序包括一个名为`requirements.txt`的文件，位于`src`文件夹中，其中列出了必须安装的所有必需的Python软件包，以便应用程序运行：
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To install these requirements, ensure you have changed to the `src` folder
    and configure the PIP package manager to read the requirements file using the
    `-r` flag.  Note that the best practice for day to day development is to install
    your application dependencies in a virtual environment (see [https://packaging.python.org/guides/installing-using-pip-and-virtualenv/](https://packaging.python.org/guides/installing-using-pip-and-virtualenv/))
    however given we are installing the application mainly for demonstration purposes,
    I won''t be taking this approach here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这些要求，请确保您已更改到`src`文件夹，并配置PIP软件包管理器以使用`-r`标志读取要求文件。请注意，日常开发的最佳实践是在虚拟环境中安装应用程序依赖项（请参阅[https://packaging.python.org/guides/installing-using-pip-and-virtualenv/](https://packaging.python.org/guides/installing-using-pip-and-virtualenv/)），但是考虑到我们主要是为了演示目的安装应用程序，我不会采取这种方法：
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Over time, the specific versions of each dependency may change to ensure that
    the sample application continues to work as expected.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，每个依赖项的特定版本可能会更改，以确保示例应用程序继续按预期工作。
- en: Running database migrations
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行数据库迁移
- en: With the application dependencies installed, you can run the `python3 manage.py`
    command to perform various Django management functions, such as running tests,
    generating static web content, running database migrations, and running a local
    instance of your web application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了应用程序依赖项后，您可以运行`python3 manage.py`命令来执行各种Django管理功能，例如运行测试、生成静态网页内容、运行数据库迁移以及运行您的Web应用程序的本地实例。
- en: 'In a local development context, you first need to run database migrations,
    which means your local database will be initialized with an appropriate database
    schema, as configured by your application. By default, Django uses the lightweight
    *SQLite* database that''s included with Python, which is suitable for development
    purposes and requires no setup to get up and running. Therefore, you simply run
    the `python3 manage.py migrate` command, which will run all database migrations
    that are configured in the application automatically for you:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发环境中，您首先需要运行数据库迁移，这意味着您的本地数据库将根据应用程序配置的适当数据库模式进行初始化。默认情况下，Django使用Python附带的轻量级*SQLite*数据库，适用于开发目的，并且无需设置即可运行。因此，您只需运行`python3
    manage.py migrate`命令，它将自动为您运行应用程序中配置的所有数据库迁移：
- en: '[PRE18]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you run Django migrations, Django will automatically detect if an existing
    schema is in place, and create a new schema if one does not exist (this is the
    case in the preceding example). If you run the migrations again, notice that Django
    detects that an up-to-date schema is already in place, and therefore nothing is
    applied:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行Django迁移时，Django将自动检测是否存在现有模式，并在不存在模式时创建新模式（在前面的示例中是这种情况）。如果再次运行迁移，请注意Django检测到已经存在最新模式，因此不会应用任何内容：
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Running the local development web server
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行本地开发Web服务器
- en: 'With the local SQLite database now in place, you can run your application by
    executing the `python3 manage.py runserver` command, which starts a local development
    web server on port 8000:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在本地SQLite数据库已经就位，您可以通过执行`python3 manage.py runserver`命令来运行应用程序，该命令将在8000端口上启动本地开发Web服务器：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you open a browser to `http://localhost:8000/`, you should see a web page
    titled **Django REST framework**:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开`http://localhost:8000/`，您应该会看到一个名为**Django REST framework**的网页：
- en: '![](assets/a8d47b6d-4d23-462e-88ec-f9291951296a.png)The todobackend application'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a8d47b6d-4d23-462e-88ec-f9291951296a.png)todobackend应用程序'
- en: 'This page is the root of the application, and you can see that the Django REST
    framework provides a graphical interface for navigating the API when you use a
    browser.  If you use the `curl` command instead of a browser, notice that Django
    detects a simple HTTP client and just returns a JSON response:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面是应用程序的根，您可以看到Django REST框架为使用浏览器时导航API提供了图形界面。如果您使用`curl`命令而不是浏览器，请注意Django检测到一个简单的HTTP客户端，并且只返回JSON响应：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you click on the hypermedia link for the todos item (`http://localhost:8000/todos`),
    you will be presented with a list of Todo items, which is currently empty:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您单击todos项目的超媒体链接（`http://localhost:8000/todos`），您将看到一个当前为空的待办事项列表：
- en: '![](assets/7c7bb14a-91e3-484e-85d6-83e9d89a6767.png)Todo Item List'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/7c7bb14a-91e3-484e-85d6-83e9d89a6767.png)待办事项列表'
- en: 'Notice that you can create a new Todo item with a title and order using the
    web interface, which will populate the list of Todo items once you click on the
    POST button:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以使用Web界面创建具有标题和顺序的新待办事项，一旦单击POST按钮，它将填充待办事项列表：
- en: '![](assets/68f0d7ba-a263-4044-9cd5-7582841aa551.png)Creating a Todo Item'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/68f0d7ba-a263-4044-9cd5-7582841aa551.png)创建待办事项'
- en: 'Of course, you also can use the command line and the `curl` command to create
    new Todo items, list all Todo items, and update Todo items:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以使用命令行和`curl`命令来创建新的待办事项，列出所有待办事项并更新待办事项：
- en: '[PRE22]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, you first create a new Todo item using the `HTTP POST`
    method, and then verify that the Todos list now contains two Todo items, piping
    the output of the `curl` command to the `jq` utility you installed previously
    to format the returned items.  Finally, you use the `HTTP PATCH` method to make
    a partial update to the Todo item, marking the item as completed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您首先使用`HTTP POST`方法创建一个新的待办事项，然后验证Todos列表现在包含两个待办事项，将`curl`命令的输出传输到之前安装的`jq`实用程序中以格式化返回的项目。最后，您使用`HTTP
    PATCH`方法对待办事项进行部分更新，将该项目标记为已完成。
- en: All of the Todo items you created and modified will be persisted in the application
    database, which in this case is a SQLite database running on your development
    machine.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建和修改的所有待办事项都将保存在应用程序数据库中，在这种情况下，这是一个运行在您的开发机器上的SQLite数据库。
- en: Testing the sample application locally
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地测试示例应用程序
- en: Now that you have had a walkthrough of the sample application, let's take a
    look at how you can run tests locally to verify that the application is functioning
    as expected.  The todobackend application includes a small set of tests for Todo
    items that are located in the `src/todo/tests.py` file.  Understanding how these
    tests are written is outside the scope of this book, however knowing how to run
    these tests is critical in being able to test, build, and ultimately package the
    application into a Docker image.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经浏览了示例应用程序，让我们看看如何在本地运行测试以验证应用程序是否按预期运行。todobackend应用程序包括一小组待办事项的测试，这些测试位于`src/todo/tests.py`文件中。了解这些测试的编写方式超出了本书的范围，但是知道如何运行这些测试对于能够测试、构建和最终将应用程序打包成Docker镜像至关重要。
- en: 'When testing your application, it is very common to have additional dependencies
    that are specific to application testing, and are not required if you are building
    your application to run in production.  This sample application defines test dependencies
    in a file called `src/requirements_test.txt`, which imports all of the core application
    dependencies in `src/requirements.txt` and adds additional test-specific dependencies:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试应用程序时，很常见的是有额外的依赖项，这些依赖项是特定于应用程序测试的，如果你正在构建应用程序以在生产环境中运行，则不需要这些依赖项。这个示例应用程序在一个名为`src/requirements_test.txt`的文件中定义了测试依赖项，该文件导入了`src/requirements.txt`中的所有核心应用程序依赖项，并添加了额外的特定于测试的依赖项：
- en: '[PRE23]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To install these requirements, you need to the run the PIP package manager,
    referencing the `requirements_test.txt` file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这些依赖项，您需要运行PIP软件包管理器，引用`requirements_test.txt`文件：
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can now run tests for the sample application by running the `python3 manage.py
    test` command, passing in the `--settings` flag, which allows you specify a custom
    settings configuration. In the sample application, there are additional test settings
    which are defined in the `src/todobackend/settings_test.py` file that extend the
    default settings included in `src/todobackend/settings.py`, which add testing
    enhancements such as specs style formatting and code coverage statistics:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过运行`python3 manage.py test`命令来运行示例应用程序的测试，传入`--settings`标志，这允许您指定自定义设置配置。在示例应用程序中，有额外的测试设置，这些设置在`src/todobackend/settings_test.py`文件中定义，扩展了`src/todobackend/settings.py`中包含的默认设置，增加了测试增强功能，如规范样式格式和代码覆盖统计：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that Django test runner scans the various folders in the repository for
    tests, creates a test database, and then runs each test.  After all tests are
    complete, the test runner automatically destroys the test database, so you don't
    have to perform any manual setup or cleanup tasks.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Django测试运行器会扫描存储库中的各个文件夹以寻找测试，创建一个测试数据库，然后运行每个测试。在所有测试完成后，测试运行器会自动销毁测试数据库，因此您无需执行任何手动设置或清理任务。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were introduced to Docker and containers, and learned about
    the history of containers and how Docker has risen to become one of most popular
    solutions for testing, building, deploying, and running your container workloads. 
    You learned about the basic architecture of Docker, which includes the Docker
    client, Docker Engine, and Docker registry, and we introduced the various types
    of objects and resources that you will work with when using Docker, which include
    Docker images, volumes, networks, services, and, of course, Docker containers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Docker和容器，并了解了容器的历史以及Docker如何成为最受欢迎的解决方案之一，用于测试、构建、部署和运行容器工作负载。您了解了Docker的基本架构，其中包括Docker客户端、Docker引擎和Docker注册表，并介绍了在使用Docker时将使用的各种类型的对象和资源，包括Docker镜像、卷、网络、服务，当然还有Docker容器。
- en: We also discussed the wide array of options you have to run your Docker applications
    in AWS, which include the Elastic Container Service, Fargate, Elastic Kubernetes
    Service, Elastic Beanstalk, and running your own Docker platforms, such as Docker
    Swarm.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了在AWS中运行Docker应用程序的各种选项，包括弹性容器服务、Fargate、弹性Kubernetes服务、弹性Beanstalk，以及运行自己的Docker平台，如Docker
    Swarm。
- en: You then installed Docker in your local environment, which is supported natively
    on Linux and requires a virtual machine on macOS and Windows platforms.  Docker
    for Mac and Docker for Windows automatically installs and configures a virtual
    machine for you, making it easier than ever to get up and running with Docker
    on these platforms.  You also learned how to integrate the Windows subsystem for
    Linux with Docker for Windows, which will allow you to support the *nix-based
    tooling that we will use throughout this book.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您在本地环境中安装了Docker，它在Linux上得到原生支持，并且在macOS和Windows平台上需要虚拟机。Docker for Mac和Docker
    for Windows会自动为您安装和配置虚拟机，使得在这些平台上更容易地开始并运行Docker。您还学习了如何将Windows子系统与Docker for
    Windows集成，这将允许您支持本书中将使用的基于*nix的工具。
- en: Finally, you set up a GitHub account, forked the sample application repository
    to your account, and cloned the repository to your local environment.  You then
    learned how to install the sample application dependencies, how to run a local
    development server,  how to run database migrations to ensure that the application
    database schema and tables are in place, and how to run unit tests to ensure that
    the application is functioning as expected.  All of these tasks are important
    to understand before you can expect to be able to test, build, and publish your
    applications as Docker images, which will be the focus of the next chapter, where
    you will create a complete local Docker workflow to automate the process of creating
    production-ready Docker images for your application.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您设置了GitHub账户，将示例应用程序存储库fork到您的账户，并将存储库克隆到您的本地环境。然后，您学习了如何安装示例应用程序的依赖项，如何运行本地开发服务器，如何运行数据库迁移以确保应用程序数据库架构和表位于正确位置，以及如何运行单元测试以确保应用程序按预期运行。在您能够测试、构建和发布应用程序作为Docker镜像之前，理解所有这些任务是很重要的。这将是下一章的重点，您将在其中创建一个完整的本地Docker工作流程，自动化创建适用于生产的Docker镜像的过程。
- en: Questions
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'True/false: The Docker client communicates with the Docker Engine using named
    pipes.'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确/错误：Docker客户端使用命名管道与Docker引擎通信。
- en: 'True/false: The Docker Engine runs natively on macOS.'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确/错误：Docker引擎在macOS上原生运行。
- en: 'True/false: Docker images are published to the Docker store for download.'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确/错误：Docker镜像会发布到Docker商店供下载。
- en: You install the Windows subsystem for Linux and install a Docker client.  Your
    Docker client cannot communicate with your Docker for Windows installation.  How
    can you resolve this?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你安装了Windows子系统用于Linux，并安装了Docker客户端。你的Docker客户端无法与Windows上的Docker通信。你该如何解决这个问题？
- en: 'True/false: Volumes, networks, containers, images, and services are all entities
    that you can work with using Docker.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：卷、网络、容器、镜像和服务都是您可以使用Docker处理的实体。
- en: 'You install Docker Compose by running the `pip install docker-compose --user` command
    flag, however you receive a message stating **docker-compose: not found** when
    attempting to run the program. How can you resolve this?'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '你通过运行`pip install docker-compose --user`命令标志来安装Docker Compose，但是当尝试运行程序时收到了**docker-compose:
    not found**的消息。你该如何解决这个问题？'
- en: Further reading
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看以下链接，了解本章涵盖的主题的更多信息：
- en: Docker Overview: [https://docs.docker.com/engine/docker-overview/](https://docs.docker.com/engine/docker-overview/)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker概述：[https://docs.docker.com/engine/docker-overview/](https://docs.docker.com/engine/docker-overview/)
- en: Docker Getting Started: [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker入门：[https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)
- en: Docker for Mac Install Instructions: [https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/)
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac上的Docker安装说明：[https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/)
- en: Docker for Windows Install Instructions: [https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows上的Docker安装说明：[https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)
- en: Docker for Ubuntu Install Instructions: [https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu上的Docker安装说明：[https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)
- en: Docker for Debian Install Instructions: [https://docs.docker.com/install/linux/docker-ce/debian/](https://docs.docker.com/install/linux/docker-ce/debian/)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Debian上的Docker安装说明：[https://docs.docker.com/install/linux/docker-ce/debian/](https://docs.docker.com/install/linux/docker-ce/debian/)
- en: Docker for Centos Install Instructions: [https://docs.docker.com/install/linux/docker-ce/centos/](https://docs.docker.com/install/linux/docker-ce/centos/)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Centos上的Docker安装说明：[https://docs.docker.com/install/linux/docker-ce/centos/](https://docs.docker.com/install/linux/docker-ce/centos/)
- en: Docker for Fedora Install Instructions: [https://docs.docker.com/install/linux/docker-ce/fedora/](https://docs.docker.com/install/linux/docker-ce/fedora/)
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fedora上的Docker安装说明：[https://docs.docker.com/install/linux/docker-ce/fedora/](https://docs.docker.com/install/linux/docker-ce/fedora/)
- en: Windows Subsystem for Linux Install Instructions: [https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux子系统的Windows安装说明：[https://docs.microsoft.com/en-us/windows/wsl/install-win10](https://docs.microsoft.com/en-us/windows/wsl/install-win10)
- en: Homebrew Package Manager for macOS: [https://brew.sh/](https://brew.sh/)
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS的Homebrew软件包管理器：[https://brew.sh/](https://brew.sh/)
- en: PIP Package Manager User Installs: [https://pip.pypa.io/en/stable/user_guide/#user-installs](https://pip.pypa.io/en/stable/user_guide/#user-installs)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PIP软件包管理器用户安装：[https://pip.pypa.io/en/stable/user_guide/#user-installs](https://pip.pypa.io/en/stable/user_guide/#user-installs)
- en: Git User Manual: [https://git-scm.com/docs/user-manual.html](https://git-scm.com/docs/user-manual.html)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git用户手册：[https://git-scm.com/docs/user-manual.html](https://git-scm.com/docs/user-manual.html)
- en: GitHub Guides: [https://guides.github.com/](https://guides.github.com/)
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub指南：[https://guides.github.com/](https://guides.github.com/)
- en: Forking a GitHub Repository: [https://guides.github.com/activities/forking/](https://guides.github.com/activities/forking/)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分叉GitHub存储库：[https://guides.github.com/activities/forking/](https://guides.github.com/activities/forking/)
- en: Django Web Framework: [https://www.djangoproject.com/](https://www.djangoproject.com/)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Django Web Framework: [https://www.djangoproject.com/](https://www.djangoproject.com/)'
- en: Django REST Framework: [http://www.django-rest-framework.org/](http://www.django-rest-framework.org/)
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Django REST Framework: [http://www.django-rest-framework.org/](http://www.django-rest-framework.org/)'
