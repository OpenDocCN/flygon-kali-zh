- en: Building and Deploying a Full Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和部署完整的Web应用程序
- en: Now that we have seen both the server-side and the client-side code for JavaScript,
    we need to focus on another matter entirely; that is, building our code for deployment
    and deploying that code to a server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了JavaScript的服务器端和客户端代码，我们需要专注于另一个完全不同的问题；也就是说，构建我们的代码以进行部署，并将该代码部署到服务器上。
- en: While we have run our servers locally, we have never actually run them in a
    remote environment such as Amazon's AWS or Microsoft's Azure. Deploying today
    is not like it used to be 5 years ago. Before, we could move our application onto
    a server through the **File Transfer Protocol** (**FTP**). Now, even for small
    applications, we use a system of Continuous Deployment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在本地运行了我们的服务器，但我们从未在云环境中运行过，比如亚马逊的AWS或微软的Azure。今天的部署不再像5年前那样。以前，我们可以通过**文件传输协议**（**FTP**）将我们的应用程序移动到服务器上。现在，即使对于小型应用程序，我们也使用持续部署系统。
- en: 'In this chapter, we will explore the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Understanding Rollup
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Rollup
- en: Integrating into CircleCI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成到CircleCI
- en: These topics will allow us to develop almost any application and get it deployed
    in a typical development environment. By the end of this chapter, we will be able
    to implement a typical build-and-deploy environment for a web application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题将使我们能够在典型的开发环境中开发几乎任何应用程序并将其部署。到本章结束时，我们将能够为Web应用程序实现典型的构建和部署环境。
- en: Let's get started.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you''ll need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将需要以下内容：
- en: A machine that can run Node.js
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够运行Node.js的机器
- en: A text editor or IDE, preferably VS Code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文本编辑器或IDE，最好是VS Code
- en: A web browser
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Web浏览器
- en: A user account for GitHub
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub的用户帐户
- en: This chapter's code, which can be found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter12).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter12)找到。
- en: Understanding Rollup
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Rollup
- en: RollupJS is a build tool that allows us to prepare our applications in different
    ways, depending on the environment. There have been many tools before it (Grunt,
    Gulp), many that are competing with it (Webpack, Parcel), and many that will be
    built in the future. We will focus on RollupJS for our specific use case (getting
    our static server application built in [Chapter 9](59d1466a-ef4d-42f8-bc88-f3d364c3d23e.xhtml),
    *Practical Example – Building a Static Server*), but just note that most build
    tools are similar in terms of their architecture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: RollupJS是一个构建工具，它允许我们根据环境的不同方式准备我们的应用程序。在它之前有许多工具（Grunt、Gulp），许多工具正在与它竞争（Webpack、Parcel），并且将来还会有许多工具。我们将专注于RollupJS用于我们的特定用例（在[第9章](59d1466a-ef4d-42f8-bc88-f3d364c3d23e.xhtml)中构建我们的静态服务器应用程序的实际示例），但请注意，大多数构建工具在其架构方面是相似的。
- en: 'What RollupJS gives us is a way to have *hooks* into different parts of the
    build life cycle. Most applications have the following states during a build process:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: RollupJS给我们的是一种在构建生命周期的不同部分具有*钩子*的方式。大多数应用程序在构建过程中具有以下状态：
- en: Build start
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建开始
- en: Dependency injection
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Compilation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译
- en: Post compilation
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译后
- en: Build end
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建结束
- en: Each of these states may go by different names in different build systems, and
    some may even have more than just these (as we will see, RollupJS does), but this
    is the typical build system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态在不同的构建系统中可能有不同的名称，并且有些甚至可能不止这些（正如我们将看到的，RollupJS有），但这是典型的构建系统。
- en: 'In most cases, we will need to do the following things for our JavaScript applications:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们需要为我们的JavaScript应用程序做以下事情：
- en: Bring in any dependencies that our Node/browser side needs
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入我们的Node/browser端需要的任何依赖项
- en: Compile our JavaScript to a single file (if targeting HTTP/1) or compile it
    to an earlier version (if we are targeting wider browser support)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的JavaScript编译为单个文件（如果针对HTTP/1）或将其编译为较早版本（如果我们针对更广泛的浏览器支持）
- en: Compile CSS to a single file, move images around, and so on
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将CSS编译为单个文件，移动图片等
- en: 'In the case of our application, we will make this quite easy. Here, we will
    learn how to do the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序来说，这将非常容易。在这里，我们将学习如何做以下事情：
- en: Build our Node.js code into a single distributable
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的Node.js代码构建成一个单一的可分发文件
- en: Prepare our static assets, such as CSS/images
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备我们的静态资产，如CSS/图片
- en: Add Rollup to our npm build process
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Rollup添加到我们的npm构建流程中
- en: Building our static server into a single distributable
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的静态服务器构建成一个单一的可分发文件
- en: 'To start off, we will need to create a folder that we''re ready to work with.
    To do this, either work in the folder that we worked in [Chapter 9](59d1466a-ef4d-42f8-bc88-f3d364c3d23e.xhtml),
    *Practical Example – Building a Static Server*, or pull down the code from this
    book''s GitHub repository. With this, run the `npm install -g rollup` command.
    This will put the rollup system into our global path so that we can utilize the
    command line if we want to by running the `rollup` command. Next, we are going
    to create a configuration file. To do this, we will add a `rollup.config.js` file
    to the base of our directory (the exact same location as our `package.json` file)
    and add the following code to it:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个我们准备好使用的文件夹。为此，可以在我们在[第9章](59d1466a-ef4d-42f8-bc88-f3d364c3d23e.xhtml)中工作的文件夹中工作，*实际示例-构建静态服务器*，或者从本书的GitHub存储库中拉取代码。然后运行`npm
    install -g rollup`命令。这将把rollup系统放入我们的全局路径，以便我们可以通过运行`rollup`命令来使用命令行。接下来，我们将创建一个配置文件。为此，我们将在我们的目录的基础（与我们的`package.json`文件的确切位置相同）中添加一个`rollup.config.js`文件，并将以下代码添加到其中：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have told Rollup that the starting point of our application is in the `main.js`
    file. Rollup will follow this starting point and run through it to see what it
    depends on. Whatever it depends on, it will try to put it into a single file and
    remove any unwanted dependencies along the way (this is called tree-shaking).
    Once it's done, it will put the file in `dist/build.js`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经告诉Rollup我们应用程序的起点在`main.js`文件中。Rollup将遵循这个起点并运行它以查看它依赖于什么。它依赖于什么，它将尝试将其放入一个单一的文件中，并在此过程中删除任何不需要的依赖项（这称为tree-shaking）。完成后，它将文件放在`dist/build.js`中。
- en: 'If we try to run this, we will run into a problem. Here, we are utilizing private
    variables for classes, and Rollup does not support this, along with other features
    of ESNext that we are utilizing. We will also need to change anywhere that had
    member variables set outside of a function. This means we will need to change
    `cache.js` to the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行这个，我们会遇到一个问题。在这里，我们正在为类使用私有变量，而Rollup不支持这一点，以及我们正在使用的ESNext的其他特性。我们还需要更改任何在函数外设置成员变量的地方。这意味着我们需要将`cache.js`更改为以下内容：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will also need to replace all of the constructors in `template.js`, just
    like we did with `LRUCache`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要替换`template.js`中的所有构造函数，就像我们在`LRUCache`中所做的那样。
- en: 'After making the preceding changes, we should see that `rollup` is happy with
    us and is now compiling. If we go into the `dist/build.js` file, we will see that
    it put all of the files together. Let''s go ahead and put another option in our
    configuration file. Follow these steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行了上述更改后，我们应该看到`rollup`对我们感到满意，并且现在正在编译。如果我们进入`dist/build.js`文件，我们将看到它将所有文件放在一起。让我们继续在我们的配置文件中添加另一个选项。按照以下步骤进行：
- en: 'Run the following command to add the minifier and code uglifier plugin to Rollup
    as a dev dependency:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令将最小化器和代码混淆器插件添加到Rollup作为开发依赖项：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With this installed, add the following lines to our `config.js` file:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了这个之后，将以下行添加到我们的`config.js`文件中：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, if we take a look at our `dist/build.js` file, we will see a file that
    is barely noticeable. This is all we need for the Rollup configuration for our
    application, but there are many more configuration options and plugins that can
    help with the compilation process. Next, we will take a look at some options that
    can help us put our CSS files into a smaller format, and also look at what would
    happen if we used Sass and how we could compile that with Rollup.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查看我们的`dist/build.js`文件，我们将看到一个几乎不可见的文件。这就是我们的应用程序的Rollup配置所需的全部内容，但还有许多其他配置选项和插件可以帮助编译过程。接下来，我们将看一些可以帮助我们将CSS文件放入更小格式的选项，并查看如果我们使用Sass会发生什么以及如何将其与Rollup编译。
- en: Adding other file types to our distribution
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将其他文件类型添加到我们的分发
- en: Currently, we are only bundling up our JavaScript files, but most application
    developers know that any frontend work also needs to be bundled up. Take Sass
    ([https://sass-lang.com/](https://sass-lang.com/)), for example. It allows us
    to write CSS in a way that allows maximum reusability.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只打包我们的JavaScript文件，但大多数应用程序开发人员知道任何前端工作也需要打包。例如，以Sass ([https://sass-lang.com/](https://sass-lang.com/))为例。它允许我们以一种最大程度地实现可重用性的方式编写CSS。
- en: 'Let''s go ahead and turn the CSS that we had for this project into a Sass file.
    Follow these steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续将我们为这个项目准备的CSS转换为Sass文件。按照以下步骤进行：
- en: Create a new folder called `stylesheets` and add `main.scss` to it.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`stylesheets`的新文件夹，并将`main.scss`添加到其中。
- en: 'Add the following code to our Sass file:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到我们的Sass文件中：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous code showcases two features of Sass that make it easier to use:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了Sass的两个特性，使其更容易使用：
- en: It allows us to nest styling. Instead of having to have a separate `footer`
    and `h2` section, we can just nest them.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许我们嵌套样式。我们不再需要单独的`footer`和`h2`部分，我们可以将它们嵌套在一起。
- en: It allows the use of variables (yes, we have them in CSS).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许使用变量（是的，在CSS中我们有它们）。
- en: With HTTP/2, some standards for bundling files have gone by the wayside. Items
    such as sprite sheets are no longer advisable since the HTTP/2 standard added
    the concept of TCP multiplexing. It can actually be faster to download multiple
    smaller files than one large file. For those of you who are interested, the following
    link explains these concepts in more detail: [https://css-tricks.com/musings-on-http2-and-bundling/](https://css-tricks.com/musings-on-http2-and-bundling/).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 随着HTTP/2的出现，一些文件捆绑的标准已经被淘汰。诸如雪碧图之类的项目不再建议使用，因为HTTP/2标准增加了TCP多路复用的概念。下载多个较小的文件可能比下载一个大文件更快。对于那些感兴趣的人，以下链接更详细地解释了这些概念：[https://css-tricks.com/musings-on-http2-and-bundling/](https://css-tricks.com/musings-on-http2-and-bundling/)。
- en: There is quite a bit more to Sass that what can be found on their website, such
    as mixins, but here, we want to focus on converting these files into the CSS that
    we know we can use on the frontend.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Sass还有很多内容，不仅仅是在他们的网站上可以找到的，比如mixin，但在这里，我们想专注于将这些文件转换为我们知道可以在前端使用的CSS。
- en: 'Now, we need to convert this into CSS and put it in our original folder. To
    do that, we will add `rollup-plugin-sass` to our configuration. We can do that
    by running `npm install -D rollup-plugin-sass`. With that added, we will add a
    new rollup configuration called `rollup.sass.config.js` and add the following
    code to it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将其转换为CSS并将其放入我们的原始文件夹中。为此，我们将在我们的配置中添加`rollup-plugin-sass`。我们可以通过运行`npm
    install -D rollup-plugin-sass`来实现。添加了这个之后，我们将添加一个名为`rollup.sass.config.js`的新rollup配置，并将以下代码添加到其中：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we have made our rollup file, we will need to create the `main-sass.js`
    file that we have currently. Let''s go ahead and do just that. Add the following
    code to that file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们制作了我们的rollup文件，我们将需要创建我们目前拥有的`main-sass.js`文件。让我们继续做到这一点。将以下代码添加到该文件中：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s run the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行以下命令：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By doing this, we will see that the `css` directory inside of our template folder
    has been populated. By doing this, we can see how we can bundle everything up,
    not just our JavaScript files. Now that we've integrated Rollup's build system
    into our development pipeline, we will take a look at integrating Rollup into
    NPM's build pipeline.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们将看到模板文件夹内的`css`目录已经被填充。通过这样做，我们可以看到我们如何捆绑一切，不仅仅是我们的JavaScript文件。现在我们已经将Rollup的构建系统集成到了我们的开发流程中，我们将看看如何将Rollup集成到NPM的构建流程中。
- en: Bringing rollup into Node.js commands
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将rollup引入Node.js命令
- en: Now, we could just leave everything alone and run our rollup commands through
    the command line, but this may make things a bit harder when we bring continuous
    integration into our process (up next). Also, we may have other developers working
    on the same system and instead of having them run multiple commands, they can
    run a single `npm` command. Instead, we want to integrate rollup into various
    Node.js scripts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以只是让一切保持原样，并通过命令行运行我们的rollup命令，但是当我们将持续集成引入我们的流程时（接下来），这可能会使事情变得更加困难。此外，我们可能有其他开发人员在同一系统上工作，而不是让他们运行多个命令，他们可以运行一个`npm`命令。相反，我们希望将rollup集成到各种Node.js脚本中。
- en: We looked at this in [Chapter 9](59d1466a-ef4d-42f8-bc88-f3d364c3d23e.xhtml), *Practical
    Example – Building a Static Server*, with the `microserve` package and the `start`
    command. But now, we want to integrate two new commands called `build` and `watch`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第9章](59d1466a-ef4d-42f8-bc88-f3d364c3d23e.xhtml)中看到了这一点，*实际示例-构建静态服务器*，使用了`microserve`包和`start`命令。但现在，我们想要集成两个新命令，称为`build`和`watch`。
- en: 'First, we want the `build` command to run our rollup configurations. Follow
    these steps to make this happen:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望`build`命令运行我们的rollup配置。按照以下步骤来实现这一点：
- en: Let's clean up our main directory and move our rollup configurations to a build
    directory.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们清理一下我们的主目录，并将我们的rollup配置移动到一个构建目录中。
- en: 'With both of those moved, we will add the following line to our `package.json`
    file:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个都移动后，我们将在`package.json`文件中添加以下行：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this move, we can run `npm run build` and see everything built for us in
    a single command.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这一举措，我们可以运行`npm run build`，并在一个命令中看到所有内容都已构建完成。
- en: 'Second, we want to add a watch command. This will allow rollup to watch for
    changes and instantly run that script for us. We can easily add this into our
    `package.json` by adding the following line to our `scripts` section:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们想要添加一个watch命令。这将允许rollup监视更改，并立即为我们运行该脚本。我们可以通过将以下行添加到我们的`scripts`部分中，轻松地将其添加到我们的`package.json`中：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, if we type `npm run watch`, it will start rollup in watch mode. With that,
    as we make changes to our JavaScript files, we can see that rollup is automatically
    rebuilding our distribution file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们输入`npm run watch`，它将以监视模式启动rollup。通过这样做，当我们对JavaScript文件进行更改时，我们可以看到rollup自动重新构建我们的分发文件。
- en: 'One final change that we need to make before we move onto continuous integration
    is to point our main entry point to our distribution file. To do this, we will
    change the start section in the `package.json` file so that it points to `dist/build.js`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入持续集成之前，我们需要做的最后一个改变是将我们的主入口点指向我们的分发文件。为此，我们将更改`package.json`文件中的start部分，使其指向`dist/build.js`：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With that, let''s go ahead and check to make sure that everything is still
    working correctly by running `npm run start`. We will see that some of our files
    aren''t pointing to the correct location. Let''s go ahead and fix this by making
    some changes to the `package.json` file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，让我们继续检查一下，确保一切仍然正常运行，通过运行`npm run start`。我们会发现一些文件没有指向正确的位置。让我们通过对`package.json`文件进行一些更改来修复这个问题：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this, we should be good to go! There are plenty of options with Rollup
    and there are even more when we want to integrate into the Node script system,
    but this should get us ready for the next section of this chapter, which is integrating
    into a CI/CD pipeline. Our system of choice is CircleCI.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们应该准备好了！Rollup有很多选项，当我们想要集成到Node脚本系统时，甚至还有更多选项，但这应该让我们为本章的下一部分做好准备，即集成到CI/CD流水线中。我们选择的系统是CircleCI。
- en: Integrating into CircleCI
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成到CircleCI
- en: As we mentioned previously, development in the real world has dramatically shifted
    in the past couple of decades. From building everything locally and deploying
    from our development machines to complicated orchestration and dependency deployment
    trees, we have seen a rise in tools that help us rapidly develop and deploy.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，过去几十年里，现实世界中的开发发生了巨大的变化。从在本地构建所有内容并从我们的开发机器部署到复杂的编排和依赖部署树，我们已经看到了一系列工具的崛起，这些工具帮助我们快速开发和部署。
- en: One example of this is the CI/CD tools that we have available to us, such as
    Jenkins, Travis, Bamboo, and CircleCI. These tools pick up on various hooks, such
    as pushing code to a remote repository and instantly running a *build*. We will
    be utilizing CircleCI as our tool of choice. It is easy to set up and an easy-to-use
    development tool that has a nice free tier for developers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用的一个例子是CI/CD工具，比如Jenkins、Travis、Bamboo和CircleCI。这些工具会触发各种钩子，比如将代码推送到远程存储库并立即运行*构建*。我们将利用CircleCI作为我们的选择工具。它易于设置，是一个易于使用的开发工具，为开发人员提供了一个不错的免费层。
- en: 'In our case, this build is going to be doing the following three things:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这个构建将做以下三件事：
- en: Pulling in all of our project dependencies
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉取所有项目依赖项
- en: Running our Node.js build script
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行我们的Node.js构建脚本
- en: Deploying those resources to our server, where we will be running the application
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些资源部署到我们的服务器上，我们将在那里运行应用程序
- en: 'Getting all of this set up can be quite a frustrating experience, but it is
    well worth the payoff once our application is hooked up. We will be utilizing
    the following technologies to help us with this process:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 设置所有这些可能是一个相当令人沮丧的经验，但一旦我们的应用程序连接起来，它就是值得的。我们将利用以下技术来帮助我们进行这个过程：
- en: CircleCI
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CircleCI
- en: GitHub
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub
- en: With this in mind, our first step will be to go to GitHub and create a profile,
    if we haven't done so already. This is as simple as going to [https://github.com/](https://github.com/)
    and looking toward the top-right corner for the signup option. Once we have done
    this, we can start creating/forking repositories.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们的第一步将是转到GitHub并创建一个个人资料，如果我们还没有这样做。只需转到[https://github.com/](https://github.com/)，然后在右上角查找注册选项。一旦我们这样做了，我们就可以开始创建/分叉存储库。
- en: Since all of the code for this book is on GitHub, most of you should already
    have a GitHub account and know the basics of utilizing Git.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书的所有代码都在GitHub上，大多数人应该已经有GitHub账户并了解如何使用Git的基础知识。
- en: 'For those of you who are struggling with Git or haven''t utilized a version
    control system, the following resource may help: [https://try.github.io/](https://try.github.io/).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些在Git上挣扎或尚未使用版本控制系统的人，以下资源可能会有所帮助：[https://try.github.io/](https://try.github.io/)。
- en: 'Now, we need to fork the repository that all of the code is in into our own
    repository. To do this, run through the following steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将所有代码都在的存储库分叉到我们自己的存储库中。要做到这一点，请按照以下步骤进行操作：
- en: Go to this book's GitHub repository at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript)
    and click the top-right option to fork the entire repository.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到本书的GitHub存储库[https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript)，并单击右上角的选项，将整个存储库分叉。
- en: If we do not want to do that, we can clone the repository to our local computer.
    (This may be the better option since we only want the contents of the `Chapter12`
    directory.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想这样做，我们可以将存储库克隆到本地计算机。（这可能是更好的选择，因为我们只想要`Chapter12`目录的内容。）
- en: Whichever of the two options we choose, go ahead and move the `Chapter12` directory
    into another location on our local computer and change the folder name to something
    like `microserve`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论我们选择哪种选项，都可以将`Chapter12`目录移动到本地计算机的另一个位置，并将文件夹名称更改为`microserve`。
- en: Go back into GitHub and create a new repository. Make this a private repository.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到GitHub，创建一个新的存储库。将其设置为私有存储库。
- en: 'Finally, go back to our local machine and remove the `.git` file that is already
    there with the following command:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，回到我们的本地机器，并使用以下命令删除已经存在的`.git`文件：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For those of you who are on Windows, you can run these commands if you have
    the Windows 10 Linux subsystem. Alternatively, you can download the Cmder tool:
    [https://cmder.net/](https://cmder.net/).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用Windows的人，如果你有Windows 10 Linux子系统，可以运行这些命令。或者，你可以下载Cmder工具：[https://cmder.net/](https://cmder.net/)。
- en: 'Run the following commands to hook the local system up to the remote GitHub
    repository:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，将本地系统连接到远程GitHub存储库：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The command line will ask for some credentials. Use the ones that we set up
    our profile with.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令行将要求输入一些凭据。使用我们设置个人资料时的凭据。
- en: Our local files should be hooked into GitHub. Now all we need to do is set up
    this system with CircleCI. To do this, we will need to create an account on CircleCI's
    website.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的本地文件应该已经连接到GitHub。现在我们需要做的就是用CircleCI设置这个系统。为此，我们需要在CircleCI的网站上创建一个账户。
- en: Go to [https://circleci.com/](https://circleci.com/) and click on Sign Up and
    then Sign up with GitHub.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[https://circleci.com/](https://circleci.com/)，点击“注册”，然后使用GitHub注册。
- en: 'Once our account is hooked up, we can log in. We should see the following screen:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的账户连接上了，我们就可以登录。我们应该会看到以下屏幕：
- en: '![](assets/16773d81-f2e9-4221-98b0-5371f74af673.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/16773d81-f2e9-4221-98b0-5371f74af673.png)'
- en: Click Set Up Project for the repository we just set up.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“设置项目”以设置我们刚刚设置的存储库。
- en: 'It should detect that we have a CircleCI file already in our repository, but
    we can always start from scratch if we want to. The directions that follow are
    going to be for setting CircleCI up from scratch. To do this, we can utilize the
    Node.js template that they have. However, the main thing we will need to do is
    create the `.circleci` directory and the `config.yml` file in that directory.
    We should have something basic that looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该会检测到我们的存储库中已经有一个CircleCI文件，但如果我们愿意，我们也可以从头开始。接下来的指示将是为了从头开始设置CircleCI。为此，我们可以利用他们提供的Node.js模板。然而，我们主要需要做的是在`.circleci`目录中创建`config.yml`文件。我们应该有一个基本的东西，看起来像这样：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The CircleCI configuration file executes in the following way:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI配置文件的执行方式如下：
- en: We state that we want to utilize the `circleci/node:12.13` image from Docker
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明要使用Docker中的`circleci/node:12.13`镜像
- en: 'We won''t be discussing Docker here, but it is yet another technology that
    many companies use to deploy and host applications. More information on this technology
    can be found here: [https://docs.docker.com/](https://docs.docker.com/).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里讨论Docker，但这是许多公司用来部署和托管应用程序的另一种技术。有关这项技术的更多信息可以在这里找到：[https://docs.docker.com/](https://docs.docker.com/)。
- en: We want to run all of our commands in `~/repo`. This will be the case for almost
    all the basic projects we create.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在`~/repo`中运行所有命令。这将是我们几乎所有基本项目的情况。
- en: Next, we check the repository into that `~/repo`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将该存储库检入到`~/repo`中。
- en: Now, we need to set up a cache for this repository, if we don't have one already.
    This will make sure that we only pull down the repository when we need to.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们还没有为这个存储库设置缓存，我们需要设置一个。这样可以确保我们只在需要时才拉取存储库。
- en: We need to run the `npm install` command to pull in all of our dependencies.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要运行`npm install`命令来拉取所有的依赖项。
- en: Finally, we save the cache.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们保存缓存。
- en: This process is known as continuous integration because it will constantly run
    builds for us when we push code. We can add different settings inside our CircleCI
    profile if we want, but that is beyond the scope of this book. We will also get
    notifications via email when a build is complete. We can tune this if we want
    at the following location: [https://circleci.com/gh/organizations/<your_user>/settings](https://circleci.com/gh/organizations/%3cyour_user%3e/settings).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程被称为持续集成，因为当我们推送代码时，它会不断地为我们运行构建。如果我们想要，我们可以在CircleCI配置文件中添加不同的设置，但这超出了本书的范围。当构建完成时，我们还会通过电子邮件收到通知。如果需要，我们可以在以下位置进行调整：[https://circleci.com/gh/organizations/<your_user>/settings](https://circleci.com/gh/organizations/%3cyour_user%3e/settings)。
- en: With this, we have created a basic CircleCI file! Now, if we go to our dashboard,
    it should run a build once we push this CircleCI configuration. It should also
    show all the steps that we laid out previously. This is great! Now, let's hook
    in our build process so that we can actually do something with our CI system.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经创建了一个基本的CircleCI文件！现在，如果我们转到我们的仪表板，一旦我们推送这个CircleCI配置，它应该运行一个构建。它还应该显示我们之前列出的所有步骤。太棒了！现在，让我们连接我们的构建过程，这样我们就可以真正地使用我们的CI系统。
- en: Adding our build steps
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加我们的构建步骤
- en: 'With our CircleCI configuration, we can add many steps to the process and even
    add things called orbs. Orbs are essentially predefined packages and commands
    that can enhance our build process. In this section, we will be adding an orb
    that was published by Snyk: [https://snyk.io/](https://snyk.io/). This scans and
    looks for bad packages that are currently in the npm ecosystem. We will add this
    after we have set up our build.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的CircleCI配置，我们可以在流程中添加许多步骤，甚至添加称为orbs的东西。Orbs本质上是预定义的包和命令，可以增强我们的构建过程。在本节中，我们将添加由Snyk发布的一个orb：[https://snyk.io/](https://snyk.io/)。这将扫描并查找当前在npm生态系统中存在的不良包。我们将在设置构建后添加这个。
- en: 'To get our build running and packaged into something that we can deploy, we
    will add the following to our CircleCI configuration:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的构建运行并打包成我们可以部署的东西，我们将在我们的CircleCI配置中添加以下内容：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With this, we will have our system building just as if we were running locally.
    Let''s go ahead and try it out. Follow these steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的系统将会像在本地运行一样构建。让我们继续尝试一下。按照以下步骤进行：
- en: 'Add our configuration file to our `git` commit:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的配置文件添加到我们的`git`提交中：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Commit this to our local repository:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此提交到我们的本地存储库：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Push this to our GitHub repository:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此推送到我们的GitHub存储库：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As soon as we do that, CircleCI will start up a build. If we go to the project
    directory in CircleCI, we will see it building. If we click on the job, we will
    see it running all of our steps – we will even see it running through the steps
    we laid out in our file. Here, we will see our build failed!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，CircleCI将启动一个构建。如果我们在CircleCI中的项目目录中，我们将看到它正在构建。如果我们点击作业，我们将看到它运行我们所有的步骤-我们甚至会看到它运行我们在文件中列出的步骤。在这里，我们将看到我们的构建失败！
- en: '![](assets/92977eda-b298-4d1d-a1a0-1e23093d7fb9.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/92977eda-b298-4d1d-a1a0-1e23093d7fb9.png)'
- en: 'This has happened because when we installed Rollup, we installed it as a global
    item. In this case, we need to add it as a dev dependency in our `package.json` file.
    If we add it to our `package.json` file, we should have a `devDependency` section
    that looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当我们安装Rollup时，我们将其安装为全局项目。在这种情况下，我们需要将其添加为`package.json`文件中的开发依赖项。如果我们将其添加到我们的`package.json`文件中，我们应该有一个看起来像这样的`devDependency`部分：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, if we commit and push these files to our GitHub repository, we will see
    that our build passes!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们将这些文件提交并推送到我们的GitHub存储库，我们将看到我们的构建通过了！
- en: 'With a passing build, we should add the Snyk orb to our configuration. If we
    head to [https://circleci.com/orbs/registry/orb/snyk/snyk](https://circleci.com/orbs/registry/orb/snyk/snyk),
    we will see all of the commands and the configuration that we need to set up.
    Let''s go ahead and change our `config.yml` file in order to bring the Snyk orb
    in. We will check our repository after we have built it. This should look like
    this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个通过的构建，我们应该将Snyk orb添加到我们的配置中。如果我们前往[https://circleci.com/orbs/registry/orb/snyk/snyk](https://circleci.com/orbs/registry/orb/snyk/snyk)，我们将看到我们需要设置的所有命令和配置。让我们继续修改我们的`config.yml`文件，以引入Snyk
    orb。我们将在构建后检查我们的存储库。这应该看起来像这样：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With the preceding configuration, we can go ahead and commit/push to our GitHub
    repository and see the new run of our build. It should fail because it will not
    allow us to run third-party orbs unless we explicitly state that we want to run
    them. We can do this by heading to our settings and going to the Security section.
    Once there, go ahead and state that we want to use third-party orbs. With this
    checked, we can do another build and we will see that we fail again!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述配置，我们可以继续提交/推送到我们的GitHub存储库，并查看我们的构建的新运行。它应该失败，因为除非我们明确声明要运行它们，否则它不允许我们运行第三方orbs。我们可以通过前往设置并转到安全部分来做到这一点。一旦在那里，继续声明我们要使用第三方orbs。勾选后，我们可以进行另一个构建，我们将看到我们再次失败！
- en: We will need to sign up with Snyk to use their orb. Go ahead and head to snyk.io
    and sign up with a GitHub account. Then, go to the Account settings section. From
    there, grab the API token and head to the Settings and contexts section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注册Snyk才能使用他们的orb。前往snyk.io并使用GitHub帐户注册。然后，转到“帐户设置”部分。从那里，获取API令牌并转到“设置和上下文”部分。
- en: 'Create a new context and add the following environment variable:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的上下文并添加以下环境变量：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To utilize contexts, we will need to change up our `config.yml` file a bit.
    We will need to add in a workflows section and tell it to run our build job with
    that context. The file should look something like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用contexts，我们需要稍微修改我们的`config.yml`文件。我们需要添加一个工作流部分，并告诉它使用该上下文运行我们的构建作业。文件应该看起来像下面这样：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With that change, we can go ahead and push it to the remote repository. We will
    see that the build passes with Snyk security scanning our packages!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个变化，我们可以继续将其推送到远程存储库。我们将看到构建通过，并且Snyk将安全扫描我们的包！
- en: The idea of contexts is to hide API keys and secrets from the configuration
    file. We don't want to put those in our configuration files since anyone would
    be able to see them. Instead, we put them in something such as a context, where
    the administrators of a project will be able to see them. Every CI/CD system should
    have a concept like this, and this should be used whenever there are items like
    this.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文的概念是为了隐藏配置文件中的API密钥和密码。我们不希望将它们放在配置文件中，因为任何人都可以看到它们。相反，我们将它们放在诸如上下文之类的地方，项目的管理员将能够看到它们。每个CI/CD系统都应该有这样的概念，并且在有这样的项目时应该使用它。
- en: With our project building and being scanned, all we need to do is deploy our
    application to a machine!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的项目构建和扫描完成，我们所需要做的就是将我们的应用程序部署到一台机器上！
- en: Deploying our build
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署我们的构建
- en: To deploy our application, we will need to deploy to our own computers. There
    are many services out there, such as AWS, Azure, Netlify, and so on, which will
    have their own ways of deploying. In our case, we are going to deploy out to Heroku.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署我们的应用程序，我们需要部署到我们自己的计算机上。有许多服务可以做到这一点，比如AWS、Azure、Netlify等等，它们都有自己的部署方式。在我们的情况下，我们将部署到Heroku。
- en: 'Follow these steps to do so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: We will need to get a Heroku account if we don't have one already. Head over
    to [https://id.heroku.com/login](https://id.heroku.com/login) and choose Sign
    Up at the bottom of the form.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们还没有Heroku帐户，我们需要去注册一个。前往[https://id.heroku.com/login](https://id.heroku.com/login)，然后在表单底部选择“注册”。
- en: Log in to the new account and click on the top-right button that states New.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录新帐户，然后点击右上角的“新建”按钮。
- en: In the dropdown, click Create new app.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉菜单中，点击“创建新应用程序”。
- en: We can call the app anything we want. Type in an application name.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以随意给应用程序取任何名字。输入一个应用程序名称。
- en: Head back to our CircleCI dashboard and go back into the settings. Create a
    new context called deploy.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到我们的CircleCI仪表板，然后进入设置。创建一个名为“deploy”的新上下文。
- en: Add a new variable called `HEROKU_APP_NAME`. This is the app name that we set
    up in *step 3*.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`HEROKU_APP_NAME`的新变量。这是我们在*步骤3*中设置的应用程序名称。
- en: Head back to Heroku and click on the user profile icon in the top right. From
    the dropdown, click on Account Settings.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Heroku，点击右上角的用户配置文件图标。从下拉菜单中，点击“帐户设置”。
- en: You should see a section called API Key. Click the Reveal button and copy the
    key shown.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该会看到一个名为“API密钥”的部分。点击“显示”按钮，然后复制显示的密钥。
- en: Head back to our CircleCI dashboard and create a new variable called `HEROKU_API_KEY`.
    The value should be the key we got in *step 8*.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到我们的CircleCI仪表板，并创建一个名为`HEROKU_API_KEY`的新变量。值应该是我们在*步骤8*中得到的密钥。
- en: 'Add a new job to our `config.yml` file. Our job should look something like
    the following:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`config.yml`文件中添加一个新的作业。我们的作业应该看起来像下面这样：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What we've done here is add a new job to our workflow, which is the `deploy`
    job. Here, the first step is to add the official Heroku orb to our workflow. Next,
    we created a job called `deploy` and we went through the steps set out by the
    Heroku orb. These can be found at [https://circleci.com/orbs/registry/orb/circleci/heroku](https://circleci.com/orbs/registry/orb/circleci/heroku).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是向我们的工作流程中添加了一个新的作业，即`deploy`作业。在这里，第一步是向我们的工作流程中添加官方的Heroku orb。接下来，我们创建了一个名为`deploy`的作业，并按照Heroku
    orb中的步骤进行操作。这些步骤可以在[https://circleci.com/orbs/registry/orb/circleci/heroku](https://circleci.com/orbs/registry/orb/circleci/heroku)找到。
- en: We need to deploy our build back to GitHub for Heroku to pick up the changes.
    To do this, we need to create a deploy key. Run the `ssh-keygen -m PEM -t rsa
    -C "<your_email>"` command in the command prompt. Make sure that you don't enter
    a password.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将我们的构建部署回GitHub，以便Heroku获取更改。为此，我们需要创建一个部署密钥。在命令提示符中运行`ssh-keygen -m PEM
    -t rsa -C "<your_email>"`命令。确保不要输入密码。
- en: Copy the key that was just generated and head into the GitHub repository's Settings.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制刚生成的密钥，然后进入GitHub存储库的设置。
- en: Click on Deploy Keys in the left navbar.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧导航栏中点击“部署密钥”。
- en: Click Add a deploy key.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“添加部署密钥”。
- en: Add a title and then paste the key that we copied in *step 12*.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个标题，然后粘贴我们在*步骤12*中复制的密钥。
- en: Check the box that states Allow write access.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选“允许写入访问”复选框。
- en: Head back into CircleCI and click on the project settings in the left-hand navbar.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回CircleCI，点击左侧导航栏中的项目设置。
- en: Click on SSH Permissions and then Add SSH Key.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“SSH权限”，然后点击“添加SSH密钥”。
- en: Add the private key we created in *step 11*. Make sure to add `github.com` in
    the Hostname section.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*步骤11*中添加我们创建的私钥。确保在主机名部分添加`github.com`。
- en: 'With this added, add the following lines to the `config.yml` file for our build
    job:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下行到我们构建作业的`config.yml`文件中：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At the end of our build, add the following step:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建结束时，添加以下步骤：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: One issue that we will have is that our application wants to work over HTTPS,
    but Heroku requires a pro license for this. Either opt in for this (this is a
    paid service) or change our application so that it only works with HTTP.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遇到的一个问题是，我们的应用程序希望通过HTTPS工作，但Heroku需要专业许可证才能实现这一点。要么选择这个（这是一个付费服务），要么更改我们的应用程序，使其只能使用HTTP。
- en: By doing this, we have successfully set up a CI/CD pipeline that can be utilized
    almost anywhere. We also added an additional security check to make sure that
    we are deploying safe code. With all of this under our belt, we are able to build
    and deploy web applications written in JavaScript!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们成功地建立了一个几乎可以在任何地方使用的CI/CD流水线。我们还增加了一个额外的安全检查，以确保我们部署的代码是安全的。有了这些，我们就能够构建和部署用JavaScript编写的Web应用程序了！
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how applications can be built while utilizing build
    environments such as RollupJS. On top of this, we looked at how to add CI and
    CD through CircleCI.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在利用构建环境（如RollupJS）的同时构建应用程序。除此之外，我们还学习了如何通过CircleCI添加CI和CD。
- en: The next chapter, and the final chapter of this book, will take a look at an
    advanced concept called WebAssembly. While the code will not be JavaScript, it
    will help us understand how we can take our web applications to the next level.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，也是本书的最后一章，将介绍一个名为WebAssembly的高级概念。虽然代码不会是JavaScript，但它将帮助我们了解如何将我们的Web应用程序提升到一个新的水平。
