- en: Design – If It's Not Testable, It's Not Designed Well
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计-如果不能进行测试，那就不是设计良好
- en: '"Simplicity is the ultimate sophistication."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “简单是终极的复杂。”
- en: – Leonardo da Vinci
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 列奥纳多·达·芬奇'
- en: In the past, the software industry was focused on developing software at high
    speed, with nothing in mind but cost and time. Quality was a secondary goal, with
    the false feeling that customers were not interested in it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，软件行业专注于以高速开发软件，只考虑成本和时间。质量是次要目标，人们错误地认为客户对此不感兴趣。
- en: Nowadays, with the increasing connectivity of all kinds of platforms and devices,
    quality has become a first-class citizen in customer's requirements. Good applications
    offer a good service with a reasonable response-time, without being affected by
    a multitude of concurrent requests from many users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，随着各种平台和设备的连接性不断增加，质量已成为客户需求中的一等公民。良好的应用程序在合理的响应时间内提供良好的服务，而不会受到许多用户的大量并发请求的影响。
- en: Good applications in terms of quality are those that have been well designed.
    A good design means scalability, security, maintainability, and many other desired
    attributes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在质量方面，良好的应用程序是那些经过良好设计的。良好的设计意味着可扩展性、安全性、可维护性和许多其他期望的属性。
- en: In this chapter, we will explore how TDD leads developers to good design and
    best practices by implementing the same application using both the traditional
    and TDD approaches.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨TDD如何通过使用传统和TDD方法来实现相同的应用程序，从而引导开发人员走向良好的设计和最佳实践。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Why should we care about design?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么要关心设计？
- en: Design considerations and principles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计考虑和原则
- en: The traditional development process
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的开发过程
- en: The TDD approach using Hamcrest
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hamcrest的TDD方法
- en: Why should we care about design?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么要关心设计？
- en: In software development, whether you are an expert or a beginner, there are
    some situations where code seems to be unnatural. You can't avoid the feeling
    that something is wrong with that code when reading it. Occasionally, you even
    wonder why the previous programmer implemented a specific method or a class in
    such a twisted manner. This is because the same functionality can be implemented
    in a vast number of different ways, each of them unique. With this huge number
    of possibilities, which is the best one? What defines a good solution? Why is
    one better than the others? The fact is, all of them are valid so long as the
    goal is achieved. However, it is true that some aspects should be considered when
    choosing the right solution. This is where the design of the solution becomes
    relevant.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，无论您是专家还是初学者，都会遇到一些代码看起来不自然的情况。在阅读时，您无法避免感觉到代码有问题。有时，您甚至会想知道为什么以前的程序员以这种扭曲的方式实现了特定的方法或类。这是因为相同的功能可以以大量不同的方式实现，每种方式都是独一无二的。在如此多的可能性中，哪一个是最好的？什么定义了一个好的解决方案？为什么一个比其他的更好？事实是，只要达到目标，所有这些都是有效的。然而，选择正确解决方案时应考虑一些方面。这就是解决方案的设计变得相关的地方。
- en: Design principles
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计原则
- en: A **software design principle** is a rule or set of rules that work as a guide
    for software developers and push them towards smart and maintainable solutions.
    In other words, design principles are conditions that code must fulfill to be
    considered objectively well designed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件设计原则**是软件开发人员的指导原则，推动他们朝着智能和可维护的解决方案前进。换句话说，设计原则是代码必须满足的条件，以便被认为是客观良好设计的。'
- en: Most senior developers and experienced programmers know about software design
    principles and it's very likely that, independently of whether they practice TDD,
    they are applying them to their daily work. The TDD philosophy encourages programmers—even
    beginners—to follow some principles and good practices that make code cleaner
    and more readable. Those practices are enforced by the Red-Green-Refactor cycle.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数资深开发人员和经验丰富的程序员都了解软件设计原则，很可能无论他们是否实践TDD，他们都在日常工作中应用这些原则。TDD哲学鼓励程序员-甚至是初学者-遵循一些原则和良好实践，使代码更清晰、更可读。这些实践是由红-绿-重构周期强制执行的。
- en: The Red-Green-Refactor cycle advocates for small feature increments by introducing
    one test that fails at a time. Programmers add code fragments, as concise and
    short as possible, so neither the new test or the old ones do not fail anymore.
    And ultimately, they refactor the code, which consists of cleanup and improvement
    tasks such as duplication removal or code optimization.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 红-绿-重构周期倡导通过一次引入一个失败的测试来实现小的功能增量。程序员添加尽可能简洁和短小的代码片段，以便新的测试或旧的测试都不再失败。最终，他们重构代码，包括清理和改进任务，如去除重复或优化代码。
- en: As a result of the process, the code becomes easier to understand and safer
    to modify in the future. Let's take a look at some of the most popular software
    design principles.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为过程的结果，代码变得更容易理解，并且在将来修改时更安全。让我们来看一些最流行的软件设计原则。
- en: You Ain't Gonna Need It
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你不会需要它
- en: '**YAGNI** is the acronym for the **You Ain''t Gonna Need It** principle. It
    aims to erase all unnecessary code and focuses on the current functionalities,
    not the future ones. The less code you have, the less code you''re going to maintain
    and the lower the probability that bugs will be introduced.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAGNI**是**You Ain''t Gonna Need It**原则的缩写。它旨在消除所有不必要的代码，专注于当前的功能，而不是未来的功能。您的代码越少，您需要维护的代码就越少，引入错误的可能性就越低。'
- en: For more information on YAGNI, visit Martin Fowler's article available at [http://martinfowler.com/bliki/Yagni.html](http://martinfowler.com/bliki/Yagni.html).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有关YAGNI的更多信息，请访问Martin Fowler的文章，网址为[http://martinfowler.com/bliki/Yagni.html](http://martinfowler.com/bliki/Yagni.html)。
- en: Don't Repeat Yourself
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要重复自己
- en: The idea behind the **Don't Repeat Yourself** (**DRY**) principle is to reuse
    the code you previously wrote instead of repeating it. The benefits are less code
    to maintain and the use of code that you know that already works, which is a great
    thing. It helps you to discover new abstraction levels inside your code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要重复自己**（DRY）原则的理念是重用之前编写的代码，而不是重复它。好处是减少需要维护的代码，使用已知可行的代码，这是一件好事。它可以帮助你发现代码中的新抽象层级。'
- en: For additional information, visit [http://en.wikipedia.org/wiki/Don%27t_repeat_yourself](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问[http://en.wikipedia.org/wiki/Don%27t_repeat_yourself](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself)。
- en: Keep it simple, stupid
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持简单，愚蠢
- en: This principle has the confusing acronym of **keep it simple**, **stupid** (**KISS**) and
    states that things perform their function better if they are kept simple rather
    than complicated. It was coined by Kelly Johnson.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则有一个令人困惑的缩写**保持简单，愚蠢**（KISS），并且陈述了事物如果保持简单而不是复杂，它们会更好地发挥功能。这是由凯利·约翰逊创造的。
- en: To read about the story behind this principle, visit [http://en.wikipedia.org/wiki/KISS_principle](http://en.wikipedia.org/wiki/KISS_principle).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这个原则背后的故事，请访问[http://en.wikipedia.org/wiki/KISS_principle](http://en.wikipedia.org/wiki/KISS_principle)。
- en: Occam's razor
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奥卡姆剃刀
- en: 'Although **Occam''s razor** is a philosophical principle, not a software engineering
    one, it is still applicable to what we do. It is very similar to the previous
    principle, with the main statement being as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管**奥卡姆剃刀**是一个哲学原则，而不是软件工程原则，但它仍然适用于我们的工作。它与前一个原则非常相似，主要陈述如下：
- en: '"When you have two competing solutions to the same problem, the simpler one
    is the better."'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: “当你有两种竞争解决同一个问题的方案时，简单的那个更好。”
- en: – William of Ockham
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: – 奥卡姆的威廉
- en: For more information on Occam's razor, visit [http://en.wikipedia.org/wiki/Occam%27s_razor](http://en.wikipedia.org/wiki/Occam%27s_razor).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多奥卡姆剃刀原理，请访问[http://en.wikipedia.org/wiki/Occam%27s_razor](http://en.wikipedia.org/wiki/Occam%27s_razor)。
- en: SOLID principles
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则
- en: 'The word **SOLID** is an acronym invented by Robert C. Martin for the five
    basic principles of object-oriented programming. By following these five principles,
    a developer is more likely to create a great, durable, and maintainable application:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOLID**这个词是罗伯特·C·马丁为面向对象编程的五个基本原则创造的缩写。通过遵循这五个原则，开发人员更有可能创建一个出色、耐用和易于维护的应用程序：'
- en: '**Single Responsibility Principle**: A class should have only a single reason
    to change.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则**：一个类应该只有一个改变的原因。'
- en: '**Open-Closed Principle**: A class should be open for extension and closed
    for modification. This is attributed to Bertrand Meyer.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**：一个类应该对扩展开放，对修改关闭。这被归因于贝尔特兰·梅耶。'
- en: '**Liskov Substitution Principle**: This was created by Barbara Liskov, and
    she says *a class should be replaceable by others that extend that class*.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**：这是由芭芭拉·里斯科夫创建的，她说*一个类应该可以被扩展该类的其他类替换*。'
- en: '**Interface Segregation Principle**: A few specific interfaces are preferable
    to one general-purpose interface.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**：几个特定的接口比一个通用接口更可取。'
- en: '**Dependency Inversion Principle**: A class should depend on abstraction instead
    of implementation. This means that class dependencies must be focused on what
    is done and forget about how it is done.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖反转原则**：一个类应该依赖于抽象而不是实现。这意味着类的依赖必须专注于做什么，而忘记了如何做。'
- en: For further information on SOLID or other related principles, visit [http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于SOLID或其他相关原则的信息，请访问[http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)。
- en: The first four principles are part of the core of TDD thinking, since they aim
    to simplify the code we write. The last one is focused on classes construction
    and dependency relationships in the application assembly process.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个原则是TDD思想的核心部分，因为它们旨在简化我们编写的代码。最后一个原则侧重于应用程序组装过程中的类构建和依赖关系。
- en: All of these principles are applicable and desirable in both test and non-test
    driven development, because, apart from other benefits, they make our code more
    maintainable. The proper practical application of them is worth a whole book by
    itself. While we won't have time to go deep into it, we encourage you to investigate
    further.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些原则在测试驱动开发和非测试驱动开发中都是适用且可取的，因为除了其他好处外，它们使我们的代码更易于维护。它们的正确实际应用值得一整本书来讨论。虽然我们没有时间深入研究，但我们鼓励你进一步调查。
- en: In this chapter, we will see how TDD induces developers to put some of these
    principles into practice effortlessly. We will implement a small but fully functional
    version of the famous game Connect 4 with both the TDD and non-TDD approaches.
    Note that repetitive parts, such as Gradle project creation and so on, are omitted,
    as they are not considered relevant for the purpose of this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到TDD如何使开发人员轻松地将这些原则付诸实践。我们将使用TDD和非TDD方法实现一个小型但完全功能的四子连线游戏版本。请注意，重复的部分，如Gradle项目创建等，被省略了，因为它们不被认为与本章的目的相关。
- en: Connect 4
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四子连线
- en: Connect 4 is a popular, very easy-to-play board game. The rules are limited
    and simple.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 四子连线是一款受欢迎、易于玩的棋盘游戏。规则有限且简单。
- en: Connect 4 is a two-player connection game in which the players first choose
    a color and then take turns dropping colored discs from the top into a seven column,
    six row, vertically suspended grid. The pieces fall straight down, occupying the
    next available space within the column. The objective of the game is to connect
    four of your own discs of the same color next to one another vertically, horizontally,
    or diagonally, before your opponent connects four of theirs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 四子连线是一款双人对战的连接游戏，玩家首先选择一种颜色，然后轮流将有颜色的圆盘从顶部放入一个七列六行的垂直悬挂网格中。棋子直接下落，占据列中的下一个可用空间。游戏的目标是在对手连接四个自己颜色的圆盘之前，垂直、水平或对角线连接四个相同颜色的圆盘。
- en: For further information on the game, visit Wikipedia ([http://en.wikipedia.org/wiki/Connect_Four](http://en.wikipedia.org/wiki/Connect_Four)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有关游戏的更多信息，请访问维基百科（[http://en.wikipedia.org/wiki/Connect_Four](http://en.wikipedia.org/wiki/Connect_Four)）。
- en: Requirements
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: 'To code the two implementations of Connect 4, the game rules are transcribed
    as follows in the form of requirements. These requirements are the starting point
    for both the developments. We will go through the code with some explanations
    and compare both implementations at the end:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写Connect 4的两种实现，游戏规则被转录为以下需求的形式。这些需求是两种开发的起点。我们将通过一些解释来查看代码，并在最后比较两种实现：
- en: The board is composed of seven columns and six rows; all positions are empty.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 棋盘由七列和六行组成；所有位置都是空的。
- en: Players introduce discs on the top of the columns. The introduced disc drops
    down the board if the column is empty. Future discs introduced in the same column
    will stack over the previous ones.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家在列的顶部放入圆盘。如果列为空，则放入的圆盘会下落到棋盘上。将来在同一列中放入的圆盘将堆叠在之前的圆盘上。
- en: It is a two-person game, so there is one color for each player. One player uses
    red (*R*) and the other one uses green (*G*). Players alternate turns, inserting
    one disc every time.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个双人游戏，所以每个玩家都有一个颜色。一个玩家使用红色（*R*），另一个使用绿色（*G*）。玩家轮流进行，每次插入一个圆盘。
- en: We want feedback when either an event or an error occurs within the game. The
    output shows the status of the board after every move.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在游戏中发生事件或错误时得到反馈。输出显示每次移动后棋盘的状态。
- en: When no more discs can be inserted, the game finishes, and it is considered
    a draw.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当不能再插入圆盘时，游戏结束，被视为平局。
- en: If a player inserts a disc and connects more than three discs of his color in
    a straight vertical line, then that player wins.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家插入一个圆盘并连接了三个以上的同色圆盘，那么该玩家就赢了。
- en: The same happens in a horizontal line direction.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在水平线方向上也是一样的。
- en: The same happens in a diagonal line direction.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对角线方向上也是一样的。
- en: Test-last implementation of Connect 4
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Connect 4的测试后实现
- en: This is the traditional approach, focusing on problem-solving code rather than
    tests. Some people and companies forget about the value of automated testing and
    rely on users in what are called **user acceptance tests**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是传统的方法，侧重于解决问题的代码，而不是测试。一些人和公司忘记了自动化测试的价值，并依赖于用户所谓的**用户验收测试**。
- en: This kind of user acceptance test consists of recreating real-world scenarios
    in a controlled environment, ideally identical to production. Some users perform
    a lot of different tasks to verify the correctness of the application. If any
    of these actions fail, then the code is not accepted, as it is breaking some functionality
    or it is not working as expected.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用户验收测试包括在一个受控环境中重新创建真实世界的场景，理想情况下与生产环境完全相同。一些用户执行许多不同的任务来验证应用程序的正确性。如果这些操作中的任何一个失败，那么代码就不会被接受，因为它破坏了某些功能或者不符合预期的工作。
- en: 'Moreover, a great number of these companies also use unit testing as a way
    to perform early regression checks. These unit tests are created after the development
    process and they try to cover as much code as possible. Last of all, code coverage
    analysis is executed to get a trace of what is actually covered by those unit
    tests. These companies follow a single rule of thumb: the bigger the code coverage,
    the better the quality delivered.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多这些公司还使用单元测试作为进行早期回归检查的一种方式。这些单元测试是在开发过程之后创建的，并试图尽可能多地覆盖代码。最后，执行代码覆盖率分析以获得这些单元测试实际覆盖的内容。这些公司遵循一个简单的经验法则：代码覆盖率越高，交付的质量就越好。
- en: The main problem of this approach is that writing tests afterwards does nothing
    but demonstrates that the code behaves the way it has been programmed, which is
    not necessarily the way code is expected to behave. Also, focusing on code coverage
    leads to bad tests that turn our production code into immutable entities. Every
    modification we may want to add may cause several tests from different, unrelated
    parts of the code to fail. That fact means the cost of introducing changes becomes
    really high and performing any slight modification could end up being a nightmare
    and very expensive.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要问题是事后编写测试只能证明代码的行为方式是按照程序编写的方式，这未必是代码预期行为的方式。此外，专注于代码覆盖率会导致糟糕的测试，将我们的生产代码变成不可变的实体。我们可能想要添加的每个修改都可能导致代码中不相关部分的多个测试失败。这意味着引入更改的成本变得非常高，进行任何轻微的修改可能会变成一场噩梦，非常昂贵。
- en: To demonstrate some points described earlier, let's implement the Connect 4
    game using a TDD and not-TDD approach. The relevant code for each of the identified
    requirements is presented as we proceed further. This code isn't written incrementally,
    so some code snippets might contain a few code lines unrelated to the mentioned
    requirement.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示前面描述的一些要点，让我们使用TDD和非TDD方法来实现Connect 4游戏。随着我们进一步进行，每个确定需求的相关代码将被呈现出来。这些代码并非是逐步编写的，因此一些代码片段可能包含一些与所提到的需求无关的代码行。
- en: Requirement 1 – the game's board
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求1 - 游戏的棋盘
- en: Let us start with the first requirement.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个需求开始。
- en: The board is composed of seven horizontal and six vertical empty positions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘由七个水平和六个垂直的空位置组成。
- en: 'The implementation of this requirement is pretty straightforward. We just need
    the representation of an empty position and the data structure to hold the game.
    Note that the colors used by the players are also defined:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个需求的实现非常直接。我们只需要表示一个空位置和保存游戏的数据结构。请注意，玩家使用的颜色也已经定义：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Requirement 2 – introducing discs
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求2 - 插入圆盘
- en: This requirement introduces part of the logic of the game.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个需求介绍了游戏的一部分逻辑。
- en: Players introduce discs on the top of the columns. The introduced disc drops
    down the board if the column is empty. Future discs introduced in the same column
    will stack over the previous ones.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家在列的顶部放入圆盘。如果列为空，则放入的圆盘会下落到棋盘上。将来在同一列中放入的圆盘将堆叠在之前的圆盘上。
- en: 'In this part, board bounds become relevant. We need to mark what positions
    are already taken, using `Color.RED` to indicate them. Finally, the first `private`
    method is created. It is a helper method that calculates the number of discs introduced
    in a given column:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，棋盘边界变得相关。我们需要标记哪些位置已经被占据，使用`Color.RED`来指示它们。最后，创建了第一个`private`方法。这是一个帮助方法，用于计算在给定列中插入的圆盘数量：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Requirement 3 – player shifts
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求3 - 玩家轮换
- en: More game logic is introduced with this requirement.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个要求引入了更多的游戏逻辑。
- en: It is a two-person game, so there is one colour for each player. One player
    uses red (*R*) and the other one uses green (*G*). Players alternate turns, inserting
    one disc every time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个双人游戏，所以每个玩家有一种颜色。一个玩家使用红色（*R*），另一个使用绿色（*G*）。玩家轮流进行，每次插入一个圆盘。
- en: 'We need to save the current player to determine which player is playing this
    turn. We also need a function to switch the players to recreate the logic of turns.
    Some lines of code become relevant in the `putDisc` function. Specifically, the
    board position assignment is made using the current player, and it is switched
    after every move, as the game rules say:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要保存当前玩家以确定哪个玩家在进行这一轮。我们还需要一个函数来切换玩家以重新创建轮换的逻辑。在`putDisc`函数中，一些代码变得相关。具体来说，使用当前玩家进行棋盘位置分配，并且按照游戏规则在每次移动后进行切换：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Requirement 4 – the game's output
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求4 - 游戏的输出
- en: A few outputs should be added to let the players know the current status of
    the game.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 应该添加一些输出，让玩家知道游戏的当前状态。
- en: We want feedback when either an event or an error occurs within the game. The
    output shows the status of the board after every move.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在游戏中发生事件或错误时得到反馈。输出显示每次移动后棋盘的状态。
- en: 'No output channel is specified. To make it easier, we decided to use the system
    standard output to print an event when it occurs. A few lines have been added
    on every action to let the user know about the status of the game:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有指定输出通道。为了更容易，我们决定使用系统标准输出来在事件发生时打印事件。在每个动作上添加了几行代码，以便让用户了解游戏的状态：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Requirement 5 – win conditions (I)
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求5 - 胜利条件（I）
- en: The first game has a finished condition.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一局游戏有一个结束条件。
- en: When no more discs can be inserted, the game finishes and it is considered a
    draw.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当不能再插入圆盘时，游戏结束并被视为平局。
- en: 'The following code shows one of the possible implementations:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了可能的一种实现：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Requirement 6 – win condition (II)
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求6 - 胜利条件（II）
- en: The first win condition.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个胜利条件。
- en: If a player inserts a disc and connects more than three discs of his colour
    in a straight vertical line, then that player wins.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个玩家插入一个圆盘并连接了三个以上的同色圆盘，那么该玩家获胜。
- en: 'The `checkWinCondition` private method implements this rule by scanning whether
    or not the last move is a winning one:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkWinCondition`私有方法通过扫描最后一步是否是获胜来实现这一规则：'
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Requirement 7 – win condition (III)
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求7 - 胜利条件（III）
- en: This is the same win condition, but in a different direction.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同的胜利条件，但是在不同的方向上。
- en: If a player inserts a disc and connects more than three discs of his color in
    a straight horizontal line, then that player wins.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个玩家插入一个圆盘并连接了三个以上的同色圆盘，那么该玩家获胜。
- en: 'A few lines to implement this rule are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一规则的几行代码如下：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Requirement 8 – win condition (IV)
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求8 - 胜利条件（IV）
- en: The last requirement is the last win condition. It is pretty similar to the
    last two; in this case, in a diagonal direction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要求是最后的胜利条件。这与前两个非常相似；在这种情况下，是在对角线方向上。
- en: If a player inserts a disc and connects more than three discs of his color in
    a straight diagonal line, then that player wins.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个玩家插入一个圆盘并连接了三个以上的同色圆盘，那么该玩家获胜。
- en: 'This is a possible implementation for this last requirement. The code is very
    similar to the other win conditions because the same statement must be fulfilled:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对最后一个要求的一个可能的实现。这段代码与其他胜利条件非常相似，因为必须满足相同的条件：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What we have got is a class with one constructor, three public methods, and
    three private methods. The logic of the application is distributed among all methods.
    The biggest flaw here is that this class is very difficult to maintain. The crucial
    methods, such as `checkWinCondition`, are non-trivial, with potential for bug
    entries in future modifications.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个带有一个构造函数、三个公共方法和三个私有方法的类。应用程序的逻辑分布在所有方法中。这里最大的缺陷是这个类非常难以维护。关键的方法，比如`checkWinCondition`，都是非平凡的，有潜在的bug可能在未来的修改中出现。
- en: If you want to take a look at the full code, you can find it in the [https://bitbucket.org/vfarcic/tdd-java-ch05-design.git](https://bitbucket.org/vfarcic/tdd-java-ch05-design.git)
    repository.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看完整的代码，你可以在[https://bitbucket.org/vfarcic/tdd-java-ch05-design.git](https://bitbucket.org/vfarcic/tdd-java-ch05-design.git)存储库中找到。
- en: We made this small example to demonstrate the common problems with this approach.
    Topics such as the SOLID principle requires a bigger project to become more illustrative.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制作了这个小例子来演示这种方法的常见问题。像SOLID原则这样的主题需要一个更大的项目来更具说明性。
- en: In large projects with hundreds of classes, the problems become hours wasted
    in a sort of surgical development. Developers spend a lot of their time investigating
    tricky code and understanding how it works, instead of creating new features.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有数百个类的大型项目中，问题变成了在一种类似手术的开发中浪费了数小时。开发人员花费大量时间调查棘手的代码并理解其工作原理，而不是创建新功能。
- en: The TDD or test-first implementation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD或先测试的实现
- en: At this time, we know how TDD works—writing tests before, implementation after
    tests, and refactoring later on. We are going to pass through the process and
    only show the final result for each requirement. It is left to you to figure out
    the iterative Red-Green-Refactor process. Let's make this more interesting, if
    possible, by using a Hamcrest framework in our tests.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们知道TDD是如何工作的——在测试之前编写测试，然后实现测试，最后进行重构。我们将通过这个过程，只展示每个要求的最终结果。剩下的就是让你去理解迭代的红绿重构过程。如果可能的话，让我们在测试中使用Hamcrest框架，让这更有趣。
- en: Hamcrest
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hamcrest
- en: As described in [Chapter 2](2b33a0f7-c645-4266-891b-8572251f083e.xhtml), *Tools,
    Frameworks, and Environment*, Hamcrest improves our test's readability. It makes
    assertions more semantic and comprehensive when complexity is reduced by using
    **matchers**. When a test fails, the error shown becomes more expressive by interpreting
    the matchers used in the assertion. A message could also be added by the developer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](2b33a0f7-c645-4266-891b-8572251f083e.xhtml)所述，*工具、框架和环境*，Hamcrest提高了我们测试的可读性。它使断言更有语义和全面性，通过使用**匹配器**减少了复杂性。当测试失败时，通过解释断言中使用的匹配器，显示的错误更具表现力。开发人员还可以添加消息。
- en: The `Hamcrest` library is full of different matchers for different object types
    and collections. Let's start coding and get a taste of it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hamcrest`库中充满了不同类型对象和集合的不同匹配器。让我们开始编码，尝试一下。'
- en: Requirement 1 – the game's board
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求1 - 游戏的棋盘
- en: We will start with the first requirement.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从第一个要求开始。
- en: The board is composed of seven horizontal and six vertical empty positions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘由七个水平和六个垂直的空位置组成。
- en: There is no big challenge with this requirement. The board bounds are specified,
    but there's no described behavior in it; just the consideration of an empty board
    when the game starts. That means zero discs when the game begins. However, this
    requirement must be taken into account later on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个要求没有太大的挑战。棋盘边界已经指定，但在其中没有描述行为；只是在游戏开始时考虑了一个空棋盘。这意味着游戏开始时没有圆盘。然而，这个要求以后必须考虑。
- en: 'This is how the test class looks for this requirement. There''s a method to
    initialize the `tested` class to use a completely fresh object in each test. There''s
    also the first test to verify that there''s no disc when we start the game, meaning
    that all board positions are empty:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是针对此要求的测试类的外观。有一个方法来初始化`tested`类，以便在每个测试中使用一个完全新的对象。还有第一个测试来验证游戏开始时没有圆盘，这意味着所有的棋盘位置都是空的：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the TDD implementation of the previous specification. Observe the simplicity
    of the given solution for this first requirement; a simple method returning the
    result in a single line:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前述规范的TDD实现。观察给出的解决方案对于这个第一个要求的简单方法，一个简单的方法在一行中返回结果：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Requirement 2 – introducing discs
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求2 - 引入圆盘
- en: This is the implementation for the second requirement.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个要求的实现。
- en: Players introduce discs on the top of the columns. An introduced disc drops
    down the board if the column is empty. Future discs introduced in the same column
    will stack over the previous ones.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家在列的顶部放入圆盘。如果列为空，则放入的圆盘会下落到棋盘上。未来放入同一列的圆盘将堆叠在前面的圆盘上。
- en: 'We can split this requirement into the following tests:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此要求分为以下测试：
- en: When a disc is inserted into an empty column, its position is `0`
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个圆盘插入到一个空列中时，它的位置是`0`
- en: When a second disc is inserted into the same column, its position is `1`
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当第二个圆盘插入到同一列时，它的位置是`1`
- en: When a disc is inserted into the board, the total number of discs increases
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个圆盘插入到棋盘上时，圆盘的总数增加
- en: When a disc is put outside the boundaries, a `Runtime Exception` is thrown
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个圆盘放在边界外时，会抛出`Runtime Exception`
- en: When a disc is inserted into a column and there's no room available for it,
    then a `Runtime Exception` is thrown
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个圆盘插入到一列中，没有可用的空间时，就会抛出`Runtime Exception`
- en: Also, these other tests are derived from the first requirement. They are related
    to the board limits or board behavior.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些其他测试源自第一个要求。它们与棋盘限制或棋盘行为有关。
- en: 'The Java implementation of the aforementioned tests is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述测试的Java实现如下：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is the necessary code to satisfy the tests:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是满足测试的必要代码：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Requirement 3 – player shifts
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求3 - 玩家轮换
- en: The third requirement relates to the game logic.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个要求涉及游戏逻辑。
- en: It is a two-person game, so there is one colour for each player. One player
    uses red (*R*) and the other one uses green (*G*). Players alternate turns, inserting
    one disc every time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个双人游戏，所以每个玩家都有一个颜色。一个玩家使用红色（*R*），另一个玩家使用绿色（*G*）。玩家轮流进行，每次插入一个圆盘。
- en: 'These tests cover the verification of the new functionality. For the sake of
    simplicity, the red player will always start the game:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试涵盖了新功能的验证。为了简单起见，红色玩家将始终开始游戏：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A couple of methods need to be created to cover this functionality. The `switchPlayer`
    method is called before returning the row in the `putDiscInColumn` method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建一些方法来覆盖这个功能。在`putDiscInColumn`方法中返回行之前调用`switchPlayer`方法：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Requirement 4 – the game's output
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求4 - 游戏输出
- en: Next, we should let the player know the status of the game.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该让玩家知道游戏的状态。
- en: We want feedback when either an event or an error occurs within the game. The
    output shows the status of the board on every move.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在游戏中发生事件或错误时得到反馈。输出显示每次移动时棋盘的状态。
- en: 'As we are throwing exceptions when an error occurs, this is already covered,
    so we only need to implement these two tests. Furthermore, for the sake of testability,
    we need to introduce a parameter within the constructor. By introducing this parameter,
    the output becomes easier to test:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时我们抛出异常，这已经涵盖了，所以我们只需要实现这两个测试。此外，为了便于测试，我们需要在构造函数中引入一个参数。通过引入这个参数，输出变得更容易测试：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'One possible implementation is to pass the preceding tests. As you can see,
    the class constructor now has one parameter. This parameter is used in several
    methods to print the event or action description:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的实现是通过前面的测试。如您所见，类构造函数现在有一个参数。这个参数在几个方法中用于打印事件或动作描述：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Requirement 5 – win condition (I)
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求5 - 胜利条件（I）
- en: This requirement tells the system whether the game is finished.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此要求告诉系统游戏是否结束。
- en: When no more discs can be inserted, the game finishes and it is considered a
    draw.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当不能再插入圆盘时，游戏结束，被视为平局。
- en: 'There are two conditions to test. The first condition is that new game must
    be unfinished; the second condition is that full board games must be finished:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个条件需要测试。第一个条件是新游戏必须未完成；第二个条件是完整的棋盘游戏必须完成：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'An easy and simple solution to these two tests is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试的一个简单解决方案如下：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Requirement 6 – win condition (II)
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求6 - 获胜条件（II）
- en: This is the first win condition requirement for players.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是玩家的第一个获胜条件要求。
- en: If a player inserts a disc and connects more than three discs of his color in
    a straight vertical line, then that player wins.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家插入一个圆盘并连接他的颜色超过三个圆盘成一条垂直直线，那么该玩家获胜。
- en: 'In fact, this requires one single check. If the current inserted disc connects
    other three discs in a vertical line, the current player wins the game:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这只需要一次检查。如果当前插入的圆盘连接其他三个圆盘成一条垂直线，当前玩家就赢得了比赛：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There are a couple of changes to the `putDiscInColumn` method. Also, a new
    method called `checkWinner` has been created:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`putDiscInColumn`方法有一些改变。还创建了一个名为`checkWinner`的新方法：'
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Requirement 7 – win condition (III)
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求7 - 获胜条件（III）
- en: This is the second win condition, which is pretty similar to the previous one.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个获胜条件，与前一个条件非常相似。
- en: If a player inserts a disc and connects more than three discs of his color in
    a straight horizontal line, then that player wins.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家插入一个圆盘并连接他的颜色超过三个圆盘成一条水平直线，那么该玩家获胜。
- en: 'This time, we are trying to win the game by inserting discs into adjacent columns:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们试图通过将圆盘插入相邻的列来赢得比赛：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The code to pass this test is put into the `checkWinners` method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个测试的代码被放入了`checkWinners`方法中：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Requirement 8 – win condition (IV)
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求8 - 获胜条件（IV）
- en: The last requirement is the last win condition.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的要求是最后的获胜条件。
- en: If a player inserts a disc and connects more than three discs of his color in
    a straight diagonal line, then that player wins.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家插入一个圆盘并连接他的颜色超过三个圆盘成一条对角线，那么该玩家获胜。
- en: 'We need to perform valid game movements to achieve the condition. In this case,
    we need to test both diagonals across the board: from top-right to bottom-left
    and from bottom-right to top-left. The following tests use a list of columns to
    recreate a full game to reproduce the scenario under test:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行有效的游戏动作来实现这个条件。在这种情况下，我们需要测试整个棋盘上的对角线：从右上到左下，从右下到左上。以下测试使用列的列表来重新创建一个完整的游戏，以重现测试场景：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Again, the `checkWinner` method needs to be modified, adding new board verifications:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`checkWinner`方法需要修改，添加新的棋盘验证：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Final considerations
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的考虑
- en: 'Using TDD, we got a class with a constructor, five public methods, and six
    private methods. In general, all methods look pretty simple and easy to understand.
    In this approach, we also got a big method to check winner conditions: `checkWinner`.
    The advantage is that with this approach we got a bunch of useful tests to guarantee
    that future modifications do not alter the behavior of the method accidentally,
    allowing for the introduction of new changes painlessly. Code coverage wasn''t
    the goal, but we got a really high percentage.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD，我们得到了一个构造函数，五个公共方法和六个私有方法的类。总的来说，所有方法看起来都很简单易懂。在这种方法中，我们还得到了一个检查获胜条件的大方法：`checkWinner`。优点是，通过这种方法，我们得到了一堆有用的测试，以确保未来的修改不会意外地改变方法的行为，从而可以轻松引入新的更改。代码覆盖率不是目标，但我们得到了一个非常高的百分比。
- en: Additionally, for testing purposes, we refactored the constructor of the class
    to accept the output channel as a parameter (**dependency injection**). If we
    need to modify the way the game status is printed, it will be easier that way
    than replacing all the uses in the traditional approach. Hence, it is more extensible.
    In the test-last approach, we have been abusing the `System.println` method and
    it will be really tedious task if we decide to change all the occurrences for
    any other thing.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，为了测试目的，我们重构了类的构造函数，接受输出通道作为参数（依赖注入）。如果我们需要修改游戏状态的打印方式，这种方式将比传统方式更容易。因此，它更具可扩展性。在测试后的方法中，我们一直在滥用`System.println`方法，如果我们决定更改所有出现的内容，这将是一个非常繁琐的任务。
- en: 'In large projects, when you detect that a great number of tests must be created
    for a single class, this enables you to split the class following the Single Responsibility
    Principle. As the output printing was delegated to an external class passed in
    a parameter in initialization, a more elegant solution would be to create a class
    with high-level printing methods. That would keep the printing logic separated
    from the game logic. Like the huge code coverage shown in the following image,
    these are a few examples of the benefits of good design using TDD:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型项目中，当您发现必须为单个类创建大量测试时，这使您能够遵循单一职责原则来拆分类。由于输出打印被委托给了一个在初始化参数中传递的外部类，一个更优雅的解决方案是创建一个具有高级打印方法的类。这将使打印逻辑与游戏逻辑分离。就像下图所示的大量代码覆盖率一样，这些都是使用TDD进行良好设计的好处的几个例子：
- en: '![](img/e3d0f91a-75fd-4966-9fb6-643ac5ea040c.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3d0f91a-75fd-4966-9fb6-643ac5ea040c.png)'
- en: The code of this approach is available at [https://bitbucket.org/vfarcic/tdd-java-ch05-design.git](https://bitbucket.org/vfarcic/tdd-java-ch05-design.git).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的代码可在[https://bitbucket.org/vfarcic/tdd-java-ch05-design.git](https://bitbucket.org/vfarcic/tdd-java-ch05-design.git)找到。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we briefly talked about software design and a few basic design
    principles. We implemented a fully functional version of the board game Connect
    4 using two approaches—traditional and TDD.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要讨论了软件设计和一些基本的设计原则。我们使用了传统和TDD两种方法来实现了一个完全功能的连四棋盘游戏。
- en: We analyzed both solutions in terms of pros and cons, and used a Hamcrest framework
    to empower our tests.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析了两种解决方案的优缺点，并使用Hamcrest框架来增强我们的测试。
- en: Finally, we concluded that good design and good practices can be performed by
    both approaches, but TDD is a better approach.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得出结论，良好的设计和良好的实践可以通过两种方法来实现，但TDD是更好的方法。
- en: 'For further information about the topics that this chapter covers, refer to
    two highly recommended books written by Robert C. Martin: *Clean Code: A Handbook
    of Agile Software Craftsmanship* and *Agile Software Development: Principles,
    Patterns, and Practices*.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章涵盖的主题的更多信息，请参考罗伯特·C·马丁所著的两本高度推荐的书籍：《代码整洁之道：敏捷软件工艺》和《敏捷软件开发：原则、模式和实践》。
