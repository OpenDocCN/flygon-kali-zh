- en: Chapter 5. Container Linking and Docker DNS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。容器链接和Docker DNS
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Verifying a host-based DNS configuration inside a container
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证容器内的基于主机的DNS配置
- en: Overriding the default name resolution settings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖默认名称解析设置
- en: Configuring links for name and service resolution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置名称和服务解析的链接
- en: Leveraging Docker DNS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Docker DNS
- en: Creating Docker DNS aliases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Docker DNS别名
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: I’ve made a point in earlier chapters to point out that Docker does a lot of
    things for you in the network space. As we’ve already seen, having Docker manage
    IP allocations through IPAM is a huge benefit that’s not inherently obvious when
    you start using Docker. Another thing that Docker provides for you is DNS resolution.
    As we’ll see in this chapter, there are multiple levels of name and service resolution
    that Docker can provide. As Docker has matured, so have the options to provide
    these types of services. In this chapter, we’ll start to review basic name resolution
    and how a container knows which DNS server to use. We’ll then cover container
    linking and see how Docker can tell containers about other containers and the
    services they host. Finally, we’ll walk through some of the DNS enhancements that
    came along with the addition of user-defined networks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我已经指出Docker在网络空间为您做了很多事情。正如我们已经看到的，通过IPAM管理IP分配是使用Docker时并不明显的巨大好处。Docker为您提供的另一项服务是DNS解析。正如我们将在本章中看到的，Docker可以提供多个级别的名称和服务解析。随着Docker的成熟，提供这些类型的服务的选项也在不断增加。在本章中，我们将开始审查基本的名称解析以及容器如何知道使用哪个DNS服务器。然后，我们将涵盖容器链接，并了解Docker如何告诉容器有关其他容器和它们托管的服务。最后，我们将介绍随着用户定义网络的增加而带来的一些DNS增强功能。
- en: Verifying a host-based DNS configuration inside a container
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证容器内的基于主机的DNS配置
- en: You might not realize it but Docker, by default, is providing your containers
    a means to do basic name resolution. Docker passes name resolution options from
    the Docker host, directly into the container. The result is that a spawned container
    can natively resolve anything that the Docker host itself can. The mechanics used
    by Docker to achieve name resolution in a container are elegantly simple. In this
    recipe, we’ll walk through how this is done and how you can verify that it’s working
    as expected.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能没有意识到，但默认情况下，Docker为您的容器提供了基本的名称解析手段。Docker将名称解析选项从Docker主机直接传递到容器中。结果是，生成的容器可以本地解析Docker主机本身可以解析的任何内容。Docker用于在容器中实现名称解析的机制非常简单。在本教程中，我们将介绍如何完成这项工作以及如何验证它是否按预期工作。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we’ll be demonstrating the configuration on a single Docker
    host. It is assumed that this host has Docker installed and that Docker is in
    its default configuration. We’ll be altering name resolution settings on the host,
    so you’ll need root-level access.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将演示单个Docker主机上的配置。假设该主机已安装Docker，并且Docker处于默认配置状态。我们将在主机上更改名称解析设置，因此您需要root级别的访问权限。
- en: How to do it…
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤：
- en: 'Let’s start a new container on our host `docker1` and examine how the container
    handles name resolution:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的主机`docker1`上启动一个新的容器，并检查容器如何处理名称解析：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It would appear that the container has the ability to resolve DNS names. If
    we look at our local Docker host and run the same test, we should get similar
    results:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来容器有能力解析DNS名称。如果我们查看我们的本地Docker主机并运行相同的测试，我们应该会得到类似的结果：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In addition, just like our Docker host, the container can also resolve local
    DNS records associated with the local domain `lab.lab`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，就像我们的Docker主机一样，容器也可以解析与本地域`lab.lab`相关的本地DNS记录：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ll notice that I didn’t need to specify a fully qualified domain name in
    order to resolve the host name `docker4` in the domain `lab.lab`. At this point,
    it’s safe to assume that the container is receiving some sort of intelligent update
    from the Docker host that provides it relevant information about the local DNS
    configuration.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，我不需要指定一个完全合格的域名来解析域`lab.lab`中的主机名`docker4`。此时，可以安全地假设容器正在从Docker主机接收某种智能更新，为其提供有关本地DNS配置的相关信息。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `resolv.conf` file is generally where you define a Linux system’s
    name resolution parameters. In many cases, it is altered automatically by configuration
    information from other places. However, regardless of how it’s altered, it should
    always be the source of truth for how the system handles name resolution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`resolv.conf`文件通常是您定义Linux系统名称解析参数的地方。在许多情况下，它会被其他地方的配置信息自动更改。但是，无论如何更改，它都应该始终是系统处理名称解析的真相来源。
- en: 'To see what the container is receiving, let’s examine the container’s `resolv.conf`
    file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看容器正在接收的内容，让我们检查容器的`resolv.conf`文件：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, the container has learned that the local DNS server is `10.20.30.13`
    and that the local DNS search domain is `lab.lab`. Where did it get this information?
    The solution is rather simple. When a container starts, Docker generates instances
    of the following three files for each container spawned and saves it with the
    container configuration:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，容器已经学会了本地DNS服务器是`10.20.30.13`，本地DNS搜索域是`lab.lab`。它是从哪里获取这些信息的？答案相当简单。当容器启动时，Docker为每个生成的容器实例生成以下三个文件的实例，并将其保存在容器配置中：
- en: '`/etc/hostname`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/hostname`'
- en: '`/etc/hosts`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/hosts`'
- en: '`/etc/resolv.conf`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/resolv.conf`'
- en: 'These files are stored as part of the container configuration and then mounted
    into the container. We can use the `findmnt` tool from within the container to
    examine the source of the mounts:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件作为容器配置的一部分存储，然后挂载到容器中。我们可以使用容器内的`findmnt`工具来检查挂载的来源：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So while the container thinks that it has local copies of the `hostname`, `hosts`,
    and `resolv.conf` file in its `/etc/` directory, the real files are actually located
    in the container's configuration directory (`/var/lib/docker/containers/`) on
    the Docker host.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然容器认为它在其`/etc/`目录中有`hostname`、`hosts`和`resolv.conf`文件的本地副本，但实际文件实际上位于Docker主机上的容器配置目录(`/var/lib/docker/containers/`)中。
- en: 'When you tell Docker to run a container, it does the following three things:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当您告诉Docker运行一个容器时，它会执行以下三件事：
- en: It examines the Docker host’s `/etc/resolv.conf` file and places a copy of it
    in the containers directory
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检查Docker主机的`/etc/resolv.conf`文件，并将其副本放在容器目录中
- en: It creates a `hostname` file in the container’s directory and assigns the container
    a unique `hostname`
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在容器的目录中创建一个`hostname`文件，并为容器分配一个唯一的`hostname`
- en: It creates a `hosts` file in the container's directory and adds relevant records
    including localhost and a record referencing the host itself
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在容器的目录中创建一个`hosts`文件，并添加相关记录，包括localhost和引用主机本身的记录
- en: Each time the container is restarted, the container’s `resolv.conf` file is
    updated based on the values found in the Docker host’s `resolv.conf` file. This
    means that any changes made to the `resolv.conf` file are lost each time the container
    is restarted. The `hostname` and `hosts` configuration files are also rewritten
    each time the container is restarted losing any changes made during the previous
    run.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每次容器重新启动时，容器的`resolv.conf`文件都会根据Docker主机`resolv.conf`文件中找到的值进行更新。这意味着每次容器重新启动时，对`resolv.conf`文件所做的任何更改都会丢失。`hostname`和`hosts`配置文件也会在每次容器重新启动时被重写，丢失在上一次运行期间所做的任何更改。
- en: 'To validate the configuration files a given container is using, we can inspect
    the container''s configuration for these variables:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证给定容器正在使用的配置文件，我们可以检查这些变量的容器配置：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As expected, these are the same mount paths we saw when we ran the `findmnt`
    command from within the container itself. These represent the exact mount path
    for each file into the containers `/etc/` directory for each respective file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，这些是我们在容器内部运行`findmnt`命令时看到的相同挂载路径。这些代表了每个文件的确切挂载路径到容器的`/etc/`目录中的每个相应文件。
- en: Overriding the default name resolution settings
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖默认的名称解析设置
- en: The method Docker uses to provide name resolution to containers works very well
    in most cases. However, there could be some instances where you want Docker to
    provide the containers with a DNS server other than the one the Docker host is
    configured to use. In these cases, Docker offers you a couple of options. You
    can tell the Docker service to provide a different DNS server for all the containers
    the service spawns. You can also manually override this setting at container runtime
    by providing a DNS server as an option to the `docker run` subcommand. In this
    recipe, we’ll show you your options for changing the default name resolution behavior
    as well as how to verify the settings worked.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Docker用于为容器提供名称解析的方法在大多数情况下都运行良好。然而，可能会有一些情况，您希望Docker为容器提供与Docker主机配置的DNS服务器不同的DNS服务器。在这些情况下，Docker为您提供了一些选项。您可以告诉Docker服务为所有服务生成的容器提供不同的DNS服务器。您还可以通过在`docker
    run`子命令中提供DNS服务器作为选项，手动覆盖此设置。在本教程中，我们将向您展示更改默认名称解析行为的选项以及如何验证设置是否有效。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll be demonstrating the configuration on a single Docker
    host. It is assumed that this host has Docker installed and that Docker is in
    its default configuration. We’ll be altering name resolution settings on the host,
    so you’ll need root-level access.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将演示单个Docker主机上的配置。假设这个主机已经安装了Docker，并且Docker处于默认配置。我们将在主机上更改名称解析设置，因此您需要root级别的访问权限。
- en: How to do it…
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: As we saw in the first recipe in this chapter, by default, Docker provides containers
    with the DNS server that the Docker host itself uses. This comes in the form of
    copying the host’s `resolv.conf` file and providing it to each spawned container.
    Along with the name server setting, this file also includes definitions for DNS
    search domains. Both of these options can be configured at the service level to
    cover any spawned containers as well as at the individual level.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章的第一个教程中看到的，默认情况下，Docker为容器提供Docker主机本身使用的DNS服务器。这是通过复制主机的`resolv.conf`文件并提供给每个生成的容器。除了名称服务器设置，该文件还包括DNS搜索域的定义。这两个选项都可以在服务级别进行配置，以覆盖任何生成的容器，也可以在个体级别进行配置。
- en: 'For the purpose of comparison, let’s start by examining the Docker host’s DNS
    configuration:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行比较，让我们首先检查Docker主机的DNS配置：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this configuration, we would expect that any container spawned on this
    host would receive the same name server and DNS search domain. Let’s spawn a container
    named `web8` to verify that this is working as expected:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个配置，我们期望在这个主机上生成的任何容器都会收到相同的名称服务器和DNS搜索域。让我们生成一个名为`web8`的容器，以验证这是否按预期工作：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As expected, the container receives the same configuration. Let’s now inspect
    the container and see if we see any DNS-related options defined:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，容器接收相同的配置。现在让我们检查容器，看看是否有任何与DNS相关的选项被定义：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because we’re using the default configuration, there is no reason to configure
    anything specific within the container in regard to DNS server or search domain.
    Each time the container starts, Docker will apply the settings for the host’s
    `resolv.conf` file to the container's DNS configuration files.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用默认配置，所以在容器内部针对DNS服务器或搜索域没有必要配置任何特定的内容。每次容器启动时，Docker都会将主机的`resolv.conf`文件的设置应用到容器的DNS配置文件中。
- en: 'If we’d prefer to have Docker give containers a different DNS server or DNS
    search domain, we can do so through Docker options. In this case, the two we’re
    interested in are:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望Docker为容器提供不同的DNS服务器或DNS搜索域，我们可以通过Docker选项来实现。在这种情况下，我们感兴趣的两个选项是：
- en: '`--dns=<DNS Server>`: Specify a DNS server address that Docker should provide
    to the containers'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dns=<DNS服务器>`：指定Docker应该为容器提供的DNS服务器地址'
- en: '`--dns-search=<DNS Search Domain>`: Specify a DNS search domain that Docker
    should provide to the containers'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dns-search=<DNS搜索域>`：指定Docker应该为容器提供的DNS搜索域'
- en: 'Let’s configure Docker to provide containers with a public DNS server (`4.2.2.2`)
    and a search domain of `lab.external`. We can do so by passing the following options
    to the Docker systemd drop-in file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置Docker以为容器提供一个公共DNS服务器（`4.2.2.2`）和一个搜索域`lab.external`。我们可以通过将以下选项传递给Docker
    systemd drop-in文件来实现：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once the options are configured, reload the systemd configuration, restart
    the service to load the new options, and restart our container `web8`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了选项，重新加载systemd配置，重新启动服务以加载新选项，并重新启动我们的容器`web8`：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You’ll note that, despite this container initially having the host's DNS server
    (`10.20.30.13`) and search domain (`lab.lab`), it now has the service-level DNS
    options we just specified. If you recall earlier, we saw that, when we inspected
    this container, it didn’t define a specific DNS server or search domain. Since
    none was specified, Docker now uses the settings from the Docker options that
    take priority. Although this provides some level of flexibility, it’s not yet
    truly flexible. At this point, any and all containers spawned on this server will
    be provided with the same DNS server and search domain. To be truly flexible,
    we should be able to have Docker alter the name resolution configuration on a
    per container level. As luck would have it, these options can also be provided
    directly at container runtime.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，尽管此容器最初具有主机的DNS服务器（`10.20.30.13`）和搜索域（`lab.lab`），但现在它具有我们刚刚指定的服务级DNS选项。如果您回想一下之前，我们看到，当我们检查这个容器时，它没有定义特定的DNS服务器或搜索域。由于没有指定，Docker现在使用优先级较高的Docker选项的设置。尽管这提供了一定程度的灵活性，但它还不够灵活。在这一点上，此服务器上生成的任何和所有容器都将提供相同的DNS服务器和搜索域。为了真正灵活，我们应该能够让Docker在每个容器级别上改变名称解析配置。幸运的是，这些选项也可以直接在容器运行时提供。
- en: '![How to do it…](graphics/B05453_05_01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_05_01.jpg)'
- en: The preceding figure defines the priority Docker uses when deciding what name
    resolution settings to apply to a container when it’s started. As we’ve seen in
    earlier chapters, settings defined at container runtime always take priority.
    If the settings aren’t defined there, Docker then looks to see if they are configured
    at the service level. If the settings aren’t there, it falls back to the default
    method of relying on the Docker host’s DNS settings.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表定义了Docker在启动容器时决定应用哪些名称解析设置时使用的优先级。正如我们在前几章中看到的那样，容器运行时定义的设置始终优先。如果那里没有定义设置，Docker然后会查看它们是否在服务级别上配置。如果那里没有设置，它将退回到依赖Docker主机的DNS设置的默认方法。
- en: 'For instance, we can launch a container named `web2` and provide different
    options:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以启动一个名为`web2`的容器并提供不同的选项：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we inspect the container, we’ll see that we now have the `dns` and `dns-search`
    fields defined as part of the container configuration:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查容器，我们会看到`dns`和`dns-search`字段现在作为容器配置的一部分被定义：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This ensures that, if the container is restarted, it will still have the same
    DNS settings that were initially provided the first time the container was run.
    Let’s make some slight changes to the Docker service to verify the priority is
    working as expected. Let’s change our Docker options to look like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了如果容器重新启动，它仍将具有最初在第一次运行容器时提供的相同的DNS设置。让我们对Docker服务进行一些微小的更改，以验证优先级是否按预期工作。让我们将我们的Docker选项更改为如下所示：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now restart the service and run the following container:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新启动服务并运行以下容器：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Because we didn’t provide any DNS-related options at container runtime, the
    next place we’d check would be the service-level options. Our Docker service-level
    options include a DNS search domain of `lab.external`. We’d expect the container
    to receive that search domain. However, since we don’t have a DNS server defined,
    we’ll need to fall back to the one configured on the Docker host itself.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在容器运行时没有提供任何与DNS相关的选项，所以我们需要检查的下一个地方将是服务级选项。我们的Docker服务级选项包括一个DNS搜索域`lab.external`。我们期望容器会收到该搜索域。然而，由于我们没有定义DNS服务器，我们需要回退到Docker主机本身上配置的DNS服务器。
- en: 'And now examine its `resolv.conf` file to make sure things worked as expected:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查它的`resolv.conf`文件，确保一切按预期工作：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Configuring links for name and service resolution
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为名称和服务解析配置链接
- en: Container linking provides a means for one container to easily communicate with
    another container on the same host. As we’ve seen in previous examples, most container-to-container
    communication has occurred through IP addresses. Container linking improves on
    this by allowing linked containers to communicate with each other by name. In
    addition to providing basic name resolution, it also provides a means to see what
    services a linked container is providing. In this recipe, we’ll review how to
    create container links as well as discuss some of their limitations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 容器链接提供了一种容器之间在同一主机上轻松通信的方式。正如我们在之前的例子中看到的，大多数容器之间的通信是通过IP地址进行的。容器链接通过允许链接的容器通过名称进行通信来改进了这一点。除了提供基本的名称解析外，它还提供了一种查看链接容器提供的服务的方法。在本教程中，我们将回顾如何创建容器链接，并讨论它们的一些局限性。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll be demonstrating the configuration on a single Docker
    host. It is assumed that this host has Docker installed and that Docker is in
    its default configuration. We’ll be altering name resolution settings on the host,
    so you’ll need root-level access.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将演示在单个Docker主机上的配置。假设该主机已安装Docker，并且Docker处于默认配置。我们将在主机上更改名称解析设置，因此您需要root级别的访问权限。
- en: How to do it…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The phrase *container linking* might imply to some that it involves some kind
    of network configuration or modification. In reality, container linking has very
    little to do with container networking. In the default mode, container linking
    provides a means for one container to resolve the name of another. For instance,
    let’s start two containers on our lab host `docker1`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 短语“容器链接”可能暗示着涉及某种网络配置或修改。实际上，容器链接与容器网络几乎没有关系。在默认模式下，容器链接提供了一种容器解析另一个容器名称的方法。例如，让我们在我们的实验主机`docker1`上启动两个容器：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice how, when I started the second container, I used a new flag named `--link`
    and referenced the container `web1`. We would now say that `web2` was linked to
    `web1`. However, they’re not really linked in any sort of way. A better description
    might be to say that `web2` is now aware of `web1`. Let’s connect to the container
    `web2` to show you what I mean:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我启动第二个容器时，我使用了一个名为 `--link` 的新标志，并引用了容器 `web1`。我们现在会说 `web2` 现在链接到 `web1`。但是，它们实际上并没有以任何方式链接。更好的描述可能是说
    `web2` 现在知道了 `web1`。让我们连接到容器 `web2`，以便向您展示我的意思：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It appears that the `web2` container is now able to resolve the container `web1`
    by name. This is because the linking process inserted records into the `web2`
    container''s `hosts` file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 `web2` 容器现在能够通过名称解析容器 `web1`。这是因为链接过程将记录插入到 `web2` 容器的 `hosts` 文件中：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this configuration, the `web2` container can reach the `web1` container
    either by the name we gave the container at runtime (`web1`) or the unique `hostname`
    Docker generated for the container (`88f9c8629668`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，`web2` 容器可以通过我们在运行时给容器的名称 (`web1`) 或 Docker 为容器生成的唯一 `hostname` 来到达 `web1`
    容器 (`88f9c8629668`)。
- en: 'In addition to the `hosts` file being updated, `web2` also generates some new
    environmental variables:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更新 `hosts` 文件之外，`web2` 还生成了一些新的环境变量：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You’ll notice many new environmental variables. Docker will copy any environmental
    variables from the linked container that were defined as part of the container.
    This includes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到许多新的环境变量。Docker 将复制来自链接容器的任何环境变量，这些环境变量是作为容器的一部分定义的。这包括：
- en: Environmental variables described in the Docker image. More specifically, any
    `ENV` variables from the images Dockerfile
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 镜像中描述的环境变量。更具体地说，来自镜像 Dockerfile 的任何 `ENV` 变量
- en: Environmental variables passed to the container at runtime through the `--env`
    or `-e` flag
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `--env` 或 `-e` 标志在运行时传递给容器的环境变量
- en: 'In this case, these three variables were defined as `ENV` variables in the
    image''s Dockerfile:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这三个变量在镜像的 Dockerfile 中被定义为 `ENV` 变量：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Because both container images have the same `ENV` variables defined, we’ll
    see the local variables as well as the same environmental variables from the container
    `web1` prefixed with `WEB1_ENV_`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因为两个容器镜像都定义了相同的 `ENV` 变量，我们将看到本地变量以及以 `WEB1_ENV_` 为前缀的来自容器 `web1` 的相同环境变量：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In addition, Docker also created six other environmental variables that describe
    the `web1` container as well as any of its exposed ports:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Docker 还创建了描述 `web1` 容器以及其任何暴露端口的其他六个环境变量：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Linking also allows you to specify aliases. For instance, let’s stop, remove,
    and respawn container `web2` using a slightly different syntax for linking:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 链接还允许您指定别名。例如，让我们使用稍微不同的链接语法停止、删除和重新生成容器 `web2`：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that, after the link definition, we inserted `a :webserver.` The name
    after the colon represents the alias for the link. In this case, I’ve specified
    an alias for the container `web1` as `webserver`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在链接定义之后，我们插入了 `a :webserver.` 冒号后面的名称表示链接的别名。在这种情况下，我指定了容器 `web1` 的别名为 `webserver`。
- en: 'If we examine the `web2` container, we’ll see that the alias is now also listed
    in the `hosts` file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查 `web2` 容器，我们会看到别名现在也列在 `hosts` 文件中：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Aliases also impact the environmental variables created during linking. Rather
    than using the container name, they’ll instead use the alias:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 别名还会影响链接期间创建的环境变量。它们不会使用容器名称，而是使用别名：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this point, you might be wondering how dynamic this is. After all, Docker
    is providing this functionality by updating static files in each container. What
    happens if a container’s IP address changes? For instance, let’s stop the container
    `web1` and start a new container named `web3` using the same image:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能想知道这有多动态。毕竟，Docker通过更新每个容器中的静态文件来提供这个功能。如果容器的IP地址发生变化会发生什么？例如，让我们停止容器`web1`，然后使用相同的镜像启动一个名为`web3`的新容器：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you’ll recall from earlier, the container `web1` had an IP address of `172.17.0.2`
    allocated to it. Since I stopped the container, Docker will release that IP address
    reservation making it available to be reassigned to the next container we start.
    Let’s check the IP address assigned to the container `web3`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得之前，容器`web1`的IP地址是`172.17.0.2`。由于我停止了容器，Docker将释放该IP地址的保留，使其可以重新分配给我们启动的下一个容器。让我们检查分配给容器`web3`的IP地址：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As expected, `web3` took the now open IP address of `172.17.0.2` that previously
    belonged to the `web1` container. We can also verify that the container `web2`
    still believes that this IP address belongs to the `web1` container:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，`web3`获取了先前属于`web1`容器的现在开放的IP地址`172.17.0.2`。我们还可以验证容器`web2`仍然认为这个IP地址属于`web1`容器：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we start the container `web1` once again, we should see that it will get
    a new IP address allocated to it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次启动容器`web1`，我们应该看到它将获得一个新的分配给它的IP地址：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we check the container `web2` again, we should see that Docker has updated
    it to reference the `web1` container’s new IP address:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次检查容器`web2`，我们应该看到Docker已经更新它以引用`web1`容器的新IP地址：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, while Docker takes care of updating the `hosts` file with the new
    IP address, it will not take care of updating any of the environmental variables
    to reflect the new IP address:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然Docker负责更新`hosts`文件中的新IP地址，但它不会负责更新任何环境变量以反映新的IP地址：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In addition, it should be pointed out that the link is only one way. That is,
    this link does not cause the container `web1` to become aware of the `web2` container.
    `Web1` will not receive the host records or the environmental variables referencing
    the `web2` container:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，应该指出，这个链接只是单向的。也就是说，这个链接不会使容器`web1`意识到`web2`容器。`Web1`不会接收主机记录或引用`web2`容器的环境变量：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Another reason to provision links is when you use Docker **Inter-Container
    Connectivity** (**ICC**) mode set to `false`. As we’ve discussed previously, ICC
    prevents any containers on the same bridge from talking directly to each other.
    This forces them to talk to each other only though published ports. Linking provides
    a mechanism to override the default ICC rules. To demonstrate, let’s stop and
    remove all the containers on our host `docker1` and then add the following Docker
    option to the systemd drop-in file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个配置链接的原因是当您将Docker **容器间连接**（**ICC**）模式设置为`false`时。正如我们之前讨论过的，ICC阻止同一网桥上的任何容器直接交流。这迫使它们只能通过发布的端口进行交流。链接提供了一个机制来覆盖默认的ICC规则。为了演示，让我们停止并删除主机`docker1`上的所有容器，然后将以下Docker选项添加到systemd
    drop-in文件中：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now reload the systemd configuration, restart the service, and start the following
    containers:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新加载systemd配置，重新启动服务，并启动以下容器：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With ICC mode on, you’ll notice that containers can’t talk directly to each
    other:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在ICC模式下，您会注意到容器无法直接交流：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding example, `web2` is not able to access the web servers on `web1`.
    Now, let’s delete and recreate the `web2` container, this time linking it to `web1`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`web2`无法访问`web1`上的Web服务器。现在，让我们删除并重新创建`web2`容器，这次将其链接到`web1`：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can see that, with the link in place, the communication is allowed as expected.
    Once again, just like the link, this access is allowed in one direction.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，链接建立后，通信按预期允许。再次强调，就像链接一样，这种访问是单向允许的。
- en: It should be noted that linking works differently when using user-defined networks.
    In this recipe, we covered what are now being named **legacy links**. Linking
    with user-defined networks will be covered in the next two recipes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，在使用用户定义网络时，链接的工作方式不同。在本教程中，我们涵盖了现在被称为**传统链接**的内容。连接到用户定义网络将在接下来的两个教程中介绍。
- en: Leveraging Docker DNS
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Docker DNS
- en: The introduction of user-defined networks signaled a big change in Docker networking.
    While the ability to provision custom networks was the big news, there were also
    major enhancements in name resolution. User-defined networks can benefit from
    what’s being named **embedded DNS**. The Docker engine itself now has the ability
    to provide name resolution to all of the containers. This is a marked improvement
    from the legacy solution where the only means for name resolution was external
    DNS or linking, which relied on the `hosts` file. In this recipe, we’ll walk through
    how to use and configure embedded DNS.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义网络的引入标志着Docker网络的重大变化。虽然提供自定义网络的能力是重大新闻，但名称解析也有了重大改进。用户定义网络可以受益于被称为**嵌入式DNS**的功能。Docker引擎本身现在具有为所有容器提供名称解析的能力。这是与传统解决方案相比的显著改进，传统解决方案中名称解析的唯一手段是外部DNS或依赖`hosts`文件的链接。在本教程中，我们将介绍如何使用和配置嵌入式DNS。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll be demonstrating the configuration on a single Docker
    host. It is assumed that this host has Docker installed and that Docker is in
    its default configuration. We’ll be altering name resolution settings on the host,
    so you’ll need root-level access.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将演示在单个Docker主机上的配置。假设该主机已安装了Docker，并且Docker处于默认配置状态。我们将在主机上更改名称解析设置，因此您需要root级别的访问权限。
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'As mentioned, the embedded DNS system only works on user-defined Docker networks.
    That being said, let’s provision a user-defined network and then start a simple
    container on it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，嵌入式DNS系统仅在用户定义的Docker网络上运行。也就是说，让我们提供一个用户定义的网络，然后在其上启动一个简单的容器：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As we saw in an earlier recipe, by default, Docker pulls the name resolution
    configuration from the Docker host and provides it to the container. This behavior
    can be changed by providing different DNS servers or search domains either at
    the service level or at container runtime. In the case of containers connected
    to a user-defined network, the DNS settings provided to the container are slightly
    different. For instance, let’s look at the `resolv.conf` file for the container
    we just connected to the user-defined bridge `mybridge1`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的教程中看到的，默认情况下，Docker从Docker主机获取名称解析配置，并将其提供给容器。可以通过在服务级别或容器运行时提供不同的DNS服务器或搜索域来更改此行为。对于连接到用户定义网络的容器，提供给容器的DNS设置略有不同。例如，让我们看看刚刚连接到用户定义桥接`mybridge1`的容器的`resolv.conf`文件：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice how the name server for this container is now `127.0.0.11`. This IP address
    represents Docker’s embedded DNS server and will be used for any container, which
    is connected to a user-defined network. It is a requirement that any container
    connected to a user-defined network should use the embedded DNS server.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个容器的名称服务器现在是`127.0.0.11`。这个IP地址代表Docker的嵌入式DNS服务器，并将用于任何连接到用户定义网络的容器。任何连接到用户定义网络的容器都应该使用嵌入式DNS服务器。
- en: 'Containers not initially started on a user-defined network will get updated
    the moment they connect to a user-defined network. For instance, let’s start another
    container named `web2` but have it use the default `docker0` bridge:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最初未在用户定义的网络上启动的容器将在连接到用户定义的网络时进行更新。例如，让我们启动另一个名为`web2`的容器，但让它使用默认的`docker0`桥接：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we now connect the `web2` container to our user-defined network, Docker
    will update the name server to reflect the embedded DNS server:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在将`web2`容器连接到我们自定义的网络，Docker将更新名称服务器以反映嵌入式DNS服务器：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Since both our containers are now connected to the same user-defined network,
    they can now reach each other by name:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的两个容器现在都连接到同一个用户定义的网络，它们现在可以通过名称相互访问：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You’ll note that the name resolution is bidirectional, and it works inherently
    without the use of any links. That being said, with user-defined networks, we
    can still define links for the purpose of creating local aliases. For instance,
    let’s stop and remove both containers `web1` and `web2` and reprovision them as
    follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到名称解析是双向的，并且它在没有任何链接的情况下固有地工作。也就是说，使用用户定义的网络，我们仍然可以定义链接，以便创建本地别名。例如，让我们停止并删除`web1`和`web2`两个容器，然后重新配置它们如下：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The first interesting item to point out is that Docker lets us link to a container
    that did not yet exist. When we ran the container `web1`, we asked Docker to link
    it to the container `web2`. At that point, `web2` didn’t exist. This is a notable
    difference in how links work with the embedded DNS server. In legacy linking,
    Docker needed to know the target container information prior to making the link.
    This was because it had to manually update the source container''s host file and
    environmental variables. The second interesting item is that aliases are no longer
    listed in the container''s `hosts` file. If we look at the `hosts` file on each
    container, we’ll see that the linking no longer generates entries:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要指出的第一件有趣的事情是，Docker允许我们链接到尚不存在的容器。当我们运行容器`web1`时，我们要求Docker将其链接到容器`web2`。那时，`web2`并不存在。这是链接与嵌入式DNS服务器工作方式的一个显着差异。在传统的链接中，Docker需要在进行链接之前知道目标容器的信息。这是因为它必须手动更新源容器的主机文件和环境变量。第二个有趣的事情是，别名不再列在容器的`hosts`文件中。如果我们查看每个容器的`hosts`文件，我们会发现链接不再生成条目：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'All of the resolution is now occurring in the embedded DNS server. This includes
    keeping track of defined aliases and their scope. So even without host records,
    each container is able to resolve the other containers alias through the embedded
    DNS server:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的解析都是在嵌入式DNS服务器中进行的。这包括跟踪定义的别名及其范围。因此，即使没有主机记录，每个容器也能够通过嵌入式DNS服务器解析其他容器的别名：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The aliases created have a scope that is local to the container itself. For
    instance, a third container on the same user-defined network is not able to resolve
    the aliases created as part of the links:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的别名的范围仅限于容器本身。例如，同一用户定义的网络上的第三个容器无法解析链接的一部分创建的别名：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You’ll recall that legacy linking also automatically created a set of environmental
    variables on the source container. These environmental variables referenced the
    target container and any ports it might be exposing. Linking in user-defined networks
    does not create these environmental variables:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您会记得，传统的链接还会自动在源容器上创建一组环境变量。这些环境变量引用了目标容器和它可能正在暴露的任何端口。在用户定义的网络中进行链接不会创建这些环境变量：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As we saw in the previous recipe, keeping these variables up to date wasn’t
    achievable even with legacy links. That being said, it’s not a total surprise
    that the functionality doesn’t exist when dealing with user-defined networks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一个示例中看到的，即使使用传统的链接，也无法保持这些变量的最新状态。也就是说，当处理用户定义的网络时，功能不存在并不是完全令人惊讶。
- en: 'In addition to providing local container resolution, the embedded DNS server
    also handles any external requests. As we saw in the preceding example, the search
    domain from the Docker host (`lab.lab` in my case) was still being passed down
    to the containers and configured in their `resolv.conf` file. The name server
    learned from the host becomes a forwarder for the embedded DNS server. This allows
    the embedded DNS server to process any container name resolution requests and
    hand off external requests to the name server used by the Docker host. This behavior
    can be overridden either at the service level or by passing the `--dns` or `--dns-search`
    flag to a container at runtime. For instance, we can start two more instances
    of the `web1` container and specify a specific DNS server in either case:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供本地容器解析外，嵌入式DNS服务器还处理任何外部请求。正如我们在前面的示例中看到的，来自Docker主机（在我的情况下是`lab.lab`）的搜索域仍然被传递给容器，并在它们的`resolv.conf`文件中配置。从主机学习的名称服务器成为嵌入式DNS服务器的转发器。这允许嵌入式DNS服务器处理任何容器名称解析请求，并将外部请求移交给Docker主机使用的名称服务器。这种行为可以在服务级别或在运行时通过传递`--dns`或`--dns-search`标志来覆盖。例如，我们可以启动`web1`容器的另外两个实例，并在任何情况下指定特定的DNS服务器：
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that `web4` would receive `10.20.30.13` as a DNS forwarder even if we didn’t
    specify it explicitly. This is because that’s also the DNS server used by the
    Docker host and when not specified the container inherits from the host. It is
    specified here for the sake of the example.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使我们没有明确指定，`web4`也会接收`10.20.30.13`作为DNS转发器。这是因为这也是Docker主机使用的DNS服务器，当未指定时，容器会继承自主机。这里为了示例而指定。
- en: 'Now if we try to resolve a local DNS record on either container, we can see
    that in the case of `web1` it works since it has the local DNS server defined,
    whereas the lookup on `web2` fails because `8.8.8.8` doesn’t know about the `lab.lab`
    domain:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试在任何一个容器上解析本地DNS记录，我们可以看到，在`web1`的情况下它可以工作，因为它定义了本地DNS服务器，而在`web2`上的查找失败，因为`8.8.8.8`不知道`lab.lab`域：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Creating Docker DNS aliases
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Docker DNS别名
- en: Before embedded DNS, the only way to alias a container to a different name was
    to use links. As we’ve seen in previous recipes, this is still the method used
    to create localized or container-specific aliases. However, what if you wanted
    to have an alias with a larger scope, one that any container connected to a given
    network could resolve? The embedded DNS server offers what are referred to as
    network-scoped aliases, which are resolvable within a given user-defined network.
    In this recipe, we’ll show you how to create network-scoped aliases within user-defined
    networks.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式DNS之前，将容器别名为不同名称的唯一方法是使用链接。正如我们在之前的示例中看到的，这仍然是用于创建本地化或特定于容器的别名的方法。但是，如果您想要具有更大范围的别名，任何连接到给定网络的容器都可以解析的别名呢？嵌入式DNS服务器提供了所谓的网络范围别名，这些别名可以在给定的用户定义网络中解析。在本示例中，我们将向您展示如何在用户定义的网络中创建网络范围的别名。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll be demonstrating the configuration on a single Docker
    host. It is assumed that this host has Docker installed and that Docker is in
    its default configuration. We’ll be altering name resolution settings on the host,
    so you’ll need root-level access.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将演示在单个Docker主机上的配置。假设该主机已安装Docker，并且Docker处于默认配置状态。我们将更改主机上的名称解析设置，因此您需要root级别的访问权限。
- en: How to do it…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Network aliases can be defined in a couple of different ways. They can be defined
    at container runtime or when you connect a container to a network. Once again,
    network aliases are a feature only provided when a container implements a user-defined
    network. You cannot create a network alias without specifying a user-defined network
    at the same time. Docker will prevent you from specifying them at container runtime:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 网络别名可以以几种不同的方式定义。它们可以在容器运行时定义，也可以在将容器连接到网络时定义。再次强调，网络别名是仅在容器实现用户定义网络时提供的功能。您不能在不同时指定用户定义网络的情况下创建网络别名。Docker将阻止您在容器运行时指定它们：
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we create a user-defined network and specify it as part of the container
    configuration, the command will execute successfully:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个用户定义的网络并将其指定为容器配置的一部分，该命令将成功执行：
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once the alias is created, we can see it as part of the specific container''s
    configuration. For instance, if we now inspect the container `web1`, we’ll see
    a defined alias under its network configuration:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦别名被创建，我们可以将其视为特定容器配置的一部分。例如，如果我们现在检查容器`web1`，我们将在其网络配置下看到一个定义的别名：
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let’s start another container named `web2` and see if we can resolve the
    alias:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动另一个名为`web2`的容器，并看看我们是否可以解析别名：
- en: '[PRE52]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There are a couple of interesting things to point out here. First, this method
    for defining aliases is vastly different than the linking method in more than
    just scope. With links, a source container specified what it wanted a target container
    to be aliases to. In the case of network aliases, a source container sets its
    own alias.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件有趣的事情要指出。首先，定义别名的方法与链接方法有很大不同，不仅仅是范围。通过链接，源容器指定了它希望将目标容器别名为的内容。在网络别名的情况下，源容器设置了自己的别名。
- en: 'Second, this only worked because the container `web2` is on the same user-defined
    network as `web1`. Because the alias'' scope is the entire user-defined network,
    this means that the same container could go by different aliases on a different
    user-defined networks. For instance, let’s create another user-defined network:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这只能工作是因为容器`web2`在与`web1`相同的用户定义网络上。因为别名的范围是整个用户定义的网络，这意味着同一个容器在不同的用户定义网络上可以使用不同的别名。例如，让我们创建另一个用户定义的网络：
- en: '[PRE53]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, let’s attach the container `web1` to it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将容器`web1`连接到它：
- en: '[PRE54]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Recall that we said you can define network-scoped aliases as part of the `network
    connect` subcommand as well:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们说过您可以在`network connect`子命令的一部分中定义网络范围的别名：
- en: '[PRE55]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Note that the container `web1` now has two aliases, one on each network. Because
    the container `web2` is only connected to one network, it is still only able to
    resolve the alias associated with the `mybridge1` network:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，容器`web1`现在有两个别名，一个在每个网络上。因为容器`web2`只连接到一个网络，所以它仍然只能解析与`mybridge1`网络关联的别名：
- en: '[PRE56]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'However, once we connect `web2` to the `mybridge2` network, it is now able
    to resolve both aliases:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们将`web2`连接到`mybridge2`网络，它现在可以解析两个别名：
- en: '[PRE57]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Interestingly, Docker also lets you define the same alias to multiple containers.
    For instance, let’s now start a third container named `web3` and connect it to
    `mybridge1` using the same alias as `web1` (`webserver1`):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Docker还允许您将相同的别名定义为多个容器。例如，现在让我们启动一个名为`web3`的第三个容器，并使用与`web1`（`webserver1`）相同的别名将其连接到`mybridge1`：
- en: '[PRE58]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The alias is now defined for the container `web1` as well as `web2`. However,
    attempts to resolve the alias from `web2` still point to `web1`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 别名现在已经为容器`web1`和`web2`定义。但是，尝试从`web2`解析别名仍然指向`web1`：
- en: '[PRE59]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If we disconnect or stop the container `web1`, we should see that the resolution
    now changes to `web3` since it’s still active on the network and has the same
    alias:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们断开或停止容器`web1`，我们应该会看到分辨率现在改变为`web3`，因为它仍然在网络上活动，并且具有相同的别名：
- en: '[PRE60]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This functionality can provide you with some interesting options in terms of
    high availability or failover, especially when coupled with the overlay network
    type.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能可以为您提供一些有趣的选择，特别是在与叠加网络类型配合使用时，可以实现高可用性或故障转移。
- en: It should be noted that this functionality works for all user-defined network
    types including the overlay network type. We’ve used bridges in these examples
    to keep the examples simple.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这个功能适用于所有用户定义的网络类型，包括叠加网络类型。我们在这些示例中使用桥接来保持示例简单。
