- en: Containers - Not Just Another Buzzword
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器-不只是另一个时髦词汇
- en: In technology, sometimes the jumps in progress are small but, as is the case
    with containerization, the jumps have been massive and turn the long-held practices
    and teachings completely upside down. With this book, we will take you from running
    a tiny service to building elastically scalable systems using containerization
    with Docker, the cornerstone of this revolution. We will perform a steady but
    consistent ramp-up through the basic blocks with a focus on the inner workings
    of Docker, and, as we continue, we will try to spend a majority of the time in
    the world of complex deployments and their considerations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术领域，有时进步的跳跃很小，但就像容器化一样，这种跳跃是巨大的，完全颠覆了长期以来的实践和教学。通过这本书，我们将带你从运行一个微小的服务到使用Docker构建弹性可扩展的系统，Docker是这场革命的基石。我们将通过基本模块进行稳定而一致的升级，重点关注Docker的内部工作，随着我们的继续，我们将尽量花费大部分时间在复杂部署及其考虑的世界中。
- en: 'Let’s take a look at what we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看本章我们将涵盖的内容：
- en: What are containers and why do we need them?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是容器，为什么我们需要它们？
- en: Docker’s place in the container world
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker在容器世界中的地位
- en: Thinking with a container mindset
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以容器思维思考
- en: The what and why of containers
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的作用和意义
- en: We can’t start talking about Docker without actually covering the ideas that
    make it such a powerful tool. A container, at the most basic level, is an isolated
    user-space environment for a given discrete set of functionality. In other words,
    it is a way to modularize a system (or a part of one) into pieces that are much
    easier to manage and maintain while often also being very resilient to failures.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能谈论Docker而不实际涵盖使其成为强大工具的想法。在最基本的层面上，容器是给定离散功能集的隔离用户空间环境。换句话说，这是一种将系统（或其中的一部分）模块化为更容易管理和维护的部分的方式，同时通常也非常耐用。
- en: In practice, this net gain is never free and requires some investment in the
    adoption and implementation of new tooling (such as Docker), but the change pays
    heavy dividends to the adopters in a drastic reduction of development, maintenance,
    and scaling costs over its lifetime.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种净收益从来都不是免费的，需要在采用和实施新工具（如Docker）上进行一些投资，但这种变化在其生命周期内大大减少了开发、维护和扩展成本，为采用者带来了丰厚的回报。
- en: 'At this point, you might ask this: how exactly are containers able to provide
    such huge benefits? To understand this, we first need to take a look at deployments
    before such tooling was available.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会问：容器究竟如何能够提供如此巨大的好处？要理解这一点，我们首先需要看一下在此类工具可用之前的部署情况。
- en: 'In the earlier days of deployments, the process for deploying a service would
    go something like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的部署中，部署服务的过程大致如下：
- en: Developer would write some code.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员会编写一些代码。
- en: Operations would deploy that code.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运维团队会部署该代码。
- en: If there were any problems in deployment, the operations team would tell the
    developer to fix something and we would go back to step 1.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果部署中出现任何问题，运维团队会告诉开发人员修复一些东西，然后我们会回到第一步。
- en: 'A simplification of this process would look something like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的简化看起来大致如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The developer would have to wait for the whole process to bounce back for them
    to try to write a fix anytime there was a problem. What is even worse, operations
    groups would often have to use various arcane forms of magic to ensure that the
    code that developers gave them can actually run on deployment machines, as differences
    in library versions, OS patches, and language compilers/interpreters were all
    high risk for failures and likely to spend a huge amount of time in this long
    cycle of break-patch-deploy attempts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员必须等待整个过程为他们弹回，以尝试在出现问题时编写修复程序。更糟糕的是，运维团队通常必须使用各种古怪的魔法来确保开发人员给他们的代码实际上可以在部署机器上运行，因为库版本、操作系统补丁和语言编译器/解释器的差异都是高风险的失败，并且很可能在这个漫长的破坏-修补-部署尝试周期中花费大量时间。
- en: 'The next step in the evolution of deployments came to improve this workflow
    with the virtualization of bare-metal hosts as manual maintenance of a heterogeneous
    mix of machines and environments is a complete nightmare even when they were in
    single-digit counts. Early tools such as `chroot` came out in the late 70s but
    were later replaced (though not fully) with hypervisors such as Xen, KVM, Hyper-V,
    and a few others, which not only reduced the management complexity of larger systems,
    but also provided Ops and developers both with a deployment environment that was
    more consistent as well as more computationally dense:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 部署演进的下一步是通过虚拟化裸机主机来改进这个工作流程，因为手动维护异构机器和环境的混合是一场完全的噩梦，即使它们只有个位数。早期的工具如`chroot`在70年代后期出现，但后来被（尽管没有完全）Xen、KVM、Hyper-V等虚拟化技术所取代，这不仅减少了更大系统的管理复杂性，还为运维人员和开发人员提供了更一致、更计算密集的部署环境。
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This helped out in the reduction of failures at the end of the pipeline, but
    the path from the developer to the deployment was still a risk as the VM environments
    could very easily get out of sync with the developers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于减少管道末端的故障，但从开发人员到部署的路径仍然存在风险，因为虚拟机环境很容易与开发人员不同步。
- en: 'From here, if we really try to figure out how to make this system better, we
    can already see how Docker and other container technologies are the organic next
    step. By making the developers'' sandbox environment as close as we can get to
    the one in production, a developer with an adequately functional container system
    can literally bypass the ops step, be sure that the code will work on the deployment
    environment, and prevent any lengthy rewrite cycles due to the overhead of multiple
    group interactions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，如果我们真的试图找出如何使这个系统更好，我们已经可以看到Docker和其他容器技术是有机的下一步。通过使开发人员的沙盒环境尽可能接近生产环境，具有足够功能的容器系统的开发人员可以绕过运维步骤，确保代码在部署环境上能够运行，并防止由于多个团队交互的开销而导致的漫长重写周期：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With Ops being needed primarily in the early stages of system setup, developers
    can now be empowered to take their code directly from the idea all the way to
    the user with the confidence that a majority of issues that they will find will
    be ones that they will be able to fix.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着运维主要在系统设置的早期阶段需要，开发人员现在可以直接将他们的代码从想法一直推送到用户，他们可以有信心地解决大部分问题。
- en: If you consider this the new model of deploying services, it is very reasonable
    to understand why we have DevOps roles nowadays, why there is such a buzz around
    **Platform as a Service** (**PaaS**) setups, and how so many tech giants can apply
    a change to a service used by millions at a time within 15 minutes with something
    as simple as `git push origin` by a developer without any other interactions with
    the system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这是部署服务的新模式，那么现在理解为什么我们现在有了DevOps角色，为什么**平台即服务**（PaaS）设置如此受欢迎，以及为什么如此多的科技巨头可以在15分钟内通过开发人员的`git
    push origin`这样简单的操作对数百万人使用的服务进行更改，而无需与系统进行任何其他交互，是非常合理的。
- en: But the benefits don't stop there either! If you have many little containers
    everywhere and if you have increased or decreased demand for a service, you can
    add or eliminate a portion of your host machines, and if the container orchestration
    is properly done, there will be zero downtime and zero user-noticeable changes
    on scaling changes. This comes in extremely handy to providers of services that
    need to handle variable loads at different times--think of Netflix and their peak
    viewership times as an example. In most cases, these can also be automated on
    almost all cloud platforms (that is, AWS Auto Scaling Groups, Google Cluster Autoscaler,
    and Azure Autoscale) so that if some triggers occur or there are changes in resource
    consumption, the service will automatically scale up and down the number of hosts
    to handle the load. By automating all these processes, your PaaS can pretty much
    be a fire-and-forget flexible layer, on top of which developers can worry about
    things that really matter and not waste time with things such as trying to figure
    out whether some system library is installed on deployment hosts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但好处并不仅限于此！如果你到处都有许多小容器，如果你对某项服务的需求增加或减少，你可以增加或减少主机的一部分，如果容器编排做得当，那么在扩展或缩减时将会零停机和用户察觉不到的变化。这对需要在不同时间处理可变负载的服务提供商非常方便--以Netflix及其高峰观看时间为例。在大多数情况下，这些也可以在几乎所有云平台上自动化（即AWS自动扩展组，Google集群自动缩放器和Azure自动缩放器），因此，如果发生某些触发器或资源消耗发生变化，服务将自动扩展和缩减主机数量以处理负载。通过自动化所有这些过程，你的PaaS基本上可以成为一个灵活的一劳永逸的层，开发人员可以在其上担心真正重要的事情，而不必浪费时间去弄清楚一些系统库是否安装在部署主机上。
- en: Now don't get me wrong; making one of these amazing PaaS services is not an
    easy task by any stretch of imagination, and the road is covered in countless
    hidden traps but if you want to be able to sleep soundly throughout the night
    without phone calls from angry customers, bosses, or coworkers, you must strive
    to be as close as you can to these ideal setups regardless of whether you are
    a developer or not.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要误会我的意思；制作这些令人惊叹的PaaS服务绝非易事，而且道路上布满了无数隐藏的陷阱，但如果你想在夜间能够安然入睡，不受愤怒客户、老板或同事的电话骚扰，无论你是开发人员还是其他人，你都必须努力尽可能接近这些理想的设置。
- en: Docker's place
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker的位置
- en: So far, we have talked a lot about containers but haven't mentioned Docker yet.
    While Docker has been emerging as the de facto standard in containerization, it
    is currently one of many competing technologies in this space, and what is relevant
    today may not be tomorrow. For this reason, we will cover a little bit of the
    container ecosystem so that if you see shifts occurring in this space, don't hesitate
    to try another solution, as picking the right tool for the job almost always beats
    out trying to, as the saying goes, fit a square peg in a round hole.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经谈了很多关于容器，但还没有提到Docker。虽然Docker已经成为容器化的事实标准，但它目前是这个领域中许多竞争技术之一，今天相关的内容可能明天就不再适用。因此，我们将涵盖一些容器生态系统的内容，这样如果你看到这个领域发生变化，不要犹豫尝试其他解决方案，因为选择合适的工具几乎总是比试图“把方形钉子塞进圆孔”更好。
- en: 'While most people know Docker as the **Command-line Interface** (**CLI**) tool,
    the Docker platform extends above and beyond that to include tooling to create
    and manage clusters, handle persistent storage, build and share Docker containers,
    and many others, but for now, we will focus on the most important part of that
    ecosystem: the Docker container.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数人知道Docker作为**命令行界面**（**CLI**）工具，但Docker平台扩展到包括创建和管理集群的工具、处理持久存储、构建和共享Docker容器等等，但现在，我们将专注于该生态系统中最重要的部分：Docker容器。
- en: Introduction to Docker containers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker容器简介
- en: Docker containers, in essence, are a grouping of a number of filesystem layers
    that are stacked on top of each other in a sequence to create the final layout
    that is then run in an isolated environment by the host machine's kernel. Each
    layer describes which files have been added, modified, and/or deleted relative
    to its previous parent layer. For example, you have a base layer with a file `/foo/bar`,
    and the next layer adds a file `/foo/baz`. When the container starts, it will
    combine the layers in order and the resulting container will have both `/foo/bar`
    and `/foo/baz`. This process is repeated for any new layer to end up with a fully
    composed filesystem to run the specified service or services.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器本质上是一组文件系统层，这些层按顺序堆叠在一起，以创建最终的布局，然后由主机机器的内核在隔离的环境中运行。每个层描述了相对于其上一个父层添加、修改和/或删除的文件。例如，你有一个基本层，其中有一个文件`/foo/bar`，下一个层添加了一个文件`/foo/baz`。当容器启动时，它将按顺序组合层，最终的容器将同时拥有`/foo/bar`和`/foo/baz`。对于任何新层，这个过程都会重复，以得到一个完全组成的文件系统来运行指定的服务或服务。
- en: 'Think of the arrangement of the filesystem layers in an image as the intricate
    layering of sounds in a symphony: you have the percussion instruments in the back
    to provide the base for the sound, wind instruments a bit closer to drive the
    movements, and in the front, the string instruments with the lead melody. Together,
    it creates a pleasing end result. In the case of Docker, you generally have the
    base layers set up the main OS layers and configuration, the service infrastructure
    layers go on top of that (interpreter installation, the compilation of helpers,
    and so on), and the final image that you run is finally topped with the actual
    service code. For now, this is all you will need to know, but we will cover this
    topic in much more detail in the next chapter.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 把镜像中文件系统层的安排想象成交响乐中复杂的层次：你有后面的打击乐器提供声音的基础，稍微靠前的吹奏乐器推动乐曲的发展，最前面的弦乐器演奏主旋律。一起，它创造了一个令人愉悦的最终结果。在Docker的情况下，通常有基本层设置主要的操作系统层和配置，服务基础设施层放在其上（解释器安装，辅助工具的编译等），最终运行的镜像最终是实际的服务代码。现在，这就是你需要知道的全部，但我们将在下一章节中更详细地涵盖这个主题。
- en: In essence, Docker in its current form is a platform that allows easy and fast
    development of isolated (or not depending on how the service is configured) Linux
    and Windows services within containers that are scalable, easily interchangeable,
    and easily distributable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，Docker在其当前形式下是一个平台，允许在容器内轻松快速地开发隔离的（或者取决于服务配置的）Linux和Windows服务，这些容器是可扩展的，易于互换和分发的。
- en: The competition
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞争
- en: Before we get too deep into Docker itself, let us also cover some of the current
    competitors in broad strokes and see how they differ from Docker itself. The curious
    thing about almost all of them is that they are generally a form of abstraction
    around Linux control groups (`cgroups`) and namespaces that limit the use of Linux
    host's physical resources and isolate groups of processes from each other, respectively.
    While almost every tooling mentioned here provides some sort of containerization
    of resources, it can differ greatly in the depth of isolation, implementation
    security, and/or the container distribution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论Docker本身之前，让我们也大致了解一下一些当前的竞争对手，并看看它们与Docker本身的区别。几乎所有这些竞争对手的有趣之处在于，它们通常是围绕Linux控制组（`cgroups`）和命名空间的一种抽象形式，这些控制组限制了Linux主机的物理资源的使用，并将进程组相互隔离。虽然这里提到的几乎所有工具都提供了某种资源的容器化，但在隔离深度、实现安全性和/或容器分发方面可能存在很大差异。
- en: rkt
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rkt
- en: '`rkt`, often written as **Rocket**, is the closest competing application containerization
    platform from CoreOS that was started as a more secure application container runtime.
    Over time, Docker has closed a number of its security failings but unlike `rkt`,
    which runs with limited privileges as a user service, Docker''s main service runs
    as root. This means that if someone manages to break out of the Docker container,
    they will automatically have full access to the host''s root, which is obviously
    a really bad thing from an operations perspective while with `rkt`, the hacker
    would also need to escalate their privilege from the limited user. While this
    comparison here isn''t painting Docker in great light from a security standpoint,
    if its development trajectory is to be extrapolated, it is possible and likely
    that this issue will be heavily mitigated and/or fixed in the future.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`rkt`，通常写作**Rocket**，是来自CoreOS的最接近的竞争应用容器化平台，它最初是作为更安全的应用容器运行时启动的。随着时间的推移，Docker已经解决了许多安全问题，但与`rkt`不同的是，它以有限的权限作为用户服务运行，而Docker的主要服务以root权限运行。这意味着如果有人设法打破Docker容器，他们将自动获得对主机root的完全访问权限，从运营的角度来看，这显然是一个非常糟糕的事情，而使用`rkt`，黑客还需要提升他们的权限从有限用户。虽然从安全的角度来看，这里的比较并没有给Docker带来太大的光明，但如果其发展轨迹可以被推断，这个问题可能会在未来得到很大程度的缓解和/或修复。'
- en: Another interesting difference is that unlike Docker, which is designed to run
    a single process within the container, `rkt` can run multiple processes within
    a container. This makes deploying multiple services within a single container
    much easier. Now, having said that, you actually *can* run multiple processes
    within a Docker container (we will cover this at a later point in the book) but
    it is a great pain to set that up properly but I did find in practice that the
    pressure to keep services and containers based on a single process really pushes
    the developer to create containers as true microservices instead of treating them
    as mini VMs so don't consider this necessarily as a problem.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的区别是，与Docker不同，它被设计为在容器内运行单个进程，`rkt`可以在一个容器内运行多个进程。这使得在单个容器内部部署多个服务变得更加容易。现在，话虽如此，你实际上*可以*在Docker容器内运行多个进程（我们将在本书的后面部分介绍），但是正确设置这一点是非常麻烦的，但我在实践中发现，保持基于单个进程的服务和容器的压力确实促使开发人员创建真正的微服务容器，而不是将它们视为迷你虚拟机，所以不一定认为这是一个问题。
- en: 'While there are many other smaller reasons to choose Docker over `rkt` and
    vice versa, one massive thing cannot be ignored: the rate of adoption. While `rkt`
    is a bit younger, Docker has been adopted by almost all big tech giants, and there
    doesn''t seem to be any sign of stopping the trend. With this in mind, if you
    need to work on microservices today, the choice is probably very clear but as
    with any tech field, the ecosystem may look much differently in a year or even
    just a couple of months.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多其他较小的原因可以选择Docker而不是`rkt`，反之亦然，但有一件重要的事情是无法忽视的：采用速度。虽然`rkt`有点年轻，但Docker已经被几乎所有大型科技巨头采用，而且似乎没有任何停止这一趋势的迹象。考虑到这一点，如果您今天需要处理微服务，选择可能非常明确，但与任何技术领域一样，生态系统在一年甚至只是几个月内可能看起来大不相同。
- en: System-level virtualization
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统级虚拟化
- en: On the opposite side, we have platforms for working with full system images
    instead of applications like LXD, OpenVZ, KVM, and a few others. They, unlike
    Docker and `rkt`, are designed to provide you with full support for all of the
    virtualized system services but at the cost of much higher resource usage purely
    by its definition. While having separate system containers on a host is needed
    for things like better security, isolation, and possibly compatibility, almost
    the entire use of these containers from personal experience can be moved to an
    application-level virtualization system with a bit of work to provide better resource
    use profile and higher modularity at a slight increase of cost in creating the
    initial infrastructure. A sensible rule to follow here is that if you are writing
    applications and services, you should probably use application-level virtualization
    but if you are providing VMs to the end user or want much more isolation between
    services you should use a system-level virtualization.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在对立的一面，我们有用于处理完整系统镜像而不是像LXD、OpenVZ、KVM和其他一些应用程序的平台。与Docker和`rkt`不同，它们旨在为您提供所有虚拟化系统服务的全面支持，但纯粹从定义上来说，资源使用成本要高得多。虽然在主机上拥有单独的系统容器对于诸如更好的安全性、隔离性和可能的兼容性之类的事情是必要的，但根据个人经验，几乎所有这些容器的使用都可以转移到应用级虚拟化系统，只需进行一些工作即可提供更好的资源使用配置文件和更高的模块化，而在创建初始基础设施时稍微增加成本。在这里要遵循的一个明智的规则是，如果您正在编写应用程序和服务，您可能应该使用应用级虚拟化，但如果您正在为最终用户提供VM或者希望在服务之间获得更高的隔离性，您应该使用系统级虚拟化。
- en: Desktop application-level virtualizations
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桌面应用程序级虚拟化
- en: Flatpak, AppImage, Snaps, and other similar technologies also provide isolation
    and packaging for single-application level containers, but unlike Docker, all
    of them target the deployment of desktop applications and do not have as precise
    control over the container life cycle (that is starting, stopping, forced termination,
    and so on) nor do they generally provide layered images. Instead, most of these
    tools have nice wrapper **Graphical User Interfaces** (**GUIs**) and provide a
    significantly better workflow for installing, running, and updating desktop applications.
    While most have large overlaps with Docker due to the same underlying reliance
    on mentioned `cgroups` and namespaces, these application-level virtualization
    platforms do not traditionally handle server applications (applications that run
    without UI components) and vice versa. Since this field is still young and the
    space they all cover is relatively small, you can probably expect consolidations
    and cross-overs so in this case it would be either for Docker to enter the desktop
    application delivery space and/or for one or more of these competing technologies
    to try to support server applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Flatpak、AppImage、Snaps和其他类似技术也为单应用级容器提供隔离和打包，但与Docker不同，它们都针对部署桌面应用程序，并且对容器的生命周期（启动、停止、强制终止等）没有如此精确的控制，也通常不提供分层镜像。相反，大多数这些工具都有很好的图形用户界面（GUI），并为安装、运行和更新桌面应用程序提供了显着更好的工作流程。虽然由于对所述cgroups和命名空间的相同依赖，大多数与Docker有很大的重叠，但这些应用级虚拟化平台通常不处理服务器应用程序（没有UI组件运行的应用程序），反之亦然。由于这个领域仍然很年轻，它们所覆盖的空间相对较小，你可能可以期待整合和交叉，因此在这种情况下，要么是Docker进入桌面应用程序交付领域，要么是其中一个或多个竞争技术尝试支持服务器应用程序。
- en: '![](assets/2116c6db-41e5-4d76-a139-1bbeea570d3b.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2116c6db-41e5-4d76-a139-1bbeea570d3b.png)'
- en: When should containerization be considered?
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时应考虑容器化？
- en: We've covered a lot of ground so far, but there is an important aspect that
    we did not cover yet but which is an extremely important thing to evaluate as
    containers do not make sense in a large array of circumstances as the end deployment
    target regardless of how much buzz there is around this concept, so we will cover
    some general use cases where this type of platform should really be considered
    (or not). While containerization should be the end goal in most cases from an
    operations perspective and offers huge dividends with minimal effort when injected
    into the development process, turning deployment machines into a containerized
    platform is a pretty tricky process, and if you will not gain tangible benefits
    from it, you might as well dedicate this time to something that will bring real
    and tangible value to your services.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了很多内容，但有一个重要的方面我们还没有涵盖，但这是一个非常重要的事情要评估，因为在许多情况下容器化并不合理，无论这个概念有多大的关注度，所以我们将涵盖一些真正应该考虑（或不应该考虑）这种类型平台的一般用例。虽然从运营角度来看，容器化应该是大多数情况下的最终目标，并且在注入到开发过程中时可以带来巨大的回报，但将部署机器转变为容器化平台是一个非常棘手的过程，如果你无法从中获得实际的好处，那么你可能还不如把这段时间用在能为你的服务带来真正和实际价值的事情上。
- en: Let's start this by covering scaling thresholds first. If your services as a
    whole can completely fit and run well on a relatively small or medium virtual
    machine or a bare-metal host and you don't anticipate sudden scaling needs, virtualization
    on the deployment machines will lead you down the path of pain that really isn't
    warranted in most cases. The high front-loaded costs of setting up even a benign
    but robust virtualized setup will usually be better spent on developing service
    features at that level.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从覆盖缩放阈值开始。如果你的服务作为一个整体可以完全适应并在相对较小或中等虚拟机或裸金属主机上良好运行，并且你不预期突然的扩展需求，部署机器上的虚拟化将使你陷入痛苦的道路，在大多数情况下并不合理。即使是建立一个良性但健壮的虚拟化设置的高前期成本，通常也更好地花在该级别的服务功能开发上。
- en: If you see increases in demand with a service backed with a VM or bare-metal
    host, you can always scale up to a larger host (vertical scaling) and refocus
    your team but for anything less than that, you probably shouldn't go that route.
    There have been many cases where a business has spent months working to get the
    container technology implemented since it is so popular, only to lose their customers
    due to lack of development resources and having to shut their doors.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到一个由虚拟机或裸金属主机支持的服务需求增加，你可以随时将其扩展到更大的主机（垂直扩展）并重新聚焦你的团队，但除此之外，你可能不应该选择这条路。有许多情况下，一家企业花了几个月的时间来实施容器技术，因为它非常受欢迎，最终由于缺乏开发资源而失去了客户，不得不关闭他们的业务。
- en: Now that your system is maxing out the limits of vertical scalability, is it
    a good time to add things such as Docker clusters to the mix? The real answer
    is "maybe". If your services are homogeneous and consistent across hosts, such
    as sharded or clustered databases or simple APIs, in most cases, this still isn't
    the right time either as you can scale this system easily with host images and
    some sort of a load balancer. If you're opting for a bit more fanciness, you can
    use a cloud-based **Database as a Service** (**DBaaS**) such as Amazon RDS, Microsoft
    DocumentDB, or Google BigQuery and auto-scale service hosts up or down through
    the same provider (or even a different one) based on the required level of performance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的系统正在达到垂直可扩展性的极限，是时候添加诸如Docker集群之类的东西了吗？真正的答案是“可能”。如果你的服务在主机上是同质的和一致的，比如分片或集群数据库或简单的API，在大多数情况下，现在也不是合适的时机，因为你可以通过主机镜像和某种负载均衡器轻松扩展这个系统。如果你想要更多的花样，你可以使用基于云的“数据库即服务”（DBaaS），比如Amazon
    RDS、Microsoft DocumentDB或Google BigQuery，并根据所需的性能水平通过同一提供商（甚至是不同的提供商）自动扩展服务主机。
- en: If there is ample foreshadowing of service variety beyond this, the need for
    a much shorter pipeline from developer to deployment, rising complexity, or exponential
    growth, you should consider each of these as triggers to re-evaluate your pros/cons
    but there is no clear threshold that will be a clear cut-off. A good rule of thumb
    here, though, is that if you have a slow period for your team it won't hurt to
    explore the containerization options or to gear up your skills in this space,
    but be *very* careful to not underestimate the time it would take to properly
    set up such a platform regardless of how easy the Getting Started instructions
    look on many of these tools.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果除此之外还有大量的服务种类预示着，需要从开发人员到部署的更短管道，不断增长的复杂性或指数级增长，你应该将这些都视为重新评估你的利弊的触发器，但没有明确的阈值会成为一个明确的切入点。然而，在这里一个很好的经验法则是，如果你的团队有一个缓慢的时期，探索容器化选项或提升你在这个领域的技能不会有害，但一定要非常小心，不要低估设置这样一个平台所需的时间，无论这些工具中的许多看起来多么容易入门。
- en: 'With this all, what are the clear signs that you need to get containers into
    your workflow as soon as you can? There can be many subtle hints here but the
    following list covers the ones that should immediately bring the containers topic
    up for discussion if the answer is yes, as the benefits greatly outweigh the time
    investment into your service platform:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，什么是你需要尽快将容器纳入工作流程的明显迹象？这里可能有许多微妙的暗示，但以下清单涵盖了如果答案是肯定的话，应立即讨论容器主题的迹象，因为其好处大大超过了投入服务平台的时间：
- en: Do you have more than 10 unique, discrete, and interconnected services in your
    deployment?
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的部署中是否有超过10个独特、离散且相互连接的服务？
- en: Do you have three or more programming languages you need to support on the hosts?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否需要在主机上支持三种或更多编程语言？
- en: Are your ops resources constantly deploying and upgrading services?
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的运维资源是否不断部署和升级服务？
- en: Do any of your services require "four 9s" (99.99%) or better availability?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的任何服务需要“四个9”（99.99%）或更高的可用性吗？
- en: Do you have a recurring pattern of services breaking in deployments because
    developers are not considerate of the environment that the services will run in?
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的部署中是否有服务经常在部署中出现故障的模式，因为开发人员没有考虑到服务将在其中运行的环境？
- en: Do you have a talented Dev or Ops team that's sitting idle?
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否有一支才华横溢的开发或运维团队闲置着？
- en: Does your project have a burning hole in the wallet?
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的项目是否在挥霍金钱？
- en: Okay, maybe the last one is a bit of a joke but it is in the list to illustrate,
    in somewhat of a sarcastic tone, that at the time of writing this getting a PaaS
    platform operational, stable, and secure is neither easy nor cheap regardless
    of whether your currency is time or money. Many will try to trick you into the
    idea that you should always use containers and make everything Dockerized, but
    keep a skeptical mindset and make sure that you evaluate your options with care.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，也许最后一个有点玩笑，但它在清单中是为了以一种讽刺的语气来说明，写作时让PaaS平台运行、稳定和安全既不容易也不便宜，无论你的货币是时间还是金钱。许多人会试图欺骗你，让你认为你应该始终使用容器并使所有东西都Docker化，但保持怀疑的心态，并确保你仔细评估你的选择。
- en: The ideal Docker deployment
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理想的Docker部署
- en: 'Now that we have the real-talk parts done with, let us say that we are truly
    ready to tackle containers and Docker for an imaginary service. We covered bits
    and pieces of this earlier in the chapter, but we will here concretely define
    what our ideal requirements would look like if we had ample time to work on them:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完成了真实的谈话部分，让我们说我们真的准备好了来处理容器和Docker的虚构服务。我们在本章的前面已经涵盖了一些内容，但在这里，我们将明确定义我们的理想要求会是什么样子，如果我们有充足的时间来处理它们：
- en: Developers should be able to deploy a new service without any need for ops resources
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员应能够部署新服务，而无需任何运维资源
- en: The system can auto-discover new instances of services running
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统可以自动发现正在运行的服务的新实例
- en: The system is flexibly scalable both up and down
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统在上下都具有灵活的可扩展性
- en: On desired code commits, the new code will automatically get deployed without
    Dev or Ops intervention
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所需的代码提交上，新代码将在没有开发或运维干预的情况下自动部署
- en: You can seamlessly handle degraded nodes and services without interruption
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以无缝地处理降级节点和服务，而不会中断。
- en: You are capable of using the full extent of the resources available on hosts
    (RAM, CPUs, and so on)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能够充分利用主机上可用的资源（RAM、CPU等）
- en: Nodes should almost never need to be accessed individually by developers
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点几乎不需要被开发人员单独访问
- en: If these are the requirements, you will be happy to know that almost all of
    them are feasible to a large extent and that we will cover almost all of them
    in detail in this book. For many of them, we will need to get into Docker *way*
    deeper and beyond most of the materials you will find elsewhere, but there is
    no point in teaching you deployments that you cannot take to the field that only
    print out "Hello World"s.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些是要求，您会高兴地知道几乎所有这些要求在很大程度上都是可行的，我们将在本书中详细介绍几乎所有这些要求。对于其中的许多要求，我们需要更深入地了解Docker，并超越大多数其他材料，但教授您无法应用到实际场景的部署是没有意义的，这些部署只会打印出“Hello
    World”。
- en: As we explore each topic in the following chapters, we will be sure to cover
    any pitfalls as there are many such complex system interactions. Some will be
    obvious to you, but many probably will not (for example, the PID1 issue), as the
    tooling in this space is relatively young and many tools critical for the Docker
    ecosystem are not even version 1.0 or have reached version 1.0 only recently.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索以下章节中的每个主题时，我们一定会涵盖任何潜在的问题，因为有许多这样复杂的系统交互。有些对您来说可能很明显，但许多可能不会（例如PID1问题），因为这个领域的工具在相对年轻，许多对Docker生态系统至关重要的工具甚至还没有达到1.0版本，或者最近才达到1.0版本。
- en: Thus, you should consider this technology space to still be in its early stages
    of development so be realistic, don't expect miracles, and expect a healthy dose
    of little "gotchas". Keep also in mind that some of the biggest tech giants have
    been using Docker for a long time now (Red Hat, Microsoft, Google, IBM, and so
    on), so don't get scared either.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您应该考虑这个技术领域仍处于早期发展阶段，所以要现实一点，不要期望奇迹，预期会有一些小“陷阱”。还要记住，一些最大的科技巨头现在已经使用Docker很长时间了（红帽、微软、谷歌、IBM等），所以也不要感到害怕。
- en: To get started and really begin our journey, we need to first reconsider the
    way we think about services.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始并真正开始我们的旅程，我们需要首先重新考虑我们对服务的思考方式。
- en: The container mindset
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器思维
- en: Today, as we have somewhat covered earlier in the chapter, vast majority of
    services deployed today are a big mess of ad hoc or manually connected and configured
    pieces that tend to break apart as soon as a single piece is changed or moved.
    It is easy to imagine this as a tower of cards where the piece that needs changing
    is often in the middle of it, with risks taking the whole structure down. Small-to-medium
    projects and talented Dev and Ops team can mostly manage this level of complexity
    but it is really not a scalable methodology.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，正如我们在本章稍早已经涵盖的那样，今天部署的绝大多数服务都是一团杂乱的临时或手动连接和配置的部分，一旦其中一个部分发生变化或移动，整个结构就会分崩离析。很容易想象这就像一堆纸牌，需要更改的部分通常位于其中间，存在风险将整个结构拆除。小到中等规模的项目和有才华的开发和运维团队大多可以管理这种复杂性，但这真的不是一种可扩展的方法。
- en: The developer workflow
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者工作流程
- en: Even if you're not working on a PaaS system, it is good to consider each piece
    of a service as something that should have a consistent environment between the
    developer and final deployment hosts, be able to run anywhere with minimal changes,
    and is modular enough to be swapped out with an API-compatible analogue if needed.
    For many of these cases, even a local Docker usage can go far in making the deployments
    easier as you can isolate each component into small pieces that don't change as
    your development environment changes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不是在开发PaaS系统，考虑将服务的每个部分都视为应该在开发人员和最终部署主机之间具有一致的环境，能够在任何地方运行并进行最小的更改，并且足够模块化，以便在需要时可以用API兼容的类似物替换。对于许多这种情况，即使是本地Docker使用也可以在使部署更容易方面发挥作用，因为您可以将每个组件隔离成不随着开发环境的变化而改变的小部分。
- en: To illustrate this, imagine a practical case where we are writing a simple web
    service that talks to a database on a system that is based on the latest Ubuntu,
    but our deployment environment is some iteration of CentOS. In this case, due
    to their vastly different support cycle lengths coordinating between versions
    and libraries will be extremely difficult, so as a developer, you can use Docker
    to provide you with the same version of the database that CentOS would have, and
    you can test your service in a CentOS-based container to ensure that all the libraries
    and dependencies can work when it gets deployed. This process will improve the
    development workflow even if the real deployment hosts have no containerization.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，想象一个实际情况，我们正在编写一个简单的Web服务，该服务与基于最新Ubuntu的系统上的数据库进行通信，但我们的部署环境是CentOS的某个迭代版本。在这种情况下，由于它们支持周期长度的巨大差异，协调不同版本和库将非常困难，因此作为开发人员，您可以使用Docker为您提供与CentOS相同版本的数据库，并且您可以在基于CentOS的容器中测试您的服务，以确保所有库和依赖项在部署时可以正常工作。即使真实的部署主机没有容器化，这个过程也会改善开发工作流程。
- en: 'Now we will take this example in a slightly more realistic direction: what
    if you need to run your service without modifications of code on all currently
    supported versions of CentOS?'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将以稍微更加现实的方向来看待这个例子：如果您需要在所有当前支持的CentOS版本上无需修改代码即可运行您的服务呢？
- en: With Docker, you can have a container for each version of the OS that you can
    test the service against in order to ensure that you are not going to get any
    surprises. For additional points, you can automate a test suite runner to launch
    each one of the OS version containers one by one (or even better, in parallel)
    to run your whole test suite against them automatically on any code changes. With
    just these few small tweaks, we have taken an ad-hoc service that would constantly
    break in production to something that you almost never have to worry about as
    you can be confident that it will work when deployed, which is really powerful
    tooling to have.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker，您可以为每个操作系统版本创建一个容器，以便测试服务，以确保不会出现任何意外。另外，您可以自动化一个测试套件运行程序，逐个（甚至更好的是并行）启动每个操作系统版本的容器，以便在任何代码更改时自动运行整个测试套件。通过这些小的调整，我们已经将一个经常在生产中出现故障的临时服务转变为几乎不需要担心的东西，因为您可以确信它在部署时会正常工作，这是一个非常强大的工具。
- en: If you extend this process, you can locally create Docker recipes (Dockerfiles),
    which we will get into in the next chapter in detail, with the exact set of steps
    needed to get your service running from a vanilla CentOS installation to fully
    capable of running the service. These steps can be taken with minimal changes
    by the ops teams as input to their automated configuration management (CM) system,
    such as Ansible, Salt, Puppet, or Chef, to ensure that the hosts will have the
    exact baseline that is required for things to run properly. This codified transfer
    of exact steps needed on the end target written by the service developer is exactly
    why Docker is such a powerful tool.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您扩展这个过程，您可以在本地创建Docker配方（Dockerfiles），我们将在下一章中详细介绍，其中包含从纯净的CentOS安装到完全能够运行服务所需的确切步骤。这些步骤可以由运维团队以最小的更改作为输入，用于他们的自动化配置管理（CM）系统，如Ansible、Salt、Puppet或Chef，以确保主机具有运行所需的确切基线。由服务开发人员编写的端目标上所需的确切步骤的编码传递，这正是Docker如此强大的原因。
- en: 'As is hopefully becoming apparent, Docker as a tool not only improves your
    development processes if they''re on the deployment machines, but it can also
    be used throughout the process to standardize your environments and thus increase
    the efficiency of almost every part of the deployment pipeline. With Docker, you
    will most likely forget the infamous phrase that instills dread in every Ops person:
    "it works fine on my machine!". This, by itself, should be enough to make you
    consider splicing in container-based workflows even if your deployment infrastructure
    doesn''t support containers.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 希望显而易见的是，Docker作为一种工具不仅可以改善部署机器上的开发流程，而且还可以在整个过程中用于标准化您的环境，从而提高几乎每个部署流程的效率。有了Docker，您很可能会忘记那句让每个运维人员感到恐惧的臭名昭著的短语：“在我的机器上运行良好！”这本身就足以让您考虑在部署基础设施不支持容器的情况下，插入基于容器的工作流程。
- en: The bottom line here that we've been dancing around and which you should always
    consider is that with the current tooling available, turning your whole deployment
    infrastructure into a container-based one is slightly difficult, but the addition
    of containers in any other part of your development process is generally not too
    difficult and can provide exponential workflow improvements to your team.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们一直在绕着弯子说的底线是，您应该始终考虑的是，使用当前可用的工具，将整个部署基础设施转变为基于容器的基础设施略微困难，但在开发流程的任何其他部分添加容器通常并不太困难，并且可以为您的团队提供指数级的工作流程改进。
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we followed along the history of deployments and looked at
    how containers with Docker bring us closer to this new world of micro-services.
    Docker was examined with a high-level overview about which parts we are most interested
    in. We covered the competition and where Docker fits into the ecosystem with some
    use cases. Lastly, we also covered when you should - and more importantly, when
    you shouldn't - consider containers in your infrastructure and development workflow.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们沿着部署的历史走了一遍，并看了看Docker容器是如何让我们更接近微服务的新世界的。我们对Docker进行了审查，概述了我们最感兴趣的部分。我们涵盖了竞争对手以及Docker在生态系统中的定位和一些使用案例。最后，我们还讨论了何时应该考虑容器在基础架构和开发工作流程中，更重要的是，何时不应该考虑。
- en: In the next chapter, we will finally get our hands dirty and look into how to
    install and run Docker images along with creating our first Docker image, so be
    sure to stick around.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们最终将动手并了解如何安装和运行Docker镜像，以及创建我们的第一个Docker镜像，所以一定要继续关注。
