- en: Chapter 2. Using the Functional Constructions of Java 8
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用Java 8的函数式构造
- en: Functional programming is not a new idea; actually, it's pretty old. For example,
    **Lisp**, which is a functional language, is the second oldest of today's commonly-used
    programming languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程并不是一个新的想法；实际上，它相当古老。例如，**Lisp**是一种函数式语言，是当今常用编程语言中第二古老的语言。
- en: Functional programs are built using small pieces of reusable pure functions
    (lambdas). The program logic is composed of small declarative steps and not complex
    algorithms. That's because functional programs minimize the use of state, which
    makes imperative programs complex and hard to refactor/support.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序是使用可重用的纯函数（lambda）构建的。程序逻辑由小的声明性步骤组成，而不是复杂的算法。这是因为函数式程序最小化了状态的使用，这使得命令式程序复杂且难以重构/支持。
- en: With Java 8, the Java world got the lambda expressions and the ability to pass
    functions to functions. With them, we can code in a more functional style and
    get rid of a lot of the boilerplate code. The other new thing we got with Java
    8 is the streams—something very similar to RxJava's observables but not asynchronous.
    Combining these streams and the lambdas, we are able to create more functional-like
    programs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8带来了lambda表达式和将函数传递给函数的能力。有了它们，我们可以以更函数式的风格编码，并摆脱大量的样板代码。Java 8带来的另一个新功能是流——与RxJava的可观察对象非常相似，但不是异步的。结合这些流和lambda，我们能够创建更类似函数式的程序。
- en: We are going to familiarize ourselves with these new constructions and look
    at how they can be used with RxJava's abstractions. Our programs will be simpler
    and easier to follow by using the lambdas, and the concepts introduced in this
    chapter will be of help while designing applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将熟悉这些新的构造，并看看它们如何与RxJava的抽象一起使用。通过使用lambda，我们的程序将更简单，更容易跟踪，并且本章介绍的概念将有助于设计应用程序。
- en: 'This chapter covers:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖：
- en: Lambdas in Java 8
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8中的Lambda
- en: First RxJava examples using the lambda syntax
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lambda语法的第一个RxJava示例
- en: What pure functions and higher order functions are
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数和高阶函数是什么
- en: Lambdas in Java 8
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 8中的Lambda
- en: The most important change in Java 8 is the introduction of lambda expressions.
    They enable faster, clearer coding and make it possible to use functional programming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8中最重要的变化是引入了lambda表达式。它们使编码更快，更清晰，并且可以使用函数式编程。
- en: Java was created back in the '90s as an object-oriented programming language,
    with the idea that everything should be an object. At that time, object-oriented
    programming was the principal paradigm for software development. But, recently,
    functional programming has become increasingly popular because it is well-suited
    for concurrent and event-driven programming. This doesn't mean that we should
    stop writing code using object-oriented languages. Instead, the best strategy
    is to mix elements of object-oriented and functional programming. Adding lambdas
    to Java 8 ties in with this idea—Java is an object-oriented language, but now
    it has lambdas, we are able to code using the functional style too.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java是在90年代作为面向对象的编程语言创建的，其思想是一切都应该是一个对象。那时，面向对象编程是软件开发的主要范式。但是，最近，函数式编程因其适用于并发和事件驱动编程而变得越来越受欢迎。这并不意味着我们应该停止使用面向对象的语言编写代码。相反，最好的策略是将面向对象和函数式编程的元素混合在一起。将lambda添加到Java
    8符合这个想法——Java是一种面向对象的语言，但现在它有了lambda，我们也能够使用函数式风格编码。
- en: Let's look at this new feature in detail.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这个新功能。
- en: Introducing the new syntax and semantics
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍新的语法和语义
- en: In order to introduce lambda expressions, we need to see their actual value.
    This is why this chapter will begin with one example implemented without using
    lambda expressions, followed by re-implementing the same example using lambda
    expressions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍lambda表达式，我们需要看到它们的实际价值。这就是为什么本章将以一个不使用lambda表达式实现的示例开始，然后重新使用lambda表达式实现相同的示例。
- en: Remember the `map(Func1)` method from the `Observable` class? Let's try to implement
    something similar for the `java.util.List` collections. Of course, Java doesn't
    support adding methods to existing classes, so the implementation will be a static
    method that takes a list and transformation and returns a new list containing
    the transformed elements. In order to pass a transformation to the method, we'll
    need an interface with one method representing it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得`Observable`类中的`map(Func1)`方法吗？让我们尝试为`java.util.List`集合实现类似的东西。当然，Java不支持向现有类添加方法，因此实现将是一个接受列表和转换并返回包含转换元素的新列表的静态方法。为了将转换传递给方法，我们将需要一个表示它的方法的接口。
- en: 'Let''s look at the code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What is happening here?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？
- en: We define a generic interface, called `Mapper`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`Mapper`的通用接口。
- en: It has only one method, `M map(V)`, that receives a value of type `V` and transforms
    it to a value of type `M`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它只有一个方法，`M map(V)`，它接收一个类型为`V`的值并将其转换为类型为`M`的值。
- en: The static method `List<M> map(List<V>, Mapper<V, M>)` takes one list with elements
    of type `V` and a `Mapper` implementation. Using this `Mapper` implementation's
    `map()` method on every element of the source list, it converts the list to a
    new list of type `M` containing the transformed elements.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态方法`List<M> map(List<V>, Mapper<V, M>)`接受一个类型为`V`的元素列表和一个`Mapper`实现。使用这个`Mapper`实现的`map()`方法对源列表的每个元素进行转换，将列表转换为包含转换元素的新类型为`M`的列表。
- en: The implementation creates a new empty list of type `M` with the same size as
    the source list.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该实现创建一个新的空类型为`M`的列表，其大小与源列表相同。
- en: Every element in the source list is transformed using the passed `Mapper` implementation
    and added to the new list.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用传递的`Mapper`实现转换源列表中的每个元素，并将其添加到新列表中。
- en: The new list is returned.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回新列表。
- en: In this implementation, every time we want to create a new list by transforming
    another, we will have to implement the `Mapper` interface with the right transformation.
    Until Java 8, the right way of passing custom logic to methods was exactly like
    this—with anonymous class instances, implementing the given methods.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，每当我们想通过转换另一个列表创建一个新列表时，我们都必须使用正确的转换来实现`Mapper`接口。直到Java 8，将自定义逻辑传递给方法的正确方式正是这样——使用匿名类实例，实现给定的方法。
- en: 'But let''s look at how we use this `List<M> map(List<V>, Mapper<V, M>)` method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们看看我们如何使用这个`List<M> map(List<V>, Mapper<V, M>)`方法：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In order to apply a mapping to a list, we need to write four lines of boilerplate
    code. The actual mapping is very simple and is only one of these lines. The real
    problem here is that instead of passing an action, we are passing an object. This
    obscures the real intention of this program—to pass an action that produces transformation
    from every item of the source list and to get a list with applied changes at the
    end.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对列表应用映射，我们需要编写四行样板代码。实际的映射非常简单，只有其中一行。真正的问题在于，我们传递的不是一个操作，而是一个对象。这掩盖了这个程序的真正意图——传递一个从源列表的每个项目产生转换的操作，并在最后得到一个应用了变化的列表。
- en: 'Here is what this call looks like using the new lambda syntax of Java 8:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用Java 8的新lambda语法进行的调用的样子：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pretty straight forward, isn't it? And it just works. Instead of passing an
    object and implementing an interface, we pass a block of code, a nameless function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 相当直接了当，不是吗？它只是起作用。我们不是传递一个对象并实现一个接口，而是传递一块代码，一个无名函数。
- en: What is going on? We defined an arbitrary interface with an arbitrary method,
    but we could pass this lambda in place of an instance of the interface. In Java
    8, if you define *interface with only one abstract method* and you create a method
    that receives a parameter of this type of interface, you can pass a lambda instead.
    If the interface single method takes two arguments of type string and returns
    an integer value, the lambda will have to be composed of two arguments before
    the `->` and to return integer, the arguments will be inferred as strings.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？我们定义了一个任意的接口和一个任意的方法，但我们可以在接口的实例位置传递这个lambda。在Java 8中，如果您定义了*只有一个抽象方法的接口*，并且创建了一个接收此类型接口参数的方法，那么您可以传递lambda。如果接口的单个方法接受两个字符串类型的参数并返回整数值，那么lambda将必须由`->`之前的两个参数组成，并且为了返回整数，参数将被推断为字符串。
- en: 'Interfaces of this type are called **functional interfaces.** It is important
    for the single method to be abstract and not default. Another new thing in Java
    8 is the default methods of interfaces:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的接口称为**功能接口。**单个方法是抽象的而不是默认的非常重要。Java 8中的另一件新事物是接口的默认方法：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The default methods are useful when changing already existing interfaces. When
    we add default methods to them, the classes implementing them won't break. An
    interface with only one default method is not functional; a single method shouldn't
    be default.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法在更改已经存在的接口时非常有用。当我们向它们添加默认方法时，实现它们的类不会中断。只有一个默认方法的接口不是功能性的；单个方法不应该是默认的。
- en: 'Lambdas act as implementations of the functional interfaces. So, it is possible
    to assign them to variables of type interface as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda充当功能接口的实现。因此，可以将它们分配给接口类型的变量，如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And we can reuse the square object as it's an implementation of the `Mapper`
    interface.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重复使用square对象，因为它是`Mapper`接口的实现。
- en: 'Maybe you''ve noticed, but in the examples up until now, the parameters of
    lambda expressions have no type. That is because the types are inferred. So this
    expression is absolutely the same as the preceding expression:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您已经注意到了，但在目前为止的例子中，lambda表达式的参数没有类型。那是因为类型是被推断的。因此，这个表达式与前面的表达式完全相同：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The fact that the example with a parameter without a type works is not magic.
    Java is a statically typed language, so the parameter of the single method of
    the functional interface is used for type checking.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 没有类型的lambda表达式的参数是如何工作的并不是魔术。Java是一种静态类型语言，因此功能接口的单个方法的参数用于类型检查。
- en: 'How about the body of the lambda expression? There is no `return` statement
    anywhere. It turns out that these two examples are exactly the same:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那么lambda表达式的主体呢？任何地方都没有`return`语句。事实证明，这两个例子完全相同：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first expression is just a short form of the second. It is preferred for
    the lambda to be only one line of code. But if the lambda expression contains
    more than one line, the only way to define it is using the second approach, like
    this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表达式只是第二个的简写形式。最好lambda只有一行代码。但是如果lambda表达式包含多行，定义它的唯一方法是使用第二种方法，就像这样：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Under the hood, lambda expressions are not just syntax sugar for anonymous inner
    classes. They are implemented to perform quickly inside the **Java Virtual Machine**
    (**JVM**), so if your code is designed to be compatible only with Java 8+, you
    should definitely use them. Their main idea is to pass around behavior in the
    same way that data is passed. This makes your program more human readable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，lambda表达式不仅仅是匿名内部类的语法糖。它们被实现为在**Java虚拟机**（**JVM**）内快速执行，因此如果您的代码只设计为与Java
    8+兼容，那么您应该绝对使用它们。它们的主要思想是以与数据传递相同的方式传递行为。这使得您的程序更易读。
- en: 'One last thing related to the new syntax is the ability to pass to methods
    and assign to variables already defined functions and methods. Let''s define a
    new functional interface:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与新语法相关的最后一件事是能够传递到方法并分配给已定义的函数和方法。让我们定义一个新的功能接口：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can use it to execute arbitrary actions for each value in a list; for example,
    logging the list. Here is a method that uses this interface:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它来对列表中的每个值执行任意操作；例如，记录列表。以下是使用此接口的方法：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This method is similar to the `map()` function. It iterates through the list
    and calls the passed action''s `act()` method on every element. Let''s call it
    using a lambda that simply logs the elements in the list:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法类似于`map()`函数。它遍历列表并在每个元素上调用传递的动作的`act()`方法。让我们使用一个简单记录列表中元素的lambda来调用它：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is quite simple but not necessary because the `println()` method can be
    passed itself to the `act()` method. This is done as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但不是必需的，因为`println()`方法本身可以直接传递给`act()`方法。这样做如下：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code for these examples can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/Java8LambdasSyntaxIntroduction.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/Java8LambdasSyntaxIntroduction.java).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例的代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/Java8LambdasSyntaxIntroduction.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/Java8LambdasSyntaxIntroduction.java)上查看/下载。
- en: 'This is valid syntax in Java 8—every method can become a lambda and can be
    assigned to a variable or passed to a method. All these are valid:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Java 8中的有效语法——每个方法都可以成为lambda，并且可以分配给一个变量或传递给一个方法。所有这些都是有效的：
- en: Book::makeBook // Static method of a class
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Book::makeBook // 类的静态方法
- en: book::read // method of an instance
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: book::read // 实例的方法
- en: Book::new // Constructor of a class
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Book::new // 类的构造函数
- en: Book::read // instance method, but referenced without using an actual instance.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Book::read // 实例方法，但在没有使用实际实例的情况下引用。
- en: Now that we've revealed the lambda syntax, we will be using it in our RxJava
    examples instead of anonymous inner classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经揭示了lambda语法，我们将在RxJava示例中使用它，而不是匿名内部类。
- en: Functional interfaces in Java 8 and RxJava
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 8和RxJava中的函数接口
- en: 'Java 8 comes with a special package containing functional interfaces for common
    cases. This package is `java.util.function`, and we are not going to look at it
    in detail in this book, but will present some of them that are worth mentioning:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8带有一个特殊的包，其中包含常见情况的函数接口。这个包是`java.util.function`，我们不会在本书中详细介绍它，但会介绍一些值得一提的接口：
- en: '`Consumer<T>`: This represents a function that accepts an argument and returns
    nothing. Its abstract method is `void accept(T)`. As an example, we can use it
    to assign the `System.out::println` method to a variable, as follows:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Consumer<T>`：这代表接受一个参数并返回空的函数。它的抽象方法是`void accept(T)`。例如，我们可以将`System.out::println`方法分配给一个变量，如下所示：'
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`Function<T,R>`: This represents a function that accepts one argument of a
    given type and returns a result of an arbitrary type. Its abstract method is `R
    accept(T)`, and it can be used for mapping. We don''t need the `Mapper` interface
    at all! Let''s take a look at the following code snippet:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Function<T,R>`：这代表接受给定类型的一个参数并返回任意类型结果的函数。它的抽象方法是`R accept(T)`，可以用于映射。我们根本不需要`Mapper`接口！让我们看一下以下代码片段：'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`Predicate<T>`: This stands for a function with only one argument that returns
    a Boolean result. Its abstract method is `boolean test(T)` and it can be used
    for filtering. Let''s take a look at the following code:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Predicate<T>`：这代表只有一个参数并返回布尔结果的函数。它的抽象方法是`boolean test(T)`，可以用于过滤。让我们看一下以下代码：'
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are a lot of functional interfaces similar to these; for example, a function
    with two arguments, or a binary operator. This is again a function with two arguments,
    but both of the same type and returning a result with the same type. They are
    there to help reuse lambdas in our code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多类似的函数接口；例如，带有两个参数的函数，或者二元运算符。这又是一个带有两个参数的函数，但两个参数类型相同，并返回相同类型的结果。它们有助于在我们的代码中重用lambda。
- en: The good thing is that RxJava is lambda compatible. This means that the actions
    we were passing to the `subscribe` method are in fact functional interfaces!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 好处是RxJava与lambda兼容。这意味着我们传递给`subscribe`方法的动作实际上是函数接口！
- en: RxJava's functional interfaces are in the `rx.functions` package. All of them
    extend a base **marker** **interface** (interface with no methods, used for type
    checking), called `Function`. Additionally, there is another marker interface,
    extending the `Function` one, called `Action`. It is used to mark consumers (functions,
    returning nothing).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava的函数接口在`rx.functions`包中。它们都扩展了一个基本的**标记** **接口**（没有方法的接口，用于类型检查），称为`Function`。此外，还有另一个标记接口，扩展了`Function`，称为`Action`。它用于标记消费者（返回空的函数）。
- en: 'RxJava has eleven `Action` interfaces:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava有十一个`Action`接口：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: They can be used mainly for subscriptions (`Action1` and `Action0`). The `Observable.OnSubscribe<T>`
    parameter, which we saw in [Chapter 1](ch01.html "Chapter 1. An Introduction to
    Reactive Programming"), *An Introduction to Reactive Programming*, (used for creating
    custom observables) extends the `Action` interface too.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它们主要用于订阅(`Action1`和`Action0`)。我们在[第1章](ch01.html "第1章。响应式编程简介")中看到的`Observable.OnSubscribe<T>`参数（用于创建自定义可观察对象）也扩展了`Action`接口。
- en: Analogically, there are eleven `Function` extenders representing function returning
    result. They are `Func0<R>`, `Func1<T1, R>` … `Func9<T1,T2,T3,T4,T5,T6,T7,T8,T9,R>`,
    and `FuncN<R>`. They are used for mapping, filtering, combining, and many other
    purposes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，有十一个`Function`扩展器代表返回结果的函数。它们是`Func0<R>`，`Func1<T1, R>`... `Func9<T1,T2,T3,T4,T5,T6,T7,T8,T9,R>`和`FuncN<R>`。它们用于映射、过滤、组合和许多其他目的。
- en: Every operator and subscribe method in RxJava is applicable to one or more of
    these interfaces. This means that we can use lambda expressions instead of anonymous
    inner classes in RxJava almost everywhere. From this point on, all our examples
    will use lambdas in order to be more readable and somewhat functional.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava中的每个操作符和订阅方法都适用于一个或多个这些接口。这意味着我们几乎可以在RxJava的任何地方使用lambda表达式代替匿名内部类。从这一点开始，我们所有的示例都将使用lambda，以便更易读和有些函数式。
- en: Now, let's look at one big RxJava example implemented with lambdas. This is
    our familiar Reactive Sum example!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个使用lambda实现的大型RxJava示例。这是我们熟悉的响应式求和示例！
- en: Implementing the reactive sum example with lambdas
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lambda实现响应式求和示例
- en: 'So this time, our main piece of code will be quite similar to the previous
    one:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这次，我们的主要代码片段将与之前的相似：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only difference is that we are going to take a more functional approach
    in calculating our sum and not to keep the same state. We won't be implementing
    the `Observer` interface; instead, we are going to pass lambdas to subscribe.
    This solution is much cleaner.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是我们将采用更加功能性的方法来计算我们的总和，而不是保持相同的状态。我们不会实现`Observer`接口；相反，我们将传递lambda来订阅。这个解决方案更加清晰。
- en: 'The `CreateObservable.from(InputStream)` method is a lot like we used previously.
    We will skip it and look at the `Observable<Double> varStream(String, Observable<String>)`
    method, which creates the `Observable` instances representing the collectors:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateObservable.from(InputStream)`方法与我们之前使用的非常相似。我们将跳过它，看看`Observable<Double>
    varStream(String, Observable<String>)`方法，它创建了代表收集器的`Observable`实例：'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This method is much shorter than used previously and looks simpler. But semantically,
    it is the same. It creates an `Observable` instance connected to a source observable
    producing arbitrary strings, and if a string is in the format it expects, it extracts
    a double number from it and emits this number. The logic responsible for checking
    the format of the input and extracting the number is only four lines and is represented
    by simple lambdas. Let''s examine it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法比以前使用的要短得多，看起来更简单。但从语义上讲，它是相同的。它创建了一个与源可观察对象连接的`Observable`实例，该源可观察对象产生任意字符串，如果字符串符合它期望的格式，它会提取出一个双精度数并发出这个数字。负责检查输入格式和提取数字的逻辑只有四行，由简单的lambda表示。让我们来看一下：
- en: We map a lambda that creates a `matcher` instance using the pattern expected
    and the input string.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们映射一个lambda，使用预期的模式和输入字符串创建一个`matcher`实例。
- en: Using the `filter()` method, only the input that is in the right format is filtered.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`filter()`方法，只过滤正确格式的输入。
- en: Using a `map()` operator, we create a string from the `matcher` instance, which
    contains only the number data we need.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`map()`操作符，我们从`matcher`实例中创建一个字符串，其中只包含我们需要的数字数据。
- en: And again with the `map()` operator, the string is turned into a double number.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`map()`操作符，将字符串转换为双精度数。
- en: 'And as for the new `void reactiveSum(Observable<Double>, Observable<Double>)`
    method''s implementation, use the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 至于新的`void reactiveSum(Observable<Double>, Observable<Double>)`方法的实现，请使用以下代码：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s take a look at the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: Again, we use the `combineLatest()` method, but this time the third argument
    is a simple lambda that implements a sum.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`combineLatest()`方法，但这次第三个参数是一个简单的lambda，实现了求和。
- en: 'The `subscribe()` method takes three lambda expressions that are triggered
    when the following events occur:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`subscribe()`方法接受三个lambda表达式，当发生以下事件时触发：'
- en: The sum changes
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总和改变了
- en: There is an error
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个错误
- en: The program is about to finish
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序即将完成
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source of this example can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/ReactiveSumV2.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/ReactiveSumV2.java).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/ReactiveSumV2.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/ReactiveSumV2.java)上查看/下载。
- en: Everything becomes simpler using lambdas. Looking at the preceding program,
    we can see that most of the logic is composed of small, independent functions,
    chained using other functions. This is what we mean by being functional, to express
    our programs using such small reusable functions that take other functions and
    return functions and data abstractions, which transform input data using chains
    of functions in order to produce the wanted result. But let's look at these functions
    in depth.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lambda使一切变得更简单。看看前面的程序，我们可以看到大部分逻辑由小型独立函数组成，使用其他函数链接在一起。这就是我们所说的功能性，使用这样的小型可重用函数来表达我们的程序，这些函数接受其他函数并返回函数和数据抽象，使用函数链转换输入数据以产生所需的结果。但让我们深入研究这些函数。
- en: Pure functions and higher order functions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数和高阶函数
- en: You don't have to remember most of the terms introduced in this chapter; the
    important thing is to understand how they help us write simplistic but powerful
    programs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必记住本章介绍的大部分术语；重要的是要理解它们如何帮助我们编写简单但功能强大的程序。
- en: RxJava's approach has many functional ideas incorporated, so it is important
    for us to learn how to think in more functional ways in order to write better
    reactive applications.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava的方法融合了许多功能性思想，因此重要的是我们学会如何以更加功能性的方式思考，以便编写更好的响应式应用程序。
- en: Pure functions
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: 'A **pure function** is a function whose return value is only determined by
    its input, without observable **side effects**. If we call it with the same parameters
    *n* times, we are going to get the same result every single time. For example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯函数**是一个其返回值仅由其输入决定的函数，没有可观察的**副作用**。如果我们用相同的参数调用它*n*次，每次都会得到相同的结果。例如：'
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each time, the even function returns `False` because it *depends only on its
    input*, which is the same each time and is not even.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每次，偶函数返回`False`，因为它*仅依赖于其输入*，而每次输入都是相同的，甚至不是。
- en: This property of pure functions is called **idempotence**. Idempotent functions
    don't depend on time, so they can treat continuous data as infinite data streams.
    And this is how ever-changing data is represented in RxJava (`Observable` instances).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的这个特性称为**幂等性**。幂等函数不依赖于时间，因此它们可以将连续数据视为无限数据流。这就是RxJava（`Observable`实例）中表示不断变化的数据的方式。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that, here, the term "idempotence" is used in its computer science meaning.
    In computing, an idempotent operation is one that has no additional effect if
    it is called more than once with the same input parameters; in mathematics, an
    idempotent operation is one that satisfies this expression: *f(f(x)) = f(x)*.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这里，“幂等性”一词是以计算机科学的意义使用的。在计算中，幂等操作是指如果使用相同的输入参数多次调用它，它不会产生额外的效果；在数学中，幂等操作是指满足这个表达式的操作：*f(f(x))
    = f(x)*。
- en: 'Pure functions *do not cause side-effects*. For example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数*不会产生副作用*。例如：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This function is not pure because it prints on the output a message every time
    it is called. So it does two things: it tests whether the number is even, and
    it outputs a message as a side-effect. A side-effect is any possible observable
    output the function can produce, for example, triggering events and throwing exceptions
    and I/O, different from its return value. A side-effect also changes shared states
    or mutable arguments.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不是纯的，因为每次调用它时都会在输出上打印一条消息。所以它做了两件事：它测试数字是否为偶数，并且作为副作用输出一条消息。副作用是函数可以产生的任何可能的可观察输出，例如触发事件、抛出异常和I/O，与其返回值不同。副作用还会改变共享状态或可变参数。
- en: Think about it. If most of your program is composed of pure functions, it will
    be easy to scale and to run parts of it in parallel because pure functions can't
    conflict with each other and don't change the shared state.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看。如果你的大部分程序由纯函数组成，它将很容易扩展，并且可以并行运行部分，因为纯函数不会相互冲突，也不会改变共享状态。
- en: Another thing that's worth mentioning in this section is **immutability**. Immutable
    objects are objects that can not change their state. A good example is the `String`
    class in Java. The `String` instances cannot be changed; even methods such as
    `substring` create a new instance of `String` without modifying the calling one.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中值得一提的另一件事是**不可变性**。不可变对象是指不能改变其状态的对象。Java中的`String`类就是一个很好的例子。`String`实例是不可变的；即使像`substring`这样的方法也会创建一个新的`String`实例，而不会修改调用它的实例。
- en: If we pass immutable data to a pure function, we can be sure that every time
    it is called with this data it will return the same. With **mutable** objects,
    is not quite the same when we write parallel programs, because one thread can
    change the object's state. In this case, the pure function will return a different
    result if called, and thus will stop being idempotent.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将不可变数据传递给纯函数，我们可以确保每次使用这些数据调用它时，它都会返回相同的结果。对于**可变**对象，在编写并行程序时情况就不太一样了，因为一个线程可以改变对象的状态。在这种情况下，如果调用纯函数，它将返回不同的结果，因此不再是幂等的。
- en: If we store our data in immutable objects and operate over it using pure functions,
    creating new immutable objects in the process, we will be safe from unexpected
    concurrency issues. There will be no global state and no mutable state; everything
    will be simple and predictable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将数据存储在不可变对象中，并使用纯函数对其进行操作，在此过程中创建新的不可变对象，我们将不会受到意外并发问题的影响。不会有全局状态和可变状态；一切都将简单而可预测。
- en: Using immutable objects is tricky; every action with them creates new instances,
    and this could eat up memory. But there are methods for avoiding that; for example,
    reusing as much as we can from the source immutable, or making the immutable objects'
    lifecycles as short as possible (because short lifecycle objects are friendly
    to GC or caching). Functional programs should be designed to work with immutable
    stateless data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可变对象是棘手的；对它们的每个操作都会创建新的实例，这可能会消耗内存。但有方法可以避免这种情况；例如，尽可能多地重用源不可变对象，或使不可变对象的生命周期尽可能短（因为生命周期短的对象对GC或缓存友好）。函数式程序应该设计为使用不可变的无状态数据。
- en: Complex programs can't be composed only of pure functions, but whenever it is
    possible, it is good to use them. In this chapter's implementation of *The Reactive
    Sum*, we passed to `map()`, `filter()`, and `combineLatest()` only pure functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的程序不能只由纯函数组成，但只要可能，最好使用它们。在本章对*The Reactive Sum*的实现中，我们只传递了纯函数给`map()`、`filter()`和`combineLatest()`。
- en: Speaking of the `map()` and `filter()` functions, we call them higher order
    functions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到`map()`和`filter()`函数，我们称它们为高阶函数。
- en: Higher order functions
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶函数
- en: A function with at least one parameter of type function or a function that returns
    functions is called a **higher order function**. Of course, *higher order functions
    can be pure*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有一个函数类型参数或返回函数的函数被称为**高阶函数**。当然，*高阶函数可以是纯的*。
- en: 'Here is an example of a higher function that takes function parameters:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受函数参数的高阶函数的例子：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It takes two functions of type `T -> int/R -> int` and some data in order to
    call them and sum their results. For example, we can do it like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要两个类型为`T -> int/R -> int`的函数和一些数据来调用它们并对它们的结果求和。例如，我们可以这样做：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we sum the square of three and the cube of two.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们对三的平方和两的立方求和。
- en: 'But the idea of higher order functions is to be flexible. For example, we can
    use the `highSum()` function for a completely different purpose, say, summing
    strings, as shown here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但高阶函数的理念是灵活的。例如，我们可以使用`highSum()`函数来完成完全不同的目的，比如对字符串求和，如下所示：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, a higher order function can be used to apply the same behavior to different
    kinds of input.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，高阶函数可以用于将相同的行为应用于不同类型的输入。
- en: If the first two arguments we pass to the `highSum()` function are pure functions,
    it will be a pure function as well. The `strToInt` parameter is a pure function,
    and if we call the `highSum(strToInt, strToInt, "4", "5")` method *n* times, it
    will return the same result and won't have side-effects.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递给`highSum()`函数的前两个参数是纯函数，那么它也将是一个纯函数。`strToInt`参数是一个纯函数，如果我们调用`highSum(strToInt,
    strToInt, "4", "5")`方法*n*次，它将返回相同的结果，并且不会产生副作用。
- en: 'Here is another example of a higher order function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个高阶函数的例子：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is a function that returns another function. It can be used like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个返回另一个函数的函数。它可以这样使用：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code for this example can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/PureAndHigherOrderFunctions.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/PureAndHigherOrderFunctions.java).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/PureAndHigherOrderFunctions.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter02/PureAndHigherOrderFunctions.java)找到。
- en: Functions like these can be used to implement different behaviors that have
    something in common. In object-oriented programming we define classes and then
    extend them, overloading their methods. In functional programming, we define higher
    order functions as interfaces and call them with different parameters, resulting
    in different behaviors.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以用来实现具有共同点的不同行为。在面向对象编程中，我们定义类然后扩展它们，重载它们的方法。在函数式编程中，我们将高阶函数定义为接口，并使用不同的参数调用它们，从而产生不同的行为。
- en: These functions are *first-class citizens*; we can code our logic using only
    functions, chaining them, and handling our data, transforming, filtering, or accumulating
    it into a result.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数是*一等公民*；我们可以仅使用函数编写我们的逻辑，将它们链接在一起，并处理我们的数据，将其转换、过滤或累积成一个结果。
- en: RxJava and functional programming
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RxJava和函数式编程
- en: 'Functional concepts such as pure functions and higher order functions are very
    important to RxJava. RxJava''s `Observable` class is an implementation of a *fluent
    interface*. This means that most of its instance methods return an `Observable`
    instance. For example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数和高阶函数等函数式概念对RxJava非常重要。RxJava的`Observable`类是*流畅接口*的一种实现。这意味着它的大多数实例方法都返回一个`Observable`实例。例如：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `map()` operator returns a new `Observable` instance, emitting the data
    transformed by it. Operators such as `map()` are clearly higher order functions,
    and we can pass other functions to them. So, a typical RxJava program is represented
    by a chain of operators chained to an `Observable` instance to which multiple
    *subscribers* can subscribe. These functions chained together can benefit from
    the topics covered in this chapter. We can pass lambdas to them instead of anonymous
    interface implementations (as we saw with the second implementation of the *Reactive
    Sum*), and we should try working with immutable data and pure functions when possible.
    This way, our code will be simple and safe.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`操作符返回一个新的`Observable`实例，发出经过转换的数据。诸如`map()`之类的操作符显然是高阶函数，我们可以向它们传递其他函数。因此，典型的RxJava程序由一系列操作符链接到一个`Observable`实例表示，多个*订阅者*可以订阅它。这些链接在一起的函数可以受益于本章涵盖的主题。我们可以向它们传递lambda而不是匿名接口实现（就像我们在*Reactive
    Sum*的第二个实现中看到的那样），并且我们应该尽可能使用不可变数据和纯函数。这样，我们的代码将会简单且安全。'
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've looked at some of the functional programming principles
    and terms. We've learned how to write programs composed of small pure function
    actions, chained together using higher order functions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了一些函数式编程原则和术语。我们学会了如何编写由小的纯函数动作组成的程序，使用高阶函数链接在一起。
- en: As functional programming is getting increasingly popular, developers proficient
    in it will be in high demand in the very near future. That's because it helps
    us achieve scalability and parallelism with ease. And what is more, if we add
    the reactive idea to it, it becomes even more appealing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 随着函数式编程的日益流行，精通它的开发人员将在不久的将来需求量很大。这是因为它帮助我们轻松实现可伸缩性和并行性。而且，如果我们将响应式思想加入其中，它将变得更加吸引人。
- en: That's why we are going to dive into the RxJava framework in the next chapters,
    learning how to use it for our benefit. We'll begin with the `Observable` instance
    creation techniques. This will provide us with the skill to create an `Observable`
    instance from everything, thus turning almost everything into a functional reactive
    program.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们将在接下来的章节中深入研究RxJava框架，学习如何将其用于我们的利益。我们将从`Observable`实例创建技术开始。这将使我们具备从任何东西创建`Observable`实例的技能，从而将几乎一切转变为函数式响应式程序。
