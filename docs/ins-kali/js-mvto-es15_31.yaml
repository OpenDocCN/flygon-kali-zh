- en: Chapter 3. Communication between Browsers in Real Time
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。实时浏览器间通信
- en: To implement features such as audio/video chat or some other features in websites
    that require real-time peer-to-peer (browser-to-browser) data transfer, or need
    to retrieve audio/video stream from a microphone, webcam, or any other device,
    we had to use browser plugins such as Java and Flash. There are various issues
    with making websites depend on browser plugins, such as mobile browsers not supporting
    plugins and plugins requiring to be kept up to date. Therefore, WebRTC was introduced
    to solve these problems, that is, browsers that support WebRTC provide APIs to
    exchange data in real time directly between browsers and also retrieve stream
    from physical media sources without the use of plugins. In this chapter, we will
    discuss WebRTC and also the PeerJS library that wraps the WebRTC APIs to provide
    an easy to use API to work with WebRTC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要在网站中实现音频/视频聊天或其他需要实时对等（浏览器对浏览器）数据传输的功能，或者需要从麦克风、网络摄像头或任何其他设备中检索音频/视频流，我们必须使用Java和Flash等浏览器插件。让网站依赖浏览器插件存在各种问题，例如移动浏览器不支持插件，插件需要保持更新。因此，WebRTC被引入来解决这些问题，即支持WebRTC的浏览器提供API，可以直接在浏览器之间交换数据，并且无需使用插件即可从物理媒体源中检索流。在本章中，我们将讨论WebRTC以及包装WebRTC
    API以提供易于使用的API与WebRTC一起工作的PeerJS库。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Discussing various APIs provided by WebRTC
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论WebRTC提供的各种API
- en: Retrieving stream from physical media input devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从物理媒体输入设备中检索流
- en: Displaying a media stream
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示媒体流
- en: Discussing protocols used by WebRTC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论WebRTC使用的协议
- en: Exchanging media stream and arbitrary data between peers using PeerJS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PeerJS在对等方之间交换媒体流和任意数据
- en: Discussing topics related to the fundamentals of WebRTC and PeerJS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论与WebRTC和PeerJS基础相关的主题
- en: Terminologies
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语
- en: Before we get into WebRTC and PeerJS, you need to know the meaning of some terms
    that we are going to use. These terms are discussed in the following sections.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解WebRTC和PeerJS之前，您需要了解一些我们将要使用的术语的含义。这些术语将在以下部分中讨论。
- en: Stream
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流
- en: A **stream** is a sequence of any kind of data that is made available over time.
    A stream object represents a stream. Usually, an event handler or callback is
    attached to the stream object, which is invoked whenever new data is available.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**流**是随时间提供的任何类型的数据序列。流对象表示一个流。通常，事件处理程序或回调附加到流对象上，每当有新数据可用时就会被调用。'
- en: A **media stream** is a stream whose data is either audio or video. Similarly,
    a **media source** is a physical device, file, or something that provides data
    that is audio or video. A **media consumer** is also a physical device, API, or
    something that uses media stream.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**媒体流**是其数据为音频或视频的流。同样，**媒体源**是提供音频或视频数据的物理设备、文件或其他内容。**媒体使用者**也是物理设备、API或其他使用媒体流的内容。'
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WebRTC allows us to retrieve a media stream of physical media sources, such
    as microphones, webcams, screens, and so on. We will discuss more about it later
    in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: WebRTC允许我们从物理媒体源（如麦克风、网络摄像头、屏幕等）中检索媒体流。我们将在本章后面更多地讨论它。
- en: Peer-to-peer network model
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对等网络模型
- en: Peer-to-peer model is the opposite of the client-server model. In the client-server
    model, the server provides resources to the clients, whereas in peer-to-peer model,
    every node in the network acts as a server and client, that is, every node provides
    and consumes resources. Peers in the peer-to-peer model communicate with each
    other directly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对等模型是客户端-服务器模型的相反。在客户端-服务器模型中，服务器向客户端提供资源，而在对等模型中，网络中的每个节点都充当服务器和客户端，也就是说，每个节点都提供和消耗资源。对等模型中的对等方直接相互通信。
- en: To establish a peer-to-peer connection, we need a signaling server, which is
    used for signaling. **Signaling** refers to the exchange of data by peers that
    is required to establish a peer-to-peer connection. Data such as session control
    messages, network configuration, and so on is required to establish a peer-to-peer
    connection. A signaling server implements a signaling protocol such as SIP, Jingle,
    or some other protocol.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立对等连接，我们需要一个用于信令的信令服务器。**信令**是指对等方之间建立对等连接所需的数据交换。需要诸如会话控制消息、网络配置等数据来建立对等连接。信令服务器实现信令协议，如SIP、Jingle或其他协议。
- en: 'A model is selected depending on the requirements and resource availability
    for the application. Let''s consider some examples:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 选择模型取决于应用程序的要求和资源可用性。让我们考虑一些例子：
- en: To build a video chat app, we should use the peer-to-peer model instead of the
    client-server model. As each node, in this case, is going to produce a lot data
    (or frames), and send the data to other node in real time, the server requires
    a lot of networks and other resources, increasing the server running cost. So,
    the peer-to-peer model is the best option for a video chat app. For example, Skype
    video chat is based on the peer-to-peer model.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要构建视频聊天应用程序，我们应该使用对等模型而不是客户端-服务器模型。在这种情况下，每个节点都会产生大量数据（或帧），并实时将数据发送到其他节点，服务器需要大量的网络和其他资源，增加了服务器的运行成本。因此，对等模型是视频聊天应用程序的最佳选择。例如，Skype视频聊天是基于对等模型的。
- en: To build a text chat app that stores messages in a centralized database, we
    should use the client-server model as the amount of data that a client produces
    is not very high and you would also want to store the messages in a centralized
    database. For example, the Facebook messenger is based on the client-server model.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要构建一个将消息存储在集中式数据库中的文本聊天应用程序，我们应该使用客户端-服务器模型，因为客户端产生的数据量不是很大，您还希望将消息存储在集中式数据库中。例如，Facebook
    Messenger是基于客户端-服务器模型的。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To establish a peer-to-peer connection using WebRTC, you will need a signaling
    server, STUN server, and optional TURN server. We will discuss more about it later
    in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用WebRTC建立对等连接，您将需要一个信令服务器、STUN服务器和可选的TURN服务器。我们将在本章后面更多地讨论它。
- en: Real-time data
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时数据
- en: '**Real-time data** is the data that needs to be processed and transferred without
    much delay. For example, video chatting, live analytics, live stock price, live
    streaming, text chat, live score, online multiplayer game data, and so on are
    all real-time data.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**实时数据**是需要在没有太多延迟的情况下进行处理和传输的数据。例如，视频聊天、实时分析、实时股票价格、实时流媒体、文本聊天、实时比分、在线多人游戏数据等都属于实时数据。'
- en: Real-time data transfer is a difficult task to achieve. The techniques and technologies
    used for real-time data transfer depend on the amount of data and whether the
    loss of data during data transfer is tolerable or not. If the real-time data is
    large, and the loss of data is intolerable, then it requires a lot of resources
    to achieve real-time data transfer, making it practically impossible to achieve
    real-time data transfer. For example, while video chatting, every user generates
    a lot of frames. If some frames are lost, then it is tolerable, therefore in this
    case, we can use the UDP protocol as a transport layer protocol that is unreliable
    and also has less overhead than TCP, making UDP very suitable for video chat application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 实时数据传输是一项难以实现的任务。用于实时数据传输的技术和技术取决于数据量以及数据传输过程中数据丢失是否可容忍。如果实时数据量大，并且数据丢失是不可容忍的，那么需要大量资源来实现实时数据传输，使得实际上不可能实现实时数据传输。例如，在视频聊天时，每个用户都会生成大量帧。如果有些帧丢失，那是可以容忍的，因此在这种情况下，我们可以使用
    UDP 协议作为传输层协议，它是不可靠的，而且开销比 TCP 小，非常适合视频聊天应用。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WebRTC allows us to transfer real-time media stream produced by it using the
    SRTP protocol. To transfer arbitrary data, it uses the SCTP protocol. We will
    discuss more about what these protocols are later in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: WebRTC 允许我们使用 SRTP 协议传输其产生的实时媒体流。为了传输任意数据，它使用 SCTP 协议。我们将在本章后面讨论这些协议是什么。
- en: Introduction to WebRTC
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebRTC 简介
- en: '**Web Real-Time Communications (WebRTC)** is a browser technology that enables
    retrieval of media stream of physical media sources and exchange media stream
    or any other data in real time. It comprises of three APIs: the `MediaStream`
    constructor, `RTCPeerConnection` constructor, and `RTCDataChannel` interface.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web 实时通信（WebRTC）** 是一种浏览器技术，它使得可以检索物理媒体源的媒体流，并在实时中交换媒体流或任何其他数据。它包括三个 API：`MediaStream`
    构造函数、`RTCPeerConnection` 构造函数和 `RTCDataChannel` 接口。'
- en: In short, `MediaStream` is used to retrieve the stream of physical media source,
    `RTCPeerConnection` is used to exchange `MediaStream` among peers in real time,
    and finally, `RTCDataChannel` is used to exchange arbitrary data among peers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`MediaStream` 用于检索物理媒体源的流，`RTCPeerConnection` 用于在对等方之间实时交换 `MediaStream`，最后，`RTCDataChannel`
    用于在对等方之间交换任意数据。
- en: Let's see how these APIs work.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些 API 是如何工作的。
- en: MediaStream API
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MediaStream API
- en: Two main components of MediaStream API are the `MediaStream` constructor and
    `MediaStreamTrack` interface.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaStream` API 的两个主要组件是 `MediaStream` 构造函数和 `MediaStreamTrack` 接口。'
- en: A track represents the stream of a media source. A track implements the `MediaStreamTrack`
    interface. A track can either be an audio track or be a video track. That is,
    a track attached to an audio source is an audio track, and a track attached to
    a video source is a video track. There can be multiple tracks attached to a particular
    media source. We can also attach constraints to a track. For example, a track
    attached to a webcam can have constraints such as the minimum video resolution
    and FPS. Each track has its own constraints.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 轨道代表媒体源的流。轨道实现了 `MediaStreamTrack` 接口。轨道可以是音频轨道或视频轨道。也就是说，连接到音频源的轨道是音频轨道，连接到视频源的轨道是视频轨道。可以连接多个轨道到特定的媒体源。我们还可以对轨道附加约束。例如，连接到网络摄像头的轨道可以有最小视频分辨率和
    FPS 等约束。每个轨道都有自己的约束。
- en: You can change the constraints of a track after it's created using the `applyConstraints()`
    method of the `MediaStreamTrack` interface. You can retrieve the constraints applied
    to a track anytime using the `getSettings()` method of the `MediaStreamTrack`
    interface. To detach a track from a media source, that is, to stop the track permanently,
    we can use the `stop()` method of the `MediaStreamTrack` interface. To pause a
    track, that is, to stop the track temporarily, we can assign `false` to the `enabled`
    property of the `MediaStreamTrack` interface.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `MediaStreamTrack` 接口的 `applyConstraints()` 方法在创建后更改轨道的约束。您可以随时使用 `MediaStreamTrack`
    接口的 `getSettings()` 方法检索应用于轨道的约束。要从媒体源中分离轨道，也就是永久停止轨道，我们可以使用 `MediaStreamTrack`
    接口的 `stop()` 方法。要暂停轨道，也就是暂时停止轨道，我们可以将 `false` 赋给 `MediaStreamTrack` 接口的 `enabled`
    属性。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Find out more about the `MediaStreamTrack` interface at [https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack)
    查找有关 `MediaStreamTrack` 接口的更多信息。
- en: A track can either be a local or remote track. A local track represents the
    stream of a local media source; whereas, a remote track represents the stream
    of a remote media source. You cannot apply constraints to the remote track. To
    find whether a track is local or remote, we can use the `remote` property of the
    `MediaStreamTrack` interface.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 轨道可以是本地轨道或远程轨道。本地轨道代表本地媒体源的流；而远程轨道代表远程媒体源的流。您不能对远程轨道应用约束。要找出轨道是本地还是远程，我们可以使用
    `MediaStreamTrack` 接口的 `remote` 属性。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will come across the remote track while exchanging tracks between peers.
    When we send a local track to a peer, the other peer receives the remote version
    of the track.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在交换轨道时，我们会遇到远程轨道。当我们将本地轨道发送给对等方时，另一个对等方会接收到轨道的远程版本。
- en: A `MediaStream` holds multiple tracks together. Technically, it doesn't do anything.
    It just represents a group of tracks that should be played, stored, or transferred
    together in a synchronized manner.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaStream` 包含多个轨道。从技术上讲，它并不执行任何操作。它只是表示应该以同步的方式播放、存储或传输的一组轨道。'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Find out more about the `MediaStream` constructor at [https://developer.mozilla.org/en/docs/Web/API/MediaStream](https://developer.mozilla.org/en/docs/Web/API/MediaStream).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://developer.mozilla.org/en/docs/Web/API/MediaStream](https://developer.mozilla.org/en/docs/Web/API/MediaStream)上查找有关`MediaStream`构造函数的更多信息。
- en: 'The `getSources()` method of the `MediaStreamTrack` object allows us to retrieve
    the ID of all the media devices, such as speakers, microphones, webcams, and so
    on. We can use the ID to create a track if the ID represents a media input device.
    The following is an example that demonstrates this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaStreamTrack`对象的`getSources()`方法允许我们检索所有媒体设备的ID，例如扬声器，麦克风，网络摄像头等。如果ID表示媒体输入设备，则可以使用该ID创建轨道。以下是演示示例：'
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output will vary for everyone. Here is the output I got:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输出对每个人都会有所不同。这是我得到的输出：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: navigator.getUserMedia
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: navigator.getUserMedia
- en: 'There are various APIs that return `MediaStream` with tracks in it. One such
    method is `navigator.getUserMedia()`. Using `navigator.getUserMedia()`, we can
    retrieve a stream from media input sources, such as microphones, webcams, and
    so on. The following is an example to demonstrate:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种API返回带有轨道的`MediaStream`。`navigator.getUserMedia()`就是其中之一。使用`navigator.getUserMedia()`，我们可以从媒体输入源（如麦克风，网络摄像头等）检索流。以下是一个示例：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run the preceding code, the browser will display a popup seeking permission
    from the user. The user has to give the permission to the code to access the media
    input devices.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行上述代码时，浏览器将显示一个弹出窗口，请求用户的许可。用户必须允许代码访问媒体输入设备。
- en: By default, the media input devices to which the tracks are attached while using
    `getUserMedia()` depends on the browser. Some browsers let the user choose the
    audio and video device that they want to use, while other browsers use the default
    audio and video devices listed in the operating system configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用`getUserMedia()`时轨道附加到的媒体输入设备取决于浏览器。一些浏览器允许用户选择他们想要使用的音频和视频设备，而其他浏览器使用操作系统配置中列出的默认音频和视频设备。
- en: We can also provide the `sourceId` property assigned to the ID of the media
    input device in the constraint object's `audio` or `video` property's `mandatory`
    property to make `getUserMedia()` attach tracks to these devices. So, if there
    are multiple webcams and microphones, then you can use `MediaStreamTrack.getSources()`
    to let the user choose a media input device and provide this media input device
    ID to `getUserMedia()` instead of relying on the browser, which doesn't guarantee
    whether it will let the user choose a media input device.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在约束对象的`audio`或`video`属性的`mandatory`属性中提供`sourceId`属性，以将其分配给媒体输入设备的ID，以便使`getUserMedia()`将轨道附加到这些设备。因此，如果有多个网络摄像头和麦克风，那么可以使用`MediaStreamTrack.getSources()`让用户选择媒体输入设备，并将此媒体输入设备ID提供给`getUserMedia()`，而不是依赖浏览器，这并不保证它是否会让用户选择媒体输入设备。
- en: The first parameter that it takes is a constraint object with audio and video
    track constraints. Mandatory constraints are those constraints that must be applied.
    Optional indicates that they are not very important, so they can be omitted if
    it's not possible to apply them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受的第一个参数是一个带有音频和视频轨道约束的约束对象。强制约束是必须应用的约束。可选表示它们不是非常重要的，因此如果不可能应用它们，则可以省略它们。
- en: Some important constraints of an audio track are `volume`, `sampleRate`, `sampleSize`,
    and `echoCancellation`. Some important constraints of a video track are `aspectRatio`,
    `facingMode`, `frameRate`, `height`, and `width`. If a constraint is not provided,
    then its default value is used.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 音频轨道的一些重要约束是`音量`，`采样率`，`采样大小`和`回声消除`。视频轨道的一些重要约束是`宽高比`，`朝向模式`，`帧速率`，`高度`和`宽度`。如果没有提供约束，则使用默认值。
- en: You can simply set the `audio` or `video` property to `false` if you don't want
    to create the audio or video tracks respectively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不想分别创建音频或视频轨道，可以将`audio`或`video`属性简单设置为`false`。
- en: We can retrieve the tracks of `MediaStream` using the `getTracks()` method of
    `MediaStream`. Similarly, we can add or remove a track using the `addTrack()`
    and `removeTrack()` methods, respectively. Whenever a track is added, the `onaddtrack`
    event is triggered. Similarly, whenever a track is removed, the `onendtrack` is
    triggered.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`MediaStream`的`getTracks()`方法检索`MediaStream`的轨道。类似地，我们可以使用`addTrack()`和`removeTrack()`方法添加或删除轨道。每当添加轨道时，都会触发`onaddtrack`事件。同样，每当删除轨道时，都会触发`onendtrack`事件。
- en: If we already have some tracks, then we can directly use the `MediaStream` constructor
    to create `MediaStream` with the tracks. The `MediaStream` constructor takes an
    array of tracks and returns `MediaStream` with the reference of the tracks added
    to it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经有一些轨道，那么我们可以直接使用`MediaStream`构造函数创建带有轨道引用的`MediaStream`。`MediaStream`构造函数接受一个轨道数组，并返回带有添加到其中的轨道引用的`MediaStream`。
- en: An API that reads data from tracks of `MediaStream` is called a `MediaStream`
    consumer. Some of the `MediaStream` consumers are the `<audio>` tag, `<video>`
    tag, `RTCPeerConnection`, `Media Recorder` API, `Image Capture` API, `Web Audio`
    API, and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从`MediaStream`的轨道中读取数据的API称为`MediaStream`消费者。一些`MediaStream`消费者是`<audio>`标签，`<video>`标签，`RTCPeerConnection`，`Media
    Recorder` API，`Image Capture` API，`Web Audio` API等。
- en: 'Here is an example that demonstrates how to display data of tracks of `MediaStream`
    in the video tag:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，演示了如何在视频标签中显示`MediaStream`的轨道数据：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we have a `<video>` tag and a button to pause it. A video tag takes a URL
    and displays the resource.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个`<video>`标签和一个用于暂停的按钮。视频标签接受URL并显示资源。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before HTML5, HTML tags and CSS attributes could only read data from `http://`
    and `file://` URLs. However, in HTML5, they can read `blob://`, `data://`, `mediastream://`,
    and other such URLs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5之前，HTML标签和CSS属性只能从`http://`和`file://`的URL中读取数据。但是，在HTML5中，它们可以读取`blob://`，`data://`，`mediastream://`等其他URL。
- en: To display the output of `MediaStream` in the `<video>` tag, we need to use
    the `URL.createObjectURL()` method, which takes a blob, file object, or `MediaStream`
    and provides a URL to read its data. `URL.createObjectURL()` takes extra memory
    and CPU time to provide access to the value passed on to it via a URL, therefore,
    it is wise to release the URL using `URL.revokeObjectURL()` when we don't need
    the URL anymore.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`<video>`标签中显示`MediaStream`的输出，我们需要使用`URL.createObjectURL()`方法，该方法接受blob、文件对象或`MediaStream`并提供一个URL来读取其数据。`URL.createObjectURL()`需要额外的内存和CPU时间来提供对通过URL传递给它的值的访问，因此，当我们不再需要URL时，最好使用`URL.revokeObjectURL()`来释放URL。
- en: If there are multiple audio and video tracks in `MediaStream`, then `<video>`
    reads the first audio and video tracks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`MediaStream`中有多个音频和视频轨道，则`<video>`会读取第一个音频和视频轨道。
- en: RTCPeerConnection API
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RTCPeerConnection API
- en: '`RTCPeerConnection` allows two browsers to exchange `MediaStream` in real time.
    `RTCPeerConnection` is an instance of the `RTCPeerConnection` constructor.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTCPeerConnection`允许两个浏览器实时交换`MediaStream`。`RTCPeerConnection`是`RTCPeerConnection`构造函数的一个实例。'
- en: Establishing peer-to-peer connection
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建立点对点连接
- en: For a peer-to-peer connection to be established, a signaling server is needed.
    Through the signaling server, the peers exchange data required to establish a
    peer-to-peer connection. Actual data transfer takes place directly between peer-to-peer.
    The signaling server is just used to exchange pre-requirements to establish a
    peer-to-peer connection. Both the peers can disconnect from the signaling server
    once the peer-to-peer connection has been established. The signaling server doesn't
    need to be a highly configured server as the actual data is not transferred through
    it. Data transfer for a single peer-to-peer connection will be in some KB, so
    a decent server can be used for signaling.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立点对点连接，需要一个信令服务器。通过信令服务器，对等方交换建立点对点连接所需的数据。实际的数据传输直接在对等方之间进行。信令服务器只是用来交换建立点对点连接的先决条件。一旦建立了点对点连接，两个对等方就可以断开与信令服务器的连接。信令服务器不需要是一个高度配置的服务器，因为实际数据不是通过它传输的。单个点对点连接的数据传输量将在几KB左右，因此可以使用一个体面的服务器进行信令。
- en: A signaling server usually uses a signaling protocol, but it is also okay if
    it's an HTTP server as long as it can pass messages between two peers. WebRTC
    doesn't force us to use any particular signaling protocol.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 信令服务器通常使用信令协议，但如果它是一个HTTP服务器也可以，只要它能在两个对等方之间传递消息。WebRTC并不强制我们使用任何特定的信令协议。
- en: 'For example, say that there are two users, Alice and Bob, on two different
    browsers. If Alice wants to establish a peer-to-peer connection with Bob for chatting,
    then this is how a peer-to-peer connection would be established between them:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设有两个用户，Alice和Bob，在两个不同的浏览器上。如果Alice想要与Bob建立点对点连接进行聊天，那么这就是他们之间建立点对点连接的方式：
- en: They both will connect to a signaling server.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们两个都将连接到一个信令服务器。
- en: Alice will then send a request to Bob via the signaling server, requesting to
    chat.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后Alice将通过信令服务器向Bob发送一个请求，请求进行聊天。
- en: The signaling server can optionally check whether Alice is allowed to chat with
    Bob, and also if Alice and Bob are logged in. If yes, then the signaling server
    passes the message to Bob.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信令服务器可以选择检查Alice是否被允许与Bob聊天，以及Alice和Bob是否已登录。如果是，那么信令服务器将消息传递给Bob。
- en: Bob receives the request and sends a message to Alice via the signaling server,
    confirming to establish a peer-to-peer connection.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bob收到请求并通过信令服务器向Alice发送一条消息，确认建立点对点连接。
- en: Now both of them need to exchange messages related to session control, network
    configuration, and media capabilities. All these messages are exchanged between
    them by the `RTCPeerConnection`. So, they both need to create an `RTCPeerConnection`,
    initiate it, and attach an event handler to `RTCPeerConnection` that will be triggered
    by `RTCPeerConnection` when it wants to send a message via the signaling server.
    `RTCPeerConnection` passes the message to the event handler in the **Session Description
    Protocol** (**SDP**) format, and the messages for the `RTCPeerConnection` received
    from the signaling server must be fed to `RTCPeerConnection` in the SDP format,
    that is, `RTCPeerConnection` only understands the SDP format. You need to use
    your own programming logic to split custom messages and messages for `RTCPeerConnection`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在他们两个都需要交换与会话控制、网络配置和媒体能力相关的消息。所有这些消息都是通过`RTCPeerConnection`之间交换的。因此，他们都需要创建一个`RTCPeerConnection`，启动它，并附加一个事件处理程序到`RTCPeerConnection`，当`RTCPeerConnection`想要通过信令服务器发送消息时，它将触发`RTCPeerConnection`。`RTCPeerConnection`以**会话描述协议**（**SDP**）格式将消息传递给事件处理程序，从信令服务器接收到的`RTCPeerConnection`的消息必须以SDP格式提供给`RTCPeerConnection`，也就是说，`RTCPeerConnection`只能理解SDP格式。您需要使用自己的编程逻辑来拆分自定义消息和`RTCPeerConnection`的消息。
- en: The preceding steps seem to have no problem; however, there are some major problems.
    The peers may be behind a NAT device or firewall, so finding their public IP address
    is a challenging task, sometimes it is practically impossible to find their IP
    address. So, how does `RTCPeerConnection` find an IP address of the peers when
    they may be behind a NAT device or firewall?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤似乎没有问题；然而，存在一些主要问题。对等方可能位于NAT设备或防火墙后，因此找到它们的公共IP地址是一项具有挑战性的任务，有时实际上是不可能找到它们的IP地址。那么，当`RTCPeerConnection`可能位于NAT设备或防火墙后时，它是如何找到对等方的IP地址的呢？
- en: '`RTCPeerConnection` uses a technique called **Interactive Connectivity Establishment**
    (**ICE**) to resolve all these issues.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTCPeerConnection`使用一种称为**交互式连接建立**（**ICE**）的技术来解决所有这些问题。'
- en: ICE involves **Session Traversal Utilities for NAT** (**STUN**) and **Traversal
    Using Relays around NAT** (**TURN**) server to solve the problems. A STUN server
    is used to find the public IP address of a peer. In case the IP address of a peer
    cannot be found, or due to some other reason a peer-to-peer cannot be established,
    then a TURN server is used to redirect the traffic, that is, both the peers communicate
    via the TURN server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ICE涉及**用于NAT的会话遍历实用程序**（**STUN**）和**用于NAT周围中继遍历**（**TURN**）服务器来解决问题。STUN服务器用于查找对等方的公共IP地址。如果无法找到对等方的IP地址，或者由于其他原因无法建立对等方通信，则使用TURN服务器重定向流量，也就是说，两个对等方通过TURN服务器进行通信。
- en: We just need to provide the addresses of the STUN and TURN servers and `RTCPeerConnection`
    handles the rest. Google provides a public STUN server, which is used by everyone.
    Building a TURN server requires a lot of resources as the actual data flows throw
    it. Therefore, WebRTC makes it optional to use a TURN server. If `RTCPeerConnection`
    fails to establish a direct communication between two peers and a TURN server
    is not provided, there is no other way for the peers to communicate and a peer-to-peer
    connection establishment fails.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要提供STUN和TURN服务器的地址，`RTCPeerConnection`会处理其余。谷歌提供了一个公共STUN服务器，每个人都可以使用。构建一个TURN服务器需要大量资源，因为实际数据通过它流动。因此，WebRTC使使用TURN服务器成为可选项。如果`RTCPeerConnection`无法在两个对等方之间建立直接通信，并且没有提供TURN服务器，则对等方之间没有其他通信方式，对等方连接建立失败。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WebRTC doesn't provide any way to make signaling secure. It's your job to make
    the signaling secure.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: WebRTC不提供使信令安全的任何方式。使信令安全是您的工作。
- en: Transferring MediaStream
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输`MediaStream`
- en: We saw how `RTCPeerConnection` establishes a peer-to-peer connection. Now, to
    transfer `MediaStream`, we just need to pass the reference of `MediaStream` to
    `RTCPeerConnection` and it will transfer `MediaStream` to the connected peer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了`RTCPeerConnection`如何建立对等方连接。现在，为了传输`MediaStream`，我们只需要将`MediaStream`的引用传递给`RTCPeerConnection`，它将把`MediaStream`传输给连接的对等方。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we say that `MediaStream` is transferred, we mean the stream of individual
    tracks is transferred.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说`MediaStream`被传输时，我们指的是传输各个轨道的流。
- en: 'The following are some of the things you need to know regarding the transfer
    of `MediaStream`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于传输`MediaStream`需要了解的一些事项：
- en: '`RTCPeerConnection` uses SRTP as an application layer protocol and UDP as a
    transport layer protocol to transfer `MediaStream`. SRTP is designed for media
    stream transfer in real time.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTCPeerConnection`使用SRTP作为应用层协议和UDP作为传输层协议来传输`MediaStream`。SRTP专为实时媒体流传输而设计。'
- en: UDP doesn't guarantee the order of packets, but SRTP takes care of the order
    of the frames.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP不能保证数据包的顺序，但SRTP会处理帧的顺序。
- en: The **Datagram Transport Layer Security** (**DTLS**) protocol is used to secure
    the `MediaStream` transfer. So, you don't have to worry about the security while
    transferring `MediaStream`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据报传输层安全**（**DTLS**）协议用于保护`MediaStream`传输。因此，在传输`MediaStream`时，您不必担心安全性。'
- en: Constraints of the tracks that the remote peer receives may be different from
    the constraints of the local tracks, as `RTCPeerConnection` modifies the stream
    automatically, depending on the bandwidth and other network factors to speed up
    the transfer, achieving real-time data transfer. For example, `RTCPeerConnection`
    may decrease the resolution and frame rate of video stream while transferring.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程对等方接收的轨道约束可能与本地轨道的约束不同，因为`RTCPeerConnection`会根据带宽和其他网络因素自动修改流，以加快传输速度，实现实时数据传输。例如，`RTCPeerConnection`在传输视频流时可能会降低分辨率和帧率。
- en: If you add or remove a track from `MediaStream` that is already being sent,
    then `RTCPeerConnection` updates `MediaStream` of the other peer by communicating
    to the other peer via the signaling server.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您向已经发送的`MediaStream`添加或移除轨道，则`RTCPeerConnection`通过与对等方通过信令服务器通信来更新另一个对等方的`MediaStream`。
- en: If you pause a track that is being sent, then `RTCPeerConnection` pauses transfer
    of the track.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果暂停正在发送的轨道，则`RTCPeerConnection`将暂停传输该轨道。
- en: If you stop a track that is being sent, `RTCPeerConnection` stops the transfer
    of the track.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果停止发送的轨道，`RTCPeerConnection`将停止传输该轨道。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can send and receive multiple `MediaStream` instances via single `RTCPeerConnection`,
    that is, you don't have to create multiple `RTCPeerConnection` instances to send
    and receive multiple `MediaStream` instances to and from a peer. Whenever you
    add or remove a new `MediaStream` to or from `RTCPeerConnection`, the peers exchange
    information related to this via the signaling server.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过单个`RTCPeerConnection`发送和接收多个`MediaStream`实例，也就是说，您不必创建多个`RTCPeerConnection`实例来与对等方发送和接收多个`MediaStream`实例。每当您向`RTCPeerConnection`添加或移除新的`MediaStream`时，对等方通过信令服务器交换与此相关的信息。
- en: RTCDataChannel API
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RTCDataChannel API
- en: '`RTCDataChannel` is used to transfer data other than `MediaStream` between
    peers to transfer arbitrary data. The mechanism to establish a peer–to-peer connection
    to transfer arbitrary data is similar to the mechanism explained in the earlier
    section.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTCDataChannel`用于在对等方之间传输除`MediaStream`之外的数据，以传输任意数据。建立对等方之间传输任意数据的机制与前一节中解释的机制类似。'
- en: '`RTCDataChannel` is an object that implements the `RTCDataChannel` interface.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTCDataChannel`是实现`RTCDataChannel`接口的对象。'
- en: 'The following are some of the things you need to know regarding `RTCDataChannel`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于`RTCDataChannel`需要了解的一些事项：
- en: '`RTCDataChannel` uses SCTP over UDP as a transport layer protocol to transfer
    data. It doesn''t use unlayered SCTP protocol as the SCPT protocol is not supported
    by many operating systems.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTCDataChannel`使用UDP上的SCTP作为传输层协议来传输数据。它不使用未分层的SCTP协议，因为SCPT协议不受许多操作系统支持。'
- en: SCTP can be configured for reliability and delivery order, unlike UDP, which
    is unreliable and unordered.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SCTP可以配置为可靠和按顺序交付，而UDP是不可靠和无序的。
- en: '`RTCDataChannel` also uses DTLS to secure data transfer. So, you don''t have
    to worry about the security at all while transferring data via `RTCDataChannel`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTCDataChannel`也使用DTLS来保护数据传输。因此，在通过`RTCDataChannel`传输数据时，您不必担心安全性问题。'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can have multiple peer-to-peer connections open between browsers. For example,
    we can have three peer-to-peer connections, that is, first one for webcam stream
    transfer, second one for text message transfer, and third one for file transfer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在浏览器之间打开多个点对点连接。例如，我们可以有三个点对点连接，即第一个用于网络摄像头流传输，第二个用于文本消息传输，第三个用于文件传输。
- en: WebRTC applications using PeerJS
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PeerJS的WebRTC应用程序
- en: '**PeerJS** is a client-side JavaScript library that provides an easy-to-use
    API to work with WebRTC. It only provides an API to exchange `MediaStream` and
    arbitrary data between peers. It doesn''t provide an API to work with `MediaStream`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**PeerJS**是一个客户端JavaScript库，提供了易于使用的API来使用WebRTC。它只提供了一个API来在对等方之间交换`MediaStream`和任意数据。它不提供用于处理`MediaStream`的API。'
- en: PeerServer
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PeerServer
- en: '**PeerServer** is an open source signaling server used by PeerJS to establish
    a peer-to-peer connection. PeerServer is written in Node.js. If you don''t want
    to run your own PeerServer instance, then you can use PeerServer cloud, which
    hosts PeerServer for public use. PeerServer cloud allows you to establish a maximum
    of 50 concurrent connections for free.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**PeerServer**是PeerJS使用的开源信令服务器，用于建立点对点连接。PeerServer是用Node.js编写的。如果您不想运行自己的PeerServer实例，那么可以使用PeerServer云，它为公共使用托管PeerServer。PeerServer云允许您免费建立最多50个并发连接。'
- en: A unique ID identifies every peer connected to PeerServer. PeerServer itself
    can generate the ID, or else the peers can provide their own ID. For a peer to
    establish a peer-to-peer connection with another peer, it just needs to know the
    other peer's ID.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个连接到PeerServer的对等方都有一个唯一的ID。PeerServer本身可以生成ID，或者对等方可以提供自己的ID。对于对等方与另一个对等方建立点对点连接，它只需要知道另一个对等方的ID。
- en: You might want to run your own PeerServer instance when you want to add more
    functionality to PeerServer or you want to support more than 50 concurrent connections.
    For example, if you want to check whether the user is logged in to PeerServer,
    then you need to add this feature and host your own customized PeerServer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要向PeerServer添加更多功能或者想要支持超过50个并发连接时，您可能希望运行自己的PeerServer实例。例如，如果您想要检查用户是否已登录到PeerServer，则需要添加此功能并托管自己定制的PeerServer。
- en: In this chapter, we will use PeerServer cloud, but in the next chapter, we will
    create our own instance of PeerServer. Therefore, to continue further with this
    chapter, create an account on the PeerServer cloud and retrieve the API key. Every
    application gets an API key to access the PeerServer cloud. If you are hosting
    your own PeerServer, then you won't need an API key. The API key is used by PeerServer
    cloud to track the total connections established by an application. To create
    an account and retrieve an API key, visit [http://peerjs.com/peerserver](http://peerjs.com/peerserver).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用PeerServer云，但在下一章中，我们将创建自己的PeerServer实例。因此，要继续进行本章的操作，请在PeerServer云上创建一个帐户并检索API密钥。每个应用程序都会获得一个API密钥来访问PeerServer云。如果您正在托管自己的PeerServer，则不需要API密钥。API密钥由PeerServer云用于跟踪应用程序建立的总连接数。要创建帐户并检索API密钥，请访问[http://peerjs.com/peerserver](http://peerjs.com/peerserver)。
- en: PeerJS API
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PeerJS API
- en: Let's discuss the PeerJS API by creating a simple app that allows the users
    to exchange video and text messages with any user whose ID they have.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个简单的应用程序来讨论PeerJS API，该应用程序允许用户与任何拥有其ID的用户交换视频和文本消息。
- en: Create a `peerjs-demo` directory in your web server and place a file named `index.html`
    in it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Web服务器上创建一个名为`peerjs-demo`的目录，并在其中放置一个名为`index.html`的文件。
- en: 'In the `index.html` file, we need to first enqueue the `PeerJS` library. Download
    `PeerJS` from [http://peerjs.com/](http://peerjs.com/). At the time of writing,
    the latest version of PeerJS was 0.3.14\. I would recommend that you stick to
    this version for the following examples. Place this starting code in the `index.html`
    file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`文件中，我们需要首先将`PeerJS`库加入队列。从[http://peerjs.com/](http://peerjs.com/)下载`PeerJS`。在撰写本文时，PeerJS的最新版本是0.3.14。我建议您在以下示例中坚持使用这个版本。将这个起始代码放在`index.html`文件中：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, I enqueued the minified version of PeerJS.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我加入了PeerJS的压缩版本。
- en: 'PeerJS API comprises of three main constructors, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: PeerJS API包括三个主要构造函数，如下：
- en: '`Peer`: An instance of `Peer` represents a peer in the network. A peer is connected
    to the signaling server and STUN, and optionally, to a TURN.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Peer`：`Peer`的一个实例表示网络中的一个对等方。对等方连接到信令服务器和STUN，以及可选地连接到TURN。'
- en: '`DataConnection`: DataConnection (that is, the instance of `DataConnection`)
    represents a peer-to-peer connection, which is used to exchange the arbitrary
    data. Technically, it wraps `RTCDataChannel`.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataConnection`：DataConnection（即`DataConnection`的实例）表示用于交换任意数据的点对点连接。从技术上讲，它包装了`RTCDataChannel`。'
- en: '`MediaConnection`: MediaConnection (that is, the instance of `MediaConnection`)
    represents a peer-to-peer connection that is used to exchange `MediaStream`. Technically,
    it wraps `RTCPeerConnection`.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MediaConnection`：MediaConnection（即`MediaConnection`的实例）表示用于交换`MediaStream`的点对点连接。从技术上讲，它包装了`RTCPeerConnection`。'
- en: If a peer wants to establish `DataConnection` or `MediaConnection` with another
    peer, then it simply needs to know the other peer's ID. PeerJS doesn't give the
    other peer an option to accept or reject `DataConnection`. Also, in the case of
    `MediaConnection`, PeerJS doesn't give the other peer an option to accept or reject
    `MediaConnection`, but `MediaConnection` will be inactive until it is activated
    programmatically by the other peer so that `MediaStream` can be transferred, otherwise
    `MediaStream` will not be transferred. So, we can write our own logic to let the
    other user accept or reject `DataConnection` or `MediaConnecton`, that is, as
    soon as `DataConnection` or `MediaConnection` is established, we can cancel it
    by asking the user for their opinion.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对等方想要与另一个对等方建立`DataConnection`或`MediaConnection`，那么它只需要知道另一个对等方的ID。PeerJS不会给其他对等方选择接受或拒绝`DataConnection`的选项。此外，在`MediaConnection`的情况下，PeerJS也不会给其他对等方选择接受或拒绝`MediaConnection`的选项，但是`MediaConnection`将处于非活动状态，直到其他对等方通过编程方式激活它，以便传输`MediaStream`，否则`MediaStream`将不会被传输。因此，我们可以编写自己的逻辑，让其他用户接受或拒绝`DataConnection`或`MediaConnecton`，也就是说，一旦建立了`DataConnection`或`MediaConnection`，我们可以通过询问用户的意见来取消它。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At present, one `MediaConnection` can transfer only one `MediaStream`. In future
    releases of PeerJS, a single `MediaConnection` will support the transfer of multiple
    MediaStreams.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，一个`MediaConnection`只能传输一个`MediaStream`。在PeerJS的未来版本中，单个`MediaConnection`将支持多个MediaStreams的传输。
- en: 'Now, we need to create a `<video>` tag where the video will be displayed, a
    button to connect to a peer, and also a text box to send message. Here is the
    HTML code to display all these:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个`<video>`标签，视频将在其中显示，一个按钮用于连接到对等方，还有一个文本框用于发送消息。以下是显示所有这些的HTML代码：
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now as soon as the page loads, we need to connect to `PeerServer` and ICE servers
    so that other peers can talk to us, and also when a user clicks on the connect
    button, we can establish `DataConnection` and `MediaConnection`. The following
    is the code for this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，页面加载后，我们需要连接到`PeerServer`和ICE服务器，以便其他对等方可以与我们交谈，还有当用户点击连接按钮时，我们可以建立`DataConnection`和`MediaConnection`。以下是此代码：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is how the code works:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的工作原理：
- en: First we displayed a prompt box to take the ID as an input so that every peer
    can decide their own ID.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们显示了一个提示框，以便每个对等方可以决定他们自己的ID。
- en: Then we created an instance of `Peer` with ID and PeerServer cloud key. Here
    we didn't provide signaling and ICE server's URLs, therefore, PeerJS will use
    PeerServer cloud as the signaling server and Google's public STUN server. It will
    not use any TURN server. As soon as a `Peer` instance is created, the instance
    connects to the signaling server and registers the given ID.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用ID和PeerServer云密钥创建了一个`Peer`实例。在这里，我们没有提供信令和ICE服务器的URL，因此，PeerJS将使用PeerServer云作为信令服务器和Google的公共STUN服务器。它不会使用任何TURN服务器。一旦创建了`Peer`实例，该实例将连接到信令服务器并注册给定的ID。
- en: Then we attached five event handlers to the `peer` object.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将五个事件处理程序附加到`peer`对象。
- en: The `open` event is triggered when the connection to `PeerServer` was successful.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当连接到`PeerServer`成功时，将触发`open`事件。
- en: The `error` event is triggered for errors on the `peer` object.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`peer`对象的错误将触发`error`事件。
- en: The `disconnected` event is triggered when the connection with the signaling
    server is disconnected. The connection with the signaling server may get disconnected
    due to network problem or if you manually call the `peer.disconnect()` method.
    Once you are disconnected, your ID can be taken by someone else. You can try to
    reconnect with the same ID using the `peer.reconnect()` method. You can check
    whether `peer` is connected to the signaling server using the `peer.disconnect`
    Boolean property.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当与信令服务器的连接断开时，将触发`disconnected`事件。与信令服务器的连接可能由于网络问题或者您手动调用`peer.disconnect()`方法而断开。一旦断开连接，您的ID可能会被其他人占用。您可以尝试使用`peer.reconnect()`方法使用相同的ID重新连接。您可以使用`peer.disconnect`布尔属性检查`peer`是否连接到信令服务器。
- en: The `close` event is triggered when `peer` is destroyed, that is, it cannot
    be used anymore, all `MediaConnections` and `DataConnections` are killed, connection
    with the signaling server is killed, the ID is taken away, and so on. You may
    want to manually destroy `peer` when you don't need it anymore. You can destroy
    a peer using the `peer.destroy()` method.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`peer`被销毁时，即不能再使用它时，将触发`close`事件，所有`MediaConnections`和`DataConnections`都将被终止，与信令服务器的连接将被终止，ID将被取消等。当您不再需要它时，您可能希望手动销毁`peer`。您可以使用`peer.destroy()`方法销毁对等方。
- en: The `connection` event is triggered when some other peer establishes `DataConnection`
    with you. As I said earlier, `DataConnection` is established without further permission,
    but you can close it as soon as it's established if you want. Here we let the
    user decide if they want to continue or close `DataConnection` established by
    another peer. The event handler attached to the event receives an instance of
    `DataConnection` via the parameter that represents the currently established `DataConnection`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其他对等方与您建立`DataConnection`时，将触发`connection`事件。如我之前所说，`DataConnection`是在没有进一步许可的情况下建立的，但是如果您愿意，可以在建立后立即关闭它。在这里，我们让用户决定他们是否要继续或关闭另一个对等方建立的`DataConnection`。附加到事件处理程序的事件处理程序通过参数接收`DataConnection`的实例，该实例表示当前建立的`DataConnection`。
- en: The `call` event is triggered when some other peer establishes `MediaConnection`
    with you. Here, we also let the user decide if they want to continue or close
    `MediaConnection` established by another peer. The event handler attached to the
    event receives an instance of `MediaConnection` via the parameter that represents
    the currently established `MediaConnection`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其他对等方与您建立`MediaConnection`时，将触发`call`事件。在这里，我们还让用户决定他们是否要继续或关闭另一个对等方建立的`MediaConnection`。附加到事件处理程序的事件处理程序通过参数接收`MediaConnection`的实例，该实例表示当前建立的`MediaConnection`。
- en: Here, in the `call` and `connection` event handlers, we asynchronously displayed
    the confirm popup boxes to prevent blocking the execution of the event handler
    that causes issues in some browsers, that is, blocking it fails to establish `DataConnection`
    and `MediaConnection`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`call`和`connection`事件处理程序中，我们异步显示确认弹出框，以防止阻塞事件处理程序的执行，在某些浏览器中可能会出现问题，即阻止它无法建立`DataConnection`和`MediaConnection`。
- en: 'Now, let''s implement the `acceptDataConnection()` and `acceptMediaConnection()`
    functions so that we can display the text messages and remote `MediaStream` when
    other peer establishes `DataConnection` or `MediaConnection` with us. Here''s
    the code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现`acceptDataConnection()`和`acceptMediaConnection()`函数，以便我们可以在其他对等方与我们建立`DataConnection`或`MediaConnection`时显示文本消息和远程`MediaStream`。以下是代码：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is how the preceding code works:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是先前代码的工作原理：
- en: In the `acceptDataConnection()` function, we attached three event handlers to
    `DataConnection`. The `data` event is triggered when the other peer sends us data.
    The `close` event is triggered when `DataConnection` is closed. Finally, the `error`
    event is triggered when an error occurs on `DataConnection`. We can manually close
    `DataConnection` using the `dataConnection.close()` method.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`acceptDataConnection()`函数中，我们附加了三个事件处理程序到`DataConnection`。当其他对等方向我们发送数据时，将触发`data`事件。当`DataConnection`关闭时，将触发`close`事件。最后，当`DataConnection`发生错误时，将触发`error`事件。我们可以使用`dataConnection.close()`方法手动关闭`DataConnection`。
- en: In the `acceptMediaConnection()` function, we attached three event handlers
    and transferred our `MediaStream` to the other peer. The `stream` event is triggered
    when other peer sends us `MediaStream`. The `close` event is triggered when `MediaConnection`
    is closed. Finally, we activated `MediaConnection` using the `mediaConnection.answer()`
    method by passing our `MediaStream`. After `MediaConnection` is activated, the
    `stream` event will be triggered.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`acceptMediaConnection()`函数中，我们附加了三个事件处理程序，并将我们的`MediaStream`传输给其他对等方。当其他对等方向我们发送`MediaStream`时，将触发`stream`事件。当`MediaConnection`关闭时，将触发`close`事件。最后，我们通过传递我们的`MediaStream`使用`mediaConnection.answer()`方法激活了`MediaConnection`。激活`MediaConnection`后，将触发`stream`事件。
- en: 'We finished writing the code to handle `MediaConnection` or `DataConnection`
    established by another peer with us. Now we need to write a code to create `MediaConnection`
    and `DataConnection` that a user clicks on the **connect** button. Here is the
    code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了编写处理由其他对等方与我们建立的`MediaConnection`或`DataConnection`的代码。现在我们需要编写代码，当用户单击**连接**按钮时创建`MediaConnection`和`DataConnection`。以下是代码：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is how the code works:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的工作原理：
- en: First we asked the user to input another user's ID.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们要求用户输入另一个用户的ID。
- en: Then we established `DataConnection`. To establish a `DataConnection` with another
    user, we need to invoke the `connect()` method of the `Peer` instance with other
    peer's ID. We also made `DataConnection` reliable and ordered. Then, we attached
    the event handlers. We also saw how `data`, `close`, and `error` events work.
    The `open` event is triggered when `DataConnection` is established.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们建立了`DataConnection`。要与另一个用户建立`DataConnection`，我们需要使用`Peer`实例的`connect()`方法调用其他对等方的ID。我们还使`DataConnection`可靠和有序。然后，我们附加了事件处理程序。我们还看到了`data`、`close`和`error`事件的工作原理。当建立`DataConnection`时，将触发`open`事件。
- en: After establishing the `DataConnection`, we established `MediaConnection`. To
    establish `MediaConnection`, we need to call the `call()` method of the `Peer`
    instance. We need to pass `MediaStream` to the `call()` method. Finally, we attached
    the event handlers. The `stream` event will be triggered when the other user calls
    the `answer()` method of the `MediaConnection` instance, that is, when the MediaConnection
    is activated.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在建立`DataConnection`后，我们建立了`MediaConnection`。要建立`MediaConnection`，我们需要调用`Peer`实例的`call()`方法。我们需要将`MediaStream`传递给`call()`方法。最后，我们附加了事件处理程序。当其他用户调用`MediaConnection`实例的`answer()`方法时，即激活`MediaConnection`时，将触发`stream`事件。
- en: 'Now the last thing we need to do is write the code to send the message when
    a user clicks on the send message button. Here is the code for this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的最后一件事是编写代码，当用户单击发送消息按钮时发送消息。以下是此代码：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To send data via `MediaConnection`, we need to call the `send()` method of the
    `MediaConnection` instance. Here, we are sending a string, but you can pass any
    type of data including blobs and objects.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过`MediaConnection`发送数据，我们需要调用`MediaConnection`实例的`send()`方法。在这里，我们发送了一个字符串，但您可以传递任何类型的数据，包括blob和对象。
- en: Now, to test the application, open the `index.html` page URL in two different
    browsers, devices, or tabs. I am assuming that you have opened the URL in two
    different devices. In each device, provide a different ID to identify the user.
    Then click on the connect button in any one device and enter the other peer's
    ID. Now accept the request on the other device. Once this is done, both the devices
    will be able to display each other's webcam video and microphone audio. You can
    also send messages between them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试应用程序，在两个不同的浏览器、设备或选项卡中打开`index.html`页面的URL。我假设您已经在两个不同的设备上打开了URL。在每个设备上，提供一个不同的ID来识别用户。然后在任一设备上单击连接按钮，并输入另一个对等方的ID。现在在另一个设备上接受请求。完成后，两个设备将能够显示彼此的网络摄像头视频和麦克风音频。您还可以在它们之间发送消息。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the official documentation of PeerJS API at [http://peerjs.com/docs/#api](http://peerjs.com/docs/#api).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://peerjs.com/docs/#api](http://peerjs.com/docs/#api)找到PeerJS API的官方文档。
- en: Miscellaneous
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项
- en: At the time of writing, the WebRTC specifications were still not finalized.
    The overall idea of what WebRTC does and how WebRTC works has been finalized.
    It's just that the APIs are still under development.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，WebRTC规范仍未最终确定。WebRTC的整体思想和工作原理已经最终确定。只是API仍在开发中。
- en: For example, WebRTC has introduced an alternative to the `navigator.getUserMedia()`
    method, that is, the `navigator.mediaDevices.getUserMedia()` method. At the time
    of writing, `navigator.mediaDevices.getUserMedia()` is not supported in any browsers.
    The difference between them is that the `navigator.mediaDevices.getUserMedia()`
    method is based on the promise pattern, whereas `navigator.getUserMedia()` is
    based on the callback pattern. At present, there is no plan to get rid of `navigator.getUserMedia()`
    due to the backward compatibility reason, but in future, `navigator.getUserMedia()`
    may be removed as WebRTC wants to implement all APIs using the promise pattern,
    therefore, it's difficult to maintain multiple APIs that do the same thing. Similarly,
    `navigator.mediaDevices.enumerateDevice()` is an alternative to `MediaStreamTrack.getSources()`,
    that is, `navigator.mediaDevices.enumerateDevice()` is based on the promise pattern.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，WebRTC引入了`navigator.getUserMedia()`方法的替代方法，即`navigator.mediaDevices.getUserMedia()`方法。在撰写本文时，`navigator.mediaDevices.getUserMedia()`在任何浏览器中都不受支持。它们之间的区别在于，`navigator.mediaDevices.getUserMedia()`方法基于promise模式，而`navigator.getUserMedia()`基于回调模式。目前，由于向后兼容性原因，没有计划摆脱`navigator.getUserMedia()`，但在未来，由于WebRTC希望使用promise模式实现所有API，因此很难维护执行相同操作的多个API，`navigator.getUserMedia()`可能会被移除。同样，`navigator.mediaDevices.enumerateDevice()`是`MediaStreamTrack.getSources()`的替代方法，即`navigator.mediaDevices.enumerateDevice()`基于promise模式。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the official specification of WebRTC at [http://www.w3.org/TR/#tr_Web_Real_Time_Communication](http://www.w3.org/TR/#tr_Web_Real_Time_Communication).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://www.w3.org/TR/#tr_Web_Real_Time_Communication](http://www.w3.org/TR/#tr_Web_Real_Time_Communication)找到WebRTC的官方规范。
- en: Due to the fact that there are multiple APIs for the same feature, each with
    a different browser support, WebRTC provides a script called `adapter.js`, which
    is a shim to insulate websites from specification changes and prefix differences.
    You can find the shim at [https://github.com/webrtc/adapter](https://github.com/webrtc/adapter).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同一功能有多个不同浏览器支持的API，WebRTC提供了一个名为`adapter.js`的脚本，它是一个用来隔离网站与规范更改和前缀差异的垫片。您可以在[https://github.com/webrtc/adapter](https://github.com/webrtc/adapter)找到这个垫片。
- en: WebRTC has a GitHub repository where it puts a lot of example projects showing
    some of the things that can be built using WebRTC. You can find the repository
    at [https://github.com/webrtc/samples](https://github.com/webrtc/samples). Just
    by looking at the examples and their source code, you can learn a lot more about
    WebRTC.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: WebRTC有一个GitHub存储库，其中放置了许多示例项目，展示了可以使用WebRTC构建的一些东西。您可以在[https://github.com/webrtc/samples](https://github.com/webrtc/samples)找到这个存储库。通过查看示例和它们的源代码，您可以更多地了解WebRTC。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the fundamentals of WebRTC and PeerJS by creating
    a simple app. We discussed the various protocols, techniques, and other technologies
    that WebRTC uses to enable real-time peer-to-peer communication and read streams
    of physical media sources. We also saw an overview of PeerServer. Now you must
    be comfortable with building any type of WebRTC app using PeerServer cloud.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过创建一个简单的应用程序讨论了WebRTC和PeerJS的基础知识。我们讨论了WebRTC使用的各种协议、技术和其他技术，以实现实时点对点通信和读取物理媒体源的流。我们还看到了PeerServer的概述。现在，您应该可以使用PeerServer云构建任何类型的WebRTC应用程序。
- en: In the next chapter, we will build an advanced WebRTC app using a custom PeerServer.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用自定义PeerServer构建一个高级的WebRTC应用程序。
