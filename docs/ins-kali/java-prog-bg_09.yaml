- en: File Input and Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件输入和输出
- en: 'The file I/O function is an extremely powerful tool that can make one of the
    most difficult and frustrating tasks of modern programming, namely transferring
    information between logically separate entities of code, much easier than it would
    otherwise be. Having said that, in this chapter, you will learn how to write and
    read data files using the `FileWriter` and `BufferedWriter` and `FileReader` and
    `BufferedReader` classes. We''ll also look at the usage of the `close ()` method
    and the `Scanner` class. Then you''ll learn about exception handling. Finally,
    we will see one more aspect of I/O: the `Serializable` class.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 文件I/O功能是一个非常强大的工具，可以使现代编程中最困难和令人沮丧的任务之一，即在代码的逻辑上分离的实体之间传输信息，比原本更容易。话虽如此，在本章中，您将学习如何使用`FileWriter`和`BufferedWriter`和`FileReader`和`BufferedReader`类来编写和读取数据文件。我们还将看一下`close()`方法和`Scanner`类的用法。然后您将学习异常处理。最后，我们将看到I/O的另一个方面：`Serializable`类。
- en: 'Specifically, we''ll cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将在本章中涵盖以下主题：
- en: Writing data to files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向文件写入数据
- en: Reading data from files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件读取数据
- en: The Serializable class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Serializable类
- en: Writing data to files
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向文件写入数据
- en: 'This will be an exciting chapter. First we''ll take a look at how to write
    to files using Java. To do this, we''ll declare a mathematical sequence for the
    first 50 numbers of the mathematical sequence in which each number will be the
    sum of the previous two numbers. When we run the following program we will see
    these 50 numbers printed out to our `System.out` stream, and we will be able to
    view them in our console window:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个令人兴奋的章节。首先，我们将看看如何使用Java写入文件。为此，我们将声明一个数学序列，前50个数字将是数学序列的前两个数字的和。当我们运行以下程序时，我们将看到这50个数字打印到我们的`System.out`流中，并且我们将能够在控制台窗口中查看它们：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, when we close the console for good, these numbers will be lost. To
    help us with this task, we''re going to make use of the `java.io` library; here,
    `io` stands for **input and output**:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们永久关闭控制台时，这些数字将丢失。为了帮助我们完成这项任务，我们将利用`java.io`库；在这里，`io`代表**输入和输出**：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We''ll utilize a class that lives in this library: `FileWriter`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用这个库中的一个类：`FileWriter`。
- en: The FileWriter class
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FileWriter类
- en: 'The `FileWriter` class and its usage could be explained as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileWriter`类及其用法可以解释如下：'
- en: 'Let''s declare a new `FileWriter` class, and for reasons that will become apparent
    a little later on, let''s explicitly set this `FileWriter` class to null:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明一个新的`FileWriter`类，并且出于稍后会变得明显的原因，让我们明确地将这个`FileWriter`类设置为null：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we do this, we can go ahead and instantiate it. In order to write to a
    file, we''re going to need to know two important things:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们这样做，我们就可以继续实例化它。为了写入文件，我们需要知道两件重要的事情：
- en: First, of course, we'll need to know what to write to the file
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，当然，我们需要知道要写入文件的内容
- en: Second, our `FileWriter` class will need to know what file it should write to
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们的`FileWriter`类需要知道它应该写入哪个文件
- en: 'When we use a `FileWriter` class, we associate it with a specific file, so
    we pass into its constructor the name of the file we would like it to write to.
    Our `FileWriter` class is capable of creating a file if none exists, so we should
    just pick a name that ends with `.txt` so that our operating system will know
    we''re creating a text file:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们使用`FileWriter`类时，我们将它与特定文件关联起来，因此我们将文件名传递给它的构造函数，我们希望它写入该文件。我们的`FileWriter`类能够在没有文件的情况下创建文件，因此我们应该选择一个以`.txt`结尾的名称，这样我们的操作系统就会知道我们正在创建一个文本文件：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even though we've called the `FileWriter` constructor with valid arguments,
    NetBeans will still let us know that we'll get a compiler error in this code.
    It'll tell us there's an unreported exception, an `IOException` error that can
    be thrown here. Many exceptions in Java are marked as handled exceptions. These
    are exceptions that a function explicitly states it may throw. `FileWriter` is
    a function that explicitly states that it can throw an `IOException` error. So,
    as far as Java is concerned, it is an error for our code not to explicitly handle
    this possible exception.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用有效的参数调用了`FileWriter`构造函数，NetBeans仍会告诉我们，我们在这段代码中会得到一个编译器错误。它会告诉我们有一个未报告的异常，即可能在此处抛出`IOException`错误。Java中的许多异常都标记为已处理异常。这些是函数明确声明可能抛出的异常。`FileWriter`是一个明确声明可能抛出`IOException`错误的函数。因此，就Java而言，我们的代码不明确处理这种可能的异常是错误的。
- en: 'To handle this, of course, we''re simply going to wrap the portions of our
    code where we use our `FileWriter` class with a `try...catch` block that catches
    `IOException` errors:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，为了处理这个问题，我们只需用`try...catch`块包装我们使用`FileWriter`类的代码部分，捕获`IOException`错误：
- en: 'If we do catch an `IOException` error, it''s probably a good time to print
    out a helpful message to the **error stream**:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们捕获到`IOException`错误，现在可能是打印有用消息到**错误流**的好时机：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, our program will finish running and will terminate because it would have
    reached the end of the `main` method. With this exception caught, the instantiation
    of `FileWriter` is now valid and legal, so let's put it to use.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的程序将完成运行，并且将终止，因为它已经到达了`main`方法的末尾。有了这个异常捕获，`FileWriter`的实例化现在是有效和合法的，所以让我们把它用起来。
- en: 'We no longer need our program to print out numbers to our console, so let''s
    comment out our `println` statement, as shown in the following code block:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要我们的程序将数字打印到控制台，所以让我们注释掉我们的`println`语句，如下面的代码块所示：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''re going to do the same logical thing with our `FileWriter` class:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用我们的`FileWriter`类做同样的逻辑处理：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `FileWriter` class doesn't have a `println` statement, but it does have
    the `write` method. Each time our `foreach` loop executes, we'd like to write
    the number to our file using the `out.write(number);` syntax.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileWriter`类没有`println`语句，但它有`write`方法。每当我们的`foreach`循环执行时，我们希望使用`out.write(number);`语法将数字写入我们的文件。'
- en: 'Unfortunately, the `write` method doesn''t know how to take a `long number`
    as input; it can take a string and it can also take an integer. So let''s use
    the static `String` class method `valueOf` to acquire the value of our `long number`
    to print out the number to our file:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不幸的是，“write”方法不知道如何以“长数字”作为输入；它可以接受一个字符串，也可以接受一个整数。因此，让我们使用静态的“String”类方法“valueOf”来获取我们的“长数字”的值，以便将数字打印到我们的文件中：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, we should now have all the pieces of a successful program here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在应该拥有一个成功的程序的所有部分：
- en: First we declared and instantiated our `FileWriter` class, giving it a filename
  id: totrans-34
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们声明并实例化了我们的“FileWriter”类，并给它一个文件名
- en: Then, we looped through our Fibonacci sequence of numbers, and told our `FileWriter`
    class to write each of these numbers to `out.txt`
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们循环遍历我们的斐波那契数列，并告诉我们的`FileWriter`类将这些数字写入`out.txt`
- en: Nevertheless, the question is where is `out.txt`? We haven't given the `FileWriter`
    class a full system path, just the name of a file. We know that the `FileWriter`
    class is capable of creating this file if it does not exist, but where in our
    system's directories will this `FileWriter` class choose to create the file?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题是`out.txt`在哪里？我们没有给`FileWriter`类一个完整的系统路径，只是一个文件名。我们知道`FileWriter`类有能力创建这个文件，如果它不存在，但在我们系统的目录中，`FileWriter`类会选择在哪里创建这个文件？
- en: 'To answer this question, we need to know where NetBeans will create the `.jar`
    file for our compiled program. To find this out, we can open the console window
    and build our program. Here, NetBeans will tell us where it''s creating all its
    files. For example, in my case, it''s a folder called `WritingToFiles`; if we
    navigate to this folder, we''ll see our project files. One of these files is `dist`,
    short for **distributable**, and this is where our JAR file will be compiled to:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这个问题，我们需要知道NetBeans将为我们编译的程序创建`.jar`文件的位置。为了找出这一点，我们可以打开控制台窗口并构建我们的程序。在这里，NetBeans会告诉我们它正在创建所有文件的位置。例如，在我的情况下，有一个名为“WritingToFiles”的文件夹；如果我们导航到这个文件夹，我们会看到我们的项目文件。其中一个文件是`dist`，缩写为**可分发**，这就是我们的JAR文件将被编译到的地方：
- en: '![](img/4b4712a9-692f-47dc-bac8-085a3768f239.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b4712a9-692f-47dc-bac8-085a3768f239.png)'
- en: 'JAR files are as close as we''re going to get to an executable with raw Java
    code. Because Java code must be interpreted by the Java virtual machine, we can''t
    actually create Java executables; however, in most operating systems where Java
    is installed, we can run a JAR file by simply double-clicking on it, like how
    we would run an executable. We can also tell the Java virtual machine to boot
    up and run a JAR file using the Java command line `-jar` command, followed by
    the name of the file we would like it to execute, of course:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JAR文件是我们能够获得的最接近原始Java代码的可执行文件。因为Java代码必须由Java虚拟机解释，我们实际上无法创建Java可执行文件；然而，在大多数安装了Java的操作系统中，我们可以通过双击运行JAR文件，就像运行可执行文件一样。我们还可以告诉Java虚拟机使用Java命令行“-jar”命令启动和运行JAR文件，后面跟着我们想要执行的文件的名称，当然：
- en: '![](img/0df1bcb5-9a5d-4ff4-9675-e3e73121a04d.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0df1bcb5-9a5d-4ff4-9675-e3e73121a04d.png)'
- en: When we submitted this command, the Java virtual machine interpreted and executed
    our `WritingToFiles.jar` program. It looks like it worked because a new file was
    created in the directory, as shown in the preceding screenshot. This is the working
    directory, and until we move it, this is where the command that executed the JAR
    file will execute from. So that's where our `FileWriter` class chose to create
    `out.txt`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提交这个命令时，Java虚拟机解释并执行了我们的`WritingToFiles.jar`程序。看起来好像成功了，因为在目录中创建了一个新文件，如前面的截图所示。这是工作目录，直到我们移动它，这就是执行JAR文件的命令将执行的地方。所以这就是我们的`FileWriter`类选择创建`out.txt`的地方。
- en: Relieving resources using the close() method
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用close()方法释放资源
- en: 'Unfortunately, when we open up `out.txt`, there''s nothing for us to see. This
    leads us to believe that our file writing probably didn''t work. So what went
    wrong? Well, there''s an important piece to using a `FileWriter` that we failed
    to take into account. When our `FileWriter` is created, it opens a file, and whenever
    we open a file, we should make sure that we close it in the end. This is pretty
    easy to do from a code standpoint; we simply call the `close` method on our `FileWriter`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当我们打开`out.txt`时，我们看不到任何内容。这让我们相信我们的文件写入可能没有成功。那么出了什么问题呢？嗯，使用`FileWriter`的一个重要部分我们没有考虑到。当我们创建我们的`FileWriter`时，它会打开一个文件，每当我们打开一个文件时，我们应该确保最终关闭它。从代码的角度来看，这是相当容易做到的；我们只需在我们的`FileWriter`上调用`close`方法：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There''s a familiar error message that appears, as shown in the following screenshot;
    `out.close` can also report an `IOException` error:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个熟悉的错误消息出现，如下面的截图所示；`out.close`也可以报告一个`IOException`错误：
- en: '![](img/9d911cd7-9921-4e02-87e7-44af424facee.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d911cd7-9921-4e02-87e7-44af424facee.png)'
- en: We could put `out.close` within another `try...catch` block and handle this
    `IOException` error, but if our file cannot be closed, that's a sign that something
    is very seriously wrong. In this case, it might be appropriate for that exception
    to keep propagating upwards and that we pass it on to a more robust piece of code
    rather than our fairly contained `WritingToFiles` program. This will happen by
    default if we don't handle this exception, but we do need to let Java know that
    this exception propagating upwards from our current code is a possibility.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`out.close`放在另一个`try...catch`块中，并处理这个`IOException`错误，但如果我们的文件无法关闭，那就意味着有非常严重的问题。在这种情况下，将这个异常传播到更健壮的代码而不是我们相当封闭的`WritingToFiles`程序可能更合适。如果我们不处理这个异常，这将是默认的行为，但我们确实需要让Java知道从我们当前的代码中向上传播这个异常是可能的。
- en: 'When we declare our `main` method, we can also let Java know what exception
    types might be thrown by this method:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明我们的`main`方法时，我们还可以让Java知道这个方法可能抛出哪些异常类型：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, we tell Java that under some circumstances, our `main` method may not
    execute perfectly and will instead throw an `IOException` error. Now, anyone who
    calls the `main` method of `WritingToFiles` will need to handle this exception
    themselves. If we build our Java program and then execute it again, we''ll see
    that `out.txt` has been properly printed. Unfortunately, we forgot to put new
    lines in our output, so there''s no distinguishable spacing between the numbers.
    When we write, we will need to append `\r\n` to each number. This is a new line
    escape character syntax that''s going to be visible to just about every operating
    system and environment:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉Java，在某些情况下，我们的`main`方法可能无法完美执行，而是会抛出`IOException`错误。现在，任何调用`WritingToFiles`的`main`方法的人都需要自己处理这个异常。如果我们构建了Java程序，然后再次执行它，我们会看到`out.txt`已经被正确打印出来。不幸的是，我们忘记在输出中加入新的行，所以数字之间没有可辨认的间距。当我们写入时，我们需要在每个数字后面添加`\r\n`。这是一个新的换行转义字符语法，几乎可以在每个操作系统和环境中看到：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again, it''s time to build, run, and take a look at `out.txt`, which is now
    starting to look pretty useful:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建、运行并查看`out.txt`，现在看起来非常有用：
- en: '![](img/b2524382-1cf8-49fa-8b30-73d4e1caacba.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2524382-1cf8-49fa-8b30-73d4e1caacba.png)'
- en: 'So this was our initial stated goal: print this Fibonacci sequence out to a
    file. A few quick things before we''re finished here, though. Let''s take a look
    at what happens if we run our program again, and then take a look at our output
    text file. The text file looks the same as it does before, which may or may not
    be expected. It seems like it''s a kind of a toss-up whether `FileWriter` would
    clear this file and write brand new text, which is what it appears to have done,
    or whether it would put the appended text after the existing text in the file.
    By default, our `FileWriter` will clear the file before it writes to it anew,
    but we can toggle this behavior through a parameter in the `FileWriter` constructor.
    Say, we set its append behavior to `true`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是我们最初的目标：将这个斐波那契数列打印到一个文件中。在我们完成之前，还有一些事情要快速看一下。让我们看看如果我们再次运行程序会发生什么，然后看看我们的输出文本文件。文本文件看起来和之前一样，这可能是预期的，也可能不是。似乎`FileWriter`是否清除这个文件并写入全新的文本是一种抉择，或者它是否会在文件中现有文本后面放置追加的文本。默认情况下，我们的`FileWriter`会在写入新内容之前清除文件，但我们可以通过`FileWriter`构造函数中的参数来切换这种行为。比如，我们将其追加行为设置为`true`：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now build the project, run it, and take a look at `out.txt`; we'll see twice
    as much information as there was before. Our text is now appended at the end.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建项目，运行它，并查看`out.txt`；我们会看到比以前多两倍的信息。我们的文本现在被追加到末尾。
- en: The BufferedWriter class
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BufferedWriter类
- en: Lastly, there's a lot of different writers available to us in Java, and `FileWriter`
    is just one of them. I decided to show it to you here because it's pretty simple.
    It takes some text and prints it to a file. Very often, however, you'll see `FileWriter`
    wrapped around by the `BufferedWriter` class. Now the declaration of the `BufferedWriter`
    class will look like the one given in the following code block, where `BufferedWriter`
    is created and given `FileWriter` as its input.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Java中有很多不同的写入器可供我们使用，`FileWriter`只是其中之一。我决定在这里向你展示它，因为它非常简单。它接受一些文本并将其打印到文件中。然而，很多时候，你会看到`FileWriter`被`BufferedWriter`类包裹。现在`BufferedWriter`类的声明将看起来像以下代码块中给出的声明，其中`BufferedWriter`被创建并给定`FileWriter`作为其输入。
- en: 'The `BufferedWriter` class is pretty cool because what it does is it intelligently
    takes all the commands you give it and attempts to write the content to a file
    in the most efficient way possible:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferedWriter`类非常酷，因为它会智能地接受你给它的所有命令，并尝试以最有效的方式将内容写入文件：'
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The program we''ve just written is from our point of view, doing the same thing
    as our existing program has been doing. However, in instances where we make many
    small writes, `BufferedWriter` can be significantly faster because where appropriate,
    it will intelligently collect the write commands we give it and perform them in
    proper blocks to maximize efficiency:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的程序从我们的角度来看，做的事情与我们现有的程序一样。然而，在我们进行许多小写入的情况下，`BufferedWriter`可能会更快，因为在适当的情况下，它会智能地收集我们给它的写入命令，并以适当的块执行它们，以最大化效率：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For this reason, very often you'll see Java code that looks like the preceding
    code block, instead of the `FileWriter` being used in isolation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很多时候你会看到Java代码看起来像前面的代码块，而不是单独使用`FileWriter`。
- en: Reading data from files
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取数据
- en: A common task we'll need to perform as programmers is reading input from a file.
    In this section, we're going to take a quick look at how to acquire text input
    from files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们经常需要从文件中读取输入。在本节中，我们将快速看一下如何从文件中获取文本输入。
- en: We've gone ahead and told Java that sometimes our `main` method will simply
    throw `IOException` errors. Both the `FileWriter` and `FileReader` objects in
    the following code block can create a number of `IOException` errors for a number
    of reasons, for example, if they can't connect to the files they're supposed to.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经告诉Java，有时我们的`main`方法会简单地抛出`IOException`错误。以下代码块中的`FileWriter`和`FileReader`对象可能会因为多种原因创建多个`IOException`错误，例如，如果它们无法连接到它们应该连接的文件。
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When writing actual programs for actual applications, we should always make
    sure that we catch and handle our exceptions in a reasonable manner, throwing
    them upward if it's truly necessary. But we're going to throw everything here
    because we're doing this to learn and we don't want to be bogged down right now
    by wrapping all of our code in `try...catch` blocks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在为实际应用编写实际程序时，我们应该始终确保以合理的方式捕获和处理异常，如果真的有必要，就将它们向上抛出。但是我们现在要抛出所有的异常，因为我们这样做是为了学习，我们不想现在被包裹在`try...catch`块中的所有代码所拖累。
- en: The FileReader and BufferedReader class
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FileReader和BufferedReader类
- en: 'Here, you will learn about the `FileReader` class with the help of the code
    we already have (see the preceding code). Firstly, go through the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将通过我们已经有的代码（请参阅前面的代码）学习`FileReader`类。首先，按照以下步骤进行：
- en: I've declared `FileWriter` and `FileReader` objects for us. `FileReader` is
    a sister class of `FileWriter`. It's capable of, believe it or not, reading text
    input from files, and it's constructed in a very similar manner. It expects to
    be given a file to be associated with throughout its life when it's constructed.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我已经为我们声明了`FileWriter`和`FileReader`对象。`FileReader`是`FileWriter`的姊妹类。它能够，信不信由你，从文件中读取文本输入，并且它的构造方式非常相似。它在构造时期望被给予一个文件，以便在其生命周期内与之关联。
- en: 'Rather than simply giving the `FileReader` and `FileWriter` paths to these
    files, I''ve chosen to create `File` objects. The Java file object is simply a
    reference to an existing file, and we tell that file what file it will reference
    when it''s created as shown in the following code block:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其简单地给`FileReader`和`FileWriter`路径，我选择创建`File`对象。Java文件对象只是对现有文件的引用，我们告诉该文件在创建时将引用哪个文件，如下面的代码块所示：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this program, we're going to use `InputFile.txt`, which contains some information.
    Also, we're going to use `OutputFile.txt`, which currently contains no information.
    Our goal is to move the information from `InputFile` to `OutputFile`. Both `FileWriter`
    and `FileReader` have methods that are going to be useful here.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们将使用包含一些信息的`InputFile.txt`。此外，我们将使用`OutputFile.txt`，目前里面没有信息。我们的目标是将`InputFile`中的信息移动到`OutputFile`中。`FileWriter`和`FileReader`都有一些在这里会有用的方法。
- en: 'Our `FileWriter` class has the `write` method, which we know can be used to
    put information into a file. Similarly, `FileReader` has the `read` method, which
    will allow us to acquire information from a file. If we simply call these methods
    in sequence and run our program, we''ll see that information will be taken from
    `InputFile` and put into `OutputFile`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`FileWriter`类有`write`方法，我们知道可以用它来将信息放入文件中。同样，`FileReader`有`read`方法，它将允许我们从文件中获取信息。如果我们简单地按顺序调用这些方法并运行我们的程序，我们会看到信息将从`InputFile`中取出并放入`OutputFile`中：
- en: '![](img/bf4cf512-f991-429b-b835-a717aeea1821.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf4cf512-f991-429b-b835-a717aeea1821.png)'
- en: 'Unfortunately, only one character appears in `OutputFile`: the first character
    of the `InputFile` text. It would appear that our `FileReader` class''s `read`
    method only acquires the smallest acquirable piece of text information. This is
    not a problem for us though because we are programmers.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`OutputFile`中只出现了一个字符：`InputFile`文本的第一个字符。看起来我们的`FileReader`类的`read`方法只获取了最小可获取的文本信息。不过这对我们来说并不是问题，因为我们是程序员。
- en: 'We can simply loop through the file using the `in.read` method to acquire all
    of the information available to us in that `InputFile` file:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以简单地使用`in.read`方法循环遍历文件，以获取在`InputFile`文件中对我们可用的所有信息：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, we can make life a little easier by wrapping `FileReader` with a `BufferedReader`
    class. Similar to the way we wrap `FileWriter` with `BufferedWriter`, wrapping
    `FileReader` with `BufferedReader` will allow us to collect varying lengths of
    input at any given time:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们可以通过用`BufferedReader`类包装`FileReader`来使生活变得更加轻松。类似于我们用`BufferedWriter`包装`FileWriter`的方式，用`BufferedReader`包装`FileReader`将允许我们在任何给定时间收集不同长度的输入：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Even more so than wrapping our `FileWriter` class, it's almost always a good
    idea to wrap our `FileReader` class The `BufferedReader` class also serves to
    protect the `FileReader` class from files that are too large for the `FileReader`
    class to hold in memory at one time. This doesn't happen very often, but when
    it does happen, it can be a pretty confusing bug. This is because `BufferedReader`
    looks at the portions of the file only at one time; it's protected from that instance.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与包装我们的`FileWriter`类一样，包装我们的`FileReader`类几乎总是一个好主意。`BufferedReader`类还可以保护`FileReader`类，使其不受`FileReader`类一次性无法容纳的过大文件的影响。这种情况并不经常发生，但当发生时，可能会是一个相当令人困惑的错误。这是因为`BufferedReader`一次只查看文件的部分；它受到了那个实例的保护。
- en: The `BufferedReader` class is also going to let us use the `nextLine` method
    so that we can collect information from `InputFile` on a line-by-line basis instead
    of a character-by-character basis. Either way though, our `while` loop is going
    to look pretty similar. The only real challenge here is that we need to know when
    to stop looking for information in our `InputFile` file. To figure this out, we're
    actually going to put some functional code in the conditional portion of our `while`
    loop.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferedReader`类还将让我们使用`nextLine`方法，这样我们就可以逐行从`InputFile`中收集信息，而不是逐个字符。不过，无论如何，我们的`while`循环看起来都会非常相似。这里唯一真正的挑战是我们需要知道何时停止在`InputFile`文件中寻找信息。为了弄清楚这一点，我们实际上会在`while`循环的条件部分放一些功能代码。'
- en: 'We''re going to assign a value to this `newInput` string variable and that
    value is going to be `in.readLine`. The reason we want to do this assignment in
    the conditional portion of our `while` loop is so that we can then check what
    value was assigned to `newInput` string. This is because if `newInput` string
    were assigned no value at all, it would mean that we''d reach the end of our file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为这个`newInput`字符串变量分配一个值，这个值将是`in.readLine`。我们之所以要在`while`循环的条件部分进行这个赋值，是因为我们可以检查`newInput`字符串被分配了什么值。这是因为如果`newInput`字符串根本没有被分配任何值，那就意味着我们已经到达了文件的末尾：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If `newInput` does have a value, if the variable is not null, then we would
    know that we've read in legitimate text from our file, an entire line of legitimate
    text actually, because we're using the `readLine` method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`newInput`有一个值，如果变量不是空的，那么我们会知道我们已经从文件中读取了合法的文本，实际上是一整行合法的文本，因为我们使用了`readLine`方法。
- en: 'In such a case, we should add a new line of text, which is `input += newInput;` to
    our input string. When we''re finished executing our `while` loop, when `newInput`
    string is assigned the value `null` because there''s nothing else for our reader
    to read, we should print out the string we''ve been building:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们应该添加一行新的文本，即 `input += newInput;` 到我们的输入字符串。当我们执行完我们的 `while` 循环时，当
    `newInput` 字符串被赋予值 `null`，因为读者没有其他内容可读时，我们应该打印出我们一直在构建的字符串：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, because our `BufferedReader` class''s `readLine` method specifically reads
    lines of text, it doesn''t append the end line character at the end of these lines,
    so we''ll have to do this on our own:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，因为我们的 `BufferedReader` 类的 `readLine` 方法专门读取文本行，它不会在这些行的末尾附加结束行字符，所以我们必须自己做：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, we''ve executed this program. Let''s go to our directory and see what''s
    been copied over to `OutputFile`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经执行了这个程序。让我们去我们的目录，看看复制到 `OutputFile` 的内容：
- en: '![](img/5f074b43-77be-47bf-955d-653d75b19acf.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f074b43-77be-47bf-955d-653d75b19acf.png)'
- en: There we go; `InputFile` and `OutputFile` now have identical content. That's
    really all there is to basic file reading in Java.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 好了；`InputFile` 和 `OutputFile` 现在具有相同的内容。这就是Java中基本文件读取的全部内容。
- en: 'A couple of other things to note, though. Just as we can wrap `FileReader`
    with `BufferedReader`, we can wrap `BufferedReader` with `Scanner` if we import
    `java.util`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他需要注意的事情。就像我们可以用 `BufferedReader` 包装 `FileReader` 一样，如果我们导入 `java.util`，我们也可以用
    `Scanner` 包装 `BufferedReader`：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This would allow us to use the `Scanner` class's methodologies to acquire only
    those portions of the text we were reading that match certain patterns. It's also
    important to note that the `FileReader` class and it's wrapping classes are only
    appropriate when we're reading text from a Java file. If we want to read binary
    information, we're going to use different classes; you'll see more on this when
    you learn about serializing objects in Java.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们使用 `Scanner` 类的方法来获取我们正在读取的文本中与某些模式匹配的部分。还要注意的是，`FileReader` 类及其包装类只适用于从Java文件中读取文本。如果我们想要读取二进制信息，我们将使用不同的类；当您学习如何在Java中序列化对象时，您将看到更多相关内容。
- en: The Serializable class
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可序列化类
- en: Often, when we're dealing with information outside of our actual code, we're
    dealing with human-readable text that we've gotten from a file or are writing
    to a file or from an input or output stream. However, sometimes, human-readable
    text is just not convenient, and we'd like to use information that's more computer
    friendly. Through a process called **serialization**, we can take some Java objects
    and convert them into a binary stream that we could transfer across programs.
    This is not a human-friendly approach, as we'll see in this section. A serialized
    object looks like complete gibberish to us, but another Java program that knows
    about that object's class can recreate an object from that serialized information.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们处理实际代码之外的信息时，我们处理的是从文件中获取的或写入文件的人类可读的文本，或者来自输入或输出流的文本。然而，有时，人类可读的文本并不方便，我们希望使用更适合计算机的信息。通过一种称为**序列化**的过程，我们可以将一些Java对象转换为二进制流，然后可以在程序之间传输。这对我们来说不是一种友好的方法，我们将在本节中看到。对我们来说，序列化的对象看起来像是一团乱码，但另一个了解该对象类的Java程序可以从序列化的信息中重新创建对象。
- en: 'Not all Java objects can be serialized, though. In order for us to serialize
    an object, it needs to be marked as an object that can be serialized, and it needs
    to only contain members that themselves can be serialized. For some objects, those
    that depend on external references or those that simply haven''t had all their
    members marked as serializable, serialization is just not appropriate. Refer to
    the following code block:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有的Java对象都可以被序列化。为了使对象可序列化，它需要被标记为可以被序列化的对象，并且它只能包含那些本身可以被序列化的成员。对于一些对象来说，那些依赖外部引用或者那些只是没有所有成员都标记为可序列化的对象，序列化就不合适。参考以下代码块：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The class in the given program (in the preceding code block) is a prime candidate
    for serialization. Its members are a number of strings and integers, both of which
    are classes that Java has marked as serializable. However, in order for us to
    transform a `Car` object into a binary representation, we will need to let Java
    know that the `Car` object is serializable as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定程序中的类（在上面的代码块中）是序列化的一个主要候选对象。它的成员是一些字符串和整数，这些都是Java标记为可序列化的类。然而，为了将 `Car`
    对象转换为二进制表示，我们需要让Java知道 `Car` 对象也是可序列化的。
- en: 'We can do this by going through the following steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤来实现这一点：
- en: 'We''re going to need the `io` library for this, then we''re going to let Java
    know that our `Car` object implements `Serializable`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要 `io` 库来实现这一点，然后我们将让Java知道我们的 `Car` 对象实现了 `Serializable`：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is telling Java that all the elements of the `Car` object can be converted
    into binary representations. We should never tell Java that an object implements
    `Serializable` unless we've looked at the object and thought it out and determined
    that this is a safe assumption to make.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Java，`Car` 对象的所有元素都可以转换为二进制表示。除非我们已经查看了对象并经过深思熟虑并确定这是一个安全的假设，否则我们不应该告诉Java对象实现了
    `Serializable`。
- en: So, we've now marked `Car` as a `Serializable` class, but that is, of course,
    the easy part of this section. Our next goal is to make use of this new functionality
    to create a `Car` object, serialize it, print it out to a file, and then read
    it back.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在将 `Car` 标记为 `Serializable` 类，但这当然是本节的简单部分。我们的下一个目标是利用这个新功能来创建一个 `Car`
    对象，将其序列化，打印到文件中，然后再读取它。
- en: 'To do this, we''re going to create two new Java classes: one to serialize our
    object and print it to a file and another class to deserialize our object and
    read it from a file.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们将创建两个新的Java类：一个用于序列化我们的对象并将其打印到文件中，另一个类用于反序列化我们的对象并从文件中读取它。
- en: In both these classes, we're going to create `main` methods so that we can run
    our classes as separate Java programs.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这两个类中，我们将创建 `main` 方法，以便我们可以将我们的类作为单独的Java程序运行。
- en: Serializing an object
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化对象
- en: 'Let''s begin with the `Serialize` class, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Serialize`类开始，如下所示：
- en: 'The first thing we''re going to need is an object for us to serialize. So let''s
    go ahead and instantiate a new `Car` object. The `Car` class takes four strings
    and an integer for its variables. It takes a vehicle identification number, make,
    model, color, and a year. So we''ll give it all of that, respectively:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是为我们序列化的对象。所以让我们继续实例化一个新的`Car`对象。`Car`类需要四个字符串和一个整数作为它的变量。它需要一个车辆识别号码、制造商、型号、颜色和年份。因此，我们将分别给它所有这些：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once we've created our `Car` object, it's time to open up a file and serialize
    this `Car` for output. When we open up a file in Java, we'll use some different
    managers, depending on whether we'd like to write formatted text output to this
    file or whether we're just planning on writing raw binary information.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了我们的`Car`对象，现在是时候打开一个文件并将这个`Car`序列化输出。在Java中打开文件时，我们将使用一些不同的管理器，这取决于我们是否想要将格式化的文本输出写入这个文件，还是我们只打算写入原始二进制信息。
- en: 'Serialized objects are binary information, so we''re going to use `FileOutputStream`
    to write this information. The `FileOutputStream` class is created with a filename
    to associate itself with:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列化对象是二进制信息，所以我们将使用`FileOutputStream`来写入这些信息。`FileOutputStream`类是使用文件名创建的：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Because we're writing raw binary information, it's not that important that we
    specify it as a text file. We can specify it to be really whatever we would like.
    Our operating system really isn't going to know what to do with this file if it
    tries to open it anyway.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在写入原始二进制信息，所以指定它为文本文件并不那么重要。我们可以指定它为我们想要的任何东西。无论如何，我们的操作系统都不会知道如何处理这个文件，如果它尝试打开它的话。
- en: 'We''re going to want to surround all of this information in a `try...catch`
    block because whenever we''re dealing with external files, exceptions can definitely
    be thrown. If we do catch an exception, let''s just simply print an error message:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想要将所有这些信息包围在一个`try...catch`块中，因为每当我们处理外部文件时，异常肯定会被抛出。如果我们捕获到异常，让我们只是简单地打印一个错误消息：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that we are required to add a lot of input here; let's just import the
    entirety of the `java.io` library, that is, lets import the `java.io.*;` package.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要在这里添加很多输入；让我们只是导入整个`java.io`库，也就是说，让我们导入`java.io.*;`包。
- en: Now I think we're good to move along. We've created our `FileOutputStream` class,
    and this stream is pretty good. However, we can wrap it with another string that's
    more specialized for the act of serializing a Java object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我认为我们可以继续了。我们已经创建了我们的`FileOutputStream`类，这个流非常好。但是，我们可以用另一个更专门用于序列化Java对象的字符串来包装它。
- en: This is `ObjectOutputStream` class, and we can construct `ObjectOutputStream`
    object by simply wrapping it around an existing `FileOutputStream` object. Once
    we've created this `ObjectOutputStream` object and associated a file with it,
    serializing our object and writing it to this file becomes extremely easy. We
    simply need to use the `writeObject` method and provide our `Car` class as the
    object to be written.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`ObjectOutputStream`类，我们可以通过简单地将它包装在现有的`FileOutputStream`对象周围来构造`ObjectOutputStream`对象。一旦我们创建了这个`ObjectOutputStream`对象并将文件与之关联，将我们的对象序列化并将其写入这个文件变得非常容易。我们只需要使用`writeObject`方法，并提供我们的`Car`类作为要写入的对象。
- en: 'Once we write this object to our file, we should be responsible and close our
    output string:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们将这个对象写入文件，我们应该负责关闭我们的输出字符串：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now I think we''re good to run our following program. Let''s see what happens:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我认为我们可以运行我们接下来的程序了。让我们看看会发生什么：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have multiple `main` methods in this Java project. So as far as NetBeans
    is concerned, when we run our program, we should make sure to right-click on the
    class whose `main` method we want to enter with and run that file specifically.
    When we run this program, we don''t really get any meaningful output because we
    didn''t ask for any, at least an error wasn''t thrown. But, when we head to our
    directory in which this project lives, we''ll see a new file: `serialize.dat`.
    If we edit this file with Notepad, it looks pretty ridiculous:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Java项目中，我们有多个`main`方法。因此，就NetBeans而言，当我们运行程序时，我们应该确保右键单击要输入的`main`方法的类，并专门运行该文件。当我们运行这个程序时，我们实际上并没有得到任何有意义的输出，因为我们没有要求任何输出，至少没有抛出错误。但是，当我们前往这个项目所在的目录时，我们会看到一个新文件：`serialize.dat`。如果我们用记事本编辑这个文件，它看起来相当荒谬：
- en: '![](img/d8f4ce67-e72d-41fa-a47a-4844defd3871.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8f4ce67-e72d-41fa-a47a-4844defd3871.png)'
- en: This is certainly not a human-readable format, but there are some words, or
    fragments of words, that we recognize. It certainly looks like the correct object
    was serialized.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这肯定不是一种人类可读的格式，但有一些单词，或者单词的片段，我们是能够识别的。它看起来肯定是正确的对象被序列化了。
- en: Deserializing an object
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反序列化对象
- en: 'Let''s begin by heading to our other class, that is, the `DeSerialize` class,
    and attempt to write a method that will pull the `Car` object out from that file
    that we''ve written its serialized information to. The steps for doing this are
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的另一个类开始，也就是`DeSerialize`类，并尝试编写一个方法，从我们已经将其序列化信息写入的文件中提取`Car`对象。这样做的步骤如下：
- en: Once again, we're going to need a `Car` object, but this time, we're not going
    to initialize it with a constructor value; rather, we're going to set its value
    to be the object we read back from our file. The syntax we're going to use in
    our deserializer is going to look very similar to the syntax that we used in our
    `Serialize` class `main` method. Let's just copy the code of the `Serialize` class
    so that we can see mirrored similarities as we build our `main` method of `DeSerialize`
    class.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再一次，我们需要一个`Car`对象，但这一次，我们不打算用构造函数值来初始化它；相反，我们将把它的值设置为我们从文件中读取回来的对象。我们在反序列化器中要使用的语法将看起来非常类似于我们在`Serialize`类`main`方法中使用的语法。让我们只是复制`Serialize`类的代码，这样我们就可以在构建`DeSerialize`类的`main`方法时看到镜像相似之处。
- en: In the previously discussed `Serialize` class, we made kind of an irresponsible
    error in the `Serialize` class's method. We closed `ObjectOutputStream` but we
    did not close `FileOutputStream`. This isn't really a big deal because our program
    immediately opened these files, performed its functionality, and upon terminating
    Java, it destroyed these objects and the files knew that nothing else was pointing
    to them. So, our operating system is aware that these files are closed and can
    now be freely written. But, in a program that continues for a long time, or even
    indefinitely, not closing a file can have some very weird consequences.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前讨论的`Serialize`类中，我们在`Serialize`类的方法中犯了一个不负责任的错误。我们关闭了`ObjectOutputStream`，但没有关闭`FileOutputStream`。这并不是什么大问题，因为我们的程序立即打开了这些文件，执行了它的功能，并在终止Java时销毁了这些对象，文件知道没有其他东西指向它们。因此，我们的操作系统知道这些文件已关闭，现在可以自由地写入。但是，在一个持续很长时间甚至无限期的程序中，不关闭文件可能会产生一些非常奇怪的后果。
- en: When we're nesting `FileInput` or `Output` classes like we've done in this program,
    we're generally going to close our files in reverse order in which we accessed
    them. In this program, it wouldn't make sense for us to call `outFile.close` before
    `out.close` because for a brief moment, our `ObjectOutputStream` object would
    be referencing a file that it could no longer access because the inner `FileOutputStream`
    class would have been closed. Now delete `Car c = new Car("FDAJFD54254", " Nisan",
    "Altima", "Green", 2000);` in the current `DeSerialize.java` class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们像在这个程序中所做的那样嵌套`FileInput`或`Output`类时，通常会以我们访问它们的相反顺序关闭文件。在这个程序中，我们在调用`out.close`之前调用`outFile.close`是没有意义的，因为在这一瞬间，我们的`ObjectOutputStream`对象将引用一个它无法访问的文件，因为内部的`FileOutputStream`类已经关闭了。现在删除`Car
    c = new Car("FDAJFD54254", " Nisan", "Altima", "Green", 2000);`在当前的`DeSerialize.java`类中。
- en: With that out of the way, we've copied our code over and now we're going to
    make some modifications to it. So instead of serializing our object to a file,
    we are now reading the serialized object from a file.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 搞定了这些，我们已经复制了我们的代码，现在我们要对其进行一些修改。所以，我们现在不是将对象序列化到文件中，而是从文件中读取序列化的对象。
- en: 'Therefore, instead of a `FileOutputStream` class, we''re going to use its sister
    class, namely `FileInputStream`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们将使用它的姐妹类`FileInputStream`，而不是`FileOutputStream`：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's import `java.io` again. We want to be referencing the same filename as
    given in the preceding code; also, let's intelligently name our variables.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次导入`java.io`。我们希望引用与前面的代码中给出的相同的文件名；另外，让我们聪明地命名我们的变量。
- en: 'In a similar manner, we''re going to wrap `FileInputStream` with `ObjectInputStream`
    instead of `ObjectOutputStream`, which is still referencing the same file:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以类似的方式，我们将`FileInputStream`包装为`ObjectInputStream`，而不是`ObjectOutputStream`，它仍然引用相同的文件：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Of course, this time we have no interest in writing an object to this file,
    and that's good because our `InputStream` class does not have the permissions
    or the know-how to write to this file; what it can do, however, is read an object
    from the file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这一次我们对将对象写入文件没有兴趣，这很好，因为我们的`InputStream`类没有权限或知识来写入这个文件；然而，它可以从文件中读取对象。
- en: '`ReadObject` doesn''t take any parameters; it''s simply going to read whatever
    object happens to be in that file. When it reads that object, assign it to our
    `Car` object. Of course, `ReadObject` only knows it''s going to acquire an object
    from the file; it has no idea what type of object that will be. One of the weaknesses
    of serialization is that we really are forced to take a leap of faith and cast
    this object to the expected type:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReadObject`不需要任何参数；它只是简单地读取那个文件中的任何对象。当它读取到那个对象时，将其赋给我们的`Car`对象。当然，`ReadObject`只知道它将从文件中获取一个对象；它不知道那个对象的类型是什么。序列化的一个弱点是，我们确实被迫去相信并将这个对象转换为预期的类型：'
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once we''ve done this, it''s simply time to close our file readers in reverse
    order:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们这样做了，就是时候以相反的顺序关闭我们的文件读取器了：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There's another type of handled exception being thrown now, namely `ClassNotFoundException`:![](img/f1a66c24-7b73-458f-a70f-b7e7bfb59c3c.png)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在有另一种被处理的异常类型，即`ClassNotFoundException`：![](img/f1a66c24-7b73-458f-a70f-b7e7bfb59c3c.png)
- en: This is thrown if our `readObject` method fails.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的`readObject`方法失败，就会抛出这个异常。
- en: 'So, let''s catch `ClassNotFoundException`, and to keep things simple and moving,
    we''ll just throw or print out an error message like we did with the previous
    I/O exception:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们捕获`ClassNotFoundException`，为了保持简单和流畅，我们将像处理之前的I/O异常一样，抛出或打印出错误消息：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we need a way to tell whether our program worked or not. So, at the very
    end, let''s attempt to print out our car''s information using its custom `toString`
    function, that is, `System.out.println(c.toString());` statement. NetBeans is
    letting us know that the variable `c` might not be initialized at this point in
    time as shown in the following screenshot:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一种方法来判断我们的程序是否工作。因此，在最后，让我们尝试使用自定义的`toString`函数打印出我们汽车的信息，也就是`System.out.println(c.toString());`语句。NetBeans提示我们，变量`c`在这个时候可能尚未初始化，如下面的截图所示：
- en: '![](img/209ae27d-b146-44b4-99d6-623c1f270534.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/209ae27d-b146-44b4-99d6-623c1f270534.png)'
- en: 'Some programming languages will let us make this mistake, and our `Car` object
    might not have been initialized because this `try` block could have failed. To
    let NetBeans know that we''re aware of this case, or rather, to let Java know
    that we''re aware of this case, we should initialize our `Car` object. We can
    simply initialize it to the value `null`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有些编程语言会让我们犯这个错误，我们的`Car`对象可能尚未初始化，因为这个`try`块可能已经失败了。为了让NetBeans知道我们意识到了这种情况，或者说，让Java知道我们意识到了这种情况，我们应该初始化我们的`Car`对象。我们可以简单地将其初始化为值`null`：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now it''s time for our moment of truth. Let''s execute the main method. When
    we run our file in our console, we get the output as a pin number: `2000 Green
    Nisan Altima with vin: FDAJFD54254`. This is illustrated in the following screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '现在是我们真相的时刻。让我们执行主方法。当我们在控制台中运行我们的文件时，我们得到的输出是一个PIN码：`2000 Green Nisan Altima
    with vin: FDAJFD54254`。如下面的截图所示：'
- en: '![](img/ff4aebb5-e973-413e-98e8-99e163e4e226.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff4aebb5-e973-413e-98e8-99e163e4e226.png)'
- en: That's the same car we declared in the `main` method of the `Serialize.java`
    class and serialized to the file. Clearly, we have been successful. Serialization
    of objects is one of the things that Java does really elegantly and really well.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在`Serialize.java`类的`main`方法中声明并序列化到文件中的同一辆车。显然，我们取得了成功。对象的序列化是Java非常优雅和出色的功能之一。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we went through the process of writing and reading data files,
    where we saw the usage of `FileWriter` and `FileReader` classes and how to relieve
    resources that use the `close()` method. We also saw how to catch an exception
    and handle it. Then, you learned how to use the `BufferedWriter` and `BufferedReader`
    classes to wrap the `FileWriter` and `FileReader` classes, respectively. Finally,
    we saw one more aspect of I/O: the `Serializable` class. We analyzed what serialization
    is and its usage with respect to serializing and deserializing objects.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们经历了编写和读取数据文件的过程，我们看到了`FileWriter`和`FileReader`类的用法，以及如何使用`close()`方法释放资源。我们还学习了如何捕获异常并处理它。然后，您学习了如何使用`BufferedWriter`和`BufferedReader`类分别包装`FileWriter`和`FileReader`类。最后，我们看到了I/O的另一个方面：`Serializable`类。我们分析了序列化的含义以及在序列化和反序列化对象方面的用法。
- en: In the next chapter, you'll learn about basic GUI development.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习基本的GUI开发。
