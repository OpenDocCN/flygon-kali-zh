- en: 2\. Building User Screen Flows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 构建用户屏幕流程
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter covers the Android activity lifecycle and explains how the Android
    system interacts with your app. By the end of this chapter, you'll have learned
    how to build user journeys through different screens. You'll also be able to use
    activity tasks and launch modes, save and restore the state of your activity,
    use logs to report on your application, and share data between screens.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Android活动生命周期，并解释了Android系统如何与您的应用程序交互。通过本章的学习，您将学会如何在不同屏幕之间构建用户旅程。您还将能够使用活动任务和启动模式，保存和恢复活动的状态，使用日志报告您的应用程序，并在屏幕之间共享数据。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The previous chapter introduced you to the core elements of Android development,
    from configuring your app using the `AndroidManifest.xml` file, working with simple
    activities, and the Android resource structure, to building an app with `build.gradle`
    and running an app on a virtual device. In this chapter, you'll go further and
    learn how the Android system interacts with your app through the Android lifecycle,
    how you are notified of changes to your app's state, and how you can use the Android
    lifecycle to respond to these changes. You'll then progress to learning how to
    create user journeys through your app and how to share data between screens. You'll
    be introduced to different techniques to achieve these goals so that you'll be
    able to use them in your own apps and recognize them when you see them used in
    other apps.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章向您介绍了Android开发的核心元素，从使用`AndroidManifest.xml`文件配置您的应用程序，使用简单活动和Android资源结构，到使用`build.gradle`构建应用程序并在虚拟设备上运行应用程序。在本章中，您将进一步学习Android系统如何通过Android生命周期与您的应用程序交互，您将被通知应用程序状态的变化，以及您如何使用Android生命周期来响应这些变化。然后，您将学习如何在应用程序中创建用户旅程以及如何在屏幕之间共享数据。您将介绍不同的技术来实现这些目标，以便您能够在自己的应用程序中使用它们，并在其他应用程序中看到它们被使用时能够识别出来。
- en: The Activity Lifecycle
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动生命周期
- en: 'In the previous chapter, we used the `onCreate(saveInstanceState: Bundle?)`
    method to display a layout in the UI of our screen. Now, we''ll explore in more
    detail how the Android system interacts with your application to make this happen.
    As soon as an Activity is launched, it goes through a series of steps to take
    it through initialization and preparing it to be displayed to being partially
    displayed, and then fully displayed. There are also steps that correspond with
    your application being hidden, backgrounded, and then destroyed. This process
    is called the **Activity lifecycle**. For every one of these steps, there is a
    **callback** that your Activity can use to perform actions such as creating and
    changing the display and saving data when your app has been put into the background
    and then restoring that data after your app comes back into the foreground. You
    can consider these callbacks as hooks into how the system interacts with your
    activity/screen.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '在上一章中，我们使用`onCreate(saveInstanceState: Bundle?)`方法在屏幕的UI中显示布局。现在，我们将更详细地探讨Android系统如何与您的应用程序交互以实现这一点。一旦启动Activity，它就会经历一系列步骤，使其经过初始化并准备好显示部分显示，然后完全显示。还有一些步骤对应着您的应用程序被隐藏、后台运行，然后被销毁。这个过程被称为**Activity生命周期**。对于这些步骤中的每一个，都有一个**回调**，您的Activity可以使用它来执行操作，比如在您的应用程序被放入后台时创建和更改显示，并在您的应用程序恢复到前台后恢复数据。您可以将这些回调视为系统与您的Activity/屏幕交互的钩子。'
- en: Every Activity has a parent Activity class that it extends. These callbacks
    are made on your Activity's parent, and it's up to you to decide whether you need
    to implement them in your own Activity to take any corresponding action. Every
    one of these callback functions has the `override` keyword. The `override` keyword
    in Kotlin means that either this function is providing an implementation of an
    interface or an abstract method, or, in the case of your Activity here, which
    is a subclass, it is providing the implementation that will override its parent.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Activity都有一个父Activity类，它是扩展的。这些回调是在您的Activity的父类上进行的，由您决定是否需要在自己的Activity中实现它们以执行任何相应的操作。这些回调函数中的每一个都有`override`关键字。在Kotlin中，`override`关键字表示这个函数要么提供接口或抽象方法的实现，要么在这里的Activity中，它是一个子类，它提供了将覆盖其父类的实现。
- en: 'Now that you know how the **Activity lifecycle** works in general, let''s go
    into more detail about the principal callbacks you will work with in order, from
    creating an Activity to the Activity being destroyed:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了**Activity生命周期**的一般工作原理，让我们更详细地了解您将按顺序使用的主要回调，从创建Activity到销毁Activity：
- en: '`override fun onCreate(savedInstanceState: Bundle?)`: This is the callback
    that you will use the most for activities that draw a full-sized screen. It''s
    here where you prepare your Activity layout to be displayed. At this stage, after
    the method completes, it is still not displayed to the user, although it will
    appear that way if you don''t implement any other callbacks. You usually set up
    the UI of your Activity here by calling the `setContentView` method `setContentView(R.layout.activity_main`)
    and carry out any initialization that is required. This method is only called
    once in its `savedInstanceState` parameter of the `Bundle?` type (`?` means the
    type can be null) in its simplest form is a map of key-value pairs optimized to
    save and restore data. It will be null if this is the first time that the Activity
    has been run after the app has started or if the Activity is being created for
    the first time or recreated without any states being saved. It may contain a saved
    state if it has been saved in the `onSaveInstanceState(outState: Bundle?)` callback
    prior to the Activity being recreated.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onCreate(savedInstanceState: Bundle?)`: 这是你在绘制全屏幕大小的活动中最常用的回调。在这里，你准备好你的活动布局以便显示。在此阶段，方法完成后，尽管如果你不实现任何其他回调，它仍未显示给用户，但如果你不实现任何其他回调，它看起来是这样的。你通常通过调用`setContentView`方法`setContentView(R.layout.activity_main)`来设置活动的UI，并进行任何必要的初始化。这个方法只会在其`savedInstanceState`参数中调用一次，`Bundle?`类型（`?`表示类型可以为null），在其最简单的形式中是一种优化保存和恢复数据的键值对映射。如果这是应用程序启动后首次运行活动，或者活动首次创建或重新创建而没有保存任何状态，它将为null。如果在活动重新创建之前已在`onSaveInstanceState(outState:
    Bundle?)`回调中保存了状态，它可能包含一个保存的状态。'
- en: '`override fun onRestart()`: When the Activity restarts, this is called immediately
    before `onStart()`. It is important to be clear about the difference between restarting
    an Activity and recreating an activity. When the Activity is backgrounded by pressing
    the home button—for instance, when it comes back into the foreground again—`onRestart()`
    will be called. Recreating an Activity is what happens when a configuration change
    happens, such as the device being rotated. The Activity is finished and then created
    again.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onRestart()`: 当活动重新启动时，此方法会在`onStart()`之前立即调用。重启活动和重新创建活动之间的区别很重要。当活动通过按下主页按钮置于后台时，例如，当它再次进入前台时，将调用`onRestart()`。重新创建活动是指发生配置更改，例如设备旋转时发生的情况。活动被结束然后重新创建。'
- en: '`override fun onStart()`: This is the callback made when the Activity first
    comes into view. Also, after the app is backgrounded by pressing either the back,
    home, or the `recents/overview` hardware buttons, on selecting the app again from
    the `recents/overview` menu or the launcher, this function will be run. It is
    the first of the visible lifecycle methods.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onStart()`: 当活动首次显示时进行的回调。此外，在通过按下返回、主页或`最近应用/概览`硬件按钮将应用置于后台后，从`最近应用/概览`菜单或启动器中再次选择应用时，也会运行此函数。这是可见生命周期方法中的第一个。'
- en: '`override fun onRestoreInstanceState(savedInstanceState: Bundle?)`: If the
    state has been saved using `onSaveInstanceState(outState: Bundle?)` this is the
    method which the system calls after `onStart()` where you can retrieve the `Bundle`
    state instead of restoring the state during `onCreate(savedInstanceState: Bundle?)`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onRestoreInstanceState(savedInstanceState: Bundle?)`: 如果状态已经使用`onSaveInstanceState(outState:
    Bundle?)`保存，系统会在`onStart()`之后调用此方法，你可以在这里检索`Bundle`状态，而不是在`onCreate(savedInstanceState:
    Bundle?)`期间恢复状态。'
- en: '`override fun onResume()`: This callback is run as the final stage of creating
    an Activity for the first time, and also when the app has been backgrounded and
    then is brought into the foreground. Upon the completion of this callback, the
    screen/activity is ready to be used, receive user events, and be responsive.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onResume()`: 这个回调函数在首次创建活动的最后阶段运行，也在应用程序被置于后台然后再次进入前台时运行。在完成这个回调后，屏幕/活动已经准备好被使用，接收用户事件，并且响应。'
- en: '`override fun onSaveInstanceState(outState: Bundle?)`: If you want to save
    the state of the activity, this function can do so. You add key-value pairs using
    one of the convenience functions depending on the data type. The data will then
    be available if your Activity is recreated in `onCreate(saveInstanceState: Bundle?)`
    and `onRestoreInstanceState(savedInstanceState: Bundle?)`.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onSaveInstanceState(outState: Bundle?)`: 如果你想保存活动的状态，这个函数可以做到。你可以使用便捷函数之一添加键值对，具体取决于数据类型。如果你的活动在`onCreate(saveInstanceState:
    Bundle?)`和`onRestoreInstanceState(savedInstanceState: Bundle?)`中重新创建，这些数据将可用。'
- en: '`override fun onPause()`: This function is called when the Activity starts
    to be backgrounded or another dialog or Activity comes into the foreground.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onPause()`: 当活动开始被置于后台或另一个对话框或活动进入前台时，调用此函数。'
- en: '`override fun onStop()`: This function is called when the Activity is hidden,
    either because it is being backgrounded or another Activity is being launched
    on top of it.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onStop()`: 当活动被隐藏时调用此函数，无论是因为被置于后台还是因为另一个活动在其上启动。'
- en: '`override fun onDestroy()`: This is called by the system to kill the Activity
    when system resources are low, when `finish()` is called explicitly on the Activity,
    or, more commonly, when the Activity is killed by the user closing the app from
    the recents/overview button.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onDestroy()`: 当系统资源不足时，显式调用`finish()`方法，或者更常见的是用户从最近应用/概览按钮关闭应用时，系统会调用此函数来销毁活动。'
- en: Now that you understand what these common lifecycle callbacks do, let's implement
    them to see when they are called.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你了解了这些常见的生命周期回调函数的作用，让我们实现它们，看它们何时被调用。
- en: 'Exercise 2.01: Logging the Activity Callbacks'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.01：记录活动回调
- en: 'Let''s create an application called *Activity Callbacks* with an empty Activity,
    as you did previously in *Chapter 1*, *Creating Your First App*. The aim of this
    exercise is to log the Activity callbacks and the order that they occur for common
    operations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为*Activity Callbacks*的应用程序，其中包含一个空活动，就像您在*第1章*中所做的那样，创建您的第一个应用程序。这个练习的目的是记录活动回调以及它们发生的顺序，以进行常见操作：
- en: 'After the application has been created, `MainActivity` will appear as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序创建后，`MainActivity`将如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to verify the order of the callbacks, let''s add a log statement at
    the end of each callback. To prepare the Activity for logging, import the Android
    log package by adding `import android.util.Log` to the `import` statements. Then,
    add a constant to the class to identify your Activity. Constants in Kotlin are
    identified by the `const` keyword and can be declared at the top level (outside
    the class) or in an object within the class. Top level constants are generally
    used if they are required to be public. For private constants, Kotlin provides
    a convenient way to add static functionality to classes by declaring a companion
    object. Add the following at the bottom of the class below `onCreate(savedInstanceState:
    Bundle?)`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '为了验证回调的顺序，让我们在每个回调的末尾添加一个日志语句。为了准备活动进行日志记录，通过在`import`语句中添加`import android.util.Log`来导入Android日志包。然后，在类中添加一个常量来标识您的活动。Kotlin中的常量由`const`关键字标识，并且可以在顶层（类外）或在类内的对象中声明。如果需要公共常量，通常使用顶级常量。对于私有常量，Kotlin提供了一种方便的方法，通过声明伴生对象来向类添加静态功能。在类的底部以下添加以下内容`onCreate(savedInstanceState:
    Bundle?)`：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then add a log statement at the end of `onCreate(savedInstanceState: Bundle?)`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '然后在`onCreate(savedInstanceState: Bundle?)`的末尾添加一个日志语句：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our Activity should now have the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的活动现在应该有以下代码：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`d` in the preceding log statement refers to *debug*. There are six different
    log levels that can be used to output message information from the least to most
    important - `v` for *verbose*, `d` for *debug*, `i` for *info*, `w` for *warn*,
    `e` for *error*, and `wtf` for *what a terrible failure*. (This last log level
    highlights an exception that should never occur.)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的日志语句中，`d`代表*debug*。有六种不同的日志级别可以用来输出从最不重要到最重要的消息信息 - `v`代表*verbose*，`d`代表*debug*，`i`代表*info*，`w`代表*warn*，`e`代表*error*，`wtf`代表*what
    a terrible failure*。（最后一个日志级别突出显示了一个不应该发生的异常。）
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, let's see how the logs are displayed in Android Studio. Open the `Logcat`
    window. It can be accessed by clicking on the `Logcat` tab at the bottom of the
    screen and also from the toolbar by going to `View` | `Tool Windows` | `Logcat`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看日志在Android Studio中是如何显示的。打开`Logcat`窗口。可以通过单击屏幕底部的`Logcat`选项卡或者从工具栏中转到`View`
    | `Tool Windows` | `Logcat`来访问它。
- en: 'Run the app on the virtual device and examine the `Logcat` window output. You
    should see the log statement you have added formatted like the following line
    in *Figure 2.1*:![Figure 2.1: Log output in Logcat'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚拟设备上运行应用程序并检查`Logcat`窗口输出。您应该看到您添加的日志语句的格式如*图2.1*中的以下行：![图2.1：Logcat中的日志输出
- en: '](img/B15216_02_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_01.jpg)'
- en: 'Figure 2.1: Log output in Logcat'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：Logcat中的日志输出
- en: 'Log statements can be quite difficult to interpret at first glance, so let''s
    break down the following statement into its separate parts:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日志语句一开始可能很难解释，所以让我们将以下语句分解为其各个部分：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s examine the elements of the log statement in detail:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查日志语句的元素：
- en: '![Figure 2.2: Table explaining a log statement'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2：解释日志语句的表'
- en: '](img/B15216_02_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_02.jpg)'
- en: 'Figure 2.2: Table explaining a log statement'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：解释日志语句的表
- en: You can examine the output of the different log levels by changing the log filter
    from `Debug` to other options in the drop-down menu. If you select `Verbose`,
    as the name implies, you will see a lot of output.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将日志过滤器从`Debug`更改为下拉菜单中的其他选项来检查不同日志级别的输出。如果您选择`Verbose`，正如其名称所示，您将看到大量输出。
- en: 'What''s great about the `TAG` option of the log statement is that it enables
    you to filter the log statements that are reported in the `Logcat` window of Android
    Studio by typing in the text of the tag, as shown in *Figure 2.3*:![Figure 2.3:
    Filtering log statements by the TAG name'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日志语句的`TAG`选项之所以好用，是因为它使您能够通过输入标签的文本来过滤在Android Studio的`Logcat`窗口中报告的日志语句，如*图2.3*所示：![图2.3：通过TAG名称过滤日志语句
- en: '](img/B15216_02_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_03.jpg)'
- en: 'Figure 2.3: Filtering log statements by the TAG name'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：通过TAG名称过滤日志语句
- en: So, if you are debugging an issue in your Activity, you can type in the `TAG`
    name and add logs to your Activity to see the sequence of log statements. This
    is what you are going to do next by implementing the principal Activity callbacks
    and adding a log statement to each one to see when they are run.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您正在调试活动中的问题，您可以输入`TAG`名称并向您的活动添加日志以查看日志语句的顺序。这就是您接下来要做的事情，通过实现主要活动回调并向每个回调添加一个日志语句来查看它们何时运行。
- en: 'Place your cursor on a new line after the closing brace of the `onCreate(savedInstanceState:
    Bundle?)` function and then add the `onRestart()` callback with a log statement.
    Make sure you call through to `super.onRestart()` so that the existing functionality
    of the Activity callback works as expected:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`onCreate(savedInstanceState: Bundle?)`函数的右括号后的新行上放置光标，然后添加`onRestart()`回调和一个日志语句。确保调用`super.onRestart()`，以便活动回调的现有功能按预期工作：'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You will find that once you start typing the name of the function, Android Studio's
    autocomplete feature will suggest options for the name of the function you want
    to override.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您开始输入函数的名称，Android Studio的自动完成功能将建议您要重写的函数的名称选项。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Your Activity should now have the following code (truncated here). You can see
    the full code on GitHub at [http://packt.live/38W7jU5](http://packt.live/38W7jU5
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的活动现在应该有以下代码（此处截断）。您可以在GitHub上查看完整的代码[http://packt.live/38W7jU5](http://packt.live/38W7jU5
- en: )
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: 'The completed activity will now override the callbacks with your implementation,
    which adds a log message:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的活动现在将使用您的实现覆盖回调，其中添加了一个日志消息：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the app, and then once it has loaded, as in *Figure 2.4*, look at the `Logcat`
    output; you should see the following log statements (this is a shortened version):'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，一旦加载完成，就像*图2.4*中一样，查看`Logcat`输出；您应该会看到以下日志语句（这是一个缩短版）：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The Activity has been created, started, and then prepared for the user to interact with:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建、启动并准备好供用户进行交互的活动：
- en: '![Figure 2.4: The app loaded and displaying MainActivity'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4：应用程序加载并显示MainActivity'
- en: '](img/B15216_02_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_04.jpg)'
- en: 'Figure 2.4: The app loaded and displaying MainActivity'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：应用程序加载并显示MainActivity
- en: 'Press the round home button in the center of the bottom navigation controls
    and background the app. You should now see the following Logcat output:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下底部导航控件中心的圆形主页按钮，将应用程序放到后台。您现在应该看到以下`Logcat`输出：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For apps which target below Android Pie (API 28) then `onSaveInstanceState(outState:
    Bundle?)` may also be called before `onPause()` or `onStop()`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '对于目标低于Android Pie（API 28）的应用程序，`onSaveInstanceState(outState: Bundle?)`也可能在`onPause()`或`onStop()`之前被调用。'
- en: 'Now, bring the app back into the foreground by pressing the recents/overview
    button (usually a square or three vertical lines) on the right and selecting the
    app, or by going to the launcher and opening the app. You should now see the following:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过按下右侧的最近/概览按钮（通常是一个方形或三条垂直线）并选择应用程序，或者通过转到启动器并打开应用程序，将应用程序带回前台。您现在应该看到以下内容：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Activity has been restarted. You might have noticed that the `onRestoreInstanceState(savedInstanceState:
    Bundle)` function was not called. This is because the Activity was not destroyed
    and recreated.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '活动已重新启动。您可能已经注意到`onRestoreInstanceState(savedInstanceState: Bundle)`函数未被调用。这是因为活动未被销毁和重建。'
- en: 'Press the triangle back button on the left of the bottom navigation controls
    (it may also be on the right) and you will see the Activity being destroyed. You
    can also do this by pressing the recents/overview button and then swiping the
    app upward to kill the activity. This is the output:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下底部导航控件左侧（也可能在右侧）的三角形返回按钮，您将看到活动被销毁。您还可以通过按下最近/概览按钮，然后向上滑动应用程序来终止活动。这是输出：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Launch your app again and then rotate the phone. You might find that the phone
    does not rotate and the display is sideways. If this happens drag down the status
    bar at the very top of the virtual device and select the auto-rotate button 2nd
    from the right in the settings.![Figure 2.5: Quick settings bar with Wi-Fi and
    Auto-rotate button selected'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次启动应用程序，然后旋转手机。您可能会发现手机不会旋转，显示屏是横向的。如果发生这种情况，请在虚拟设备顶部拉下状态栏，并选择设置中从右边数第二个的自动旋转按钮。![图2.5：快速设置栏，选中Wi-Fi和自动旋转按钮
- en: '](img/B15216_02_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_05.jpg)'
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Please note that as stated in step 11, the order of the `onSaveInstanceState(outState:
    Bundle?)` callback may vary.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，如步骤11所述，`onSaveInstanceState(outState: Bundle?)`回调的顺序可能会有所不同。'
- en: 'Configuration changes, such as rotating the phone, by default recreate the
    activity. You can choose not to handle certain configuration changes in the app,
    which will then not recreate the activity. To do this for rotation, add `android:configChanges="orientation|screenSize|screenLayout"`
    to `MainActivity` in the `AndroidManifest.xml` file. Launch the app and then rotate
    the phone, and these are the only callbacks that you have added to `MainActivity`
    that you will see:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，配置更改（例如旋转手机）会重新创建活动。您可以选择不在应用程序中处理某些配置更改，这样就不会重新创建活动。要对旋转进行此操作，请在`AndroidManifest.xml`文件的`MainActivity`中添加`android:configChanges="orientation|screenSize|screenLayout"`。启动应用程序，然后旋转手机，您将看到已添加到`MainActivity`的唯一回调：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `orientation` and `screenSize` values have the same function for different
    Android API levels for detecting screen orientation changes. The `screenLayout`
    value detects other layout changes which might occur on foldable phones. These
    are some of the config changes you can choose to handle yourself (another common
    one is `keyboardHidden` to react to changes in accessing the keyboard). The app
    will still be notified by the system of these changes through the following callback:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`orientation`和`screenSize`值对于不同的Android API级别具有相同的功能，用于检测屏幕方向的更改。`screenLayout`值检测可能在可折叠手机上发生的其他布局更改。这些是您可以选择自行处理的一些配置更改（另一个常见的更改是`keyboardHidden`，用于对访问键盘的更改做出反应）。应用程序仍将通过以下回调被系统通知这些更改：'
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you add this callback function to `MainActivity`, and you have added `android:configChanges="orientation|screenSize|screenLayout"`
    to `MainActivity` in the manifest, you will see it called on rotation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将此回调函数添加到`MainActivity`，并且在清单中为`MainActivity`添加了`android:configChanges="orientation|screenSize|screenLayout"`，您将在旋转时看到它被调用。
- en: In this exercise, you have learned about the principal Activity callbacks and
    how they run when a user carries out common operations with your app through the
    system's interaction with `MainActivity`. In the next section, you will cover
    saving the state and restoring it, as well as see more examples of how the Activity
    lifecycle works.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您已经了解了主要的活动回调以及当用户通过系统与`MainActivity`进行常见操作时它们是如何运行的。在下一节中，您将学习保存状态和恢复状态，以及看到活动生命周期的更多示例。
- en: Saving and Restoring the Activity State
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和恢复活动状态
- en: In this section, you'll explore how your Activity saves and restores the state.
    As you've learned in the previous section, configuration changes, such as rotating
    the phone, cause the Activity to be recreated. This can also happen if the system
    has to kill your app in order to free up memory. In these scenarios, it is important
    to preserve the state of the Activity and then restore it. In the next two exercises,
    you'll work through an example ensuring that the user's data is restored when
    `TextView` is created and populated from a user's data after filling in a form.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将探索你的Activity如何保存和恢复状态。正如你在上一节中学到的，配置更改，比如旋转手机，会导致Activity被重新创建。如果系统需要杀死你的应用程序以释放内存，也会发生这种情况。在这些情景中，保留Activity的状态然后恢复它是很重要的。在接下来的两个练习中，你将通过一个示例确保当`TextView`被创建并从用户的数据中填充表单后，用户的数据得到恢复。
- en: 'Exercise 2.02: Saving and Restoring the State in Layouts'
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.02：在布局中保存和恢复状态
- en: 'In this exercise, firstly create an application called *Save and Restore* with
    an empty activity. The app you are going to create will have a simple form that
    offers a discount code for a user''s favorite restaurant if they enter some personal
    details (no actual information will be sent anywhere, so your data is safe):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，首先创建一个名为*Save and Restore*的应用程序，其中包含一个空的活动。你将创建的应用程序将有一个简单的表单，如果用户输入一些个人信息，就会提供一个用户最喜欢的餐厅的折扣码（实际上不会发送任何信息，所以你的数据是安全的）：
- en: 'Open up the `strings.xml` file (located in `app` | `src` | `main` | `res` |
    `values` | `strings.xml`) and create the following strings that you''ll need for
    your app:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`strings.xml`文件（位于`app` | `src` | `main` | `res` | `values` | `strings.xml`），并创建你的应用程序所需的以下字符串：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You are also going to specify some text sizes, layout margins, and padding
    directly, so create the `dimens.xml` file in the `app` | `src` | `main` | `res`
    | `values` folder and add the dimensions you''ll need for the app (you can do
    this by right-clicking on the `res` | `values` folder within Android Studio and
    selecting `New` `values`):'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还将直接指定一些文本大小、布局边距和填充，因此在`app` | `src` | `main` | `res` | `values`文件夹中创建`dimens.xml`文件，并添加你的应用程序所需的尺寸（你可以通过在Android
    Studio中右键单击`res` | `values`文件夹，然后选择`New` `values`来完成）：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, you are specifying all the dimensions you need in the exercise. You will
    see here that `default_text_size` and `discount_code_text_size` are specified
    in `sp`. They represent the same values as density-independent pixels, which not
    only define the size measurement according to the density of the device that your
    app is being run on but also change the text size according to the user's preference,
    defined in `Settings` | `Display` | `Font style` (this might be `Font size and
    style` or something similar, depending on the exact device you are using).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在指定练习中所需的所有尺寸。你将看到`default_text_size`和`discount_code_text_size`在`sp`中指定。它们代表与密度无关的像素，不仅根据你的应用程序运行的设备的密度定义尺寸测量，而且根据用户在`设置`
    | `显示` | `字体样式`中定义的偏好更改文本大小（这可能是`字体大小和样式`或类似的，具体取决于你使用的确切设备）。
- en: 'In `R.layout.activity_main`, add the following XML, creating a containing layout
    file and adding header a `TextView` with the `Enter your name and email for a
    discount code at Your Favorite Restaurant!` text. This is done by adding the `android:text`
    attribute with the `@string/header_text` value:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`R.layout.activity_main`中，添加以下XML，创建一个包含布局文件，并添加一个带有`Enter your name and email
    for a discount code at Your Favorite Restaurant!`文本的标题`TextView`。这是通过添加`android:text`属性和`@string/header_text`值来完成的：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You are using `ConstraintLayout` for constraining Views against the parent View
    and sibling Views.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用`ConstraintLayout`来约束父视图和同级视图。
- en: Although you should normally specify the display of the View with styles, you
    can do this directly in the XML, as is done for some attributes here. The value
    of the `android:textSize` attribute is `@dimen/default_text_size`, defined in
    the previous code block, which you use to avoid repetition, and it enables you
    to change all the text size in one place. Using styles is the preferred option
    for setting text sizes as you will get sensible defaults and you can override
    the value in the style or, as you are doing here, on the individual Views.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常应该使用样式来指定视图的显示，但你可以直接在XML中进行，就像这里的一些属性所做的那样。`android:textSize`属性的值是`@dimen/default_text_size`，在前面的代码块中定义，你可以使用它来避免重复，并且它使你能够在一个地方更改所有文本的大小。使用样式是设置文本大小的首选选项，因为你将获得合理的默认值，并且你可以在样式中覆盖该值，或者像你在这里做的那样，在单独的视图上覆盖该值。
- en: Other attributes that affect positioning are also specified directly here in
    the Views. The most common ones are padding and margin. Padding is applied on
    the inside of Views and is the space between the text and the border. Margin is
    specified on the outside of Views and is the space from the outer edges of Views.
    For example, `android:padding` in `ConstraintLayout` sets the padding for the
    View with the specified value on all sides. Alternatively, you can specify the
    padding for one of the four sides of a View with `android:paddingTop`, `android:paddingBottom`,
    `android:paddingStart`, and `android:paddingEnd`. This pattern also exists to
    specify margins, so `android:layout_margin` specifies the margin value for all
    four sides of a View and `android:layoutMarginTop`, `android:layoutMarginBottom`,
    `android:layoutMarginStart`, and `android:layoutMarginEnd` allow setting the margin
    for individual sides.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其他影响定位的属性也直接在视图中指定。最常见的是填充和边距。填充应用在视图的内部，是文本和边框之间的空间。边距在视图的外部指定，是视图的外边缘之间的空间。例如，在`ConstraintLayout`中，`android:padding`设置了具有指定值的视图的填充。或者，你可以使用`android:paddingTop`、`android:paddingBottom`、`android:paddingStart`和`android:paddingEnd`来指定视图的四个边的填充。这种模式也存在于指定边距，所以`android:layout_margin`指定了视图四个边的边距值，`android:layoutMarginTop`、`android:layoutMarginBottom`、`android:layoutMarginStart`和`android:layoutMarginEnd`允许设置单独边的边距。
- en: For API levels less than 17 (and your app supports down to 16) you also have
    to add `android:layoutMarginLeft` if you use `android:layoutMarginStart` and `android:layoutMarginRight`
    if you use `android:layoutMarginEnd`. In order to have consistency and uniformity
    throughout the app, you define the margin and padding values as dimensions contained
    within the `dimens.xml` file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小于17的API级别（并且您的应用程序支持到16），如果使用`android:layoutMarginStart`，则还必须添加`android:layoutMarginLeft`，如果使用`android:layoutMarginEnd`，则必须添加`android:layoutMarginRight`。为了在整个应用程序中保持一致性和统一性，您将边距和填充值定义为包含在`dimens.xml`文件中的尺寸。
- en: To position the content within a View, you can specify `android:gravity`. The
    `center` value constrains the content both vertically and horizontally within
    the View.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要在视图中定位内容，您可以指定`android:gravity`。`center`值会在`View`内垂直和水平方向上约束内容。
- en: 'Next, add three `EditText` views below the `header_text` for the user to add
    their first name, last name, and email:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`header_text`下方添加三个`EditText`视图，供用户添加他们的名字、姓氏和电子邮件：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `EditText` fields have an `inputType` attribute to specify the type of input
    that can be entered into the form field. Some values, such as `number` on `EditText`,
    restrict the input that can be entered into the field, and on selecting the field,
    suggest how the keyboard is displayed. Others, such as `android:inputType="textEmailAddress"`,
    will not enforce an `@` symbol being added to the form field, but will give a
    hint to the keyboard to display it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditText`字段具有`inputType`属性，用于指定可以输入到表单字段中的输入类型。一些值，例如`EditText`上的`number`，限制了可以输入到字段中的输入，并在选择字段时建议键盘的显示方式。其他值，例如`android:inputType="textEmailAddress"`，不会强制在表单字段中添加`@`符号，但会提示键盘显示它。'
- en: 'Finally, add a button for the user to press to generate a discount code, and
    display the discount code itself and a confirmation message:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个按钮，供用户按下以生成折扣代码，并显示折扣代码本身和确认消息：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are also some attributes that you haven't seen before. The tools namespace
    `xmlns:tools="http://schemas.android.com/tools"` which was specified at the top
    of the xml layout file enables certain features that can be used when creating
    your app to assist with configuration and design. The attributes are removed when
    you build your app, so they don't contribute to the overall size of the app. You
    are using the `tools:text` attribute to show the text that will typically be displayed
    in the form fields. This helps when you switch to the `Design` view from viewing
    the XML in the `Code` view in Android Studio as you can see an approximation of
    how your layout displays on a device.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些以前没有见过的属性。在xml布局文件顶部指定的tools命名空间`xmlns:tools="http://schemas.android.com/tools"`启用了在创建应用程序时可以使用的某些功能，以帮助配置和设计。这些属性在构建应用程序时会被移除，因此它们不会影响应用程序的整体大小。您正在使用`tools:text`属性来显示通常会显示在表单字段中的文本。当您从Android
    Studio中的`Code`视图切换到`Design`视图时，这有助于您看到布局在设备上的显示近似值。
- en: 'Run the app and you should see the output displayed in *Figure 2.6*:![Figure
    2.6: The Activity screen on the first launch'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，您应该看到输出显示在*图2.6*中：![图2.6：首次启动时的Activity屏幕
- en: '](img/B15216_02_06.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_06.jpg)'
- en: 'Figure 2.6: The Activity screen on the first launch'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：首次启动时的Activity屏幕
- en: 'Enter some text into each of the form fields:![Figure 2.7: The EditText fields
    filled in'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个表单字段中输入一些文本：![图2.7：填写的EditText字段
- en: '](img/B15216_02_07.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_07.jpg)'
- en: 'Figure 2.7: The EditText fields filled in'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：填写的EditText字段
- en: 'Now, use the second rotate button in the virtual device controls (![1](img/B15216_Icon1.png))
    to rotate the phone 90 degrees to the right:![Figure 2.8: The virtual device turned
    to landscape orientation'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用虚拟设备控件中的第二个旋转按钮（![1](img/B15216_Icon1.png)）将手机向右旋转90度：![图2.8：虚拟设备转为横向方向
- en: '](img/B15216_02_08.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_08.jpg)'
- en: 'Figure 2.8: The virtual device turned to landscape orientation'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：虚拟设备转为横向方向
- en: Can you spot what has happened? The `Last Name` field value is no longer set.
    It has been lost in the process of recreating the activity. Why is this? Well,
    in the case of the `EditText` fields, the Android framework will preserve the
    state of the fields if they have an ID set on them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您能发现发生了什么吗？`Last Name`字段的值不再设置。它在重新创建活动的过程中丢失了。为什么呢？嗯，在`EditText`字段的情况下，如果它们有一个ID设置，Android框架将保留字段的状态。
- en: 'Go back to the `activity_main.xml` layout file and add an ID for the `Last
    Name` value in the `EditText` field:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`activity_main.xml`布局文件，并为`EditText`字段中的`Last Name`值添加一个ID：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When you run up the app again and rotate the device, it will preserve the value
    you have entered. You've now seen that you need to set an ID on the `EditText`
    fields to preserve the state. For the `EditText` fields, it's common to retain
    the state on a configuration change when the user is entering details into a form
    so that it is the default behavior if the field has an ID. Obviously, you want
    to get the details of the `EditText` field once the user has entered some text,
    which is why you set an ID, but setting an ID for other field types, such as `TextView`,
    does not retain the state if you update them and you need to save the state yourself.
    Setting IDs for Views that enable scrolling, such as `RecyclerView`, is also important
    as it enables the scroll position to be maintained when the Activity is recreated.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当您再次运行应用程序并旋转设备时，它将保留您输入的值。您现在已经看到，您需要在`EditText`字段上设置一个ID来保留状态。对于`EditText`字段，当用户输入表单中的详细信息时，保留状态是常见的，因此如果字段有一个ID，它就是默认行为。显然，您希望在用户输入一些文本后获取`EditText`字段的详细信息，这就是为什么要设置一个ID，但是为其他字段类型，例如`TextView`，设置ID不会保留状态，如果您更新它们，您需要自己保存状态。为启用滚动的视图设置ID，例如`RecyclerView`，也很重要，因为它可以在重新创建Activity时保持滚动位置。
- en: Now, you have defined the layout for the screen, but you have not added any
    logic for creating and displaying the discount code. In the next exercise, we
    will work through this.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经为屏幕定义了布局，但尚未添加任何逻辑来创建和显示折扣代码。在下一个练习中，我们将解决这个问题。
- en: The layout created in this exercise is available at [http://packt.live/35RSdgz](http://packt.live/35RSdgz
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习中创建的布局可在[http://packt.live/35RSdgz](http://packt.live/35RSdgz)找到
- en: )
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: You can find the code for the entire exercise at [http://packt.live/3p1AZF3](http://packt.live/3p1AZF3)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://packt.live/3p1AZF3](http://packt.live/3p1AZF3)找到整个练习的代码
- en: 'Exercise 2.03: Saving and Restoring the State with Callbacks'
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.03：使用回调保存和恢复状态
- en: 'The aim of this exercise is to bring all the UI elements in the layout together
    to generate a discount code after the user has entered their data. In order to
    do this, you will have to add logic to the button to retrieve all the `EditText`
    fields and then display a confirmation to the user, as well as generate a discount
    code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是将布局中的所有UI元素组合在一起，在用户输入数据后生成折扣码。为了做到这一点，您将不得不添加逻辑到按钮中，以检索所有`EditText`字段，然后向用户显示确认信息，并生成一个折扣码：
- en: 'Open up `MainActivity.kt` and replace the default empty Activity from the project
    creation. A snippet of the code is shown here, but you''ll need to use the link
    given below to find the full code block you need to add:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.kt`并替换项目创建时的默认空Activity。这里显示了代码片段，但您需要使用下面给出的链接找到需要添加的完整代码块：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `get() = …` is a custom accessor for a property.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`get() = …`是属性的自定义访问器。'
- en: 'Upon clicking the discount button, you retrieve the values from the `first_name`
    and `last_name` fields, concatenate them with a space, and then use a string resource
    to format the discount code confirmation text. The string you reference in the
    `strings.xml` file is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 单击折扣按钮后，您将从`first_name`和`last_name`字段中检索值，将它们与一个空格连接，然后使用字符串资源格式化折扣码确认文本。您在`strings.xml`文件中引用的字符串如下：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `%s` value specifies a string value to be replaced when the string resource
    is retrieved. This is done by passing in the full name when getting the string:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`％s`值指定在检索字符串资源时要替换的字符串值。通过在获取字符串时传入全名来完成此操作：'
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code is generated by using the UUID (Universally Unique Identifier) library
    from the `java.util` package. This creates a unique id, and then the `take()`
    Kotlin function is used to get the first eight characters before setting these
    to uppercase. Finally, discount_code is set in the view, the keyboard is hidden,
    and all the form fields are set back to their initial values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码是使用`java.util`包中的UUID（通用唯一标识符）库生成的。这将创建一个唯一的ID，然后使用`take()` Kotlin函数来获取前八个字符并将其设置为大写。最后，在视图中设置discount_code，隐藏键盘，并将所有表单字段设置回初始值。
- en: 'Run the app and enter some text into the name and email fields, and then click
    on `GET DISCOUNT`:![Figure 2.9: Screen displayed after the user has generated
    a discount code'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并在名称和电子邮件字段中输入一些文本，然后单击`GET DISCOUNT`：![图2.9：用户生成折扣码后显示的屏幕
- en: '](img/B15216_02_09.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_09.jpg)'
- en: 'Figure 2.9: Screen displayed after the user has generated a discount code'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：用户生成折扣码后显示的屏幕
- en: The app behaves as expected, showing the confirmation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序表现如预期，显示确认信息。
- en: 'Now, rotate the phone (pressing the fifth button down with the arrow on the
    right-hand side of the virtual device picture) and observe the result:![Figure
    2.10: Discount code no longer displaying on the screen'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，旋转手机（按下虚拟设备图片右侧带箭头的第五个按钮）并观察结果：![图2.10：折扣码不再显示在屏幕上
- en: '](img/B15216_02_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_10.jpg)'
- en: 'Figure 2.10: Discount code no longer displaying on the screen'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：折扣码不再显示在屏幕上
- en: Oh, no! The discount code has gone. The `TextView` fields do not retain the
    state, so you will have to save the state yourself.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，不！折扣码不见了。`TextView`字段不保留状态，因此您必须自己保存状态。
- en: 'Go back into `MainActivity.kt` and add the following Activity callbacks:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`MainActivity.kt`并添加以下Activity回调函数：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These callbacks, as the names declare, enable you to save and restore the instance
    state. `onSaveInstanceState(outState: Bundle)` allows you to add key-value pairs
    from your Activity when it is being backgrounded or destroyed, which you can retrieve
    in either `onCreate(savedInstanceState: Bundle?)` or `onRestoreInstanceState(savedInstanceState:
    Bundle)`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '这些回调函数，正如它们的名称所声明的那样，使您能够保存和恢复实例状态。`onSaveInstanceState(outState: Bundle)`允许您在Activity被置于后台或销毁时添加键值对，您可以在`onCreate(savedInstanceState:
    Bundle?)`或`onRestoreInstanceState(savedInstanceState: Bundle)`中检索这些键值对。'
- en: 'So, you have two callbacks to retrieve the state once it has been set. If you
    are doing a lot of initialization in `onCreate(savedInstanceState: Bundle)`, it
    might be better to use `onRestoreInstanceState(savedInstanceState: Bundle)` to
    retrieve this instance state when your Activity is being recreated. In this way,
    it''s clear which state is being recreated. However, you might prefer to use `onCreate(savedInstanceState:
    Bundle)` if there is minimal setup required.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '所以，一旦状态被设置，您有两个回调函数来检索状态。如果您在`onCreate(savedInstanceState: Bundle)`中进行了大量初始化，最好使用`onRestoreInstanceState(savedInstanceState:
    Bundle)`来在Activity被重新创建时检索此实例状态。这样，清楚地知道正在重新创建哪个状态。但是，如果只需要进行最小的设置，您可能更喜欢使用`onCreate(savedInstanceState:
    Bundle)`。'
- en: 'Whichever of the two callbacks you decide to use, you will have to get the
    state you set in the `onSaveInstanceState(outState: Bundle)` call. For the next
    step in the exercise, you will use `onRestoreInstanceState(savedInstanceState:
    Bundle)`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '无论您决定使用这两个回调函数中的哪一个，您都必须获取在`onSaveInstanceState(outState: Bundle)`调用中设置的状态。在练习的下一步中，您将使用`onRestoreInstanceState(savedInstanceState:
    Bundle)`。'
- en: 'Add two constants to the `MainActivity` companion object:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`伴生对象中添加两个常量：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, add these constants as keys for the values you want to save and retrieve
    by making the following additions to the Activity:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过向Activity添加以下内容，将这些常量作为键添加到要保存和检索的值中：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the app, enter the values into the `EditText` fields, and then generate
    a discount code. Then, rotate the device and you will see that the discount code
    is restored in *Figure 2.11*:![Figure 2.11: Discount code continues to be displayed
    on the screen'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，输入值到`EditText`字段中，然后生成折扣代码。然后，旋转设备，您将看到折扣代码在*图2.11*中得到恢复：![图2.11：折扣代码继续显示在屏幕上
- en: '](img/B15216_02_11.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_11.jpg)'
- en: 'Figure 2.11: Discount code continues to be displayed on the screen'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：折扣代码继续显示在屏幕上
- en: 'In this exercise, you first saw how the state of the `EditText` fields is maintained
    on configuration changes. You also saved and restored the instance state using
    the Activity lifecycle `onSaveInstanceState(outState: Bundle)` and `onCreate(savedInstanceState:
    Bundle?)`/`onRestoreInstanceState(savedInstanceState: Bundle)` functions. These
    functions provide a way to save and restore simple data. The Android framework
    also provides `ViewModel`, an Android architecture component that is lifecycle-aware.
    The mechanisms of how to save and restore this state (with `ViewModel`) are managed
    by the framework, so you don''t have to explicitly manage it as you have done
    in the preceding example. You will learn how to use this component in *Chapter
    10*, *Android Architecture Components*.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个练习中，您首先看到了`EditText`字段的状态如何在配置更改时保持不变。您还使用了Activity生命周期`onSaveInstanceState(outState:
    Bundle)`和`onCreate(savedInstanceState: Bundle?)`/`onRestoreInstanceState(savedInstanceState:
    Bundle)`函数保存和恢复了实例状态。这些函数提供了一种保存和恢复简单数据的方法。Android框架还提供了`ViewModel`，这是一个生命周期感知的Android架构组件。如何保存和恢复此状态（使用`ViewModel`）的机制由框架管理，因此您不必像在前面的示例中那样显式管理它。您将在*第10章*，*Android架构组件*中学习如何使用此组件。'
- en: So far, you have created a single-screen app. Although it is possible for simple
    apps to use one Activity, it is likely that you will want to organize your app
    into different activities that handle different functions. So, in the next section,
    you will add another Activity to an app and navigate between the activities.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经创建了一个单屏应用程序。虽然简单的应用程序可以使用一个Activity，但您可能希望将应用程序组织成处理不同功能的不同活动。因此，在下一节中，您将向应用程序添加另一个Activity，并在活动之间导航。
- en: Activity Interaction with Intents
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与意图交互的活动
- en: 'An intent in Android is a communication mechanism between components. Within
    your own app, a lot of the time, you will want another specific Activity to start
    when some action happens in the current activity. Specifying exactly which Activity
    will start is called an `AndroidManifest.xml` file and you will see an example
    of two intent filters set within the `<intent-filter>` XML element:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，意图是组件之间的通信机制。在您自己的应用程序中，很多时候，您希望在当前活动中发生某些操作时启动另一个特定的Activity。指定将启动哪个Activity称为`AndroidManifest.xml`文件，并且您将看到在`<intent-filter>`
    XML元素内设置了两个意图过滤器的示例：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The one specified with `<action android:name="android.intent.action.MAIN" />`
    means that this is the main entry point into the app. Depending on which category
    is set, it governs which Activity first starts when the app is started. The other
    intent filter that is specified is `<category android:name="android.intent.category.LAUNCHER"
    />`, which defines that the app should appear in the launcher. When combined,
    the two intent filters define that when the app is started from the launcher,
    `MainActivity` should be started. Removing any one of these intent filters results
    in the `"Error running ''app'': Default Activity not found"` message. As the app
    has not got a main entry point, it can''t be launched, which is what also happens
    when you remove `<action android:name="android.intent.action.MAIN". />`. If you
    remove `<category android:name="android.intent.category.LAUNCHER" />` and don''t
    specify a category, then there is nowhere that it can be launched from.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '使用`<action android:name="android.intent.action.MAIN" />`指定的意图表示这是应用程序的主入口点。根据设置的类别，它决定了应用程序启动时首先启动的Activity。另一个指定的意图过滤器是`<category
    android:name="android.intent.category.LAUNCHER" />`，它定义了应用程序应该出现在启动器中。当结合在一起时，这两个意图过滤器定义了从启动器启动应用程序时应启动`MainActivity`。删除任何一个这些意图过滤器都会导致`"Error
    running ''app'': Default Activity not found"`的消息。由于应用程序没有主入口点，因此无法启动，这也是当您删除`<action
    android:name="android.intent.action.MAIN". />`时发生的情况。如果删除`<category android:name="android.intent.category.LAUNCHER"
    />`并且不指定类别，则无法从任何地方启动它。'
- en: For the next exercise, you will see how intents work to navigate around your
    app.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将了解意图如何在应用程序中导航。
- en: 'Exercise 2.04: An Introduction to Intents'
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.04：意图简介
- en: 'The goal of this exercise is to create a simple app that uses intents to display
    text to the user based on their input. Create a new project in Android Studio
    and select an empty Activity. Once you have set up the project, go to the toolbar
    and select `File` | `New` | `Activity` | `Empty` `Activity`. Call it `WelcomeActivity`
    and leave all the other defaults as they are. It will be added to the `AndroidManifest.xml`
    file, ready to use. The issue you have now that you''ve added `WelcomeActivity`
    is how do you do anything with it? `MainActivity` starts when you launch the app,
    but you need a way to launch `WelcomeActivity` and then, optionally, pass data
    to it, which is when you use intents:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是创建一个简单的应用程序，使用意图根据用户的输入向用户显示文本。在Android Studio中创建一个新项目，并选择一个空的Activity。设置好项目后，转到工具栏，选择`File`
    | `New` | `Activity` | `Empty` `Activity`。将其命名为`WelcomeActivity`，并将所有其他默认设置保留不变。它将被添加到`AndroidManifest.xml`文件中，准备使用。现在您添加了`WelcomeActivity`后的问题是如何处理它？`MainActivity`在启动应用程序时启动，但您需要一种方法来启动`WelcomeActivity`，然后，可选地，向其传递数据，这就是使用意图的时候：
- en: 'In order to work through this example, add the following code to the `strings.xml`
    file. These are the strings you''ll be using in the app:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通过这个示例，将以下代码添加到`strings.xml`文件中。这些是您将在应用程序中使用的字符串：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, update the styles in the `themes.xml` file adding the header style.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`themes.xml`文件中更新样式，添加标题样式。
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, add the `fullname`, `button`, and `page` styles:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加`fullname`，`button`和`page`样式：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Normally, you wouldn't specify dimensions directly in the styles themselves.
    They should be referenced as `dimens` values so that they can be updated in one
    place, are more uniform, and can be labeled to represent what the dimension actually
    is. This is not done here for simplicity.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不会直接在样式中指定尺寸。它们应该被引用为`dimens`值，这样它们可以在一个地方更新，更加统一，并且可以被标记为代表实际尺寸是什么。出于简单起见，这里没有这样做。
- en: 'Next, change the `MainActivity` layout in `activity_main.xml` and add a `TextView`
    header:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`activity_main.xml`中更改`MainActivity`布局并添加一个`TextView`标题：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This should be the first View displayed, and as it''s constrained using `ConstraintLayout`
    to the top of its parent, it displays at the top of the screen. As it''s also
    constrained to both the start and end of its parent, it will be displayed in the
    middle when you run the app, as shown in *Figure 2.12*:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是显示的第一个视图，并且由于它使用`ConstraintLayout`约束到其父级的顶部，它显示在屏幕顶部。由于它还被约束到其父级的开始和结束，当您运行应用程序时，它将显示在中间，如*图2.12*所示：
- en: '![Figure 2.12: Initial app display after adding the TextView header'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.12：在添加TextView标题后的初始应用显示'
- en: '](img/B15216_02_12.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_12.jpg)'
- en: 'Figure 2.12: Initial app display after adding the TextView header'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：在添加TextView标题后的初始应用显示
- en: 'Now, add an `EditText` field for the full name and a `Button` field for the
    submit button in the `activity_main.xml` file below the `TextView` header:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`activity_main.xml`文件中，在`TextView`标题下方添加一个用于全名的`EditText`字段和一个用于提交按钮的`Button`字段：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The app, when run, looks as in *Figure 2.13*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时，显示如*图2.13*所示：
- en: '![Figure 2.13: The app display after adding the EditText full name field and
    submit button'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13：在添加EditText全名字段和提交按钮后的应用显示'
- en: '](img/B15216_02_13.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_13.jpg)'
- en: 'Figure 2.13: The app display after adding the EditText full name field and
    submit button'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：在添加EditText全名字段和提交按钮后的应用显示
- en: You now need to configure the button so that when it's clicked, it retrieves
    the user's full name from the `EditText` field and then sends it in an intent,
    which starts `WelcomeActivity`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要配置按钮，以便当点击按钮时，它从`EditText`字段中检索用户的全名，然后将其发送到启动`WelcomeActivity`的意图中。
- en: 'Update the `activity_welcome.xml` layout file to prepare to do this:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`activity_welcome.xml`布局文件以准备进行此操作：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You are adding a `TextView` field to display the full name of the user with
    a welcome message. The logic to create the full name and welcome message will
    be shown in the next step.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在添加一个`TextView`字段来显示用户的全名和欢迎消息。创建全名和欢迎消息的逻辑将在下一步中显示。
- en: 'Now, open `MainActivity` and add a constant value above the class header and
    also update the imports:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`MainActivity`并在类头部添加一个常量值，并更新导入：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You will use the constant to set the key to hold the full name of the user by
    setting it in the intent.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用常量来设置保存用户全名的键，通过在意图中设置它。
- en: 'Then, add the following code to the bottom of `onCreate(savedInstanceState:
    Bundle?)`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，在`onCreate(savedInstanceState: Bundle?)`的底部添加以下代码：'
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There is logic to retrieve the value of the full name and verify that the user
    has filled this in; otherwise, a pop-up toast message will be shown if it is blank.
    The main logic, however, takes the `fullName` value of the `EditText` field and
    creates an explicit intent to start `WelcomeActivity`. The `also` scope function
    allows you to carry on using the intent you've just created, `Intent(this, WelcomeActivity::class.java)`,
    and further operate on it by using something called a `it` but here for clarity
    we've called it `welcomeIntent`. Then, you use the lambda argument in the `welcomeIntent.putExtra(FULL_NAME_KEY,
    fullName)` line to add the `fullName` field, using `FULL_NAME_KEY` as the key
    and `fullName` as the value to the extras that the intent holds.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有逻辑来检索全名的值并验证用户是否已填写；否则，如果为空，将显示一个弹出式提示消息。然而，主要逻辑是获取`EditText`字段的`fullName`值，并创建一个显式意图来启动`WelcomeActivity`。`also`作用域函数允许您继续使用您刚刚创建的意图`Intent(this,
    WelcomeActivity::class.java)`，并进一步操作它，使用一个叫做`it`的东西，但为了清晰起见，我们将其称为`welcomeIntent`。然后，您可以在`welcomeIntent.putExtra(FULL_NAME_KEY,
    fullName)`行中使用lambda参数来向意图添加`fullName`字段，使用`FULL_NAME_KEY`作为键，`fullName`作为意图持有的额外值。
- en: Then, you use the intent to start `WelcomeActivity`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您使用意图启动`WelcomeActivity`。
- en: 'Now, run the app, enter your name, and press `SUBMIT`, as shown in *Figure
    2.14*:![Figure 2.14: The default screen displayed when the intent extras data
    is not processed'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行应用程序，输入您的姓名，然后按`提交`，如*图2.14*所示：![图2.14：当意图额外数据未被处理时显示的默认屏幕
- en: '](img/B15216_02_14.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_14.jpg)'
- en: 'Figure 2.14: The default screen displayed when the intent extras data is not
    processed'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：当意图额外数据未被处理时显示的默认屏幕
- en: Well, that's not very impressive. You've added the logic to send the user's
    name, but not to display it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这并不是很令人印象深刻。您已经添加了发送用户姓名的逻辑，但没有显示它。
- en: 'To enable this, please open `WelcomeActivity` and add the following to the
    bottom of the `onCreate(savedInstanceState: Bundle?)` callback:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '要实现这一点，请打开`WelcomeActivity`并在`onCreate(savedInstanceState: Bundle?)`回调的底部添加以下内容：'
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We reference the intent that started the Activity with `intent?.let{} which`
    specifies that the `let` block will be run if the intent is not null, and `let`
    is a scope function in which you can reference the context object with a default
    lambda argument of `it`. This means you don't have to assign a variable before
    you can use it. You reference the intent with `it` and then retrieve the string
    value that was passed from the `MainActivity` intent by getting the string `FULL_NAME_KEY`
    extra key. You then format the `<string name="welcome_text">Hello %s, we hope
    you enjoy using the app!</string>` resource string by getting the string from
    the resources and passing in the `fullname` value retrieved from the intent. Finally,
    this is set as the text of `TextView`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`intent?.let{}`引用启动Activity的意图，指定如果意图不为空，则将运行`let`块，`let`是一个作用域函数，您可以在其中使用默认的lambda参数`it`引用上下文对象。这意味着您不必在使用之前分配变量。您使用`it`引用意图，然后通过获取`FULL_NAME_KEY`额外键从`MainActivity`意图中传递的字符串值。然后，通过从资源中获取字符串并传入从意图中检索的`fullname`值来格式化`<string
    name="welcome_text">Hello %s, we hope you enjoy using the app!</string>`资源字符串。最后，将其设置为`TextView`的文本。
- en: 'Run the app again, and a simple greeting will be displayed, as in *Figure 2.15*:![Figure
    2.15: User welcome message displayed'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行应用程序，将显示一个简单的问候语，如*图2.15*所示：![图2.15：显示用户欢迎消息
- en: '](img/B15216_02_15.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_15.jpg)'
- en: 'Figure 2.15: User welcome message displayed'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：显示用户欢迎消息
- en: This exercise, although very simple in terms of layouts and user interaction,
    allows the demonstration of some core principles of intents. You will use them
    to add navigation and create user flows from one section of your app to another.
    In the next section, you will see how you can use intents to launch an Activity
    and receive a result back from it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个练习在布局和用户交互方面非常简单，但它可以演示意图的一些核心原则。您将使用它们来添加导航，并从应用程序的一个部分创建用户流程到另一个部分。在下一节中，您将看到如何使用意图来启动一个Activity，并从中接收结果。
- en: 'Exercise 2.05: Retrieving a Result from an Activity'
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.05：从Activity中检索结果
- en: 'For some user flows, you will only launch an Activity for the sole purpose
    of retrieving a result back from it. This pattern is often used to ask permission
    to use a particular feature, popping up a dialog with a question about whether
    the user gives their permission to access contacts, the calendar, and so on, and
    then reporting the result of yes or no back to the calling Activity. In this exercise,
    you will ask the user to pick their favorite color of the rainbow, and then once
    that is chosen, display the result in the calling activity:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些用户流程，您只会启动一个Activity，目的是从中检索结果。这种模式通常用于请求使用特定功能的权限，弹出一个带有关于用户是否同意访问联系人、日历等的问题的对话框，然后将结果报告给调用Activity。在这个练习中，您将要求用户选择他们喜欢的彩虹颜色，然后一旦选择了，就在调用Activity中显示结果：
- en: 'Create a new project named `Activity Results` and add the following strings
    to the `strings.xml` file:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Activity Results`的新项目，并将以下字符串添加到`strings.xml`文件中：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Add the following colors to colors.xml
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下颜色添加到colors.xml
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the relevant new styles to the `themes.xml` file. A snippet is shown below,
    but you''ll need to follow the link given to see all the code that you need to
    add:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相关的新样式添加到`themes.xml`文件。下面显示了一个片段，但您需要按照给定的链接查看您需要添加的所有代码：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Dimensions have not been added to `dimens.xml` for simplicity.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 出于简单起见，尚未将尺寸添加到`dimens.xml`中。
- en: Now, you have to set up the Activity that will set the result you receive in
    `MainActivity`. Go to `File` | `New` | `Activity` | `EmptyActivity` and create
    an Activity called `RainbowColorPickerActivity`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您必须设置将在`MainActivity`中接收的结果的Activity。转到`文件` | `新建` | `Activity` | `EmptyActivity`，创建一个名为`RainbowColorPickerActivity`的Activity。
- en: 'Update the `activity_main.xml` layout file to display a header, a button, and
    then a hidden `android:visibility="gone"` View, which will be made visible and
    set with the user''s favorite color of the rainbow when the result is reported:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`activity_main.xml`布局文件以显示标题、按钮，然后是隐藏的`android:visibility="gone"`视图，当报告结果时将其设置为可见并设置为用户喜欢的彩虹颜色：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You''ll be using the `startActivityForResult(Intent intent, int requestCode)`
    function to get a result back from the Activity you launch. In order to ensure
    that the result you get back is from the operation you expected, you have to set
    `requestCode`. Add this constant for the request code, and two others to set keys
    for the values we want to use in the intent, as well as a default color above
    the class header in MainActivity so it is displayed as follows with the package
    name and imports:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将使用`startActivityForResult(Intent intent, int requestCode)`函数从您启动的Activity中获取结果。为了确保您收到的结果是您期望的操作，您必须设置`requestCode`。添加此请求代码的常量，以及另外两个用于在意图中使用的值的键，以及在MainActivity类头部上方设置一个默认颜色，以便显示如下所示，带有包名和导入：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, at the bottom of `onCreate(savedInstanceState: Bundle?)` in `MainActivity`
    add the following:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，在`MainActivity`的`onCreate(savedInstanceState: Bundle?)`底部添加以下内容：'
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This uses the syntax you used previously with `also` to create an intent and
    use it with a named lambda parameter of the context object. In this case, you
    are using `rainbowColorPickerIntent` to refer to the intent you just created with
    `Intent(this, RainbowColorPickerActivity::class.java)`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了您之前使用`also`的语法来创建一个意图，并使用具有上下文对象的命名lambda参数。在这种情况下，您使用`rainbowColorPickerIntent`来引用您刚刚使用`Intent(this,
    RainbowColorPickerActivity::class.java)`创建的意图。
- en: 'The key call is `startActivityForResult(rainbowColorPickerIntent, PICK_RAINBOW_COLOR_INTENT)`,
    which launches `RainbowColorPickerActivity` with a request code. So, when do we
    get this result back? You receive the result when it is set by overriding `onActivityResult(requestCode:
    Int, resultCode: Int, data: Intent?)`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '关键调用是`startActivityForResult(rainbowColorPickerIntent, PICK_RAINBOW_COLOR_INTENT)`，它使用请求代码启动`RainbowColorPickerActivity`。那么我们什么时候收到这个结果呢？当它被设置时，您将通过覆盖`onActivityResult(requestCode:
    Int, resultCode: Int, data: Intent?)`来接收结果。'
- en: This call specifies the request code, which you can check to confirm that it
    is the same as the request code you sent. `resultCode` reports the status of the
    operation. You can set your own code, but it is usually set to `Activity.RESULT_OK`
    or `Activity.RESULT_CANCELED`, and the last parameter, `data`, is the intent that
    has been set by the activity started for the result, RainbowColorPickerActivity.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用指定了请求代码，您可以检查以确认它与您发送的请求代码相同。`resultCode`报告操作的状态。您可以设置自己的代码，但通常设置为`Activity.RESULT_OK`或`Activity.RESULT_CANCELED`，最后一个参数`data`是由为结果启动的活动设置的意图，RainbowColorPickerActivity。
- en: 'Add the following to `onActivityResult(requestCode: Int, resultCode: Int, data:
    Intent?)` callback in `MainActivity`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`MainActivity`的`onActivityResult(requestCode: Int, resultCode: Int, data:
    Intent?)`回调中添加以下内容：'
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So, you check that the request code and response code values are what is expected,
    and then proceed to query the intent data for the values you are expecting. For
    this exercise, you want to get the background color name (`colorName`) and the
    hexadecimal value of the color (`backgroundColor`) so that we can display it.
    The `?` operator checks whether the value is null (that is, not set in the intent),
    and if so, the Elvis operator (`?:`) sets the default value. The color message
    uses String formatting to set a message replacing the placeholder in the resource
    value with the color name. Now that you've got the colors, you can make the `rainbow_color`
    `TextView` field visible and set the background color of the View to `backgroundColor`
    and add text displaying the name of the user's favorite color of the rainbow.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，您要检查请求代码和响应代码的值是否符合预期，然后继续查询意图数据以获取您期望的值。对于此练习，您希望获取背景颜色名称（`colorName`）和颜色的十六进制值（`backgroundColor`），以便我们可以显示它。`?`运算符检查值是否为null（即未在意图中设置），如果是，则Elvis运算符（`?:`）设置默认值。颜色消息使用字符串格式设置消息，用颜色名称替换资源值中的占位符。现在您已经获得了颜色，可以使`rainbow_color`
    `TextView`字段可见，并将视图的背景颜色设置为`backgroundColor`，并添加显示用户最喜欢的彩虹颜色名称的文本。
- en: 'For the layout of the `RainbowColorPickerActivity` activity, you are going
    to display a button with a background color and color name for each of the seven
    colors of the rainbow: `RED`, `ORANGE`, `YELLOW`, `GREEN`, `BLUE`, `INDIGO`, and
    `VIOLET`. These will be displayed in a `LinearLayout` vertical list. For most
    of the layout files in the course, you will be using `ConstrainLayout`, as it
    provides fine-grained positioning of individual Views. For situations where you
    need to display a vertical or horizontal list of a small number of items, `LinearLayout`
    is also a good choice. If you need to display a large number of items, then `RecyclerView`
    is a better option as it can cache layouts for individual rows and recycle views
    that are no longer displayed on the screen. You will learn about `RecyclerView`
    in *Chapter 5*, *RecyclerView*.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`RainbowColorPickerActivity`活动的布局，您将显示一个按钮，每个按钮都有彩虹的七种颜色的背景颜色和颜色名称：`RED`，`ORANGE`，`YELLOW`，`GREEN`，`BLUE`，`INDIGO`和`VIOLET`。这些将显示在`LinearLayout`垂直列表中。在课程中的大多数布局文件中，您将使用`ConstrainLayout`，因为它提供了对单个视图的精细定位。对于需要显示少量项目的垂直或水平列表的情况，`LinearLayout`也是一个不错的选择。如果需要显示大量项目，则`RecyclerView`是更好的选择，因为它可以缓存单行的布局并回收不再显示在屏幕上的视图。您将在*第5章*，*RecyclerView*中了解有关`RecyclerView`的信息。
- en: The first thing you need to do in `RainbowColorPickerActivity` is create the
    layout. This will be where you present the user with the option to choose their
    favorite color of the rainbow.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RainbowColorPickerActivity`中，您需要做的第一件事是创建布局。这将是您向用户提供选择其最喜欢的彩虹颜色的选项的地方。
- en: 'Open `activity_rainbow_color_picker.xml` and replace the layout, inserting
    the following:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_rainbow_color_picker.xml`并替换布局，插入以下内容：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We are adding `ScrollView` to allow the contents to scroll if the screen height
    cannot display all of the items. `ScrollView` can only take one child View, which
    is the layout to scroll.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在添加`ScrollView`以允许内容在屏幕高度无法显示所有项目时滚动。`ScrollView`只能接受一个子视图，即要滚动的布局。
- en: 'Next, add `LinearLayout` within `ScrollView` to display the contained views
    in the order that they are added with a header and a footer. The first child View
    is a header with the title of the page and the last View that is added is a footer
    with instructions to the user to pick their favorite color:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`ScrollView`中添加`LinearLayout`以按添加顺序显示包含的视图，并添加一个标题和页脚。第一个子视图是一个带有页面标题的标题，最后添加的视图是一个带有指示用户选择其最喜欢的颜色的说明的页脚：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The layout should now look as in *Figure 2.16* in the app:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的布局现在应如*图2.16*所示：
- en: '![Figure 2.16: Rainbow colors screen with a header and footer'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.16：带有标题和页脚的彩虹颜色屏幕'
- en: '](img/B15216_02_16.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_16.jpg)'
- en: 'Figure 2.16: Rainbow colors screen with a header and footer'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：带有标题和页脚的彩虹颜色屏幕
- en: 'Now, finally, add the button views between the header and the footer to select
    a color of the rainbow, and then run the app:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，最后，在标题和页脚之间添加按钮视图以选择彩虹的颜色，然后运行应用程序：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The preceding layout created is available at the following link: [http://packt.live/2M7okBX](http://packt.live/2M7okBX)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 前面创建的布局可在以下链接找到：[http://packt.live/2M7okBX](http://packt.live/2M7okBX)
- en: These Views are buttons that are displayed in the order of the colors of the
    rainbow. Although there is a button label for the color and the background color,
    which is filled in with the appropriate color, the most important XML attribute
    is `id`. This is what you will use in the Activity to prepare the result of what
    is returned to the calling activity.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些视图是按照彩虹颜色的顺序显示的按钮。尽管按钮标签是颜色和背景颜色，但最重要的XML属性是`id`。这是您将在Activity中使用的内容，以准备返回给调用活动的结果。
- en: 'Now, open `RainbowColorPickerActivity` and replace the content with the following:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`RainbowColorPickerActivity`并用以下内容替换内容：
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is the function that creates an intent and puts the relevant String extras
    holding the rainbow color name and the rainbow color `hex` value. The result is
    then returned to the calling Activity, and as you have no further use of this
    Activity, you call `finish()` so that the calling Activity is displayed. The way
    that you retrieve the rainbow color that the user has chosen is done by adding
    a listener for all the buttons in the layout.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建意图并放置相关的字符串额外信息的函数，其中包含彩虹颜色名称和彩虹颜色`hex`值。然后将结果返回给调用的Activity，由于你不再需要这个Activity，所以调用`finish()`以显示调用的Activity。你通过为布局中的所有按钮添加监听器来检索用户选择的彩虹颜色。
- en: 'Now, add the following to the bottom of `onCreate(savedInstanceState: Bundle?)`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，在`onCreate(savedInstanceState: Bundle?)`的底部添加以下内容：'
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `colorPickerClickListener` click listener added in the preceding code determines
    which colors to set for the `setRainbowColor(colorName: String, color: Int)` function
    by using a `when` statement. The `when` statement is the equivalent of the `switch`
    statement in Java and languages based on C. It allows multiple conditions to be
    satisfied with one branch and is more concise. In the preceding example, `view.id`
    is matched against the IDs of the rainbow layout buttons and when found, executes
    the branch, setting the color name and hex value from the string resources to
    pass into `setRainbowColor(colorName: String, color: Int)`.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中添加的`colorPickerClickListener`点击监听器确定了要为`setRainbowColor(colorName: String,
    color: Int)`函数设置哪些颜色，它使用了`when`语句。`when`语句相当于Java和基于C的语言中的`switch`语句。它允许满足多个条件并执行一个分支，并且更加简洁。在前面的例子中，`view.id`与彩虹布局按钮的ID匹配，找到后执行该分支，将颜色名称和十六进制值从字符串资源传递到`setRainbowColor(colorName:
    String, color: Int)`中。'
- en: 'Now, add this click listener to the buttons from the layout:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将此点击监听器添加到布局中的按钮：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Every button has a `ClickListener` interface attached, and as the operation
    is the same, they have the same `ClickListener` interface attached. Then, when
    the button is pressed, it sets the result of the color that the user has chosen
    and returns it to the calling activity.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮都附加了一个`ClickListener`接口，由于操作相同，它们都附加了相同的`ClickListener`接口。然后，当按钮被按下时，它设置用户选择的颜色的结果并将其返回给调用的Activity。
- en: 'Now, run the app and press the `CHOOSE COLOR` button, as shown in *Figure 2.17*:![Figure
    2.17: The rainbow colors app start screen'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序并按下“选择颜色”按钮，如*图2.17*所示：![图2.17：彩虹颜色应用程序启动屏幕
- en: '](img/B15216_02_17.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_17.jpg)'
- en: 'Figure 2.17: The rainbow colors app start screen'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：彩虹颜色应用程序启动屏幕
- en: 'Now, select your favorite color of the rainbow:![Figure 2.18: The rainbow colors
    selection screen'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择你彩虹中最喜欢的颜色：![图2.18：彩虹颜色选择屏幕
- en: '](img/B15216_02_18.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_18.jpg)'
- en: 'Figure 2.18: The rainbow colors selection screen'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18：彩虹颜色选择屏幕
- en: 'Once you''ve chosen your favorite color, a screen with your favorite color
    will be displayed, as shown in *Figure 2.19*:![Figure 2.19: The app displaying
    the selected color'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你选择了你最喜欢的颜色，屏幕上会显示你最喜欢的颜色，如*图2.19*所示：![图2.19：应用程序显示所选颜色
- en: '](img/B15216_02_19.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_19.jpg)'
- en: 'Figure 2.19: The app displaying the selected color'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：应用程序显示所选颜色
- en: As you can see, the app displays the color that you've selected as your favorite
    color in *Figure 2.19*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，应用程序显示了你选择的最喜欢的颜色，如*图2.19*所示。
- en: This exercise introduced you to another way of creating user flows using `startActivityForResult`.
    This can be very useful for carrying out a dedicated Task where you need a result
    before proceeding with the user's flow through the app. Next, you will explore
    launch modes and how they impact the flow of user journeys when building apps.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习向你介绍了使用`startActivityForResult`创建用户流程的另一种方式。这对于执行需要在继续用户在应用程序中的流程之前获得结果的专用任务非常有用。接下来，你将探索启动模式以及它们在构建应用程序时如何影响用户旅程的流程。
- en: Intents, Tasks, and Launch Modes
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 意图、任务和启动模式
- en: Up until now, you have been using the standard behavior for creating Activities
    and moving from one Activity to the next. The flow you have been using is the
    default, and in most cases, this will be the one you choose to use. When you open
    the app from the launcher with the default behavior, it creates its own Task,
    and each Activity you create is added to a back stack, so when you open three
    Activities one after the other as part of your user's journey, pressing the back
    button three times will move the user back through the previous screens/Activities
    and then go back to the device's home screen, while still keeping the app open.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在使用创建Activity和从一个Activity到另一个Activity的标准行为。你一直使用的是默认的流程，在大多数情况下，这将是你选择使用的流程。当你使用默认行为从启动器打开应用程序时，它会创建自己的任务，并且你创建的每个Activity都会添加到后退堆栈中，因此当你连续打开三个Activity作为用户旅程的一部分时，按三次返回按钮将使用户返回到之前的屏幕/Activity，然后返回到设备的主屏幕，同时保持应用程序打开。
- en: The launch mode for this type of Activity is called `Standard`; it is the default
    and doesn't need specifying in the Activity element of `AndroidManifest.xml`.
    Even if you launch the same Activity three times, one after the other, there will
    be three instances of the same activity that exhibit the behavior described previously.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的Activity的启动模式称为“标准”；这是默认的，不需要在`AndroidManifest.xml`的Activity元素中指定。即使你连续三次启动相同的Activity，仍然会有三个展现之前描述行为的相同Activity的实例。
- en: For some apps, you may want to change this behavior. The scenario most commonly
    used that doesn't conform to this pattern is when you want to relaunch an Activity
    without creating a new separate instance. A common use case for this is when you
    have a home screen with a main menu and different news stories that the user can
    read. Once the user has gone through to an individual news story and then presses
    another news story title from the menu, when the user presses the back button,
    they will expect to return to the home screen and not the previous news story.
    The launch mode that can help here is called `singleTop`. If a `singleTop` Activity
    is at the top of the Task (*top*, in this context, means most recently added),
    when the same `singleTop` Activity is launched, then instead of creating a new
    Activity, it uses the same Activity and runs the `onNewIntent` callback. In the
    preceding scenario, this could then use the same activity to display a different
    news story. In this callback, you receive an intent, and you can then process
    this intent as you have done previously in `onCreate`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些应用程序，您可能希望更改此行为。最常用的不符合此模式的场景是当您想要重新启动活动而不创建新的单独实例时。这种情况的常见用例是当您有一个主菜单和用户可以阅读不同新闻故事的主屏幕。一旦用户浏览到单个新闻故事，然后从菜单中按下另一个新闻故事标题，当用户按下返回按钮时，他们将期望返回到主屏幕而不是以前的新闻故事。在这里可以帮助的启动模式称为`singleTop`。如果`singleTop`活动位于任务的顶部（在这种情况下，“顶部”表示最近添加的），则启动相同的`singleTop`活动时，它将使用相同的活动并运行`onNewIntent`回调，而不是创建新的活动。在上述情况中，这将使用相同的活动来显示不同的新闻故事。在此回调中，您将收到一个意图，然后可以像以前在`onCreate`中一样处理此意图。
- en: There are two other launch modes to be aware of, called `SingleTask` and `SingleInstance`.
    These are not for general use and are only used for special scenarios. For both
    of these launch modes, only one Activity of this type can exist in the application
    and it is always at the root of its Task. If you launch an Activity with this
    launch mode, it will create a new Task. If it already exists, then it will route
    the intent through the `onNewIntent` call and not create another instance. The
    only difference between `SingleTask` and `SingleInstance` is that `SingleInstance`
    is the one and only Activity of its Task. No new Activities can be launched into
    its Task. In contrast, `SingleTask` does allow other Activities to be launched
    into its Task, but the `SingleTask` Activity is always at the root.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种启动模式需要注意，称为`SingleTask`和`SingleInstance`。这些不是用于一般用途，只用于特殊情况。对于这两种启动模式，应用程序中只能存在一种此类型的活动，并且它始终位于其任务的根部。如果使用此启动模式启动活动，它将创建一个新任务。如果已经存在，则将通过`onNewIntent`调用路由意图，而不会创建另一个实例。`SingleTask`和`SingleInstance`之间的唯一区别是`SingleInstance`是其任务中唯一的活动。不能将新活动启动到其任务中。相反，`SingleTask`允许其他活动启动到其任务中，但`SingleTask`活动始终位于根部。
- en: 'These launch modes can be added to the XML of `AndroidManifest.xml` or created
    programmatically by adding intent flags. The most common ones used are the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些启动模式可以添加到`AndroidManifest.xml`的XML中，也可以通过添加意图标志以编程方式创建。最常用的是以下几种：
- en: '`FLAG_ACTIVITY_NEW_TASK`: Launches the Activity into a new Task.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLAG_ACTIVITY_NEW_TASK`：将活动启动到新任务中。'
- en: '`FLAG_ACTIVITY_CLEAR_TASK`: Clears the current Task, so finishes all Activities
    and launches the Activity at the root of the current Task.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLAG_ACTIVITY_CLEAR_TASK`：清除当前任务，因此完成所有活动并启动当前任务的根处的活动。'
- en: '`FLAG_ACTIVITY_SINGLE_TOP`: Replicates the launch mode of the `launchMode="singleTop"`
    XML.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLAG_ACTIVITY_SINGLE_TOP`：复制`launchMode="singleTop"` XML的启动模式。'
- en: '`FLAG_ACTIVITY_CLEAR_TOP`: Removes all Activities that are above any other
    instances of the same activity. If this is launched on a standard launch mode
    Activity, then it will clear the Task down to the first existing instance of the
    same Activity, and then launch another instance of the same Activity. This will
    probably not be what you want, and you can launch this flag with the `FLAG_ACTIVITY_SINGLE_TOP`
    flag to clear all the activities down to the same instance of the Activity you
    are launching and not create a new instance, but instead route a new intent to
    the existing Activity. To create an Activity using these two `intent` flags, you
    would do the following:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLAG_ACTIVITY_CLEAR_TOP`：删除所有高于同一活动的任何其他实例的活动。如果在标准启动模式活动上启动此活动，则它将清除任务，直到第一个现有实例的同一活动，并然后启动同一活动的另一个实例。这可能不是您想要的，您可以使用`FLAG_ACTIVITY_SINGLE_TOP`标志启动此标志，以清除所有活动，直到与您要启动的活动的相同实例，并且不创建新实例，而是将新意图路由到现有活动。要使用这两个`intent`标志创建活动，您需要执行以下操作：'
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If an intent launches an Activity with one or more of the intent flags specified
    in the preceding code block, then the launch mode specified overrides the one
    that is set in the `AndroidManifest.xml` file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果意图启动具有前面代码块中指定的一个或多个意图标志的活动，则指定的启动模式将覆盖在`AndroidManifest.xml`文件中设置的启动模式。
- en: Intent flags can be combined in multiple ways. For more information, see the
    official documentation at [https://developer.android.com/reference/android/content/Intent](https://developer.android.com/reference/android/content/Intent).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 意图标志可以以多种方式组合。有关更多信息，请参阅官方文档[https://developer.android.com/reference/android/content/Intent](https://developer.android.com/reference/android/content/Intent)。
- en: You'll explore the differences in the behavior of these two launch modes in
    the next exercise.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在下一个练习中探索这两种启动模式的行为差异。
- en: 'Exercise 2.06: Setting the Launch Mode of an Activity'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.06：设置活动的启动模式
- en: 'This exercise has many different layout files and Activities to illustrate
    the two most commonly used launch modes. Please download the code from [http://packt.live/2LFWo8t](http://packt.live/2LFWo8t)
    and then we will go through the exercise at [http://packt.live/2XUo3Vk](http://packt.live/2XUo3Vk):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习有许多不同的布局文件和活动，用来说明两种最常用的启动模式。请从[http://packt.live/2LFWo8t](http://packt.live/2LFWo8t)下载代码，然后我们将在[http://packt.live/2XUo3Vk](http://packt.live/2XUo3Vk)上进行练习：
- en: Open up the `activity_main.xml` file and examine it.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`文件并检查它。
- en: 'This illustrates a new concept when using layout files. If you have a layout
    file and you would like to include it in another layout, you can use the `<include>`
    XML element (have a look at the following snippet of the layout file):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了在使用布局文件时的一个新概念。如果您有一个布局文件，并且希望在另一个布局中包含它，您可以使用“<include>”XML元素（查看以下布局文件片段）。
- en: '[PRE52]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The preceding layout uses the `include` XML element to include the two layout
    files: `letters.xml` and `numbers.xml`.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的布局使用“include” XML元素来包含两个布局文件：“letters.xml”和“numbers.xml”。
- en: Open up and inspect the `letters.xml` and `numbers.xml` files found in the `res`
    | `layout` folder. These are very similar and are only differentiated from the
    buttons they contain by the ID of the buttons themselves and the text label they
    display.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开并检查“res” | “layout”文件夹中的“letters.xml”和“numbers.xml”文件。这些文件非常相似，只是通过按钮本身的ID和它们显示的文本标签来区分它们包含的按钮。
- en: 'Run the app and you will see the following screen:![Figure 2.20: App displaying
    both the standard and single top modes'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，您将看到以下屏幕：![图2.20：应用程序显示标准和single top模式
- en: '](img/B15216_02_20.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_20.jpg)'
- en: 'Figure 2.20: App displaying both the standard and single top modes'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20：应用程序显示标准和single top模式
- en: In order to demonstrate/illustrate the difference between `standard` and `singleTop`
    activity launch modes, you have to launch two or three activities one after the
    other.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示/说明“standard”和“singleTop”活动启动模式之间的区别，您必须连续启动两到三个活动。
- en: 'Open up `MainActivity` and examine the contents of the code block in `onCreate(savedInstanceState:
    Bundle?)` after the signature:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开“MainActivity”并检查签名后的“onCreate(savedInstanceState: Bundle?)”代码块的内容：'
- en: '[PRE53]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The logic contained in the main Activity and the other activities is basically
    the same. It displays an Activity and allows the user to press a button to launch
    another Activity using the same logic of creating a ClickListener and setting
    it on the button you saw in Exercise 2.05, *Retrieving a Result from an Activity*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 主要活动和其他活动中包含的逻辑基本相同。它显示一个活动，并允许用户按下按钮使用与在练习2.05中看到的相同的逻辑来启动另一个活动。
- en: 'Open the `AndroidManifest.xml` file and you will see the following:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“AndroidManifest.xml”文件，您将看到以下内容：
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You launch an Activity based on a button pressed on the main screen, but the
    letter and number activities have a different launch mode, which you can see specified
    in the `AndroidManifest.xml` file.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据主屏幕上按下的按钮启动一个活动，但字母和数字活动具有不同的启动模式，您可以在“AndroidManifest.xml”文件中看到指定的启动模式。
- en: The `standard` launch mode is specified here to illustrate the difference between
    `standard` and `singleTop`, but `standard` is the default and would be how the
    Activity is launched if the `android:launchMode` XML attribute was not present.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处指定了“standard”启动模式，以说明“standard”和“singleTop”之间的区别，但“standard”是默认值，如果“android:launchMode”
    XML属性不存在，则会启动Activity。
- en: 'Press one of the letters under the `Standard` heading and you will see the
    following screen (with `A` or letters `C` or `B`):![Figure 2.21: The app displaying
    standard activity'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下“Standard”标题下的字母之一，您将看到以下屏幕（带有“A”或字母“C”或“B”）：![图2.21：应用程序显示标准活动
- en: '](img/B15216_02_21.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_21.jpg)'
- en: 'Figure 2.21: The app displaying standard activity'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：应用程序显示标准活动
- en: 'Keep on pressing any of the letter buttons, which will launch another Activity.
    Logs have been added to show this sequence of launching activities. Here is the
    log after pressing 10 letter Activities randomly:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续按下任何字母按钮，这将启动另一个活动。已添加日志以显示启动活动的顺序。以下是随机按下10个字母活动后的日志：
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you observe the preceding log, every time the user presses a character button
    in launch mode, a new instance of the character Activity is launched and added
    to the back stack.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您观察前面的日志，每次用户按下启动模式中的字符按钮时，都会启动并添加一个新的字符Activity到返回堆栈中。
- en: 'Close the app, making sure it is not backgrounded (or in the recents/overview
    menu) but is actually closed, and then open the app again and press one of the
    number buttons under the `Single Top` heading:![Figure 2.22: The app displaying
    the Single Top activity'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭应用程序，确保它不在后台（或在最近/概述菜单中），而是实际关闭，然后再次打开应用程序，并按下“Single Top”标题下的数字按钮之一：![图2.22：应用程序显示Single
    Top活动
- en: '](img/B15216_02_22.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_22.jpg)'
- en: 'Figure 2.22: The app displaying the Single Top activity'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22：应用程序显示Single Top活动
- en: Press the number buttons 10 times, but make sure you press the same number button
    at least twice sequentially before pressing another number button.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下数字按钮10次，但确保在按下另一个数字按钮之前至少连续按下相同的数字按钮两次。
- en: 'The logs you should see in the `Logcat` window (`View` | `Tool Windows` | `Logcat`)
    should be similar to the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在“Logcat”窗口（“View” | “Tool Windows” | “Logcat”）中看到类似以下的日志：
- en: '[PRE56]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You'll notice that instead of calling `onCreate` when you pressed the same button
    again, the Activity is not created, but a call is made to `onNewIntent`. If you
    press the back button, you'll notice that it will take you less than 10 clicks
    to back out of the app and return to the home screen, reflecting the fact that
    10 activities have not been created.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，当您再次按下相同的按钮时，不会调用“onCreate”，而是调用“onNewIntent”。如果按下返回按钮，您会注意到返回到主屏幕只需要不到10次点击，反映出并未创建10个活动。
- en: 'Activity 2.01: Creating a Login Form'
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动2.01：创建登录表单
- en: 'The aim of this activity is to create a login form with username and password
    fields. Once the values in these fields are submitted, check these entered values
    against hardcoded values and display a welcome message if they match, or an error
    message if they don''t, and return the user to the login form. The steps needed
    to achieve this are the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的目的是创建一个带有用户名和密码字段的登录表单。一旦提交这些字段中的值，请检查这些输入的值与硬编码的值是否匹配，并在它们匹配时显示欢迎消息，或者在它们不匹配时显示错误消息，并将用户返回到登录表单。实现此目的所需的步骤如下：
- en: Create a form with username and password `EditText` Views and a `LOGIN` button.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有用户名和密码`EditText`视图和一个`LOGIN`按钮的表单。
- en: Add a `ClickListener` interface to the button to react to a button press event.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加一个`ClickListener`接口以对按钮按下事件做出反应。
- en: Validate that the form fields are filled in.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证表单字段是否已填写。
- en: Check the submitted username and password fields against the hardcoded values.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查提交的用户名和密码字段与硬编码的值是否匹配。
- en: Display a welcome message with the username if successful and hide the form.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成功，显示带有用户名的欢迎消息并隐藏表单。
- en: Display an error message if not successful and redirect the user back to the form.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不成功，显示错误消息并将用户重定向回表单。
- en: 'There are a few possible ways that you could go about trying to complete this
    activity. Here are three ideas for approaches you could adopt:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种可能的方法可以尝试完成这个活动。以下是您可以采用的三种方法的想法：
- en: Use a `singleTop` Activity and send an intent to route to the same Activity
    to validate the credentials.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`singleTop` Activity并发送意图到同一个Activity以验证凭据。
- en: Use a **standard** Activity to pass a username and password to another Activity
    and validate the credentials.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个**标准**Activity将用户名和密码传递到另一个Activity并验证凭据。
- en: Use `startActivityForResult` to carry out the validation in another Activity
    and then return the result.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`startActivityForResult`在另一个Activity中进行验证，然后返回结果。
- en: 'The completed app, upon its first loading, should look as in *Figure 2.23*:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的应用程序，在首次加载时，应该如*图2.23*所示：
- en: '![Figure 2.23: The app display when first loaded'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.23：首次加载时的应用程序显示'
- en: '](img/B15216_02_23.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_02_23.jpg)'
- en: 'Figure 2.23: The app display when first loaded'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23：首次加载时的应用程序显示
- en: Note
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在以下网址找到：http://packt.live/3sKj1cp
- en: The source code for all the exercises and the activity in this chapter is located
    at [http://packt.live/3o12sp4](http://packt.live/3o12sp4).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有练习和活动的源代码位于[http://packt.live/3o12sp4](http://packt.live/3o12sp4)。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have covered a lot of the groundwork of how your application
    interacts with the Android framework, from the Activity lifecycle callbacks to
    retaining the state in your activities, navigating from one screen to another,
    and how intents and launch modes make this happen. These are core concepts that
    you need to understand in order to move on to more advanced topics.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经涵盖了应用程序如何与Android框架交互的许多基础知识，从Activity生命周期回调到在活动中保留状态，从一个屏幕导航到另一个屏幕，以及意图和启动模式如何实现这一点。这些都是您需要了解的核心概念，以便进入更高级的主题。
- en: In the next chapter, you will be introduced to fragments and how they fit into
    the architecture of your application, as well as exploring more of the Android
    resources framework.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将介绍片段以及它们如何适应应用程序的架构，以及更多探索Android资源框架。
