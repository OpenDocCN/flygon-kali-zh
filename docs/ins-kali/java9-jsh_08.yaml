- en: Chapter 8. Contract Programming with Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。接口的契约编程
- en: 'In this chapter, we will work with complex scenarios in which we will have
    to use instances that belong to more than one blueprint. We will take advantage
    of the interfaces to work with contract programming. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理复杂的场景，在这些场景中，我们将不得不使用属于多个蓝图的实例。我们将利用接口来进行契约编程。我们将：
- en: Learn about interfaces in Java 9
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Java 9中的接口
- en: Understand how interfaces work in combination with classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解接口与类结合的工作原理
- en: Declare interfaces in Java 9
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java 9中声明接口
- en: Declare classes that implement interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明实现接口的类
- en: Take advantage of the multiple inheritance of interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用接口的多重继承
- en: Combine class inheritance with interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类继承与接口结合
- en: Understanding how interfaces work in combination with classes
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解接口与类结合的工作原理
- en: 'Let''s imagine we have to develop a Web Service in which we have to work with
    two different types of character: comic and game characters.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须开发一个Web服务，在其中我们必须处理两种不同类型的角色：漫画角色和游戏角色。
- en: 'A comic character must be drawable in a comic strip. A comic character must
    be able to provide a nickname and perform the following tasks:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 漫画角色必须在漫画中可绘制。漫画角色必须能够提供昵称并执行以下任务：
- en: Draw a speech balloon, also known as speech bubble, with a message
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制一个带有消息的语音气泡，也称为语音气泡
- en: Draw a thought balloon, also known as thought bubble, with a message
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制一个带有消息的思想气泡，也称为思想气泡
- en: Draw a speech balloon with a message and another comic character, drawable in
    a comic strip, as a destination
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制带有消息的语音气泡和另一个漫画角色，在漫画中可绘制，作为目标。
- en: 'A game character must be drawable in a game scene. A game character must be
    able to provide a full name and its current score. In addition, a game character
    must be able to perform the following tasks:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏角色必须在游戏场景中可绘制。游戏角色必须能够提供全名和当前得分。此外，游戏角色必须能够执行以下任务：
- en: Set its desired location to a specific 2D position indicated by the *x* and
    *y* coordinates
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其所需的位置设置为由*x*和*y*坐标指示的特定2D位置
- en: Provide the value for its *x* coordinate
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为其*x*坐标提供值
- en: Provide the value for its *y* coordinate
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为其*y*坐标提供值
- en: Draw itself at its current position
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前位置绘制自身
- en: Check whether it intersects with another game character, drawable in a game
    scene
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查它是否与另一个游戏角色相交，在游戏场景中可绘制
- en: We have to be able to work with objects that can be both a comic character and
    a game character; that is, they are both drawable in a comic strip and drawable
    in a game scene. However, we will also work with objects that will just be either
    a comic or game character; that is, they are drawable in a comic strip or drawable
    in a game scene.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须能够处理既是漫画角色又是游戏角色的对象；也就是说，它们既可以在漫画中绘制，也可以在游戏场景中绘制。然而，我们还将处理只是漫画或游戏角色的对象；也就是说，它们可以在漫画中绘制或在游戏场景中绘制。
- en: We don't want to code a generic way of performing the previously described tasks.
    We want to make sure that many classes are capable of performing these tasks with
    a common interface. Each object that declares itself as drawable in a comic strip
    must define the tasks related to speech and thought balloons. Each object that
    declares itself as drawable in a game scene must define how to set its desired
    2D position, draw itself, and check whether it intersects with another game character,
    drawable in a game scene.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想编写执行先前描述的任务的通用方式。我们希望确保许多类能够通过一个公共接口执行这些任务。在漫画中声明自己为可绘制的每个对象必须定义与语音和思想气泡相关的任务。在游戏场景中声明自己为可绘制的每个对象必须定义如何设置其所需的2D位置，绘制自身，并检查它是否与另一个游戏角色相交，在游戏场景中可绘制。
- en: '**SpiderDog** is a comic character, drawable in a comic strip, that has a specific
    way of drawing speech and thought balloons. **WonderCat** is both a comic and
    game character, drawable in a comic strip and also in a game scene. Thus, WonderCat
    must define all the tasks required by both character types.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**SpiderDog**是一种漫画角色，在漫画中可绘制，具有特定的绘制语音和思想气泡的方式。**WonderCat**既是漫画角色又是游戏角色，在漫画中可绘制，也在游戏场景中可绘制。因此，WonderCat必须定义两种角色类型所需的所有任务。'
- en: 'WonderCat is a very versatile character, and it can use different costumes
    to participate in either games or comics with different names. WonderCat can also
    be hideable, powerable, or fightable:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: WonderCat是一个非常多才多艺的角色，它可以使用不同的服装参与游戏或漫画，并具有不同的名称。WonderCat还可以是可隐藏的、可供能力的或可战斗的：
- en: A hideable character is capable of being hidden. It can provide a specific number
    of eyes and must be able to show and hide itself.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可隐藏的角色能够被隐藏。它可以提供特定数量的眼睛，并且必须能够显示和隐藏自己。
- en: A powerable character is capable of being powered. It can provide a spell power
    score value and use this spell power to make a hideable character disappear.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可供能力的角色能够被赋予能力。它可以提供一个法术能力分数值，并使用这个法术能力使一个可隐藏的角色消失。
- en: A fightable character is able to fight. It has a sword and can provide both
    the sword power and weight values. In addition, a fightable character can unsheathe
    his sword with or without a hideable character as a target.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可战斗的角色能够战斗。它有一把剑，并且可以提供剑的力量和重量值。此外，可战斗的角色可以在有或没有可隐藏的角色作为目标时拔出剑。
- en: Let's imagine that Java 9 provides support for multiple inheritance. We need
    base blueprints to represent a comic character and a game character. Then, each
    class that represents any of these types of character can provide its implementation
    of the methods. In this case, comic and game characters are very different, and
    they don't perform similar tasks that might lead to confusion and problems for
    multiple inheritance. Thus, we can use multiple inheritance to create a `WonderCat`
    class that implements both comic and game character blueprints. In some cases,
    multiple inheritance is not convenient because similar blueprints might have methods
    with the same names, and it can be extremely confusing to use multiple inheritance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Java 9支持多重继承。我们需要基本蓝图来表示漫画角色和游戏角色。然后，代表这些类型角色的每个类都可以提供其方法的实现。在这种情况下，漫画和游戏角色非常不同，它们不执行可能导致混乱和问题的相似任务，因此多重继承不方便。因此，我们可以使用多重继承来创建一个`WonderCat`类，该类实现了漫画和游戏角色的蓝图。在某些情况下，多重继承不方便，因为相似的蓝图可能具有相同名称的方法，并且使用多重继承可能会非常令人困惑。
- en: In addition, we can use multiple inheritance to combine the `WonderCat` class
    with `Hideable`, `Powerable`, and `Fightable`. This way, we will have a `Hideable`
    + `WonderCat`, a `Powerable` + `WonderCat`, and a `Fightable` + `WonderCat`. We
    would be able to use any of them, `Hideable` + `WonderCat`, `Powerable` + `WonderCat`,
    or `Fightable` + `WonderCat`, as either a comic or game character.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用多重继承将`WonderCat`类与`Hideable`、`Powerable`和`Fightable`结合在一起。这样，我们将有一个`Hideable`
    + `WonderCat`，一个`Powerable` + `WonderCat`，和一个`Fightable` + `WonderCat`。我们可以使用任何一个，`Hideable`
    + `WonderCat`，`Powerable` + `WonderCat`，或`Fightable` + `WonderCat`，作为漫画或游戏角色。
- en: 'Our goals are simple, but we face a little problem: Java 9 doesn''t support
    the multiple inheritance of classes. Instead, we can use multiple inheritance
    with interfaces or combine interfaces with classes. So, we will use interfaces
    and classes to fulfill our previous requirements.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标很简单，但我们面临一个小问题：Java 9不支持类的多重继承。相反，我们可以使用接口进行多重继承，或者将接口与类结合使用。因此，我们将使用接口和类来满足我们之前的要求。
- en: In the previous chapters, we have been working with abstract classes and concrete
    classes. When we coded the abstract classes, we declared constructors, instance
    fields, instance methods, and abstract methods. The abstract classes had concrete
    instance methods mixed with abstract methods.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们一直在使用抽象类和具体类。当我们编写抽象类时，我们声明了构造函数、实例字段、实例方法和抽象方法。抽象类中有具体的实例方法和抽象方法。
- en: In this case, we don't need to provide implementation for any method; we just
    have to make sure that we provide the appropriate methods with specific names
    and arguments. You can think of an **interface** as a group of related abstract
    methods that a class must implement to be considered a member of the type identified
    with the interface name. Java 9 doesn't allow us to specify requirements for constructors
    or instance fields in interfaces. It is also important to take into account that
    an interface is not a class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要为任何方法提供实现；我们只需要确保我们提供了具有特定名称和参数的适当方法。您可以将**接口**视为一组相关的抽象方法，类必须实现这些方法才能被视为接口名称标识的类型的成员。Java
    9不允许我们在接口中指定构造函数或实例字段的要求。还要注意接口不是类。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In other programming languages, interfaces are known as protocols.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他编程语言中，接口被称为协议。
- en: 'For example, we can create a `Hideable` interface that specifies the following
    parameterless methods with empty bodies:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个`Hideable`接口，该接口指定以下无参数方法并具有空体：
- en: '`getNumberOfEyes()`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getNumberOfEyes()`'
- en: '`appear()`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appear()`'
- en: '`disappear()`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disappear()`'
- en: Once we define an interface, we create a new type. Hence, we can use the interface
    name to specify the required type for an argument. This way, instead of using
    classes as types, we will use interfaces as types, and we can use an instance
    of any class that implements the specific interface as an argument. For example,
    if we use `Hideable` as the required type for an argument, we can pass an instance
    of any class that implements the `Hideable` interface as an argument.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了一个接口，我们就创建了一个新类型。因此，我们可以使用接口名称来指定参数的所需类型。这样，我们将使用接口作为类型，而不是使用类作为类型，并且我们可以使用实现特定接口的任何类的实例作为参数。例如，如果我们使用`Hideable`作为参数的所需类型，我们可以将实现`Hideable`接口的任何类的实例作为参数传递。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We can declare interfaces that inherit from more than one interface; that is,
    interfaces support multiple inheritance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明继承自多个接口的接口；也就是说，接口支持多重继承。
- en: 'However, you must take into account some limitations for interfaces compared
    with abstract classes. Interfaces cannot specify requirements for constructors
    or instance fields because interfaces have to do with methods and signature. Interfaces
    can declare requirements for the following members:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您必须考虑接口与抽象类相比的一些限制。接口不能指定构造函数或实例字段的要求，因为接口与方法和签名有关。接口可以声明对以下成员的要求：
- en: Class constants
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类常量
- en: Static methods
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法
- en: Instance methods
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法
- en: Default methods
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认方法
- en: Nested types
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套类型
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Java 8 added the possibility to add default methods to interfaces. They allow
    us to declare methods that actually provide an implementation. Java 9 keeps this
    feature alive.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8增加了向接口添加默认方法的可能性。它们允许我们声明实际提供实现的方法。Java 9保留了这一特性。
- en: Declaring interfaces
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明接口
- en: 'It is time to code the necessary interfaces in Java 9\. We will code the following
    five interfaces:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在Java 9中编写必要的接口了。我们将编写以下五个接口：
- en: '`DrawableInComic`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DrawableInComic`'
- en: '`DrawableInGame`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DrawableInGame`'
- en: '`Hideable`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hideable`'
- en: '`Powerable`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Powerable`'
- en: '`Fightable`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fightable`'
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Some programming languages, such as C#, use `I` as a prefix for interfaces.
    Java 9 doesn't use this naming convention for interface names. Thus, if you see
    an interface named `IDrawableInComic`, it was probably coded by someone who has
    C# experience and transferred the naming convention to the Java land.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言，比如C#，使用`I`作为接口的前缀。Java 9不使用这种接口命名约定。因此，如果你看到一个名为`IDrawableInComic`的接口，那可能是由有C#经验的人编写的，并将命名约定转移到了Java领域。
- en: The following UML diagram shows the five interfaces that we will code with their
    required methods included in the diagram. Notice that we include the **<<interface>>**
    text before the class name in each diagram that declares an interface.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的UML图表显示了我们将要编码的五个接口，其中包括在图表中的必需方法。请注意，在声明接口的每个图表中，我们在类名前包含了**<<interface>>**文本。
- en: '![Declaring interfaces](img/00080.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![声明接口](img/00080.jpeg)'
- en: The following lines show the code for the `DrawableInComic` interface. The `public`
    modifier, followed by the `interface` keyword and the interface name, `DrawableInComic`,
    composes the interface declaration. As it happens with class declarations, the
    interface body is enclosed in curly brackets (`{}`). The code file for the sample
    is included in the `java_9_oop_chapter_08_01` folder, in the `example08_01.java`
    file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了`DrawableInComic`接口的代码。`public`修饰符，后跟`interface`关键字和接口名`DrawableInComic`，构成了接口声明。与类声明一样，接口体被括在大括号（`{}`）中。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中，名为`example08_01.java`。
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The members declared in an interface have an implicit `public` modifier, and
    therefore, there is no need to specify `public` for each method declaration.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中声明的成员具有隐式的`public`修饰符，因此不需要为每个方法声明指定`public`。
- en: The `DrawableInComic` interface declared a `getNickName` method requirement,
    a `drawSpeechBalloon` method requirement overloaded twice, and a `drawThoughtBalloon`
    method requirement. The interface includes only the method declaration because
    the classes that implement the `DrawableInComic` interface will be responsible
    for providing the implementation of the `getNickName` method, the `drawThoughtBalloon`
    methods and the two overloads of the `drawSpeechBalloon` method. Note that there
    is no method body, as happened when we declared abstract methods for abstract
    classes. There is no need to use the `abstract` keyword to declare the methods
    because they are implicitly abstract.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawableInComic`接口声明了一个`getNickName`方法要求，两次重载的`drawSpeechBalloon`方法要求，以及一个`drawThoughtBalloon`方法要求。该接口只包括方法声明，因为实现`DrawableInComic`接口的类将负责提供`getNickName`方法、`drawThoughtBalloon`方法和`drawSpeechBalloon`方法的两个重载的实现。请注意，没有方法体，就像我们为抽象类声明抽象方法时一样。不需要使用`abstract`关键字来声明这些方法，因为它们是隐式抽象的。'
- en: The following lines show the code for the `DrawableInGame` interface. The code
    file for the sample is included in the `java_9_oop_chapter_08_01` folder, in the
    `example08_01.java` file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了`DrawableInGame`接口的代码。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中，名为`example08_01.java`。
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `DrawableInGame` interface declaration includes seven method requirements:
    `getFullName`, `getScore`, `getX`, `getY`, `setLocation`, `draw`, and `isIntersectingWith`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawableInGame`接口声明包括七个方法要求：`getFullName`、`getScore`、`getX`、`getY`、`setLocation`、`draw`和`isIntersectingWith`。'
- en: The following lines show the code for the `Hideable` interface. The code file
    for the sample is included in the `java_9_oop_chapter_08_01` folder, in the `example08_01.java`
    file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了`Hideable`接口的代码。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中，名为`example08_01.java`。
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Hideable` interface declaration includes three method requirements: `getNumberOfEyes`,
    `show`, and `hide`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hideable`接口声明包括三个方法要求：`getNumberOfEyes`、`show`和`hide`。'
- en: The following lines show the code for the `Powerable` interface. The code file
    for the sample is included in the `java_9_oop_chapter_08_01` folder, in the `example08_01.java`
    file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了`Powerable`接口的代码。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中，名为`example08_01.java`。
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Powerable` interface declaration includes two method requirements: `getSpellPower`
    and `useSpellToHide`. As it happened in other method requirement declarations
    included in the previously declared interface, we use an interface name as the
    type of an argument within a method declaration. In this case, the `hideable`
    argument for the `useSpellToHide` method declaration is `Hideable`. Hence, we
    will be able to call the method with any class that implements the `Hideable`
    interface.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Powerable`接口声明包括两个方法要求：`getSpellPower`和`useSpellToHide`。与先前声明的接口中包含的其他方法要求一样，在方法声明中，我们使用接口名作为方法声明中参数的类型。在这种情况下，`useSpellToHide`方法声明的`hideable`参数为`Hideable`。因此，我们将能够使用任何实现`Hideable`接口的类来调用该方法。'
- en: The following lines show the code for the `Fightable` interface. The code file
    for the sample is included in the `java_9_oop_chapter_08_01` folder, in the `example08_01.java`
    file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了`Fightable`接口的代码。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中，名为`example08_01.java`。
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Fightable` interface declaration includes four method requirements: `getSwordPower`,
    `getSwordWeight`, and the two overloads of the `unsheathSword` method.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fightable`接口声明包括四个方法要求：`getSwordPower`、`getSwordWeight`和`unsheathSword`方法的两个重载。'
- en: Declaring classes that implement interfaces
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明实现接口的类
- en: Now, we will declare a concrete class that specifies that it implements the
    `DrawableInComic` interface in its declaration in JShell. Instead of specifying
    a superclass, the class declaration includes the name of the previously declared
    `DrawableInComic` interface after the class name (`SiperDog`) and the `implements`
    keyword. We can read the class declaration as "the `SpiderDog` class implements
    the `DrawableInComic` interface." The code file for the sample is included in
    the `java_9_oop_chapter_08_01` folder, in the `example08_02.java` file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在JShell中声明一个具体类，该类在其声明中指定实现`DrawableInComic`接口。类声明不包括超类，而是在类名（`SiperDog`）和`implements`关键字之后包括先前声明的`DrawableInComic`接口的名称。我们可以将类声明解读为“`SpiderDog`类实现`DrawableInComic`接口”。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中的`example08_02.java`文件中。
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The Java compiler will generate an error because the `SpiderDog` class is declared
    as a concrete class and doesn''t override all the abstract methods declared in
    the `DrawableInComic` interface. JShell displays us the following error, indicating
    that the first method declaration in the interface isn''t overridden:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Java编译器将生成错误，因为`SpiderDog`类被声明为具体类，并且没有覆盖`DrawableInComic`接口中声明的所有抽象方法。JShell显示以下错误，指示接口中的第一个方法声明没有被覆盖：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we will replace the previous declaration of the empty `SuperDog` class
    with a class that tries to implement the `DrawableInComic` interface, but it still
    doesn't achieve its goal. The following lines show the new code for the `SuperDog`
    class. The code file for the sample is included in the `java_9_oop_chapter_08_01`
    folder, in the `example08_03.java` file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将用尝试实现`DrawableInComic`接口的类替换之前声明的空`SuperDog`类，但它仍未实现其目标。以下行显示了`SuperDog`类的新代码。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中的`example08_03.java`文件中。
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Java compiler will generate many errors because the `SpiderDog` concrete
    class doesn't implement the `DrawableInComic` interface. JShell displays us the
    following error messages, indicating that the interface required many methods
    to be declared as `public` methods.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Java编译器将生成许多错误，因为`SpiderDog`具体类没有实现`DrawableInComic`接口。JShell显示以下错误消息，指示接口需要许多方法声明为`public`方法。
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The public `DrawableInComic` interface specified methods that are implicitly
    public. Thus, when we declare a class that doesn't declare the required members
    as `public`, the Java compiler generates errors and indicates that we cannot attempt
    to assign a weaker access privilege than the one required by the interface.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 公共`DrawableInComic`接口指定了隐式公共方法。因此，当我们声明一个类时，该类没有将所需成员声明为`public`时，Java编译器会生成错误，并指出我们不能尝试分配比接口要求的更弱的访问权限。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Whenever we declare a class that specifies that it implements an interface,
    it must fulfill all the requirements specified in the interface. If it doesn't,
    the Java compiler will generate errors indicating which requirements aren't fulfilled,
    as it happened in the previous example. When we work with interfaces, the Java
    compiler makes sure that the requirements specified in them are honored in any
    class that implements them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们声明一个指定实现接口的类时，它必须满足接口中指定的所有要求。如果不满足，Java编译器将生成错误，指示未满足哪些要求，就像在前面的示例中发生的那样。在使用接口时，Java编译器确保实现接口的任何类都遵守其中指定的要求。
- en: Finally, we will replace the previous declaration of the `SpiderDog` class with
    a class that really implements the `DrawableInComic` interface. The following
    lines show the new code for the `SpiderDog` class. The code file for the sample
    is included in the `java_9_oop_chapter_08_01` folder, in the `example08_04.java`
    file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将用真正实现`DrawableInComic`接口的类替换`SpiderDog`类的先前声明。以下行显示了`SpiderDog`类的新代码。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中的`example08_04.java`文件中。
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `SpiderDog` class declares a constructor that assigns the value of the required
    `nickName` argument to the `nickName` immutable protected field. The class implements
    the `getNickName` method that just returns the `nickName` immutable protected
    field. The class declares the code for the two versions of the `drawSpeechBalloon`
    method. Both methods call the protected `speak` method that prints a message with
    a specific format that includes the `nickName` value as a prefix. In addition,
    the class declares the code for the `drawThoughtBalloon` method that invokes the
    protected `think` method that also prints a message including the `nickName` value
    as a prefix.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpiderDog`类声明了一个构造函数，将所需的`nickName`参数的值分配给`nickName`不可变的受保护字段。该类实现了`getNickName`方法，该方法只返回`nickName`不可变的受保护字段。该类声明了两个版本的`drawSpeechBalloon`方法的代码。两种方法都调用受保护的`speak`方法，该方法打印一个包括`nickName`值作为前缀的特定格式的消息。此外，该类声明了`drawThoughtBalloon`方法的代码，该方法调用受保护的`think`方法，该方法也打印一个包括`nickName`值作为前缀的消息。'
- en: The `SpiderDog` class implements the methods declared in the `DrawableInComic`
    interface. The class also declares a constructor, a `protected` immutable field,
    and two `protected` methods.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpiderDog`类实现了`DrawableInComic`接口中声明的方法。该类还声明了一个构造函数，一个`protected`的不可变字段和两个`protected`方法。'
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As long as we implement all the members declared in the interface or interfaces
    listed in the class declaration after the `implements` keyword, we can add any
    desired additional member to the class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们实现了类声明中`implements`关键字后列出的接口中声明的所有成员，就可以向类添加任何所需的额外成员。
- en: Now, we will declare another class that implements the same interface that the
    `SpiderDog` class implemented, that is, the `DrawableInComic` interface. The following
    lines show the code for the `WonderCat` class. The code file for the sample is
    included in the `java_9_oop_chapter_08_01` folder, in the `example08_04.java`
    file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将声明另一个类，该类实现了`SpiderDog`类实现的相同接口，即`DrawableInComic`接口。以下行显示了`WonderCat`类的代码。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中的`example08_04.java`文件中。
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `WonderCat` class declares a constructor that assigns the value of the required
    `nickName` and `age` arguments to the `nickName` and `age` immutable fields. The
    class declares the code for the two versions of the `drawSpeechBalloon` method.
    The version that requires only a `message` argument uses the value of the `age`
    property to generate a different message when the `age` value is greater than
    `2`. In addition, the class declares the code for the `drawThoughtBalloon` and
    `getNickName` methods.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`WonderCat`类声明了一个构造函数，将所需的`nickName`和`age`参数的值分配给`nickName`和`age`不可变字段。该类声明了两个版本的`drawSpeechBalloon`方法的代码。只需要`message`参数的版本使用`age`属性的值，在`age`值大于`2`时生成不同的消息。此外，该类声明了`drawThoughtBalloon`和`getNickName`方法的代码。'
- en: The `WonderCat` class implements the methods declared in the `DrawableInComic`
    interface. However, the class also declares an additional immutable field, `age`,
    and a `getAge` method that aren't required by the interface.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`WonderCat`类实现了`DrawableInComic`接口中声明的方法。但是，该类还声明了一个额外的不可变字段`age`和一个`getAge`方法，这些并不是接口所要求的。'
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Interfaces in Java 9 allow us to make sure that the classes that implement them
    define all the members specified in the interface. If they don't, the code won't
    compile.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9中的接口允许我们确保实现它们的类定义接口中指定的所有成员。如果没有，代码将无法编译。
- en: Taking advantage of the multiple inheritance of interfaces
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用接口的多重继承
- en: Java 9 doesn't allow us to declare a class with multiple superclasses or base
    classes, so there is no support for multiple inheritance of classes. A subclass
    can inherit from just one class. However, a class can implement one or more interfaces.
    In addition, we can declare classes that inherit from a superclass and implement
    one or more interfaces. Hence, we can combine class-based inheritance with the
    implementation of interfaces.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9不允许我们声明具有多个超类或基类的类，因此不支持类的多重继承。子类只能继承一个类。但是，一个类可以实现一个或多个接口。此外，我们可以声明从超类继承并实现一个或多个接口的类。因此，我们可以将基于类的继承与接口的实现结合起来。
- en: We want the `WonderCat` class to implement both the `DrawableInComic` and `DrawableInGame`
    interfaces. We want to be able to use any `WonderCat` instance as both a comic
    character and a game character. In order to do so, we must change the class declaration
    and add the `DrawableInGame` interface to the list of interfaces that the class
    implements and declare all the methods included in this added interface within
    the class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望`WonderCat`类实现`DrawableInComic`和`DrawableInGame`接口。我们希望能够将任何`WonderCat`实例用作漫画角色和游戏角色。为了实现这一点，我们必须更改类声明，并将`DrawableInGame`接口添加到类实现的接口列表中，并在类中声明此添加接口中包含的所有方法。
- en: The following lines show the new class declaration that specifies that the `WonderCat`
    class implements both the `DrawableInComic` and the `DrawableInGame` interfaces.
    The class body remains without changes, and therefore, we don't repeat the code.
    The code file for the sample is included in the `java_9_oop_chapter_08_01` folder,
    in the `example08_05.java` file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了新的类声明，指定`WonderCat`类实现`DrawableInComic`和`DrawableInGame`接口。类主体保持不变，因此我们不重复代码。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中的`example08_05.java`文件中。
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After we change the class declaration, the Java compiler will generate many
    errors because the new version of the `WonderCat` concrete class doesn't implement
    the `DrawableInGame` interface. JShell displays us the following error message.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 更改类声明后，Java编译器将生成许多错误，因为`WonderCat`具体类的新版本没有实现`DrawableInGame`接口。JShell显示以下错误消息。
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The new constructor assigns the value of the additional required `fullName`,
    `score`, `x`, and `y` arguments to the fields with the same names. Hence, we will
    need to specify these additional arguments whenever we want to create an instance
    of the `AngryCat` class. In addition, the class added the implementation of all
    the methods specified in the `DrawableInGame` interface.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 新的构造函数将额外需要的`fullName`、`score`、`x`和`y`参数的值分配给同名的字段。因此，每当我们想要创建`AngryCat`类的实例时，我们将需要指定这些额外的参数。此外，该类添加了`DrawableInGame`接口中指定的所有方法的实现。
- en: Combining class inheritance and interfaces
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合类继承和接口
- en: We can combine class inheritance with the implementation of interfaces. The
    following lines show the code for a new `HideableWonderCat` class that inherits
    from the `WonderCat` class and implements the `Hideable` interface. Note that
    the class declaration includes the superclass (`WonderCat`) after the `extends`
    keyword and the implemented interface (`Hideable`) after the `implements` keyword.
    The code file for the sample is included in the `java_9_oop_chapter_08_01` folder,
    in the `example08_07.java` file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将类继承与接口的实现结合起来。以下行显示了一个新的`HideableWonderCat`类的代码，它继承自`WonderCat`类并实现了`Hideable`接口。请注意，类声明在`extends`关键字后包括超类（`WonderCat`），在`implements`关键字后包括实现的接口（`Hideable`）。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中的`example08_07.java`文件中。
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As a result of the previous code, we have a new class named `HideableWonderCat`
    that implements the following three interfaces:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的代码，我们有了一个名为`HideableWonderCat`的新类，它实现了以下三个接口：
- en: '`DrawableInComic`: This interface is implemented by the `WonderCat` superclass
    and inherited by `HideableWonderCat`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DrawableInComic`：这个接口由`WonderCat`超类实现，并被`HideableWonderCat`继承'
- en: '`DrawableInGame`: This interface is implemented by the `WonderCat` superclass
    and inherited by `HideableWonderCat`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DrawableInGame`：这个接口由`WonderCat`超类实现，并被`HideableWonderCat`继承'
- en: '`Hideable`: This interface is implemented by `HideableWonderCat`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hideable`：这个接口由`HideableWonderCat`实现'
- en: The constructor defined in the `HideableWonderCat` class adds a `numberOfEyes`
    argument to the argument list defined in the constructor declared in the `WonderCat`
    superclass. In this case, the constructor calls the constructor defined in the
    superclass by using the `super` keyword and then initializes the `numberOfEyes`
    immutable field with the value received in the `numberOfEyes` argument. The class
    implements the `getNumberOfEyes`, `show`, and `hide` methods required by the `Hideable`
    interface.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`HideableWonderCat`类中定义的构造函数在构造函数中添加了一个`numberOfEyes`参数，该参数在`WonderCat`超类中声明的参数列表中。在这种情况下，构造函数使用`super`关键字调用超类中定义的构造函数，然后使用接收到的`numberOfEyes`参数初始化`numberOfEyes`不可变字段。该类实现了`Hideable`接口所需的`getNumberOfEyes`、`show`和`hide`方法。'
- en: The following lines show the code for a new `PowerableWonderCat` class that
    inherits from the `WonderCat` class and implements the `Powerable` interface.
    Note that the class declaration includes the superclass (`WonderCat`) after the
    `extends` keyword and the implemented interface (`Powerable`) after the `implements`
    keyword. The code file for the sample is included in the `java_9_oop_chapter_08_01`
    folder, in the `example08_07.java` file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行显示了一个新的`PowerableWonderCat`类的代码，该类继承自`WonderCat`类并实现了`Powerable`接口。请注意，类声明在`extends`关键字后包括超类（`WonderCat`），在`implements`关键字后包括实现的接口（`Powerable`）。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中的`example08_07.java`文件中。
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As it happened with the `HideableWonderCat` class, the new `PowerableWonderCat`
    class implements three interfaces. Two of these interfaces are implemented by
    the `WonderCat` superclass and inherited by `HideableWonderCat`: `DrawableInComic`
    and `DrawableInGame`. The `HideableWonderCat` class adds the implementation of
    the `Powerable` interface.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`HideableWonderCat`类一样，新的`PowerableWonderCat`类实现了三个接口。其中两个接口由`WonderCat`超类实现，并被`HideableWonderCat`继承：`DrawableInComic`和`DrawableInGame`。`HideableWonderCat`类添加了`Powerable`接口的实现。
- en: The constructor defined in the `PowerableWonderCat` class adds a `spellPower`
    argument to the argument list defined in the constructor declared in the `WonderCat`
    superclass. In this case, the constructor calls the constructor defined in the
    superclass by using the `super` keyword and then initializes the `spellPower`
    immutable field with the value received in the `spellPower` argument. The class
    implements the `getSpellPower` and `useSpellToHide` methods required by the `Powerable`
    interface.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`PowerableWonderCat`类中定义的构造函数在构造函数中添加了一个`spellPower`参数，该参数在`WonderCat`超类中声明的参数列表中。在这种情况下，构造函数使用`super`关键字调用超类中定义的构造函数，然后使用接收到的`spellPower`参数初始化`spellPower`不可变字段。该类实现了`Powerable`接口所需的`getSpellPower`和`useSpellToHide`方法。'
- en: The `hide` method receives a `Hideable` as an argument. Hence, any instance
    of `HideableWonderCat` would qualify as an argument for this method, that is,
    any instance of any class that conforms to the `Hideable` instance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`hide`方法接收一个`Hideable`作为参数。因此，任何`HideableWonderCat`的实例都可以作为该方法的参数，也就是符合`Hideable`实例的任何类的实例。'
- en: The following lines show the code for a new `FightableWonderCat` class that
    inherits from the `WonderCat` class and implements the `Fightable` interface.
    Note that the class declaration includes the superclass (`WonderCat`) after the
    `extends` keyword and the implemented interface (`Fightable`) after the `implements`
    keyword. The code file for the sample is included in the `java_9_oop_chapter_08_01`
    folder, in the `example08_07.java` file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行显示了一个新的`FightableWonderCat`类的代码，该类继承自`WonderCat`类并实现了`Fightable`接口。请注意，类声明在`extends`关键字后包括超类（`WonderCat`），在`implements`关键字后包括实现的接口（`Fightable`）。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中的`example08_07.java`文件中。
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As it happened with the two previously coded classes that are inherited from
    the `WonderCat` class and implemented interfaces, the new `FightableWonderCat`
    class implements three interfaces. Two of these interfaces are implemented by
    the `WonderCat` superclass and inherited by `FightableWonderCat`: `DrawableInComic`
    and `DrawableInGame`. The `FightableWonderCat` class adds the implementation of
    the `Fightable` interface.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前编写的两个从`WonderCat`类继承并实现接口的类一样，新的`FightableWonderCat`类实现了三个接口。其中两个接口由`WonderCat`超类实现，并被`FightableWonderCat`继承：`DrawableInComic`和`DrawableInGame`。`FightableWonderCat`类添加了`Fightable`接口的实现。
- en: The constructor defined in the `FightableWonderCat` class adds the `swordPower`
    and `swordWeight` arguments to the parameters list defined in the constructor
    declared in the `WonderCat` superclass. In this case, the constructor calls the
    constructor defined in the superclass by using the `super` keyword and then initializes
    the `swordPower` and `swordWeight` immutable fields with the value received in
    the `swordPower` and `swordWeight` arguments.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`FightableWonderCat`类中定义的构造函数在构造函数中添加了`swordPower`和`swordWeight`参数，这些参数在`WonderCat`超类中声明的参数列表中。在这种情况下，构造函数使用`super`关键字调用超类中定义的构造函数，然后使用接收到的`swordPower`和`swordWeight`参数初始化`swordPower`和`swordWeight`不可变字段。'
- en: The class implements `getSpellPower`, `getSwordWeight`, and the two versions
    of the `unsheathSword` method required by the `Fightable` interface. The two versions
    of the `unsheathSword` method call the protected `printSwordInformation` method
    and the overloaded version that receives a `Hideable` instance as an argument
    prints an additional message with the number of eyes of the `Hideable` instance
    that the sword has as a target.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该类实现了`getSpellPower`、`getSwordWeight`和`Fightable`接口所需的两个版本的`unsheathSword`方法。两个版本的`unsheathSword`方法调用了受保护的`printSwordInformation`方法，而接收`Hideable`实例作为参数的重载版本则打印了一个额外的消息，该消息包含了`Hideable`实例的眼睛数量作为目标。
- en: 'The following table summarizes the interfaces that each of the classes we created
    implements:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了我们创建的每个类实现的接口：
- en: '| Class name | Implements the following interfaces |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 类名 | 实现以下接口 |'
- en: '| --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SpiderDog` | `DrawableInComic` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `SpiderDog` | `DrawableInComic` |'
- en: '| `WonderCat` | `DrawableInComic` and `DrawableInGame` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `WonderCat` | `DrawableInComic` 和 `DrawableInGame` |'
- en: '| `HideableWonderCat` | `DrawableInComic`, `DrawableInGame`, and `Hideable`
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `HideableWonderCat` | `DrawableInComic`、`DrawableInGame` 和 `Hideable` |'
- en: '| `PowerableWonderCat` | `DrawableInComic`, `DrawableInGame`, and `Powerable`
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `PowerableWonderCat` | `DrawableInComic`、`DrawableInGame` 和 `Powerable` |'
- en: '| `FightableWonderCat` | `DrawableInComic`, `DrawableInGame`, and `Fightable`
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `FightableWonderCat` | `DrawableInComic`、`DrawableInGame` 和 `Fightable` |'
- en: The following simplified UML diagram shows the hierarchy tree for the classes
    and their relationship with interfaces. The diagram doesn't include any members
    for the interfaces and classes to make it simpler to understand the relationships.
    The dashed lines that end with an arrow indicate that the class implements the
    interface indicated by the arrow.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简化的UML图显示了类的层次结构树及其与接口的关系。该图表不包括任何接口和类的成员，以使其更容易理解关系。以虚线结束的带箭头的线表示类实现了箭头指示的接口。
- en: '![Combining class inheritance and interfaces](img/00081.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Combining class inheritance and interfaces](img/00081.jpeg)'
- en: 'The following UML diagram shows the interfaces and the classes with all their
    members. Notice that we don''t repeat the members declared in the interfaces that
    the classes implement to make the diagram simpler and to avoid repeating information.
    We can use the diagram to understand all the things that we will analyze with
    the next code samples based on the usage of these classes and the previously defined
    interfaces:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下UML图显示了接口和类及其所有成员。请注意，我们不重复类实现的接口中声明的成员，以使图表更简单，并避免重复信息。我们可以使用该图表来理解我们将在基于这些类和先前定义的接口的使用的下一个代码示例中分析的所有内容：
- en: '![Combining class inheritance and interfaces](img/00082.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![Combining class inheritance and interfaces](img/00082.jpeg)'
- en: The following lines create one instance of each of the previously created classes.
    The code file for the sample is included in the `java_9_oop_chapter_08_01` folder,
    in the `example08_08.java` file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了每个先前创建的类的一个实例。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中的`example08_08.java`文件中。
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following table summarizes the instance name and its class name for the
    instances we have created with the previous code snippet:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了我们使用前面的代码片段创建的实例名称及其类名称：
- en: '| Instance name | Class name |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 实例名称 | 类名称 |'
- en: '| --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `spiderDog1` | `SpiderDog` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `spiderDog1` | `SpiderDog` |'
- en: '| `wonderCat1` | `WonderCat` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `wonderCat1` | `WonderCat` |'
- en: '| `hideableWonderCat1` | `HideableWonderCat` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `hideableWonderCat1` | `HideableWonderCat` |'
- en: '| `powerableWonderCat1` | `PowerableWonderCat` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `powerableWonderCat1` | `PowerableWonderCat` |'
- en: '| `fightableWonderCat1` | `FightableWonderCat` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `fightableWonderCat1` | `FightableWonderCat` |'
- en: Now, we will evaluate many expressions that use the `instanceof` keyword to
    determine whether the instances are an instance of the specified class or of a
    class that implements a specific interface. Note that all the expressions are
    evaluated to `true` because the type specified at the right-hand side after the
    `instanceof` keyword for each instance is its main class, its superclass, or an
    interface that the main class implements.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将评估许多使用`instanceof`关键字的表达式，以确定实例是指定类的实例还是实现特定接口的类的实例。请注意，所有表达式的评估结果都为`true`，因为在`instanceof`关键字后面的右侧指定的类型对于每个实例来说，都是它的主类、超类或主类实现的接口。
- en: 'For example, `powerableWonderCat1` is an instance of `PowerableWonderCat`.
    In addition, `powerableWonderCat1` belongs to `WonderCat` because `WonderCat`
    is the superclass of the `PowerableWonderCat` class. It is also true that `powerableWonderCat1`
    implements three interfaces: `DrawableInComic`, `DrawableInGame`, and `Powerable`.
    The superclass of `PowerableWonderCat`, `WonderCat`, implements the following
    two interfaces: `DrawableInComic` and `DrawableInGame`. Hence, `PowerableWonderCat`
    inherits the implementation of the interfaces. Finally, the `PowerableWonderCat`
    class not only inherits from `WonderCat`, but also implements the `Powerable`
    interface.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`powerableWonderCat1` 是 `PowerableWonderCat` 的一个实例。此外，`powerableWonderCat1`
    属于 `WonderCat`，因为 `WonderCat` 是 `PowerableWonderCat` 类的超类。同样，`powerableWonderCat1`
    实现了三个接口：`DrawableInComic`、`DrawableInGame` 和 `Powerable`。`PowerableWonderCat`
    的超类 `WonderCat` 实现了以下两个接口：`DrawableInComic` 和 `DrawableInGame`。因此，`PowerableWonderCat`
    继承了接口的实现。最后，`PowerableWonderCat` 类不仅继承自 `WonderCat`，还实现了 `Powerable` 接口。
- en: In [Chapter 3](part0033_split_000.html#VF2I1-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 3. Classes and Instances"), *Classes and Instances*, we learned that
    the `instanceof` keyword allows us to test whether an object is of the specified
    type. This type can be either a class or an interface. If we execute the following
    lines with many expressions in JShell, all of them will print `true` as a result
    of their evaluation. The code file for the sample is included in the `java_9_oop_chapter_08_01`
    folder, in the `example08_08.java` file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0033_split_000.html#VF2I1-bc1530b4c4784270ae8a31a7038f8341 "Chapter 3. Classes
    and Instances")*Classes and Instances*中，我们学习了`instanceof`关键字允许我们测试对象是否是指定类型。这种类型可以是类，也可以是接口。如果我们在JShell中执行以下行，所有这些行的评估结果都将打印为`true`。示例的代码文件包含在`java_9_oop_chapter_08_01`文件夹中的`example08_08.java`文件中。
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following two screenshots show the results of evaluating the previous expressions
    in JShell:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个屏幕截图显示了在JShell中评估先前表达式的结果：
- en: '![Combining class inheritance and interfaces](img/00083.jpeg)![Combining class
    inheritance and interfaces](img/00084.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![Combining class inheritance and interfaces](img/00083.jpeg)![Combining class
    inheritance and interfaces](img/00084.jpeg)'
- en: Test your knowledge
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'A class can implement:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个类可以实现：
- en: Only one interface.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有一个接口。
- en: One or more interfaces.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个或多个接口。
- en: A maximum of two interfaces.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最多两个接口。
- en: 'When a class implements an interface:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个类实现一个接口：
- en: It can also inherit from a superclass.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它也可以继承自一个超类。
- en: It cannot inherit from a superclass.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它不能从一个超类继承。
- en: It can inherit only from an abstract superclass but not from concrete superclasses.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它只能从抽象超类继承，而不能从具体超类继承。
- en: 'An interface:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个接口：
- en: Can inherit from a superclass.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以从一个超类继承。
- en: Cannot inherit from either a superclass or another interface.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不能继承自超类或另一个接口。
- en: Can inherit from another interface.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以继承另一个接口。
- en: 'Which of the following lines declares a class named `WonderDog` that implements
    the `Hideable` interface:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪一行声明了一个名为`WonderDog`的类，该类实现了`Hideable`接口：
- en: '`public class WonderDog extends Hideable {`'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public class WonderDog extends Hideable {`'
- en: '`public class WonderDog implements Hideable {`'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public class WonderDog implements Hideable {`'
- en: '`public class WonderDog: Hideable {`'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public class WonderDog: Hideable {`'
- en: 'An interface is:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口是：
- en: A method.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种方法。
- en: A type.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种类型。
- en: An abstract class.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象类。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the declaration and combination of multiple
    blueprints to generate a single instance. We declared interfaces that specified
    the required methods. Then, we created many classes that implemented single and
    multiple interfaces.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了声明和组合多个蓝图以生成单个实例。我们声明了指定所需方法的接口。然后，我们创建了许多实现单个和多个接口的类。
- en: We combined class inheritance with the implementation of interfaces. We realized
    that a single class can implement multiple interfaces. We executed code in JShell
    to understand that a single instance belongs to class types and to interface types.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将类继承与接口实现结合在一起。我们意识到一个类可以实现多个接口。我们在JShell中执行代码，以了解单个实例属于类类型和接口类型。
- en: Now that you have learned about interfaces and the basics for contract programming,
    we are ready to work with advanced contract programming scenarios, which is the
    topic we are going to discuss in the next chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了接口和基本的契约编程知识，我们准备开始处理高级契约编程场景，这是我们将在下一章讨论的主题。
