- en: Refactoring C# Code – Identifying Code Smells
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 重构 C# 代码 - 识别代码异味
- en: In this chapter, we will look at problem code and how to refactor it. In the
    industry, problem code is normally termed **code smell**. It is code that compiles,
    runs, and does what it is supposed to do. The reason it is problem code is that
    it becomes unreadable, complex in nature, and makes the code base hard to maintain
    and extend further down the line. Such code should be refactored as soon as it's
    feasible to do so. It is technical debt, and in the long run, if you don't deal
    with it, it will bring the project to its knees. When this happens, you are looking
    at an expensive redesign and recoding of the application from scratch.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将看看问题代码以及如何重构它。在行业中，问题代码通常被称为**代码异味**。它是编译、运行并完成其预期功能的代码。问题代码之所以成为问题是因为它变得难以阅读，具有复杂的性质，并使得代码库难以维护和进一步扩展。这样的代码应该在可行的情况下尽快重构。这是技术债务，在长期来看，如果你不处理它，它将使项目陷入困境。当这种情况发生时，你将面临昂贵的重新设计和从头开始编码应用程序。
- en: So what is refactoring? Refactoring is the process of taking existing code that
    works and rewriting it such that the code becomes clean. And as you have already
    discovered, clean code is easy to read, easy to maintain, and easy to extend.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么是重构？重构是将现有的工作代码重写，使得代码变得干净的过程。正如你已经发现的那样，干净的代码易于阅读、易于维护和易于扩展。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Identifying application-level code smells and how we can address them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别应用级别的代码异味以及我们如何解决它们
- en: Identifying class-level code smells and how we can address them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别类级别的代码异味以及我们如何解决它们
- en: Identifying method-level code smells and how we can address them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别方法级别的代码异味以及我们如何解决它们
- en: 'After working your way through this chapter, you will have gained the following
    skills:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您将获得以下技能：
- en: Identifying different kinds of code smell
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别不同类型的代码异味
- en: Understanding why the code is classed as code smell
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么代码被归类为代码异味
- en: Refactoring code smells so they become clean code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构代码异味，使其成为干净的代码
- en: We'll start our look at refactoring code smells by looking at application-level
    code smells.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从应用级别的代码异味开始看重构代码异味。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following prerequisites for the chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要本章的以下先决条件：
- en: Visual Studio 2019
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019
- en: PostSharp
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostSharp
- en: For the code files of the chapter, you can use this link: [https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH13](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH13).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的代码文件，您可以使用以下链接：[https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH13](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH13)。
- en: Application-level code smells
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用级别的代码异味
- en: Application-level code smells are problem code scattered through the application
    and affect every layer. No matter what layer of the software you find yourself
    in, you will see the same problematic code appearing over and over again. If you
    don't address these issues now, then you will find that your software will start
    to die a slow and agonizing death.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用级别的代码异味是散布在应用程序中的问题代码，影响每一层。无论您身处软件的哪一层，您都会看到相同的问题代码一遍又一遍地出现。如果您现在不解决这些问题，那么您将发现您的软件将开始缓慢而痛苦地死去。
- en: In this section, we will look at the application-level code smells and how we
    can remove them. Let's start with Boolean blindness.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看看应用级别的代码异味以及我们如何去除它们。让我们从布尔盲目开始。
- en: Boolean blindness
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔盲目
- en: Boolean data blindness refers to the information loss as determined by functions
    that work on Boolean values. Using a better structure provides better interfaces
    and classes that keep data, making for a more pleasant experience in working with
    data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数据盲目指的是由处理布尔值的函数确定的信息丢失。使用更好的结构提供更好的接口和类来保存数据，使得在处理数据时更加愉快。
- en: 'Let''s look at the problem of Boolean blindness via this code sample:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这段代码示例来看看布尔盲目的问题：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This method takes a string for the concert name, and a Boolean value indicating
    whether the person is standing or seated. Now, we would call the code as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受音乐会名称的字符串和一个布尔值，指示人是站立还是坐着。现在，我们将如下调用代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If someone new to the code saw the `BooleanBlindnessConcertBooking()` method,
    do you think they would know instinctively what `true` stands for? I think not.
    They would be blind to what it means. So they would have to either use IntelliSense
    or locate the method being referred to find the meaning. They are Boolean blind.
    So how can we cure them of this blindness?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个新手看到`BooleanBlindnessConcertBooking()`方法，你认为他们会本能地知道`true`代表什么吗？我认为不会。他们对它的含义会一无所知。所以他们要么使用智能感知，要么找到被引用的方法来找到含义。他们是布尔盲目的。那么我们如何治愈他们的盲目呢？
- en: 'Well, a simple solution would be to replace the Boolean with an enum. Let''s
    start by adding our enum called `TicketType`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，一个简单的解决方案是用枚举替换布尔值。让我们首先添加我们的名为`TicketType`的枚举：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our enum identifies two types of ticket types. These are `Seated` and `Standing`.
    Now let''s add our `ConcertBooking()` method:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的枚举标识了两种类型的票。这些是`Seated`和`Standing`。现在让我们添加我们的`ConcertBooking()`方法：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following code shows how to call the newly refactored code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何调用新重构的代码：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, if that new person came along and looked at this code, they would see that
    we are booking a concert to see the band `Chrom`, and that we want seated tickets.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有新人来看这段代码，他们会看到我们正在预订一场音乐会，看`Chrom`乐队，并且我们想要座位票。
- en: Combinatorial explosion
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合爆炸
- en: 'Combinatorial explosion is a *by-product* of the same thing being performed
    by different pieces of code using different combinations of parameters. Let''s
    look at an example that adds numbers:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 组合爆炸是同一段代码使用不同参数组合执行相同操作的副产品。让我们看一个添加数字的例子：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we have three methods that all add numbers. The return types and parameters
    are all different. Is there a better way? Yes, through the use of generics. By
    using generics, you can have one single method that is capable of working with
    different types. And so, we will be using generics to solve our addition problem.
    This will allow us to have a single addition method that will accept either integers,
    doubles, or floats. Let''s have a look at our new method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有三种方法都是对数字进行加法。返回类型和参数都不同。有更好的方法吗？有，通过使用泛型。通过使用泛型，你可以有一个单一的方法，能够处理不同类型的工作。因此，我们将使用泛型来解决我们的加法问题。这将允许我们有一个单一的加法方法，可以接受整数、双精度或浮点数。让我们来看看我们的新方法：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This generic method is called with a specific type assigned to `T`. It performs
    the addition and returns the result. Only one version of the method is required
    for the different .NET types that can be added together. To call the code for
    `int`, `double`, and `float` values, we would do the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个泛型方法被调用时，为`T`分配了特定类型。它执行加法并返回结果。只需要一个版本的方法来处理可以相加的不同.NET类型。要调用`int`、`double`和`float`值的代码，我们将这样做：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have just eliminated three methods and replaced them with a single method
    that performs the same task.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚消除了三种方法，并用一个执行相同任务的单一方法替代了它们。
- en: Contrived complexity
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人为复杂
- en: When you can develop code with simple architecture, but instead implement an
    advanced and rather complex architecture, this is known as **contrived complexity**.
    Unfortunately, I have suffered having to work on such systems and it is a proper
    pain and cause of stress. What you find with such systems is that they tend to
    have a high turnover of staff. They lack documentation, and no one seems to know
    the system or has the ability to answer questions by onboarders—the poor souls
    who have to learn the system to maintain and extend it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你可以用简单的架构开发代码，但却实现了一个先进而相当复杂的架构时，这被称为**人为复杂**。不幸的是，我曾经不得不在这样的系统上工作，这是一种真正的痛苦和压力来源。你会发现这样的系统往往有很高的员工流动率。它们缺乏文档，似乎没有人知道系统或者有能力回答接受培训的人的问题——那些不得不学习系统来维护和扩展它的可怜人。
- en: 'My advice to all super-intelligent software architects is that when it comes
    to software, **Keep It Simple, Stupid** (**KISS**). Remember, the days of permanent
    employment with jobs for life appear to be a thing of the past now. Oftentimes,
    programmers are more for chasing the money than showing lifelong loyalty to the
    business. So with the business relying on the software for revenue, you need a
    system that is easy to understand, to onboard new staff, to maintain, and to extend.
    Ask yourself this question: If the systems that you are responsible for suddenly
    experienced yourself and all staff assigned to them walking out and finding new
    opportunities, would the new staff who take over be able to hit the ground running?
    Or would they be left stressed out and scratching their heads?'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有超级智能软件架构师的建议是，当涉及软件时，**保持简单，愚蠢**（**KISS**）。记住，永久就业和终身工作似乎已经成为过去的事情。通常情况下，程序员更多地追逐金钱，而不是对企业的终身忠诚。因此，由于企业依赖软件来获取收入，你需要一个易于理解、接纳新员工、维护和扩展的系统。问问自己这个问题：如果你负责的系统突然经历了你和所有分配给它们的员工离职并找到新机会，接管的新员工能立即上手吗？还是他们会感到压力重重，摸不着头脑？
- en: Also bear in mind that if you have only one person on the team who understands
    that system and they die, move on to a new location, or retire, where does that
    leave you and the rest of the team? And even more than that, where does it leave
    the business?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，如果团队中只有一个人了解该系统，而他们去世、搬到新地方或退休了，那么你和团队的其他人会怎么样？甚至更重要的是，这对企业意味着什么？
- en: I cannot stress enough that you really are to KISS. The only reason for creating
    complex systems and not documenting them and sharing the architectural knowledge
    is to hold the business over a barrel so they keep you on and you can bleed them
    dry. Don't do it. In my experience, the more complicated a system is, the quicker
    it dies a death and has to be rewritten.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法再强调你真的要简单了。创建复杂系统并不记录它们并分享架构知识的唯一原因是为了让企业束手就擒，让他们留住你并榨干他们。不要这样做。根据我的经验，系统越复杂，死亡速度越快，必须重写。
- en: In [Chapter 12](f98f3b29-f422-4907-842f-c34a9af9d0d5.xhtml), *Using Tools to
    Improve Code Quality*, you learned how to use Visual Studio 2019 tools to discover
    the *cyclomatic complexity* and *Depth of Inheritance*. You also learned how to
    produce dependency diagrams with ReSharper. Use these tools to discover problem
    areas in the code, then focus on those areas. Reduce cyclomatic complexity down
    to a value of 10 or less. And reduce the depth of inheritance on all objects down
    to no greater than 1.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](f98f3b29-f422-4907-842f-c34a9af9d0d5.xhtml)中，*使用工具提高代码质量*，你学会了如何使用Visual
    Studio 2019工具来发现*圈复杂度*和*继承深度*。你还学会了如何使用ReSharper生成依赖关系图。使用这些工具来发现代码中的问题区域，然后专注于这些区域。将圈复杂度降至10或更低。并将所有对象的继承深度降至不超过1。
- en: Then, make sure all classes only perform the tasks that they are meant to. Aim
    to keep methods small. A good rule of thumb is to have no more than around 10
    lines of code per method. As for method parameters, replace long parameter lists
    with parameter objects. And where you have a lot of `out` parameters, refactor
    the method to return a tuple or object. Identify any multithreading, and make
    sure that the code being accessed is thread-safe. You have seen in [Chapter 9](f9b8bb24-456b-4362-9c3f-76d21cdba32b.xhtml), *Designing
    and Developing APIs*, how to replace mutable objects with immutable ones to improve
    thread-safety.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，确保所有类只执行它们的本职任务。力求使方法简短。一个很好的经验法则是每个方法不超过大约10行代码。对于方法参数，用参数对象替换长参数列表。在有很多`out`参数的地方，重构方法以返回元组或对象。识别任何多线程，并确保被访问的代码是线程安全的。你已经在[第9章](f9b8bb24-456b-4362-9c3f-76d21cdba32b.xhtml)中看到了如何用不可变对象替换可变对象来提高线程安全性。
- en: Also, look for the Quick Tips icons. These will normally suggest one-click refactorings
    for the line of code they highlight. I recommend you use them. These were mentioned
    in [Chapter 12](f98f3b29-f422-4907-842f-c34a9af9d0d5.xhtml), *Using Tools to Improve
    Code Quality*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，寻找快速提示图标。它们通常会建议单击重构所突出显示的代码行。我建议你使用它们。这些在[第12章](f98f3b29-f422-4907-842f-c34a9af9d0d5.xhtml)中提到过，*使用工具提高代码质量*。
- en: The next code smell to consider is the data clump.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑的下一个代码异味是数据团。
- en: Data clump
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据团
- en: A **data clump** occurs when you see the same fields appearing together in different
    classes and parameter lists. Their names usually follow the same pattern. This
    is normally the sign that a class is missing from the system. The reduction in
    system complexity will come by identifying the missing class and generalizing
    it. Don't be put off by the fact that the class may only be small, and never think
    of a class as being unimportant. If there is a need for a class to simplify the
    code, then add it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据团**是指在不同的类和参数列表中看到相同字段一起出现。它们的名称通常遵循相同的模式。这通常是系统中缺少一个类的迹象。通过识别缺失的类并将其概括，可以减少系统复杂性。不要被这个类可能很小的事实吓到，也永远不要认为一个类不重要。如果需要一个类来简化代码，那就添加它。'
- en: Deodorant comments
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 除臭注释
- en: When a comment uses nice words to excuse bad code, this is known as a **deodorant
    comment**. If the code is bad, then refactor it to make it good and remove the
    comment. If you don't know how to refactor it to make it good, then ask for help.
    If there is no one to ask that can help you, then post your code on Stack Overflow.
    There are some very good programmers on that site that can be a real help to you.
    Just make sure to follow the rules when posting!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当注释使用美好的词语来为糟糕的代码开脱时，这被称为**除臭注释**。如果代码糟糕，那就重构它使之变好，并删除注释。如果你不知道如何重构使之变好，那就寻求帮助。如果没有人可以帮助你，请在Stack
    Overflow上发布你的代码。那个网站上有一些非常优秀的程序员，他们可以真正帮助你。只要确保在发布时遵守规则！
- en: Duplicate code
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复代码
- en: '**Duplicate code** is code that occurs more than once. Problems that arise
    from duplicate code include increased maintenance cost per duplication. When a
    developer is fixing a piece of code, it costs the business time and money. Fixing
    1 bug is *technical debt (programmer''s pay) x 1*. But if there are 10 duplications
    of that code, that''s *technical debt x 10*. So the more that code is duplicated,
    the more expensive it is to maintain. Then there is the boredom factor of having
    to fix the same problem in multiple locations. And the fact that duplication may
    get overlooked by the programmer doing the bug fix.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**重复代码**是指出现多次的代码。重复代码带来的问题包括每次重复增加的维护成本。当开发人员修复一段代码时，这会花费企业的时间和金钱。修复一个错误就是
    *技术债务（程序员的工资） x 1*。但如果有10个代码重复，那就是 *技术债务 x 10*。因此，代码重复的次数越多，维护成本就越高。此外，还有在多个位置修复相同问题的无聊因素。还有重复可能被进行错误修复的程序员忽视的事实。'
- en: It is best to refactor the duplicate code so that only one copy of the code
    exists. Often, the easiest way to do this is to add it to a new reusable class
    in your current project and place it in a class library. The benefit of placing
    reusable code in a class library is that other projects can use the same file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最好重构重复代码，使之只存在一份。通常，最简单的方法是将其添加到当前项目中的一个新的可重用类中，并将其放在一个类库中。将可重用代码放入类库的好处是其他项目可以使用相同的文件。
- en: In the present day, it is best to use the .NET Standard class library for building
    reusable code. The reason for this is that .NET Standard libraries can be accessed
    by all C# project types on Windows, Linux, macOS, iOS, and Android.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今，最好使用.NET标准类库来构建可重用的代码。原因在于.NET标准库可以在Windows、Linux、macOS、iOS和Android上的所有C#项目类型中访问。
- en: Another alternative for removing boilerplate code is to use **Aspect-Oriented
    Programming (AOP)**. We looked at AOP in the previous chapter. You essentially
    move boilerplate code into an aspect. The aspect then decorates the method it
    is applied to. When the method is compiled, the boilerplate code is then weaved
    into place. This enables you only to write code that meets the business requirement
    inside the method. The aspect applied to the method hides the code that is essential,
    but not part of what the business has asked for. This coding technique is nice
    and clean, and it works really well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个消除样板代码的选择是使用**面向方面的编程（AOP）**。我们在上一章中看过AOP。你可以将样板代码移入一个方面。然后，该方面装饰应用于的方法。当方法被编译时，样板代码就被编织到位。这使你只需在方法内编写满足业务需求的代码。应用于方法的方面隐藏了必要但不属于业务要求的代码。这种编码技术既美观又干净，而且效果非常好。
- en: You can also write decorators using the decorator pattern, as you also saw in
    the previous chapter. The decorator wraps concrete class operations in such a
    way that you can add new code without affecting the expected operation of the
    code. A simple example would be to wrap the operation in a `try`/`catch` block
    as you saw previously in [Chapter 11](c9f56c87-1d5a-45e1-b03c-30a2fb9f7713.xhtml),
    *Addressing Cross-Cutting Concerns*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用装饰者模式编写装饰器，就像你在上一章中看到的那样。装饰器以一种可以添加新代码而不影响代码预期操作的方式包装具体类操作。一个简单的例子是将操作包装在一个`try`/`catch`块中，就像你之前在[第11章](c9f56c87-1d5a-45e1-b03c-30a2fb9f7713.xhtml)中看到的那样，*解决横切关注点*。
- en: Lost intent
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 失去意图
- en: If you can't easily understand the intent of the source code, then it has lost
    its intent.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法轻松理解源代码的意图，那它就失去了意图。
- en: The first thing to do is look at the namespace and the class name. These should
    indicate the purpose of the class. Then, check the contents of the class, and
    look for code that looks out of place. Once you have identified such code, refactor
    the code and place it in the right location.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是查看命名空间和类名。它们应该指示类的目的。然后，检查类的内容，寻找看起来不合适的代码。一旦你识别出这样的代码，就重构代码并将其放在正确的位置。
- en: The next thing to do is to look at each of the methods. Are they only doing
    one thing well or doing multiple things not so well? If yes, then refactor them.
    For large methods, look for code that can be extracted out into a method. Aim
    to make the code of the class read like a book. Keep refactoring the code until
    the intent is clear, and only what is in the class needs to be in the class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的是看每个方法。它们只做一件事还是做多件事不太好？如果是的话，就重构它们。对于大型方法，寻找可以提取到方法中的代码。目标是使类的代码读起来像一本书。不断重构代码，直到意图清晰，类中只需要的东西才在类中。
- en: Don't forget to put the tools to work that you learned how to use in [Chapter
    12](f98f3b29-f422-4907-842f-c34a9af9d0d5.xhtml), *Using Tools to Improve Code
    Quality*. The mutation of variables is the code smell we will look at next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记运用你在[第12章](f98f3b29-f422-4907-842f-c34a9af9d0d5.xhtml)中学会的工具来提高代码质量。变量的变异是我们接下来要看的代码异味。
- en: The mutation of variables
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量的变异
- en: The mutation of variables means they are hard to understand and reason about.
    This makes them difficult to refactor.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的变异意味着它们很难理解和推理。这使得它们很难重构。
- en: A mutable variable is one that gets changed multiple times by different operations.
    This makes reasoning about why is the value more difficult. Not only that, but
    because the variable is mutating from different operations, this makes it difficult
    to extract sections of code into other small and more readable methods. Mutable
    variables can also require more checking that adds complexity to the code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可变变量是指被不同操作多次更改的变量。这使得理解值的原因更加困难。不仅如此，因为变量是从不同操作中变异的，这使得将代码片段提取到其他小而更易读的方法中变得困难。可变变量还可能需要更多的检查，增加了代码的复杂性。
- en: Look to refactor small sections of code by extracting them out to methods. If
    there is a lot of branching and looping, see if there is an easier way to do things
    to remove the complexity. If you are using multiple `out` values, consider returning
    an object or tuple. Aim to remove the mutability of the variable to make it easier
    to reason about, and know why it is the value that it is, and from where it is
    getting set. Remember that the smaller the method is that holds a variable, the
    easier it will be to determine where the variable is getting set, and why.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 试着重构代码的小部分，将它们提取到方法中。如果有很多分支和循环，请看看是否有更简单的方法来做事情，以消除复杂性。如果你使用多个`out`值，请考虑返回一个对象或元组。目标是消除变量的可变性，使其更容易理解，并知道它的值是什么，以及它是从哪里设置的。记住，持有变量的方法越小，确定变量设置位置和原因就越容易。
- en: 'Look at the following example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The method takes a list of integers. It then loops through the integers, squares
    them, and then adds them to the `squaredSum` variable that is returned when the
    method exits. Notice the iterations, and the fact that the local variable is getting
    updated in each iteration. We can improve on this using LINQ. The following code
    shows the improved, refactored version:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个整数列表。然后它循环遍历整数，对它们进行平方，然后将它们添加到在方法退出时返回的`squaredSum`变量中。注意迭代次数，以及本地变量在每次迭代中的更新。我们可以使用LINQ来改进这一点。以下代码显示了改进后的重构版本：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In our new version, we use LINQ. As you know from an earlier chapter, LINQ employs
    functional programming. As you can see here, there is no loop, and no local variable
    being mutated.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新版本中，我们使用了LINQ。正如你在前面的章节中所了解的，LINQ采用了函数式编程。正如你在这里看到的，这里没有循环，也没有本地变量被变异。
- en: 'Compile and run the program, and you will see the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行程序，你会看到以下内容：
- en: '![](img/ef28bf84-6935-4be5-8510-a00d02d8009e.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef28bf84-6935-4be5-8510-a00d02d8009e.png)'
- en: Both versions of the code produce the same output.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的两个版本都产生了相同的输出。
- en: 'You will have noticed that both versions of the code have `[InstrumentationAspect]`
    applied to them. We added this aspect to our reusable library in [Chapter 12](c9f56c87-1d5a-45e1-b03c-30a2fb9f7713.xhtml),
    *Addressing Cross-Cutting Concerns*. When you run the code, you will find a `Logs`
    folder in the `Debug` folder. Open the `Profile.log` file in Notepad, and you
    will see the following output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到代码的两个版本都应用了`[InstrumentationAspect]`。我们在[第12章](c9f56c87-1d5a-45e1-b03c-30a2fb9f7713.xhtml)中将这个方面添加到了我们的可重用库中，*解决横切关注点*。当你运行代码时，你会在`Debug`文件夹中找到一个`Logs`文件夹。在记事本中打开`Profile.log`文件，你会看到以下输出：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output shows that the `ProblemCode.IntegerSquaredSum()` method was the slowest
    version, taking **548.9** nanoseconds to run. And that the `RefactoredCode.IntegerSquaredSum()`
    method was much faster, taking only **2.7** nanoseconds to run.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示`ProblemCode.IntegerSquaredSum()`方法是最慢的版本，运行时间为**548.9**纳秒。而`RefactoredCode.IntegerSquaredSum()`方法要快得多，只需要**2.7**纳秒。
- en: By refactoring the loop to use LINQ, we avoided mutating a local variable. And
    we also reduced the time it took to process the calculation by **546.2** nanoseconds.
    Such a small improvement is not noticeable to the human eye. But if you perform
    such calculations on big data, then you will experience a noticeable difference.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重构循环使用LINQ，我们避免了对本地变量的变异。我们还减少了处理计算所需的时间**546.2**纳秒。这样微小的改进对人眼来说并不明显。但如果你在大数据上执行这样的计算，那么你会体验到明显的差异。
- en: We'll now discuss the oddball solution.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论奇异解决方案。
- en: The oddball solution
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 奇异解决方案
- en: When you see a problem solved in a different way throughout the source code,
    this is known as an **oddball solution**. This can happen because of different
    programmers having their own style of programming, and no standards being put
    in place. It can also happen through ignorance of the system, in that the programmer
    does not realize a solution already exists.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在源代码中看到以不同方式解决问题时，这被称为**奇异解决方案**。这可能是因为不同的程序员有他们自己的编程风格，没有制定标准。也可能是由于对系统的无知，即程序员没有意识到已经存在一个解决方案。
- en: A way to refactor oddball solutions is to write a new class that encompasses
    the behavior that is being repeated in different ways. Add the behavior to the
    class in the cleanest way that is the most performant. Then, replace the oddball
    solutions with the newly refactored behavior.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重构奇怪的解决方案的一种方法是编写一个新类，其中包含以不同方式重复的行为。以最高效的方式将行为添加到类中。然后，用新重构的行为替换奇怪的解决方案。
- en: 'You can also unite different system interfaces using the **Adapter Pattern**:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用**适配器模式**来统一不同的系统接口：
- en: '![](img/4139a381-b2cd-40a3-a22f-c7ec6fd8ad68.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4139a381-b2cd-40a3-a22f-c7ec6fd8ad68.png)'
- en: 'The `Target` class is the domain-specific interface that is used by `Client`.
    An existing interface that needs adapting is called `Adaptee`. The `Adapter` class
    adapts the `Adaptee` class to the `Target` class. And finally, the `Client` class
    communicates objects that conform to the `Target` interface. Let''s implement
    the adapter pattern. Add a new class called `Adaptee`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Target`类是由`Client`使用的特定于域的接口。需要适应的现有接口称为`Adaptee`。`Adapter`类将`Adaptee`类适配到`Target`类。最后，`Client`类通信符合`Target`接口的对象。让我们实现适配器模式。添加一个名为`Adaptee`的新类：'
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Adaptee` class is very simple. It contains a method called `AdapteeOperation()`
    that prints out a message to the console. Now add the `Target` class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Adaptee`类非常简单。它包含一个名为`AdapteeOperation()`的方法，该方法将消息打印到控制台。现在添加`Target`类：'
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Target` class is also very simple and contains a virtual method called
    `Operation()` that prints out a message to the console. We''ll now add the `Adapter`
    class that wires `Target` and `Adaptee` together:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Target`类也非常简单，包含一个名为`Operation()`的虚方法，该方法将消息打印到控制台。现在我们将添加将`Target`和`Adaptee`连接在一起的`Adapter`类：'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Adapter` class inherits the `Target` class. We then create a member variable
    to hold our `Adaptee` object and initialize it. We then have a single method that
    is the overridden `Operation()` method of the `Target` class. Finally, we will
    add our `Client` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Adapter`类继承了`Target`类。然后我们创建一个成员变量来保存我们的`Adaptee`对象并对其进行初始化。然后我们有一个单一方法，即`Target`类的重写`Operation()`方法。最后，我们将添加我们的`Client`类：'
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Client` class has a single method called `Operation()`. This method creates
    a new `Adapter` object and assigns it to a `Target` variable. It then calls the
    `Operation()` method on the `Target` variable. If you call a new `Client().Operation()` method
    and run the code, you will see the following output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client`类有一个名为`Operation()`的方法。此方法创建一个新的`Adapter`对象并将其分配给`Target`变量。然后调用`Target`变量上的`Operation()`方法。如果调用`new
    Client().Operation()`方法并运行代码，您将看到以下输出：'
- en: '![](img/37077c85-28de-4054-bffa-13dd96722844.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37077c85-28de-4054-bffa-13dd96722844.png)'
- en: You can see from the screenshot that the method that gets executed is the `Adaptee.AdapteeOperation()`
    method. Now that you have successfully learned how to implement the adapter pattern
    to solve oddball solutions, we will move on to look at shotgun surgery.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从屏幕截图中看到执行的方法是`Adaptee.AdapteeOperation()`方法。现在您已成功学会了如何实现适配器模式来解决奇怪的解决方案，我们将继续看散弹手术。
- en: Shotgun surgery
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 散弹手术
- en: Making a single change that requires changes to multiple classes is known as
    **shotgun surgery**. This can sometimes be down to excessive refactoring of code
    due to divergent changes being encountered. This code smell increases the propensity
    for introducing bugs such as those caused by a missed chance. You also increase
    the possibility of merge conflicts, because the code needs to change in so many
    areas that programmers end up stepping on each other's toes. The code is that
    convoluted that it induces cognitive overload in programmers. And new programmers
    have a steep learning curve because of the nature of the software.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 进行单个更改需要对多个类进行更改被称为**散弹手术**。这有时是由于代码过多重构导致遇到不同变化而产生的。这种代码异味增加了引入错误的倾向，例如由于错过机会而导致的错误。您还增加了合并冲突的可能性，因为代码需要在许多领域进行更改，程序员最终会互相干扰。代码如此复杂，以至于会导致程序员的认知负荷过重。新程序员由于软件的性质而面临陡峭的学习曲线。
- en: The version control history will provide a history of the changes made to the
    software over time. This can help you identify all the areas that are changed,
    every time a new piece of functionality is added or when a bug is encountered.
    Once these areas have been identified, then you can look to move the changes to
    a more localized area of the code base. This way, when a change is required, you
    only have to focus on one area of the program and not many areas. This makes the
    maintenance of the project a lot easier.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制历史将提供随时间对软件所做更改的历史记录。这可以帮助您识别每次添加新功能或遇到错误时所更改的所有区域。一旦确定了这些区域，那么您可以考虑将更改移动到代码库的更局部的区域。这样，当需要进行更改时，您只需专注于程序的一个区域，而不是许多区域。这使得项目的维护变得更加容易。
- en: Duplicate code is a good candidate for refactoring into a single class that
    is appropriately named, and that is placed in the correct namespace. Also, consider
    all the different layers of your application. Are they really necessary? Can things
    be simplified? In a database-driven application, is it really necessary to have
    DTOs, DAOs, domain objects, and the like? Could database access be simplified
    in any way? These are just some ideas for reducing the size of the code base,
    and so reducing the number of areas that must be modified to effect a change.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的代码是重构为一个适当命名的单个类的良好候选，并放置在正确的命名空间中。还要考虑应用程序的所有不同层。它们真的有必要吗？事情可以简化吗？在基于数据库的应用程序中，真的有必要拥有DTO、DAO、领域对象等吗？数据库访问可以以任何方式简化吗？这些只是一些减少代码库大小的想法，从而减少必须修改以实现更改的区域数量。
- en: 'Other things to look at are the level of coupling and cohesion. Coupling needs
    to be kept to an absolute minimum. One way to accomplish this is to inject dependencies
    via constructors, properties, and methods. The injected dependencies would be
    of a specific interface type. We will code a simple example. Add an interface
    called `IService`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其他要考虑的是耦合度和内聚度。耦合度需要保持在绝对最低限度。实现这一点的一种方法是通过构造函数、属性和方法注入依赖项。注入的依赖项将是特定接口类型。我们将编写一个简单的示例。添加一个名为`IService`的接口：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The interface contains a single method called `Operation()`. Now, add a class
    called `Dependency` that implements `IService`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接口包含一个名为`Operation()`的方法。现在，添加一个实现`IService`的类`Dependency`：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Dependency` class implements the `IService` interface. In the `Operation()`
    method, a message is printed to the console. Now let''s add the `LooselyCoupled`
    class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dependency`类实现了`IService`接口。在`Operation()`方法中，向控制台打印了一条消息。现在让我们添加`LooselyCoupled`类：'
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the constructor takes a type of `IService` and stores it in
    a member variable. The call to `DoWork()` calls the `Operation()` method within
    the `IService` type. The `LooselyCoupled` class is just that loosely coupled,
    and it is easy to test.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，构造函数接受`IService`类型并将其存储在成员变量中。对`DoWork()`的调用调用`IService`类型内的`Operation()`方法。`LooselyCoupled`类就是松耦合的，很容易测试。
- en: By reducing coupling, you make classes easier to test. By removing code that
    does not belong in a class and placing it where it does belong, you improve the
    readability, maintainability, and extensibility of the application. You lessen
    the learning curve for anyone coming on board, and there is less chance of introducing
    bugs when you perform maintenance or new development.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过减少耦合度，使类更容易测试。通过删除不属于类的代码并将其放在应该属于的地方，可以提高应用程序的可读性、可维护性和可扩展性。您减少了任何新人上手的学习曲线，并且在进行维护或新开发时减少了引入错误的机会。
- en: Let's now have a look at solution sprawl.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下解决方案扩散。
- en: Solution sprawl
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案扩散
- en: The single responsibility that is implemented within different methods, classes,
    and even libraries suffer from solution sprawl. This can make code really hard
    to read and understand. The result is that code becomes harder to maintain and
    extend.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同方法、类甚至库中实现的单一责任会导致解决方案扩散。这会使代码变得非常难以阅读和理解。结果是代码变得更难维护和扩展。
- en: To fix the problem, move the implementation of the single responsibility into
    the same class. This way the code is in just one location and does what it needs
    to. This makes code easy to read and understand. The result is that the code can
    be easily maintained and extended.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决问题，将单一责任的实现移入同一类中。这样，代码就只在一个位置，做它需要做的事情。这样做使得代码易于阅读和理解。结果是代码可以很容易地维护和扩展。
- en: Uncontrolled side effects
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不受控制的副作用
- en: Uncontrolled side effects are those issues that raise their ugly heads in production
    because the quality assurance tests are unable to capture them. When you encounter
    these problems, the only option you have is to refactor the code so that it is
    fully testable and variables can be viewed during debugging to make sure they
    are set appropriately.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 不受控制的副作用是那些在生产中出现的问题，因为质量保证测试无法捕捉到它们。当遇到这些问题时，您唯一的选择就是重构代码，使其完全可测试，并且在调试期间可以查看变量，以确保它们被适当设置。
- en: An example is passing values by reference. Imagine two threads passing a person
    object by reference to a method that modifies the person object. A side effect
    is that unless proper locking mechanisms are in place, each thread can modify
    the other thread's person object invalidating the data. You saw an example of
    mutable objects in [Chapter 8](21b5d748-3720-4bea-a03c-5420862c01b3.xhtml), *Threading
    and Concurrency*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是通过引用传递值。想象两个线程通过引用将一个人的对象传递给修改人的对象的方法。一个副作用是，除非有适当的锁定机制，否则每个线程都可以修改另一个线程的人的对象，使数据无效。您在[第8章](21b5d748-3720-4bea-a03c-5420862c01b3.xhtml)中看到了可变对象的一个例子，*线程和并发*。
- en: That concludes our look at application-level code smells. So, now we will move
    on to look at class-level code smells.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对应用级代码异味的讨论。现在，我们将继续看一下类级代码异味。
- en: Class-level code smells
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类级代码异味
- en: Class-level code smells are localized problems with the class in question. The
    kinds of problems that can plague a class are things like cyclomatic complexity
    and depth of inheritance, high coupling, and low cohesion. Your aim when writing
    a class is to keep it small and functional. The methods in the class should actually
    be there, and they should be small. Only do in the class what needs to be done
    – no more, no less. Work to remove class dependency and make your classes testable.
    Remove code that should be placed elsewhere to where it belongs. In this section,
    we address class-level code smells and how to refactor them, starting with cyclomatic
    complexity.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 类级代码异味是与所讨论的类有关的局部问题。可能困扰类的问题包括圈复杂度和继承深度、高耦合度和低内聚度。编写类时的目标是保持其小而功能齐全。类中的方法应该确实存在，并且应该很小。在类中只做需要做的事情
    - 不多，也不少。努力消除类的依赖性，并使您的类可测试。将应该放在其他地方的代码移除到它应该属于的地方。在本节中，我们将解决类级代码异味以及如何重构它们，从圈复杂度开始。
- en: Cyclomatic complexity
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 圈复杂度
- en: When a class has a large number of branches and loops, it has an increased cyclomatic
    complexity. Ideally, the code should have a cyclomatic complexity value of *between
    1 and 10*. Such code is simple and without risks. Code with a cyclomatic complexity
    of 11-20 is complex but low risk. When the cyclomatic complexity of the code is
    between 21-50, then the code requires attention as it is too complex and poses
    a medium risk to your project. And if the code has a cyclomatic complexity of
    more than 50, then such code is high risk and is not testable. A code that has
    a value above 50 must be refactored immediately.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类有大量的分支和循环时，它的圈复杂度会增加。 理想情况下，代码的圈复杂度值应该在*1到10之间*。 这样的代码简单且没有风险。 圈复杂度为11-20的代码复杂但风险较低。
    当代码的圈复杂度在21-50之间时，代码需要关注，因为它太复杂并对项目构成中等风险。 如果代码的圈复杂度超过50，则这样的代码是高风险的，无法进行测试。 圈复杂度超过50的代码必须立即进行重构。
- en: The goal of refactoring will be to get the cyclomatic value down to between
    1-10\. Start by replacing `switch` statements followed by `if` expressions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重构的目标是将圈复杂度值降低到1-10之间。 首先，通过替换`switch`语句后跟`if`表达式来开始。
- en: Replacing switch statements with the factory pattern
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用工厂模式替换`switch`语句
- en: 'In this section, you will see how to replace a `switch` statement with the
    factory pattern. First, we will need a report enum:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将看到如何用工厂模式替换`switch`语句。 首先，我们需要一个报告枚举：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `[Flags]` attribute enables us to extract the name of the enum. The `Report`
    enum provides a list of reports. Now let''s add our `switch` statement:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Flags]`属性使我们能够提取枚举的名称。 `Report`枚举提供了报告列表。 现在让我们添加我们的`switch`语句：'
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our method accepts a report and then decides on what report to execute. When
    I started off in 1999 as a junior VB6 programmer, I was responsible for building
    a report generator from scratch for the likes of Thomas Cook, ANZ, BNZ, Vodafone,
    and a few other big concerns. There were many reports, and I was responsible for
    writing a case statement that was massive that dwarfed this one. But my system
    worked really well. However, by today's standards, there are much better ways
    of performing this same code and I would do things very differently.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法接受一个报告，然后决定执行什么报告。 当我1999年作为初级VB6程序员开始时，我负责为Thomas Cook，ANZ，BNZ，Vodafone和其他一些大公司构建了一个报告生成器。
    有很多报告，我负责编写一个庞大的case语句，使得这个case语句相形见绌。 但我的系统运行得非常好。 但是，按照今天的标准，有更好的方法来执行相同的代码，我会做一些非常不同的事情。
- en: 'Let''s use the factory method to run our reports without using a `switch` statement.
    Add a file called `IReportFactory` as shown:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用工厂方法来运行我们的报告，而不使用`switch`语句。 添加一个名为`IReportFactory`的文件，如下所示：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `IReportFactory` interface only has one method called `Run()`. This method
    will be used by the implementing classes to run their reports. We''ll only add
    one report class, called `StaffShiftPatternReport`, which implements `IReportFactory`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`IReportFactory`接口只有一个名为`Run()`的方法。 实现类将使用此方法来运行其报告。 我们只添加一个名为`StaffShiftPatternReport`的报告类，它实现了`IReportFactory`：'
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `StaffShiftPatternReport` class implements the `IReportFactory` interface.
    The implemented `Run()` method prints a message to the screen. Add a report called
    `ReportRunner`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaffShiftPatternReport`类实现了`IReportFactory`接口。 实现的`Run()`方法在屏幕上打印一条消息。 添加一个名为`ReportRunner`的报告：'
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ReportRunner` class has a method called `RunReport`. It accepts a parameter
    of type `Report`. With `Report` being an enum with the `[Flags]` attribute, we
    can obtain the name of the `report` enum. We use this to build the name of the
    report. Then, we use the `Activator` class to create an instance of the report.
    If the `reportName` returns null when getting the type, `InvalidOperationException`
    is thrown. The factory is cast to the `IReportFactory` type. We then call the
    `Run` method on the factory to generate the report.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReportRunner`类有一个名为`RunReport`的方法。 它接受一个类型为`Report`的参数。 由于`Report`是带有`[Flags]`属性的枚举，我们可以获取`report`枚举的名称。
    我们使用这个名称来构建报告的名称。 然后，我们使用`Activator`类来创建报告的实例。 如果在获取类型时`reportName`返回null，则抛出`InvalidOperationException`。
    工厂被转换为`IReportFactory`类型。 然后我们调用工厂上的`Run`方法来生成报告。'
- en: This code is definitely much better than a very long `switch` statement. We
    need to know how to improve the readability of conditional checks within an `if`
    statement. We'll look at that next.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码绝对比一个非常长的`switch`语句要好得多。 我们需要知道如何提高`if`语句中条件检查的可读性。 我们接下来会看一下。
- en: Improving the readability of conditional checks within an if statement
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高`if`语句中条件检查的可读性
- en: 'The `if` statements can break the single responsibility and the open/closed
    principles. See the following example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句可能会违反单一职责和开闭原则。 请参阅以下示例：'
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `GetReport()` class has three responsibilities: the staff joiners report,
    the staff leavers report, and the balance sheet report. This breaks the SRP because
    the method should only be concerned with HR reports and it is returning HR and
    Finance reports. As far as the open/closed principle is concerned, every time
    a new report is needed we will have to extend this method. Let''s refactor the
    method so we no longer need the `if` statement. Add a new class called `ReportBase`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetReport()`类有三个职责：员工入职报告，员工离职报告和资产负债表报告。 这违反了SRP，因为该方法应该只关心HR报告，但它返回HR和财务报告。
    就开闭原则而言，每次需要新报告时，我们都必须扩展此方法。 让我们重构该方法，以便不再需要`if`语句。 添加一个名为`ReportBase`的新类：'
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `ReportBase` class is an abstract class with an abstract `Print()` method.
    We will add the `NewStartersReport` class, which inherits the `ReportBase` class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReportBase`类是一个带有抽象`Print()`方法的抽象类。 我们将添加`NewStartersReport`类，它继承了`ReportBase`类：'
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `NewStartersReport` class inherits the `ReportBase` class and overrides
    the `Print()` method. The `Print()` method prints a message to the screen. Now,
    we will add the `LeaversReport` class, which is pretty much the same:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewStartersReport`类继承了`ReportBase`类并重写了`Print()`方法。 `Print()`方法在屏幕上打印一条消息。
    现在，我们将添加`LeaversReport`类，它几乎相同：'
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `LeaversReport` inherits the `ReportBase` class and overrides the `Print()`
    method. The `Print()` method prints a message to the screen. We can now call the
    reports as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: “LeaversReport”继承了“ReportBase”类并重写了“Print()”方法。“Print()”方法向屏幕打印一条消息。现在我们可以这样调用报告：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Both reports inherit the `ReportBase` class, and so can be instantiated and
    assigned to a `ReportBase` variable. The `Print()` method can then be called on
    the variable, and the correct `Print()` method will be executed. The code now
    adheres to the single responsibility principle and the open/closed principle.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 两个报告都继承了“ReportBase”类，因此可以被实例化并分配给“ReportBase”变量。然后可以在变量上调用“Print()”方法，并且将执行正确的“Print()”方法。现在的代码遵循了单一责任原则和开闭原则。
- en: The next thing we will look at is a divergent change code smell.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一看分歧变化代码异味。
- en: Divergent change
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分歧变化
- en: When you need to make a change in one location and find yourself having to change
    many unrelated methods, then this is known as a **divergent change**. Divergent
    changes take place within a single class and are the result of a poor class structure.
    Copying and pasting code is another reason this problem arises.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在一个位置进行更改，并发现自己不得不更改许多不相关的方法时，这被称为**分歧变化**。分歧变化发生在单个类中，是糟糕的类结构的结果。复制和粘贴代码是导致此问题出现的另一个原因。
- en: To fix the problem, move the code causing the problem to its own class. If the
    behavior and state are shared between classes, then consider implementing inheritance
    using base classes and subclasses as appropriate.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决问题，将导致问题的代码移动到自己的类中。如果行为和状态在类之间共享，则考虑使用适当的基类和子类来实现继承。
- en: The benefits of fixing divergent change-related problems include easier maintenance,
    as changes will be located within a single location. This makes supporting the
    application a whole load easier. It also removes duplicate code from the system,
    which just so happens to be the next thing we will be discussing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 修复分歧变化相关问题的好处包括更容易的维护，因为更改将位于单个位置。这使得支持应用程序变得更加容易。它还从系统中删除了重复的代码，这恰好是我们接下来将讨论的内容。
- en: Downcasting
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向下转型
- en: When a base class is cast to one of its children, this is known as **downcasting**.
    This is clearly a code smell as the base class should not know about the classes
    that inherit it. For example, consider the `Animal` base class. Any type of animal
    can inherit the base class. But an animal can only be of one type. For example,
    felines are felines and canines are canines. It would be absurd to cast a feline
    to a canine and vice versa.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当基类被转换为其子类之一时，这被称为**向下转型**。这显然是一种代码异味，因为基类不应该知道继承它的类。例如，考虑“Animal”基类。任何类型的动物都可以继承基类。但动物只能是一种类型。例如，猫科动物是猫科动物，犬科动物是犬科动物。将猫科动物转换为犬科动物，反之亦然，是荒谬的。
- en: It is even more absurd to downcast an animal to one of its subtypes. That would
    be like saying a monkey is the same as a camel and is really good at transporting
    humans and cargo long distances through the desert. This just does not make sense.
    And so, you should never be downcasting. The upcasting of various animals such
    as monkeys and camels to the type `Animal` is valid because felines, canines,
    monkeys, and camels are all types of animals.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将动物向下转型为其子类型甚至更加荒谬。这就像说猴子和骆驼是一样的，非常擅长通过沙漠长距离运输人类和货物。这是毫无意义的。因此，您永远不应该进行向下转型。将各种动物（如猴子和骆驼）向上转型为类型“Animal”是有效的，因为猫科动物、犬科动物、猴子和骆驼都是动物的类型。
- en: Excessive literal use
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过度使用文字
- en: When using literals, it is very easy to introduce coding errors. An example
    would be a spelling mistake in a string literal. It is best to assign literals
    to constant variables. String literals should be placed in resource files for
    localization. Especially if you plan to deploy your software to different locations
    around the world.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用文字时，很容易引入编码错误。一个例子是字符串文字中的拼写错误。最好将文字文字分配给常量变量。字符串文字应放在资源文件中以进行本地化。特别是如果您计划将软件部署到世界各地的不同位置。
- en: Feature envy
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特征嫉妒
- en: 'When a method spends more time processing source code in classes other than
    the one that it is in, this is known as **feature envy**. We will see an example
    of this in our `Authorization` class. But before we do, let''s have a look at
    our `Authentication` class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法在除了它自己所在的类之外的其他类中花费更多时间处理源代码时，这被称为**特征嫉妒**。我们将在我们的“授权”类中看到这样的例子。但在我们这样做之前，让我们来看看我们的“认证”类：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our `Authentication` class is responsible for logging people in and out, as
    well as identifying whether they are authenticated or not. Add our `Authorization`
    class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“认证”类负责登录和注销用户，以及确定他们是否经过身份验证。添加我们的“授权”类：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see with our `Authorization` class, it is doing more than it is supposed
    to. There is one method that validates whether the user is authorized to carry
    a role. The role passed in is checked to see whether it is the administrator role.
    If it is, then the person is authorized. But if the role is not the administrator
    role, then the person is not authorized.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在我们的“授权”类中所看到的，它所做的事情远远超出了它应该做的范围。有一个方法用于验证用户是否被授权承担某个角色。传入的角色将被检查，以确定它是否是管理员角色。如果是，那么该人被授权。但如果角色不是管理员角色，那么该人就没有被授权。
- en: 'However, if you look at the other methods, they are doing no more than calling
    the same methods in the `Authentication` class. So, in the context of this class,
    the authentication methods are an example of feature envy. Let''s remove the feature
    envy from the `Authorization` class:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您看一下其他方法，它们所做的不过是调用“认证”类中的相同方法。因此，在这个类的上下文中，认证方法是特征嫉妒的一个例子。让我们从“授权”类中移除特征嫉妒：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You will see that the `Authorization` class is a lot smaller now, and only does
    what it needs to. There is no longer any feature envy.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现“授权”类现在要小得多，只做了它需要做的事情。不再有特征嫉妒。
- en: Next up, we will look at an inappropriate intimacy code smell.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一看不适当的亲密关系代码异味。
- en: Inappropriate intimacy
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不适当的亲密关系
- en: A class engages in inappropriate intimacy when it relies on the implementation
    details held in a separate class. Does the class that has this reliance really
    need to exist? Can it be merged with the class that it relies on? Or is there
    shared functionality that is better off being extracted into its own class?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类依赖于另一个类中保存的实现细节时，它就会参与不恰当的亲密关系。这种依赖的类真的需要存在吗？它能否与它所依赖的类合并？或者有没有共享功能最好被提取到自己的类中？
- en: Classes should not rely on each other as this causes coupling, and it can also
    affect cohesion. A class should ideally be self-contained. And classes should
    really know as little about each other as possible.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 类不应该相互依赖，因为这会导致耦合，并且也会影响内聚性。一个类理想上应该是自包含的。类应该尽可能少地了解彼此。
- en: Indecent exposure
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不检点的暴露
- en: When a class reveals its internal details, this is known as **indecent exposure**.
    This breaks the OOP principle of *encapsulation*. Only that which should be public
    should be public. All other implementations that don't need to be public should
    be hidden by using the appropriate access modifiers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类暴露其内部细节时，这被称为**不检点的暴露**。这违反了面向对象编程的**封装**原则。只有应该是公共的才应该是公共的。所有不需要公开的实现都应该通过适当的访问修饰符进行隐藏。
- en: Data values should not be public. They should be private, and they should only
    be modifiable via constructors, methods, and properties. And they should only
    be retrievable via properties.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 数据值不应该是公共的。它们应该是私有的，只能通过构造函数、方法和属性进行修改。它们只能通过属性进行检索。
- en: The large class (aka the God object)
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大类（又名上帝对象）
- en: The large class, also known as the `God` object, is all things to all parts
    of the system. It is a large, unwieldy class that simply does far too much. When
    you attempt to read the object, the intent of the code may be clear when you read
    the class name and see what namespace it is in, but then when you come to look
    at the code, the intent of the code can become lost.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 大类，也被称为“上帝”对象，对系统的所有部分都是一切。它是一个庞大而笨重的类，做了太多的事情。当你尝试阅读对象时，当你读到类名并看到它所在的命名空间时，代码的意图可能是清晰的，但当你来看代码时，代码的意图可能会变得模糊。
- en: A well-written class should have the name of its intent and should be placed
    in the appropriate namespace. The contents of the class should follow the company
    coding standards. Methods should be kept as small as possible, and method parameters
    should be kept to the absolute bare minimum. Only the methods that belong in the
    class should be in the class. Member variables, properties, and methods that don't
    belong in the class should be removed and placed in the correct files in the correct
    namespace.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个写得好的类应该有其意图的名称，并且应该放在适当的命名空间中。类的内容应该遵循公司的编码标准。方法应该尽可能保持小，方法参数应该尽可能保持绝对最少。只有属于类的方法应该在类中。不属于类的成员变量、属性和方法应该被移除，并放在正确的文件和正确的命名空间中。
- en: To keep classes small and focused, don't inherit classes if there is no need.
    If there is a class that has five methods, and you will only ever use one of them,
    is it possible to move that method out into its own reusable class? Remember the
    single responsibility principle. A class should only have a single responsibility.
    For example, a file class should only handle operations and behaviors associated
    with files. A file class should not be performing database operations. You get
    the idea.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持类的小型和专注，如果没有必要，就不要继承类。如果有一个类有五个方法，而你只会使用其中一个，那么是否可能将该方法移出到自己可重用的类中？记住单一职责原则。一个类应该只有一个职责。例如，文件类应该只处理与文件相关的操作和行为。文件类不应该执行数据库操作。你明白了。
- en: When writing a class, your aim is to make it as small, clean, and readable as
    you can.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写一个类时，你的目标是使它尽可能小，干净和可读。
- en: The lazy class (aka the freeloader and the lazy object)
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒惰类（又名搭便车和懒惰对象）
- en: A **freeloading** class is one that hardly does anything to be useful. When
    you encounter such classes, you can merge their contents with other classes that
    have the same kind of intentions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**搭便车**的类几乎没有任何用处。当你遇到这样的类时，你可以将它们的内容与具有相同意图的其他类合并。
- en: You can also attempt to collapse the inheritance hierarchy. Remember that the
    ideal depth of inheritance is *1*. And so, if your classes have a larger value
    for their depth of inheritance, then they are good candidates for moving back
    up the inheritance tree. You may also want to consider using inline classes for
    really small classes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试折叠继承层次结构。记住，理想的继承深度是*1*。因此，如果你的类的继承深度较大，那么它们是将向上移动继承树的良好候选者。你可能还想考虑使用内联类来处理非常小的类。
- en: The middleman class
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间人类
- en: The middleman class does no more than delegate functionality to other objects.
    In situations like this, you can get rid of the middleman and deal with the objects
    that carry out the responsibility directly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 中间人类只是将功能委托给其他对象。在这种情况下，你可以摆脱中间人，直接处理负责的对象。
- en: Also, remember that you need to keep the depth of inheritance down. So if you
    cannot get rid of the class, look to merge it with existing classes. Look at the
    overall design of that area of code. Could it all be refactored in some way to
    reduce the amount of code and the number of different classes?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，你需要保持继承深度。所以如果你不能摆脱这个类，就要考虑将它与现有的类合并。看看代码区域的整体设计。是否可以以某种方式重构所有代码，以减少代码量和不同类的数量？
- en: The orphan class of variables and constants
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量和常量的孤立类
- en: It is not really good practice to have a lone class that holds variables and
    constants for multiple different parts of the application. When you encounter
    such a situation, it can be hard for the variables to have any real meaning and
    their context can be lost. It is better to move constants and variables to areas
    that use them. If constants and variables will be used by multiple classes, then
    they should be assigned to a file within the root of the namespace they will be
    used in.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个独立的类来保存应用程序多个不同部分的变量和常量并不是一个好的做法。当你遇到这种情况时，变量可能很难有任何真正的含义，它们的上下文可能会丢失。最好将常量和变量移动到使用它们的地方。如果常量和变量将被多个类使用，那么它们应该分配给命名空间根目录中的一个文件。
- en: Primitive obsession
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始偏执
- en: Source code that uses primitive values rather than objects for certain tasks
    such as range values and formatted strings such as credit cards, postcodes, and
    phone numbers suffers from primitive obsession. Other signs include constants
    used for field names, and information stored inappropriately stored in constants.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码使用原始值而不是对象来执行某些任务，比如范围值和格式化字符串，比如信用卡、邮政编码和电话号码，这就是原始偏执。其他迹象包括用于字段名称的常量，以及不适当存储在常量中的信息。
- en: Refused bequest
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拒绝遗赠
- en: When a class inherits from another class but does not use all its methods, then
    this is known as **refused bequest**. A common reason for this happening is when
    the subclass is completely different from the base class. For example, a `building`
    base class is used by different building types, but then a `car` object inherits
    `building` because it has properties and methods to do with windows and doors.
    This is clearly wrong.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类继承自另一个类，但不使用其所有方法时，这被称为**拒绝遗赠**。发生这种情况的常见原因是子类与基类完全不同。例如，一个`building`基类被不同的建筑类型使用，但然后一个`car`对象继承`building`，因为它具有与窗户和门相关的属性和方法。这显然是错误的。
- en: When you encounter this, consider whether a base class is necessary. If it is,
    then create one and then inherit from it. Otherwise, add the functionality to
    the class that was inherited from the wrong type.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到这种情况时，考虑是否需要一个基类。如果需要，那么创建一个，然后从中继承。否则，将功能添加到从错误类型继承的类中。
- en: Speculative generality
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投机泛化
- en: A class that is programmed with functionality that is not needed now but may
    beneeded in the future is suffering from speculative generality. Such code is
    dead code and adds maintenance overhead as well as code bloat. It is best to remove
    these classes when you see them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类被编程为具有现在不需要但将来可能需要的功能，这就是投机泛化。这样的代码是死代码，会增加维护开销和代码膨胀。最好在发现这些类时将其删除。
- en: Tell, Don't Ask
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 告诉，不要问
- en: The *Tell, Don't Ask* software principle informs us as programmers that we are
    to bundle data with the methods that will operate on that data. Our objects must
    not ask for data and then operate on it! They must tell the logic of an object
    to perform a specific task on that object's data.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*告诉，不要问*软件原则告诉我们作为程序员，我们应该将数据与将操作该数据的方法捆绑在一起。我们的对象不应该要求数据然后对其进行操作！它们必须告诉对象的逻辑在对象的数据上执行特定任务。'
- en: If you find objects that contain logic and that ask other objects for data to
    carry out their operations, then combine the logic and the data into a single
    class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现包含逻辑并要求其他对象提供数据来执行其操作的对象，那么将逻辑和数据合并到一个类中。
- en: Temporary fields
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时字段
- en: Temporary fields are member variables that are not needed for an object's entire
    lifetime.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 临时字段是不需要在对象的整个生命周期中的成员变量。
- en: You can perform refactoring by removing the temporary fields and the methods
    that operate upon them to their own class. You will end up with clearer code that
    is well organized.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将临时字段和操作它们的方法移除到它们自己的类中来进行重构。你最终会得到更清晰、更有组织的代码。
- en: Method-level smells
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法级别的异味
- en: Method-level code smells are problems within the method itself. Methods are
    the work-horses that either make software function well or poorly. They should
    be well organized and do only what they are expected to do—no more and no less.
    It is important to know the kinds of problems and issues that can arise because
    of poorly constructed methods. We will address what to look out for in terms of
    method-level code smells, and what we can do to address them. We'll start with
    the black sheep method first.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 方法级别的代码异味是方法本身的问题。方法是使软件功能良好或糟糕的工作马。它们应该组织良好，只做它们预期要做的事情——不多也不少。了解由于构造不良的方法可能出现的问题和问题的种类是很重要的。我们将讨论在方法级别的代码异味方面要注意的问题，以及我们可以做些什么来解决它们。我们将首先从黑羊方法开始。
- en: The black sheep method
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑羊方法
- en: Out of all the methods in the class, a black sheep method will be noticeably
    different. When you encounter a black sheep method, you must consider the method
    objectively. What is its name? What is the method's intent? When you have answered
    these questions, then you can decide to remove the method and place it where it
    truly belongs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中的所有方法中，黑羊方法将明显不同。当你遇到黑羊方法时，你必须客观地考虑这个方法。它的名字是什么？方法的意图是什么？当你回答了这些问题，然后你可以决定删除这个方法，并将它放在它真正属于的地方。
- en: Cyclomatic complexity
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 圈复杂度
- en: When a method has too many loops and branches, this is known as cyclomatic complexity.
    This code smell is also a class-level code smell, and we have already seen how
    we can reduce the problems with branching when we looked at replacing `switch`
    and `if` statements. As for loops, they can be replaced with LINQ statements.
    LINQ statements have the added benefit of being a functional code since LINQ is
    a functional query language.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法有太多的循环和分支时，这被称为圈复杂度。这种代码异味也是一个类级别的代码异味，我们已经看到了如何在替换`switch`和`if`语句时可以减少分支的问题。至于循环，它们可以被替换为LINQ语句。LINQ语句的额外好处是它是一个函数式代码，因为LINQ是一个函数式查询语言。
- en: Contrived complexity
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人为复杂
- en: When a method is unnecessarily complex and can be simplified, this complexity
    is termed contrived complexity. Simplify the method to make sure that its contents
    are human-readable and understandable. Then, look to refactor the method and reduce
    the size to the smallest number of lines that is practical.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法不必要地复杂并且可以简化时，这种复杂性被称为人为复杂性。简化方法以确保其内容是人类可读和可理解的。然后，尝试重构方法并将其大小减小到实际可行的最小行数。
- en: Dead code
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死代码
- en: When a method exists but is not used, this is known as dead code. The same goes
    for constructors, properties, parameters, and variables. They should be identified
    and removed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在但未被使用的方法时，这被称为死代码。构造函数、属性、参数和变量也是如此。它们应该被识别并移除。
- en: Excessive data return
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过多的数据返回
- en: When a method returns more data than is needed by each client that calls it,
    this code smell is known as excessive data return. Only the data that is required
    should be returned. If you find that there are groups of objects with different
    requirements, then you should maybe consider writing different methods that appeal
    to both groups and only return what is necessary to those groups.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法返回的数据比每个调用它的客户端所需的数据更多时，这种代码异味被称为过多的数据返回。应该只返回所需的数据。如果发现有不同要求的对象组，那么可能需要考虑编写不同的方法，以满足两组的需求，并且只返回对这些组有必要的数据。
- en: Feature envy
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特性嫉妒
- en: A method that has feature envy spends more time accessing data in other objects
    than it does in its own object. We have already seen this in action when we looked
    at feature envy under class-level code smells.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 特性嫉妒的方法花费更多时间访问其他对象中的数据，而不是在自己的对象中。当我们在类级别代码异味中看到特性嫉妒时，我们已经看到了这一点。
- en: A method should be kept small, and most of all, its main functionality should
    be localized to that method. If it is doing more in other methods than its own,
    then there is scope for moving some of the code out of the method and into its
    own method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 方法应该保持小巧，最重要的是，其主要功能应该局限于该方法。如果它在其他方法中做的事情比自己的方法还多，那么就有可能将一些代码从该方法中移出并放入自己的方法中。
- en: Identifier size
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标识符大小
- en: Identifiers can be either too short or too long. Identifiers should be descriptive
    and succinct. The main thing to consider when naming variables is the context
    and location. In a localized loop, a single letter may be appropriate. But if
    the identifier is at the class level, then it will need a human-understandable
    name to give it context. Avoid using names that lack context, and that are ambiguous
    or cause confusion.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符可能太短或太长。标识符应该具有描述性和简洁性。在命名变量时要考虑的主要因素是上下文和位置。在局部循环中，一个字母可能是合适的。但如果标识符在类级别，那么它将需要一个人能理解的名称来给它上下文。避免使用缺乏上下文、模糊或引起混淆的名称。
- en: Inappropriate intimacy
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不恰当的亲密性
- en: Methods that rely too heavily on implementation details in other methods or
    classes display inappropriate intimacy. These methods need to be refactored and
    possibly even removed. The main thing to bear in mind is that the methods use
    the internal fields and methods of another class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 过于依赖其他方法或类中的实现细节的方法显示出不恰当的亲密性。这些方法需要被重构，甚至可能被移除。要牢记的主要事情是这些方法使用另一个类的内部字段和方法。
- en: To perform refactoring, you can move the methods and fields to where they actually
    need to be used. Alternatively, you can extract the fields and methods into a
    class of their own. Inheritance can replace delegation when the subclass is being
    intimate with the superclass.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行重构，您可以将方法和字段移动到实际需要使用它们的地方。或者，您可以将字段和方法提取到它们自己的类中。当子类与超类亲密关联时，继承可以取代委托。
- en: Long lines (aka God lines)
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长行（又称上帝行）
- en: Long lines of code can be very hard to read and decipher. This makes it difficult
    for programmers to debug and refactor such code. Where it is possible, the line
    can be formatted so that any periods and any code after a comma appears on a new
    line. But such code should also be refactored to make it small.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 长行代码很难阅读和解释。这使得程序员很难调试和重构这样的代码。在可能的情况下，可以格式化该行，使得任何句点和逗号后的代码出现在新行上。但这样的代码也应该被重构成更小的代码。
- en: Lazy methods
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒惰的方法
- en: A lazy method is one that does very little work. It may delegate its work to
    other methods, and it may simply call a method on another class that does what
    it is supposed to. If any of these are the case, then it may pay to get rid of
    the methods and place code within the methods where it is needed. You could, for
    instance, use an inline function such as a lambda.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰的方法是指做很少工作的方法。它可能将工作委托给其他方法，也可能只是调用另一个类的方法来完成它应该完成的工作。如果有任何这些情况，那么可能需要摆脱这些方法，并将代码放在需要的方法中。例如，您可以使用内联函数，比如lambda。
- en: Long methods (aka God methods)
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长方法（又称上帝方法）
- en: A long method is one that has outgrown itself. Such methods may lose their intent
    and perform more tasks than they are expected to. You can use the IDE to select
    parts of the method, and then select extract method or extract class to move portions
    of the method to their own method and even their own class. A method should only
    be responsible for doing a single task.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 长方法是指已经超出自身范围的方法。这样的方法可能会失去其意图，并执行比预期更多的任务。您可以使用IDE选择方法的部分，然后选择提取方法或提取类，将方法的部分移动到自己的方法甚至自己的类中。方法应该只负责执行单一任务。
- en: Long parameter lists (aka too many parameters)
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长参数列表（又称参数过多）
- en: Three or more parameters are classed as the long parameter list code smell.
    You can tackle this problem by replacing the parameters with a method call. An
    alternative is to replace the parameters with a parameter object.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 三个或更多参数被归类为长参数列表代码异味。您可以通过用方法调用替换参数来解决这个问题。另一种方法是用参数对象替换参数。
- en: Message chains
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息链
- en: A message chain occurs when a method calls an object that calls another object
    that calls another object and so on. Previously, you saw how to deal with message
    chains when we looked at the Law of Demeter. Message chains break this law, as
    a class should only communicate with its nearest neighbor. Refactor the classes
    to move the required state and behavior closer to where it is needed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法调用一个对象，该对象调用另一个对象，依此类推时，就会出现消息链。之前，我们在看到迪米特法则时已经了解了如何处理消息链。消息链违反了这个法则，因为一个类只应该与其最近的邻居通信。重构类，将所需的状态和行为移动到需要它的地方。
- en: The middleman method
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间人方法
- en: When all a method does is delegate work out to others to complete, it is a middleman
    method and can be refactored and removed. But if there is functionality that can't
    be removed, then merge it in the area that it is being used in.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法的全部工作只是委托给其他人完成时，它就是一个中间人方法，可以进行重构和删除。但如果有功能无法删除，那么将其合并到使用它的区域。
- en: Oddball solutions
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 古怪解决方案
- en: When you see multiple methods doing the same thing but doing it differently,
    then this is an oddball solution. Choose the method that best implements the task,
    and then replace the method calls to the other methods with calls to the best
    method. Then, delete the other methods. This will leave only one method and one
    way of implementing the task that can be reused.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当看到多个方法做同样的事情但以不同的方式时，这就是一个古怪的解决方案。选择最好实现任务的方法，然后将对其他方法的调用替换为对最佳方法的调用。然后，删除其他方法。这将只留下一个方法和一种可以重复使用的实现任务的方法。
- en: Speculative generality
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推测性泛化
- en: A method that is not used anywhere in the code is known as a speculative generality
    code smell. It is essentially dead code, and all dead code should be removed from
    the system. Such code provides a maintenance overhead and also provides unnecessary
    code bloat.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在代码中没有被使用的方法被称为推测性泛化代码异味。它本质上是死代码，所有死代码都应该从系统中删除。这样的代码会增加维护成本，也会提供不必要的代码膨胀。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have been introduced to a variety of code smells and how
    to remove them through refactoring. We have stated that there are application-level
    code smells that permeate throughout all the layers of the application, class-level
    code smells that run throughout the class, and method-level code smells that affect
    the individual methods.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了各种代码异味以及如何通过重构来消除它们。我们已经指出，有应用级别的代码异味渗透到应用程序的所有层，类级别的代码异味贯穿整个类，方法级别的代码异味影响个别方法。
- en: First of all, we covered the application-level code smells, which consisted
    of Boolean blindness, combinatorial explosion, contrived complexity, data clump,
    deodorant comments, duplicate code, lost intent, mutation of variables, oddball
    solutions, shotgun surgery, solution sprawl, and uncontrolled side effects.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们讨论了应用级别的代码异味，其中包括布尔盲目、组合爆炸、人为复杂、数据团、除臭剂注释、重复代码、意图丢失、变量突变、古怪解决方案、散弹手术、解决方案蔓延和不受控制的副作用。
- en: We then went on to look at class-level code smells, including cyclomatic complexity,
    divergent change, downcasting, excessive literal use, feature envy, inappropriate
    intimacy, indecent exposure, and the large object, also known as the God object.
    We also covered the lazy class, also known as the freeloader and the lazy object;
    middleman; orphan classes of variables and constants; primitive obsession; refused
    bequest; speculative generality; Tell, Don't Ask; and temporary fields.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续查看类级别的代码异味，包括圈复杂度、分歧变更、向下转型、过多的文字使用、特性嫉妒、不当亲密、不检狂露和大对象，也称为上帝对象。我们还涵盖了懒惰类，也称为吃白食者和懒惰对象；中间人；变量和常量的孤立类；原始偏执；拒绝继承；推测性泛化；告诉，不要问；和临时字段。
- en: Finally, we moved on to method-level code smells. We discussed black sheep;
    cyclomatic complexity; contrived complexity; dead code; feature envy; identifier
    size; inappropriate intimacy; long lines, also known as the God lines; the lazy
    method; the long method, also known as the God method; the long parameter list,
    also known as too many parameters; message chains; middleman; oddball solutions;
    and speculative generality.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们转向了方法级别的代码异味。我们讨论了黑羊；圈复杂度；人为复杂；死代码；特性嫉妒；标识符大小；不当亲密；长行，也称为上帝行；懒惰方法；长方法，也称为上帝方法；长参数列表，也称为参数过多；消息链；中间人；古怪解决方案；和推测性泛化。
- en: In the next chapter, we will be continuing our look at code refactoring with
    the use of ReSharper.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续使用ReSharper来查看代码重构。
- en: Questions
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the three main categories of code smell?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码异味的三个主要类别是什么？
- en: Name the different types of application-level code smells.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名不同类型的应用级代码异味。
- en: Name the different types of class-level code smells.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名不同类型的类级别代码异味。
- en: Name the different types of method-level code smells.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名不同类型的方法级代码异味。
- en: What kinds of refactoring are you able to perform in order to clean up various
    code smells?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以执行哪些重构以清理各种代码异味？
- en: What is cyclomatic complexity?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是圈复杂度？
- en: How can we overcome cyclomatic complexity?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何克服圈复杂度？
- en: What is contrived complexity?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是人为复杂？
- en: How can we overcome contrived complexity?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何克服人为复杂？
- en: What is a combinatorial explosion?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是组合爆炸？
- en: How do we overcome a combinatorial explosion?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何克服组合爆炸？
- en: What should you do when you find deodorant comments?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发现除臭剂注释时，你应该怎么办？
- en: If you have bad code but don't know how to fix it, what should you do?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有糟糕的代码但不知道如何修复，你应该怎么办？
- en: What is a good place to ask questions and get answers when it comes to programming
    issues?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理编程问题时，哪里是提问和获取答案的好地方？
- en: In what ways can a long parameter list be reduced?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何减少长参数列表？
- en: How can a large method be refactored?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何重构一个大方法？
- en: What is the maximum length for a clean method?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个干净方法的最大长度是多少？
- en: Within what range of numbers should your program's cyclomatic complexity be?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的程序的圈复杂度应该在什么范围内？
- en: What is the ideal depth of inheritance value?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承深度的理想值是多少？
- en: What is speculative generality and what should you do about it?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是投机泛化，以及你应该怎么做？
- en: If you encounter an oddball solution, what course of action should you take?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你遇到一个奇怪的解决方案，你应该采取什么行动？
- en: What refactorings would you perform if you encountered a temporary field?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你遇到一个临时字段，你会进行哪些重构？
- en: What is a data clump, and what should you do about it?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是数据团，以及你应该怎么做？
- en: Explain the refused bequest code smell.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释拒绝遗赠的代码异味。
- en: What law do message chains break?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息链违反了什么法则？
- en: How should message chains be refactored?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息链应该如何重构？
- en: What is feature envy?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是特征嫉妒？
- en: How do you remove feature envy?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何消除特征嫉妒？
- en: What pattern can you use to replace `switch` statements that return objects?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用什么模式来替换返回对象的`switch`语句？
- en: How can we replace `if` statements that return objects?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何替换返回对象的`if`语句？
- en: What is solution sprawl, and what can be done to tackle it?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是解决方案蔓延，以及可以采取什么措施来解决它？
- en: Explain the Tell, don't ask! principle.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释“告诉，不要问！”原则。
- en: How does the Tell, don't ask! principle get broken?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “告诉，不要问！”原则是如何被打破的？
- en: What are the symptoms of shotgun surgery, and how should they be addressed?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 霰弹手术的症状是什么，应该如何解决？
- en: Explain lost intent and what can be done about it.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释失去意图以及可以采取的措施。
- en: How can loops be refactored, and what benefits do the refactorings bring?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环可以如何重构，重构会带来什么好处？
- en: What is a divergent change, and how would you go about refactoring it?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是分歧变化，你会如何重构它？
- en: Further reading
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Refactoring - Improving the Design of Existing Code* by Martin Fowler and
    Kent Beck.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重构-改善现有代码的设计* by Martin Fowler and Kent Beck.'
- en: '[https://refactoring.guru/refactoring](https://refactoring.guru/refactoring):
    A good site on design patterns and code smells.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://refactoring.guru/refactoring](https://refactoring.guru/refactoring)：一个关于设计模式和代码异味的好网站。'
- en: '[https://www.dofactory.com/net/design-patterns](https://www.dofactory.com/net/design-patterns):
    A very good C#-based site on various design patterns.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.dofactory.com/net/design-patterns](https://www.dofactory.com/net/design-patterns)：一个关于各种设计模式的非常好的基于C#的网站。'
