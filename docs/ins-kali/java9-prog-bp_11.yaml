- en: DeskDroid - A Desktop Client for Your Android Phone
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DeskDroid-用于Android手机的桌面客户端
- en: We've come at long last to our final project. To close our time together here,
    we're going to build a very practical application, one that lets us send and receive
    SMS messages from the comfort of our desktop. There are a number of products on
    the market that let you do this now, but they typically require a third-party
    service, meaning your message travels through someone else's servers. For the
    privacy-minded, that can be a real problem. We'll build a system that is 100%
    local.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于来到了我们的最终项目。为了结束我们在这里的时光，我们将构建一个非常实用的应用程序，让我们可以在桌面上轻松发送和接收短信。现在市场上有许多产品可以做到这一点，但它们通常需要第三方服务，这意味着您的消息会通过其他人的服务器传输。对于注重隐私的人来说，这可能是一个真正的问题。我们将构建一个100%本地的系统。
- en: 'Building the app will cover several different topics, some familiar, some new.
    That list includes the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序将涵盖几个不同的主题，有些熟悉，有些新的。该列表包括以下内容：
- en: Android applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android应用程序
- en: Android services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android服务
- en: REST servers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST服务器
- en: Server-sent events for event/data streaming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器发送事件以进行事件/数据流式传输
- en: Data access using Content Providers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内容提供程序访问数据
- en: There will also be a host of other, smaller tidbits along the way as we finish
    out our time together on a strong, high note.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们一起度过美好时光的过程中，还会有许多其他小细节。
- en: Getting started
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'This project will have two parts:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将有两个部分：
- en: The Android application/server (not to be confused with application server,
    of course)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android应用程序/服务器（当然不要与应用服务器混淆）
- en: The desktop/JavaFX application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面/JavaFX应用程序
- en: The desktop piece is somewhat useless without the **server** piece, so we'll
    start by building the Android side first.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面部分没有服务器部分就有点无用，所以我们将首先构建Android端。
- en: Creating the Android project
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Android项目
- en: While we have been using NetBeans for most of our work so far, we will again
    use Android Studio for this piece of the project. While there is some semblance
    of Android support for NetBeans, as of this writing, the project seems to have
    stalled. Android Studio, on the other hand, is very actively developed by Google
    and is, in fact, the official IDE for Android development. I will leave it as
    an exercise for the reader, if needed, to install the IDE and the SDK.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然到目前为止我们大部分工作都在使用NetBeans，但我们将再次使用Android Studio进行项目的这一部分。虽然NetBeans对Android有一定程度的支持，但截至目前，该项目似乎已经停滞不前。另一方面，Android
    Studio由Google积极开发，并且实际上是Android开发的官方IDE。如果需要，我将把安装IDE和SDK留给读者作为练习。
- en: 'To create a new project, we click on File | New Project, and specify Application
    name, Company domain, and Project location, as shown in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新项目，我们点击文件|新项目，并指定应用程序名称，公司域和项目位置，如下面的屏幕截图所示：
- en: '![](img/d5460c89-dad0-4a38-bd46-cf3412578f90.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5460c89-dad0-4a38-bd46-cf3412578f90.png)'
- en: 'Next, we need to specify the API version we want to target. This can be a tricky
    choice. On the one hand, we''d like to be on the cutting edge and have all of
    the great new features that Android offers available to us, but on the other hand,
    we don''t want to target such a new API level that we make the application unusable
    (read uninstallable) for a larger number of Android users than is necessary. In
    this case, Android 6.0, or Marshmallow, seems like an acceptable trade-off:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要指定要针对的API版本。这可能是一个棘手的选择。一方面，我们希望站在最前沿，并且拥有Android提供的所有出色的新功能，但另一方面，我们不希望针对一个如此新的API级别，以至于我们使应用程序对更多的Android用户而言无法使用（即无法卸载）。在这种情况下，Android
    6.0，或者说Marshmallow，似乎是一个可以接受的折衷方案：
- en: '![](img/0b9dd275-5991-41e4-be74-a93968b89653.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b9dd275-5991-41e4-be74-a93968b89653.png)'
- en: Click on Next, select Blank Activity, Next, and Finish, and our project is ready
    for development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步，选择空白活动，下一步，完成，我们的项目已准备好开发。
- en: On the Android side, we are not going to do much in the way of user interface.
    Once we have finished the project, you will likely have all sorts of ideas of
    what could be done, which is great, but we won't spend the time here doing any
    of those. That said, the first thing we really need to do is ask the user for
    permission to access the text messages on their phone.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android端，我们不会在用户界面方面做太多工作。一旦我们完成了项目，您可能会有各种各样的想法，这很好，但我们不会在这里花时间去做任何事情。也就是说，我们真正需要做的第一件事是请求用户权限以访问他们手机上的短信。
- en: Requesting permissions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求权限
- en: 'In earlier versions of Android, permissions were an all or nothing proposition.
    Starting with Android 6, though, the user is prompted for each permission that
    the application requests, allowing for the possibility of a user to grant some
    permissions while denying others. We will need to request some permissions--we
    need to be able to read and write SMS messages, and we''ll need access to the
    contacts (so we can try to figure out who sent us a given message). Android provides
    an API for requesting those permissions very easily, which we''ll put in our `onCreate()`
    method, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在较早的Android版本中，权限是一种全有或全无的提议。但是，从Android 6开始，用户将被提示应用程序请求的每个权限，从而允许用户在拒绝其他权限的同时授予某些权限的可能性。我们需要请求一些权限--我们需要能够读取和写入短信，还需要访问联系人（这样我们就可以尝试弄清楚谁给我们发送了某条消息）。Android提供了一个非常容易请求这些权限的API，我们将把它放在我们的`onCreate()`方法中，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When this preceding code runs, Android will prompt the user to grant or deny
    the requested permissions. This is done asynchronously, so, in your applications,
    you need to make sure you don't attempt any operation that requires any permission
    that you request until the user has had a chance to grant the permission (and,
    should the user deny the permission, the application should degrade, or fail,
    gracefully).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当上述代码运行时，Android将提示用户授予或拒绝请求的权限。这是异步完成的，因此在您的应用程序中，您需要确保在用户有机会授予权限之前，不要尝试执行任何需要您请求的权限的操作（并且，如果用户拒绝权限，则应用程序应该优雅地降级或失败）。
- en: 'To allow the application to respond to permission grants, Android provides
    a callback. In our callback, we want to make sure the user grants us both permissions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许应用程序响应权限授予，Android提供了一个回调。在我们的回调中，我们希望确保用户授予我们两个权限：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When Android calls back in to our application, we need to make sure that the
    `requestCode` is what we specified-- `PERMISSION_REQUEST_CODE`--to make sure that
    we only respond to our own requests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当Android回调到我们的应用程序时，我们需要确保`requestCode`是我们指定的--`PERMISSION_REQUEST_CODE`--以确保我们只响应我们自己的请求。
- en: Once we've identified an appropriate response, we make sure that `grantResults`
    is the correct length, and that each entry is `PERMISSION_GRANTED`. If the array
    is too short, or if either array element is not the correct type, we display a
    dialog informing the user that both permissions are required, and then exit the
    application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了适当的响应，我们确保`grantResults`的长度是正确的，并且每个条目都是`PERMISSION_GRANTED`。如果数组太短，或者任一数组元素不是正确的类型，我们会显示一个对话框，通知用户需要两个权限，然后退出应用程序。
- en: In our example, we are requesting both permissions simultaneously, so we respond
    to both simultaneously. If you have a complex set of permissions, for example,
    if your application can work with only some of the requested permissions, you
    can make multiple calls to `ActivityCompat.requestPermissions`, providing a distinct
    `requestCode` for each. You would then need to expand your switch block in `onRequestPermissionsResult()`
    to cover each new `requestCode`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们同时请求两个权限，因此我们同时响应两个权限。如果您有一组复杂的权限，例如，如果您的应用程序只能使用请求的某些权限，您可以多次调用`ActivityCompat.requestPermissions`，为每个请求提供一个不同的`requestCode`。然后，您需要扩展`onRequestPermissionsResult()`中的switch块，以涵盖每个新的`requestCode`。
- en: 'One final word on permissions. Typically, you should always check to make sure
    that you have the permission needed to perform a given task. You can do that with
    a method as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于权限的一句话。通常情况下，您应该始终检查是否具有执行给定任务所需的权限。您可以使用以下方法来做到这一点：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our case, we just don't allow the application to run if we aren't granted
    the required permissions, so we need not worry about additional permission checks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，如果没有被授予所需的权限，我们就不允许应用程序运行，因此我们不需要担心额外的权限检查。
- en: Creating the service
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务
- en: The heart of the Android portion of the project is our REST endpoints. We would
    like these endpoints to be available whenever the phone is on, so we can't use
    an `Activity` to host them. What we want is a `Service`. The Android documentation
    defines a `Service` as *an application component that can perform long-running
    operations in the background, and it does not provide a user interface*. There
    are three types of Services--`scheduled` (which runs on a schedule), `started`
    (which can be started explicitly by another application component), and `bound`
    (which is bound to an application component via the `bindService()` call, and
    runs until all the bound components are destroyed). Since we want this to be available
    all the time, we want a started service.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的Android部分的核心是我们的REST端点。我们希望这些端点在手机开启时可用，因此我们不能使用`Activity`来托管它们。我们需要的是一个`Service`。Android文档将`Service`定义为*可以在后台执行长时间操作的应用程序组件，并且不提供用户界面*。有三种类型的服务--`scheduled`（按计划运行），`started`（可以由另一个应用程序组件显式启动），和`bound`（通过`bindService()`调用绑定到应用程序组件，并在所有绑定的组件被销毁之前运行）。由于我们希望这个服务一直可用，我们需要一个已启动的服务。
- en: 'To create the service, click on File | New | Service | Service. Enter `DeskDroidService`
    for the service, uncheck Exported, and click on Finish. That will get you the
    following stubbed code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务，点击文件 | 新建 | 服务 | 服务。输入`DeskDroidService`作为服务，取消选中Exported，然后点击完成。这将为您提供以下存根代码：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The wizard also updates `AndroidManifest.xml` as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 向`AndroidManifest.xml`中添加以下内容：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The method `onBind()` is abstract, so it must be implemented. We are not creating
    a bound service, so we can leave this unimplemented, although we will change it
    so that it returns `null` rather than throwing an `Exception`. We are, though,
    interested in when the service is started and stopped, so we need to override
    these two relevant lifecycle methods:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`onBind()`是抽象的，因此必须实现。我们不创建绑定服务，所以我们可以将其保持未实现，尽管我们将更改它以返回`null`而不是抛出异常。然而，我们对服务何时启动和停止感兴趣，因此我们需要重写这两个相关的生命周期方法：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s in these methods that we''ll place our REST service code. We will once
    again use Jersey, the JAX-RS reference implementation, which provides a nice way
    of bootstrapping a server in a Java SE environment, such as what we find ourselves
    in here in our Android application. We''ll encapsulate that logic in a new method
    called `startServer()` as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方法中，我们将放置我们的REST服务代码。我们将再次使用Jersey，JAX-RS的参考实现，它提供了一种在Java SE环境中引导服务器的好方法，例如我们在Android应用程序中发现的环境。我们将把这个逻辑封装在一个名为`startServer()`的新方法中，如下所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first thing we do is check to make sure that we're on Wi-Fi. This isn't
    strictly necessary, but it seemed to be a prudent precaution to prevent the application
    from listening for connections, regardless of the network state. If the phone
    is not on Wi-Fi, there's a good chance the intended laptop is not either. There
    may be legitimate use cases for allowing the endpoints to listen even on a cellular
    network, however. Making this restriction configurable is a great candidate for
    a preferences-driven option.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是检查确保我们在Wi-Fi上。这并非绝对必要，但似乎是一个谨慎的预防措施，以防止应用程序监听连接，无论网络状态如何。如果手机不在Wi-Fi上，那么预期的笔记本电脑也很可能不在。然而，允许端点即使在蜂窝网络上也监听可能存在合法的用例。使这种限制可配置是一个很好的首选项驱动选项。
- en: 'For this code to work, we need to add this new permission to the manifest:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这段代码工作，我们需要将这个新的权限添加到清单中：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once we're sure that we're on Wi-Fi, we look up our IP address, and bootstrap
    a Jetty-based Jersey server. With a nod to the Venerable Commodore 64, for those
    of us old enough to remember that computing pioneer, we listen on port `49152`
    on the Wi-Fi network interface.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定我们在Wi-Fi上，我们查找我们的IP地址，并引导一个基于Jetty的Jersey服务器。向值得尊敬的Commodore 64致敬，对于我们中年人来说，我们在Wi-Fi网络接口的端口`49152`上监听。
- en: Next, we create a `ResourceConfig` instance, providing two feature references
    that we're interested in--`SseFeature` and `JacksonFeature`. We've already seen
    `JacksonFeature`; that's what lets us work with POJOs, leaving the JSON concerns
    to Jersey. What is `SseFeature`, though?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`ResourceConfig`实例，提供我们感兴趣的两个特性引用--`SseFeature`和`JacksonFeature`。我们已经见过`JacksonFeature`；这就是让我们能够使用POJOs，将JSON问题留给Jersey的功能。但`SseFeature`是什么呢？
- en: Server-sent events
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器发送事件
- en: SSE, or server-sent events, is a means by which we can stream data from the
    server to the client. Typically, a REST request is very short-lived--make a connection,
    send the request, get a response, close the connection. Sometimes, though, the
    REST server may not have all of the data that the client wants at the time of
    the request (for example, reading data from another data source such as a log
    file or network socket). So, it would be nice to be able to push that data to
    the client as it becomes available. That's exactly what SSE allows us to do. We'll
    look into that in more detail later.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SSE，或者服务器发送事件，是一种我们可以从服务器向客户端流式传输数据的方式。通常，REST请求的生命周期非常短暂--建立连接，发送请求，获取响应，关闭连接。然而，有时REST服务器可能在请求时没有客户端想要的所有数据（例如，从另一个数据源读取数据，比如日志文件或网络套接字）。因此，能够在数据可用时将数据推送到客户端将是很好的。这正是SSE允许我们做的。我们稍后会更详细地研究这个问题。
- en: 'Finally, we start the server instance with a call to `JettyHttpContainerFactory.createServer()`.
    Since we need to be able to stop the server later, we capture the server instance,
    and store it in an instance variable. We call `startServer()` from `onStartCommand()`
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`JettyHttpContainerFactory.createServer()`来启动服务器实例。由于我们需要能够稍后停止服务器，我们捕获服务器实例，并将其存储在一个实例变量中。我们从`onStartCommand()`中调用`startServer()`如下：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we've wrapped our call to `startServer()` in a `synchronized` block.
    For those that might be unaware, `synchronized` is one of the more basic approaches
    to concurrent code available to Java developers. The net effect of this keyword
    is that multiple threads that try to execute this block of code must do so synchronously,
    or one a time. We do this here so that if we have two different processes attempting
    to start the server, we can guarantee that at most one is running. Without this
    block, the first thread could start the server and store the instance in the variable,
    while a second thread could do the same thing, but its server instance, which
    gets stored in the variable, fails to start. We would now have a running server
    with no valid reference to it, so we would be unable to stop it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将对`startServer()`的调用包装在一个`synchronized`块中。对于可能不知道的人来说，`synchronized`是Java开发人员可以使用的更基本的并发代码方法之一。这个关键字的净效果是，试图执行这个代码块的多个线程必须同步执行，或者一个接一个地执行。我们这样做是为了确保如果有两个不同的进程尝试启动服务器，我们可以保证最多只有一个正在运行。如果没有这个块，第一个线程可能会启动服务器并将实例存储在变量中，而第二个线程可能会做同样的事情，但它的服务器实例存储在变量中，却无法启动。现在我们有一个正在运行的服务器，却没有有效的引用，所以我们无法停止它。
- en: We have also registered a `BroadcastReceiver` that listens for `CODE_GENERATED`.
    We'll come back and explain this later in the chapter, so don't worry about this
    for now.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注册了一个监听`CODE_GENERATED`的`BroadcastReceiver`。我们稍后会回来解释这一点，所以现在不用担心这个。
- en: Controlling the service state
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制服务状态
- en: 'If we run the application now, our service won''t run, so we need to make it
    such that it will run. We''ll do that in a couple of different ways. The first
    way will be from our application. We want to make sure the service is running
    when we open the application, especially after it is just installed. To do that,
    we need to add one line to `MainActivity.onCreate()` as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，我们的服务不会运行，所以我们需要使它能够运行。我们将以几种不同的方式来做到这一点。第一种方式将是从我们的应用程序。我们希望确保在打开应用程序时服务正在运行，特别是在刚安装完应用程序后。为了做到这一点，我们需要在`MainActivity.onCreate()`中添加一行如下：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the application is started now, it will guarantee that the service is
    running. We don''t, though, want to require that the user open the application
    to run the service. Fortunately, we have a way to start the application when the
    phone starts. We can do that by installing a `BroadcastReceiver` that listens
    for boot events, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序启动时，它将保证服务正在运行。然而，我们不希望要求用户打开应用程序来运行服务。幸运的是，我们有一种方法可以在手机启动时启动应用程序。我们可以通过安装一个监听引导事件的`BroadcastReceiver`来实现，如下所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The body of the preceding method is identical to our recent addition to `MainActivity`.
    We do, though, need to register the service, and ask for permission. In `AndroidManifest.xml`,
    we need to add this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的主体与我们最近添加到`MainActivity`的内容相同。但是，我们需要注册服务，并请求权限。在`AndroidManifest.xml`中，我们需要添加这个：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now have a service that starts either at device boot or application startup.
    It does not, however, do anything of interest, so we need to add some endpoints
    to our server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个服务，它可以在设备启动或应用程序启动时启动。然而，它并没有做任何有趣的事情，所以我们需要向服务器添加一些端点。
- en: Adding endpoints to the server
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向服务器添加端点
- en: 'As covered in [Chapter 9](../Text/50fd66f8-4865-4bc4-afdc-39f8cd5bf4f0.xhtml),
    *Taking Notes with Monumentum*, a JAX-RS resource lives in a POJO with certain
    annotations. To stub out our endpoint class, we can start with this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第9章](../Text/50fd66f8-4865-4bc4-afdc-39f8cd5bf4f0.xhtml)中所述，*使用Monumentum做笔记*，JAX-RS资源位于带有特定注解的POJO中。为了存根我们的端点类，我们可以从这里开始：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will also need to register this class with JAX-RS, which we do with this
    line in `startServer()`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在JAX-RS中注册这个类，我们在`startServer()`中这样做：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Ordinarily, we would pass, say, `DeskDroidResource.class`, to the `ResourceConfig`
    constructor, like we did with `JacksonFeature.class`. We will be accessing Android
    resources, and to do that, we're going to need the `Service`'s `Context` instance.
    There are a number of resources on the internet that will suggest creating a custom
    `Application` class and storing it in a `public static`. While that does seem
    to work, it will also leak memory, so, Android Studio, for example, will complain
    if you try that. We can, however, avoid that by using nested classes. That approach
    can get a bit unwieldy, but our classes should be small enough that it remains
    manageable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们会将`DeskDroidResource.class`传递给`ResourceConfig`构造函数，就像我们使用`JacksonFeature.class`一样。我们将访问Android资源，为此，我们将需要`Service`的`Context`实例。互联网上有很多资源会建议创建一个自定义的`Application`类，并将其存储在`public
    static`中。虽然这似乎可以工作，但它也会泄漏内存，因此，例如，Android Studio会在您尝试这样做时发出警告。然而，我们可以通过使用嵌套类来避免这种情况。这种方法可能有点笨拙，但我们的类应该足够小，以至于它仍然可以管理。
- en: Getting conversations
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取对话
- en: 'Let''s start by adding an endpoint to get all of the conversations on the phone,
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先添加一个端点，以获取手机上的所有对话，如下所示：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here is where we see the Android artifacts start to show up--we are going to
    use a `ContentProvider` to access the SMS data. A `ContentProvider` is a way for
    an application, or, in this case, an Android subsystem, to expose data to outside
    consumers in a portable, storage-agnostic manner. We don't care how the data is
    stored. We simply specify what fields we want, what filters or restrictions we
    want placed on that data, and `ContentProvider` does the rest.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到Android的构件开始出现--我们将使用`ContentProvider`来访问短信数据。`ContentProvider`是应用程序或在这种情况下是Android子系统以一种便携、存储无关的方式向外部消费者公开数据的一种方式。我们不关心数据是如何存储的。我们只是指定我们想要的字段、我们想要放在数据上的过滤器或限制条件，`ContentProvider`就会完成剩下的工作。
- en: Using `ContentProvider`s, we specify the type of data not by a table name, like
    we would with SQL, but with a `Uri`. In this case, we specify `Telephony.Sms.Conversations.CONTENT_URI`.
    We pass several null values to `query()` as well. These represent the projection
    (or field list), the selection (or filter), the selection arguments, and the sort
    order. Since these are all `null`, we want every field and every row in the natural
    sort order for the provider. That gets us a `Cursor` object, which we then iterate
    over, creating `Conversation` objects, and add them to our `List`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ContentProvider`，我们不是通过表名来指定数据类型，就像我们在SQL中那样，而是通过`Uri`来指定。在这种情况下，我们指定`Telephony.Sms.Conversations.CONTENT_URI`。我们也将几个空值传递给`query()`。这些代表投影（或字段列表）、选择（或过滤器）、选择参数和排序顺序。由于这些都是`null`，我们希望提供程序中的每个字段和每一行都按自然排序顺序。这会得到一个`Cursor`对象，然后我们遍历它，创建`Conversation`对象，并将它们添加到我们的`List`中。
- en: 'We create the `Conversation` instances with this method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这种方法创建`Conversation`实例：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Each conversation is just a thread ID, message count, and snippet, which is
    the last message received. To get the actual messages, we call `getSmsMessages()`
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对话只是一个线程ID、消息计数和片段，这是最后收到的消息。要获取实际的消息，我们调用`getSmsMessages()`如下：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This method, and the processing logic, is mostly identical to that for conversations.
    The `Uri` for the `ContentProvider`, `Telephony.Sms.CONTENT_URI`, is different,
    of course, and we specify a filter for the query as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法和处理逻辑与对话的大部分相同。当然，`ContentProvider`的`Uri`，`Telephony.Sms.CONTENT_URI`是不同的，我们为查询指定了一个过滤器，如下所示：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We do have a slight bit of data analysis here. We need to know which of the
    messages are the ones we sent and which are the ones we received so that we can
    display the thread more meaningfully. On the device, the messages we've sent have
    the type `Telephony.Sms.MESSAGE_TYPE_SENT`. The values for this field translate
    roughly to folders (sent, received, draft, and so on). Rather than leaking part
    of the Android API into ours by sharing the value of the constant, we have a `boolean`
    field, `isMine`, which is true if the message is of type `MESSAGE_TYPE_SENT`.
    It is, admittedly, a slightly clumsy alternative, but it works and should be clear
    enough.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有一点数据分析。我们需要知道哪些消息是我们发送的，哪些是我们接收的，以便我们可以更有意义地显示对话。在设备上，我们发送的消息的类型是`Telephony.Sms.MESSAGE_TYPE_SENT`。该字段的值大致对应于文件夹（已发送、已接收、草稿等）。我们没有通过共享常量的值将Android
    API的一部分泄漏到我们的API中，而是有一个`boolean`字段`isMine`，如果消息的类型是`MESSAGE_TYPE_SENT`，则为true。这是一个稍微笨拙的替代方法，但它有效并且应该足够清晰。
- en: Once we return the list of messages, we iterate over the list, getting a list
    of the unique participants (which should be only one, since we are dealing with
    SMS messages).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们返回消息列表，我们遍历列表，获取唯一参与者的列表（应该只有一个，因为我们处理的是短信消息）。
- en: 'Finally, we return this `List<Conversation>` to the client using Jersey''s
    POJO-mapping feature as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用Jersey的POJO映射功能将`List<Conversation>`返回给客户端，如下所示：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/c65074a9-60d0-4ce9-9fbd-cac745d5fae5.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c65074a9-60d0-4ce9-9fbd-cac745d5fae5.png)'
- en: 'If we click either the run or debug buttons (the large triangle or the triangle-over-a-bug
    icons in the tool bar), you''ll be asked for the deployment target, as seen in
    this screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击运行或调试按钮（工具栏中的大三角形或三角形上的带有错误图标），您将被要求选择部署目标，如下截图所示：
- en: '![](img/666baa0f-7732-4d02-9af4-3c0c135d3e34.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/666baa0f-7732-4d02-9af4-3c0c135d3e34.png)'
- en: 'Since we require Wi-Fi, I select my physical device. If you want to configure
    an emulator with Wi-Fi, that would work as well. Click on OK, and after a few
    moments, the application should start on the device you have selected, and we
    can make our first REST request as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要Wi-Fi，我选择了我的物理设备。如果您想配置一个带有Wi-Fi的模拟器，那也可以。点击确定，几秒钟后，应用程序应该在您选择的设备上启动，然后我们可以按照以下方式进行第一个REST请求：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This preceding sample code shows a conversation I'm having with myself. Too
    many late nights, perhaps, but you can see where the first message, the oldest
    message, is marked as mine, which is the one I sent to myself, and the second
    is where I received it back. Pretty cool, but how do you send a message? It turns
    out that that's actually quite simple.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显示了我和自己的对话。也许是太多的深夜，但你可以看到第一条消息，最老的消息，标记为我的，这是我发给自己的，第二条是我收到回复的地方。非常酷，但是如何发送消息呢？事实证明，这实际上非常简单。
- en: Sending an SMS message
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送短信
- en: To send a message, we will create a POST endpoint that takes a `Message` object,
    which we'll then pull apart and pass to Android's telephony APIs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发送消息，我们将创建一个POST端点，该端点接受一个`Message`对象，然后我们将其拆分并传递给安卓的电话API。
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There''s a lot going on this method. Here is the breakdown:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有很多内容。以下是详细说明：
- en: We get a reference to the `SmsManager` class. This class will do all of the
    work for us.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获得了`SmsManager`类的引用。这个类将为我们做所有的工作。
- en: We ask `SmsManager` to divide the message for us. Text messages are, typically,
    limited to 160 characters, so this will split the message as needed.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要求`SmsManager`为我们分割消息。文本消息通常限制在160个字符，所以这将根据需要分割消息。
- en: We create a `CountDownLatch` with a count that matches the number of parts in
    the message.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个与消息中部分数量相匹配的`CountDownLatch`。
- en: We create an `AtomicInteger` to store the status code. As we'll see in a moment,
    we need to change the value of this variable from inside an anonymous class. However,
    for an anonymous class to access variables from its enclosing scope, those variables
    must be `final`, which means that we can not have a `final int`, as then we would
    not be able to change the value. With `AtomicInteger`, though, we can call `set()`
    to change the value while leaving the instance reference, which is what the variable
    will hold, unchanged.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`AtomicInteger`来存储状态码。正如我们将在一会儿看到的，我们需要从匿名类内部改变这个变量的值。然而，匿名类要访问其封闭范围的变量，这些变量必须是`final`的，这意味着我们不能有一个`final
    int`，因为那样我们就无法改变值。不过，使用`AtomicInteger`，我们可以调用`set()`来改变值，同时保持实例引用不变，这就是变量将持有的内容。
- en: We create a new `BroadcastReceiver`, which will handle `Intent`s broadcast (as
    we'll see further) when the message is sent. In `onReceive()`, if the result code
    is not `ACTIVITY.RESULT_OK`, we call `AtomicInteger.set()` to reflect the failure.
    We then call `sentLatch.countDown()` to indicate that this message part has been
    processed.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`BroadcastReceiver`，它将处理消息发送时的`Intent`广播（我们将在后面看到）。在`onReceive()`中，如果结果代码不是`ACTIVITY.RESULT_OK`，我们调用`AtomicInteger.set()`来反映失败。然后我们调用`sentLatch.countDown()`来表示这个消息部分已经被处理。
- en: With the call to `registerReceiver()`, we let the operating system know about
    our new receiver. We provide an `IntentFilter` to restrict which `Intents` our
    receiver has to process.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`registerReceiver()`，我们让操作系统知道我们的新接收器。我们提供一个`IntentFilter`来限制我们的接收器必须处理哪些`Intent`。
- en: We then create a new `PendingIntent` for each part our message has been split
    into. This will allow us to react to each part's send attempt individually.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们为消息的每个部分创建一个新的`PendingIntent`。这将允许我们对每个部分的发送尝试做出反应。
- en: We call `sendMultipartTextMessage()` to send the message part(s). Android handles
    the details of a multipart message for us, so there's no extra effort required.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`sendMultipartTextMessage()`来发送消息的部分。安卓会为我们处理多部分消息的细节，所以不需要额外的努力。
- en: We need to wait for all of the message parts to be sent, so we call `sentLatch.await()`
    to give the system time to send the message. We don't want to wait forever, though,
    so we give it a timeout of five seconds, which should be long enough. It is conceivable
    that some networks may be very slow about sending text messages, so this value
    may need to be adjusted.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要等待所有消息部分被发送，所以我们调用`sentLatch.await()`来给系统发送消息的时间。然而，我们不想永远等下去，所以我们给了它一个五秒的超时时间，这应该足够长了。可以想象，有些网络可能在发送短信方面非常慢，所以这个值可能需要调整。
- en: Once we pass the latch, we `unregister` our receiver, and return the status
    code.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们通过了门闩，我们就`unregister`我们的接收器，并返回状态码。
- en: 'Using curl again, we can now test sending a message (be sure to click on `Run`
    or `Debug` again to deploy your updated code):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用curl，我们现在可以测试发送消息（确保再次点击`Run`或`Debug`来部署您更新的代码）：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding `curl` we send some `lorem ipsum` text to our recipient, which
    gives us a nice, long message (482 total characters for the request payload),
    which is correctly chunked up and sent to the destination phone number, as indicated
    by the `201 Created` response status.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`curl`中，我们向接收者发送了一些`lorem ipsum`文本，这给了我们一个漂亮的、长长的消息（请求负载总共482个字符），这些消息被正确地分块并发送到目标电话号码，正如`201
    Created`响应状态所示。
- en: We now have a working REST service on the phone, which lets us read the existing
    messages and send new ones. Interacting with the service with `curl` has worked
    well enough, but it's time to build our desktop client, and put a nice face on
    this project.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在手机上有一个工作的REST服务，它让我们读取现有的消息并发送新消息。使用`curl`与服务交互已经足够好了，但是现在是时候建立我们的桌面客户端，并为这个项目打造一个漂亮的外观了。
- en: Creating the desktop application
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建桌面应用程序
- en: 'To build our application, we''ll return to NetBeans and JavaFX. As in the previous
    chapters, we''ll create a new Maven-based JavaFX application by clicking on File
    | New Project:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的应用程序，我们将返回NetBeans和JavaFX。和之前的章节一样，我们将通过点击文件|新建项目来创建一个基于Maven的JavaFX应用程序：
- en: '![](img/665acc29-dbe6-41a0-ac15-afcd98ae6b23.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/665acc29-dbe6-41a0-ac15-afcd98ae6b23.png)'
- en: In the next step, call the project `deskdroid-desktop`, verify the package name,
    and click on Finish. While not strictly necessary, let's clean up the naming a
    bit, changing the controller to `DeskDroidController`, and the FXML file to `deskdroid.fxml`.
    We'll also need to modify the references to the FXML and the CSS in the controller,
    and the reference to the controller in the FXML. Click on Run | Run Project to
    make sure everything is wired up correctly. Once the app starts, we can immediately
    close it so we can start making changes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，将项目命名为`deskdroid-desktop`，验证包名称，并单击完成。虽然不是严格必要的，但让我们稍微清理一下命名，将控制器更改为`DeskDroidController`，将FXML文件更改为`deskdroid.fxml`。我们还需要修改控制器中对FXML和CSS的引用，以及在FXML中对控制器的引用。单击运行|运行项目，以确保一切连接正确。一旦应用程序启动，我们可以立即关闭它，以便开始进行更改。
- en: Defining the user interface
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用户界面
- en: 'Let''s start by building up the user interface. Here''s what the application
    will look like:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建用户界面。应用程序将如下所示：
- en: '![](img/c41ac1fa-9371-4d5a-bfe7-26fd8fb937a9.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c41ac1fa-9371-4d5a-bfe7-26fd8fb937a9.png)'
- en: In the preceding screen, we'll have our list of conversations on the left, and
    we will display the selected conversation on the right. We will add a mechanism
    for auto-refreshing, but the Refresh Conversations will allow for a manual refresh,
    if needed. New Message should be self-explanatory.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕中，我们将在左侧显示我们的对话列表，并在右侧显示所选对话。我们将添加一个自动刷新的机制，但如果需要，刷新对话将允许手动刷新。新消息应该是不言而喻的。
- en: 'We can use Gluon''s Scene Builder to build the user interface, of course, but
    let''s take a look at the FXML. We''ll start, as usual, with a `BorderPane`, as
    follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用Gluon的Scene Builder来构建用户界面，但让我们来看看FXML。我们将像往常一样从`BorderPane`开始，如下所示：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the `top` section, we''re going to add a menu bar as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`top`部分，我们将添加一个菜单栏，如下所示：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ll have three `MenuItem`s in the `FileMenu`: `connectToPhone`, `disconnectFromPhone`,
    and `Exit`. Each menu item will have a mnemonic, as indicated by the underscores.
    The `ExitMenuItem` has an accelerator key, `ALT-F4`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FileMenu`中，我们将有三个`MenuItem`：`connectToPhone`，`disconnectFromPhone`和`Exit`。每个菜单项都将有一个助记符，如下划线所示。`ExitMenuItem`有一个加速键`ALT-F4`。
- en: 'We''ll put the bulk of the user interface in the `center` section. The vertical
    split allows us to resize the two sides of the user interface. For that, we use
    a `SplitPane` as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把大部分用户界面放在`center`部分。垂直分割允许我们调整用户界面的两侧。为此，我们使用`SplitPane`如下所示：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With `dividerPositions`, we set the default split at the 25% mark along the
    horizontal rule. The `SplitPane` has a nested `items` element to hold its children
    to which we add the left element, `ListView`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dividerPositions`，我们将默认分割设置为水平规则的25%标记。`SplitPane`有一个嵌套的`items`元素来保存其子元素，我们将左侧元素`ListView`添加到其中：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We wrap `ListView` in a `VBox` to make the `ListView` grow and shrink, as needed,
    more easily.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`ListView`包装在`VBox`中，以便更容易地使`ListView`根据需要增长和收缩。
- en: 'Finally, let''s build the right side of the user interface:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们构建用户界面的右侧：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On the right side, we also have a `VBox`, which we use to arrange our two user
    interface elements. The first is `HBox`, which holds two buttons: Refresh Conversation
    and New Message. The second is our `ListView` for displaying the selected conversation.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，我们还有一个`VBox`，用来安排我们的两个用户界面元素。第一个是`HBox`，其中包含两个按钮：刷新对话和新消息。第二个是我们的`ListView`，用于显示所选对话。
- en: Defining user interface behavior
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用户界面行为
- en: 'While we can define the structure of the user interface in FXML in all but
    the most trivial applications, the user interface still requires some Java code
    to finish defining its behavior. We''ll do that now in `DeskDroidController.initialize()`.
    We''ll start with the left side of the user interface, the conversation list,
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在FXML中定义用户界面的结构，但除了最简单的应用程序外，用户界面仍然需要一些Java代码来完成其行为的定义。我们将在`DeskDroidController.initialize()`中进行。我们将从用户界面的左侧，对话列表开始，如下所示：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We declare an injectable variable to hold a reference to our `ListView`. JavaFX
    will set that value for us, thanks to the annotation `@FXML`. `ListView` will
    need a model to display, which we declare as `conversations`, and we declare `conversation`
    to hold the currently selected conversation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个可注入的变量来保存对我们的`ListView`的引用。JavaFX将为我们设置该值，感谢注解`@FXML`。`ListView`将需要一个要显示的模型，我们将其声明为`conversations`，并声明`conversation`来保存当前选定的对话。
- en: In the `initialize()` method, we wire everything together. Since `ListView`
    will be displaying our domain object, we need to declare a `CellFactory` for it,
    which we do with the lambda passed to `setCellFactory()`. We'll look at `ListCell`
    in a moment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initialize()`方法中，我们将所有内容连接在一起。由于`ListView`将显示我们的领域对象，我们需要为其声明一个`CellFactory`，我们使用传递给`setCellFactory()`的lambda来实现。我们稍后会看一下`ListCell`。
- en: Next, we associate `ListView` with its model, `conversations`, and define what
    is, in effect, an `onClick` listener. We achieve that, though, by adding a listener
    to `SelectionModel` on `ListView`. In that listener, we update the currently selected
    conversation, update the messages `ListView` to display the conversation, and
    scroll that `ListView` to the very bottom so that we see the most recent message.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`ListView`与其模型`conversations`关联，并定义实际上是一个`onClick`监听器。我们通过向`ListView`的`SelectionModel`添加监听器来实现这一点。在该监听器中，我们更新当前选定的对话，更新消息`ListView`以显示对话，并将该`ListView`滚动到最底部，以便看到最近的消息。
- en: 'Initializing the message `ListView` is much simpler. We need these instance
    variables:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化消息`ListView`要简单得多。我们需要这些实例变量：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We also need these lines in `initialize()`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`initialize()`中添加这些行：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And the New Message button needs a handler:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 新消息按钮需要一个处理程序：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`ConversationCell` tells JavaFX how to display a `Conversation` instance. To
    do that, we create a new `ListCell` child as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConversationCell`告诉JavaFX如何显示`Conversation`实例。为此，我们创建一个新的`ListCell`子元素，如下所示：'
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then we override `updateItem()`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们重写`updateItem()`：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the cell is given a `Conversation`, we process it. If not, we set the cell's
    graphic to null. If we fail to do that, we'll have unpredictable results when
    scrolling through the lists.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元格给定了“对话”，我们会处理它。如果没有，我们将单元格的图形设置为null。如果我们无法做到这一点，当浏览列表时，将会产生不可预测的结果。
- en: 'To build the cell contents, we start by getting the `Participant` and creating
    the wrapper component as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建单元格内容，我们首先获取`Participant`，然后创建包装组件，如下所示：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is pretty standard JavaFX fare--create an `HBox`, and add to it an `ImageView`.
    We are, though, using a class we haven't looked at yet--`ConversationService`.
    We'll look at this later, but for now, it's enough to know that we will encapsulate
    our REST calls in this class. Here, we're calling an endpoint (that we haven't
    seen yet) to get the contact information for the phone number at the other end
    of this conversation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当标准的JavaFX内容——创建一个`HBox`，并向其中添加一个`ImageView`。不过，我们使用了一个我们尚未看过的类——`ConversationService`。稍后我们会看到这个，但现在知道我们将在这个类中封装我们的REST调用就足够了。在这里，我们调用一个端点（我们尚未看到的）来获取对话另一端的电话号码的联系信息。
- en: 'We also need to create the conversation snippet as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建对话片段，如下所示：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using `VBox` to ensure vertical alignment, we create two labels, one with the
    participants' information, and the other with the snippet of the conversation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`VBox`来确保垂直对齐，我们创建两个标签，一个包含参与者的信息，另一个包含对话片段。
- en: 'While that finishes the cell definition, if we were to run the application
    the way it is now, the `ListCell`''s contents would likely be cropped by the edge
    of `ListView` itself. For example, see the difference between the top list and
    the bottom list in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这完成了单元格定义，但如果我们现在运行应用程序，`ListCell`的内容可能会被`ListView`本身的边缘裁剪。例如，查看以下截图中顶部列表和底部列表之间的差异：
- en: '![](img/4907b58e-45dd-4ce7-a9e2-b2bb7a4ecef7.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4907b58e-45dd-4ce7-a9e2-b2bb7a4ecef7.png)'
- en: 'To make our `ListCell` behave as we see at the bottom of the last screen, we
    need to make one more change to our code, which is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的`ListCell`的行为与上一个屏幕底部看到的一样，我们需要对我们的代码进行一些更改，如下所示：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In our preceding `CellFactory`, we pass in the reference to the enclosing `ListView`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的`CellFactory`中，我们传入了对封闭`ListView`的引用。
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the constructor, we then bind the preferred width of our cell to the actual
    width of the list (and subtract a small amount to adjust for the control borders).
    When rendered now, our cell will wrap just as we expected.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在构造函数中，我们将单元格的首选宽度绑定到列表的实际宽度（并减去一小部分以调整控件边框）。现在渲染时，我们的单元格将如我们所期望的那样换行。
- en: 'The `MessageCell` definition is similar, and goes as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageCell`的定义类似，如下所示：'
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For *my* message, we create the contents this way:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*我的*消息，我们以这种方式创建内容：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The **message box** is much like the previous conversation snippet--a vertical
    display of the message, followed by its date and time. This format will be used
    by *my* messages and *their* messages, so we use `javafx.geometry.Pos` to align
    the controls to the right or left, respectively.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息框**与之前的对话片段非常相似——消息的垂直显示，后跟其日期和时间。这种格式将被用于*我的*消息和*他们*的消息，因此我们使用`javafx.geometry.Pos`将控件对齐到右侧或左侧。'
- en: 'The *their* message is created this way:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*他们*的消息是这样创建的：'
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is similar to the *my* message, with the exception that we display the
    sender's profile picture, if there is one associated with the contact on the phone,
    which we retrieve from the phone via the `ConversationService` class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这与*我的*消息类似，唯一的区别是，如果与手机上的联系人关联的话，我们会显示发送者的个人资料图片，这些图片是通过`ConversationService`类从手机中检索到的。
- en: 'We have a bit more work to do, but this is what the application will look like
    with data:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有更多的工作要做，但这就是应用程序在有数据时的样子：
- en: '![](img/9bdc898a-39b4-4c3f-9a2c-f2b87babafa9.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bdc898a-39b4-4c3f-9a2c-f2b87babafa9.png)'
- en: 'To get the data, we need a REST client, and that is found in `ConversationService`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取数据，我们需要一个REST客户端，这在`ConversationService`中找到：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using the so-called *Initialize-on-Demand Holder* idiom, we create a sort of
    a poor man''s singleton. Since the constructor is private, it can''t be called
    from outside this class. The nested static class, `LazyHolder`, is initialized
    only when it is finally referenced, which happens on the first call to `getInstance()`.
    Once that method is called, `LazyHolder` is loaded and initialized, at which point,
    the constructor is run. The instance created is stored in the static variable,
    and lives as long as the JVM runs. Every subsequent call will return the same
    instance. This is important for us, as we have some objects that are expensive
    to create as well as some simple caching in the class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所谓的“按需初始化持有者”习语，我们创建了一种贫民的单例。由于构造函数是私有的，因此无法从此类外部调用。嵌套的静态类`LazyHolder`只有在最终被引用时才会被初始化，这发生在第一次调用`getInstance()`时。一旦调用了该方法，`LazyHolder`就会被加载和初始化，此时构造函数会运行。创建的实例存储在静态变量中，并在JVM运行时存在。每次后续调用都将返回相同的实例。这对我们来说很重要，因为我们有一些昂贵的对象需要创建，以及类中的一些简单缓存：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, we initialize our client instance, registering the `JacksonFeature`,
    which gets us the POJO mapping we've already discussed. We also register `SseFeature`,
    a more advanced feature of Jersey that we'll discuss in detail later.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们初始化了客户端实例，注册了`JacksonFeature`，这使我们得到了已经讨论过的POJO映射。我们还注册了`SseFeature`，这是Jersey的一个更高级的功能，我们稍后会详细讨论。
- en: 'We''ve already seen the conversation list. That is generated using data from
    this method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了对话列表。这是使用此方法的数据生成的：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`WebTarget` is a JAX-RS class that represents the *resource target identified
    by the resource URI*. We''re pulling the address for the phone from preferences,
    which we''ll discuss later. Once we have our `WebTarget`, we complete building
    the URI by appending `conversations`, specify the request mime type, and issue
    the `GET` request. Note that our request here is somewhat optimistic, as we don''t
    do any status code checking. Should an `Exception` be thrown, we simply return
    an empty `List`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebTarget`是一个JAX-RS类，表示由资源URI标识的*资源目标*。我们从偏好设置中获取电话地址，稍后我们会讨论这个问题。一旦我们有了我们的`WebTarget`，我们通过附加`conversations`来完成构建URI，指定请求的mime类型，并发出`GET`请求。请注意，我们的请求在这里有点乐观，因为我们没有进行任何状态码检查。如果抛出`Exception`，我们只是返回一个空的`List`。'
- en: 'The other method we''ve seen is `getParticipant()`, which is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的另一个方法是`getParticipant()`，如下所示：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the last method, we see our cache come into play. When a `Participant` is
    requested, we look to see if this information has already been fetched. If so,
    we return the cached information. If not, we can make a request for it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个方法中，我们看到了我们的缓存发挥作用。当请求`Participant`时，我们查看是否已经获取了这些信息。如果是，我们返回缓存的信息。如果没有，我们可以请求它。
- en: Much like `getConversations(),` we build a request for the appropriate endpoint,
    and send the `GET` request. This time, though, we do check for the status code.
    Only if the status is `200 (OK)` do we continue processing the response. In this
    case, we ask JAX-RS for the `Participant` instance returned, which `JacksonFeature`
    happily builds for us from the JSON response body, and which we immediately add
    to our cache.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与`getConversations()`类似，我们为适当的端点构建请求，并发送`GET`请求。不过这次，我们确实检查状态码。只有状态码为`200（OK）`时，我们才继续处理响应。在这种情况下，我们要求JAX-RS返回`Participant`实例，`JacksonFeature`愉快地为我们从JSON响应体中构建，并立即添加到我们的缓存中。
- en: If the server found a thumbnail for the contact, we need to process that. The
    server piece, which we will look at immediately after we finish discussing this
    method, sends the thumbnail as a base 64-encoded string in the body of the JSON
    object, so we convert it back to the binary representation, and save that to a
    file. Notice that we are using try-with-resources, so we need not worry about
    cleaning up after ourselves.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器找到联系人的缩略图，我们需要处理它。服务器部分，我们将在讨论完这个方法后立即查看，将缩略图作为base 64编码的字符串发送到JSON对象的主体中，因此我们将其转换回二进制表示，并将其保存到文件中。请注意，我们使用了try-with-resources，因此我们不需要担心清理工作。
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We haven''t seen the server side of this operation, so let''s look at that
    now. In our Android application in Android Studio, we have this method on `DeskDroidResource`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有看到此操作的服务器端，所以现在让我们来看看。在Android Studio中的我们的Android应用中，我们在`DeskDroidResource`上有这个方法：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We attempt to build the `Participant` instance. If an Exception is thrown, we
    return a `500` (Server Error). If `null` is returned, we return a `404` (Not Found).
    If a participant is found, we return `200` (OK) and the participant.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试构建`Participant`实例。如果抛出异常，我们返回`500`（服务器错误）。如果返回`null`，我们返回`404`（未找到）。如果找到参与者，我们返回`200`（OK）和参与者。
- en: 'To build the participant, we need to query the phone contacts. This works in
    much the same way as the SMS queries:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建参与者，我们需要查询电话联系人。这与短信查询的方式非常相似：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding is the same type of query and cursor management that we saw earlier
    with conversations, but there is one exception. If the contact has a thumbnail,
    the query returns a `Uri` to that image. We can use `ContentResolver` to open
    an `InputStream` using that `Uri` to read the contents, which we load into `ByteArrayOutputStream`.
    Using Android's `Base64` class, we encode this binary image into a `String`, and
    add that to our `Participant` model. We saw the decoding half of this operation
    previously.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的内容与我们之前在对话和游标管理中看到的相同，但有一个例外。如果联系人有缩略图，查询将返回该图像的`Uri`。我们可以使用`ContentResolver`打开一个`InputStream`，使用该`Uri`读取内容，然后将其加载到`ByteArrayOutputStream`中。使用Android的`Base64`类，我们将这个二进制图像编码为一个`String`，并将其添加到我们的`Participant`模型中。我们之前看到了这个操作的解码部分。
- en: Sending messages
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送消息
- en: 'Now that we can see the conversations that we''ve been having, we need to add
    the ability to take part in those conversations--to send new text messages. We''ll
    start on the client. We''ve actually already seen the handler for the `New Message`
    button assigned. It is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到我们一直在进行的对话，我们需要添加参与这些对话的能力--发送新的文本消息。我们将从客户端开始。我们实际上已经看到了分配给`New Message`按钮的处理程序。它如下所示：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'What we need to do now is to look at this `sendNewMessage()` method itself:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要看看这个`sendNewMessage()`方法本身：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The actual dialog is displayed in another window, so we have a separate FXML
    file, `message_dialog.fxml`, and controller, `SendMessageDialogController`. When
    the dialog closes, we check the return `Optional` to see if the user entered a
    message. If so, process the message as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 实际对话显示在另一个窗口中，所以我们有一个单独的FXML文件`message_dialog.fxml`和控制器`SendMessageDialogController`。对话框关闭时，我们检查返回的`Optional`，看用户是否输入了消息。如果是，按以下方式处理消息：
- en: Get a reference to the selected `Conversation`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所选`Conversation`的引用。
- en: Create a new message, setting the conversation ID, recipient, and body.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一条新消息，设置会话ID，收件人和正文。
- en: 'Using `ConversationService`, we attempt to send the message:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ConversationService`，我们尝试发送消息：
- en: If successful, we update the user interface with the new message.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成功，我们用新消息更新用户界面。
- en: If unsuccessful, we display an error message.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不成功，我们显示一个错误消息。
- en: '`SendMessageController` works just like the other controllers we''ve looked
    at. The most interesting is the method `showAndWait()`. We''ll use that method
    to show the dialog, wait for it to close, and return any user response to the
    caller. The dialog looks as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendMessageController`的工作方式与我们之前看过的其他控制器一样。最有趣的是`showAndWait()`方法。我们将使用该方法显示对话框，等待其关闭，并将任何用户响应返回给调用者。对话框如下所示：'
- en: '![](img/00f5c6b8-1902-4dba-819e-22097a7c7659.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00f5c6b8-1902-4dba-819e-22097a7c7659.png)'
- en: 'The method looks as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法如下所示：
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The first few lines in the preceding method are what we''ve normally seen,
    which is creating the loader and the `Stage`. Before showing the `Stage`, we set
    the modality, and pass in the current `Conversation`. Finally, we call `showAndWait()`,
    at which point the method blocks until the user closes the dialog, and then we
    return the entered message:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法中的前几行是我们通常看到的，即创建加载器和`Stage`。在显示`Stage`之前，我们设置模态，并传入当前的`Conversation`。最后，我们调用`showAndWait()`，在这一点上，该方法会阻塞，直到用户关闭对话框，然后我们返回输入的消息：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: A Java `Optional` is a *container object which may or may not contain a non-null
    value*. The value of `message` may or may not be set depending on which button
    is clicked in the dialog. Using the `Optional`, we can return a, possibly, null
    value, and handle it more safely in the caller--`if (result.isPresent())`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Java的`Optional`是一个*可能包含非空值的容器对象*。`message`的值可能设置或未设置，这取决于对话框中点击了哪个按钮。使用`Optional`，我们可以返回一个可能为空的值，并在调用者中更安全地处理它--`if
    (result.isPresent())`。
- en: 'The sending of the message is a simple POST operation in the `ConversationService`,
    which is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的发送是`ConversationService`中的一个简单的POST操作，如下所示：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The client side is simple, but what about the server side? Unsurprisingly,
    that''s where the complexity lies:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端很简单，但服务器端呢？毫不奇怪，复杂性就在那里：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: To add the endpoint, we define a new method with the correct annotations. This
    method will listen on the path `conversations` for `POST` requests, and expect
    a `Message` as its payload. The actual work of sending a message is handled by
    `SmsManager`, so we acquire a reference to the default manager. The next step
    calls `divideMessage()`, but what's that all about?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加端点，我们使用正确的注释定义一个新的方法。这个方法将在路径`conversations`上监听`POST`请求，并期望`Message`作为其有效负载。发送消息的实际工作由`SmsManager`处理，因此我们获取对默认管理器的引用。下一步调用`divideMessage()`，但这是怎么回事呢？
- en: Text messages are technically limited to 160 characters. Twitter users are probably
    somewhat familiar with that already. Twitter limits tweets to 140 characters,
    leaving 20 characters for the sender's name. While Twitter has stuck hard to that
    limit, regular SMS users have a better experience. If the message is longer than
    160 characters, most modern phones will chunk the message into 153 character segments
    when sending (with 7 characters for segmentation information used to piece the
    segments back together), which are merged back into one message on the receiving
    end if the phone supports it. The `SmsManager` API handles this complexity for
    us with `divideMessage()`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 短信技术上限制为160个字符。Twitter用户可能已经对此有所了解。Twitter将推文限制为140个字符，留下20个字符供发送者的名称。虽然Twitter严格遵守这一限制，但普通短信用户有更好的体验。如果消息超过160个字符，大多数现代手机在发送时会将消息分成153个字符的段（使用7个字符的分段信息将这些段拼接在一起），如果手机支持的话，在接收端将这些段合并成一条消息。`SmsManager`
    API通过`divideMessage()`为我们处理了这种复杂性。
- en: 'Once the message is *chunked*, though, our job gets a little more difficult.
    We would like to be able to return a status code indicating whether or not the
    message was sent successfully. To do that, we need to check the status of each
    chunk of the message, be it one or ten. Sending a text message with `SmsManager`,
    Android broadcasts an `Intent` with the results. To react to that, we need to
    register a receiver. Put that all together, and we get this code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦消息被*分块*，我们的工作就变得有点困难。我们希望能够返回一个状态码，指示消息是否成功发送。为了做到这一点，我们需要检查消息的每个块的状态，无论是一个还是十个。使用`SmsManager`发送文本消息时，Android会广播带有结果的`Intent`。为了对此做出反应，我们需要注册一个接收器。将所有这些放在一起，我们得到了这段代码：
- en: '[PRE53]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To make sure that we've received the `Intent` for each message chunk, we start
    by creating a `CountDownLatch` with a count matching the number of chunks in the
    message. We also create an `AtomicInteger` to hold the status code. The reason
    we do this is that we need a final variable which we can access from our `BroadcastReceiver`,
    but we also need to be able to change the value. `AtomicInteger` allows us to
    do that.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们已经收到了每个消息块的`Intent`，我们首先创建一个与消息中块的数量匹配的`CountDownLatch`。我们还创建一个`AtomicInteger`来保存状态码。我们这样做的原因是我们需要一个最终的变量，我们可以从我们的`BroadcastReceiver`中访问，但我们也需要能够更改这个值。`AtomicInteger`允许我们这样做。
- en: We create and register a `BroadcastReceiver`, which analyzes the result code
    on `Intent`. If it's not `Activity.RESULT_OK`, we set `statusCode` to `INTERNAL_SERVER_ERROR`.
    Either way, we count down the latch.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建并注册一个`BroadcastReceiver`，它分析`Intent`上的结果代码。如果不是`Activity.RESULT_OK`，我们将`statusCode`设置为`INTERNAL_SERVER_ERROR`。无论哪种方式，我们都会倒计时。
- en: With our receiver ready, we create a `List` of `PendingIntent`s, one for each
    chunk, then we pass that, with our list of message chunks, to `SmsManager.sendMultipartTextMessage()`.
    Message sending is asynchronous, so we call `sentLatch.await()` to wait for the
    results to be returned. We limit the wait to five seconds so that we don't wait
    forever. Once the wait time expires or the latch is cleared, we unregister our
    receiver and return the status code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好我们的接收器后，我们创建一个`PendingIntent`的`List`，每个块一个，然后我们将它与我们的消息块列表一起传递给`SmsManager.sendMultipartTextMessage()`。消息发送是异步的，所以我们调用`sentLatch.await()`等待结果返回。我们将等待时间限制为五秒，以免永远等待。一旦等待时间到期或latch被清除，我们取消注册我们的接收器并返回状态码。
- en: Getting updates
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取更新
- en: So far, we can see all of the conversations, view individual messages in a conversation,
    and send new messages. What we can't do yet is get updates when new messages arrive
    on the device, so let's implement that now, starting with the server piece this
    time.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以看到所有的对话，查看对话中的单个消息，并发送新消息。但是，我们还不能在设备上收到新消息时获取更新，所以让我们从这次开始实现，从服务器部分开始。
- en: 'To get a constant stream of events, we''ll use a feature called Server-Sent
    Events, a W3C specification for receiving push notifications from the server.
    We enabled this feature in Jersey by registering the `SseFeature` in both the
    client and server setup steps. To create an SSE endpoint, we specify that the
    method returns the media type `SERVER_SENT_EVENTS`, and we return an `EventOutput`
    as the payload:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得一系列事件，我们将使用一个名为Server-Sent Events的功能，这是W3C规范，用于从服务器接收推送通知。我们通过在客户端和服务器设置步骤中注册“SseFeature”来启用Jersey中的此功能。要创建一个SSE端点，我们指定该方法返回媒体类型“SERVER_SENT_EVENTS”，并将“EventOutput”作为有效载荷返回：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'From the Jersey documentation, we learn this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从Jersey文档中，我们了解到：
- en: After the eventOutput is returned from the method, the Jersey runtime recognizes
    that this is a ChunkedOutput extension and does not close the client connection
    immediately. Instead, it writes the HTTP headers to the response stream and waits
    for more chunks (SSE events) to be sent. At this point the client can read headers
    and starts listening for individual events.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法返回eventOutput之后，Jersey运行时会识别这是一个ChunkedOutput扩展，并不会立即关闭客户端连接。相反，它会将HTTP头写入响应流，并等待发送更多的块（SSE事件）。此时，客户端可以读取头并开始监听各个事件。
- en: 'The server, then, keeps the socket to the client open, and pushes data down
    it. But where does the data come from? The Server-sent Event endpoints create
    a `Thread` that writes data to the `EventOutput` instance we created earlier.
    When the `Thread` is finished, it calls `eventOutput.close()`, which signals to
    the runtime that it is appropriate to close the client connection. To stream updates,
    our `Thread` looks as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器会保持与客户端的套接字打开，并向其推送数据。但数据从哪里来呢？服务器发送事件端点创建一个“线程”，该线程将数据写入我们之前创建的“EventOutput”实例。当“线程”完成时，它调用“eventOutput.close()”，这表示运行时可以关闭客户端连接。为了流式更新，我们的“线程”如下所示：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As we've seen before, we set up a `BroadcastReceiver`, which we register here
    and unregister before the `Thread` ends, but this time, we're listening for broadcasts
    that an SMS message has been received. To make sure our `Thread` isn't in a small,
    tight, fast loop, which would quickly kill the battery on the device, we use `LinkedBlockingQueue`.
    When a message is received, we pull the `SmsMessage`(s) from `Intent`, and add
    them to `queue`. In our while loop, we attempt to `take()` an item from `queue`.
    If we find one, we process it and any more that might either already be in the
    queue or be added while we are processing. Once `queue` is empty, we go back to
    waiting. We have a timeout on `take()` to make sure that the thread can respond
    to the exit criteria, most notably, the client disconnecting. This will run as
    long as the client remains connected. Let's look, then, at the client.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们以前所见，我们设置了一个“BroadcastReceiver”，我们在这里注册并在“线程”结束之前注销，但这次，我们正在监听广播，即已收到短信消息。为了确保我们的“线程”不会陷入一个小的、紧凑的、快速的循环中，这将迅速耗尽设备的电池，我们使用了“LinkedBlockingQueue”。当收到消息时，我们从“Intent”中提取“SmsMessage”，并将它们添加到“queue”中。在我们的while循环中，我们尝试从“queue”中“take()”一个项目。如果我们找到一个，我们处理它以及可能在我们处理时已经在队列中或在我们处理时添加的任何其他项目。一旦“queue”为空，我们就会回到等待状态。我们对“take()”设置了超时，以确保线程可以响应退出条件，尤其是客户端断开连接。只要客户端保持连接，这将继续运行。接下来，让我们看看客户端。
- en: 'We encapsulated the details in `ConversationService.subscribeToNewMessageEvents()`
    as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将细节封装在`ConversationService.subscribeToNewMessageEvents()`中，如下所示：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the preceding code, we create a `Thread`, in which we make the call to the
    SSE endpoint. The return type on the client is `EventInput`. We loop to process
    each incoming event, which we get as an `InboundEvent`. If it is null, then the
    connection has been closed, so we break out of our processing loop. If it is not
    null, we make sure that the event name matches what we're waiting for--`new-message`.
    If found, we extract the event payload, a `Message`, and call our callback, which
    we pass in as `Consumer<Message>`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建一个“线程”，在其中调用SSE端点。客户端的返回类型是“EventInput”。我们循环处理每个传入事件，我们将其作为“InboundEvent”获取。如果它为空，则连接已关闭，因此我们退出处理循环。如果它不为空，我们确保事件名称与我们正在等待的内容匹配--“new-message”。如果找到，我们提取事件有效载荷，即“消息”，并调用我们的回调，我们将其作为“Consumer<Message>”传递。
- en: 'From the application proper, we subscribe to the status stream this way:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序中，我们以这种方式订阅状态流：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`handleMessageReceived()` looks like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleMessageReceived()`看起来像这样：'
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The first step in handling this new message is very important--we pass a `Runnable`
    to `Platform.runLater()`. If we don't do this, any attempts to modify the user
    interface will fail. You have been warned. In our `Runnable`, we create a `Stream`
    of `Conversation`s, `filter()` it, looking for a `Conversation` whose participant
    matches the `Message` sender, then grab the first (and only) match.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这条新消息的第一步非常重要--我们将一个“Runnable”传递给“Platform.runLater()”。如果我们不这样做，任何修改用户界面的尝试都将失败。你已经被警告了。在我们的“Runnable”中，我们创建一个“Conversation”的“Stream”，对其进行“filter()”，寻找与“消息”发送者匹配的“Conversation”，然后抓取第一个（也是唯一的）匹配项。
- en: If we find the `Conversation` in the list, we add this new `Message` to its
    list, and update the snippet (which is just the `Conversation`'s last message
    body). We also ask the `Conversation` list to `refresh()` itself to make sure
    the user interface reflects these changes. Finally, if the `Conversation` is the
    currently selected one, we update the message list and scroll to the bottom to
    make sure the new message shows.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在列表中找到“对话”，我们将这条新的“消息”添加到其列表中，并更新摘要（即“对话”的最后一条消息正文）。我们还要求“对话”列表“刷新（）”自身，以确保用户界面反映这些更改。最后，如果“对话”是当前选定的对话，我们会更新消息列表并滚动到底部，以确保新消息显示出来。
- en: If we don't find the `Conversation` in the list, we create a new one, and add
    it to the `ConversationObservable`, which results in the `List` automatically
    updating on the screen.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在列表中找不到“对话”，我们会创建一个新的对话，并将其添加到“ConversationObservable”中，这将导致“List”在屏幕上自动更新。
- en: Finally, we attempt a couple of desktop integration tasks. If `Taskbar` supports
    the `USER_ATTENTION` feature, we request user attention. From the Javadocs we
    learn that, *depending on the platform, this may be visually indicated by a bouncing
    or flashing icon in the task area*. Regardless, we issue a beep to get the user's
    attention.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们尝试一些桌面集成任务。如果`Taskbar`支持`USER_ATTENTION`功能，我们请求用户注意。从Javadocs中我们了解到，*根据平台的不同，这可能通过任务区域中的图标弹跳或闪烁来进行视觉指示*。无论如何，我们都会发出蜂鸣声来引起用户的注意。
- en: Security
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: There's one last major piece that we haven't discussed, and that's security.
    Currently, anybody with the desktop application can, in theory, connect to your
    phone, see your messages, send others, and so on. Let's fix that now.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个我们还没有讨论的重要部分，那就是安全性。目前，任何拥有桌面应用程序的人理论上都可以连接到您的手机，查看您的消息，发送其他消息等。让我们现在来解决这个问题。
- en: Securing the endpoints
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护端点
- en: 'To secure the REST server, we will use a filter just like we used in [Chapter
    9](../Text/50fd66f8-4865-4bc4-afdc-39f8cd5bf4f0.xhtml), *Taking Notes with Monumentum*.
    We''ll start by defining the annotation that will specify which endpoints need
    to be secured, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护REST服务器，我们将使用一个过滤器，就像我们在[第9章](../Text/50fd66f8-4865-4bc4-afdc-39f8cd5bf4f0.xhtml)中使用的那样，*使用Monumentum做笔记*。我们将首先定义一个注解，指定需要保护的端点，如下所示：
- en: '[PRE59]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will apply this preceding annotation to each secured endpoint (annotations
    condensed to one line for brevity):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把上述注解应用到每个受保护的端点上（为简洁起见，将注解压缩为一行）：
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will also need a filter to enforce security, which we add as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个过滤器来强制执行安全性，我们将其添加如下：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Much like in [Chapter 9](../Text/50fd66f8-4865-4bc4-afdc-39f8cd5bf4f0.xhtml),
    *Taking Notes with Monumentum*, we''ll be using **JSON Web Tokens** (**JWT**)
    to help authenticate and authorize clients. In this filter, we extract the JWT
    from the request headers and validate it through these steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[第9章](../Text/50fd66f8-4865-4bc4-afdc-39f8cd5bf4f0.xhtml)中一样，*使用Monumentum做笔记*，我们将使用**JSON
    Web Tokens**（**JWT**）来帮助验证和授权客户端。在这个过滤器中，我们从请求头中提取JWT，并通过以下步骤验证它：
- en: Get the signing key from `KeyGenerator`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`KeyGenerator`获取签名密钥。
- en: Create the `JwtParser` using the signing key.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用签名密钥创建`JwtParser`。
- en: Parse the claims in the JWT. For our purposes here, this is, basically, just
    a validation of the token itself.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析JWT中的声明。在这里，基本上只是对令牌本身进行验证。
- en: Abort the request with `UNAUTHORIZED` (`401`) should the token be invalid.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果令牌无效，使用`UNAUTHORIZED`（`401`）中止请求。
- en: 'The `KeyGenerator` itself looks a bit like what we saw in [Chapter 9](../Text/50fd66f8-4865-4bc4-afdc-39f8cd5bf4f0.xhtml),
    *Taking Notes with Monumentum*, but has been modified to use Android APIs in this
    manner:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyGenerator`本身看起来有点像我们在[第9章](../Text/50fd66f8-4865-4bc4-afdc-39f8cd5bf4f0.xhtml)中看到的，*使用Monumentum做笔记*，但已经修改为以这种方式使用Android
    API：'
- en: '[PRE62]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Since we might possibly receive requests from multiple clients at a time, we
    need to be careful about how the key is generated. To make sure it's done once
    and only once, we'll use the same type of synchronization/locking we saw in the
    server startup.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能同时从多个客户端接收请求，我们需要小心生成密钥。为了确保它只执行一次，我们将使用与服务器启动中看到的相同类型的同步/锁定。
- en: Once we've acquired the lock, we perform a null check to see if the process
    has already generated (or read) the key. If not, we then read the signing key
    from `SharedPreferences`. If it's null, we create a random string (here, just
    a UUID), and save it to `SharedPreferences` for reuse next time. Note that to
    save to Android preferences, we have to get an instance of `SharedPreferences.Editor`,
    write the string, then `commit()`. Once we have the signing key, we create the
    actual `SecretKeySpec` that we'll use to sign and verify our JWTs.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了锁，我们执行一个空检查，看看进程是否已经生成（或读取）了密钥。如果没有，我们就从`SharedPreferences`中读取签名密钥。如果它为空，我们就创建一个随机字符串（这里只是一个UUID），并保存到`SharedPreferences`中以便下次重用。请注意，要保存到Android首选项，我们必须获得`SharedPreferences.Editor`的实例，写入字符串，然后`commit()`。一旦我们有了签名密钥，我们就创建实际的`SecretKeySpec`，用于签名和验证我们的JWT。
- en: Handling authorization requests
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理授权请求
- en: 'With our endpoints now secured, we need a way for the clients to request authorization.
    To do that, we''ll expose a new endpoint, unsecured, of course, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的端点已经得到保护，我们需要一种方式让客户端请求授权。为此，我们将公开一个新的端点，当然是不安全的，如下所示：
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Rather than require a more complicated authorization system that might require
    a username and password or an OAuth2 provider, what we''ll implement is a simple
    system that requires only a random number:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要一个更复杂的授权系统，可能需要用户名和密码或OAuth2提供者，我们将实现一个只需要一个随机数的简单系统：
- en: On the phone, the user requests that a new client be added, and is presented
    with a random number.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在手机上，用户请求添加一个新的客户端，并呈现一个随机数。
- en: In the desktop application, the user enters the number, which the desktop application
    then POSTs to the server.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在桌面应用程序中，用户输入数字，然后桌面应用程序将其POST到服务器。
- en: If the numbers match, the client is given a JWT, which it will send with every
    request.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数字匹配，客户端将获得一个JWT，它将在每个请求中发送。
- en: The JWT is verified each time to make sure the client is authorized to access
    the target resource.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次验证JWT以确保客户端被授权访问目标资源。
- en: In this method, we get the number POSTed by the client (which we let JAX-RS
    extract from the request body), then compare it to the number generated on the
    phone. If they match, we create the JWT, and return it to the client. Before doing
    so, we broadcast an intent with the action `CODE_ACCEPTED`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们获取客户端POST的数字（我们让JAX-RS从请求体中提取），然后将其与手机上生成的数字进行比较。如果它们匹配，我们创建JWT，并将其返回给客户端。在这样做之前，我们广播一个带有动作`CODE_ACCEPTED`的意图。
- en: 'Where does the number come from, and why are we broadcasting this intent? We
    haven''t looked at this in detail yet, but in the main layout, `activity_main.xml`,
    there is a `FloatingActionButton`. To this, we attach an `onClick` listener as
    follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字是从哪里来的，为什么我们要广播这个意图？我们还没有详细研究过这个问题，但在主布局`activity_main.xml`中，有一个`FloatingActionButton`。我们将一个`onClick`监听器附加到这个上面，如下所示：
- en: '[PRE64]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When the user taps on the button, the following screen will be shown:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，将显示以下屏幕：
- en: '![](img/615b1a73-0b78-4a8f-b0a5-bab464247a9f.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/615b1a73-0b78-4a8f-b0a5-bab464247a9f.png)'
- en: 'The client will use this information to connect and gain authorization. The
    `Activity` itself is fairly basic. It needs to present the IP address and code,
    and then respond to a client connecting. All of this is done in `onCreate()` in
    our new `AuthorizeClientActivity` class. We get the IP from `WifiManager`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将使用这些信息进行连接和授权。`Activity`本身非常基本。它需要呈现IP地址和代码，然后响应客户端连接。所有这些都在我们的新`AuthorizeClientActivity`类的`onCreate()`中完成。我们从`WifiManager`中获取IP地址：
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Remember that we require that the client be on a Wi-Fi network. The code is
    just a random, 6-digit number:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们要求客户端连接到Wi-Fi网络。代码只是一个随机的6位数字：
- en: '[PRE66]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To listen for the `Intent` we saw earlier, which indicates that a client has
    been authenticated (which, presumably, will happen shortly after this `Activity`
    has been displayed), we register another receiver as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 监听我们之前看到的`Intent`，这表明客户端已经通过身份验证（很可能是在`Activity`显示后不久），我们注册另一个接收器如下：
- en: '[PRE67]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We also need to tell the `Service` what this new code is so that it can verify
    it. To do that, we broadcast an `Intent` as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要告诉`Service`这个新代码是什么，以便它可以验证它。为此，我们广播一个`Intent`如下：
- en: '[PRE68]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We've already seen the other half of this broadcast in `DeskDroidService.onStartCommand()`
    earlier, where the code is retrieved from the `Intent`, and stored in the service
    for use by `DeskDroidResource.getAuthorization()`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`DeskDroidService.onStartCommand()`中看到了广播的另一半，在那里从`Intent`中检索代码，并将其存储在服务中供`DeskDroidResource.getAuthorization()`使用。
- en: 'Finally, this method, which handles the authentication notice, simply cleans
    up the receiver and closes the `Activity`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，处理身份验证通知的这个方法只是清理接收器并关闭`Activity`：
- en: '[PRE69]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: With this, when a client connects and successfully authenticates, the `Activity`
    closes, and the user is returned to the main `Activity`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，当客户端连接并成功验证时，`Activity`关闭，用户返回到主`Activity`。
- en: Authorizing the client
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权客户端
- en: Up until this point, everything has assumed that the desktop is already connected
    to the phone. We have enough pieces in place now that we can talk about that in
    a meaningful manner.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 直到这一点，一切都假定桌面已经连接到手机。我们现在已经有足够的部件，可以有意义地讨论这个问题。
- en: 'In the application''s main `Menu`, we have two `MenuItem`s: `Connect to Phone`
    and `Disconnect from Phone`. The `Connect to Phone` handler looks as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的主`Menu`中，我们有两个`MenuItem`：`连接到手机`和`断开手机连接`。`连接到手机`处理程序如下所示：
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We''re going to use the now-familiar `showAndWait()` pattern to display a modal
    dialog, and to get the response using the new `ConnectToPhoneController`. The
    user interface is very simple, and is shown in this screenshot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用现在熟悉的`showAndWait()`模式来显示模态对话框，并使用新的`ConnectToPhoneController`获取响应。用户界面非常简单，如下截图所示：
- en: '![](img/c46711ea-77d2-42dd-85fe-baa05d041061.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c46711ea-77d2-42dd-85fe-baa05d041061.png)'
- en: 'When the user clicks on OK, we save the address and the code in the application''s
    preferences, then attempt to authorize against the server, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击确定时，我们将地址和代码保存在应用程序的首选项中，然后尝试对服务器进行授权，如下所示：
- en: '[PRE71]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Notice the use of `Optional<String>` as the return type for `ConversationService.getAuthorization()`.
    Using `Optional`, as we've discussed before, makes working with potentially `null`
    values much safer. In this case, if `Optional` has a value present, then we've
    successfully authenticated. So, we save the token to preferences, and close the
    dialog.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Optional<String>`被用作`ConversationService.getAuthorization()`的返回类型。正如我们之前讨论过的，使用`Optional`可以更安全地处理可能为`null`的值。在这种情况下，如果`Optional`有一个值，那么我们已经成功验证。因此，我们将令牌保存到首选项中，并关闭对话框。
- en: 'The actual authentication is handled by `ConversationService`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的身份验证由`ConversationService`处理：
- en: '[PRE72]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This last method sends the code to the server via a `POST`, and if the status
    code is `200`, we create an `Optional` with the returned token. Otherwise, we
    return an empty `Optional`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的方法通过`POST`将代码发送到服务器，如果状态码是`200`，我们将创建一个带有返回令牌的`Optional`。否则，我们返回一个空的`Optional`。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we built a different kind of project. We've had applications
    that run on Android, and some that run on the desktop. This one, though, runs
    on both platforms simultaneously. One is no good without the other. That requires
    that we build things a bit differently to make sure the two are synchronized.
    While there are a variety of ways to go about this, we chose to use a REST server
    on the phone, with the desktop acting as a REST client.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一种不同类型的项目。我们有在Android上运行的应用程序，也有在桌面上运行的应用程序。然而，这个项目同时在两个平台上运行。一个没有另一个是不行的。这要求我们以稍微不同的方式构建东西，以确保两者同步。虽然有各种各样的方法可以解决这个问题，但我们选择在手机上使用REST服务器，桌面作为REST客户端。
- en: By the end of the chapter, we built an Android application that provides not
    only a user interface, but a background process (called `Service`), and embedded
    our REST server in the Android application using Jersey and its Java SE deployment
    option. You also learned how to interact with text (SMS) messages on Android using
    the system-provided Content Providers and platform APIs, and streaming those messages
    to the client using Server-Sent Events. We demonstrated how to send messages between
    processes/threads in Android using `Intent`s, broadcasts, and `BroadcastReceiver`s.
    Finally, on the desktop side, we built a JavaFX client to display and send text
    messages, which connects to the REST server on the phone via the Jersey REST client,
    and we consumed the Server-sent Event stream, updating the user interface as appropriate.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们构建了一个安卓应用程序，它不仅提供了用户界面，还提供了一个后台进程（称为“服务”），并使用Jersey及其Java SE部署选项在安卓应用程序中嵌入了我们的REST服务器。您还学会了如何在安卓上使用系统提供的内容提供程序和平台API与文本（短信）进行交互，并使用服务器发送事件将这些消息流式传输到客户端。我们演示了如何在安卓中使用“意图”、“广播”和“广播接收器”在进程/线程之间发送消息。最后，在桌面端，我们构建了一个JavaFX客户端来显示和发送文本消息，它通过Jersey
    REST客户端连接到手机上的REST服务器，并消费了服务器发送的事件流，根据需要更新用户界面。
- en: With all of the moving parts, this was probably the most complex of our projects.
    It was certainly a great way to round out our list of projects. In the next chapter,
    we'll take a look at what's next for Java, as well as some other technologies
    that might be good to have on your radar.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于涉及的各个部分都很复杂，这可能是我们项目中最复杂的一个。这无疑是一个很好的方式来完成我们的项目列表。在下一章中，我们将看看Java的未来发展，以及一些其他可能值得关注的技术。
