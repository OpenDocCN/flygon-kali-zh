- en: Beginning Your Kotlin Adventure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始你的Kotlin之旅
- en: Kotlin is great language that makes Android development easier, faster, and
    much more pleasant. In this chapter, we will discuss what Kotlin really is and
    look at many Kotlin examples that will help us build even better Android applications.
    Welcome to the amazing journey of Kotlin, that will change the way you think about
    writing code and solving common programming problems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin是一种优秀的语言，使Android开发更加简单、快速和愉快。在本章中，我们将讨论Kotlin的真正含义，并查看许多Kotlin示例，这将帮助我们构建更好的Android应用程序。欢迎来到Kotlin的惊人之旅，它将改变您对编写代码和解决常见编程问题的方式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: First steps with Kotlin
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kotlin的第一步
- en: Practical Kotlin examples
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实用的Kotlin示例
- en: Creating new Kotlin project in Android Studio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android Studio中创建新的Kotlin项目
- en: Migrating existing Java project to Kotlin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有的Java项目迁移到Kotlin
- en: The Kotlin standard library (stdlib)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin标准库（stdlib）
- en: Why Kotlin is a good choice to learn
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么学习Kotlin是一个不错的选择
- en: Say hello to Kotlin
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Kotlin打个招呼
- en: Kotlin is a modern, statically typed, Android-compatible language that fixes
    many *Java* problems, such as null pointer exceptions or excessive code verbosity.
    Kotlin is a language inspired by Swift, Scala, Groovy, C#, and many other languages.
    Kotlin was designed by JetBrains professionals, based on analysis of both developers
    experiences, best usage guidelines (most important are *clean code* and *effective
    Java* ), and data about this language's usage. Deep analysis of other programming
    languages has been done. Kotlin tries hard to not repeat the mistakes from other
    languages and take advantage of their most useful features. When working with
    Kotlin, we can really feel that this is a mature and well-designed language.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin是一种现代的、静态类型的、与Android兼容的语言，它解决了许多*Java*的问题，比如空指针异常或过多的代码冗余。Kotlin是一种受Swift、Scala、Groovy、C#和许多其他语言启发的语言。Kotlin是由JetBrains专业人员设计的，基于对开发者经验、最佳使用指南（最重要的是*clean
    code*和*effective Java*）以及有关该语言使用情况的数据的分析。对其他编程语言进行了深入分析。Kotlin努力避免重复其他语言的错误，并利用它们最有用的特性。在使用Kotlin时，我们真的可以感觉到这是一种成熟且设计良好的语言。
- en: 'Kotlin takes application development to a whole new level by improving code
    quality and safety and boosting developer performance. Official Kotlin support
    for the Android platform was announced by Google in 2017, but the Kotlin language
    has been here for some time. It has a very active community and Kotlin adoption
    on the Android platform is already growing quickly. We can describe Kotlin as
    a safe, expressive, concise, versatile, and tool-friendly language that has great
    interoperability with Java and JavaScript. Let''s discuss these features:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin通过提高代码质量和安全性以及提高开发人员的性能，将应用程序开发提升到一个全新的水平。Google在2017年宣布正式支持Android平台的Kotlin，但Kotlin语言已经存在一段时间了。它拥有一个非常活跃的社区，而且在Android平台上的Kotlin采用已经迅速增长。我们可以将Kotlin描述为一种安全、表达力强、简洁、多功能且友好的语言，它与Java和JavaScript具有很好的互操作性。让我们讨论一下这些特点：
- en: '**Safety** : Kotlin offers safety features in terms of nullability and immutability.
    Kotlin is statically typed, so the type of every expression is known at compile
    time. The compiler can verify that whatever property or method that we are trying
    to access or a particular class instance actually exists. This should be familiar
    from Java which is also statically typed, but unlike Java, Kotlin type system
    is much more strict (safe). We have to explicitly tell the compiler whether the
    given variable can store null values. This allows making the program fail at compile
    time instead of throwing a `NullPointerException` at runtime:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：Kotlin在空指针和不可变性方面提供了安全功能。Kotlin是静态类型的，因此在编译时就知道每个表达式的类型。编译器可以验证我们尝试访问的任何属性或方法或特定类实例是否真的存在。这应该是熟悉的Java，它也是静态类型的，但与Java不同，Kotlin的类型系统更加严格（安全）。我们必须明确告诉编译器给定的变量是否可以存储空值。这允许在编译时使程序失败，而不是在运行时抛出`NullPointerException`：'
- en: '![](img/Image00004.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00004.jpg)'
- en: '**Easy debugging** : Bugs can be detected much faster during the development
    phase instead of crashing the application after it is released and thus damaging
    the user experience. Kotlin offers a convenient way to work with immutable data.
    For example, it can distinguish mutable (read-write) and immutable (read-only)
    collections by providing convenient interfaces (under the hood collections are
    still mutable).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于调试**：在开发阶段可以更快地检测到错误，而不是在发布后导致应用程序崩溃，从而损害用户体验。Kotlin提供了一种方便的方法来处理不可变数据。例如，它可以通过提供便利的接口（底层集合仍然是可变的）来区分可变（读写）和不可变（只读）集合。'
- en: '**Conciseness** : Most of the Java verbosity was eliminated. We need less code
    to achieve common tasks and thus the amount of boilerplate code is greatly reduced,
    even comparing Kotlin to Java 8\. As a result, the code is also easier to read
    and understand (expressive).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性**：大部分Java的冗长性都被消除了。我们需要更少的代码来完成常见任务，因此样板代码的数量大大减少，甚至将Kotlin与Java 8进行比较。结果，代码也更容易阅读和理解（表达力强）。'
- en: '**Interoperability** : Kotlin is designed to seamlessly work side by side with
    Java (cross-language project). The existing ecosystem of Java libraries and frameworks
    works with Kotlin without any performance penalties. Many Java libraries have
    even Kotlin-specific versions that allow more idiomatic usage with Kotlin. Kotlin
    classes can also be directly instantiated and transparently referenced from Java
    code without any special semantics and vice versa. This allows us to incorporate
    Kotlin into existing Android projects and use Kotlin easily together with Java
    (if we want to).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性**：Kotlin被设计为可以与Java（跨语言项目）无缝协同工作。现有的Java库和框架可以在Kotlin中无需任何性能损失地工作。许多Java库甚至有针对Kotlin的版本，可以更符合Kotlin的习惯用法。Kotlin类也可以直接在Java代码中实例化和透明地引用，而无需任何特殊的语义，反之亦然。这使我们可以将Kotlin整合到现有的Android项目中，并且可以轻松地与Java一起使用（如果我们愿意）。'
- en: '**Versatility** : We can target many platforms, including mobile applications
    (Android), server-side applications (backend), desktop applications, frontend
    code running in the browser, and even build systems (Gradle).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多功能性**：我们可以针对许多平台，包括移动应用程序（Android）、服务器端应用程序（后端）、桌面应用程序、在浏览器中运行的前端代码，甚至构建系统（Gradle）。'
- en: Any programming language is only as good as its tool support. Kotlin has outstanding
    support for modern IDEs such as Android Studio, IntelliJ Idea, and Eclipse. Common
    tasks like code assistance or refactoring are handled properly. The Kotlin team
    works hard to make the Kotlin plugin better with every single release. Most of
    the bugs are quickly fixed and many of the features requested by the community
    are implemented.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言的好坏取决于其工具支持。Kotlin在现代IDE（如Android Studio、IntelliJ Idea和Eclipse）中有出色的支持。常见任务如代码辅助或重构都得到了妥善处理。Kotlin团队努力使每个版本的Kotlin插件更好。大多数错误都能迅速修复，社区提出的许多功能也得到了实现。
- en: 'Kotlin bug tracker: [https://youtrack.jetbrains.com/issues/KT](https://youtrack.jetbrains.com/issues/KT)
    Kotlin slack channel: [http://slack.kotlinlang.org/](http://slack.kotlinlang.org/)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin错误跟踪器：[https://youtrack.jetbrains.com/issues/KT](https://youtrack.jetbrains.com/issues/KT)
    Kotlin slack频道：[http://slack.kotlinlang.org/](http://slack.kotlinlang.org/)
- en: Android application development becomes much more efficient and pleasant with
    Kotlin. Kotlin is compatible with JDK 6, so applications created in Kotlin run
    safely even on old Android devices that precede Android 4.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kotlin进行Android应用程序开发变得更加高效和愉快。Kotlin与JDK 6兼容，因此使用Kotlin创建的应用程序甚至可以在旧的Android设备上安全运行，这些设备先于Android
    4。
- en: Kotlin aims to bring you the best of both worlds by combining concepts and elements
    from both procedural and functional programming. It follows many guidelines are
    described in the book, *Effective Java* , *2nd Edition* , by Joshua Bloch which
    is considered must read a book for every Java developer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin旨在通过结合程序设计和函数式编程的概念和元素，为您带来最佳的体验。它遵循了书籍《Effective Java》，第二版，作者Joshua Bloch描述的许多准则，这被认为是每个Java开发人员必读的书籍。
- en: On top of that, Kotlin is open sourced, so we can check out the project and
    be actively involved in any aspect of the Kotlin project such as Kotlin plugins,
    compilers, documentations or Kotlin language itself.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Kotlin是开源的，因此我们可以查看项目并积极参与Kotlin项目的任何方面，如Kotlin插件、编译器、文档或Kotlin语言本身。
- en: Awesome Kotlin examples
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 令人惊叹的Kotlin示例
- en: 'Kotlin is really easy to learn for Android developers because the syntax is
    similar to Java and Kotlin often feels like natural Java evolution. At the beginning,
    a developer usually writes Kotlin code having in mind habits from Java, but after
    a while, it is very easy to move to more idiomatic Kotlin solutions. Let''s look
    at some cool Kotlin features, and see where Kotlin may provide benefits by solving
    common programming tasks in an easier, more concise, and more flexible way. We
    have tried to keep examples simple and self-explanatory, but they utilize content
    from various parts of this book, so it''s fine if they are not fully understood
    at this point. The goal of this section is to focus on the possibilities and present
    what can be achieved by using Kotlin. This section does not necessarily need to
    fully describe how to achieve it. Let''s start with a variable declaration:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android开发人员来说，学习Kotlin真的很容易，因为语法类似于Java，而且Kotlin经常感觉像是自然的Java演变。在开始时，开发人员通常会根据Java的习惯编写Kotlin代码，但过一段时间后，很容易转移到更符合惯例的Kotlin解决方案。让我们看一些酷炫的Kotlin功能，并看看Kotlin在哪些地方可能通过更简单、更简洁和更灵活的方式解决常见的编程任务而提供好处。我们试图保持示例简单和自解释，但它们利用了本书各个部分的内容，所以如果目前还没有完全理解也没关系。本节的目标是专注于可能性，并展示使用Kotlin可以实现什么。本节不一定需要完全描述如何实现它。让我们从变量声明开始：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice that Kotlin does not require semicolons. You can still use them, but
    they are optional. We also don''t need to specify a variable type because it''s
    inferred from the context. Each time the compiler can figure out the type from
    the context we don''t have to explicitly specify it. Kotlin is a strongly typed
    language, so each variable has an adequate type:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Kotlin不需要分号。你仍然可以使用它们，但它们是可选的。我们也不需要指定变量类型，因为它是从上下文中推断出来的。每当编译器可以从上下文中推断出类型时，我们就不必明确指定它。Kotlin是一种强类型语言，因此每个变量都有适当的类型：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The variable has an inferred `String` type, so assigning a different value
    (integer) will result in compilation error. Now, let''s see how Kotlin improves
    the way to add multiple strings using *string templates* :'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 变量具有推断的`String`类型，因此分配不同值（整数）将导致编译错误。现在，让我们看看Kotlin如何改进使用*字符串模板*添加多个字符串的方式：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We need no more joining strings using the `+` character. In Kotlin, we can
    easily incorporate single variable or even whole expression into string literals:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要使用`+`字符来连接字符串。在Kotlin中，我们可以轻松地将单个变量甚至整个表达式合并到字符串文字中：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In Java any variable can store null values. In Kotlin *strict null safety*
    forces us to explicitly mark each variable that can store nullable values:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，任何变量都可以存储空值。在Kotlin中，*严格的空安全*强制我们明确标记每个可以存储可空值的变量：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Adding a question mark to a data type (string versus string?), we say that
    variable can be nullable (can store null references). If we don''t mark variable
    as nullable, we will not be able to assign a nullable reference to it. Kotlin
    also allows to deal with nullable variables in proper ways. We can use *safe call*
    operator to safely call methods on potentially nullable variables:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 向数据类型（字符串与字符串？）添加问号，我们说变量可以是可空的（可以存储空引用）。如果我们不将变量标记为可空，我们将无法将可空引用分配给它。Kotlin还允许以适当的方式处理可空变量。我们可以使用*安全调用*运算符在可能为空的变量上安全调用方法：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The method `doSomething` will be invoked only if `savedInstanceState` has a
    non-null value, otherwise the method call will be ignored. This is Kotlin's safe
    way to avoid null pointer exceptions that are so common in Java.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在`savedInstanceState`具有非空值时，才会调用`doSomething`方法，否则方法调用将被忽略。这是Kotlin避免Java中常见的空指针异常的安全方式。
- en: 'Kotlin also has several new data types. Let''s look at the `Range` data type
    that allows us to define end inclusive ranges:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin还有几种新的数据类型。让我们看看`Range`数据类型，它允许我们定义包含结束的范围：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Kotlin introduces the `Pair` data type that, combined with *infix* *notation,*
    allows us to hold a common pair of values:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin引入了`Pair`数据类型，结合*中缀* *表示*，允许我们保存一对常见的值：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can deconstruct it into separate variables using *destructive declarations*
    :'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*破坏性声明*将其解构为单独的变量：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can even iterate through a list of pairs:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以迭代一对对：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, we can use the `forEach` function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`forEach`函数：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that Kotlin distinguishes between mutable and immutable collections by
    providing a set of interfaces and helper methods (`List` versus `MutableList`
    , `Set` versus `Set` versus `MutableSet` , `Map` versus `MutableMap` , and so
    on):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Kotlin通过提供一组接口和辅助方法（`List`与`MutableList`，`Set`与`Set`与`MutableSet`，`Map`与`MutableMap`等）区分可变和不可变集合：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Immutable collection means that the collection state can't change after initialization
    (we can't add/remove items). Mutable collection (quite obviously) means that the
    state can change.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变集合意味着集合状态在初始化后无法更改（无法添加/删除项目）。可变集合（显然）意味着状态可以改变。
- en: 'With lambda expressions, we can use the Android framework build in a very concise
    way:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lambda表达式，我们可以以非常简洁的方式使用Android框架构建：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Kotlin standard library (stdlib) contains many functions that allow us to perform
    operations on collections in simple and concise way. We can easily perform stream
    processing on lists:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库（stdlib）包含许多函数，允许我们以简单而简洁的方式对集合执行操作。我们可以轻松地对列表进行流处理：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that we don't have to pass parameters to a lambda. We can also define
    our own lambdas that will allow us to write code in completely new way. This lambda
    will allow us to run a particular piece of code only in Android Marshmallow or
    newer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不必向lambda传递参数。我们还可以定义自己的lambda，这将使我们以全新的方式编写代码。这个lambda将允许我们仅在Android
    Marshmallow或更新版本中运行特定的代码片段。
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can make asynchronous requests easily and display responses on the main
    thread using the `doAsync` function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地发出异步请求，并在主线程上显示响应，使用`doAsync`函数：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Smart casts allow us to write code without performing redundant casting:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 智能转换允许我们编写代码而不执行冗余的转换：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Kotlin compiler knows that the variable `*x*` is of the type `String` after
    performing a check, so it will automatically cast it to the `String` type*,* allowing
    it to call all methods and access all properties of the `String` class without
    any explicit casts.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin编译器知道变量`*x*`在执行检查后是`String`类型，因此它将自动将其转换为`String`类型*，*允许调用`String`类的所有方法和访问所有属性而无需进行任何显式转换。
- en: 'Sometimes, we have a simple function that returns the value of a single expression.
    In this case, we can use a function with an expression body to shorten the syntax:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们有一个返回单个表达式值的简单函数。在这种情况下，我们可以使用具有表达式主体的函数来缩短语法：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using *default argument syntax,* we can define the default value for each function
    argument and call it in various ways:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*默认参数语法*，我们可以为每个函数参数定义默认值，并以各种方式调用它：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The only limitation is that we need to supply all arguments without default
    values. We can also use *named argument* *syntax* to specify function arguments:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的限制是我们需要提供所有参数而不带默认值。我们还可以使用*命名参数* *语法*指定函数参数：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This also increases readability when invoking the function with multiple parameters
    in the function call.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这也增加了在函数调用中使用多个参数时的可读性。
- en: 'The data classes give a very easy way to define and operate on classes from
    the data model. To define a proper data class, we will use the `data` modifier
    before the class name:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类提供了一种非常简单的方式来定义和操作数据模型中的类。要定义一个合适的数据类，我们将在类名之前使用`data`修饰符：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice that we have a really nice, human readable string representation of
    the class instance and we do not need the `new` keyword to instantiate the class.
    We can also easily create a custom copy of the class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们有一个非常好的、人类可读的类实例的字符串表示，我们不需要`new`关键字来实例化类。我们还可以轻松地创建类的自定义副本：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding constructs make working with *immutable* objects very easy and
    convenient.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的构造使得使用*不可变*对象非常容易和方便。
- en: 'One of the best features in Kotlin are *extensions.* They allow us to add new
    behavior (a method or property) to an existing class without changing its implementation.
    Sometimes when you work with a library or framework, you would like to have extra
    method or property for certain class. Extensions are a great way to add those
    missing members. Extensions reduce code verbosity and remove the need to use utility
    functions known from Java (for example, the `StringUtils` class). We can easily
    define extensions for custom classes, third-party libraries, or even Android framework
    classes. First of all, `ImageView` does not have the ability to load images from
    network, so we can add the `loadImage` extension method to load images using the
    `Picasso` library (an image loading library for Android):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中最好的功能之一是*扩展*。它们允许我们向现有类添加新行为（方法或属性）而不更改其实现。有时，当您使用库或框架时，您可能希望为某个类添加额外的方法或属性。扩展是添加这些缺失成员的绝佳方式。扩展减少了代码冗长，并消除了使用Java中已知的实用函数的需要（例如`StringUtils`类）。我们可以轻松地为自定义类、第三方库甚至Android框架类定义扩展。首先，`ImageView`没有从网络加载图像的能力，因此我们可以添加`loadImage`扩展方法来使用`Picasso`库（用于Android的图像加载库）加载图像：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can also add a simple method displaying toasts to the `Activity` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向`Activity`类添加一个显示toast的简单方法：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are many places where usage of *extensions* will make our code simpler
    and more concise. Using Kotlin, we can fully take advantage of lambdas to simplify
    Kotlin code even more.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多地方，使用*扩展*将使我们的代码更简单、更简洁。使用Kotlin，我们可以充分利用lambda来进一步简化Kotlin代码。
- en: 'Interfaces in Kotlin can have default implementations as long as they don''t
    hold any state:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，接口可以具有默认实现，只要它们不保存任何状态：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In Android, there are many applications where we want to delay object initialization
    until it is needed (used). To solve this problem, we can use *delegates* :'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，有许多应用程序需要延迟对象初始化直到需要（使用）它为止。为了解决这个问题，我们可以使用*委托*：
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Retrofit (a popular Android networking framework) property initialization will
    be delayed until the value is accessed for the first time. Lazy initialization
    may result in faster Android application startup time since loading is deferred
    to when the variable is accessed. This is a great way to initialize multiple objects
    inside a class, especially when not all of them are always needed (for certain
    class usage scenario, we may need only specific objects) or when not every one
    of them is needed instantly after class creation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit（一种流行的Android网络框架）属性初始化将延迟到第一次访问该值时。延迟初始化可能会导致更快的Android应用程序启动时间，因为加载被推迟到变量被访问时。这是在类中初始化多个对象的好方法，特别是当它们并非总是需要（对于某些类的使用场景，我们可能只需要特定的对象）或者并非在类创建后立即需要时。
- en: All the presented examples are only a glimpse of what can be accomplished with
    Kotlin. We will learn how to utilize the power of Kotlin throughout this book.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有呈现的示例只是Kotlin可以实现的一小部分。我们将在本书中学习如何利用Kotlin的强大功能。
- en: Dealing with Kotlin code
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理Kotlin代码
- en: There are multiple ways of managing and running Kotlin code. We will mainly
    focus on Android Studio and Kotlin Playground.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种管理和运行Kotlin代码的方式。我们将主要关注Android Studio和Kotlin Playground。
- en: Kotlin Playground
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin Playground
- en: The fastest way to try Kotlin code without the need to install any software
    is Kotlin Playground ([https://try.kotlinlang.org](https://try.kotlinlang.org)
    )*.* We can run Kotlin code there using JavaScript or JVM Kotlin implementations
    and easily switch between different Kotlin versions. All the code examples from
    the book that does not require the Android framework dependencies and can be executed
    using **Kotlin Playground** .
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在不需要安装任何软件的情况下尝试Kotlin代码的最快方式是Kotlin Playground ([https://try.kotlinlang.org](https://try.kotlinlang.org)
    )*.* 我们可以在那里使用JavaScript或JVM Kotlin实现运行Kotlin代码，并轻松切换不同的Kotlin版本。所有不需要Android框架依赖并且可以在**Kotlin
    Playground**中执行的书中代码示例。
- en: '![](img/Image00005.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00005.jpg)'
- en: 'The `main` function is the entry point of every Kotlin application. This function
    is called when any application starts, so we must place code from the book examples
    in the body of this method. We can place code directly or just place a call to
    another function containing more Kotlin code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数是每个Kotlin应用程序的入口点。当任何应用程序启动时，都会调用这个函数，因此我们必须将书中示例的代码放在这个方法的主体中。我们可以直接放置代码，或者只是调用另一个包含更多Kotlin代码的函数：'
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Android Applications have multiple entry points. main function is called implicitly
    by the Android framework, so we can't use it to run Kotlin code on Android platform.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序有多个入口点。`main`函数会被Android框架隐式调用，因此我们不能用它在Android平台上运行Kotlin代码。
- en: Android Studio
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Studio
- en: All Android Studio's existing tools work with Kotlin code. We can easily use
    debugging, lint checks, have proper code assistance, refactoring and more. Most
    of the things work the same way as for Java, so the biggest noticeable change
    is the Kotlin language syntax. All we need to do is to configure Kotlin in the
    project.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Android Studio现有的工具都可以处理Kotlin代码。我们可以轻松使用调试、lint检查、正确的代码辅助、重构等。大部分功能的使用方式与Java相同，因此最明显的变化是Kotlin语言的语法。我们只需要在项目中配置Kotlin即可。
- en: Android applications have multiple entry points (different intents can start
    different components in the application) and require Android framework dependencies.
    To run book examples, we need to extend the `Activity` class and place code there.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序有多个入口点（不同的意图可以启动应用程序中的不同组件），并且需要Android框架依赖。为了运行书中的示例，我们需要扩展`Activity`类并在其中放置代码。
- en: Configuring Kotlin for the project
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为项目配置Kotlin
- en: Starting from Android Studio 3.0, full tooling support for Kotlin was added.
    Installation of the Kotlin plugin is not required and Kotlin is integrated even
    deeper into the Android development process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android Studio 3.0开始，Kotlin获得了完整的工具支持。不需要安装Kotlin插件，Kotlin甚至更深入地集成到了Android开发过程中。
- en: 'To use Kotlin with Android Studio 2.x, we must manually install the Kotlin
    plugin. To install it, we need to go to Android Studio | File | Settings | Plugins
    | Install JetBrains plugin... | Kotlin and press the Install button:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Android Studio 2.x中使用Kotlin，我们必须手动安装Kotlin插件。要安装它，我们需要转到Android Studio | 文件
    | 设置 | 插件 | 安装JetBrains插件... | Kotlin并按下安装按钮：
- en: '![](img/Image00006.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00006.jpg)'
- en: 'To be able to use Kotlin, we need to configure Kotlin in our project. For existing
    Java projects, we need to run the *Configure Kotlin in project* action (the shortcut
    in Windows is *Ctrl* +*Shift* +*A* , and in macOS, it is *command* + *shift* +
    *A* ) or use the corresponding Tools |Kotlin *|* Configure Kotlin in Project menu
    item:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Kotlin，我们需要在项目中配置Kotlin。对于现有的Java项目，我们需要运行*在项目中配置Kotlin*操作（在Windows中的快捷键是*Ctrl*
    +*Shift* +*A*，在macOS中是*command* + *shift* + *A*）或者使用相应的工具 |Kotlin *|* 在项目中配置Kotlin菜单项：
- en: '![](img/Image00007.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00007.jpg)'
- en: 'Then, select Android with Gradle :'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择Android with Gradle：
- en: '![](img/Image00008.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00008.jpg)'
- en: 'Finally, we need to select the required modules and the proper Kotlin version:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要选择所需的模块和适当的Kotlin版本：
- en: '![](img/Image00009.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00009.jpg)'
- en: 'The preceding configuration scenario also applies to all existing Android projects
    that were initially created in Java. Starting from Android Studio 3.0, we can
    also check the Include Kotlin support checkbox while creating a new project:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置场景也适用于最初是用Java创建的所有现有Android项目。从Android Studio 3.0开始，我们还可以在创建新项目时勾选包括Kotlin支持的复选框：
- en: '![](img/Image00010.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00010.jpg)'
- en: 'In both scenarios, the `Configure Kotlin in project` command updates the root
    `build.gradle` file and the `build.gradle` files corresponding to the module(s)
    by adding Kotlin dependencies. It also adds the Kotlin plugin to the Android module.
    During the time of writing this book release version of Android Studio 3 is not
    yet available, but we can review build script from pre-release version:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`在项目中配置Kotlin`命令会通过添加Kotlin依赖项来更新根`build.gradle`文件和对应模块的`build.gradle`文件。它还会将Kotlin插件添加到Android模块中。在撰写本书发布版本的Android
    Studio 3时尚未提供，但我们可以从预发布版本中查看构建脚本：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Prior to Android Plugin for Gradle 3.x (delivered with Android Studio 3.0) *compile*
    dependency configuration was used instead of *implementation* .
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Plugin for Gradle 3.x之前（随Android Studio 3.0提供），使用*compile*依赖配置而不是*implementation*。
- en: 'To update the Kotlin version (let us say in the future), we need to change
    the value of the `kotlin_version` variable in the `build.gradle` file (project
    root folder). Changes in Gradle files mean that the project must be synchronized,
    so Gradle can update its configuration and download all the required dependencies:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新Kotlin版本（比如说在将来），我们需要在`build.gradle`文件（项目根文件夹）中更改`kotlin_version`变量的值。Gradle文件的更改意味着项目必须同步，这样Gradle才能更新其配置并下载所有所需的依赖项：
- en: '![](img/Image00011.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00011.jpg)'
- en: Using Kotlin in a new Android project
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在新的Android项目中使用Kotlin
- en: 'For the new Kotlin projects created in Android Studio 3.x, the main activity
    will be already defined in Kotlin, so that we can start writing Kotlin code right
    away:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio 3.x中创建的新Kotlin项目中，主要活动将已经在Kotlin中定义，因此我们可以立即开始编写Kotlin代码：
- en: '![](img/Image00012.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00012.jpg)'
- en: 'Adding a new Kotlin file is similar to adding a Java file. Simply right-click
    on a package and select new | Kotlin File/Class :'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的Kotlin文件类似于添加Java文件。只需右键单击包，然后选择新建|Kotlin文件/类：
- en: '![](img/Image00013.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00013.jpg)'
- en: The reason why the IDE says Kotlin File/Class and not simply *Kotlin class*
    , analogously to *Java class* is that we can have more members defined inside
    a single file. We will discuss this in more detail in [Chapter 2](text00035.html)
    , *Laying a Foundation* .
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: IDE之所以说Kotlin文件/类而不是简单的*Kotlin类*，类似于*Java类*，是因为我们可以在单个文件中定义更多成员。我们将在[第2章](text00035.html)中更详细地讨论这个问题，*奠定基础*。
- en: 'Notice that Kotlin source files can be located inside the `java` source folder.
    We can create a new source folder for Kotlin, but it is not required:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Kotlin源文件可以位于`java`源文件夹内。我们可以为Kotlin创建一个新的源文件夹，但这并不是必需的：
- en: '![](img/Image00014.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00014.jpg)'
- en: 'Running and debugging a project is exactly the same as in Java and does not
    require any additional steps besides configuring Kotlin in the project:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 运行和调试项目与Java完全相同，除了在项目中配置Kotlin之外，不需要任何额外的步骤：
- en: '![](img/Image00015.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00015.jpg)'
- en: 'Starting from Android Studio 3.0, various Android templates will also allow
    us to select a language. This is the new Configure Activity wizard:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android Studio 3.0开始，各种Android模板也将允许我们选择一种语言。这是新的配置活动向导：
- en: '![](img/Image00016.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00016.jpg)'
- en: Java to Kotlin converter (J2K)
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java转Kotlin转换器（J2K）
- en: Migration of existing Java projects is also quite easy, because we can use Java
    and Kotlin side by side in the same project. There are also ways to convert existing
    Java code into Kotlin code by using the **Java to Kotlin converter** (**J2K**
    ).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移现有的Java项目也相当容易，因为我们可以在同一个项目中同时使用Java和Kotlin。还有一些方法可以通过使用**Java转Kotlin转换器**（**J2K**）将现有的Java代码转换为Kotlin代码。
- en: 'The first way is to convert whole Java files into Kotlin files using the c*onvert
    Java File to Kotlin* command (keyboard shortcut in Windows is *Alt* + *Shift*
    + *Ctrl* + *K* and in macOS: *option* + *shift* + *command* + *K* ), and this
    works very well. The second way is to paste Java code into an existing Kotlin
    file and the code will also be converted (a dialog window will appear with a conversion
    proposition). This may be very helpful when learning Kotlin.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用*将Java文件转换为Kotlin*命令（在Windows中的键盘快捷键为*Alt* + *Shift* + *Ctrl* + *K*，在macOS中为*option*
    + *shift* + *command* + *K*）将整个Java文件转换为Kotlin文件，这非常有效。第二种方法是将Java代码粘贴到现有的Kotlin文件中，代码也将被转换（将出现一个转换建议的对话框）。在学习Kotlin时，这可能非常有帮助。
- en: If we don't know how to write a particular piece of code in Kotlin, we can write
    it in Java, then simply copy to the clipboard and then paste it into the Kotlin
    file. Converted code will not be the most idiomatic version of Kotlin, but it
    will work. The IDE will display various intentions to convert the code even more
    and improve its quality. Before conversion, we need to make sure that Java code
    is valid, because conversion tools are very sensitive and the process will fail
    even if a single semicolon is missing. The J2K converter combined with Java interoperability
    allows Kotlin be introduced gradually into the existing project (for example,
    to convert a single class at a time).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不知道如何用Kotlin编写特定的代码片段，我们可以用Java编写，然后简单地复制到剪贴板，然后粘贴到Kotlin文件中。转换后的代码可能不是最符合Kotlin的版本，但它可以工作。IDE将显示各种意图，以便进一步转换代码并提高其质量。在转换之前，我们需要确保Java代码是有效的，因为转换工具非常敏感，即使缺少一个分号，过程也会失败。J2K转换器结合Java互操作性，允许逐步将Kotlin引入现有项目（例如，逐个转换单个类）。
- en: Alternative ways to run Kotlin code
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Kotlin代码的替代方法
- en: Android Studio offers an alternative way of running Kotlin code without the
    need to run Android application. This is useful when you want to quickly test
    some Kotlin code separately from the long Android compilation and deployment process.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio提供了一种在不运行Android应用程序的情况下运行Kotlin代码的替代方法。当您想要快速测试一些Kotlin代码而不需要进行漫长的Android编译和部署过程时，这是非常有用的。
- en: 'The way to run Kotlin code is to use build Kotlin **Read Eval Print Loop**
    (**REPL** ). REPL is a simple language shell that reads single user input, evaluates
    it, and prints the result:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Kotlin代码的方法是使用构建Kotlin **读取评估打印循环**（**REPL**）。 REPL是一个简单的语言shell，它读取单个用户输入，评估它，并打印结果：
- en: '![](img/Image00017.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00017.jpg)'
- en: 'REPL looks like the command-line, but it will provide us with all the required
    code hints and will give us access to various structures defined inside the project
    (classes, interfaces, top-level functions, and so on):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: REPL看起来像命令行，但它将为我们提供所有所需的代码提示，并且让我们访问项目内定义的各种结构（类、接口、顶级函数等）：
- en: '![](img/Image00018.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00018.jpg)'
- en: The biggest advantage of REPL is its speed. We can test Kotlin code really quickly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: REPL的最大优势是速度。我们可以非常快速地测试Kotlin代码。
- en: Kotlin under the hood
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin的内部工作原理
- en: 'We will focus mainly on Android, but keep in mind that Kotlin can be compiled
    to multiple platforms. Kotlin code can be compiled to *Java bytecode* and then
    to *Dalvik bytecode* . Here is simplified version of the Kotlin build process
    for the Android platform:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要将重点放在Android上，但请记住，Kotlin可以编译到多个平台。Kotlin代码可以编译为*Java字节码*，然后再编译为*Dalvik字节码*。以下是Android平台的Kotlin构建过程的简化版本：
- en: '![](img/Image00019.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00019.jpg)'
- en: A file with a `.java` extension contains Java code
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展名为`.java`的文件包含Java代码
- en: A file with a `.kt` extension contains Kotlin code
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展名为`.kt`的文件包含Kotlin代码
- en: A file with a `.class` extension contains Java bytecode
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展名为`.class`的文件包含Java字节码
- en: A file with a `.dex` extension contains Dalvik bytecode
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展名为`.dex`的文件包含Dalvik字节码
- en: A file with a `.apk` extension contains the `AndroidManifest` file, resources,
    and `.dex` file
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展名为`.apk`的文件包含`AndroidManifest`文件、资源和`.dex`文件
- en: For pure Kotlin projects, only the Kotlin compiler will be used, but Kotlin
    also supports cross-language projects, where we can use Kotlin together with Java
    in the same Android project. In such cases, both compilers are used to compile
    the Android application and the result will be merged at the class level.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于纯Kotlin项目，只会使用Kotlin编译器，但Kotlin也支持跨语言项目，在这种情况下，将同时使用两个编译器来编译Android应用程序，并且结果将在类级别合并。
- en: The Kotlin standard library
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin标准库
- en: '**Kotlin standard library** (**stdlib** ) is a very small library that is distributed
    together with Kotlin. It is required to run applications written in Kotlin and
    it is added automatically to our application during the build process.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kotlin标准库**（**stdlib**）是一个非常小的库，与Kotlin一起分发。运行Kotlin编写的应用程序需要它，并且在构建过程中会自动添加到我们的应用程序中。'
- en: In Kotlin 1.1, `kotlin-runtime` was required to run applications written in
    Kotlin. In fact, in Kotlin 1.1 there were two artifacts (`kotlin-runtime` and
    `kotlin-stdlib` ) that shared a lot of Kotlin packages. To reduce the amount of
    confusion both the artifacts will be merged into single artifact (`kotlin-stdlib`
    ) in in the upcoming 1.2 version of Kotlin. Starting from Kotlin 1.2, `kotlin-stdlib`
    is required to run applications written in Kotlin.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin 1.1中，运行Kotlin编写的应用程序需要`kotlin-runtime`。事实上，在Kotlin 1.1中有两个组件（`kotlin-runtime`和`kotlin-stdlib`）共享了很多Kotlin包。为了减少混乱，这两个组件将在即将推出的Kotlin
    1.2版本中合并为单个组件（`kotlin-stdlib`）。从Kotlin 1.2开始，运行Kotlin编写的应用程序需要`kotlin-stdlib`。
- en: 'The Kotlin standard library provides essential elements required for everyday
    work with Kotlin. These include:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库提供了与Kotlin的日常工作所需的基本元素。这些包括：
- en: Data types like arrays, collections, lists, ranges, and so on
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组、集合、列表、范围等数据类型
- en: Extensions
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展
- en: Higher-order functions
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Various utilities for working with strings and char sequences
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于处理字符串和字符序列的各种实用工具
- en: Extensions for JDK classes making it convenient to work with files, IO, and
    threading
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为JDK类提供的扩展，使得处理文件、IO和线程变得更加方便。
- en: More reasons to use Kotlin
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kotlin的更多原因
- en: Kotlin has strong commercial support from JetBrains, a company that delivers
    very popular IDEs for many popular programming languages (Android Studio is based
    on JetBrains IntelliJ IDEA). JetBrains wanted to improve the quality of their
    code and team performance, so they needed the language that will solve all the
    Java issues and provide seamless interoperability with Java. None of the other
    JVM languages meet those requirements, so JetBrains finally decided to create
    their own language and started the Kotlin project. Nowadays, Kotlin is used in
    their flagship products. Some use Kotlin together with Java while others are pure
    Kotlin products.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin得到了JetBrains的强大商业支持，这家公司为许多流行的编程语言提供了非常受欢迎的IDE（Android Studio基于JetBrains
    IntelliJ IDEA）。JetBrains希望提高他们的代码质量和团队绩效，因此他们需要一种能解决所有Java问题并提供与Java无缝互操作性的语言。没有其他JVM语言符合这些要求，因此JetBrains最终决定创建自己的语言并开始Kotlin项目。如今，Kotlin被用于他们的旗舰产品。有些人将Kotlin与Java一起使用，而另一些则是纯Kotlin产品。
- en: 'Kotlin is quite a mature language. In fact, its development started many years
    before Google announced official Android support (first commit dates back to 2010-11-08):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin是一种非常成熟的语言。事实上，它的开发早在Google宣布官方支持Android之前就开始了（第一个提交日期为2010-11-08）：
- en: '![](img/Image00020.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00020.jpg)'
- en: The initial name of the language was **Jet** . At some point, the JetBrains
    team decided to rename it to Kotlin. The name comes from Kotlin Island, near St.
    Petersburg and its analogy to Java which was also named after the Indonesian island.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的初始名称是**Jet**。在某个时候，JetBrains团队决定将其改名为Kotlin。这个名字来自于圣彼得堡附近的科特林岛，类似于Java，Java也是以印度尼西亚岛屿命名的。
- en: After the version 1.0 release in 2016, more and more companies started to support
    the Kotlin project. Gradle added support of Kotlin into building scripts, Square,
    the biggest creator of Android libraries posted that they strongly support Kotlin
    and finally, Google announced it's official Kotlin support for the Android platform.
    This means that every tool that will be released by the Android team will be compatible
    not only with Java but also with Kotlin. Google and JetBrains have begun a partnership
    to create a nonprofit foundation for Kotlin, responsible for future language maintenance
    and development. All of this will greatly increase the number of companies that
    will use Kotlin in their projects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在2016年发布1.0版本后，越来越多的公司开始支持Kotlin项目。Gradle将Kotlin支持添加到构建脚本中，Android库的最大创建者Square表示他们强烈支持Kotlin，最后，Google宣布了官方对Android平台的Kotlin支持。这意味着Android团队发布的每个工具都不仅与Java兼容，还与Kotlin兼容。Google和JetBrains已经开始合作，创建一个负责未来语言维护和开发的非营利基金会。所有这些都将大大增加使用Kotlin的公司数量。
- en: Kotlin is also similar to Apple's Swift programming language. In fact, such
    is the resemblance, that some articles focus on differences, not similarities.
    Learning Kotlin will be very helpful for developers eager to develop applications
    for Android and iOS. There are also plans to port Kotlin to iOS (Kotlin/Native),
    so maybe we don't have to learn Swift after all. Full stack development is also
    possible in Kotlin, so we can develop server-side applications and frontend clients
    sharing the same data model with mobile clients.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin也类似于苹果的Swift编程语言。事实上，它们如此相似，以至于一些文章关注的是差异，而不是相似之处。学习Kotlin对于渴望为Android和iOS开发应用程序的开发人员将非常有帮助。还有计划将Kotlin移植到iOS（Kotlin/Native），所以也许我们根本不需要学习Swift。在Kotlin中也可以进行全栈开发，因此我们可以开发服务器端应用程序和共享与移动客户端相同数据模型的前端客户端。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've discussed how the Kotlin language fits into Android development and how
    we can incorporate Kotlin into new and existing projects. We have seen useful
    examples where Kotlin simplified the code and made it much safer. There are still
    many interesting things to discover.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Kotlin语言如何适用于Android开发，以及我们如何将Kotlin纳入新项目和现有项目中。我们已经看到了Kotlin简化了代码并使其更安全的有用示例。还有许多有趣的事情等待我们去发现。
- en: In the next chapter, we will learn about Kotlin building blocks and lay a foundation
    to develop Android applications using Kotlin.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Kotlin的构建模块，并奠定使用Kotlin开发Android应用程序的基础。
