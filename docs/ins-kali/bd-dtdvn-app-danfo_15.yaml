- en: '*Chapter 12*: Building a Twitter Analysis Dashboard'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：构建Twitter分析仪表板'
- en: The main goal of this chapter is to show how you can build a full stack web
    analytics platform using Danfo.js at the backend and the frontend.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是展示如何使用Danfo.js在后端和前端构建全栈Web分析平台。
- en: To demonstrate this, we will be building a small single-page web app in which
    you can run a search on a Twitter user, obtain all the tweets in which they are
    mentioned on a specific day, and perform some simple analysis such as sentiment
    analysis, drawing insights from the data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将构建一个小型的单页面Web应用程序，在这个应用程序中，您可以搜索Twitter用户，获取他们在特定日期被提及的所有推文，并进行一些简单的分析，比如情感分析，从数据中得出一些见解。
- en: 'In this chapter, we''ll look at the following topics for building the web app:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究构建Web应用程序的以下主题：
- en: Setting up the project environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目环境
- en: Building the backend
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建后端
- en: Building the frontend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建前端
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is required for this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下内容：
- en: Knowledge of React.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React.js的知识
- en: 'The code for this chapter, which is available here: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter12](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter12)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码在这里可用：[https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter12](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter12)
- en: Setting up the project environment
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目环境
- en: For this project, we will build a single web page with both a backend and a
    frontend. We will be using the Next.js framework to build the app. Next.js makes
    it possible for you to build the backend and frontend quickly and easily. We will
    also make use of `tailwindcss,` as we have done for some of our previous projects,
    such as the no-code environment project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将构建一个既有后端又有前端的单个网页。我们将使用Next.js框架来构建应用程序。Next.js使您能够快速轻松地构建后端和前端。我们还将使用`tailwindcss`，就像我们之前为一些项目所做的那样，比如无代码环境项目。
- en: 'To set up our project environment with Next.js containing the default `tailwindcss`
    configuration, all we need to do is run the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 设置我们的项目环境与Next.js包含默认的`tailwindcss`配置，我们只需要运行以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `npx` command runs `create-next-app`, which creates Next.js boilerplate
    code, including the `tailwindcss` configuration in the `twitterdashboard` directory.
    Note that the `twitterdashboard` directory (also called *project name*) can be
    given any name of your choice. If everything is successfully installed, you should
    get the output shown in the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`npx`命令运行`create-next-app`，它在`twitterdashboard`目录中创建了Next.js样板代码，包括`tailwindcss`配置。请注意，`twitterdashboard`目录（也称为*项目名称*）可以根据您的选择命名。如果一切安装成功，您应该会得到以下截图中显示的输出：'
- en: '![Figure 12.1 – Code environment setup'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – 代码环境设置'
- en: '](img/B17076_12_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_12_01.jpg)'
- en: Figure 12.1 – Code environment setup
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 代码环境设置
- en: 'Now that we are done with the installation, if everything works correctly,
    you should have the following files in your project:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了安装，如果一切正常工作，您应该在项目中有以下文件：
- en: '![Figure 12.2 – Directory structure'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 – 目录结构'
- en: '](img/B17076_12_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_12_02.jpg)'
- en: Figure 12.2 – Directory structure
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 目录结构
- en: 'Finally, to test whether the project is well installed and ready to go, let''s
    run the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了测试项目是否安装成功并准备就绪，让我们运行以下命令：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command should automatically start the app and open up the browser, showing
    the following interface:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令应该自动启动应用程序并打开浏览器，显示以下界面：
- en: '![Figure 12.3 – Next.js UI'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 – Next.js UI'
- en: '](img/B17076_12_03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_12_03.jpg)'
- en: Figure 12.3 – Next.js UI
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – Next.js UI
- en: For this project, we will modify the interface shown in *Figure 12.3* to suit
    our tastes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将修改*图12.3*中显示的界面以适应我们的口味。
- en: Now that the code environment is set up, let's move on to creating our app.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码环境已经设置好了，让我们继续创建我们的应用程序。
- en: Building the backend
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建后端
- en: 'In this section, we will be looking at how to create the following APIs for
    our app:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何为我们的应用程序创建以下API：
- en: '`/api/tweet`: This API is responsible for fetching a Twitter user and obtaining
    their data.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/tweet`：这个API负责获取Twitter用户并获取他们的数据。'
- en: '`/api/nlp`: This API is responsible for running sentiment analysis on the obtained
    user data.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/nlp`：这个API负责对获取的用户数据进行情感分析。'
- en: These APIs will be consumed by the frontend components and will be used to create
    different visualizations and analyses. Let's start by creating the API to fetch
    a Twitter user's data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API将被前端组件所使用，并将用于创建不同的可视化和分析。让我们从创建用于获取Twitter用户数据的API开始。
- en: Building the Twitter API
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建Twitter API
- en: In this section, we will build an API that makes it easy to obtain tweets in
    which a Twitter user is mentioned. From each of the tweets, we will obtain their
    metadata, such as the text, the name of the sender, the numbers of likes and retweets,
    the device used to tweet, and the time the tweet was created.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个API，使得轻松获取Twitter用户被提及的推文。从每条推文中，我们将获取它们的元数据，比如文本、发送者的姓名、喜欢和转发的次数、用于发推的设备以及推文创建的时间。
- en: 'To build the Twitter API for fetching a Twitter user''s data and structure
    it to our taste for easy consumption in the frontend, we need to install a tool
    that makes it easier to interact with the main Twitter developer API. In the following
    command, we will install `twit.js` for easy access and handling of the Twitter
    API:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建用于获取Twitter用户数据的Twitter API，并将其结构化为我们喜欢的形式，以便在前端轻松使用，我们需要安装一个工具，使其更容易与主要的Twitter开发者API进行交互。在以下命令中，我们将安装`twit.js`以便轻松访问和处理Twitter
    API：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once `twit` is installed, we need to configure it. To use `twit`, we will need
    various Twitter developer keys, such as the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了`twit`，我们需要对其进行配置。为了使用`twit`，我们需要各种Twitter开发者密钥，比如以下内容：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you don't have these keys, you will need to create a Twitter developer account
    and then apply to get access to the API via [https://developer.twitter.com/](https://developer.twitter.com/).
    If given access to use the Twitter API, you can visit [https://developer.twitter.com/en/apps](https://developer.twitter.com/en/apps)
    to create an app and set up your credential keys.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有这些密钥，您将需要创建一个Twitter开发者账户，然后申请通过[https://developer.twitter.com/](https://developer.twitter.com/)获得API访问权限。如果获得使用Twitter
    API的权限，您可以访问[https://developer.twitter.com/en/apps](https://developer.twitter.com/en/apps)创建一个应用程序并设置您的凭证密钥。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Obtaining the Twitter API might take several days, based on how you describe
    your use case. For a proper step-by-step guide with visual aids to setting up
    the Twitter API and obtaining the necessary keys, follow the steps here: [https://realpython.com/twitter-bot-python-tweepy/#creating-twitter-api-authentication-credentials](https://realpython.com/twitter-bot-python-tweepy/#creating-twitter-api-authentication-credentials).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 获取Twitter API可能需要几天的时间，这取决于您描述用例的方式。要获得关于设置Twitter API和获取必要密钥的逐步指南以及视觉辅助，请按照这里的步骤：[https://realpython.com/twitter-bot-python-tweepy/#creating-twitter-api-authentication-credentials](https://realpython.com/twitter-bot-python-tweepy/#creating-twitter-api-authentication-credentials)。
- en: 'After obtaining the Twitter developer keys needed for the project, we''ll make
    use of them in our code. To prevent exposing the keys to the public, let''s create
    a file named `.env.local`, and in this file, let''s add our API keys as shown
    in the following code block:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得项目所需的Twitter开发者密钥之后，我们将在我们的代码中使用它们。为了防止将密钥暴露给公众，让我们创建一个名为`.env.local`的文件，并在这个文件中添加我们的API密钥，如下面的代码块所示：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In Next.js, all APIs are created in a `/pages/api` folder. Next.js uses a file
    structure in the `pages/` folder to create the URL route. For example, if you
    have a file named `login.js` located in the `pages/` folder, the content in `login.js`
    will be rendered in `http://localhost:3000/login`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Next.js中，所有API都是在`/pages/api`文件夹中创建的。Next.js使用`pages/`文件夹中的文件结构来创建URL路由。例如，如果您在`pages/`文件夹中有一个名为`login.js`的文件，那么`login.js`中的内容将在`http://localhost:3000/login`中呈现。
- en: The preceding paragraph shows how a route is created for web pages in Next.js
    based on the filename and structure. The same thing applies to creating APIs in
    Next.js.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的段落展示了基于文件名和结构在Next.js中为网页创建路由的方法。同样的方法也适用于在Next.js中创建API。
- en: 'Let''s assume we created an API for signing up in `signup.js` located in `pages/api`.
    This API will automatically be available in `http://localhost:3000/api/signup`
    and if we were to use this API within the app itself, we could make a call to
    it like this: `/api/signup`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在`pages/api`中创建了一个用于注册的API，名为`signup.js`。这个API将自动在`http://localhost:3000/api/signup`中可用，如果我们要在应用程序内部使用这个API，我们可以这样调用它：`/api/signup`。
- en: 'For our `/api/tweet` API, let''s create a file named `tweet.js` in `pages/api/`
    and update the file with the following steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`/api/tweet` API，让我们在`pages/api/`中创建一个名为`tweet.js`的文件，并按照以下步骤更新文件：
- en: 'First, we import `twit.js`, and then create a function to clean each of the
    tweets:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入`twit.js`，然后创建一个函数来清理每个推文：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `clean_tweet` function takes in tweet text, normalizes the text, removes
    the hashtag character, users' names, URL links, and newlines, and then trims the
    text.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`clean_tweet`函数接受推文文本，规范化文本，移除标签字符，用户名称，URL链接和换行符，然后修剪文本。'
- en: 'We then create a function called `twitterApi`, which will be used to create
    our API:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个名为`twitterApi`的函数，用于创建我们的API：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `twitterApi` function takes in two arguments, `req` and `res`, which are
    the server request and response arguments.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`twitterApi`函数接受两个参数，`req`和`res`，分别是服务器请求和响应的参数。'
- en: 'We will now update `twitterApi` with the necessary code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将使用必要的代码更新`twitterApi`：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we check whether the `req.method` request method is a `POST` method,
    and then we obtain the username from the request body sent via the search box.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查`req.method`请求方法是否为`POST`方法，然后我们从通过搜索框发送的请求体中获取用户名。
- en: The `Twit` class is instantiated and our Twitter API keys are passed in. Since
    our Twitter developer API keys are stored as environmental keys in `.env.local`,
    we can easily access each of the keys using `process.env`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Twit`类被实例化，并且我们的Twitter API密钥被传入。由于我们的Twitter开发者API密钥存储为`.env.local`中的环境密钥，我们可以使用`process.env`轻松访问每个密钥。'
- en: 'We''ve configured `twit.js` with our API keys. Let''s now do a search of all
    the tweets that mention a user:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经使用我们的API密钥配置了`twit.js`。现在让我们搜索提到用户的所有推文：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We search for all tweets using the `search/tweets` API in the `T.get` method.
    We then pass in the `param` object containing the username of the user we want
    to search for.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`T.get`方法中的`search/tweets` API搜索所有推文。然后我们传入包含我们想要搜索的用户的用户名的`param`对象。
- en: 'A `dfData` object is created to structure the data based on how we want the
    API output response to be. `dfData` contains the following keys, which are the
    metadata we want to extract from the tweet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`dfData`对象来根据我们希望的API输出响应的方式对数据进行结构化。`dfData`包含以下键，这些键是我们想要从推文中提取的元数据：
- en: '`text`: The texts in the tweet'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`：推文中的文本'
- en: '`length`: The length of the tweet'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：推文的长度'
- en: '`date`: The date the tweet was tweeted'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`：推文发布日期'
- en: '`source`: The device used to create the tweet'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`：用于创建推文的设备'
- en: '`likes`: The number of likes the tweet has'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`likes`：推文的点赞数'
- en: '`retweet`: The number of retweets the tweet has'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retweet`：推文的转发数'
- en: '`users`: The user who created the tweet'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users`：创建推文的用户'
- en: 'The metadata in the preceding list is extracted from the JSON data returned
    from `search/tweets` in the `T.get()` method from the preceding code. All the
    metadata extracted from this JSON data is contained in an array of objects called
    `statuses` and the following shows the structure of the JSON data:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面列表中的元数据是从前面代码中的`T.get()`方法返回的`search/tweets`中提取的JSON数据中提取的。从这个JSON数据中提取的所有元数据都包含在一个名为`statuses`的对象数组中，以下是JSON数据的结构：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Twitter API is created and ready to use. Let's move ahead to create the
    sentiment analysis API.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter API已经创建并准备好使用。让我们继续创建情感分析API。
- en: Building the text sentiment API
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建文本情感API
- en: From the `/api/tweet` API, we are going to obtain the structured JSON data and
    then perform sentiment analysis.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从`/api/tweet` API中，我们将获取结构化的JSON数据，然后进行情感分析。
- en: The sentiment analysis on the data will be fetched via the `/api/nlp` route.
    Hence, in this section, we will see how to create a sentiment analysis API for
    our Twitter data.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的情感分析将通过`/api/nlp`路由获取。因此，在本节中，我们将看到如何为我们的Twitter数据创建情感分析API。
- en: 'Let''s create a file named `nlp.js` in the `/pages/api/` folder and update
    it with the following steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`/pages/api/`文件夹中创建一个名为`nlp.js`的文件，并按以下步骤更新它：
- en: 'We will make use of the `nlp-node.js` package for our sentiment analysis. We''ll
    also make use of `danfojs-node` for data preprocessing, so let''s install these
    two packages:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`nlp-node.js`包进行情感分析。我们还将使用`danfojs-node`进行数据预处理，因此让我们安装这两个包：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We import `SentimentAnalyzer` from `nlp-node` and `DataFrame` from `danfojs-node`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`nlp-node`和`danfojs-node`中导入`SentimentAnalyzer`和`DataFrame`：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will create a default `SentimentApi` export function, which will contain
    our API code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个默认的`SentimentApi`导出函数，其中将包含我们的API代码：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will then check whether the request method is a `POST` request, and then
    perform some data preprocessing on the data obtained from the request body:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将检查请求方法是否为`POST`请求，然后对从请求体获取的数据进行一些数据预处理：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we first instantiated `SentimentAnalyzer`, and then set
    its language configuration to English (`en`). We then obtained `dfData` and `username`
    from the request body.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先实例化了`SentimentAnalyzer`，然后将其语言配置设置为英语（`en`）。然后我们从请求体中获取了`dfData`和`username`。
- en: To analyze and create insights from the data, we only want to consider the user's
    interaction with others and not themself; that is, we don't want to consider tweets
    where the user replied to themself. Hence, we filter out the user's replies from
    the DataFrame generated from `dfData`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析和从数据中创建见解，我们只想考虑用户与他人的互动，而不是他们自己；也就是说，我们不想考虑用户回复自己的推文。因此，我们从从`dfData`生成的DataFrame中过滤出用户的回复。
- en: 'Sometimes, a tweet will just contain a hashtag or reference a user with the
    `@` sign. However, we removed the hashtags and `@` signs during our cleaning process
    earlier, which will result in some tweets ending up not containing any text. Therefore,
    we will create a new `filterBylength` DataFrame that will contain non-empty text:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一条推文可能只包含一个标签或使用`@`符号引用用户。但是，在我们之前的清理过程中，我们删除了标签和`@`符号，这将导致一些推文最终不包含任何文本。因此，我们将创建一个新的`filterBylength`
    DataFrame，其中将包含非空文本：
- en: 'We will move ahead to creating an object that will contain the overall sentiment
    count for the user''s data and is sent to the frontend whenever we make a call
    to the API:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续创建一个对象，该对象将包含用户数据的整体情感计数，并在我们调用API时发送到前端：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we create object data to store the overall sentiment
    analysis. Since sentiment analysis will only be performed on the text data from
    the `filterByLength` DataFrame, we extract the text column values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建数据对象来存储整体情感分析。由于情感分析只会在`filterByLength` DataFrame中的文本数据上执行，我们提取文本列值。
- en: 'We then loop through the text column values extracted and pass them into `sentiment.getSentiment`.
    For each piece of text passed into `sentiment.getSentiment`, the following types
    of objects are returned:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们循环遍历提取的文本列值，并将它们传递给`sentiment.getSentiment`。对于传递给`sentiment.getSentiment`的每个文本，将返回以下类型的对象：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For our use case, we only need the key value of `vote`. Hence, we check whether
    the value of `vote` for a text is `negative`, `positive`, or `neutral`, and we
    then increment the count of each of these keys in a data object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用例，我们只需要`vote`的键值。因此，我们检查文本的`vote`值是`negative`、`positive`还是`neutral`，然后递增数据对象中每个键的计数。
- en: 'Hence, whenever a call is made to `/api/nlp`, we should receive the following
    response, for example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当调用`/api/nlp`时，我们应该收到以下响应，例如：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this section, we saw how we can create APIs in Next.js and, more importantly,
    we saw how it is convenient to use Danfo.js in the backend. In the next section,
    we will implement the frontend part of the app.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何在Next.js中创建API，更重要的是，我们看到了在后端使用Danfo.js是多么方便。在下一节中，我们将实现应用程序的前端部分。
- en: Building the frontend
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建前端
- en: 'For our frontend design, we will use the default UI that comes with Next.js,
    as shown in *Figure 12.3*. We will implement the following set of components for
    our frontend:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的前端设计，我们将使用Next.js默认的UI，如*图12.3*所示。我们将为我们的前端实现以下一组组件：
- en: 'The `Search` component: Creates a search box to search for Twitter users.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Search`组件：创建一个搜索框来搜索Twitter用户。'
- en: 'The `ValueCount` component: Obtains the count of unique values and plots it
    using a bar chart or pie chart.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValueCount`组件：获取唯一值的计数并使用条形图或饼图绘制它。'
- en: 'The `Plot` component: This component is used to plot our sentiment analysis
    in the form of a bar chart.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Plot`组件：此组件用于以条形图的形式绘制我们的情感分析。'
- en: 'The `Table` component: This is used to display the obtained user data in table
    form.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Table`组件：用于以表格形式显示获取的用户数据。'
- en: In the following sections, we'll implement the preceding list of components.
    Let's get started by implementing the `Search` component.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将实现上述组件列表。让我们开始实现`Search`组件。
- en: Creating the Search component
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建搜索组件
- en: 'The `Search` component is the main component for setting the app in action.
    It provides the input field in which a Twitter user''s name can be inputted and
    then searched for. The `search` component enables us to make a call to the two
    APIs created: `/api/tweet` and `/api/nlp`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Search`组件是设置应用程序运行的主要组件。它提供了输入字段，可以在其中输入Twitter用户的名称，然后进行搜索。`search`组件使我们能够调用创建的两个API：`/api/tweet`和`/api/nlp`。'
- en: In our `twitterdashboard` project directory, let's create a directory called
    `components`, and in that directory, we'll create a JavaScript file named `Search.js`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`twitterdashboard`项目目录中，让我们创建一个名为`Search.js`的目录，并在该目录中创建一个名为`Search.js`的JavaScript文件。
- en: 'In `Search.js`, let''s input the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Search.js`中，让我们输入以下代码：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we created a `Search` function with the following set
    of props:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个带有以下一组props的`Search`函数：
- en: '`inputRef`: This prop is obtained from the `useRef` React Hook. It will be
    used to track the current value of the search input field.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inputRef`：此prop是从`useRef` React Hook获取的。它将用于跟踪搜索输入字段的当前值。'
- en: '`handleKeyEvent`: This is an event function that will be passed to the search
    input field to enable search by just pressing the *Enter* key.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleKeyEvent`：这是一个事件函数，将被传递给搜索输入字段，以便通过按*Enter*键进行搜索。'
- en: '`handleSubmit`: This is a function that will be activated anytime you click
    the search button. The `handleSubmit` function is responsible for making a call
    to our API.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleSubmit`：这是一个函数，每次单击搜索按钮时都会激活。`handleSubmit`函数负责调用我们的API。'
- en: 'Let''s move on to `/pages/index.js` to update the file by importing the `Search`
    component and creating the preceding list of required props based on the following
    steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前往`/pages/index.js`，通过导入`Search`组件并根据以下步骤创建所需的props列表来更新文件：
- en: 'First, we will import React, React Hooks, and the `Search` component:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入React、React Hooks和`Search`组件：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we will create some sets of state:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一些状态集：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will then create the `handleSubmit` function to make a call to our API and
    update the state data:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建`handleSubmit`函数来调用我们的API并更新状态数据：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, in `handleSubmit`, we make a call to the `/api/tweet` API to obtain the
    user's data. In the `fetch` function, we obtain the current value of the `inputRef.current.value`
    search field and convert it into a JSON object, which is passed into the request
    body. A variable result is then used to obtain the JSON data from the API.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`handleSubmit`中，我们调用`/api/tweet` API来获取用户的数据。在`fetch`函数中，我们获取`inputRef.current.value`搜索字段的当前值，并将其转换为JSON对象，然后传递到请求体中。然后使用变量result来从API获取JSON数据。
- en: 'We further update the `handleSubmit` function to fetch data from `/api/nlp`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们进一步更新`handleSubmit`函数以从`/api/nlp`获取数据：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code is the same as that in *Step 3*. The only difference is that
    we make a call to the `/api/nlp` API and then pass the result data from *Step
    3* and the username obtained from the search input field into the request body.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与*步骤3*中的代码相同。唯一的区别是我们调用`/api/nlp` API，然后将*步骤3*中的结果数据和从搜索输入字段获取的用户名传递到请求体中。
- en: 'We then update the following states in `handleSubmit`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在`handleSubmit`中更新以下状态：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will create the `handleKeyEvent` function to enable search by pressing
    the *Enter* key:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`handleKeyEvent`函数以通过按*Enter*键进行搜索：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we check whether the keypress is an *Enter* key, and
    if it is, we make a call to the `handleSubmit` function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们检查按键是否为*Enter*键，如果是，则调用`handleSubmit`函数。
- en: 'Finally, we make a call to our `Search` component:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用我们的`Search`组件：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Remember, we said that we'll be using Next.js's default UI. Hence, in `index.js`,
    let's convert `Welcome to Next.js` to `Welcome to Twitter Dashboard`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们说过我们将使用Next.js的默认UI。因此，在`index.js`中，让我们将`Welcome to Next.js`转换为`Welcome
    to Twitter Dashboard`。
- en: 'After updating `index.js`, you can check your browser for the update at `http://localhost:3000/`.
    You''ll see the following changes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`index.js`后，您可以在`http://localhost:3000/`检查浏览器的更新。您将看到以下更改：
- en: '![Figure 12.4 – index.js updated with the search component'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 - index.js更新为搜索组件'
- en: '](img/B17076_12_04.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_12_04.jpg)'
- en: Figure 12.4 – index.js updated with the search component
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 - index.js更新为搜索组件
- en: The `Search` component is implemented and infused into the main app, and all
    the required state data can easily be updated by the `Search` component. Let's
    go ahead and implement the `ValueCounts` component.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Search`组件已经实现并融入到主应用程序中，所有必需的状态数据都可以轻松地由`Search`组件更新。让我们继续实现`ValueCounts`组件。'
- en: Creating the ValueCounts component
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建ValueCounts组件
- en: We will be creating a simple analysis for the obtained data from `/api/tweet`.
    This analysis involves checking the number of times the unique values in a column
    exist. We'll obtain the value count of the `source` column and the `users` column.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为从`/api/tweet`获取的数据创建一个简单的分析。这个分析涉及检查列中唯一值存在的次数。我们将获得`source`列和`users`列的值计数。
- en: The value count from the `source` column tells us the device used by other Twitter
    users to interact with our searched user. The value count from the `users` column
    tells us the users who interact most with our searched user.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`source`列的值计数告诉我们其他Twitter用户用于与我们搜索的用户进行交互的设备。`users`列的值计数告诉我们与我们搜索的用户互动最多的用户。'
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code used here is copied from the *Implementing the chart component* section
    in [*Chapter 8*](B17076_08_ePub_RK.xhtml#_idTextAnchor149), *Creating a No-Code
    Data Analysis/Handling System*. The code for this section can be obtained here:
    [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter12/components/ValueCounts.js](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter12/components/ValueCounts.js).
    Most of the code won''t be explained in detail here.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的代码是从[*第8章*](B17076_08_ePub_RK.xhtml#_idTextAnchor149)的*实现图表组件*部分中复制的，*创建无代码数据分析/处理系统*。此部分的代码可以在此处获取：[https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter12/components/ValueCounts.js](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js-/blob/main/Chapter12/components/ValueCounts.js)。这里大部分代码不会在这里详细解释。
- en: 'Let''s go to the `components/` directory and create a file named `ValueCounts.js`,
    and then update it with the following steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到`components/`目录并创建一个名为`ValueCounts.js`的文件，然后按以下步骤更新它：
- en: 'First, we import the necessary modules:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入必要的模块：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we create a function called `ValueCounts`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为`ValueCounts`的函数：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The function accepts the following props:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受以下props：
- en: 'a) `data`: This is the data from `/api/tweet`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: a) `data`：这是来自`/api/tweet`的数据。
- en: 'b) `column`: The name of the column from which we want to obtain the value
    count.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: b) `column`：我们要获取值计数的列的名称。
- en: 'c) `username`: The inputted username from the search field.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: c) `username`：来自搜索字段的输入用户名。
- en: 'd) `type`: The type of chart we want to plot.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: d) `type`：我们要绘制的图表类型。
- en: 'Next, we update the `ValueCounts` function:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们更新`ValueCounts`函数：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we first create a DataFrame from the data and then filter
    out the rows containing the searched user since we don't want tweets where the
    user is interacting with themself. We then extract the `value_counts` value from
    the passed-in column. From the created `countSeries` variable, we generate our
    labels and values, which we will use for plotting our chart.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先从数据创建一个DataFrame，然后过滤掉包含搜索用户的行，因为我们不希望用户与自己交互的推文。然后，我们从传入的列中提取`value_counts`值。从创建的`countSeries`变量中，我们生成标签和值，这将用于绘制我们的图表。
- en: 'We then create a chart data variable called `dataChart`, which will be in the
    format accepted by the `chart` component:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为`dataChart`的图表数据变量，它将符合`chart`组件所接受的格式：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `dataChart` object contains the labels and values created in *Step 3*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataChart`对象包含在*步骤3*中创建的标签和值。'
- en: 'We create a conditional rendering to check the type of chart to plot:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个条件渲染来检查要绘制的图表类型：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `ValueCounts` component is set.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueCounts`组件已设置。'
- en: 'We can now import the `ValueCounts` component into `index.js` using the following
    steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下步骤将`ValueCounts`组件导入`index.js`：
- en: 'We import `ValueCounts`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入`ValueCounts`：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The way we import `ValueCounts` is different from the way we import the `Search`
    component. This is because in `ValueCounts`, we use some core browser-specific
    tools in TensorFlow.js, which is required in Danfo.js. Hence, we need to prevent
    Next.js from rendering the component from the server to prevent an error.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`ValueCounts`的方式与导入`Search`组件的方式不同。这是因为在`ValueCounts`中，我们使用了TensorFlow.js中的一些核心浏览器特定工具，这是Danfo.js所需的。因此，我们需要防止Next.js从服务器渲染组件，以防止出现错误。
- en: To prevent Next.js from rendering a component from the server, we use `next/dynamic`,
    and we then wrap the component to be imported in the `dynamic` function, as well
    as setting the `ssr` key to `false`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止Next.js从服务器渲染组件，我们使用`next/dynamic`，然后将要导入的组件包装在`dynamic`函数中，并将`ssr`键设置为`false`。
- en: Note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To find out more about `next/dynamic`, check out [https://nextjs.org/docs/advanced-features/dynamic-import](https://nextjs.org/docs/advanced-features/dynamic-import).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`next/dynamic`的更多信息，请访问[https://nextjs.org/docs/advanced-features/dynamic-import](https://nextjs.org/docs/advanced-features/dynamic-import)。
- en: 'We make a call to the `ValueCounts` component, which is now named `DynamicValueCounts`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`ValueCounts`组件，现在命名为`DynamicValueCounts`：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We check whether the state data is undefined and that the user's data has been
    fetched from `/api/tweet`. If so, we render the `ValueCounts` component for the
    `source` column.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查状态数据是否未定义，并且用户数据是否已从`/api/tweet`获取。如果是这样，我们就为`source`列呈现`ValueCounts`组件。
- en: 'Let''s also add `ValueCounts` for the `users` column:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还为`users`列添加`ValueCounts`：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We specify `BarChart` for the user's `ValueCounts` chart and `PieChart` for
    the `ValueCounts` source.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为用户的`ValueCounts`图表指定`BarChart`，并为`ValueCounts`源指定`PieChart`。
- en: 'The following shows the display of `ValueCounts` for the source and user interactions
    whenever a user is searched:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了每当搜索用户时，`ValueCounts`显示源和用户交互的显示：
- en: '![Figure 12.5 – ValueCounts chart result for the source and user columns'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – 源和用户列的ValueCounts图表结果'
- en: '](img/B17076_12_05.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_12_05.jpg)'
- en: Figure 12.5 – ValueCounts chart result for the source and user columns
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 源和用户列的ValueCounts图表结果
- en: The value count is done and working okay. Let's move on to create a plot for
    our sentiment analysis data obtained from `/api/nlp`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 值计数已完成并且工作正常。让我们继续从`/api/nlp`获取的情感分析数据创建一个图表。
- en: Creating a plot component for sentiment analysis
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建情感分析的图表组件
- en: When a user is searched by using the search field, the `sentiData` state is
    updated to contain the sentiment data from `/api/nlp`. In this section, we will
    create a `Plot` component for the data.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用搜索字段搜索用户时，`sentiData`状态将更新为包含来自`/api/nlp`的情感数据。在本节中，我们将为数据创建一个`Plot`组件。
- en: 'Let''s create a `Plot.js` file in the `components/` directory and update it
    with the following steps:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`components/`目录中创建一个`Plot.js`文件，并按照以下步骤进行更新：
- en: 'First, we import the required modules:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的模块：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We then create a `Plot` function to plot a chart for sentiment data:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为`Plot`的函数来绘制情感数据的图表：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The function accepts a `data` prop. We then create a `dataChart` object containing
    the format for the `chart` component. We specify the chart label by obtaining
    the keys in the `data` props and also specify the value of key data in `dataChart`
    by obtaining the values of the `data` props. The `dataChart` object is passed
    into the `BarChart` component. The `Plot` component is now created for the sentiment
    analysis chart.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个`data`属性。然后我们创建一个包含`chart`组件格式的`dataChart`对象。我们通过获取`data`属性中的键来指定图表标签，并通过获取`data`属性的值来指定`dataChart`中键数据的值。`dataChart`对象传递到`BarChart`组件中。`Plot`组件现在用于情感分析图表。
- en: 'The next step is to import the `Plot` component inside `index.js` and make
    a call to it:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在`index.js`中导入`Plot`组件并调用它：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With the preceding update in `index.js`, we should see the following chart
    for sentiment analysis whenever we search for a user:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`index.js`中进行上述更新，每当搜索用户时，我们应该看到情感分析的以下图表：
- en: '![Figure 12.6 – Sentiment analysis chart'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6 – 情感分析图表'
- en: '](img/B17076_12_06.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_12_06.jpg)'
- en: Figure 12.6 – Sentiment analysis chart
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 情感分析图表
- en: The sentiment analysis is done and fully integrated into `index.js`. Let's move
    on to create the `Table` component to display our user data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 情感分析已经完成并完全集成到`index.js`中。让我们继续创建`Table`组件来显示我们的用户数据。
- en: Creating a Table component
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Table组件
- en: We will be implementing a `Table` component to display the data obtained.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个`Table`组件来显示获取的数据。
- en: Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The table implementation is the same as for the DataTable implementation created
    in [*Chapter 8*](B17076_08_ePub_RK.xhtml#_idTextAnchor149), *Creating a No-Code
    Data Analysis/Handling System*. For a better explanation of the code, kindly check
    out [*Chapter 8*](B17076_08_ePub_RK.xhtml#_idTextAnchor149), *Creating a No-Code
    Data Analysis/Handling System*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 表格实现与[*第8章*](B17076_08_ePub_RK.xhtml#_idTextAnchor149)中创建的DataTable实现相同，*创建无代码数据分析/处理系统*。有关代码的更好解释，请查看[*第8章*](B17076_08_ePub_RK.xhtml#_idTextAnchor149)，*创建无代码数据分析/处理系统*。
- en: 'Let''s create a `Table.js` file in the `components/` directory and update the
    file with the following steps:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`components/`目录中创建一个`Table.js`文件，并按以下步骤更新文件：
- en: 'We import the necessary modules:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入了必要的模块：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We create a function called `Table`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`Table`的函数：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The function takes in `dfData` (sentiment data from `/api/nlp`) and `username`
    (from the search field) as props.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受`dfData`（来自`/api/nlp`的情感数据）和`username`（来自搜索字段）作为props。
- en: 'We update the function with the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下代码更新函数：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We create a DataFrame from `dfData`, filter out the rows containing the user's
    tweets, and then extract the column names and the values of the DataFrame.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`dfData`创建一个DataFrame，过滤掉包含用户推文的行，然后提取DataFrame的列名和值。
- en: 'We then format this column in the format accepted by `ReactTable`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将此列格式化为`ReactTable`接受的格式：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We also format the values to be accepted by `ReactTable`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将值格式化为`ReactTable`接受的格式：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Once again, the code in *Steps 4*, *5*, and *6* is explained in detail in [*Chapter
    8*](B17076_08_ePub_RK.xhtml#_idTextAnchor149), *Creating a No-Code Data Analysis/Handling
    System*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，*步骤4*、*5*和*6*中的代码在[*第8章*](B17076_08_ePub_RK.xhtml#_idTextAnchor149)中有详细解释，*创建无代码数据分析/处理系统*。
- en: 'We then make a call to the `ReactTable` component and pass in `dataColumns`
    and `data`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用`ReactTable`组件并传入`dataColumns`和`data`：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `table` component is completed; the next step is to import the component
    in Next.js and then make a call to the component.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`table`组件已完成；下一步是在Next.js中导入组件，然后调用该组件。'
- en: 'Note that since we are using the web version of Danfo.js, we need to load this
    component with `next/dynamic` to prevent the app from crashing:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们使用的是Danfo.js的Web版本，我们需要使用`next/dynamic`加载此组件，以防止应用程序崩溃：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, we import the `Table` component dynamically and also
    instantiate the `Table` component inside and pass in the `dfData` and `username`
    prop values.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们动态导入了`Table`组件，并在内部实例化了`Table`组件，并传入了`dfData`和`username`的prop值。
- en: 'If you switch over to your browser and go to the project''s `localhost` port,
    you should see the full updated app, as shown in the following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您切换到浏览器并转到项目的`localhost`端口，您应该看到完整更新的应用程序，如下面的屏幕截图所示：
- en: '![Figure 12.7 – Extracted user data'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7 - 提取的用户数据'
- en: '](img/B17076_12_07.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_12_07.jpg)'
- en: Figure 12.7 – Extracted user data
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 - 提取的用户数据
- en: 'The final result of the app should look like the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的最终结果应如下所示：
- en: '![Figure 12.8 – Twitter user dashboard'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8 - Twitter用户仪表板'
- en: '](img/B17076_12_08.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_12_08.jpg)'
- en: Figure 12.8 – Twitter user dashboard
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 - Twitter用户仪表板
- en: In this section, we built different components for the frontend implementation.
    We saw how to make use of Danfo.js with Next.js and also got to know about loading
    components with `next/dynamic`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们为前端实现构建了不同的组件。我们看到了如何在Next.js中使用Danfo.js，还了解了如何使用`next/dynamic`加载组件。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how to make use of Next.js to build a fast full stack
    app. We saw how to make use of Danfo.js nodes in the backend and we also used
    JavaScript packages such as twit.js and `nlp-node` to obtain Twitter data and
    perform sentiment analysis.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用Next.js构建快速全栈应用程序。我们看到了如何在后端使用Danfo.js节点，还使用了JavaScript包，如twit.js和`nlp-node`来获取Twitter数据并进行情感分析。
- en: We also saw how to easily infuse Danfo.js with Next.js and how to prevent errors
    by loading components with `next/dynamic`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何轻松地将Danfo.js与Next.js结合使用，以及如何通过使用`next/dynamic`加载组件来防止错误。
- en: The goal of the chapter was to enable you to see how you can easily use Danfo.js
    to build a full stack (backend and frontend) data-driven app, and I believe this
    was well achieved in this chapter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是让您看到如何轻松使用Danfo.js构建全栈（后端和前端）数据驱动应用程序，我相信本章在这方面取得了很好的成就。
- en: I believe we've covered a lot in this book, starting from the introduction to
    Danfo.js to building a no-code environment with Danfo.js, to building a recommendation
    system and Twitter analytics dashboard. From the various use cases of Danfo.js
    with various JavaScript frameworks, we were able to build an analytics platform
    and machine learning-driven web apps.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信我们在本书中涵盖了很多内容，从介绍Danfo.js到使用Danfo.js构建无代码环境，再到构建推荐系统和Twitter分析仪表板。通过在各种JavaScript框架中使用Danfo.js的各种用例，我们能够构建分析平台和机器学习驱动的Web应用程序。
- en: We've come to the end of the book and I believe we are now well equipped with
    skills to include data analytics and machine learning in our next web app and
    also contribute to Danfo.js.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了本书的学习，我相信我们现在已经具备了在下一个Web应用程序中包含数据分析和机器学习的技能，并且可以为Danfo.js做出贡献。
