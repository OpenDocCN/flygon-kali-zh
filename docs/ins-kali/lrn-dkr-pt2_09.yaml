- en: Chapter 9. Testing with Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。使用Docker进行测试
- en: Undoubtedly, the trait of testing has been at the forefront of the software
    engineering discipline. It is widely accepted that there is a deep and decisive
    penetration of software into every kind of tangible object in our daily environments
    these days in order to have plenty of smart, connected, and digitized assets.
    Also, with a heightened focus on distributed and synchronized software, the complexity
    of the software design, development, testing and debugging, deployment, and delivery
    are continuously on the climb. There are means and mechanisms being unearthed
    to simplify and streamline the much-needed automation of software building and
    the authentication of software reliability, resiliency, and sustainability. Docker
    is emerging as an extremely flexible tool to test a wide variety of software applications.
    In this chapter, we are going to discuss how to effectively leverage the noteworthy
    Docker advancements for software testing and its unique advantages in accelerating
    and augmenting testing automation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，测试的特征一直处于软件工程学科的前沿。人们普遍认为，如今软件已经深入并决定性地渗透到我们日常环境中的各种有形物体中，以便拥有大量智能、连接和数字化的资产。此外，随着对分布式和同步软件的高度关注，软件设计、开发、测试和调试、部署以及交付的复杂性不断攀升。正在发现手段和机制来简化和优化软件构建的必要自动化，以及对软件可靠性、弹性和可持续性的认证。Docker正成为测试各种软件应用的极其灵活的工具。在本章中，我们将讨论如何有效地利用值得注意的Docker进展进行软件测试，以及它在加速和增强测试自动化方面的独特优势。
- en: 'The following topics are discussed in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论以下主题：
- en: A brief overview of **test-driven development** (**TDD**)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）的简要概述
- en: Testing your code inside Docker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中测试您的代码
- en: Integrating the Docker testing process into Jenkins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Docker测试过程集成到Jenkins中
- en: The emerging situation is that Docker containers are being leveraged to create
    development and testing environments that are the exact replicas of the production
    environment. Containers require less overhead when compared to virtual machines,
    which have been the primary environments for development, staging, and deployment
    environments. Let's start with an overview of test-driven development of the next
    generation software and how the Docker-inspired containerization becomes handy
    in simplifying the TDD process.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 新兴情况是，Docker容器被利用来创建开发和测试环境，这些环境与生产环境完全相同。与虚拟机相比，容器需要更少的开销，虚拟机一直是开发、分级和部署环境的主要环境。让我们从下一代软件的测试驱动开发概述开始，以及Docker启发的容器化如何简化TDD过程。
- en: A brief overview of the test-driven development
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发的简要概述
- en: The long and arduous journey of software development has taken many turns and
    twists in the past decades, and one of the prominent software engineering techniques
    is nonetheless the TDD. There are more details and documents on TDD at [http://agiledata.org/essays/tdd.html](http://agiledata.org/essays/tdd.html).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发的漫长而艰难的旅程在过去的几十年里经历了许多转折，而其中一种突出的软件工程技术无疑是TDD。关于TDD的更多细节和文档请参见[http://agiledata.org/essays/tdd.html](http://agiledata.org/essays/tdd.html)。
- en: 'In a nutshell, the test-driven development, also popularly known as TDD, is
    a software development practice in which the development cycle begins with writing
    a test case that would fail, then writes the actual software to make the test
    pass, and continues to refactor and repeat the cycle till the software reaches
    the acceptable level. This process is depicted in the following diagram:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，测试驱动开发，也被称为TDD，是一种软件开发实践，其中开发周期始于编写一个会失败的测试用例，然后编写实际的软件使测试通过，并继续重构和重复这个周期，直到软件达到可接受的水平。这个过程在下面的图表中描述了：
- en: '![A brief overview of the test-driven development](graphics/7937OT_09_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![测试驱动开发的简要概述](graphics/7937OT_09_01.jpg)'
- en: Testing your code inside Docker
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中测试您的代码
- en: 'In this section, we will take you through a journey in which we will show you
    how TDD is done using stubs, and how Docker can come handy in developing software
    in the deployment equivalent system. For this purpose, we take a web application
    use case that has a feature to track the visit count of each of its users. For
    this example, we use Python as the implementation language and `redis` as the
    key-value pair database to store the users hit count. Besides, to showcase the
    testing capability of Docker, we limit our implementation to just two functions:
    `hit` and `getHit`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将带您进行一次旅程，向您展示如何使用存根进行TDD，并且Docker如何在开发软件中变得方便。为此，我们以一个具有跟踪每个用户访问次数功能的Web应用程序用例为例。在这个例子中，我们使用Python作为实现语言，`redis`作为键值对数据库来存储用户的点击次数。此外，为展示Docker的测试能力，我们将我们的实现限制在只有两个功能：`hit`和`getHit`。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: All the examples in this chapter use `python3` as the runtime environment.
    The `ubuntu 14.04` installation comes with `python3` by default. If you don''t
    have `python3` installed on your system, refer to the respective manual to install
    `python3`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中的所有示例都使用`python3`作为运行环境。`ubuntu 14.04`安装默认带有`python3`。如果您的系统上没有安装`python3`，请参考相应的手册安装`python3`。
- en: 'As per the TDD practice, we start by adding unit test cases for the `hit` and
    `getHit` functionalities, as depicted in the following code snippet. Here, the
    test file is named `test_hitcount.py`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据TDD实践，我们首先为`hit`和`getHit`功能添加单元测试用例，如下面的代码片段所示。在这里，测试文件的名称为`test_hitcount.py`：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is also available at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例也可在[https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src)找到。
- en: Here, in the first line, we are importing the `unittest` Python module that
    provides the necessary framework and functionality to run the unit test and generate
    a detailed report on the test execution. In the second line, we are importing
    the `hitcount` Python module, where we are going to implement the hit count functionality.
    Then, we will continue to add the test code that would test the `hitcount` module's
    functionality.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们导入了提供运行单元测试并生成详细报告的必要框架和功能的`unittest` Python模块。在第二行中，我们导入了`hitcount`
    Python模块，我们将在其中实现点击计数功能。然后，我们将继续添加测试代码，测试`hitcount`模块的功能。
- en: 'Now, run the test suite using the unit test framework of Python, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用Python的单元测试框架运行测试套件，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the output generated by the unit test framework:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是单元测试框架生成的输出：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As expected, the test failed with the error message `ImportError: No module
    named ''hitcount''` because we had not even created the file and hence, it could
    not import the `hitcount` module.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '如预期的那样，测试失败并显示错误消息“ImportError: No module named ''hitcount''”，因为我们甚至还没有创建文件，因此无法导入`hitcount`模块。'
- en: 'Now, create a file with the name `hitcount.py` in the same directory as `test_hitcount.py`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在与`test_hitcount.py`相同的目录中创建一个名为`hitcount.py`的文件：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Continue to run the unit test suite:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 继续运行单元测试套件：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is the output generated by the unit test framework:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是单元测试框架生成的输出：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Again the test suite failed like the earlier but with a different error message
    `AttributeError: ''module'' object has no attribute ''hit''`. We are getting this
    error because we have not implemented the `hit` function yet.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '再次，测试套件失败，就像之前一样，但是出现了不同的错误消息`AttributeError: ''module'' object has no attribute
    ''hit''`。我们之所以会得到这个错误，是因为我们还没有实现`hit`函数。'
- en: 'Let''s proceed to implement the `hit` and `getHit` functions in `hitcount.py`,
    as shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在`hitcount.py`中实现`hit`和`getHit`函数，如下所示：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is also available on GitHub at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例也可在GitHub上找到[https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src)。
- en: 'Note: To continue with this example, you must have the `python3` compatible
    version of package installer (`pip3`).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要继续进行此示例，您必须具有与`pip3`兼容的`python3`版本的软件包安装程序。
- en: 'The following command is used to install `pip3`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令用于安装`pip3`：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the first line of this program, we are importing the `redis` driver, which
    is the connectivity driver of the `redis` database. In the following line, we
    are connecting to the `redis` database, and then we will continue to implement
    the `hit` and `getHit` function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在此程序的第一行中，我们导入了`redis`驱动程序，这是`redis`数据库的连接驱动程序。在接下来的一行中，我们将连接到`redis`数据库，然后我们将继续实现`hit`和`getHit`函数。
- en: 'The `redis` driver is an optional Python module, so let''s proceed to install
    the `redis` driver using the pip installer, which is illustrated as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`redis`驱动程序是一个可选的Python模块，因此让我们继续使用pip安装程序安装`redis`驱动程序，如下所示：'
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our `unittest` will still fail even after installing the `redis` driver because
    we are not running a `redis` database server yet. So, we can either run a `redis`
    database server to successfully complete our unit testing or take the traditional
    TDD approach of mocking the `redis` driver. Mocking is a testing approach wherein
    complex behavior is substituted by predefined or simulated behavior. In our example,
    to mock the redis driver, we are going to leverage a third-party Python package
    called mockredis. This mock package is available at [https://github.com/locationlabs/mockredis](https://github.com/locationlabs/mockredis)
    and the `pip` installer name is `mockredispy`. Let''s install this mock using
    the pip installer:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 即使安装了`redis`驱动程序，我们的`unittest`仍然会失败，因为我们尚未运行`redis`数据库服务器。因此，我们可以运行`redis`数据库服务器以成功完成我们的单元测试，或者采用传统的TDD方法来模拟`redis`驱动程序。模拟是一种测试方法，其中复杂的行为被预定义或模拟的行为替代。在我们的示例中，为了模拟redis驱动程序，我们将利用一个名为mockredis的第三方Python包。这个模拟包可以在[https://github.com/locationlabs/mockredis](https://github.com/locationlabs/mockredis)找到，`pip`安装程序的名称是`mockredispy`。让我们使用pip安装这个模拟：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Having installed `mockredispy`, the `redis` mock, let''s refactor our test
    code `test_hitcount.py` (which we had written earlier) to use the simulated `redis`
    functionality provided by the `mockredis` module. This is accomplished by the
    patch method provided by the `unittest.mock` mocking framework, as shown in the
    following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`mockredispy`，`redis`模拟器之后，让我们重构我们之前编写的测试代码`test_hitcount.py`，以使用`mockredis`模块提供的模拟`redis`功能。这是通过`unittest.mock`模拟框架提供的patch方法来实现的，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is also available on GitHub at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例也可在GitHub上找到[https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src)。
- en: 'Now, run the test suite again:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行测试套件：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, as we can see in the preceding output, we successfully implemented
    our visitors count functionality through the test, code, and refactor cycle.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如我们在前面的输出中所看到的，我们通过测试、代码和重构周期成功实现了访客计数功能。
- en: Running the test inside a container
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器内运行测试
- en: In the previous section, we walked you through the complete cycle of TDD, in
    which we installed additional Python packages to complete our development. However,
    in the real world, one might work on multiple projects that might have conflicting
    libraries and hence, there is a need for the isolation of runtime environments.
    Before the advent of Docker technology, the Python community used to leverage
    the `virtualenv` tool to isolate the Python runtime environment. Docker takes
    this isolation a step further by packaging the OS, the Python tool chain, and
    the runtime environment. This type of isolation gives a lot of flexibility to
    the development community to use appropriate software versions and libraries as
    per the project needs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们向您介绍了TDD的完整周期，其中我们安装了额外的Python包来完成我们的开发。然而，在现实世界中，一个人可能会在多个可能具有冲突库的项目上工作，因此需要对运行时环境进行隔离。在Docker技术出现之前，Python社区通常使用`virtualenv`工具来隔离Python运行时环境。Docker通过打包操作系统、Python工具链和运行时环境将这种隔离推向了更高级别。这种类型的隔离为开发社区提供了很大的灵活性，可以根据项目需求使用适当的软件版本和库。
- en: 'Here is the step-by-step procedure to package the test and visitor count implementation
    of the previous section to a Docker container and perform the test inside the
    container:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将上一节的测试和访客计数实现打包到Docker容器中并在容器内执行测试的逐步过程：
- en: 'Craft a `Dockerfile` to build an image with the `python3` runtime, the `redis`
    and `mockredispy` packages, both the `test_hitcount.py` test file and the visitors
    count implementation `hitcount.py`, and finally, launch the unit test:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Dockerfile`来构建一个带有`python3`运行时、`redis`和`mockredispy`包、`test_hitcount.py`测试文件和访客计数实现`hitcount.py`的镜像，最后启动单元测试：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is also available on GitHub at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例也可在GitHub上找到：[https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src)。
- en: Now create a directory called `src` on the directory, where we crafted our `Dockerfile`.
    Move the `test_hitcount.py` and `hitcount.py` files to the newly created `src`
    directory.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在我们制作`Dockerfile`的目录中创建一个名为`src`的目录。将`test_hitcount.py`和`hitcount.py`文件移动到新创建的`src`目录中。
- en: 'Build the `hit_unittest` Docker image using the `docker build` subcommand:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker build`子命令构建`hit_unittest` Docker镜像：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we have successfully built the image, let''s launch our container
    with the unit testing bundle using the `docker run` subcommand, as illustrated
    here:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经成功构建了镜像，让我们使用`docker run`子命令启动我们的容器，并使用单元测试包，如下所示：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Apparently, the unit test ran successfully with no errors because we already
    packaged the tested code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，单元测试成功运行且无错误，因为我们已经打包了被测试的代码。
- en: In this approach, for every change, the Docker image is built and then, the
    container is launched to complete the test.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，对于每次更改，都会构建Docker镜像，然后启动容器来完成测试。
- en: Using a Docker container as a runtime environment
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Docker容器作为运行时环境
- en: In the previous section, we built a Docker image to perform the testing. Particularly,
    in the TDD practice, the unit test cases and the code go through multiple changes.
    Consequently, the Docker image needs to be built over and over again, which is
    a daunting job. In this section, we will see an alternative approach in which
    the Docker container is built with a runtime environment, the development directory
    is mounted as a volume, and the test is performed inside the container.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们构建了一个Docker镜像来执行测试。特别是在TDD实践中，单元测试用例和代码经历多次更改。因此，需要反复构建Docker镜像，这是一项艰巨的工作。在本节中，我们将看到一种替代方法，即使用运行时环境构建Docker容器，将开发目录挂载为卷，并在容器内执行测试。
- en: During this TDD cycle, if an additional library or update to the existing library
    is required, then the container will be updated with the required libraries and
    the updated container will be committed as a new image. This approach gives the
    isolation and flexibility that any developer would dream of because the runtime
    and its dependency live within the container, and any misconfigured runtime environment
    can be discarded and a new runtime environment can be built from a previously
    working image. This also helps to preserve the sanity of the Docker host from
    the installation and uninstallation of libraries.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD周期中，如果需要额外的库或更新现有库，那么容器将被更新为所需的库，并更新的容器将被提交为新的镜像。这种方法提供了任何开发人员梦寐以求的隔离和灵活性，因为运行时及其依赖项都存在于容器中，任何配置错误的运行时环境都可以被丢弃，并且可以从先前工作的镜像构建新的运行时环境。这也有助于保持Docker主机的清醒状态，避免安装和卸载库。
- en: 'The following example is a step-by-step instruction on how to use the Docker
    container as a nonpolluting yet very powerful runtime environment:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是关于如何将Docker容器用作非污染但非常强大的运行时环境的逐步说明：
- en: 'We begin with launching the Python runtime interactive container, using the
    `docker run` subcommand:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始启动Python运行时交互式容器，使用`docker run`子命令：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, in this example, the `/home/peter/src/hitcount` Docker host directory
    is earmarked as the placeholder for the source code and test files. This directory
    is mounted in the container as `/src`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`/home/peter/src/hitcount` Docker主机目录被标记为源代码和测试文件的占位符。该目录在容器中被挂载为`/src`。
- en: Now, on another terminal of the Docker host, copy both the `test_hitcount.py`
    test file and the visitors count implementation `hitcount.py` to `/home/peter/src/hitcount
    directory`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在Docker主机的另一个终端上，将`test_hitcount.py`测试文件和访客计数实现`hitcount.py`复制到`/home/peter/src/hitcount`目录中。
- en: 'Switch to the Python runtime interactive container terminal, change the current
    working directory to `/src`, and run the unit test:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到Python运行时交互式容器终端，将当前工作目录更改为`/src`，并运行单元测试：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Evidently, the test failed because it could not find the `mockredis` Python
    library.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，测试失败是因为找不到`mockredis` Python库。
- en: 'Proceed to install the `mockredispy pip` package because the previous step
    failed, as it could not find the `mockredis` library in the runtime environment:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续安装`mockredispy pip`包，因为前一步失败了，无法在运行时环境中找到`mockredis`库：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Rerun the Python unit test:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行Python单元测试：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Again, the test failed because the `redis` driver is not yet installed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，测试失败，因为尚未安装`redis`驱动程序。
- en: 'Continue to install the `redis` driver using the pip installer, as shown here:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续使用pip安装程序安装`redis`驱动程序，如下所示：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Having successfully installed the `redis` driver, let''s once again run the
    unit test:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功安装了`redis`驱动程序后，让我们再次运行单元测试：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Apparently, this time the unit test passed with no warnings or error messages.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这次单元测试通过了，没有警告或错误消息。
- en: 'Now we have a runtime environment that is good enough to run our test cases.
    It is better to commit these changes to a Docker image for reuse, using the `docker
    commit` subcommand:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个足够好的运行时环境来运行我们的测试用例。最好将这些更改提交到Docker镜像以便重用，使用`docker commit`子命令：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From now on, we can use the `python_rediswithmock` image to launch new containers
    for our TDD.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们可以使用`python_rediswithmock`镜像来启动新的容器进行TDD。
- en: In this section, we vividly illustrated the approach on how to use the Docker
    container as a testing environment, and also at the same time, preserve the sanity
    and sanctity of the Docker host by isolating and limiting the runtime dependency
    within the container.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们生动地阐述了如何将Docker容器作为测试环境的方法，同时通过在容器内隔离和限制运行时依赖项，保持Docker主机的完整性和纯洁性。
- en: Integrating Docker testing into Jenkins
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Docker测试集成到Jenkins中
- en: In the previous section, we laid out a stimulating foundation on software testing,
    how to leverage the Docker technology for the software testing, and the unique
    benefits of the container technology during the testing phase. In this section,
    we will introduce you to the steps required to prepare the Jenkins environment
    for testing with Docker, and then, demonstrate how Jenkins can be extended to
    integrate and automate testing with Docker using the well-known hit count use
    case.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们阐述了关于软件测试的激动人心的基础，如何利用Docker技术进行软件测试，以及在测试阶段容器技术的独特优势。在本节中，我们将介绍为了使用Docker准备Jenkins环境所需的步骤，然后演示如何扩展Jenkins以集成和自动化使用Docker进行测试，使用众所周知的点击计数用例。
- en: Preparing the Jenkins environment
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备Jenkins环境
- en: 'In this section, we will take you through the steps to install `jenkins`, GitHub
    plugin for Jenkins and `git`, and the revision control tool. These steps are as
    follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将带您完成安装`jenkins`、Jenkins的GitHub插件和`git`以及修订控制工具的步骤。这些步骤如下：
- en: 'We begin with adding the Jenkins'' trusted PGP public key:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要添加Jenkins的受信任的PGP公钥：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we are using `wget` to download the PGP public key, and then we add it
    to the list of trusted keys using the apt-key tool. Since Ubuntu and Debian share
    the same software packaging, Jenkins provides a single common package for both
    Ubuntu and Debian.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`wget`来下载PGP公钥，然后使用apt-key工具将其添加到受信任密钥列表中。由于Ubuntu和Debian共享相同的软件打包，Jenkins为两者提供了一个通用的软件包。
- en: 'Add the Debian package location to the `apt` package source list, as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Debian软件包位置添加到`apt`软件包源列表中，如下所示：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Having added the package source, continue to run the `apt-get` command update
    option to resynchronize the package index from the sources:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了软件包源后，继续运行`apt-get`命令更新选项，以重新同步来自源的软件包索引：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, install `jenkins` using the `apt-get` command install option, as demonstrated
    here:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`apt-get`命令安装选项来安装`jenkins`，如下所示：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, activate the `jenkins` service using the `service` command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`service`命令激活`jenkins`服务：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `jenkins` service can be accessed through any web browsers by specifying
    the IP address (`10.1.1.13`) of the system in which Jenkins is installed. The
    default port number for Jenkins is `8080`. The following screenshot is the entry
    page or **Dashboard** of **Jenkins**:![Preparing the Jenkins environment](graphics/7937OT_09_02.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jenkins`服务可以通过任何Web浏览器访问，只需指定安装了Jenkins的系统的IP地址（`10.1.1.13`）。Jenkins的默认端口号是`8080`。以下截图是**Jenkins**的入口页面或**仪表板**：![准备Jenkins环境](graphics/7937OT_09_02.jpg)'
- en: 'In this example, we are going to use GitHub as the source code repository.
    Jenkins does not support GitHub by default and hence, we need to install the GitHub
    plugin. During the installation, sometimes Jenkins does not populate the plugin
    availability list, and hence, you have to force it to download the list of available
    plugins. You can do so by performing the following steps:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用GitHub作为源代码存储库。Jenkins默认不支持GitHub，因此需要安装GitHub插件。在安装过程中，有时Jenkins不会填充插件可用性列表，因此您必须强制它下载可用插件列表。您可以通过执行以下步骤来实现：
- en: Select **Manage Jenkins** on the left-hand side of the screen, which will take
    us to a **Manage Jenkins** page, as shown in the following screenshot:![Preparing
    the Jenkins environment](graphics/7937OT_09_03.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕左侧选择**管理Jenkins**，这将带我们到**管理Jenkins**页面，如下面的屏幕截图所示：![准备Jenkins环境](graphics/7937OT_09_03.jpg)
- en: On the **Manage Jenkins** page, select **Manage Plugins** and this will take
    us to the **Plugin Manager** page, as shown in the following screenshot:![Preparing
    the Jenkins environment](graphics/7937OT_09_04.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**管理Jenkins**页面上，选择**管理插件**，这将带我们到**插件管理器**页面，如下面的屏幕截图所示：![准备Jenkins环境](graphics/7937OT_09_04.jpg)
- en: Here, on the **Plugin Manager** page, select the **Advanced** tab, go to the
    bottom of this page, and you will find the **Check now** button in the right-hand
    side corner of the page. Click on the **Check now** button to start the plugin
    updates. Alternatively, you can directly go to the **Check now** button on the
    **Advanced** page by navigating to `http://<jenkins-server>:8080/pluginManager/advanced`,
    wherein `<jenkins-server>` is the IP address of the system in which Jenkins is
    installed.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**插件管理器**页面上，选择**高级**选项卡，转到页面底部，您将在页面右下角找到**立即检查**按钮。单击**立即检查**按钮开始插件更新。或者，您可以通过导航到`http://<jenkins-server>:8080/pluginManager/advanced`直接转到**高级**页面上的**立即检查**按钮，其中`<jenkins-server>`是安装Jenkins的系统的IP地址。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: If Jenkins does not update the available plugin list, it is most likely
    a mirror site issue, so modify the **Update Site** field with a working mirror
    URL.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果Jenkins没有更新可用的插件列表，很可能是镜像站点的问题，因此使用有效的镜像URL修改**更新站点**字段。
- en: 'Having updated the available plugin list, let''s continue to install the GitHub
    plugin, as depicted in the following substeps:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新了可用插件列表后，让我们继续安装GitHub插件，如下面的子步骤所示：
- en: Select the **Available** tab in the **Plugin Manager** page, which will list
    all the available plugins.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**插件管理器**页面中选择**可用**选项卡，其中将列出所有可用的插件。
- en: Type `GitHub plugin` as the filter, which will list just the GitHub plugin,
    as shown in the following screenshot:![Preparing the Jenkins environment](graphics/7937OT_09_05.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`GitHub插件`作为过滤器，这将只列出GitHub插件，如下面的屏幕截图所示：![准备Jenkins环境](graphics/7937OT_09_05.jpg)
- en: Select the checkbox, and click on **Download now and install after restart**.
    You will be taken to a screen that will show you the progress of the plugin installation:![Preparing
    the Jenkins environment](graphics/7937OT_09_06.jpg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择复选框，然后单击**立即下载并在重启后安装**。您将进入一个屏幕，显示插件安装的进度：![准备Jenkins环境](graphics/7937OT_09_06.jpg)
- en: After all the plugins have successfully downloaded, go ahead and restart Jenkins
    using `http://< jenkins-server >:8080/restart`, where `<jenkins-server>` is the
    IP address of the system in which Jenkins is installed.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有插件成功下载后，继续使用`http://< jenkins-server >:8080/restart`重新启动Jenkins，其中`<jenkins-server>`是安装Jenkins的系统的IP地址。
- en: 'Ensure that the `git` package is installed, otherwise install the `git` package
    using the `apt-get` command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保安装了`git`软件包，否则使用`apt-get`命令安装`git`软件包：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So far, we have been running the Docker client using the `sudo` command, but
    unfortunately, we could not invoke `sudo` inside Jenkins because sometimes it
    prompts for a password. To overcome the `sudo` password prompt issue, we can make
    use of the Docker group, wherein any user who is part of the Docker group can
    invoke the Docker client without using the `sudo` command. Jenkins installation
    always sets up a user and group called `jenkins` and runs the Jenkins server using
    that user and group. So, we just need to add the `jenkins` user to the Docker
    group to get the Docker client working without the `sudo` command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用`sudo`命令运行Docker客户端，但不幸的是，我们无法在Jenkins中调用`sudo`，因为有时它会提示输入密码。为了克服`sudo`密码提示问题，我们可以利用Docker组，任何属于Docker组的用户都可以在不使用`sudo`命令的情况下调用Docker客户端。Jenkins安装总是设置一个名为`jenkins`的用户和组，并使用该用户和组运行Jenkins服务器。因此，我们只需要将`jenkins`用户添加到Docker组，即可使Docker客户端在不使用`sudo`命令的情况下工作：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Restart the `jenkins` service for the group change to take effect using the
    following command:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动`jenkins`服务，以使组更改生效，使用以下命令：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have set up a Jenkins environment that is now capable of automatically pulling
    the latest source code from the [http://github.com](http://github.com) repository,
    packaging it as a Docker image, and executing the prescribed test scenarios.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了一个Jenkins环境，现在能够自动从[http://github.com](http://github.com)存储库中拉取最新的源代码，将其打包为Docker镜像，并执行规定的测试场景。
- en: Automating the Docker testing process
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化Docker测试流程
- en: In this section, we will explore how to automate testing using Jenkins and Docker.
    As mentioned earlier, we are going to use GitHub as our repository. We have already
    uploaded the `Dockerfile`, `test_hitcount.py`, and `hitcount.py` files of our
    previous example to GitHub at [https://github.com/thedocker/testing](https://github.com/thedocker/testing),
    which we are to use in the ensuing example. However, we strongly encourage you
    to set up your own repository at [http://github.com](http://github.com), using
    the fork option that you can find at [https://github.com/thedocker/testing](https://github.com/thedocker/testing),
    and substitute this address wherever applicable in the ensuing example.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用Jenkins和Docker自动化测试。如前所述，我们将使用GitHub作为我们的存储库。我们已经将我们之前示例的`Dockerfile`、`test_hitcount.py`和`hitcount.py`文件上传到GitHub上的[https://github.com/thedocker/testing](https://github.com/thedocker/testing)，我们将在接下来的示例中使用它们。但是，我们强烈建议您在[http://github.com](http://github.com)上设置自己的存储库，使用您可以在[https://github.com/thedocker/testing](https://github.com/thedocker/testing)找到的分支选项，并在接下来的示例中替换此地址。
- en: 'The following are the detailed steps to automate the Docker testing:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是自动化Docker测试的详细步骤：
- en: 'Configure Jenkins to trigger a build when a file is modified in the GitHub
    repository, which is illustrated in the following substeps:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Jenkins在GitHub存储库中的文件修改时触发构建，如下面的子步骤所示：
- en: Connect to the Jenkins server again.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次连接到Jenkins服务器。
- en: Select either **New Item** or **create new jobs**:![Automating the Docker testing
    process](graphics/7937OT_09_07.jpg)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**新项目**或**创建新作业**：![自动化Docker测试流程](graphics/7937OT_09_07.jpg)
- en: In the following screenshot, give a name to the project (for example, `Docker-Testing`),
    and select the **Freestyle project** radio button:![Automating the Docker testing
    process](graphics/7937OT_09_08.jpg)
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个截图中，为项目命名（例如`Docker-Testing`），并选择**自由风格项目**单选按钮：![自动化Docker测试流程](graphics/7937OT_09_08.jpg)
- en: In the next screenshot, select the **Git** radio button under **Source Code
    Management**, and specify the GitHub repository URL in the **Repository URL**
    text field:![Automating the Docker testing process](graphics/7937OT_09_09.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个截图中，在**源代码管理**下选择**Git**单选按钮，并在**存储库URL**文本字段中指定GitHub存储库URL：![自动化Docker测试流程](graphics/7937OT_09_09.jpg)
- en: Select **Poll SCM** under **Build Triggers** to schedule GitHub polling for
    every `15` minute interval. Type the following line of code `H/15 * * * *` in
    the **Schedule** textbox, as shown in the following screenshot. For testing purposes,
    you can reduce the polling interval:![Automating the Docker testing process](graphics/7937OT_09_10.jpg)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建触发器**下选择**轮询SCM**，以便每`15`分钟间隔进行GitHub轮询。在**计划**文本框中输入以下代码`H/15 * * * *`，如下面的屏幕截图所示。为了测试目的，您可以缩短轮询间隔：![自动化Docker测试流程](graphics/7937OT_09_10.jpg)
- en: Scroll down the screen a little further, and select the **Add build step** button
    under **Build**. In the drop-down list, select **Execute shell** and type in the
    text, as shown in the following screenshot:![Automating the Docker testing process](graphics/7937OT_09_11.jpg)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动屏幕，然后在**构建**下选择**添加构建步骤**按钮。在下拉列表中，选择**执行shell**并输入以下文本，如下面的屏幕截图所示：![自动化Docker测试流程](graphics/7937OT_09_11.jpg)
- en: Finally, save the configuration by clicking on the **Save** button.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过点击**保存**按钮保存配置。
- en: Go back to the Jenkins Dashboard, and you can find your test listed on the dashboard:![Automating
    the Docker testing process](graphics/7937OT_09_12.jpg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Jenkins仪表板，您可以在仪表板上找到您的测试：![自动化Docker测试流程](graphics/7937OT_09_12.jpg)
- en: You can either wait for the Jenkins schedule to kick-start the build, or you
    can click on the clock icon on the right-hand side of the screen to kick-start
    the build immediately. As soon as the build is done, the Dashboard is updated
    with the build status as a success or failure, and the build number:![Automating
    the Docker testing process](graphics/7937OT_09_13.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以等待Jenkins计划启动构建，也可以点击屏幕右侧的时钟图标立即启动构建。一旦构建完成，仪表板将更新构建状态为成功或失败，并显示构建编号：![自动化Docker测试流程](graphics/7937OT_09_13.jpg)
- en: If you hover the mouse closer to the build number, you will get a drop-down
    button with options, such as **Changes**, **Console Output**, and so on, as shown
    in the following screenshot:![Automating the Docker testing process](graphics/7937OT_09_14.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果将鼠标悬停在构建编号附近，将会出现一个下拉按钮，其中包括**更改**、**控制台输出**等选项，如下面的屏幕截图所示：![自动化Docker测试流程](graphics/7937OT_09_14.jpg)
- en: 'The **Console Output** option will show the details highlighted for the build,
    as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**控制台输出**选项将显示构建的详细信息，如下所示：'
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Evidently, the test failed because of the wrong module name **error_hitcount**,
    which we deliberately introduced. Now, let's experiment a negative scenario by
    deliberately introducing a bug in **test_hitcount.py** and observe the effect
    the on Jenkins build. As we have configured Jenkins, it faithfully polls the GitHub
    and kick-starts the build:![Automating the Docker testing process](graphics/7937OT_09_15.jpg)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显然，测试失败是因为错误的模块名**error_hitcount**，这是我们故意引入的。现在，让我们故意在**test_hitcount.py**中引入一个错误，观察对Jenkins构建的影响。由于我们已经配置了Jenkins，它会忠实地轮询GitHub并启动构建：![自动化Docker测试流程](graphics/7937OT_09_15.jpg)
- en: Apparently, the build failed as we expected.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，构建失败了，正如我们预期的那样。
- en: 'As a final step, open **Console Output** of the failed build:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，打开失败构建的**控制台输出**：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Evidently, the test failed because of the wrong module name `error_hitcount`,
    which we deliberately introduced.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，测试失败是因为我们故意引入的错误模块名`error_hitcount`。
- en: Cool, isn't it? We automated our testing using Jenkins and Docker. Besides,
    we are able to experience the power of testing automation using Jenkins and Docker.
    In a large-scale project, Jenkins and Docker can be combined together to automate
    the complete unit testing needs, and thus, to automatically capture any defects
    and deficiencies introduced by any developers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 酷，不是吗？我们使用Jenkins和Docker自动化了我们的测试。此外，我们能够体验使用Jenkins和Docker进行测试自动化的力量。在大型项目中，Jenkins和Docker可以结合在一起，自动化完成完整的单元测试需求，从而自动捕捉任何开发人员引入的缺陷和不足。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The potential benefits of containerization are being discovered across the breadth
    and the length of software engineering. Previously, testing sophisticated software
    systems involved a number of expensive and hard-to-manage server modules and clusters.
    Considering the costs and complexities involved, most of the software testing
    is accomplished using mocking procedures and stubs. All of this is going to end
    for good with the maturity of the Docker technology. The openness and flexibility
    of Docker enables it to work seamlessly with other technologies to substantially
    reduce the testing time and complexity.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 集装箱化的潜在好处正在软件工程的广度和长度上被发现。以前，测试复杂的软件系统涉及许多昂贵且难以管理的服务器模块和集群。考虑到涉及的成本和复杂性，大多数软件测试是通过模拟程序和存根来完成的。随着Docker技术的成熟，所有这些都将永远结束。Docker的开放性和灵活性使其能够与其他技术无缝地配合，从而大大减少测试时间和复杂性。
- en: For a long time, the leading ways of testing software systems included mocking,
    dependency, injection, and so on. Usually, these mandate creating many sophisticated
    abstractions in the code. The current practice for developing and running test
    cases against an application is actually done on stubs rather than on the full
    application. That is, with a containerized workflow, it is very much possible
    to test against real application containers with all the dependencies. The contributions
    of the Docker paradigm, especially for the testing phenomenon and phase are therefore
    being carefully expounded and recorded in the recent past. Precisely speaking,
    the field of software engineering is moving towards smart and sunnier days with
    all the innovations in the Docker space.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，测试软件系统的主要方法包括模拟、依赖注入等。通常，这些方法需要在代码中创建许多复杂的抽象。目前的做法是针对应用程序开发和运行测试用例实际上是在存根上进行，而不是在完整的应用程序上进行。也就是说，通过容器化工作流，很可能对具有所有依赖关系的真实应用程序容器进行测试。因此，Docker范式的贡献，特别是对测试现象和阶段的贡献，近来正在被认真阐述和记录。确切地说，软件工程领域正在朝着Docker空间的所有创新迈进，迎来智能和更加晴朗的日子。
- en: In this chapter, we clearly expounded and explained a powerful testing framework
    for integrated applications using the Docker-inspired containerization paradigm.
    Increasingly for the agile world, the proven and potential TDD method is being
    insisted as an efficient software building and sustenance methodology. This chapter
    has utilized the Python unit test framework to illustrate how the TDD methodology
    is a pioneering tool for software engineering. The unit test framework is tweaked
    to be efficiently and elegantly containerized, and the Docker container is seamlessly
    integrated with Jenkins, which is a modern day deployment tool for continuous
    delivery, and is part and parcel of the agile programming world, as described
    in this chapter. The Docker container source code is pre-checked before it enters
    into the GitHub code repository. The Jenkins tool downloads the code from GitHub
    and runs the test inside a container. In the next chapter, we shall will dive
    deep into, and describe the theoretical aspects of, the process isolation through
    the container technology and various debugging tools and techniques.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们清楚地阐述和解释了使用受Docker启发的容器化范式的集成应用程序的强大测试框架。对于敏捷世界来说，经过验证的TDD方法被坚持为高效的软件构建和维护方法。本章利用Python单元测试框架来说明TDD方法是软件工程的开创性工具。单元测试框架被调整为高效、优雅的容器化，并且Docker容器与Jenkins无缝集成，后者是持续交付的现代部署工具，并且是敏捷编程世界的重要组成部分，正如本章所描述的。Docker容器源代码在进入GitHub代码存储库之前经过预检。Jenkins工具从GitHub下载代码并在容器内运行测试。在下一章中，我们将深入探讨并描述容器技术和各种调试工具和技术的理论方面。
