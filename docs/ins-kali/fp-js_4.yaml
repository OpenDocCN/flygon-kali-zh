- en: Chapter 4. Implementing Functional Programming Techniques in JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。在 JavaScript 中实现函数式编程技术
- en: Hold on to your hats because we're really going to get into the functional mind-set
    now.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 紧紧抓住你的帽子，因为我们现在真的要进入函数式思维模式了。
- en: 'In this chapter, we''re going to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Put all the core concepts together into a cohesive paradigm
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有核心概念整合成一个连贯的范式
- en: Explore the beauty that functional programming has to offer when we fully commit
    to the style
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全面致力于函数式风格时，探索函数式编程所提供的美
- en: Step through the logical progression of functional patterns as they build upon
    each other
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步推进函数式模式的逻辑进展
- en: All the while, we will build up a simple application that does some pretty cool
    stuff
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，我们将构建一个简单的应用程序，做一些非常酷的事情
- en: You may have noticed a few concepts that were brought up in the last chapter
    when dealing with functional libraries for JavaScript, but not in [Chapter 2](part0019_split_000.html#page
    "Chapter 2. Fundamentals of Functional Programming"), *Fundamentals of Functional
    Programming*. Well, that was for a reason! Compositions, currying, partial application,
    and more. Let's explore why and how these libraries implemented those concepts.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当处理 JavaScript 的函数式库时，您可能已经注意到了一些概念，但在《第 2 章》《函数式编程基础》中没有提到。好吧，这是有原因的！组合、柯里化、部分应用等。让我们探讨为什么以及这些库是如何实现这些概念的。
- en: 'Functional programming can come in a variety of flavors and patterns. This
    chapter will cover many different styles of functional programming:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程可以采用多种风格和模式。本章将涵盖许多不同的函数式编程风格：
- en: Data generic programming
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据泛型编程
- en: Mostly functional programming
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大部分是函数式编程
- en: Functional reactive programming and more
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数响应式编程等
- en: This chapter, however, will be as style-unbiased as possible. Without leaning
    too hard on one style of functional programming over another, the overall goal
    is to show that there are better ways to write code than what is often accepted
    as the correct and only way. Once you free your mind about the preconceptions
    of what is the right way and what is not the right way to write code, you can
    do whatever you want. When you just write code with childlike abandon for no reason
    other than the fact that you like it and when you're not concerned about conforming
    to the traditional way of doing things, then the possibilities are endless.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本章将尽可能不偏向任何一种函数式编程风格。不过度倚重某种函数式编程风格，总体目标是展示有比通常被接受的正确和唯一的编码方式更好的方式。一旦你摆脱了对编写代码的先入为主的观念，你就可以随心所欲。当你只是出于喜欢而写代码，而不担心符合传统的做事方式时，那么可能性就是无限的。
- en: Partial function application and currying
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分函数应用和柯里化
- en: Many languages support optional arguments, but not in JavaScript. JavaScript
    uses a different pattern entirely that allows for any number of arguments to be
    passed to a function. This leaves the door open for some very interesting and
    unusual design patterns. Functions can be applied in part or in whole.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言支持可选参数，但 JavaScript 不支持。JavaScript 使用一种完全不同的模式，允许将任意数量的参数传递给函数。这为一些非常有趣和不寻常的设计模式留下了空间。函数可以部分或全部应用。
- en: Partial application in JavaScript is the process of binding values to one or
    more arguments of a function that returns another function that accepts the remaining,
    unbound arguments. Similarly, currying is the process of transforming a function
    with many arguments into a function with one argument that returns another function
    that takes more arguments as needed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的部分应用是将值绑定到一个或多个函数参数的过程，返回另一个接受剩余未绑定参数的函数。类似地，柯里化是将具有多个参数的函数转换为接受所需参数的另一个函数的过程。
- en: The difference between the two may not be clear now, but it will be obvious
    in the end.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在两者之间的区别可能不太明显，但最终会显而易见。
- en: Function manipulation
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数操作
- en: Actually, before we go any further and explain just how to implement partial
    application and currying, we need a review. If we're going to tear JavaScript's
    thick veneer of C-like syntax right off and expose it's functional underbelly,
    then we're going to need to understand how primitives, functions, and prototypes
    in JavaScript work; we would never need to consider these if we just wanted to
    set some cookies or validate some form fields.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在我们进一步解释如何实现部分应用和柯里化之前，我们需要进行复习。如果我们要揭开 JavaScript 厚重的类 C 语法的外表，暴露它的函数式本质，那么我们需要了解
    JavaScript 中原始值、函数和原型是如何工作的；如果我们只是想设置一些 cookie 或验证一些表单字段，我们就不需要考虑这些。
- en: Apply, call, and the this keyword
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用、调用和 this 关键字
- en: In pure functional languages, functions are not invoked; they're applied. JavaScript
    works the same way and even provides utilities for manually calling and applying
    functions. And it's all about the `this` keyword, which, of course, is the object
    that the function is a member of.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯函数式语言中，函数不是被调用，而是被应用。JavaScript 也是如此，甚至提供了手动调用和应用函数的工具。而这一切都与 `this` 关键字有关，当然，它是函数的成员所属的对象。
- en: 'The `call()` function lets you define the `this` keyword as the first argument.
    It works as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`call()` 函数允许您将 `this` 关键字定义为第一个参数。它的工作方式如下：'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `call()` function can be used, for example, to invoke anonymous functions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`call()` 函数可以用来调用匿名函数，例如：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `apply()` function is very similar to the `call()` function, but a little
    more useful:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply()` 函数与 `call()` 函数非常相似，但更有用：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The fundamental difference is that, while the `call()` function accepts a list
    of arguments, the `apply()` function accepts an array of arguments.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根本区别在于，`call()` 函数接受参数列表，而 `apply()` 函数接受参数数组。
- en: The `call()` and `apply()` functions allow you to write a function once and
    then inherit it in other objects without writing the function over again. And
    they are both members themselves of the `Function` argument.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`call()`和`apply()`函数允许您编写一次函数，然后在其他对象中继承它，而无需重新编写函数。它们本身也是`Function`参数的成员。'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This is bonus material, but when you use the `call()` function on itself, some
    really cool things can happen:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是额外材料，但当您在自身上使用`call()`函数时，一些非常酷的事情可能会发生：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Binding arguments
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定参数
- en: The `bind()` function allows you to apply a method to one object with the `this`
    keyword assigned to another. Internally, it's the same as the `call()` function,
    but it's chained to the method and returns a new bounded function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()`函数允许您将一个方法应用于一个对象，并将`this`关键字分配给另一个对象。在内部，它与`call()`函数相同，但它链接到方法并返回一个新的绑定函数。'
- en: 'It''s especially useful for callbacks, as shown in the following code snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它在回调函数中特别有用，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This solves a lot of problems in object-oriented frameworks, such as Dojo, specifically
    the problems of maintaining the state when using classes that define their own
    handler functions. But we can use the `bind()` function for functional programming
    too.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了面向对象框架中的许多问题，比如Dojo，特别是在使用定义自己的处理程序函数的类时维护状态的问题。但我们也可以将`bind()`函数用于函数式编程。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `bind()` function actually does partial application on its own, though in
    a very limited way.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()`函数实际上可以自行进行部分应用，尽管方式非常有限。'
- en: Function factories
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数工厂
- en: Remember our section on closures in [Chapter 2](part0019_split_000.html#page
    "Chapter 2. Fundamentals of Functional Programming"), *Fundamentals of Functional
    Programming*? Closures are the constructs that makes it possible to create a useful
    JavaScript programming pattern known as function factories. They allow us to *manually
    bind* arguments to functions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在[第2章](part0019_split_000.html#page "第2章。函数式编程基础")中关于闭包的部分吗，*函数式编程基础*？闭包是使得可能创建一种称为函数工厂的有用的JavaScript编程模式的构造。它们允许我们*手动绑定*参数到函数。
- en: 'First, we''ll need a function that binds an argument to another function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个将参数绑定到另一个函数的函数：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then we can use this to create more generic functions:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用这个函数创建更通用的函数：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And it can work on the other argument too:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以用于另一个参数：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The ability to create generic functions is very important in functional programming.
    But there''s a clever trick to making this process even more generalized. The
    `bindFirstArg()` function itself takes two arguments, the first being a function.
    If we pass the `bindFirstArg` function as a function to itself, we can create
    *bindable* functions. This can be best described with the following example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，创建通用函数的能力非常重要。但是有一个聪明的技巧可以使这个过程更加通用化。`bindFirstArg()`函数本身接受两个参数，第一个是函数。如果我们将`bindFirstArg`函数作为函数传递给它自己，我们就可以创建*可绑定*函数。以下示例最能描述这一点：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is why they're called function factories.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么它们被称为函数工厂。
- en: Partial application
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分应用
- en: Notice that our function factory example's `bindFirstArg()` and `bindSecondArg()`
    functions only work for functions that have exactly two arguments. We could write
    new ones that work for different numbers of arguments, but that would work away
    from our model of generalization.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的函数工厂示例中的`bindFirstArg()`和`bindSecondArg()`函数只适用于具有确切两个参数的函数。我们可以编写新的函数，使其适用于不同数量的参数，但这将偏离我们的通用化模型。
- en: What we need is partial application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是部分应用。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Partial application is the process of binding values to one or more arguments
    of a function that returns a partially-applied function that accepts the remaining,
    unbound arguments.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用是将值绑定到一个或多个函数参数的过程，返回一个接受剩余未绑定参数的部分应用函数。
- en: Unlike the `bind()` function and other built-in methods of the `Function` object,
    we'll have to create our own functions for partial application and currying. There
    are two distinct ways to do this.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与`bind()`函数和`Function`对象的其他内置方法不同，我们必须为部分应用和柯里化创建自己的函数。有两种不同的方法可以做到这一点。
- en: As a stand-alone function, that is, `var partial = function(func){...`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个独立的函数，也就是，`var partial = function(func){...`
- en: As a *polyfill*, that is, `Function.prototype.partial = function(){...`
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为*polyfill*，也就是，`Function.prototype.partial = function(){...`
- en: 'Polyfills are used to augment prototypes with new functions and will allow
    us to call our new functions as methods of the function that we want to partially
    apply. Just like this: `myfunction.partial(arg1, arg2, …);`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Polyfills用于用新函数增加原型，并且允许我们将新函数作为我们想要部分应用的函数的方法来调用。就像这样：`myfunction.partial(arg1,
    arg2, …);`
- en: Partial application from the left
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从左侧进行部分应用
- en: 'Here''s where JavaScript''s `apply()` and `call()` utilities become useful
    for us. Let''s look at a possible polyfill for the Function object:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是JavaScript的`apply()`和`call()`实用程序对我们有用的地方。让我们看一下Function对象的可能的polyfill：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, it works by slicing the `arguments` special variable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它通过切割`arguments`特殊变量来工作。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Every function has a special local variable called `arguments` that is an array-like
    object of the arguments passed to it. It's technically not an array. Therefore
    it does not have any of the Array methods such as `slice` and `forEach`. That's
    why we need to use Array's `slice.call` method to slice the arguments.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都有一个特殊的本地变量称为`arguments`，它是传递给它的参数的类似数组的对象。它在技术上不是一个数组。因此它没有任何数组方法，比如`slice`和`forEach`。这就是为什么我们需要使用Array的`slice.call`方法来切割参数。
- en: And now let's see what happens when we use it in an example. This time, let's
    get away from the math and go for something a little more useful. We'll create
    a little application that converts numbers to hexadecimal values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看当我们在一个例子中使用它时会发生什么。这一次，让我们远离数学，转而做一些更有用的事情。我们将创建一个小应用程序，将数字转换为十六进制值。
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This example shows that we can partially apply arguments to a generic function
    and get a new function in return. *This first example is left-to-right*, which
    means that we can only partially apply the first, left-most arguments.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明我们可以部分应用参数到一个通用函数，并得到一个新的函数作为返回。*这个第一个例子是从左到右*，这意味着我们只能部分应用第一个、最左边的参数。
- en: Partial application from the right
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从右侧进行部分应用
- en: In order to apply arguments from the right, we can define another polyfill.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从右侧应用参数，我们可以定义另一个polyfill。
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Partial application has allowed us to take a very generic function and extract
    more specific functions out of it. But the biggest flaw in this method is that
    the way in which the arguments are passed, as in how many and in what order, can
    be ambiguous. And ambiguity is never a good thing in programming. There''s a better
    way to do this: currying.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用使我们能够从一个非常通用的函数中提取更具体的函数。但这种方法最大的缺陷是参数传递的方式，即数量和顺序可能是模糊的。模糊从来不是编程中的好事。有更好的方法来做到这一点：柯里化。
- en: Currying
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化
- en: Currying is the process of transforming a function with many arguments into
    a function with one argument that returns another function that takes more arguments
    as needed. Formally, a function with N arguments can be transformed into a function
    *chain* of N functions, each with only one argument.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化是将具有多个参数的函数转换为具有一个参数的函数的过程，该函数返回另一个根据需要接受更多参数的函数。形式上，具有N个参数的函数可以转换为N个函数的*链*，每个函数只有一个参数。
- en: 'A common question is: what is the difference between partial application and
    currying? While it''s true that partial application returns a value right away
    and currying only returns another curried function that takes the next argument,
    the fundamental difference is that currying allows for much better control of
    how arguments are passed to the function. We''ll see just how that''s true, but
    first we need to create function to perform the currying.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的问题是：部分应用和柯里化之间有什么区别？虽然部分应用立即返回一个值，而柯里化只返回另一个接受下一个参数的柯里化函数，但根本区别在于柯里化允许更好地控制参数如何传递给函数。我们将看到这是真的，但首先我们需要创建执行柯里化的函数。
- en: 'Here''s our polyfill for adding currying to the Function prototype:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们为Function原型添加柯里化的polyfill：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `numArgs` argument lets us optionally specify the number of arguments the
    function being curried needs if it's not explicitly defined.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`numArgs`参数让我们可以选择指定柯里化函数需要的参数数量，如果没有明确定义的话。'
- en: 'Let''s look at how to use it within our hexadecimal application. We''ll write
    a function that converts RGB values to a hexadecimal string that is appropriate
    for HTML:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在我们的十六进制应用程序中使用它。我们将编写一个将RGB值转换为适用于HTML的十六进制字符串的函数：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It will return the curried function until all needed arguments are passed in.
    And they're passed in the same left-to-right order as defined by the function
    being curried.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回柯里化函数，直到传入所有需要的参数。它们按照被柯里化函数定义的左到右的顺序传入。
- en: 'But we can step it up a notch and define the more specific functions that we
    need as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们可以再进一步，定义我们需要的更具体的函数如下：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So that's a nice way to use currying. But if we just want to curry our `nums2hex()`
    function directly, we run into a little bit of trouble. And that's because the
    function doesn't define any arguments, it just lets you pass as many arguments
    in as you want. So we have to define the number of arguments. We do that with
    the optional parameter to the curry function that allows us to set the number
    of arguments of the function being curried.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用柯里化的一个好方法。但是，如果我们只想直接对`nums2hex()`进行柯里化，我们会遇到一些麻烦。那是因为该函数没有定义任何参数，它只允许您传入任意数量的参数。因此，我们必须定义参数的数量。我们可以使用curry函数的可选参数来设置被柯里化函数的参数数量。
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Therefore currying does not work well with functions that accept variable numbers
    of arguments. For something like that, partial application is preferred.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，柯里化不适用于接受可变数量参数的函数。对于这样的情况，部分应用更可取。
- en: All of this isn't just for the benefit of function factories and code reuse.
    Currying and partial application play into a bigger pattern known as composition.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些不仅仅是为了函数工厂和代码重用的好处。柯里化和部分应用都融入了一个更大的模式，称为组合。
- en: Function composition
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组合
- en: Finally, we have arrived at function composition.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经到达了函数组合。
- en: In functional programming, we want everything to be a function. We especially
    want unary functions if possible. If we can convert all functions to unary functions,
    then magical things can happen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，我们希望一切都是函数。如果可能的话，我们尤其希望是一元函数。如果我们可以将所有函数转换为一元函数，那么就会发生神奇的事情。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Unary** functions are functions that take only a single input. Functions
    with multiple inputs are **polyadic**, but we usually say *binary* for functions
    that accept two inputs and **ternary** for three inputs. Some functions don''t
    accept a specific number of inputs; we call those **variadic**.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**一元**函数是只接受一个输入的函数。具有多个输入的函数是**多元**的，但对于接受两个输入的函数，我们通常说是*二元*，对于三个输入的函数，我们说是**三元**。有些函数不接受特定数量的输入；我们称这些为**可变元**。'
- en: 'Manipulating functions and their acceptable number of inputs can be extremely
    expressive. In this section, we will explore how to compose new functions from
    smaller functions: little units of logic that combine into whole programs that
    are greater than the sum of the functions on their own.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 操纵函数及其可接受的输入数量可以非常具有表现力。在本节中，我们将探讨如何从较小的函数组合新函数：将逻辑的小单元组合成整个程序，这些程序比单独的函数的总和更大。
- en: Compose
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合
- en: Composing functions allows us to build complex functions from many simple, generic
    functions. By treating functions as building blocks for other functions, we can
    build truly modular applications with excellent readability and maintainability.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 组合函数允许我们从许多简单的通用函数构建复杂的函数。通过将函数视为其他函数的构建块，我们可以构建具有出色可读性和可维护性的模块化应用程序。
- en: 'Before we define the `compose()` polyfill, you can see how it all works with
    these following examples:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义 `compose()` 的 polyfill 之前，您可以通过以下示例看到它是如何工作的：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In math, the composition of the `f` and `g` variables is defined as `f(g(x))`.
    In JavaScript, this can be written as:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，`f` 和 `g` 变量的组合被定义为 `f(g(x))`。在 JavaScript 中，这可以写成：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: But if we left it at that, we would lose track of the `this` keyword, among
    other problems. The solution is to use the `apply()` and `call()` utilities. Compared
    to curry, the `compose()` polyfill is quite simple.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们就此结束，我们将失去 `this` 关键字的跟踪，还有其他问题。解决方案是使用 `apply()` 和 `call()` 工具。与柯里化相比，`compose()`
    的 polyfill 相当简单。
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To show how it''s used, let''s build a completely contrived example, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示它的使用，让我们构建一个完全牵强的例子，如下所示：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Did you notice that the `function3` parameter was applied first? This is very
    important. Functions are applied from right to left.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到 `function3` 参数被首先应用了？这非常重要。函数是从右到左应用的。
- en: Sequence – compose in reverse
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列 - 反向组合
- en: Because many people like to read things from the left to the right, it might
    make sense to apply the functions in that order too. We'll call this a sequence
    instead of a composition.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为许多人喜欢从左到右阅读，所以按照这个顺序应用函数可能是有意义的。我们将这称为序列而不是组合。
- en: To reverse the order, all we need to do is swap the `nextFunc` and `prevFunc`
    parameters.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要颠倒顺序，我们只需要交换 `nextFunc` 和 `prevFunc` 参数。
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This allows us to now call the functions in a more natural order.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们现在可以以更自然的顺序调用函数。
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compositions versus chains
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合与链
- en: Here are five different implementations of the same `floorSqrt()` functional
    composition. They seem to be identical, but they deserve scrutiny.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有五种不同的 `floorSqrt()` 函数组合实现。它们看起来是相同的，但值得仔细检查。
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But there are a few key differences we should go over:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一些关键的区别我们应该了解：
- en: Obviously the first method is verbose and inefficient.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然，第一种方法冗长且低效。
- en: The second method is a nice one-liner, but this approach becomes very unreadable
    after only a few functions are applied.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是一个很好的一行代码，但在应用了几个函数之后，这种方法变得非常难以阅读。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To say that less code is better is missing the point. Code is more maintainable
    when the effective instructions are more concise. If you reduce the number of
    characters on the screen without changing the effective instructions carried out,
    this has the complete opposite effect—code becomes harder to understand, and decidedly
    less maintainable; for example, when we use nested ternary operators, or we chain
    several commands together on a single line. These approaches reduce the amount
    of 'code on the screen', but they don't reduce the number of steps actually being
    specified by that code. So the effect is to obfuscate and make the code harder
    to understand. The kind of conciseness that makes code easier to maintain is that
    which effectively reduces the specified instructions (for example, by using a
    simpler algorithm that accomplishes the same result with fewer and/or simpler
    steps), or when we simply replace code with a message, for instance, invoking
    a third-party library with a well-documented API.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 说少量代码更好是错的。当有效指令更简洁时，代码更易维护。如果您减少屏幕上的字符数而不改变执行的有效指令，这将产生完全相反的效果——代码变得更难理解，维护性明显降低；例如，当我们使用嵌套的三元运算符，或者在一行上链接多个命令。这些方法减少了屏幕上的
    '代码量'，但并没有减少代码实际指定的步骤数。因此，这种简洁性使得代码更易维护的方式是有效地减少指定的指令（例如，通过使用更简单的算法来实现相同结果，或者仅仅用消息替换代码，例如，使用具有良好文档化
    API 的第三方库）。
- en: The third approach is a chain of array functions, notably the `map` function.
    This works fairly well, but it is not mathematically correct.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种方法是一系列数组函数的链，特别是 `map` 函数。这很有效，但在数学上不正确。
- en: Here's our `compose()` function in action. All methods are forced to be unary,
    pure functions that encourage the use of better, simpler, and smaller functions
    that do one thing and do it well.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是我们的 `compose()` 函数的实际应用。所有方法都被强制成一元的、纯函数，鼓励使用更好、更简单、更小的函数，只做一件事并且做得很好。
- en: The last approach uses the `compose()` function in reverse sequence, which is
    just as valid.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一种方法使用了 `compose()` 函数的反向顺序，这同样有效。
- en: Programming with compose
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 compose 进行编程
- en: 'The most important aspect of compose is that, aside from the first function
    that is applied, it works best with pure, *unary* functions: functions that take
    only one argument.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 组合最重要的方面是，除了应用的第一个函数之外，它最适合使用纯 *一元* 函数：只接受一个参数的函数。
- en: The output of the first function that is applied is sent to the next function.
    This means that the function must accept what the previous function passed to
    it. This is the main influence behind *type signatures*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的第一个函数的输出被发送到下一个函数。这意味着函数必须接受前一个函数传递给它的内容。这是 *类型签名* 的主要影响。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Type Signatures are used to explicitly declare what types of input the function
    accepts and what type it outputs. They were first used by Haskell, which actually
    used them in the function definitions to be used by the compiler. But, in JavaScript,
    we just put them in a code comment. They look something like this: `foo :: arg1
    -> argN -> output`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '类型签名用于明确声明函数接受的输入类型和输出类型。它们最初由 Haskell 使用，在函数定义中由编译器使用。但在 JavaScript 中，我们只是将它们放在代码注释中。它们看起来像这样：`foo
    :: arg1 -> argN -> output`'
- en: 'Examples:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In order to truly reap the benefits of compose, any application will need a
    hefty collection of unary, pure functions. These are the building blocks that
    are composed into larger functions that, in turn, are used to make applications
    that are very modular, reliable, and maintainable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正享受组合的好处，任何应用都需要大量的一元、纯函数。这些是组合成更大函数的构建块，反过来又用于制作非常模块化、可靠和易维护的应用程序。
- en: 'Let''s go through an example. First we''ll need many building-block functions.
    Some of them build upon the others as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解。首先我们需要许多构建块函数。其中一些函数是基于其他函数构建的，如下所示：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now let's compose some of them together.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将其中一些组合在一起。
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can even use `compose()` and `curry()` functions together. In fact, they
    work very well together. Let's forge together the curry example with our compose
    example. First we'll need our helper functions from before.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将`compose()`和`curry()`函数一起使用。事实上，它们在一起工作得非常好。让我们将柯里化示例与我们的组合示例结合起来。首先我们需要之前的辅助函数。
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First we need to make the curried and partial-applied functions, then we can
    compose them to our other composed functions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们需要制作柯里化和部分应用的函数，然后我们可以将它们组合到我们的其他组合函数中。
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There we have it! The functions read really well and make a lot of sense. We
    were forced to begin with little functions that just did one thing. Then we were
    able to put together functions with more utility.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的内容！这些函数读起来非常流畅，而且意义深远。我们被迫从只做一件事的小函数开始。然后我们能够组合具有更多实用性的函数。
- en: Let's look at one last example. Here's a function that lightens an RBG value
    by a variable amount. Then we can use composition to create new functions from
    it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看最后一个例子。这是一个通过可变量来减轻RBG值的函数。然后我们可以使用组合来从中创建新的函数。
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the same way, we could easily create more functions for creating lighter
    and darker blues, greens, grays, purples, anything you want. *This is a really
    great way to construct an API*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以轻松地创建更多用于创建更浅或更深的蓝色、绿色、灰色、紫色等的函数。*这是构建API的一个非常好的方法*。
- en: We just barely scratched the surface of what function composition can do. What
    compose does is take control away from JavaScript. Normally JavaScript will evaluate
    left to right, but now the interpreter is saying "OK, something else is going
    to take care of this, I'll just move on to the next." And now the `compose()`
    function has control over the evaluation sequence!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是刚刚触及了函数组合的表面。组合的作用是夺走JavaScript的控制权。通常JavaScript会从左到右进行评估，但现在解释器在说“好的，其他东西会处理这个，我只会继续下一个。”现在`compose()`函数控制着评估顺序！
- en: This is how `Lazy.js`, `Bacon.js` and others have been able to implement things
    such as lazy evaluation and infinite sequences. Up next, we'll look into how those
    libraries are used.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`Lazy.js`、`Bacon.js`等库能够实现诸如惰性评估和无限序列等功能的方式。接下来，我们将看看这些库是如何使用的。
- en: Mostly functional programming
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大部分是函数式编程
- en: What is a program without side effects? A program that does nothing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 没有副作用的程序算不上是程序。
- en: 'Complementing our code with functional code with unavoidable side-effects can
    be called "mostly functional programming." Using multiple paradigms in the same
    codebase and applying them where they are most optimal is the best approach. Mostly
    functional programming is how even the pure, traditional functional programs are
    modelled: keep most of the logic in pure functions and interface with imperative
    code.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 用不可避免产生副作用的函数式代码来补充我们的代码可以称为“大部分是函数式编程”。在同一个代码库中使用多种范式，并在最优的地方应用它们，是最佳的方法。大部分是函数式编程是即使是纯粹的、传统的函数式程序也是如何建模的：将大部分逻辑放在纯函数中，并与命令式代码进行接口。
- en: And this is how we're going to write a little application of our own.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将要编写自己的一个小应用程序的方式。
- en: 'In this example, we have a boss that tells us that we need a web application
    for our company that tracks the status of the employees'' availability. All the
    employees at this fictional company only have one job: using our website. Staff
    will sign in when they get to work and sign out when they leave. But that''s not
    enough, it also needs to automatically update the content as it changes, so our
    boss doesn''t have to keep refreshing the pages.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个老板告诉我们，我们的公司需要一个网页应用来跟踪员工的可用性状态。这家虚构公司的所有员工只有一个工作：使用我们的网站。员工到达工作地点时会签到，离开时会签退。但这还不够，它还需要在内容发生变化时自动更新，这样我们的老板就不必一直刷新页面了。
- en: '*We''re going to use* `Lazy.js` *as our functional library*. And we''re also
    going to be lazy: instead of worrying about handling all the users logging in
    and out, WebSockets, databases, and more, we''ll just pretend there''s a generic
    application object that does this for us and just happens to have the perfect
    API.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将使用* `Lazy.js` *作为我们的函数库*。而且我们也会变得懒惰：不用担心处理所有用户的登录和退出、WebSockets、数据库等等，我们只需假装有一个通用的应用对象来为我们做这些，并且恰好具有完美的API。'
- en: So for now, let's just get the ugly parts out of the way, the parts that interface
    and create side-effects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在，让我们先把丑陋的部分搞定，也就是那些接口和产生副作用的部分。
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This would be sufficient for just displaying a list of availabilities, but we
    want it to be reactive, which brings us to our first obstacle.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于只显示可用性列表来说已经足够了，但我们希望它是响应式的，这就带来了我们的第一个障碍。
- en: By using the `Lazy.js` library to store the objects in a sequence, which won't
    actually compute anything until the `toArray()` method is called, we can take
    advantage of its laziness to provide a sort of functional reactive programming.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`Lazy.js`库将对象存储在一个序列中，直到调用`toArray()`方法才会实际计算任何内容，我们可以利用其惰性来提供一种函数式响应式编程。
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Because the `Receptor.render()` method returns new HTML instead of modifying
    the current HTML, all we have to do is set the `innerHTML` parameter to its output.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Receptor.render()`方法返回新的HTML而不是修改当前的HTML，我们只需要将`innerHTML`参数设置为它的输出。
- en: We'll also have to trust that our generic application for user management will
    provide callback methods for us to use.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要相信，我们用于用户管理的通用应用程序将为我们提供回调方法供我们使用。
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This way, any time a user logs in or out, the `lazyReceptors` parameter will
    be computed again and the availability list will be printed with the most recent
    values.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每当用户登录或退出时，“lazyReceptors”参数将被重新计算，并且可用性列表将以最新的值打印出来。
- en: Handling events
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理事件
- en: But what if the application doesn't provide callbacks for when the user logs
    in and out? Callbacks are messy and can quickly turn a program into spaghetti
    code. Instead, we can determine it ourselves by observing the user directly. If
    the user has the webpage in focus, then he/she must be active and available. We
    can use JavaScript's `focus` and `blur` events for this.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果应用程序没有提供用户登录和注销时的回调怎么办？回调很混乱，很快就会使程序变得混乱。相反，我们可以通过直接观察用户来确定。如果用户关注网页，那么他/她必须是活跃和可用的。我们可以使用JavaScript的`focus`和`blur`事件来实现这一点。
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Wait a second, aren't events reactive too? Can they be lazily computed as well?
    They can in the `Lazy.js` library, where there's even a handy method for this.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，事件也是响应式的吗？它们也可以懒计算吗？在`Lazy.js`库中可以，甚至还有一个方便的方法。
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Easy as pie.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 简单得很。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By using the `Lazy.js` library to handle events, we can create an infinite sequence
    of events. Each time the event is fired, the `Lazy.each()` function is able to
    iterate one more time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`Lazy.js`库来处理事件，我们可以创建一个无限序列的事件。每次事件触发时，`Lazy.each()`函数都能再次迭代。
- en: Our boss likes the application so far, but she points out that if an employee
    never logs out before leaving for the day without closing the page, then the application
    says the employee is still available.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的老板到目前为止很喜欢这个应用，但她指出，如果员工在离开前从未注销并关闭页面，那么应用会显示员工仍然可用。
- en: To figure out if an employee is active on the website, we can monitor the keyboard
    and mouse events. Let's say they're considered to be unavailable after 30 minutes
    of no activity.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定员工在网站上是否活跃，我们可以监视键盘和鼠标事件。假设在30分钟没有活动后，他们被视为不可用。
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `Lazy.js` library has made it very easy for us to handle events as an infinite
    stream that we can map over. It makes this possible because it uses function composition
    to take control of the order of execution.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lazy.js`库让我们很容易地处理事件，将其作为一个可以映射的无限流。这是可能的，因为它使用函数组合来控制执行顺序。'
- en: But there's a little problem with all of this. What if there are no user input
    events that we can latch onto? What if, instead, there is a property value that
    changes all the time? In the next section, we'll investigate exactly this issue.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个小问题。如果没有用户输入事件可以依附呢？相反，如果有一个属性值一直在变化呢？在下一节中，我们将详细调查这个问题。
- en: Functional reactive programming
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式响应式编程
- en: Let's build another kind of application that works in much the same way; one
    that uses functional programming to react to changes in state. But, this time,
    the application won't be able to rely on event listeners.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建另一种工作方式基本相同的应用程序；一个使用函数式编程来对状态变化做出反应的应用程序。但是，这次应用程序不能依赖事件监听器。
- en: Imagine for a moment that you work for a news media company and your boss tells
    you to create a web application that tracks government election results on Election
    Day. Data is continuously flowing in as local precincts turn in their results,
    so the results to display on the page are very reactive. But we also need to track
    the results by each region, so there will be multiple objects to track.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你在一家新闻媒体公司工作，你的老板告诉你要创建一个网络应用，用于跟踪选举日政府选举结果。数据不断地流入，因为当地选区提交他们的结果时，页面上要显示的结果是非常反应灵敏的。但我们还需要按地区跟踪结果，因此会有多个对象要跟踪。
- en: Rather than creating a big object-oriented hierarchy to model the interface,
    we can describe it declaratively as immutable data. We can transform it with chains
    of pure and semi-pure functions whose only ultimate side effects are updating
    whatever bits of state absolutely must be held onto (ideally, not many).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与其创建一个大的面向对象的层次结构来建模界面，我们可以将其声明性地描述为不可变数据。我们可以使用纯函数和半纯函数的链式转换，其最终副作用仅是更新绝对必须保留的状态位（理想情况下，不多）。
- en: And we'll use the `Bacon.js` library, which will allow us to quickly develop
    **Functional Reactive Programming** (**FRP**) applications. The application will
    only be used one day out of the year (Election Day), and our boss thinks it should
    take a proportional amount of time. With functional programming and a library
    such as `Bacon.js`, we'll get it done in half the time.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Bacon.js`库，它将允许我们快速开发**函数式响应式编程**（**FRP**）应用程序。该应用程序一年只会在一天（选举日）使用一次，我们的老板认为它应该花费相应的时间。通过函数式编程和`Bacon.js`这样的库，我们将在一半的时间内完成。
- en: But first, we're going to need some objects to represent the voting regions,
    such as states, provinces, districts, and so on.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要一些对象来表示投票区域，比如州、省、地区等。
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: While the above would be sufficient for just displaying a static list of election
    results, we need a way to update the regions dynamically. It's time to cook up
    some Bacon and FRP.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以上内容对于仅显示静态选举结果列表已经足够了，但我们需要一种动态更新区域的方法。是时候煮一些Bacon和FRP了。
- en: Reactivity
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应性
- en: Bacon has a function, `Bacon.fromPoll()`, that lets us create an event stream,
    where the event is just a function that is called on the given interval. And the
    `stream.subscribe()` function lets us *subscribe* a handler function to the stream.
    Because it's lazy, the stream will not actually do anything without a subscriber.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon有一个函数`Bacon.fromPoll()`，它让我们创建一个事件流，其中事件只是在给定间隔上调用的函数。而`stream.subscribe()`函数让我们*订阅*一个处理函数到流中。因为它是懒惰的，流没有订阅者时实际上不会执行任何操作。
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By essentially putting it in a loop that runs every 10 seconds, we could get
    the job done. But this method would hammer-ping the network and is incredibly
    inefficient. That would not be very functional. Instead, let's dig a little deeper
    into the `Bacon.js` library.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其放入每10秒运行一次的循环中，我们可以完成任务。但这种方法会频繁地ping网络，效率非常低下。这并不是很实用。相反，让我们深入了解一下`Bacon.js`库。
- en: In Bacon, there are EventStreams and Properties parameters. Properties can be
    thought of as "magic" variables that change over time in response to events. They're
    not really magic because they still rely on a stream of events. The Property changes
    over time in relation to its EventStream.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bacon中，有EventStreams和Properties参数。属性可以被认为是随时间变化的“魔术”变量，以响应事件。它们并不真的是魔术，因为它们仍然依赖于事件流。属性随时间变化，与其EventStream相关。
- en: The `Bacon.js` library has another trick up its sleeve. The `Bacon.fromPromise()`
    function is a way to emit events into a stream by using *promises*. And as of
    jQuery version 1.5.0, jQuery AJAX implements the promises interface. So all we
    need to do is write an AJAX search function that emits events when the asynchronous
    call is complete. Every time the promise is resolved, it calls the EvenStream's
    subscribers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bacon.js`库还有另一个技巧。`Bacon.fromPromise()`函数是一种通过*promises*向流发出事件的方法。而且自jQuery版本1.5.0起，jQuery
    AJAX实现了promises接口。所以我们只需要编写一个在异步调用完成时发出事件的AJAX搜索函数。每当承诺被解决时，它都会调用EventStream的订阅者。'
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A promise can be thought of as an *eventual value*; with the `Bacon.js` library,
    we can lazily wait on the eventual values.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺可以被认为是*最终值*；使用`Bacon.js`库，我们可以懒惰地等待最终值。
- en: Putting it all together
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: Now that we have the reactivity covered, we can finally play with some code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了响应性，我们终于可以玩一些代码了。
- en: We can modify the subscriber with chains of pure functions to do things such
    as adding up a total and filtering out unwanted results, and we do it all within
    `onclick()` handler functions for buttons that we create.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用纯函数的链式修改订阅者，做一些诸如累加总和和过滤不需要的结果的操作，而且我们都是在我们创建的按钮的`onclick()`处理函数中完成的。
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The beauty of this is that, when users click between the buttons, the event
    stream doesn't change but the subscriber does, which makes it all work smoothly.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 美妙之处在于，当用户在按钮之间点击时，事件流不会改变，但订阅者会改变，这使得一切都能顺利运行。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: JavaScript is a beautiful language.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种美丽的语言。
- en: Its inner beauty really shines with functional programming. It's what empowers
    its excellent extendibility. Just the fact that it allows first-class functions
    that can do so many things is what opens the functional flood gates. Concepts
    build on top of each other, stacking up higher and higher.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它的内在美真正闪耀在函数式编程中。这正是赋予它出色可扩展性的力量。它允许可以做很多事情的头等函数，这正是打开函数式大门的原因。概念在彼此之上构建，不断堆叠。
- en: In this chapter, we dove head-first into the functional paradigm in JavaScript.
    We covered function factories, currying, function composition and everything required
    to make it work. We built an extremely modular application that used these concepts.
    And then we showed how to use some functional libraries that use these same concepts
    themselves, namely function composition, to manipulate the order of execution.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先深入了解了JavaScript中的函数式范式。我们涵盖了函数工厂、柯里化、函数组合以及使其工作所需的一切。我们构建了一个极其模块化的应用程序，使用了这些概念。然后我们展示了如何使用一些使用这些概念的函数式库，即函数组合，来操纵执行顺序。
- en: 'Throughout the chapter, we covered several styles of functional programming:
    data generic programming, mostly-functional programming, and functional reactive
    programming. They''re all not that different from each other, they''re just different
    patterns for applying functional programing in different situations.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了几种函数式编程风格：数据通用编程、大部分函数式编程和函数式响应式编程。它们彼此并没有太大的不同，它们只是在不同情况下应用函数式编程的不同模式。
- en: In the previous chapter, something called Category Theory was briefly mentioned.
    In the next chapter, we're going to learn a lot more about what it is and how
    to use it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，简要提到了范畴论。在下一章中，我们将学习更多关于它是什么以及如何使用它。
