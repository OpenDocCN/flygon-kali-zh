- en: Dictionaries and Sets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典和集
- en: The current chapter will focus on data structures related to dictionaries and
    sets. A proper application of these data structures makes it possible to map keys
    to values and perform fast lookup, as well as make various operations on sets.
    To simplify the understanding of dictionaries and sets, this chapter will contain
    illustrations and code snippets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍与字典和集相关的数据结构。正确应用这些数据结构可以将键映射到值，并进行快速查找，以及对集合进行各种操作。为了简化对字典和集的理解，本章将包含插图和代码片段。
- en: In the first parts of this chapter, you will learn both non-generic and generic
    versions of a dictionary, that is, a collection of pairs, each consisting of a
    key and a value. Then, a sorted variant of a dictionary will be presented, as
    well. You will also see some similarities between dictionaries and lists.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几部分，您将学习字典的非泛型和泛型版本，即由键和值组成的一对集合。然后，还将介绍字典的排序变体。您还将看到字典和列表之间的一些相似之处。
- en: The remaining part of the chapter will show you how to use hash sets, together
    with the variant, which is named a "sorted" set. Is it possible to have a "sorted"
    set? You will get to know how to understand this topic while reading the last
    section.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的剩余部分将向您展示如何使用哈希集，以及名为“排序”集的变体。是否可能有一个“排序”集？在阅读最后一节时，您将了解如何理解这个主题。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Hash tables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表
- en: Dictionaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: Sorted dictionaries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序字典
- en: Hash sets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希集
- en: '"Sorted" sets'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “排序”集
- en: Hash tables
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希表
- en: 'Let''s start with the first data structure, which is a **hash table**, also
    known as a **hash map**. It allows **mapping** keys to particular values, as shown
    in the following diagram:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个数据结构开始，即**哈希表**，也称为**哈希映射**。它允许将键**映射**到特定值，如下图所示：
- en: '![](img/e874bb03-d53d-432d-a1b6-cfb25bae7204.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e874bb03-d53d-432d-a1b6-cfb25bae7204.png)'
- en: One of the most important assumptions of the hash table is the possibility of
    very fast lookup for a **Value** based on the **Key**, which should be the *O(1)*
    operation. To achieve this goal, the **Hash function** is used. It takes the **Key**
    to generate an index of a bucket, where the **Value** can be found.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表最重要的假设之一是可以非常快速地查找基于**Key**的**Value**，这应该是*O(1)*操作。为了实现这一目标，使用了**哈希函数**。它将**Key**生成一个桶的索引，**Value**可以在其中找到。
- en: For this reason, if you need to find a value of the key, you do not need to
    iterate through all items in the collection, because you can just use the hash
    function to easily locate a proper bucket and get the value. Due to the great
    performance of the hash table, such a data structure is frequently used in many
    real-world applications, such as for associative arrays, database indices, or
    cache systems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您需要查找键的值，您不需要遍历集合中的所有项，因为您可以使用哈希函数轻松定位适当的桶并获取值。由于哈希表的出色性能，在许多现实世界的应用程序中经常使用这样的数据结构，例如用于关联数组、数据库索引或缓存系统。
- en: As you can see, the role of the hash function is critical and ideally it should
    generate a unique result for all keys. However, it is possible that the same result
    is generated for different keys. Such a situation is called a **hash collision**
    and should be dealt with.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，哈希函数的作用至关重要，理想情况下应该为所有键生成唯一的结果。然而，可能会为不同的键生成相同的结果。这种情况被称为**哈希冲突**，需要处理。
- en: The topic of hash table implementation from scratch seems to be quite difficult,
    especially when it comes to using the hash function, handling hash collisions,
    as well as assigning particular keys to buckets. Fortunately, a suitable implementation
    is available while developing applications in the C# language, and its usage is
    very simple.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始实现哈希表的实现似乎相当困难，特别是涉及使用哈希函数、处理哈希冲突以及将特定键分配给桶。幸运的是，在C#语言中开发应用程序时可以使用合适的实现，而且使用起来非常简单。
- en: There are two variants of the hash table-related classes, namely non-generic
    (`Hashtable`) and generic (`Dictionary`). The first is described in this section,
    while the other is described in the following section. If you can use the strongly-typed
    generic version, I strongly recommend using it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表相关类有两个变体，即非泛型（`Hashtable`）和泛型（`Dictionary`）。第一个在本节中描述，而另一个在下一节中描述。如果可以使用强类型的泛型版本，我强烈建议使用它。
- en: Let's take a look at the `Hashtable` class from the `System.Collections` namespace.
    As already mentioned, it stores a collection of pairs, where each contains a key
    and a value. A pair is represented by the `DictionaryEntry` instance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`System.Collections`命名空间中的`Hashtable`类。如前所述，它存储了一组成对的集合，每个集合包含一个键和一个值。一对由`DictionaryEntry`实例表示。
- en: 'You can easily get access to a particular element using the indexer. As the
    `Hashtable` class is a non-generic variant of hash table-related classes, you
    need to cast the returned result to the proper type (for example, `string`), as
    shown here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地使用索引器访问特定元素。由于`Hashtable`类是与哈希表相关类的非泛型变体，您需要将返回的结果转换为适当的类型（例如`string`），如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In a similar way, you can set the value:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以设置值：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is worth mentioning that the `null` value is incorrect for a `key` of an
    element, but it is acceptable for `value` of an element.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，`null`值对于元素的`key`是不正确的，但对于元素的`value`是可以接受的。
- en: Apart from the indexer, the class is equipped with a few properties, which makes
    it possible to get the number of stored elements (`Count`), as well as return
    the collection of keys or values (`Keys` and `Values`, respectively). Moreover,
    you can use some available methods, such as to add a new element (`Add`), to remove
    an element (`Remove`), to remove all elements (`Clear`), as well as to check whether
    the collection contains a particular key (`Contains` and `ContainsKey`) or a given
    value (`ContainsValue`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了索引器之外，该类还配备了一些属性，可以获取存储的元素数量（`Count`），以及返回键或值的集合（分别为`Keys`和`Values`）。此外，您可以使用一些可用的方法，例如添加新元素（`Add`），删除元素（`Remove`），删除所有元素（`Clear`），以及检查集合是否包含特定键（`Contains`和`ContainsKey`）或给定值（`ContainsValue`）。
- en: 'If you want to get all entries from the hash table, you can use the `foreach`
    loop to iterate through all pairs stored in the collection, as presented here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要从哈希表中获取所有条目，可以使用`foreach`循环来迭代存储在集合中的所有对，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The variable used in the loop has the `DictionaryEntry` type. Therefore, you
    need to use its `Key` and `Value` properties to access the key and the value,
    respectively.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中使用的变量具有`DictionaryEntry`类型。因此，您需要使用其`Key`和`Value`属性分别访问键和值。
- en: You can find more information about the `Hashtable` class at [https://msdn.microsoft.com/library/system.collections.hashtable.aspx](https://msdn.microsoft.com/library/system.collections.hashtable.aspx).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://msdn.microsoft.com/library/system.collections.hashtable.aspx](https://msdn.microsoft.com/library/system.collections.hashtable.aspx)找到有关`Hashtable`类的更多信息。
- en: After this short introduction, it is now time to take a look at an example.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，现在是时候看一个例子了。
- en: Example – phone book
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-电话簿
- en: 'As an example, you will create an application for a phone book. The `Hashtable`
    class will be used to store entries where the person name is a key and the phone
    number is a value, as shown in the following diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您将创建一个电话簿应用程序。`Hashtable`类将用于存储条目，其中人名是键，电话号码是值，如下图所示：
- en: '![](img/b596dbfa-5ace-48a2-be5f-68657c98bb64.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b596dbfa-5ace-48a2-be5f-68657c98bb64.png)'
- en: The program will demonstrate how to add elements to the collection, check the
    number of stored items, iterate through all of them, check whether an element
    with a given key exists, as well as how to get a value based on the key.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将演示如何向集合中添加元素，检查存储的项目数量，遍历所有项目，检查是否存在具有给定键的元素，以及如何基于键获取值。
- en: 'The whole code presented here should be placed in the body of the `Main` method
    in the `Program` class. At the beginning, let''s create a new instance of the
    `Hashtable` class, as well as initialize it with some entries, as shown in the
    following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此处呈现的整个代码应放在`Program`类的`Main`方法的主体中。首先，让我们创建`Hashtable`类的新实例，并使用一些条目对其进行初始化，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can add elements to the collection in various ways, such as while creating
    a new instance of the class (phone numbers for `Marcin Jamro` and `John Smith`
    in the preceding example), by using the indexer (`Lily Smith`), and using the
    `Add` method (`Mary Fox`), as shown in the following part of the code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以各种方式向集合中添加元素，例如在创建类的新实例时（在前面的示例中为`Marcin Jamro`和`John Smith`的电话号码），通过使用索引器（`Lily
    Smith`），以及使用`Add`方法（`Mary Fox`），如下面的代码部分所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the call of the `Add` method is placed within the `try-catch`
    statement. Why? The answer is very simple—you cannot add more than one element
    with the same key, and in such a scenario, `ArgumentException` is thrown. To prevent
    the application from crashing, the `try-catch` statement is used and a proper
    message is shown in the console to inform the user about the situation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Add`方法的调用位于`try-catch`语句中。为什么？答案很简单——您不能添加具有相同键的多个元素，在这种情况下会抛出`ArgumentException`。为了防止应用程序崩溃，使用`try-catch`语句，并在控制台中显示适当的消息，通知用户情况。
- en: When you use the indexer to set a value for a particular key, it will not throw
    any exception when there is already an item with the given key. In such a situation,
    a value of this element will be updated.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用索引器为特定键设置值时，如果已经存在具有给定键的项目，它不会抛出任何异常。在这种情况下，将更新此元素的值。
- en: 'In the following part of the code, you iterate through all pairs from the collection
    and present the results in the console. When there are no items, the additional
    information will be presented to the user, as shown in the following code snippet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的下一部分中，您将遍历集合中的所有对，并在控制台中呈现结果。当没有项目时，将向用户呈现附加信息，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can check whether there are no elements in the collection using the `Count`
    property and comparing its value with `0`. The way of iterating through all pairs
    is simplified by the availability of the `foreach` loop. However, you need to
    remember that a single pair from the `Hashtable` class is represented by the `DictionaryEntry`
    instance and you can access its key and value using the `Key` and `Value` properties.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Count`属性检查集合中是否没有元素，并将其值与`0`进行比较。通过`foreach`循环的可用性，遍历所有对的方式变得更加简单。但是，您需要记住，`Hashtable`类中的单个对由`DictionaryEntry`实例表示，您可以使用`Key`和`Value`属性访问其键和值。
- en: 'At the end, let''s see how to check whether a specific key exists in the collection,
    as well as how to get its value. The first task can be accomplished just by calling
    the `Contains` method, which returns a value indicating whether a suitable element
    exists (`true`) or not (`false`). The other job (getting a value), uses the indexer
    and is required to cast the returned value to a suitable type (`string` in this
    example). This requirement is caused by the non-generic version of the hash table-related
    class. The code is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何检查特定键是否存在于集合中，以及如何获取其值。第一个任务可以通过调用`Contains`方法来完成，该方法返回一个值，指示是否存在合适的元素（`true`）或不存在（`false`）。另一个任务（获取值）使用索引器，并且需要将返回的值转换为适当的类型（在本例中为`string`）。这个要求是由哈希表相关类的非泛型版本引起的。代码如下：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Your first program using the hash table is ready! After launching it, you will
    receive a result similar to the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第一个使用哈希表的程序已经准备好了！启动后，您将收到类似以下的结果：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is worth noting that the order of pairs stored using the `Hashtable` class
    is not consistent with the order of their addition or keys. For this reason, if
    you need to present the sorted results, you need to sort the elements on your
    own or use another data structure, namely `SortedDictionary`, which is described
    later in the book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，使用`Hashtable`类存储的键值对的顺序与它们添加或键的顺序不一致。因此，如果需要呈现排序后的结果，您需要自行对元素进行排序，或者使用另一个数据结构，即稍后在本书中描述的`SortedDictionary`。
- en: However, for now, let's take a look at one of the most common classes used while
    developing in C#, namely `Dictionary`, which is a generic version of hash table-related
    classes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在让我们来看一下在C#中开发时最常用的类之一，即`Dictionary`，它是哈希表相关类的泛型版本。
- en: Dictionaries
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: In the previous section, you got to know the `Hashtable` class as a non-generic
    variant of the hash table-related classes. However, it has a significant limitation,
    because it does not allow you to specify a type of a key and a value. Both the `Key`
    and `Value` properties of the `DictionaryEntry` class are of the `object` type.
    Therefore, you need to perform boxing and unboxing operations, even if all keys
    and values have the same type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您了解了`Hashtable`类作为哈希表相关类的非泛型变体。但是，它有一个重要的限制，因为它不允许您指定键和值的类型。`DictionaryEntry`类的`Key`和`Value`属性都是`object`类型。因此，即使所有键和值都具有相同的类型，您仍需要执行装箱和拆箱操作。
- en: If you want to benefit from the strongly typed variant, you can use the `Dictionary`
    generic class, which is the main subject of this section of the chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用强类型变体，可以使用`Dictionary`泛型类，这是本章节的主要内容。
- en: 'First of all, you should specify two types namely, a type of a key and a value,
    while creating an instance of the `Dictionary` class. Moreover, it is possible
    to define initial content of the dictionary using the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在创建`Dictionary`类的实例时，您应该指定两种类型，即键的类型和值的类型。此外，可以使用以下代码定义字典的初始内容：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, a new instance of the `Dictionary` class is created.
    It stores `string`-based keys and values. By default, two entries exist in the
    dictionary, namely the keys `Key 1` and `Key 2`. Their values are `Value 1` and
    `Value 2`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，创建了`Dictionary`类的一个新实例。它存储基于`string`的键和值。默认情况下，字典中存在两个条目，即键`Key 1`和`Key
    2`。它们的值分别是`Value 1`和`Value 2`。
- en: 'Similar to the `Hashtable` class, here you can also use the indexer to get
    access to a particular element within the collection, as shown in the following
    line of code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Hashtable`类类似，您也可以使用索引器来访问集合中的特定元素，如下面的代码行所示：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is worth noting that casting to the `string` type is unnecessary, because
    `Dictionary` is the strongly typed version of the hash table-related classes.
    Therefore, the returned value already has the proper type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，不需要将类型转换为`string`类型，因为`Dictionary`是哈希表相关类的强类型版本。因此，返回的值已经具有正确的类型。
- en: 'If an element with the given key does not exist in the collection, `KeyNotFoundException`
    is thrown. To avoid problems, you can do one of the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合中不存在具有给定键的元素，则会抛出`KeyNotFoundException`。为了避免问题，您可以选择以下之一：
- en: Place the line of code in the `try-catch` block
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码行放在`try-catch`块中
- en: Check whether the element exists (by calling `ContainsKey`)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查元素是否存在（通过调用`ContainsKey`）
- en: Use the `TryGetValue` method
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`TryGetValue`方法
- en: 'You can add a new element or update a value of the existing one using the indexer,
    as shown in the following line of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用索引器添加新元素或更新现有元素的值，如下面的代码行所示：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Similar to the non-generic variant, the `key` cannot be equal to `null`, but
    a `value` can be, of course, if it is allowed by the type of values stored in
    the collection. Moreover, the performance of getting a value of an element, adding
    a new element, or updating an existing one, is approaching the *O(1)* operation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与非泛型变体类似，`key`不能等于`null`，但`value`可以，当然，如果允许存储在集合中的值的类型。此外，获取元素的值、添加新元素或更新现有元素的性能接近*O(1)*操作。
- en: The `Dictionary` class is equipped with a few properties, which makes it possible
    to get the number of stored elements (`Count`), as well as return the collection
    of keys or values (`Keys` and `Values`, respectively). Moreover, you can use the
    available methods, such as for adding a new element (`Add`), removing an item
    (`Remove`), removing all elements (`Clear`), as well as checking whether the collection
    contains a particular key (`ContainsKey`) or a given value (`ContainsValue`).
    You can also use the `TryGetValue` method to try to get a value for a given key
    and return it (if the element exists) or return `null` (otherwise).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary`类配备了一些属性，可以获取存储元素的数量（`Count`），以及返回键或值的集合（分别是`Keys`和`Values`）。此外，您可以使用可用的方法，例如添加新元素（`Add`），删除项目（`Remove`），删除所有元素（`Clear`），以及检查集合是否包含特定键（`ContainsKey`）或给定值（`ContainsValue`）。您还可以使用`TryGetValue`方法尝试获取给定键的值并返回它（如果元素存在），否则返回`null`。'
- en: While scenarios of returning a value by a given key (using an indexer or `TryGetValue`)
    and checking whether the given key exists (`ContainsKey`) are approaching the
    *O(1)* operation, the process of checking whether the collection contains a given
    value (`ContainsValue`) is the *O(n)* operation and requires you to search the
    entire collection for the particular value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过给定键返回值（使用索引器或`TryGetValue`）和检查给定键是否存在（`ContainsKey`）的场景接近*O(1)*操作，但检查集合是否包含给定值（`ContainsValue`）的过程是*O(n)*操作，并且需要您搜索整个集合以查找特定值。
- en: 'If you want to iterate through all pairs stored in the collection, you can
    use the `foreach` loop. However, the variable used in the loop is an instance
    of the `KeyValuePair` generic class with `Key` and `Value` properties, allowing
    you to access the key and the value. The `foreach` loop is shown in the following
    code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要遍历集合中存储的所有对，可以使用`foreach`循环。但是，循环中使用的变量是`KeyValuePair`泛型类的实例，具有`Key`和`Value`属性，允许您访问键和值。`foreach`循环显示在以下代码片段中：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Do you remember the thread-safe versions of some classes from the previous chapter?
    If so, the situation looks quite similar in the case of the `Dictionary` class,
    because the `ConcurrentDictionary` class (from the `System.Collections.Concurrent`
    namespace) is available. It is equipped with a set of methods, such as `TryAdd`,
    `TryUpdate`, `AddOrUpdate`, and `GetOrAdd`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您还记得上一章中一些类的线程安全版本吗？如果记得，那么在`Dictionary`类的情况下，情况看起来与`ConcurrentDictionary`类相当相似，因为`System.Collections.Concurrent`命名空间中提供了`ConcurrentDictionary`类。它配备了一组方法，例如`TryAdd`、`TryUpdate`、`AddOrUpdate`和`GetOrAdd`。
- en: You can find more information about the `Dictionary` generic class at [https://msdn.microsoft.com/library/xfhwa508.aspx](https://msdn.microsoft.com/library/xfhwa508.aspx),
    while details of the thread-safe alternative, namely `ConcurrentDictionary`, are
    shown at [https://msdn.microsoft.com/library/dd287191.aspx](https://msdn.microsoft.com/library/dd287191.aspx).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://msdn.microsoft.com/library/xfhwa508.aspx](https://msdn.microsoft.com/library/xfhwa508.aspx)找到有关`Dictionary`泛型类的更多信息，而有关线程安全替代方案`ConcurrentDictionary`的详细信息则显示在[https://msdn.microsoft.com/library/dd287191.aspx](https://msdn.microsoft.com/library/dd287191.aspx)。
- en: Let's start coding! In the following sections, you will find two examples presenting
    dictionaries.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编码！在接下来的部分，您将找到两个展示字典的示例。
- en: Example – product location
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-产品位置
- en: The first example is the application that helps employees of a shop to find
    the location of where a product should be placed. Let's imagine that each employee
    has a phone with your application, which is used to scan the code of the product
    and the application tells them that the product should be located in area **A1**
    or **C9**. Sounds interesting, doesn't it?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例是帮助商店员工找到产品应放置的位置的应用程序。假设每个员工都有一部手机，上面安装了您的应用程序，用于扫描产品的代码，应用程序会告诉他们产品应放置在**A1**或**C9**区域。听起来很有趣，不是吗？
- en: 'As the number of products in the shop is often very high, it is necessary to
    find results quickly. For this reason, the data of products together with their
    locations will be stored in the hash table, using the generic `Dictionary` class.
    The key will be the barcode, while the value will be the area code, as shown in
    the following diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于商店中的产品数量通常非常庞大，因此有必要快速找到结果。因此，产品的数据以及其位置将存储在哈希表中，使用泛型`Dictionary`类。键将是条形码，而值将是区域代码，如下图所示：
- en: '![](img/47f0b01a-098f-4b52-b227-d3d1daf4b0ce.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47f0b01a-098f-4b52-b227-d3d1daf4b0ce.png)'
- en: 'Let''s take a look at the code, which should be added to the `Main` method
    in the `Program` class. At the beginning, you need to create a new collection,
    as well as add some data:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下应该添加到`Program`类的`Main`方法中的代码。首先，您需要创建一个新的集合，并添加一些数据：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The code shows two ways of adding elements to the collection, namely by passing
    their data while creating a new instance of the class and by using the indexer.
    A third solution also exists and uses the `Add` method, as shown in the following
    part of the code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 代码显示了向集合中添加元素的两种方法，即在创建类的新实例时传递它们的数据和使用索引器。还存在第三种解决方案，使用`Add`方法，如代码的以下部分所示：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As mentioned in the case of the `Hashtable` class, `ArgumentException` is thrown
    if you want to add the element with the same key as the one already existing in
    the collection. You can prevent the application from crashing by using the `try-catch`
    block.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Hashtable`类的情况下提到，如果您想要添加与集合中已存在的元素具有相同键的元素，则会抛出`ArgumentException`。您可以通过使用`try-catch`块来防止应用程序崩溃。
- en: 'In the following part of the code, you present the data of all products available
    in the system. To do so, you use the `foreach` loop, but before that you check
    whether there are any elements in the dictionary. If not, the proper message is
    presented to the user. Otherwise, keys and values from all pairs are presented
    in the console. It is worth mentioning that a type of the variable within the
    `foreach` loop is `KeyValuePair<string, string>`, thus its `Key` and `Value` properties
    are of the `string` type, not `object`, as in the case of the non-generic variant.
    The code is shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的下一部分中，您会展示系统中所有可用产品的数据。为此，您使用`foreach`循环，但在此之前，您要检查字典中是否有任何元素。如果没有，则向用户呈现适当的消息。否则，控制台中显示所有对的键和值。值得一提的是，在`foreach`循环中的变量类型是`KeyValuePair<string,
    string>`，因此其`Key`和`Value`属性是`string`类型，而不是`object`类型，与非泛型变体的情况相同。代码如下所示：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At the end, let''s take a look at the part of the code that makes it possible
    to find a location for the product by its barcode. To do so, you use `TryGetValue`
    to check whether the element exists. If so, a message with the target location
    is presented in the console. Otherwise, other information is shown. What is important
    is that the `TryGetValue` method uses the `out` parameter to return the found
    value of the element. The code is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下代码的一部分，该代码使得可以通过其条形码找到产品的位置。为此，您使用`TryGetValue`来检查元素是否存在。如果是，控制台中会显示带有目标位置的消息。否则，会显示其他信息。重要的是，`TryGetValue`方法使用`out`参数来返回找到的元素的值。代码如下：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you run the program, you will see the list of all products in the shop
    and the program will ask you to enter the barcode. After typing it, you will receive
    the message with the area code. The result shown in the console will be similar
    to the following one:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序时，您将看到商店中所有产品的列表，并且程序会要求您输入条形码。输入后，您将收到带有区域代码的消息。控制台中显示的结果将类似于以下内容：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You have just completed the first example! Let's proceed to the next one.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚完成了第一个示例！让我们继续到下一个。
- en: Example – user details
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-用户详细信息
- en: 'The second example will show you how to store more complex data in the dictionary.
    In this scenario, you will create an application that shows details of a user
    based on him or her identifier, as shown in the following diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例将向您展示如何在字典中存储更复杂的数据。在这种情况下，您将创建一个应用程序，根据用户的标识符显示用户的详细信息，如下图所示：
- en: '![](img/12009a61-2e0f-4ab3-9a8a-de5495759aff.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12009a61-2e0f-4ab3-9a8a-de5495759aff.png)'
- en: The program should start with the data of three users. You should be able to
    enter the identifier and see details of the found user. Of course, the situation
    of non-existence of a given user should be handled by presenting the proper information
    in the console.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 程序应该以三个用户的数据开始。您应该能够输入标识符并查看找到的用户的详细信息。当然，应该通过在控制台中呈现适当的信息来处理给定用户不存在的情况。
- en: 'At the beginning, let''s add the `Employee` class that just stores the data
    of an employee, namely first name, last name, and phone number. The code is as
    follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加`Employee`类，它只存储员工的数据，即名字、姓氏和电话号码。代码如下：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next modifications will be performed in the `Main` method in the `Program`
    class. Here, you create a new instance of the `Dictionary` class and add the data
    of three employees, using the `Add` method, as shown in the following code snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的修改将在`Program`类的`Main`方法中执行。在这里，您创建了`Dictionary`类的一个新实例，并使用`Add`方法添加了三个员工的数据，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The most interesting operations are performed in the following `do-while` loop:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的操作是在以下`do-while`循环中执行的：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, the user is asked to enter the identifier of the employee, which is then
    parsed to the integer value. If this operation is completed successfully, the
    `TryGetValue` method is used to try to get details of the user. If the user is
    found, that is, `TryGetValue` returns `true`, the details are presented in the
    console. Otherwise, `"The employee with the given identifier does not exist."` message
    is shown. The loop is executed until the provided identifier cannot be parsed
    to the integer value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用户被要求输入员工的标识符，然后将其解析为整数值。如果此操作成功完成，则使用`TryGetValue`方法尝试获取用户的详细信息。如果找到用户，即`TryGetValue`返回`true`，则在控制台中呈现详细信息。否则，显示`“给定标识符的员工不存在。”`消息。循环执行，直到提供的标识符无法解析为整数值为止。
- en: 'When you run the application and enter some data, you will receive the following
    result:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序并输入一些数据时，您将收到以下结果：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That's all! You have just completed two examples showing how to use dictionaries
    while developing applications in the C# language.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！您刚刚完成了两个示例，展示了如何在C#语言中开发应用程序时使用字典。
- en: However, another kind of dictionary has been mentioned in the section regarding
    the `Hashtable` class, namely a sorted dictionary. Are you interested in finding
    out what it does and how you can use it in your programs? If so, let's proceed
    to the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在关于`Hashtable`类的部分提到了另一种字典，即有序字典。您是否有兴趣了解它的作用以及如何在程序中使用它？如果是的话，让我们继续到下一节。
- en: Sorted dictionaries
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有序字典
- en: Both non-generic and generic variants of the hash table-related classes do not
    keep the order of the elements. For this reason, if you need to present data from
    the collection sorted by keys, you need to sort them prior to presentation. However,
    you can use another data structure, the **sorted dictionary,** to solve this problem
    and keep keys sorted all the time. Therefore, you can easily get the sorted collection
    whenever necessary.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与哈希表相关的类的非泛型和泛型变体都不保留元素的顺序。因此，如果您需要按键排序的方式呈现来自集合的数据，您需要在呈现之前对它们进行排序。但是，您可以使用另一种数据结构，**有序字典**，来解决这个问题，并始终保持键的排序。因此，您可以在必要时轻松获取排序后的集合。
- en: The sorted dictionary is implemented as the `SortedDictionary` generic class,
    available in the `System.Collections.Generic` namespace. You can specify types
    for keys and values while creating a new instance of the `SortedDictionary` class.
    Moreover, the class contains similar properties and methods to `Dictionary`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有序字典实现为`SortedDictionary`泛型类，位于`System.Collections.Generic`命名空间中。您可以在创建`SortedDictionary`类的新实例时指定键和值的类型。此外，该类包含与`Dictionary`类类似的属性和方法。
- en: 'First of all, you can use the indexer to get access to a particular element
    within the collection, as shown in the following line of code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以使用索引器访问集合中的特定元素，如下面的代码行所示：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You should ensure that the element exists in the collection. Otherwise, `KeyNotFoundException`
    is thrown.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该确保元素存在于集合中。否则，将抛出`KeyNotFoundException`。
- en: 'You can add a new element or update a value of the existing one, as shown in
    the code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加新元素或更新现有元素的值，如下所示的代码：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Similar to the `Dictionary` class, a key cannot be equal to `null`, but value can
    be, of course, if it is allowed by the type of values stored in the collection.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Dictionary`类类似，键不能等于`null`，但值可以，当然，如果允许存储在集合中的值的类型允许的话。
- en: The class is equipped with a few properties, which makes it possible to get
    the number of stored elements (`Count`), as well as return the collection of keys
    and values (`Keys` and `Values`, respectively). Moreover, you can use the available
    methods, such as for adding a new element (`Add`), removing an item (`Remove`),
    removing all elements (`Clear`), as well as checking whether the collection contains
    a particular key (`ContainsKey`) or a given value (`ContainsValue`). You can use
    the `TryGetValue` method to try to get a value for a given key and return it (if
    the element exists) or return `null` (otherwise).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该类配备了一些属性，可以获取存储元素的数量（`Count`），以及返回键和值的集合（`Keys`和`Values`）。此外，您可以使用可用的方法，例如添加新元素（`Add`），删除项目（`Remove`），删除所有元素（`Clear`），以及检查集合是否包含特定键（`ContainsKey`）或给定值（`ContainsValue`）。您可以使用`TryGetValue`方法尝试获取给定键的值并返回它（如果元素存在），否则返回`null`。
- en: If you want to iterate through all pairs stored in the collection, you can use
    the `foreach` loop. The variable used in the loop is an instance of the `KeyValuePair`
    generic class with `Key` and `Value` properties, allowing you to access the key
    and the value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要遍历集合中存储的所有键值对，可以使用`foreach`循环。循环中使用的变量是`KeyValuePair`泛型类的实例，具有`Key`和`Value`属性，允许您访问键和值。
- en: Despite the automatic sorting advantages, the `SortedDictionary` class has some
    performance drawbacks in comparison with `Dictionary`, because retrieval, insertion,
    and removal are the *O(log n)* operations, where *n* is the number of elements
    in the collection, instead of *O(1)*. Moreover, `SortedDictionary` is quite similar
    to `SortedList`, described in [Chapter 2](f285d687-6495-4d5e-a2b0-6f0b4af46096.xhtml),
    *Arrays and Lists*. However, it differs in memory-related and performance-related
    results. The retrieval for both these classes is the *O(log n)* operation, but
    insertion and removal for unsorted data is *O(log n)* for `SortedDictionary` and
    *O(n)* for `SortedList`. Of course, more memory is necessary for `SortedDictionary`
    than for `SortedList`. As you can see, choosing a proper data structure is not
    an easy task and you should think carefully about the scenarios in which particular
    data structures will be used and take into account the both pros and cons.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自动排序有优势，但与`Dictionary`相比，`SortedDictionary`类在性能上有一些缺点，因为检索、插入和删除都是*O(log n)*操作，其中*n*是集合中的元素数量，而不是*O(1)*。此外，`SortedDictionary`与[第2章](f285d687-6495-4d5e-a2b0-6f0b4af46096.xhtml)中描述的`SortedList`非常相似，*数组和列表*。然而，它们在与内存相关和性能相关的结果上有所不同。这两个类的检索都是*O(log
    n)*操作，但对于未排序的数据，`SortedDictionary`的插入和删除是*O(log n)*，而`SortedList`是*O(n)*。当然，`SortedDictionary`需要比`SortedList`更多的内存。正如您所看到的，选择合适的数据结构并不是一件容易的事，您应该仔细考虑特定数据结构将被使用的场景，并考虑其优缺点。
- en: You can find more information about the `SortedDictionary` generic class at
    [https://msdn.microsoft.com/library/f7fta44c.aspx](https://msdn.microsoft.com/library/f7fta44c.aspx).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://msdn.microsoft.com/library/f7fta44c.aspx](https://msdn.microsoft.com/library/f7fta44c.aspx)找到关于`SortedDictionary`泛型类的更多信息。
- en: Let's see the sorted dictionary in action by creating an example.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个示例来看看排序字典的实际操作。
- en: Example – definitions
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-定义
- en: As an example, you will create a simple encyclopedia, where you can add entries,
    as well as show its full content. The encyclopedia can contain millions of entries,
    so it is crucial to provide its users with the possibility of browsing entries
    in the correct order, alphabetically by keys, as well as finding entries quickly.
    For this reason, the sorted dictionary is a good choice in this example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以创建一个简单的百科全书，可以添加条目，并显示其完整内容。百科全书可以包含数百万条目，因此至关重要的是为其用户提供按正确顺序浏览条目的可能性，按键的字母顺序排列，以及快速找到条目。因此，在这个例子中，排序字典是一个很好的选择。
- en: 'The idea of the encyclopedia is shown in the following diagram:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 百科全书的概念如下图所示：
- en: '![](img/9915bf6c-68cd-49a8-8a8b-98078a4c5462.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9915bf6c-68cd-49a8-8a8b-98078a4c5462.png)'
- en: When the program is launched, it presents a simple menu with two options, namely
    `[a] - add` and `[l] - list`. After pressing the *A* key, the application asks
    you to enter the name and explanation for the entry. If the provided data are
    correct, a new entry is added to the encyclopedia. If the user presses the *L* key,
    the data of all entries, sorted by keys, are presented in the console. When any
    other key is pressed, the additional confirmation is shown and, if confirmed,
    the program exits.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，它会显示一个简单的菜单，包括两个选项，即`[a] - add`和`[l] - list`。按下*A*键后，应用程序会要求您输入条目的名称和解释。如果提供的数据是正确的，新条目将被添加到百科全书中。如果用户按下*L*键，则按键排序的所有条目数据将显示在控制台中。当按下其他键时，会显示额外的确认信息，如果确认，则程序退出。
- en: 'Let''s take a look at the code, which should be placed as the body of the `Main`
    method in the `Program` class:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看代码，它应该放在`Program`类的`Main`方法的主体中：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At the beginning, a new instance of the `SortedDictionary` class is created,
    which represents a collection of pairs with `string`-based keys and `string`-based
    values. Then, the infinite `do-while` loop is used. Within it, the program waits
    until the user presses any key. If it is the *A* key, a name and explanation for
    the entry are obtained from the values entered by the user. Then, a new entry
    is added to the dictionary using the indexer. Thus, if the entry with the same
    key already exists, it will be updated. In the case of pressing the *L* key, the
    `foreach` loop is used to show all entered entries. When any other key is pressed,
    another question is presented to the user and the program waits for confirmation.
    If the user presses *Y*, you break out of the loop.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建了`SortedDictionary`类的新实例，它表示具有基于`string`的键和基于`string`的值的一组对。然后，使用无限的`do-while`循环。在其中，程序会等待用户按下任意键。如果是*A*键，程序将从用户输入的值中获取条目的名称和解释。然后，使用索引器将新条目添加到字典中。因此，如果具有相同键的条目已经存在，它将被更新。如果按下*L*键，则使用`foreach`循环显示所有输入的条目。当按下其他键时，会向用户显示另一个问题，并等待确认。如果用户按下*Y*，则跳出循环。
- en: 'When you run the program, you can enter a few entries, as well as present them.
    The result from the console is shown in the following block:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行程序时，您可以输入一些条目，并将它们显示出来。控制台的结果如下所示：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So far, you have learned three dictionary-related classes, namely `Hashtable`,
    `Dictionary`, and `SortedDictionary`. All of them have some specific advantages
    and they can be used in various scenarios. To make understanding them easier,
    a few examples have been presented, together with a detailed explanation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学习了三个与字典相关的类，分别是`Hashtable`、`Dictionary`和`SortedDictionary`。它们都有一些特定的优势，并且可以在各种场景中使用。为了更容易理解它们，我们提供了一些示例，并附有详细的解释。
- en: However, do you know that there are also some other data structures that store
    just keys, without values? Do you want to learn more about them? If so, let's
    proceed to the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你知道还有一些其他只存储键而没有值的数据结构吗？想要了解更多吗？如果是的话，让我们继续到下一节。
- en: Hash sets
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希集
- en: In some algorithms, it is necessary to perform operations on sets with various
    data. However, what is a **set**? A set is a collection of distinct objects without
    duplicated elements and without a particular order. Therefore, you can only get
    to know whether a given element is in the set or not. The sets are strictly connected
    with the mathematical models and operations, such as union, intersection, subtraction,
    and symmetric difference.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些算法中，有必要对具有不同数据的集合执行操作。但是，什么是**集合**？集合是一组不重复元素的集合，没有重复的元素，也没有特定的顺序。因此，你只能知道给定的元素是否在集合中。集合与数学模型和操作紧密相关，如并集、交集、差集和对称差。
- en: A set can store various data, such as integer or string values, as shown in
    the following diagram. Of course, you can also create a set with instances of
    a user-defined class, as well as add and remove elements from the set at any time.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 集合可以存储各种数据，如整数或字符串值，如下图所示。当然，你也可以创建一个包含用户定义类实例的集合，并随时向集合中添加和删除元素。
- en: '![](img/711ea288-1b69-41e1-bc10-ce9441ca8978.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/711ea288-1b69-41e1-bc10-ce9441ca8978.png)'
- en: 'Before seeing sets in action, it is a good idea to remind you of some basic
    operations that can be performed on two sets, named **A** and **B**. Let''s start
    with the union and intersection, as shown in the following illustration. As you
    can see, the **union** (shown on the left as **A∪B**) is a set with all elements
    that belong to **A** or **B**. The **intersection** (presented on the right as
    **A∩B**) contains only the elements that belong to both **A** and **B**:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到集合的实际操作之前，值得提醒一下可以对两个集合**A**和**B**执行的一些基本操作。让我们从并集和交集开始，如下图所示。如你所见，**并集**（左侧显示为**A∪B**）是一个包含属于**A**或**B**的所有元素的集合。**交集**（右侧显示为**A∩B**）仅包含属于**A**和**B**的元素：
- en: '![](img/d5053aab-bdec-4534-a3a4-65677880f858.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5053aab-bdec-4534-a3a4-65677880f858.png)'
- en: 'Another common operation is the **set subtraction**. The result set of **A
    \ B** contains elements which are the members of **A** and not the members of
    **B**. In the following illustration, two examples are presented, namely **A \
    B** and **B \ A**:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的操作是**集合减法**。**A \ B**的结果集包含属于**A**而不属于**B**的元素。在下面的示例中，分别呈现了**A \ B**和**B
    \ A**：
- en: '![](img/7c8d365f-f84c-4d1c-abaf-abe4805fad0e.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c8d365f-f84c-4d1c-abaf-abe4805fad0e.png)'
- en: 'While performing operations on sets, it is also worth mentioning the **symmetric
    difference**, which is presented on the left-hand side of the following illustration,
    as **A ∆ B**. The final set can be interpreted as a union of two sets, namely
    (**A \ B**) and (**B \ A**). Therefore, it contains elements that belong to only
    one set, either **A** or **B**. The elements that belong to both sets are excluded
    from the result:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在对集合执行操作时，还值得提到**对称差**，如下图左侧所示的**A ∆ B**。最终集合可以解释为两个集合的并集，即（**A \ B**）和（**B
    \ A**）。因此，它包含属于只属于一个集合的元素，要么是**A**，要么是**B**。属于两个集合的元素被排除在结果之外：
- en: '![](img/ba83077a-cb31-42c0-bc5b-2df29ff3445e.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba83077a-cb31-42c0-bc5b-2df29ff3445e.png)'
- en: Another important topic is the **relationship** between sets. If every element
    of **B** belongs also to **A**, it means that **B** is a **subset** of **A**,
    as shown in the preceding diagram, on the right. At the same time, **A** is a
    **superset** of **B**. Moreover, if **B** is a subset of **A**, but **B** is not
    equal to **A**, **B** is a **proper subset** of **A**, and **A** is a **proper
    superset** of **B**.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的主题是集合之间的**关系**。如果**B**的每个元素也属于**A**，那么**B**是**A**的**子集**，如前图中右侧所示。同时，**A**是**B**的**超集**。此外，如果**B**是**A**的子集，但**B**不等于**A**，那么**B**是**A**的**真子集**，而**A**是**B**的**真超集**。
- en: While developing applications in the C# language, you can benefit from high-performance
    operations provided by the `HashSet` class from the `System.Collections.Generic`
    namespace. The class contains a few properties, including `Count` that returns
    the number of elements in the set. Moreover, you can use many methods to perform
    operations of sets, as explained next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#语言中开发应用程序时，你可以从`System.Collections.Generic`命名空间中的`HashSet`类提供的高性能操作中受益。该类包含一些属性，包括返回集合中元素数量的`Count`。此外，你可以使用许多方法来执行集合操作，如下面所述。
- en: 'The first group of methods makes it possible to modify the current set (on
    which the method is called) to create the following, with the set passed as the
    parameter:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组方法使得可以修改当前集合（调用方法的集合）以创建以下集合，其中传递的集合作为参数：
- en: The union (`UnionWith`)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并集（`UnionWith`）
- en: The intersection (`IntersectWith`)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交集（`IntersectWith`）
- en: The subtraction (`ExceptWith`)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 差集（`ExceptWith`）
- en: The symmetric difference (`SymmetricExceptWith`)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称差（`SymmetricExceptWith`）
- en: 'You can also check the relationships between two sets, such as checking whether
    the current set (on which the method is called) is:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以检查两个集合之间的关系，例如检查调用方法的当前集合是否是：
- en: A subset (`IsSubsetOf`) of the set passed as the parameter
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递的集合的子集（`IsSubsetOf`）
- en: A superset (`IsSupersetOf`) of the set passed as the parameter
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递的集合的超集（`IsSupersetOf`）
- en: A proper subset (`IsProperSubsetOf`) of the set passed as the parameter
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递的集合的真子集（`IsProperSubsetOf`）
- en: A proper superset (`IsProperSupersetOf`) of the set passed as the parameter
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递的集合的真超集（`IsProperSupersetOf`）
- en: Furthermore, you can verify whether two sets contain the same elements (`SetEquals`)
    or whether two sets have at least one common element (`Overlaps`).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以验证两个集合是否包含相同的元素（`SetEquals`），或者两个集合是否至少有一个公共元素（`Overlaps`）。
- en: Apart from the mentioned operations, you can add a new element to the set (`Add`),
    remove a particular element (`Remove`), or remove all elements (`Clear`), as well
    as check whether the given element exists in the set (`Contains`).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述操作，您还可以向集合中添加新元素（`Add`），删除特定元素（`Remove`）或删除所有元素（`Clear`），以及检查给定元素是否存在于集合中（`Contains`）。
- en: You can find more information about the `HashSet` generic class at [https://msdn.microsoft.com/library/bb359438.aspx](https://msdn.microsoft.com/library/bb359438.aspx).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://msdn.microsoft.com/library/bb359438.aspx](https://msdn.microsoft.com/library/bb359438.aspx)找到有关`HashSet`泛型类的更多信息。
- en: After this introduction, it is a good idea to try to put the learned information
    into practice. Thus, let's proceed to two examples that will show you how you
    can apply hash sets in your applications.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个介绍之后，尝试将学到的信息付诸实践是一个好主意。因此，让我们继续进行两个示例，它们将向您展示如何在应用程序中应用哈希集。
- en: Example – coupons
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 优惠券
- en: The first example represents the system that checks whether a one-time coupon
    has already been used. If so, a suitable message should be presented to the user.
    Otherwise, the system should inform the user that the coupon is valid and it should
    be marked as used and cannot be used again. Due to the high number of coupons,
    it is necessary to choose a data structure that allows for quickly checking whether
    an element exists in some collection. For this reason, the hash set is chosen
    as a data structure for storing identifiers of the used coupons. Therefore, you
    just need to check whether an entered identifier exists in the set.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例代表了一个系统，用于检查一次性优惠券是否已经被使用。如果是，应向用户呈现适当的消息。否则，系统应通知用户优惠券有效，并且应标记为已使用，不能再次使用。由于优惠券数量众多，有必要选择一种数据结构，可以快速检查某个集合中是否存在元素。因此，哈希集被选择为存储已使用优惠券的标识符的数据结构。因此，您只需要检查输入的标识符是否存在于集合中。
- en: 'Let''s take a look at the code, which should be added to the `Main` method
    in the `Program` class. The first part is shown here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看应该添加到`Program`类的`Main`方法的代码。第一部分如下所示：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At the beginning, a new instance of the `HashSet` generic class, storing integer
    values, is created. Then, the majority of the operations are performed within
    the `do-while` loop. Here, the program waits until the user enters the coupon
    identifier. If it cannot be parsed to the integer value, you break out of the
    loop. Otherwise, it is checked whether the set already contains an element equal
    to the identifier of the coupon (using the `Contains` method). If so, the suitable
    warning information is presented. However, if it does not exist, you add it to
    the collection of used coupons (using the `Add` method) and inform the user.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建存储整数值的`HashSet`泛型类的新实例。然后，大多数操作都在`do-while`循环内执行。在这里，程序会等待用户输入优惠券标识符。如果无法解析为整数值，则跳出循环。否则，将检查集合是否已包含等于优惠券标识符的元素（使用`Contains`方法）。如果是，将呈现适当的警告信息。但是，如果不存在，则将其添加到已使用优惠券的集合中（使用`Add`方法）并通知用户。
- en: 'When you break out of the loop, you just need to show the complete list of
    identifiers of the used coupons. You can achieve this goal using the `foreach`
    loop, iterating over the set, and writing its elements in the console, as shown
    in the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当您跳出循环时，您只需要显示已使用优惠券的标识符的完整列表。您可以使用`foreach`循环实现此目标，遍历集合，并在控制台中写入其元素，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now you can launch the application, enter some data, and see how it works.
    The result written in the console is presented here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以启动应用程序，输入一些数据，然后查看它的运行情况。控制台中的结果如下所示：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is the end of the first example. Let's proceed to the next one, where you
    will see a more complex solution that uses the hash set.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个示例的结束。让我们继续进行下一个示例，在这个示例中，您将看到一个使用哈希集的更复杂的解决方案。
- en: Example – swimming pools
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 游泳池
- en: This example presents the system for a SPA center with four swimming pools,
    namely recreation, competition, thermal, and for kids. Each visitor receives a
    special wrist band that allows one to enter all the pools. However, it is necessary
    to scan the wrist band while entering any pool and your program can use such data
    for creating various statistics.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一个SPA中心的系统，有四个游泳池，分别是休闲、比赛、温泉和儿童。每位访客都会收到一个特殊的手腕带，可以进入所有游泳池。但是，必须在进入任何游泳池时扫描手腕带，您的程序可以使用这些数据来创建各种统计数据。
- en: 'In this example, the hash set is chosen as a data structure for storing unique
    numbers of wrist bands that have been scanned in the entrance to each swimming
    pool. Four sets will be used, one per each pool, as shown in the following diagram.
    Moreover, they will be grouped in the dictionary to simplify and shorten the code,
    as well as make future modifications easier:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，哈希集被选择为存储已经在每个游泳池入口扫描的手腕带的唯一编号的数据结构。将使用四个集合，每个游泳池一个，如下图所示。此外，它们将被分组在字典中，以简化和缩短代码，以及使未来的修改更容易：
- en: '![](img/5e73a997-35ca-427f-8258-207a9986b8a1.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e73a997-35ca-427f-8258-207a9986b8a1.png)'
- en: To simplify testing the application, the initial data will be set randomly.
    Thus, you just need to create statistics, namely the number of visitors by a pool
    type, the most popular pool, the number of people who visited at least one pool,
    and the number of people who visited all the pools. All the statistics will use
    sets.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化测试应用程序，初始数据将被随机设置。因此，您只需要创建统计数据，即按游泳池类型统计的访客人数，最受欢迎的游泳池，至少访问过一个游泳池的人数，以及访问过所有游泳池的人数。所有统计数据将使用集合。
- en: 'Let''s start with the `PoolTypeEnum` enumeration (declared in the `PoolTypeEnum.cs`
    file), which represents possible types of swimming pools, as shown in the following
    code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`PoolTypeEnum`枚举开始（在`PoolTypeEnum.cs`文件中声明），它表示可能的游泳池类型，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, add the `random` private static field to the `Program` class. It will
    be used to fill the hash set with some random values. The code is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向`Program`类添加`random`私有静态字段。它将用于使用一些随机值填充哈希集。代码如下：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, declare the `GetRandomBoolean` static method in the `Program` class to
    return the `true` or `false` value, according to the random value. The code is
    shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Program`类中声明`GetRandomBoolean`静态方法，返回`true`或`false`值，根据随机值。代码如下所示：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The next changes are necessary only in the `Main` method. The first part is
    as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的更改只需要在`Main`方法中进行。第一部分如下：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, you create a new instance of `Dictionary`. It contains four entries. Each
    key is of the `PoolTypeEnum` type and each value of the `HashSet<int>` type, that
    is, a set with integer values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个`Dictionary`的新实例。它包含四个条目。每个键都是`PoolTypeEnum`类型，每个值都是`HashSet<int>`类型，也就是一个包含整数值的集合。
- en: 'In the next part, you fill the sets with random values, as shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，你会用随机值填充集合，如下所示：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To do so, you use two loops, namely `for` and `foreach`. The first iterates
    100 times and simulates 100 wrist bands. Within it there is the `foreach` loop
    that iterates through all available pool types. For each of them, you randomly
    check whether a visitor entered a particular swimming pool. It is checked by getting
    a random Boolean value. If `true` is received, an identifier is added to the proper
    set. The `false` value indicates that the user with the given number of wrist
    band (`i`) has not entered the current swimming pool.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你使用两个循环，即`for`和`foreach`。第一个循环100次，模拟100个手环。其中有一个`foreach`循环，遍历所有可用的游泳池类型。对于每一个，你随机检查访客是否进入了特定的游泳池。通过获取一个随机的布尔值来检查。如果收到`true`，则将标识符添加到适当的集合中。`false`值表示具有给定手环号（`i`）的用户没有进入当前游泳池。
- en: 'The remaining code is related to generating various statistics. First, let''s
    present the number of visitors by a pool type. Such a task is very easy, because
    you just need to iterate through the dictionary, as well as write the pool type
    and the number of elements in the set (using the `Count` property), as shown in
    the following part of the code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的代码与生成各种统计数据有关。首先，让我们按游泳池类型呈现访客人数。这样的任务非常简单，因为你只需要遍历字典，以及写入游泳池类型和集合中的元素数量（使用`Count`属性），如下面的代码部分所示：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next part finds the swimming pool with the maximum number of visitors.
    It is performed using LINQ and its methods, namely:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分找到了访客人数最多的游泳池。这是使用LINQ及其方法执行的，即：
- en: '`OrderByDescending` to order elements by the number of elements in the set,
    in descending order'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderByDescending`按集合中元素的数量降序排序元素'
- en: '`Select` to choose only a pool type'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select`来选择游泳池类型'
- en: '`FirstOrDefault` to take the first result'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstOrDefault`来获取第一个结果'
- en: 'Then, you just present the result. The code for doing this is shown here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你只需呈现结果。做这件事的代码如下所示：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, you need to get the number of people who have visited at least one pool.
    You can perform this task by creating the union of all the sets and getting the
    count of the final set. At the beginning, you create a new set and fill it with
    identifiers regarding the recreation swimming pool. In the following lines of
    code, you call the `UnionWith` method to create a union with the following three
    sets. This part of the code is shown here:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要获取至少访问了一个游泳池的人数。你可以通过创建所有集合的并集并获取最终集合的计数来执行此任务。首先，创建一个新的集合，并用有关休闲游泳池的标识符填充它。在代码的下面几行中，你调用`UnionWith`方法创建与以下三个集合的并集。代码的这部分如下所示：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The last statistic is the number of people who have visited all the pools during
    one visit in the SPA center. To perform such a calculation, you just need to create
    the intersection of all the sets and get the count of the final set. To do so,
    let''s create a new set and fill it with identifiers regarding the recreation
    swimming pool. Then, call the `IntersectWith` method to create an intersection
    with the following three sets. At the end, get the number of elements in the set
    using the `Count` property and present the results, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的统计数据是在SPA中心一次访问中访问了所有游泳池的人数。要执行这样的计算，你只需要创建所有集合的交集，并获取最终集合的计数。为此，让我们创建一个新的集合，并用有关休闲游泳池的标识符填充它。然后，调用`IntersectWith`方法创建与以下三个集合的交集。最后，使用`Count`属性获取集合中的元素数量，并呈现结果，如下所示：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And that''s all! When you run the application, you may receive a result similar
    to the following one:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！当你运行应用程序时，你可能会收到类似以下的结果：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You have just completed two examples regarding the hash sets. It is a good idea
    to try to modify the code and add new features to learn more about such a data
    structure. When you are ready to learn the next data structure, let's continue
    reading.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚完成了两个关于哈希集的例子。尝试修改代码并添加新功能是了解这种数据结构的更好方法。当你准备好学习下一个数据结构时，让我们继续阅读。
- en: '"Sorted" sets'
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “排序”集合
- en: The previously described class, `HashSet`, can be understood as a dictionary
    that stores only keys, without values. So, if there is the `SortedDictionary`
    class, maybe there is also the `SortedSet` class? Indeed, there is! However, can
    a set be "sorted"? Why is the "sorted" word written with quotation marks? The
    answer is simple—by definition, a set stores a collection of distinct objects
    without duplicated elements and without a particular order. If a set does not
    support order, how can it be "sorted"? For this reason, a "sorted" set can be
    understood as a combination of `HashSet` and `SortedList`, not a set itself.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前面描述的`HashSet`类可以被理解为一个只存储键而没有值的字典。所以，如果有`SortedDictionary`类，也许还有`SortedSet`类？确实有！但是，一个集合可以被“排序”吗？为什么“排序”一词用引号括起来？答案很简单——根据定义，一个集合存储一组不重复的对象，没有重复的元素，也没有特定的顺序。如果一个集合不支持顺序，它怎么能被“排序”呢？因此，“排序”集合可以被理解为`HashSet`和`SortedList`的组合，而不是一个集合本身。
- en: The "sorted" set can be used if you want to have a sorted collection of distinct
    objects without duplicated elements. The suitable class is named `SortedSet` and
    is available in the `System.Collections.Generic` namespace. It has a set of methods,
    similar to those already described in the case of the `HashSet` class, such as
    `UnionWith`, `IntersectWith`, `ExceptWith`, `SymmetricExceptWith`, `Overlaps`,
    `IsSubsetOf`, `IsSupersetOf`, `IsProperSubsetOf`, and `IsProperSupersetOf`. However,
    it contains additional properties for returning the minimum and maximum values
    (`Min` and `Max`, respectively). It is worth mentioning also the `GetViewBetween`
    method that returns a `SortedSet` instance with values from the given range.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要一个排序的不重复元素集合，可以使用“sorted”集合。适当的类名为`SortedSet`，并且位于`System.Collections.Generic`命名空间中。它具有一组方法，类似于已经描述的`HashSet`类的方法，例如`UnionWith`，`IntersectWith`，`ExceptWith`，`SymmetricExceptWith`，`Overlaps`，`IsSubsetOf`，`IsSupersetOf`，`IsProperSubsetOf`和`IsProperSupersetOf`。但是，它还包含用于返回最小值和最大值（分别为`Min`和`Max`）的附加属性。还值得一提的是`GetViewBetween`方法，它返回一个具有给定范围内的值的`SortedSet`实例。
- en: You can find more information about the `SortedSet` generic class at [https://msdn.microsoft.com/library/dd412070.aspx](https://msdn.microsoft.com/library/dd412070.aspx).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://msdn.microsoft.com/library/dd412070.aspx](https://msdn.microsoft.com/library/dd412070.aspx)找到有关`SortedSet`泛型类的更多信息。
- en: Let's proceed to a simple example to see how to use the "sorted" set in the
    code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行一个简单的示例，看看如何在代码中使用“sorted”集合。
- en: Example – removing duplicates
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 删除重复项
- en: As an example, you will create a simple application that removes duplicates
    from the list of names. Of course, the comparison of names should be case-insensitive,
    thus it is not allowed to have both `"Marcin"` and `"marcin"` in the same collection.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您将创建一个简单的应用程序，从名称列表中删除重复项。当然，名称的比较应该是不区分大小写的，因此不允许在同一集合中同时拥有`"Marcin"`和`"marcin"`。
- en: 'To see how to perform this goal, let''s add the following code as the body
    of the `Main` method in the `Program` class:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看如何实现此目标，让我们将以下代码添加为`Program`类中`Main`方法的主体：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At the beginning, a list of names is created and initialized with nine elements,
    including `"Marcin"` and `"marcin"`. Then, you create a new instance of the `SortedSet`
    class, passing two parameters, namely the list of names and the case-insensitive
    comparer. At the end, you just iterate through the collection to write names in
    the console.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个包含九个元素的名称列表，并初始化，包括`"Marcin"`和`"marcin"`。然后，创建`SortedSet`类的新实例，传递两个参数，即名称列表和不区分大小写的比较器。最后，只需遍历集合以在控制台中写入名称。
- en: 'When you run the application, you will see the following result:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序后，您将看到以下结果：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is the last example shown in this chapter. Thus, let's proceed to the summary.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章中展示的最后一个例子。因此，让我们继续进行总结。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This fourth chapter of the book focused on hash tables, dictionaries, and sets.
    All of these collections are interesting data structures that can be used in various
    scenarios. By presenting such collections with detailed descriptions and examples,
    you have seen that choosing a proper data structure is not a trivial task and
    requires analysis of performance-related topics, because some of them operate
    better in retrieving values and some promote the addition and removal of data.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第四章着重介绍了哈希表、字典和集合。所有这些集合都是有趣的数据结构，可以在各种场景中使用。通过详细描述和示例介绍这些集合，您已经看到选择适当的数据结构并不是一项微不足道的任务，需要分析与性能相关的主题，因为其中一些在检索值方面运行更好，而另一些则促进数据的添加和删除。
- en: At the beginning, you have learned how to use two variants of a hash table,
    namely non-generic (the `Hashtable` class) and generic (`Dictionary`). The huge
    advantage of these is the very fast lookup for a value based on the key, which
    is the close *O(1)* operation. To achieve this goal, the hash function is used.
    Moreover, the sorted dictionary has been introduced as an interesting solution
    to solve the problem of unsorted items in the collection and to keep keys sorted
    all the time.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您学习了如何使用哈希表的两个变体，即非泛型（`Hashtable`类）和泛型（`Dictionary`）。这些的巨大优势是基于键进行值查找的非常快速，接近*O(1)*的操作。为了实现这个目标，使用了哈希函数。此外，已经介绍了排序字典作为解决集合中无序项目问题并始终保持键排序的有趣解决方案。
- en: Afterwards, the high-performance solution to set operations was presented. It
    uses the `HashSet` class, which represents a collection of distinct objects without
    duplicated elements and without particular order. The class makes it possible
    to perform various operations on sets, such as union, intersection, subtraction,
    and symmetric difference. Then, the concept of the "sorted" set (the `SortedSet`
    class), has been introduced as a sorted collection of distinct objects without
    duplicated elements.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，介绍了高性能解决方案的集合操作。它使用`HashSet`类，表示一个没有重复元素和特定顺序的对象集合。该类使得可以对集合执行各种操作，如并集、交集、差集和对称差。然后，介绍了“sorted”集合（`SortedSet`类）的概念，作为一个排序的不重复元素集合。
- en: Do you want to dive deeper into the topic of data structures and algorithms,
    while developing applications in the C# language? If so, let's proceed to the
    next chapter where trees are presented.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否想深入了解数据结构和算法，同时在C#语言中开发应用程序？如果是这样，让我们继续进行下一章，介绍树。
