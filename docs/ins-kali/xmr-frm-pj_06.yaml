- en: Setting up a Backend for a Chat App Using Azure Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Azure服务为聊天应用程序设置后端
- en: In this chapter, we will build a chat app with real-time communication. To do
    this, we need a backend. We will create a backend that can scale up to handle
    a large number of users but also scale down when the number of users is reduced.
    To build that backend, we will use a serverless architecture based on services
    in Microsoft Azure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个具有实时通信的聊天应用程序。为此，我们需要一个后端。我们将创建一个后端，可以扩展以处理大量用户，但当用户数量减少时也可以缩小。为了构建该后端，我们将使用基于Microsoft
    Azure服务的无服务器架构。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating a SignalR service in Microsoft Azure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Microsoft Azure中创建SignalR服务
- en: Using Azure functions as an API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Azure函数作为API
- en: Scheduling jobs with Azure functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Azure函数调度作业
- en: Using blob storage to store photos
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用blob存储来存储照片
- en: Using Azure Cognitive Services to scan photos for adult content
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Azure认知服务扫描照片以查找成人内容
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To be able to complete this project, you need to have Visual Studio for Mac
    or PC installed. See [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml),
    *Introduction to Xamarin*, for more details on how to set up your environment. You
    also need an Azure account. If you have a Visual Studio subscription, there is
    a specific amount of Azure credits included each month. To activate your Azure
    benefits, go to the following link: [https://my.visualstudio.com](https://my.visualstudio.com).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够完成这个项目，您需要安装Mac或PC上的Visual Studio。有关如何设置您的环境的更多详细信息，请参阅[第1章](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml)，*Xamarin简介*。您还需要一个Azure帐户。如果您有Visual
    Studio订阅，每个月都包含特定数量的Azure积分。要激活您的Azure福利，请转到以下链接：[https://my.visualstudio.com](https://my.visualstudio.com)。
- en: You can also create a free account, where you can use selected services for
    free over 12 months. You will get $200 worth of credit to explore any Azure service
    for 30 days and you can also use the free services at any time. Read more at the
    following link: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一个免费帐户，在12个月内免费使用选定的服务。您将获得价值200美元的信用额度，以在30天内探索任何Azure服务，并且您还可以随时使用免费服务。在以下链接阅读更多信息：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。
- en: Azure serverless services
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure无服务器服务
- en: Before we start to build a backend with a serverless architecture, we need to
    define what serverless actually means. In a serverless architecture, of course
    the code will run on a server, but we don't need to worry about that; the only
    thing we need to focus on is building our software. We let someone else handle
    everything to do with servers. We don't need to think about how much memory or
    CPU the server needs, or even how many servers we need. When we use services in
    Azure, Microsoft takes care of this for us.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建具有无服务器架构的后端之前，我们需要定义无服务器实际意味着什么。在无服务器架构中，当然代码将在服务器上运行，但我们不需要担心这一点；我们唯一需要关注的是构建我们的软件。我们让其他人处理与服务器有关的一切。我们不需要考虑服务器需要多少内存或CPU，甚至我们需要多少服务器。当我们在Azure中使用服务时，微软会为我们处理这一切。
- en: Azure SignalR Service
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure SignalR服务
- en: The **Azure SignalR Service** is a service in **Microsoft Azure** for real-time
    communication between a server and clients. The service will push content to the
    clients without them having to poll the server to get content updates. SignalR
    can be used for multiple types of applications, including mobile applications,
    web applications, and desktop applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure SignalR服务**是**Microsoft Azure**中用于服务器和客户端之间的实时通信的服务。该服务将向客户端推送内容，而无需他们轮询服务器以获取内容更新。SignalR可用于多种类型的应用程序，包括移动应用程序、Web应用程序和桌面应用程序。'
- en: SignalR will use WebSockets if that option is available. If it is not, SignalR
    will use other techniques for communication, such as **Server-Sent Events** (**SSE**)
    or **long polling**. SignalR will detect which transport technology is available
    and use it without the developer having to think about it at all.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可用，SignalR将使用WebSockets。如果不可用，SignalR将使用其他通信技术，如**服务器发送事件**（**SSE**）或**长轮询**。SignalR将检测可用的传输技术并使用它，而开发人员根本不需要考虑这一点。
- en: 'SignalR can be used in the following examples:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SignalR可以在以下示例中使用：
- en: '**Chat applications**: Where the application needs updates from the server
    immediately when new messages are available'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聊天应用程序**：当新消息可用时，应用程序需要立即从服务器获取更新'
- en: '**Collaborative applications**: For example, meeting applications or when users
    on multiple devices are working with the same document'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作应用程序**：例如，会议应用程序或多个设备上的用户正在使用相同文档时'
- en: '**Multiplayer games**: Where all users need live updates about other users'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多人游戏**：所有用户都需要实时更新其他用户的地方'
- en: '**Dashboard applications**: Where users need live updates'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表板应用程序**：用户需要实时更新的地方'
- en: Azure functions
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure函数
- en: Azure functions is a Microsoft Azure service that allows us to run code in a
    serverless way. We will deploy small pieces of code called **Functions**.Functions
    are deployed in groups, called **Function Apps**. When we are creating a Function
    App, we need to select whether we want it to run on a consumption plan or on an
    app service plan. We select a consumption plan if we want the application to be
    completely serverless, while with an app service plan, we have to specify the
    requirements of the server. With a consumption plan, we pay for the execution
    time and for how much memory the function uses. One benefit of the app service
    plan is that you can configure it to be Always On and you won't have any cold
    starts as long as you don't have to scale up to more instances. The big benefit
    of a consumption plan is that it will always scale according to which resources
    are needed at that time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Azure函数是微软Azure的一项服务，允许我们以无服务器的方式运行代码。我们将部署称为**函数**的小代码片段。函数部署在称为**函数应用**的组中。创建函数应用时，我们需要选择是否要在消耗计划或应用服务计划上运行。如果我们希望应用程序完全无服务器化，我们选择消耗计划，而对于应用服务计划，我们必须指定服务器的要求。使用消耗计划，我们支付执行时间和函数使用的内存量。应用服务计划的一个好处是可以配置为始终运行，并且只要不需要扩展到更多实例，就不会有任何冷启动。消耗计划的一个重要好处是它将根据需要的资源进行自动扩展。
- en: There are several ways in which a function can be triggered to run. Two examples
    are `HttpTrigger` and `TimeTrigger`. `HttpTrigger` will trigger the function to
    run when an HTTP request is calling the function. With `TimeTrigger`, functions
    will run at an interval that we can specify. There are also triggers for other
    Azure services. For example, we can configure a function to run when a file is
    uploaded to blob storage, when a new message is posted to an event hub or service
    bus, or when data is changed in an Azure CosmosDB.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过多种方式触发运行。两个例子是`HttpTrigger`和`TimeTrigger`。`HttpTrigger`将在调用函数的HTTP请求时触发函数运行。使用`TimeTrigger`，函数将按照我们指定的间隔运行。还有其他Azure服务的触发器。例如，我们可以配置函数在文件上传到blob存储时运行，当新消息发布到事件中心或服务总线时运行，或者在Azure
    CosmosDB中的数据发生变化时运行。
- en: Azure blob storage
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure blob存储
- en: Azure blob storage is used for storing unstructured data objects, such as images,
    videos, audio, and documents. Objects or blobs can be organized into containers. Blob
    storage can be redundant over multiple data centers in Azure. This to protect
    the data from unplanned events ranging from transient hardware failures to network
    or power outages, or even massive natural disasters. Blob storage in Azure can
    have different tiers, depending on how often we want to use the objects that we
    are storing. These include archive and cold tiers, and hot and premium tiers,
    which are used for applications in which we need to access data more often. As
    well as blob storage, we can add a **Content Delivery Network** (**CDN**) to make
    the content in our storage closer to our users. This is important if we have users
    around the globe. If we can deliver our content from a place that is closer to
    the user, we can reduce the loading time of content and we can give the users
    a better experience.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Azure blob存储用于存储非结构化数据对象，如图像、视频、音频和文档。对象或blob可以组织成容器。Azure的Blob存储可以在多个数据中心进行冗余。这是为了保护数据免受从瞬时硬件故障到网络或电源中断，甚至大规模自然灾害的不可预测事件的影响。Azure的Blob存储可以有不同的层级，取决于我们希望使用存储的对象的频率。这包括存档和冷层，以及热层和高级层，用于需要更频繁访问数据的应用程序。除了Blob存储，我们还可以添加**内容交付网络**（**CDN**）以使我们存储的内容更接近我们的用户。如果我们的用户遍布全球，这一点很重要。如果我们可以从更接近用户的地方提供我们的内容，我们可以减少内容的加载时间，并为用户提供更好的体验。
- en: Azure Cognitive Services
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure认知服务
- en: The easiest way to describe **Azure Cognitive Services** is that it is **Machine
    Learning** as a service. With just a simple API call, we can use machine learning
    in our applications, without which we have to use complex data science techniques.
    When we use APIs, we are making predictions against the models that Microsoft
    has trained for us.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 描述**Azure认知服务**最简单的方法是它是**机器学习**作为一项服务。只需简单的API调用，我们就可以在我们的应用程序中使用机器学习，而无需使用复杂的数据科学技术。当我们使用API时，我们正在针对Microsoft为我们训练的模型进行预测。
- en: 'The services in Azure Cognitive Services have been organized into five categories:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Azure认知服务的服务已经组织成五个类别：
- en: '**Vision**: The vision services are about image processing. These include APIs
    for face recognition, detection of adult content, image classification, and **Optical
    Character Recognition** (**OCR**).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视觉**：视觉服务涉及图像处理。这包括面部识别、成人内容检测、图像分类和**光学字符识别**（**OCR**）的API。'
- en: '**Knowledge**: An example of a knowledge service is the **Question and Answer**
    (**QnA**) makers that allow us to train a model with a knowledge base. When we
    have trained the model, we can use it for getting answers when we are asking questions.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**知识**：知识服务的一个示例是**问答**（**QnA**）制作者，它允许我们用知识库训练模型。当我们训练了模型，我们可以用它来获取问题的答案。'
- en: '**Language**: The language services are about understanding text, such as text
    analytics, language understanding, and translations.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言**：语言服务涉及文本理解，如文本分析、语言理解和翻译。'
- en: '**Speech**: Examples of speech APIs include speaker recognition, speech-to-text
    functionality, and speech translation.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语音**：语音API的示例包括说话者识别、语音转文本功能和语音翻译。'
- en: '**Search**: The search services are about using the power of a web search engine
    to find an answer to your problems. These include knowledge acquisition from images,
    the auto-completion of search queries, and the identification of similar people.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：搜索服务是利用网络搜索引擎的力量来找到问题的答案。这包括从图像中获取知识、搜索查询的自动完成以及相似人员的识别。'
- en: Project overview
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: This project will be to set up the backend for a chat application. The biggest
    part of the project will be the configuration that we will carry out in the Azure
    portal. We will also write some code for the Azure Functions that will handle
    the SignalR connections. There will be one function to return information about
    the SignalR connection and one that posts messages to the SignalR service. The
    function that we will post messages to will also determine whether the message
    contains an image. If it does, it will be sent to the Vision API in Azure Cognitive
    Services to analyze whether it contains adult content. If it does, it won't be
    posted to the SignalR service and the other users will not get it. Because the
    SignalR service has a limitation about how big messages can be, we need to store
    images in blob storage and just post the URL of the image to the users. Because
    we don't save any chat history in this app, we also want to clear the blob storage
    at specific intervals. To do this, we will create a function that uses `TimeTrigger`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将是为聊天应用程序设置后端。项目的最大部分将是我们将在Azure门户中进行的配置。我们还将为处理SignalR连接的Azure Functions编写一些代码。将有一个函数返回有关SignalR连接的信息，还有一个函数将消息发布到SignalR服务。发布消息的函数还将确定消息是否包含图像。如果包含图像，它将被发送到Azure认知服务中的Vision
    API，以分析是否包含成人内容。如果包含成人内容，它将不会发布到SignalR服务，其他用户也不会收到。由于SignalR服务有关于消息大小的限制，我们需要将图像存储在blob存储中，只需将图像的URL发布给用户。因为我们在这个应用程序中不保存任何聊天记录，我们还希望在特定间隔清除blob存储。为此，我们将创建一个使用`TimeTrigger`的函数。
- en: 'The following diagram shows an overview of the architecture of this application:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了此应用程序架构的概述：
- en: '![](img/2d439ffb-2128-471c-95c7-422d7b1cda07.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d439ffb-2128-471c-95c7-422d7b1cda07.png)'
- en: The estimated time to complete this project is about two hours.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此项目的估计时间约为两个小时。
- en: Building the serverless backend
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建无服务器后端
- en: Let's start setting up the backend based on the services described in the preceding
    section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始根据前面部分描述的服务来设置后端。
- en: Creating a SignalR service
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建SignalR服务
- en: 'The first service that we will set up is the one for SignalR:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置的第一个服务是SignalR：
- en: Go to the Azure portal: [https://portal.azure.com](https://portal.azure.com).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Azure门户：[https://portal.azure.com](https://portal.azure.com)。
- en: Create a new resource. The **SignalR Service** is in the web category.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新资源。**SignalR服务**位于Web类别中。
- en: Fill in a name for the resource in the form.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写表单中的资源名称。
- en: Select the subscription you want to use for this project.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要用于此项目的订阅。
- en: We recommend that you create a new Resource Group and use it for all resources
    that we will create for this project. The reason that we want one resource group
    is that it is easier to track what resources are related to this project, and
    it is also easier to delete all the resources together.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们建议您创建一个新的资源组，并将其用于为此项目创建的所有资源。我们希望使用一个资源组的原因是更容易跟踪与此项目相关的资源，并且更容易一起删除所有资源。
- en: Select a location that is close to your users.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个靠近您的用户的位置。
- en: 'Select a pricing tier. For this project, we can use the free tier. We can always
    use the free tier for development and later scale up to a tier that can handle
    more connections. Refer to the following screenshot:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个定价层。对于这个项目，我们可以使用免费层。我们可以始终在开发中使用免费层，然后扩展到可以处理更多连接的层。参考以下截图：
- en: '![](img/62b6c152-5606-4f37-962b-4a128ffefab8.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62b6c152-5606-4f37-962b-4a128ffefab8.png)'
- en: This is all we need to do to set up a SignalR Service. We will return to it
    in the Azure portal later to grab a connection string to it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们设置SignalR服务所需做的一切。我们将在Azure门户中返回以获取连接字符串。
- en: Creating a storage account
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建存储帐户
- en: 'The next step is to set up a storage account in which we can store the images
    that are uploaded by the users:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置一个存储帐户，我们可以在其中存储用户上传的图像：
- en: Create a new Storage Account resource. Storage Account is found under the Storage
    category.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的存储帐户资源。存储帐户位于存储类别下。
- en: Select a subscription and a resource group. We recommend that you use the same
    as you did for the SignalR Service.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择订阅和资源组。我们建议您使用与SignalR服务相同的订阅和资源组。
- en: Give the storage account a name.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给存储帐户命名。
- en: Select a location that is close to your users.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个靠近您的用户的位置。
- en: Select a performance option. If we use Premium storage, the data will be stored
    on SSD disks. Select Standard storage for this project.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择性能选项。如果我们使用高级存储，数据将存储在SSD磁盘上。为此项目选择标准存储。
- en: Use StorageV2 for the Account kind.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用StorageV2作为帐户类型。
- en: In replication, we can select how we want our data to be replicated across the
    data centers.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在复制中，我们可以选择我们希望数据在数据中心之间如何复制。
- en: For the access tier, we will use Hot, because we will need to access the data
    frequently in this app.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于访问层，我们将使用热层，因为在这个应用程序中我们需要频繁访问数据。
- en: Click Create + review to review the settings before creating the storage account.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击创建+审阅以在创建存储帐户之前审查设置。
- en: 'Click Create to create the storage account:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击创建以创建存储帐户：
- en: '![](img/f385b548-0a0f-4097-9513-c284754453b3.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f385b548-0a0f-4097-9513-c284754453b3.png)'
- en: 'The last step of the configuration of the blob storage is to go to the resource
    and create a container for the chat images:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: blob存储配置的最后一步是转到资源并为聊天图像创建一个容器：
- en: Go to the resource and select Blobs.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到资源并选择Blobs。
- en: Create a New container with the name `chatimages`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`chatimages`的新容器。
- en: 'Set the Public access level to Blob (anonymous read access for blobs only).
    This means that it will have public read access, but that you have to be authorized
    to upload content. Refer to the following screenshot:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将公共访问级别设置为Blob（仅对Blob的匿名读取访问）。这意味着它将具有公共读取访问权限，但您必须获得授权才能上传内容。参考以下截图：
- en: '![](img/f71fdee8-2685-4e61-8b4a-4563de5ea35b.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f71fdee8-2685-4e61-8b4a-4563de5ea35b.png)'
- en: Creating a Cognitive Service
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建认知服务
- en: 'To be able to use **Cognitive Services** to scan images for adult content,
    we need to create a resource in the Azure portal. This will give us a key that
    we can use when making calls to the API:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用**认知服务**来扫描成人内容的图像，我们需要在Azure门户中创建一个资源。这将为我们提供一个在调用API时可以使用的密钥：
- en: Create a new Custom Vision resource.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的自定义视觉资源。
- en: Give the resource a name and select a subscription.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给资源命名并选择订阅。
- en: Select a location that is close to your users.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个靠近用户的位置。
- en: Select a pricing tier for prediction and training. This app will only use predictions
    because we will use a model that is already trained.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为预测和训练选择一个定价层。此应用程序将仅使用预测，因为我们将使用已经训练好的模型。
- en: Select the same resource groups as you selected for the other resources.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择与您为其他资源选择的相同的资源组。
- en: 'Click OK to create the new resource. Refer to the following screenshot:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”创建新资源。参考以下截图：
- en: '![](img/35760e18-4d2d-4569-93ed-64609451c594.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35760e18-4d2d-4569-93ed-64609451c594.png)'
- en: We have now finished creating the Cognitive Service. We will come back later
    to grab a key that we will use for the calls we will make against the API.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了创建认知服务。稍后我们将回来获取一个密钥，我们将用它来调用API。
- en: Creating functions
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建函数
- en: All the code we will write in the backend will be functions. We will use version
    2 of Azure Functions, which will run on top of .NET Core. Version 1 ran on top
    of the full .NET framework.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后端编写的所有代码都将是函数。我们将使用Azure Functions的第2版，它将在.NET Core之上运行。第1版是在完整的.NET框架之上运行的。
- en: Creating the Azure service for functions
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于函数的Azure服务
- en: 'Before we start to write any code, we will create the Function App. This will
    contain the functions in the Azure portal:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写任何代码之前，我们将创建Function App。这将在Azure门户中包含函数：
- en: Create a new Function App resource. Function App is found under the Compute
    category.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Function App资源。Function App在计算类别下找到。
- en: Give the Function App a name. The name will also be the start of the URL of
    the function.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给Function App命名。该名称也将成为函数URL的起始部分。
- en: Select a subscription for the Function App.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Function App选择一个订阅。
- en: Select a resource group for the Function App, which should be the same as the
    other resources we have created in this chapter.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Function App选择一个资源组，应该与本章中创建的其他资源相同。
- en: Because we will use .NET Core as the runtime for the functions, we can run them
    in both Windows and Linux. In this case, however, we will run them in Windows.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们将使用.NET Core作为函数的运行时，所以可以在Windows和Linux上运行它们。但在这种情况下，我们将在Windows上运行它们。
- en: We will use the Consumption Plan as our Hosting Plan, so we only pay for what
    we use. The Function App will scale both up and down according to our requirements,
    without us having to think about it at all, if we select a Consumption Plan.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用**消耗计划**作为我们的托管计划，因此我们只支付我们使用的费用。Function App将根据我们的要求进行上下缩放，而无需我们考虑任何事情，如果我们选择消耗计划。
- en: Select a location that is close to your users.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个靠近用户的位置。
- en: Select .NET as the Runtime stack.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择.NET作为运行时堆栈。
- en: For storage, we can either create a new storage account or use the one we created
    earlier in this project.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于存储，我们可以创建一个新的存储帐户，或者使用我们在此项目中早期创建的存储帐户。
- en: Set Application Insights to be On so that we can monitor our functions.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序洞察设置为打开，以便我们可以监视我们的函数。
- en: 'Click Create to create the new resource:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“创建”以创建新资源：
- en: '![](img/6c829370-40e8-4cef-b9a3-b4a11a9afec7.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c829370-40e8-4cef-b9a3-b4a11a9afec7.png)'
- en: Creating a function to return the connection information for the SignalR service
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个函数来返回SignalR服务的连接信息
- en: 'If you want, you can create functions in the Azure portal. I prefer to use
    Visual Studio, however, because the code editing experience is much better and
    you can use version tracking for the source code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果愿意，可以在Azure门户中创建函数。但我更喜欢使用Visual Studio，因为代码编辑体验更好，而且可以对源代码进行版本跟踪：
- en: Create a new project in Visual Studio of the Azure Functionstype. This can be
    found under the Cloud tabof the new project dialog box.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中创建一个Azure Functions类型的新项目。这可以在新项目对话框的云选项卡下找到。
- en: Name the project `Chat.Functions`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`Chat.Functions`。
- en: 'Click OK to continue:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”继续：
- en: '![](img/164daf00-aeb7-4a95-af57-836603c096eb.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/164daf00-aeb7-4a95-af57-836603c096eb.png)'
- en: 'The next step is to create our first function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建我们的第一个函数：
- en: Select Azure Functions v2 (.NET Core) at the top of the dialog box.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框顶部选择Azure Functions v2 (.NET Core)。
- en: Select Http trigger as the trigger for our first function.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Http触发器作为我们第一个函数的触发器。
- en: Change the **Access rights** from Admin to Anonymous.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**访问权限**从管理员更改为匿名。
- en: 'Click OK to continue and our functions project will be created:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”继续，我们的函数项目将被创建：
- en: '![](img/eb5a4909-85eb-49dd-9769-cf701904b327.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb5a4909-85eb-49dd-9769-cf701904b327.png)'
- en: 'Our first function will return the connection information for the SignalR service.
    To do that, we need to connect the function by adding a connection string to the
    SignalR service:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个函数将返回SignalR服务的连接信息。为此，我们需要通过向SignalR服务添加连接字符串来连接函数：
- en: Go to the SignalR Service resource in the Azure Portal.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Azure门户中的SignalR服务资源。
- en: Go to the Keys tab and copy the connection string.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Keys选项卡并复制连接字符串。
- en: Go to the Function App resource and add the connection string under Application
    Settings. Use `AzureSignalRConnectionString` as the name for the setting.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Function App资源并在应用程序设置下添加连接字符串。使用`AzureSignalRConnectionString`作为设置的名称。
- en: 'Add the connection string to the `Values` array in the `local.settings.json`
    file in the Visual Studio project to be able to run the function locally on the
    development machine:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将连接字符串添加到Visual Studio项目中的`local.settings.json`文件的`Values`数组中，以便能够在开发机器上本地运行函数：
- en: '[PRE0]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we can write the code for the function that will return the connection
    information. Go to Visual Studio and follow these instructions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写将返回连接信息的函数的代码。转到Visual Studio并按照以下说明操作：
- en: Install the `Microsoft.Azure.WebJobs.Extensions.SignalRService` NuGet package
    in the functions project. The package contains the classes we need to communicate
    with the SignalR service. It is a prerelease package so we have to check the Include
    prerelease checkbox. If an error occurs during this and you are not able to install
    the package, make sure that you have the latest version of all other packages
    in the project and try again.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数项目中安装`Microsoft.Azure.WebJobs.Extensions.SignalRService` NuGet包。该包包含了我们与SignalR服务通信所需的类。这是一个预发布包，因此我们必须勾选包含预发布复选框。如果在此过程中出现错误，无法安装该包，请确保您的项目中所有其他包的版本都是最新的，然后重试。
- en: Rename the function that was created when we created the functions project as `GetSignalRInfo`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在创建函数项目时创建的函数重命名为`GetSignalRInfo`。
- en: Also, rename the class as `GetSignalRInfo`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要将类重命名为`GetSignalRInfo`。
- en: To implement the binding to the SignalR service, we will add a parameter of
    the `SignalRConnectionInfo` type to the method of the function. The parameter
    will also have the `SignalRConnectionInfo` attribute, which specifies `HubName`,
    as in the following code.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现与SignalR服务的绑定，我们将在函数的方法中添加一个`SignalRConnectionInfo`类型的参数。该参数还将具有`SignalRConnectionInfo`属性，指定`HubName`，如下代码所示。
- en: 'Return the connection info parameter:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回连接信息参数：
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating a message library
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个消息库
- en: We will now define a couple of message classes that we will use to send the
    chat messages. We will create a base message class that will contain information
    that is shared between all types of messages. We will also create a separate project
    for the messages, which will be a .NET Standard library. The reason that we will
    create it as a separate .NET Standard library is that we then can reuse it in
    the app we will build in the next chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将定义一些消息类，我们将用它们来发送聊天消息。我们将创建一个基本消息类，其中包含所有类型消息共享的信息。我们还将创建一个消息的独立项目，它将是一个.NET标准库。我们之所以将它创建为一个独立的.NET标准库，是因为我们可以在下一章中构建的应用程序中重用它。
- en: Create a new .NET Standard 2.0 project and name it `Chat.Messages`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的.NET标准2.0项目，命名为`Chat.Messages`。
- en: Add a reference to `Chat.Messages` in the `Chat.Functions` project.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat.Functions`项目中添加对`Chat.Messages`的引用。
- en: Create a new class and name it `Message` in the `Chat.Messages` project.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat.Messages`项目中创建一个新类，命名为`Message`。
- en: Add a `TypeInfo` property to the `Message` class. We need this property later
    in [Chapter 7](569915b8-d374-4dce-9c18-589fdadd5459.xhtml), *Building a Real-Time
    Chat Application*, when we will carry out serialization of the messages.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Message`类添加一个`TypeInfo`属性。我们在[第7章](569915b8-d374-4dce-9c18-589fdadd5459.xhtml)中需要这个属性，*构建实时聊天应用程序*，当我们进行消息序列化时。
- en: Add a property for the `Id` of the `string`type.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Id`的字符串类型的属性。
- en: Add a property for the `Timestamp` of the `DateTime`type.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`DateTime`类型的`Timestamp`属性。
- en: Add a property for the `Username` of the `string`type.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`string`类型的`Username`属性。
- en: Add an empty constructor.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个空的构造函数。
- en: Add a constructor that takes a username as a parameter.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个以用户名为参数的构造函数。
- en: 'Set the values of all properties as in the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有属性的值设置如下代码所示：
- en: '[PRE2]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When a new client is connecting, a message will be sent to other users to indicate
    that they have connected:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当新客户端连接时，将向其他用户发送一条消息，指示他们已连接：
- en: Create a new class called `UserConnectedMessage`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UserConnectedMessage`的新类。
- en: Set `Message` as the base class.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Message`作为基类。
- en: Add an empty constructor.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个空的构造函数。
- en: 'Add a constructor that takes the username as a parameter and sends it to the
    constructor of the base class, as shown in the following code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个以用户名为参数的构造函数，并将其发送到基类的构造函数，如下代码所示：
- en: '[PRE3]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When a client is sending a message with text, it will send a `SimpleTextMessage`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端发送带有文本的消息时，它将发送一个`SimpleTextMessage`：
- en: Create a new class called `SimpleTextMessage`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SimpleTextMessage`的新类。
- en: Add `Message` as the base class.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Message`作为基类。
- en: Add an empty constructor.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个空的构造函数。
- en: Add a constructor that takes the username as a parameter and sends it to the
    constructor of the base class.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个以用户名为参数的构造函数，并将其发送到基类的构造函数。
- en: 'Add a string property called `Text`. Refer to the following code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Text`的字符串属性。参考以下代码：
- en: '[PRE4]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If a user uploads an image, it will be sent to the functions as a `base64`
    string:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户上传了一张图片，它将作为`base64`字符串发送到函数：
- en: Create a new class called `PhotoMessage`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PhotoMessage`的新类。
- en: Add `Message` as the base class.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Message`作为基类。
- en: Add an empty constructor.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个空的构造函数。
- en: Add a constructor that takes the username as a parameter and sends it to the
    constructor of the base class.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个以用户名为参数的构造函数，并将其发送到基类的构造函数。
- en: Add a string property called `Base64Photo`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Base64Photo`的字符串属性。
- en: 'Add a string property called `FileEnding` as shown in the following code snippet:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`FileEnding`的字符串属性，如下代码片段所示：
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last message we will create is used to send information about a photo to
    the user:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的最后一个消息用于向用户发送有关照片的信息：
- en: Create a new class called `PhotoUrlMessage`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PhotoUrlMessage`的新类。
- en: Add `Message` as the base class.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Message`作为基类。
- en: Add an empty constructor.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个空的构造函数。
- en: Add a constructor that takes the username as a parameter and sends it to the
    constructor of the base class.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个以用户名为参数的构造函数，并将其发送到基类的构造函数。
- en: 'Add a string property called `Url`. Refer to the following code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Url`的字符串属性。参考以下代码：
- en: '[PRE6]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Creating a storage helper
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建存储助手
- en: 'We will create a helper to share some of the code that we will write for Azure
    Blob Storage between the send message function and the clear photos function that
    we will create. When we are creating the Function App in the Azure Portal, a setting
    for the connection string is created so we just have to add this to the `local.settings.json`
    file in order to be able to run it locally. The name for the connection string
    will be `StorageConnection`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个辅助程序，以便在我们将为Azure Blob Storage编写的一些代码之间共享发送消息函数和我们将创建的清除照片函数。在Azure门户中创建Function
    App时，会创建一个用于连接字符串的设置，因此我们只需将其添加到`local.settings.json`文件中，以便能够在本地运行它。连接字符串的名称将是`StorageConnection`：
- en: '[PRE7]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the helper, we will create a new static class, as given in the following
    steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于辅助程序，我们将创建一个新的静态类，如下所示：
- en: Install the `WindowsAzure.Storage NuGet` package in the `Chat.Functions` project.
    This is to get the classes we need to work with storage.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat.Functions`项目中安装`WindowsAzure.Storage NuGet`包。这是为了获得我们需要与存储一起使用的类。
- en: Create a new class called `StorageHelper` in the `Chat.Functions` project.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat.Functions`项目中创建一个名为`StorageHelper`的新类。
- en: Make the class `static`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类`static`。
- en: Create a new static method called `GetContainer`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`GetContainer`的新静态方法。
- en: Use the static `GetEnviromentVariable` method on the `Environment` class to
    read the connection string for storage.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Environment`类上的静态`GetEnviromentVariable`方法读取存储的连接字符串。
- en: Create a `CloudStorageAccount` object of it using the static `Parse` method
    on `CloudStorageAccount`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用静态`Parse`方法在`CloudStorageAccount`上创建一个`CloudStorageAccount`对象。
- en: Create a new `CloudBlobClient` using the `CreateCloudBlobClient` method on the
    `CloudStorageAccount` class.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CloudStorageAccount`类上的`CreateCloudBlobClient`方法创建一个新的`CloudBlobClient`。
- en: 'Get the container reference using the `GetContainerReference` method on the
    `CloudBlobClient` class and pass the name of the container we created earlier
    in the chapter as an argument:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CloudBlobClient`类上的`GetContainerReference`方法获取容器引用，并将我们在本章中早期创建的容器的名称作为参数传递：
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To upload files to the blob storage, we will create a method that has the bytes
    of the photo and what type of photo it is as parameters. The photo type will be
    defined by its file ending:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将文件上传到blob存储，我们将创建一个具有照片的字节和照片类型的方法。照片类型将由其文件结束定义：
- en: Create a new `async static` method that returns `Task<string>`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`async static`方法，返回`Task<string>`。
- en: Add a `byte[]` and a `string` parameter to the method. Name the parameters `bytes`
    and `fileEnding`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向方法添加一个`byte[]`和一个`string`参数。将参数命名为`bytes`和`fileEnding`。
- en: Call the `GetContainer` method to get a reference to the container.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`GetContainer`方法获取对容器的引用。
- en: Define a filename for the new blob and use it as an argument to `GetBlockBlobReference`
    in the `CloudBlobContainer` class. Use `GUID` as the filename to make sure that
    it is unique.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新的blob定义一个文件名，并将其作为参数传递给`CloudBlobContainer`类中的`GetBlockBlobReference`。使用`GUID`作为文件名，以确保其唯一性。
- en: Create a `MemoryStream` of the bytes.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用字节创建一个`MemoryStream`。
- en: Use the `UploadFromStreamAsync` method on the `BlockBlobReference` class to
    upload the photo to the cloud.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`BlockBlobReference`类上的`UploadFromStreamAsync`方法将照片上传到云端。
- en: 'Return the `AbsoluteUri` of the blob:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回blob的`AbsoluteUri`：
- en: '[PRE9]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The second public method that we will add to the helper is a method to delete
    all photos that are older than an hour:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加到辅助程序的第二个公共方法是一个方法，用于删除所有早于一小时的照片：
- en: Create a new `async static` method called `Clear` that returns `Task`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Clear`的新的`async static`方法，返回`Task`。
- en: Use the `GetContainer` method to get a reference to the container.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GetContainer`方法获取对容器的引用。
- en: Get all blobs in the container by calling the `ListBlobsSegmentedAsync` method
    with the arguments shown in the following code.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`ListBlobsSegmentedAsync`方法并使用以下代码中显示的参数获取容器中的所有blob。
- en: Loop through all blobs that are of the `CloudBlob` type.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历所有`CloudBlob`类型的blob。
- en: 'Add an `if` statement to check whether the photos were created more than an
    hour ago. If so, the blob should be deleted:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`if`语句来检查照片是否是一个小时前创建的。如果是，则应删除blob：
- en: '[PRE10]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating a function for sending messages
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个发送消息的函数
- en: 'To handle messages that are sent by the user, we will create a new function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理用户发送的消息，我们将创建一个新函数：
- en: Create a function with an `HttpTrigger` and with anonymous access rights.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`HttpTrigger`和匿名访问权限的函数。
- en: Name the function `Messages`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数命名为`Messages`。
- en: Add a collection of `SignalRMessage` as in the following code.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`SignalRMessage`集合，如下所示。
- en: 'Use the `SignalR` attribute to specify the hub name:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SignalR`属性指定hub名称：
- en: '[PRE11]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The message parameter will be the message that the user sent. It will be of
    the `JObject` type (from `Newtonsoft.Json`). We need to convert it to the `Message`
    type that we created earlier. To do that, we need to add a reference to the `Chat.Messages`
    project. However, because the parameter is of an object type, we first need to
    cast it to `JObject`. Once we have done this, we can use the `ToObject` method
    to get a `Message`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 消息参数将是用户发送的消息。它将是`JObject`类型（来自`Newtonsoft.Json`）。我们需要将其转换为我们之前创建的`Message`类型。为此，我们需要添加对`Chat.Messages`项目的引用。但是，因为参数是对象类型，我们首先需要将其转换为`JObject`。一旦我们做到这一点，我们就可以使用`ToObject`方法获得`Message`：
- en: '[PRE12]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the message is a `PhotoMessage`, we will upload the photo to blob storage.
    All other messages will be sent directly to the SignalR service using the `AddAsync`
    method on the `signalRmessages` parameter:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息是`PhotoMessage`，我们将把照片上传到blob存储。所有其他消息将直接使用`signalRmessages`参数上的`AddAsync`方法发送到SignalR服务：
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before we upload the photo to blob storage with the helper we created, we need
    to convert the `base64` string to a `byte[]`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用我们创建的辅助程序将照片上传到blob存储之前，我们需要将`base64`字符串转换为`byte[]`：
- en: Use the static `FromBase64String` method on the `Converter` class to convert
    the `base64` string to a `byte[]`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Converter`类上的静态`FromBase64String`方法将`base64`字符串转换为`byte[]`。
- en: Upload the photo to blob storage with the static `Upload` method on `StorageHelper`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`StorageHelper`上的静态`Upload`方法将照片上传到blob存储。
- en: Create a new `PhotoUrlMessage`, pass the username to the constructor, and set
    it as the value for the `msg` variable.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`PhotoUrlMessage`，将用户名传递给构造函数，并将其设置为`msg`变量的值。
- en: Set the `Timestamp` property to the value of the original message, because we
    are interested in when the message was created by the user.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Timestamp`属性设置为原始消息的值，因为我们对用户创建消息的时间感兴趣。
- en: Set the `Id` property to the value of the original message so that it will be
    handled as the same message on the client.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Id`属性设置为原始消息的值，以便在客户端上将其处理为相同的消息。
- en: Set the `Url` property to the URL that was returned by `StorageHelper` when
    we uploaded the photo.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Url`属性设置为`StorageHelper`上传照片时返回的URL。
- en: Use the `AddAsync` method on the `signalRMessages` variable to send a message
    to the SignalR service.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`signalRMessages`变量上使用`AddAsync`方法向SignalR服务发送消息。
- en: 'Add an empty return statement:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个空的返回语句：
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using the Computer Vision API to scan for adult content
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算机视觉API扫描成人内容
- en: 'To minimize the risk that offensive photos are shown in our chat, we will use
    machine learning to try to find problematic material and prevent it from being
    posted to the chat. For that, we will use the **Computer Vision API** in Azure,
    which is a part of the **Azure Cognitive services**. To use the API, we need a
    key. We will add it to the application settings of the Function App:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大程度地减少在我们的聊天中显示冒犯性照片的风险，我们将使用机器学习来尝试查找问题材料并防止其发布到聊天中。为此，我们将在Azure中使用**计算机视觉API**，这是**Azure认知服务**的一部分。要使用API，我们需要一个密钥。我们将把它添加到功能应用程序的应用程序设置中：
- en: Go to the Azure Portal.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Azure门户。
- en: Go to the resource we created for the Custom Vision API.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到我们为Custom Vision API创建的资源。
- en: The key can be found under the Keys tab. You can use either Key 1 or Key 2.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密钥可以在“密钥”选项卡下找到。您可以使用Key 1或Key 2。
- en: Go to the resource for `Function App`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“功能应用程序”的资源。
- en: Add the Key as an application setting named `ComputerVisionKey`. Also, add the
    key to `local.settings.json`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将密钥作为名为`ComputerVisionKey`的应用程序设置添加。还要将密钥添加到`local.settings.json`中。
- en: Also, add the Endpoint as an application setting. Use the name `ComputerVisionEndpoint`.
    The Endpoint can be found under the Overview tab of the Function App resource. Also,
    add the Endpoint to `local.settings.json`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要将Endpoint添加为应用程序设置。使用名称`ComputerVisionEndpoint`。可以在功能应用程序资源的“概述”选项卡下找到Endpoint。还要将Endpoint添加到`local.settings.json`中。
- en: Install the `Microsoft.Azure.CognitiveServices.Vision.ComputerVision` NuGet
    package in the `Chat.Functions` project in Visual Studio. This isto get the necessary
    classes to use the Computer Vision API.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio的`Chat.Functions`项目中安装`Microsoft.Azure.CognitiveServices.Vision.ComputerVision`
    NuGet包。这是为了获取使用计算机视觉API所需的类。
- en: The code for the call to the Computer Vision API will be added to the `Message`
    function. After that, we convert the `base 64` string to a `byte[]`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用计算机视觉API的代码将被添加到`Message`函数中。之后，我们将把`base 64`字符串转换为`byte[]`。
- en: Create a `MemoryStream` based on the byte array.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于字节数组创建一个`MemoryStream`。
- en: Create a `ComputerVisonClient` as shown in the following code and send the credentials
    to the constructor.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码中所示创建`ComputerVisonClient`并将凭据传递给构造函数。
- en: Create a list of which features we will use when we are analyzing the photo. In
    this case, we will use the `VisualFeatureTypes.Adult` feature.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们在分析照片时将使用的功能列表。在这种情况下，我们将使用`VisualFeatureTypes.Adult`功能。
- en: Use the `AnalyzeImageInStreamAsync` method on `ComputerVisionClient` and pass
    the stream and feature list to the constructor to analyze the photo.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ComputerVisionClient`上使用`AnalyzeImageInStreamAsync`方法，并将流和功能列表传递给构造函数以分析照片。
- en: 'If the result is `IsAdultContent`, stop the execution of the function by using
    an empty return statement:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果结果是`IsAdultContent`，则使用空的返回语句停止函数的执行：
- en: '[PRE15]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Creating a scheduled job to clear photos from storage
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个定期清除存储中照片的计划作业
- en: 'The last thing we will do is clean the blob storage at regular intervals and
    delete photos that are older than one hour. We will do that by creating a function
    that is triggered by `TimeTrigger`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的最后一件事是定期清理blob存储并删除超过一小时的照片。我们将通过创建一个由`TimeTrigger`触发的函数来实现这一点：
- en: To create a new function, right-click the `Chat.Functions` project and click
    New Azure Function, which will be found under the Add menu.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建新函数，请右键单击`Chat.Functions`项目，然后单击“新的Azure函数”，该选项将在“添加”菜单下找到。
- en: Name the function `ClearPhotos`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数命名为`ClearPhotos`。
- en: Select that the function will use a Time trigger, because we want it to run
    on a time interval.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择函数将使用时间触发器，因为我们希望它按时间间隔运行。
- en: 'Use a chron expression to set the Scheduleto `0 */60 * * * *` to make it run
    every 60 minutes:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用时间表达式将Schedule设置为`0 */60 * * * *`，使其每60分钟运行一次：
- en: '![](img/edc5a51c-8e9e-44e9-b55a-b040ec05de41.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edc5a51c-8e9e-44e9-b55a-b040ec05de41.png)'
- en: 'The only thing we will do in the `ClearPhotos` function is call the `Clear`
    method of the `StorageHelper` that we created earlier in this chapter:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ClearPhotos`函数中，我们唯一要做的是调用本章前面创建的`StorageHelper`的`Clear`方法：
- en: '[PRE16]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Deploying the functions to Azure
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数部署到Azure
- en: 'The last step in this chapter is to deploy the functions to Azure. You can
    do that as a part of a CI/CD pipeline, for example with Azure DevOps. But the
    easiest way to deploy the functions in this case is to do it directly from Visual
    Studio. Follow these steps to deploy the functions:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一步是将函数部署到Azure。您可以将其作为CI/CD流水线的一部分来完成，例如使用Azure DevOps。但在这种情况下，将函数直接从Visual
    Studio部署是最简单的方法。按照以下步骤部署函数：
- en: Right-click on the `Chat.Functions` project and select Publish.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`Chat.Functions`项目，然后选择发布。
- en: Select the Select existing option. Also, check the `Run from package` file option.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“选择现有选项”。还要勾选“从包文件运行”选项。
- en: Click the Create profile button.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“创建配置文件”按钮。
- en: Sign in to the same Microsoft account that we used in the Azure portal when
    we were creating the Function App.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到与我们在创建功能应用程序时在Azure门户中使用的相同的Microsoft帐户。
- en: Select the subscription that contains the Function App. All Function Apps we
    have in the subscription will now be loaded.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择包含函数应用程序的订阅。我们在订阅中拥有的所有函数应用程序现在将被加载。
- en: Select the Function App and click OK.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择函数应用程序，然后点击“确定”。
- en: When the profile is created, click the Publish button.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建配置文件后，点击“发布”按钮。
- en: 'The following screenshot shows the last step. After that, the publishing profile
    is created:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了最后一步。之后，发布配置文件被创建：
- en: '![](img/2fc2606f-d4e0-436b-97ef-d6b867fa5f85.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fc2606f-d4e0-436b-97ef-d6b867fa5f85.png)'
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned how to set up a serverless backend for real-time
    communication with Azure Functions and the Azure SignalR Service. We have also
    learned how to use blob storage and machine learningwith the Azure Cognitive Services
    to scan for adult content in photos.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学习了如何为实时通信设置无服务器后端，使用Azure Functions和Azure SignalR服务。我们还学习了如何使用blob存储和Azure认知服务中的机器学习来扫描照片中的成人内容。
- en: In the next chapter, we will build a chat app that will use the backend we have
    built in this project.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个聊天应用程序，该应用程序将使用我们在本项目中构建的后端。
