- en: Events, Event-Driven Design, and APIs
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 事件，事件驱动设计和API
- en: At the heart of a frontend application are *events*. JavaScript allows us to
    listen for and react to user and browser events to change content for the user
    in an intuitive fashion to create elegant user interfaces and experiences. We
    need to know how to use these packets of data that are thrown around. Browser
    events are our bread and butter—they allow us to have more than a static application
    and, instead, be dynamic! By understanding events, you'll be on your way to becoming
    a full JavaScript developer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端应用的核心是*事件*。JavaScript允许我们监听并对用户和浏览器事件做出反应，以直观地改变用户内容，从而创建优雅的用户界面和体验。我们需要知道如何使用这些被抛出的数据包。浏览器事件是我们的基础
    - 它们使我们不仅仅拥有静态应用，而是动态的！通过理解事件，您将成为一个完整的JavaScript开发人员。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The event life cycle
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件生命周期
- en: Capturing an event and reading its properties
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获事件并读取其属性
- en: Using Ajax and events to populate API data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ajax和事件来填充API数据
- en: Handling asynchronicity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异步性
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Be prepared to work with the code provided in the `Chapter-7` directory of the
    repository: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好使用存储库的`Chapter-7`目录中提供的代码：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7)。
- en: The event life cycle
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件生命周期
- en: 'When an event occurs in JavaScript, it doesn''t simply happen and vanish—it
    goes through a *life cycle*. There are three phases to this life cycle:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript中发生事件时，它不仅仅发生并消失 - 它经历了一个*生命周期*。这个生命周期有三个阶段：
- en: The **capture** phase
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捕获**阶段'
- en: The **targeting** phase
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**阶段'
- en: The **bubbling** phase
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冒泡**阶段'
- en: 'Consider the following HTML:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下HTML：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can visualize it as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其可视化如下：
- en: '![](assets/b30b13fc-d9a9-42ba-90f2-9f1e8a9c7acf.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b30b13fc-d9a9-42ba-90f2-9f1e8a9c7acf.png)'
- en: Figure 7.1 – The event life cycle
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 - 事件生命周期
- en: 'Now, there''s something else that is important to consider when it comes to
    events: they don''t just take effect on the exact target, but rather on the whole
    stack of objects. Before we describe what capturing, targeting, and bubbling entail,
    take a look at the following representation of our code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，还有一件重要的事情需要考虑，那就是事件发生时不仅仅影响到确切的目标，而是整个对象堆栈。在描述捕获、目标和冒泡之前，看一下我们代码的以下表示：
- en: '![](assets/9059220b-da02-4e37-9470-532f29aedc52.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9059220b-da02-4e37-9470-532f29aedc52.png)'
- en: Figure 7.2 – Event layering
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - 事件分层
- en: 'If we think about our page as a layer cake, we can see that this event (represented
    by the arrow) must pass through all the layers of our DOM to reach the button.
    This is our **capture** phase. When the button is clicked, an event is *dispatched*
    into the event flow. First, the event looks at the document object. It then travels
    through the layers of the DOM until it reaches the intended destination: the button.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们把我们的页面想象成一个分层蛋糕，我们可以看到这个事件（由箭头表示）必须通过我们DOM的所有层才能到达按钮。这是我们的**捕获**阶段。当按钮被点击时，事件被*派发*到事件流中。首先，事件查看文档对象。然后它穿过DOM的各层直到到达预定目的地：按钮。
- en: Now that the event has reached the button, we begin the **targeting** phase.
    Whatever information the event is supposed to capture from the button will be
    gathered, such as the event type (such as a click or mouseover) and other details,
    such as the cursor's *X*/*Y* coordinates.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事件已经到达按钮，我们开始**目标**阶段。事件应该从按钮中捕获的任何信息都将被收集，比如事件类型（比如点击或鼠标悬停）和其他细节，比如光标的*X*/*Y*坐标。
- en: Finally, the event travels back through the layers to the document in the bubbling
    phase. The **bubbling** phase allows us to handle an event on *any* element by
    its parent elements.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，事件在冒泡阶段返回到文档的各层。**冒泡**阶段允许我们通过其父元素在*任何*元素上处理事件。
- en: 'Let''s look at this in practice and play with our events a little bit. Find
    the following directory and open `index.html` in the browser—[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/events](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/events):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在实践中看看并稍微玩一下我们的事件。找到以下目录并在浏览器中打开`index.html` - [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/events](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/events)：
- en: '![](assets/e08b2b13-0d2c-475d-bc0e-6c5eccb8e965.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e08b2b13-0d2c-475d-bc0e-6c5eccb8e965.png)'
- en: Figure 7.3 – Events playground
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 - 事件游乐场
- en: 'If we take a look at this page and play around with it for a few minutes, we
    see a few things:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下这个页面并玩几分钟，我们会看到一些东西：
- en: The *X*/*Y* coordinates on the right will change as we move our mouse on the
    page.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧的*X*/*Y*坐标将随着我们在页面上移动鼠标而改变。
- en: When we open the console, it will display messages about our click event and
    at which *phase* it occurred.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们打开控制台时，它将显示有关我们的点击事件以及发生在哪个*阶段*的消息。
- en: Let's take a look at the code in `index.js` at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/events/index.js](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/events/index.js).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`index.js`中的代码，网址是[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/events/index.js](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/events/index.js)。
- en: From lines 1 to 5, we're simply setting up a data object to map a numerical
    code to a string. So far, so good. Now, let's take a look at line 32, where it
    says `document.querySelector('html').addEventListener('click', logClick, true)`.
    This optional Boolean parameter is new to us right now; when put it into an event
    listener, it simply says "Let me listen in the *capture* phase." Thus, when we
    click anywhere on our page, we'll get a click event with the information Click
    event triggered during capture phase at HTML. And this event was previously handled
    at undefined because it's the very first encounter with this event. It hasn't
    yet bubbled or been targeted.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从1到5行，我们只是设置了一个数据对象，将数字代码映射到一个字符串。到目前为止，一切都很顺利。现在，让我们看看第32行，那里写着`document.querySelector('html').addEventListener('click',
    logClick, true)`。这个可选的布尔参数对我们来说是新的；当它放入事件监听器中时，它只是表示“让我在*捕获*阶段监听”。因此，当我们在页面的任何地方点击时，我们将得到一个点击事件，其中包含信息点击事件在HTML上的捕获阶段触发。这个事件之前在未定义处被处理，因为这是对这个事件的第一次遭遇。它还没有冒泡或被定位。
- en: Let's keep dissecting this example in the next section to learn about these
    mysterious parts of the code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节继续剖析这个例子，了解代码中这些神秘的部分。
- en: Capturing an event and reading its properties
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获事件并读取其属性
- en: We'll continue working with our `events` playground code: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/events/index.js](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/events/index.js).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用我们的`events`游乐场代码：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/events/index.js](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/events/index.js)。
- en: 'On lines 32–34, we registered three click event listeners, as shown:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在32-34行，我们注册了三个点击事件监听器，如下所示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we discussed, the first one is listening in the capture phase because we've
    included the final Boolean parameter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，第一个事件监听在捕获阶段，因为我们包括了最后的布尔参数。
- en: 'We also have three `mousemove` events on lines 16–29\. Let''s take a look at
    one of them:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有三个`mousemove`事件在16-29行。让我们看看其中一个：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'I hope most of this makes sense—we''re using a new event type of `mousemove`,
    so this event says "as the user''s mouse goes over the button, execute this code."
    It''s as simple as that. The code we''re executing is to set the value of our
    inputs with IDs of `x` and `y` to equal *the* *x and y values of the event*. Here''s
    the magic of the event object: it carries with it a *lot* of information. Go ahead
    and add a line inside this function as `console.log(e)` and take a look at what''s
    logged, as shown in the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望大部分都是有意义的-我们正在使用一个新的事件类型`mousemove`，所以这个事件表示“当用户的鼠标移过按钮时，执行这段代码。”就是这么简单。我们要执行的代码是将ID为`x`和`y`的输入的值设置为*事件的x和y值*。这就是事件对象的魔力所在：它携带了*很多*信息。继续在这个函数内添加一行`console.log(e)`，看看记录了什么，如下面的截图所示：
- en: '![](assets/999173f2-3fb6-47cb-a27d-b6404e7a26df.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/999173f2-3fb6-47cb-a27d-b6404e7a26df.png)'
- en: Figure 7.4 – Logging events
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4-记录事件
- en: 'As expected, every time your mouse moves over Click Here, the event fires and
    MouseEvent is logged out. Open one of those events. You''ll see something similar
    to the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，每当你的鼠标移动到“点击这里”上时，事件就会触发，并且鼠标事件被记录下来。打开其中一个事件。你会看到类似于以下内容：
- en: '![](assets/2fa91e96-485b-405b-a27b-d0b01e1dc530.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2fa91e96-485b-405b-a27b-d0b01e1dc530.png)'
- en: Figure 7.5 – MouseEvent
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5-鼠标事件
- en: Here, we see plenty of information about the event, including (as expected)
    the *X* and *Y* coordinates of our mouse at that time. Many of these properties
    will be useful, but one in particular to note is `target`. The target of an event
    is the node upon which we placed our event listener. From the `target` property,
    we can get its ID, which is useful if we have one event handler for multiple nodes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了关于事件的大量信息，包括（如预期的那样）我们鼠标在那个时候的*X*和*Y*坐标。这些属性中的许多将会很有用，但特别要注意的是`target`。事件的目标是我们放置事件监听器的节点。从`target`属性中，我们可以得到它的ID，如果我们有一个事件处理程序用于多个节点，这将会很有用。
- en: Do you remember our sticky note program from [Chapter 6](fe95a50e-72eb-45eb-a35c-4ce76858884e.xhtml), *The
    Document Object Model (DOM)*? Let's augment it now.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在[第6章](fe95a50e-72eb-45eb-a35c-4ce76858884e.xhtml)中的便利贴程序，*文档对象模型（DOM）*吗？现在让我们来增强它。
- en: Sticky notes revisited
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视便利贴
- en: 'Let''s take a closer look at our sticky note program from [Chapter 6](fe95a50e-72eb-45eb-a35c-4ce76858884e.xhtml), *The
    Document Object Model (DOM)—*[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/stickies/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/stickies/starter-code)—and
    include the ability to create a modal window with information about the sticky
    when clicked on and the ability to delete that sticky, as shown in the following
    screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从[第6章](fe95a50e-72eb-45eb-a35c-4ce76858884e.xhtml)中的便利贴程序*文档对象模型（DOM）*中更仔细地看一下：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/stickies/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/stickies/starter-code)，并包括创建模态窗口的能力，当点击时显示有关便利贴的信息，并能够删除该便利贴，如下面的截图所示：
- en: '![](assets/0f8a836e-9704-4f27-9788-e787ab513906.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0f8a836e-9704-4f27-9788-e787ab513906.png)'
- en: Figure 7.6 – New and improved sticky note creator
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6-新的和改进的便利贴创建者
- en: 'To successfully code this, you''ll need to use a new DOM manipulation method:
    `.remove()`. Take a peek at [https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove](https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove)
    for the documentation. You may also want to take a look at the CSS property of
    `visibility` to show and hide the modal window.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功编写这段代码，你需要使用一个新的DOM操作方法：`.remove()`。查看[https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove](https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove)获取文档。你可能还想看一下`visibility`的CSS属性来显示和隐藏模态窗口。
- en: Just for fun, I also included a small JavaScript library to use a color picker
    for the sticky color field as an example of how simple it can be to include third-party
    code. You don't need to do anything with the `jscolor.js` script; it will work
    automatically.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，我还包括了一个小的JavaScript库，用于将颜色选择器用于便利贴颜色字段，作为包含第三方代码的简单示例。您不需要对`jscolor.js`脚本做任何操作；它将自动工作。
- en: Sticky notes – solution 1
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 便利贴 - 解决方案1
- en: Did you arrive at something similar to the following code?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否得到了类似以下代码的东西？
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can find this code file on GitHub at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/stickies/solution-code-1](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/stickies/solution-code-1).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到这个代码文件：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/stickies/solution-code-1](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/stickies/solution-code-1)。
- en: There are a few interesting pieces here, such as our sticky click handler starting
    on line 29\. Most of this should look familiar, with the addition of a few new
    friends. First, the click handler is using the event's target property to set
    text in our message box with attributes of the target. We don't have to search
    through the DOM in order to find our properties. In fact, doing so would be an
    expensive and wasteful operation when we have the information passed to us already
    with the event object. Line 33 modifies the CSS of the modal window to display
    it, and on line 37, we remove the sticky when the delete button of the modal is
    clicked.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的部分，比如我们的便利贴单击处理程序从第29行开始。大部分内容应该看起来很熟悉，只是增加了一些新的内容。首先，单击处理程序使用事件的目标属性来使用目标的属性设置消息框中的文本。我们不必在DOM中搜索以查找我们的属性。事实上，当事件对象已经将信息传递给我们时，这样做将是昂贵和浪费的操作。第33行修改了模态窗口的CSS以显示它，第37行在模态的删除按钮被单击时删除了便利贴。
- en: 'This works pretty well! However, there''s another feature of events that we
    can use to make our code more efficient, thanks to the event life cycle: *event
    delegation*.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个效果相当不错！但是，由于事件生命周期的特性，我们可以使用另一个事件的特性来使我们的代码更加高效：*事件委托*。
- en: Sticky notes – solution 2 – event delegation
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 便利贴 - 解决方案2 - 事件委托
- en: 'The principle of **event delegation** is to register an event listener on a
    parent event and let event propagation tell us what element has been clicked on.
    Remember our diagram of the event life cycle and the layers through which an event
    travels? We can use this to our advantage. Take a look at line 37, which is shown
    here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件委托**的原则是在父事件上注册一个事件监听器，让事件传播告诉我们哪个元素被点击了。还记得我们的事件生命周期图和事件传播的层次吗？我们可以利用这一点。看一下第37行，如下所示：'
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can find this code on GitHub at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/stickies/solution-code-2/script.js#L37](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/stickies/solution-code-2/script.js#L37).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到这段代码：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/stickies/solution-code-2/script.js#L37](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/stickies/solution-code-2/script.js#L37)。
- en: In this code, we've removed the attachment of the click listener from the sticky
    creation logic and abstracted it to be attached to the whole container. When `container`
    is clicked, we check to see whether the target has `box` as its class. If so,
    we execute our logic! This is a more efficient use of event listeners, especially
    when used on dynamically created elements. There are cases where event delegation
    will be your best option and times when either will work.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们已经将点击监听器的附加从便利贴创建逻辑中移除，并将其抽象为附加到整个容器。当单击`container`时，我们检查目标是否具有`box`作为其类。如果是，我们执行我们的逻辑！这是事件监听器更有效的使用，特别是在动态创建的元素上使用时。有些情况下，事件委托将是您的最佳选择，有时任何一种都可以。
- en: 'But now we have another problem: every time a sticky is clicked, a new click
    handler is added to the delete button. That''s not very efficient. See whether
    you can refactor the code to eliminate that problem.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们有另一个问题：每次单击便利贴时，都会向删除按钮添加一个新的单击处理程序。这并不是很高效。看看是否可以重构代码以消除这个问题。
- en: Sticky notes – solution 3
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 便利贴 - 解决方案3
- en: 'Here''s one possible solution:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可能的解决方案：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can find this solution on GitHub at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/stickies/solution-code-3/script.js](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/stickies/solution-code-3/script.js).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到这个解决方案：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/stickies/solution-code-3/script.js](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/blob/master/chapter-7/stickies/solution-code-3/script.js)。
- en: While this uses a global variable, it's still more efficient. By encapsulating
    our whole program in a function or class, we could eliminate the global variable,
    but that's not important for this concept.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这使用了一个全局变量，但它仍然更高效。通过将整个程序封装在一个函数或类中，我们可以消除全局变量，但这对于这个概念来说并不重要。
- en: It's now time to look at Ajax and how events tie into the life cycle of a program.
    Let's do a lab!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看一下Ajax以及事件如何与程序的生命周期联系起来了。让我们做一个实验！
- en: Using Ajax and events to populate API data
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ajax和事件来填充API数据
- en: 'Let''s put it all together. For this lab, we''re going to be creating a simplified
    Pokémon game using PokéAPI: [https://pokeapi.co/](https://pokeapi.co/).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有东西都放在一起。在这个实验中，我们将使用PokéAPI创建一个简化的宝可梦游戏：[https://pokeapi.co/](https://pokeapi.co/)。
- en: 'Here''s what our game will end up being: [https://sleepy-anchorage-53323.herokuapp.com/](https://sleepy-anchorage-53323.herokuapp.com/).
    Go ahead and pull up the site and play around with it to see the functionality.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的游戏最终的样子：[https://sleepy-anchorage-53323.herokuapp.com/](https://sleepy-anchorage-53323.herokuapp.com/)。请打开网站并尝试一下功能。
- en: Please resist the temptation to look at the finished JavaScript file (for now).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请抵制诱惑，暂时不要查看已完成的JavaScript文件。
- en: 'Here''s a screenshot of what you''ll see when you access the preceding URL
    and start playing the game:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当您访问上述URL并开始玩游戏时会看到的屏幕截图：
- en: '![](assets/67fb2064-b64e-41a5-9980-d9500f60521d.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/67fb2064-b64e-41a5-9980-d9500f60521d.png)'
- en: Figure 7.7 – Pokémon game
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 宝可梦游戏
- en: 'All of the HTML and CSS have been provided for you. You''ll be working in the
    `main.js` file: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/pokeapi/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/pokeapi/starter-code).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的HTML和CSS都已经为您提供。您将在`main.js`文件中工作：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/pokeapi/starter-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/pokeapi/starter-code)。
- en: If you're not familiar with Pokémon, don't worry! The logic behind this game
    is basic. (If you *are* familiar with the games, forgive the simplified approach.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉宝可梦，不用担心！这个游戏的逻辑很基本。（如果您熟悉这些游戏，请原谅这种简化的方法。）
- en: 'Here''s what we''ll be doing:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要做的事情：
- en: Query PokéAPI for all the Pokémon available.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询PokéAPI以获取所有可用的宝可梦。
- en: Populate the select list with the names of the Pokémon and the value of their
    API URLs, as provided by the API.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用API提供的宝可梦名称和API URL的值填充选择列表。
- en: When this is done, toggle the CSS property to show the player selections.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，切换CSS属性以显示玩家的选择。
- en: Allow each of the two players to select their Pokémon.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许每个玩家选择他们的宝可梦。
- en: Create functionality for each player to use their Pokémon's moves against the
    other.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个玩家创建功能，让他们使用自己宝可梦的招式对抗对方。
- en: Decrement the other player's Pokémon hit points based on a random number generated
    from the maximum power possible.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据从最大可能力量生成的随机数减少另一个玩家的宝可梦生命值。
- en: Display the overlay with text stating that it's effective.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示叠加文本，指出它是有效的。
- en: If the move does not have the power attribute, display the overlay saying it's
    not effective.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果招式没有力量属性，显示叠加，表示它不起作用。
- en: When one Pokémon's hit points are `0` or lower, display the overlay that the
    opponent has fainted.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个宝可梦的生命值为`0`或更低时，显示对手已经晕倒的叠加。
- en: Let's break down the starter code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分解起始代码。
- en: Starter code
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 起始代码
- en: 'Let''s take a look at the starter code, piece by piece, as it introduces a
    new formulation of our JavaScript: classes! If you''re familiar with classes in
    Python or other languages, this ES6 introduction will come as a welcome reminder
    of the use of JavaScript. Let''s begin:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步看一下起始代码，因为它引入了我们的JavaScript的一个新的构造：类！如果您熟悉Python或其他语言中的类，这个ES6的介绍将是对JavaScript使用的一个受欢迎的提醒。让我们开始：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First of all, when declaring a class in JavaScript ES6, we simply create an
    object! Now, the details of the object *are* a little different than what we're
    used to, but many of the principles are the same. To create an instance of the
    class, we can say `const p = new Poke()` after finishing the class code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在JavaScript ES6中声明一个类时，我们只是创建一个对象！现在，对象的细节与我们习惯的有些不同，但许多原则是相同的。要创建类的实例，我们可以在完成类代码后说`const
    p = new Poke()`。
- en: After that, there is some syntactic sugar with classes, such as constructors,
    getters, and setters. Feel free to research classes in JavaScript, as it'll help
    you with the overall goal.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，有一些类的语法糖，比如构造函数、getter和setter。随意研究JavaScript中的类，因为它将帮助您实现整体目标。
- en: 'I''ve given you the starter to a constructor, which is executed when you create
    an instance of a class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为您提供了构造函数的起始部分，当您创建一个类的实例时，它将被执行：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What might you want in your constructor? Maybe you want references to often-used
    DOM elements or event handlers? Then, of course, the question arises: how do we
    *reference* the variables we''ve created?'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您的构造函数可能需要什么？也许您想要对经常使用的DOM元素或事件处理程序进行引用？然后，当然，问题就出现了：我们如何*引用*我们创建的变量？
- en: 'The answer is `this`. When using a variable global to the class, you can preface
    it with `this.<variableName>` and it will be available to all methods. Here''s
    the great part: it''s not a pure global variable to our whole page, but just to
    our class! If you recall a few of the previous code examples, we didn''t handle
    that piece; here''s one way to do so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是`this`。当使用一个全局变量到类时，您可以在`this.<variableName>`之前加上它，它将对所有方法可用。这里的好处是：它不是我们整个页面的纯全局变量，而只是我们类的全局变量！如果您回忆一下之前的一些代码示例，我们没有处理那一部分；这是一种处理的方法：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since each Pokémon has multiple moves that it learns at different points in
    the game, this is the logic for finding the moves available at the beginning of
    play. You won''t have to modify it, but take a look at the `.filter()` method
    of arrays. We didn''t cover it before, but it''s a useful method to know. MDN
    is a good resource: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个宝可梦在游戏的不同阶段学习多个招式，这是在游戏开始时找到可用招式的逻辑。您不必修改它，但是看一下数组的`.filter()`方法。我们之前没有涉及它，但这是一个有用的方法。MDN是一个很好的资源：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)。
- en: 'The next part of the code we''re interested in is the **setter**:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的代码的下一部分是**setter**：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A **setter** is a class method that handles setting or changing a member variable.
    Usually used with a **getter**, the concept allows us to abstract the logic of
    manipulation needed when changing (or retrieving) a variable. In this case, we''re
    using some game logic to see how to treat the hit points. But then we get into
    a new and wonderful idea: custom events.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**setter**是一个处理设置或更改成员变量的类方法。通常与**getter**一起使用，这个概念允许我们在更改（或检索）变量时抽象出所需的操作逻辑。在这种情况下，我们使用一些游戏逻辑来看待生命值。但是然后我们进入了一个新的、美妙的想法：自定义事件。'
- en: Custom events
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义事件
- en: 'With the `new CustomEvent()` directive, we can create a new, named event to
    use in our program. Sometimes, user interactions or page behavior don''t fully
    handle what we need. Custom events can help with that need. Notice in the preceding
    code that the `detail` object contains data to be passed with the event, and we
    use `document.dispatchEvent()` to send it to the event stream. Creating an event
    listener for a custom event is the same as doing so with a built-in event: use `.addEventListener()`.
    We''ll want to use the `doMove()` function.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`new CustomEvent()`指令，我们可以创建一个新的命名事件在我们的程序中使用。有时，用户交互或页面行为并不能完全满足我们的需求。自定义事件可以帮助满足这种需求。请注意在前面的代码中，`detail`对象包含要传递的事件数据，我们使用`document.dispatchEvent()`将其发送到事件流中。创建自定义事件的事件监听器与使用内置事件一样：使用`.addEventListener()`。我们将要使用`doMove()`函数。
- en: Solution code
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案代码
- en: 'How did you do with your attempt? You can take a look at one possible way of
    solving the lab here: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/pokeapi/solution-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/pokeapi/solution-code).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您尝试得怎么样？您可以在这里看到解决实验室的一种可能方式：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/pokeapi/solution-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/pokeapi/solution-code)。
- en: Remember, there are multiple ways to solve a programming problem, so if your
    solution doesn't match the provided approach, it's OK! The main idea is to solve
    the problem.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，解决编程问题有多种方法，所以如果您的解决方案与提供的方法不匹配，也没关系！主要目的是解决问题。
- en: Handling asynchronicity
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异步性
- en: 'As we can see when using APIs, the asynchronous nature of Ajax calls for a
    couple of creative approaches. In our Pokémon game, we used a loading spinner
    while calls were completing; this is an approach you''ve seen all around the modern
    web. Let''s take a look at one example from the game:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在使用API时所看到的，Ajax调用的异步性需要一些创造性的方法。在我们的宝可梦游戏中，我们在调用完成时使用了加载旋转器；这是您在现代网络上到处都能看到的方法。让我们看一个游戏中的例子：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'All *this* part of the code is doing is toggling the visibility of a layer
    that contains a spinning image. This is all in the CSS (as it''s not technically
    an image, but rather a CSS animation). Let''s look at how it''s used:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*这*部分代码所做的只是切换包含旋转图像的图层的可见性。这都是在CSS中（因为它不是技术上的图像，而是CSS动画）。让我们看看它是如何使用的：'
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we see that in our asynchronous Promise calls with `.then()`, we're toggling
    the loader when everything is complete! It's a nice little bundle. If you'd like
    a refresher on how to use `fetch` and Ajax calls in general, take a look back
    at [Chapter 4](d985ee47-411d-4ffa-bdd7-2d49fccc9b78.xhtml), *Data and Your Friend,
    JSON*, in the *API calls from the frontend – Ajax* section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到在我们的异步Promise调用中使用`.then()`时，当一切都完成时切换加载程序！这是一个很好的小捆绑。如果您想复习如何使用`fetch`和一般的Ajax调用，请回顾一下[第4章](d985ee47-411d-4ffa-bdd7-2d49fccc9b78.xhtml)，*数据和您的朋友，JSON*，在*来自前端的API调用
    - Ajax*部分。
- en: When dealing with the inherently asynchronous nature of Ajax calls, it's important
    to keep in mind the fact that we don't know exactly when a call will return with
    its data—or even *if* it will return at all! We can make our code better with
    **error handling**.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Ajax调用固有的异步特性时，重要的是要记住我们不知道调用何时会返回其数据，甚至*是否*会返回！我们可以通过**错误处理**使我们的代码更好。
- en: Error handling
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Take a look at this code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这段代码：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have some of the usual suspects here: a `fetch` call and `.then()` handling
    our results. Now, take a look at `new Error()` and `.catch()`. Just like in most
    languages, JavaScript has a way to explicitly throw errors, and `.catch()` at
    the end of our `fetch` chain will then present the error to the user in an alert
    box. It''s always best practice to include error handling in your Ajax calls in
    case the service you''re calling doesn''t respond, doesn''t respond in time, or
    sends back an error. We''ll discuss errors a bit more in [Chapter 9](2e099e56-1f9c-4329-a3ae-55c23f6bd7d3.xhtml),
    *Deciphering Error Messages and Performance Leaks*.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有一些常见的嫌疑人：一个`fetch`调用和`.then()`处理我们的结果。现在，看一下`new Error()`和`.catch()`。就像大多数语言一样，JavaScript有一种明确抛出错误的方法，我们`fetch`链的末尾的`.catch()`将在警报框中向用户呈现错误。在您的Ajax调用中包含错误处理总是最佳实践，以防您调用的服务没有响应，没有及时响应或发送错误。我们将在[第9章](2e099e56-1f9c-4329-a3ae-55c23f6bd7d3.xhtml)中更多地讨论错误，*解密错误消息和性能泄漏*。
- en: Star Wars API exploration Lab
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 星球大战API探索实验室
- en: 'Let''s get our hands dirty with some more Ajax calls. We''ll be using the popular
    **Star Wars API** (**SWAPI**): [https://swapi.dev/](https://swapi.dev/) . Take
    a few minutes to familiarize yourself with the documentation and how the API works.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些Ajax调用来动手。我们将使用流行的**星球大战API**（**SWAPI**）：[https://swapi.dev/](https://swapi.dev/)。花几分钟时间熟悉文档和API的工作原理。
- en: 'Here''s what we''ll be building:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要构建的内容：
- en: '![](assets/5ad5025a-4894-47ce-8f0c-07af48682c27.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5ad5025a-4894-47ce-8f0c-07af48682c27.png)'
- en: Figure 7.8 – Star Wars exploration
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 - 星球大战探索
- en: You can experiment with the functionality at [https://packtpublishing.github.io/Hands-on-JavaScript-for-Python-Developers/chapter-7/swapi/solution-code/](https://packtpublishing.github.io/Hands-on-JavaScript-for-Python-Developers/chapter-7/swapi/solution-code/).
    Try to resist the temptation to peruse the solution code until after you've tried
    your hand at recreating the functionality.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packtpublishing.github.io/Hands-on-JavaScript-for-Python-Developers/chapter-7/swapi/solution-code/](https://packtpublishing.github.io/Hands-on-JavaScript-for-Python-Developers/chapter-7/swapi/solution-code/)上尝试该功能的功能。在尝试重新创建功能之后，试着抵制浏览解决方案代码的诱惑。
- en: 'Here''s what our code should do:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码应该做到以下几点：
- en: Display a loader on page load. This loader is provided for you as a CSS animation.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面加载时显示加载程序。这个加载程序作为CSS动画为您提供。
- en: 'Call the `/people` SWAPI endpoint to retrieve all people in the API. *Hint:
    you will need to call SWAPI more than once to get all of the people.*'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`/people` SWAPI端点来检索API中的所有人。*提示：您需要多次调用SWAPI才能获取所有人。*
- en: Populate the select list with the names of the people and hide the loader.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用人们的名字填充选择列表并隐藏加载器。
- en: When Go is clicked, make another call to SWAPI to retrieve details about the
    person chosen and display them (at least the name).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击Go时，再次调用SWAPI以检索有关所选人员的详细信息并显示它们（至少是姓名）。
- en: Our approach will be to first populate the list and then prepare for user action,
    in order to explore both synchronously chained events and asynchronous action
    dependent on user input.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法将首先填充列表，然后准备用户操作，以便探索同步链接事件和异步动作依赖于用户输入的情况。
- en: The starter HTML and CSS shouldn't need to be altered, and our starter JavaScript
    file is nearly empty! Are you ready for the challenge? Good luck!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 起始HTML和CSS不应该需要更改，我们的起始JavaScript文件几乎是空的！您准备好挑战了吗？祝你好运！
- en: A solution
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个解决方案
- en: If you look at the solution code, you'll find one way of creating this functionality.
    Let's break it down.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看解决方案代码，您会发现创建此功能的一种方法。让我们来分解一下。
- en: 'Just like in our Pokémon game, we''ll use a class. Its constructor will store
    a few various pieces of information, as well as add an event listener to the Go
    button:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在我们的宝可梦游戏中一样，我们将使用一个类。它的构造函数将存储一些各种信息，并添加一个事件侦听器到Go按钮：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, as we know we''ll be making multiple calls to SWAPI, we can make ourselves
    a helper function to facilitate this work. It may take four arguments: the SWAPI
    API URL, an array of previous results (useful if we''re paginating!), and Promise-like
    `resolve` and `reject` parameters:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们知道我们将多次调用SWAPI，我们可以创建一个帮助函数来简化这项工作。它可能需要四个参数：SWAPI API URL，先前结果的数组（如果我们正在分页的话很有用！），以及类似Promise的`resolve`和`reject`参数：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This last line may be new. `…` is the spread operator and it expands an array
    into each of its parts. With this ES6 feature, we don''t need to iterate over
    an array in order to join it to another or do any other reassignment magic. We
    can simply explode the results and join them with the existing results:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行可能是新的。`…`是扩展运算符，它将数组展开为其各个部分。有了这个ES6功能，我们就不需要迭代数组来将其连接到另一个数组或进行任何其他重新分配的操作。我们可以简单地展开结果并将它们与现有结果连接起来：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In many APIs, if the dataset is large, only limited results will be returned,
    with a link for the next and previous pages of data. SWAPI''s nomenclature specifies
    that `.next` is the property to look for if there''s another page. Otherwise,
    we can return our results in our `resolve` function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多API中，如果数据集很大，只会返回有限的结果，并提供下一页和上一页数据的链接。 SWAPI的命名规范指定`.next`是要查找的属性，如果有另一页的话。否则，我们可以在我们的`resolve`函数中返回我们的结果：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Don't forget error handling!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记错误处理！
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Try to read through `getPeople()` in its entirety to get a sense of what it
    does. Some of it is simple manipulation, but `new Promise()` is the core of this
    function. Instead of hardcoding page numbers to iterate over our API''s list of
    people, we''re creating a new Promise that uses our `fetchThis` function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试完整阅读`getPeople()`，以了解它的功能。其中一些是简单的操作，但`new Promise()`是这个函数的核心。我们不是在我们的API人员列表上硬编码页数来迭代，而是创建一个使用我们的`fetchThis`函数的新Promise：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In theory, we can use the same `fetchThis` function to get an individual person
    as well, once the button is clicked, but just for the sake of our example, this
    solution handles it all in one piece:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，一旦点击按钮，我们可以使用相同的`fetchThis`函数来获取单个人，但仅仅为了我们的示例，这个解决方案将所有内容都处理在一个地方：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, all that's needed is to instantiate our class!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需要实例化我们的类！
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At this point, our program is complete and will run! Visit the page and you'll
    see our fully operational page. Emperor Palpatine thanks you for your help eliminating
    the rebel scum. We have seen the power of classes, event-based programming, and
    our ability to use events to our benefits.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的程序已经完成并且可以运行！访问页面，您将看到我们的完全运行的页面。帝国皇帝感谢您帮助消灭叛军。我们已经看到了类、基于事件的编程以及我们利用事件的能力。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've learned about events, their life cycle, and how event-driven design works.
    An **event** is triggered by an action by the user (or programmatically based
    on the program logic) and enters its **life cycle**. In the event life cycle,
    our program can pick up on many pieces of information carried by the **event object**
    itself, such as the mouse position or target DOM node.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了事件、它们的生命周期以及事件驱动设计的工作原理。**事件**是由用户的动作（或基于程序逻辑的程序化触发）而触发的，并进入其**生命周期**。在事件生命周期中，我们的程序可以捕获事件对象本身携带的许多信息，例如鼠标位置或目标DOM节点。
- en: By understanding how Ajax works with events, you're well on your way toward
    becoming a fully fledged JavaScript developer. **Ajax** is incredibly important
    as its the conduit between JavaScript and external APIs. Since JavaScript is stateless
    and client-side JavaScript has no concept of sessions, it's important for Ajax
    calls to be **asynchronous** in nature; hence the introduction of tools such as
    `fetch`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解Ajax如何与事件配合工作，您已经在成为一个完全成熟的JavaScript开发人员的道路上迈出了重要的一步。**Ajax**非常重要，因为它是JavaScript和外部API之间的通道。由于JavaScript是无状态的，客户端JavaScript没有会话的概念，因此Ajax调用在性质上需要是**异步**的；因此引入了诸如`fetch`之类的工具。
- en: Congratulations! We've covered a lot of very dense material. Next up are frameworks
    and libraries in JavaScript.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经涵盖了很多非常密集的材料。接下来是JavaScript中的框架和库。
- en: Questions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to gauge your understanding of events:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以评估您对事件的理解：
- en: Which of these is the second phase of the event life cycle?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些中哪一个是事件生命周期的第二阶段？
- en: Capturing
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获
- en: Targeting
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标
- en: Bubbling
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冒泡
- en: 'The event object provides us with which of the following? – Select all that
    apply:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件对象为我们提供了以下哪些内容？- 选择所有适用的：
- en: The type of event triggered
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发的事件类型
- en: The target DOM node, if applicable
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标DOM节点，如果适用的话
- en: The mouse coordinates, if applicable
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鼠标坐标，如果适用的话
- en: The parent DOM node, if applicable
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父DOM节点，如果适用的话
- en: 'Look at this code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这段代码：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Which JavaScript features ae used in the preceding code? Select all that apply:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述代码中使用了哪些JavaScript特性？选择所有适用的：
- en: DOM manipulation
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DOM操作
- en: Event delegation
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件委托
- en: Event registration
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件注册
- en: Style changes
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样式更改
- en: What will happen when the container is clicked?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当容器被点击时会发生什么？
- en: '`box` will be visible.'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`box` 将可见。'
- en: '`#color` will be red.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#color` 将是红色。'
- en: Both 1 and 2.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1 和 2 都是。
- en: There is not enough context.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有足够的上下文。
- en: In which phase of the event life cycle do we typically take action?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件生命周期的哪个阶段我们通常采取行动？
- en: Targeting
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标
- en: Capturing
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获
- en: Bubbling
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冒泡
- en: Further reading
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*JavaScript: Understanding DOM Event Life Cycle*: [https://medium.com/prod-io/javascript-understanding-dom-event-life-cycle-49e1cf62b2ea](https://medium.com/prod-io/javascript-understanding-dom-event-life-cycle-49e1cf62b2ea)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript: 理解 DOM 事件生命周期*: [https://medium.com/prod-io/javascript-understanding-dom-event-life-cycle-49e1cf62b2ea](https://medium.com/prod-io/javascript-understanding-dom-event-life-cycle-49e1cf62b2ea)'
- en: 'w3schools.com – JavaScript events: [https://www.w3schools.com/js/js_events.asp](https://www.w3schools.com/js/js_events.asp)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'w3schools.com – JavaScript 事件: [https://www.w3schools.com/js/js_events.asp](https://www.w3schools.com/js/js_events.asp)'
- en: 'MDN – event reference: [https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MDN – 事件参考: [https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)'
