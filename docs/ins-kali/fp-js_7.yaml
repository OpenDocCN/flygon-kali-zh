- en: Chapter 7. Functional and Object-oriented Programming in JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。JavaScript中的函数式和面向对象编程
- en: You will often hear that JavaScript is a blank language, where blank is either
    object-oriented, functional, or general-purpose. This book has focused on JavaScript
    as a functional language and has gone to great lengths to prove that it is. But
    the truth is that JavaScript is a general-purpose language, meaning it's fully
    capable of multiple programming styles. Like Python and F#, JavaScript is multi-paradigm.
    But unlike those languages, JavaScript's OOP side is prototype-based while most
    other general-purpose languages are class-based.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会听到JavaScript是一种空白语言，其中空白可以是面向对象的、函数式的或通用的。本书将JavaScript作为一种函数式语言进行了重点研究，并且已经付出了很大的努力来证明它是这样的。但事实上，JavaScript是一种通用语言，意味着它完全能够支持多种编程风格。与Python和F#不同，JavaScript是多范式的。但与这些语言不同，JavaScript的OOP方面是基于原型的，而大多数其他通用语言是基于类的。
- en: 'In this final chapter, we will relate both functional and object-oriented programming
    to JavaScript, and see how the two paradigms can complement each other and coexist
    side-by-side. In this chapter the following topics will be covered:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把函数式和面向对象编程与JavaScript联系起来，看看这两种范式如何相辅相成，共存。本章将涵盖以下主题：
- en: How can JavaScript be both functional and OOP?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript如何既是函数式的又是面向对象的？
- en: JavaScript's OOP – using prototypes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript的OOP - 使用原型
- en: How to mix functional and OOP in JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在JavaScript中混合函数式和面向对象编程
- en: Functional inheritance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数继承
- en: Functional mixins
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式混入
- en: Better code is the goal. Functional and object-oriented programming are just
    means to this end.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的代码是目标。函数式和面向对象编程只是实现这一目标的手段。
- en: JavaScript – the multi-paradigm language
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript - 多范式语言
- en: If object-oriented programming means treating all variables as objects, and
    functional programming means treating all functions as variables, then can't functions
    be treated like objects? In JavaScript, they can.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果面向对象编程意味着将所有变量视为对象，而函数式编程意味着将所有函数视为变量，那么函数不能被视为对象吗？在JavaScript中，它们可以。
- en: 'But saying that functional programming means treating functions as variables
    is somewhat inaccurate. A better way to put it is: functional programming means
    treating everything as a value, especially functions.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但说函数式编程意味着将函数视为变量有些不准确。更好的说法是：函数式编程意味着将一切都视为值，尤其是函数。
- en: A better way still to describe functional programming may be to call it declarative.
    Independent of the imperative branch of programming styles, *declarative programming*
    expresses the logic of computation required to solve the problem. The computer
    is told what the problem is rather than the procedure for how to solve it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 描述函数式编程的更好方式可能是将其称为声明式。与命令式编程风格无关，*声明式编程*表达了解决问题所需的计算逻辑。计算机被告知问题是什么，而不是如何解决它的过程。
- en: 'Meanwhile, object-oriented programming is derived from the imperative programming
    style: the computer is given step-by-step instructions for how to solve the problem.
    OOP mandates that the instructions for computation (methods) and the data they
    work on (member variables) be organized into units called objects. The only way
    to access that data is through the object''s methods.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，面向对象编程源自命令式编程风格：计算机会得到解决问题的逐步说明。OOP要求计算的说明（方法）和它们操作的数据（成员变量）被组织成称为对象的单元。访问数据的唯一方式是通过对象的方法。
- en: So how can these two styles be integrated together?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这两种风格如何集成在一起呢？
- en: The code inside the object's methods is typically written in an imperative style.
    But what if it was in a functional style? After all, OOP doesn't exclude immutable
    data and higher-order functions.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象方法中的代码通常以命令式风格编写。但如果以函数式风格呢？毕竟，OOP并不排斥不可变数据和高阶函数。
- en: Perhaps a purer way to mix the two would be to treat objects both as functions
    and as traditional, class-based objects at the same time.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许更纯粹的混合方式是同时将对象视为函数和传统的基于类的对象。
- en: Maybe we can simply include several ideas from functional programming—such as
    promises and recursion—into our object-oriented application.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也许我们可以简单地在面向对象的应用程序中包含一些函数式编程的思想，比如承诺和递归。
- en: OOP covers topics such as encapsulation, polymorphism, and abstraction. So does
    functional programming, it just goes about it in a different way. So maybe we
    can include several ideas from object-oriented programming in our functional-oriented
    application.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OOP涵盖了封装、多态和抽象等主题。函数式编程也涵盖了这些主题，只是它采用了不同的方式。也许我们可以在面向函数的应用程序中包含一些面向对象编程的思想。
- en: 'The point is: OOP and FP can be mixed together and there are several ways to
    do it. They''re not exclusive of each other.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是：OOP和FP可以混合在一起，有几种方法可以做到这一点。它们并不互斥。
- en: JavaScript's object-oriented implementation – using prototypes
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript的面向对象实现 - 使用原型
- en: JavaScript is a class-less language. That's not to mean it is less fashionable
    or more blue-collar than other computer languages; class-less means it doesn't
    have a class structure in the same way that object-oriented languages do. Instead,
    it uses prototypes for inheritance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种无类语言。这并不意味着它比其他计算机语言更时尚或更蓝领；无类意味着它没有类结构，就像面向对象的语言那样。相反，它使用原型进行继承。
- en: 'Although this may be baffling to programmers with backgrounds in C++ and Java,
    prototype-based inheritance can be much more expressive than traditional inheritance.
    The following is a brief comparison between the differences between C++ and JavaScript:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这可能让有C++和Java背景的程序员感到困惑，基于原型的继承比传统继承更具表现力。以下是C++和JavaScript之间差异的简要比较：
- en: '| C++ | JavaScript |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| C++ | JavaScript |'
- en: '| --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Strongly typed | Loosely typed |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 强类型 | 弱类型 |'
- en: '| Static | Dynamic |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 静态 | 动态 |'
- en: '| Class-based | Prototype-based |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 基于类 | 基于原型 |'
- en: '| Classes | Functions |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 函数 |'
- en: '| Constructors | Functions |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 构造函数 | 函数 |'
- en: '| Methods | Functions |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 函数 |'
- en: Inheritance
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: 'Before we go much further, let''s make sure we fully understand the concept
    of inheritance in object-oriented programming. Class-based inheritance is demonstrated
    in the following pseudo-code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步讨论之前，让我们确保我们充分理解面向对象编程中的继承概念。基于类的继承在以下伪代码中得到了展示：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Polygon` class is the parent class the other classes inherit from. It defines
    just one member variable, the number of sides, which is set in the `init()` function.
    The `Rectangle` subclass inherits from the `Polygon` class and adds two more member
    variables, `length` and `width`, and a method, `getArea()`. It doesn't need to
    define the `numSides` variable because it was already defined by the class it
    inherits from, and it also overrides the `init()` function. The `Square` class
    carries on this chain of inheritance even further by inheriting from the `Rectangle`
    class for its `getArea()` method. By simply overriding the `init()` function again
    such that the length and width are the same, the `getArea()` function can remain
    unchanged and less code needs to be written.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polygon`类是其他类继承的父类。它只定义了一个成员变量，即边数，该变量在`init()`函数中设置。`Rectangle`子类继承自`Polygon`类，并添加了两个成员变量`length`和`width`，以及一个方法`getArea()`。它不需要定义`numSides`变量，因为它已经被继承的类定义了，并且它还覆盖了`init()`函数。`Square`类通过从`Rectangle`类继承其`getArea()`方法进一步延续了这种继承链。通过简单地再次覆盖`init()`函数，使长度和宽度相同，`getArea()`函数可以保持不变，从而需要编写的代码更少。'
- en: In a traditional OOP language, this is what inheritance is all about. If we
    wanted to add a color property to all the objects, all we would have to do is
    add it to the `Polygon` object without having to modify any of the objects that
    inherit from it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的面向对象编程语言中，这就是继承的全部含义。如果我们想要向所有对象添加一个颜色属性，我们只需将其添加到`Polygon`对象中，而无需修改任何继承自它的对象。
- en: JavaScript's prototype chain
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript的原型链
- en: 'Inheritance in JavaScript comes down to prototypes. Each object has an internal
    property known as its prototype, which is a link to another object. That object
    has a prototype of its own. This pattern can repeat until an object is reached
    that has `undefined` as its prototype. This is known as the prototype chain, and
    it''s how inheritance works in JavaScript. The following diagram explain the inheritance
    in JavaScirpt:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的继承归结为原型。每个对象都有一个名为其原型的内部属性，它是指向另一个对象的链接。该对象本身也有自己的原型。这种模式可以重复，直到达到一个具有`undefined`作为其原型的对象。这就是原型链，这就是JavaScript中继承的工作原理。以下图解释了JavaScript中的继承：
- en: '![JavaScript''s prototype chain](../images/00011.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![JavaScript的原型链](../images/00011.jpeg)'
- en: When running a search for an object's function definition, JavaScript "walks"
    the prototype chain until it finds the first definition of a function with the
    right name. Therefore, overriding it is as simple as providing a new definition
    on the prototype of the subclass.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索对象的函数定义时，JavaScript会“遍历”原型链，直到找到具有正确名称的函数的第一个定义。因此，覆盖它就像在子类的原型上提供一个新定义一样简单。
- en: Inheritance in JavaScript and the Object.create() method
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript中的继承和`Object.create()`方法
- en: Just as there are many ways to create objects in JavaScript, there are also
    many ways to replicate class-based, classical inheritance. But the one preferred
    way to do it is with the `Object.create()` method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像有许多方法可以在JavaScript中创建对象一样，也有许多方法可以复制基于类的经典继承。但做这件事的首选方法是使用`Object.create()`方法。
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This syntax may seem unusual to many but, with a little practice, it will become
    familiar. The `prototype` keyword must be used to gain access to the internal
    property, `[[Prototype]]`, which all objects have. The `Object.create()` method
    declares a new object with a specified object for its prototype to inherit from.
    In this way, classical inheritance can be achieved in JavaScript.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法对许多人来说可能看起来不寻常，但经过一点练习，它将变得熟悉。必须使用`prototype`关键字来访问所有对象都具有的内部属性`[[Prototype]]`。`Object.create()`方法声明一个新对象，该对象继承自指定的对象原型。通过这种方式，可以在JavaScript中实现经典继承。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Object.create()` method was introduced in ECMAScript 5.1 in 2011, and it
    was billed as the new and preferred way to create objects. This was just one of
    many attempts to integrate inheritance into JavaScript. Thankfully, this method
    works pretty well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.create()`方法在2011年的ECMAScript 5.1中引入，并被宣传为创建对象的新方法。这只是JavaScript整合继承的众多尝试之一。幸运的是，这种方法运行得相当好。'
- en: We saw this structure of inheritance when building the `Maybe` classes in [Chapter
    5](part0032_split_000.html#page "Chapter 5. Category Theory"), *Category Theory*.
    Here are the `Maybe`, `None`, and `Just` classes, which inherit from each other
    just like the preceding example.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建[第5章](part0032_split_000.html#page "第5章。范畴论")*范畴论*中的`Maybe`类时，我们看到了这种继承结构，`Maybe`、`None`和`Just`类，它们彼此之间也是继承关系。
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This shows that class inheritance in JavaScript can be an enabler of functional
    programming.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明JavaScript中的类继承可以成为函数式编程的一种实现方式。
- en: A common mistake is to pass a constructor into `Object.create()` instead of
    a `prototype` object. This problem is compounded by the fact that an error will
    not be thrown until the subclass tries to use an inherited member function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是将构造函数传递给`Object.create()`而不是`prototype`对象。这个问题的复杂性在于，直到子类尝试使用继承的成员函数时才会抛出错误。
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function won't be found if the `inheritedMethod()` method has been attached
    to the `Foo.prototype` class. If the `inheritedMethod()` method is attached directly
    to the instance with `this.inheritedMethod = function(){...}` in the `Bar` constructor,
    then this use of `Parent` as an argument of `Object.create()`could be correct.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`inheritedMethod()`方法已经附加到`Foo.prototype`类，则无法找到该函数。如果`inheritedMethod()`方法直接附加到实例上，即在`Bar`构造函数中使用`this.inheritedMethod
    = function(){...}`，那么`Object.create()`中使用`Parent`作为参数可能是正确的。
- en: Mixing functional and object-oriented programming in JavaScript
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JavaScript中混合函数式和面向对象编程
- en: 'Object-oriented programming has been the dominant programming paradigm for
    several decades. It is taught in Computer Science 101 classes around the world,
    while functional programming is not. It is what software architects use to design
    applications, while functional programming is not. And it makes sense too: OOP
    makes it easy to conceptualize abstract ideas. It makes it easier to write code.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程已经是主导的编程范式数十年了。它在世界各地的计算机科学101课程中被教授，而函数式编程则没有。软件架构师用它来设计应用程序，而函数式编程则没有。这也是有道理的：面向对象编程使得抽象思想更容易理解。它使编写代码更容易。
- en: So, unless you can convince your boss that the application needs to be all functional,
    we're going to be using functional programming in an object-oriented world. This
    section will explore ways to do this.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，除非你能说服你的老板应用程序需要全部是函数式的，否则我们将在面向对象的世界中使用函数式编程。本节将探讨如何做到这一点。
- en: Functional inheritance
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式继承
- en: Perhaps the most accessible way to apply functional programming to JavaScript
    applications is to use a mostly functional style within OOP principles, such as
    inheritance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数式编程应用于JavaScript应用程序的最直接方式可能是在面向对象编程原则内使用大部分函数式风格，比如继承。
- en: 'To explore how this might work, let''s build a simple application that calculates
    the price of a product. First, we''ll need some product classes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这可能如何工作，让我们构建一个简单的应用程序来计算产品的价格。首先，我们需要一些产品类：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can then organize them within a `Store` class as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在`Store`类中组织它们如下：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `calculateTotal()` method uses the array's `reduce()` function to cleanly
    sum together the prices of the products.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateTotal()`方法使用数组的`reduce()`函数来干净地将产品的价格相加。'
- en: This works just fine, but what if we need a dynamic way to calculate the markup
    value? For this, we can turn to a concept called **Strategy Pattern**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做完全没问题，但如果我们需要一种动态计算标记值的方法呢？为此，我们可以转向一个称为**策略模式**的概念。
- en: Strategy Pattern
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略模式
- en: 'Strategy Pattern is a method for defining a family of interchangeable algorithms.
    It is used by OOP programmers to manipulate behavior at runtime, but it is based
    on a few functional programming principles:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式是一种定义一组可互换算法的方法。它被面向对象编程程序员用于在运行时操纵行为，但它基于一些函数式编程原则。
- en: Separation of logic and data
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑和数据的分离
- en: Composition of functions
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的组合
- en: Functions as first-class objects
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为一等对象
- en: 'And a couple of OOP principles as well:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些面向对象编程的原则：
- en: Encapsulation
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Inheritance
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: In our example application for calculating product cost, explained previously,
    let's say we want to give preferential treatment to certain customers, and that
    the markup will have to be adjusted to reflect this.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前解释的用于计算产品成本的示例应用中，假设我们想要给予某些客户优惠待遇，并且需要调整标记来反映这一点。
- en: 'So let''s create some customer classes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们创建一些客户类：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each `Customer` class encapsulates the algorithm. Now we just need the `Store`
    class to call the `Customer` class's `calculateTotal()` method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Customer`类封装了算法。现在我们只需要`Store`类调用`Customer`类的`calculateTotal()`方法。
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Customer` classes do the calculating, the `Product` classes hold the data
    (the prices), and the `Store` class maintains the context. This achieves a very
    high level of cohesion and a very good mixture of object-oriented programming
    and functional programming. JavaScript's high level of expressiveness makes this
    possible and quite easy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Customer`类进行计算，`Product`类保存数据（价格），`Store`类维护上下文。这实现了非常高的内聚性和面向对象编程与函数式编程的很好的混合。JavaScript的高表现力使这成为可能，而且相当容易。'
- en: Mixins
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mixins
- en: In a nutshell, mixins are classes that can allow other classes to use their
    methods. The methods are intended to be used solely by other classes, and the
    `mixin` class itself is never to be instantiated. This helps to avoid inheritance
    ambiguity. And they're a great means of mixing functional programming with object-oriented
    programming.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，mixins是允许其他类使用它们的方法的类。这些方法仅供其他类使用，而`mixin`类本身永远不会被实例化。这有助于避免继承的模糊性。它们是将函数式编程与面向对象编程混合的绝佳手段。
- en: Mixins are implemented differently in each language. Thanks to JavaScript's
    flexibility and expressiveness, mixins are implemented as objects with only methods.
    While they can be defined as function objects (that is, `var mixin = function(){...};`),
    it would be better for the structural discipline of the code to define them as
    object literals (that is, `var mixin = {...};`). This will help us to distinguish
    between classes and mixins. After all, mixins should be treated as processes,
    not objects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每种语言中的mixin实现方式都不同。由于JavaScript的灵活性和表现力，mixins被实现为只有方法的对象。虽然它们可以被定义为函数对象（即`var
    mixin = function(){...};`），但最好将它们定义为对象字面量（即`var mixin = {...};`）以保持代码的结构纪律。这将帮助我们区分类和mixins。毕竟，mixins应该被视为过程，而不是对象。
- en: Let's start with declaring some mixins. We'll extend our `Store` application
    from the previous section, using mixins to expand on the classes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从声明一些mixins开始。我们将扩展我们之前部分的`Store`应用程序，使用mixins来扩展类。
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''re not limited to just this. Many more mixins can be added, like colors
    or fabric material. We''ll have to rewrite our `Shirt` classes a little bit, as
    shown in the following code snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅仅局限于这些。还可以添加许多其他的mixins，比如颜色或面料材质。我们需要稍微修改我们的`Shirt`类，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we're ready to use mixins.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用mixins了。
- en: Classical mixins
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经典mixin
- en: 'You''re probably wondering just how these mixins get mixed with the classes.
    The classical way to do this is by copying the mixin''s functions into the receiving
    object. This can be done with the following extension to the `Shirt` prototype:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这些mixin是如何与类混合在一起的。这样做的经典方式是将mixin的函数复制到接收对象中。可以通过以下方式扩展`Shirt`原型来实现：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And now the mixins can be added as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以添加mixins如下：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: However, there is a major problem. When the price of `p1` is calculated again,
    it comes back as `15`, the price of a large item. It should be the value for a
    small one!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一个主要问题。当再次计算`p1`的价格时，结果是`15`，即大件物品的价格。它应该是小件物品的价格！
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The problem is that the `Shirt` object's `prototype.getPrice()` method is getting
    rewritten every time a mixin is added to it; this is not very functional at all
    and not what we want.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`Shirt`对象的`prototype.getPrice()`方法每次添加混入时都会被重写；这根本不是我们想要的函数式编程。
- en: Functional mixins
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式混入
- en: There's another way to use mixins, one that is more aligned with functional
    programming.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种使用混入的方法，更符合函数式编程。
- en: Instead of copying the methods of the mixin to the target object, we need to
    create a new object that is a clone of the target object with the mixin's methods
    added in. The object must be cloned first, and this is achieved by creating a
    new object that inherits from it. We'll call this variation `plusMixin`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是将混入的方法复制到目标对象，而是需要创建一个新对象，该对象是目标对象的克隆，并添加了混入的方法。首先必须克隆对象，这可以通过创建一个继承自它的新对象来实现。我们将这个变体称为`plusMixin`。
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here comes the fun part! Now we can get really functional with the mixins. We
    can create every possible combination of products and mixins.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就来玩乐趣部分！现在我们可以真正地使用混入进行函数式编程。我们可以创建产品和混入的每种可能的组合。
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To make it more object-oriented, we can rewrite the `Store` object with this
    functionality. We'll also add a display function to the `Store` object, not the
    products, to keep the interface logic and the data separated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更加面向对象，我们可以重写`Store`对象以具有此功能。我们还将在`Store`对象而不是产品中添加一个显示函数，以保持接口逻辑和数据的分离。
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And all we have to do is create a `Store` object and call its `displayProducts()`
    method to generate a list of products and prices!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所要做的就是创建一个`Store`对象并调用它的`displayProducts()`方法来生成产品和价格的列表！
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These lines need to be added to the `product` classes and mixins to get the
    preceding output to work:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行需要添加到`product`类和混入中，以使前面的输出正常工作：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And, just like that, we have an e-commerce application that is highly modular
    and extendable. New shirt styles can be added absurdly easily—just define a new
    `Shirt` subclass and add to it the `Store` class's array `product` classes. Mixins
    are added in just the same way. So now when our boss says, "Hey, we have a new
    type of shirt and a coat, each available in the standard colors, and we need them
    added to the website before you go home today", we can rest assured that we'll
    not be staying late!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们拥有了一个高度模块化和可扩展的电子商务应用。新的衬衫款式可以非常容易地添加——只需定义一个新的`Shirt`子类，并将其添加到`Store`类的数组`product`类中。混入的添加方式也是一样的。所以现在当我们的老板说：“嘿，我们有一种新类型的衬衫和外套，每种都有标准颜色，我们需要在你今天下班前将它们添加到网站上”，我们可以放心地说我们不会加班了！
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: JavaScript has a high level of expressiveness. This makes it possible to mix
    functional and object-oriented programming. Modern JavaScript is not solely OOP
    or functional—it is a mixture of the two. Concepts such as Strategy Pattern and
    mixins are perfect for JavaScript's prototype structure, and they help to prove
    that today's best practices in JavaScript share equal amounts of functional programming
    and object-oriented programming.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript具有很高的表现力。这使得将函数式编程和面向对象编程混合使用成为可能。现代JavaScript不仅仅是面向对象编程或函数式编程，它是两者的混合体。诸如策略模式和混入之类的概念非常适合JavaScript的原型结构，并且它们有助于证明当今JavaScript最佳实践中函数式编程和面向对象编程的使用量是相等的。
- en: If you were to take away only one thing from this book, I would want it to be
    how to apply functional programming techniques to real-world applications. And
    this chapter showed you how to do exactly that.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从这本书中只学到了一件事，我希望是如何将函数式编程技术应用到现实应用中。本章向你展示了如何做到这一点。
- en: Appendix A. Common Functions for Functional Programming in JavaScript
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. JavaScript中函数式编程的常见函数
- en: 'This Appendix covers common functions for functional programming in JavaScript:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个附录涵盖了JavaScript中函数式编程的常见函数：
- en: 'Array Functions:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组函数：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Binding Functions:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定函数：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Category Theory:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范畴论：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Composition:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Currying:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Functors:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Lenses:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜头：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Maybes:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maybes：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Mixins:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混入：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Partial Application:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分应用：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Trampolining:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Trampolining：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Type Safeties:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型安全：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Y-combinator:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Y组合子：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Appendix B. Glossary of Terms
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B. 术语表
- en: 'This appendix covers some of the important terms that are used in this book:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个附录涵盖了本书中使用的一些重要术语：
- en: '**Anonymous function**: A function that has no name and is not bound to any
    variables. It is also known as a Lambda Expression.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数：没有名称且未绑定到任何变量的函数。也称为Lambda表达式。
- en: '**Callback**: A function that can be passed to another function to be used
    in a later event.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调：可以传递给另一个函数以在以后的事件中使用的函数。
- en: '**Category**: In terms of Category Theory, a category is a collection of objects
    of the same type. In JavaScript, a category can be an array or object that contains
    objects that are all explicitly declared as numbers, strings, Booleans, dates,
    objects, and so on.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范畴：在范畴论中，范畴是相同类型的对象集合。在JavaScript中，范畴可以是包含明确定义为数字、字符串、布尔值、日期、对象等的对象的数组或对象。
- en: '**Category Theory**: A concept that organizes mathematical structures into
    collections of objects and operations on those objects. The data types and functions
    used in computer programs form the categories used in this book.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范畴论：一种将数学结构组织成对象集合和对这些对象的操作的概念。本书中使用的计算机程序中的数据类型和函数形成了这些范畴。
- en: '**Closure**: An environment such that functions defined within it can access
    local variables that are not available outside it.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包：一种环境，使得其中定义的函数可以访问外部不可用的局部变量。
- en: '**Coupling**: The degree to which each program module relies on each of the
    other modules. Functional programming reduces the amount of coupling within a
    program.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 耦合：每个程序模块依赖于其他模块的程度。函数式编程减少了程序内部的耦合程度。
- en: '**Currying**: The process of transforming a function with many arguments into
    a function with one argument that returns another function that can take more
    arguments, as needed. Formally, a function with *N* arguments can be transformed
    into a function chain of *N* functions, each with only one argument.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Currying**：将具有多个参数的函数转换为一个参数的函数的过程，返回另一个可以根据需要接受更多参数的函数。形式上，具有*N*个参数的函数可以转换为*N*个函数的函数链，每个函数只有一个参数。'
- en: '**Declarative programming**: A programming style that expresses the computational
    logic required to solve the problem. The computer is told what the problem is
    rather than the procedure required to solve it.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Declarative programming**：一种表达解决问题所需的计算逻辑的编程风格。计算机被告知问题是什么，而不是解决问题所需的过程。'
- en: '**Endofunctor**: A functor that maps a category to itself.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Endofunctor**：将一个范畴映射到自身的函子。'
- en: '**Function composition**: The process of combining many functions into one
    function. The result of each function is passed as an argument to the next, and
    the result of the last function is the result of the whole composition.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Function composition**：将许多函数组合成一个函数的过程。每个函数的结果作为下一个参数传递，最后一个函数的结果是整个组合的结果。'
- en: '**Functional language**: A computer language that facilitates functional programming.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Functional language**：促进函数式编程的计算机语言。'
- en: '**Functional programming**: A declarative programming paradigm that focuses
    on treating functions as mathematical expressions and avoids mutable data and
    changes in state.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Functional programming**：一种声明式编程范式，侧重于将函数视为数学表达式，并避免可变数据和状态变化。'
- en: '**Functional reactive programming**: A style of functional programming that
    focuses on reactive elements and variables that change over time in response to
    events.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Functional reactive programming**：一种侧重于响应式元素和随时间变化的变量的函数式编程风格。'
- en: '**Functor**: A mapping between categories.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Functor**：范畴之间的映射。'
- en: '**Higher-order function**: A function that takes either one or more functions
    as input, and returns a function as its output.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Higher-order function**：以一个或多个函数作为输入，并返回一个函数作为输出的函数。'
- en: '**Inheritance**: An object-oriented programming capability that allows one
    class to inherit member variables and methods from another class.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Inheritance**：一种面向对象编程的能力，允许一个类从另一个类继承成员变量和方法。'
- en: '**Lambda expressions**: See Anonymous function.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lambda expressions**：参见匿名函数。'
- en: '**Lazy evaluation**: A computer language evaluation strategy that delays the
    evaluation of an expression until its value is needed. The opposite of this strategy
    is called eager evaluation or greedy evaluation. Lazy evaluation is also known
    as call by need.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lazy evaluation**：一种计算机语言的评估策略，延迟对表达式的评估，直到需要其值。这种策略的相反称为急切评估或贪婪评估。惰性评估也被称为按需调用。'
- en: '**Library**: A set of objects and functions that have a well-defined interface
    that allows a third-party program to invoke their behavior.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Library**：一组具有明确定义接口的对象和函数，允许第三方程序调用它们的行为。'
- en: '**Memoization**: The technique of storing the results of expensive function
    calls. When the function is called later with the same arguments, the stored result
    is returned rather than computing the result again.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Memoization**：存储昂贵函数调用的结果的技术。当以相同参数再次调用函数时，返回存储的结果，而不是重新计算结果。'
- en: '**Method chain**: A pattern in which many methods are invoked side by side
    by directly passing the output of one method to the input of the next. This avoids
    the need to assign the intermediary values to temporary variables.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Method chain**：一种模式，其中许多方法并排调用，直接将一个方法的输出传递给下一个方法的输入。这避免了将中间值分配给临时变量的需要。'
- en: '**Mixin**: An object that can allow other objects to use its methods. The methods
    are intended to be used solely by other objects, and the mixin object itself is
    never to be instantiated.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mixin**：一个对象，可以让其他对象使用它的方法。这些方法只能被其他对象使用，而mixin对象本身永远不会被实例化。'
- en: '**Modularity**: The degree to which a program can be broken down into independent
    modules of code. Functional programming increases the modularity of programs.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Modularity**：程序可以被分解为独立的代码模块的程度。函数式编程增加了程序的模块化。'
- en: '**Monad**: A structure that provides the encapsulation required by functors.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Monad**：提供函子所需的封装的结构。'
- en: '**Morphism**: A pure function that only works on a certain category and always
    returns the same output when given a specific set of inputs. Homomorphic operations
    are restricted to a single category, while polymorphic operations can operate
    on multiple categories.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Morphism**：仅在特定范畴上工作并在给定特定输入集时始终返回相同输出的纯函数。同态操作受限于单一范畴，而多态操作可以在多个范畴上操作。'
- en: '**Partial application**: The process of binding values to one or more arguments
    of a function. It returns a partially applied function, which in turn accepts
    the remaining, unbound arguments.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Partial application**：将一个或多个参数的值绑定到函数的过程。它返回一个部分应用的函数，该函数反过来接受剩余的未绑定参数。'
- en: '**Polyfill**: A function used to augment prototypes with new functions. It
    allows us to call our new functions as methods of the previous function.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Polyfill**：用于用新函数增强原型的函数。它允许我们将新函数作为先前函数的方法来调用。'
- en: '**Pure function**: A function whose output value depends only on the arguments
    that are the input to the function. Thus, calling a function, *f*, twice with
    the same value of an argument, *x*, will produce the same result, *f(x)*,every
    time.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pure function**：其输出值仅取决于作为函数输入的参数的函数。因此，用相同值的参数*x*两次调用函数*f*，每次都会产生相同的结果*f(x)*。'
- en: '**Recursive function**: A function that calls itself. Such functions depend
    on solutions to smaller instances of the same problem to compute the solution
    to the larger problem. Like iteration, recursion is another way to repeatedly
    call the same block of code. But, unlike iteration, recursion requires that the
    code block define the case in which the repeating code calls should terminate,
    known as the base case.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**递归函数**：调用自身的函数。这样的函数依赖于解决同一问题的较小实例来计算较大问题的解决方案。与迭代类似，递归是重复调用相同代码块的另一种方式。但是，与迭代不同，递归要求代码块定义重复调用应该终止的情况，即基本情况。'
- en: '**Reusability**: The degree to which a block of code, usually a function in
    JavaScript, can be reused in other parts of the same program or in other programs.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：通常是指代码块（通常是JavaScript中的函数）可以在同一程序的其他部分或其他程序中被重复使用的程度。'
- en: '**Self-invoking function**: An anonymous function that is invoked immediately
    after it has been defined. In JavaScript, this is achieved by placing a pair of
    parentheses after the function expression.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自执行函数**：在定义后立即被调用的匿名函数。在JavaScript中，通过在函数表达式后放置一对括号来实现这一点。'
- en: '**Strategy pattern**: A method used to define a family of interchangeable algorithms.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略模式**：用于定义一组可互换算法的方法。'
- en: '**Tail recursion**: A stack-based implementation of recursion. For every recursive
    call, there is a new frame in the stack.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尾递归**：基于堆栈的递归实现。对于每个递归调用，堆栈中都有一个新的帧。'
- en: '**Toolkit**: A small software library that provides a set of functions for
    the programmer to use. Compared to a library, a toolkit is simpler and requires
    less coupling with the program that invokes it.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具包**：一个小型软件库，提供一组函数供程序员使用。与库相比，工具包更简单，需要与调用它的程序耦合更少。'
- en: '**Trampolining**: A strategy for recursion that provides tail-call elimination
    in programming languages that do not provide this feature, such as JavaScript.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蹦床编程**：一种递归策略，可以在不提供尾调用消除功能的编程语言中实现，比如JavaScript。'
- en: '**Y-combinator**: A fixed-point combinator in Lambda calculus that eliminates
    explicit recursion. When it is given as input to a function that returns a recursive
    function, the Y-combinator returns the fixed point of that function, which is
    the transformation from the recursive function to a non-recursive function.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Y组合子**：Lambda演算中的固定点组合子，消除了显式递归。当它作为返回递归函数的输入时，Y组合子返回该函数的不动点，即将递归函数转换为非递归函数的转换。'
