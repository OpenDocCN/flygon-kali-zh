- en: Chapter 10. Messaging Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 消息模式
- en: When Smalltalk, the first real object oriented programming language, was first
    developed, the communication between classes was envisioned as being messages.
    Somehow we've moved away from this pure idea of messages. We spoke a bit about
    how functional programming avoids side effects, well, much the same is true of
    messaging-based systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当Smalltalk，第一个真正的面向对象的编程语言，首次开发时，类之间的通信被设想为消息。不知何故，我们已经偏离了这个纯粹的消息理念。我们已经谈到了函数式编程如何避免副作用，同样的情况也适用于基于消息的系统。
- en: Messaging also allows for impressive scalability as messages can be fanned out
    to dozens, or even hundreds, of computers. Within a single application, messaging
    promotes low-coupling and eases testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递还可以实现令人印象深刻的可伸缩性，因为消息可以传播到数十甚至数百台计算机。在单个应用程序中，消息传递促进了低耦合和简化测试。
- en: In this chapter we're going to look at a number of patterns related to messaging.
    By the end of the chapter you should be aware of how messages work. When I first
    learned about messaging I wanted to rewrite everything using it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究与消息传递相关的一些模式。在本章结束时，您应该了解消息的工作原理。当我第一次了解消息传递时，我想用它重写一切。
- en: 'We will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: What's a message anyway?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息到底是什么？
- en: Commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Request-reply
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求-回复
- en: Publish-subscribe
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布-订阅
- en: Fan out
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扇出
- en: Dead letter queues
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死信队列
- en: Message replay
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息重播
- en: Pipes and filters
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道和过滤器
- en: What's a message anyway?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息到底是什么？
- en: 'In the simplest definition a message is a collection of related bits of data
    that have some meaning together. The message is named in a way that provides some
    additional meaning to it. For instance, both an `AddUser` and a `RenameUser` message
    might have the following fields:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的定义中，消息是一组相关的数据位，它们一起具有某种含义。消息的命名方式提供了一些额外的含义。例如，`AddUser`和`RenameUser`消息可能具有以下字段：
- en: User ID
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户ID
- en: Username
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: But the fact that the fields exist inside a named container gives them different
    meaning.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但事实上，字段存在于一个命名的容器内，这使它们具有不同的含义。
- en: Messages are usually related to some action in the application or some action
    in the business. A message contains all the information needed for a receiver
    to act upon the action. In the case of the `RenameUser` message, the message contains
    enough information for any component that keeps track of a relationship between
    a user ID and a username to update its value for username.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 消息通常与应用程序中的某个操作或业务中的某个操作相关。消息包含了接收者执行该操作所需的所有信息。在`RenameUser`消息的情况下，消息包含了足够的信息，以便于任何一个跟踪用户ID和用户名之间关系的组件更新其用户名的值。
- en: 'Many messaging systems, especially those that communicate between application
    boundaries, also define an **envelope**. The envelope has metadata on it that
    could help with message auditing, routing, and security. The information on the
    envelope is not part of the business process but is part of the infrastructure.
    So having a security annotation on the envelope is fine, as security exists outside
    of the normal business workflow and is owned by a different part of the application.
    The contents on the envelope look like the one shown in the following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多消息系统，特别是在应用程序边界之间通信的系统，还定义了一个**信封**。信封上有元数据，可以帮助进行消息审计、路由和安全性。信封上的信息不是业务流程的一部分，而是基础设施的一部分。因此，在信封上有安全注释是可以的，因为安全性存在于正常业务工作流程之外，并由应用程序的不同部分拥有。信封上的内容看起来像下图所示的内容：
- en: '![What''s a message anyway?](img/00081.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![消息到底是什么？](img/00081.jpeg)'
- en: Messages should be sealed so that no changes can be made to them once they have
    been created. This makes certain operations like auditing and replaying much easier.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 消息应该被封闭，这样一旦创建就不能对它们进行更改。这使得诸如审计和重播等操作变得更加容易。
- en: Messaging can be used to communicate inside a single process or it can be used
    between applications. For the most part there is no difference to sending a message
    within an application and between applications. One difference is the treatment
    of synchronicity. Within a single process, messages can be handled in a synchronous
    fashion. This means that the main processing effectively waits for the handling
    of the message to complete before continuing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 消息可以用于在单个进程内部通信，也可以用于应用程序之间的通信。在大多数情况下，在应用程序内部和应用程序之间发送消息没有区别。一个区别是同步处理的方式。在单个进程内部，消息可以以同步方式处理。这意味着主要处理在处理消息完成之前会等待。
- en: In an asynchronous scenario, the handling of the message may occur at a later
    date. Sometimes the later date is far in the future. When calling out to an external
    server, asynchronous will certainly be the correct approach – this is due to the
    inherit latency associated with network I/O. Even within a single process, the
    single threaded nature of JavaScript encourages using asynchronous messaging.
    While using asynchronous messaging, some additional care and attention needs to
    be taken as some of the assumptions made for synchronous messaging cease to be
    safe. For instance, assuming the messages will be replied to in the same order
    in which they were sent is no longer safe.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步场景中，消息的处理可能会在以后的某个日期发生。有时，这个以后的日期可能是遥远的未来。当调用外部服务器时，异步肯定是正确的方法——这是由于与网络I/O相关的固有延迟。即使在单个进程中，JavaScript的单线程特性也鼓励使用异步消息传递。在使用异步消息传递时，需要额外的注意和关注，因为一些针对同步消息传递所做的假设不再安全。例如，假设消息将按照发送的顺序进行回复不再安全。
- en: 'There are two different flavors of messages: commands and events. Commands
    instruct things to happen while events notify about something which has happened.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 消息有两种不同的类型：命令和事件。命令指示要发生的事情，而事件通知发生了什么事情。
- en: Commands
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令
- en: A command is simply an instruction from one part of a system to another. It
    is a message so it is really just a simple data transfer object. If you think
    back to the command pattern introduced in [Chapter 5](part0111_split_000.html#39REE1-015e68c68a464f18a9559f448be84435
    "Chapter 5. Behavioral Patterns"), *Behavioral Patterns*, this is exactly what
    it uses.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 命令只是系统中的一部分向另一部分发出的指令。它是一条消息，因此实际上只是一个简单的数据传输对象。如果您回想一下在[第5章](part0111_split_000.html#39REE1-015e68c68a464f18a9559f448be84435
    "第5章。行为模式")中介绍的命令模式，*行为模式*，这正是它所使用的。
- en: As a matter of convention, commands are named using the imperative. The format
    is usually `<verb><object>`. Thus a command might be called `InvadeCity`. Typically,
    when naming a command, you want to avoid generic names and focus on exactly what
    is causing the command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种惯例，命令使用命令式命名。格式通常是`<动词><对象>`。因此，一个命令可能被称为`InvadeCity`。通常，在命名命令时，您要避免使用通用名称，而要专注于确切导致命令的原因。
- en: As an example, consider a command that changes the address of a user. You might
    be tempted to simply call the command `ChangeAddress` but doing so does not add
    any additional information. It would be better to dig deeper and see why the address
    is being changed. Did the person move or was the original address entered incorrectly?
    Intent is as important as the actual data changes. For instance, altering an address
    due to a mistake might trigger a different behavior from a person who has moved.
    Users that have moved could be sent a moving present, while those correcting their
    address would not.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个更改用户地址的命令。您可能会简单地将命令称为`ChangeAddress`，但这样做并不会增加任何额外的信息。更好的做法是深入挖掘并了解为什么要更改地址。是因为人搬家了还是原始地址输入错误了？意图和实际数据更改一样重要。例如，由于错误更改地址可能会触发不同的行为，而搬家的用户可能会收到搬家礼物，而更正地址的用户则不会。
- en: Messages should have a component of business meaning to increase their utility.
    Defining messages and how they can be constructed within a complex business is
    a whole field of study on its own. Those interested might do well to investigate
    **domain driven** **design** (**DDD**).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 消息应该具有业务含义的组件，以增加其效用。在复杂业务中定义消息及其构造方式是一个独立的研究领域。有兴趣的人可能会对**领域驱动设计**（**DDD**）进行深入研究。
- en: Commands are an instruction targeted at one specific component giving it instructions
    to perform a task.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是针对一个特定组件的指令，让其执行任务。
- en: Within the context of a browser you might consider that a command would be the
    click that is fired on a button. The command is transformed into an event and
    that event is what is passed to your event listeners.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器的上下文中，您可能会考虑命令是在按钮上触发的点击。命令被转换为事件，而该事件就是传递给您的事件监听器的内容。
- en: Only one end point should receive a specific command. This means that only one
    component is responsible for an action taking place. As soon as a command is acted
    upon by more than one end point any number of race conditions are introduced.
    What if one of the end points accepts the command and another rejects it as invalid?
    Even in cases where several near identical commands are issued they should not
    be aggregated. For instance, sending a command from a king to all his generals
    should send one command to each general.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个端点应该接收特定的命令。这意味着只有一个组件负责动作的发生。一旦一个命令被多个端点执行，就会引入任意数量的竞争条件。如果一个端点接受命令，另一个拒绝它作为无效的呢？即使发出了几个几乎相同的命令，它们也不应该被聚合。例如，从国王发送一条命令给他的所有将军应该给每个将军发送一条命令。
- en: Because there is only one end point for a command it is possible for that end
    point to validate and even cancel the command. The cancellation of the command
    should have no impact on the rest of the application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命令只有一个端点，因此该端点有可能验证甚至取消命令。取消命令不应对应用程序的其余部分产生影响。
- en: When a command is acted upon, then one or more events may be published.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个命令被执行时，可能会发布一个或多个事件。
- en: Events
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: An event is a special message that notifies that something has happened. There
    is no use in trying to change or cancel an event because it is simply a notification
    that something has happened. You cannot change the past unless you own a Delorian.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是一条特殊的消息，通知发生了某事。试图改变或取消事件是没有意义的，因为它只是通知发生了某事。除非您拥有一辆迪洛雷安，否则您无法改变过去。
- en: The naming convention for events is that they are written in the past tense.
    You might see a reversal of the ordering of the words in the command, so we could
    end up with `CityInvaded` once the `InvadeCity` command has succeeded.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的命名约定是使用过去时。您可能会看到命令中单词顺序的颠倒，因此一旦`InvadeCity`命令成功，我们可能会得到`CityInvaded`。
- en: Unlike commands, events may be received by any number of components. There are
    not real race conditions presented by this approach. As no message handler can
    change the message nor interfere with the delivery of other copies of the message,
    each handler is siloed away from all others.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令不同，事件可能被任意数量的组件接收。这种方法不会产生真正的竞争条件。由于没有消息处理程序可以更改消息或干扰其他副本的传递，每个处理程序都与其他处理程序隔离开来。
- en: 'You may be familiar with events from having done user interface work. When
    a user clicks a button then an event is "raised". In effect the event is broadcast
    to a series of listeners. You subscribe to a message by hooking into that event:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能熟悉事件，因为您做过用户界面工作。当用户点击按钮时，就会“触发”一个事件。实际上，事件被广播到一系列监听器。您可以通过连接到该事件来订阅消息：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The events in browsers don't quite meet the definition of an event I gave in
    the preceding paragraph. This is because event handlers in the browser can cancel
    events and stop them from propagating to the next handler. That is to say, when
    there are a series of event handlers for the same message one of them can completely
    consume the message and not pass it on to subsequent handlers. There is certainly
    utility to an approach like this but it does introduce some confusion. Fortunately
    for UI messages, the number of handlers is typically quite small.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的事件并不完全符合我在前面段落中给出的事件定义。这是因为浏览器中的事件处理程序可以取消事件并阻止它们传播到下一个处理程序。也就是说，当有一系列相同消息的事件处理程序时，其中一个可以完全消耗消息，不将其传递给后续处理程序。这种方法当然有其用途，但也会引入一些混乱。对于UI消息来说，幸运的是，处理程序的数量通常相当少。
- en: 'In some systems, events can be polymorphic in nature. That is to say that if
    I had an event called `IsHiredSalary` that is fired when somebody is hired in
    a salaried role, I could make it a descendant of the message `IsHired`. Doing
    so would allow for both handlers subscribed to `IsHiredSalary` and `IsHired` to
    be fired upon receipt of an `IsHiredSalary` event. JavaScript doesn''t have polymorphism
    in the true sense, so such things aren''t particularly useful. You can add a message
    field that takes the place of polymorphism but it looks somewhat messy:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统中，事件可能具有多态性。也就是说，如果我有一个名为“IsHiredSalary”的事件，当有人被聘用为有薪角色时触发，我可以将其作为消息“IsHired”的后代。这样做可以使订阅“IsHiredSalary”和“IsHired”的处理程序在接收“IsHiredSalary”事件时都被触发。JavaScript在真正意义上没有多态性，因此这样的东西并不特别有用。您可以添加一个消息字段来代替多态性，但看起来有些混乱：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case I've used `__` to denote fields that are part of the envelope.
    You could also construct the message with separate fields for message and envelope,
    it really doesn't matter all that much.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我使用“__”来表示信封中的字段。您也可以使用单独的字段构造消息和信封，这实际上并不那么重要。
- en: 'Let''s take a look at a simple operation like creating a user so we can see
    how commands and events interact:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的操作，比如创建一个用户，这样我们就可以看到命令和事件是如何交互的：
- en: '![Events](img/00082.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![事件](img/00082.jpeg)'
- en: Here a user enters data into a form and submits it. The web server takes in
    the input, validates it and, if it is correct, creates a command. The command
    is now sent to the command handler. The command handler performs some action,
    perhaps writes to a database, it then publishes an event that is consumed by a
    number of event listeners. These event listeners might send confirmation e-mails,
    notify system administrators, or any number of things.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，用户输入数据到表单并提交。Web服务器接收输入，验证它，如果正确，创建一个命令。现在，命令被发送到命令处理程序。命令处理程序执行一些操作，也许写入数据库，然后发布一个事件，被多个事件监听器消费。这些事件监听器可能发送确认电子邮件，通知系统管理员，或者执行任何数量的操作。
- en: All of this looks familiar because systems already contain commands and events.
    The difference is that we are now modeling the commands and events explicitly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些看起来很熟悉，因为系统已经包含了命令和事件。不同之处在于，我们现在正在显式地对命令和事件进行建模。
- en: Request-reply
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求-回复
- en: The simplest pattern you'll see with messaging is the request-reply pattern.
    Also known as request-response, this is a method of retrieving data that is owned
    by another part of the application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在消息传递中看到的最简单的模式是请求-回复模式。也称为请求-响应，这是一种检索由应用程序的另一部分拥有的数据的方法。
- en: 'In many cases the sending of a command is an asynchronous operation. A command
    is fired and the application flow continues on. Because of this, there is no easy
    way to do things like lookup a record by ID. Instead one needs to send a command
    to retrieve a record and then wait for the associated event to be returned. A
    normal workflow looks like the following diagram:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，发送命令是一个异步操作。命令被触发后，应用程序流程继续进行。因此，没有简单的方法来执行诸如按ID查找记录之类的操作。相反，需要发送一个命令来检索记录，然后等待相关事件的返回。正常的工作流程如下图所示：
- en: '![Request-reply](img/00083.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![请求-回复](img/00083.jpeg)'
- en: Most events can be subscribed to by any number listeners. While it is possible
    to have multiple event listeners for a request-response pattern, it is unlikely
    and is probably not advisable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数事件可以被任意数量的监听器订阅。虽然可能存在多个事件监听器用于请求-响应模式，但这种情况不太可能，而且可能不可取。
- en: We can implement a very simple request-response pattern here. In Westeros there
    are some issues with sending messages in a timely fashion. Without electricity,
    sending messages over long distances rapidly can really only be accomplished by
    attaching tiny messages to the legs of crows. Thus we have a Crow Messaging System.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里实现一个非常简单的请求-回复模式。在维斯特洛，发送消息及时存在一些问题。没有电力，通过乌鸦的腿迅速发送消息实际上是唯一可行的方法。因此，我们有了一个乌鸦消息系统。
- en: 'We''ll start with building out what we''ll call the **bus**. A bus is simply
    a distribution mechanism for messages. It can be implemented in process, as we''ve
    done here, or out of process. If implementing it out of process, there are many
    options from 0mq, a lightweight message queue, to RabbitMQ, a more fully featured
    messaging system, to a wide variety of systems built on top of databases and in
    the cloud. Each of these systems exhibit some different behaviors when it comes
    to message reliability and durability. It is important to do some research into
    the way that the message distribution systems work as they may dictate how the
    application is constructed. They also implement different approaches to dealing
    with the underlying unreliability of applications:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从构建我们称之为**总线**的东西开始。总线只是消息的分发机制。它可以在进程中实现，就像我们在这里做的那样，也可以在进程外实现。如果在进程外实现，有许多选项可供选择，从轻量级消息队列0mq到更全面的消息系统RabbitMQ，再到基于数据库和云端构建的各种系统。这些系统在消息的可靠性和持久性方面表现出一些不同的行为。重要的是要对消息分发系统的工作方式进行一些研究，因为它们可能决定应用程序的构建方式。它们还实施了不同的方法来处理应用程序的基本不可靠性：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One thing which is a potential trip-up is that the order in which messages are
    received back on the client is not necessarily the order in which they were sent.
    To deal with this it is typical to include some sort of a correlation ID. When
    the event is raised it includes a known ID from the sender so that the correct
    event handler is used.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个潜在的问题是客户端接收消息的顺序不一定是发送消息的顺序。为了解决这个问题，通常会包含某种相关ID。当事件被触发时，它会包含来自发送方的已知ID，以便使用正确的事件处理程序。
- en: This bus is a highly naïve one as it has its routing hard coded. A real bus
    would probably allow the sender to specify the address of the end point for delivery.
    Alternately, the receivers could register themselves as interested in a specific
    sort of message. The bus would then be responsible for doing some limited routing
    to direct the message. Our bus is even named after the messages it deals with
    – certainly not a scalable approach.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这辆总线是一个非常天真的总线，因为它的路由是硬编码的。真正的总线可能允许发送方指定交付的终点地址。或者，接收方可以注册自己对特定类型的消息感兴趣。然后总线将负责进行一些有限的路由以指导消息。我们的总线甚至以它处理的消息命名
    - 这显然不是可扩展的方法。
- en: 'Next we''ll implement the requestor. The requestor contains only two methods:
    one to send a request and the other to receive a response from the bus:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将实现请求者。请求者只包含两种方法：一个用于发送请求，另一个用于从总线接收响应：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The process message function currently just logs the response but it would likely
    do more in a real world scenario such as updating the UI or dispatching another
    message. The correlation ID is invaluable for understanding which sent message
    the reply is related to.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，处理消息函数只是记录响应，但在现实世界的场景中可能会做更多的事情，比如更新UI或分派另一条消息。相关ID对于理解回复与发送消息的关系是非常宝贵的。
- en: 'Finally, the responder simply takes in the message and replies to it with another
    message:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，响应者只需接收消息并用另一条消息回复：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Everything in our example is synchronous but all it would take to make it asynchronous
    is to swap out the bus. If we''re working in node then we can do this using `process.nextTick`
    which simply defers a function to the next time through the event loop. If we''re
    in a web context, then web workers may be used to do the processing in another
    thread. In fact, when starting a web worker, the communication back and forth
    to it takes the form of a message:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例中的一切都是同步的，但要使其异步只需要更换总线。如果我们在node中工作，可以使用`process.nextTick`来实现这一点，它只是将一个函数推迟到事件循环的下一次。如果我们在web上下文中，那么web
    worker可以用来在另一个线程中进行处理。实际上，当启动web worker时，与其来回通信采用消息的形式：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This approach now allows other code to run before the message is processed.
    If we weave in some print statements after each bus send, then we get output like
    the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法现在允许其他代码在消息被处理之前运行。如果我们在每次总线发送后编入一些打印语句，那么我们会得到以下输出：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can see that the print statements are executed before the message processing
    as that processing happens on the next iteration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到打印语句在消息处理之前执行，因为处理发生在下一个迭代中。
- en: Publish-subscribe
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布-订阅
- en: I've alluded to the publish-subscribe model elsewhere in this chapter. Publish-subscribe
    is a powerful tool for decoupling events from processing code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章的其他地方已经提到了发布-订阅模型。发布-订阅是将事件与处理代码解耦的强大工具。
- en: At the crux of the pattern is the idea that, as a message publisher, my responsibility
    for the message should end as soon as I send it. I should not know who is listening
    to messages or what they will do with the messages. So long as I am fulfilling
    a contract to produce correctly formatted messages, the rest shouldn't matter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的关键在于，作为消息发布者，我对消息的责任应该在我发送消息后立即结束。我不应该知道谁在监听消息或他们将如何处理消息。只要我履行了生成格式正确的消息的合同，其他事情就不重要了。
- en: It is the responsibility of the listener to register its interest in the message
    type. You'll, of course, wish to register some sort of security to disallow registration
    of rogue services.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器有责任注册其对消息类型的兴趣。当然，您希望注册某种安全性，以阻止注册恶意服务。
- en: 'We can update our service bus to do more, to do a complete job of routing and
    sending multiple messages. Let''s call our new method `Publish` instead of `Send`.
    We''ll keep `Send` around to do the sending functionality:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更新我们的服务总线，使其做更多的事情，完成路由和发送多条消息。我们将新的方法称为`Publish`而不是`Send`。我们将保留`Send`来执行发送功能：
- en: '![Publish-subscribe](img/00084.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![发布-订阅](img/00084.jpeg)'
- en: The crow mail analogy we used in the previous section starts to fall apart here
    as there is no way to broadcast a message using crows. Crows are too small to
    carry large banners and it is very difficult to train them to do sky writing.
    I'm unwilling to totally abandon the idea of crows so let's assume that there
    exists a sort of crow broadcast centre. Sending a message here allows for it to
    be fanned out to numerous interested parties who have signed up for updates. This
    centre will be more or less synonymous with a bus.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中使用的乌鸦邮件类比在这里开始崩溃，因为没有办法使用乌鸦广播消息。乌鸦太小，无法携带大型横幅，而且很难训练它们进行天空书写。我不愿意完全放弃乌鸦的想法，所以让我们假设存在一种乌鸦广播中心。在这里发送消息允许将其传播给许多已经注册更新的感兴趣的各方。这个中心或多或少与总线是同义词。
- en: We'll write our router so that it works as a function of the name of the message.
    One could route a message using any of its attributes. For instance, a listener
    could subscribe to all the messages called `invoicePaid` where the `amount` field
    is greater than $10000\. Adding this sort of logic to the bus will slow it down
    and make it far harder to debug. Really this is more the domain of business process
    orchestration engines than a bus. We'll continue on without that complexity.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写我们的路由器，使其作为消息名称的一个函数。可以使用消息的任何属性来路由消息。例如，监听器可以订阅所有名为“invoicePaid”的消息，其中“amount”字段大于10000美元。将这种逻辑添加到总线中会减慢总线速度，并使调试变得更加困难。实际上，这更多地属于业务流程编排引擎的领域，而不是总线。我们将继续进行而不添加这种复杂性。
- en: 'The first thing to set up is the ability to subscribe to published messages:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 设置的第一件事是能够订阅已发布的消息：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Subscribe` function just adds a message handler and the name of a message
    to consume. The responders array is simply an array of handlers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscribe`函数只是添加一个消息处理程序和要消耗的消息的名称。响应者数组只是一个处理程序数组。'
- en: 'When a message is published we loop over the array and fire each of the handlers
    that have registered for messages with that name:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息发布时，我们遍历数组并触发已注册该名称消息的每个处理程序：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The execution here is deferred to the next tick. This is done using a closure
    to ensure that the correctly scoped variables are passed through. We can now change
    our `CrowMailResponder` to use the new `Publish` method instead of `Send`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的执行被推迟到下一个时刻。这是通过使用闭包来确保正确范围的变量被传递的。现在我们可以改变我们的`CrowMailResponder`，使用新的`Publish`方法而不是`Send`：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Instead of allowing the `CrowMailRequestor` object to create its own bus as
    earlier, we need to modify it to accept an instance of `bus` from outside. We
    simply assign it to a local variable in `CrowMailRequestor`. Similarly, `CrowMailResponder`
    should also take in an instance of `bus`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与其像之前那样允许`CrowMailRequestor`对象创建自己的总线，我们需要修改它以接受外部的`bus`实例。我们只需将其分配给`CrowMailRequestor`中的一个局部变量。同样，`CrowMailResponder`也应该接受一个`bus`实例。
- en: 'In order to make use of this we simply need to create a new bus instance and
    pass it into the requestor:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这一点，我们只需要创建一个新的总线实例并将其传递给请求者：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here we''ve also passed in two other responders that are interested in knowing
    about `KingdomInvaded` messages. They look like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还传入了另外两个对`KingdomInvaded`消息感兴趣的响应者。它们看起来像这样：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running this code will now get the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行此代码将得到以下结果：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can see that the messages are sent using `Send`. The responder or handler
    does its work and publishes a message that is passed onto each of the subscribers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到消息是使用`Send`发送的。响应者或处理程序完成其工作并发布一条消息，该消息传递给每个订阅者。
- en: 'There are some great JavaScript libraries which make publish and subscribe
    even easier. One of my favorites is Radio.js. It has no external dependencies
    and its name is an excellent metaphor for publish subscribe. We could rewrite
    our preceding subscribe example like so:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些很棒的JavaScript库可以使发布和订阅变得更加容易。我最喜欢的之一是Radio.js。它没有外部依赖项，其名称是发布订阅的一个很好的比喻。我们可以像这样重写我们之前的订阅示例：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then publish a message using the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下方式发布一条消息：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Fan out and in
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扇出和扇入
- en: A fantastic use of the publish subscribe pattern is allowing you to fan out
    a problem to a number of different nodes. Moore's law has always been about the
    doubling of the number of transistors per square unit of measure. If you've been
    paying attention to processor clock speeds you may have noticed that there hasn't
    really been any significant change in clock speeds for a decade. In fact, clock
    speeds are now lower than they were in 2005.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 发布订阅模式的一个梦幻般的用途是允许您将问题扩展到多个不同的节点。摩尔定律一直是关于每个单位面积的晶体管数量翻倍的。如果您一直关注处理器时钟速度，您可能已经注意到在过去十年中时钟速度实际上没有发生任何显著变化。事实上，时钟速度现在比2005年还要低。
- en: This is not to say that processors are "slower" than they once were. The work
    that is performed in each clock tick has increased. The number of cores has also
    jumped up. It is now unusual to see a single core processor; even in cellular
    phones dual core processors are becoming common. It is the rule, rather than the
    exception, to have computers that are capable of doing more than one thing at
    a time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说处理器比以前“慢”。每个时钟周期中执行的工作量已经增加。核心数量也大幅增加。现在看到单核处理器已经不再是常态；即使在手机中，双核处理器也变得很常见。拥有能够同时执行多项任务的计算机已经成为规则，而不再是例外。
- en: At the same time, cloud computing is taking off. The computers you purchase
    outright are faster than the ones available to rent from the cloud. The advantage
    of cloud computing is that you can scale it out easily. It is nothing to provision
    a hundred or even a thousand computers to form a cloud provider.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，云计算正在蓬勃发展。您直接购买的计算机比云中可租用的计算机更快。云计算的优势在于您可以轻松地扩展它。轻松地提供一百甚至一千台计算机来组成一个云提供商并不是什么难事。
- en: 'Writing software that can take advantage of multiple cores is the great computing
    problem of our time. Dealing directly with threads is a recipe for disaster. Locking
    and contention is far too difficult a problem for most developers: me included!
    For a certain class of problems, they can easily be divided up into sub problems
    and distributed. Some call this class of problems "embarrassingly parallelizable".'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 编写可以利用多个核心的软件是我们这个时代的伟大计算问题。直接处理线程是灾难的开始。锁定和争用对大多数开发人员来说是一个过于困难的问题：包括我在内！对于某些类别的问题，它们可以很容易地分成子问题并进行分发。有些人称这类问题为“尴尬地可并行化”。
- en: 'Messaging provides a mechanism for communicating the inputs and outputs from
    a problem. If we had one of these easily parallelized problems, such as searching,
    then we would bundle up the inputs into one message. In this case it would contain
    our search terms. The message might also contain the set of documents to search.
    If we had 10,000 documents then we could divide the search space up into, say,
    four collections of 2500 documents. We would publish five messages with the search
    terms and the range of documents to search as can be seen here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递提供了一个机制，用于传达问题的输入和输出。如果我们有一个这样的易于并行化的问题，比如搜索，那么我们会将输入打包成一个消息。在这种情况下，它将包含我们的搜索词。消息还可能包含要搜索的文档集。如果我们有10,000个文档，那么我们可以将搜索空间分成四个包含2500个文档的集合。我们将发布五条消息，其中包含搜索词和要搜索的文档范围，如下所示：
- en: '![Fan out and in](img/00085.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![扇出和扇入](img/00085.jpeg)'
- en: Different search nodes will pick up the messages and perform the search. The
    results will then be sent back to a node that will collect the messages and combine
    them into one. This is what will be returned to the client.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的搜索节点将接收消息并执行搜索。然后将结果发送回一个节点，该节点将收集消息并将它们组合成一个。这将返回给客户端。
- en: Of course this is a bit of an over simplification. It is likely that the receiving
    nodes themselves would maintain a list of documents over which they had responsibility.
    This would prevent the original publishing node from having to know anything about
    the documents over which it was searching. The search results could even be returned
    directly to the client that would do the assembling.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这有点过于简化了。接收节点本身可能会维护一个负责的文档列表。这将防止原始发布节点必须了解其正在搜索的文档。搜索结果甚至可以直接返回给客户端进行组装。
- en: Even in a browser, the fan out and in approach can be used to distribute a calculation
    over a number of cores through the use of web workers. A simple example might
    take the form of creating a potion. A potion might contain a number of ingredients
    that can be combined to create a final product. It is quite computationally complicated
    combining ingredients so we would like to farm the process out to a number of
    workers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在浏览器中，也可以使用扇出和扇入方法通过Web工作者将计算分布到多个核心。一个简单的例子可能是创建一个药水。药水可能包含许多成分，可以组合成最终产品。组合成分是相当复杂的计算，因此我们希望将这个过程分配给多个工作者。
- en: 'We start with a combiner that contains a `combine()` method as well as a `complete()`
    function that is called once all the distributed ingredients are combined:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个组合器开始，其中包含一个`combine()`方法以及一个`complete()`函数，一旦所有分布式成分都被组合，就会调用该函数：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In order to keep track of the number of workers outstanding, we use a simple
    counter. Because the main section of code is single threaded we have no risk of
    race conditions. Once the counter shows no remaining workers we can take whatever
    steps are necessary. The web worker looks like the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪未完成的工作人员数量，我们使用一个简单的计数器。由于主要代码部分是单线程的，我们不会有竞争条件的风险。一旦计数器显示没有剩余的工作人员，我们可以采取必要的步骤。Web工作者如下所示：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case we simply put in a timeout to simulate the complex calculation
    needed to combine ingredients.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需设置一个超时来模拟组合成分所需的复杂计算。
- en: The sub problems that are farmed out to a number of nodes don't have to be identical
    problems. However, they should be sufficiently complicated that the cost savings
    of farming them out are not consumed by the overhead of sending out a message.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给多个节点的子问题不必是相同的问题。但是，它们应该足够复杂，以至于将它们分配出去的成本节省不会被发送消息的开销所消耗。
- en: Dead letter queues
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死信队列
- en: No matter how hard I try I have yet to write any significant block of code that
    does not contain any errors. Nor have I been very good at predicting the wide
    range of crazy things users do with my applications. Why would anybody click that
    link 73 times in a row? I'll never know.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我多么努力，我都还没有写出任何不含错误的重要代码块。我也一直不擅长预测用户在我的应用程序中做的各种疯狂事情。为什么有人会连续点击那个链接73次呢？我永远不会知道。
- en: Dealing with failures in a messaging scenario is very easy. The core of the
    failure strategy is to embrace errors. We have exceptions for a reason and to
    spend all of our time trying to predict and catch exceptions is counter-productive.
    You'll invariably spend time building in catches for errors that never happen
    and miss errors that happen frequently.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息传递场景中处理故障非常容易。故障策略的核心是接受错误。我们有异常是有原因的，花费所有时间来预测和捕获异常是适得其反的。你将不可避免地花时间来捕获从未发生的错误，并错过频繁发生的错误。
- en: 'In an asynchronous system, errors need not be handled as soon as they occur.
    Instead, the message that caused an error can be put aside to be examined by an
    actual human later. The message is stored in a dead letter, or error, queue. From
    there the message can easily be reprocessed after it has been corrected or the
    handler has been corrected. Ideally the message handler is changed to deal with
    messages exhibiting whatever property caused the errors. This prevents future
    errors and is preferable to fixing whatever generates the message as there is
    no guarantee that other messages with the same problem aren''t lurking somewhere
    else in the system. The workflow of a message through the queue and error queue
    can be seen here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步系统中，错误不需要在发生时立即处理。相反，导致错误的消息可以被放在一边，以便稍后由实际人员检查。消息存储在死信或错误队列中。然后，消息可以在被更正或处理程序被更正后轻松地重新处理。理想情况下，消息处理程序被更改以处理表现出导致错误的任何属性的消息。这可以防止未来的错误，并且比修复生成消息的任何内容更可取，因为不能保证系统中其他地方没有潜在的具有相同问题的其他消息。消息通过队列和错误队列的工作流程如下所示：
- en: '![Dead letter queues](img/00086.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![死信队列](img/00086.jpeg)'
- en: As more and more errors are caught and fixed, the quality of the message handlers
    increases. Having an error queue of messages ensures that nothing important, such
    as a `BuySimonsBook` message is missed. This means that getting to a correct system
    becomes a marathon instead of a sprint. There is no need to rush a fix into production
    before it is properly tested. Progress towards a correct system is constant and
    reliable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的错误被捕获和修复，消息处理程序的质量也在提高。拥有一个消息错误队列可以确保不会错过任何重要的东西，比如`BuySimonsBook`消息。这意味着达到正确系统的进程变成了马拉松，而不是短跑。在正确测试之前，没有必要急于将修复推向生产。朝着正确系统的进展是持续而可靠的。
- en: Using a dead letter queue also improves the catching of intermittent errors.
    These are errors that result from an external resource being unavailable or incorrect.
    Imagine a handler that calls out to an external web service. In a traditional
    system, a failure in the web service guarantees failure in the message handler.
    However, with a message based system, the command can be moved back to the end
    of the input queue and tried again whenever it reaches the front of the queue.
    On the envelope we write down the number of times the message has been dequeued
    (processed). Once this dequeue count reaches a limit, like five, only then is
    the message moved into the true error queue.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用死信队列还可以提高捕获间歇性错误的能力。这些错误是由外部资源不可用或不正确导致的。想象一个调用外部网络服务的处理程序。在传统系统中，网络服务的故障会导致消息处理程序的失败。然而，在基于消息的系统中，命令可以被移回输入队列的末尾，并在达到队列前端时再次尝试。在信封上，我们记录消息被出列（处理）的次数。一旦这个出列计数达到上限，比如五次，那么消息才会被移动到真正的错误队列中。
- en: This approach improves the overall quality of the system by smoothing over the
    small failures and stopping them from becoming large failures. In effect, the
    queues provide failure bulkheads to prevent small errors from overflowing and
    becoming large errors that might have an impact on the system as a whole.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过平滑处理小故障并阻止它们变成大故障来提高系统的整体质量。实际上，队列提供了故障隔离，防止小错误溢出并成为可能对整个系统产生影响的大错误。
- en: Message replay
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息重放
- en: When developers are working with a set of messages that produce an error, the
    ability to reprocess messages is also useful. Developers can take a snapshot of
    the dead letter queue and reprocess it in debug mode again and again until they
    have correctly processed the messages. A snapshot of a message can also make up
    a part of the testing for a message handler.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员处理一组产生错误的消息时，重新处理消息的能力也是有用的。开发人员可以对死信队列进行快照，并在调试模式下反复重新处理，直到正确处理消息。消息的快照也可以成为消息处理程序的一部分测试。
- en: Even without there being an error, the messages sent to a service on a daily
    basis are representative of the normal workflows of users. These messages can
    be mirrored to an audit queue as they enter into the system. The data from the
    audit queue can be used for testing. If a new feature is introduced, then a normal
    day's workload can be played back to ensure that there has been no degradation
    in either correct behavior or performance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有错误，每天发送到服务的消息代表用户的正常工作流程。这些消息可以在进入系统时镜像到审计队列。审计队列中的数据可以用于测试。如果引入了新功能，那么可以回放正常的一天工作量，以确保正确的行为或性能没有下降。
- en: Of course if the audit queue contains a list of every message, then it becomes
    trivial to understand how the application arrived at its current state. Frequently
    people implement history by plugging in a lot of custom code or by using triggers
    and audit tables. Neither of these approaches do as good of a job as messaging
    at understanding not only which data has changed, but why it has changed. Consider
    again the address change scenario, without messaging we will likely never know
    why an address for a user is different from the previous day.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果审计队列包含每条消息的列表，那么理解应用程序如何达到当前状态就变得微不足道。经常有人通过插入大量自定义代码或使用触发器和审计表来实现历史记录。这两种方法都不如消息理解数据不仅发生了哪些变化，还有为什么发生变化。再次考虑地址更改的情况，如果没有消息传递，我们很可能永远不会知道为什么用户的地址与前一天不同。
- en: Maintaining a good history of changes to system data is storage intensive but
    that cost is easily paid by allowing auditors to see how and why each change was
    made. Well-constructed messages also allow for the history to contain the intent
    of the user making the change.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 维护系统数据变更的良好历史记录会占用大量存储空间，但通过允许审计人员查看每次变更是如何以及为何进行的来支付这种成本是很容易的。良好构建的消息还允许历史记录包含用户进行变更的意图。
- en: While it is possible to implement this sort of messaging system, in a single
    process it is difficult. Ensuring that messages are properly saved in the event
    of errors is difficult, as the entire process that deals with messages may crash,
    taking the internal message bus with it. Realistically if the replaying of messages
    sounds like something worth investigating then external message busses are the
    solution.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在单个进程中实现这种消息系统是可能的，但却很困难。确保消息在发生错误时能够正确保存是困难的，因为处理消息的整个过程可能会崩溃，带走内部消息总线。实际上，如果重放消息听起来像是值得调查的事情，那么外部消息总线就是解决方案。
- en: Pipes and filters
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道和过滤器
- en: I mentioned earlier that messages should be considered immutable. This is not
    to say that messages cannot be rebroadcast with some properties changed or even
    broadcast as a new type of message. In fact, many message handlers may consume
    an event and then publish a new event after having performed some task.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，消息应该被视为不可变的。这并不是说消息不能被重新广播，其中一些属性被改变，甚至作为一种新类型的消息进行广播。事实上，许多消息处理程序可能会消耗一个事件，然后在执行了一些任务后发布一个新的事件。
- en: 'As an example, you might consider the workflow for adding a new user to a system:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，你可以考虑向系统添加新用户的工作流程：
- en: '![Pipes and filters](img/00087.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Pipes and filters](img/00087.jpeg)'
- en: 'In this case, the `CreateUser` command triggers a `UserCreated` event. That
    event is consumed by a number of different services. One of these services passes
    on user information to a select number of affiliates. As this service runs, it
    publishes its own set of events, one for each affiliate that receives the new
    user''s details. These events may, in turn, be consumed by other services which
    could trigger their own events. In this way changes can ripple through the entire
    application. However, no service knows more than what starts it and what events
    it publishes. This system has very low coupling. Plugging in new functionality
    is trivial and even removing functionality is easy: certainly easier than a monolithic
    system.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，“CreateUser”命令触发了一个“UserCreated”事件。这个事件被许多不同的服务所消费。其中一个服务将用户信息传递给一些特定的联盟。当这个服务运行时，它会发布自己的一系列事件，每个事件都是给接收新用户详细信息的联盟。这些事件可能会被其他服务所消费，从而触发它们自己的事件。这样一来，变化可以在整个应用程序中传播。然而，没有一个服务知道比它启动的更多，也不知道它发布了哪些事件。这个系统的耦合度非常低。插入新功能是微不足道的，甚至删除功能也很容易：肯定比单片系统容易得多。
- en: Systems constructed using messaging and autonomous components are frequently
    referred to as using **Service Oriented Architecture** (**SOA**) or Microservices.
    There remains a great deal of debate as to the differences, if indeed there are
    any, between SOA and Microservices.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息传递和自治组件构建的系统通常被称为使用面向服务的架构（SOA）或微服务。关于SOA和微服务之间是否存在差异，甚至是否存在差异，仍然存在大量的争论。
- en: The altering and rebroadcasting of messages can be thought of as being a pipe
    or a filter. A service can proxy messages through to other consumers just as a
    pipe would do or can selectively republish messages as would be done by a filter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的更改和转发可以被看作是一个管道或一个过滤器。一个服务可以像管道一样代理消息到其他消费者，也可以像过滤器一样有选择地重新发布消息。
- en: Versioning messages
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息版本控制
- en: As systems evolve, the information contained in a message may also change. In
    our user creation example, we might have originally been asking for a name and
    e-mail address. However, the marketing department would like to be able to send
    e-mails addressed to Mr. Jones or Mrs. Jones so we need to also collect the user's
    title. This is where message versioning comes in handy.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的发展，消息中包含的信息也可能会发生变化。在我们的用户创建示例中，我们可能最初要求姓名和电子邮件地址。然而，市场部门希望能够发送给琼斯先生或琼斯夫人的电子邮件，因此我们还需要收集用户的头衔。这就是消息版本控制派上用场的地方。
- en: We can now create a new message that extends the previous message. The message
    can contain additional fields and might be named using the version number or a
    date. Thus a message like `CreateUser` might become `CreateUserV1` or `CreateUser20140101`.
    Earlier I mentioned polymorphic messages. This is one approach to versioning messages.
    The new message extends the old so all the old message handlers still fire. However,
    we also talked about how there are no real polymorphic capabilities in JavaScript.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个扩展了之前消息的新消息。该消息可以包含额外的字段，并且可能使用版本号或日期进行命名。因此，像“CreateUser”这样的消息可能会变成“CreateUserV1”或“CreateUser20140101”。之前我提到过多态消息。这是一种版本控制消息的方法。新消息扩展了旧消息，因此所有旧消息处理程序仍然会触发。然而，我们也谈到了JavaScript中没有真正的多态能力。
- en: Another option is to use upgrading message handlers. These handlers will take
    in a version of the new message and modify it to be the old version. Obviously
    the newer messages need to have at least as much data in them as the old version
    or have data that permits converting one message type to another.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用升级消息处理程序。这些处理程序将接收新消息的版本并将其修改为旧版本。显然，新消息需要至少包含与旧版本相同的数据，或者具有允许将一种消息类型转换为另一种消息类型的数据。
- en: 'Consider a v1 message that looked like the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个看起来像以下的v1消息：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Consider a v2 message that extended it adding a user title:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个扩展了v1消息并添加了用户头衔的v2消息：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we would be able to write a very simple upgrader or downgrader that looks
    like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们就能够编写一个非常简单的升级器或降级器，看起来像下面这样：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can see that we simply modify the message and rebroadcast it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们只是修改消息并重新广播它。
- en: Hints and tips
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: Messages create a well-defined interface between two different systems. Defining
    messages should be done by members of both teams. Establishing a common language
    can be tricky especially as terms are overloaded between different business units.
    What a sales department considers a customer may be totally different from what
    a shipping department considers a customer. Domain driven design provides some
    hints as to how boundaries can be established to avoid mixing terms.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 消息在两个不同系统之间创建了一个明确定义的接口。定义消息应该由两个团队的成员来完成。建立一个共同的语言可能会很棘手，特别是因为术语在不同的业务部门之间被重载。销售部门认为的客户可能与运输部门认为的客户完全不同。领域驱动设计提供了一些提示，可以帮助建立边界，避免混淆术语。
- en: 'There is a huge preponderance of queue technologies available. Each of them
    have a bunch of different properties around reliability, durability, and speed.
    Some of the queues support reading and writing JSON over HTTP: ideal for those
    interested in building JavaScript applications. Which queue is appropriate for
    your application is a topic for some research.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量的队列技术可供选择。它们每个都有关于可靠性、持久性和速度的不同属性。其中一些队列支持通过HTTP读写JSON：非常适合那些有兴趣构建JavaScript应用程序的人。哪种队列适合你的应用程序是一个需要进行一些研究的话题。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Messaging and the associated patterns are large topics. Delving too deeply into
    messages will bring you in contact with **domain driven design** (**DDD**) and
    **command query responsibility segregation** (**CQRS**) as well as touching on
    high performance computing solutions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递和相关模式是一个大的话题。深入研究消息会让你接触到领域驱动设计（DDD）和命令查询职责分离（CQRS），以及高性能计算解决方案。
- en: There is substantial research and discussion ongoing as to the best way to build
    large systems. Messaging is one possible solution that avoids creating a big ball
    of mud that is difficult to maintain and fragile to change. Messaging provides
    natural boundaries between components in a system and the messages themselves
    provide for a consistent API.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量的研究和讨论正在进行，关于构建大型系统的最佳方式。消息传递是一个可能的解决方案，可以避免创建一个难以维护和易于更改的大型混乱系统。消息传递在系统中为组件提供了自然的边界，消息本身提供了一致的API。
- en: Not every application benefits from messaging. There is additional overhead
    to building a loosely coupled application such as this. Applications that are
    collaborative, ones where losing data is especially undesirable, and those that
    benefit from a strong history story are good candidates for messaging. In most
    cases a standard CRUD application will be sufficient. It is still worthwhile to
    know about messaging patterns, as they will offer alternative thinking.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个应用程序都从消息传递中受益。构建这样一个松散耦合的应用程序会增加额外的开销。协作型应用程序、那些特别不希望丢失数据的应用程序，以及受益于强大历史故事的应用程序都是消息传递的良好候选者。在大多数情况下，标准的CRUD应用程序就足够了。但了解消息传递模式仍然是值得的，因为它们会提供替代思路。
- en: In this chapter we've taken a look at a number of different messaging patterns
    and how they can be applied to common scenarios. The differences between commands
    and events were also explored.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一些不同的消息传递模式，以及它们如何应用于常见情景。还探讨了命令和事件之间的区别。
- en: In the next chapter we'll look at some patterns for making testing code a little
    bit easier. Testing is jolly important so read on!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些使测试代码变得更容易的模式。测试非常重要，所以请继续阅读！
