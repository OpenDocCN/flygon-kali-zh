- en: Chapter 7. Members Inheritance and Polymorphism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。成员继承和多态
- en: 'In this chapter, we will learn about one of the most exciting features of object-oriented
    programming in Java 9: polymorphism. We will code many classes and then we will
    work with their instances in JShell to understand how objects can take many different
    forms. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Java 9中面向对象编程最激动人心的特性之一：多态。我们将编写许多类，然后在JShell中使用它们的实例，以了解对象如何呈现许多不同的形式。我们将：
- en: Create concrete classes that inherit from abstract superclasses
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建从抽象超类继承的具体类
- en: Work with instances of subclasses
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用子类的实例进行操作
- en: Understand polymorphism
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多态。
- en: Control whether subclasses can or cannot override members
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制子类是否可以覆盖成员
- en: Control whether classes can be subclassed
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制类是否可以被子类化
- en: Use methods that perform operations with instances of different subclasses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行与不同子类实例的操作的方法
- en: Creating concrete classes that inherit from abstract superclasses
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建从抽象超类继承的具体类
- en: 'In the previous chapter, we created an abstract base class named `VirtualAnimal`
    and then we coded the following three abstract subclasses: `VirtualMammal`, `VirtualDomesticMammal`,
    and `VirtualHorse`. Now, we will code the following three concrete classes. Each
    class represents a different horse breed and is a subclass of the `VirtualHorse`
    abstract class.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个名为`VirtualAnimal`的抽象基类，然后编写了以下三个抽象子类：`VirtualMammal`、`VirtualDomesticMammal`和`VirtualHorse`。现在，我们将编写以下三个具体类。每个类代表不同的马种，是`VirtualHorse`抽象类的子类。
- en: '`AmericanQuarterHorse`: This class represents a virtual horse that belongs
    to the American Quarter Horse breed.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AmericanQuarterHorse`: 这个类表示属于美国四分之一马品种的虚拟马。'
- en: '`ShireHorse`: This class represents a virtual horse that belongs to the Shire
    Horse breed.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShireHorse`: 这个类表示属于夏尔马品种的虚拟马。'
- en: '`Thoroughbred`: This class represents a virtual horse that belongs to the Thoroughbred
    breed.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thoroughbred`: 这个类表示属于纯种赛马品种的虚拟马。'
- en: 'The three concrete classes will implement the following three abstract methods
    they inherited from abstract superclasses:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个具体类将实现它们从抽象超类继承的以下三个抽象方法：
- en: '`String getAsciiArt()`: This abstract method is inherited from the `VirtualAnimal`
    abstract class.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String getAsciiArt()`: 这个抽象方法是从`VirtualAnimal`抽象类继承的。'
- en: '`String getBaby()`: This abstract method is inherited from the `VirtualAnimal`
    abstract class.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String getBaby()`: 这个抽象方法是从`VirtualAnimal`抽象类继承的。'
- en: '`String getBreed()`: This abstract method is inherited from the `VirtualHorse`
    abstract class.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String getBreed()`: 这个抽象方法是从`VirtualHorse`抽象类继承的。'
- en: 'The following UML diagram shows the members for the three concrete classes
    that we will code: `AmericanQuarterHorse`, `ShireHorse`, and `Thoroughbred`. We
    don''t use bold text format for the three methods that each of these concrete
    classes will declare because they aren''t overriding the methods; they are implementing
    the abstract methods that the classes inherited.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下UML图表显示了我们将编写的三个具体类`AmericanQuarterHorse`、`ShireHorse`和`Thoroughbred`的成员：我们不使用粗体文本格式来表示这三个具体类将声明的三个方法，因为它们不是覆盖方法；它们是实现类继承的抽象方法。
- en: '![Creating concrete classes that inherit from abstract superclasses](img/00068.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![创建从抽象超类继承的具体类](img/00068.jpeg)'
- en: First, we will create the `AmericanQuarterHorse` concrete class. The following
    lines show the code for this class in Java 9\. Notice that there is no `abstract`
    keyword before `class`, and therefore, our class must make sure that it implements
    all the inherited abstract methods. The code file for the sample is included in
    the `java_9_oop_chapter_07_01` folder, in the `example07_01.java` file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建`AmericanQuarterHorse`具体类。以下行显示了Java 9中此类的代码。请注意，在`class`之前没有`abstract`关键字，因此，我们的类必须确保实现所有继承的抽象方法。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_01.java`文件中。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we will create the `ShireHorse` concrete class. The following lines show
    the code for this class in Java 9\. The code file for the sample is included in
    the `java_9_oop_chapter_07_01` folder, in the `example07_01.java` file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建`ShireHorse`具体类。以下行显示了Java 9中此类的代码。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_01.java`文件中。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finally, we will create the `Thoroughbred` concrete class. The following lines
    show the code for this class in Java 9\. The code file for the sample is included
    in the `java_9_oop_chapter_07_01` folder, in the `example07_01.java` file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建`Thoroughbred`具体类。以下行显示了Java 9中此类的代码。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_01.java`文件中。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As it happened in the other subclasses that we coded, we have more than one
    constructor defined for the three concrete classes. The first constructor that
    requires four arguments uses the `super` keyword to call the constructor from
    the base class or superclass, that is, the constructor defined in the `VirtualHorse`
    class. After the constructor defined in the superclass finishes its execution,
    the code prints a message indicating that an instance of each specific concrete
    class has been created. The constructor defined in each class prints a different
    message.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编码的其他子类中发生的情况，我们为这三个具体类定义了多个构造函数。第一个构造函数需要四个参数，使用`super`关键字调用基类或超类中的构造函数，也就是在`VirtualHorse`类中定义的构造函数。在超类中定义的构造函数执行完毕后，代码会打印一条消息，指示已创建了每个具体类的实例。每个类中定义的构造函数会打印不同的消息。
- en: The second constructor uses the `this` keyword to call the previously explained
    constructor with the received arguments and with `false` as the value for the
    `isPregnant` argument.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数使用`this`关键字调用先前解释的构造函数，并使用`false`作为`isPregnant`参数的值。
- en: Each class returns a different `String` in the implementation of the `getBaby`
    and `getBreed` methods. In addition, each class returns a different ASCII art
    representation for a virtual horse in the implementation of the `getAsciiArt`
    method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类在`getBaby`和`getBreed`方法的实现中返回不同的`String`。此外，每个类在`getAsciiArt`方法的实现中返回虚拟马的不同ASCII艺术表示。
- en: Understanding polymorphism
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多态性
- en: We can use the same method, that is, a method with the same name and arguments,
    to cause different things to happen according to the class on which we invoke
    the method. In object-oriented programming, this feature is known as **polymorphism**.
    Polymorphism is the ability of an object to take on many forms, and we will see
    it in action by working with instances of the previously coded concrete classes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的方法，即使用相同名称和参数的方法，根据调用方法的类来引起不同的事情发生。在面向对象编程中，这个特性被称为**多态性**。多态性是对象能够呈现多种形式的能力，我们将通过使用先前编写的具体类的实例来看到它的作用。
- en: The following lines create a new instance of the `AmericanQuarterHorse` class
    named `american` and use one of its constructors that doesn't require the `isPregnant`
    argument. The code file for the sample is included in the `java_9_oop_chapter_07_01`
    folder, in the `example07_01.java` file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行创建了一个名为`american`的`AmericanQuarterHorse`类的新实例，并使用了一个不需要`isPregnant`参数的构造函数。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_01.java`文件中。
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following lines show the messages that the different constructors displayed
    in JShell after we entered the previous code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行显示了我们在JShell中输入前面的代码后，不同构造函数显示的消息：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The constructor defined in the `AmericanQuarterHorse` calls the constructor
    from its superclass, that is, the `VirtualHorse` class. Remember that each constructor
    calls its superclass constructor and prints a message indicating that an instance
    of the class is created. We don't have five different instances; we just have
    one instance that calls the chained constructors of five different classes to
    perform all the necessary initialization to create an instance of `AmericanQuarterHorse`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`AmericanQuarterHorse`中定义的构造函数调用了其超类的构造函数，即`VirtualHorse`类。请记住，每个构造函数都调用其超类构造函数，并打印一条消息，指示创建了类的实例。我们没有五个不同的实例；我们只有一个实例，它调用了五个不同类的链接构造函数，以执行创建`AmericanQuarterHorse`实例所需的所有必要初始化。'
- en: If we execute the following lines in JShell, all of them will display `true`
    as a result, because `american` belongs to the `VirtualAnimal`, `VirtualMammal`,
    `VirtualDomesticMammal`, `VirtualHorse`, and `AmericanQuarterHorse` classes. The
    code file for the sample is included in the `java_9_oop_chapter_07_01` folder,
    in the `example07_01.java` file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在JShell中执行以下几行，它们都会显示`true`，因为`american`属于`VirtualAnimal`、`VirtualMammal`、`VirtualDomesticMammal`、`VirtualHorse`和`AmericanQuarterHorse`类。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_01.java`文件中。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The results of the previous lines mean that the instance of the `AmericanQuarterHorse`
    class, whose reference is saved in the `american` variable of type `AmericanQuarterHorse`,
    can take on the form of an instance of any of the following classes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面几行的结果意味着`AmericanQuarterHorse`类的实例，其引用保存在类型为`AmericanQuarterHorse`的`american`变量中，可以采用以下任何一个类的实例形式：
- en: '`VirtualAnimal`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟动物
- en: '`VirtualMammal`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟哺乳动物
- en: '`VirtualDomesticMammal`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟家养哺乳动物
- en: '`VirtualHorse`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟马
- en: '`AmericanQuarterHorse`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美国四分之一马
- en: 'The following screenshot shows the results of executing the previous lines
    in JShell:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中执行前面几行的结果：
- en: '![Understanding polymorphism](img/00069.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![理解多态性](img/00069.jpeg)'
- en: 'We coded the `printBreed` method within the `VirtualHorse` class, and we didn''t
    override this method in any of the subclasses. The following is the code for the
    `printBreed` method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`VirtualHorse`类中编写了`printBreed`方法，并且我们没有在任何子类中重写此方法。以下是`printBreed`方法的代码：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code prints the `String` returned by the `getBreed` method, declared in
    the same class as an abstract method. The three concrete classes that inherit
    from `VirtualHorse` implemented the `getBreed` method and each of them returns
    a different `String`. When we called the `american.printBreed` method, JShell
    displayed `American Quarter Horse`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 代码打印了`getBreed`方法返回的`String`，在同一类中声明为抽象方法。继承自`VirtualHorse`的三个具体类实现了`getBreed`方法，它们每个都返回不同的`String`。当我们调用`american.printBreed`方法时，JShell显示`American
    Quarter Horse`。
- en: The following lines create an instance of the `ShireHorse` class named `zelda`.
    Note that, in this case, we use the constructor that requires the `isPregnant`
    argument. As happened when we created an instance of the `AmericanQuarterHorse`
    class, JShell will display a message for each constructor that is executed as
    a result of the chained constructors we coded. The code file for the sample is
    included in the `java_9_oop_chapter_07_01` folder, in the `example07_01.java`
    file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行创建了一个名为`zelda`的`ShireHorse`类的实例。请注意，在这种情况下，我们使用需要`isPregnant`参数的构造函数。与创建`AmericanQuarterHorse`类的实例时一样，JShell将显示每个执行的构造函数的消息，这是由我们编写的链接构造函数的结果。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_01.java`文件中。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The next lines call the `printAverageNumberOfBabies` and `printAsciiArt` instance
    methods for `american`, the instance of `AmericanQuarterHorse`, and `zelda`, which
    is the instance of `ShireHorse`. The code file for the sample is included in the
    `java_9_oop_chapter_07_01` folder, in the `example07_01.java` file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行调用了`american`（`AmericanQuarterHorse`的实例）和`zelda`（`ShireHorse`的实例）的`printAverageNumberOfBabies`和`printAsciiArt`实例方法。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_01.java`文件中。
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We coded the `printAverageNumberOfBabies` and `printAsciiArt` methods in the
    `VirtualAnimal` class, and we didn't override them in any of its subclasses. Hence,
    when we call these methods for either `american` or `Zelda`, Java will execute
    the code defined in the `VirtualAnimal` class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`VirtualAnimal`类中编写了`printAverageNumberOfBabies`和`printAsciiArt`方法，并且没有在任何子类中对它们进行重写。因此，当我们为`american`或`Zelda`调用这些方法时，Java将执行`VirtualAnimal`类中定义的代码。
- en: 'The `printAverageNumberOfBabies` method uses the `int` value returned by `getAverageNumberOfBabies`
    and the `String` returned by the `getBaby` method to generate a `String` that
    represents the average number of babies for a virtual animal. The `VirtualHorse`
    class implemented the inherited `getAverageNumberOfBabies` abstract method with
    code that returns `1`. The `AmericanQuarterHorse` and `ShireHorse` classes implemented
    the inherited `getBaby` abstract method with code that returns a `String` that
    represents a baby for the virtual horse breed: `"AQH baby"` and `"ShireHorse baby"`.
    Thus, our call to the `printAverageNumberOfBabies` method will produce different
    results in each instance because they belong to a different class.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`printAverageNumberOfBabies`方法使用`getAverageNumberOfBabies`返回的`int`值和`getBaby`方法返回的`String`来生成代表虚拟动物平均幼崽数量的`String`。`VirtualHorse`类实现了继承的`getAverageNumberOfBabies`抽象方法，其中的代码返回`1`。`AmericanQuarterHorse`和`ShireHorse`类实现了继承的`getBaby`抽象方法，其中的代码返回代表虚拟马种类的幼崽的`String`："AQH
    baby"和"ShireHorse baby"。因此，我们对`printAverageNumberOfBabies`方法的调用将在每个实例中产生不同的结果，因为它们属于不同的类。'
- en: The `printAsciiArt` method uses the `String` returned by the `getAsciiArt` method
    to print the ASCII art that represents a virtual horse. The `AmericanQuarterHorse`
    and `ShireHorse` classes implemented the inherited `getAsciiArt` abstract method
    with code that returns a `String` with the ASCII art that is appropriate for each
    virtual horse that the class represents. Thus, our call to the `printAsciiArt`
    method will produce different results in each instance because they belong to
    a different class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`printAsciiArt`方法使用`getAsciiArt`方法返回的`String`来打印代表虚拟马的ASCII艺术。`AmericanQuarterHorse`和`ShireHorse`类实现了继承的`getAsciiArt`抽象方法，其中的代码返回适用于每个类所代表的虚拟马的ASCII艺术的`String`。因此，我们对`printAsciiArt`方法的调用将在每个实例中产生不同的结果，因为它们属于不同的类。'
- en: The following screenshot shows the results of executing the previous lines in
    JShell. Both instances run the same code for the two methods that were coded in
    the `VirtualAnimal` abstract class. However, each class provided a different implementation
    for the methods that end up being called to generate the result and cause the
    differences in the output.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中执行前几行的结果。两个实例对在`VirtualAnimal`抽象类中编写的两个方法运行相同的代码。然而，每个类为最终被调用以生成结果并导致输出差异的方法提供了不同的实现。
- en: '![Understanding polymorphism](img/00070.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![理解多态性](img/00070.jpeg)'
- en: The following lines create an instance of the `Thoroughbred` class named `willow`,
    and then call its `printAsciiArt` method. As happened before, JShell will display
    a message for each constructor that is executed as a result of the chained constructors
    we coded. The code file for the sample is included in the `java_9_oop_chapter_07_01`
    folder, in the `example07_01.java` file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个名为`willow`的`Thoroughbred`类的实例，然后调用了它的`printAsciiArt`方法。与之前一样，JShell将显示每个构造函数执行的消息，这是我们编写的链式构造函数的结果。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_01.java`文件中。
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The following screenshot shows the results of executing the previous lines in
    JShell. The new instance is from a class that provides a different implementation
    of the `getAsciiArt` method, and therefore, we will see different ASCII art from
    what we saw in the previous two calls to the same method for the other instances.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中执行前几行的结果。新实例来自一个提供了`getAsciiArt`方法不同实现的类，因此，我们将看到与之前对其他实例调用相同方法时所看到的不同ASCII艺术。
- en: '![Understanding polymorphism](img/00071.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![理解多态性](img/00071.jpeg)'
- en: The following lines call the `neigh` method for the instance named `willow`
    with a different number of arguments. This way, we take advantage of the `neigh`
    method that we overloaded four times with different arguments. Remember that we
    coded the four `neigh` methods in the `VirtualHorse` class and the `Thoroughbred`
    class inherits the overloaded methods from this superclass through its hierarchy
    tree. The code file for the sample is included in the `java_9_oop_chapter_07_01`
    folder, in the `example07_01.java` file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行调用了名为`willow`的实例的`neigh`方法，使用不同数量的参数。这样，我们利用了使用不同参数重载了四次的`neigh`方法。请记住，我们在`VirtualHorse`类中编写了这四个`neigh`方法，而`Thoroughbred`类通过其继承树从这个超类继承了重载的方法。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_01.java`文件中。
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following screenshot shows the results of calling the `neigh` and `nicker`
    methods with the different arguments in JShell:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中使用不同参数调用`neigh`和`nicker`方法的结果：
- en: '![Understanding polymorphism](img/00072.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![理解多态性](img/00072.jpeg)'
- en: We called the four versions of the `neigh` method defined in the `VirtualHorse`
    class for the `Thoroughbred` instance named `willow`. The third and fourth lines
    that call the `neigh` method specify a value for the `otherDomesticMammal` argument
    of type `VirtualDomesticMammal`. The third line specifies `american` as the value
    for `otherDomesticMammal` and the fourth line specifies `zelda` as the value for
    the same argument. Both the `AmericanQuarterHorse` and `ShireHorse` concrete classes
    are subclasses of `VirtualHorse`, and `VirtualHorse` is a subclass of `VirtualDomesticMammal`.
    Hence, we can use `american` and `zelda` as arguments where a `VirtualDomesticMammal`
    instance is required.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为名为“willow”的“Thoroughbred”实例调用了“VirtualHorse”类中定义的“neigh”方法的四个版本。调用“neigh”方法的第三行和第四行指定了类型为“VirtualDomesticMammal”的“otherDomesticMammal”参数的值。第三行指定“american”作为“otherDomesticMammal”的值，第四行指定相同参数的值为“zelda”。“AmericanQuarterHorse”和“ShireHorse”具体类都是“VirtualHorse”的子类，“VirtualHorse”是“VirtualDomesticMammal”的子类。因此，我们可以在需要“VirtualDomesticMammal”实例的地方使用“american”和“zelda”作为参数。
- en: Then, we called the four versions of the `nicker` method defined in the `VirtualHorse`
    class for the `AmericanQuarterHorse` instance named `american`. The third and
    fourth lines that call the `nicker` method specify `willow` as the value for the
    `otherDomesticMammal` argument of type `VirtualDomesticMammal`. The `Thoroughbred`
    concrete class is also a subclass of `VirtualHorse`, and `VirtualHorse` is a subclass
    or `VirtualDomesticMammal`. Hence, we can use `willow` as an argument where a
    `VirtualDomesticMammal` instance is required.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为名为“american”的“AmericanQuarterHorse”实例调用了“VirtualHorse”类中定义的“nicker”方法的四个版本。调用“nicker”方法的第三行和第四行指定了类型为“VirtualDomesticMammal”的“otherDomesticMammal”参数的值为“willow”。“Thoroughbred”具体类也是“VirtualHorse”的子类，“VirtualHorse”是“VirtualDomesticMammal”的子类。因此，我们可以在需要“VirtualDomesticMammal”实例的地方使用“willow”作为参数。
- en: Controlling overridability of members in subclasses
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制子类中成员的可覆盖性
- en: 'We will code the `VirtualDomesticCat` abstract class and its concrete subclass:
    `MaineCoon`. Then, we will code the `VirtualBird` abstract class, its `VirtualDomesticBird`
    abstract subclass, and the `Cockatiel` concrete subclass. Finally, we will code
    the `VirtualDomesticRabbit` concrete class. While coding these classes, we will
    use Java 9 features that allow us to decide whether the subclasses can or cannot
    override specific members.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写“VirtualDomesticCat”抽象类及其具体子类：“MaineCoon”。然后，我们将编写“VirtualBird”抽象类、其“VirtualDomesticBird”抽象子类和“Cockatiel”具体子类。最后，我们将编写“VirtualDomesticRabbit”具体类。在编写这些类时，我们将使用Java
    9的功能，允许我们决定子类是否可以覆盖特定成员。
- en: 'All the virtual domestic cats must be able to talk, and therefore, we will
    override the `talk` method inherited from `VirtualDomesticMammal` to print the
    word that represents a cat meowing: `"Meow"`. We also want to provide a method
    to print `"Meow"` a specific number of times. Hence, at this point, we realize
    that we can take advantage of the `printSoundInWords` method we declared in the
    `VirtualHorse` class.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有虚拟家猫都必须能够说话，因此，我们将覆盖从“VirtualDomesticMammal”继承的“talk”方法，以打印代表猫叫声的单词：““Meow””。我们还希望提供一个方法来指定打印“Meow”的次数。因此，此时我们意识到我们可以利用在“VirtualHorse”类中声明的“printSoundInWords”方法。
- en: 'We cannot access this instance method in the `VirtualDomesticCat` abstract
    class because it doesn''t inherit from `VirtualHorse`. Thus, we will move this
    method from the `VirtualHorse` class to its superclass: `VirtualDomesticMammal`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在“VirtualDomesticCat”抽象类中访问此实例方法，因为它不是从“VirtualHorse”继承的。因此，我们将把这个方法从“VirtualHorse”类移动到它的超类：“VirtualDomesticMammal”。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We will use the `final` keyword before the return type for the methods that
    we don't want to be overridden in subclasses. When a method is marked as a final
    method, the subclasses cannot override the method and the Java 9 compiler shows
    an error if they try to do so.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在不希望在子类中被覆盖的方法的返回类型前使用“final”关键字。当一个方法被标记为最终方法时，子类无法覆盖该方法，如果它们尝试这样做，Java
    9编译器将显示错误。
- en: Not all the birds are able to fly in real-life. However, all our virtual birds
    are able to fly, and therefore, we will implement the inherited `isAbleToFly`
    abstract method as a final method that returns `true`. This way, we make sure
    that all the classes that inherit from the `VirtualBird` abstract class will always
    run this code for the `isAbleToFly` method and that they won't be able to override
    it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的鸟类在现实生活中都能飞。然而，我们所有的虚拟鸟类都能飞，因此，我们将实现继承的“isAbleToFly”抽象方法作为一个返回“true”的最终方法。这样，我们确保所有继承自“VirtualBird”抽象类的类都将始终运行此代码以进行“isAbleToFly”方法，并且它们将无法对其进行覆盖。
- en: The following UML diagram shows the members for the new abstract and concrete
    classes that we will code. In addition, the diagram shows the `printSoundInWords`
    method moved from the `VirtualHorse` abstract class to the `VirtualDomesticMammal`
    abstract class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下UML图显示了我们将编写的新抽象和具体类的成员。此外，该图显示了从“VirtualHorse”抽象类移动到“VirtualDomesticMammal”抽象类的“printSoundInWords”方法。
- en: '![Controlling overridability of members in subclasses](img/00073.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![控制子类中成员的可覆盖性](img/00073.jpeg)'
- en: First, we will create a new version of the `VirtualDomesticMammal` abstract
    class. We will add the `printSoundInWords` method that we have in the `VirtualHorse`
    abstract class and we will use the `final` keyword to indicate that we don't want
    to allow subclasses to override this method. The following lines show the new
    code for the `VirtualDomesticMammal` class. The code file for the sample is included
    in the `java_9_oop_chapter_07_01` folder, in the `example07_02.java` file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建“VirtualDomesticMammal”抽象类的新版本。我们将添加在“VirtualHorse”抽象类中的“printSoundInWords”方法，并使用“final”关键字指示我们不希望允许子类覆盖此方法。以下行显示了“VirtualDomesticMammal”类的新代码。示例的代码文件包含在“java_9_oop_chapter_07_01”文件夹中的“example07_02.java”文件中。
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After we enter the previous lines, JShell will display the following messages:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入上述行后，JShell将显示以下消息：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: JShell indicates us that the `VirtualHorse` class and its subclasses cannot
    be referenced until we correct an error for this class. The class declares the
    `printSoundInWords` method and overrides the recently added method with the same
    name and arguments in the `VirtualDomesticMammal` class. We used the `final` keyword
    in the new declaration to make sure that any subclass cannot override it, and
    therefore, the Java compiler generates the error message that JShell displays.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: JShell告诉我们，`VirtualHorse`类及其子类在我们纠正该类的错误之前不能被引用。该类声明了`printSoundInWords`方法，并在`VirtualDomesticMammal`类中重写了最近添加的具有相同名称和参数的方法。我们在新声明中使用了`final`关键字，以确保任何子类都不能覆盖它，因此，Java编译器生成了JShell显示的错误消息。
- en: Now, we will create a new version of the `VirtualHorse` abstract class. The
    following lines show the new version that removes the `printSoundInWords` method
    and uses the `final` keyword to make sure that many methods cannot be overridden
    by any of the subclasses. The declarations that use the `final` keyword to avoid
    the methods to be overridden are highlighted in the next lines. The code file
    for the sample is included in the `java_9_oop_chapter_07_01` folder, in the `example07_02.java`
    file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建`VirtualHorse`抽象类的新版本。以下行显示了删除了`printSoundInWords`方法并使用`final`关键字确保许多方法不能被任何子类覆盖的新版本。在下面的行中，使用`final`关键字避免方法被覆盖的声明已经被突出显示。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_02.java`文件中。
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After we enter the previous lines, JShell will display the following messages:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 输入上述行后，JShell将显示以下消息：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We replaced the definition for the `VirtualHorse` class and the subclasses were
    also updated. It is important to know that the variables we declared in JShell
    that held references to instances of subclasses of `VirtualHorse` were set to
    null.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们替换了`VirtualHorse`类的定义，并且子类也已更新。重要的是要知道，在JShell中声明的变量，它们持有`VirtualHorse`的子类实例的引用被设置为null。
- en: Controlling subclassing of classes
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制类的子类化
- en: The `final` keyword has one additional usage. We can use `final` as a modifier
    before the `class` keyword in the class declaration to indicate Java that we want
    to generate a **final class**, that is, a class that cannot be extended or subclassed.
    Java 9 won't allow us to create a subclass for a final class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`关键字有一个额外的用法。我们可以在类声明中的`class`关键字之前使用`final`作为修饰符，告诉Java我们要生成一个**final类**，即一个不能被扩展或子类化的类。Java
    9不允许我们为final类创建子类。'
- en: Now, we will create the `VirtualDomesticCat` abstract class and then we will
    declare a concrete subclass named `MaineCoon` as a final class. This way, we will
    make sure that nobody will be able to create a subclass of `MaineCoon`. The following
    lines show the code for the `VirtualDomesticCat` abstract class. The code file
    for the sample is included in the `java_9_oop_chapter_07_01` folder, in the `example07_02.java`
    file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建`VirtualDomesticCat`抽象类，然后我们将声明一个名为`MaineCoon`的具体子类作为final类。这样，我们将确保没有人能够创建`MaineCoon`的子类。以下行显示了`VirtualDomesticCat`抽象类的代码。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_02.java`文件中。
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `VirtualDomesticCat` abstract class implements many of the abstract methods
    inherited from the `VirtualDomesticMammal` superclass as final methods, and overrides
    the `talk` method with a final method. Thus, we won't be able to create a subclass
    of `VirtualDomesticCat` that overrides the `isAbleToFly` method to return `true`.
    We won't have virtual cats that will be able to fly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualDomesticCat`抽象类将从`VirtualDomesticMammal`超类继承的许多抽象方法实现为final方法，并用final方法重写了`talk`方法。因此，我们将无法创建一个覆盖`isAbleToFly`方法返回`true`的`VirtualDomesticCat`子类。我们将无法拥有能够飞行的虚拟猫。'
- en: 'The following lines show the code for the `MaineCoon` concrete class that inherits
    from `VirtualDomesticCat`. We declare `MaineCoon` as a final class and it overrides
    the inherited `getAverageNumberOfBabies` method to return `6`. In addition, the
    final class implements the following inherited abstract methods: `getBaby` and
    `getAsciiArt`. The code file for the sample is included in the `java_9_oop_chapter_07_01`
    folder, in the `example07_02.java` file.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了从`VirtualDomesticCat`继承的`MaineCoon`具体类的代码。我们将`MaineCoon`声明为final类，并且它重写了继承的`getAverageNumberOfBabies`方法以返回`6`。此外，该final类实现了以下继承的抽象方法：`getBaby`和`getAsciiArt`。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_02.java`文件中。
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We didn't mark any method as `final` because all the methods in a final class
    are implicitly final.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有将任何方法标记为`final`，因为在final类中的所有方法都是隐式final的。
- en: However, when we run Java code outside of JShell, the final class will be created
    and we won't be able to subclass it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们在JShell之外运行Java代码时，final类将被创建，我们将无法对其进行子类化。
- en: Now, we will create the `VirtualBird` abstract class that inherits from `VirtualAnimal`.
    The following lines show the code for the `VirtualBird` abstract class. The code
    file for the sample is included in the `java_9_oop_chapter_07_01` folder, in the
    `example07_02.java` file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建从`VirtualAnimal`继承的`VirtualBird`抽象类。以下行显示了`VirtualBird`抽象类的代码。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_02.java`文件中。
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `VirtualBird` abstract class inherits the members from the previously declared
    `VirtualAnimal` abstract class and adds a new `String` mutable field named `feathersColor`.
    The new abstract class declares a constructor that requires initial values for
    `age` and `feathersColor` to create an instance of the class. The constructor
    uses the `super` keyword to call the constructor from the base class or superclass,
    that is, the constructor defined in the `VirtualAnimal` class that requires the
    `age` argument. After the constructor defined in the superclass finishes its execution,
    the code sets the value for the `feathersColor` mutable field and prints a message
    indicating that a virtual bird has been created.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualBird`抽象类继承了先前声明的`VirtualAnimal`抽象类的成员，并添加了一个名为`feathersColor`的新的可变的`String`字段。新的抽象类声明了一个构造函数，该构造函数需要`age`和`feathersColor`的初始值来创建类的实例。构造函数使用`super`关键字调用来自基类或超类的构造函数，即在`VirtualAnimal`类中定义的构造函数，该构造函数需要`age`参数。在超类中定义的构造函数执行完毕后，代码设置了`feathersColor`可变字段的值，并打印了一条消息，指示已创建了一个虚拟鸟类。'
- en: The `VirtualBird` abstract class implements the inherited `isAbleToFly` method
    as a final method that returns `true`. We want to make sure that all the virtual
    birds in our application domain are able to fly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualBird`抽象类实现了继承的`isAbleToFly`方法作为一个最终方法，返回`true`。我们希望确保我们应用程序领域中的所有虚拟鸟都能飞。'
- en: Now, we will create the `VirtualDomesticBird` abstract class that inherits from
    `VirtualBird`. The following lines show the code for the `VirtualDomesticBird`
    abstract class. The code file for the sample is included in the `java_9_oop_chapter_07_01`
    folder, in the `example07_02.java` file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建从`VirtualBird`继承的`VirtualDomesticBird`抽象类。以下行显示了`VirtualDomesticBird`抽象类的代码。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_02.java`文件中。
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `VirtualDomesticBird` abstract class inherits the members from the previously
    declared `VirtualBird` abstract class and adds a new `String` immutable field
    called `name`. The new abstract class declares a constructor that requires initial
    values for `age`, `feathersColor`, and `name` to create an instance of the class.
    The constructor uses the `super` keyword to call the constructor from the superclass,
    that is, the constructor defined in the `VirtualBird` class that requires the
    `age` and `feathersColor` arguments. After the constructor defined in the superclass
    finishes its execution, the code sets the value for the `name` immutable field
    and prints a message indicating that a virtual domestic bird has been created.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualDomesticBird`抽象类继承了先前声明的`VirtualBird`抽象类的成员，并添加了一个名为`name`的新的不可变的`String`字段。新的抽象类声明了一个构造函数，该构造函数需要`age`、`feathersColor`和`name`的初始值来创建类的实例。构造函数使用`super`关键字调用来自超类的构造函数，即在`VirtualBird`类中定义的构造函数，该构造函数需要`age`和`feathersColor`参数。在超类中定义的构造函数执行完毕后，代码设置了`name`不可变字段的值，并打印了一条消息，指示已创建了一个虚拟家禽。'
- en: 'The following lines show the code for the `Cockatiel` concrete class that inherits
    from `VirtualDomesticBird`. We declare `Cockatiel` as a final class and it implements
    the following inherited abstract methods: `isRideable`, `isHerbivore`, `isCarnivore`,
    `getAverageNumberOfBabies`, `getBaby`, and `getAsciiArt`. As previously explained,
    all the methods in a final class are implicitly final. The code file for the sample
    is included in the `java_9_oop_chapter_07_01` folder, in the `example07_02.java`
    file.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了从`VirtualDomesticBird`继承的`Cockatiel`具体类的代码。我们将`Cockatiel`声明为最终类，并实现以下继承的抽象方法：`isRideable`、`isHerbivore`、`isCarnivore`、`getAverageNumberOfBabies`、`getBaby`和`getAsciiArt`。如前所述，最终类中的所有方法都是隐式最终的。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_02.java`文件中。
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following lines show the code for the `VirtualDomesticRabbit` concrete
    class that inherits from `VirtualDomesticMammal`. We declare `VirtualDomesticRabbit`
    as a final class because we don''t want additional subclasses. We will just have
    one type of virtual domestic rabbit in our application domain. The final class
    implements the following inherited abstract methods: `isAbleToFly`, `isRideable`,
    `isHerbivore`, `isCarnivore`, `getAverageNumberOfBabies`, `getBaby`, and `getAsciiArt`.
    The code file for the sample is included in the `java_9_oop_chapter_07_01` folder,
    in the `example07_02.java` file.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了从`VirtualDomesticMammal`继承的`VirtualDomesticRabbit`具体类的代码。我们将`VirtualDomesticRabbit`声明为最终类，因为我们不希望有额外的子类。我们只会在我们的应用程序领域中有一种虚拟家兔。最终类实现了以下继承的抽象方法：`isAbleToFly`、`isRideable`、`isHerbivore`、`isCarnivore`、`getAverageNumberOfBabies`、`getBaby`和`getAsciiArt`。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_02.java`文件中。
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: JShell ignores the `final` modifier, and therefore, a class declared with the
    `final` modifier will allow subclasses in JShell.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: JShell忽略`final`修饰符，因此，使用`final`修饰符声明的类将允许在JShell中存在子类。
- en: Creating methods that work with instances of different subclasses
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建与不同子类实例一起工作的方法
- en: 'After we declare all the new classes, we will create the following two methods
    that receive a `VirtualAnimal` instance as an argument, that is, a `VirtualAnimal`
    instance or an instance of any subclass of `VirtualAnimal`. Each method calls
    a different instance method defined in the `VirtualAnimal` class: `printAverageNumberOfBabies`
    and `printAsciiArg`. The code file for the sample is included in the `java_9_oop_chapter_07_01`
    folder, in the `example07_02.java` file.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明所有新类之后，我们将创建以下两个方法，这两个方法接收一个`VirtualAnimal`实例作为参数，即`VirtualAnimal`实例或`VirtualAnimal`的任何子类的实例。每个方法调用`VirtualAnimal`类中定义的不同实例方法：`printAverageNumberOfBabies`和`printAsciiArg`。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_02.java`文件中。
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then the following lines create instances of the next classes: `Cockatiel`,
    `VirtualDomesticRabbit`, and `MaineCoon`. The code file for the sample is included
    in the `java_9_oop_chapter_07_01` folder, in the `example07_02.java` file.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后以下行创建了下列类的实例：`Cockatiel`、`VirtualDomesticRabbit`和`MaineCoon`。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_02.java`文件中。
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The following screenshot shows the results of executing the previous lines in
    JShell. We will see the messages that the different constructors displayed in
    JShell after we enter the code to create each instance. These messages will allow
    us to easily understand all the chained constructors that were called when Java
    created each instance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中执行先前行的结果。在我们输入代码创建每个实例后，我们将看到不同构造函数在JShell中显示的消息。这些消息将帮助我们轻松理解Java在创建每个实例时调用的所有链接构造函数。
- en: '![Creating methods that work with instances of different subclasses](img/00074.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![创建与不同子类实例一起工作的方法](img/00074.jpeg)'
- en: Then the following lines call the `printBabies` and `printAsciiArt` methods
    with the previously created instances as arguments. The code file for the sample
    is included in the `java_9_oop_chapter_07_01` folder, in the `example07_02.java`
    file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以下行调用了`printBabies`和`printAsciiArt`方法，并将先前创建的实例作为参数传递。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_02.java`文件中。
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The three instances become a `VirtualAnimal` argument for the different methods,
    that is, they take the form of a `VirtualAnimal` instance. However, the values
    used for the fields and the methods aren''t those declared in the `VirtualAnimal`
    class. The call to the `printAverageNumberOfBabies` and `printAsciiArt` instance
    methods take into account all the members declared in the subclasses because each
    instance is an instance of a subclass of `VirtualAnimal`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个实例成为不同方法的`VirtualAnimal`参数，即它们采用`VirtualAnimal`实例的形式。然而，字段和方法使用的值并非在`VirtualAnimal`类中声明的。对`printAverageNumberOfBabies`和`printAsciiArt`实例方法的调用考虑了所有在子类中声明的成员，因为每个实例都是`VirtualAnimal`的子类的实例：
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `printBabies` and `printAsciiArt` methods that receive a `VirtualAnimal`
    instance as an argument can only access the members defined in the `VirtualAnimal`
    class for the instances that they receive as arguments because the argument type
    is `VirtualAnimal`. We can unwrap the `Cockatiel`, `VirtualDomesticRabbit`, and
    `MaineCoon` instances that are received in the `animal` argument if necessary.
    However, we will work with these scenarios later as we cover more advanced topics.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接受`VirtualAnimal`实例作为参数的`printBabies`和`printAsciiArt`方法只能访问为它们接收的实例在`VirtualAnimal`类中定义的成员，因为参数类型是`VirtualAnimal`。如果需要，我们可以解开接收到的`animal`参数中的`Cockatiel`、`VirtualDomesticRabbit`和`MaineCoon`实例。然而，随着我们涵盖更高级的主题，我们将在以后处理这些情景。
- en: The following screenshot shows the results of executing the previous lines for
    the `Cockatiel` instance named `tweety` in JShell.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中为名为“tweety”的`Cockatiel`实例执行先前行的结果。
- en: '![Creating methods that work with instances of different subclasses](img/00075.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![创建与不同子类实例一起工作的方法](img/00075.jpeg)'
- en: The following screenshot shows the results of executing the previous lines for
    the `VirtualDomesticRabbit` instance named `bunny` in JShell.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中为名为“bunny”的`VirtualDomesticRabbit`实例执行先前行的结果。
- en: '![Creating methods that work with instances of different subclasses](img/00076.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![创建与不同子类实例一起工作的方法](img/00076.jpeg)'
- en: The following screenshot shows the results of executing the previous lines for
    the `MaineCoon` instance named `garfield` in JShell.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中为名为“garfield”的`MaineCoon`实例执行先前行的结果。
- en: '![Creating methods that work with instances of different subclasses](img/00077.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![创建与不同子类实例一起工作的方法](img/00077.jpeg)'
- en: Now we will create another method that receives a `VirtualDomesticMammal` instance
    as an argument, that is, a `VirtualDomesticMammal` instance or an instance of
    any subclass of `VirtualDomesticMammal`. The following function calls the `talk`
    instance method defined in the `VirtualDomesticMammal` class. The code file for
    the sample is included in the `java_9_oop_chapter_07_01` folder, in the `example07_02.java`
    file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建另一个方法，该方法接收一个`VirtualDomesticMammal`实例作为参数，即`VirtualDomesticMammal`实例或`VirtualDomesticMammal`的任何子类的实例。以下函数调用了在`VirtualDomesticMammal`类中定义的`talk`实例方法。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_02.java`文件中。
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, the following two lines call the `makeItTalk` method with the `VirtualDomesticRabbit`
    and `MaineCoon` instances as arguments: `bunny` and `garfield`. The code file
    for the sample is included in the `java_9_oop_chapter_07_01` folder, in the `example07_02.java`
    file.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以下两行调用了`makeItTalk`方法，并将`VirtualDomesticRabbit`和`MaineCoon`实例作为参数：`bunny`和`garfield`。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_02.java`文件中。
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The call to the same method for a `VirtualDomesticMammal` instance received
    as an argument produces different results. The `VirtualDomesticRabbit` didn''t
    override the inherited `talk` method while the `MaineCoon` class inherited the
    `talk` method overridden in the `VirtualDomesticCat` abstract class to make domestic
    cat meow. The following screenshot shows the results of the two method calls in
    JShell:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对接收到的`VirtualDomesticMammal`实例调用相同方法会产生不同的结果。`VirtualDomesticRabbit`没有覆盖继承的`talk`方法，而`MaineCoon`类继承了在`VirtualDomesticCat`抽象类中被覆盖的`talk`方法，使家猫发出喵喵的声音。以下截图显示了在JShell中进行的两个方法调用的结果。
- en: '![Creating methods that work with instances of different subclasses](img/00078.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![创建与不同子类实例一起工作的方法](img/00078.jpeg)'
- en: 'The `VirtualAnimal` abstract class declared two instance methods that allow
    us to determine whether a virtual animal is younger or older than an other virtual
    animal: `isYoungerThan` and `isOlderThan`. These two methods receive a `VirtualAnimal`
    argument and return the results of applying an operator between the `age` value
    for the instance and the `age` value of the received instance.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualAnimal`抽象类声明了两个实例方法，允许我们确定虚拟动物是比另一个虚拟动物更年轻还是更年长：`isYoungerThan`和`isOlderThan`。这两个方法接收一个`VirtualAnimal`参数，并返回在实例的`age`值和接收实例的`age`值之间应用运算符的结果。'
- en: 'The following lines call the `printAge` method for the three instances: `tweety`,
    `bunny`, and `garfield`. This method was declared in the `VirtualAnimal` class.
    Then, the next lines call the `isOlderThan` and `isYoungerThan` methods with these
    instances as arguments to display the results of comparing the age of the different
    instances. The code file for the sample is included in the `java_9_oop_chapter_07_01`
    folder, in the `example07_02.java` file.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行调用`printAge`方法的三个实例：`tweety`，`bunny`和`garfield`。此方法在`VirtualAnimal`类中声明。然后，下一行调用`isOlderThan`和`isYoungerThan`方法，并将这些实例作为参数，以显示比较不同实例年龄的结果。示例的代码文件包含在`java_9_oop_chapter_07_01`文件夹中的`example07_02.java`文件中。
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following screenshot shows the results of executing the previous lines
    in JShell:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中执行前面行的结果：
- en: '![Creating methods that work with instances of different subclasses](img/00079.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![创建可以与不同子类的实例一起工作的方法](img/00079.jpeg)'
- en: Test your knowledge
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的知识
- en: 'Which of the following lines declares an instance method that cannot be overridden
    in any subclass:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪行声明了一个实例方法，不能在任何子类中被覆盖：
- en: '`public void talk(): final {`'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public void talk(): final {`'
- en: '`public final void talk() {`'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public final void talk() {`'
- en: '`public notOverrideable void talk() {`'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public notOverrideable void talk() {`'
- en: 'We have an abstract superclass named `Shape`. The `Circle` class is a subclass
    of `Shape` and is a concrete class. If we create an instance of `Circle` named
    `circle`, this instance will also be:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个名为`Shape`的抽象超类。`Circle`类是`Shape`的子类，是一个具体类。如果我们创建一个名为`circle`的`Circle`实例，这个实例也将是：
- en: An instance of `Shape`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Shape`的一个实例。'
- en: A subclass of `Circle`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Circle`的子类。'
- en: An abstract superclass of `Circle`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Circle`的一个抽象超类。'
- en: 'In UML diagrams, class names that use italic text format indicate that they
    are:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UML图中，使用斜体文本格式的类名表示它们是：
- en: Concrete classes.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具体类。
- en: Classes that override at least one member inherited from its superclass.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖了至少一个从其超类继承的成员的具体类。
- en: Abstract classes.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象类。
- en: 'Which of the following lines declares a class that cannot be subclassed:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪行声明了一个不能被子类化的类：
- en: '`public final class Dog extends VirtualAnimal {`'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public final class Dog extends VirtualAnimal {`'
- en: '`public final class Dog subclasses VirtualAnimal {`'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public final class Dog subclasses VirtualAnimal {`'
- en: '`public final Dog subclasses VirtualAnimal {`'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public final Dog subclasses VirtualAnimal {`'
- en: 'Which of the following lines declares a concrete class named `Circle` that
    can be subclassed and whose superclass is the `Shape` abstract class:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪行声明了一个名为`Circle`的具体类，可以被子类化，其超类是`Shape`抽象类：
- en: '`public final class Shape extends Circle {`'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public final class Shape extends Circle {`'
- en: '`public class Shape extends Circle {`'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public class Shape extends Circle {`'
- en: '`public concrete class Shape extends Circle {`'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public concrete class Shape extends Circle {`'
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we created many abstract and concrete classes. We learned to
    control whether subclasses can or cannot override members, and whether classes
    can be subclassed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了许多抽象和具体类。我们学会了控制子类是否可以覆盖成员，以及类是否可以被子类化。
- en: We worked with instances of many subclasses and we understood that objects can
    take many forms. We worked with many instances and their methods in JShell to
    understand how the classes and the methods that we coded are executed. We used
    methods that performed operations with instances of different classes that had
    a common superclass.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了许多子类的实例，并且了解到对象可以采用许多形式。我们在JShell中使用了许多实例及其方法，以了解我们编写的类和方法是如何执行的。我们使用了执行与具有共同超类的不同类的实例的操作的方法。
- en: Now that you have learned about members inheritance and polymorphism, we are
    ready to use contract programming with interfaces in Java 9, which is the topic
    we are going to discuss in the next chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了成员继承和多态性，我们准备在Java 9中使用接口进行契约编程，这是我们将在下一章中讨论的主题。
