- en: Part II. Other Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分。其他模式
- en: Functional Programming
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Reactive Programming
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Application Patterns
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序模式
- en: Web Patterns
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Web模式
- en: Messaging Patterns
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 消息模式
- en: Microservices
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务
- en: Patterns for Testing
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模式
- en: Advanced Patterns
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 高级模式
- en: ECMAScript-2015/2016 Solutions Today
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript-2015/2016解决方案今天
- en: In Part 1 we focused on patterns originally identified in the GoF book that
    were the original impetus behind patterns in software design. In this part of
    the book we'll expand beyond those patterns to look at patterns that are related
    to functional programming, large-scale patterns for structuring an entire application,
    patterns which are specific to the Web, and messaging patterns. In addition, we'll
    look at patterns for testing and some rather interesting advanced patterns. Finally,
    we'll look at how we can get many of the features of the next version of JavaScript
    today.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，我们专注于GoF书中最初确定的模式，这些模式是软件设计模式背后的最初动力。在本书的这一部分中，我们将超越这些模式，看看与函数式编程相关的模式，用于构建整个应用程序的大规模模式，专门用于Web的模式以及消息模式。此外，我们将研究测试模式和一些非常有趣的高级模式。最后，我们将看看如何在今天就能获得JavaScript下一个版本的许多功能。
- en: Chapter 6. Functional Programming
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。函数式编程
- en: Functional programming is a different approach to development than the heavily
    object oriented approach that we have focused on so far. Object oriented programming
    is a fantastic tool for solving a great number of problems but it has some issues.
    Parallel programming within an object oriented context is difficult as the state
    can be changed by various different threads with unknown side effects. Functional
    programming does not permit state or mutable variables. Functions act as primary
    building blocks in functional programming. Places where you might have used a
    variable in the past will now use a function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种与我们迄今为止专注的重度面向对象方法不同的开发方法。面向对象编程是解决许多问题的绝佳工具，但也存在一些问题。在面向对象的上下文中进行并行编程是困难的，因为状态可能会被不同的线程改变，产生未知的副作用。函数式编程不允许状态或可变变量。函数在函数式编程中充当主要的构建块。在过去可能使用变量的地方现在将使用函数。
- en: Even in a single threaded program, functions can have side-effects that change
    global state. This means that, when calling an unknown function, it can alter
    the whole flow of the program. This makes debugging a program quite difficult.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在单线程程序中，函数也可能具有改变全局状态的副作用。这意味着，当调用一个未知的函数时，它可能改变程序的整个流程。这使得调试程序变得非常困难。
- en: 'JavaScript is not a functional programming language but we can still apply
    some functional principles to our code. We''ll look at a number of patterns in
    the functional space:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript并不是一种函数式编程语言，但我们仍然可以将一些函数式原则应用到我们的代码中。我们将研究函数式空间中的许多模式：
- en: Function passing
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数传递
- en: Filters and pipes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器和管道
- en: Accumulators
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累加器
- en: Memoization
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录
- en: Immutability
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: Lazy instantiation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟实例化
- en: Functional functions are side-effect-free
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式函数是无副作用的
- en: A core tenant of functional programming is that functions should not change
    state. Values local to the function may be set but nothing outside the function
    may change. This approach is very useful for making code more maintainable. There
    need no longer be any concern that passing an array into a function is going to
    play havoc with its contents. This is especially a concern when using libraries
    that are not under your control.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的核心原则之一是函数不应改变状态。函数内部的局部值可以被设置，但函数外部的任何东西都不可以改变。这种方法对于使代码更易维护非常有用。不再需要担心将数组传递给函数会对其内容造成混乱。特别是在使用不受控制的库时，这是一个问题。
- en: There is no mechanism within JavaScript to prevent you from changing global
    state. Instead you must rely on developers to write side-effect-free functions.
    This may be difficult or not, depending on the maturity of the team.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript内部没有机制可以阻止您改变全局状态。相反，您必须依赖开发人员编写无副作用的函数。这可能很困难，也可能不是，这取决于团队的成熟度。
- en: It may not be desirable to put all the code from your application into functions,
    but separating as much as possible is desirable. There is a pattern called command
    query separation that suggests that methods should fall into two categories. Either
    they are a function that reads a value or they are a command that sets a value.
    Never the twain should meet. Keeping methods categorized like this eases in debugging
    and in code reuse.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 也许并不希望将应用程序中的所有代码都放入函数中，但尽可能地分离是可取的。有一种称为命令查询分离的模式建议方法应该分为两类。要么是读取值的函数，要么是设置值的命令。二者不可兼得。保持方法按此分类有助于调试和代码重用。
- en: One of the consequences of side effect-free functions is that they can be called
    any number of times with the same inputs and the result will be the same. Furthermore,
    because there are no changes to state, calling the function many times will not
    cause any ill side effects, other than making it run slower.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无副作用函数的一个结果是，它们可以使用相同的输入被调用任意次数，结果都将是相同的。此外，由于没有状态的改变，多次调用函数不会产生任何不良副作用，除了使其运行速度变慢。
- en: Function passing
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数传递
- en: In functional programming languages, functions are first class citizens. Functions
    can be assigned to variables and passed around just like you would with any other
    variable. This is not entirely a foreign concept. Even languages such as C had
    function pointers that could be treated just like other variables. C# has delegates
    and, in more recent versions, lambdas. The latest release of Java has also added
    support for lambdas as they have proven to be so useful.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程语言中，函数是一等公民。函数可以赋值给变量并像处理其他变量一样传递。这并不是完全陌生的概念。即使像C这样的语言也有可以像其他变量一样处理的函数指针。C#有委托，在更近期的版本中有lambda。最新版本的Java也添加了对lambda的支持，因为它们被证明非常有用。
- en: JavaScript allows for functions to be treated as variables and even as objects
    and strings. In this way JavaScript is functional in nature.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript允许将函数视为变量，甚至作为对象和字符串。这样，JavaScript在本质上是函数式的。
- en: 'Because of JavaScript''s single threaded nature, callbacks are a common convention
    and you can find them pretty much everywhere. Consider calling a function at a
    later date on a web page. This is done by setting a timeout on the window object
    like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript的单线程特性，回调是一种常见的约定，你几乎可以在任何地方找到它们。考虑在网页上的稍后时间调用一个函数。这是通过在window对象上设置超时来实现的，就像这样：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The arguments for the set timeout function are a function to call and a time
    to delay in milliseconds.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 设置超时函数的参数是要调用的函数和以毫秒为单位的延迟时间。
- en: 'Irrespective of the JavaScript environment in which you''re working, it is
    almost impossible to avoid functions in the shape of callbacks. Node.js'' asynchronous
    processing model is highly dependent on being able to call a function and pass
    in something to be completed at a later date. Making calls to external resources
    in a browser is also dependent on a callback to notify the caller that some asynchronous
    operation has completed. In basic JavaScript this looks like the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您在哪种JavaScript环境中工作，几乎不可能避免以回调函数的形式使用函数。Node.js的异步处理模型高度依赖于能够调用函数并传递一些内容以便在以后的某个日期完成。在浏览器中调用外部资源也依赖于回调来通知调用者某些异步操作已完成。在基本的JavaScript中，这看起来像这样：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You may notice that we assign the `onreadystatechange` function before we even
    send the request. This is because assigning it later may result in a race condition
    in which the server responds before the function is attached to the ready state
    change. In this case, we''ve used an inline function to process the returned data.
    Because functions are first class citizens we can change this to look like the
    following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到我们在发送请求之前就分配了`onreadystatechange`函数。这是因为稍后分配可能会导致服务器在函数附加到准备状态更改之前做出响应的竞争条件。在这种情况下，我们使用内联函数来处理返回的数据。因为函数是一等公民，我们可以将其更改为以下形式：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is typically a cleaner approach and avoids performing complex processing
    in line with another function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是一种更清晰的方法，避免在另一个函数中执行复杂的处理。
- en: 'However, you might be more familiar with the jQuery version of this, which
    looks something like the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可能更熟悉jQuery版本，它看起来像这样：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case the boiler plate of dealing with ready state changes is handled
    for you. There is even convenience provided for you if the request for data fails:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，处理准备状态变化的模板已经为您处理了。如果请求数据失败，甚至还为您提供了便利：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, we've passed an object into the `ajax` call which defines a number
    of properties. Amongst these properties are function callbacks for success and
    failure. This method of passing numerous functions into another suggests a great
    way of providing expansion points for classes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将一个对象传递给`ajax`调用，该对象定义了许多属性。在这些属性中，成功和失败的函数回调是其中之一。将多个函数传递到另一个函数中的这种方法表明了为类提供扩展点的一种很好的方式。
- en: Likely you've seen this pattern in use before without even realizing it. Passing
    functions into constructors as part of an options object is a commonly used approach
    to providing extension hooks in JavaScript libraries. We saw some treatment of
    functions in the previous chapter, [Chapter 5](text00044.html#page "Chapter 5. Behavioral
    Patterns") , *Behavioral Patterns* , when passing function into the observer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能您以前已经看到过这种模式的使用，甚至没有意识到。将函数作为选项对象的一部分传递给构造函数是JavaScript库中提供扩展挂钩的常用方法。在上一章中，[第5章](text00044.html#page
    "第5章。行为模式")，*行为模式*中，我们看到了对函数的一些处理，当将函数传递给观察者时。
- en: Implementation
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: In Westeros the tourism industry is almost non-extant. There are great difficulties
    with bandits killing tourists and tourists becoming entangled in regional conflicts.
    Nonetheless, some enterprising folks have started to advertise a grant tour of
    Westeros in which they will take those with the means on a tour of all the major
    attractions. From King's Landing to Eyrie, to the great mountains of Dorne - the
    tour will cover it all. In fact, a rather mathematically inclined member of the
    tourism board has taken to calling it a Hamiltonian tour as it visits everywhere
    once.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛，旅游业几乎不存在。有很多困难，如强盗杀害游客和游客卷入地区冲突。尽管如此，一些有远见的人已经开始宣传维斯特洛斯的大巡回之旅，他们将带领有能力的人游览所有主要景点。从国王之地到艾利，再到多恩的巨大山脉-这次旅行将覆盖一切。事实上，旅游局中一个相当数学倾向的成员已经开始称其为哈密顿之旅，因为它到达每个地方一次。
- en: 'The `HamiltonianTour` class provides an options object which allows the definition
    of an options object. This object contains the various places to which a callback
    can be attached. In our case the interface for it would look something like the
    following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`HamiltonianTour`类提供了一个选项对象，允许定义一个选项对象。该对象包含可以附加回调的各种位置。在我们的情况下，它的接口看起来可能是以下样子：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The full `HamiltonianTour` class looks like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`HamiltonianTour`类如下所示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can see in the highlighted code how we check the options and then execute
    the callback as needed. This can be used by simply doing the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在突出显示的代码中看到我们如何检查选项，然后根据需要执行回调。只需简单地执行以下操作即可使用：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output from running this code would be the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码的输出将如下所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Passing functions is a great approach to solving a number of problems in JavaScript
    and tends to be used extensively by libraries such as jQuery and frameworks such
    as express. It is so commonly adopted that using it provides added barriers to
    your code's readability.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中传递函数是解决许多问题的好方法，并且在jQuery等库和express等框架中被广泛使用。它是如此普遍地被采用，以至于使用它会增加代码的可读性障碍。
- en: Filters and pipes
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器和管道
- en: 'If you''re at all familiar with the Unix command line or, to a lesser extent,
    the Windows command line, then you''ll have probably made use of pipes. A pipe,
    which is represented by the `|` character is shorthand for "take the output of
    program A and put it into program B". This relatively simple idea makes the Unix
    command line incredibly powerful. For instance, if you wanted to list all the
    files in a directory and then sort them and filter for any which start with either
    the letters `b` or `g` and end with an `f` then the command might look like the
    following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Unix命令行或者在较小程度上对Windows命令行有所了解，那么您可能已经使用过管道。管道由`|`字符表示，它是“获取程序A的输出并将其放入程序B”的简写。这个相对简单的想法使得Unix命令行非常强大。例如，如果您想要列出目录中的所有文件，然后对它们进行排序并过滤出以字母`b`或`g`开头并以`f`结尾的文件，那么命令可能如下所示：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `ls` command lists all files and directories, the `sort` command sorts
    them, and the `grep` command matches file names against a regular expression.
    Running this command in the `etc` directory on an Ubuntu box in `/etc` would give
    a result which looks something like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls`命令列出所有文件和目录，`sort`命令对它们进行排序，`grep`命令匹配文件名与正则表达式。在Ubuntu的`/etc`目录中运行这个命令会得到类似以下的结果：'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Some functional programming languages such as F# offer a special syntax for
    piping between functions. In F#, filtering a list for even numbers can be done
    in the following way:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数式编程语言，如F#，提供了在函数之间进行管道传递的特殊语法。在F#中，可以通过以下方式对列表进行偶数过滤：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This syntax is very nice-looking, especially when used for long chains of functions.
    As an example, taking a number, casting it to a float, square rooting it, and
    then rounding it would look like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法看起来非常漂亮，特别是在长链式函数中使用时。例如，将一个数字转换为浮点数，然后对其进行平方根运算，最后四舍五入，看起来会像下面这样：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is a clearer syntax than the C-style syntax that would look more like
    the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这比C风格的语法更清晰，后者看起来会像下面这样：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Unfortunately, there is no ability to write pipes in JavaScript using a nifty
    F# style syntax, but we can still improve upon the normal method shown in the
    preceding code by using method chaining.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，JavaScript没有使用巧妙的F#风格语法编写管道的能力，但是我们仍然可以通过方法链接来改进前面代码中显示的普通方法。
- en: Everything in JavaScript is an object, which means that we can have some real
    fun adding functionality to existing objects to improve their look. Operating
    on collections of objects is a space in which functional programming provides
    some powerful features. Let's start by adding a simple filtering method to the
    array object. You can think of these queries as being like SQL database queries
    written in a functional fashion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的所有内容都是对象，这意味着我们可以通过向现有对象添加功能来改进它们的外观。对对象集合进行操作是函数式编程提供一些强大功能的领域。让我们首先向数组对象添加一个简单的过滤方法。您可以将这些查询视为以函数式方式编写的SQL数据库查询。
- en: Implementation
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'We would like to provide a function that performs a match against each member
    of the array and returns a set of results:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望提供一个对数组的每个成员进行匹配并返回一组结果的函数：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The rather simple looking function allows us to quickly filter an array:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看起来相当简单的函数允许我们快速过滤一个数组：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What we return is also an object, an array object in this case. We can continue
    to chain methods onto it like the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回的也是一个对象，这种情况下是一个数组对象。我们可以继续像下面这样链式调用方法：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The result of this is an array containing only the number 6, as it is the only
    number between 1 and 10 which is both even and divisible by three. This method
    of returning a modified version of the original object without changing the original
    is known as a fluent interface. By not changing the original item array, we've
    introduced a small degree of immutability into our variables.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个只包含数字6的数组，因为它是1到10之间唯一既是偶数又可被三整除的数字。返回原始对象的修改版本而不改变原始对象的方法称为流畅接口。通过不改变原始的项目数组，我们为变量引入了一定程度的不可变性。
- en: 'If we add another function to our library of array extensions, we can start
    to see how useful these pipes can be:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向数组扩展库添加另一个函数，我们就可以开始看到这些管道有多么有用：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This extension allows for projections of the original items based on an arbitrary
    projection function. Given a set of objects which contain IDs and names, we can
    use our fluent extensions to array to perform complex operations:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展允许根据任意投影函数对原始项目进行投影。给定一组包含ID和名称的对象，我们可以使用我们的流畅扩展到数组来执行复杂的操作：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code will build a new array which contains only children with even IDs
    and instead of full objects, the array will contain only their names: `Sansa`
    and `Brandon` . For those familiar with .Net these functions may look very familiar.
    The **Language Integrated Queries** ( **LINQ** ) library on .Net provides similarly
    named functional inspired functions for the manipulation of collections.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将构建一个新数组，其中只包含具有偶数ID的子项，而不是完整的对象，数组将只包含它们的名称：`Sansa`和`Brandon`。对于熟悉.Net的人来说，这些函数可能看起来非常熟悉。.Net上的**语言集成查询**（**LINQ**）库提供了类似命名的受函数启发的函数，用于操作集合。
- en: 'Chaining functions in this manner can be both easier to understand and easier
    to build than alternatives: temporary variables are avoided and the code made
    terser. Consider the preceding example re-implemented using loops and temporary
    variables:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式链接函数既更容易理解，也更容易构建，因为避免了临时变量，代码更加简洁。考虑使用循环和临时变量重新实现前面的示例：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A number of JavaScript libraries such as d3 are constructed to encourage this
    sort of programming. At first it seems like the code created following this convention
    is bad due to very long line length. I would argue that this is a function of
    line length not being a very good tool to measure complexity rather than an actual
    problem with the approach.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 许多JavaScript库，比如d3，都是为了鼓励这种编程方式而构建的。起初，遵循这种约定创建的代码似乎很糟糕，因为行长非常长。我认为这是行长不是一个很好的衡量复杂性的工具，而不是这种方法的实际问题。
- en: Accumulators
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 累加器
- en: We've looked at some simple array functions which add filtering and pipes to
    arrays. Another useful tool is the accumulator. Accumulators aid in building up
    a single result by iterating over a collection. Many common operations such as
    summing up the elements of an array can be implemented using an accumulator instead
    of a loop.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了一些简单的数组函数，它们为数组添加了过滤和管道。另一个有用的工具是累加器。累加器通过对集合进行迭代来帮助构建单个结果。许多常见的操作，比如对数组元素求和，都可以使用累加器来实现，而不是使用循环。
- en: Recursion is popular within functional programming languages and many of them
    actually offer an optimization called "tail call optimization". A language that
    supports this provides optimizations for functions using recursion in which the
    stack frame is reused. This is very efficient and can easily replace most loops.
    Details on whether tail call optimization is supported in any JavaScript interpreter
    are sketchy. For the most part it doesn't seem like it is but we can still make
    use of recursion.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 递归在函数式编程语言中很受欢迎，其中许多语言实际上提供了一种称为“尾递归优化”的优化。支持这一点的语言为使用递归的函数提供了优化，其中堆栈帧被重用。这是非常高效的，可以轻松地替代大多数循环。关于JavaScript解释器是否支持尾递归优化的细节还不清楚。在大多数情况下，似乎并不支持，但我们仍然可以利用递归。
- en: 'The problem with `for` loops is that the control flow through the loop is mutable.
    Consider this rather easy-to-make mistake:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的问题在于循环中的控制流是可变的。考虑这个相当容易犯的错误：'
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Did you spot the error? It took me several attempts to get a working version
    of this code I could break. The problem is in the loop counter in the second loop,
    it should read as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你发现错误了吗？我尝试了几次才得到一个可行的版本，我才发现了问题。问题在于第二个循环中的循环计数器，它应该是这样的：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Obviously this could be somewhat mitigated through better variable naming but
    we would like to avoid the problem altogether.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，通过更好的变量命名可以在一定程度上缓解这个问题，但我们希望完全避免这个问题。
- en: Instead we can make use of an accumulator, a tool for combining multiple values
    from a collection into a single value. We've rather missed Westeros for a couple
    of patterns so let's get back to our mythical example land. Wars cost a great
    deal of money but fortunately there are a great number of peasants to pay taxes
    and finance the lords in their games for the throne.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以利用累加器，这是一个将集合中的多个值组合成单个值的工具。我们错过了Westeros的一些模式，所以让我们回到我们的神话般的例子。战争花费了大量的金钱，但幸运的是有大量的农民来交税，为领主们的王位之争提供资金。
- en: Implementation
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'Our peasants are represented by a simple model which looks like the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的农民由一个简单的模型代表，看起来像下面这样：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Over this set of peasants we have an accumulator which looks like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这组农民中，我们有一个看起来像下面这样的累加器：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code takes a list of items, an accumulator value, and a function that projects
    the value to be integrated into the accumulation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码接受一个项目列表，一个累加器值，以及一个将值投影到累加中的函数。
- en: 'The projection function looks something like the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 投影函数看起来像下面这样：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In order to prime this function, we simply need to pass in an initial value
    for the accumulator along with the array and projection. The priming value will
    vary but more often than not it will be an identity; an empty string in the case
    of a string accumulator and a 0 or 1 in the case of mathematical ones.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了激活这个函数，我们只需要传入一个累加器的初始值以及数组和投影。激活值会有所不同，但往往是一个身份；在字符串累加器的情况下是一个空字符串，在数学累加器的情况下是0或1。
- en: Each pass through the accumulator shrinks the size of the array over which we
    are operating. All this is done without a single mutable variable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过累加器，我们都会缩小我们操作的数组的大小。所有这些都是在没有一个可变变量的情况下完成的。
- en: 'The inner accumulation can really be any function you like: string appending,
    addition, or something more complicated. The accumulator is somewhat like the
    visitor pattern except that modifying values in the collection inside an accumulator
    is frowned upon. Remember that functional programming is side-effect-free.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 内部累积可以是任何你喜欢的函数：字符串追加，加法，或者更复杂的东西。累加器有点像访问者模式，只是在累加器内部修改集合中的值是不被赞同的。记住，函数式编程是无副作用的。
- en: Memoization
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化
- en: Not to be confused with memorization, memoization is a specific term for retaining
    a number of previously calculated values from a function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不要与记忆混淆，记忆化是一个特定术语，用于保留函数中先前计算的值。
- en: As we saw earlier, side-effect-free functions can be called multiple times without
    causing problems. The corollary to this is that a function can also be called
    fewer times than needed. Consider an expensive function which does some complex
    or, at least, time-consuming math. We know that the result of the function is
    entirely predicated on the inputs to the function. So the same inputs will always
    produce the same outputs. Why, then, would we need to call the function multiple
    times? If we saved the output of the function, we could retrieve that instead
    of redoing the time-consuming math.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，无副作用的函数可以被多次调用而不会引起问题。与此相对的是，函数也可以被调用的次数少于需要的次数。考虑一个复杂或者至少耗时的数学运算的昂贵函数。我们知道函数的结果完全取决于函数的输入。因此，相同的输入将始终产生相同的输出。那么，为什么我们需要多次调用函数呢？如果我们保存函数的输出，我们可以检索到它，而不是重新进行耗时的数学运算。
- en: Trading off space for time is a classic computing science problem. By caching
    the result, we make the application faster but we will consume more memory. Deciding
    when to perform caching and when to simply recalculate the result is a difficult
    problem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以空间换时间是一个经典的计算科学问题。通过缓存结果，我们可以使应用程序更快，但会消耗更多的内存。决定何时进行缓存，何时简单地重新计算结果是一个困难的问题。
- en: Implementation
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: In the land of Westeros, learned men, known as Maesters, have long had a fascination
    with a sequence of numbers which seems to reappear a great deal in the natural
    world. In a strange coincidence they call this sequence the Fibonacci sequence.
    It is defined by adding the two previous terms in the sequence to get the next
    one. The sequence is bootstrapped by defining the first few terms as 0, 1, 1\.
    So to get the next term we would simply add 1 and 1 to get 2\. The next term would
    add 2 and 1 to get 3 and so forth. Finding an arbitrary member of the sequence
    requires finding the two previous members, so it can end up being a bit of calculation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛大陆，被称为大师的学者们长期以来对一个数字序列产生了浓厚的兴趣，这个序列似乎在自然界中频繁出现。一个奇怪的巧合是，他们称这个序列为斐波那契数列。它的定义是将序列中的前两个项相加以得到下一个项。这个序列的起始项被定义为0、1、1。所以要得到下一个项，我们只需将1和1相加得到2。下一个项将2和1相加得到3，依此类推。找到序列的任意成员需要找到前两个成员，因此可能需要进行一些计算。
- en: In our world we have discovered a closed form that avoids much of this calculation
    but in Westeros no such discovery has been made.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的世界中，我们已经发现了一个避免大部分计算的封闭形式，但在维斯特洛还没有做出这样的发现。
- en: 'A naïve approach is to simply calculate every term like so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个朴素的方法是简单地计算每个项，如下所示：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This solution works very quickly for small numbers such as 10\. However, for
    larger numbers, say greater than 40, there is a substantial slow-down. This is
    because the base case is called 102,334,155 times.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案对于小数字（比如10）非常快。然而，对于更大的数字，比如大于40，速度会明显变慢。这是因为基本情况被调用了102,334,155次。
- en: 'Let''s see if we can improve things by memoizing some values:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否可以通过备忘录一些值来改善情况：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have just memoized every item we encounter. As it turns out for this algorithm
    we store *n+1* items, which is a pretty good trade-off. Without memoization, calculating
    the 40th fibonacci number took 963ms while the memoization version took only 11ms.
    The difference is far more pronounced when the functions become more complex to
    calculate. Fibonacci of 140 took 12 ms for the memoization version while the naïve
    version took… well, it is has been a day and it is still running.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚对我们遇到的每个项目进行了备忘录。事实证明，对于这个算法，我们存储了*n+1*个项目，这是一个相当不错的折衷。没有备忘录，计算第40个斐波那契数需要963毫秒，而备忘录版本只需要11毫秒。当函数变得更复杂时，差异会更加明显。备忘录版本的斐波那契数列140只需要12毫秒，而朴素版本……嗯，已经过了一天，它还在运行。
- en: The best part of this memoization is that subsequent calls to the function with
    the same parameter will be lightning-fast as the result is already computed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录的最大优点是，对具有相同参数的函数的后续调用将非常快，因为结果已经计算过了。
- en: In our example only a very small cache was needed. In more complex examples
    it is difficult to know how large a cache should be or how frequently a value
    will need to be recomputed. Ideally your cache will be large enough that there
    will always be room to put more results in. However, this may not be realistic
    and tough decisions will need to be made about which members of the cache should
    be removed to save space. There is a plethora of methods for performing cache
    invalidation. It has been said that cache invalidation is one of the toughest
    problems in computing science, the reason being that we're effectively trying
    to predict the future. If anybody has perfected a method of telling the future,
    it is likely they are applying their skills in a more important domain than cache
    invalidation. Two options are to prey on the least recently used member of the
    cache or the least frequently used member. It is possible that the shape of the
    problem may dictate a better strategy.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，只需要一个非常小的缓存。在更复杂的例子中，很难知道缓存应该有多大，或者一个值需要重新计算的频率。理想情况下，您的缓存应该足够大，以至于总是有足够的空间来放更多的结果。然而，这可能并不现实，需要做出艰难的决定，即哪些缓存成员应该被移除以节省空间。有很多方法可以执行缓存失效。有人说，缓存失效是计算科学中最棘手的问题之一，原因是我们实际上在试图预测未来。如果有人完善了一种预测未来的方法，那么他们很可能会将自己的技能应用于比缓存失效更重要的领域。两个选择是依赖于最近最少使用的缓存成员或最不经常使用的成员。问题的形状可能决定了更好的策略。
- en: Memoization is a fantastic tool for speeding up calculations which need to be
    performed multiple times or even calculations which have common sub-calculations.
    One can consider memoization as just a special case of caching, which is a commonly
    used technique when building web servers or browsers. It is certainly worthwhile
    exploring in more complex JavaScript applications.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录是加速需要多次执行的计算或者有共同子计算的计算的一个奇妙工具。人们可以将备忘录视为缓存的一种特殊情况，这是在构建网络服务器或浏览器时常用的技术。在更复杂的JavaScript应用程序中探索备忘录是值得的。
- en: Immutability
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不变性
- en: 'One of the cornerstones of functional programming is that so called variables
    can be assigned only once. This is known as immutability. ECMAScript 2015 supports
    a new keyword, `const` . The `const` keyword can be used in the same way as `var`
    except that variables assigned with `const` will be immutable. For instance, the
    following code shows a variable and a constant that are both manipulated in the
    same way:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的基石之一是所谓的变量只能被赋值一次。这就是不变性。ECMAScript 2015支持一个新关键字，`const`。`const`关键字可以像`var`一样使用，只是用`const`赋值的变量将是不可变的。例如，以下代码显示了一个变量和一个常量，它们都以相同的方式被操作：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of running this is the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的输出如下：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the results for the constant and variable are different.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，常数和变量的结果是不同的。
- en: 'If you''re using an older browser without support, then `const` won''t be available
    to you. A possible workaround is to make use of the `Object.freeze` functionality
    which is more widely adopted:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是不支持`const`的旧浏览器，那么`const`对您来说将不可用。一个可能的解决方法是使用更广泛采用的`Object.freeze`功能：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, the syntax here is not very user-friendly. Also an issue is
    that attempting to assign to an already assigned `const` simply fails silently
    instead of throwing an error. Failing silently in this fashion is not at all a
    desirable behavior; a full exception should be thrown. If you enable strict mode,
    a more rigorous parsing mode is added in ECMAScript 5, and an exception is actually
    thrown:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这里的语法并不是很用户友好。另一个问题是，尝试对已分配的`const`进行赋值只会静默失败，而不是抛出错误。以这种方式静默失败绝对不是一种理想的行为；应该抛出完整的异常。如果启用了严格模式，ECMAScript
    5中添加了更严格的解析模式，并且实际上会抛出异常：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code will throw the following error:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将抛出以下错误：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'An alternative is the `object.Create` syntax we spoke about earlier. When creating
    properties on the object, one can specify `writable: false` to make the property
    immutable:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '另一种方法是我们之前提到的`object.Create`语法。在创建对象的属性时，可以指定`writable: false`来使属性不可变：'
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: However, even in strict mode no exception is thrown when attempting to write
    to a non-writable property. Thus I would claim that the `const` keyword is not
    perfect for implementing immutable objects. You're better off using freeze.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使在严格模式下，当尝试写入不可写属性时也不会抛出异常。因此，我认为`const`关键字并不完美地实现了不可变对象。最好使用freeze。
- en: Lazy instantiation
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟实例化
- en: If you go into a higher-end coffee shop and place an order for some overly complex
    beverage (Grande Chai Tea Latte, 3 Pump, Skim Milk, Lite Water, No Foam, Extra
    Hot anybody?) then that beverage is going to be made on-the-fly and not in advance.
    Even if the coffee shop knew which orders were going to come in that day, they
    would still not make all the beverages up front. First, because it would result
    in a large number of ruined, cold beverages, and second, it would be a very long
    time for the first customer to get their order if they had to wait for all the
    orders of the day to be completed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您进入一个高端咖啡店并点一杯过于复杂的饮料（大杯奶茶拿铁，3泵，脱脂牛奶，少水，无泡沫，超热，有人吗？），那么这种饮料将是临时制作的，而不是提前制作的。即使咖啡店知道当天会有哪些订单，他们也不会提前制作所有的饮料。首先，因为这会导致大量的毁坏、冷却的饮料，其次，如果他们必须等待当天所有订单完成，第一个顾客要等很长时间才能拿到他们的订单。
- en: Instead coffee shops follow a just-in-time approach to crafting beverages. They
    make them when they're ordered. We can apply a similar approach to our code through
    the use of a technique known as lazy instantiation or lazy initialization.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 咖啡店遵循按需制作饮料的方法。他们在点单时制作饮料。我们可以通过使用一种称为延迟实例化或延迟初始化的技术来将类似的方法应用到我们的代码中。
- en: Consider an object which is expensive to create; that is to say that it takes
    a great deal of time to create the object. If we are unsure if the object's value
    will be needed, we can defer its full creation until later.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个昂贵的创建对象；也就是说，创建对象需要很长时间。如果我们不确定对象的值是否需要，我们可以推迟到以后再完全创建它。
- en: Implementation
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'Let''s jump into an example of this. Westeros isn''t really big on expensive
    coffee shops but they do love a good bakery. This bakery takes requests for different
    bread types in advance and then bakes them all at once should they get an order.
    However, creating the bread object is an expensive operation so we would like
    to defer that until somebody actually comes to pick up the bread:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。Westeros并不是很喜欢昂贵的咖啡店，但他们确实喜欢好的面包店。这家面包店提前接受不同种类的面包请求，然后一旦有订单，就会一次性烘烤所有面包。然而，创建面包对象是一个昂贵的操作，所以我们希望推迟到有人来取面包时再进行：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We start by creating a list of bread types to be created as needed. This list
    is appended to by ordering a bread type:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个要根据需要创建的面包类型列表。通过订购面包类型，这个列表会被追加：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This allows for breads to be rapidly added to the required bread list without
    paying the price for each bread to be created.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以快速地将面包添加到所需的面包列表中，而不必为每个面包的创建付出代价。
- en: 'Now when `pickUpBread` is called we''ll actually create the breads:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当调用`pickUpBread`时，我们将实际创建面包：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here we call a series of operations:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用了一系列操作：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will result in the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下结果：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can see that the collection of actual breads is left until after the pickup
    has been requested.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到实际面包的收集是在取货后进行的。
- en: Lazy instantiation can be used to simplify asynchronous programming. Promises
    are an approach to simplifying callbacks which are common in JavaScript. Instead
    of building up complicated callbacks, a promise is an object which contains a
    state and a result. When first called, the promise is in an unresolved state;
    once the `async` operation completes, the state is updated to complete and the
    result is filled in. You can think of the result as being lazily instantiated.
    We'll look at promises and promise libraries in more detail in [Chapter 9](text00080.html#ch09
    "Chapter 9. Web Patterns") , *Web Patterns* .
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟实例化可以用来简化异步编程。Promise是简化JavaScript中常见的回调的一种方法。Promise是一个包含状态和结果的对象。首次调用时，promise处于未解决状态；一旦`async`操作完成，状态就会更新为完成，并填充结果。您可以将结果视为延迟实例化。我们将在[第9章](text00080.html#ch09
    "第9章。Web Patterns") *Web Patterns*中更详细地讨论promise和promise库。
- en: Being lazy can save you quite a bit of time in creating expensive objects that
    end up never being used.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰可以节省大量时间，因为创建昂贵的对象最终可能根本不会被使用。
- en: Hints and tips
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: 'Although callbacks are the standard way of dealing with asynchronous methods
    in JavaScript they can get out of hand easily. There are a number of approaches
    to solving this spaghetti code: promise libraries provide a more fluent way of
    handling callbacks and future versions of JavaScript may adopt an approach similar
    to the C# `async/await` syntax.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管回调是处理JavaScript中异步方法的标准方式，但它们很容易变得混乱。有许多方法可以解决这种混乱的代码：promise库提供了一种更流畅的处理回调的方式，未来版本的JavaScript可能会采用类似于C#
    `async/await`语法的方法。
- en: I really like accumulators but they can be inefficient in terms of memory use.
    The lack of tail recursion means that each pass through adds another stack frame,
    so this approach may result in memory pressure. All things are a trade-off in
    this case between memory and code maintainability.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很喜欢累加器，但它们在内存使用方面可能效率低下。缺乏尾递归意味着每次通过都会增加另一个堆栈帧，因此这种方法可能会导致内存压力。在这种情况下，所有事情都是在内存和代码可维护性之间进行权衡。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: JavaScript is not a functional programming language. That is not to say that
    it isn't possible to apply some of the ideas from functional programming to it.
    These approaches enable cleaner, easier to debug code. Some might even argue that
    the number of issues will be reduced although I have never seen any convincing
    studies on that.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript不是一种函数式编程语言。这并不是说不可能将一些函数式编程的思想应用到它上面。这些方法可以使代码更清晰、更易于调试。有些人甚至可能会认为问题的数量会减少，尽管我从未见过任何令人信服的研究。
- en: In this chapter we looked at six different patterns. Lazy instantiation, memoization,
    and immutability are all creational patterns. Function passing is a structural
    pattern as well as a behavioral one. Accumulators are also behavioral in nature.
    Filters and pipes don't really fall into any of the GoF categories so one might
    think of them as a style pattern.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了六种不同的模式。延迟实例化、记忆化和不可变性都是创建模式。函数传递既是结构模式，也是行为模式。累加器也是行为模式。过滤器和管道实际上并不属于GoF的任何一类，因此可以将它们视为一种样式模式。
- en: In the next chapter we'll look at a number of patterns for dividing the logic
    and presentation in applications. These patterns have become more important as
    JavaScript applications have grown.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究一些在应用程序中划分逻辑和呈现的模式。随着JavaScript应用程序的增长，这些模式变得更加重要。
- en: Chapter 7. Reactive Programming
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 响应式编程
- en: I once read a book that suggested that Newton came up with the idea for calculus
    when he was observing the flow of a river around a reed. I've never been able
    to find any other source which supports that assertion. It is, however, a nice
    picture to hold in your mind. Calculus deals with understanding how the state
    of a system changes over time. Most developers will rarely have to deal with calculus
    in their day to day work. They will, however, have to deal with systems changing.
    After all, having a system which doesn't change at all is pretty boring.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经读过一本书，书中提到牛顿在观察芦苇周围的河流时想出了微积分的概念。我从未能找到其他支持这一说法的来源。然而，这是一个很好的形象。微积分涉及理解系统随时间变化的状态。大多数开发人员在日常工作中很少需要处理微积分。然而，他们必须处理系统的变化。毕竟，一个完全不变的系统是相当无聊的。
- en: Over the last few years a number of different ideas have arisen in the area
    of treating change as a stream of events – just like the stream that Newton supposedly
    observed. Given a starting position and a stream of events it should be possible
    to figure out the state of the system. Indeed, this is the idea behind using an
    event store. Instead of keeping the final state of an aggregate in a database
    we instead keep track of all the events which have been applied to that aggregate.
    By replaying this series of events we can recreate the current state of the aggregate.
    This seems like a roundabout way of storing the state of an object but it is actually
    very useful for a number of situations. For example, a disconnected system, like
    a cell phone application when the phone isn't connected to the network, which
    uses an event store can be merged with other events much more easily than simply
    keeping the end state. It is also stunningly useful for audit scenarios as it
    is possible to pull the system back to the state it was in at any point in time
    by simply halting the replay at a time index. How frequently have you been asked,
    "why is the system in this state?", and you've been unable to reply? With an event
    store the answer should be easy to ascertain.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，关于将变化视为一系列事件的不同想法已经出现 - 就像牛顿所观察到的那条河流一样。给定一个起始位置和一系列事件，应该可以找出系统的状态。事实上，这就是使用事件存储的想法。我们不是将聚合的最终状态保存在数据库中，而是跟踪已应用于该聚合的所有事件。通过重放这一系列事件，我们可以重新创建聚合的当前状态。这似乎是一种存储对象状态的绕圈方式，但实际上对于许多情况非常有用。例如，一个断开连接的系统，比如手机应用程序在手机未连接到网络时，使用事件存储可以更容易地与其他事件合并，而不仅仅是保留最终状态。对于审计场景，它也非常有用，因为可以通过简单地在时间索引处停止重放来将系统拉回到任何时间点的状态。你有多少次被问到，“为什么系统处于这种状态？”，而你无法回答？有了事件存储，答案应该很容易确定。
- en: 'In this chapter we''ll cover the following topics:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Application state changes
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用状态变化
- en: Streams
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流
- en: Filtering streams
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤流
- en: Merging streams
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并流
- en: Streams for multiplexing
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于多路复用的流
- en: Application state changes
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用状态变化
- en: 'Within an application we can think of all the events happening as a similar
    stream of events. The user clicks on a button? Event. The user''s mouse enters
    some region? Event. A clock ticks? Event. In both front and backend applications,
    events are the things which trigger changes in state. You''re likely already using
    events for event listeners. Consider attaching a click handler to a button:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，我们可以将所有事件发生的事情视为类似的事件流。用户点击按钮？事件。用户的鼠标进入某个区域？事件。时钟滴答？事件。在前端和后端应用程序中，事件是触发状态变化的事物。你可能已经在使用事件监听器进行事件处理。考虑将点击处理程序附加到按钮上：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this code we have attached a handler to the `click` event. This is fairly
    simple code but think about how rapidly the complexity of this code increases
    when we add conditions like "ignore additional click for 500ms once a click is
    fired to prevent people double-clicking" and "Fire a different event if the *Ctrl*
    key is being held when the button is clicked". Reactive programming or functional
    reactive programming provides a simple solution to these complex interaction scenarios
    through use of streams. Let's explore how your code can benefit from leveraging
    reactive programming.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们已经将处理程序附加到了`click`事件上。这是相当简单的代码，但是想象一下当我们添加条件时，这段代码的复杂性会如何迅速增加，比如“在点击后忽略500毫秒内的额外点击，以防止人们双击”和“如果按住*Ctrl*键时点击按钮，则触发不同的事件”。响应式编程或函数式响应式编程通过使用流提供了这些复杂交互场景的简单解决方案。让我们探讨一下你的代码如何从利用响应式编程中受益。
- en: Streams
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流
- en: 'The easiest way to think of an event stream is not to think of the streams
    you''ve probably used before in programming, input reader streams, but to think
    of arrays. Let''s say that you have an array with a series of numbers in it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 想要简单地思考事件流的最简单方法不是考虑你以前在编程中可能使用过的流，而是考虑数组。假设你有一个包含一系列数字的数组：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now you want to filter this array to only show you even numbers. In modern
    JavaScript this is easily done through the use of the `filter` function on the
    array:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你想要过滤这个数组，只显示偶数。在现代JavaScript中，可以通过数组的`filter`函数轻松实现这一点：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A graphical representation can be seen here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这里看到一个图形表示：
- en: '![Streams](Image00032.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![流](Image00032.jpg)'
- en: The filtering function here remains the same should we have ten items in the
    array or ten thousand items in the array. Now, what if the source array had new
    items being appended to it all the time? We would like to keep our dependent array
    up-to-date by inserting any new items which are even, into it. To do this we could
    hook into the `add` function on the array using a pattern-like decorator. Using
    a decorator we could call the filter method and, if a match was found, we would
    add it to the filtered array.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的过滤功能保持不变，无论数组中有十个项目还是一万个项目。现在，如果源数组不断添加新项目，我们希望通过将任何新的偶数项目插入到依赖数组中来保持其最新状态。为此，我们可以使用类似装饰器的模式来钩入数组的`add`函数。使用装饰器，我们可以调用过滤方法，如果找到匹配项，就将其添加到过滤后的数组中。
- en: 'Streams are, in effect, an observable on a collection of future events. There
    are a number of interesting problems which can be solved using operations on streams.
    Let''s start with a simple problem: handling clicks. This problem is so simple
    that, on the surface, it doesn''t seem like there is any advantage to using streams.
    Don''t worry we''ll make it more difficult as we go along.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，流是对未来事件集合的可观察对象。可以使用流操作解决许多有趣的问题。让我们从一个简单的问题开始：处理点击。这个问题非常简单，表面上似乎没有使用流的优势。别担心，随着我们的深入，我们会让它变得更加困难。
- en: For the most part this book avoids making use of any specific JavaScript libraries.
    The idea is that patterns should be able to be implemented with ease without a
    great deal of ceremony. However, in this case we're actually going to make use
    of a library because streams have a few nuances to their implementation for which
    we'd like some syntactic niceties. If you're looking to see how to implement a
    basic stream, then you can base it on the observer pattern outlined in [Chapter
    5](text00044.html#page "Chapter 5. Behavioral Patterns") , *Behavioral Patterns*
    .
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在大部分情况下，本书避免使用任何特定的JavaScript库。这是因为模式应该能够在不需要太多仪式的情况下轻松实现。然而，在这种情况下，我们实际上要使用一个库，因为流的实现有一些细微之处，我们希望有一些语法上的美感。如果你想看看如何实现基本的流，那么你可以基于[第5章](text00044.html#page
    "第5章 行为模式")中概述的观察者模式进行实现。
- en: There are a number of stream libraries in JavaScript Reactive.js, Bacon.js,
    and RxJS to name a few. Each one has various advantages and disadvantages but
    the specifics are outside the purview of this book. In this book we'll make use
    of Reactive Extensions for JavaScript, the source code for which can be found
    on GitHub at [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)
    .
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中有许多流库，如Reactive.js、Bacon.js和RxJS等。每个库都有各种优点和缺点，但具体细节超出了本书的范围。在本书中，我们将使用JavaScript的Reactive
    Extensions，其源代码可以在GitHub上找到[https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)。
- en: 'Let''s start with a brief piece of HTML:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简短的HTML代码开始：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To this, let''s add a quick click counter:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个快速的点击计数器：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here you can see we''re creating a new stream of events from the `click` event
    on the button. The newly created stream is commonly referred to as a metastream.
    Whenever an event is emitted from the source stream it is automatically manipulated
    and published, as needed, to the metastream. We subscribe to this stream and increment
    a counter. If we wanted to react to only the even numbered events, we could do
    so by subscribing a second function to the stream:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们正在从按钮的`click`事件创建一个新的事件流。新创建的流通常被称为元流。每当从源流中发出事件时，它会自动被操作和发布到元流中。我们订阅了这个流并增加一个计数器。如果我们只想对偶数事件做出反应，我们可以通过向流订阅第二个函数来实现：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here you can see that we're applying a filter to the stream such that the counter
    is distinct from the function which updates the screen. Keeping a counter outside
    of the streams like this feels dirty, though, doesn't it? Chances are that incrementing
    every other click isn't the goal of this function anyway. It is much more likely
    that we would like to run a function only on double click.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们正在对流应用过滤器，以使计数器与更新屏幕的函数不同。但是，将计数器保留在流之外感觉有些不好，对吧？很可能，每隔一次点击增加一次并不是这个函数的目标。更有可能的是，我们只想在双击时运行一个函数。
- en: 'This is difficult to do with traditional methods, however these sorts of complex
    interactions are easy to achieve using streams. You can see how we might approach
    the problem in this code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用传统方法很难做到的，然而这些复杂的交互可以很容易地通过流来实现。您可以看到我们如何在这段代码中解决这个问题：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here we take the click stream and buffer the stream using a debounce to generate
    the boundaries of the buffer. Debouncing is a term from the hardware world which
    means that we clean up a noisy signal into a single event. When a physical button
    is pushed, there are often a couple of additional high or low signals instead
    of the single point signal we would like. In effect we eliminate repeated signals
    which occur within a window. In this case we wait `250` ms before firing an event
    to move to a new buffer. The buffer contains all the events fired during the debouncing
    and passes on a list of them to the next function in the chain. The map function
    generates a new stream with the list length as the contents. Next, we filter the
    stream to show only events with a value of 2 or more, that''s two clicks or more.
    The stream of events look like the following diagram:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取点击流并使用防抖动来缓冲流以生成缓冲区的边界。防抖动是硬件世界的一个术语，意味着我们将一个嘈杂的信号清理成一个单一的事件。当按下物理按钮时，通常会有一些额外的高或低信号，而不是我们想要的单点信号。实际上，我们消除了在一个窗口内发生的重复信号。在这种情况下，我们等待`250`毫秒，然后触发一个事件以移动到一个新的缓冲区。缓冲区包含在防抖期间触发的所有事件，并将它们的列表传递给链中的下一个函数。map函数生成一个以列表长度为内容的新流。接下来，我们过滤流，只显示值为2或更多的事件，即两次点击或更多。事件流看起来像下面的图表：
- en: '![Streams](Image00033.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Streams](Image00033.jpg)'
- en: Performing the same logic as this using traditional event listeners and call-backs
    would be quite difficult. One could easily imagine a far more complex workflow
    that would spiral out of control. FRP allows for a more streamlined approach to
    handling events.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统的事件监听器和回调执行相同的逻辑将会非常困难。人们很容易想象出一个更复杂的工作流程，这将失控。FRP允许更简化的方式来处理事件。
- en: Filtering streams
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤流
- en: As we saw in the preceding section, it is possible to filter a stream of events
    and, from it produce a new stream of events. You might be familiar with being
    able to filter items in an array. ES5 introduced a number of new operators for
    arrays such as **filter** and **some** . The first of these produces a new array
    containing only elements which match the rule in the filter. `Some` is a similar
    function which simply returns `true` if any element of the array matches. These
    same sorts of functions are also supported on streams as well as functions you
    might be familiar with from functional languages such as First and Last. In addition
    to the functions which would make sense for arrays, there are a number of time
    series based functions which make much more sense when you consider that streams
    exist in time.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的部分中看到的，可以过滤事件流，并从中产生一个新的事件流。您可能熟悉能够过滤数组中的项目。ES5引入了一些新的数组运算符，如**filter**和**some**。其中的第一个产生一个只包含符合过滤规则的元素的新数组。`Some`是一个类似的函数，如果数组的任何元素匹配，则简单返回`true`。这些相同类型的函数也支持在流上，以及您可能熟悉的来自函数式语言的函数，如First和Last。除了对数组有意义的函数之外，还有许多基于时间序列的函数，当您考虑到流存在于时间中时，这些函数更有意义。
- en: 'We''ve already seen debounce which is an example of a time based filter. Another
    very simple application of debounce is to prevent the annoying bug of users double-clicking
    a submit button. Consider how much simpler the code for that is using a stream:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了防抖动，这是一个基于时间的过滤器的例子。防抖动的另一个非常简单的应用是防止用户双击提交按钮的恼人错误。考虑一下使用流的代码有多简单：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You might also find it that functions like Sample – which generates a set of
    events from a time window. This is a very handy function when we're dealing with
    observables which may produce a large number of events. Consider an example from
    our example world of Westeros.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会发现像Sample这样的函数，它从时间窗口生成一组事件。当我们处理可能产生大量事件的可观察对象时，这是一个非常方便的函数。考虑一下我们维斯特洛斯的示例。
- en: Unfortunately, Westeros is quite a violent place where people seem to die in
    unpleasant ways. So many people die that we can't possibly keep an eye on each
    one so we'd like to just sample the data and gather a few causes of death.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，维斯特洛是一个相当暴力的地方，人们似乎以不愉快的方式死去。有这么多人死去，我们不可能每个人都关注，所以我们只想对数据进行抽样并收集一些死因。
- en: 'To simulate this incoming stream, we will start with an array, something like
    the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这个传入的流，我们将从一个数组开始，类似于以下内容：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Tip
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can see we're using an array to simulate a stream of events. This can be
    done with any stream and is a remarkably easy way to perform testing on complex
    code. You can build a stream of events in an array and then publish them with
    appropriate delays giving an accurate representation of anything from a stream
    of events from the filesystem to user interactions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们正在使用数组来模拟事件流。这可以用任何流来完成，并且是一个非常简单的测试复杂代码的方法。您可以在数组中构建一个事件流，然后以适当的延迟发布它们，从而准确地表示从文件系统到用户交互的事件流的任何内容。
- en: 'Now we need to make our array into a stream of events. Fortunately, there are
    some shortcuts for doing that using the `from` method. This will simply return
    a stream which is immediately executed. What we''d like is to pretend we have
    a regularly distributed stream of events or, in our rather morbid case, deaths.
    This can be done by using two methods from RxJS: `interval` and `zip` . `interval`
    creates a stream of events at a regular interval. `zip` matches up pairs of events
    from two streams. Together these two methods will emit a new stream of events
    at a regular interval:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将我们的数组转换为事件流。幸运的是，有一些使用`from`方法的快捷方式可以做到这一点。这将简单地返回一个立即执行的流。我们希望假装我们有一个定期分布的事件流，或者在我们相当阴郁的情况下，死亡。这可以通过使用RxJS的两种方法来实现：`interval`和`zip`。`interval`创建一个定期间隔的事件流。`zip`匹配来自两个流的事件对。这两种方法一起将以定期间隔发出新的事件流：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this code we zip together the deaths array with an interval stream which
    fires every `500` ms. Because we're not super interested in the interval event
    we simply discard it and project the item from the array onwards.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们将死亡数组与每`500`毫秒触发一次的间隔流进行了合并。因为我们对间隔事件不是特别感兴趣，所以我们简单地丢弃了它，并将数组中的项目进行了投影。
- en: 'Now we can sample this stream by simply taking a sample and then subscribing
    to it. Here we''re sampling every `1500` ms:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过简单地取样本然后订阅它来对这个流进行取样。在这里，我们每`1500`毫秒取样一次：
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can have as many subscribers to a stream as you like so if you wanted to
    perform some sampling, as well as perhaps some aggregate functions like simply
    counting the events, you could do so by having several subscribers:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有任意多个订阅者订阅一个流，所以如果你想进行一些取样，以及可能一些聚合函数，比如简单地计算事件的数量，你可以通过有几个订阅者来实现。
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Merging streams
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并流
- en: 'We''ve already seen the `zip` function that merges events one-to-one to create
    a new stream but there are numerous other ways of combining streams. A very simple
    example might be a page which has several code paths which all want to perform
    a similar action. Perhaps we have several actions all of which result in a status
    message being updated:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`zip`函数，它将事件一对一地合并以创建一个新的流，但还有许多其他合并流的方法。一个非常简单的例子可能是一个页面，它有几个代码路径，它们都想执行类似的操作。也许我们有几个动作，所有这些动作都会导致状态消息被更新：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here you can see how the various streams are passed into the merge function
    and the resulting merged stream:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，你可以看到各种流被传递到合并函数中，然后产生了合并后的流：
- en: '![Merging streams](Image00034.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![合并流](Image00034.jpg)'
- en: While useful, this code doesn't seem to be particularly better than simply calling
    the event handler directly, in fact it is longer than necessary. However, consider
    that there are more sources of status messages than just button pushes. We might
    want to have asynchronous events also write out information. For instance, sending
    a request to the server might also want to add status information. Another fantastic
    application may be with web workers which run in the background and communicate
    with the main thread using messaging. For web based JavaScript applications this
    is how we implement multithreaded applications. Let's see how that would look.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有用，但这段代码似乎并不比直接调用事件处理程序更好，实际上它比必要的代码还要长。然而，考虑到状态消息的来源不仅仅是按钮推送。我们可能还希望异步事件也写出信息。例如，向服务器发送请求可能还想添加状态信息。另一个很棒的应用可能是使用在后台运行并使用消息与主线程通信的web
    worker。对于基于web的JavaScript应用程序，这是我们实现多线程应用程序的方式。让我们看看它是什么样子。
- en: 'First we can create a stream from a worker role. In our example the worker
    simply calculates the fibonacci sequence. We''ve added a fourth button to our
    page and have it trigger the worker process:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以从worker角色创建一个流。在我们的示例中，worker只是计算斐波那契数列。我们在页面上添加了第四个按钮，并触发了worker进程：
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we can subscribe to the merged stream and combine it with all the previous
    streams:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以订阅合并后的流，并将其与所有先前的流结合起来：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This all looks really nice but we don''t want to clobber the users with dozens
    of notifications at a time. We can throttle the stream of events so that only
    a single toast shows up at a time by using the same interval zip pattern we saw
    earlier. In this code we''ve replaced our `appendToOutput` method with a call
    to a toast display library:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切看起来非常好，但我们不想一次给用户提供数十个通知。我们可以通过使用与之前看到的相同的间隔zip模式来限制事件流，以便一次只显示一个toast。在这段代码中，我们用调用toast显示库来替换我们的`appendToOutput`方法：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see the code for this functionality is short and easy to understand
    yet it contains a great deal of functionality.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个功能的代码很简短，易于理解，但包含了大量的功能。
- en: Streams for multiplexing
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多路复用流
- en: 'One does not rise to a position of power on the King''s council in Westeros
    without being a master at building networks of spies. Often the best spy is one
    who can respond the quickest. Similarly, we may have some code which has the option
    of calling one of many different services which can fulfill the same task. A great
    example would be a credit card processor: it doesn''t really matter which processor
    we use as they''re pretty much all the same.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在Westeros国王的议会中，没有人能够在权力地位上升到一定程度而不擅长建立间谍网络。通常，最好的间谍是那些能够最快做出反应的人。同样，我们可能有一些代码可以选择调用许多不同的服务中的一个来完成相同的任务。一个很好的例子是信用卡处理器：我们使用哪个处理器并不重要，因为它们几乎都是一样的。
- en: To achieve this, we can kick off a number of HTTP requests to each of the services.
    If we take each of the requests and put them into a stream, we can use it to select
    the fastest to respond processor and then perform the rest of the actions using
    that processor.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以启动多个HTTP请求到每个服务。如果我们将每个请求放入一个流中，我们可以使用它来选择最快响应的处理器，然后使用该处理器执行其余的操作。
- en: 'With RxJS this looks like the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RxJS，这看起来像下面这样：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You could even include a timeout in the `amb` call which would be called to
    handle the eventuality that none of the processors responded in time.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以在`amb`调用中包含一个超时，以处理处理器没有及时响应的情况。
- en: Hints and tips
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: There are a large number of different functions that can be applied to streams.
    If you happen to decide on the RxJS library for your FRP needs in JavaScript,
    many of the most common functions have been implemented for you. More complex
    functions can often be written as a chain of the included functions so try to
    think of a way to create the functionality you want by chaining before writing
    your own functions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用于流的不同函数有很多。如果你决定在JavaScript中使用RxJS库进行FRP需求，许多常见的函数已经为你实现了。更复杂的函数通常可以编写为包含函数链，因此在编写自己的函数之前，尝试想出一种通过链式调用来创建所需功能的方法。
- en: Frequently, asynchronous calls across the network in JavaScript fail. Networks
    are unreliable, mobile networks doubly so. For the most part when the network
    fails, our application fails. Streams provide an easy fix to this by allowing
    you to easily retry failed subscriptions. In RxJS this method is called `Retry`
    . Slotting it into any observable chain makes it more resilient to network failures.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，经常会出现跨网络的异步调用失败。网络是不可靠的，移动网络尤其如此。在大多数情况下，当网络失败时，我们的应用程序也会失败。流提供了一个简单的解决方法，允许您轻松重试失败的订阅。在RxJS中，这种方法被称为“重试”。将其插入到任何可观察链中，可以使其更具抗网络故障的能力。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Functional reactive programming has many uses in different applications both
    on the server and on the client. On the client side it can be used to wrangle
    a large number of events together into a data flow enabling complex interactions.
    It can also be used for the simplest of things such as preventing a user from
    double-clicking a button. There is no huge cost to simply using streams for all
    of your data changes. They are highly testable and have a minimal impact on performance.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式响应式编程在服务器端和客户端的不同应用中有许多用途。在客户端，它可以用于将大量事件整合成数据流，实现复杂的交互。它也可以用于最简单的事情，比如防止用户双击按钮。仅仅使用流来处理所有数据变化并没有太大的成本。它们非常易于测试，并且对性能影响很小。
- en: Perhaps the nicest thing about FRP is that it raises the level of abstraction.
    You have to deal with less finicky process flow code and can, instead, focus on
    the logical flow of the application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: FRP最美好的一点也许是它提高了抽象级别。您不必处理繁琐的流程代码，而是可以专注于应用程序的逻辑流。
- en: Chapter 8. Application Patterns
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 应用程序模式
- en: Thus far we have spent a great deal of time examining patterns that are used
    to solve local problems, that is; problems that span only a handful of classes
    and not the whole application. These patterns have been narrow in scope. They
    frequently only relate to two or three classes and might be used but a single
    time in any given application. As you can imagine there are also larger scale
    patterns that are applicable to the application as a whole. You might think of
    "toolbar" as a general pattern that is used in many places in an application.
    What's more, it is a pattern that is used in a great number of applications to
    give them a similar look and feel. Patterns can help guide how the whole application
    is assembled.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经花了大量时间研究用于解决局部问题的模式，也就是说，仅涉及少数类而不是整个应用程序的问题。这些模式的范围很窄。它们通常只涉及两三个类，并且在任何给定的应用程序中可能只使用一次。您可以想象一下，还有更大规模的模式适用于整个应用程序。您可以将“工具栏”视为一个通用模式，它在应用程序中的许多地方使用。而且，它是在许多应用程序中使用的模式，以赋予它们相似的外观和感觉。模式可以帮助指导整个应用程序的组装方式。
- en: In this chapter we're going to look at a family of patterns which I've taken
    to calling the MV* family. This family includes MVC, MVVM, MVP, and even PAC.
    Just like their names, the patterns themselves are pretty similar. The chapter
    will cover each of these patterns and show how, or if, we can apply them to JavaScript.
    We'll also pay special attention to how the patterns differ from one another.
    By the end of the chapter you should be able to thrill guests at a cocktail party
    with an explanation of the nuances of MVP versus MVC.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一系列我称之为MV*家族的模式。这个家族包括MVC、MVVM、MVP，甚至PAC。就像它们的名字一样，这些模式本身非常相似。本章将涵盖这些模式，并展示如何或者是否可以将它们应用到JavaScript中。我们还将特别关注这些模式之间的区别。在本章结束时，您应该能够在鸡尾酒会上以MVP与MVC的微妙差异为题向客人讲解。
- en: 'The topics covered will be as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的主题将如下：
- en: History of Model View patterns
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型视图模式的历史
- en: Model View Controller
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型视图控制器
- en: Model View Presenter
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型视图呈现器
- en: Model View ViewModel
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型视图视图模型
- en: First, some history
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先，一些历史
- en: 'Separating concerns inside an application is a very important idea. We live
    in a complex and ever-changing world. This means that not only is it nearly impossible
    to formulate a computer program which works in exactly the way users want, but
    that what users want is an ever-shifting maze. Couple this with the fact that
    an ideal program for user A is totally different from an ideal program for user
    B and we''re guaranteed to end up in a mess. Our applications need to change as
    frequently as we change our socks: at least once a year.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序内部分离关注点是一个非常重要的想法。我们生活在一个复杂且不断变化的世界中。这意味着不仅几乎不可能制定一个完全符合用户需求的计算机程序，而且用户需求是一个不断变化的迷宫。再加上一个事实，即用户A的理想程序与用户B的理想程序完全不同，我们肯定会陷入混乱。我们的应用程序需要像我们换袜子一样频繁地更改：至少每年一次。
- en: Layering an application and maintaining modularity reduces the impact of a change.
    The less each layer knows about the other layers the better. Maintaining simple
    interfaces between the layers reduces the chances that a change to one layer will
    percolate to another layer.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 分层应用程序和维护模块化可以减少变更的影响。每个层次对其他层次了解得越少越好。在层次之间保持简单的接口可以减少一个层次的变更对另一个层次的影响的机会。
- en: If you've ever taken a close look at a high quality piece of nylon (from a hot
    air balloon, parachute, or expensive jacket) you may have noticed that that the
    fabric seems to form tiny squares. This is because, every few millimeters, a thick
    reinforcing thread is added to the weave to form a crosshatch pattern. If the
    fabric is ripped, then the rip will be stopped or at least slowed by the reinforcement.
    This limits the damage to a small area and prevents it from spreading.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经仔细观察过高质量的尼龙制品（如热气球、降落伞或昂贵的夹克），您可能会注意到这种织物似乎形成了微小的方块。这是因为每隔几毫米，都会添加一根粗的加强线到织物中，形成交叉网格图案。如果织物被撕裂，那么撕裂将会被加强线停止或至少减缓。这限制了损坏的范围，并防止其扩散。
- en: 'Layers and modules in an application are exactly the same: they limit the spread
    of damage from a change.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的层次和模块与限制变更的影响传播是完全相同的。
- en: In the early chapters of this book, we talked a bit about the seminal language,
    Smalltalk. It was the language which made classes famous. Like many of these patterns,
    the original MV* pattern, **Model View Controller** ( **MVC** ), was used long
    before it was ever identified. Although difficult to prove it seems that MVC was
    originally suggested in the late 1970s by Trygve Reenskaug, a Norwegian computer
    scientist, during a visit to the legendary Xerox PARC. Through the 1980s the pattern
    became heavily used in Smalltalk applications. However, it was not until 1988
    that the pattern was more formally documented in an article entitled, *A Cookbook
    for Using the Model-View-Controller User Interface Paradigm* by Glenn E. Krasner
    and Stephen T. Pope.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章中，我们谈到了开创性的语言Smalltalk。它是使类著名的语言。像许多这些模式一样，原始的MV*模式，**模型 视图 控制器**（**MVC**），在被识别之前就已经被使用。尽管很难证明，但MVC最初是在20世纪70年代末由挪威计算机科学家Trygve
    Reenskaug在访问传奇般的施乐PARC期间提出的。在20世纪80年代，该模式在Smalltalk应用程序中得到了广泛使用。然而，直到1988年，该模式才在一篇名为《使用模型-视图-控制器用户界面范式的烹饪书》的文章中得到更正式的记录，作者是Glenn
    E. Krasner和Stephen T. Pope。
- en: Model View Controller
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型 视图 控制器
- en: 'MVC is a pattern that is useful for creating rich, interactive user interfaces:
    just the sort of interfaces which are becoming more and more popular on the web.
    The astute amongst you will have already figured out that the pattern is made
    up of three major components: model, view, and controller. You can see how information
    flows between the components in this illustration:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: MVC是一种用于创建丰富、交互式用户界面的模式：这正是在网络上变得越来越受欢迎的界面类型。敏锐的读者已经发现，该模式由三个主要组件组成：模型、视图和控制器。您可以在这个插图中看到信息在这些组件之间的流动：
- en: '![Model View Controller](Image00035.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![模型 视图 控制器](Image00035.jpg)'
- en: The preceding diagram shows the relationship between the three components in
    MVC.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了MVC中三个组件之间的关系。
- en: The model contains the state of the program. In many applications this model
    is contained in some form, in a database. The model may be rehydrated from a persistent
    store such as the database or it can be transient. Ideally the model is the only
    mutable part of the pattern. Neither the view nor the controller has any state
    associated with them.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 模型包含程序的状态。在许多应用程序中，该模型以某种形式包含在数据库中。模型可以从数据库等持久存储重新生成，也可以是瞬态的。理想情况下，模型是该模式中唯一可变的部分。视图和控制器都不与任何状态相关联。
- en: 'For a simple login screen the model might look like the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的登录屏幕，模型可能如下所示：
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You'll notice that not only do we have fields for the inputs shown to the user
    but also for the state of the login. This would not be apparent to the user but
    it is still part of the application state.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，我们不仅为用户显示的输入字段设置了字段，还为登录状态设置了字段。用户可能不会注意到这一点，但它仍然是应用程序状态的一部分。
- en: The model is usually modeled as a simple container for information. Typically,
    there are no real functions in the model. It simply contains data fields and may
    also contain validation. In some implementations of the MVC pattern the model
    also contains meta-data about the fields such as validation rules.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 模型通常被建模为信息的简单容器。通常，模型中没有真正的功能。它只包含数据字段，也可能包含验证。在一些MVC模式的实现中，模型还包含有关字段的元数据，如验证规则。
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: The Naked Object pattern is a deviation from the typical MVC pattern. It augments
    the model with extensive business information as well as hits about the display
    and editing of data. It even contains methods for persisting the model to storage.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 裸对象模式是典型MVC模式的偏离。它通过大量的业务信息以及有关数据显示和编辑的提示来增强模型。甚至包含了将模型持久化到存储的方法。
- en: The views in the Naked Object pattern are generated from these models automatically.
    The controller is also automatically generated by examining the model. This centralizes
    the logic for displaying and manipulating application states and saves the developer
    from having to write their own views and controllers. So while the view and controller
    still exist, they are not actual objects but are dynamically created from the
    model.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 裸对象模式中的视图是从这些模型自动生成的。控制器也是通过检查模型自动生成的。这将逻辑集中在显示和操作应用程序状态上，并使开发人员无需编写自己的视图和控制器。因此，虽然视图和控制器仍然存在，但它们不是实际的对象，而是从模型动态创建的。
- en: Several systems have been successfully deployed using this pattern. Some criticism
    has emerged around the ability to generate an attractive user interface from just
    the models as well as how to properly coordinate multiple views.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 已经成功地使用了该模式部署了几个系统。一些批评涌现，主要是关于如何从仅仅模型生成吸引人的用户界面以及如何正确协调多个视图。
- en: In a foreword to the PhD thesis, *presenting Naked Objects* by Reenskaug, he
    suggests that the naked objects pattern is actually closer to his original vision
    for MVC than most of the derivations of MVC in the wild.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reenskaug的博士论文《呈现裸对象》的序言中，他建议裸对象模式实际上比野生MVC的大多数派生更接近他最初对MVC的愿景。
- en: Updates to the model are communicated to the view whenever the state changes.
    This is typically done through the use of an observer pattern. The model does
    not typically know about either the controller or the view. The first is simply
    the thing telling it to change and the second is only updated through the observer
    pattern so the model doesn't have direct knowledge of it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型发生变化时，更新会传达给视图。通常通过使用观察者模式来实现。模型通常不知道控制器或视图。第一个只是告诉它要改变的东西，第二个只通过观察者模式更新，所以模型并不直接知道它。
- en: 'The view does pretty much what you would expect: communicate the model state
    to a target. I hesitate to suggest that the view must be a visual or graphical
    representation of the model as frequently the view is being communicated to another
    computer and may be in the form of XML, JSON, or some other data format. In most
    cases, especially those related to JavaScript, the view will be a graphical object.
    In a web context this will typically be HTML which is rendered by the browser.
    JavaScript is also gaining popularity on phones and on the desktop, so the view
    could also be a screen on a phone or on the desktop.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 视图基本上做您所期望的事情：将模型状态传达给目标。我不敢说视图必须是模型的视觉或图形表示，因为视图经常被传达到另一台计算机，并且可能以XML、JSON或其他数据格式的形式存在。在大多数情况下，特别是与JavaScript相关的情况，视图将是一个图形对象。在Web环境中，这通常是由浏览器呈现的HTML。JavaScript在手机和桌面上也越来越受欢迎，因此视图也可以是手机或桌面上的屏幕。
- en: 'The view for the model presented in the preceding paragraph might look like
    the following figure:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 上述段落中的模型的视图可能如下图所示：
- en: '![Model View Controller](Image00036.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![模型视图控制器](Image00036.jpg)'
- en: In cases, where the observer pattern is not used, then the view may poll the
    model at some interval looking for changes. In this case the view may have to
    keep a representation of the state itself or at least a version number. It is
    important that the view not unilaterally update this state without passing the
    updates to the controller, otherwise the model and the copy in the view will get
    out of sync.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有使用观察者模式的情况下，视图可能会定期轮询模型以查找更改。在这种情况下，视图可能必须保持状态的表示，或者至少一个版本号。重要的是，视图不要单方面更新此状态，而不将更新传递给控制器，否则模型和视图中的副本将不同步。
- en: 'Finally, the state of the model is updated by the controller. The controller
    usually contains all the logic and business rules for updating fields on the model.
    A simple controller for our login page might look like the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模型的状态由控制器更新。控制器通常包含更新模型字段的所有逻辑和业务规则。我们登录页面的简单控制器可能如下所示：
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The controller knows about the existence of the model and is typically aware
    of the view's existence as well. It coordinates the two of them. A controller
    may be responsible for initializing more than one view. For instance, a single
    controller may provide a list view of all the instances of a model as well as
    a view that simply provides details. In many systems a controller will have create,
    read, update, and delete (CRUD) operations on it that work over a model. The controller
    is responsible for choosing the correct view and for wiring up the communication
    between the model and the view.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器知道模型的存在，并且通常也知道视图的存在。它协调两者。控制器可能负责初始化多个视图。例如，单个控制器可以提供模型所有实例的列表视图，以及仅提供详细信息的视图。在许多系统中，控制器将对模型进行创建、读取、更新和删除（CRUD）操作。控制器负责选择正确的视图，并建立模型和视图之间的通信。
- en: 'When there is a need for a change to the application then the location of the
    code should be immediately apparent. For example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要对应用程序进行更改时，代码的位置应立即显而易见。例如：
- en: '| Change | Location |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 更改 | 位置 |'
- en: '| --- | --- |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Elements don''t appear well spaced on the screen, change spacing. | View
    |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 屏幕上的元素间距不合适，更改间距。 | 视图 |'
- en: '| No users are able to log in due to a logical error in password validation.
    | Controller |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 由于密码验证中的逻辑错误，没有用户能够登录。 | 控制器 |'
- en: '| New field to be added. | All layers |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 要添加的新字段。 | 所有层 |'
- en: Note
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Presentation-Abstraction-Control** ( **PAC** ) is another pattern that makes
    use of a triad of components. In this case its goal is to describe a hierarchy
    of encapsulated triples that more closely match how we think of the world. The
    control, similar to an MVC controller, passes interactions up in the hierarchy
    of encapsulated components allowing for information to flow between components.
    The abstraction is similar to a model but may represent only a few fields that
    are important for that specific PAC instead of the entire model. Finally, the
    presentation is effectively the same as a view.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**Presentation-Abstraction-Control**（**PAC**）是另一种利用三个组件的模式。在这种情况下，它的目标是描述一组封装的三元组的层次结构，更符合我们对世界的思考方式。控制，类似于MVC控制器，将交互传递到封装组件的层次结构中，从而允许信息在组件之间流动。抽象类似于模型，但可能只代表对于特定PAC而言重要的一些字段，而不是整个模型。最后，演示文稿实际上与视图相同。'
- en: The hierarchical nature of PAC allows for parallel processing of the components,
    meaning that it can be a powerful tool in today's multiprocessor systems.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: PAC的分层性质允许对组件进行并行处理，这意味着它可以成为当今多处理器系统中强大的工具。
- en: 'You might notice that the last one there requires a change in all layers of
    the application. These multiple locations for responsibility are something that
    the Naked Objects pattern attempts to address by dynamically creating views and
    controllers. The MVC pattern splits code into locations by dividing the code by
    its role in user interaction. This means that a single data field lives in all
    the layers as is shown in this picture:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到最后一个需要对应用程序的所有层进行更改。这种责任的多重位置是裸对象模式试图通过动态创建视图和控制器来解决的。MVC模式通过根据用户交互中的角色将代码分割成位置。这意味着单个数据字段存在于所有层中，如图所示：
- en: '![Model View Controller](Image00037.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![模型视图控制器](Image00037.jpg)'
- en: Some might call this a cross-cutting concern but really it doesn't span a sufficient
    amount of the application to be called such. Data access and logging are cross-cutting
    concerns as they are pervasive and difficult to centralize. This pervasion of
    a field through the different layers is really not a major problem. However, if
    it is bugging you then you might be an ideal candidate for using the Naked Objects
    pattern.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会称这为横切关注点，但实际上它并没有涵盖足够多的应用程序部分才能被称为这样。数据访问和日志记录是横切关注点，因为它们是普遍存在的，难以集中化。这种领域在不同层之间的普遍存在并不是一个主要问题。但是，如果这让你感到困扰，那么你可能是使用裸对象模式的理想候选人。
- en: Let's step into building some code to represent a MVC in JavaScript.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建一些JavaScript中表示MVC的代码。
- en: MVC code
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC代码
- en: Let's start with a simple scenario for which we can apply MVC. Unfortunately,
    Westeros has very few computers, likely due to the lack of electricity. Thus applying
    application structuring patterns using Westeros as an example is difficult. Sadly
    we'll have to take a step back and talk about an application which controls Westeros.
    Let's assume it to be a web application and implement the entirety of MVC on the
    client side.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的场景开始，我们可以应用MVC。不幸的是，维斯特洛几乎没有计算机，可能是由于缺乏电力。因此，使用维斯特洛作为示例应用结构模式是困难的。遗憾的是，我们将不得不退一步，谈论一个控制维斯特洛的应用程序。让我们假设它是一个Web应用程序，并在客户端实现整个MVC。
- en: It is possible to implement MVC by splitting the model, view and controller
    between client and server. Typically, the controller would sit on the server and
    provide an API which is known by the view. The model serves as a communication
    method both to the view which resides on the web browser and to the data store,
    likely a database of some form. It is also common that the controller be split
    between the server and the client in cases where some additional control is required
    on the client.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在客户端和服务器之间分割模型、视图和控制器来实现MVC。通常，控制器会位于服务器上，并提供视图所知的API。模型作为通信方法，既用于驻留在Web浏览器上的视图，也用于数据存储，可能是某种形式的数据库。在需要在客户端上进行一些额外控制的情况下，通常也会将控制器在服务器和客户端之间分割。
- en: 'In our example we would like to create a screen that controls the properties
    of a castle. Fortunately, you''re lucky that this is not a book on designing user
    interfaces with HTML as I would certainly fail. We''ll stick to a picture in place
    of the HTML:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们想创建一个控制城堡属性的屏幕。幸运的是，你很幸运，这不是一本关于使用HTML设计用户界面的书，因为我肯定会失败。我们将用图片代替HTML：
- en: '![MVC code](Image00038.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![MVC代码](Image00038.jpg)'
- en: 'For the most part, the view simply provides a set of controls and data for
    the end user. In this example the view will need to know how to call the save
    function on the controller. Let''s set that up:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，视图只是为最终用户提供一组控件和数据。在这个例子中，视图需要知道如何调用控制器上的保存函数。让我们来设置一下：
- en: '[PRE57]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You'll notice that the constructor for this view contains both a reference to
    the document and to the controller. The document contains both HTML and styling,
    provided by CSS. We can get away with not passing in a reference to the document
    but injecting the document in this fashion allows for easier testability. We'll
    look at testability more in a later chapter. It also permits reusing the view
    multiple times on a single page without worrying about the two instances conflicting.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到这个视图的构造函数包含对文档和控制器的引用。文档包含HTML和样式，由CSS提供。我们可以不传递对文档的引用，但以这种方式注入文档可以更容易地进行可测试性。我们将在后面的章节中更多地讨论可测试性。它还允许在单个页面上多次重用视图，而不必担心两个实例之间的冲突。
- en: 'The constructor also contains a reference to the model which is used to add
    data to fields on the page as needed. Finally, the constructor also references
    a collection of errors. This allows for validation errors from the controller
    to be passed back to the view to be handled. We have set the validation result
    to be a wrapped collection that looks something like the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数还包含对模型的引用，用于根据需要向页面字段添加数据。最后，构造函数还引用了一个错误集合。这允许将控制器的验证错误传递回视图进行处理。我们已经设置了验证结果为一个包装集合，看起来像下面这样：
- en: '[PRE58]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The only functionality here is that the button's `onclick` method is bound to
    calling save on the controller. Instead of passing in a large number of parameters
    to the `saveCastle` function on the controller, we build a lightweight object
    and pass that in. This makes the code more readable, especially in cases where
    some of the parameters are optional. No real work is done in the view and all
    the input goes directly to the controller.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一功能是按钮的`onclick`方法绑定到调用控制器上的保存。我们不是将大量参数传递给控制器上的`saveCastle`函数，而是构建一个轻量级对象并传递进去。这使得代码更易读，特别是在一些参数是可选的情况下。视图中没有真正的工作，所有输入直接传递给控制器。
- en: 'The controller contains the real functionality of the application:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器包含应用程序的真正功能：
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The controller here does a number of things. The first thing is that it has
    a `setView` function which instructs the browser to set the given view as the
    current one. This is likely done through the use of a template. The mechanics
    of how that works are not important to the pattern so I'll leave that up to your
    imagination.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的控制器做了很多事情。首先，它有一个`setView`函数，指示浏览器将给定的视图设置为当前视图。这可能是通过使用模板来完成的。这个工作的机制对于模式来说并不重要，所以我会留给你的想象力。
- en: Next, the controller implements a `validate` method. This method checks to make
    sure that the model is valid. Some validation may be performed on the client,
    such as testing the format of a postal code, but other validation requires a server
    trip. If a username must be unique then there is no reasonable way to test that
    on the client without communicating with the server. In some cases, the validation
    functionality may exist on the model rather than in the controller.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，控制器实现了一个`validate`方法。该方法检查模型是否有效。一些验证可能在客户端执行，比如测试邮政编码的格式，但其他验证需要与服务器通信。如果用户名必须是唯一的，那么在客户端没有合理的方法在不与服务器通信的情况下进行测试。在某些情况下，验证功能可能存在于模型中而不是控制器中。
- en: Methods for setting up various different views are also found in the controller.
    In this case we have a bit of a workflow with a view for creating a castle then
    views for both success and failure. The failure case just returns the same view
    with a collection of validation errors attached to it. The success case returns
    a whole new view.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 设置各种不同视图的方法也在控制器中找到。在这种情况下，我们有一个创建城堡的视图，然后成功和失败的视图。失败情况只返回相同的视图，并附加一系列验证错误。成功情况返回一个全新的视图。
- en: The logic to save the model to some sort of persistent storage is also located
    in the controller. Again the implementation of this is less important than to
    see that the logic for communicating with the storage system is located in the
    controller.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 将模型保存到某种持久存储的逻辑也位于控制器中。再次强调，实现这一点不如看到与存储系统通信的逻辑位于控制器中重要。
- en: 'The final letter in MVC is the model. In this case, it is a very light weight
    one:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: MVC中的最后一个字母是模型。在这种情况下，它是一个非常轻量级的模型：
- en: '[PRE60]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, all it does is keep track of the variables that make up the
    state of the application.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它只是跟踪构成应用程序状态的变量。
- en: Concerns are well separated in this pattern allowing for changes to be made
    with relative ease.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式中的关注点得到了很好的分离，使得相对容易进行更改。
- en: Model View Presenter
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型视图Presenter
- en: The **Model View** **Presenter** ( **MVP** ) pattern is very similar to MVC.
    It is a fairly well known pattern in the Microsoft world and is generally used
    to structure WPF and Silverlight applications. It can be used in pure JavaScript
    as well. The key difference comes down to how the different parts of the system
    interact and where their responsibility ends.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型视图** **Presenter**（**MVP**）模式与MVC非常相似。这是在微软世界中相当知名的模式，通常用于构建WPF和Silverlight应用程序。它也可以在纯JavaScript中使用。关键区别在于系统不同部分的交互方式以及它们的责任范围。'
- en: 'The first difference is that, with the presenter, there is a one to one mapping
    between presenter and view. This means that the logic that existed in the controller
    in the MVC pattern, which selected the correct view to render, doesn''t exist.
    Or rather it exists at a higher level outside the concern of the pattern. The
    selection of the correct presenter may be handled by a routing tool. Such a router
    will examine the parameters and provide the best choice for the presenter. The
    flow of information in the MVP pattern can be seen here:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个区别是，使用Presenter时，Presenter和View之间存在一对一的映射关系。这意味着在MVC模式中存在于控制器中的逻辑，用于选择正确的视图进行渲染，不存在。或者说它存在于模式关注范围之外的更高级别。选择正确的Presenter可能由路由工具处理。这样的路由器将检查参数并提供最佳的Presenter选择。MVP模式中的信息流可以在这里看到：
- en: '![Model View Presenter](Image00039.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![Model View Presenter](Image00039.jpg)'
- en: The presenter is aware of both the view and the model but the view is unaware
    of the model and the model unaware of the view. All communication is passed through
    the presenter.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Presenter既知道View又知道Model，但View不知道Model，Model也不知道View。所有通信都通过Presenter传递。
- en: The presenter pattern is often characterized by a great deal of two-way dispatch.
    A click will fire in the presenter and then the presenter will update the model
    with the change and then the view. The preceding diagram suggests that the input
    first passes through the view. In a passive version of the MVP pattern, the view
    has little to no interaction with the messages as they are passed onto the presenter.
    However, there is also a variation called active MVP that allows the view to contain
    some additional logic.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Presenter模式通常以大量的双向分发为特征。点击将在Presenter中触发，然后Presenter将更新模型并更新视图。前面的图表表明输入首先通过视图传递。在MVP模式的被动版本中，视图与消息几乎没有交互，因为它们被传递到Presenter。然而，还有一种称为活动MVP的变体，允许视图包含一些额外的逻辑。
- en: This active version of MVP can be more useful for web situations. It permits
    adding validation and other simple logic to the view. This reduces the number
    of requests that need to pass from the client back to the web server.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这种活跃版本的MVP对于Web情况可能更有用。它允许在视图中添加验证和其他简单逻辑。这减少了需要从客户端传递回Web服务器的请求数量。
- en: Let's update our existing code sample to use MVP instead of MVC.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新现有的代码示例，使用MVP而不是MVC。
- en: MVP code
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVP代码
- en: 'Let''s start again with the view:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从视图开始：
- en: '[PRE61]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you can see the constructor for the view no longer takes a reference to the
    model. This is because the view in MVP doesn't have any idea about what model
    is being used. That information is abstracted away by the presenter. The reference
    to presenter remains in the constructor to allow sending messages back to the
    presenter.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，视图的构造函数不再接受对模型的引用。这是因为MVP中的视图不知道使用的是哪个模型。这些信息由Presenter抽象掉。保留对Presenter的引用仍然在构造函数中，以便向Presenter发送消息。
- en: Without the model there is an increase in the number of public setter and getter
    methods. These setters allow the presenter to make updates to the state of the
    view. The getters provide an abstraction over how the view stores the state and
    gives the presenter a way to get the information. The `saveCastle` function no
    longer passes any values to the presenter.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 没有模型的情况下，公共setter和getter方法的数量增加了。这些setter允许Presenter更新视图的状态。getter提供了一个抽象，隐藏了视图存储状态的方式，并为Presenter提供了获取信息的途径。`saveCastle`函数不再向Presenter传递任何值。
- en: 'The presenter''s code looks like the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Presenter的代码如下：
- en: '[PRE62]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You can see that the view is now referenced in a persistent fashion in the presenter.
    The `saveCastle` method calls into the view to get its values. However, the presenter
    does make sure to use the public methods of the view instead of referencing the
    document directly. The `saveCastle` method updates the model. If there are validation
    errors, then it will call back into the view to update the `IsValid` flag. This
    is an example of the double dispatch I mentioned earlier.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，视图现在以持久的方式在Presenter中被引用。`saveCastle`方法调用视图以获取其数值。然而，Presenter确保使用视图的公共方法而不是直接引用文档。`saveCastle`方法更新了模型。如果存在验证错误，它将回调视图以更新`IsValid`标志。这是我之前提到的双重分发的一个例子。
- en: Finally, the model remains unchanged from before. We've kept the validation
    logic in the presenter. At which level the validation is done, model or presenter,
    matters less than being consistent in where the validation is done through your
    application.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模型与以前一样保持不变。我们将验证逻辑保留在Presenter中。在哪个级别进行验证，模型还是Presenter，不如在整个应用程序中一致地进行验证更重要。
- en: The MVP pattern is again a fairly useful pattern for building user interfaces.
    The larger separation between the view and the model creates a stricter API allowing
    for better adaptation to change. However, this comes at the expense of more code.
    With more code comes more opportunity for bugs.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: MVP模式再次是构建用户界面的一个相当有用的模式。视图和模型之间更大的分离创建了一个更严格的API，允许更好地适应变化。然而，这是以更多的代码为代价的。更多的代码意味着更多的错误机会。
- en: Model View ViewModel
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型视图视图模型
- en: 'The final pattern we''ll look at in this chapter is the Model View ViewModel
    pattern, more commonly known as MVVM. By now this sort of pattern should be getting
    quite familiar. Again you can see the flow of information between components in
    this illustration:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中看到的最后一种模式是模型视图视图模型模式，更常被称为MVVM。到现在为止，这种模式应该已经相当熟悉了。再次，你可以在这个插图中看到组件之间的信息流：
- en: '![Model View ViewModel](Image00040.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![模型视图视图模型](Image00040.jpg)'
- en: You can see here that many of the same constructs have returned but that the
    communication between them is somewhat different.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里许多相同的构造已经回来了，但它们之间的通信有些不同。
- en: In this variation, what has previously been the controller and presenter is
    now the view model. Just like with MVC and MVP, the majority of the logic is held
    within the central component, in this case the view model. The model itself is
    actually very simple in MVVM. Typically, it acts as an envelope that just holds
    data. Validation is done within the view model.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种变化中，以前的控制器和Presenter现在是视图模型。就像MVC和MVP一样，大部分逻辑都在中心组件中，这里是视图模型。MVVM中的模型本身实际上非常简单。通常，它只是一个简单地保存数据的信封。验证是在视图模型中完成的。
- en: Just like with MVP, the view is totally unaware of the existence of the model.
    The difference is that, with MVP, the view was aware that it was talking to some
    intermediate class. It called methods rather than simply setting values. In MVVM
    the view believes that the view model is its view. Instead of calling operations
    like `saveCastle` and passing in data or waiting for data to be requested, the
    view updates fields on the view model as they change. In effect, the fields on
    the view are bound to the view model. The view model may proxy these values through
    to the model or wait until a commit-like operation like save is called to pass
    the data along.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 就像MVP一样，视图完全不知道模型的存在。不同之处在于，在MVP中，视图知道自己在与某个中间类交谈。它调用方法而不是简单地设置值。在MVVM中，视图认为视图模型就是它的视图。它不是调用像`saveCastle`这样的操作并传递数据，或者等待数据被请求，而是在字段发生变化时更新视图模型上的字段。实际上，视图上的字段与视图模型绑定。视图模型可以通过将这些值代理到模型，或者等到调用保存等类似操作时传递数据。
- en: Equally, changes to the view model should be reflected at once in the view.
    A single view may have a number of view models. Each of these view models may
    push updates to the view or have changes pushed to it via the view.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，对视图模型的更改应立即在视图中反映出来。一个视图可能有多个视图模型。这些视图模型中的每一个可能会向视图推送更新，或者通过视图向其推送更改。
- en: Let's take a look at a really rudimentary implementation of this and then we'll
    discuss how to make it better.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个真正基本的实现，然后我们将讨论如何使其更好。
- en: MVVM code
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM代码
- en: 'The naïve view implementation is, frankly, a huge mess:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 天真的视图实现，坦率地说，是一团糟：
- en: '[PRE63]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'It is highly repetitive and each property must be proxied back to `ViewModel`
    . I''ve truncated most of this code but it adds up to a good 70 lines. The code
    inside the view model is equally terrible:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这是高度重复的，每个属性都必须被代理回`ViewModel`。我截断了大部分代码，但总共有大约70行。视图模型内部的代码同样糟糕：
- en: '[PRE64]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'One look at this code should send you running for the hills. It is set up in
    a way that will encourage copy and paste programming: a fantastic way to introduce
    errors into a code base. I sure hope there is a better way to transfer changes
    between the model and the view.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 看一眼这段代码就会让你望而却步。它的设置方式会鼓励复制粘贴编程：这是引入代码错误的绝佳方式。我真希望有更好的方法来在模型和视图之间传递变化。
- en: A better way to transfer changes between the model and the view
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模型和视图之间传递变化的更好方法
- en: It may not have escaped your notice that there are a number of MVVM-style frameworks
    for JavaScript in the wild. Obviously they would not have been readily adopted
    if they followed the approach that we described in the preceding section. Instead
    they follow one of two different approaches.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有许多MVVM风格的JavaScript框架。显然，如果它们遵循我们在前一节中描述的方法，它们就不会被广泛采用。相反，它们遵循两种不同的方法之一。
- en: The first approach is known as dirty checking. In this approach, after every
    interaction with the view model we loop over all of its properties looking for
    changes. When changes are found, the related value in the view is updated with
    the new value. For changes to values in the view change, actions are attached
    to all the controls. These then trigger updates to the view model.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法被称为脏检查。在这种方法中，与视图模型的每次交互之后，我们都会遍历其所有属性，寻找变化。当发现变化时，视图中的相关值将被更新为新值。对于视图中值的更改，操作都附加到所有控件上。然后这些操作会触发对视图模型的更新。
- en: 'This approach can be slow for large models as it is expensive to iterate over
    all the properties of a large model. The number of things which can cause a model
    to change is high and there is no real way to tell if a distant field in a model
    has been changed by changing another without going and validating it. On the upside,
    dirty checking allows you to use plain old JavaScript objects. There is no need
    to write your code any differently than before. The same is not true of the other
    approach: container objects.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型模型来说，这种方法可能会很慢，因为遍历大型模型的所有属性是昂贵的。可以导致模型变化的事情很多，而且没有真正的方法来判断是否通过更改另一个字段来改变模型中的一个远程字段，而不去验证它。但好处是，脏检查允许你使用普通的JavaScript对象。不需要像以前那样编写代码。而另一种方法——容器对象则不然。
- en: With a container object a special interface is provided to wrap existing objects
    so that changes to the object may be directly observed. Basically this is an application
    of the observer pattern but applied dynamically so the underlying object has no
    idea it is being observed. The spy pattern, perhaps?
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器对象提供了一个特殊的接口，用于包装现有对象，以便直接观察对象的变化。基本上这是观察者模式的应用，但是动态应用，因此底层对象并不知道自己正在被观察。间谍模式，也许？
- en: 'An example might be helpful here. Let us say that we have the model object
    we''ve been using up until now:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这里举个例子可能会有所帮助。假设我们现在使用的是之前的模型对象：
- en: '[PRE65]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, instead of `model.name` being a simple string, we would wrap some function
    around it. In the case of the Knockout library this would look like the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`model.name`不再是一个简单的字符串，我们会在其周围包装一些函数。在Knockout库的情况下，代码如下所示：
- en: '[PRE66]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the highlighted code, the various properties of the model are being wrapped
    with an observable. This means that they must now be accessed differently:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，模型的各种属性都被包装成可观察的。这意味着它们现在必须以不同的方式访问：
- en: '[PRE67]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This approach obviously adds some friction to your code and makes changing frameworks
    quite involved.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法显然给你的代码增加了一些摩擦，并且使得更改框架相当复杂。
- en: Current MVVM frameworks are split on their approach to container objects versus
    dirty checking. AngularJS uses dirty checking while Backbone, Ember, and Knockout
    all make use of container objects. There is currently no clear winner.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的MVVM框架在处理容器对象与脏检查方面存在分歧。AngularJS使用脏检查，而Backbone、Ember和Knockout都使用容器对象。目前还没有明显的赢家。
- en: Observing view changes
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察视图变化
- en: Fortunately, the pervasiveness of MV* patterns on the web and the difficulties
    with observing model changes has not gone unnoticed. You might be expecting me
    to say that this will be solved in ECMAScript-2015 as is my normal approach. Weirdly,
    the solution to all of this, `Object.observe` , is a feature under discussion
    for ECMAScript-2016\. However, at the time of writing, at least one major browser
    already supports it.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Web上MV*模式的普及以及观察模型变化的困难并没有被忽视。你可能期待我说这将在ECMAScript-2015中得到解决，因为这是我的正常做法。奇怪的是，解决所有这些问题的`Object.observe`，是ECMAScript-2016讨论中的一个功能。然而，在撰写本文时，至少有一个主要浏览器已经支持它。
- en: 'It can be used like the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像下面这样使用：
- en: '[PRE68]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Having this simple interface to monitor changes to objects removes much of the
    logic provided by large MV* frameworks. It will be easier to roll your own functionality
    for MV* and there may, in fact, be no need to use external frameworks.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的接口来监视对象的变化，可以消除大型MV*框架提供的大部分逻辑。为MV*编写自己的功能将会更容易，实际上可能根本不需要使用外部框架。
- en: Tips and tricks
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: The different layers of the various MV* patterns need not all be on the browser,
    nor do they all need to be written in JavaScript. Many popular frameworks allow
    for maintaining a model on the server and communicating with it using JSON.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 各种MV*模式的不同层不一定都在浏览器上，也不一定都需要用JavaScript编写。许多流行的框架允许在服务器上维护模型，并使用JSON进行通信。
- en: '`Object.observe` may not be available on all browsers yet, but there are polyfills
    that can be used to create a similar interface. The performance is not as good
    as the native implementation, but it is still usable.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.observe`可能还没有在所有浏览器上可用，但有一些polyfill可以用来创建类似的接口。性能不如原生实现好，但仍然可用。'
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Separating concerns to a number of layers ensures that changes to the application
    are isolated like a ripstop. The various MV* patterns allow for separating the
    concerns in a graphical application. The differences between the various patterns
    come down to how the responsibilities are separated and how information is communicated.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 将关注点分离到多个层次可以确保应用程序的变化像防撕裂一样被隔离。各种MV*模式允许在图形应用程序中分离关注点。各种模式之间的差异在于责任如何分离以及信息如何通信。
- en: In the next chapter we'll look at a number of patterns and techniques to improve
    the experience of developing and deploying JavaScript to the Web.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些模式和技术，以改善开发和部署JavaScript到Web的体验。
- en: Chapter 9. Web Patterns
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 网页模式
- en: The rise of Node.js has proven that JavaScript has a place on web servers, even
    very high throughput servers. There is no denying that JavaScript's pedigree remains
    in the browser for client side programming.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的崛起证明了JavaScript在Web服务器上有一席之地，甚至是非常高吞吐量的服务器。毫无疑问，JavaScript的传统仍然在客户端进行编程的浏览器中。
- en: In this chapter we're going to look at a number of patterns to improve the performance
    and usefulness of JavaScript on the client. I'm not sure that all of these can
    be thought of as patterns in the strictest sense. They are, however, important
    and worth mentioning.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些模式，以提高客户端JavaScript的性能和实用性。我不确定所有这些是否都可以被认为是严格意义上的模式。然而，它们是重要的，值得一提。
- en: 'The concepts we''ll examine in this chapter are as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下概念：
- en: Sending JavaScript
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送JavaScript
- en: Plugins
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件
- en: Multithreading
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程
- en: Circuit breaker pattern
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器模式
- en: Back-off
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退避
- en: Promises
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺
- en: Sending JavaScript
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送JavaScript
- en: 'Communicating JavaScript to the client seems to be a simple proposition: so
    long as you can get the code to the client it doesn''t matter how that happens,
    right? Well not exactly. There are actually a number of things that need to be
    considered when sending JavaScript to the browser.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 将JavaScript传输给客户端似乎是一个简单的命题：只要您可以将代码传输给客户端，那么传输方式并不重要，对吗？嗯，不完全是这样。实际上，在将JavaScript发送到浏览器时需要考虑一些事情。
- en: Combining files
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并文件
- en: Way back in [Chapter 2](text00019.html#page "Chapter 2. Organizing Code") ,
    *Organizing Code* , we looked at how to build objects using JavaScript, although
    opinions on this vary. I consider it to be good form to have a one-class-to-one-file
    organization of my JavaScript or really any of my object oriented code. By doing
    this, it makes finding code easy. Nobody needs to hunt through a 9000 line long
    JavaScript file to locate that one method. It also allows for a hierarchy to be
    established again allowing for good code organization. However, good organization
    for a developer is not necessarily good organization for a computer. In our case
    having a lot of small files is actually highly detrimental. To understand why,
    you need to know a little bit about how browsers ask for and receive content.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](text00019.html#page "第2章。组织代码")中，*组织代码*，我们讨论了如何使用JavaScript构建对象，尽管对此的看法有所不同。我认为，将我的JavaScript或任何面向对象的代码组织成一个类对应一个文件的形式是一个好习惯。通过这样做，可以轻松找到代码。没有人需要在9000行长的JavaScript文件中寻找那个方法。它还允许建立一个层次结构，再次实现良好的代码组织。然而，对于开发人员的良好组织并不一定对计算机来说是良好的组织。在我们的情况下，拥有大量小文件实际上是非常有害的。要了解为什么，您需要了解一些关于浏览器如何请求和接收内容的知识。
- en: 'When you type a URL into the address bar of a browser and hit *Enter* , a cascading
    series of events happens. The first thing is that the browser will ask the operating
    system to resolve the website name to an IP address. On both Windows and Linux
    (and OSX) the standard C library function `gethostbyname` is used. This function
    will check the local DNS cache to see if the mapping from name to address is already
    known. If it is, then that information is returned. If not, then the computer
    makes a request to the DNS server one step up from it. Typically, this is the
    DNS server provided by the ISP but on a larger network it could also be a local
    DNS server. The path of a query between DNS servers can be seen here:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在浏览器的地址栏中输入URL并按下*Enter*时，会发生一系列级联事件。首先，浏览器会要求操作系统将网站名称解析为IP地址。在Windows和Linux（以及OSX）上使用标准C库函数`gethostbyname`。此函数将检查本地DNS缓存，以查看名称到地址的映射是否已知。如果是，则返回该信息。如果不是，则计算机会向其上一级的DNS服务器发出请求。通常，这是由ISP提供的DNS服务器，但在较大的网络上也可能是本地DNS服务器。可以在此处看到DNS服务器之间的查询路径：
- en: '![Combining files](Image00041.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![合并文件](Image00041.jpg)'
- en: If a record doesn't exist on that server then the request is propagated up a
    chain of DNS servers in an attempt to find one that knows about the domain. Eventually
    the propagation stops at the root servers. These root servers are the stopping
    point for queries – if they don't know who is responsible for DNS information
    for a domain then the lookup is deemed to have failed.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器上不存在记录，则请求会在一系列DNS服务器之间传播，以尝试找到知道该域的服务器。最终，传播会停止在根服务器处。这些根服务器是查询的终点 - 如果它们不知道谁负责域的DNS信息，那么查找将被视为失败。
- en: Once the browser has an address for the site it opens up a connection and sends
    a request for the document. If no document is provided, then a */* is sent. Should
    the connection be a secure one, then negotiation of SSL/TSL is performed at this
    time. There is some computational expense to setting up an encrypted connection
    but this is slowly being fixed.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦浏览器有了站点的地址，它就会打开一个连接并发送对文档的请求。如果没有提供文档，则发送*/*。如果连接是安全的，则此时执行SSL/TSL的协商。建立加密连接会有一些计算开销，但这正在慢慢得到解决。
- en: 'The server will respond with a blob of HTML. As the browser receives this HTML
    it starts to process it; the browser does not wait for the entire HTML document
    to be downloaded before it goes to work. If the browser encounters a resource
    that is external to the HTML it will kick off a new request to open another connection
    to the web server and download that resource. The maximum number of connections
    to a single domain is limited so that the web server isn''t flooded. It should
    also be mentioned that setting up a new connection to the web server carries overhead.
    The flow of data between a web client and server can be seen in this illustration:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将以HTML的形式做出响应。当浏览器接收到这个HTML时，它开始处理它；浏览器在整个HTML文档被下载之前并不等待。如果浏览器遇到一个外部于HTML的资源，它将启动一个新的请求，打开另一个连接到Web服务器并下载该资源。对于单个域的最大连接数是有限制的，以防止Web服务器被淹没。还应该提到，建立到Web服务器的新连接会带来开销。Web客户端和服务器之间的数据流可以在这个插图中看到：
- en: '![Combining files](Image00042.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![合并文件](Image00042.jpg)'
- en: 'Connections to the web server should be limited to avoid paying the connection
    setup costs repeatedly. This brings us to our first concept: combining files.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 应该限制与Web服务器的连接，以避免重复支付连接设置成本。这带我们来到我们的第一个概念：合并文件。
- en: If you've followed the advice to leverage namespaces and classes in your JavaScript,
    then putting all of your JavaScript together in a single file is a trivial step.
    One need only concatenate the files together and everything should continue to
    work as normal. Some minor care and attention may need to be paid to the order
    of inclusion, but not typically.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经遵循了在JavaScript中利用命名空间和类的建议，那么将所有JavaScript放在单个文件中就是一个微不足道的步骤。只需要将文件连接在一起，一切应该继续像往常一样工作。可能需要稍微注意一下包含的顺序，但通常不需要。
- en: 'The previous code we''ve written has been pretty much one file per pattern.
    If there is a need for multiple patterns to be used, then we could simply concatenate
    the files together. For instance, the combined builder and factory method patterns
    might look like the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前编写的代码基本上是每个模式一个文件。如果需要使用多个模式，那么我们可以简单地将文件连接在一起。例如，组合的生成器和工厂方法模式可能如下所示：
- en: '[PRE69]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The question may arise as to how much of your JavaScript should be combined
    and loaded at once. It is a surprisingly difficult question to answer. On one
    hand it is desirable to front load all the JavaScript for the entire site when
    users first arrive at the site. This means that users will pay a price initially
    but will not have to download any additional JavaScript as they travel about the
    site. This is because the browser will cache the script and reuse it instead of
    downloading it from the server again. However, if users only visit a small subset
    of the pages on the site then they will have loaded a great deal of JavaScript
    that was not needed.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现一个问题，即应该一次组合和加载多少JavaScript。这是一个令人惊讶地难以回答的问题。一方面，希望在用户首次访问站点时为整个站点加载所有JavaScript。这意味着用户最初会付出代价，但在浏览站点时不必下载任何额外的JavaScript。这是因为浏览器将缓存脚本并重复使用它，而不是再次从服务器下载。然而，如果用户只访问站点上的一小部分页面，那么他们将加载许多不需要的JavaScript。
- en: On the other hand, splitting up the JavaScript means that additional page visits
    incur a penalty for retrieving additional JavaScript files. There is a sweet spot
    somewhere in the middle of these two approaches. Script can be organized into
    blocks that map to different sections of the website. This can be a place where
    using proper name spacing will come in handy once again. Each namespace can be
    combined into a single file and then loaded as users visit that part of the site.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，拆分JavaScript意味着额外的页面访问会因检索额外的JavaScript文件而产生惩罚。这两种方法之间存在一个平衡点。脚本可以被组织成映射到网站不同部分的块。这可能是再次使用适当的命名空间的地方。每个命名空间可以合并到一个文件中，然后在用户访问站点的那部分时加载。
- en: In the end, the only approach that makes sense is to maintain statistics about
    how users move about the site. Based on this information an optimal strategy for
    finding the sweet spot can be established.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，唯一有意义的方法是维护关于用户如何在站点上移动的统计信息。根据这些信息，可以建立一个找到平衡点的最佳策略。
- en: Minification
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩小
- en: Combining JavaScript into a single file solves the problem of limiting the number
    of requests. However, each request may still be large. Again we come to a schism
    between what makes code fast and readable by humans and what makes it fast and
    readable by computers.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 将JavaScript合并到单个文件中解决了限制请求数量的问题。然而，每个请求可能仍然很大。我们再次面临一个问题，即如何使代码对人类快速可读与对计算机快速可读之间的分歧。
- en: We humans like descriptive variable names, bountiful whitespace, and proper
    indentation. Computers don't care about descriptive names, whitespace, or proper
    indentation. In fact, these things increase the size of the file and thus decrease
    the speed at which the code can be read.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们人类喜欢描述性的变量名，丰富的空格和适当的缩进。计算机不在乎描述性名称，空格或适当的缩进。事实上，这些东西会增加文件的大小，从而减慢代码的阅读速度。
- en: Minification is a compile step that transforms the human readable code into
    smaller, but equivalent, code. External variables' names remain the same, as the
    minifier has no way to know what other code may be relying on the variable names
    remaining unchanged.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小是一个将人类可读的代码转换为更小但等效的代码的编译步骤。外部变量的名称保持不变，因为缩小器无法知道其他代码可能依赖于变量名称保持不变。
- en: 'As an example, if we start with the composite code from [Chapter 4](text00035.html#page
    "Chapter 4. Structural Patterns") , *Structural Patterns* , the minified code
    looks like the following:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们从[第4章](text00035.html#page "第4章 结构模式")的组合代码开始，*结构模式*，压缩后的代码如下所示：
- en: '[PRE70]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You'll notice that all the spacing has been removed and that any internal variables
    have been replaced with smaller versions. At the same time, you can spot some
    well-known variable names have remained unchanged.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到所有空格已被移除，并且任何内部变量都已被替换为较小的版本。与此同时，您可以看到一些众所周知的变量名保持不变。
- en: Minification saved this particular piece of code 40%. Compressing the content
    stream from the server using gzip, a popular approach, is lossless compression.
    That means that there is a perfect bijection between compressed and uncompressed.
    Minification, on the other hand, is a lossy compression. There is no way to get
    back to the unminified code from just the minified code once it has been minified.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小使这段特定代码节省了40%。使用gzip对服务器的内容流进行压缩是一种流行的方法，是无损压缩。这意味着压缩和未压缩之间存在完美的双射。另一方面，缩小是一种有损压缩。一旦进行了缩小，就无法仅从缩小的代码中恢复到未缩小的代码。
- en: Note
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about gzip compression at [http://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/](http://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/)
    .
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/](http://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/)了解更多关于gzip压缩的信息。
- en: If there is a need to return to the original code, then source maps can be used.
    A source map is a file that provides a translation from one format of code to
    another. It can be loaded by the debugging tools in modern browsers to allow you
    to debug the original code instead of unintelligible minified code. Multiple source
    maps can be combine to allow for translation from, say, minified code to unminified
    JavaScript to TypeScript.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要返回到原始代码，则可以使用源映射。源映射是提供从一种代码格式到另一种代码格式的转换的文件。它可以被现代浏览器中的调试工具加载，允许您调试原始代码而不是难以理解的压缩代码。多个源映射可以组合在一起，以允许从压缩代码到未压缩的JavaScript到TypeScript的转换。
- en: There are numerous tools which can be used to construct minified and combined
    JavaScript. Gulp and Grunt are JavaScript-based tools for building a pipeline
    which manages JavaScript assets. Both these tools call out to external tools such
    as Uglify to do the actual work. Gulp and Grunt are the equivalent to GNU Make
    or Ant.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可用于构建压缩和合并的JavaScript。Gulp和Grunt是构建JavaScript资产管道的基于JavaScript的工具。这两个工具都调用外部工具（如Uglify）来执行实际工作。Gulp和Grunt相当于GNU
    Make或Ant。
- en: Content Delivery Networks
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容交付网络
- en: The final delivery trick is to make use of **Content Delivery Networks** ( **CDNs**
    ). CDNs are distributed networks of hosts whose only purpose is to serve out static
    content. In much the same way that the browser will cache JavaScript between pages
    on the site, it will also cache JavaScript that is shared between multiple web
    servers. Thus, if your site makes use of jQuery, pulling jQuery from a well-known
    CDN such as [https://code.jquery.com/](https://code.jquery.com/) or Microsoft's
    ASP.net CDN may be faster as it is already cached. Pulling from a CDN also means
    that the content is coming from a different domain and doesn't count against the
    limited connections to your server. Referencing a CDN is as simple as setting
    the source of the script tag to point at the CDN.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 最终交付的技巧是利用**内容交付网络**（**CDN**）。CDN是分布式主机网络，其唯一目的是提供静态内容。就像浏览器在网站页面之间缓存JavaScript一样，它也会缓存在多个Web服务器之间共享的JavaScript。因此，如果您的网站使用jQuery，从知名CDN（如[https://code.jquery.com/](https://code.jquery.com/)或Microsoft的ASP.net
    CDN）获取jQuery可能会更快，因为它已经被缓存。从CDN获取还意味着内容来自不同的域，并且不计入对服务器的有限连接。引用CDN就像将脚本标签的源设置为指向CDN一样简单。
- en: Once again, some metrics will need to be gathered to see whether it is better
    to use a CDN or simply roll libraries into the JavaScript bundle. Examples of
    such metrics may include the added time to perform additional DNS lookup and the
    difference in the download sizes. The best approach is to use the timing APIs
    in the browser.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，需要收集一些指标，以查看是更好使用CDN还是将库简单地合并到JavaScript包中。此类指标的示例可能包括执行额外DNS查找所需的时间以及下载大小的差异。最佳方法是使用浏览器中的时间API。
- en: The long and short of distributing JavaScript to the browser is that experimentation
    is required. Testing a number of approaches and measuring the results will give
    the best result for end users.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 将JavaScript分发到浏览器的长短是需要实验的。测试多种方法并测量结果将为最终用户带来最佳结果。
- en: Plugins
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件
- en: There are a great number of really impressive JavaScript libraries in the wild.
    For me the library that changed how I look at JavaScript was jQuery. For others
    it may have been one of the other popular libraries such as MooTool, Dojo, Prototype,
    or YUI. However, jQuery has exploded in popularity and has, at the time of writing,
    won the JavaScript library wars. 78.5% of the top ten thousand websites, by traffic,
    on the internet make use of some version of jQuery. None of the rest of the libraries
    even breaks 1%.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在野外有许多令人印象深刻的JavaScript库。对我来说，改变了我对JavaScript的看法的库是jQuery。对于其他人来说，可能是其他流行的库，比如MooTool、Dojo、Prototype或YUI。然而，jQuery在流行度上迅速增长，并且在撰写本文时，已经赢得了JavaScript库之争。互联网上前一万个网站中有78.5%使用了某个版本的jQuery。其他库甚至没有超过1%。
- en: Many developers have seen fit to implement their own libraries on top of these
    foundational libraries in the form of plugins. A plugin typically modifies the
    prototype exposed by the library and adds additional functionality. The syntax
    is such that, to the end developer, it appears to be part of the core library.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员已经决定在这些基础库的基础上实现自己的库，以插件的形式。插件通常修改库暴露的原型并添加额外的功能。语法是这样的，对于最终开发人员来说，它看起来就像是核心库的一部分。
- en: How plugins are built varies depending on the library you're trying to extend.
    Nonetheless, let's take a look at how we can build a plugin for jQuery and then
    for one of my favourite libraries, d3\. We'll see if we can extract some commonalities.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 构建插件的方式取决于您要扩展的库。尽管如此，让我们看看如何为jQuery构建插件，然后为我最喜欢的库之一d3构建插件。我们将看看是否可以提取一些共同点。
- en: jQuery
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery
- en: 'At jQuery''s core is the CSS selector library called `sizzle.js` . It is sizzle
    that is responsible for all the really nifty ways jQuery can select items on a
    page using CSS3 selectors. Use jQuery to select elements on a page like so:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的核心是名为`sizzle.js`的CSS选择器库。正是sizzle负责jQuery可以使用CSS3选择器在页面上选择项目的所有非常聪明的方法。使用jQuery在页面上选择元素如下：
- en: '[PRE71]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here, a jQuery object is returned. The jQuery object acts a lot like, although
    not completely like, an array. This is achieved by creating a series of keys on
    the jQuery object numbered 0 through to n-1 where n is the number of elements
    matched by the selector. This is actually pretty smart as it enables array like
    accessors:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，返回了一个jQuery对象。jQuery对象的行为很像，尽管不完全像数组。这是通过在jQuery对象上创建一系列从0到n-1的键来实现的，其中n是选择器匹配的元素数量。这实际上非常聪明，因为它使得可以像访问数组一样访问器：
- en: '[PRE72]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: While providing a bunch of additional functions, the items at the indices are
    plain HTML Elements and not wrapped with jQuery, hence the use of the second `$()`
    .
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然提供了大量额外的功能，但索引处的项目是普通的HTML元素，而不是用jQuery包装的，因此使用第二个`$()`。
- en: 'For jQuery plugins, we typically want to make our plugins extend this jQuery
    object. Because it is dynamically created every time the selector is fired we
    actually extend an object called `$.fn` . This object is used as the basis for
    creating all jQuery objects. Thus creating a plugin that transforms all the text
    in inputs on the page into uppercase is nominally as simple as the following:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 对于jQuery插件，我们通常希望使我们的插件扩展这个jQuery对象。因为它在每次选择器被触发时动态创建，我们实际上扩展了一个名为`$.fn`的对象。这个对象被用作创建所有jQuery对象的基础。因此，创建一个插件，将页面上所有输入框中的文本转换为大写，名义上就像下面这样简单：
- en: '[PRE73]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This plugin is particularly useful for posting to bulletin boards and for whenever
    my boss fills in a form. The plugin iterates over all the objects selected by
    the selector and converts their content to uppercase. It also returns this. By
    doing so we allow for chaining of additional functions. You can use the function
    like so:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件特别适用于发布到公告板，以及每当我的老板填写表格时。该插件遍历选择器选择的所有对象，并将它们的内容转换为大写。它也返回这个。通过这样做，我们允许链接额外的函数。您可以这样使用该函数：
- en: '[PRE74]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: It does rather depend on the `$` variable being assigned to jQuery. This isn't
    always the case as `$` is a popular variable in JavaScript libraries, likely because
    it is the only character that isn't a letter or a number and doesn't already have
    special meaning.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这在很大程度上取决于`$`变量被赋值给jQuery。这并不总是这样，因为`$`是JavaScript库中一个常用的变量，可能是因为它是唯一一个既不是字母也不是数字，也没有特殊含义的字符。
- en: 'To combat this, we can use an immediately evaluated function in much the same
    way we did way back in [Chapter 2](text00019.html#page "Chapter 2. Organizing
    Code") , *Organizing Code* :'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用立即执行的函数，就像我们在[第2章](text00019.html#page "第2章。组织代码")中所做的那样，*组织代码*：
- en: '[PRE75]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The added advantage here is that, should our code require helper functions or
    private variables, they can be set inside the same function. You can also pass
    in any options required. jQuery provides a very helpful `$.extend` function that
    copies properties between objects, making it ideal for extending a set of default
    options with those passed in. We looked at this in some detail in a previous chapter.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的额外优势是，如果我们的代码需要辅助函数或私有变量，它们可以在同一个函数内设置。您还可以传入所需的任何选项。jQuery提供了一个非常有用的`$.extend`函数，它可以在对象之间复制属性，非常适合用于将一组默认选项与传入的选项扩展在一起。我们在之前的章节中详细讨论过这一点。
- en: 'The jQuery plugin documentation recommends that the jQuery object be polluted
    as little as possible with plugins. This is to avoid conflicts between multiple
    plugins that want to use the same names. Their solution is to have a single function
    that has different behaviours depending on the parameters passed in. For instance,
    the jQuery UI plugin uses this approach for dialog:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery插件文档建议尽量减少对jQuery对象的污染。这是为了避免多个插件之间使用相同名称而产生冲突。他们的解决方案是有一个单一的函数，具有不同的行为，取决于传入的参数。例如，jQuery
    UI插件就使用了这种方法来创建对话框：
- en: '[PRE76]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'I would much rather call these like the following:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢这样调用：
- en: '[PRE77]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: With dynamic languages there really isn't a great deal of difference but I would
    much rather have well named functions that can be discovered by tooling than magic
    strings.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态语言，实际上并没有太大的区别，但我更喜欢有良好命名的函数，可以通过工具发现，而不是魔术字符串。
- en: d3
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: d3
- en: 'd3 is a great JavaScript library that is used for creating and manipulating
    visualizations. For the most part, people use d3 in conjunction with scalable
    vector graphics to produce graphics such as this hexbin graph by Mike Bostock:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: d3是一个用于创建和操作可视化的优秀JavaScript库。大多数情况下，人们会将d3与可伸缩矢量图形一起使用，以制作像Mike Bostock的这个六边形图表一样的图形：
- en: '![d3](Image00043.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![d3](Image00043.jpg)'
- en: d3 attempts to be non-opinionated about the sorts of visualizations it creates.
    Thus there is no built-in support for creating such things as bar charts. There
    is, however, a collection of plugins that can be added to d3 to enable a wide
    variety of graphs including the hexbin one shown in the preceding figure.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: d3试图不对其创建的可视化类型发表意见。因此，它没有内置支持创建条形图等内容。然而，有一系列插件可以添加到d3中，以实现各种各样的图表，包括前面图中显示的六边形图表。
- en: 'Even more, the jQuery d3 places emphasis on creating chainable functions. For
    example, this code is a snippet that creates a column chart. You can see that
    all the attributes are being set through chaining:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，jQuery d3强调创建可链接的函数。例如，这段代码是创建柱状图的片段。您可以看到所有的属性都是通过链接设置的：
- en: '[PRE78]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The core of `d3` is the `d3` object. Off that object hang a number of namespaces
    for layouts, scales, geometry, and numerous others. As well as whole namespaces,
    there are functions for doing array manipulation and loading data from external
    sources.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3`的核心是`d3`对象。该对象下挂了许多用于布局、比例尺、几何等的命名空间。除了整个命名空间，还有用于数组操作和从外部源加载数据的函数。'
- en: 'Creating a plugin for `d3` starts with deciding where we''re going to plug
    into the code. Let''s build a plugin that creates a new color scale. A color scale
    is used to map a domain of values to a range of colors. For instance, we might
    wish to map the domain of the following four values onto a range of four colors:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 为`d3`创建一个插件的开始是决定我们将在代码中插入的位置。让我们构建一个创建新颜色比例尺的插件。颜色比例尺用于将一组值的定义域映射到一组颜色的值域。例如，我们可能希望将以下四个值的定义域映射到四种颜色的值域：
- en: '![d3](Image00044.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![d3](Image00044.jpg)'
- en: 'Let''s plug in a function to provide a new color scale, in this case one that
    supports grouping elements. A scale is a function that maps a domain to a range.
    For a color scale, the range is a set of colors. An example might be a function
    that maps all even numbers to red and all odd to white. Using this scale on a
    table would result in zebra striping:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们插入一个函数来提供一个新的颜色比例尺，这种情况下支持分组元素。比例尺是一个将定义域映射到值域的函数。对于颜色比例尺，值域是一组颜色。一个例子可能是一个函数，将所有偶数映射到红色，所有奇数映射到白色。在表格上使用这个比例尺会产生斑马条纹：
- en: '[PRE79]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We simply attach this plugin to the existing `d3.scale` object. This can be
    used by simply giving an array of arrays as a domain and an array as a range:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将这个插件附加到现有的`d3.scale`对象上。这可以通过简单地给定一个数组作为定义域和一个数组作为值域来使用：
- en: '[PRE80]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This simple plugin extends the functionality of d3's scale. We could have replaced
    existing functionality or even wrapped it such that calls into existing functionality
    would be proxied through our plugin.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的插件扩展了d3的比例尺功能。我们可以替换现有的功能，甚至包装它，使得对现有功能的调用可以通过我们的插件代理。
- en: Plugins are generally not that difficult to build but they do vary from library
    to library. It is important to keep an eye on the existing variable names in libraries
    so we don't end up clobbering them or even clobbering functionality provided by
    other plugins. Some suggest prefixing functions with a string to avoid clobbering.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 插件通常并不难构建，但它们在不同的库中可能有所不同。重要的是要注意库中现有变量名，以免覆盖它们，甚至覆盖其他插件提供的功能。一些建议使用字符串前缀来避免覆盖。
- en: If the library has been designed with it in mind there may be additional places
    into which we can hook. A popular approach is to provide an options object that
    contains optional fields for hooking in our own functions as event handlers. If
    nothing is provided the function continues as normal.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库在设计时考虑到了这一点，可能会有更多的地方可以挂接。一个流行的方法是提供一个选项对象，其中包含用于挂接我们自己的函数作为事件处理程序的可选字段。如果没有提供任何内容，函数将继续正常运行。
- en: Doing two things at once – multithreading
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时做两件事情-多线程
- en: Doing two things at once is hard. For many years the solution in the computer
    world was to use either multiple processes or multiple threads. The difference
    between the two is fuzzy due to implementation differences on different operating
    systems but threads are typically lighter-weight versions of processes. JavaScript
    on the browser supports neither of these approaches.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 同时做两件事情是困难的。多年来，计算机世界的解决方案要么是使用多个进程，要么是使用多个线程。由于不同操作系统上的实现差异，两者之间的区别模糊不清，但线程通常是进程的轻量级版本。浏览器上的JavaScript不支持这两种方法。
- en: Historically, there has been no real need for multithreading on a browser. JavaScript
    was used to manipulate the user interface. When manipulating a UI, even in other
    languages and windowing environments, only one thread is permitted to act at a
    time. This avoids race conditions that would be very obvious to users.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器上历史上并没有真正需要多线程。JavaScript被用来操作用户界面。在操作用户界面时，即使在其他语言和窗口环境中，也只允许一个线程同时操作。这避免了对用户来说非常明显的竞争条件。
- en: However, as JavaScript grows in popularity, more and more complicated software
    is being written to run inside the browser. Sometimes that software could really
    benefit from performing complex calculations in the background.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着JavaScript在流行度上的增长，越来越复杂的软件被编写以在浏览器内运行。有时，这些软件确实可以从在后台执行复杂计算中受益。
- en: Web workers provide a mechanism for doing two things at once in a browser. Although
    a fairly recent innovation, web workers now have good support in mainstream browsers.
    In effect a worker is a background thread that can communicate with the main thread
    using messages. Web workers must be self-contained in a single JavaScript file.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Web workers为浏览器提供了一种同时进行两件事情的机制。虽然这是一个相当新的创新，但Web workers现在在主流浏览器中得到了很好的支持。实际上，工作线程是一个可以使用消息与主线程通信的后台线程。Web
    workers必须在单个JavaScript文件中自包含。
- en: 'To make use of web workers is fairly easy. We''ll revisit our example from
    a few chapters ago when we looked at the fibonacci sequence. The worker process
    listens for messages like so:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web workers相当容易。我们将回顾一下之前几章中我们看过的斐波那契数列的例子。工作进程监听消息如下：
- en: '[PRE81]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here we start a new instance of `fib` any time we get a `startCalculation` message.
    `fib` is simply the naive implementation from earlier.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每当收到一个`startCalculation`消息时，我们就会启动一个新的`fib`实例。`fib`只是之前的朴素实现。
- en: 'The main thread loads the worker process from its external file and attaches
    a number of listeners:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 主线程从外部文件加载工作进程，并附加了一些监听器：
- en: '[PRE82]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In order to start the calculation, all that is needed is to send a command:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始计算，只需要发送一个命令：
- en: '[PRE83]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here we pass the number of the term in the sequence we want to calculate. While
    the calculation is running in the background the main thread is free to do whatever
    it likes. When the message is received back from the worker it is placed in the
    normal event loop to be processed:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递我们想要计算的序列中的项的编号。当计算在后台运行时，主线程可以自由地做任何它想做的事情。当从工作线程接收到消息时，它被放入正常的事件循环中进行处理：
- en: '![Doing two things at once – multithreading](Image00045.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![同时做两件事情-多线程](Image00045.jpg)'
- en: Web workers may be useful to you if you have to do any time consuming calculations
    in JavaScript.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在JavaScript中进行耗时的计算，Web workers可能对你有用。
- en: If you're making use of server-side JavaScript through the use of Node.js then
    there is a different approach to doing more than one thing at a time. Node.js
    offers the ability to fork child processes and provides an interface not dissimilar
    to the web worker one to communicate between the child and parent processes. This
    method forks an entire process though, which is much more resource intensive than
    using lightweight threads.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过Node.js使用服务器端JavaScript，那么进行多任务处理有不同的方法。Node.js提供了分叉子进程的能力，并提供了一个与Web worker类似的接口来在子进程和父进程之间通信。不过这种方法会分叉整个进程，比使用轻量级线程更加消耗资源。
- en: Some other tools exist that create lighter-weight background workers in Node.js.
    These are probably a closer parallel to what exists on the web side than forking
    a child process.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中还存在一些其他工具，可以创建轻量级的后台工作进程。这些可能更接近于Web端存在的情况，而不是分叉子进程。
- en: Circuit breaker pattern
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器模式
- en: Systems, even the best designed systems, fail. The larger and more distributed
    a system, the higher the probability of failure. Many large systems such as Netflix
    or Google have extensive built-in redundancies. The redundancies don't decrease
    the chance of a failure of a component but they do provide a backup. Switching
    to the backup is frequently transparent to the end user.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 系统，即使是设计最好的系统，也会失败。系统越大、分布越广，失败的可能性就越高。许多大型系统，如Netflix或Google，都内置了大量冗余。冗余并不会减少组件失败的可能性，但它们提供了备用方案。切换到备用方案通常对最终用户是透明的。
- en: The circuit breaker pattern is a common component of a system that provides
    this sort of redundancy. Let's say that your application queries an external data
    source every five seconds, perhaps you're polling for some data that you're expecting
    to change. What happens when this polling fails? In many cases the failure is
    simply ignored and the polling continues. This is actually a pretty good behaviour
    on the client side as data updates are not always crucial. In some cases, a failure
    will cause the application to retry the request immediately. Retrying server requests
    in a tight loop can be problematic for both the client and the server. The client
    may become unresponsive as it spends more time in a loop requesting data.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式是提供这种冗余的系统的常见组件。假设您的应用程序每五秒查询一次外部数据源，也许您正在轮询一些预计会发生变化的数据。当此轮询失败时会发生什么？在许多情况下，失败被简单地忽略，轮询继续进行。这实际上是客户端端的一个相当好的行为，因为数据更新并不总是至关重要。在某些情况下，失败会导致应用程序立即重试请求。在紧密的循环中重试服务器请求对客户端和服务器都可能有问题。客户端可能因为在循环中请求数据而变得无响应。
- en: On the server side, a system that is attempting to recover from a failure is
    being slammed every five seconds by what could be thousands of clients. If the
    failure is due to the system being overloaded, then continuing to query it will
    only make matters worse.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，一个试图从失败中恢复的系统每五秒钟就会受到可能是成千上万的客户端的冲击。如果失败是由系统过载造成的，那么继续查询它只会使情况变得更糟。
- en: 'The circuit breaker pattern stops attempting to communicate with a system that
    is failing once a certain number of failures have been reached. Basically, repeated
    failures result in the circuit being broken and the application ceasing to query.
    You can see the general pattern of a circuit breaker in this illustration:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式在达到一定数量的失败后停止尝试与正在失败的系统通信。基本上，重复的失败导致断路器被打开，应用程序停止查询。您可以在这个插图中看到断路器的一般模式：
- en: '![Circuit breaker pattern](Image00046.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![断路器模式](Image00046.jpg)'
- en: For the server, having the number of clients drop off as failures pile up allows
    for some breathing room to recover. The chances of a storm of requests coming
    in and keeping the system down is minimized.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器来说，随着失败的积累，客户端数量的减少为其提供了一些喘息的空间来恢复。请求风暴进来并使系统崩溃的可能性被最小化。
- en: Of course we would like the circuit breaker to reset at some point so that service
    can be restored. The two approaches for this are that, either the client polls
    periodically (less frequently than before) and resets the breaker, or that the
    external system communicates back to its clients that service has been restored.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们希望断路器在某个时候重置，以便恢复服务。对此有两种方法，一种是客户端定期轮询（比以前频率低）并重置断路器，另一种是外部系统向其客户端通信服务已恢复。
- en: Back-off
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退避
- en: A variation on the circuit breaker pattern is to use some form of back-off instead
    of cutting out communication to the server completely. This is an approach that
    is suggested by many database vendors and cloud providers. If our original polling
    was at five second intervals, then when a failure is detected change the interval
    to every 10 seconds. Repeat this process using longer and longer intervals.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式的一个变种是使用某种形式的退避，而不是完全切断与服务器的通信。这是许多数据库供应商和云提供商建议的一种方法。如果我们最初的轮询间隔为五秒，那么当检测到失败时，将间隔更改为每10秒一次。重复这个过程，使用越来越长的间隔。
- en: When requests start to work again then the pattern of changing the time interval
    is reversed. Requests are sent closer and closer together until the original polling
    interval is resumed.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求重新开始工作时，更改时间间隔的模式将被颠倒。请求会越来越接近，直到恢复原始的轮询间隔。
- en: Monitoring the status of the external resource availability is a perfect place
    to use background worker roles. The work is not complex but it is totally detached
    from the main event loop.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 监视外部资源可用性的状态是使用后台工作角色的理想场所。这项工作并不复杂，但它完全与主事件循环无关。
- en: Again this reduces the load on the external resource giving it more breathing
    room. It also keeps the clients unburdened by too much polling.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次减少了对外部资源的负载，为其提供了更多的喘息空间。它还使客户端不会因过多的轮询而负担过重。
- en: 'An example using jQuery''s `ajax` function looks like the following:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery的`ajax`函数的示例如下：
- en: '[PRE84]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: You can see that the highlighted section retries the query.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，突出显示的部分重新尝试查询。
- en: This style of back-off is actually used in Ethernet to avoid repeated packet
    collisions.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这种退避方式实际上在以太网中用于避免重复的数据包碰撞。
- en: Degraded application behavior
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降级的应用程序行为
- en: There is likely a very good reason that your application is calling out to external
    resources. Backing off and not querying the data source is perfectly reasonable
    but it is still desirable that users have some ability to interact with the site.
    One solution to this problem is to degrade the behavior of the application.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序呼叫外部资源很可能有很好的理由。退避并不查询数据源是完全合理的，但仍然希望用户能够与网站进行交互。解决这个问题的一个方法是降低应用程序的行为。
- en: For instance, if your application shows real-time stock quote information, but
    the system for delivering stock information is broken, then a less than real time
    service could be swapped in. Modern browsers have a whole raft of different technologies
    that allow for storing small quantities of data on the client computer. This storage
    space is ideal for caching old versions of some data should the latest versions
    be unavailable.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您的应用程序显示实时股票报价信息，但提供股票信息的系统出现故障，那么可以替换为一个不太实时的服务。现代浏览器有许多不同的技术，允许在客户端计算机上存储少量数据。这个存储空间非常适合缓存一些旧版本的数据，以防最新版本不可用。
- en: Even in cases where the application is sending data to the server, it is possible
    to degrade behaviour. Saving the data updates locally and then sending them altogether
    when the service is restored is generally acceptable. Of course, once a user leaves
    a page, then any background works will terminate. If the user never again returns
    to the site, then whatever updates they had queued to send to the server will
    be lost.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在应用程序向服务器发送数据的情况下，也可以降级行为。通常可以在本地保存数据更新，然后在服务恢复时一起发送它们。当用户离开页面时，任何后台工作都将终止。如果用户再也不返回网站，那么他们排队发送到服务器的任何更新都将丢失。
- en: Note
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A word of warning: if this is an approach you take it might be best to warn
    users that their data is old, especially if your application is a stock trading
    application.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 一个警告：如果您采取这种方法，最好警告用户他们的数据已经过时，特别是如果您的应用程序是股票交易应用程序。
- en: Promise pattern
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺模式
- en: I said earlier that JavaScript is single threaded. This is not entirely accurate.
    There is a single event loop in JavaScript. Blocking this event loop with a long
    running process is considered to be bad form. Nothing else can happen while your
    greedy algorithm is taking up all the CPU cycles.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过JavaScript是单线程的。这并不完全准确。JavaScript中有一个单一的事件循环。用长时间运行的进程阻塞这个事件循环被认为是不好的形式。当您的贪婪算法占用所有CPU周期时，其他事情就无法发生了。
- en: 'When you launch an asynchronous function in JavaScript, such as fetching data
    from a remote server, then much of this activity happens in a different thread.
    The success or failure handler functions are executed in the main event thread.
    This is part of the reason that success handlers are written as functions: it
    allows them to be easily passed back and forth between contexts.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在JavaScript中启动异步函数，比如从远程服务器获取数据时，很多活动都发生在不同的线程中。成功或失败处理程序函数在主事件线程中执行。这也是成功处理程序被编写为函数的部分原因：它允许它们在不同的上下文之间轻松传递。
- en: Thus there are activities which truly do happen in an asynchronous, parallel
    fashion. When the `async` method has completed then the result is passed into
    the handler we provided and the handler is put into the event queue to be picked
    up next time the event loop repeats. Typically, the event loop runs many hundreds
    or thousands of times a second, depending on how much work there is to do on each
    iteration.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，确实有一些活动是以异步、并行的方式发生的。当`async`方法完成后，结果将传递给我们提供的处理程序，并且处理程序将被放入事件队列中，在事件循环重复时下次被接收。通常，事件循环每秒运行数百次或数千次，具体取决于每次迭代需要做多少工作。
- en: 'Syntactically, we write the message handlers as functions and hook them up:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上讲，我们将消息处理程序编写为函数并将其挂钩：
- en: '[PRE85]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This is reasonable if the situation is simple. However, if you would like to
    perform some additional asynchronous actions with the results of the callback
    then you end up with nested callbacks. If you need to add error handling that
    too is done using callbacks. The complexity of waiting for multiple callbacks
    to return and orchestrating your response rises quickly.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果情况简单，这是合理的。然而，如果您想要对回调的结果执行一些额外的异步操作，那么您最终会得到嵌套的回调。如果需要添加错误处理，也是使用回调来完成。等待多个回调返回并协调您的响应的复杂性会迅速上升。
- en: 'The promise pattern provides some syntactic help to clean up the asynchronous
    difficulties. If we take a common asynchronous operation such as retrieving data
    over XMLHttp Request using jQuery, then the code takes both an error and a success
    function. It might look something like the following:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺模式提供了一些语法帮助来清理异步困难。如果我们采取一个常见的异步操作，比如使用jQuery通过XMLHttp请求检索数据，那么代码会同时接受错误和成功函数。它可能看起来像下面这样：
- en: '[PRE86]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Using a promise instead would transform the code to look more like the following:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺而不是会使代码看起来更像下面这样：
- en: '[PRE87]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In this case the `$.ajax` method returns a promise object that contains a value
    and a state. The value is populated when the async call completes. The status
    provides some information about the current state of the request: has it completed,
    was it successful?'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`$.ajax`方法返回一个包含值和状态的承诺对象。当异步调用完成时，该值将被填充。状态提供了有关请求当前状态的一些信息：它是否已完成，是否成功？
- en: The promise also has a number of functions called on it. The `then()` function
    takes a success and an error function and it returns an additional promise. Should
    the success function run synchronously, then the promise returns as already fulfilled.
    Otherwise it remains in a working state, known as pending, until the asynchronous
    success has fired.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺还有许多在其上调用的函数。`then()`函数接受一个成功和一个错误函数，并返回一个额外的承诺。如果成功函数同步运行，那么承诺会立即返回为已实现。否则，它将保持在一个工作状态中，即待定状态，直到异步成功触发为止。
- en: 'In my mind, the method in which jQuery implements promises is not ideal. Their
    error handing doesn''t properly distinguish between a promise that has failed
    to be fulfilled and a promise that has failed but has been handled. This renders
    jQuery promises incompatible with the general idea of promises. For instance,
    it is not possible to do the following:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，jQuery实现承诺的方法并不理想。他们的错误处理没有正确区分承诺未能实现和已失败但已处理的承诺。这使得jQuery的承诺与承诺的一般概念不兼容。例如，无法执行以下操作：
- en: '[PRE88]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Even though the error has been handed and a new promise returned, processing
    will discontinue. It would be much better if the function could be written as
    the following:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管错误已经被处理并返回了一个新的承诺，但处理将会终止。如果函数能够被写成以下形式将会更好：
- en: '[PRE89]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: There has been much discussion about the implementation of promises in jQuery
    and other libraries. As a result of this discussion the current proposed promise
    specification is different from jQuery's promises and is incompatible. Promises/A+
    are the certification that is met by numerous promise libraries such as `when.js`
    and Q. It also forms the foundation of the promises specification that came with
    ECMAScript-2015.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在jQuery和其他库中实现承诺的讨论很多。由于这些讨论，当前提出的承诺规范与jQuery的承诺规范不同，并且不兼容。Promises/A+是许多承诺库（如`when.js`和Q）满足的认证。它也构成了ECMAScript-2015所带来的承诺规范的基础。
- en: Promises provide a bridge between synchronous and asynchronous functions, in
    effect turning the asynchronous functions into something that can be manipulated
    as if it were synchronous.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺为同步和异步函数之间提供了桥梁，实际上将异步函数转换为可以像同步函数一样操作的东西。
- en: 'If promise sounds a lot like the lazy evaluation pattern we saw some chapters
    ago then you''re exactly correct. Promises are constructed using lazy evaluation,
    the actions called on them are queued inside the object rather than being evaluated
    at once. This is a wonderful application of a functional pattern and even enables
    scenarios like the following:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如果承诺听起来很像我们在前几章看到的惰性评估模式，那么你完全正确。承诺是使用惰性评估构建的，对它们调用的操作被排队在对象内部，而不是立即评估。这是函数模式的一个很好的应用，甚至可以实现以下场景：
- en: '[PRE90]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Promises greatly simplify asynchronous programming in JavaScript and should
    certainly be considered for any project that is heavily asynchronous in nature.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺极大地简化了JavaScript中的异步编程，并且应该被考虑用于任何在性质上是高度异步的项目中。
- en: Hints and tips
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: ECMAScript 2015 promises are well supported on most browsers. Should you need
    to support an older browser then there are some great shims out there that can
    add the functionality with a minimum of overhead.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 2015的承诺在大多数浏览器上得到了很好的支持。如果需要支持旧版浏览器，那么有一些很棒的shim可以添加功能而不会增加太多开销。
- en: When examining the performance of retrieving JavaScript from a remote server,
    there are tools provided in most modern browsers for viewing a timeline of resource
    loading. This timeline will show when the browser is waiting for scripts to be
    downloaded and when it is parsing the scripts. Using this timeline allows for
    experimenting to find the best way to load a script or series of scripts.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查从远程服务器检索JavaScript的性能时，大多数现代浏览器都提供了工具来查看资源加载的时间轴。这个时间轴将显示浏览器何时在等待脚本下载，以及何时在解析脚本。使用这个时间轴可以进行实验，找到加载脚本或一系列脚本的最佳方式。
- en: Summary
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we've looked at a number of patterns or approaches that improve
    the experience of developing JavaScript. We looked at a number of concerns around
    delivery to the browser. We also looked at how to implement plugins against a
    couple of libraries and extrapolated general practices. Next we took a look at
    how to work with background processes in JavaScript. Circuit breakers were suggested
    as a method of keeping remote resource-fetching sane. Finally, we examined how
    promises can improve the writing of asynchronous code.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一些改进JavaScript开发体验的模式或方法。我们关注了一些关于传递到浏览器的问题。我们还看了如何针对一些库实现插件并推断出一般的实践。接下来，我们看了如何在JavaScript中处理后台进程。断路器被建议作为保持远程资源获取的方法。最后，我们研究了承诺如何改进异步代码的编写。
- en: In the next chapter we'll spend quite a bit more time looking at messaging patterns.
    We saw a little about messing with web workers but we'll expand quite heavily
    on them in the next section.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将花费更多的时间来研究消息模式。我们已经稍微了解了如何使用web worker，但在下一节中我们将大量扩展。
- en: Chapter 10. Messaging Patterns
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。消息模式
- en: When Smalltalk, the first real object oriented programming language, was first
    developed, the communication between classes was envisioned as being messages.
    Somehow we've moved away from this pure idea of messages. We spoke a bit about
    how functional programming avoids side effects, well, much the same is true of
    messaging-based systems.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 当Smalltalk，第一个真正的面向对象的编程语言，首次开发时，类之间的通信被设想为消息。不知何故，我们已经偏离了这个纯粹的消息理念。我们稍微谈到了函数式编程如何避免副作用，同样，基于消息的系统也是如此。
- en: Messaging also allows for impressive scalability as messages can be fanned out
    to dozens, or even hundreds, of computers. Within a single application, messaging
    promotes low-coupling and eases testing.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 消息还可以实现令人印象深刻的可伸缩性，因为消息可以传播到数十甚至数百台计算机。在单个应用程序中，消息传递促进了低耦合和测试的便利性。
- en: In this chapter we're going to look at a number of patterns related to messaging.
    By the end of the chapter you should be aware of how messages work. When I first
    learned about messaging I wanted to rewrite everything using it.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一些与消息相关的模式。在本章结束时，您应该知道消息是如何工作的。当我第一次了解消息时，我想用它重写一切。
- en: 'We will be covering the following topics:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: What's a message anyway?
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息到底是什么？
- en: Commands
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Events
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Request-reply
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求-回复
- en: Publish-subscribe
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布-订阅
- en: Fan out
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扇出
- en: Dead letter queues
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死信队列
- en: Message replay
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息重播
- en: Pipes and filters
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道和过滤器
- en: What's a message anyway?
  id: totrans-528
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息到底是什么？
- en: 'In the simplest definition a message is a collection of related bits of data
    that have some meaning together. The message is named in a way that provides some
    additional meaning to it. For instance, both an `AddUser` and a `RenameUser` message
    might have the following fields:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的定义中，消息是一组相关的数据位，它们一起具有一定的含义。消息的命名方式提供了一些额外的含义。例如，`AddUser`和`RenameUser`消息可能具有以下字段：
- en: User ID
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户ID
- en: Username
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名
- en: But the fact that the fields exist inside a named container gives them different
    meaning.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这些字段存在于命名容器内的事实赋予了它们不同的含义。
- en: Messages are usually related to some action in the application or some action
    in the business. A message contains all the information needed for a receiver
    to act upon the action. In the case of the `RenameUser` message, the message contains
    enough information for any component that keeps track of a relationship between
    a user ID and a username to update its value for username.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 消息通常与应用程序中的某个操作或业务中的某个操作相关。消息包含接收者执行操作所需的所有信息。在`RenameUser`消息的情况下，消息包含足够的信息，以便任何跟踪用户ID和用户名之间关系的组件更新其用户名值。
- en: 'Many messaging systems, especially those that communicate between application
    boundaries, also define an **envelope** . The envelope has metadata on it that
    could help with message auditing, routing, and security. The information on the
    envelope is not part of the business process but is part of the infrastructure.
    So having a security annotation on the envelope is fine, as security exists outside
    of the normal business workflow and is owned by a different part of the application.
    The contents on the envelope look like the one shown in the following diagram:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 许多消息系统，特别是在应用程序边界之间通信的系统，还定义了**信封**。信封上有元数据，可以帮助消息审计、路由和安全性。信封上的信息不是业务流程的一部分，而是基础设施的一部分。因此，在信封上有安全注释是可以的，因为安全性存在于正常业务工作流程之外，并由应用程序的不同部分拥有。信封上的内容看起来像下图所示的内容：
- en: '![What''s a message anyway?](Image00047.jpg)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![消息到底是什么？](Image00047.jpg)'
- en: Messages should be sealed so that no changes can be made to them once they have
    been created. This makes certain operations like auditing and replaying much easier.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 消息应该被封闭，以便在创建后不能对其进行更改。这使得诸如审计和重播等操作更加容易。
- en: Messaging can be used to communicate inside a single process or it can be used
    between applications. For the most part there is no difference to sending a message
    within an application and between applications. One difference is the treatment
    of synchronicity. Within a single process, messages can be handled in a synchronous
    fashion. This means that the main processing effectively waits for the handling
    of the message to complete before continuing.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 消息可以用于在单个进程内进行通信，也可以用于应用程序之间进行通信。在大多数情况下，在应用程序内部发送消息和应用程序之间发送消息没有区别。一个区别是同步处理的处理。在单个进程内，消息可以以同步方式处理。这意味着主要处理在继续之前会等待消息的处理完成。
- en: In an asynchronous scenario, the handling of the message may occur at a later
    date. Sometimes the later date is far in the future. When calling out to an external
    server, asynchronous will certainly be the correct approach – this is due to the
    inherit latency associated with network I/O. Even within a single process, the
    single threaded nature of JavaScript encourages using asynchronous messaging.
    While using asynchronous messaging, some additional care and attention needs to
    be taken as some of the assumptions made for synchronous messaging cease to be
    safe. For instance, assuming the messages will be replied to in the same order
    in which they were sent is no longer safe.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步场景中，消息的处理可能会在以后的某个时间发生。有时，这个时间可能是遥远的未来。当调用外部服务器时，异步肯定是正确的方法——这是由于与网络I/O相关的固有延迟。即使在单个进程内，JavaScript的单线程特性也鼓励使用异步消息传递。在使用异步消息传递时，需要额外的注意和关注，因为一些针对同步消息传递所做的假设不再安全。例如，假设消息将按照发送顺序进行回复不再安全。
- en: 'There are two different flavors of messages: commands and events. Commands
    instruct things to happen while events notify about something which has happened.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 消息有两种不同的类型：命令和事件。命令指示发生的事情，而事件通知发生的事情。
- en: Commands
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令
- en: A command is simply an instruction from one part of a system to another. It
    is a message so it is really just a simple data transfer object. If you think
    back to the command pattern introduced in [Chapter 5](text00044.html#page "Chapter 5. Behavioral
    Patterns") , *Behavioral Patterns* , this is exactly what it uses.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 命令只是系统的一部分向另一部分发出的指令。这是一条消息，因此实际上只是一个简单的数据传输对象。如果回想一下在[第5章](text00044.html#page
    "第5章。行为模式")中介绍的命令模式，*行为模式*，这正是它所使用的。
- en: As a matter of convention, commands are named using the imperative. The format
    is usually `<verb><object>` . Thus a command might be called `InvadeCity` . Typically,
    when naming a command, you want to avoid generic names and focus on exactly what
    is causing the command.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 作为惯例，命令使用命令式命名。格式通常是`<动词><对象>`。因此，一个命令可能被称为`InvadeCity`。通常，在命名命令时，您希望避免使用通用名称，而是专注于导致命令的确切原因。
- en: As an example, consider a command that changes the address of a user. You might
    be tempted to simply call the command `ChangeAddress` but doing so does not add
    any additional information. It would be better to dig deeper and see why the address
    is being changed. Did the person move or was the original address entered incorrectly?
    Intent is as important as the actual data changes. For instance, altering an address
    due to a mistake might trigger a different behavior from a person who has moved.
    Users that have moved could be sent a moving present, while those correcting their
    address would not.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个更改用户地址的命令。您可能会简单地称该命令为`ChangeAddress`，但这样做并没有添加任何额外的信息。更好的做法是深入挖掘并查看为什么要更改地址。是因为人搬家了，还是原始地址输入错误了？意图与实际数据更改一样重要。例如，由于错误而更改地址可能会触发与搬家的人不同的行为。搬家的用户可以收到搬家礼物，而更正地址的用户则不会。
- en: Messages should have a component of business meaning to increase their utility.
    Defining messages and how they can be constructed within a complex business is
    a whole field of study on its own. Those interested might do well to investigate
    **domain driven** **design** ( **DDD** ).
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 消息应该具有业务含义的组件，以增加它们的效用。在复杂业务中定义消息以及它们如何构造是一个独立的研究领域。有兴趣的人可能会对**领域驱动设计**（**DDD**）感兴趣。
- en: Commands are an instruction targeted at one specific component giving it instructions
    to perform a task.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是针对特定组件的指令，用于给其下达执行任务的指示。
- en: Within the context of a browser you might consider that a command would be the
    click that is fired on a button. The command is transformed into an event and
    that event is what is passed to your event listeners.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器的上下文中，你可以认为命令是在按钮上触发的点击。命令被转换为事件，而事件则传递给你的事件监听器。
- en: Only one end point should receive a specific command. This means that only one
    component is responsible for an action taking place. As soon as a command is acted
    upon by more than one end point any number of race conditions are introduced.
    What if one of the end points accepts the command and another rejects it as invalid?
    Even in cases where several near identical commands are issued they should not
    be aggregated. For instance, sending a command from a king to all his generals
    should send one command to each general.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个端点应该接收特定的命令。这意味着只有一个组件负责执行动作。一旦一个命令被多个端点执行，就会引入任意数量的竞争条件。如果其中一个端点接受了命令，而另一个将其拒绝为无效呢？即使在发出了几个几乎相同的命令的情况下，它们也不应该被聚合。例如，从国王发送一个命令给他的所有将军应该给每个将军发送一个命令。
- en: Because there is only one end point for a command it is possible for that end
    point to validate and even cancel the command. The cancellation of the command
    should have no impact on the rest of the application.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 因为只有一个端点可以接收命令，所以该端点有可能验证甚至取消命令。命令的取消不应对应用程序的其余部分产生影响。
- en: When a command is acted upon, then one or more events may be published.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行了一个命令，就可能发布一个或多个事件。
- en: Events
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: An event is a special message that notifies that something has happened. There
    is no use in trying to change or cancel an event because it is simply a notification
    that something has happened. You cannot change the past unless you own a Delorian.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是一种特殊的消息，用于通知发生了某事。试图更改或取消事件是没有意义的，因为它只是通知发生了某事。除非你拥有一辆德洛雷安，否则你无法改变过去。
- en: The naming convention for events is that they are written in the past tense.
    You might see a reversal of the ordering of the words in the command, so we could
    end up with `CityInvaded` once the `InvadeCity` command has succeeded.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的命名约定是使用过去时。你可能会看到命令中单词顺序的颠倒，因此一旦`InvadeCity`命令成功，我们可能会得到`CityInvaded`。
- en: Unlike commands, events may be received by any number of components. There are
    not real race conditions presented by this approach. As no message handler can
    change the message nor interfere with the delivery of other copies of the message,
    each handler is siloed away from all others.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令不同，事件可以被任意数量的组件接收。这种方法不会产生真正的竞争条件。由于没有消息处理程序可以更改消息或干扰其他副本消息的传递，每个处理程序都与其他处理程序隔离开来。
- en: 'You may be familiar with events from having done user interface work. When
    a user clicks a button then an event is "raised". In effect the event is broadcast
    to a series of listeners. You subscribe to a message by hooking into that event:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对事件有所了解，因为你做过用户界面工作。当用户点击按钮时，事件就会“触发”。实际上，事件会广播给一系列监听器。你可以通过连接到该事件来订阅消息：
- en: '[PRE91]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The events in browsers don't quite meet the definition of an event I gave in
    the preceding paragraph. This is because event handlers in the browser can cancel
    events and stop them from propagating to the next handler. That is to say, when
    there are a series of event handlers for the same message one of them can completely
    consume the message and not pass it on to subsequent handlers. There is certainly
    utility to an approach like this but it does introduce some confusion. Fortunately
    for UI messages, the number of handlers is typically quite small.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的事件并不完全符合我在前面段落中给出的事件定义。这是因为浏览器中的事件处理程序可以取消事件并阻止其传播到下一个处理程序。也就是说，当同一消息有一系列事件处理程序时，其中一个可以完全消耗该消息，不将其传递给后续处理程序。这样的方法当然有其用处，但也会引入一些混乱。幸运的是，对于UI消息，处理程序的数量通常相当少。
- en: 'In some systems, events can be polymorphic in nature. That is to say that if
    I had an event called `IsHiredSalary` that is fired when somebody is hired in
    a salaried role, I could make it a descendant of the message `IsHired` . Doing
    so would allow for both handlers subscribed to `IsHiredSalary` and `IsHired` to
    be fired upon receipt of an `IsHiredSalary` event. JavaScript doesn''t have polymorphism
    in the true sense, so such things aren''t particularly useful. You can add a message
    field that takes the place of polymorphism but it looks somewhat messy:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统中，事件可能具有多态性质。也就是说，如果我有一个名为`IsHiredSalary`的事件，当有人被聘用为有薪角色时会触发该事件，我可以将其作为消息`IsHired`的后代。这样做可以让订阅了`IsHiredSalary`和`IsHired`的处理程序在接收到`IsHiredSalary`事件时都被触发。JavaScript并没有真正意义上的多态性，因此这样的东西并不特别有用。你可以添加一个消息字段来代替多态性，但看起来有些混乱：
- en: '[PRE92]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In this case I've used `__` to denote fields that are part of the envelope.
    You could also construct the message with separate fields for message and envelope,
    it really doesn't matter all that much.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我使用`__`来表示信封中的字段。你也可以构建具有消息和信封的单独字段的消息，这并不那么重要。
- en: 'Let''s take a look at a simple operation like creating a user so we can see
    how commands and events interact:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的操作，比如创建用户，以便我们可以看到命令和事件是如何交互的：
- en: '![Events](Image00048.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: '![事件](Image00048.jpg)'
- en: Here a user enters data into a form and submits it. The web server takes in
    the input, validates it and, if it is correct, creates a command. The command
    is now sent to the command handler. The command handler performs some action,
    perhaps writes to a database, it then publishes an event that is consumed by a
    number of event listeners. These event listeners might send confirmation e-mails,
    notify system administrators, or any number of things.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，用户输入数据到表单并提交。Web服务器接收输入，验证它，如果正确，创建一个命令。现在命令被发送到命令处理程序。命令处理程序执行一些操作，也许写入数据库，然后发布一个事件，被多个事件监听器消费。这些事件监听器可能发送确认电子邮件，通知系统管理员，或者执行任何数量的操作。
- en: All of this looks familiar because systems already contain commands and events.
    The difference is that we are now modeling the commands and events explicitly.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些看起来很熟悉，因为系统已经包含了命令和事件。不同之处在于，我们现在明确地对命令和事件进行建模。
- en: Request-reply
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求-响应
- en: The simplest pattern you'll see with messaging is the request-reply pattern.
    Also known as request-response, this is a method of retrieving data that is owned
    by another part of the application.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在消息传递中看到的最简单的模式是请求-响应模式。也称为请求-响应，这是一种检索由应用程序的另一部分拥有的数据的方法。
- en: 'In many cases the sending of a command is an asynchronous operation. A command
    is fired and the application flow continues on. Because of this, there is no easy
    way to do things like lookup a record by ID. Instead one needs to send a command
    to retrieve a record and then wait for the associated event to be returned. A
    normal workflow looks like the following diagram:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，发送命令是一个异步操作。命令被触发后，应用程序流程会继续进行。因此，没有简单的方法来执行诸如按ID查找记录之类的操作。相反，需要发送一个命令来检索记录，然后等待相关事件的返回。正常的工作流程如下图所示：
- en: '![Request-reply](Image00049.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_IMG
  zh: '![请求-响应](Image00049.jpg)'
- en: Most events can be subscribed to by any number listeners. While it is possible
    to have multiple event listeners for a request-response pattern, it is unlikely
    and is probably not advisable.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数事件可以被任意数量的监听器订阅。虽然可能对请求-响应模式有多个事件监听器，但这不太可能，也可能不可取。
- en: We can implement a very simple request-response pattern here. In Westeros there
    are some issues with sending messages in a timely fashion. Without electricity,
    sending messages over long distances rapidly can really only be accomplished by
    attaching tiny messages to the legs of crows. Thus we have a Crow Messaging System.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里实现一个非常简单的请求-响应模式。在维斯特洛，发送及时消息存在一些问题。没有电力，通过乌鸦的腿传递消息是唯一可以快速实现的远距离传递消息的方法。因此我们有了一个乌鸦消息系统。
- en: 'We''ll start with building out what we''ll call the **bus** . A bus is simply
    a distribution mechanism for messages. It can be implemented in process, as we''ve
    done here, or out of process. If implementing it out of process, there are many
    options from 0mq, a lightweight message queue, to RabbitMQ, a more fully featured
    messaging system, to a wide variety of systems built on top of databases and in
    the cloud. Each of these systems exhibit some different behaviors when it comes
    to message reliability and durability. It is important to do some research into
    the way that the message distribution systems work as they may dictate how the
    application is constructed. They also implement different approaches to dealing
    with the underlying unreliability of applications:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从构建我们称之为**总线**开始。总线只是消息的分发机制。它可以在进程中实现，就像我们在这里做的一样，也可以在进程外实现。如果在进程外实现，有许多选项，从轻量级消息队列0mq，到更全面的消息系统RabbitMQ，再到建立在数据库和云端的各种系统。这些系统在消息的可靠性和持久性方面表现出一些不同的行为。重要的是要对消息分发系统的工作方式进行一些研究，因为它们可能决定应用程序的构建方式。它们还实现了不同的方法来处理应用程序的基本不可靠性：
- en: '[PRE93]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: One thing which is a potential trip-up is that the order in which messages are
    received back on the client is not necessarily the order in which they were sent.
    To deal with this it is typical to include some sort of a correlation ID. When
    the event is raised it includes a known ID from the sender so that the correct
    event handler is used.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 一个潜在的问题是客户端接收消息的顺序不一定是发送消息的顺序。为了解决这个问题，通常会包含某种相关ID。当事件被触发时，它会包含来自发送方的已知ID，以便使用正确的事件处理程序。
- en: This bus is a highly naïve one as it has its routing hard coded. A real bus
    would probably allow the sender to specify the address of the end point for delivery.
    Alternately, the receivers could register themselves as interested in a specific
    sort of message. The bus would then be responsible for doing some limited routing
    to direct the message. Our bus is even named after the messages it deals with
    – certainly not a scalable approach.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这个总线是一个非常天真的总线，因为它的路由是硬编码的。一个真正的总线可能允许发送者指定交付的终点地址。或者，接收者可以注册自己对特定类型的消息感兴趣。然后总线将负责进行一些有限的路由来指导消息。我们的总线甚至以它处理的消息命名
    - 这显然不是一种可扩展的方法。
- en: 'Next we''ll implement the requestor. The requestor contains only two methods:
    one to send a request and the other to receive a response from the bus:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将实现请求者。请求者只包含两种方法：一个用于发送请求，另一个用于从总线接收响应：
- en: '[PRE94]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The process message function currently just logs the response but it would likely
    do more in a real world scenario such as updating the UI or dispatching another
    message. The correlation ID is invaluable for understanding which sent message
    the reply is related to.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 处理消息函数目前只是记录响应，但在实际情况下可能会执行更多操作，比如更新UI或分派另一个消息。相关ID对于理解回复与发送消息的关联非常宝贵。
- en: 'Finally, the responder simply takes in the message and replies to it with another
    message:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，响应者只是接收消息并用另一条消息回复。
- en: '[PRE95]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Everything in our example is synchronous but all it would take to make it asynchronous
    is to swap out the bus. If we''re working in node then we can do this using `process.nextTick`
    which simply defers a function to the next time through the event loop. If we''re
    in a web context, then web workers may be used to do the processing in another
    thread. In fact, when starting a web worker, the communication back and forth
    to it takes the form of a message:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中的一切都是同步的，但要使其异步化只需要更换总线。如果我们在node中工作，可以使用`process.nextTick`来实现这一点，它只是将一个函数推迟到事件循环的下一次。如果我们在web上下文中，那么可以使用web
    workers在另一个线程中进行处理。实际上，启动web worker时，与其来回通信采用消息的形式：
- en: '[PRE96]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This approach now allows other code to run before the message is processed.
    If we weave in some print statements after each bus send, then we get output like
    the following:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法现在允许其他代码在消息被处理之前运行。如果我们在每次总线发送后编织一些打印语句，那么我们会得到以下输出：
- en: '[PRE97]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: You can see that the print statements are executed before the message processing
    as that processing happens on the next iteration.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到打印语句在消息处理之前执行，因为该处理发生在下一次迭代中。
- en: Publish-subscribe
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布-订阅
- en: I've alluded to the publish-subscribe model elsewhere in this chapter. Publish-subscribe
    is a powerful tool for decoupling events from processing code.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其他地方，我已经提到了发布-订阅模型。发布-订阅是将事件与处理代码解耦的强大工具。
- en: At the crux of the pattern is the idea that, as a message publisher, my responsibility
    for the message should end as soon as I send it. I should not know who is listening
    to messages or what they will do with the messages. So long as I am fulfilling
    a contract to produce correctly formatted messages, the rest shouldn't matter.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的关键在于，作为消息发布者，我的责任应该在我发送消息后立即结束。我不应该知道谁在监听消息或他们将对消息做什么。只要我履行了生成正确格式的消息的合同，其他事情就不重要了。
- en: It is the responsibility of the listener to register its interest in the message
    type. You'll, of course, wish to register some sort of security to disallow registration
    of rogue services.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 监听者有责任注册对消息类型的兴趣。当然，您希望注册某种安全性来阻止注册恶意服务。
- en: 'We can update our service bus to do more, to do a complete job of routing and
    sending multiple messages. Let''s call our new method `Publish` instead of `Send`
    . We''ll keep `Send` around to do the sending functionality:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更新我们的服务总线来做更多事情，完成路由和发送多个消息的工作。让我们将新方法称为`Publish`而不是`Send`。我们将保留`Send`来执行发送功能：
- en: '![Publish-subscribe](Image00050.jpg)'
  id: totrans-589
  prefs: []
  type: TYPE_IMG
  zh: '![发布-订阅](Image00050.jpg)'
- en: The crow mail analogy we used in the previous section starts to fall apart here
    as there is no way to broadcast a message using crows. Crows are too small to
    carry large banners and it is very difficult to train them to do sky writing.
    I'm unwilling to totally abandon the idea of crows so let's assume that there
    exists a sort of crow broadcast centre. Sending a message here allows for it to
    be fanned out to numerous interested parties who have signed up for updates. This
    centre will be more or less synonymous with a bus.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中使用的乌鸦邮件类比在这里开始崩溃，因为没有办法使用乌鸦广播消息。乌鸦太小，无法携带大型横幅，而且很难训练它们进行天空书写。我不愿意完全放弃乌鸦的想法，所以让我们假设存在一种乌鸦广播中心。在这里发送消息允许将其传播给许多已注册更新的感兴趣的各方。这个中心将更多或更少地与总线同义。
- en: We'll write our router so that it works as a function of the name of the message.
    One could route a message using any of its attributes. For instance, a listener
    could subscribe to all the messages called `invoicePaid` where the `amount` field
    is greater than $10000\. Adding this sort of logic to the bus will slow it down
    and make it far harder to debug. Really this is more the domain of business process
    orchestration engines than a bus. We'll continue on without that complexity.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写我们的路由器，使其作为消息名称的函数。可以使用消息的任何属性来路由消息。例如，监听器可以订阅所有名为`invoicePaid`的消息，其中`amount`字段大于$10000。将这种逻辑添加到总线中会减慢它的速度，并且使调试变得更加困难。实际上，这更多地属于业务流程编排引擎的领域，而不是总线。我们将继续进行而不涉及这种复杂性。
- en: 'The first thing to set up is the ability to subscribe to published messages:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要设置的是订阅发布消息的能力：
- en: '[PRE98]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `Subscribe` function just adds a message handler and the name of a message
    to consume. The responders array is simply an array of handlers.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscribe`函数只是添加一个消息处理程序和要消费的消息的名称。响应者数组只是一个处理程序数组。'
- en: 'When a message is published we loop over the array and fire each of the handlers
    that have registered for messages with that name:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息发布时，我们遍历数组并触发已注册该名称消息的每个处理程序：
- en: '[PRE99]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The execution here is deferred to the next tick. This is done using a closure
    to ensure that the correctly scoped variables are passed through. We can now change
    our `CrowMailResponder` to use the new `Publish` method instead of `Send` :'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的执行被推迟到下一个tick。这是通过使用闭包来确保正确作用域的变量被传递的。现在我们可以改变我们的`CrowMailResponder`来使用新的`Publish`方法而不是`Send`：
- en: '[PRE100]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Instead of allowing the `CrowMailRequestor` object to create its own bus as
    earlier, we need to modify it to accept an instance of `bus` from outside. We
    simply assign it to a local variable in `CrowMailRequestor` . Similarly, `CrowMailResponder`
    should also take in an instance of `bus` .
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前允许`CrowMailRequestor`对象创建自己的总线不同，我们需要修改它以接受外部的`bus`实例。我们只需将其分配给`CrowMailRequestor`中的一个本地变量。同样，`CrowMailResponder`也应该接收`bus`的实例。
- en: 'In order to make use of this we simply need to create a new bus instance and
    pass it into the requestor:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这一点，我们只需要创建一个新的总线实例并将其传递给请求者：
- en: '[PRE101]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Here we''ve also passed in two other responders that are interested in knowing
    about `KingdomInvaded` messages. They look like the following:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还传递了另外两个对`KingdomInvaded`消息感兴趣的响应者。它们看起来像这样：
- en: '[PRE102]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Running this code will now get the following:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行这段代码将得到以下结果：
- en: '[PRE103]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: You can see that the messages are sent using `Send` . The responder or handler
    does its work and publishes a message that is passed onto each of the subscribers.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到消息是使用`Send`发送的。响应者或处理程序完成其工作并发布消息，该消息传递给每个订阅者。
- en: 'There are some great JavaScript libraries which make publish and subscribe
    even easier. One of my favorites is Radio.js. It has no external dependencies
    and its name is an excellent metaphor for publish subscribe. We could rewrite
    our preceding subscribe example like so:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些很棒的JavaScript库可以使发布和订阅变得更加容易。我最喜欢的之一是Radio.js。它没有外部依赖项，其名称是发布订阅的一个很好的比喻。我们可以像这样重写我们之前的订阅示例：
- en: '[PRE104]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then publish a message using the following:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下方法发布消息：
- en: '[PRE105]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Fan out and in
  id: totrans-611
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扇出和扇入
- en: A fantastic use of the publish subscribe pattern is allowing you to fan out
    a problem to a number of different nodes. Moore's law has always been about the
    doubling of the number of transistors per square unit of measure. If you've been
    paying attention to processor clock speeds you may have noticed that there hasn't
    really been any significant change in clock speeds for a decade. In fact, clock
    speeds are now lower than they were in 2005.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 发布订阅模式的一个很好的用途是让您将问题传播到许多不同的节点。摩尔定律一直是关于每平方单位的晶体管数量翻倍的。如果您一直关注处理器的时钟速度，您可能已经注意到在过去十年里时钟速度实际上没有发生任何显著变化。事实上，时钟速度现在比2005年还要低。
- en: This is not to say that processors are "slower" than they once were. The work
    that is performed in each clock tick has increased. The number of cores has also
    jumped up. It is now unusual to see a single core processor; even in cellular
    phones dual core processors are becoming common. It is the rule, rather than the
    exception, to have computers that are capable of doing more than one thing at
    a time.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说处理器比以前“慢”。每个时钟周期中执行的工作量已经增加。核心数量也有所增加。现在看到单核处理器已经不再是常态；即使在手机中，双核处理器也变得很常见。拥有能够同时执行多项任务的计算机已经成为规则，而不是例外。
- en: At the same time, cloud computing is taking off. The computers you purchase
    outright are faster than the ones available to rent from the cloud. The advantage
    of cloud computing is that you can scale it out easily. It is nothing to provision
    a hundred or even a thousand computers to form a cloud provider.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，云计算正在蓬勃发展。您直接购买的计算机比云中可租用的计算机更快。云计算的优势在于您可以轻松地扩展它。轻松地提供一百甚至一千台计算机来组成一个云提供商。
- en: 'Writing software that can take advantage of multiple cores is the great computing
    problem of our time. Dealing directly with threads is a recipe for disaster. Locking
    and contention is far too difficult a problem for most developers: me included!
    For a certain class of problems, they can easily be divided up into sub problems
    and distributed. Some call this class of problems "embarrassingly parallelizable".'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 编写能够利用多个核心的软件是我们这个时代的伟大计算问题。直接处理线程是灾难的开始。锁定和争用对于大多数开发人员来说都太困难了：包括我在内！对于某些类别的问题，它们可以很容易地分解为子问题并进行分布。有些人将这类问题称为“令人尴尬地可并行化”。
- en: 'Messaging provides a mechanism for communicating the inputs and outputs from
    a problem. If we had one of these easily parallelized problems, such as searching,
    then we would bundle up the inputs into one message. In this case it would contain
    our search terms. The message might also contain the set of documents to search.
    If we had 10,000 documents then we could divide the search space up into, say,
    four collections of 2500 documents. We would publish five messages with the search
    terms and the range of documents to search as can be seen here:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递提供了一个从问题中通信输入和输出的机制。如果我们有一个这样容易并行化的问题，比如搜索，那么我们将输入打包成一个消息。在这种情况下，它将包含我们的搜索词。消息还可能包含要搜索的文档集。如果我们有10,000个文档，那么我们可以将搜索空间分成四个包含2500个文档的集合。我们将发布五条消息，其中包含搜索词和要搜索的文档范围，如下所示：
- en: '![Fan out and in](Image00051.jpg)'
  id: totrans-617
  prefs: []
  type: TYPE_IMG
  zh: '![扇出和扇入](Image00051.jpg)'
- en: Different search nodes will pick up the messages and perform the search. The
    results will then be sent back to a node that will collect the messages and combine
    them into one. This is what will be returned to the client.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的搜索节点将接收消息并执行搜索。然后将结果发送回一个节点，该节点将收集消息并将它们合并成一个。这将返回给客户端。
- en: Of course this is a bit of an over simplification. It is likely that the receiving
    nodes themselves would maintain a list of documents over which they had responsibility.
    This would prevent the original publishing node from having to know anything about
    the documents over which it was searching. The search results could even be returned
    directly to the client that would do the assembling.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这有点过于简化了。接收节点本身可能会维护一个它们负责的文档列表。这将防止原始发布节点必须了解任何有关其搜索的文档。搜索结果甚至可以直接返回给执行组装的客户端。
- en: Even in a browser, the fan out and in approach can be used to distribute a calculation
    over a number of cores through the use of web workers. A simple example might
    take the form of creating a potion. A potion might contain a number of ingredients
    that can be combined to create a final product. It is quite computationally complicated
    combining ingredients so we would like to farm the process out to a number of
    workers.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在浏览器中，扇出和扇入方法也可以通过使用Web Workers将计算分布到多个核心上。一个简单的例子可能是创建一种药水。一种药水可能包含许多成分，可以组合成最终产品。组合成分是相当复杂的计算，因此我们希望将这个过程分配给多个工作者。
- en: 'We start with a combiner that contains a `combine()` method as well as a `complete()`
    function that is called once all the distributed ingredients are combined:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个包含`combine()`方法和一个`complete()`函数的合并器开始，一旦所有分布的成分都被合并，就会调用该函数：
- en: '[PRE106]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'In order to keep track of the number of workers outstanding, we use a simple
    counter. Because the main section of code is single threaded we have no risk of
    race conditions. Once the counter shows no remaining workers we can take whatever
    steps are necessary. The web worker looks like the following:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪未完成的工作人员数量，我们使用一个简单的计数器。由于主要的代码部分是单线程的，我们不会出现竞争条件的风险。一旦计数器显示没有剩余的工作人员，我们可以采取必要的步骤。Web工作者如下所示：
- en: '[PRE107]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: In this case we simply put in a timeout to simulate the complex calculation
    needed to combine ingredients.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需设置一个超时来模拟组合配料所需的复杂计算。
- en: The sub problems that are farmed out to a number of nodes don't have to be identical
    problems. However, they should be sufficiently complicated that the cost savings
    of farming them out are not consumed by the overhead of sending out a message.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给多个节点的子问题不必是相同的问题。但是，它们应该足够复杂，以至于将它们分配出去的成本节省不会被发送消息的开销所消耗。
- en: Dead letter queues
  id: totrans-627
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死信队列
- en: No matter how hard I try I have yet to write any significant block of code that
    does not contain any errors. Nor have I been very good at predicting the wide
    range of crazy things users do with my applications. Why would anybody click that
    link 73 times in a row? I'll never know.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我多努力，我都还没有写出任何不包含错误的重要代码块。我也没有很好地预测用户对我的应用程序做的各种疯狂的事情。为什么有人会连续点击那个链接73次？我永远不会知道。
- en: Dealing with failures in a messaging scenario is very easy. The core of the
    failure strategy is to embrace errors. We have exceptions for a reason and to
    spend all of our time trying to predict and catch exceptions is counter-productive.
    You'll invariably spend time building in catches for errors that never happen
    and miss errors that happen frequently.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息传递场景中处理故障非常容易。故障策略的核心是接受错误。我们有异常是有原因的，花费所有时间来预测和捕获异常是适得其反的。你不可避免地会花时间为从未发生的错误构建捕获，并错过频繁发生的错误。
- en: 'In an asynchronous system, errors need not be handled as soon as they occur.
    Instead, the message that caused an error can be put aside to be examined by an
    actual human later. The message is stored in a dead letter, or error, queue. From
    there the message can easily be reprocessed after it has been corrected or the
    handler has been corrected. Ideally the message handler is changed to deal with
    messages exhibiting whatever property caused the errors. This prevents future
    errors and is preferable to fixing whatever generates the message as there is
    no guarantee that other messages with the same problem aren''t lurking somewhere
    else in the system. The workflow of a message through the queue and error queue
    can be seen here:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步系统中，错误不需要在发生时立即处理。相反，导致错误的消息可以被放在一边，以便稍后由实际人员检查。消息存储在死信或错误队列中。从那里，消息在被纠正或处理程序被纠正后可以很容易地重新处理。理想情况下，消息处理程序被更改以处理表现出导致错误的任何属性的消息。这可以防止未来的错误，而且比修复生成消息的任何内容更可取，因为无法保证系统中其他具有相同问题的消息不会潜伏在其他地方。消息通过队列和错误队列的工作流程如下：
- en: '![Dead letter queues](Image00052.jpg)'
  id: totrans-631
  prefs: []
  type: TYPE_IMG
  zh: 死信队列
- en: As more and more errors are caught and fixed, the quality of the message handlers
    increases. Having an error queue of messages ensures that nothing important, such
    as a `BuySimonsBook` message is missed. This means that getting to a correct system
    becomes a marathon instead of a sprint. There is no need to rush a fix into production
    before it is properly tested. Progress towards a correct system is constant and
    reliable.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的错误被捕获和修复，消息处理程序的质量也在提高。拥有消息错误队列可以确保不会错过任何重要的东西，比如“购买西蒙的书”消息。这意味着达到正确系统的进展是一个马拉松，而不是短跑。在正确测试之前，没有必要急于将修复推向生产。朝着正确系统的进展是持续而可靠的。
- en: Using a dead letter queue also improves the catching of intermittent errors.
    These are errors that result from an external resource being unavailable or incorrect.
    Imagine a handler that calls out to an external web service. In a traditional
    system, a failure in the web service guarantees failure in the message handler.
    However, with a message based system, the command can be moved back to the end
    of the input queue and tried again whenever it reaches the front of the queue.
    On the envelope we write down the number of times the message has been dequeued
    (processed). Once this dequeue count reaches a limit, like five, only then is
    the message moved into the true error queue.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 使用死信队列还可以改善对间歇性错误的捕捉。这些错误是由外部资源不可用或不正确导致的。想象一下一个调用外部Web服务的处理程序。在传统系统中，Web服务的故障保证了消息处理程序的故障。然而，在基于消息的系统中，一旦命令到达队列的前端，就可以将其移回输入队列的末尾并在下次到达队列前端时再次尝试。在信封上，我们记录消息被出列（处理）的次数。一旦这个出列计数达到一个限制，比如五次，那么消息才会被移动到真正的错误队列中。
- en: This approach improves the overall quality of the system by smoothing over the
    small failures and stopping them from becoming large failures. In effect, the
    queues provide failure bulkheads to prevent small errors from overflowing and
    becoming large errors that might have an impact on the system as a whole.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过平滑处理小错误并阻止它们变成大错误来提高系统的整体质量。实际上，队列提供了故障隔离，防止小错误溢出并成为可能对整个系统产生影响的大错误。
- en: Message replay
  id: totrans-635
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息重播
- en: When developers are working with a set of messages that produce an error, the
    ability to reprocess messages is also useful. Developers can take a snapshot of
    the dead letter queue and reprocess it in debug mode again and again until they
    have correctly processed the messages. A snapshot of a message can also make up
    a part of the testing for a message handler.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员处理产生错误的一组消息时，重新处理消息的能力也很有用。开发人员可以对死信队列进行快照，并在调试模式下反复处理，直到正确处理消息。消息的快照也可以成为消息处理程序的一部分测试。
- en: Even without there being an error, the messages sent to a service on a daily
    basis are representative of the normal workflows of users. These messages can
    be mirrored to an audit queue as they enter into the system. The data from the
    audit queue can be used for testing. If a new feature is introduced, then a normal
    day's workload can be played back to ensure that there has been no degradation
    in either correct behavior or performance.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有错误，每天发送到服务的消息也代表用户的正常工作流程。这些消息可以在进入系统时镜像到审计队列中。审计队列中的数据可以用于测试。如果引入了新功能，那么可以回放正常的一天工作量，以确保正确行为或性能没有降级。
- en: Of course if the audit queue contains a list of every message, then it becomes
    trivial to understand how the application arrived at its current state. Frequently
    people implement history by plugging in a lot of custom code or by using triggers
    and audit tables. Neither of these approaches do as good of a job as messaging
    at understanding not only which data has changed, but why it has changed. Consider
    again the address change scenario, without messaging we will likely never know
    why an address for a user is different from the previous day.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果审计队列包含每条消息的列表，那么理解应用程序如何达到当前状态就变得微不足道了。经常有人通过插入大量自定义代码或使用触发器和审计表来实现历史。这两种方法都不如消息传递在理解数据不仅发生了什么变化，还发生了为什么变化方面做得好。再次考虑地址更改的情况，如果没有消息传递，我们很可能永远不会知道为什么用户的地址与前一天不同。
- en: Maintaining a good history of changes to system data is storage intensive but
    that cost is easily paid by allowing auditors to see how and why each change was
    made. Well-constructed messages also allow for the history to contain the intent
    of the user making the change.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 保持系统数据变更的良好历史记录需要大量存储空间，但通过允许审计员查看每次变更是如何以及为什么进行的，这个成本是很容易支付的。良好构建的消息还允许历史记录包含用户进行更改的意图。
- en: While it is possible to implement this sort of messaging system, in a single
    process it is difficult. Ensuring that messages are properly saved in the event
    of errors is difficult, as the entire process that deals with messages may crash,
    taking the internal message bus with it. Realistically if the replaying of messages
    sounds like something worth investigating then external message busses are the
    solution.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在单个进程中实现这种消息传递系统是可能的，但却很困难。确保消息在发生错误时被正确保存是困难的，因为处理消息的整个过程可能会崩溃，带走内部消息总线。实际上，如果重放消息听起来值得调查，那么外部消息总线就是解决方案。
- en: Pipes and filters
  id: totrans-641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道和过滤器
- en: I mentioned earlier that messages should be considered immutable. This is not
    to say that messages cannot be rebroadcast with some properties changed or even
    broadcast as a new type of message. In fact, many message handlers may consume
    an event and then publish a new event after having performed some task.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过消息应该被视为不可变的。这并不是说消息不能被重新广播并更改一些属性，甚至作为一种新类型的消息进行广播。事实上，许多消息处理程序可能会消耗一个事件，然后在执行了一些任务后发布一个新事件。
- en: 'As an example, you might consider the workflow for adding a new user to a system:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，你可以考虑向系统添加新用户的工作流程：
- en: '![Pipes and filters](Image00053.jpg)'
  id: totrans-644
  prefs: []
  type: TYPE_IMG
  zh: '![Pipes and filters](Image00053.jpg)'
- en: 'In this case, the `CreateUser` command triggers a `UserCreated` event. That
    event is consumed by a number of different services. One of these services passes
    on user information to a select number of affiliates. As this service runs, it
    publishes its own set of events, one for each affiliate that receives the new
    user''s details. These events may, in turn, be consumed by other services which
    could trigger their own events. In this way changes can ripple through the entire
    application. However, no service knows more than what starts it and what events
    it publishes. This system has very low coupling. Plugging in new functionality
    is trivial and even removing functionality is easy: certainly easier than a monolithic
    system.'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`CreateUser`命令触发了`UserCreated`事件。这个事件被许多不同的服务消耗。其中一个服务将用户信息传递给一些特定的联盟。当这个服务运行时，它会发布自己的一系列事件，每个事件都是为了接收新用户的详细信息的联盟。这些事件可能反过来被其他服务消耗，这些服务可能触发它们自己的事件。通过这种方式，变化可以在整个应用程序中传播。然而，没有一个服务知道比它启动和发布的事件更多的信息。这个系统耦合度很低。插入新功能是微不足道的，甚至删除功能也很容易：肯定比单片系统容易得多。
- en: Systems constructed using messaging and autonomous components are frequently
    referred to as using **Service Oriented Architecture** ( **SOA** ) or Microservices.
    There remains a great deal of debate as to the differences, if indeed there are
    any, between SOA and Microservices.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息传递和自治组件构建的系统经常被称为使用**面向服务的架构**（**SOA**）或微服务。关于SOA和微服务之间是否有任何区别，仍然存在很多争论。
- en: The altering and rebroadcasting of messages can be thought of as being a pipe
    or a filter. A service can proxy messages through to other consumers just as a
    pipe would do or can selectively republish messages as would be done by a filter.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的更改和重新广播可以被视为管道或过滤器。一个服务可以像管道一样将消息代理给其他消费者，也可以像过滤器一样有选择地重新发布消息。
- en: Versioning messages
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息版本控制
- en: As systems evolve, the information contained in a message may also change. In
    our user creation example, we might have originally been asking for a name and
    e-mail address. However, the marketing department would like to be able to send
    e-mails addressed to Mr. Jones or Mrs. Jones so we need to also collect the user's
    title. This is where message versioning comes in handy.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的发展，消息中包含的信息也可能会发生变化。在我们的用户创建示例中，我们可能最初要求姓名和电子邮件地址。然而，市场部门希望能够发送给琼斯先生或琼斯夫人的电子邮件，所以我们还需要收集用户的头衔。这就是消息版本控制派上用场的地方。
- en: We can now create a new message that extends the previous message. The message
    can contain additional fields and might be named using the version number or a
    date. Thus a message like `CreateUser` might become `CreateUserV1` or `CreateUser20140101`
    . Earlier I mentioned polymorphic messages. This is one approach to versioning
    messages. The new message extends the old so all the old message handlers still
    fire. However, we also talked about how there are no real polymorphic capabilities
    in JavaScript.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个扩展之前消息的新消息。该消息可以包含额外的字段，并可能使用版本号或日期进行命名。因此，像`CreateUser`这样的消息可能会变成`CreateUserV1`或`CreateUser20140101`。之前我提到过多态消息。这是一种消息版本控制的方法。新消息扩展了旧消息，因此所有旧消息处理程序仍然会触发。然而，我们也谈到了JavaScript中没有真正的多态能力。
- en: Another option is to use upgrading message handlers. These handlers will take
    in a version of the new message and modify it to be the old version. Obviously
    the newer messages need to have at least as much data in them as the old version
    or have data that permits converting one message type to another.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用升级消息处理程序。这些处理程序将接收新消息的版本并将其修改为旧版本。显然，新消息需要至少包含与旧版本相同的数据，或者具有允许将一种消息类型转换为另一种消息类型的数据。
- en: 'Consider a v1 message that looked like the following:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个看起来像下面这样的v1消息：
- en: '[PRE108]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Consider a v2 message that extended it adding a user title:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个扩展了用户标题的v2消息：
- en: '[PRE109]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Then we would be able to write a very simple upgrader or downgrader that looks
    like the following:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以编写一个非常简单的升级器或降级器，看起来像下面这样：
- en: '[PRE110]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: You can see that we simply modify the message and rebroadcast it.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们只是修改消息并重新广播它。
- en: Hints and tips
  id: totrans-659
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: Messages create a well-defined interface between two different systems. Defining
    messages should be done by members of both teams. Establishing a common language
    can be tricky especially as terms are overloaded between different business units.
    What a sales department considers a customer may be totally different from what
    a shipping department considers a customer. Domain driven design provides some
    hints as to how boundaries can be established to avoid mixing terms.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 消息在两个不同系统之间创建了一个明确定义的接口。定义消息应该由两个团队的成员共同完成。建立一个共同的语言可能会很棘手，特别是因为术语在不同的业务部门之间被重载。销售部门认为的客户可能与运输部门认为的客户完全不同。领域驱动设计提供了一些关于如何建立边界以避免混淆术语的提示。
- en: 'There is a huge preponderance of queue technologies available. Each of them
    have a bunch of different properties around reliability, durability, and speed.
    Some of the queues support reading and writing JSON over HTTP: ideal for those
    interested in building JavaScript applications. Which queue is appropriate for
    your application is a topic for some research.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 现有大量的队列技术可用。它们每个都有关于可靠性、持久性和速度的许多不同属性。其中一些队列支持通过HTTP读写JSON：这对于那些有兴趣构建JavaScript应用程序的人来说是理想的。哪种队列适合您的应用程序是一个需要进行一些研究的话题。
- en: Summary
  id: totrans-662
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Messaging and the associated patterns are large topics. Delving too deeply into
    messages will bring you in contact with **domain driven design** ( **DDD** ) and
    **command query responsibility segregation** ( **CQRS** ) as well as touching
    on high performance computing solutions.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递及其相关模式是一个庞大的主题。深入研究消息会让您接触到**领域驱动设计**（**DDD**）和**命令查询职责分离**（**CQRS**），以及涉及高性能计算解决方案。
- en: There is substantial research and discussion ongoing as to the best way to build
    large systems. Messaging is one possible solution that avoids creating a big ball
    of mud that is difficult to maintain and fragile to change. Messaging provides
    natural boundaries between components in a system and the messages themselves
    provide for a consistent API.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量的研究和讨论正在进行，以找到构建大型系统的最佳方法。消息传递是一种可能的解决方案，它避免了创建难以维护和易于更改的大块代码。消息传递在系统中提供了自然的边界，消息本身为一致的API提供了支持。
- en: Not every application benefits from messaging. There is additional overhead
    to building a loosely coupled application such as this. Applications that are
    collaborative, ones where losing data is especially undesirable, and those that
    benefit from a strong history story are good candidates for messaging. In most
    cases a standard CRUD application will be sufficient. It is still worthwhile to
    know about messaging patterns, as they will offer alternative thinking.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个应用程序都受益于消息传递。构建这样一个松散耦合的应用程序会增加额外的开销。协作型应用程序、那些特别不希望丢失数据的应用程序以及那些受益于强大历史故事的应用程序都是消息传递的良好候选者。在大多数情况下，标准的CRUD应用程序就足够了。然而，了解消息传递模式仍然是值得的，因为它们会提供替代思路。
- en: In this chapter we've taken a look at a number of different messaging patterns
    and how they can be applied to common scenarios. The differences between commands
    and events were also explored.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一些不同的消息模式以及它们如何应用于常见场景。还探讨了命令和事件之间的区别。
- en: In the next chapter we'll look at some patterns for making testing code a little
    bit easier. Testing is jolly important so read on!
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些使测试代码变得更容易的模式。测试非常重要，所以请继续阅读！
- en: Chapter 11. Microservices
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 微服务
- en: It seems like no book on programming these days is complete without at least
    some mention of microservices. For fear that this book could be singled out for
    ridicule as a non-conformant publication, a chapter has been included on microservices.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 现在似乎没有一本编程书籍是完整的，没有至少提到微服务的一些内容。为了避免这本书被指责为不符合规范的出版物，我们在微服务上包含了一章。
- en: 'Microservices are billed as the solution to the problems of monolithic applications.
    Likely every application you''ve dealt with has been a monolith: that is, the
    application has a single logical executable and is perhaps split into layers such
    as a user interface, a service or application layer, and a data store. In many
    applications these layers might be a web page, a server side application, and
    a database. Monoliths have their issues as I''m sure you''ve encountered.'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务被宣传为解决单块应用程序的问题的解决方案。很可能你处理过的每个应用程序都是单块应用程序：也就是说，应用程序有一个单一的逻辑可执行文件，并且可能分成诸如用户界面、服务或应用程序层和数据存储等层。许多应用程序中，这些层可能是一个网页、一个服务器端应用程序和一个数据库。单块应用程序有它们的问题，我相信你已经遇到过。
- en: Maintaining a monolithic application quickly becomes an exercise in limiting
    the impact of change. Frequently in such applications a change to one, seemingly
    isolated, corner of the application has an unintended effect on some other part
    of the application. Although there are many patterns and approaches to describe
    well isolated components, these often fall by the wayside inside a monolith. Often
    we take shortcuts which may save time now but will return to make our lives terrible
    down the road.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 维护单块应用程序很快就变成了限制变化影响的练习。在这样的应用程序中，经常会发生对应用程序的一个看似孤立的角落的更改对应用程序的其他部分产生意外影响。尽管有许多模式和方法来描述良好隔离的组件，但在单块应用程序中，这些往往会被抛在一边。通常我们会采取捷径，这可能会节省时间，但将来会让我们的生活变得糟糕。
- en: Monolithic applications are also difficult to scale. Because we tend to have
    only three layers, we are limited to scaling each one of those layers. We can
    add more application servers if the middle tier is becoming slow or more web servers
    if the web tier is laggy. If the database is slow then we can increase the power
    of the database server. These scaling approaches are very large operations. If
    the only part of the application which is slow is signing up new users, then we
    really have no way to simply scale that one component. This means that components
    which are not frequently used (one might call these cold or cool components) must
    be able to scale as the whole application scales. This sort of scaling doesn't
    come for free.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 单块应用程序也很难扩展。因为我们倾向于只有三层，我们受限于扩展这些层中的每一层。如果中间层变慢，我们可以添加更多的应用服务器，或者如果Web层滞后，我们可以添加更多的Web服务器。如果数据库变慢，那么我们可以增加数据库服务器的性能。这些扩展方法都是非常大的操作。如果应用程序中唯一慢的部分是注册新用户，那么我们真的没有办法简单地扩展那个组件。这意味着不经常使用的组件（可以称为冷或凉组件）必须能够随着整个应用程序的扩展而扩展。这种扩展并不是免费的。
- en: 'Consider that scaling from a single web server to multiple web servers introduces
    the problem of sharing sessions between many web servers. If we were, instead,
    to divide our application into a number of services, of which each acts as the
    canonical source of truth for a piece of data, then we could scale these sections
    independently. A service for logging users in, another service for saving and
    retrieving their preferences, yet another for sending out reminder e-mails about
    abandoned shopping carts, each one responsible for its own functions and own data.
    Each service stands alone as a separate application and may run on a separate
    machine. In effect we have taken our monolithic application and sharded it into
    many applications. Not only does each service have an isolated function but it
    also has its own datastore and could be implemented using its own technology.
    The difference between a monolith and microservices can be seen here:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到从单个Web服务器扩展到多个Web服务器会引入在多个Web服务器之间共享会话的问题。如果我们将应用程序分成多个服务，每个服务都作为数据的真实来源，那么我们可以独立地扩展这些部分。一个用于登录用户的服务，另一个用于保存和检索他们的偏好，另一个用于发送有关被遗弃的购物车的提醒电子邮件，每个服务负责自己的功能和数据。每个服务都是一个独立的应用程序，可以在单独的机器上运行。实际上，我们已经将我们的单块应用程序分片成了许多应用程序。每个服务不仅具有隔离的功能，而且还具有自己的数据存储，并且可以使用自己的技术来实现。单块应用程序和微服务之间的区别可以在这里看到：
- en: '![Microservices](Image00054.jpg)'
  id: totrans-674
  prefs: []
  type: TYPE_IMG
  zh: '![微服务](Image00054.jpg)'
- en: Applications are written more by composing services than by writing singular
    monolithic applications. The UI of an application can even be created by asking
    a number of services to provide visual components to be slotted into a composite
    UI by some form of composing service.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序更多地是通过组合服务来编写，而不是编写单一的单块应用程序。应用程序的用户界面甚至可以通过请求一些服务提供的可视组件来创建，然后由某种形式的组合服务插入到复合用户界面中。
- en: Node.js' lightweight approach to building applications with just the required
    components makes it an ideal platform to build lightweight microservices. Many
    microservice deployments make heavy use of HTTP to communicate between services
    while others rely more heavily on messaging systems such as **RabbitMQ** or **ZeroMQ**
    . These two communication methods may be mixed in deployments. One might split
    the technology used along the lines of using HTTP against services which are query-only,
    and messaging against services which perform some action. This is because messaging
    is more reliable (depending on your messaging system and configuration) than sending
    HTTP requests.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js以只使用所需组件构建应用程序的轻量级方法，使其成为构建轻量级微服务的理想平台。许多微服务部署大量使用HTTP在服务之间进行通信，而其他则更多地依赖于消息系统，如RabbitMQ或ZeroMQ。这两种通信方法可以在部署中混合使用。可以根据使用HTTP对仅进行查询的服务进行技术分割，并使用消息对执行某些操作的服务进行技术分割。这是因为消息比发送HTTP请求更可靠（取决于您的消息系统和配置）。
- en: While it may seem that we've introduced a great deal of complexity into the
    system it is a complexity that is easier to manage with modern tooling. Very good
    tooling exists for managing distributed log files and for monitoring the performance
    of applications for performance issues. Isolating and running many applications
    with virtualization is more approachable than ever with containerization technologies.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来我们在系统中引入了大量复杂性，但这种复杂性在现代工具的管理下更容易处理。存在非常好的工具来管理分布式日志文件和监视应用程序的性能问题。通过容器化技术，隔离和运行许多应用程序比以往任何时候都更容易。
- en: 'Microservices may not be the solution to all our maintenance and scalability
    issues but they are certainly an approach that is viable for consideration. In
    this chapter we''ll explore some of the patterns that may assist in using microservices:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可能不是解决我们所有维护和可扩展性问题的方法，但它们肯定是一个值得考虑的方法。在本章中，我们将探讨一些可能有助于使用微服务的模式：
- en: Façade
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观
- en: Aggregate services
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合服务
- en: Pipeline
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Message upgrader
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息升级器
- en: Service selector
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务选择器
- en: Failure patterns
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障模式
- en: Because microservices are a relatively new development, there are likely to
    be many more patterns which emerge as more and more applications are created with
    the microservice approach. There is some similarity between the Microservices
    approach and **Service Oriented** **Architecture** ( **SOA** ). This means that
    there are likely some patterns from the SOA world which will be applicable in
    the microservices world.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务是一个相对较新的发展，随着越来越多的应用程序采用微服务方法创建，可能会出现更多的模式。微服务方法与面向服务的体系结构（SOA）之间存在一些相似之处。这意味着SOA世界中可能有一些适用于微服务世界的模式。
- en: Façade
  id: totrans-686
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观
- en: If you feel that you recognize the name of this pattern, then you're correct.
    We discussed this pattern way back in [Chapter 4](text00035.html#page "Chapter 4. Structural
    Patterns") , *Structural Patterns* . In that application of the pattern we created
    a class which could direct the actions of a number of other classes providing
    a simpler API. Our example was that of an admiral who directed a fleet of ships.
    In the microservices world we can simply replace the concept of classes with that
    of services. After all, the functionality of a service is not that different from
    a microservice – they both perform a single action.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得认识这个模式的名字，那么您是正确的。我们在[第4章](text00035.html#page "第4章 结构模式")中讨论过这个模式，*结构模式*。在该模式的应用中，我们创建了一个可以指导多个其他类行动的类，提供了一个更简单的API。我们的例子是一个指挥官指挥一支舰队。在微服务世界中，我们可以简单地用服务的概念取代类的概念。毕竟，服务的功能与微服务并没有太大的不同-它们都执行单个动作。
- en: 'We might make use of a façade to coordinate the use of a number of other services.
    This pattern is a base pattern for many of the other patterns listed in this chapter.
    Coordinating services can be difficult, but by putting them behind a façade we
    can make the entire application much simpler. Let us consider a service which
    sends e-mails. Sending e-mails is quite a complex process which may involve a
    number of other services: a username to e-mail address translator, an anti-malware
    scanner, a spam checker, a formatter to message the e-mail body for various e-mail
    clients, and so forth.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用外观来协调使用多个其他服务。这种模式是本章中许多其他模式的基础模式。协调服务可能很困难，但通过将它们放在外观后面，我们可以使整个应用程序变得更简单。让我们考虑一个发送电子邮件的服务。发送电子邮件是一个相当复杂的过程，可能涉及许多其他服务：用户名到电子邮件地址的转换器，反恶意软件扫描器，垃圾邮件检查器，为各种电子邮件客户端格式化电子邮件正文的格式化器等等。
- en: 'Most clients who want to send e-mail don''t want to concern themselves with
    all of these other services so a façade e-mail-sending service can be put in place
    which holds the responsibility of coordinating other services. The coordination
    pattern can be seen here:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数想要发送电子邮件的客户并不想关注所有这些其他服务，因此可以放置一个外观电子邮件发送服务，它负责协调其他服务。协调模式可以在这里看到：
- en: '![Façade](Image00055.jpg)'
  id: totrans-690
  prefs: []
  type: TYPE_IMG
  zh: '![外观](Image00055.jpg)'
- en: Service selector
  id: totrans-691
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务选择器
- en: 'Along the same lines as a façade we have the service selector pattern. In this
    pattern we have a service which fronts a number of other services. Depending on
    the message which arrives, a different service could be selected to respond to
    the initial request. This pattern is useful in upgrade scenarios and for experimentation.
    If you''re rolling out a new service and want to ensure that it will function
    correctly under load then you could make use of the service selector pattern to
    direct a small portion of your production traffic to the new service while monitoring
    it closely. Another application might be for directing specific customers or groups
    of customers to a different service. The distinguishing factor could be anything
    from directing people who have paid for your service toward faster end points,
    to directing traffic from certain countries to country-specific services. The
    service selector pattern can be seen in this illustration:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 与外观类似的是服务选择器模式。在这种模式中，我们有一个服务作为其他服务的前端。根据到达的消息，可以选择不同的服务来响应初始请求。这种模式在升级场景和实验中很有用。如果您正在推出一个新的服务，并希望确保它在负载下能正常运行，那么您可以利用服务选择器模式将一小部分生产流量引导到新服务，同时密切监视它。另一个应用可能是将特定的客户或客户组引导到不同的服务。区分因素可以是任何东西，从将为您的服务付费的人引导到更快的终端，到将来自某些国家的流量引导到特定国家的服务。服务选择器模式可以在这个插图中看到：
- en: '![Service selector](Image00056.jpg)'
  id: totrans-693
  prefs: []
  type: TYPE_IMG
  zh: '![服务选择器](Image00056.jpg)'
- en: Aggregate services
  id: totrans-694
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合服务
- en: Data in a microservice architecture is owned by a single service, but there
    are many times when we might need to retrieve data from a number of different
    sources at once. Consider, again, a member of the Small Council in the land of
    Westeros. They may have a number of informants from whom they gather information
    about the workings of the kingdom. You can consider each informant to be its own
    microservice.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，数据由单个服务拥有，但有许多时候我们可能需要一次从许多不同的来源检索数据。再次考虑一下在维斯特洛大陆的小议会成员。他们可能有许多通报者，从他们那里收集有关王国运作的信息。您可以将每个通报者视为其自己的微服务。
- en: Tip
  id: totrans-696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Informants are a fantastic metaphor for microservices as each one is independent
    and holds its own data. Services may also fail from time to time just as informants
    may be captured and terminated. Messages are passed between informants just as
    they are among a collection of microservices. Each informant should know very
    little about how the rest of the informants work, and even, who they are – an
    abstraction which works for microservices too.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 通报者是微服务的一个很好的比喻，因为每个通报者都是独立的，并且拥有自己的数据。服务也可能会偶尔失败，就像通报者可能会被捕获和终止一样。消息在通报者之间传递，就像在一组微服务之间传递一样。每个通报者对其他通报者的工作知之甚少，甚至不知道他们是谁——这种抽象对微服务也适用。
- en: 'With the aggregate service pattern, we ask each one of a collection of nodes
    to perform some action or return some piece of data. This is a fairly common pattern
    even outside the microservice world and is a special case of the façade or even
    adapter pattern. The aggregator requests information from a number of other services
    and then waits for them to return. Once all the data has been returned, then the
    aggregator may perform some additional tasks such as summarizing the data or counting
    records. The information is then passed back to the caller. The aggregator can
    be seen in this illustration:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 使用聚合服务模式，我们要求一组节点中的每一个执行某些操作或返回某些数据。这是一个相当常见的模式，即使在微服务世界之外也是如此，它是外观模式甚至适配器模式的特例。聚合器从其他一些服务请求信息，然后等待它们返回。一旦所有数据都返回了，聚合器可能执行一些额外的任务，比如总结数据或计算记录。然后将信息传递回给调用者。聚合器可以在这个插图中看到：
- en: '![Aggregate services](Image00057.jpg)'
  id: totrans-699
  prefs: []
  type: TYPE_IMG
  zh: '![聚合服务](Image00057.jpg)'
- en: This pattern may also have some provision for dealing with slow-to-return services
    or failures of services. The aggregator service may return partial results or
    return data from a cache in the event that one of the child services reaches a
    timeout. In certain architectures, the aggregator could return a partial result
    and then return additional data to the caller when it becomes available.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可能还有一些处理返回缓慢的服务或服务失败的规定。聚合器服务可能返回部分结果，或者在其中一个子服务达到超时时，从缓存返回数据。在某些架构中，聚合器可以返回部分结果，然后在可用时向调用者返回其他数据。
- en: Pipeline
  id: totrans-701
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: 'A pipeline is another example of a microservice connecting pattern. If you
    have made use of the shell on a *NIX system, then you have certainly piped the
    output of one command to another command. The programs on a *NIX system such as
    ls, sort, uniq, and grep are designed to perform just one task; their power comes
    from the ability to chain the tools together to build quite complex workflows.
    For instance, this command:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是微服务连接模式的另一个例子。如果您曾经在*NIX系统上使用过shell，那么您肯定已经将一个命令的输出传递给另一个命令。*NIX系统上的程序，如ls、sort、uniq和grep，都是设计用来执行单一任务的；它们的强大之处在于能够将这些工具链接在一起构建相当复杂的工作流程。例如，这个命令：
- en: '[PRE111]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This command will list all the unique file extensions in the current directory.
    It does this by taking the list of files, then cutting them and taking the extension;
    this is then sorted and finally passed to `uniq` which removes duplicates. While
    I wouldn't suggest having a microservice for such trivial actions as sorting or
    deduplicating, you might have a series of services which build up more and more
    information.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将列出当前目录中所有唯一的文件扩展名。它通过获取文件列表，然后剪切它们并获取扩展名来实现这一点；然后对其进行排序，最后传递给`uniq`，以删除重复项。虽然我不建议为排序或去重等琐碎操作创建微服务，但您可能有一系列服务，逐渐积累更多信息。
- en: 'Let''s imagine a query service that returns a collection of company records:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个查询服务，返回一组公司记录：
- en: '[PRE112]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'This record is returned by our company lookup service. Now we can pass this
    record onto our sales accounting service which will add a sales total to the record:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 这条记录是由我们的公司查找服务返回的。现在我们可以将这条记录传递给我们的销售会计服务，该服务将向记录中添加销售总额：
- en: '[PRE113]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Now that record can be passed onto a sales estimate service, which further
    enhances the record with an estimate of 2017 sales:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 现在该记录可以传递给销售估算服务，该服务将进一步增强记录，估算2017年的销售额：
- en: '[PRE114]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This sort of progressive enhancement could be reversed too by a service that
    stripped out information which shouldn''t be presented to the users. The record
    might now become the following:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 这种渐进式增强也可以通过一个服务来逆转，该服务可以剥离不应呈现给用户的信息。记录现在可能变成以下内容：
- en: '[PRE115]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Here we have dropped the company identifier because it is an internal identifier.
    A microservice pipeline should be bidirectional so that a quantum of information
    is passed into each step in the pipeline and then passed back out again through
    each step. This affords services the opportunity to act upon the data twice, manipulating
    it as they see fit. This is the same approach used in many web servers where modules
    such as PHP are permitted to act upon the request and the response. A pipeline
    can be seen illustrated here:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们删除了公司标识符，因为这是一个内部标识符。微服务管道应该是双向的，这样信息量就可以通过管道中的每个步骤传递，然后再通过每个步骤传递回来。这为服务提供了两次操作数据的机会，可以根据需要对数据进行操作。这与许多Web服务器中使用的方法相同，其中诸如PHP之类的模块被允许对请求和响应进行操作。管道可以在这里看到示例：
- en: '![Pipeline](Image00058.jpg)'
  id: totrans-714
  prefs: []
  type: TYPE_IMG
  zh: '![管道](Image00058.jpg)'
- en: Message upgrader
  id: totrans-715
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息升级器
- en: 'One of the highest-risk activities with some monolithic applications is upgrading.
    To do so you basically need to upgrade the entire application at once. With even
    a medium-sized application there are far too many aspects to reasonably test.
    Thus at some point you simply need to cut over from the old system to the new
    system. With a microservice approach, the cutover can be done for each individual
    service. Smaller services mean that the risk can be spread out over a long time
    and, should something go wrong, the source of the error can be more quickly pinpointed:
    the singular new component.'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些单片应用程序来说，升级是最高风险的活动之一。要做到这一点，您基本上需要一次性升级整个应用程序。即使是中等规模的应用程序，也有太多方面需要合理测试。因此，在某个时候，您只需要从旧系统切换到新系统。采用微服务方法，可以为每个单独的服务进行切换。较小的服务意味着风险可以分散在很长时间内，如果出现问题，错误的来源可以更快地被定位：单一的新组件。
- en: 'At issue are the services which are still talking to the old version of the
    upgraded service. How can we continue to serve these services without having to
    update all those services too? If the interface to the service remains unchanged,
    say our service calculates the distance between two points on the earth and we
    change it from using a simple Pythagorean approach to using haversine (a formula
    to find the distance between two spots on a sphere), then there may be no need
    to make changes to the input and output formats. Frequently, however, this approach
    isn''t available to us as the message format must change. Even in the previous
    example there is a possibility of changing the output message. Haversine is more
    accurate than a Pythagorean approach so we could have more significant digits
    requiring a larger data type. There are two good approaches to deal with this:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于仍在与升级服务的旧版本进行通信的服务。我们如何继续为这些服务提供服务，而无需更新所有这些服务呢？如果服务的接口保持不变，比如我们的服务计算地球上两点之间的距离，我们将其从使用简单的毕达哥拉斯方法更改为使用哈弗赛恩（一种在球面上找到两个点之间距离的公式），那么可能不需要对输入和输出格式进行更改。然而，通常情况下，这种方法对我们来说是不可用的，因为消息格式必须更改。即使在前面的例子中，也有可能更改输出消息。哈弗赛恩比毕达哥拉斯方法更准确，因此我们可能需要更多的有效数字，需要更大的数据类型。有两种很好的方法来处理这个问题：
- en: 'Continue to use the old version of our service and the new version. We can
    then slowly move the client services over to the new service as time permits.
    There are problems with this approach: we now need to maintain more code. Also,
    if the reason we change the service out was one which would not permit us to continue
    to run it (a security problem, termination of a dependent service, and so on)
    then we are at something of an impasse.'
  id: totrans-718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续使用我们服务的旧版本和新版本。然后，我们可以在时间允许的情况下慢慢将客户服务迁移到新服务。这种方法存在问题：我们现在需要维护更多的代码。此外，如果我们更改服务的原因是无法继续运行它（安全问题，终止依赖服务等），那么我们就陷入了某种僵局。
- en: Upgrade messages and pass them on. In this approach we take the old message
    format and upgrade it to the new format. This is done by, you guessed it, another
    service. This service's responsibility is to take in the old message format and
    emit the new message format. At the other end you might need an equivalent service
    to downgrade messages back to the expected output format for older services.
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级消息并传递它们。在这种方法中，我们采用旧的消息格式并将其升级到新的格式。这是通过另一个服务来完成的。这个服务的责任是接收旧的消息格式并发出新的消息格式。在另一端，您可能需要一个等效的服务来将消息降级为旧服务的预期输出格式。
- en: 'Upgrader services should have a limited lifespan. Ideally we would want to
    make updates to the services which depend on deprecated services as quickly as
    possible. The small code footprint of microservices, coupled with the ability
    to rapidly deploy services, should make these sorts of upgrade much easier than
    those used to a monolithic approach might expect. An example message upgrader
    service can be seen here:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 升级服务应该有一个有限的寿命。理想情况下，我们希望尽快对依赖于已弃用服务的服务进行更新。微服务的小代码占用量，加上快速部署服务的能力，应该使这些类型的升级比单片方法所期望的更容易。一个示例消息升级器服务可以在这里看到：
- en: '![Message upgrader](Image00059.jpg)'
  id: totrans-721
  prefs: []
  type: TYPE_IMG
  zh: '![消息升级器](Image00059.jpg)'
- en: Failure patterns
  id: totrans-722
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 失败模式
- en: We have already touched upon some of the ways of dealing with failures in microservices
    in this chapter. There are, however, a couple of more interesting approaches we
    should consider. The first of these is service degradation.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经提到了一些处理微服务故障的方法。然而，还有一些更有趣的方法值得考虑。其中之一是服务降级。
- en: Service degradation
  id: totrans-724
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务降级
- en: This pattern could also be called graceful degradation and is related to progressive
    enhancement. Let us hark back to the example of replacing the Pythagorean distance
    function with the haversine equivalent. If the haversine service is down for some
    reason, the less demanding function could be used in its place without a huge
    impact on users. In fact, they may not notice it at all. It isn't ideal that users
    have a worse version of the service but it is certainly more desirable than simply
    showing the user an error message. When the haversine service returns to life
    then we can stop using the less desirable service. We could have multiple levels
    of fallback allowing several different services to fail while we continue to present
    a fully functional application to the end user.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式也可以称为优雅降级，与渐进增强有关。让我们回顾一下用哈弗赛恩等效替换毕达哥拉斯距离函数的例子。如果哈弗赛恩服务由于某种原因而关闭，那么可以使用不太苛刻的函数代替它，而对用户几乎没有影响。事实上，他们可能根本没有注意到。用户拥有更糟糕的服务版本并不理想，但肯定比简单地向用户显示错误消息更可取。当哈弗赛恩服务恢复正常时，我们可以停止使用较差的服务。我们可以有多个级别的备用方案，允许多个不同的服务失败，同时我们继续向最终用户呈现一个完全功能的应用程序。
- en: Another good application of this form of degradation is to fall back to more
    expensive services. I once had an application that sent SMS messages. It was quite
    important that these messages actually be sent. We used our preferred SMS gateway
    provider the majority of the time but, if our preferred service was unavailable,
    something we monitored closely, then we would fail over to using a different provider.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 这种退化形式的另一个很好的应用是退回到更昂贵的服务。我曾经有一个发送短信的应用程序。确实很重要这些消息实际上被发送。我们大部分时间都使用我们首选的短信网关提供商，但是，如果我们的首选服务不可用，这是我们密切监视的情况，那么我们就会切换到使用另一个提供商。
- en: Message storage
  id: totrans-727
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息存储
- en: We've already drawn a bit of a distinction between services which are query-only
    and those which actually perform some lasting data change. When one of these updating
    services fails there is still a need to run the data change code at some point
    in the future. Storing these requests in a message queue allows them to be run
    later without risk of losing any of the ever-so important messages. Typically,
    when a message causes an exception it is returned to the processing queue where
    it can be retried.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在查询服务和实际执行某些持久数据更改的服务之间划分了一些区别。当这些更新服务之一失败时，仍然需要在将来的某个时间运行数据更改代码。将这些请求存储在消息队列中可以让它们稍后运行，而不会有丢失任何非常重要的消息的风险。通常，当消息引发异常时，它会被返回到处理队列，可以进行重试。
- en: There is an old saying that insanity is doing the same thing over again and
    expecting a different outcome. However, there are many transient errors which
    can be solved by simply performing the same action over again. Database deadlocks
    are a prime example of this. Your transaction may be killed to resolve a deadlock,
    in which case performing it again is, in fact, the recommended approach. However,
    one cannot retry messages ad infinitum so it is best to choose some relatively
    small number of retry attempts, three or five. Once this number has been reached
    then the message can be sent to a dead letter or poison message queue.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 有一句古老的谚语说，疯狂就是一遍又一遍地做同样的事情，却期待不同的结果。然而，有许多瞬态错误可以通过简单地再次执行相同的操作来解决。数据库死锁就是一个很好的例子。您的事务可能会被终止以解决死锁问题，在这种情况下，再次执行它实际上是推荐的方法。然而，不能无限次重试消息，因此最好选择一些相对较小的重试次数，比如三次或五次。一旦达到这个数字，消息就可以被发送到死信或毒消息队列。
- en: 'Poison messages, or dead letters as some call them, are messages which have
    actual legitimate reasons for failing. It is important to keep these messages
    around not only for debugging purposes but because the messages may represent
    a customer order or a change to a medical record: not data you can afford to lose.
    Once the message handler has been corrected these messages can be replayed as
    if the error never happened. A storage queue and message reprocessor can be seen
    illustrated here:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 毒消息，或者有些人称之为死信，是因为实际合理的原因而失败的消息。保留这些消息非常重要，不仅用于调试目的，还因为这些消息可能代表客户订单或医疗记录的更改：这些都是您不能承受丢失的数据。一旦消息处理程序已经被纠正，这些消息可以被重放，就好像错误从未发生过一样。存储队列和消息重新处理器可以在这里看到：
- en: '![Message storage](Image00060.jpg)'
  id: totrans-731
  prefs: []
  type: TYPE_IMG
  zh: '![消息存储](Image00060.jpg)'
- en: Message replay
  id: totrans-732
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息重放
- en: Although not a real production pattern, a side-effect of having a message-based
    architecture around all the services which change data is that you can acquire
    the messages for later replay outside of production. Being able to replay messages
    is very handy for debugging complex interactions between numerous services as
    the messages contain almost all the information to set up a tracing environment
    identical to production. Replay capabilities are also very useful for environments
    where one must be able to audit any data changes to the system. There are other
    methods to address such audit requirements but a very solid message log is simply
    a delight to work with.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是一个真正的生产模式，但围绕所有更改数据的服务构建基于消息的架构的一个副作用是，您可以获取消息以便在生产环境之外稍后重放。能够重放消息对于调试多个服务之间复杂交互非常方便，因为消息几乎包含了设置与生产环境完全相同的跟踪环境所需的所有信息。重放功能对于必须能够审计系统中的任何数据更改的环境也非常有用。还有其他方法来满足此类审计要求，但非常可靠的消息日志简直是一种乐趣。
- en: Indempotence of message handling
  id: totrans-734
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息处理的幂等性
- en: The final failure pattern we'll discuss is idempotence of message handling.
    As systems grow larger it is almost certain that a microservices architecture
    will span many computers. This is even more certain due to the growing importance
    of containers, which can, ostensibly, be thought of as computers. Communicating
    between computers in a distributed system is unreliable; thus, a message may end
    up being delivered more than once. To handle such an eventuality one might wish
    to make messaging handling idempotent.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的最后一个失败模式是消息处理的幂等性。随着系统规模的扩大，几乎可以肯定，微服务架构将跨越许多计算机。由于容器的重要性日益增长，这更是肯定的，容器本质上可以被视为计算机。在分布式系统中的计算机之间的通信是不可靠的；因此，消息可能会被传递多次。为了处理这种可能性，人们可能希望使消息处理具有幂等性。
- en: Tip
  id: totrans-736
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more about the unreliability of distributed computing, I cannot recommend
    any paper more worth reading than *Falacies of Distributed Computing Explained*
    by Arnon Rotem-Gal-Oz at [http://rgoarchitects.com/Files/fallacies.pdf](http://rgoarchitects.com/Files/fallacies.pdf)
    .
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 关于分布式计算的不可靠性，我强烈推荐阅读Arnon Rotem-Gal-Oz的《分布式计算谬误解释》一文，网址为[http://rgoarchitects.com/Files/fallacies.pdf](http://rgoarchitects.com/Files/fallacies.pdf)。
- en: 'Idempotence means that a message can be processed many times without changing
    the outcome. This can be harder to achieve than one might realize, especially
    with services which are inherently non-transactional such as sending e-mails.
    In these cases, one may need to write a record that an e-mail has been sent to
    a database. There are some scenarios in which the e-mail will be sent more than
    once, but a service crashing in the critical section between the e-mail being
    sent and the record of it being written is unlikely. The decision will have to
    be made: is it better to send an e-mail more than once or not send it at all?'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等性意味着一条消息可以被处理多次而不改变结果。这可能比人们意识到的更难实现，特别是对于那些本质上是非事务性的服务，比如发送电子邮件。在这些情况下，可能需要将已发送电子邮件的记录写入数据库。在某些情况下，电子邮件可能会被发送多次，但在电子邮件发送和记录写入之间的关键部分崩溃的情况是不太可能的。必须做出决定：是更好地多次发送电子邮件，还是根本不发送？
- en: Hints and tips
  id: totrans-739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: If you think of a microservice as a class and your microservice web as an application,
    then it rapidly becomes apparent that many of the same patterns we've seen elsewhere
    in the book are applicable to microservices. Service discovery could be synonymous
    with dependency injection. Singleton, decorator, proxy; all of them could be applicable
    to the microservice world just as they are within the boundaries of a process.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把微服务看作一个类，把微服务网络看作一个应用程序，那么很快就会发现，我们在本书中看到的许多模式同样适用于微服务。服务发现可能与依赖注入是同义词。单例、装饰器、代理；所有这些模式在微服务世界中同样适用，就像它们在进程边界内一样。
- en: One thing to keep in mind is that many of these patterns are somewhat chatty,
    sending significant data back and forth. Within a process there is no overhead
    to passing around pointers to data. The same is not true of microservices. Communicating
    over the network is likely to incur a performance penalty.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一件事是，许多这些模式有点啰嗦，来回传送大量数据。在一个进程内，传递数据指针是没有额外开销的。但对于微服务来说情况并非如此。通过网络通信很可能会带来性能损失。
- en: Summary
  id: totrans-742
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Microservices are a fascinating idea and one which is more likely to be realized
    in the next few years. It is too early to tell if this is simply another false
    turn on the way to properly solving software engineering or a major step in the
    right direction. In this chapter we've explored a few patterns which may be of
    use should you embark upon a journey into the microservices world. Because we're
    only on the cusp of microservices becoming mainstream, it is likely that, more
    than any other chapter of this book, the patterns here will quickly become dated
    and found to be suboptimal. Remaining vigilant with regard to developments and
    being aware of the bigger picture when you're developing is highly advisable.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一个令人着迷的想法，很可能在未来几年内得以实现。现在还为时过早，无法确定这是否只是在正确解决软件工程问题的道路上又一个错误转折，还是朝着正确方向迈出的重要一步。在本章中，我们探讨了一些模式，这些模式可能在你踏上微服务世界的旅程时会有所帮助。由于我们只是处于微服务成为主流的初期阶段，这一章的模式很可能会很快过时，并被发现不够优化。在开发过程中保持警惕，了解更大的画面是非常明智的。
- en: Chapter 12. Patterns for Testing
  id: totrans-744
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。测试模式
- en: Throughout this book we've been pushing the idea that JavaScript is no longer
    a toy language with which we can't do useful things. Real world software is being
    written in JavaScript right now and the percentage of applications using JavaScript
    is only likely to grow over the next decade.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在强调JavaScript不再是一个我们无法做有用事情的玩具语言。现在就有真实世界的软件是用JavaScript编写的，未来十年使用JavaScript的应用程序的比例只可能增长。
- en: With real software comes concerns about correctness. Manually testing software
    is painful and, weirdly, error-prone. It is far cheaper and easier to produce
    unit and integration tests that run automatically and test various aspects of
    the application.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 随着真实软件的出现，对正确性的担忧也随之而来。手动测试软件是痛苦的，而且容易出错。编写自动运行并测试应用程序各个方面的单元测试和集成测试要便宜得多，也更容易。
- en: There are countless tools available for testing JavaScript, from test runners
    to testing frameworks; the ecosystem is a rich one. We'll try to maintain a more
    or less tool-agnostic approach to testing in this chapter. This book does not
    concern itself with which framework is the best or friendliest. There are overarching
    patterns that are common to testing as a whole. It is those that we'll examine.
    We will touch on some specific tools but only as a shortcut to having to write
    all our own testing tools.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 有无数工具可用于测试JavaScript，从测试运行器到测试框架；这个生态系统非常丰富。在本章中，我们将尽量保持一种几乎不依赖特定工具的测试方法。本书不关心哪个框架是最好或最友好的。有一些普遍的模式适用于整个测试过程。我们将涉及一些具体的工具，但只是为了避免编写所有自己的测试工具而采取的捷径。
- en: 'In this chapter we''ll look at the following topics:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Fake objects
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚假对象
- en: Monkey patching
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 猴子补丁
- en: Interacting with the user interface
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与用户界面交互
- en: The testing pyramid
  id: totrans-752
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: We computer programmers are, as a rule, highly analytical people. This means
    that we're always striving to categorize and understand concepts. This has led
    to our developing some very interesting global techniques that can be applied
    outside computer programming. For instance, agile development has applications
    in general society but can trace its roots back to computing. One might even argue
    that the idea of patterns owes much of its popularity to it being used by computer
    programmers in other walks of life.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 作为计算机程序员，我们通常是高度分析性的人。这意味着我们总是在努力对概念进行分类和理解。这导致我们开发了一些非常有趣的全球技术，可以应用于计算机编程之外。例如，敏捷开发在一般社会中也有应用，但可以追溯到计算机。甚至可以说，模式的概念之所以如此流行，很大程度上是因为它被计算机程序员在其他生活领域中使用。
- en: 'This desire to categorize has led to the concept of testing code being divided
    up into a number of different types of tests. I''ve seen as many as eight different
    categories of tests from unit tests, right the way up to workflow tests and GUI
    tests. This is, perhaps, an overkill. It is much more common to think about having
    three different categories of test: unit, integration, and user interface:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分类的愿望导致了将测试代码划分为许多不同类型的测试的概念。我见过从单元测试一直到工作流测试和GUI测试等多达八种不同类型的测试。这可能有些过度。更常见的是考虑有三种不同类型的测试：单元测试、集成测试和用户界面测试：
- en: '![The testing pyramid](Image00061.jpg)'
  id: totrans-755
  prefs: []
  type: TYPE_IMG
  zh: '![测试金字塔](Image00061.jpg)'
- en: 'Unit tests form the foundation of the pyramid. They are the most numerous,
    the easiest to write, and the most granular in the errors they give. An error
    in a unit test will allow you to find the individual method that has an error
    in it. As we move up the pyramid, the number of tests falls along with the granularity
    while the complexity of each test increases. At a higher level, when a test fails
    we might only be able to say: "There is an issue with adding an order to the system".'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试构成了金字塔的基础。它们数量最多，编写起来最容易，并且在提供错误信息时最细粒度。单元测试中的错误将帮助您找到具有错误的单个方法。随着金字塔的上升，测试数量随着粒度的减少而减少，而每个测试的复杂性则增加。在更高的层次上，当一个测试失败时，我们可能只能说：“在向系统添加订单时出现了问题”。
- en: Testing in the small with unit tests
  id: totrans-757
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过单元测试在小范围内进行测试
- en: To many, unit testing is a foreign concept. This is understandable as it is
    a topic which is poorly taught in many schools. I know that I've done six years
    of higher education in computing science without it being mentioned. It is unfortunate
    because delivering a quality product is a pretty important part of any project.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 对许多人来说，单元测试是一个陌生的概念。这是可以理解的，因为在许多学校里，这个话题都没有得到很好的教授。我知道我在计算机科学的六年高等教育中从未听说过它。这是不幸的，因为交付高质量的产品是任何项目中非常重要的一部分。
- en: For those who know about unit testing, there is a big barrier to adoption. Managers,
    and even developers, frequently see unit testing, and automated testing as a whole,
    as a waste of time. After all you cannot ship a unit test to your customer nor
    do most customers care whether their product has been properly unit tested.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 对于了解单元测试的人来说，采用单元测试存在一个很大的障碍。经理，甚至开发人员经常认为单元测试和自动化测试整体上都是浪费时间。毕竟，你不能把一个单元测试交给客户，大多数客户也不在乎他们的产品是否经过了正确的单元测试。
- en: 'Unit testing is notoriously difficult to define. It is close enough to integration
    testing that people slip back and forth between the two easily. In the seminal
    book; *The Art of Unit Testing* , *Roy Osherove* , the author defines a unit test
    as:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的定义非常困难。它与集成测试非常接近，人们很容易在两者之间来回切换。在开创性的书籍《单元测试的艺术》中，作者罗伊·奥舍罗夫定义了单元测试为：
- en: '*A unit test is an automated piece of code that invokes a unit of work in the
    system and then checks a single assumption about the behavior of that unit of
    work.*'
  id: totrans-761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*单元测试是一个自动化的代码片段，它调用系统中的一个工作单元，然后检查关于该工作单元行为的一个假设。*'
- en: The exact size of a unit of work is up for some debate. Some people restrict
    it to a single function or a single class, while others allow a unit of work to
    span multiple classes. I tend to think that a unit of work that spans multiple
    classes can actually be broken into smaller, testable units.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 一个工作单元的确切大小存在一些争议。有些人将其限制在一个函数或一个类，而其他人允许一个工作单元跨越多个类。我倾向于认为跨越多个类的工作单元实际上可以分解成更小、可测试的单元。
- en: The key to unit testing is that it tests a small piece of functionality and
    it quickly tests the functionality in a repeatable, automated fashion. Unit tests
    written by one person should be easily runnable by any other member of the team.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的关键在于它测试了一个小的功能片段，并且以可重复、自动化的方式快速测试了功能。一个人编写的单元测试应该很容易地被团队中的任何其他成员运行。
- en: For unit testing we want to test small pieces of functionality because we believe
    that if all the components of a system work correctly then the system as a whole
    will work. This is not the whole truth. The communication between modules is just
    as likely to fail as a function within the unit. This is why we want to write
    tests on several levels. Unit tests check that the code we're writing right now
    is correct. Integration testing tests entire workflows through the application
    and will uncover problems in the interaction of units.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单元测试，我们希望测试小的功能片段，因为我们相信如果系统的所有组件都正确工作，那么整个系统也会工作。这并不是全部真相。模块之间的通信和单元内的功能一样容易出错。这就是为什么我们希望在几个层面上编写测试。单元测试检查我们正在编写的代码是否正确。集成测试测试应用程序中的整个工作流程，并且会发现单元之间的交互问题。
- en: The test-driven development approach suggests writing tests at the same time
    as we write code. While this gives us great confidence that the code we're writing
    is correct, the real advantage is that it helps drive good architecture. When
    code has too many interdependencies it is far harder to test than well-separated
    modular code. A lot of the code that developers write goes unread by anybody ever
    again. Unit tests provide a useful way of keeping developers on the right path
    even in cases where they know that nobody will ever see their code. There is no
    better way to produce a quality product than to tell people they are going to
    be checked on it, even if the checker happens to be an automated test.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发方法建议在编写代码的同时编写测试。虽然这给了我们很大的信心，我们正在编写的代码是正确的，但真正的优势在于它有助于推动良好的架构。当代码之间存在太多的相互依赖时，要测试它就比良好分离的模块化代码要困难得多。开发人员编写的许多代码永远不会被任何人阅读。单元测试为开发人员提供了一种有用的方式，即使在他们知道没有人会再次看到他们的代码的情况下，也可以使他们走上正确的道路。没有比告诉人们他们将受到检查更好的方式来生产高质量的产品，即使检查者可能是一个自动化测试。
- en: Tests can be run both while developing new code and in an automatic fashion
    on the build machines. If every time a developer checks in a change, the entire
    project is built and tested, then some reassurance can be provided that the newly
    checked-in code is correct. From time to time the build will break and that will
    be a flag that something that was just added was in error. Often the code that
    is broken may not even be proximal to the code changed. An altered return value
    may percolate through the system and manifest itself somewhere wholly unexpected.
    Nobody can keep anything more than the most trivial system in their mind at any
    one time. Testing acts as a sort of second memory, checking and rechecking assumptions
    made previously.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以在开发新代码时运行，也可以在构建机器上以自动方式运行。如果每次开发人员提交更改时，整个项目都会被构建和测试，那么可以提供一些保证，即新提交的代码是正确的。有时构建会中断，这将是一个标志，表明刚刚添加的内容存在错误。通常，出现错误的代码可能甚至与更改的代码不相邻。修改后的返回值可能会在系统中传播，并在完全意想不到的地方显现出来。没有人可以一次记住比最琐碎的系统更多的东西。测试充当了第二记忆，检查和重新检查以前做出的假设。
- en: Failing the build as soon as an error occurs shortens the time it takes between
    an error being made in the code and it being found and fixed. Ideally the problem
    will still be fresh in the developer's mind so the fix can easily be found. If
    the errors were not discovered until months down the road, the developer will
    certainly have forgotten what s/he was working on at the time. The developer may
    not even be around to help solve the problem, throwing somebody who has never
    seen the code in to fix it.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发生错误，立即中断构建可以缩短在代码中出现错误和发现并修复错误之间的时间。理想情况下，问题仍然在开发人员的脑海中，因此修复可以很容易地找到。如果错误直到几个月后才被发现，开发人员肯定会忘记当时正在做什么。开发人员甚至可能不在现场帮助解决问题，而是让从未见过代码的人来解决问题。
- en: Arrange-Act-Assert
  id: totrans-768
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安排-执行-断言
- en: When building tests for any piece of code, a very common approach to follow
    is that of Arrange-Act-Assert. This describes the different steps that take place
    inside a single unit test.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 在为任何代码构建测试时，一个非常常见的方法是遵循安排-执行-断言的步骤。这描述了单元测试中发生的不同步骤。
- en: The first thing we do is set up a test scenario (arrange). This step can consist
    of a number of actions and may involve putting in place fake objects to simulate
    real objects as well as creating new instances of the subject under test. If you
    find that your test setup code is long or involved, it is likely a smell and you
    should consider refactoring your code. As mentioned in the previous section, testing
    is helpful for driving not just correctness but also architecture. Difficult-to-write
    tests are indicative that the architecture is not sufficiently modular.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是设置一个测试场景（安排）。这一步可以包括许多操作，并且可能涉及放置虚假对象来模拟真实对象，以及创建被测试主题的新实例。如果您发现您的测试设置代码很长或者很复杂，那很可能是一种异味，您应该考虑重构您的代码。如前一节所述，测试有助于驱动正确性和架构。难以编写的测试表明架构不够模块化。
- en: Once the test is set up then the next step is to actually execute the function
    we would like to test (act). The act step is usually very short, in many cases
    no more than a single line of code.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试设置好了，下一步就是实际执行我们想要测试的函数（执行）。执行步骤通常非常简短，在许多情况下不超过一行代码。
- en: The final part is to check to make sure that the result of the function or the
    state of the world is as you would expect (assert).
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是检查函数的结果或世界的状态是否符合您的期望（断言）。
- en: 'A very simple example of this might be a castle builder:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的例子可能是一个城堡建造者：
- en: '[PRE116]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'This class simply builds a new castle of a specific size. We want to make sure
    that no shenanigans are going on and that when we build a castle of size `10`
    we get a castle of size `10` :'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只是简单地构建一个特定大小的新城堡。我们想确保没有什么欺骗行为，并且当我们建造一个大小为`10`的城堡时，我们得到的是一个大小为`10`的城堡：
- en: '[PRE117]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Assert
  id: totrans-777
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断言
- en: You may have noticed that in the last example we made use of a function called
    `assertEquals` . An assert is a test that, when it fails, throws an exception.
    There is currently no built-in assert functionality in JavaScript, although there
    is a proposal in the works to add it.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在上一个示例中，我们使用了一个名为`assertEquals`的函数。断言是一个测试，当它失败时会抛出异常。目前在JavaScript中没有内置的断言功能，尽管有一个提案正在进行中以添加它。
- en: 'Fortunately, building an assert is pretty simple:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，构建一个断言非常简单：
- en: '[PRE118]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: It is helpful to mention, in the error, the actual value as well as the expected
    value.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误中提及实际值和期望值是有帮助的。
- en: There is a great number of assertion libraries in existence. Node.js ships with
    one, creatively called `assert.js` . If you end up using a testing framework for
    JavaScript it is likely that it will also contain an assertion library.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 存在大量的断言库。Node.js附带了一个，创造性地称为`assert.js`。如果您最终在JavaScript中使用测试框架，很可能它也包含一个断言库。
- en: Fake objects
  id: totrans-783
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚假对象
- en: If we think of the interdependencies between objects in an application as a
    graph it becomes quickly apparent that there are a number of nodes that have dependencies
    on, not just one, but many other objects. Attempting to place an object with a
    lot of dependencies under test is challenging. Each of the dependent objects must
    be constructed and included in the test. When these dependencies interact with
    external resources such as the network or file system, the problem becomes intractable.
    Pretty soon we're testing the entire system at a time. This is a legitimate testing
    strategy, known as **integration testing** , but we're really just interested
    in ensuring that the functionality of a single class is correct.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将应用程序中对象之间的相互依赖关系视为图形，很快就会发现有许多节点依赖于不止一个，而是许多其他对象。试图测试具有许多依赖关系的对象是具有挑战性的。每个依赖对象都必须被构建并包含在测试中。当这些依赖与网络或文件系统等外部资源进行交互时，问题变得棘手。很快我们就会一次性测试整个系统。这是一种合法的测试策略，称为**集成测试**，但我们真正感兴趣的是确保单个类的功能是正确的。
- en: Integration testing tends to be slower to execute than unit tests.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的执行速度往往比单元测试慢。
- en: 'The subject of a test can have a large dependency graph that makes testing
    it difficult. You can see an example here:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的主体可能有一个庞大的依赖图，这使得测试变得困难。你可以在这里看到一个例子：
- en: '![Fake objects](Image00062.jpg)'
  id: totrans-787
  prefs: []
  type: TYPE_IMG
  zh: '![虚假对象](Image00062.jpg)'
- en: 'We need to find a way to isolate the class under test so that we don''t have
    to recreate all the dependencies, including the network. We can think of this
    approach as adding bulkheads to our code. We will insert bulkheads to stop tests
    from flowing over from one class to many. These bulkheads are similar to how oil
    tankers maintain separation to limit the impact of spills and maintain weight
    distribution as can be seen here:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到一种方法来隔离被测试的类，这样我们就不必重新创建所有的依赖关系，包括网络。我们可以将这种方法看作是向我们的代码添加防护墙。我们将插入防护墙，阻止测试从一个类流向多个类。这些防护墙类似于油轮维持隔离以限制泄漏的影响并保持重量分布，如下所示：
- en: '![Fake objects](Image00063.jpg)'
  id: totrans-789
  prefs: []
  type: TYPE_IMG
  zh: '![虚假对象](Image00063.jpg)'
- en: '*Image courtesy of [http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/)
    .'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '*图片由[http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/)提供。*'
- en: To this end we can use fake objects that have a limited set of functionalities
    in place of the real objects. We'll look at three different methods of creating
    fake objects.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以使用虚假对象来代替真实对象，虚假对象具有一组有限的功能。我们将看看三种创建虚假对象的不同方法。
- en: The first is the, rather niftily named, test spy.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是一个非常巧妙命名的测试间谍。
- en: Test spies
  id: totrans-793
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试间谍
- en: A spy is an approach that wraps all the methods of an object and records the
    inputs and outputs from that method as well as the number of calls. By wrapping
    the calls, it is possible to examine exactly what was passed in and what came
    out of the function. Test spies can be used when the exact inputs into a function
    are not known beforehand.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍是一种包装对象的方法，记录该方法的输入和输出以及调用次数。通过包装调用，可以检查函数的确切输入和输出。当不事先知道函数的确切输入时，可以使用测试间谍。
- en: In other languages, building test spies requires reflection and can be quite
    complicated. We can actually get away with making a basic test spy in no more
    than a couple of lines of code. Let's experiment.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，构建测试间谍需要反射，可能会相当复杂。实际上，我们可以用不超过几行代码来制作一个基本的测试间谍。让我们来试验一下。
- en: 'To start we''ll need a class to intercept:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个要拦截的类：
- en: '[PRE119]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now we would like to spy on this function. Because functions are first class
    objects in JavaScript we can simply rejigger the `SpyUpon` object:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要监视这个函数。因为在JavaScript中，函数是一等对象，我们可以简单地重新调整`SpyUpon`对象：
- en: '[PRE120]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Here we take the existing function and give it a new name. Then we create a
    new function that calls the renamed function and also records some things. After
    the function has been called we can examine the various properties:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们接受现有的函数并给它一个新名字。然后我们创建一个新的函数，调用重命名的函数并记录一些东西。函数被调用后，我们可以检查各种属性：
- en: '[PRE121]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Running this code in node gets us the following:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 在node中运行这段代码，我们得到以下结果：
- en: '[PRE122]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Using this technique, it is possible to get all sorts of insight into how a
    function is used. There are a number of libraries that support creating test spies
    in a more robust way than our simple version here. Some provide tools for recording
    exceptions, the number of times called, and the arguments for each call.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，可以深入了解函数的使用方式。有许多库支持以比我们这里的简单版本更强大的方式创建测试间谍。有些提供记录异常、调用次数和每次调用的参数的工具。
- en: Stubs
  id: totrans-805
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存根
- en: A **stub** is another example of a fake object. We can use stubs when we have
    some dependencies in the subject under test that need to be satisfied with an
    object that returns a value. They can also be used to provide a bulkhead to stop
    computationally expensive or I/O reliant functions from being run.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '**存根**是另一个虚假对象的例子。当被测试的主体中有一些需要满足返回值对象的依赖关系时，我们可以使用存根。它们也可以用来提供防护，阻止计算密集型或依赖I/O的函数运行。'
- en: Stubs can be implemented in much the same way that we implemented spies. We
    just need to intercept the call to the method and replace it with a version that
    we wrote. However, with stubs we actually don't call the replaced function. It
    can be useful to keep the replaced function around just in case we need to restore
    the functionality of the stubbed out class.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 存根可以以与我们实现间谍相同的方式实现。我们只需要拦截对方法的调用，并用我们编写的版本替换它。然而，对于存根，我们实际上不调用被替换的函数。保留被替换函数可能是有用的，以防我们需要恢复存根类的功能。
- en: 'Let''s start with an object that depends on another object for part of its
    functionality:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个对象开始，该对象的部分功能依赖于另一个对象：
- en: '[PRE123]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This knight object takes a `credentialFactory` argument as part of its constructor.
    By passing in the object we exteriorize the dependency and remove the responsibility
    for creating `credentialFactory` from the knight. We've seen this sort of inversion
    of control previously and we'll look at it in more detail in the next chapter.
    This makes our code more modular and testing far easier.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 这个骑士对象在其构造函数中接受一个`credentialFactory`参数。通过传入对象，我们将依赖性外部化，并将创建`credentialFactory`的责任从骑士身上移除。我们之前已经看到了这种控制反转的方式，我们将在下一章中更详细地讨论它。这使得我们的代码更模块化，测试更容易。
- en: 'Now when we want to test the knight without worrying about how a credential
    factory works, we can use a fake object, in this case a stub:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们想要测试骑士而不用担心凭证工厂的工作方式时，我们可以使用一个虚假对象，这里是一个存根：
- en: '[PRE124]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'This stub is a very simple one that simply returns a standard new credential.
    Stubs can be made quite complicated if there need to be multiple calls to it.
    For instance, we could rewrite our simple stub as the following:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存根是一个非常简单的存根，只是返回一个标准的新凭证。如果需要多次调用，存根可以变得相当复杂。例如，我们可以将我们简单的存根重写为以下形式：
- en: '[PRE125]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'This version of the stub returns a different sort of credential every time
    it is called. On the third call it returns null. As we set up the class using
    an inversion of control, writing a test is as simple as the following:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存根的版本在每次调用时返回不同类型的凭据。第三次调用时返回null。由于我们使用了控制反转来设置类，编写测试就像下面这样简单：
- en: '[PRE126]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We can now execute the test:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以执行测试：
- en: '[PRE127]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Because there is no hard typing system in JavaScript, we can build stubs without
    worrying about implementing interfaces. There is also no need to stub an entire
    object but only the function in which we're interested.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript中没有硬类型系统，我们可以构建存根而不必担心实现接口。也不需要存根整个对象，只需要我们感兴趣的函数。
- en: Mock
  id: totrans-820
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟
- en: 'The final type of fake object is a **mock** . The difference between a mock
    and a stub is where the verification is done. With a stub, our test must check
    if the state is correct after the act. With a mock object, the responsibility
    for testing the asserts falls to the mock itself. Mocks are another place where
    it is useful to leverage a mocking library. We can, however, build the same sort
    of thing, simply, ourselves:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种虚假对象是**模拟**。模拟和存根之间的区别在于验证的位置。对于存根，我们的测试必须在行动之后检查状态是否正确。对于模拟对象，测试断言的责任落在模拟对象本身。模拟是另一个有用的地方，可以利用模拟库。但是，我们也可以简单地构建相同类型的东西：
- en: '[PRE128]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'This `mockCredentialsFactory` class takes on the responsibility of verifying
    the correct functions were called. This is a very simple sort of approach to mocking
    and can be used as such:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`mockCredentialsFactory`类承担了验证正确函数是否被调用的责任。这是一种非常简单的模拟方法，可以像这样使用：
- en: '[PRE129]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: This is a static mock that keeps the same behavior every time it is used. It
    is possible to build mocks that act as recording devices. You can instruct the
    mock object to expect certain behaviors and then have it automatically play them
    back.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个静态模拟，每次使用时都保持相同的行为。可以构建作为录音设备的模拟。您可以指示模拟对象期望某些行为，然后让它自动播放它们。
- en: 'The syntax for this is taken from the documentation for the mocking library;
    Sinon. It looks like the following:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法取自模拟库Sinon的文档。它看起来像下面这样：
- en: '[PRE130]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Monkey patching
  id: totrans-828
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Monkey patching
- en: We've seen a number of methods for creating fake objects in JavaScript. When
    creating the spy, we made use of a method called **monkey patching** . Monkey
    patching allows you to dynamically change the behavior of an object by replacing
    its functions. We can use this sort of approach without having to revert to full
    fake objects. Any existing object can have its behavior changed in isolation using
    this approach. This includes built-in objects such as strings and arrays.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在JavaScript中创建虚假对象的许多方法。在创建间谍时，我们使用了一种称为**monkey patching**的方法。Monkey
    patching允许您通过替换其函数来动态更改对象的行为。我们可以使用这种方法，而无需回到完全虚假的对象。使用这种方法可以单独更改任何现有对象的行为。这包括字符串和数组等内置对象。
- en: Interacting with the user interface
  id: totrans-830
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与用户界面交互
- en: A great deal of the JavaScript in use today is used on the client and is used
    to interact with elements that are visible on the screen. Interacting with the
    page flows through a model of the page known as **Document Object Model** ( **DOM**
    ).
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 今天使用的大量JavaScript用于客户端，并用于与屏幕上可见的元素进行交互。与页面交互通过称为**文档对象模型**（**DOM**）的页面模型进行。
- en: Every element on the page is represented in the DOM. Whenever a change is made
    to the page, the DOM is updated. If we add a paragraph to the page, then a paragraph
    is added to the DOM. Thus if our JavaScript code adds a paragraph, checking that
    it does so is simply a function of checking the DOM.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上的每个元素都在DOM中表示。每当页面发生更改时，DOM都会更新。如果我们向页面添加段落，那么DOM中就会添加一个段落。因此，如果我们的JavaScript代码添加了一个段落，检查它是否这样做只是检查DOM的一个函数。
- en: Unfortunately, this requires that a DOM actually exists and that it is formed
    in the same way that it is on the actual page. There are a number of approaches
    to testing against a page.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这要求DOM实际上存在，并且以与实际页面相同的方式形成。有许多方法可以针对页面进行测试。
- en: Browser testing
  id: totrans-834
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器测试
- en: The most naïve approach is to simply automate the browser. There are a few projects
    out there that can help with this task. One can either automate a fully-fledged
    browser such as Firefox, Internet Explorer, or Chrome, or one can pick a browser
    that is headless. The fully-fledged browser approach requires that a browser be
    installed on the test machine and that the machine be running in a mode that has
    a desktop available.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 最天真的方法就是简单地自动化浏览器。有一些项目可以帮助完成这项任务。可以自动化完整的浏览器，如Firefox、Internet Explorer或Chrome，也可以选择一个无头浏览器。完整的浏览器方法要求测试机器上安装了浏览器，并且机器正在运行具有可用桌面的模式。
- en: Many Unix-based build servers will not have been set up to show a desktop as
    it isn't needed for most build tasks. Even if your build machine is a Windows
    one, the build account frequently runs in a mode that has no ability to open a
    window. Tests using full browsers also have a tendency to break, to my mind. Subtle
    timing issues crop up and tests are easily interrupted by unexpected changes to
    the browser. It is a frequent occurrence that manual intervention will be required
    to unstick a browser that has ended up in an incorrect state.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 许多基于Unix的构建服务器不会被设置为显示桌面，因为大多数构建任务不需要。即使您的构建机器是Windows机器，构建帐户经常以无法打开窗口的模式运行。在我看来，使用完整浏览器进行测试也有破坏的倾向。会出现微妙的时间问题，并且测试很容易被浏览器的意外更改打断。经常需要手动干预来解决浏览器陷入不正确状态的问题。
- en: Fortunately, efforts have been made to decouple the graphical portions of a
    web browser from the DOM and JavaScript. For Chrome this initiative has resulted
    in PhantomJS and for Firefox SlimerJS.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，已经努力将Web浏览器的图形部分与DOM和JavaScript解耦。对于Chrome，这一举措已经导致了PhantomJS，而对于Firefox则是SlimerJS。
- en: Typically, the sorts of test that require a full browser require some navigation
    of the browser across several pages. This is provided for in the headless browsers
    through an API. I tend to think of tests at this scale as integration tests rather
    than unit tests.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，需要完整浏览器的测试需要浏览器在多个页面之间进行导航。无头浏览器通过API提供了这一功能。我倾向于将这种规模的测试视为集成测试，而不是单元测试。
- en: 'A typical test using PhantomJS and the CasperJS library that sits on top of
    the browser might look like the following:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PhantomJS和位于浏览器顶部的CasperJS库进行的典型测试可能如下所示：
- en: '[PRE131]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This would test that entering a value into the search box on Google changes
    the `aria-haspopup` property from `false` to `true` .
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 这将测试在Google搜索框中输入值是否会将`aria-haspopup`属性从`false`更改为`true`。
- en: Testing things this way puts a great deal of reliance on the DOM not changing
    too radically. Depending on the selectors used to find elements on the page, a
    simple change to the style of the page could break every test. I like to keep
    tests of this sort away from the look of that page by never using CSS properties
    to select elements. Instead make use of IDs or, better yet, data-* attributes.
    We don't necessarily have the luxury of that when it comes to testing existing
    pages but certainly for new pages it is a good plan.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式测试会在很大程度上依赖于DOM不会发生太大变化。根据用于在页面上查找元素的选择器，页面样式的简单更改可能会破坏每个测试。我喜欢通过不使用CSS属性来选择元素，而是使用ID或者更好的是data-*属性，将这种测试与页面的外观分开。当我们测试现有页面时，我们可能没有这样的奢侈，但对于新页面来说，这是一个很好的计划。
- en: Faking the DOM
  id: totrans-843
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪造DOM
- en: Much of the time, we don't need a full page DOM to perform our tests. The page
    elements we need to test are part of a section on the page instead of the entire
    page. A number of initiatives exist that allow for the creation of a chunk of
    the document in pure JavaScript. `jsdom` for instance is a method for injecting
    a string of HTML and receiving back a fake window.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分时间，我们不需要完整的页面DOM来执行测试。我们需要测试的页面元素是页面上的一个部分，而不是整个页面。存在许多倡议可以通过纯JavaScript创建文档的一部分。例如，`jsdom`是一种通过注入HTML字符串并接收一个虚假窗口的方法。
- en: 'In this example, modified slightly from their README, they create some HTML
    elements, load JavaScript, and test that it returns correctly:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，稍作修改，他们创建了一些HTML元素，加载了JavaScript，并测试其是否正确返回：
- en: '[PRE132]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: If your JavaScript is focused on a small section of the page, perhaps you're
    building custom controls or web components, then this is an ideal approach.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的JavaScript专注于页面的一个小部分，也许你正在构建自定义控件或Web组件，那么这是一种理想的方法。
- en: Wrapping the manipulation
  id: totrans-848
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装操作
- en: The final approach to dealing with graphical JavaScript is to stop interacting
    directly with elements on the page. This is the approach that many of the more
    popular JavaScript frameworks of today use. One simply updates a JavaScript model
    and this model then updates the page through the use of some sort of MV* pattern.
    We looked at this approach in some detail some chapters ago.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 处理图形JavaScript的最终方法是停止直接与页面上的元素进行交互。这是当今许多更受欢迎的JavaScript框架采用的方法。一个简单地更新JavaScript模型，然后通过某种MV*模式更新页面。我们在前几章中详细讨论了这种方法。
- en: Testing in this case becomes quite easy. Our complicated JavaScript can simply
    be tested by building a model state prior to running the code and then testing
    to see if the model state after running the code is as we expect.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，测试变得非常容易。我们可以通过在运行代码之前构建模型状态，然后测试运行代码后的模型状态是否符合预期来测试复杂的JavaScript。
- en: 'As an example we could have a model that looks like the following:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以有一个如下所示的模型：
- en: '[PRE133]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The test code for it might look as simple as the following:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 对于它的测试代码可能看起来就像下面这样简单：
- en: '[PRE134]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: As everything on the page is manipulated, through the bindings to the model,
    we can be confident that changes in the model are correctly updating the page.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面上的所有内容都被操作时，通过与模型的绑定，我们可以确信模型中的更改是否正确地更新了页面。
- en: Some would argue that we've simply shifted the problem. Now the only place for
    errors is if the binding between the HTML and the model is incorrect. So we also
    need to test if we have bindings correctly applied to the HTML. This falls to
    higher-level testing that can be done more simply. We can cover far more with
    a higher-level test than with a lower-level one, although at the cost of knowing
    exactly where the error occurred.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 有人会争辩说我们只是把问题转移了。现在错误的唯一可能性是HTML和模型之间的绑定是否不正确。因此，我们还需要测试是否已将绑定正确应用到HTML。这需要更简单地进行更高级别的测试。我们可以通过更高级别的测试覆盖更多内容，尽管会牺牲知道错误发生的确切位置。
- en: You're never going to be able to test everything about an application but the
    smaller you can make the untested surface, the better.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远无法测试应用程序的所有内容，但是未经测试的表面越小，越好。
- en: Tips and tricks
  id: totrans-858
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技巧和窍门
- en: 'I have seen tests where people split up the Arrange-Act-Assert by putting in
    place comments:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过一些人通过添加注释来分隔安排-执行-断言：
- en: '[PRE135]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: You're going to wear your fingers to the bone typing those comments for every
    single test. Instead I just split them up with a blank line. The separation is
    clear and anybody who knows Arrange-Act-Assert will instantly recognize what it
    is that you're doing. You'll have seen the example code in this chapter split
    up in this fashion.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会因为为每个测试输入这些注释而累得手指骨折。相反，我只是用空行分隔它们。分隔清晰，任何了解安排-执行-断言的人都会立即认识到你正在做什么。你会看到本章中的示例代码以这种方式分隔。
- en: There are countless JavaScript testing libraries available to make your life
    easier. Choosing one may depend on your preferred style. If you like a gherkin-style
    syntax then cuumber.js might be for you. Otherwise try mocha, either on its own,
    or with the chai BDD style assertion library , which is is fairly nice. There
    are also testing frameworks such as Protractor which are specific to Angular apps
    (although you can use it to test other frameworks with a bit of work). I'd suggest
    taking a day and playing with a few to find your sweet spot.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 有无数的JavaScript测试库可用，可以让你的生活更轻松。选择一个可能取决于你的偏好风格。如果你喜欢gherkin风格的语法，那么cuumber.js可能适合你。否则，尝试mocha，可以单独使用，也可以与chai
    BDD风格断言库一起使用，这也相当不错。还有一些针对Angular应用程序的测试框架，比如Protractor（尽管你可以通过一些工作来测试其他框架）。我建议花一天时间玩一下，找到适合你的点。
- en: When writing tests, I tend to name them in a way that makes it obvious that
    they are tests and not production code. For most JavaScript I follow camel case
    naming conventions such as `testMapping` . However, for test methods I follow
    an underscored naming pattern `When_building_a_castle_size_should_be_correctly_set`
    . In this way the test reads more like a specification. Others have different
    approaches to naming and there is no "right" answer, so feel free to experiment.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，我倾向于以一种明显表明它们是测试而不是生产代码的方式命名它们。对于大多数JavaScript，我遵循驼峰命名约定，比如`testMapping`。然而，对于测试方法，我遇到了一个下划线命名模式`When_building_a_castle_size_should_be_correctly_set`。这样测试就更像是一个规范。其他人对命名有不同的方法，没有“正确”的答案，所以请随意尝试。
- en: Summary
  id: totrans-864
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Producing a quality product is always going to require extensive and repeated
    testing; this is exactly the sort of thing computers are really good at. Automate
    as much as possible.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 生产高质量产品总是需要广泛和重复的测试；这正是计算机真正擅长的事情。尽可能自动化。
- en: Testing JavaScript code is an up-and-coming thing. The tooling around, mocking
    out objects, and even the tools for running tests are undergoing constant changes.
    Being able to use tools such as Node.js to run tests quickly and without having
    to boot up an entire browser is stunningly helpful. This is an area that is only
    going to improve over the next few years. I am enthused to see what changes come
    from it.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 测试JavaScript代码是一个新兴的事物。围绕它的工具，模拟对象，甚至运行测试的工具都在不断变化。能够使用诸如Node.js之类的工具快速运行测试，而不必启动整个浏览器，这非常有帮助。这个领域在未来几年内只会得到改善。我很期待看到它带来的变化。
- en: In the next chapter we'll take a look at some advanced patterns in JavaScript
    that you might not want to use every day but are very handy.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一些JavaScript中的高级模式，这些模式可能不是每天都想使用，但非常方便。
- en: Chapter 13. Advanced Patterns
  id: totrans-868
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。高级模式
- en: I hesitated when naming this chapter, *Advanced Patterns* . This isn't really
    about patterns that are more complicated or sophisticated than other patterns.
    It is about patterns that you wouldn't use very frequently. Frankly, coming from
    a static programming language background, some of them seem crazy. Nonetheless
    they are completely valid patterns and are in use within big name projects everywhere.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 当我给这一章命名时，我犹豫不决，*高级模式*。这并不是关于比其他模式更复杂或复杂的模式。这是关于你不经常使用的模式。坦率地说，来自静态编程语言背景的一些模式看起来有些疯狂。尽管如此，它们是完全有效的模式，并且在各大项目中都在使用。
- en: 'In this chapter we''ll be looking at the following topics:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Dependency injection
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Live post processing
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时后处理
- en: Aspect oriented programming
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向方面的编程
- en: Macros
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏
- en: Dependency injection
  id: totrans-875
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: One of the topics we've been talking about continuously during this book is
    the importance of making your code modular. Small classes are easier to test,
    provide better reuse, and promote better collaboration for teams. Modular, loosely
    coupled code is easier to maintain, as changes can be limited. You may remember
    the example of a ripstop we used earlier.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中一直在讨论的一个主题是使你的代码模块化的重要性。小类更容易测试，提供更好的重用，并促进团队更好的协作。模块化，松散耦合的代码更容易维护，因为变更可以受限。你可能还记得我们之前使用的一个ripstop的例子。
- en: With modular code of this sort we see a lot of inversion of control. Classes
    have functionality inserted into them through passing additional classes by their
    creators. This moves the responsibility for how some portions of the child class
    work to the parent. For small projects, this is a pretty reasonable approach.
    As projects get more complicated and dependency graphs get more complicated, manually
    injecting the functionality becomes more and more difficult. We are still creating
    objects all over the code base, passing them into created objects so the coupling
    problem still exists, we've just shifted it up a level.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模块化代码中，我们看到了很多控制反转。类通过创建者传递额外的类来插入功能。这将一些子类的工作责任移交给了父类。对于小项目来说，这是一个相当合理的方法。随着项目变得更加复杂和依赖图变得更加复杂，手动注入功能变得越来越困难。我们仍然在整个代码库中创建对象，将它们传递给创建的对象，因此耦合问题仍然存在，我们只是将它提升到了更高的级别。
- en: If we think of object creation as a service, then a solution to this problem
    presents itself. We can defer the object creation to a central location. This
    allows us to change the implementations for a given interface in one place, simply
    and easily. It also allows us to control object lifetime so that we can reuse
    objects or recreate them every time they are used. If we need to replace one implementation
    of an interface with another implementation, then we can be confident that we
    need to only change it in one location. Because the new implementation still fulfils
    the contract, that is the interface, then all the classes that make use of the
    interface can remain ignorant of the change.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将对象创建视为一项服务，那么这个问题的解决方案就呈现出来了。我们可以将对象创建推迟到一个中心位置。这使我们能够在一个地方简单轻松地更改给定接口的实现。它还允许我们控制对象的生命周期，以便我们可以重用对象或在每次使用时重新创建它们。如果我们需要用另一个实现替换接口的一个实现，那么我们可以确信只需要在一个位置进行更改。因为新的实现仍然满足合同，也就是接口，那么使用接口的所有类都可以对更改保持无知。
- en: What's more is that by centralizing object creation it becomes easier to construct
    objects that depend on other objects. If we look at a dependency graph for a module
    such as the `UserManager` variable, it is clear that it has a number of dependencies.
    These dependencies may have additional dependencies and so forth. To build a `UserManager`
    variable, we not only need to pass in the database, but also `ConnectionStringProvider`
    , `CredentialProvider` , and `ConfigFileConnectionStringReader` . Goodness, that
    is going to be a lot of work to create instances of all of these. If we, instead,
    register implementations of each of these interfaces in a registry, then we need
    only go to the registry to look up how to make them. This can be automated and
    the dependencies automatically get injected to all dependencies without a need
    to explicitly create any of them. This method of solving dependencies is commonly
    referred to as 'solving the transitive closure'.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，通过集中对象创建，更容易构造依赖于其他对象的对象。如果我们查看诸如`UserManager`变量的模块的依赖图，很明显它有许多依赖关系。这些依赖关系可能还有其他依赖关系等等。要构建一个`UserManager`变量，我们不仅需要传递数据库，还需要`ConnectionStringProvider`，`CredentialProvider`和`ConfigFileConnectionStringReader`。天哪，要创建所有这些实例将是一项艰巨的工作。相反，我们可以在注册表中注册每个接口的实现，然后只需去注册表查找如何创建它们。这可以自动化，依赖关系会自动注入到所有依赖项中，无需显式创建任何依赖项。这种解决依赖关系的方法通常被称为“解决传递闭包”。
- en: 'A dependency injection framework handles the responsibility of constructing
    objects. On application set up the dependency injection framework is primed with
    a combination of names and objects. From this, it creates a registry or a container.
    When constructing an object through the container, the container looks at the
    signature of the constructor and attempts to satisfy the arguments on the constructor.
    Here is an illustration of a dependency graph:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入框架处理构造对象的责任。在应用程序设置时，依赖注入框架使用名称和对象的组合进行初始化。从这个组合中，它创建一个注册表或容器。通过容器构造对象时，容器查看构造函数的签名，并尝试满足构造函数中的参数。以下是依赖图的示例：
- en: '![Dependency injection](Image00064.jpg)'
  id: totrans-881
  prefs: []
  type: TYPE_IMG
  zh: '![依赖注入](Image00064.jpg)'
- en: In more statically typed languages such as C# or Java, dependency injection
    frameworks are commonplace. They usually work by using reflection, a method of
    using code to extract structural information from other code. When building the
    container, one specifies an interface and one or more concrete classes that can
    satisfy the interface. Of course using interfaces and reflection to perform dependency
    injection requires that the language support both interfaces and introspection.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如C#或Java等更静态类型的语言中，依赖注入框架很常见。它们通常通过使用反射来工作，反射是一种使用代码从其他代码中提取结构信息的方法。在构建容器时，我们指定一个接口和一个或多个可以满足该接口的具体类。当然，使用接口和反射执行依赖注入需要语言支持接口和内省。
- en: 'There is no way to do this in JavaScript. JavaScript has neither direct introspection
    nor a traditional object inheritance model. A common approach is to use variable
    names to solve the dependency problem. Consider a class that has a constructor
    like so:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中无法做到这一点。JavaScript既没有直接的内省，也没有传统的对象继承模型。一种常见的方法是使用变量名来解决依赖问题。考虑一个具有以下构造函数的类：
- en: '[PRE136]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The constructor takes two arguments that are very specifically named. When we
    construct this class through the dependency injection, these two arguments are
    satisfied by looking through the names registered with the container and passing
    them into the constructor. However, without introspection how can we extract the
    names of the parameters so we know what to pass into the constructor?
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受两个非常具体命名的参数。当我们通过依赖注入构造这个类时，这两个参数通过查看容器中注册的名称并将它们传递到构造函数中来满足。然而，没有内省，我们如何提取参数的名称，以便知道传递到构造函数中的内容呢？
- en: 'The solution is actually amazingly simple. The original text of any function
    in JavaScript is available by simply calling `toString` on it. So, for the constructor
    given in the preceding code, we can do just do this:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案实际上非常简单。在JavaScript中，任何函数的原始文本都可以通过简单地调用`toString`来获得。因此，对于前面代码中给出的构造函数，我们可以这样做：
- en: '[PRE137]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Now we can parse the string returned to extract the names of the parameters.
    Care must be taken to parse the text correctly, but it is possible. The popular
    JavaScript framework, Angular, actually uses this method to do its dependency
    injection. The result remains relatively preformat. The parsing really only needs
    to be done once and the results cached, so no additional penalty is incurred.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以解析返回的字符串以提取参数的名称。必须小心地解析文本，但这是可能的。流行的JavaScript框架Angular实际上使用这种方法来进行其依赖注入。结果仍然相对预格式。解析实际上只需要进行一次，并且结果被缓存，因此不会产生额外的开销。
- en: I won't go through how to actually implement the dependency injection, as it
    is rather tedious. When parsing the function, you can either parse it using a
    string-matching algorithm or build a lexer and parser for the JavaScript grammar.
    The first solution seems easier but it is likely a better decision to try to build
    up a simple syntax tree for the code into which you're injecting. Fortunately,
    the entire method body can be treated as a single token, so it is vastly easier
    than building a fully-fledged parser.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细介绍如何实际实现依赖注入，因为这相当乏味。在解析函数时，你可以使用字符串匹配算法进行解析，也可以为JavaScript语法构建词法分析器和解析器。第一种解决方案似乎更容易，但更好的决定可能是尝试为代码构建一个简单的语法树，然后进行注入。幸运的是，整个方法体可以被视为一个单一的标记，因此比构建一个完全成熟的解析器要容易得多。
- en: If you're willing to impose a different syntax on the user of your dependency
    injection framework then you can even go so far as to create your own syntax.
    The Angular 2.0 dependency injection framework, `di.js` , supports a custom syntax
    for denoting both places where objects should be injected and for denoting which
    objects satisfy some requirement.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意对依赖注入框架的用户施加不同的语法，甚至可以创建自己的语法。Angular 2.0依赖注入框架`di.js`支持自定义语法，用于表示应该注入对象的位置以及表示哪些对象满足某些要求。
- en: 'Using it as a class into which some code needs to be injected, looks like this
    code, taken from the `di.js` examples page:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 将其用作需要注入一些代码的类，看起来像这段代码，取自`di.js`示例页面：
- en: '[PRE138]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The `CoffeeMaker` instance might look like the following code:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoffeeMaker`实例可能看起来像以下代码：'
- en: '[PRE139]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: You might have also noticed that this example makes use of the `class` keyword.
    This is because the project is very forward looking and requires the use of `traceur.js`
    to provide for ES6 class support. We'll learn about `traceur.js` file in the next
    chapter.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了，这个例子使用了`class`关键字。这是因为该项目非常前瞻，需要使用`traceur.js`来提供ES6类支持。我们将在下一章学习`traceur.js`文件。
- en: Live post processing
  id: totrans-896
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时后处理
- en: It should be apparent now that running `toString` over a function in JavaScript
    is a valid way to perform tasks. It seems odd but, really, writing code that emits
    other code is as old as Lisp or possibly older. When I first came across how dependency
    injection works in AngularJS, I was both disgusted at the hack and impressed by
    the ingenuity of the solution.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该明显了，在JavaScript中运行`toString`函数是执行任务的有效方式。这似乎很奇怪，但实际上，编写发出其他代码的代码与Lisp一样古老，甚至可能更古老。当我第一次了解AngularJS中依赖注入的工作原理时，我对这种hack感到恶心，但对解决方案的创造力印象深刻。
- en: 'If it is possible to do dependency injection by interpreting code on the fly,
    then what more could we do with it? The answer is: quite a lot. The first thing
    that comes to mind is that you could write domain specific languages.'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以通过解释代码来进行依赖注入，那么我们还能做些什么呢？答案是：相当多。首先想到的是，你可以编写特定领域的语言。
- en: We talked about DSLs in [Chapter 5](text00044.html#page "Chapter 5. Behavioral
    Patterns") , *Behavioral Patterns* , and even created a very simple one. With
    the ability to load and rewrite JavaScript, we can take advantage of a syntax
    that is close to JavaScript but not wholly compatible. When interpreting the DSL,
    our interpreter would write out additional tokens needed to convert the code to
    actual JavaScript.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](text00044.html#page "Chapter 5. Behavioral Patterns")中讨论了DSL，*行为模式*，甚至创建了一个非常简单的DSL。通过加载和重写JavaScript的能力，我们可以利用接近JavaScript但不完全兼容的语法。在解释DSL时，我们的解释器会写出转换代码为实际JavaScript所需的额外标记。
- en: 'One of the nice features of TypeScript that I''ve always liked is that parameters
    to the constructors that are marked as public are automatically transformed into
    properties on the object. For instance, the TypeScript code that follows:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直喜欢TypeScript的一个很好的特性是，标记为public的构造函数参数会自动转换为对象的属性。例如，以下是TypeScript代码：
- en: '[PRE140]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Compiles to the following code:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 编译为以下代码：
- en: '[PRE141]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We could do something similar in our DSL. Starting with the `Axe` definition
    that follows:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的DSL中做类似的事情。从以下`Axe`定义开始：
- en: '[PRE142]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: We've used a comment here to denote that `headHeight` should be public. Unlike
    the TypeScript version, we would like our source code to be valid JavaScript.
    Because comments are included in the `toString` function this works just fine.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了注释来表示`headHeight`应该是公共的。与TypeScript版本不同，我们希望我们的源代码是有效的JavaScript。因为注释包含在`toString`函数中，这样做完全没问题。
- en: 'The next thing to do is to actually emit new JavaScript from this. I''ve taken
    a naïve approach and used regular expressions. This approach would quickly get
    out of hand and probably only works with the well-formed JavaScript in the `Axe`
    class:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的事情是实际上从中发出新的JavaScript。我采取了一种天真的方法，并使用了正则表达式。这种方法很快就会失控，可能只适用于`Axe`类中格式良好的JavaScript：
- en: '[PRE143]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Here we extract the parameters to the function and check for those that have
    the `public` annotation. The result of this function can be passed back into eval
    for use in the current object or written out to a file if we're using this function
    in a pre-processor. Typically use of eval in JavaScript is discouraged.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提取函数的参数并检查具有`public`注释的参数。此函数的结果可以传回到eval中，用于当前对象的使用，或者如果我们在预处理器中使用此函数，则可以写入文件。通常不鼓励在JavaScript中使用eval。
- en: There are tons of different things that can be done using this sort of processing.
    Even without string post-processing there are some interesting programming concept
    we can explore by just wrapping methods.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种处理方式可以做很多不同的事情。即使没有字符串后处理，我们也可以通过包装方法来探索一些有趣的编程概念。
- en: Aspect oriented programming
  id: totrans-911
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向方面的编程
- en: Modularity of software is a great feature, the majority of this book has been
    about modularity and its advantages. However, there are some features of software
    that span the entire system. Security is a great example of this.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 软件的模块化是一个很好的特性，本书的大部分内容都是关于模块化及其优势。然而，软件还有一些跨整个系统的特性。安全性就是一个很好的例子。
- en: 'We would like to have similar security code in all the modules of the application
    to check that people are, in fact, authorized to perform some action. So if we
    have a function of the sort:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在应用程序的所有模块中都有类似的安全代码，以检查人们是否实际上被授权执行某些操作。所以如果我们有这样的一个函数：
- en: '[PRE144]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'We can see that there is a fair bit of code in place to check if a user is
    authorized. This same boilerplate code is used elsewhere in the application. In
    fact, with this being a high security application, the security checks are in
    place in every public function. All is well until we need to make a change to
    the common security code. This change needs to take place in every single public
    function in the application. We can refactor our application all we want, but
    the truth remains: we need to have at least some code in each of the public methods
    to perform a security check. This is known as a cross-cutting concern.'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有相当多的代码来检查用户是否被授权。这个相同的样板代码在应用程序的其他地方也被使用。事实上，由于这是一个高安全性的应用程序，安全检查在每个公共函数中都有。一切都很好，直到我们需要对常见的安全代码进行更改。这个更改需要在应用程序的每一个公共函数中进行。我们可以重构我们的应用程序，但事实仍然存在：我们需要在每个公共方法中至少有一些代码来执行安全检查。这被称为横切关注点。
- en: There are other instances of cross-cutting concerns in most large applications.
    Logging is a great example, as is database access and performance instrumenting.
    **Aspect oriented programming** ( **AOP** ) presents a way to minimize the repeated
    code through a process known as **weaving** .
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数大型应用程序中，还存在其他横切关注点。日志记录是一个很好的例子，数据库访问和性能检测也是如此。**面向方面的编程**（**AOP**）提供了一种通过**编织**过程来最小化重复代码的方式。
- en: 'An aspect is a piece of code that can intercept method calls and change them.
    On the .Net platform there is a tool called PostSharp that does aspect weaving
    and, on the Java platform, one called AspectJ. These tools hook into the build
    pipeline and modify the code after it has been transformed into instructions.
    This allows code to be injected wherever needed. The source code appears unchanged
    but the compiled output now includes calls to the aspect. Aspects solve the cross
    cutting concern by being injected into existing code. Here you can see the application
    of an aspect to a method through a weaver:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 方面是一段可以拦截方法调用并改变它们的代码。在.Net平台上有一个叫做PostSharp的工具可以进行方面编织，在Java平台上有一个叫做AspectJ的工具。这些工具可以钩入构建管道，并在代码被转换为指令后修改代码。这允许在需要的地方注入代码。源代码看起来没有改变，但编译输出现在包括对方面的调用。方面通过被注入到现有代码中来解决横切关注点。在这里，你可以看到通过编织器将一个方面应用到一个方法：
- en: '![Aspect oriented programming](Image00065.jpg)'
  id: totrans-918
  prefs: []
  type: TYPE_IMG
  zh: '![面向方面的编程](Image00065.jpg)'
- en: Of course we don't have the luxury of a design-time compile step in most JavaScript
    workflows. Fortunately, we've already seen some approaches that would allow us
    to implement cross cuts using JavaScript. The first thing we need is the wrapping
    of methods that we saw in the testing chapter. The second is the `tostring` abilities
    from earlier in this chapter.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在大多数JavaScript工作流程中，我们没有设计时编译步骤的奢侈。幸运的是，我们已经看到了一些方法，可以让我们使用JavaScript实现横切。我们需要的第一件事是包装我们在测试章节中看到的方法。第二个是本章前面提到的`tostring`能力。
- en: There are some AOP libraries already in existence for JavaScript that may be
    a good bet to explore. However, we can implement a simple interceptor here. First
    let's decide on the grammar for requesting injection. We'll use the same idea
    of comments from earlier to denote methods that require interception. We'll just
    make the first line in the method a comment that reads `aspect(<name of aspect>)`
    .
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript已经存在一些AOP库，可能是一个值得探索的好选择。然而，我们可以在这里实现一个简单的拦截器。首先让我们决定请求注入的语法。我们将使用之前的注释的想法来表示需要拦截的方法。我们只需要将方法中的第一行作为注释，写上`aspect(<aspect的名称>)`。
- en: 'To start we''ll take a slightly modified version of our same `GoldTransfer`
    class from earlier:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将采用稍微修改过的与之前相同的`GoldTransfer`类的版本：
- en: '[PRE145]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'We''ve stripped out all the security stuff that used to exist in it and added
    a console log so we can see that it actually works. Next we''ll need an aspect
    to weave into it:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经剥离了以前存在的所有安全性内容，并添加了一个控制台日志，以便我们可以看到它实际上是如何工作的。接下来，我们需要一个方面来编织进去：
- en: '[PRE146]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'For this we use a simple class that has a `BeforeCall` and `AfterCall` method,
    one which is called before and one which is called after the original method.
    We don''t need to use eval in this case so the interceptions are safer:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们使用一个简单的类，其中有一个`BeforeCall`和一个`AfterCall`方法，一个在原始方法之前调用，一个在原始方法之后调用。在这种情况下，我们不需要使用eval，所以拦截更安全：
- en: '[PRE147]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: This interceptor can easily be modified to a shortcut and return something before
    the main method body is called. It can also be changed so that the output of the
    function can be modified by simply tracking the output from the wrapped method
    and then modifying it in the `AfterCall` method.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 这个拦截器可以很容易地修改为一个快捷方式，并在调用主方法体之前返回一些内容。它也可以被改变，以便通过简单跟踪包装方法的输出，然后在`AfterCall`方法中修改函数的输出。
- en: This is a fairly lightweight example of AOP. There are some frameworks in existence
    for JavaScript AOP, but perhaps the best approach is to make use of a precompiler
    or macro language.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当轻量级的AOP示例。对于JavaScript AOP已经存在一些框架，但也许最好的方法是利用预编译器或宏语言。
- en: Mixins
  id: totrans-929
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混入
- en: As we saw much earlier in this book, the inheritance pattern for JavaScript
    is different from the typical pattern seen in languages like C# and Java. JavaScript
    uses prototype inheritance that allows adding functions to a class quite easily
    and from multiple sources. Prototype inheritance allows for adding methods from
    multiple sources in a similar fashion to the much-maligned multiple-inheritance.
    The primary criticism of multiple inheritance is that it is difficult to understand
    which overload of a method will be called in a situation. This problem is somewhat
    alleviated in a prototype inheritance model. Thus we can feel comfortable using
    the approach of adding functionality from several sources, which is known as mixins.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书的早期看到的那样，JavaScript的继承模式与C＃和Java等语言中典型的模式不同。JavaScript使用原型继承，允许轻松地向类添加函数，并且可以从多个来源添加。原型继承允许以类似于备受诟病的多重继承的方式从多个来源添加方法。多重继承的主要批评是很难理解在某种情况下将调用哪个方法的重载。在原型继承模型中，这个问题在一定程度上得到了缓解。因此，我们可以放心地使用从多个来源添加功能的方法，这被称为mixin。
- en: A mixin is a chunk of code which can be added to existing classes to expand
    their functionality. They make the most sense in scenarios where the functions
    need to be shared between disparate classes where an inheritance relationship
    is too strong.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: Mixin是一段代码，可以添加到现有类中以扩展其功能。它们在需要在不同的类之间共享函数的场景中最有意义，其中继承关系过于强大。
- en: 'Let''s imagine a scenario where this sort of functionality would be handy.
    In the land of Westeros, death is not always as permanent as in our world. However,
    those who return from the dead may not be exactly as they were when they were
    alive. While much of the functionality is shared between `Person` and `ReanimatedPerson`
    , they are not close enough to have an inheritance relationship. In this code
    you can see the `extend` function of underscore used to add mixins to our two
    people classes. It is possible to do this without `underscore` but, as mentioned
    earlier, there are some complex edge cases around `extends` which make using a
    library handy:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一种情景，这种功能会很方便。在维斯特洛大陆，死亡并不总是像我们的世界那样永久。然而，那些从死者中复活的人可能并不完全与他们活着时一样。虽然`Person`和`ReanimatedPerson`之间共享了很多功能，但它们之间并没有足够的继承关系。在这段代码中，您可以看到underscore的`extend`函数用于向我们的两个人类添加mixin。虽然可以在没有`underscore`的情况下做到这一点，但正如前面提到的，使用库会使一些复杂的边缘情况变得方便：
- en: '[PRE148]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Mixins provide a mechanism to share functionality between diverse objects but
    do pollute the prototype structure.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: Mixin提供了一个在不同对象之间共享功能的机制，但会污染原型结构。
- en: Macros
  id: totrans-935
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏
- en: Preprocessing code through macros is not a new idea. It was, and probably still
    is, very popular for C and C++. In fact, if you take a look at some of the source
    code for the Gnu utilities for Linux they are written almost entirely in macros.
    Macros are notorious for being hard to understand and debug. For a time, newly-created
    languages like Java and C# did not support macros for exactly this reason.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 通过宏预处理代码并不是一个新的想法。对于C和C++来说，这是非常流行的。事实上，如果你看一下Linux的Gnu工具的一些源代码，它们几乎完全是用宏编写的。宏因难以理解和调试而臭名昭著。有一段时间，像Java和C＃这样的新创建的语言之所以不支持宏，正是因为这个原因。
- en: That being said, even more recent languages like Rust and Julia have brought
    the idea of macros back. These languages were influenced by the macros from the
    Scheme language, a dialect of Lisp. The difference between C macros and Lisp/Scheme
    macros is that the C versions are textual while the Lisp/Scheme ones are structural.
    This means that C macros are just glorified find/replace tools while Scheme macros
    are aware of the **abstract syntax tree** ( **AST** ) around them, allowing them
    to be much more powerful.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，甚至像Rust和Julia这样的最新语言也重新引入了宏的概念。这些语言受到了Scheme语言的宏的影响，Scheme是Lisp的一个方言。C宏和Lisp/Scheme宏的区别在于，C版本是文本的，而Lisp/Scheme版本是结构的。这意味着C宏只是被赞美的查找/替换工具，而Scheme宏则意识到它们周围的**抽象语法树**（**AST**），使它们更加强大。
- en: The AST for Scheme is a far simpler construct than that of JavaScript. Nonetheless,
    there is a very interesting project called `Sweet.js` that tries to create structural
    macros for JavaScript.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme的AST比JavaScript的简单得多。尽管如此，有一个非常有趣的项目叫做`Sweet.js`，它试图为JavaScript创建结构宏。
- en: '`Sweet.js` plugs into the JavaScript build pipeline and modified JavaScript
    source code using one or more macros. There are a number of fully-fledged JavaScript
    transpilers, that is compilers that emit JavaScript. These compilers are problematic
    for sharing code between multiple projects. Their code is so different that there
    is no real way to share it. `Sweet.js` supports multiple macros being expanded
    in a single step. This allows for much better code sharing. The reusable bits
    are a smaller size and more easy to run together.'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sweet.js`插入到JavaScript构建管道中，并使用一个或多个宏修改JavaScript源代码。有许多完整的JavaScript转译器，即生成JavaScript的编译器。这些编译器在多个项目之间共享代码时存在问题。它们的代码差异很大，几乎没有真正的共享方式。`Sweet.js`支持在单个步骤中扩展多个宏。这允许更好地共享代码。可重用的部分更小，更容易一起运行。'
- en: 'A simple example of `Sweet.js` is as follows:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sweet.js`的一个简单示例如下：'
- en: '[PRE149]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The macro here provides ECMAScript-2015-style deconstructors that split an array
    into tree fields. The macro matches an array assignment and also regular assignment.
    For regular assignment the macro simply returns the identity, while for assignment
    of an array it will explode the text and replace it.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的宏提供了ECMAScript-2015风格的解构器，将数组分割成三个字段。该宏匹配数组赋值和常规赋值。对于常规赋值，宏只是返回标识，而对于数组的赋值，它将分解文本并替换它。
- en: 'For instance, if you run it over the following:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您在以下内容上运行它：
- en: '[PRE150]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Then, the result will be the following:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，结果将是以下内容：
- en: '[PRE151]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: This is just one example macro. The power of macros is really quite spectacular.
    Macros can create an entirely new language or change very minor things. They can
    be easily plugged in to fit any sided requirement.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个宏的例子。宏的威力真的非常壮观。宏可以创建一个全新的语言或改变非常微小的东西。它们可以很容易地插入以适应任何需求。
- en: Tips and tricks
  id: totrans-948
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技巧和窍门
- en: Using name-based dependency injection allows for conflicts between names. In
    order to avoid conflicts it may be worth prefacing your injected arguments with
    a special character. For instance, AngularJS uses the `$` sign to denote an injected
    term.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于名称的依赖注入允许名称之间发生冲突。为了避免冲突，值得在注入的参数前加上特殊字符。例如，AngularJS使用“$”符号来表示一个注入的术语。
- en: Several times in this chapter I've mentioned the JavaScript build pipeline.
    It may seem odd that we have to build an interpreted language. However, there
    are certain optimizations and process improvements that may result from building
    JavaScript. There are a number of tools that can be used to help building JavaScript.
    Tools such as Grunt and Gulp are specifically designed to perform JavaScript and
    web tasks but you can also make use of traditional build tools such as Rake, Ant,
    or even Make.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我多次提到了JavaScript构建流水线。我们不得不构建一种解释性语言可能看起来有些奇怪。然而，从构建JavaScript可能会产生某些优化和流程改进。有许多工具可以用于帮助构建JavaScript。像Grunt和Gulp这样的工具专门设计用于执行JavaScript和Web任务，但您也可以利用传统的构建工具，如Rake、Ant，甚至是Make。 '
- en: Summary
  id: totrans-951
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we covered a number of advanced JavaScript patterns. Of these
    patterns it's my belief that dependency injection and macros are the most useful
    to us. You may not necessarily want to use them on every project. When approaching
    problems simply being aware of the possible solutions may change your approach
    to the problem.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多高级JavaScript模式。在这些模式中，我相信依赖注入和宏对我们最有用。您可能并不一定希望在每个项目中都使用它们。当面对问题时，仅仅意识到可能的解决方案可能会改变您对问题的处理方式。
- en: Throughout this book I have talked extensively about the next versions of JavaScript.
    However, you don't need to wait until some future time to make use of many of
    these tools. Today, there are ways to compile newer versions of JavaScript down
    to the current version of JavaScript. The final chapter will explore a number
    of these tools and techniques.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我广泛讨论了JavaScript的下一个版本。然而，您不需要等到将来才能使用这些工具。今天，有方法可以将较新版本的JavaScript编译成当前版本的JavaScript。最后一章将探讨一些这样的工具和技术。
- en: Chapter 14. ECMAScript-2015/2016 Solutions Today
  id: totrans-954
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。ECMAScript-2015/2016解决方案今天
- en: I cannot count the number of times I have mentioned upcoming versions of JavaScript
    in this book, rest assured that it's a large number. It is somewhat frustrating
    that the language is not keeping pace with the requirements of application developers.
    Many of the approaches we've discussed become unnecessary with a newer version
    of JavaScript. There are, however, some ways to get the next version of JavaScript
    working today.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我无法计算提到JavaScript即将推出的版本的次数，可以放心，这个数字很大。令人有些沮丧的是，语言没有跟上应用程序开发人员的要求。我们讨论过的许多方法在JavaScript的新版本中变得不再必要。然而，有一些方法可以让下一个版本的JavaScript在今天就能运行。
- en: 'In this chapter we''ll look at a couple of these, specifically:'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点讨论其中的一些：
- en: Typescript
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript
- en: BabelJS
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BabelJS
- en: TypeScript
  id: totrans-959
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript
- en: There is no shortage of languages that compile to JavaScript. CoffeeScript is
    perhaps the best known example of one of these languages, although the Google
    web toolkit that compiles Java to JavaScript was also once very popular. Never
    ones to be left behind or use somebody else's solution, Microsoft released a language
    called TypeScript in 2012\. It is designed to be a superset of JavaScript in the
    same way that C++ is a superset of C. This means that all syntactically valid
    JavaScript code is also syntactically valid TypeScript code.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 编译成JavaScript的语言并不少。CoffeeScript可能是这些语言中最知名的一个例子，尽管将Java编译成JavaScript的Google
    Web Toolkit也曾经非常流行。微软在2012年发布了一种名为TypeScript的语言，以设计成JavaScript的超集，就像C++是C的超集一样。这意味着所有语法上有效的JavaScript代码也是TypeScript代码。
- en: Microsoft itself is making heavy use of TypeScript in some of its larger web
    properties. Both Office 365 and Visual Studio Online have significant code bases
    written in TypeScript. These projects actually predate TypeScript by a significant
    margin. The transition from JavaScript to TypeScript was reportedly quite easy
    due to the fact that it is a superset of JavaScript.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 微软自身在一些较大的网络属性中大量使用TypeScript。Office 365和Visual Studio Online都有大量用TypeScript编写的代码库。这些项目实际上早于TypeScript很长时间。据报道，从JavaScript过渡到TypeScript相当容易，因为它是JavaScript的超集。
- en: One of the design goals for TypeScript was to make it as compatible as possible
    with ECMAScript-2015 and future versions. This means that TypeScript supports
    some, although certainly not all, of the features of ECMAScript-2016, as well
    as a healthy chunk of ECMAScript-2015\. Two significant features from ECMAScript-2016
    which are partially supported by Typescript are decorators and async/await.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的设计目标之一是尽可能与ECMAScript-2015和未来版本兼容。这意味着TypeScript支持ECMAScript-2016的一些特性，尽管当然不是全部，以及ECMAScript-2015的大部分特性。TypeScript部分支持的ECMAScript-2016的两个重要特性是装饰器和async/await。
- en: Decorators
  id: totrans-963
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: 'In an earlier chapter we explored **aspect oriented programming** ( **AOP**
    ). With AOP we wrap function with interceptors. Decorators offer an easy way of
    doing this. Let''s say that we have a class which dispatches messages in Westeros.
    Obviously there are no phones or internet there, so messages are dispatched via
    crows. It would be very helpful if we could spy on these messages. Our `CrowMessenger`
    class looks like the following:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 在早些章节中，我们探讨了**面向方面的编程**（**AOP**）。使用AOP，我们用拦截器包装函数。装饰器提供了一种简单的方法来做到这一点。假设我们有一个在维斯特洛传递消息的类。显然，那里没有电话或互联网，因此消息是通过乌鸦传递的。如果我们能监视这些消息将会非常有帮助。我们的`CrowMessenger`类看起来像下面这样：
- en: '[PRE152]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'You may note the `@spy` annotation on the `SendMessage` method. This is simply
    another function which intercepts and wraps the function. Inside of the spy we
    have access to the function descriptor. As you can see in the following code,
    we take the descriptor and manipulate it to capture the argument sent to the `CrowMessenger`
    class:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到`SendMessage`方法上的`@spy`注释。这只是另一个拦截和包装函数的函数。在spy内部，我们可以访问函数描述符。正如您在以下代码中所看到的，我们获取描述符并操纵它以捕获发送到`CrowMessenger`类的参数：
- en: '[PRE153]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Spys would obviously be very useful for testing functions. Not only can we
    spy on the values here but we could replace the input and output to the function.
    Consider the following:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍显然对于测试函数非常有用。我们不仅可以在这里监视值，还可以替换函数的输入和输出。考虑以下内容：
- en: '[PRE154]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Decorators can be used for purposes other than AOP. For instance, you could
    annotate the properties on an object as serializable and use the annotations to
    control custom JSON serialization. It is my suspicion that decorators will become
    more useful and powerful as decorators become supported. Already Angular 2.0 is
    making extensive use of decorators.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器可以用于除AOP之外的其他目的。例如，您可以将对象的属性注释为可序列化，并使用注释来控制自定义JSON序列化。我怀疑随着装饰器的支持，装饰器将变得更加有用和强大。已经有Angular
    2.0在大量使用装饰器。
- en: Async/Await
  id: totrans-971
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步/等待
- en: 'In [Chapter 7](text00067.html#page "Chapter 7. Reactive Programming") , *Reactive
    Programming* , we spoke about how the callback nature of JavaScript programming
    makes code very confusing. Nowhere is this more apparent than trying to chain
    together a series of asynchronous events. We rapidly fall into a trap of code,
    which looks like the following:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](text00067.html#page "第7章. 反应式编程")中，*反应式编程*，我们谈到了JavaScript编程的回调性质使代码非常混乱。尝试将一系列异步事件链接在一起时，这一点表现得更加明显。我们很快陷入了一个看起来像下面这样的代码陷阱：
- en: '[PRE155]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Not only is this code difficult to read, it is nearly impossible to understand.
    The async/await syntax, which is borrowed from C#, allows for writing your code
    in a much more succinct fashion. Behind the scenes generators are used (or abused,
    if you like) to create the impression of true async/await. Let''s look at an example.
    In the preceding code we made use of the geolocation API which returns the location
    of a client. It is asynchronous as it performs some IO with the user''s machine
    to get a real world location. Our specification calls for us to get the user''s
    location, post it back to the server, and then get an image:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不仅难以阅读，而且几乎不可能理解。从C#借鉴的异步/等待语法允许以更简洁的方式编写代码。在幕后，使用（或滥用，如果您愿意）生成器来创建真正的异步/等待的印象。让我们看一个例子。在前面的代码中，我们使用了返回客户端位置的地理位置API。它是异步的，因为它与用户的机器进行一些IO以获取真实世界的位置。我们的规范要求我们获取用户的位置，将其发送回服务器，然后获取图像：
- en: '[PRE156]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'If we now introduce async/await, this can become the following:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在引入异步/等待，代码可以变成以下形式：
- en: '[PRE157]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: This code assumes that all `async` responses return promises which are a construct
    that contains a status and a result. As it stands, most `async` operations do
    not return promises but there are libraries and utilities to convert callbacks
    to promises. As you can see, the syntax is much cleaner and easier to follow than
    the callback mess.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码假设所有`async`响应都返回包含状态和结果的promise构造。事实上，大多数`async`操作并不返回promise，但有库和工具可以将回调转换为promise。正如您所看到的，这种语法比回调混乱要清晰得多，更容易理解。
- en: Typing
  id: totrans-979
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: 'As well as the ECMAScript-2016 features we''ve mentioned in the preceding section,
    TypeScript has a rather intriguing typing system incorporated into it. One of
    the nicest parts of JavaScript is that it is a dynamically typed language. We''ve
    seen, repeatedly, how, not being burdened by types has saved us time and code.
    The typing system in TypeScript allows you to use as much or as little typing
    as you deem to be necessary. You can give variables a type by declaring them with
    the following syntax:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在前一节中提到的ECMAScript-2016功能之外，TypeScript还具有一个非常有趣的类型系统。JavaScript最好的部分之一是它是一种动态类型语言。我们反复看到，不受类型负担的好处节省了我们的时间和代码。TypeScript中的类型系统允许您根据需要使用尽可能多或尽可能少的类型。您可以使用以下语法声明变量的类型：
- en: '[PRE158]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Once a variable has a type assigned to it, the TypeScript compiler will use
    that not only to check that variable''s usage, but also to infer what other types
    may be derived from that class. For example, consider the following code:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦变量被分配了一个类型，TypeScript编译器将使用它不仅来检查该变量的使用情况，还将推断出可能从该类派生的其他类型。例如，考虑以下代码：
- en: '[PRE159]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Here, the TypeScript compiler will know that `unknown` is a number. If you
    attempt to use it as something else, say as the following string:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，TypeScript编译器将知道`unknown`是一个数字。如果您尝试将其用作其他类型，比如以下字符串：
- en: '[PRE160]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Then the compiler will throw an error. However, you don't need to assign a type
    to any variable. This means that you can tune the degree to which the type checking
    is run. While it sounds odd, it is actually a brilliant solution for introducing
    the rigour of type checking without losing the pliability of JavaScript. The typing
    is only enforced during compilation, once the code is compiled to JavaScript,
    any hint that there was typing information associated with a field disappears.
    As a result, the emitted JavaScript is actually very clean.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编译器会抛出一个错误。然而，你不需要为任何变量分配类型。这意味着你可以调整类型检查的程度。虽然听起来很奇怪，但实际上这是一个很好的解决方案，可以在不失去JavaScript的灵活性的情况下引入类型检查的严谨性。类型只在编译期间强制执行，一旦代码编译成JavaScript，与字段相关的类型信息的任何提示都会消失。因此，生成的JavaScript实际上非常干净。
- en: If you're interested in typing systems and know words like contravariant and
    can discuss the various levels of gradual typing, then TypeScript's typing system
    may be well worth your time to investigate.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对类型系统感兴趣，知道逆变等词汇，并且可以讨论逐渐类型的各个层次，那么TypeScript的类型系统可能值得你花时间去研究。
- en: All the examples in this book were originally written in TypeScript and then
    compiled to JavaScript. This was done to improve the accuracy of the code and
    generally to save me from messing up quite so frequently. I'm horribly biased
    but I think that TypeScript is really well done and certainly better than writing
    pure JavaScript.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例最初都是用TypeScript编写的，然后编译成JavaScript。这样做是为了提高代码的准确性，通常也是为了让我不那么频繁地搞砸。我非常偏袒，但我认为TypeScript做得非常好，肯定比纯JavaScript写得好。
- en: There is no support for typing in future versions of JavaScript. Thus, even
    with all the changes coming to future versions of JavaScript, I still believe
    that TypeScript has its place in providing compile time type checking. I never
    cease to be amazed by the number of times that the type checker has saved me from
    making silly mistakes when writing TypeScript.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 未来版本的JavaScript中不支持类型。因此，即使未来版本的JavaScript带来了许多变化，我仍然相信TypeScript在提供编译时类型检查方面有其存在的价值。每当我写TypeScript时，类型检查器总是让我惊讶，因为它多次帮我避免了愚蠢的错误。
- en: BabelJS
  id: totrans-990
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BabelJS
- en: An alternative to TypeScript is to use the BabelJS compiler. This is an open
    source project ECMAScript-2015 and beyond to the equivalent ECMAScript 5 JavaScript.
    A lot of the changes put in place for ECMAScript-2015 are syntactic niceties,
    so they can actually be represented in ECMAScript 5 JavaScript, although not as
    succinctly or as pleasantly. We've seen that already using class-like structures
    in ES 5\. BabelJS is written in JavaScript, which means that the compilation from
    ECMAScript-2015 to ES 5 is possible directly on a web page. Of course, as seems
    to be the trend with compilers, the source code for BabelJS makes use of ES 6
    constructs, so BabelJS must be used to compile BabelJS.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的另一种选择是使用BabelJS编译器。这是一个开源项目，用于将ECMAScript-2015及更高版本转换为等效的ECMAScript
    5 JavaScript。ECMAScript-2015中的许多更改都是语法上的美化，因此它们实际上可以表示为ECMAScript 5 JavaScript，尽管不像那么简洁或令人愉悦。我们已经看到在ES
    5中使用类似类的结构。BabelJS是用JavaScript编写的，这意味着可以直接在网页上从ECMAScript-2015编译到ES 5。当然，与编译器的趋势一样，BabelJS的源代码使用了ES
    6构造，因此必须使用BabelJS来编译BabelJS。
- en: 'At the time of writing, the list of ES6 functions that are supported by BabelJS
    are extensive:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，BabelJS支持的ES6函数列表非常广泛：
- en: Arrow functions
  id: totrans-993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Classes
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Computed property names
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算属性名称
- en: Default parameters
  id: totrans-996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认参数
- en: Destructuring assignment
  id: totrans-997
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构赋值
- en: Iterators and for of
  id: totrans-998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器和for of
- en: Generator comprehension
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器理解
- en: Generators
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: Modules
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Numeric literals
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字文字
- en: Property method assignment
  id: totrans-1003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性方法赋值
- en: Object initializer shorthand
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象初始化程序简写
- en: Rest parameters
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余参数
- en: Spread
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展
- en: Template literals
  id: totrans-1007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板文字
- en: Promises
  id: totrans-1008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺
- en: BabelJS is multi-purpose JavaScript compiler, so compiling ES-2015 code is simply
    one of the many things it can do. There are numerous plugins which provide a wide
    array of interesting functionality. For instance, the "Inline environmental variable"
    plugin inserts compile time variables, allowing for conditional compilation based
    on environments.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: BabelJS是一个多用途的JavaScript编译器，因此编译ES-2015代码只是它可以做的许多事情之一。有许多插件提供各种有趣的功能。例如，“内联环境变量”插件插入编译时变量，允许根据环境进行条件编译。
- en: There is already a fair bit of documentation available on how each of these
    features work so we won't go over all of them.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有大量关于这些功能如何工作的文档可用，因此我们不会详细介绍它们。
- en: 'Setting up Babel JS is a fairly simple exercise if you already have node and
    npm installed:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经安装了node和npm，那么设置Babel JS就是一个相当简单的练习：
- en: '[PRE161]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'This will create a BabelJS binary which can do compilation like so:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个BabelJS二进制文件，可以进行编译，如下所示：
- en: '[PRE162]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: For most use cases you'll want to investigate using build tools such as Gulp
    or Grunt, which can compile many files at once and perform any number of post-compilation
    steps.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数用例，您将希望使用构建工具，如Gulp或Grunt，它们可以一次编译多个文件，并执行任意数量的后编译步骤。
- en: Classes
  id: totrans-1016
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: By now you should be getting sick of reading about different ways to make classes
    in JavaScript. Unfortunately for you I'm the one writing this book so let's look
    at one final example. We'll use the same castle example from earlier.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经厌倦了阅读关于在JavaScript中创建类的不同方法。不幸的是，你是我写这本书的人，所以让我们看一个最后的例子。我们将使用之前的城堡例子。
- en: Modules within files are not supported in BabelJS. Instead, files are treated
    as modules, which allows for dynamic loading of modules in a fashion not unlike
    `require.js` . Thus we'll drop the module definition from our castle and stick
    to just the classes. One other feature that exists in TypeScript and not ES 6
    is prefacing a parameter with `public` to make it a public property on a class.
    Instead we make use of the `export` directive.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: BabelJS不支持文件内的模块。相反，文件被视为模块，这允许以一种类似于`require.js`的方式动态加载模块。因此，我们将从我们的堡垒中删除模块定义，只使用类。TypeScript中存在但ES
    6中不存在的另一个功能是使用`public`作为参数前缀，使其成为类的公共属性。相反，我们使用`export`指令。
- en: 'Once we''ve made these changes, the source ES6 file looks like the following:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们做出了这些更改，源ES6文件看起来像这样：
- en: '[PRE163]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The resulting ES 5 JavaScript looks like the following:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的ES 5 JavaScript看起来像这样：
- en: '[PRE164]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Right away it is apparent that the code produced by BabelJS is not as clean
    as the code from TypeScript. You may also have noticed that there are some helper
    functions employed to handle inheritance scenarios. There are also a number of
    mentions of `"use strict";` . This is an instruction to the JavaScript engine
    that it should run in strict mode.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 立即就会发现，BabelJS生成的代码不如TypeScript中的代码干净。您可能还注意到有一些辅助函数用于处理继承场景。还有许多提到`"use strict";`。这是对JavaScript引擎的指示，它应该以严格模式运行。
- en: 'Strict mode prevents a number of dangerous JavaScript practices. For instance,
    in some JavaScript interpreters it is legal to use a variable without declaring
    it first:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式阻止了许多危险的JavaScript实践。例如，在一些JavaScript解释器中，可以在不事先声明变量的情况下使用它是合法的：
- en: '[PRE165]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'This will throw an error if `x` has not previously been declared:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`x`之前未声明，这将抛出错误：
- en: '[PRE166]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Duplicating properties in objects is disallowed, as well as double declaring
    a parameter. There are a number of other practises that `"use strict";` will treat
    as errors. I like to think of `"use strict";` as being similar to treating all
    warnings as errors. It isn't, perhaps, as complete as `–Werror` in GCC but it
    is still a good idea to use strict mode on new JavaScript code bases. BabelJS
    simply enforces that for you.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许在对象中复制属性，也不允许重复声明参数。还有许多其他实践方法，`"use strict";`会将其视为错误。我认为`"use strict";`类似于将所有警告视为错误。它可能不像GCC中的`-Werror`那样完整，但在新的JavaScript代码库中使用严格模式仍然是一个好主意。BabelJS只是为您强制执行这一点。
- en: Default parameters
  id: totrans-1029
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数
- en: Not a huge feature but a real nicety in ES 6 is the introduction of default
    parameters. It has always been possible to call a function in JavaScript without
    specifying all the parameters. Parameters are simply populated from left to right
    until there are no more values and all remaining parameters are given undefined.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: ES 6中一个不是很重要但确实很好的功能是默认参数的引入。在JavaScript中一直可以调用函数而不指定所有参数。参数只是从左到右填充，直到没有更多的值，并且所有剩余的参数都被赋予undefined。
- en: 'Default parameters allow setting a value other than undefined for parameters
    that aren''t filled out:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数允许为未填充的参数设置一个值，而不是undefined：
- en: '[PRE167]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'This will output the following:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE168]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'The JavaScript code produced is actually very simple:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的JavaScript代码实际上非常简单：
- en: '[PRE169]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Template literals
  id: totrans-1037
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板文字
- en: 'On the surface, template literals seem to be a solution for the lack of string
    interpolation in JavaScript. In some languages, such as Ruby and Python, you can
    inject substitutions from the surrounding code directly into a string without
    having to pass them into some sort of string formatting function. For instance,
    in Ruby you can do the following:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，模板文字似乎是解决JavaScript中缺乏字符串插值的解决方案。在某些语言中，比如Ruby和Python，您可以直接将周围代码中的替换插入到字符串中，而无需将它们传递给某种字符串格式化函数。例如，在Ruby中，您可以执行以下操作：
- en: '[PRE170]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This will bind the `${name}` parameter to the name from the surrounding scope.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`${name}`参数绑定到周围范围内的名称。
- en: 'ES6 supports template literals that allow something similar in JavaScript:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: ES6支持模板文字，允许在JavaScript中实现类似的功能：
- en: '[PRE171]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'It may be difficult to see but that string is actually surrounded by backticks
    and not quotation marks. Tokens to bind to the scope are denoted by `${}` . Within
    the braces you can put complex expressions such as:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 可能很难看到，但该字符串实际上是用反引号而不是引号括起来的。要绑定到作用域的标记由`${}`表示。在大括号内，您可以放置复杂的表达式，例如：
- en: '[PRE172]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'The BabelJS compiled version of this code simply substitutes appending strings
    for the string interpolation:'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的BabelJS编译版本只是简单地用字符串拼接来替代字符串插值：
- en: '[PRE173]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Template literals also solve a number of other problems. New line characters
    inside of a template literal are legal, meaning that you can use template literals
    to create multiline strings.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 模板文字还解决了许多其他问题。模板文字内部的换行符是合法的，这意味着您可以使用模板文字来创建多行字符串。
- en: 'With the multiline string idea in mind, it seems like template literals might
    be useful for building domain specific languages: a topic we''ve seen a number
    of times already. The DSL can be embedded in a template literal and then values
    from outside plugged in. An example might be using it to hold HTML strings (certainly
    a DSL) and inserting values in from a model. These could, perhaps, take the place
    of some of the template tools in use today.'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到多行字符串的想法，模板文字似乎对构建特定领域语言很有用：这是我们已经多次看到的一个主题。DSL可以嵌入到模板文字中，然后从外部插入值。例如，可以使用它来保存HTML字符串（当然是DSL）并从模型中插入值。这些可能取代今天使用的一些模板工具。
- en: Block bindings with let
  id: totrans-1049
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用let进行块绑定
- en: 'The scoping of variables in JavaScript is weird. If you define a variable inside
    a block, say inside an `if` statement, then that variable is still available outside
    of the block. For example, see the following code:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的变量作用域很奇怪。如果在块内定义变量，比如在`if`语句内部，那么该变量仍然可以在块外部使用。例如，看下面的代码：
- en: '[PRE174]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: This code will print `9` , even though the variable outside is clearly out of
    scope. At least it is out of scope if you assume that JavaScript is like other
    C-syntax languages and supports block level scoping. The scoping in JavaScript
    is actually function level. Variables declared in code blocks like those found
    attached to `if` and `for` loop statements are hoisted to the beginning of the
    function. This means that they remain in scope for the entirety of the function.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将打印`9`，即使外部变量显然超出了范围。至少如果你假设JavaScript像其他C语法语言一样支持块级作用域，那么它就超出了范围。JavaScript中的作用域实际上是函数级的。在`if`和`for`循环语句附加的代码块中声明的变量被提升到函数的开头。这意味着它们在整个函数的范围内保持有效。
- en: ES 6 introduces a new keyword, `let` , which scopes variables to the block level.
    This sort of variable is ideal for use in loops or to maintain proper variable
    values inside an `if` statement. Traceur implements support for block scoped variables.
    However, the support is experimental at the moment due to performance implications.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: ES 6引入了一个新关键字`let`，它将变量的作用域限制在块级。这种类型的变量非常适合在循环中使用，或者在`if`语句中保持正确的变量值。Traceur实现了对块级作用域变量的支持。然而，由于性能影响，目前该支持是实验性的。
- en: 'Consider the following code:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE175]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'This will compile to the following:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译为以下内容：
- en: '[PRE176]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: You can see that the inner variable is replaced with a renamed one. Once outside
    the block, the variable is no longer replaced. Running this code will report that
    inside is undefined when the `console.log` method occurs.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到内部变量被替换为重命名的变量。一旦离开代码块，变量就不再被替换。运行这段代码时，当`console.log`方法发生时，内部变量将报告为未定义。
- en: In production
  id: totrans-1059
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在生产中
- en: BabelJS is a very powerful tool for replicating many of the structures and features
    of the next version of JavaScript today. However, the code generated is never
    going to be quite as efficient as having native support for the constructs. It
    may be worth benchmarking the generated code to ensure that it continues to meet
    the performance requirements of your project.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: BabelJS是一个非常强大的工具，可以在今天复制下一个版本的JavaScript的许多结构和特性。然而，生成的代码永远不会像原生支持这些结构那样高效。值得对生成的代码进行基准测试，以确保它继续满足项目的性能要求。
- en: Tips and tricks
  id: totrans-1061
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技巧和窍门
- en: 'There are two excellent libraries for working with collections functionally
    in JavaScript: Underscore.js and Lo-Dash. Used in combination with TypeScript
    or BabelJS they have a very pleasant syntax and provide immense power.'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中有两个优秀的库可以在集合功能上进行函数式操作：Underscore.js和Lo-Dash。与TypeScript或BabelJS结合使用时，它们具有非常愉快的语法，并提供了巨大的功能。
- en: 'For instance, finding all the members of a collection that satisfy a condition
    using Underscore looks like the following:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用Underscore查找满足条件的集合成员的所有成员看起来像下面这样：
- en: '[PRE177]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: This code will find all the items where the ID is greater than `3` .
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将找到所有ID大于`3`的项目。
- en: Either of these libraries is one of the first things I add to a new project.
    Underscore is actually bundled with backbone.js, an MVVM framework.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个库中的任何一个都是我在新项目中添加的第一件事。Underscore实际上已经与backbone.js捆绑在一起，这是一个MVVM框架。
- en: Tasks for Grunt and Gulp exist for compiling code written in TypeScript or BabelJS.
    There is, of course, also good support for TypeScript in much of Microsoft's development
    tool chain, although BabelJS is currently not supported directly.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt和Gulp的任务用于编译用TypeScript或BabelJS编写的代码。当然，微软的开发工具链中也对TypeScript有很好的支持，尽管BabelJS目前没有直接支持。
- en: Summary
  id: totrans-1068
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As the functionality of JavaScript expands, the need for third party frameworks
    and even transpilers starts to drop off. The language itself replaces many of
    these tools. The end game for tools like jQuery is that they are no longer required
    as they have been absorbed into the ecosystem. For many years the velocity of
    web browsers has been unable to keep pace with the rate of change of people's
    desires.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 随着JavaScript功能的扩展，对第三方框架甚至转译器的需求开始减少。语言本身取代了许多这些工具。像jQuery这样的工具的最终目标是它们不再需要，因为它们已经被吸收到生态系统中。多年来，Web浏览器的速度一直无法跟上人们愿望变化的速度。
- en: There is a large effort behind the next version of AngularJS but great efforts
    are being made to align the new components with the upcoming web component standards.
    Web components won't fully replace AngularJS but Angular will end up simply enhancing
    web components.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS的下一个版本背后有很大的努力，但正在努力使新组件与即将到来的Web组件标准保持一致。Web组件不会完全取代AngularJS，但Angular最终将简单地增强Web组件。
- en: Of course the idea that there won't be a need for any frameworks or tools is
    ridiculous. There is always going to be a new method of solving a problem and
    new libraries and frameworks will show up. The opinions of people on how to solve
    problems is also going to differ. That's why there is space in the market for
    the wide variety of MVVM frameworks that exist.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，认为不需要任何框架或工具的想法是荒谬的。总会有新的解决问题的方法和新的库和框架出现。人们对如何解决问题的看法也会有所不同。这就是为什么市场上存在各种各样的MVVM框架的原因。
- en: Working with JavaScript can be a much more pleasant experience if you make use
    of ES6 constructs. There are a couple of possible approaches to doing so, which
    of these is best suited to your specific problem is a matter for closer investigation.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用ES6构造来处理JavaScript，那么工作将会更加愉快。有几种可能的方法来做到这一点，哪种方法最适合您的具体问题是需要更仔细调查的问题。
