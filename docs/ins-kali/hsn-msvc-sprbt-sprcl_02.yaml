- en: Introduction to Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务简介
- en: This book does not blindly praise microservices. Instead, it's about how we
    can use their benefits while being able to handle the challenges of building scalable,
    resilient, and manageable microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书并不盲目赞扬微服务。相反，它是关于我们如何利用它们的优势，同时能够处理构建可扩展、有弹性和可管理的微服务的挑战。
- en: 'As an introduction to this book, the following topics will be covered in this
    chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本书的介绍，本章将涵盖以下主题：
- en: How I learned about microservices and what experience I have of their benefits
    and challenges
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是如何了解微服务以及我对其优势和挑战的经验
- en: What is a microservice-based architecture?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于微服务的架构是什么？
- en: Challenges with microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的挑战
- en: Design patterns for handling challenges
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理挑战的设计模式
- en: Software enablers that can help us handle these challenges
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以帮助我们处理这些挑战的软件支持者
- en: Other important considerations that aren't covered in this book
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书未涵盖的其他重要考虑因素
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: No installations are required for this chapter. However, you may be interested
    in taking a look at the C4 model conventions, [https://c4model.com](https://c4model.com),
    since the illustrations in this chapter are inspired by the C4 model.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不需要安装。但是，您可能会对查看C4模型约定感兴趣，[https://c4model.com](https://c4model.com)，因为本章中的插图是受C4模型启发的。
- en: This chapter does not contain any source code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不包含任何源代码。
- en: My way into microservices
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我对微服务的了解
- en: When I first learned about the concept of microservices back in 2014, I realized
    that I had been developing microservices (well, kind of) for a number of years
    without knowing it was microservices I was dealing with. I was involved in a project
    that started in 2009 where we developed a platform based on a set of separated
    features. The platform was delivered to a number of customers that deployed it
    on-premise. To make it easy for the customers to pick and choose what features
    they wanted to use from the platform, each feature was developed as an **autonomous
    software component**; that is, it had its own persistent data and only communicated
    with other components using well-defined APIs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在2014年第一次了解到微服务的概念时，我意识到我在处理微服务（嗯，有点像）多年了，而不知道我在处理的是微服务。我参与了一个从2009年开始的项目，我们开发了一个基于一组分离功能的平台。该平台交付给了许多部署在本地的客户。为了让客户能够轻松地从平台中选择他们想要使用的功能，每个功能都被开发为一个**自主软件组件**；也就是说，它有自己的持久数据，并且只使用明确定义的API与其他组件通信。
- en: 'Since I can''t discuss specific features in this project''s platform, I have
    generalized the names of the components, which are labeled from **Component A** to
    **Component F**. The composition of the platform into a set of components is illustrated
    as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我不能在这个项目的平台中讨论具体的功能，我已经将组件的名称概括为从**组件A**到**组件F**。平台的组成被分解为一组组件，如下图所示：
- en: '![](img/a28adfee-5ac7-4006-8bc9-ca0bd3ce0688.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a28adfee-5ac7-4006-8bc9-ca0bd3ce0688.png)'
- en: 'Each component is developed using Java and the Spring Framework, and is packaged
    as a WAR file and deployed as a web app in a Java EE web container, for example,
    Apache Tomcat. Depending on the customer''s specific requirements, the platform
    can be deployed on single or multiple servers. A two-node deployment may look
    as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都是使用Java和Spring框架开发的，并且打包为WAR文件，并部署为Java EE Web容器中的Web应用程序，例如Apache Tomcat。根据客户的具体要求，该平台可以部署在单个或多个服务器上。两节点部署可能如下所示：
- en: '![](img/e608abe5-c594-4079-8523-6f56e88ae3b3.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e608abe5-c594-4079-8523-6f56e88ae3b3.png)'
- en: Benefits of autonomous software components
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自主软件组件的好处
- en: 'Decomposing the platform''s functionality into a set of autonomous software
    components provides a number of benefits:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将平台功能分解为一组自主软件组件提供了许多好处：
- en: A customer can deploy parts of the platform in its own system landscape, integrating
    it with its existing systems using its well-defined APIs.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户可以在其自己的系统景观中部署平台的部分，并使用其明确定义的API将其集成到现有系统中。
- en: 'The following is an example where one customer decided to deploy **Component
    A**, **Component ****B**, **Component ****D**, and **Component ****E** from the
    platform and integrate them with two existing systems in the customer''s system
    landscape, **System A** and **System B**:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子，一个客户决定从平台中部署**组件A**、**组件B**、**组件D**和**组件E**，并将它们与客户系统景观中的两个现有系统**系统A**和**系统B**集成：
- en: '![](img/d9c37999-c0e3-4121-9cf8-0fbc0053acc1.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9c37999-c0e3-4121-9cf8-0fbc0053acc1.png)'
- en: 'Another customer can choose to replace parts of the platform''s functionality
    with implementations that already exist in the customer''s system landscape, potentially
    requiring some adoption of the existing functionality in the platform''s APIs.
    The following is an example where a customer has replaced **Component C** and
    **Component F** in the platform with their own implementation:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个客户可以选择用现有的系统景观中已经存在的实现来替换平台功能的部分，可能需要对平台的API中的现有功能进行一些采用。以下是一个例子，客户已经用自己的实现替换了平台中的**组件C**和**组件F**：
- en: '![](img/ec70e06b-72fc-4582-8598-23b2be9da9b2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec70e06b-72fc-4582-8598-23b2be9da9b2.png)'
- en: Each component in the platform can be delivered and upgraded separately. Thanks
    to using well-defined APIs, one component can be upgraded to a new version without
    being dependent on the life cycle of the other components.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台中的每个组件可以单独交付和升级。由于使用了明确定义的API，一个组件可以升级到新版本，而不依赖于其他组件的生命周期。
- en: 'The following is an example where **Component A** has been upgraded from version
    **v1.1** to **v1.2**. **Component B**, which calls **Component A**, does not need
    to be upgraded since it uses a well-defined API; that is, it''s still the same
    after the upgrade (or it''s at least backward-compatible):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子，**组件A**已经从版本**v1.1**升级到**v1.2**。调用**组件A**的**组件B**不需要升级，因为它使用了明确定义的API；也就是说，在升级后它仍然是相同的（或者至少是向后兼容的）：
- en: '![](img/a8e582ba-86f5-4a7a-9549-b74de17dc705.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8e582ba-86f5-4a7a-9549-b74de17dc705.png)'
- en: 'Thanks to the use of well-defined APIs, each component in the platform can
    also be scaled out to multiple servers independently of the other components.
    Scaling can be done either to meet high availability requirements or to handle
    higher volumes of requests. Technically, this is achieved by *manually* setting
    up load balancers in front of a number of servers, each running a Java EE web
    container. An example where **Component A** has been scaled out to three instances
    looks as follows:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于使用了明确定义的API，平台中的每个组件也可以独立于其他组件扩展到多个服务器。扩展可以是为了满足高可用性要求，也可以是为了处理更高的请求量。从技术上讲，这是通过在一些服务器前手动设置负载均衡器来实现的，每个服务器都运行着一个Java
    EE web容器。一个例子是**组件A**已经扩展到了三个实例：
- en: '![](img/693e8127-e343-4ea8-94fa-14488f1a1673.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/693e8127-e343-4ea8-94fa-14488f1a1673.png)'
- en: Challenges with autonomous software components
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自治软件组件的挑战
- en: 'We also learned that decomposing the platform introduced a number of new challenges
    that we were not exposed (at least not to the same degree) when developing more
    traditional, monolithic applications:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，分解平台引入了一些新的挑战，这些挑战在开发更传统的单片应用时我们并没有暴露出来（至少没有到同样的程度）：
- en: Adding new instances to a component required manually configuring load balancers
    and manually setting up new nodes. This work was both time-consuming and error-prone.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向组件添加新实例需要手动配置负载均衡器和手动设置新节点。这项工作既耗时又容易出错。
- en: The platform was initially prone to errors in the other systems it was communicating
    with. If a system stopped responding to requests that were sent from the platform
    in a timely fashion, the platform quickly ran out of crucial resources, for example,
    OS threads, specifically when exposed to a large number of concurrent requests.
    This caused components in the platform to hang or even crash. Since most of the
    communication in the platform is based on synchronous communication, one component
    crashing can lead to cascading failures; that is, clients of the crashing components
    could also crash after a while. This is known as a **chain of failures**.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台最初容易出现与其通信的其他系统的错误。如果一个系统停止及时响应平台发送的请求，平台很快就会耗尽关键资源，例如操作系统线程，特别是在面对大量并发请求时。这导致平台中的组件挂起甚至崩溃。由于平台中大部分通信是基于同步通信，一个组件崩溃可能导致级联故障；也就是说，崩溃组件的客户端在一段时间后也可能崩溃。这被称为**故障链**。
- en: Keeping the configuration consistent and up to date in all the instances of
    the components quickly became a problem, causing a lot of manual and repetitive
    work. This led to quality problems from time to time.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持所有组件实例中的配置一致和及时更新很快成为一个问题，导致大量手动和重复的工作。这有时会导致质量问题。
- en: Monitoring the state of the platform in terms of latency issues and hardware
    usage (for example, usage of CPU, memory, disks, and the network) was more complicated
    compared to monitoring a single instance of a monolithic application.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控平台的状态，例如延迟问题和硬件使用情况（例如CPU、内存、磁盘和网络的使用）比监控单片应用的单个实例更加复杂。
- en: Collecting log files from a number of distributed components and correlating
    related log events from the components was also difficult but feasible since the
    number of components was fixed and known in advance.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个分布式组件收集日志文件并关联组件的相关日志事件也很困难，但是可行，因为组件的数量是固定的并且事先已知。
- en: Over time, we addressed most of the challenges that were mentioned in the preceding
    list with a mix of in-house-developed tools and well-documented instructions for
    handling these challenges manually. The scale of the operation was, in general,
    at a level where manual procedures for releasing new versions of the components
    and handling runtime issues were acceptable, even though they were not desirable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们通过一套自行开发的工具和处理这些挑战的详细说明，解决了前面列表中提到的大部分挑战。总的来说，操作的规模达到了一个水平，手动程序释放新版本的组件和处理运行时问题是可以接受的，尽管并不理想。
- en: Enter microservices
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入微服务
- en: Learning about microservice-based architectures in 2014 made me realize that
    other projects had also been struggling with similar challenges (partly for other
    reasons than the ones I described earlier, for example, the large cloud service
    providers meeting web-scale requirements). Many microservice pioneers had published
    details of lessons they'd learned. It was very interesting to learn from these
    lessons.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年了解到基于微服务的架构让我意识到其他项目也在面对类似的挑战（部分是出于其他原因，例如，大型云服务提供商满足Web规模的要求）。许多微服务先驱者已经发布了他们所学到的经验细节。从这些经验中学习是非常有趣的。
- en: Many of the pioneers initially developed monolithic applications that made them
    very successful from a business perspective. But over time, these monolithic applications
    became more and more difficult to maintain and evolve. They also became challenging
    to scale beyond the capabilities of the largest machines available (also known
    as **vertical scaling**). Eventually, the pioneers started to find ways to split
    monolithic applications into smaller components that could be released and scaled
    independently of each other. Scaling small components can be done horizontally,
    that is, deploying a component on a number of smaller servers and placing a load
    balancer in front of it. If done in the cloud, the scaling capability is potentially
    endless – it is just a matter of how many virtual servers you bring in (given
    that your component can scale out on a huge number of instances, but more on that
    later on).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多先驱最初开发了单片应用程序，使它们在商业上非常成功。但随着时间的推移，这些单片应用程序变得越来越难以维护和演进。它们也变得难以扩展到超出最大可用机器的能力（也称为**垂直扩展**）。最终，先驱们开始寻找将单片应用程序拆分为可以独立发布和独立扩展的更小组件的方法。小组件的扩展可以通过水平方式进行，即在多台较小的服务器上部署组件，并在其前面放置负载均衡器。如果在云中进行，扩展能力可能是无限的——只是要看您引入了多少虚拟服务器（假设您的组件可以在大量实例上扩展，但稍后会详细介绍）。
- en: 'In 2014, I also learned about a number of new open source projects that delivered
    tools and frameworks that simplified the development of microservices and could
    be used to handle the challenges that come with a microservice-based architecture.
    Some of these are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，我还了解了一些新的开源项目，它们提供了简化微服务开发的工具和框架，并且可以用来处理基于微服务的架构所带来的挑战。其中一些如下：
- en: Pivotal released **Spring Cloud**, which wraps parts of the **Netflix OSS** in
    order to provide capabilities such as dynamic service discovery, configuration
    management, distributed tracing, circuit breaking, and more.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pivotal发布了**Spring Cloud**，它包装了**Netflix OSS**的部分内容，以提供诸如动态服务发现、配置管理、分布式跟踪、断路器等功能。
- en: I also learned about **Docker** and the container revolution, which is great
    for minimizing the gap between development and production. Being able to package
    a component not only as a deployable runtime artifact (for example, a Java, `war`
    or, `jar` file) but as a complete image ready to be launched as a container (for
    example, an isolated process) on a server running Docker was a great step forward
    for development and testing.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我还了解了**Docker**和容器革命，这对于缩小开发和生产之间的差距非常有帮助。能够将组件打包不仅作为可部署的运行时构件（例如Java的`war`或`jar`文件），而且作为一个完整的镜像，可以作为容器（例如隔离的进程）在运行Docker的服务器上启动，这对于开发和测试是一个很大的进步。
- en: A container engine, such as Docker, is not enough to be able to use containers
    in a production environment. Something is needed that, for example, can ensure
    that all the containers are up and running and that they can scale out containers
    on a number of servers, thereby providing high availability and/or increased compute
    resources. These types of product became known as **container orchestrators***.* A
    number of products have evolved over the last few years, such as Apache Mesos,
    Docker in Swarm mode, Amazon ECS, HashiCorp Nomad, and **Kubernetes**. Kubernetes
    was initially developed by Google. When Google released v1.0, they also donated
    Kubernetes to CNCF ([https](https://www.cncf.io/)[://www.cncf.io/](https://www.cncf.io/)).
    During 2018, Kubernetes became kind of a de facto standard, available both pre-packaged
    for on-premise use and available as a service from most major cloud providers.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，像Docker这样的容器引擎并不足以在生产环境中使用容器。需要一些东西，例如可以确保所有容器都正常运行，并且可以在多台服务器上扩展容器，从而提供高可用性和/或增加计算资源。这些类型的产品被称为**容器编排器**。在过去几年中，出现了许多产品，如Apache
    Mesos、Docker的Swarm模式、Amazon ECS、HashiCorp Nomad和**Kubernetes**。Kubernetes最初由Google开发。当Google发布v1.0时，他们还将Kubernetes捐赠给了CNCF
    ([https](https://www.cncf.io/)[://www.cncf.io/](https://www.cncf.io/))。在2018年，Kubernetes成为了一种事实上的标准，可以在本地预打包使用，也可以在大多数主要云提供商那里作为服务使用。
- en: I have recently started to learn about the concept of a **service mesh** and
    how a service mesh can complement a container orchestrator to further offload
    microservices from responsibilities to make them manageable and resilient.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我最近开始了解**服务网格**的概念，以及服务网格如何与容器编排器相辅相成，进一步卸载微服务的责任，使它们更易管理和更具弹性。
- en: A sample microservice landscape
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例微服务景观
- en: Since this book can't cover all aspects of the technologies I just mentioned,
    I will focus on the parts that have proven to be useful in customer projects I
    have been involved in since 2014\. I will describe how they can be used together
    to create cooperating microservices that are manageable, scalable, and resilient.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书无法涵盖我刚提到的所有技术方面，我将专注于自2014年以来我参与的客户项目中证明有用的部分。我将描述它们如何一起使用，以创建可管理、可扩展和有弹性的合作微服务。
- en: 'Each chapter in this book will address a specific concern. To demonstrate how
    things fit together, I will use a small set of cooperating microservices that
    we will evolve throughout this book:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的每一章都将涉及特定的问题。为了演示事物如何组合在一起，我将使用一组合作的微服务，这些微服务将在本书中不断发展：
- en: '![](img/bd28199a-e796-4dd9-aaf1-ae322a726f93.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd28199a-e796-4dd9-aaf1-ae322a726f93.png)'
- en: Now that we know the how and what of microservices, let's start to look into
    how a microservice can be defined.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道了微服务的如何和什么，让我们开始探讨如何定义微服务。
- en: Defining a microservice
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义微服务
- en: 'To me, a microservice architecture is about splitting up monolithic applications
    into smaller components, which achieves two major goals:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，微服务架构是将单片应用程序拆分为更小的组件，从而实现了两个主要目标：
- en: Faster development, enabling continuous deployments
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的开发，实现持续部署
- en: Easier to scale, manually or automatically
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易扩展，手动或自动
- en: 'A microservice is essentially an autonomous software component that is independently
    upgradeable and scalable. To be able to act as an autonomous component, it must
    fulfill certain criteria as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务本质上是一个独立升级和可扩展的自主软件组件。为了能够充当自主组件，它必须满足以下某些标准：
- en: It must conform to a shared-nothing architecture; that is, microservices don't
    share data in databases with each other!
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须符合共享无架构；也就是说，微服务不会在数据库中共享数据！
- en: It must only communicate through well-defined interfaces, for example, using
    synchronous services or preferably by sending messages to each other using APIs
    and message formats that are stable, well-documented, and evolve by following
    a defined versioning strategy.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须只通过明确定义的接口进行通信，例如，使用同步服务或更好地通过使用稳定、有文档记录并遵循定义的版本控制策略的API和消息格式相互发送消息。
- en: It must be deployed as separate runtime processes. Each instance of a microservice
    runs in a separate runtime process, for example, a Docker container.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须作为单独的运行时进程部署。每个微服务实例都在单独的运行时进程中运行，例如，一个Docker容器。
- en: Microservice instances are stateless so that incoming requests to a microservice
    can be handled by any of its instances.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务实例是无状态的，因此微服务的传入请求可以由其任何实例处理。
- en: Using a set of microservices, we can deploy to a number of smaller servers instead
    of being forced to deploy to a single big server, like we have to do when deploying
    a monolithic application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一组微服务，我们可以部署到多个较小的服务器，而不是被迫部署到单个大型服务器，就像我们在部署单片应用程序时必须做的那样。
- en: Given that the preceding criteria have been fulfilled, it is easier to scale
    up a single microservice into more instances (for example, using more virtual
    servers) compared to scaling up a big monolithic application. Utilizing auto-scaling
    capabilities that are available in the cloud is also a possibility, but not typically
    feasible for a big monolithic application. It's also easier to upgrade or even
    replace a single microservice compared to upgrading a big monolithic application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于前述标准已得到满足，与升级大型单片应用程序相比，将单个微服务扩展为更多实例（例如，使用更多虚拟服务器）更容易。云中可用的自动扩展功能也是一种可能性，但通常不适用于大型单片应用程序。与升级大型单片应用程序相比，升级甚至替换单个微服务也更容易。
- en: 'This is illustrated by the following diagram, where a monolithic application
    has been divided into six microservices, all of which have been deployed into
    one separate server. Some of the microservices have also been scaled up independently
    of the others:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这由以下图表说明，其中一个单片应用程序已被分解为六个微服务，所有这些微服务都已部署到一个单独的服务器中。一些微服务也已独立扩展，而不依赖于其他微服务：
- en: '![](img/ee5160d1-409d-419e-9a56-489a4e8aa3a9.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee5160d1-409d-419e-9a56-489a4e8aa3a9.png)'
- en: A very frequent question I receive from customers is, *How big should a microservice
    be?*
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常收到的一个问题是，“微服务应该有多大？”
- en: 'I try to use the following rules-of-thumb:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我尝试使用以下经验法则：
- en: Small enough to fit in the head of a developer
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 足够小，适合开发人员的头脑
- en: Big enough to not jeopardize performance (that is, latency) and/or data consistency
    (SQL foreign keys between data that's stored in different microservices are no
    longer something you can take for granted)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 足够大，不会危及性能（即延迟）和/或数据一致性（在不同微服务中存储的数据之间的SQL外键不再是理所当然的事情）
- en: So, to summarize, a microservice architecture is, in essence, an architectural
    style where we decompose a monolithic application into a group of cooperating
    autonomous software components. The motivation is to enable faster development
    and to make it easier to scale the application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，微服务架构本质上是一种架构风格，我们将单片应用程序分解为一组合作的自主软件组件。动机是为了实现更快的开发，并使应用程序更容易扩展。
- en: Next, we will move on to understand some of the challenges that we will face
    when it comes to microservices.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续了解在微服务方面可能面临的一些挑战。
- en: Service discovery
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: The **service** **discovery** pattern has the following problem, solution, and
    solution requirements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务发现**模式具有以下问题、解决方案和解决方案要求。'
- en: Challenges with microservices
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的挑战
- en: 'In the *Challenges with autonomous software components* section, we have already
    seen some of the challenges that autonomous software components can bring (and
    they all apply to microservices as well) as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在“自主软件组件的挑战”部分，我们已经看到了一些自主软件组件可能带来的挑战（它们也都适用于微服务），如下所示：
- en: Many small components that use synchronous communication can cause *a* *chain
    of failure* problem, especially under high load.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多使用同步通信的小组件可能在高负载下引起*一系列故障*问题。
- en: Keeping the configuration up to date for many small components can be challenging.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持许多小组件的配置最新可能具有挑战性。
- en: It's hard to track a request that's being processed and involves many components,
    for example, when performing root cause analysis, where each component stores
    log events locally.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很难跟踪正在处理并涉及许多组件的请求，例如，在执行根本原因分析时，每个组件都会在本地存储日志事件。
- en: Analyzing the usage of hardware resources on a component level can be challenging
    as well.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析组件级别的硬件资源使用也可能具有挑战性。
- en: Manual configuration and management of many small components can become costly
    and error-prone.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多小组件的手动配置和管理可能变得昂贵且容易出错。
- en: 'Another downside (but not always obvious initially) of decomposing an application
    into a group of autonomous components is that they form a distributed system.
    Distributed systems are known to be, by their nature, very hard to deal with. This
    has been known for many years (but in many cases neglected until proven differently).
    My favorite quote to establish this fact is from Peter Deutsch who, back in 1994, stated
    the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分解为一组自主组件的另一个缺点（但最初并不总是明显的）是它们形成了一个分布式系统。分布式系统因其本质而闻名，非常难以处理。这已经众所周知（但在许多情况下被忽视，直到证明不同）。我用来证实这一事实的最喜欢的引用是彼得·德意志在1994年所说的：
- en: '***T*he 8 fallacies of distributed computing***: Essentially everyone, when
    they first build a distributed application, makes the following eight assumptions.
    All prove to be false in the long run and all cause big trouble and painful learning
    experiences:*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '***分布式计算的8个谬误***：实际上，每个人在首次构建分布式应用程序时都会做出以下八个假设。所有这些假设最终都被证明是错误的，并且都会导致大麻烦和痛苦的学习经历：'
- en: '*The network is reliable*'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*网络是可靠的*'
- en: '*Latency is zero*'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*延迟为零*'
- en: '*Bandwidth is infinite*'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*带宽是无限的*'
- en: '*The network is secure*'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*网络是安全的*'
- en: '*Topology doesn''t change*'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*拓扑不会改变*'
- en: '*There is one administrator*'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*只有一个管理员*'
- en: '*Transport cost is zero*'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*传输成本为零*'
- en: '*The network is homogeneous*'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*网络是同质的*'
- en: '*-- Peter Deutsch, 1994*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*-- Peter Deutsch, 1994*'
- en: '**Note:** The eighth fallacy was actually added by James Gosling at a later
    date. For more details, please go to [https://www.rgoarchitects.com/Files/fallacies.pdf](https://www.rgoarchitects.com/Files/fallacies.pdf).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**第八个谬误实际上是后来由James Gosling添加的。有关更多详细信息，请访问[https://www.rgoarchitects.com/Files/fallacies.pdf](https://www.rgoarchitects.com/Files/fallacies.pdf)。'
- en: In general, building microservices-based on these false assumptions leads to
    solutions that are prone to both temporary network glitches and problems that
    occur in other microservice instances. When the number of microservices in a system
    landscape increases, the likelihood of problems also goes up. A good rule of thumb
    is to design your microservice architecture based on the assumption that there
    is always something going wrong in the system landscape. The microservice architecture
    needs to be designed to handle this, in terms of detecting problems and restarting
    failed components but also on the client-side so that requests are not sent to
    failed microservice instances. When problems are corrected, requests to the previously
    failing microservice should be resumed; that is, microservice clients need to
    be resilient. All of these need, of course, to be fully automated. With a large
    number of microservices, it is not feasible for operators to handle this manually!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，基于这些错误假设构建微服务会导致解决方案容易受到临时网络故障和其他微服务实例出现的问题的影响。当系统中微服务的数量增加时，问题的可能性也会增加。一个很好的经验法则是，基于这样一个假设设计你的微服务架构，即系统景观中总是会出现问题。微服务架构需要设计成能够处理这一点，包括检测问题并重新启动失败的组件，同时也需要在客户端处理，以便请求不会发送到失败的微服务实例。当问题得到纠正时，对先前失败的微服务的请求应该恢复；也就是说，微服务客户端需要具有弹性。当然，所有这些都需要完全自动化。对于大量的微服务，运营商无法手动处理这些问题！
- en: The scope of this is large, but we will limit ourselves for now and move on
    to study design patterns for microservices.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个范围很大，但我们现在将限制自己，继续研究微服务的设计模式。
- en: Design patterns for microservices
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的设计模式
- en: This topic will cover using design patterns to mitigate challenges with microservices,
    as described in the preceding section. Later in this book, we will see how we
    can implement these design patterns using Spring Boot, Spring Cloud, and Kubernetes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题将涵盖使用设计模式来缓解微服务的挑战，如前一节所述。本书的后面，我们将看到如何使用Spring Boot、Spring Cloud和Kubernetes来实现这些设计模式。
- en: The concept of design patterns is actually quite old; it was invented by Christopher
    Alexander back in 1977\. In essence, a design pattern is about describing a reusable
    solution to a problem when given a specific context.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的概念实际上非常古老；它是由Christopher Alexander在1977年发明的。实质上，设计模式是描述在特定上下文中给定问题的可重用解决方案。
- en: 'The design patterns we will cover are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要涵盖的设计模式如下：
- en: Service discovery
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: Edge server
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘服务器
- en: Reactive microservices
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式微服务
- en: Central configuration
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中配置
- en: Centralized log analysis
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式日志分析
- en: Distributed tracing
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: Circuit Breaker
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器
- en: Control loop
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制循环
- en: Centralized monitoring and alarms
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式监控和警报
- en: This list is not intended to be comprehensive; instead, it's a minimal list
    of design patterns that are required to handle the challenges we described previously.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表并不打算是全面的；相反，它是我们之前描述的挑战所需的设计模式的最低限度列表。
- en: 'We will use a lightweight approach to describing design patterns, and focus
    on the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用轻量级方法来描述设计模式，并专注于以下内容：
- en: The problem
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题
- en: A solution
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个解决方案
- en: Requirements for the solution
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案的要求
- en: Later in this book, we will delve more deeply into how to apply these design
    patterns. The context for these design patterns is a system landscape of cooperating
    microservices where the microservices communicate with each other using either
    synchronous requests (for example, using HTTP) or by sending asynchronous messages
    (for example, using a message broker).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的后面，我们将更深入地探讨如何应用这些设计模式。这些设计模式的上下文是一个合作的微服务系统景观，其中微服务之间使用同步请求（例如使用HTTP）或通过发送异步消息（例如使用消息代理）进行通信。
- en: Problem
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How can clients find microservices and their instances?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端如何找到微服务及其实例？
- en: 'Microservices instances are typically assigned dynamically allocated IP addresses
    when they start up, for example, when running in containers. This makes it difficult
    for a client to make a request to a microservice that, for example, exposes a
    REST API over HTTP. Consider the following diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当微服务实例启动时，通常会动态分配IP地址，例如在容器中运行时。这使得客户端难以向暴露REST API的微服务发出请求。考虑以下图表：
- en: '![](img/ae0b2dda-3e2d-4028-b48b-cff12017468e.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae0b2dda-3e2d-4028-b48b-cff12017468e.png)'
- en: Solution
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add a new component – a **service discovery** service – to the system landscape,
    which keeps track of currently available microservices and the IP addresses of
    its instances.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 向系统景观添加一个新组件——一个**服务发现**服务，用于跟踪当前可用的微服务及其实例的IP地址。
- en: Solution requirements
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'Some solution requirements are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解决方案要求如下：
- en: Automatically register/unregister microservices and their instances as they
    come and go.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动注册/注销微服务及其实例，随着它们的进出。
- en: The client must be able to make a request to a logical endpoint for the microservice.
    The request will be routed to one of the microservices available instances.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端必须能够向微服务的逻辑端点发出请求。请求将被路由到一个可用的微服务实例。
- en: Requests to a microservice must be load-balanced over the available instances.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对微服务的请求必须在可用实例之间进行负载均衡。
- en: We must be able to detect instances that are not currently healthy; that is,
    requests will not be routed to them.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须能够检测当前不健康的实例；也就是说，请求不会被路由到它们。
- en: '**Implementation notes:** As we will see, this design pattern can be implemented
    using two different strategies:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现注意事项：**正如我们将看到的，这种设计模式可以使用两种不同的策略来实现：'
- en: '**Client-side routing**: The client uses a library that communicates with the
    service discovery service to find out the proper instances to send the requests
    to.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端路由**：客户端使用一个与服务发现服务通信的库，以找到发送请求的正确实例。'
- en: '**Server-side routing**: The infrastructure of the service discovery service also
    exposes a reverse proxy that all requests are sent to. The reverse proxy forwards
    the requests to a proper microservice instance on behalf of the client.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端路由**：服务发现服务的基础设施还公开了一个反向代理，所有请求都发送到它。反向代理代表客户端将请求转发到适当的微服务实例。'
- en: Edge server
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘服务器
- en: The edge server pattern has the following problem, solution, and solution requirements.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务器模式存在以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: In a system landscape of microservices, it is in many cases desirable to expose
    some of the microservices to the outside of the system landscape and hide the
    remaining microservices from external access. The exposed microservices must be
    protected against requests from malicious clients.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务系统架构中，通常希望将一些微服务暴露给系统架构之外，并将其余微服务隐藏起来，不对外部进行访问。暴露的微服务必须受到恶意客户端请求的保护。
- en: Solution
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add a new component, an **Edge Server**, to the system landscape that all incoming
    requests will go through:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 向系统架构中添加一个新组件，即**边缘服务器**，所有传入的请求都将通过它：
- en: '![](img/ae4561e4-4945-4613-9385-0f1bf1719981.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae4561e4-4945-4613-9385-0f1bf1719981.png)'
- en: 'Implementation notes: An edge server typically behaves like a reverse proxy
    and can be integrated with a discovery service to provide dynamic load balancing
    capabilities.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实现注意事项：边缘服务器通常表现为反向代理，并可以与发现服务集成，以提供动态负载平衡能力。
- en: Solution requirements
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'Some solution requirements are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解决方案要求如下：
- en: Hide internal services that should not be exposed outside their context; that
    is, only route requests to microservices that are configured to allow external
    requests.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏不应该在其上下文之外暴露的内部服务；也就是说，只将请求路由到配置为允许外部请求的微服务。
- en: Expose external services and protect them from malicious requests; that is,
    use standard protocols and best practices such as OAuth, OIDC, JWT tokens, and
    API keys to ensure that the clients are trustworthy.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露外部服务并保护它们免受恶意请求；也就是说，使用标准协议和最佳实践，如OAuth、OIDC、JWT令牌和API密钥，以确保客户端是可信的。
- en: Reactive microservice
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式微服务
- en: The reactive microservice pattern has the following problem, solution, and solution
    requirements.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式微服务模式存在以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Traditionally, as Java developers, we are used to implementing synchronous communication using
    blocking I/O, for example, a RESTful JSON API over HTTP. Using a blocking I/O
    means that a thread is allocated from the operating system for the length of the
    request. If the number of concurrent requests goes up (and/or the number of involved
    components in a request, for example, a chain of cooperating microservices, goes
    up), a server might run out of available threads in the operating system, causing
    problems ranging from longer response times to crashing servers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，作为Java开发人员，我们习惯于使用阻塞I/O来实现同步通信，例如通过HTTP的RESTful JSON API。使用阻塞I/O意味着为请求的整个长度从操作系统分配一个线程。如果并发请求的数量增加（和/或请求中涉及的组件数量增加，例如一系列合作的微服务），服务器可能会耗尽操作系统中的可用线程，导致从响应时间变长到服务器崩溃等一系列问题。
- en: Also, as we already mentioned in this chapter, overusing blocking I/O can make
    a system of microservices prone to errors. For example, an increased delay in
    one service can cause clients to run out of available threads, causing them to
    fail. This, in turn, can cause their clients to have the same types of problem,
    which is also known as a chain of failures. See the *Circuit Breaker* section for
    how to handle a chain-of-failure-related problem.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们在本章中已经提到的，过度使用阻塞I/O可能会使微服务系统容易出现错误。例如，一个服务中的延迟增加可能导致客户端耗尽可用线程，导致它们失败。这反过来又可能导致它们的客户端出现相同类型的问题，这也被称为一系列故障。有关如何处理与一系列故障相关的问题，请参见*断路器*部分。
- en: Solution
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use non-blocking I/O to ensure that no threads are allocated while waiting for
    processing to occur in another service, that is, a database or another microservice.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非阻塞I/O确保在等待另一个服务进行处理时不分配线程。
- en: Solution requirements
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'Some solution requirements are as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解决方案要求如下：
- en: Whenever feasible, use an asynchronous programming model; that is, send messages
    without waiting for the receiver to process them.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可行的情况下，使用异步编程模型；也就是说，发送消息而无需等待接收方处理它们。
- en: If a synchronous programming model is preferred, ensure that reactive frameworks
    are used that can execute synchronous requests using non-blocking I/O, that is,
    without allocating a thread while waiting for a response. This will make the microservices
    easier to scale in order to handle an increased workload.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果更喜欢同步编程模型，请确保使用可以使用非阻塞I/O执行同步请求的响应式框架，也就是说，在等待响应时不分配线程。这将使微服务更容易扩展以处理增加的工作负载。
- en: Microservices must also be designed to be resilient, that is, capable of producing
    a response, even if a service that it depends on fails. Once the failing service
    is operational again, its clients must be able to resume using it, which is known
    as self-healing.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务还必须设计为具有韧性，即使它所依赖的服务失败，也能够产生响应。一旦失败的服务再次运行，其客户端必须能够恢复使用它，这被称为自愈。
- en: In 2013, key principles for designing systems in these ways were established
    in *The Reactive Manifesto* ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)).
    According to the manifesto, the foundation for reactive systems is that they are
    message-driven; that is, they use asynchronous communication. This allows them
    to be elastic, that is, scalable, and resilient, that is, tolerant to failures.
    Elasticity and resilience together allow a reactive system to be responsive so
    that it can respond in a timely fashion.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，《响应式宣言》（[https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)）确立了以这些方式设计系统的关键原则。根据宣言，响应式系统的基础是它们是消息驱动的；也就是说，它们使用异步通信。这使它们能够具有弹性，即可扩展，以及具有韧性，即容错。弹性和韧性共同使得响应式系统能够响应及时。
- en: Central configuration
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中央配置
- en: The central configuration pattern has the following problem, solution, and solution
    requirements.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 中央配置模式存在以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'An application is, traditionally, deployed together with its configuration,
    for example, a set of environment variables and/or files containing configuration
    information. Given a system landscape based on a microservice architecture, that
    is, with a large number of deployed microservice instances, some queries arise:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，应用程序与其配置一起部署，例如一组环境变量和/或包含配置信息的文件。在基于微服务架构的系统景观中，即在大量部署的微服务实例的情况下，会出现一些查询：
- en: How do I get a complete picture of the configuration that is in place for all
    the running microservice instances?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取所有运行的微服务实例的配置完整图片？
- en: How do I update the configuration and make sure that all the affected microservice
    instances are updated correctly?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何更新配置并确保所有受影响的微服务实例都正确更新？
- en: Solution
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add a new component, a **c****onfiguration** server, to the system landscape to
    store the configuration of all the microservices.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 向系统景观添加一个新组件，即**配置**服务器，用于存储所有微服务的配置。
- en: Solution requirements
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: Make it possible to store configuration information for a group of microservices
    in one place, with different settings for different environments (for example,
    `dev`, `test`, `qa`, and `prod`).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使得能够将一组微服务的配置信息存储在一个地方，对不同环境（例如`dev`、`test`、`qa`和`prod`）进行不同设置。
- en: Centralized log analysis
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中式日志分析
- en: Centralized log analysis has the following problem, solution, and solution requirements.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式日志分析存在以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Traditionally, an application writes log events to log files that are stored
    on the local machine that the application runs on. Given a system landscape based
    on a microservice architecture, that is, with a large number of deployed microservice
    instances on a large number of smaller servers, we can ask the following questions:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，应用程序将日志事件写入存储在其运行的本地计算机上的日志文件中。在基于微服务架构的系统景观中，即在大量较小服务器上部署了大量微服务实例的情况下，我们可以提出以下问题：
- en: How do I get an overview of what is going on in the system landscape when each microservice
    instance writes to its own local log file?
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当每个微服务实例写入自己的本地日志文件时，如何获取系统景观中正在发生的情况的概述？
- en: How do I find out if any of the microservice instances get into trouble and
    start writing error messages to their log files?
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何找出任何微服务实例是否出现问题并开始向其日志文件写入错误消息？
- en: 'If end users start to report problems, how can I find related log messages;
    that is, how can I identify which microservice instance is the root cause of the
    problem? The following diagram illustrates the problem:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最终用户开始报告问题，我如何找到相关的日志消息；也就是说，我如何确定哪个微服务实例是问题的根本原因？以下图表说明了问题：
- en: '![](img/12e455e5-f256-43f4-b593-7145f36401c7.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12e455e5-f256-43f4-b593-7145f36401c7.png)'
- en: Solution
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add a new component that can manage **centralized logging** and is capable
    of the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新组件，可以管理**集中式日志**，并具有以下功能：
- en: Detecting new microservice instances and collecting log events from them
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测新的微服务实例并收集其日志事件
- en: Interpreting and storing log events in a structured and searchable way in a
    central database
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以结构化和可搜索的方式解释和存储日志事件在中央数据库中
- en: Providing APIs and graphical tools for querying and analyzing log events
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供用于查询和分析日志事件的API和图形工具
- en: Distributed tracing
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: Distributed tracing has the following problem, solution, and solution requirements.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式跟踪存在以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: It must be possible to track requests and messages that flow between microservices
    while processing an external call to the system landscape.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理系统景观的外部调用时，必须能够跟踪在微服务之间流动的请求和消息。
- en: 'Some examples of fault scenarios are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一些故障场景的示例如下：
- en: If end users start to file support cases regarding a specific failure, how can
    we identify the microservice that caused the problem, that is, the root cause?
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最终用户开始提交支持案例，涉及特定故障，我们如何确定导致问题的微服务，也就是说，根本原因？
- en: If one support case mentions problems related to a specific entity, for example,
    a specific order number, how can we find log messages related to processing this
    specific order – for example, log messages from all microservices that were involved
    in processing this specific order?
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个支持案例提到与特定实体（例如特定订单号）相关的问题，我们如何找到与处理此特定订单相关的日志消息，例如，所有涉及处理此特定订单的微服务的日志消息？
- en: 'The following diagram depicts this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了这一点：
- en: '![](img/a7e6182c-b5f4-4344-8e98-3e9f62aef421.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7e6182c-b5f4-4344-8e98-3e9f62aef421.png)'
- en: Solution
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: To track the processing between cooperating microservices, we need to ensure
    that all related requests and messages are marked with a common correlation ID
    and that the correlation ID is part of all log events. Based on a correlation
    ID, we can use the centralized logging service to find all related log events.
    If one of the log events also includes information about a business-related identifier,
    for example, the ID of a customer, product, order, and so on, we can find all
    related log events for that business identifier using the correlation ID.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪协作微服务之间的处理，我们需要确保所有相关请求和消息都标有一个公共关联ID，并且该关联ID是所有日志事件的一部分。根据关联ID，我们可以使用集中式日志服务找到所有相关的日志事件。如果其中一个日志事件还包括有关业务相关标识符的信息，例如客户、产品、订单等的ID，我们可以使用关联ID找到该业务标识符的所有相关日志事件。
- en: Solution requirements
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'The solution requirements are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案要求如下：
- en: Assign unique correlation IDs to all incoming or new requests and events in
    a well-known place, such as a header with a recognized name.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有传入或新请求和事件分配唯一的关联ID，并放在一个公认的位置，例如一个具有公认名称的标头中。
- en: When a microservice makes an outgoing request or sends a message, it must add
    the correlation ID to the request and message.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当微服务发出出站请求或发送消息时，必须将关联ID添加到请求和消息中。
- en: All log events must include the correlation ID in a predefined format so that
    the centralized logging service can extract the correlation ID from the log event
    and make it searchable.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有日志事件必须以预定义格式包含关联ID，以便集中式日志服务可以从日志事件中提取关联ID并使其可搜索。
- en: Circuit Breaker
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器
- en: The Circuit Breaker pattern will have the following problem, solution, and solution
    requirements.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器模式将具有以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: A system landscape of microservices that uses synchronous intercommunication
    can be exposed to a *chain of failure*. If one microservice stops responding,
    its clients might get into problems as well and stop responding to requests from
    their clients. The problem can propagate recursively throughout a system landscape
    and take out major parts of it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用同步互联的微服务系统架构可能会暴露给*故障链*。如果一个微服务停止响应，它的客户端也可能遇到问题，并停止响应其客户端的请求。问题可能会在系统架构中递归传播，并摧毁其中的重要部分。
- en: This is especially common in cases where synchronous requests are executed using
    blocking I/O, that is, blocking a thread from the underlying operating system
    while a request is being processed. Combined with a large number of concurrent
    requests and a service that starts to respond unexpectedly slowly, thread pools
    can quickly become drained, causing the caller to hang and/or crash. This failure
    can spread unpleasantly fast to the caller's caller, and so on.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这在使用阻塞I/O执行同步请求的情况下特别常见，即在处理请求时阻塞来自底层操作系统的线程。结合大量并发请求和服务开始以意外缓慢的速度响应，线程池可能会迅速耗尽，导致调用者挂起和/或崩溃。这种故障可能会非常快速地传播到调用者的调用者，依此类推。
- en: Solution
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add a Circuit Breaker that prevents new outgoing requests from a caller if it
    detects a problem with the service it calls.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个断路器，如果检测到调用的服务出现问题，它将阻止来自调用者的新出站请求。
- en: Solution requirements
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'The solution requirements are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案要求如下：
- en: Open the circuit and fail fast (without waiting for a timeout) if problems with
    the service are detected.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果检测到服务出现问题，打开断路并快速失败（无需等待超时）。
- en: Probe for failure correction (also known as a **half-open circuit**); that is,
    allow a single request to go through on a regular basis to see if the service
    operates normally again.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探测故障纠正（也称为**半开断路**）；也就是说，定期允许单个请求通过，以查看服务是否再次正常运行。
- en: Close the circuit if the probe detects that the service operates normally again.
    This capability is very important since it makes the system landscape resilient
    to these kinds of problems; that is, it self-heals.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果探测到服务再次正常运行，关闭断路。这种能力非常重要，因为它使系统架构对这类问题具有弹性；也就是说，它能自我修复。
- en: 'The following diagram illustrates a scenario where all synchronous communication
    within the system landscape of microservices goes through Circuit Breakers. All
    the Circuit Breakers are closed; that is, they allow traffic, except for one Circuit
    Breaker detected problems in the service the requests go to. Therefore, this Circuit
    Breaker is open and utilizes fast-fail logic; that is, it does not call the failing
    service and waits for a timeout to occur. In the following, it immediately returns
    a response, optionally applying some fallback logic before responding:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了一个场景，即微服务系统架构中的所有同步通信都经过断路器。所有断路器都是关闭的；也就是说，它们允许流量通过，除了一个断路器检测到请求的服务出现问题。因此，这个断路器是打开的，并利用快速失败逻辑；也就是说，它不调用失败的服务并等待超时发生。接下来，它立即返回一个响应，在响应之前可能应用一些备用逻辑：
- en: '![](img/039f95d4-defe-4ecf-9ce1-71c78ed322ac.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/039f95d4-defe-4ecf-9ce1-71c78ed322ac.png)'
- en: Control loop
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制循环
- en: The control loop pattern will have the following problem, solution, and solution
    requirements.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 控制循环模式将具有以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: In a system landscape with a large number of microservice instances spread out
    over a number of servers, it is very difficult to manually detect and correct
    problems such as crashed or hung microservice instances.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布在多台服务器上的大量微服务实例的系统架构中，手动检测和纠正诸如崩溃或挂起的微服务实例等问题非常困难。
- en: Solution
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add a new component, a **control loop**, to the system landscape; this constantly
    observes the actual state of the system landscape; compares it with the desired
    state, as specified by the operators; and, if required, takes action. For example,
    if the two states differ, it needs to make the actual state equal to the desired
    state:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 向系统架构中添加一个新组件，即**控制循环**；它不断观察系统架构的实际状态；将其与操作员指定的期望状态进行比较；并在需要时采取行动。例如，如果两个状态不同，它需要使实际状态等于期望状态：
- en: '![](img/4716aa50-5154-4e6a-b6d2-32ae7728d640.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4716aa50-5154-4e6a-b6d2-32ae7728d640.png)'
- en: Solution requirements
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'Implementation notes: In the world of containers, a *container orchestrator* such
    as Kubernetes is typically used to implement this pattern. We will learn more
    about Kubernetes in [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml),
    *Introduction to Kubernetes*.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 实施说明：在容器的世界中，通常会使用*容器编排器*，如Kubernetes来实现这种模式。我们将在[第15章](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml)中更多地了解Kubernetes，即*介绍Kubernetes*。
- en: Centralized monitoring and alarms
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中式监控和警报
- en: For this pattern, we will have the following problem, solution, and solution
    requirements.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种模式，我们将有以下问题、解决方案和解决方案要求。
- en: Problem
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: If observed response times and/or the usage of hardware resources become unacceptably
    high, it can be very hard to discover the root cause of the problem. For example,
    we need to be able to analyze hardware resource consumption per microservice.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果观察到响应时间和/或硬件资源的使用变得不可接受高，很难发现问题的根本原因。例如，我们需要能够分析每个微服务的硬件资源消耗。
- en: Solution
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: To curb this, we add a new component, a **monitor service**, to the system landscape,
    which is capable of collecting metrics about hardware resource usage for each
    microservice instance level.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们向系统架构中添加了一个新组件，一个**监控服务**，它能够收集关于每个微服务实例级别的硬件资源使用情况的指标。
- en: Solution requirements
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案要求
- en: 'The solution requirements are as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案要求如下：
- en: It must be able to collect metrics from all the servers that are used by the
    system landscape, which includes auto-scaling servers.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够从系统架构中使用的所有服务器收集指标，其中包括自动扩展服务器。
- en: It must be able to detect new microservice instances as they are launched on
    the available servers and start to collect metrics from them.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够在可用服务器上启动新的微服务实例，并开始从中收集指标。
- en: It must be able to provide APIs and graphical tools for querying and analyzing the
    collected metrics.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须能够提供API和图形工具，用于查询和分析收集到的指标。
- en: 'The following screenshot shows Grafana, which visualizes metrics from Prometheus,
    a monitoring tool that we will look at later in this book:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Grafana，它可视化了来自Prometheus的指标，这是我们在本书后面将要讨论的监控工具：
- en: '![](img/c19497ae-0184-4788-baed-9bc5a5f11993.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c19497ae-0184-4788-baed-9bc5a5f11993.png)'
- en: That was an extensive list! I am sure these design patterns helped you understand
    the challenges with microservices better. Next, we will move on to understand
    software enablers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的列表！我相信这些设计模式帮助您更好地理解了微服务的挑战。接下来，我们将继续了解软件使能。
- en: Software enablers
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件使能
- en: 'As we''ve already mentioned, we have a number of very good open-source tools
    that can help us both meet our expectations of microservices and, most importantly,
    handle the new challenges that come with them:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，我们有许多非常好的开源工具，可以帮助我们满足微服务的期望，最重要的是，处理伴随它们而来的新挑战：
- en: Spring Boot
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot
- en: Spring Cloud/Netflix OSS
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud/Netflix OSS
- en: Docker
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Kubernetes
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Istio (a service mesh)
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio（服务网格）
- en: 'The following table maps the design patterns we will need to handle these challenges,
    along with the corresponding open-source tool that implements the design pattern:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了我们需要处理这些挑战的设计模式，以及实现设计模式的相应开源工具：
- en: '| **Design Pattern** | **Spring Boot** | **Spring Cloud** | **Kubernetes**
    | **Istio** |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **设计模式** | **Spring Boot** | **Spring Cloud** | **Kubernetes** | **Istio**
    |'
- en: '| **Service discovery** |  | Netflix Eureka and Netflix Ribbon | Kubernetes
    `kube-proxy` and service resources |  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| **服务发现** |  | Netflix Eureka和Netflix Ribbon | Kubernetes `kube-proxy`和服务资源
    |  |'
- en: '| **Edge server** |  | Spring Cloud and Spring Security OAuth | Kubernetes
    Ingress controller | Istio ingress gateway |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| **边缘服务器** |  | Spring Cloud和Spring Security OAuth | Kubernetes入口控制器 | Istio入口网关
    |'
- en: '| **Reactive microservices** | Spring Reactor and Spring WebFlux |  |  |  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **响应式微服务** | Spring Reactor和Spring WebFlux |  |  |  |'
- en: '| **Central configuration** |  | Spring Config Server | Kubernetes `ConfigMaps`
    and Secrets |  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **中央配置** |  | Spring Config Server | Kubernetes `ConfigMaps`和Secrets |  |'
- en: '| **Centralized log analysis** |  |  | Elasticsearch, Fluentd, and Kibana **Note**:
    Actually not part of Kubernetes'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '| **集中式日志分析** |  |  | Elasticsearch，Fluentd和Kibana **注意**：实际上不是Kubernetes的一部分'
- en: but can easily be deployed and configured together with Kubernetes |  |
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 但可以很容易地与Kubernetes一起部署和配置 |  |
- en: '| **Distributed tracing** |  | Spring Cloud Sleuth and Zipkin |  | Jaeger |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **分布式跟踪** |  | Spring Cloud Sleuth和Zipkin |  | Jaeger |'
- en: '| **Circuit Breaker** |  | Resilience4j |  | Outlier detection |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| **熔断器** |  | Resilience4j |  | 异常检测 |'
- en: '| **Control loop** |  |  | Kubernetes controller manager |  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **控制循环** |  |  | Kubernetes控制器管理器 |  |'
- en: '| **Centralized monitoring and alarms** |  |  | Grafana and Prometheus **Note:** Actually
    not part of Kubernetes'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '| **集中式监控和警报** |  |  | Grafana和Prometheus **注意：**实际上不是Kubernetes的一部分'
- en: but can easily be deployed and configured  together with Kubernetes | Kiali,
    Grafana, and Prometheus |
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 但可以很容易地与Kubernetes一起部署和配置 | Kiali，Grafana和Prometheus |
- en: Please note that Spring Cloud, Kubernetes, and Istio can be used to implement
    some design patterns, such as service discovery, edge server, and central configuration.
    We will discuss the pros and cons of using these alternatives later in this book.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Spring Cloud、Kubernetes和Istio可以用于实现一些设计模式，例如服务发现、边缘服务器和中央配置。我们将在本书的后面讨论使用这些替代方案的利弊。
- en: Now, let's look at some other important things that we need to take into consideration.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看其他一些需要考虑的重要事项。
- en: Other important considerations
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他重要考虑事项
- en: 'To be successful implementing a microservice architecture, there are a number
    of related areas to consider as well. I will not cover these areas in this book;
    instead, I''ll just briefly mention them here as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功实施微服务架构，还有许多相关领域需要考虑。我不会在本书中涵盖这些领域；相反，我会在这里简要提到它们，如下所示：
- en: '**Importance of Dev/Ops**:One of the benefits of a microservice architecture
    is that it enables shorter delivery times and, in extreme cases allows the *continuous
    delivery* of new versions. To be able to deliver that fast, you need to establish
    an organization where dev and ops work together under the mantra *you built it,
    you run it*. This means that developers are no longer allowed to simply pass new
    versions of the software over to the operations team. Instead, the dev and ops
    organizations need to work much more closely together, organized into teams that
    have full responsibility for the end-to-end life cycle of one microservice (or
    a group of related microservices). Besides the organizational part of `dev`/`ops`,
    the teams also need to automate the delivery chain, that is, the steps for building,
    testing, packaging, and deploying the microservices to the various deployment
    environments. This is known as setting up a *delivery pipeline*.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dev/Ops的重要性**：微服务架构的一个好处是它能够缩短交付时间，并且在极端情况下允许连续交付新版本。为了能够快速交付，您需要建立一个开发和运维共同工作的组织，遵循“你构建它，你运行它”的口号。这意味着开发人员不再被允许简单地将软件的新版本交给运维团队。相反，开发和运维组织需要更加紧密地合作，组织成负责一个微服务（或一组相关微服务）的端到端生命周期的团队。除了`dev`/`ops`的组织部分外，团队还需要自动化交付链，即构建、测试、打包和部署微服务到各种部署环境的步骤。这被称为建立一个*交付管道*。'
- en: '**Organizational aspects and Conway''s law**: Another interesting aspect of
    how a microservice architecture might affect the organization is *Conway''s law*,
    which states the following:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织方面和康威定律：微服务架构可能影响组织的另一个有趣方面是康威定律，该定律陈述如下：
- en: '"Any organization that designs a system (defined broadly) will produce a design
    whose structure is a copy of the organization''s communication structure."'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: “任何设计系统（广义定义）的组织都会产生一个结构与该组织沟通结构相似的设计。”
- en: -- Melvyn Conway, 1967
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: -- Melvyn Conway, 1967
- en: This means that the traditional approach of organizing IT teams for large applications
    based on their technology expertise (for example, UX, business logic, and databases-teams)
    will lead to a big three-tier application – typically a big monolithic application
    with a separately deployable unit for the UI, one for processing the business
    logic, and one for the big database. To successfully deliver an application based
    on a microservice architecture, the organization needs to be changed into teams
    that work with one or a group of related microservices. The team must have the
    skills that are required for those microservices, for example, languages and frameworks
    for the business logic and database technologies for persisting its data.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着根据其技术专长（例如，UX、业务逻辑和数据库团队）为大型应用程序组织IT团队的传统方法将导致一个大型的三层应用程序——通常是一个大型的单片应用程序，其中UI有一个单独的可部署单元，业务逻辑有一个，大型数据库有一个。要成功交付基于微服务架构的应用程序，组织需要转变为与一个或一组相关的微服务一起工作的团队。团队必须具备执行这些微服务所需的技能，例如，业务逻辑的语言和框架以及持久化数据的数据库技术。
- en: '**Decomposing a monolithic application into microservices: **One of the most
    difficult and expensive decisions is how to decompose a monolithic application
    into a set of cooperating microservices. If this is done in the wrong way, you
    will end up with problems such as the following:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将单片应用程序分解为微服务**：最困难和昂贵的决定之一是如何将单片应用程序分解为一组协作的微服务。如果这样做得不对，就会出现以下问题：'
- en: '**Slow delivery**: Changes in the business requirements will affect too many
    of the microservices, resulting in extra work.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交付缓慢**：业务需求的变化将影响太多的微服务，导致额外的工作。'
- en: '**Slow performance**: To be able to perform a specific business function, a
    lot of requests have to be passed between various microservices, resulting in
    long response times.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能缓慢**：为了执行特定的业务功能，必须在各种微服务之间传递大量请求，导致响应时间长。'
- en: '**Inconsistent data**: Since related data is separated into different microservices,
    inconsistencies can appear over time in data that''s managed by different microservices.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据不一致**：由于相关数据被分隔到不同的微服务中，不同微服务管理的数据可能随时间出现不一致性。'
- en: A good approach to finding proper boundaries for microservices is to apply **Domain-Driven
    Design** and its **Bounded Context** concept. According to Eric Evans, a *Bounded
    Context* is "*A description of a boundary (typically a subsystem, or the work
    of a particular team) within which a particular model is defined and applicable." *This
    means that the microservice defined by a Bounded Context will have a well-defined
    model of its own data.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 找到微服务的适当边界的一个好方法是应用**领域驱动设计**及其**有界上下文**概念。根据Eric Evans的说法，*有界上下文*是“*定义和适用于特定模型的边界（通常是子系统或特定团队的工作）的描述。”这意味着由有界上下文定义的微服务将拥有自己的数据的明确定义模型。
- en: '**Importance of API design: **If a group of microservices expose a common,
    externally available API, it is important that the API is easy to understand and
    consumes the following:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API设计的重要性**：如果一组微服务公开一个常见的、外部可用的API，那么API易于理解和包含以下内容是非常重要的：'
- en: If the same concept is used in multiple APIs, it should have the same description
    in terms of the naming and data types used.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果同一概念在多个API中使用，它在命名和数据类型方面应该有相同的描述。
- en: It is of great importance that APIs are allowed to evolve in a controlled manner.
    This typically requires applying a proper versioning schema for the APIs, for
    example, [https://semver.org/](https://semver.org/), and having the capability
    of handling multiple major versions of an API over a specific period of time,
    allowing clients of the API to migrate to new major versions at their own pace.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API被允许以受控的方式进行演进非常重要。这通常需要为API应用适当的版本控制模式，例如[https://semver.org/](https://semver.org/)，并且具有在特定时间段内处理多个主要版本的API的能力，允许API的客户端以自己的步调迁移到新的主要版本。
- en: '**Migration paths from on-premise to the cloud**:Many companies today run their
    workload on-premise, but are searching for ways to move parts of their workload
    to the cloud. Since most cloud providers today offer Kubernetes as a Service,
    an appealing migration approach can be to first move the workload into Kubernetes on-premise (as
    microservices or not) and then redeploy it on a *Kubernetes as a Service* offering
    provided by a preferred cloud provider.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地到云端的迁移路径：今天许多公司在本地运行其工作负载，但正在寻找将部分工作负载迁移到云端的方法。由于大多数云提供商今天提供Kubernetes作为服务，一个吸引人的迁移方法可以是首先将工作负载移入本地的Kubernetes（作为微服务或其他形式），然后重新部署到首选云提供商提供的Kubernetes作为服务的平台上。
- en: '**Good design principles for microservices, the 12-factor app**:The 12-factor
    app ([https://12factor.net](https://12factor.net/)) is a set of design principles
    for building software that can be deployed in the cloud. Most of these design
    principles are applicable to building microservices independently of where and
    how they will be deployed, that is, in the cloud or on-premise. Some of these
    principles will be covered in this book, such as config, processes, and logs, but
    not all.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的良好设计原则，12要素应用程序：12要素应用程序（[https://12factor.net](https://12factor.net/)）是一组用于构建可以在云中部署的软件的设计原则。这些设计原则大多适用于独立构建微服务，无论它们将在云端还是本地部署。本书将涵盖其中一些原则，如配置、进程和日志，但不是全部。
- en: That's it for the first chapter! I hope this gave you a good basic idea of microservices
    and helped you understand the large scale topics that will be covered in this
    book.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章就到这里了！希望这给了你对微服务的基本概念，并帮助你理解本书将涵盖的大规模主题。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this introductory chapter, I described my own way into microservices and
    delved into a bit of their history. We defined what a microservice is, that is,
    a kind of autonomous distributed component with some specific requirements. We
    also went through the good and challenging aspects of a microservice-based architecture.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个介绍性的章节中，我描述了我自己进入微服务的方式，并深入了解了它们的一些历史。我们定义了微服务是什么，即一种具有特定要求的自治分布式组件。我们还讨论了基于微服务的架构的优点和挑战。
- en: To handle these challenges, we defined a set of design patterns and briefly
    mapped the capabilities of open source products such as Spring Boot, Spring Cloud,
    and Kubernetes to them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些挑战，我们定义了一组设计模式，并简要地将Spring Boot、Spring Cloud和Kubernetes等开源产品的能力映射到这些模式上。
- en: You're eager to develop your first microservice now, right? In the next chapter,
    we will be introduced to Spring Boot and complementary open source tools that
    we will use to develop our first microservices
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你一定迫不及待地想要开发你的第一个微服务了，对吧？在下一章中，我们将介绍Spring Boot和其他开源工具，这些工具将用于开发我们的第一个微服务。
