- en: Chapter 12. Adding Physics and Sounds to Your Scene
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。将物理和声音添加到您的场景
- en: In this final chapter, we'll look at Physijs, another library you can use to
    extend the basic functionality of Three.js. Physijs is a library that allows you
    to introduce physics into your 3D scene. By physics, we mean that your objects
    are subject to gravity, they can collide with each other, can be moved by applying
    impulse, and can be constrained in their movement through hinges and sliders.
    This library internally makes use of another well-known physics engine called
    **ammo.js**. Besides physics, we'll also look at how Three.js can help you with
    adding spatial sounds to your scene.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后一章中，我们将看看Physijs，这是另一个您可以用来扩展Three.js基本功能的库。Physijs是一个允许您在3D场景中引入物理的库。通过物理，我们指的是您的对象受到重力的影响，它们可以相互碰撞，可以通过施加冲量移动，并且可以通过铰链和滑块约束其运动。这个库内部使用另一个著名的物理引擎**ammo.js**。除了物理，我们还将看看Three.js如何帮助您向场景添加空间声音。
- en: 'In this chapter, we''ll discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Creating a Physijs scene where your objects are subject to gravity and can collide
    with each other
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Physijs场景，其中您的对象受到重力的影响，并且可以相互碰撞。
- en: Showing how to change the friction and restitution (bounciness) of the objects
    in the scene
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示如何改变场景中对象的摩擦和恢复（弹性）
- en: Explaining the various shapes supported by Physijs and how to use them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Physijs支持的各种形状以及如何使用它们
- en: Showing how to create compound shapes by combining simple shapes together
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示如何通过组合简单形状来创建复合形状
- en: Showing how a height field allows you to simulate a complex shape
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示高度场如何允许您模拟复杂的形状
- en: Limiting the movement of an object by applying a point, hinge, slider, and cone
    twist, and the 'degree of freedom' constraint
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用点、铰链、滑块和锥扭转以及“自由度”约束来限制对象的移动
- en: Adding sound sources to your scene whose sound volume and direction is based
    on their distance to the camera.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向场景添加声音源，其声音音量和方向基于它们与摄像机的距离。
- en: The first thing we will do is create a Three.js scene that can be used with
    Physijs. We'll do that in our first example.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是创建一个可以与Physijs一起使用的Three.js场景。我们将在我们的第一个示例中这样做。
- en: Creating a basic Three.js scene
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的Three.js场景
- en: 'Setting up a Three.js scene for Physijs is very simple and only takes a couple
    of steps. The first thing we need to do is include the correct JavaScript file,
    which you can get from the GitHub repository at [http://chandlerprall.github.io/Physijs/](http://chandlerprall.github.io/Physijs/).
    Add the Physijs library to your HTML page like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为Physijs设置一个Three.js场景非常简单，只需要几个步骤。我们需要做的第一件事是包含正确的JavaScript文件，您可以从GitHub存储库[http://chandlerprall.github.io/Physijs/](http://chandlerprall.github.io/Physijs/)获取。像这样将Physijs库添加到您的HTML页面中：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Simulating a scene is rather processor intensive. If we run all the simulation
    computations on the render thread (since JavaScript is single threaded in nature),
    it will seriously affect the frame rate of our scene. To compensate for that,
    Physijs does its calculations in a background thread. This background thread is
    provided through the "web workers" specification that is implemented by most modern
    browsers. With this specification, you can run CPU-intensive tasks in a separate
    thread, thus not affecting the rendering. More information on web workers can
    be found at [http://www.w3.org/TR/workers/](http://www.w3.org/TR/workers/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟场景需要相当多的处理器。如果我们在渲染线程上运行所有模拟计算（因为JavaScript的本质是单线程），它将严重影响场景的帧速率。为了补偿这一点，Physijs在后台线程中进行计算。这个后台线程是通过大多数现代浏览器实现的“web
    workers”规范提供的。使用这个规范，您可以在单独的线程中运行CPU密集型任务，从而不影响渲染。有关web workers的更多信息可以在[http://www.w3.org/TR/workers/](http://www.w3.org/TR/workers/)找到。
- en: For Physijs, this means we have to configure the JavaScript file that contains
    this worker task and also tell Physijs where it can find the ammo.js file needed
    to simulate our scene. The reason we need to include the ammo.js file is that
    Physijs is a wrapper around ammo.js to make it easy to use. Ammo.js (which you
    can find at [https://github.com/kripken/ammo.js/](https://github.com/kripken/ammo.js/))
    is the library that implements the physics engine; Physijs just provides an easy-to-use
    interface to this physics library. Since Physijs is just a wrapper, we can also
    use other physics engines together with Physijs. On the Physijs repository, you
    can also find a branch that uses Cannon.js, a different physics engine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Physijs，这意味着我们必须配置包含这个工作任务的JavaScript文件，并告诉Physijs它在哪里可以找到需要模拟我们场景的ammo.js文件。我们需要包含ammo.js文件的原因是，Physijs是一个围绕ammo.js的包装器，使其易于使用。Ammo.js（您可以在[https://github.com/kripken/ammo.js/](https://github.com/kripken/ammo.js/)找到）是实现物理引擎的库；Physijs只是为这个物理库提供了一个易于使用的接口。由于Physijs只是一个包装器，我们也可以将其他物理引擎与Physijs一起使用。在Physijs存储库上，您还可以找到一个使用不同物理引擎Cannon.js的分支。
- en: 'To configure Physijs, we have to set the following two properties:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Physijs，我们必须设置以下两个属性：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first property points to the worker tasks we want to execute, and the second
    property points to the ammo.js library that is used internally. The next step
    we need to perform is create a scene. Physijs provides a wrapper around the Three.js
    normal scene, so in your code, you do the following to create a scene:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性指向我们要执行的工作任务，第二个属性指向内部使用的ammo.js库。我们需要执行的下一步是创建一个场景。Physijs提供了一个围绕Three.js普通场景的包装器，因此在您的代码中，您可以这样做来创建一个场景：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates a new scene where physics is applied, and we set the gravity. In
    this case, we set the gravity on the *y* axis to be `-10`. In other words, objects
    fall straight down. You can set, or change at runtime, the gravity for the various
    axes to any value you see fit, and the scene will respond accordingly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的场景，应用了物理，并设置了重力。在这种情况下，我们将* y *轴上的重力设置为`-10`。换句话说，物体直下落。您可以为各个轴设置或在运行时更改重力为任何您认为合适的值，场景将相应地做出响应。
- en: 'Before we can start simulating the physics in the scene, we need to add some
    objects. For this, we can use the normal way Three.js specifies objects, but we
    have to wrap them inside a specific Physijs object so that they can be managed
    by the Physijs library, as you can see in the following code fragment:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中开始模拟物理之前，我们需要添加一些对象。为此，我们可以使用Three.js指定对象的常规方式，但我们必须将它们包装在特定的Physijs对象中，以便它们可以被Physijs库管理，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we create a simple `THREE.BoxGeometry` object. Instead of creating
    `THREE.Mesh`, we create `Physijs.BoxMesh`, which tells Physijs to treat the shape
    of the geometry as a box when simulating physics and detecting collisions. Physijs
    provides a number of meshes you can use for the various shapes. More information
    on the available shapes can be found later in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建一个简单的`THREE.BoxGeometry`对象。我们不是创建`THREE.Mesh`，而是创建`Physijs.BoxMesh`，这告诉Physijs在模拟物理和检测碰撞时将几何形状视为盒子。Physijs提供了许多不同形状的网格供您使用。有关可用形状的更多信息可以在本章后面找到。
- en: 'Now that `THREE.BoxMesh` has been added to the scene, we have all the ingredients
    for the first Physijs scene. All that is left to do is tell Physijs to simulate
    the physics and update the position and rotation of the objects in our scene.
    We can do this by calling the simulate method on the scene we just created. So,
    for this, we change our basic render loop to the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`THREE.BoxMesh`已经添加到场景中，我们已经具备了第一个Physijs场景的所有要素。剩下的就是告诉Physijs模拟物理并更新场景中对象的位置和旋转。我们可以通过在我们刚刚创建的场景上调用simulate方法来实现这一点。因此，为此，我们将基本的渲染循环更改为以下内容：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And with that final step, by calling `scene.simulate()`, we have our basic setup
    for a Physijs scene. If we would run this example, though, we wouldn't see much.
    We would just see a single cube in the middle of the screen, which starts falling
    down as soon as the scene renders. So, let's look at a more complex example, where
    we'll simulate dominos falling down.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`scene.simulate()`这一最后一步，我们就完成了Physijs场景的基本设置。不过，如果我们运行这个例子，我们不会看到太多。我们只会看到屏幕中央的一个立方体，当场景渲染时开始下落。因此，让我们看一个更复杂的例子，模拟多米诺骨牌倒下的情况。
- en: 'For this example, we''re going to create the following scene:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将创建以下场景：
- en: '![Creating a basic Three.js scene](graphics/2215OS_12_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![创建基本的Three.js场景](graphics/2215OS_12_01.jpg)'
- en: 'If you open the `01-basic-scene.html` example in your browser, you''ll see
    a set of domino stones that start falling down as soon as the scene is loaded.
    The first one will tip over the second one, and so on. The complete physics of
    this scene is managed by Physijs. The only thing we did to start this animation
    is tip over the first domino. Creating this scene is actually very easy and only
    takes a few steps, which are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开`01-basic-scene.html`示例，您会看到一组多米诺石，当场景加载时开始倒下。第一个会推倒第二个，依此类推。这个场景的完整物理效果由Physijs管理。我们启动此动画的唯一操作是推倒第一个多米诺。实际上，创建这个场景非常简单，只需要几个步骤，如下所示：
- en: Define a Physijs scene.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个Physijs场景。
- en: Define the ground area that holds the stones.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义容纳石头的地面区域。
- en: Place the stones.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置石头。
- en: Tip over the first stone.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把第一块石头推倒。
- en: 'Let''s skip this first step since we''ve already seen how to do this and go
    directly to the second step, where we define the sandbox that contains all the
    stones. This sandbox is constructed out of a couple of boxes that are grouped
    together. The following is the code required to accomplish this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳过这一步，因为我们已经知道如何做，直接进入第二步，定义包含所有石头的沙盒。这个沙盒由几个箱子组成。以下是完成此操作所需的代码：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code isn't very complicated. First, we create a simple box that serves
    as the ground plane, and next we add a couple of borders to prevent objects falling
    off this ground plane. We add these borders to the ground object to create a compound
    object. This is an object that is treated by Physijs as a single object. There
    are a couple of other new things in this code that we'll explain in more depth
    in the following sections. The first one is `ground_material`, which we create.
    We use the `Physijs.createMaterial` function to create this material. This function
    wraps a standard Three.js material but allows us to set `friction` and `restitution`
    (bounciness) of the material. More on this can be found in the next section. Another
    new aspect is the final parameter we add to the `Physijs.BoxMesh` constructor.
    For all the `BoxMesh` objects we create in this section, we add `0` as the final
    parameter. With this parameter, we set the weight of the object. We do this to
    prevent the ground from being subject to the gravity in the scene so that it doesn't
    fall down.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不复杂。首先，我们创建一个简单的盒子作为地面平面，然后我们添加一些边界以防止物体从这个地面平面上掉下来。我们将这些边界添加到地面对象上，以创建一个复合对象。这是Physijs将作为单个对象处理的对象。在这段代码中还有一些其他新内容，我们将在接下来的章节中更深入地解释。第一个是我们创建的`ground_material`。我们使用`Physijs.createMaterial`函数来创建这种材料。这个函数包装了一个标准的Three.js材料，但允许我们设置材料的`摩擦`和`弹性`（弹性）属性。关于这一点的更多信息可以在下一节中找到。另一个新方面是我们添加到`Physijs.BoxMesh`构造函数的最后一个参数。对于我们在本节中创建的所有`BoxMesh`对象，我们将`0`作为最后一个参数添加。通过这个参数，我们设置了对象的重量。我们这样做是为了防止地面受到场景中的重力影响，以免它下落。
- en: 'Now that we have the ground, we can place the dominos. For this, we create
    simple `Three.BoxGeometry` instances that we wrap inside `BoxMesh` and place them
    at a specific position on top of the ground mesh, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了地面，我们可以放置多米诺骨牌。为此，我们创建简单的`Three.BoxGeometry`实例，将它们包裹在`BoxMesh`中，并将它们放置在地面网格的特定位置上，如下所示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We don't show the code where the position of each domino is calculated (see
    the `getPoints()` function in the source code of the example for this); this code
    just shows how the dominos are positioned. What you can see here is that we once
    again create `BoxMesh`, which wraps `THREE.BoxGeometry`. To make sure the dominos
    are aligned correctly, we use the `lookAt` function to set their correct rotation.
    If we don't do this, they'll all face the same way and won't fall down. We have
    to make sure that after we manually update the rotation (or the position) of a
    Physijs wrapped object, we tell Physijs that something has changed so that Physijs
    can update it's own internal representation of all the objects in the scene. For
    the rotation, we can do this with the internal `__dirtyRotation` property, and
    for the position, we set `__dirtyPosition` to `true`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不展示计算每个多米诺骨牌位置的代码（请参阅示例源代码中的`getPoints()`函数）；这段代码只是展示了多米诺骨牌的位置。您可以在这里看到，我们再次创建了`BoxMesh`，它包装了`THREE.BoxGeometry`。为了确保多米诺骨牌正确对齐，我们使用`lookAt`函数来设置它们正确的旋转。如果我们不这样做，它们将面向同一个方向，不会倒下。我们必须确保在手动更新Physijs包装对象的旋转（或位置）之后，告诉Physijs发生了变化，以便Physijs可以更新场景中所有对象的内部表示。对于旋转，我们可以使用内部的`__dirtyRotation`属性，对于位置，我们将`__dirtyPosition`设置为`true`。
- en: 'Now all that is left to do is tip the first domino. We do this by just setting
    the rotation on the *x* axis to 0.2, which tips it slightly. The gravity in the
    scene will do the rest and completely tip over the first domino. Here''s how we
    tip the first domino:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下要做的就是推第一个多米诺骨牌。我们只需将*x*轴上的旋转设置为0.2，稍微倾斜它。场景中的重力会完成剩下的工作，完全推倒第一个多米诺骨牌。以下是我们如何推第一个多米诺骨牌：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This completes the first example, which already shows a lot of features from
    Physijs. If you want to play around with the gravity, you can change it through
    the menu in the top-right corner. The change to the gravity is applied when you
    push the **resetScene** button:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了第一个示例，其中已经展示了Physijs的许多功能。如果您想要调整重力，可以通过右上角的菜单进行更改。当您按下**resetScene**按钮时，重力的更改将被应用：
- en: '![Creating a basic Three.js scene](graphics/2215OS_12_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![创建基本的Three.js场景](graphics/2215OS_12_02.jpg)'
- en: In the next section, we'll have a closer look at how the Physijs material properties
    affect the objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更仔细地看一下Physijs材质属性如何影响对象。
- en: Material properties
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材质属性
- en: 'Let''s begin with an explanation of the example. When you open up the `02-material-properties.html`
    example, you''ll see an empty box somewhat similar to the previous example. This
    box is rotating up and down around its *x* axis. In the menu in the top-right
    corner, you have several sliders that can be used to change some of the material
    properties of Physijs. These properties apply to the cubes and spheres you can
    add with the **addCubes** and **addSpheres** buttons. When you press the **addSpheres**
    button, five spheres will be added to the scene, and when you press the **addCubes**
    button, five cubes will be added. The following is an example demonstrating friction
    and restitution:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从示例的解释开始。当您打开`02-material-properties.html`示例时，您会看到一个空盒子，与之前的示例有些相似。这个盒子围绕其*x*轴上下旋转。在右上角的菜单中，您有几个滑块，可以用来改变Physijs的一些材质属性。这些属性适用于您可以使用**addCubes**和**addSpheres**按钮添加的立方体和球体。当您按下**addSpheres**按钮时，场景中将添加五个球体，当您按下**addCubes**按钮时，将添加五个立方体。以下是一个演示摩擦和恢复的示例：
- en: '![Material properties](graphics/2215OS_12_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![材质属性](graphics/2215OS_12_03.jpg)'
- en: 'This example allows you to play around with the `restitution` (bounciness)
    and `friction` properties that you can set when you create a Physijs material.
    If, for example, you set **cubeFriction** all the way to `1` and add some cubes,
    you''ll see that, even though the ground is moving, the cubes barely move. If
    you set **cubeFriction** to **0**, you''ll notice the cubes sliding around as
    soon as the ground stops being level. The following screenshot shows that high
    friction allows cubes to resist gravity:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例允许您玩弄在创建Physijs材质时可以设置的`restitution`（弹性）和`friction`属性。例如，如果您将**cubeFriction**设置为`1`并添加一些立方体，您会发现，即使地面在移动，立方体几乎不会移动。如果您将**cubeFriction**设置为**0**，您会注意到立方体在地面停止水平时立即滑动。以下截图显示了高摩擦力允许立方体抵抗重力：
- en: '![Material properties](graphics/2215OS_12_04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![材质属性](graphics/2215OS_12_04.jpg)'
- en: The other property you can set in this example is the `restitution` property.
    The `restitution` property defines how much of the energy that an object possesses
    is restituted when it collides. In other words, high restitution creates a bouncy
    object, and low restitution results in an object that stops immediately when it
    hits another object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此示例中设置的另一个属性是`restitution`属性。`restitution`属性定义了对象具有的能量在碰撞时有多少被恢复。换句话说，高恢复会创建一个有弹性的对象，低恢复会导致对象在碰撞时立即停止。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When you use a physics engine, you normally don't have to worry about detecting
    collisions. The engine will take care of that. It is, however, sometimes very
    useful to be informed when a collision between two objects occurs. For instance,
    you might want to create a sound effect, or when creating a game, deduct a life.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用物理引擎时，通常不必担心检测碰撞。引擎会处理这个问题。然而，有时候在两个对象发生碰撞时得到通知是非常有用的。例如，您可能想要创建一个声音效果，或者在创建游戏时扣除一条生命。
- en: 'With Physijs, you can add an event listener to a Physijs mesh, as shown in
    the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Physijs，您可以向Physijs网格添加事件侦听器，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This way, you'll be informed whenever this mesh collides with another of the
    meshes handled by Physijs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当此网格与Physijs处理的其他网格发生碰撞时，您将得到通知。
- en: A good way to demonstrate this is using spheres, setting the restitution to
    `1`, and clicking on the **addSpheres** button a couple of times. This will create
    a number of spheres that bounce everywhere.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的演示方法是使用球体，将恢复设置为`1`，然后点击**addSpheres**按钮几次。这将创建一些到处弹跳的球体。
- en: 'Before we move on to the next section, let''s look at a bit of code used in
    this example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一节之前，让我们先看一下这个示例中使用的一点代码：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the code that gets executed when we add spheres to the scene. This
    time, we use a different Physijs mesh: `Physijs.SphereMesh`. We''re creating `THREE.SphereGeometry,`
    and the best match from the set of meshes provided is, logically, `Physijs.SphereMesh`
    (more on this in the next section). When we create `Physijs.SphereMesh`, we pass
    in our geometry and use `Physijs.createMaterial` to create a Physijs-specific
    material. We do this so that we can set `friction` and `restitution` for this
    object.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当我们向场景添加球体时执行的代码。这一次，我们使用了不同的Physijs网格：`Physijs.SphereMesh`。我们创建了`THREE.SphereGeometry`，而提供的最佳匹配逻辑上是`Physijs.SphereMesh`（在下一节中会详细介绍）。当我们创建`Physijs.SphereMesh`时，我们传入我们的几何图形，并使用`Physijs.createMaterial`来创建一个Physijs特定的材质。我们这样做是为了可以为这个对象设置`摩擦`和`弹性`。
- en: Until now, we've seen `BoxMesh` and `SphereMesh`. In the next section, we'll
    explain and show the different types of meshes provided by Physijs that you can
    use to wrap your geometries.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了`BoxMesh`和`SphereMesh`。在下一节中，我们将解释并展示Physijs提供的不同类型的网格，你可以用它们来包装你的几何图形。
- en: Basic supported shapes
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本支持的形状
- en: Physijs provides a number of shapes you can use to wrap your geometries. In
    this section, we'll walk you through all the available Physijs meshes and demonstrate
    these meshes through an example. Remember that all you have to do to use these
    meshes is replace the `THREE.Mesh` constructor with one of these meshes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Physijs提供了一些形状，你可以用它们来包装你的几何图形。在本节中，我们将向你介绍所有可用的Physijs网格，并通过一个示例演示这些网格。记住，你只需要用这些网格之一替换`THREE.Mesh`构造函数即可使用这些网格。
- en: 'The following table provides an overview of the meshes that are available in
    Physijs:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了Physijs中可用的网格的概述：
- en: '| Name | Description |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: 名称 | 描述 |
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '--- | --- |'
- en: '| `Physijs.PlaneMesh` | This mesh can be used to create a zero-thickness plane.
    You could also use `BoxMesh` for this together with `THREE.BoxGeometry` with low
    height. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '`Physijs.PlaneMesh` | 这个网格可以用来创建一个零厚度的平面。你也可以使用`BoxMesh`和`THREE.BoxGeometry`以及低高度一起使用。'
- en: '| `Physijs.BoxMesh` | If you have geometries that look like cubes, use this
    mesh. For instance, this is a good match for `THREE.BoxGeometry`. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '`Physijs.BoxMesh` | 如果你有类似立方体的几何图形，使用这个网格。例如，这是`THREE.BoxGeometry`的一个很好的匹配。'
- en: '| `Physijs.SphereMesh` | For sphere shapes, use this geometry. This geometry
    is a good match for `THREE.SphereGeometry`. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '`Physijs.SphereMesh` | 对于球形，使用这个几何图形。这个几何图形是`THREE.SphereGeometry`的一个很好的匹配。'
- en: '| `Physijs.CylinderMesh` | With `THREE.Cylinder`, you can create various cylinder-like
    shapes. Physijs provides multiple meshes depending on the shape of the cylinder.
    `Physijs.CylinderMesh` should be used for a normal cylinder with the same top
    radius and bottom radius. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '`Physijs.CylinderMesh` | 使用`THREE.Cylinder`，你可以创建各种类似圆柱体的形状。根据圆柱体的形状，Physijs提供了多个网格。`Physijs.CylinderMesh`应该用于具有相同顶部半径和底部半径的普通圆柱体。'
- en: '| `Physijs.ConeMesh` | If you specify the top radius as `0` and use a positive
    value for the bottom radius, you can use `THREE.Cylinder` to create a cone. If
    you want to apply physics to such an object, the best fit from Physijs is `ConeMesh`.
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '`Physijs.ConeMesh` | 如果你将顶部半径指定为`0`，并使用底部半径的正值，你可以使用`THREE.Cylinder`来创建一个圆锥。如果你想对这样的对象应用物理效果，Physijs中最合适的选择是`ConeMesh`。'
- en: '| `Physijs.CapsuleMesh` | A capsule is just like `THREE.Cylinder`, but with
    a rounded top and a rounded bottom. We''ll show you how to create a capsule in
    Three.js later on in this section. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '`Physijs.CapsuleMesh` | 胶囊体就像`THREE.Cylinder`，但顶部和底部都是圆形的。我们稍后将向你展示如何在Three.js中创建一个胶囊体。'
- en: '| `Physijs.ConvexMesh` | `hysijs.ConvexMesh` is a rough shape you can use for
    more complex objects. It creates a convex (just like `THREE.ConvexGeometry`) to
    approximate the shape of complex objects. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '`Physijs.ConvexMesh` | `hysijs.ConvexMesh`是一个粗糙的形状，你可以用它来创建更复杂的对象。它创建一个凸面（就像`THREE.ConvexGeometry`）来近似复杂对象的形状。'
- en: '| `Physijs.ConcaveMesh` | While `ConvexMesh` is a rough shape, `ConcaveMesh`
    is a more detailed representation of your complex geometry. Note that the performance
    penalty of using `ConcaveMesh` is very high. Usually, it is better to either create
    separate geometries with their own specific Physijs meshes or group them together
    (as we do with the floors shown in the previous examples). |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '`Physijs.ConcaveMesh` | 虽然`ConvexMesh`是一个粗糙的形状，`ConcaveMesh`是你复杂几何图形的更详细的表示。请注意，使用`ConcaveMesh`会有很高的性能惩罚。通常，最好是要么创建具有自己特定Physijs网格的单独几何图形，要么将它们组合在一起（就像我们在前面的示例中所做的那样）。'
- en: '| `Physijs.HeightfieldMesh` | This mesh is a very specialized one. With this
    mesh, you can create a height field from `THREE.PlaneGeometry`. Look at the `03-shapes.html`
    example for this mesh. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '`Physijs.HeightfieldMesh` | 这个网格是一个非常专业化的网格。使用这个网格，你可以从`THREE.PlaneGeometry`创建一个高度场。查看`03-shapes.html`示例以了解这个网格。'
- en: We'll quickly walk you through these shapes using `03-shapes.html` as a reference.
    We won't explain `Physijs.ConcaveMesh` any further since its usage is very limited.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速浏览这些形状，使用`03-shapes.html`作为参考。我们不会进一步解释`Physijs.ConcaveMesh`，因为它的使用非常有限。
- en: 'Before we look at the example, we''ll first have a quick look at `Physijs.PlaneMesh`.
    This mesh creates a simple plane based on `THREE.PlaneGeometry`, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看示例之前，让我们先快速看一下`Physijs.PlaneMesh`。这个网格基于`THREE.PlaneGeometry`创建一个简单的平面，如下所示：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this function, you can see that we just pass in a simple `THREE.PlaneGeometry`
    to create this mesh. If you add this to the scene, you''ll notice something strange.
    The mesh you just created doesn''t respond to gravity. The reason is that `Physijs.PlaneMesh`
    has a fixed weight of `0`, so it won''t respond to gravity or be moved by collisions
    with other objects. Besides this mesh, all the other meshes respond to gravity
    and collisions, as you''d expect. The following screenshot shows a height field
    on which the various supported shapes can be dropped:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，您可以看到我们只是传入一个简单的`THREE.PlaneGeometry`来创建这个网格。如果您将其添加到场景中，您会注意到一些奇怪的事情。您刚刚创建的网格不会对重力产生反应。原因是`Physijs.PlaneMesh`的固定重量为`0`，因此它不会对重力产生反应，也不会被其他对象的碰撞移动。除了这个网格，所有其他网格都会对重力和碰撞产生反应，就像您所期望的那样。以下截图显示了一个高度场，您可以在其中放置各种支持的形状：
- en: '![Basic supported shapes](graphics/2215OS_12_05.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![基本支持的形状](graphics/2215OS_12_05.jpg)'
- en: The previous image shows the `03-shapes.html` example. In this example, we've
    created a random height field (more on that later) and have a menu in the top-right
    corner that you can use to drop objects of various shapes. If you play around
    with this example, you'll see how different shapes respond differently to the
    height map and in collisions with other objects.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像显示了`03-shapes.html`示例。在这个示例中，我们创建了一个随机高度场（稍后会详细介绍），并在右上角有一个菜单，您可以使用它来放置各种形状的对象。如果您尝试这个示例，您会看到不同的形状如何对高度图和与其他对象的碰撞产生不同的响应。
- en: 'Let''s look at the construction of some of these shapes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些这些形状的构造：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There''s nothing special here; we create a geometry and use the best matching
    mesh from Physijs to create the object we add to the scene. However, what if we
    want to use `Physijs.CapsuleMesh`? Three.js doesn''t contain a capsule-like geometry,
    so we have to create one ourselves. Here''s the code for this purpose:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的；我们创建一个几何体，并使用Physijs中最匹配的网格来创建我们添加到场景中的对象。然而，如果我们想要使用`Physijs.CapsuleMesh`呢？Three.js中没有类似胶囊的几何体，所以我们必须自己创建一个。以下是为此目的编写的代码：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`Physijs.CapsuleMesh` looks like a cylinder but has a rounded top and bottom.
    We can easily recreate this in Three.js by creating a cylinder (`cyl`) and two
    spheres (`top` and `bot`) and merging them together using the `merge()` function.
    The following screenshot shows a number of capsules rolling down the height map:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Physijs.CapsuleMesh`看起来像一个圆柱体，但顶部和底部是圆角的。我们可以通过创建一个圆柱体（`cyl`）和两个球体（`top`和`bot`），然后使用`merge()`函数将它们合并在一起来轻松地在Three.js中重新创建这个形状。以下截图显示了一些胶囊体沿着高度图滚动：'
- en: '![Basic supported shapes](graphics/2215OS_12_06.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![基本支持的形状](graphics/2215OS_12_06.jpg)'
- en: 'Before we look at the height map, let''s look at the last of the shapes you
    can add to this example, `Physijs.ConvexMesh`. A convex is the minimal shape that
    wraps all the vertices of a geometry. The resulting shape will only have angles
    smaller than 180 degrees. You would use this mesh for complex shapes such as torus
    knots, as shown in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看高度图之前，让我们来看看您可以添加到这个示例中的最后一个形状，`Physijs.ConvexMesh`。凸包是包裹几何体所有顶点的最小形状。结果形状将只有小于180度的角。您可以将此网格用于复杂的形状，如环面结，如下所示：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, for physics simulation and collisions, the convex of the torus
    knot will be used. This is a very good way to apply physics and detect collisions
    for complex objects, while still minimizing the performance impact.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对于物理模拟和碰撞，将使用环面结的凸包。这是一种非常好的方法，可以应用物理效果并检测复杂对象的碰撞，同时最小化性能影响。
- en: 'The last mesh from Physijs to discuss is `Physijs.HeightMap`. The following
    screenshot shows a height map created with Physijs:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Physijs中讨论的最后一个网格是`Physijs.HeightMap`。以下截图显示了使用Physijs创建的高度图：
- en: '![Basic supported shapes](graphics/2215OS_12_07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![基本支持的形状](graphics/2215OS_12_07.jpg)'
- en: 'With a height map, you can very easily create a terrain that contains bumps
    and shallows. Using `Physijs.Heightmap`, we make sure all the objects respond
    correctly to the height differences of this terrain. Let''s look at the code required
    to accomplish this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高度图，您可以非常容易地创建一个包含凸起和浅滩的地形。使用`Physijs.Heightmap`，我们确保所有对象对这个地形的高度差作出正确的响应。让我们来看看完成这个任务所需的代码：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code fragment, we take a couple of steps to create the height map you
    can see in the example. First off, we create the Physijs material and a simple
    `PlaneGeometry` object. To create a bumpy terrain from `PlaneGeometry`, we walk
    through each of the vertices of this geometry and randomly set the `z` property.
    For this, we use a Perlin noise generator to create a bump map just as we used
    in the *Using the canvas as a bump map* section of [Chapter 10](ch10.html "Chapter 10. Loading
    and Working with Textures"), *Loading and Working with Textures*. We need to call
    `computeFaceNormals` and `computeVertexNormals` to make sure the texture, lighting,
    and shadows are rendered correctly. At this point, we have `PlaneGeometry`, which
    contains the correct height information. With `PlaneGeometry`, we can create `Physijs.HeightFieldMesh`.
    The last two parameters for the constructor take the number of horizontal and
    vertical segments of `PlaneGeometry` and should match the last two properties
    used to construct `PlaneGeometry`. Finally, we rotate `HeightFieldMesh` to the
    position we want and add it to the scene. All other Physijs objects will now interact
    correctly with this height map.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，我们采取了几个步骤来创建您在示例中看到的高度图。首先，我们创建了Physijs材质和一个简单的`PlaneGeometry`对象。为了从`PlaneGeometry`创建一个崎岖的地形，我们遍历这个几何体的每个顶点，并随机设置`z`属性。为此，我们使用Perlin噪声生成器来创建一个凸起地图，就像我们在[第10章](ch10.html
    "第10章。加载和使用纹理")的*使用画布作为凸起地图*部分中使用的那样，*加载和使用纹理*。我们需要调用`computeFaceNormals`和`computeVertexNormals`来确保纹理、光照和阴影被正确渲染。在这一点上，我们有了包含正确高度信息的`PlaneGeometry`。使用`PlaneGeometry`，我们可以创建`Physijs.HeightFieldMesh`。构造函数的最后两个参数取`PlaneGeometry`的水平和垂直段数，并应与用于构造`PlaneGeometry`的最后两个属性匹配。最后，我们将`HeightFieldMesh`旋转到我们想要的位置，并将其添加到场景中。所有其他Physijs对象现在将正确地与这个高度图交互。
- en: Using constraints to limit movement of objects
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用约束来限制对象的移动
- en: 'Until now, we''ve seen some basic physics in action. We''ve seen how the various
    shapes respond to gravity, friction, and restitution and how they affect collisions.
    Physijs also provides advanced constructs that allow you to limit the movement
    of your objects. In Physijs, these objects are called constraints. The following
    table gives an overview of the constraints that are available in Physijs:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些基本的物理现象。我们已经看到了各种形状如何对重力、摩擦和恢复力作出反应，以及它们如何影响碰撞。Physijs还提供了高级构造，允许您限制对象的运动。在Physijs中，这些对象被称为约束。以下表格概述了Physijs中可用的约束：
- en: '| Constraint | Description |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 约束 | 描述 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PointConstraint` | This allows you to fix the position of one object to
    the position of another object. If one object moves, the other will move with
    it, keeping the distance and orientation between them the same. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `PointConstraint` | 这允许您将一个对象的位置固定到另一个对象的位置。如果一个对象移动，另一个对象也会随之移动，保持它们之间的距离和方向不变。
    |'
- en: '| `HingeConstraint` | `HingeConstraint` allows you to limit the movement of
    an object as if it were on a hinge, such as a door. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `HingeConstraint` | `HingeConstraint`允许您限制物体的运动，就像它是在铰链上一样，比如门。 |'
- en: '| `SliderConstraint` | This constraint, as the name implies, allows you to
    limit the movement of an object to a single axis, for instance, a sliding door.
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `SliderConstraint` | 这个约束，正如其名称所示，允许您限制物体在一个单一轴上的运动，比如滑动门。 |'
- en: '| `ConeTwistConstraint` | With this constraint, you can limit the rotation
    and the movement of one object to another. This constraint functions like a ball-and-socket
    joint, for instance, the way your arm moves in your shoulder socket. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `ConeTwistConstraint` | 使用这个约束，您可以限制一个对象相对于另一个对象的旋转和运动。这个约束的功能类似于球和插座连接，比如您的手臂在肩膀插座中的移动方式。
    |'
- en: '| `DOFConstraint` | `DOFConstraint` allows you to specify the limit of movement
    around any of the three axes, and it allows you to set the minimum and maximum
    angle that is allowed. This is the most versatile of the constraints available.
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `DOFConstraint` | `DOFConstraint`允许您指定围绕任意三个轴的运动限制，并允许您设置允许的最小和最大角度。这是可用的约束中最通用的一个。
    |'
- en: 'The easiest way to understand these constraints is to see them in action and
    play around with them. For this, we''ve provided an example where all these constraints
    are used together, `04-physijs-constraints.js`. The following screenshot shows
    this example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些约束的最简单方法是看到它们在实际中的作用并与它们一起玩耍。为此，我们提供了一个使用所有这些约束的例子，`04-physijs-constraints.js`。以下截图显示了这个例子：
- en: '![Using constraints to limit movement of objects](graphics/2215OS_12_08.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![使用约束来限制物体的移动](graphics/2215OS_12_08.jpg)'
- en: Based on this example, we'll walk you through four of these five constraints.
    For `DOFConstraint`, we've created a separate example. The first one we look at
    is `PointConstraint`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个例子，我们将为您介绍这五个约束中的四个。对于`DOFConstraint`，我们创建了一个单独的例子。我们首先看的是`PointConstraint`。
- en: Using PointConstraint to limit movement between two points
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PointConstraint来限制两个点之间的移动
- en: If you open the example, you'll see two red spheres. These two spheres are connected
    to each other using `PointConstraint`. With the menu in the top-left corner, you
    can move the green sliders around. As soon as one of the sliders hits one of the
    red spheres, you'll see that both of them move in the same manner, and they keep
    the distance between them the same, while still complying with weight, gravity,
    friction, and other aspects of physics.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开这个例子，您会看到两个红色的球体。这两个球体使用`PointConstraint`连接在一起。在左上角的菜单中，您可以移动绿色的滑块。一旦其中一个滑块碰到一个红色的球体，您会看到它们两个以相同的方式移动，并且它们保持相同的距离，同时仍然遵守重量、重力、摩擦和其他物理方面的规则。
- en: '`PointConstraint` in this example was created as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`PointConstraint`是这样创建的：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, you can see that we create objects using a Physijs-specific mesh (`SphereMesh`
    in this case) and add them to the scene. We use the `Physijs.PointConstraint`
    constructor to create the constraint. This constraint takes three parameters:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们使用了Physijs特定的网格（在这种情况下是`SphereMesh`）来创建对象，并将它们添加到场景中。我们使用`Physijs.PointConstraint`构造函数来创建约束。这个约束需要三个参数：
- en: The first two arguments define which objects you want to connect to each other.
    In this case, we connect the two spheres to one another.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个参数定义了您想要连接在一起的对象。在这种情况下，我们将两个球体连接在一起。
- en: The third argument defines to what position the constraint is bound. For instance,
    if you bind the first object to a very large object, you can set this position,
    for instance, to the right-hand side of that object. Usually, if you just want
    to connect two objects together, a good choice is to just set it to the position
    of the second object.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数定义了约束绑定的位置。例如，如果您将第一个对象绑定到一个非常大的对象，您可以将这个位置设置为该对象的右侧。通常，如果您只想连接两个对象在一起，一个很好的选择就是将它设置为第二个对象的位置。
- en: If you don't want to fix an object to another one, but to a static position
    in the scene, you can omit the second parameter. In that case, the first object
    keeps the same distance to the position you specified, while complying with gravity
    and other aspects of physics, of course.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想将一个对象固定到另一个对象，而是固定到场景中的一个静态位置，您可以省略第二个参数。在这种情况下，第一个对象保持与您指定的位置相同的距离，当然也遵守重力和其他物理方面的规则。
- en: Once the constraint is created, we can enable it by adding it to the scene with
    the `addConstraint` function. As you start experimenting with constraints, you'll
    likely run into some strange issues. To make debugging easier, you can pass in
    `true` to the `addConstraint` function. If you do this, the constraint point and
    orientation is shown in the scene. This can help you get the rotation and position
    of your constraint correctly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦约束被创建，我们可以通过使用`addConstraint`函数将其添加到场景中来启用它。当您开始尝试使用约束时，您可能会遇到一些奇怪的问题。为了使调试更容易，您可以向`addConstraint`函数传递`true`。如果这样做，约束点和方向将显示在场景中。这可以帮助您正确获取约束的旋转和位置。
- en: Creating door-like constraints with HingeConstraint
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HingeConstraint创建类似门的约束
- en: '`HingeConstraint`, as the name implies, allows you to create an object that
    behaves like a hinge. It rotates around a specific axis, limiting the movement
    to a specified angle. In our example, `HingeConstraint` is shown with two white
    flippers at the center of the scene. These flippers are constrained to the small,
    brown cubes and can rotate around them. If you want to play around with these
    hinges, you can enable them by checking the `enableMotor` box in the **hinge**
    menu. This will accelerate the flippers to the velocity specified in the **general**
    menu. A negative velocity will move the hinges down, and a positive velocity will
    move them up. The following screenshot shows the hinges in the up position and
    in the down position:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`HingeConstraint`，顾名思义，允许您创建一个行为类似铰链的对象。它围绕特定轴旋转，将运动限制在指定的角度内。在我们的示例中，`HingeConstraint`显示为场景中心的两个白色弹簧板。这些弹簧板受约束于小的棕色立方体，并可以围绕它们旋转。如果您想要玩弄这些铰链，您可以通过在**铰链**菜单中勾选`enableMotor`框来启用它们。这将加速弹簧板到**general**菜单中指定的速度。负速度将使铰链向下移动，正速度将使其向上移动。以下屏幕截图显示了铰链处于上升位置和下降位置：'
- en: '![Creating door-like constraints with HingeConstraint](graphics/2215OS_12_09.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![使用HingeConstraint创建类似门的约束](graphics/2215OS_12_09.jpg)'
- en: 'Let''s take a closer look at how we created one of these flippers:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们是如何创建其中一个弹簧板的：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This constraint takes four parameters. Let''s look at each one in a bit more
    detail:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此约束接受四个参数。让我们更详细地看看每个参数：
- en: '| Parameter | Description |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mesh_a` | The first object passed into the function is the object that is
    to be constrained. In this example, the first object is the white cube that serves
    as the flipper. This is the object that is constrained in its movements. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `mesh_a` | 传递到函数中的第一个对象是要约束的对象。在本例中，第一个对象是作为弹簧板的白色立方体。这是受约束的对象在其运动中受到约束的对象。'
- en: '| `mesh_b` | The second object defines to which object `mesh_a` is constrained.
    In this example, `mesh_a` is constrained to the small, brown cube. If we move
    this mesh around, `mesh_a` would follow it around, still keeping `HingeConstraint`
    in place. You''ll see that all constraints have this option. You could, for instance,
    use this if you''ve created a car that moves around and want to create a constraint
    for opening a door. If this second parameter is omitted, the hinge will be constrained
    to the scene (and never be able to move around). |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `mesh_b` | 第二个对象定义了`mesh_a`约束到哪个对象。在本例中，`mesh_a`受约束于小的棕色立方体。如果我们移动此网格，`mesh_a`将跟随它移动，仍然保持`HingeConstraint`在原位。您会发现所有约束都有这个选项。例如，如果您创建了一个四处移动的汽车，并希望创建一个打开门的约束，您可以使用此选项。如果省略了第二个参数，铰链将受到场景的约束（永远无法移动）。'
- en: '| `position` | This is the point where the constraint is applied. In this case,
    it''s the hinge point around which `mesh_a` rotates. If you''ve specified `mesh_b`,
    this hinge point will move around with the position and rotation of `mesh_b`.
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `position` | 这是应用约束的点。在本例中，它是`mesh_a`围绕其旋转的铰链点。如果您指定了`mesh_b`，则此铰链点将随着`mesh_b`的位置和旋转而移动。'
- en: '| `axis` | This is the axis around which the hinge should rotate. In this example,
    we''ve set the hinge horizontally (0,1,0). |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `axis` | 这是铰链应该围绕其旋转的轴。在本例中，我们将铰链水平设置为(0,1,0)。'
- en: Adding `HingeConstraint` to the scene works in the same way as we've seen with
    `PointConstraint`. You use the `addConstraint` method, specify the constraint
    to add, and optionally add `true` to show the exact location and orientation of
    the constraint for debugging purposes. For `HingeConstraint`, however, we also
    need to define the range of movement that is allowed. We do this with the `setLimits`
    function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 向场景添加`HingeConstraint`的方式与我们在`PointConstraint`中看到的方式相同。您使用`addConstraint`方法，指定要添加的约束，并可选择添加`true`以显示约束的确切位置和方向，以进行调试。然而，对于`HingeConstraint`，我们还需要定义允许的运动范围。我们使用`setLimits`函数来实现这一点。
- en: 'This function takes the following four parameters:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受以下四个参数：
- en: '| Parameter | Description |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `low` | This is the minimum angle, in radians, of motion. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `low` | 运动的最小角度，以弧度表示。'
- en: '| `high` | This is the maximum angle, in radians, of motion. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `high` | 运动的最大角度，以弧度表示。'
- en: '| `bias_factor` | This property defines the rate with which the constraint
    corrects itself after an error in position. For instance, when the hinge is pushed
    out of its constraints by a different object, it will move itself to its correct
    position. The higher this value, the faster it will correct its position. It is
    best to keep it below `0.5`. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `bias_factor` | 此属性定义约束在位置错误后纠正自身的速率。例如，当铰链被不同对象推出其约束时，它将移动到正确的位置。此值越高，它纠正位置的速度就越快。最好将其保持在`0.5`以下。'
- en: '| `relaxation_factor` | This defines the rate at which the velocity is changed
    by the constraint. If this is set to a high value, the object will bounce when
    it reaches its minimum or maximum angle of motion. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `relaxation_factor` | 这定义了约束改变速度的速率。如果设置为较高的值，当达到运动的最小或最大角度时，对象将会弹跳。'
- en: 'You can change these properties at runtime if you want. If you add `HingeConstraint`
    with these properties, you won''t see much movement. The mesh will only move when
    hit by another object or based on gravity. This constraint, as with many others,
    however, can also be moved by an internal motor. This is what you see when you
    check the `enableMotor` box in the **hinge** submenu from our example. The following
    code is used to enable this motor:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在运行时更改这些属性。如果您使用这些属性添加`HingeConstraint`，您将看不到太多移动。只有当网格被另一个对象击中或基于重力时，网格才会移动。然而，许多其他约束也可以通过内部电机移动。当您在我们的示例中检查**铰链**子菜单中的`enableMotor`框时，您会看到这一点。以下代码用于启用此电机：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will speed up the mesh (in our case, the flipper) to the specified velocity
    using the acceleration provided. If we want to move the flipper the other way,
    we just specify a negative velocity. If we didn''t have any limits, this would
    cause our flipper to rotate as long as our motor kept running. To disable a motor,
    we can just call the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用提供的加速度将网格（在我们的例子中是弹簧板）加速到指定的速度。如果我们想让弹簧板向另一个方向移动，我们只需指定一个负速度。如果我们没有任何限制，这将导致我们的弹簧板只要电机持续运行就会旋转。要禁用电机，我们只需调用以下代码：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now the mesh will slow down based on friction, collisions, gravity, and other
    aspects of physics.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在网格会根据摩擦、碰撞、重力和其他物理方面减速。
- en: Limiting movement to a single axis with SliderConstraint
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SliderConstraint限制运动到单一轴
- en: 'The next constraint is `SliderConstraint`. With this constraint, you can limit
    the movement of an object to any one of its axes. The green sliders in the `04-constraints.html`
    example can be controlled from the **sliders** submenu. The following screenshot
    shows this example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个约束是`SliderConstraint`。使用这个约束，你可以限制物体沿着任意一个轴的运动。在`04-constraints.html`示例中，绿色的滑块可以从**滑块**子菜单中控制。以下截图显示了这个例子：
- en: '![Limiting movement to a single axis with SliderConstraint](graphics/2215OS_12_10.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![使用SliderConstraint限制运动到单一轴](graphics/2215OS_12_10.jpg)'
- en: 'With the **SlidersLeft** button, the sliders will move to the left-hand side
    (their lower limit), and with the **SlidersRight** button, they will move to the
    right-hand side (their upper limit). Creating these constraints from code is very
    easy:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**SlidersLeft**按钮，滑块将移动到左侧（它们的下限），使用**SlidersRight**按钮，它们将移动到右侧（它们的上限）。从代码中创建这些约束非常容易：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see from the code, this constraint takes three arguments (or four
    if you want to constrain an object to another object). The following table explains
    the arguments for this constraint:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中可以看出，这个约束需要三个参数（如果你想将一个对象约束到另一个对象，则需要四个参数）。以下表格解释了这个约束的参数：
- en: '| Parameter | Description |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mesh_a` | The first object passed into the function is the object that is
    to be constrained. In this example, the first object is the green cube that serves
    as the slider. This is the object that will be constrained in its movements. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `mesh_a` | 传入函数的第一个对象是要约束的对象。在这个例子中，第一个对象是作为滑块的绿色立方体。这是将在其运动中受到约束的对象。 |'
- en: '| `mesh_b` | This is the second object, which defines to which object `mesh_a`
    is constrained. This is an optional argument and omitted in this example. If omitted,
    the mesh will be constrained to the scene. If it is specified, the slider will
    move around when this mesh moves around or when its orientation changes. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `mesh_b` | 这是第二个对象，定义了`mesh_a`被约束到哪个对象。这是一个可选参数，在这个例子中被省略了。如果省略，网格将被约束到场景。如果指定了，当这个网格移动或其方向改变时，滑块将随之移动。
    |'
- en: '| `position` | This is the point where the constraint is applied. This is especially
    important when you constrain `mesh_a` to `mesh_b`. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `position` | 这是约束应用的点。当你将`mesh_a`约束到`mesh_b`时，这一点尤为重要。 |'
- en: '| `axis` | This is the axis on which `mesh_a` will slide. Note that this is
    relative to the orientation of `mesh_b` if it is specified. In the current version
    of Physijs, there seems to be a strange offset to this axis when using a linear
    motor with linear limits. The following works for this version if you want to
    slide along:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '| `axis` | 这是`mesh_a`将要滑动的轴。请注意，如果指定了`mesh_b`，这是相对于`mesh_b`的方向。在当前版本的Physijs中，使用线性电机和线性限制时，这个轴似乎有一个奇怪的偏移。如果你想沿着这个方向滑动，以下内容适用于这个版本：'
- en: 'The *x* axis: `new` `THREE.Vector3(0,1,0)`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*轴：`new` `THREE.Vector3(0,1,0)`'
- en: 'The *y* axis: `new` `THREE.Vector3(0,0,Math.PI/2)`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*y*轴：`new` `THREE.Vector3(0,0,Math.PI/2)`'
- en: 'The *z* axis: `new` `THREE.Vector3(Math.PI/2,0,0)`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*z*轴：`new` `THREE.Vector3(Math.PI/2,0,0)`'
- en: '|'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'After you''ve created the constraint and added it to the scene using `scene.addConstraint`,
    you can set the `constraint.setLimits(-10,` `10,` `0,` `0)` limits for this constraint
    to specify how far the slider may slide. You can set the following limits on `SliderConstraint`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建约束并使用`scene.addConstraint`将其添加到场景后，你可以设置`constraint.setLimits(-10, 10, 0,
    0)`来指定这个约束的限制，以确定滑块可以滑动多远。你可以在`SliderConstraint`上设置以下限制：
- en: '| Parameter | Description |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `linear_lower` | This is the lower linear limit of the object |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `linear_lower` | 这是物体的线性下限 |'
- en: '| `linear_upper` | This is the upper linear limit of the object |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `linear_upper` | 这是物体的线性上限 |'
- en: '| `angular_lower` | This is the lower angular limit of the object |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `angular_lower` | 这是物体的角度下限 |'
- en: '| `angular_higher` | This is the upper angular limit of the object |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `angular_higher` | 这是物体的角度上限 |'
- en: Finally, you can set the restitution (the bounce) that'll occur when you hit
    one of these limits. You do this with `constraint.setRestitution(res_linear,`
    `res_angular)`, where the first parameter sets the amount of bounce when you hit
    the linear limit and the second one sets the amount of bounce when you hit the
    angular limit.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你击中这些限制时，你可以设置恢复（弹跳）的大小。你可以使用`constraint.setRestitution(res_linear, res_angular)`来设置，第一个参数设置线性限制时的弹跳量，第二个参数设置角限制时的弹跳量。
- en: 'Now, the complete constraint has been configured, and we can wait until collisions
    occur that slide the object around or use a motor. For `SlideConstraint`, we have
    two options: we can use an angular motor to accelerate along the axis we specified,
    complying with the angular limits we set, or use a linear motor to accelerate
    along the axis we specified, complying with the linear limits. In this example,
    we used a linear motor. For using an angular motor, take a look at `DOFConstraint`,
    which is explained later on in this chapter.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，完整的约束已经配置好了，我们可以等待碰撞发生，使物体滑动，或者使用电机。对于`SlideConstraint`，我们有两个选择：我们可以使用角度电机沿着我们指定的轴加速，遵守我们设置的角度限制，或者使用线性电机沿着我们指定的轴加速，遵守我们设置的线性限制。在这个例子中，我们使用了线性电机。要使用角度电机，请看后面在本章中解释的`DOFConstraint`。
- en: Creating a ball-and-socket-joint-like constraint with ConeTwistConstraint
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`ConeTwistConstraint`创建类似球和插座的约束
- en: 'With `ConeTwistConstraint`, it is possible to create a constraint where the
    movement is limited to a set of angles. We can specify what the minimum and maximum
    angle is from one object to the other for the *x*, *y*, and *z* axes. The following
    screenshot shows that `ConeTwistConstraint` allows you to move an object around
    a reference at certain angles:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ConeTwistConstraint`，可以创建一个受限于一组角度的约束。我们可以指定从一个对象到另一个对象的*x*、*y*和*z*轴的最小和最大角度。以下截图显示了`ConeTwistConstraint`允许您以一定角度围绕参考点移动对象：
- en: '![Creating a ball-and-socket-joint-like constraint with ConeTwistConstraint](graphics/2215OS_12_11.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![使用ConeTwistConstraint创建类似球和插座的约束](graphics/2215OS_12_11.jpg)'
- en: 'The easiest way to understand `ConeTwistConstraint` is by looking at the code
    required to create one. The code required to accomplish this is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`ConeTwistConstraint`最简单的方法是看一下创建它所需的代码。实现这一点所需的代码如下：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this piece of JavaScript, you''ll probably already recognize a number of
    concepts we discussed earlier. We start with creating the objects that we connect
    to each other with the constraint: `objectOne` (a sphere) and `objectTwo` (a box).
    We position these objects so that `objectTwo` hangs below `objectOne`. Now we
    can create `ConeTwistConstraint`. The arguments this constraint takes aren''t
    anything new if you''ve already looked at the other constraints. The first parameter
    is the object to constrain, the second parameter is the object to which the first
    object is constrained, and the last parameter is the location where the constraint
    is constructed (in this case, it''s the point around which `objectOne` rotates).
    After adding the constraint to the scene, we can set its limits with the `setLimit`
    function. This function takes three radian values that specify the maximum angle
    for each of the axes.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段JavaScript代码中，你可能已经认识到了我们之前讨论过的许多概念。我们首先创建了两个对象，并用约束将它们连接起来：`objectOne`（一个球体）和`objectTwo`（一个立方体）。我们将这些对象定位，使得`objectTwo`悬挂在`objectOne`下方。现在我们可以创建`ConeTwistConstraint`。如果你已经看过其他约束的话，那么这个约束所需的参数并不陌生。第一个参数是要约束的对象，第二个参数是第一个对象要被约束到的对象，最后一个参数是约束被构建的位置（在这种情况下，是`objectOne`围绕其旋转的点）。在将约束添加到场景后，我们可以使用`setLimit`函数设置其限制。这个函数接受三个弧度值，用来指定每个轴的最大角度。
- en: 'Just as with most of the other constraints, we can move `objectOne` using the
    motor provided by the constraint. For `ConeTwistConstraint`, we set `MaxMotorImpulse`
    (how much force the motor can apply), and we set the target angles the motor should
    move `objectOne` to. In this example, we move it to its resting position directly
    below the sphere. You can play around with this example, as shown in the following
    screenshot, by setting this target value:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数其他约束一样，我们可以使用约束提供的马达来移动`objectOne`。对于`ConeTwistConstraint`，我们设置了`MaxMotorImpulse`（马达可以施加的力量），并设置了马达应该将`objectOne`移动到的目标角度。在这个例子中，我们将其移动到其直接在球体下方的静止位置。您可以通过设置这个目标值来玩弄这个例子，如下面的截图所示：
- en: '![Creating a ball-and-socket-joint-like constraint with ConeTwistConstraint](graphics/2215OS_12_12.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![使用ConeTwistConstraint创建类似球和插座的约束](graphics/2215OS_12_12.jpg)'
- en: The last constraint we'll look at is also the most versatile—`DOFConstraint`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的最后一个约束也是最通用的——`DOFConstraint`。
- en: Creating detailed control with DOFConstraint
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DOFConstraint创建详细控制
- en: '`DOFConstraint`, also called the degree of freedom constraint, allows you to
    exactly control an object''s linear and angular movement. We''ll show how to use
    this constraint by creating an example where you can drive around a simple, car-like
    shape. This shape consists of a single rectangle that serves as the body and four
    spheres that serve as the wheels. Let''s start by creating the wheels:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`DOFConstraint`，也称为自由度约束，允许您精确控制对象的线性和角运动。我们将通过创建一个示例来展示如何使用这个约束，您可以在这个示例中驾驶一个简单的类似汽车的形状。这个形状由一个作为车身的矩形和四个作为车轮的球体组成。让我们从创建车轮开始：'
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this piece of code, we just created a simple `CylinderGeometry` and `CylinderMesh`
    object, which can be used as the wheels for our car. The following screenshot
    depicts the result of the preceding code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们只是创建了一个简单的`CylinderGeometry`和`CylinderMesh`对象，它们可以作为我们汽车的车轮。以下截图展示了前面代码的结果：
- en: '![Creating detailed control with DOFConstraint](graphics/2215OS_12_13.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![使用DOFConstraint创建详细控制](graphics/2215OS_12_13.jpg)'
- en: 'Next, we need to create the body of the car and add everything to the scene:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建汽车的车身并将所有东西添加到场景中：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Until now, we just created the separate components that will have to make up
    our car. To tie everything together, we''re going to create constraints. Each
    wheel will be constrained to `body`. The constraints are created as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是创建了组成汽车的各个部件。为了将所有东西联系在一起，我们将创建约束。每个车轮都将被约束到`body`上。约束的创建如下：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each wheel (the first argument) has it''s own constraint, and the position
    where it is attached to the car (the second argument) is specified with the last
    argument. If we ran with this configuration, we''d see that the four wheels hold
    up the body of the car. We need to do two more things to get the car moving: we
    need to set up the constraints for the wheels (along which axis they can move),
    and we need to configure the correct motors. First, we set up the constraints
    for the two front wheels; what we want for these front wheels is just to be able
    to rotate along the *z* axis so that they can power the car, and they shouldn''t
    be allowed to move along the other axes.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每个车轮（第一个参数）都有自己的约束，并且它附加到汽车的位置（第二个参数）是用最后一个参数指定的。如果我们按照这个配置运行，我们会看到四个车轮支撑着汽车的车身。为了让汽车移动，我们还需要做两件事：我们需要为车轮设置约束（它们可以沿着哪个轴移动），并且我们需要配置正确的马达。首先，我们为两个前轮设置约束；对于这些前轮，我们希望它们只能沿着*z*轴旋转，以便它们可以驱动汽车，并且不允许它们沿着其他轴移动。
- en: 'The code required to accomplish this is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点所需的代码如下：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At first glance, this might seem weird. By setting the lower and upper limits
    to the same value, we make sure that no rotation is possible in the specified
    direction. This would also mean that the wheels can't rotate around their *z*
    axis. The reason we specify it like this is that when you enable a motor for a
    specific axis, these limits are ignored. So setting limits on the *z* axis at
    this point doesn't have any effect on our front wheels.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这可能看起来很奇怪。通过将下限和上限设置为相同的值，我们确保在指定的方向上不能进行旋转。这也意味着车轮不能围绕其*z*轴旋转。我们之所以这样指定它，是因为当您为特定轴启用马达时，这些限制将被忽略。因此，在这一点上设置*z*轴上的限制对我们的前轮没有任何影响。
- en: 'We''re going to steer with our rear wheels, and to make sure they don''t fall
    over, we need to fix the *x* axis. With the following code, we fix the *x* axis
    (set upper and lower limits to `0`), fix the *y* axis so that these wheels are
    already initially turned, and disable any limit on the *z* axis:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用后轮来转向，并确保它们不会倒下，我们需要固定*x*轴。使用以下代码，我们固定*x*轴（将上限和下限设置为`0`），固定*y*轴，以便这些车轮最初已经转向，并且禁用*z*轴上的任何限制：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, to disable the limits, we have to set the lower limit of that
    specific axis higher than the upper limit. This will allow free rotation around
    that axis. If we don't set this for the *z* axis, these two wheels will just be
    dragged along. In this case, they'll turn together with the other wheels because
    of the friction with the ground.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，要禁用限制，我们必须将特定轴的下限设置得比上限高。这将允许围绕该轴的自由旋转。如果我们不为*z*轴设置这个，这两个车轮将只是被拖着走。在这种情况下，它们将因与地面的摩擦而与其他车轮一起转动。
- en: 'All that is left to do is set up the motors for the front wheels, which can
    be done as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是为前轮设置马达，可以这样做：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since there are three axes we can create a motor for, we need to specify the
    axis the motor works on: 0 is the *x* axis, 1 is the *y* axis, and 2 is the *z*
    axis. The second and third arguments define the angular limits for the motor.
    Here, we once again set the lower limit (`0.1`) higher than the upper limit (`0`)
    to allow free rotation. The third argument specifies the velocity we want to reach,
    and the last argument specifies the force this motor can apply. If this last one
    is too little, the car won''t move; if it''s too high, the rear wheels will lift
    off from the ground.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以为三个轴创建一个马达，我们需要指定马达工作的轴：0是*x*轴，1是*y*轴，2是*z*轴。第二个和第三个参数定义了马达的角度限制。在这里，我们再次将下限（`0.1`）设置得比上限（`0`）高，以允许自由旋转。第三个参数指定我们要达到的速度，最后一个参数指定这个马达可以施加的力。如果这最后一个参数太小，汽车就不会移动；如果太大，后轮就会离开地面。
- en: 'Enable them with the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码启用它们：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you open up the `05-dof-constraint.html` example, you can play around with
    the various constraints and motors and drive the car around. The following screenshot
    shows this example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开`05-dof-constraint.html`示例，您可以玩弄各种约束和马达，并驾驶汽车四处走动。以下截图显示了这个例子：
- en: '![Creating detailed control with DOFConstraint](graphics/2215OS_12_14.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![使用DOFConstraint创建详细控制](graphics/2215OS_12_14.jpg)'
- en: In the next section, we'll look at the last subject we'll discuss in this book,
    and that is how to add sounds to your Three.js scene.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看这本书中我们将讨论的最后一个主题，那就是如何将声音添加到您的Three.js场景中。
- en: Add sound sources to your scene
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将声源添加到您的场景中
- en: 'With the subjects discussed until now, we have a lot of the ingredients in
    place to create beautiful scenes, games, and other 3D visualizations. What we
    haven''t shown, however, is how to add sounds to your Three.js scene. In this
    section, we''ll look at two Three.js objects that allow you to add sources of
    sound to your scene. This is especially interesting since these sound sources
    respond to the position of the camera:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了很多内容，可以创建美丽的场景、游戏和其他3D可视化。然而，我们还没有展示如何将声音添加到您的Three.js场景中。在本节中，我们将看看两个Three.js对象，它们允许您向场景中添加声音源。这是特别有趣的，因为这些声源会响应摄像机的位置：
- en: The distance between the sound source and the camera determines the volume of
    the sound source.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声源与摄像机之间的距离决定了声源的音量。
- en: The positions to the left-hand side and the right-hand side of the camera determine
    the sound volume of the left-hand side speaker and the right-hand side speaker,
    respectively.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像机左侧和右侧的位置决定了左侧扬声器和右侧扬声器的声音音量。
- en: 'The best way to explain this is to see this in action. Open up the `06-audio.html`
    example in your browser, and you''ll see three cubes with pictures of animals.
    The following screenshot shows this example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的解释方法是看到它的实际效果。在浏览器中打开`06-audio.html`示例，您会看到三个带有动物图片的立方体。以下截图显示了这个例子：
- en: '![Add sound sources to your scene](graphics/2215OS_12_15.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![向您的场景添加声源](graphics/2215OS_12_15.jpg)'
- en: This example uses the first-person controls we saw in [Chapter 9](ch09.html
    "Chapter 9. Animations and Moving the Camera"), *Animations and Moving the Camera*,
    so you can use the arrow keys in combination with the mouse to move around the
    scene. What you'll see is that the closer you move to a specific cube, the louder
    that specific animal will sound. If you position the camera between the dog and
    the cow, you'll hear the cow from the right-hand side and the dog from the left-hand
    side.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了我们在[第9章](ch09.html "第9章。动画和移动摄像机")中看到的第一人称控制，*动画和移动摄像机*，所以您可以使用箭头键与鼠标结合来在场景中移动。您会发现，您越接近特定的立方体，该特定动物的声音就会越大。如果您将摄像机位置放在狗和奶牛之间，您将会从右侧听到奶牛的声音，从左侧听到狗的声音。
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In this example, we used a specific helper, `THREE.GridHelper`, from Three.js
    to create the grid beneath the cubes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个特定的辅助工具`THREE.GridHelper`，从Three.js中创建了立方体下面的网格：
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To create a grid, you need to specify the size of the grid (500 in this case)
    and the size of the individual grid elements (we used 10 here). If you want, you
    can also set the colors of the horizontal lines by specifying the `color1` and
    `color2` properties.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 创建网格时，您需要指定网格的大小（在本例中为500）和单个网格元素的大小（我们在这里使用了10）。如果您愿意，还可以通过指定`color1`和`color2`属性来设置水平线的颜色。
- en: 'Accomplishing this only takes a small amount of code. The first thing we need
    to do is define `THREE.AudioListener` and add it to `THREE.PerspectiveCamera`,
    as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 只需少量代码即可完成此操作。我们需要做的第一件事是定义`THREE.AudioListener`并将其添加到`THREE.PerspectiveCamera`中，如下所示：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we need to create `THREE.Mesh` and add a `THREE.Audio` object to that
    mesh, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建`THREE.Mesh`并将`THREE.Audio`对象添加到该网格中，如下所示：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see from this code snippet, we first create a standard `THREE.Mesh`
    instance. Next, we create a `THREE.Audio` object, which we connect to the `THREE.AudioListener`
    object we created earlier. Finally, we add the `THREE.Audio` object to the mesh
    we created and we're done.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码片段中可以看出，我们首先创建了一个标准的`THREE.Mesh`实例。接下来，我们创建了一个`THREE.Audio`对象，将其连接到之前创建的`THREE.AudioListener`对象上。最后，我们将`THREE.Audio`对象添加到我们创建的网格中，完成了整个过程。
- en: 'There are a couple of properties we can set on the `THREE.Audio` object to
    configure its behavior:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些属性可以在`THREE.Audio`对象上设置以配置其行为：
- en: '`load`: This allows us to load an audio file to be played.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load`：这允许我们加载要播放的音频文件。'
- en: '`setRefDistance`: This determines the distance from the object from where the
    sound will be reduced in volume.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRefDistance`：这确定了从对象到声音减小的距离。'
- en: '`setLoop`: By default, a sound is played once. By setting this property to
    `true`, the sound is looped.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setLoop`：默认情况下，声音只播放一次。通过将此属性设置为`true`，声音将循环播放。'
- en: '`setRolloffFactor`: This determines how quickly the volume decreases as you
    move away from the sound source.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRolloffFactor`：这确定了音量随着远离声源而减小的速度。'
- en: Internally, Three.js uses the Web Audio API ([http://webaudio.github.io/web-audio-api/](http://webaudio.github.io/web-audio-api/))
    to play the sound and determine the correct volume. Not all browsers support this
    specification. The best support currently is from Chrome and Firefox.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Three.js使用Web Audio API（[http://webaudio.github.io/web-audio-api/](http://webaudio.github.io/web-audio-api/)）来播放声音并确定正确的音量。并非所有浏览器都支持此规范。目前最好的支持来自Chrome和Firefox。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this last chapter, we explored how you can extend the basic 3D functionality
    from Three.js by adding physics. For this, we used the Physijs library, which
    allows you to add gravity, collisions, constraints, and much more. We also showed
    how you can add positional sound to your scene using the `THREE.Audio` and `THREE.AudioListener`
    objects. With those subjects, we've reached the end of this book on Three.js.
    In these chapters, we covered a lot of different subjects and explored pretty
    much everything Three.js has to offer. In the first couple of chapters, we explained
    the core concepts and ideas behind Three.js; after that, we looked at the available
    lights and how materials affect how an object is rendered. After the basics, we
    explored the various geometries Three.js has to offer and how you can combine
    geometries to create new ones.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们探讨了如何通过添加物理功能来扩展Three.js的基本3D功能。为此，我们使用了Physijs库，它允许您添加重力、碰撞、约束等等。我们还展示了如何在场景中添加定位声音使用`THREE.Audio`和`THREE.AudioListener`对象。通过这些主题，我们已经完成了关于Three.js的这本书。在这些章节中，我们涵盖了许多不同的主题，并探索了Three.js所提供的几乎所有内容。在前几章中，我们解释了Three.js背后的核心概念和思想；之后，我们研究了可用的灯光以及材质如何影响对象的渲染方式。在掌握基础知识之后，我们探索了Three.js提供的各种几何图形以及如何组合几何图形来创建新的图形。
- en: In the second part of the book, we looked at a few more advanced subjects. You
    learned how to create particle systems, how to load models from external sources,
    and how to create animations. Finally, in these last couple of chapters, we looked
    at the advanced textures you can use in skinning and the postprocessing effects
    that can be applied after the scene is rendered. We end the book with this chapter
    on physics, which, besides explaining how you can add physics to your Three.js
    scene, also shows the active community of projects surrounding Three.js that you
    can use to add even more functionality to an already great library.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的第二部分，我们研究了一些更高级的主题。您学会了如何创建粒子系统，如何从外部来源加载模型，以及如何创建动画。最后，在最后几章中，我们研究了您可以在皮肤中使用的高级纹理以及在场景渲染后可以应用的后处理效果。我们以这一章关于物理的书结束，除了解释如何将物理添加到Three.js场景中，还展示了围绕Three.js的活跃社区项目，您可以使用这些项目为已经很棒的库添加更多功能。
- en: I hope you've enjoyed reading this book and playing around with the examples
    as much as I have writing it!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您喜欢阅读本书并且和我写作一样喜欢玩弄示例！
