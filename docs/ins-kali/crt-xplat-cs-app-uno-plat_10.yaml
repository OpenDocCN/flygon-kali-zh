- en: '*Chapter 7*: Testing Your Apps'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：测试您的应用'
- en: In the previous chapters, we covered developing multiple different types of
    apps using Uno Platform. Uno Platform not only allows apps to be written, however;
    it also allows automated UI tests to be written that will run on Android, iOS,
    and WebAssembly using the Uno.UITest framework. During this chapter, we will write
    our first test using Uno.UITest and run it on different platforms, including using
    emulators. After this, you will also learn how to write tests for Windows using
    WinAppDriver.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们介绍了使用Uno平台开发多种不同类型的应用。Uno平台不仅允许编写应用程序，还允许使用Uno.UITest框架编写自动化UI测试，这些测试将在Android、iOS和WebAssembly上运行。在本章中，我们将使用Uno.UITest编写我们的第一个测试，并在不同平台上运行它，包括使用模拟器。之后，您还将学习如何使用WinAppDriver为Windows编写测试。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up the `Uno.UITest` project for your app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用设置`Uno.UITest`项目
- en: Authoring `Uno.UITest` tests for your Uno Platform app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的Uno平台应用编写`Uno.UITest`测试
- en: Running your tests against the WASM, Android, and iOS versions of your app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对您的应用的WASM、Android和iOS版本运行您的测试
- en: Writing unit tests for your Uno Platform app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的Uno平台应用编写单元测试
- en: Using WinAppDriver to author automated tests for the UWP head of your app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WinAppDriver为您的应用的UWP版本编写自动化测试
- en: Why manual testing is still important
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么手动测试仍然很重要
- en: By the end of this chapter, you'll have learned how to write tests using `Uno.UITest`
    and WinAppDriver for your app, how to run those tests on different platforms,
    and why manually testing your app is still important.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将学会如何使用`Uno.UITest`和WinAppDriver为您的应用编写测试，如何在不同平台上运行这些测试，以及为什么手动测试您的应用仍然很重要。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you already have your development environment set
    up, including installing the project templates, as was covered in [*Chapter 1*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015),
    *Introducing Uno Platform*. The source code for this chapter is available at [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter07](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter07).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经设置好了开发环境，包括安装了项目模板，就像在[*第1章*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015)中介绍的那样，*介绍Uno平台*。本章的源代码可在[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter07](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter07)上找到。
- en: The code in this chapter makes use of the library from [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码使用了来自[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary)的库。
- en: 'Check out the following video to see the code in action: [https://bit.ly/3iBFZ2e](https://bit.ly/3iBFZ2e)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码示例：[https://bit.ly/3iBFZ2e](https://bit.ly/3iBFZ2e)
- en: Getting started with Uno.UITest
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Uno.UITest
- en: Before we get started with Uno.UITest, let's cover what Uno.UITest is and what
    its aim is. Uno.UITest is a library developed and maintained by the Uno Platform
    team to allow developers to write unified UI tests for their Uno Platform apps.
    These UI tests allow you to simulate users interacting with your app and verify
    the UI of your app to ensure that user interactions work correctly and that your
    app behaves as designed. With Uno.UITest, you can write **UI tests** (also sometimes
    referred to as interaction tests), which you can run against the **Android**,
    **iOS**, and **WASM** heads of your app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用Uno.UITest之前，让我们先了解一下Uno.UITest是什么，以及它的目标是什么。Uno.UITest是由Uno平台团队开发和维护的库，允许开发人员为他们的Uno平台应用编写统一的UI测试。这些UI测试允许您模拟用户与您的应用进行交互，并验证您的应用的UI，以确保用户交互正常工作，并且您的应用行为符合设计。使用Uno.UITest，您可以编写UI测试（有时也称为交互测试），并针对您的应用的Android、iOS和WASM版本运行这些测试。
- en: Under the hood, Uno.UITest uses **Xamarin.UITest** to run tests against the
    Android and iOS head of the app. For the WASM version of the app, Uno.UITest uses
    **Selenium** and **Google Chrome**. Using these libraries, Uno.UITest allows you
    to write tests that mimic user interactions with the UI of your app, including
    mimicking mouse input such as clicking, and keyboard input such as entering text.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Uno.UITest使用**Xamarin.UITest**来针对应用的Android和iOS版本运行测试。对于应用的WASM版本，Uno.UITest使用**Selenium**和**Google
    Chrome**。使用这些库，Uno.UITest允许您编写模拟用户与应用UI交互的测试，包括模拟鼠标输入（如点击）和键盘输入（如输入文本）。
- en: But when should you use UI tests? When writing complex apps, ensuring that changes
    to your code did not break existing features can often be difficult to test, especially
    as some changes only become noticeable when using the app, not when testing components
    or classes alone. UI tests are ideal for this kind of scenario as you can write
    tests simulating a normal user using your app without having to manually go through
    dozens or hundreds of steps. A common scenario for writing UI tests is to check
    whether users can successfully achieve certain tasks within your app, for example,
    sign in to your app or search for a specific thing. While UI tests are good for
    testing these kinds of scenarios, UI tests are no silver bullet and also have
    their drawbacks. Since UI tests simulate user input, they are slower to run compared
    to normal unit tests, which are only testing single objects or classes. In addition
    to this, since the UI testing framework or library needs to find a way to interact
    with your app, UI tests can sometimes break when updating the UI of your app or
    changing texts or names within your app.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但是何时应该使用UI测试？在编写复杂的应用程序时，确保代码更改没有破坏现有功能通常很难测试，特别是因为某些更改只有在使用应用程序时才会变得显而易见，而不是在单独测试组件或类时。UI测试非常适合这种情况，因为您可以编写测试来模拟普通用户使用您的应用程序，而无需手动执行数十甚至数百个步骤。编写UI测试的常见场景是检查用户是否可以成功完成应用程序中的某些任务，例如登录到您的应用程序或搜索特定内容。虽然UI测试非常适合测试这些类型的场景，但UI测试并非万能药，也有其缺点。由于UI测试模拟用户输入，因此与仅测试单个对象或类的常规单元测试相比，它们运行速度较慢。此外，由于UI测试框架或库需要找到一种与您的应用程序交互的方法，因此在更新应用程序的UI或更改应用程序中的文本或名称时，UI测试有时可能会出现问题。
- en: Nonetheless, when developing an app, writing UI tests is very important when
    you try to ensure that no bugs have snuck into the app. This is especially useful
    when writing apps that will run on a variety of different devices having different
    screen sizes, capabilities, and OS versions as this makes it easier to test your
    app on a lot of different configurations as manual testing is slow and error-prone.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在开发应用程序时，编写UI测试非常重要，尤其是在尝试确保没有错误进入应用程序时。这在编写将在各种不同设备上运行的应用程序时尤其有用，这些设备具有不同的屏幕尺寸、功能和操作系统版本，因此可以更容易地在许多不同的配置上测试应用程序，因为手动测试速度慢且容易出错。
- en: 'Before we use Uno.UITest, we first need an app that we can use to write tests
    for. For this, let''s start by creating a new solution for our app that we will
    use to write tests for:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Uno.UITest之前，我们首先需要一个可以用来编写测试的应用程序。为此，让我们首先创建一个新的解决方案，用于编写测试：
- en: Create a new project with the **Multi-Platform App (Uno Platform)** template.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**多平台应用程序（Uno平台）**模板创建一个新项目。
- en: Name the project `UnoAutomatedTestsApp`. Of course, you can use a different
    name; however, in this chapter, we will assume that the project is named `UnoAutomatedTestsApp`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`UnoAutomatedTestsApp`。当然，您可以使用不同的名称；但是，在本章中，我们将假定项目命名为`UnoAutomatedTestsApp`。
- en: Remove all the platform head projects *except* for Android, iOS, UWP, and WASM.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除除Android、iOS、UWP和WASM之外的所有平台头项目。
- en: Now we need to add a reference to our shared library. To do this, right-click
    on the solution file, select `UnoBookRail.Common.csproj` file, and then click
    **Open**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要向我们的共享库添加引用。要做到这一点，右键单击解决方案文件，选择`UnoBookRail.Common.csproj`文件，然后单击**打开**。
- en: Reference the shared library project in every head project. For this, right-click
    on the head project, select **Add > Reference… > Projects**, check **UnoBookRail.Common**,
    and click **OK**. Since we need a reference to the library in every head, repeat
    this process for every head, in other words, Android, iOS, UWP, and WASM.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个头项目中引用共享库项目。为此，在头项目上右键单击，选择**添加 > 引用… > 项目**，选中**UnoBookRail.Common**，然后单击**确定**。由于我们需要在每个头中引用库，请为每个头重复此过程，换句话说，Android、iOS、UWP和WASM。
- en: 'Now that we have created the project, let''s add some content to our app that
    we can test:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目，让我们向我们的应用程序添加一些内容，以便我们可以进行测试：
- en: Add `xmlns:toolkit="using:Uno.UI.Toolkit"` to the `MainPage.xaml`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`xmlns:toolkit="using:Uno.UI.Toolkit"`添加到`MainPage.xaml`中。
- en: 'Replace the `Grid` control inside your `MainPage.xaml` file with the following:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换`MainPage.xaml`文件中的`Grid`控件：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a simple sign-in interface that we will write tests for later in this
    chapter. It includes sign-in controls, a sign-in button, and a label that will
    be shown when signed in.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个简单的登录界面，我们将在本章后面为其编写测试。它包括登录控件、登录按钮和在登录时显示的标签。
- en: 'Now, add the following two methods to the `MainPage` class:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向`MainPage`类添加以下两个方法：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code adds handlers that allow us to enable the sign-in button as soon as
    the user has entered a username and password. Otherwise, the sign-in button will
    be disabled. In addition to this, we also handle the sign-in button click and
    update the UI accordingly, including showing the error message if the sign-in
    failed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码添加了处理程序，允许我们在用户输入用户名和密码后立即启用登录按钮。否则，登录按钮将被禁用。除此之外，我们还处理登录按钮的点击，并相应地更新UI，包括在登录失败时显示错误消息。
- en: 'Now, if you start the UWP head of your app, you will see something like *Figure
    7.1*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您启动应用程序的UWP头，您将看到类似*图7.1*的东西：
- en: '![Figure 7.1 – Screenshot of the running app with the sign-in form'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 - 运行应用程序的屏幕截图，带有登录表单'
- en: '](img/Figure_7.01_B17132.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.01_B17132.jpg)'
- en: Figure 7.1 – Screenshot of the running app with the sign-in form
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 - 运行应用程序的屏幕截图，带有登录表单
- en: 'Now that we have added a simple test app that we can test again, we can now
    add our **Uno.UITest** tests project:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了一个简单的测试应用程序，我们可以再次进行测试，现在我们可以添加我们的**Uno.UITest**测试项目：
- en: If you want to run tests for the WASM head of your app, make sure you have Google
    Chrome installed.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想对应用程序的WASM头运行测试，请确保已安装Google Chrome。
- en: 'First, you will need to update the project files for the Android, iOS, and
    WASM heads. For that, add the following entries before the last closing project
    tag of the `.csproj` files for those projects:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要更新Android、iOS和WASM头的项目文件。为此，在这些项目的`.csproj`文件的最后一个闭合项目标签之前添加以下条目：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For the iOS project, add a reference to the `Xamarin.TestCloud.Agent` NuGet
    package. Since, as of the time of writing, the latest stable version was `OnLaunched`
    method of your `App.xaml.cs` file, add the following at the beginning of the method:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于iOS项目，添加对`Xamarin.TestCloud.Agent` NuGet包的引用。由于在撰写时，最新的稳定版本是`OnLaunched`方法的`App.xaml.cs`文件，因此在该方法的开头添加以下内容：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since the Uno.UITest library uses Xamarin.UITest under the hood, for the iOS
    app, we need to add the preceding code. Otherwise Xamarin.UITest can't interact
    with the running iOS app and the tests won't work.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Uno.UITest库在底层使用Xamarin.UITest，因此对于iOS应用程序，我们需要添加前面的代码。否则，Xamarin.UITest无法与正在运行的iOS应用程序交互，测试将无法正常工作。
- en: Since the Uno.UITest project type is not included in the Uno Platform Visual
    Studio templates extension, make sure you have the Uno Platform `dotnet new` templates
    installed. You can find the instructions for this in [*Chapter 1*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015),
    *Introducing Uno Platform*.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Uno.UITest项目类型未包含在Uno Platform Visual Studio模板扩展中，请确保已安装了Uno Platform `dotnet
    new`模板。您可以在[*Chapter 1*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015)中找到此说明，*介绍Uno平台*。
- en: Inside the `UnoAutomatedTestsApp` folder, create a folder named `UnoAutomatedTestsApp.UITests`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UnoAutomatedTestsApp`文件夹内，创建一个名为`UnoAutomatedTestsApp.UITests`的文件夹。
- en: 'Inside the newly created folder, run the following command:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的文件夹内，运行以下命令：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will create a new Uno.UITest project inside the folder and also add the
    project to the solution file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在文件夹内创建一个新的Uno.UITest项目，并将该项目添加到解决方案文件中。
- en: Update the Android and iOS apps package names. For Android, replace the `Properties/AndroidManifest.xml`
    file of the Android project with `package="UnoBook.UnoAutomatedTestsApp"`. To
    replace the iOS package name, open the `Info.plist` file inside the iOS project
    and replace `Bundle Identifier` with `UnoBook.UnoAutomatedTestsApp`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Android和iOS应用程序的包名称。对于Android，请使用`UnoBook.UnoAutomatedTestsApp`替换Android项目的`Properties/AndroidManifest.xml`文件。要替换iOS包名称，请打开iOS项目内的`Info.plist`文件，并将`Bundle
    Identifier`替换为`UnoBook.UnoAutomatedTestsApp`。
- en: 'Now we need to update the `Constants.cs` file inside the Uno.UITests app project
    to point to the correct app. For this, replace lines 13, 14, and 15 with the following:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要更新Uno.UITests应用项目内的`Constants.cs`文件，以指向正确的应用程序。为此，请使用以下内容替换第13、14和15行：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since the port of the WASM app is generated randomly, replace `[PORT]` from
    the preceding code with the following information
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WASM应用的端口是随机生成的，因此请使用前面代码中的以下信息替换`[PORT]`。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We need to update the `Constants.cs` file since Uno.UITest needs to be able
    to find the app through the app name or app URI in the case of WASM. To find out
    which URI your WASM head is running on, open `Properties/launchSettings.json`
    inside the WASM head. Inside there, depending on whether you will be using the
    `[ProjectName].Wasm` target, either use `applicationUrl` from the `applicationUrl`
    from the `[Project name].Wasm` profile to ascertain the port. In this chapter,
    we will be using `Info.plist` file located inside the iOS project. For the Android
    app name, refer to the package property inside the `Properties/AndroidManifest.xml`
    file of the Android project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新`Constants.cs`文件，因为Uno.UITest需要能够通过应用程序名称或在WASM情况下的应用程序URI找到应用程序。要找出您的WASM
    head正在运行的URI，请打开WASM head内的`Properties/launchSettings.json`。在那里，根据您是否将使用`[ProjectName].Wasm`目标，可以使用`[Project
    name].Wasm`配置文件中的`applicationUrl`来确定端口。在本章中，我们将使用位于iOS项目内的`Info.plist`文件。有关Android应用程序名称，请参考Android项目的`Properties/AndroidManifest.xml`文件中的包属性。
- en: 'Inside the **UnoAutomatedTestsApp.UITests** project, you will find three files:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在**UnoAutomatedTestsApp.UITests**项目内，您将找到三个文件：
- en: '`Constants.cs`: This contains the configuration to find the running app using
    the app package name or URL of the app, as explained earlier.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Constants.cs`：这包含了使用应用程序包名称或应用程序的URL来找到正在运行的应用程序的配置，如前所述。'
- en: '`Given_MainPage.cs`: This is a sample test file with a small test showing how
    to write a test.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Given_MainPage.cs`：这是一个包含小型测试的示例测试文件，显示了如何编写测试。'
- en: '`TestBase.cs`: This file contains all the bootstrap code that takes care of
    starting and tearing down the app and also exposes an `IApp` instance (more on
    this in the next section). This file also exports a `TakeScreenshot` function
    that you can use to take screenshots of the running app being tested.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestBase.cs`：此文件包含所有启动和关闭应用程序的引导代码，并公开一个`IApp`实例（在下一节中详细介绍）。该文件还导出了一个`TakeScreenshot`函数，您可以使用它来对正在测试的运行中的应用程序进行截图。'
- en: Now that we have covered how to set up the Uno.UITest project and its structure,
    let's continue by writing our first Uno.UITest and learn how to run those tests.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何设置Uno.UITest项目及其结构，让我们继续编写我们的第一个Uno.UITest，并学习如何运行这些测试。
- en: Writing and running your first test
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写和运行您的第一个测试
- en: Before we start writing our first test, we will cover how you can use Uno.UITest
    to interact with your apps. For this, we will first start by covering the basics
    of the addressing elements using Uno.UITests query feature objects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写第一个测试之前，我们将介绍如何使用Uno.UITest与您的应用程序进行交互。为此，我们将首先介绍使用Uno.UITests查询功能对象来定位元素的基础知识。
- en: How Uno.UITest works
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Uno.UITest的工作原理
- en: Since UI tests need to address UI elements of your app, every UI testing library
    needs to have a way to allow developers to address those elements. `Uno.UITest`
    does this using the `IAppQuery` interface to define queries and the `IApp` interface
    to run those queries and inject input.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于UI测试需要处理应用程序的UI元素，因此每个UI测试库都需要一种方式让开发人员处理这些元素。`Uno.UITest`使用`IAppQuery`接口来定义查询和`IApp`接口来运行这些查询和注入输入。
- en: The `IApp` interface provides you with the necessary APIs to interact with your
    app, including clicking elements, simulating scrolling, and injecting text input.
    As part of the creation of the `Uno.UITest` project, the `TestBase` class will
    provide you with an `IApp` instance. Since the `IApp` interface allows you to
    simulate input to your app and most interactions require a specific control to
    be the target of your interaction, most methods on the `IApp` interface require
    you to specify the `AutomationID` property of the control or by using the `IAppQuery`
    interface.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`IApp`接口为您提供了与应用程序交互所需的API，包括单击元素、模拟滚动和注入文本输入。在创建`Uno.UITest`项目的过程中，`TestBase`类将为您提供一个`IApp`实例。由于`IApp`接口允许您模拟对应用程序的输入，并且大多数交互需要特定的控件作为交互的目标，因此`IApp`接口上的大多数方法都要求您指定控件的`AutomationID`属性或使用`IAppQuery`接口。'
- en: 'In the following example, we will use `AutomationID` to click the button, as
    defined by the following XAML:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将使用`AutomationID`来单击按钮，如以下XAML中所定义的：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When writing a Uno.UITest test, we can then press the button using the following
    code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Uno.UITest测试时，我们可以使用以下代码按下按钮：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In contrast to using `x:Name`/`AutomationID` of a control to specify the element,
    by using the `IAppQuery` interface, you can address controls based on other properties,
    for example, their type, or based on specific properties being set on a control.
    When working with `IAppQuery`, you will notice that the `IApp` interface does
    not expect to get an element of the `IAppQuery` type, but rather an element of
    the `Func<IAppQuery,IAppQuery>` type. Since the `IApp` interface relies heavily
    on this, you will often see the following `using-alias` statement:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`x:Name`/`AutomationID`来指定元素的控件不同，通过使用`IAppQuery`接口，您可以根据其他属性（例如它们的类型）或基于控件上设置的特定属性来寻址控件。在使用`IAppQuery`时，您会注意到`IApp`接口不希望得到`IAppQuery`类型的元素，而是希望得到`Func<IAppQuery,IAppQuery>`类型的元素。由于`IApp`接口在很大程度上依赖于此，因此您经常会看到以下`using-alias`语句：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This allows developers to write queries more easily since you can simply use
    the `Query` type alias instead of having to write it out every time. For simplicity,
    in this chapter, we will also use this `using` statement and use the `Query` type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这使开发人员更容易编写查询，因为您可以简单地使用`Query`类型别名，而不必每次都写出来。为简单起见，在本章中，我们还将使用此`using`语句并使用`Query`类型。
- en: 'If we take the XAML from before, pressing the button with the `IAppQuery` interface
    can be done as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从之前的XAML中获取，使用`IAppQuery`接口按下按钮可以按照以下方式完成：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we created the Uno.UITest project, you may have also noticed that a reference
    to the NUnit NuGet package was added. By default, Uno.UITest uses NUnit for assertions
    and their tests. Of course, this does not mean that you have to use NUnit for
    your tests. However, if you wish to use a different testing framework, you will
    need to update the `TestBase.cs` file since it uses NUnit attributes to hook into
    the setup and teardown of the tests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建Uno.UITest项目时，您可能还注意到已添加了对NUnit NuGet包的引用。默认情况下，Uno.UITest使用NUnit进行断言和测试。当然，这并不意味着您必须在测试中使用NUnit。但是，如果您希望使用不同的测试框架，您将需要更新`TestBase.cs`文件，因为它使用NUnit属性来连接测试的设置和拆卸。
- en: Now that we covered the basics of how `Uno.UITest` works, we will now continue
    by writing tests for our sign-in interface.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了`Uno.UITest`的基本工作原理，现在我们将继续为我们的登录界面编写测试。
- en: Authoring your first test
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写您的第一个测试
- en: 'We will start by writing our first tests for the sign-in interface we added
    at the start of this chapter. For simplicity, we will use `NUnit` since `Uno.UITest`
    uses this by default when creating a new `Uno.UITest` project, meaning that we
    don''t have to update the `TestBase` class. We begin by creating a new file for
    our tests:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从编写我们在本章开头添加的登录界面的第一个测试开始。为简单起见，我们将使用`NUnit`，因为在创建新的`Uno.UITest`项目时，默认情况下会使用`Uno.UITest`，这意味着我们不必更新`TestBase`类。我们首先创建一个新的测试文件：
- en: First, remove the existing `Given_MainPage.cs` file.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，删除现有的`Given_MainPage.cs`文件。
- en: Create a new folder called `Tests`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Tests`的新文件夹。
- en: Create a new class called `SignInTests.cs` inside the `Tests` folder.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Tests`文件夹内创建一个名为`SignInTests.cs`的新类。
- en: 'Update `SignInTests.cs` with the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新`SignInTests.cs`：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are inheriting from `TestBase` to access the `IApp` instance of the current
    test run and to be able to send input to our app. In addition to that, we are
    also adding a using statement for the `NUnit` library as we will use it later
    and add the named using statement we covered in the section *How Uno.UITest works*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继承自`TestBase`以访问当前测试运行的`IApp`实例并能够向我们的应用程序发送输入。除此之外，我们还添加了一个使用`NUnit`库的`using`语句，因为我们稍后将使用它，并添加了我们在*Uno.UITest工作原理*部分中介绍的命名使用语句。
- en: 'Now, let''s add our first test. Let''s start by simply checking whether the
    email and password input fields and the sign-in button exist. For the rest of
    this section, we will only be working inside the `SignInTests.cs` file since we
    are writing tests for the sign-in user interface:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加我们的第一个测试。让我们首先简单地检查电子邮件和密码输入字段以及登录按钮是否存在。在本节的其余部分，我们将只在`SignInTests.cs`文件中工作，因为我们正在为登录用户界面编写测试：
- en: Start by adding a new public function, which will be our test case. We will
    name the function `VerifySignInRenders`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加一个新的公共函数，这将是我们的测试用例。我们将函数命名为`VerifySignInRenders`。
- en: Add the `NUnit` know that the function is a test.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`NUnit`知道该函数是一个测试。
- en: 'Now, add the following code inside the function:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在函数内添加以下代码：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Your `SignInTests` class should now look something like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`SignInTests`类现在应该看起来像这样：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now what our test does is try to find the elements with the automation ID `UserNameInput`,
    `PasswordInput`, and `SignInButton`, and fail the test if it can't find any of
    those elements.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试所做的是尝试查找具有`UserNameInput`、`PasswordInput`和`SignInButton`的自动化ID的元素，并且如果找不到这些元素，则测试失败。
- en: Now that we have written our first test, let's try it out! To do this, we'll
    first cover how to run those tests.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了第一个测试，让我们试一下！为此，我们首先来看如何运行这些测试。
- en: Running your tests on Android, iOS, and WASM
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Android、iOS和WASM上运行您的测试
- en: Running your `Uno.UITest` tests against the Android, iOS, and WASM head of your
    app is fairly simple, although the process is always slightly different depending
    on what platform you are trying to start.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 针对您的应用的Android、iOS和WASM头运行您的`Uno.UITest`测试非常简单，尽管具体过程因您尝试启动的平台而略有不同。
- en: Running tests against the WASM head
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对WASM头运行测试
- en: 'Let''s start by running our test against the WASM head of our app:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先针对我们应用的WASM头运行我们的测试：
- en: First, you will need to deploy the WASM head of the app. For this, select the
    **UnoAutomatedTestsApp.Wasm** start up project and select the **IIS Express**
    target, as shown in *Figure 7.2*. Then, press *Ctrl + F5*, which will deploy the
    project.![Figure 7.2 – WASM project with IIS Express selected
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要部署应用的WASM头。为此，请选择**UnoAutomatedTestsApp.Wasm**作为启动项目，并选择**IIS Express**目标，如*图7.2*所示。然后，按下*Ctrl
    + F5*，这将部署项目。![图7.2 - 选择了IIS Express的WASM项目
- en: '](img/Figure_7.02_B17132.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.02_B17132.jpg)'
- en: Figure 7.2 – WASM project with IIS Express selected
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - 选择了IIS Express的WASM项目
- en: Update `Constants.cs` and change `Constants.CurrentPlatform` to `Platform.Browser`.
    If you haven't updated the `Constants.WebAssemblyDefaultUri` property, do that
    as in the *Getting started with Uno.UITest* section.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Constants.cs`并将`Constants.CurrentPlatform`更改为`Platform.Browser`。如果您尚未更新`Constants.WebAssemblyDefaultUri`属性，请按照*开始使用Uno.UITest*部分中的说明进行操作。
- en: Open **Test Explorer** by clicking **View** in the menu bar and clicking on
    **Test Explorer**. Now, expand the tree and right-click the **VerifySignInRenders**
    test. Click the **Run** option from the popup. Now, the test will run against
    the app running in Chrome.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击菜单栏中的**View**，然后单击**Test Explorer**来打开**Test Explorer**。现在，展开树并右键单击**VerifySignInRenders**测试。从弹出菜单中选择**Run**选项。现在，测试将针对在Chrome中运行的应用运行。
- en: Important note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'At the time of writing, due to a known bug with Uno.UITest, running the tests
    against the WASM head might not work as Chrome might fail to start. Unfortunately,
    no workaround is known yet. To learn more about the current state of this bug,
    refer to the following GitHub issue: [https://github.com/unoplatform/Uno.UITest/issues/60](https://github.com/unoplatform/Uno.UITest/issues/60).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，由于Uno.UITest存在已知的bug，针对WASM头运行测试可能无法正常工作，因为Chrome可能无法启动。不幸的是，目前还没有已知的解决方法。要了解有关此错误当前状态的更多信息，请参考以下GitHub问题：[https://github.com/unoplatform/Uno.UITest/issues/60](https://github.com/unoplatform/Uno.UITest/issues/60)。
- en: Once the tests have started, Chrome will be started in headless mode and once
    the tests have finished, the test will be marked as passed in the Visual Studio
    Test Explorer.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试开始，Chrome将以无头模式启动，一旦测试完成，测试将在Visual Studio Test Explorer中标记为通过。
- en: Running tests against the Android version of your app
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对您的应用的Android版本运行测试
- en: 'In addition to running your tests against the WASM head, you can also run the
    tests against the Android version of your app running on an emulator or running
    on an Android device. To do this, follow these steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了针对WASM头运行测试外，您还可以针对在模拟器上运行的Android版本或在Android设备上运行的应用运行测试。要做到这一点，请按照以下步骤操作：
- en: Ensure that **Android Emulator** is running and that the app has been deployed.
    To deploy the Android version of your app, select the Android project as the start
    up project and press *Ctrl + F5*. If you want to run the tests against the app
    running on your Android device, make sure the app is deployed on the device and
    that your device is connected to your computer.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保**Android模拟器**正在运行，并且应用已部署。要部署应用的Android版本，请选择Android项目作为启动项目，然后按下*Ctrl +
    F5*。如果您想对在Android设备上运行的应用运行测试，请确保应用已部署在设备上，并且您的设备已连接到计算机。
- en: Update `Constants.cs` and change `Constants.CurrentPlatform` to `Platform.Android`.
    In case you haven't updated the `Constants.AndroidAppName` property, do that as
    in the *Getting started with Uno.UITest* section.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Constants.cs`并将`Constants.CurrentPlatform`更改为`Platform.Android`。如果您尚未更新`Constants.AndroidAppName`属性，请按照*开始使用Uno.UITest*部分中的说明进行操作。
- en: As was the case with WASM, now right-click the test in **Test Explorer** and
    click on **Run**. The app will start inside the emulator or on your Android device
    and the tests will be running against the running Android app.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与WASM一样，现在在**Test Explorer**中右键单击测试，然后单击**Run**。应用将在模拟器内或在Android设备上启动，并且测试将针对正在运行的Android应用运行。
- en: Running tests against the iOS version of your app
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对iOS版本的应用运行测试
- en: 'You can also run your UI tests against the iOS version of your app running
    on an emulator or on an iOS device. Note that macOS is required for this. To run
    the tests against the iOS head, follow these steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以针对在模拟器上运行的iOS版本或在iOS设备上运行的应用运行UI测试。请注意，这需要macOS。要针对iOS头运行测试，请按照以下步骤操作：
- en: Ensure that the iOS simulator is running and that the app has been deployed.
    To deploy the iOS version of your app, select the iOS project as the start up
    project and run the app. If you want to run the tests against the app running
    on your iOS device, make sure the app is deployed on the device and that it is
    connected to your computer.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保iOS模拟器正在运行，并且应用已部署。要部署应用的iOS版本，请选择iOS项目作为启动项目并运行应用。如果您想对在iOS设备上运行的应用运行测试，请确保应用已部署在设备上，并且已连接到计算机。
- en: Update `Constants.cs` and change `Constants.CurrentPlatform` to `Platform.iOS`.
    Set `iOSDeviceNameOrId` to the name of the emulator or tethered device you wish
    to use.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Constants.cs`并将`Constants.CurrentPlatform`更改为`Platform.iOS`。将`iOSDeviceNameOrId`设置为您希望使用的模拟器或连接设备的名称。
- en: If using a tethered device, you may also need to change `iOSAppName` and the
    `info.plist` so that it is compatible with your developer certificate.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用连接设备，您可能还需要更改`iOSAppName`和`info.plist`，以使其与您的开发者证书兼容。
- en: Now, right-click the test project in the **Tests** window and click on **Run
    Test**. The app will start and the tests will be run.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**Tests**窗口中右键单击测试项目，然后单击**Run Test**。应用将启动，并且测试将运行。
- en: Additional information
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 附加信息
- en: Running the UI tests on a mac requires having compatible versions of the test
    libraries, tools, and OS versions. If you encounter errors when running the tests,
    ensure you have the latest versions of OS X, Xcode, Visual Studio for Mac, and
    the NuGet packages you are using in the test project. You may also need to ensure
    that the device or simulator you are running against is the latest iOS version
    (including any updates).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上运行UI测试需要具有兼容的测试库、工具和操作系统版本。如果在运行测试时遇到错误，请确保您拥有OS X、Xcode、Visual Studio
    for Mac和测试项目中使用的NuGet包的最新版本。您还可能需要确保您正在运行的设备或模拟器是最新的iOS版本（包括任何更新）。
- en: Running the UI tests on a simulator can be resource-intensive. You may find
    it necessary to run the tests on a connected device if they don't start on the
    simulator.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器上运行UI测试可能会消耗大量资源。如果测试无法在模拟器上启动，可能需要在连接的设备上运行测试。
- en: If testing on a physical device, UI automation must be enabled. Enable this
    at **Settings > Developer > UI Automation**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在物理设备上进行测试，必须启用UI自动化。在**设置 > 开发人员 > UI自动化**中启用此功能。
- en: Hopefully, more documentation will be added that will make testing and debugging
    tests on a Mac easier. For progress on this, see [https://github.com/unoplatform/Uno.UITest/issues/66](https://github.com/unoplatform/Uno.UITest/issues/66).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 希望会添加更多文档，使在Mac上进行测试和调试测试更加容易。有关此问题的进展，请参见[https://github.com/unoplatform/Uno.UITest/issues/66](https://github.com/unoplatform/Uno.UITest/issues/66)。
- en: Now that we have covered how to run your tests against the Android, iOS, and
    WASM versions of the app, we will dive deeper into writing tests by writing more
    UI tests for our sign-in interface.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何针对Android、iOS和WASM版本的应用程序运行测试，我们将通过为我们的登录界面编写更多UI测试来深入了解如何编写测试。
- en: Writing more complex tests
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写更复杂的测试
- en: 'So far, we have only tested the very basic example of our sign-in interface
    rendering. However, we also want to make sure that our sign-in interface actually
    works and allows users to sign in. For this, we will write a new test that ensures
    that when a username and password are being provided, the sign-in button is clickable:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只测试了登录界面呈现的基本示例。但是，我们还希望确保我们的登录界面实际上可以正常工作并允许用户登录。为此，我们将编写一个新的测试，以确保在提供用户名和密码时，登录按钮是可点击的：
- en: Create a new function, `VerifyButtonIsEnabledWithUsernameAndPassword`, inside
    the `SignInTests.cs` file and add the **Test** attribute to it.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SignInTests.cs`文件中创建一个名为`VerifyButtonIsEnabledWithUsernameAndPassword`的新函数，并为其添加**Test**属性。
- en: 'Since we will use those queries more often, add the following `Query` objects
    to the `SignInTests` class:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将经常使用这些查询，因此将以下`Query`对象添加到`SignInTests`类中：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s simulate entering text in the username and password fields by inserting
    the following code into the `VerifyButtonIsEnabledWithUsernameAndPassword` test:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过将以下代码插入`VerifyButtonIsEnabledWithUsernameAndPassword`测试来模拟在用户名和密码字段中输入文本：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Important note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Due to a bug with Xamarin.UITest, the testing library Uno.UITest uses for Android
    and iOS, clearing and entering tests does not work on every Android device or
    emulator. You can find more information on this bug here: [https://github.com/microsoft/appcenter/issues/1451](https://github.com/microsoft/appcenter/issues/1451).
    As a workaround, you can use an Android emulator with API version 28 or lower
    as those Android versions are not affected by this bug.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Xamarin.UITest存在一个bug，Uno.UITest用于Android和iOS的测试库，清除和输入测试无法在每台Android设备或模拟器上正常工作。您可以在这里找到有关此错误的更多信息：[https://github.com/microsoft/appcenter/issues/1451](https://github.com/microsoft/appcenter/issues/1451)。作为解决方法，您可以使用API版本为28或更低的Android模拟器，因为这些Android版本不受此bug影响。
- en: This will simulate a user entering the text `test` into the username input field
    and the same text into the password input field. Note that in this and the following
    tests, we will always clear the text beforehand to ensure that the correct text
    has been entered.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将模拟用户在用户名输入字段和密码输入字段中输入文本`test`。请注意，在这个和后续的测试中，我们将始终在输入文本之前清除文本，以确保输入了正确的文本。
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When running multiple tests as a group, for example, by selecting multiple tests
    or their root node in the Test Explorer, Uno.UITest will not reset the app between
    the individual tests. That means that you will need an initialization code for
    your tests if those rely on a specific initial app state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在作为一组运行多个测试时，例如通过选择多个测试或它们的根节点在测试资源管理器中，Uno.UITest不会在各个测试之间重置应用程序。这意味着如果测试依赖于特定的初始应用程序状态，则需要为您的测试编写初始化代码。
- en: 'Now, let''s verify that the sign-in button is enabled by using the following
    code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下代码验证登录按钮是否已启用：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For this, we ensure that the button exists and grab the `IAppResult[]` object
    for that query. We then check that the button is enabled through the `IAppResult.Enabled`
    property. Note that we added a message to the assert that will be displayed when
    the assert fails by providing a second parameter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此操作，我们确保按钮存在，并获取该查询的`IAppResult[]`对象。然后，我们通过`IAppResult.Enabled`属性检查按钮是否已启用。请注意，我们通过提供第二个参数向断言添加了一条在断言失败时显示的消息。
- en: Now, if you run the test for Android, the app will start on your Android device
    or the emulator. `Uno.UITest` will then enter text inside the **Username** and
    **Password** input fields and you should see the sign-in button become clickable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果在Android上运行测试，应用程序将在您的Android设备或模拟器上启动。`Uno.UITest`然后会在**用户名**和**密码**输入字段中输入文本，您应该会看到登录按钮变为可点击状态。
- en: 'Let''s now test whether invalid sign-in credentials provide a meaningful error
    message. For this, we will write a new test:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试无效的登录凭据是否提供了有意义的错误消息。为此，我们将编写一个新的测试：
- en: Create a new function, `VerifyInvalidCredentialsHaveErrorMessage`, inside the
    `SignInTests.cs` file and add the **Test** attribute to it.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SignInTests.cs`文件中创建一个名为`VerifyInvalidCredentialsHaveErrorMessage`的新函数，并为其添加**Test**属性。
- en: 'Now, add a new query to the `SignInTests` class that we will use to access
    the error message label:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`SignInTests`类中添加一个新的查询，我们将用它来访问错误消息标签：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s enter credentials that are definitely invalid and press the **Sign
    in** button using the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们输入绝对无效的凭据并使用以下代码按下**登录**按钮：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since we will be using `Uno.UITest` extensions methods and `Linq` inside our
    test, add the following `using` statements:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将在测试中使用`Uno.UITest`扩展方法和`Linq`，请添加以下`using`语句：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Lastly, we need to verify the error message using the following code. By that,
    we check that the error label is displaying the appropriate error message:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要使用以下代码验证错误消息。通过这样做，我们检查错误标签是否显示适当的错误消息：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you run this test now, you will see how the username **"invalid"** and the
    password "**invalid"** will be entered. After that, the test clicks on the sign-in
    button and you will see the error message **Username or password invalid or user
    does not exist.**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您现在运行此测试，您将看到用户名**“invalid”**和密码**“invalid”**将被输入。之后，测试点击登录按钮，您将看到错误消息**用户名或密码无效或用户不存在**。
- en: 'Lastly, we want to verify the fact that with valid credentials, users can sign
    in. For this, we will use the username `demo` and the password `1234`, as these
    are known to the authentication code as a demo user:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望验证具有有效凭据的用户可以登录的事实。为此，我们将使用用户名`demo`和密码`1234`，因为这些对身份验证代码来说是已知的演示用户：
- en: As with the previous tests, create a new function with the name `VerifySigningInWorks`
    inside the `SignInTests.cs` file and add the `Test` attribute to it.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与以前的测试一样，创建一个名为`VerifySigningInWorks`的新函数，并在`SignInTests.cs`文件中添加`Test`属性。
- en: Since we will use the `SignedInLabel` to detect whether we are signed in, add
    the following query as we will use it later to detect whether the label is visible.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用`SignedInLabel`来检测我们是否已登录，因此添加以下查询，因为我们稍后将使用它来检测标签是否可见。
- en: 'Add the following code to enter the demo user credentials and sign in:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以输入演示用户凭据并登录：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Lastly, check whether we are signed in by verifying that the signed-in label
    is visible and displaying the correct text using the following code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过以下代码验证我们是否已登录，以验证已登录标签是否可见并显示正确的文本：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you run this test, you will see how the username `demo` and the password
    `1234` have been entered. After the sign-in button gets clicked by the test, the
    sign-in form will disappear and you will see the text **Successfully signed in**.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运行此测试，您将看到用户名`demo`和密码`1234`已被输入。测试点击登录按钮后，登录表单将消失，您将看到文本**成功登录**。
- en: 'While we covered writing tests using Uno.UITest, of course, we didn''t cover
    all the available APIs. *Figure 7.3* shows a list of different APIs available
    as part of Uno.UITest and how you can use them:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们介绍了使用Uno.UITest编写测试，当然，我们并没有涵盖所有可用的API。*图7.3*显示了Uno.UITest作为一部分提供的不同API列表以及您可以如何使用它们：
- en: '![Figure 7.3 – List of additional APIs available as part of Uno.UITest'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 - Uno.UITest的其他可用API列表'
- en: '](img/Figure_7.03_B17132.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.03_B17132.jpg)'
- en: Figure 7.3 – List of additional APIs available as part of Uno.UITest
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 - Uno.UITest的其他可用API列表
- en: Now that we have covered writing tests using `Uno.UITest`, let's look at tools
    you can use to write automated tests for your app, including using WinAppDriver
    to write UI tests for the UWP head of your app.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了使用`Uno.UITest`编写测试，让我们看看您可以使用的工具来为您的应用程序编写自动化测试，包括使用WinAppDriver为应用程序的UWP头部编写UI测试。
- en: Test tools beside Uno.UITest
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 除了Uno.UITest之外的测试工具
- en: '`Uno.UITest` is not the only tool you can use to write automated tests for
    your Uno Platform app. In this section, we will cover writing UI tests for the
    UWP head of your project using WinAppDriver and Selenium and writing unit tests
    for the UWP head of the project.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Uno.UITest`并不是您可以用来为Uno平台应用编写自动化测试的唯一工具。在本节中，我们将介绍使用WinAppDriver和Selenium为项目的UWP头部编写UI测试，并为项目的UWP头部编写单元测试。'
- en: Testing the UWP head of your app with WinAppDriver
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用WinAppDriver测试应用程序的UWP头部
- en: 'At the time of writing, Uno.UITest does not support running the tests against
    the UWP head of your app. However, you might also want to run UI tests against
    the UWP version of your app. Luckily, **WinAppDriver** and **Appium** allow us
    to achieve this. WinAppDriver is a tool developed by Microsoft that allows developers
    to simulate input to Windows apps, including UWP apps. While WinAppDriver allows
    you to interact with Windows apps, it does so by starting a web server locally
    and allows interaction with apps by communicating with WinAppDriver through a
    web-based protocol. To make the development process easier for us, we will use
    **Appium.WebDriver** as our library to write the UI tests. We will start by creating
    our test project and adding the necessary tests. Note that we will be creating
    a new project since we don''t want Appium.WebDriver to interfere with Uno.UITest
    and we can''t use Appium and WinAppDriver from inside a UWP project, meaning we
    can''t reuse our UWP Unit test project:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Uno.UITest不支持针对应用程序的UWP头部运行测试。但是，您可能还想针对应用程序的UWP版本运行UI测试。幸运的是，**WinAppDriver**和**Appium**允许我们实现这一点。WinAppDriver是微软开发的一个工具，允许开发人员模拟对Windows应用程序（包括UWP应用程序）的输入。虽然WinAppDriver允许您与Windows应用程序交互，但它是通过在本地启动一个Web服务器，并通过与WinAppDriver通过基于Web的协议进行通信来允许与应用程序交互的。为了使开发过程对我们更加容易，我们将使用**Appium.WebDriver**作为编写UI测试的库。我们将首先创建我们的测试项目并添加必要的测试。请注意，我们将创建一个新项目，因为我们不希望Appium.WebDriver干扰Uno.UITest，并且我们无法从UWP项目内部使用Appium和WinAppDriver，这意味着我们无法重用我们的UWP单元测试项目：
- en: First, you will need to install WinAppDriver. For this, go to the releases page
    of WinAppDriver ([https://github.com/Microsoft/WinAppDriver/releases](https://github.com/Microsoft/WinAppDriver/releases))
    and download the latest MSI installer. At the time of writing, the latest stable
    release was version `WinAppDriver.exe` file and if you install WinAppDriver in
    a different folder, you should make a note of the installation folder.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要安装WinAppDriver。为此，请转到WinAppDriver的发布页面（[https://github.com/Microsoft/WinAppDriver/releases](https://github.com/Microsoft/WinAppDriver/releases)）并下载最新的MSI安装程序。在撰写本文时，最新的稳定版本是版本`WinAppDriver.exe`文件，如果您在不同的文件夹中安装了WinAppDriver，您应该记下安装文件夹。
- en: Open the **UnoAutomatedTestsApp** solution and create a new Unit Test project.
    To do this, right-click on the solution node and click **Add > New Project**.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**UnoAutomatedTestsApp**解决方案并创建一个新的单元测试项目。要做到这一点，右键单击解决方案节点，然后点击**添加 > 新建项目**。
- en: In the dialog, search for `Unit Test App` and select the option highlighted
    in *Figure 7.4*:![Figure 7.4 – Unit Test Project template in the new project dialog
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框中搜索`Unit Test App`并选择*图7.4*中突出显示的选项：![图7.4 - 新项目对话框中的单元测试项目模板
- en: '](img/Author_Figure_7.04_B17132.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Author_Figure_7.04_B17132.jpg)'
- en: Figure 7.4 – Unit Test Project template in the new project dialog
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 - 新项目对话框中的单元测试项目模板
- en: Press `UnoAutomatedTestsApp.UWPUITests`. Of course, you can name the project
    differently; however, we will assume that the project is named `UnoAutomatedTestsApp.UWPUITests`
    in this chapter. Then, press **Next**.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按`UnoAutomatedTestsApp.UWPUITests`。当然，您可以以不同的名称命名项目；但是，在本章中，我们将假定项目命名为`UnoAutomatedTestsApp.UWPUITests`。然后，点击**下一步**。
- en: Now, select the target framework; we will be using **.NET 5.0**. Now, click
    **Create** to create the project.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择目标框架；我们将使用**.NET 5.0**。现在，点击**创建**来创建项目。
- en: Once the project is created, right-click the project in the solution view and
    click on `Appium.WebDriver` in the **Browse** section and installing the package.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目后，在解决方案视图中右键单击项目，然后在**浏览**部分点击`Appium.WebDriver`并安装该包。
- en: 'Now that we have created the unit test project, we can write our first UI test
    using `Appium.Webdriver`. We will only cover how to write your first test using
    Appium and WinAppDriver. You can find more information about WinAppDriver and
    writing tests in their official documentation:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了单元测试项目，我们可以使用`Appium.Webdriver`编写我们的第一个UI测试。我们将只介绍如何使用Appium和WinAppDriver编写您的第一个测试。您可以在它们的官方文档中找到有关WinAppDriver和编写测试的更多信息：
- en: Before we write our first test, first rename the `UnitTest1.cs` file to `SignInTests.cs`.
    and also rename the `UnitTest1` class to `SignInTests`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写我们的第一个测试之前，首先将`UnitTest1.cs`文件重命名为`SignInTests.cs`。还将`UnitTest1`类重命名为`SignInTests`。
- en: Open the `Package.appxmanifest` file located inside the UWP head of the app
    and change the `UnoAutomatedTestsApp`. Now, deploy the UWP head of your app by
    selecting the UWP head and pressing *Ctrl + F5*. Since we have changed the package
    name, we want the test to start the app using the updated package name.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于应用程序UWP头部内的`Package.appxmanifest`文件，并更改`UnoAutomatedTestsApp`。现在，通过选择UWP头部并按下*Ctrl
    + F5*来部署您的应用程序的UWP头部。由于我们已更改了包名称，我们希望测试使用更新后的包名称启动应用程序。
- en: 'Add the following `using` statements to the `SignInTests` class:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`语句添加到`SignInTests`类中：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, add the following code to the `SignInTests` class.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到`SignInTests`类中。
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, remove the existing `TestMethod1` test and add the following test:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，删除现有的`TestMethod1`测试，并添加以下测试：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Like the `VerifyButtonIsEnabledWithUsernameAndPassword` test we wrote in the
    Uno.UITest section, this test verifies that when a username and password have
    been entered, the sign-in button is enabled.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在Uno.UITest部分编写的`VerifyButtonIsEnabledWithUsernameAndPassword`测试一样，此测试验证了当输入用户名和密码时，登录按钮是否已启用。
- en: 'Now that we have written our first test, let''s run it! To do this, you will
    first need to start WinAppDriver. If you have installed WinAppDriver in the default
    folder, you will find the `WinAppDriver.exe` file in the `C:\Program Files (x86)\Windows
    Application Driver` folder. If you have chosen a different installation folder
    earlier, open that folder and start the `WinAppDriver.exe` file inside there.
    Upon starting, you should see something as shown in *Figure 7.5*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了我们的第一个测试，让我们运行它！要做到这一点，您首先需要启动WinAppDriver。如果您已将WinAppDriver安装在默认文件夹中，您将在`C:\Program
    Files (x86)\Windows Application Driver`文件夹中找到`WinAppDriver.exe`文件。如果您之前选择了不同的安装文件夹，打开该文件夹并在其中启动`WinAppDriver.exe`文件。启动后，您应该看到如*图7.5*所示的内容。
- en: '![Figure 7.5 – Window running WinAppDriver'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 - 运行WinAppDriver的窗口'
- en: '](img/Figure_7.05_B17132.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.05_B17132.jpg)'
- en: Figure 7.5 – Window running WinAppDriver
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 - 运行WinAppDriver的窗口
- en: Now, you can start the test by right-clicking the **VerifyButtonIsEnabledWithUsernameAndPasswordUWP**
    test inside the test explorer and clicking on **Run**. The test will start the
    app, enter the text, and then check whether the sign-in button is enabled.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过右键单击测试资源管理器中的**VerifyButtonIsEnabledWithUsernameAndPasswordUWP**测试并点击**运行**来启动测试。测试将启动应用程序，输入文本，然后检查登录按钮是否已启用。
- en: Automated accessibility testing with Axe.Windows
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Axe.Windows进行自动化可访问性测试
- en: 'In addition to writing normal UI tests, you can also add `Axe.Windows` is a
    library developed and maintained by Microsoft that aims to detect accessibility
    issues in apps. Adding `Axe.Windows` to your UI tests is simple:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编写常规UI测试之外，您还可以添加`Axe.Windows`是由Microsoft开发和维护的旨在检测应用程序中的可访问性问题的库。将`Axe.Windows`添加到您的UI测试非常简单：
- en: Add a reference to the `Axe.Windows` package in the `Axe.Windows` and install
    the package.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Axe.Windows`和安装包中添加对`Axe.Windows`包的引用。
- en: 'Now, add the following two `using` statements to the `SignInTests.cs` file:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下两个`using`语句添加到`SignInTests.cs`文件中：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Lastly, add the following test to the `SignInTests` class:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下测试添加到`SignInTests`类中：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since `Axe.Windows` needs to know the process ID, we first get the process ID
    of the running app using the `Axe.Windows` configuration using the process ID,
    which we then use to create a new `Axe.Windows` scanner allows us to scan our
    app for accessibility issues using the `Scan()` returns a scan result object telling
    us that all accessibility issues have been found, we assert that we have found
    zero accessibility errors. When writing UI tests for more complex apps, you would
    scan the app more often to ensure that every scenario and view inside your app
    will be covered by this accessibility scan. For example, you could scan the app
    for accessibility issues every time you navigate to a different view. If you now
    run the test, the test app will start and after a few seconds, the test will be
    marked as `Axe.Windows`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Axe.Windows`需要知道进程ID，因此我们首先使用`Axe.Windows`配置获取正在运行的应用程序的进程ID，然后使用该进程ID创建一个新的`Axe.Windows`扫描程序，允许我们使用`Scan()`扫描我们的应用程序以查找辅助功能问题，返回一个扫描结果对象告诉我们已经找到了所有辅助功能问题，我们断言我们已经找到了零个辅助功能错误。在编写更复杂应用程序的UI测试时，您将更频繁地扫描应用程序，以确保此辅助功能扫描覆盖了应用程序内的每种情景和视图。例如，您可以在导航到不同视图时每次扫描应用程序以查找辅助功能问题。如果现在运行测试，测试应用程序将启动，几秒钟后，测试将被标记为`Axe.Windows`。
- en: 'In this section, we have only scratched the surface in terms of testing with
    WinAppDriver and Axe.Windows and there is a lot more we could cover. If you would
    like to learn more about authoring tests with WinAppDriver, you can find more
    information in their authoring test scripts documentation ([https://github.com/microsoft/WinAppDriver/blob/master/Docs/AuthoringTestScripts.md](https://github.com/microsoft/WinAppDriver/blob/master/Docs/AuthoringTestScripts.md))
    or take a look at their sample code: [https://github.com/microsoft/WinAppDriver/tree/master/Samples/C%23](https://github.com/microsoft/WinAppDriver/tree/master/Samples/C%23).
    If you wish to learn more about Axe.Windows, you can visit their GitHub repository:
    [https://github.com/microsoft/axe-windows](https://github.com/microsoft/axe-windows).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们只是浅尝辄止地介绍了使用WinAppDriver和Axe.Windows进行测试，还有很多内容可以涵盖。如果您想了解更多关于使用WinAppDriver编写测试的信息，可以在其编写测试脚本文档中找到更多信息（[https://github.com/microsoft/WinAppDriver/blob/master/Docs/AuthoringTestScripts.md](https://github.com/microsoft/WinAppDriver/blob/master/Docs/AuthoringTestScripts.md)），或者查看它们的示例代码：[https://github.com/microsoft/WinAppDriver/tree/master/Samples/C%23](https://github.com/microsoft/WinAppDriver/tree/master/Samples/C%23)。如果您想了解更多关于Axe.Windows的信息，可以访问它们的GitHub存储库：[https://github.com/microsoft/axe-windows](https://github.com/microsoft/axe-windows)。
- en: In the next section, we will cover how to write unit tests for your Uno Platform
    app, including the different approaches to it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何为Uno平台应用程序编写单元测试，包括不同的方法。
- en: Writing unit tests for your Uno Platform app
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Uno平台应用程序编写单元测试
- en: As app complexity increases, ensuring that your app's logic is working becomes
    increasingly difficult to validate without tests. While you can use UI tests to
    validate the logic, you can only verify logic that gets exposed as part of the
    UI. Things such as network access or error handling, however, become very difficult
    to validate using UI tests as those things are generally exposed through the UI.
    In addition to that, UI tests are slower since they are mimicking user interaction
    and rely on the rendered UI to update.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序复杂性的增加，确保应用程序逻辑的正常工作变得越来越难以在没有测试的情况下验证。虽然您可以使用UI测试来验证逻辑，但您只能验证作为UI的一部分公开的逻辑。然而，诸如网络访问或错误处理之类的事情很难使用UI测试来验证，因为这些事情通常是通过UI公开的。除此之外，UI测试速度较慢，因为它们模拟用户交互并依赖于渲染的UI进行更新。
- en: This is where **unit tests** come in. Unit tests are small tests that verify
    single units of your code. Most commonly, classes or functions are treated as
    individual units and tests are grouped based on the class or function they are
    testing; in other words, for every class you want to test, there is a set of tests
    only targeting that class and not any other class. As the complexity of your app
    increases, unit tests allow you to verify that single classes are still working
    as expected.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**单元测试**的作用。单元测试是验证代码的单个单元的小测试。最常见的是，类或函数被视为单独的单元，并且测试是根据它们正在测试的类或函数进行分组的；换句话说，对于每个要测试的类，都有一组仅针对该类而不是任何其他类的测试。随着应用程序复杂性的增加，单元测试允许您验证单个类仍然按预期工作。
- en: Important note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Unit tests are no silver bullet! While unit tests allow you to verify the behavior
    of single pieces of functionality, larger and more complex apps also require more
    tests besides unit tests, in other words, UI tests to ensure that the app as a
    whole works as expected. Only because single classes work correctly in isolation,
    this does not mean that the whole construct works together as expected and is
    bug-free!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试并非万能药！虽然单元测试允许您验证单个功能片段的行为，但更大更复杂的应用程序除了单元测试之外还需要更多的测试，换句话说，还需要UI测试来确保整个应用程序按预期工作。仅仅因为单个类在隔离状态下工作正确，并不意味着整个构造体按预期工作且没有错误！
- en: Since, at the time of writing, only creating unit tests against the UWP head
    is well supported, we will focus on this. We will now cover the different ways
    to create the unit test project.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在撰写本文时，只有针对UWP头部创建单元测试得到了很好的支持，因此我们将重点关注这一点。我们现在将介绍创建单元测试项目的不同方法。
- en: Different approaches to adding a unit test project
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加单元测试项目的不同方法
- en: Since most, if not all, of your app's logic sits inside a shared project, writing
    unit tests is a bit more complex. Since the shared project does not actually produce
    an assembly that you can reference, there are different ways to test your app's
    logic, which both come with their own benefits and drawbacks.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数，如果不是全部，您的应用程序逻辑都位于共享项目中，编写单元测试会更加复杂。由于共享项目实际上并不生成您可以引用的程序集，因此有不同的方法来测试应用程序的逻辑，它们都具有各自的优点和缺点。
- en: The first option is to create a project containing the unit tests for the platform
    you want to run the tests on and reference the shared project in that project.
    This is the easiest way to get started since you just need to create a new project
    and reference the shared project. One of the downsides is that since shared projects
    don't allow references such as NuGet packages to be added to them, any libraries
    you are using inside your shared project also need to be referenced by your test
    project. In addition to this, since the shared project does not create a binary
    but is compiled into the projects that are referencing it, changes made to the
    shared project will always result in the tests project recompiling.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是创建一个包含要在其上运行测试的平台的单元测试的项目，并在该项目中引用共享项目。这是最简单的入门方式，因为您只需要创建一个新项目并引用共享项目。其中一个缺点是，由于共享项目不允许添加诸如NuGet包之类的引用，您在共享项目中使用的任何库也需要被测试项目引用。此外，由于共享项目不创建二进制文件，而是编译到引用它的项目中，对共享项目所做的更改将始终导致测试项目重新编译。
- en: The next option is to leave your code inside the shared project and reference
    the platforms head project inside the unit test projects; for example, create
    a UWP Unit test project and reference the UWP head of your app inside it. This
    option is better than the first option since you don't encounter the issues of
    library references needing to be added to the test project since the platform
    head references the libraries for us. We will use this approach in this chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项是将代码留在共享项目中，并在单元测试项目中引用平台头项目；例如，创建一个UWP单元测试项目，并在其中引用您的应用程序的UWP头。这个选项比第一个选项更好，因为您不会遇到需要添加到测试项目的库引用的问题，因为平台头为我们引用了库。我们将在本章中使用这种方法。
- en: The last option is to move the code inside the shared project into a **Cross
    Platform Library (Uno Platform)** project and reference the library in the platform
    heads and unit test projects. This approach has the benefit that you can add library
    references to the library project on its own and don't have to manually add the
    reference to the individual projects. One of the downsides is that you have to
    switch to a cross-platform library project type instead of being able to use the
    existing shared project. This approach also has the downside that the cross-platform
    library will always be compiled for all platforms, thereby increasing the build
    time when only requiring specific platforms.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项是将共享项目中的代码移动到**跨平台库（Uno Platform）**项目中，并在平台头和单元测试项目中引用该库。这种方法的好处是您可以单独为库项目添加库引用，而无需手动添加到各个项目的引用。其中一个缺点是，您必须切换到跨平台库项目类型，而不能使用现有的共享项目。这种方法还有一个缺点，即跨平台库将始终为所有平台编译，从而在只需要特定平台时增加构建时间。
- en: Let's now add a unit test to our app by using the second option previously discussed,
    that is, adding a reference to the platforms head project.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过使用先前讨论的第二个选项，即添加对平台头项目的引用，向我们的应用程序添加一个单元测试。
- en: Adding your first unit test project
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加您的第一个单元测试项目
- en: 'Since we will reference the UWP platform head, we need a UWP unit test app.
    For this, we first need to add a new project:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将引用UWP平台头，我们需要一个UWP单元测试应用程序。为此，我们首先需要添加一个新项目：
- en: Right-click the solution and click **Add > New Project**.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击解决方案，点击**添加 > 新建项目**。
- en: In the dialog, search for the **Unit Test App (Universal Windows)** text and
    select the **Unit Test App (Universal Windows)** project type, as shown in *Figure
    7.6*:![Figure 7.6 – Unit Test App (Universal Windows) project type in a new project
    dialog
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框中，搜索**Unit Test App (Universal Windows)**文本，并选择**Unit Test App (Universal
    Windows)**项目类型，如*图7.6*所示：![图7.6 - 新项目对话框中的Unit Test App (Universal Windows)项目类型
- en: '](img/Author_Figure_7.06_B17132.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Author_Figure_7.06_B17132.jpg)'
- en: Figure 7.6 – Unit Test App (Universal Windows) project type in a new project
    dialog
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 - 新项目对话框中的Unit Test App (Universal Windows)项目类型
- en: Click `UnoAutomatedTestsApp.UWPUnitTests`. You can name the project differently,
    of course; however, in this and the following sections, we will assume that the
    project is named as mentioned previously.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`UnoAutomatedTestsApp.UWPUnitTests`。当然，您可以给项目取不同的名称；但是，在本节和接下来的几节中，我们将假设项目名称如前所述。
- en: Select the minimum and target version. We will use **18362** for both since
    the UWP head of the app also uses those. Not using the same minimum and target
    version of the UWP head might result in build errors, so you should always aim
    to match the UWP head.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择最小和目标版本。我们将使用**18362**，因为应用程序的UWP头也使用这些版本。不使用与UWP头相同的最小和目标版本可能会导致构建错误，因此您应该始终努力匹配UWP头。
- en: Now, add a reference for the UWP head to the Unit Test App project. For this,
    right-click the **UnoAutomatedTestsApp.UWPUnitTests** project in the solution
    view, click **Add > Reference… > Projects**, check **UnoAutomatedTestsApp.UWP**,
    and then click **OK**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为Unit Test App项目添加对UWP头的引用。为此，在解决方案视图中右键单击**UnoAutomatedTestsApp.UWPUnitTests**项目，点击**添加
    > 引用… > 项目**，勾选**UnoAutomatedTestsApp.UWP**，然后点击**确定**。
- en: Since the reference to the UWP head will also copy the `Properties/Default.rd.xml`
    file into the build output folder, this will result in a build issue as there
    are two `Default.rd.xml` files that the compiler wants to copy into the same folder.
    Because of that, rename the `Default.rd.xml` file of the unit test app to `TestsDefault.rd.xml`.
    Then, also update the `UnoAutomatedTestsApp.UWPUnitTests.csproj` file to point
    to that file. If you are renaming the file from the **Solution** view, you just
    need to select the project and press *Ctrl + S*.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于对UWP头的引用还会将`Properties/Default.rd.xml`文件复制到构建输出文件夹中，这将导致构建问题，因为编译器希望将两个`Default.rd.xml`文件复制到同一个文件夹中。因此，将单元测试应用程序的`Default.rd.xml`文件重命名为`TestsDefault.rd.xml`。然后，还要更新`UnoAutomatedTestsApp.UWPUnitTests.csproj`文件指向该文件。如果您从**解决方案**视图重命名文件，只需选择项目并按下*Ctrl
    + S*。
- en: In addition to that, we also need to rename the image assets of the unit test
    project. For this, prepend all images inside the `Assets` folder with `UWPUnitTestApp-`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除此之外，我们还需要重命名单元测试项目的图像资产。为此，请在`Assets`文件夹中的所有图像前加上`UWPUnitTestApp-`。
- en: 'We are now able to write and run unit tests for everything included inside
    the UWP head, including classes included inside the shared project. For larger
    apps that also have platform conditional code, you will only be able to reference
    classes and code inside the UWP unit test project that are getting compiled for
    the UWP head. Now that we have created the project, let''s write a small unit
    test. In contrast to the Uno.UITest tests project, the Unit Test App (Universal
    Windows) project type uses **MSTest** as the testing framework. Of course, you
    can change this, but for simplicity, we will stick with MSTest. Note that you
    can''t use NUnit for UWP unit tests as it does not support UWP:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够为UWP头部内的所有内容编写和运行单元测试，包括共享项目内的类。对于还包含平台条件代码的较大应用程序，您只能引用为UWP头部编译的类和代码。现在我们已经创建了项目，让我们编写一个小的单元测试。与Uno.UITest测试项目相比，单元测试应用程序（Universal
    Windows）项目类型使用**MSTest**作为测试框架。当然，您可以更改这一点，但为了简单起见，我们将坚持使用MSTest。请注意，您不能在UWP单元测试中使用NUnit，因为它不支持UWP。
- en: Since we don't have many classes we can test now, let's add a new class to the
    shared project. To do this, create a new class named `DemoUtils`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在没有太多可以测试的类，让我们向共享项目添加一个新类。为此，请创建一个名为`DemoUtils`的新类。
- en: 'Replace the code of the file with the following:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换文件的代码：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We will just use this code so that we have something easy to write unit tests
    for.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只使用这段代码，以便我们有一些简单的单元测试可供编写。
- en: Now, rename the `UnitTest.cs` file inside the `DemoUtilsTests.cs`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`DemoUtilsTests.cs`文件重命名为`UnitTest.cs`。
- en: 'Now, replace the content of the `DemoUtilsTests.cs` file with the following:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用以下内容替换`DemoUtilsTests.cs`文件的内容：
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a small unit test to verify that our `DemoUtils.IsEven` function successfully
    determines that the number **2** is even.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小的单元测试，用于验证我们的`DemoUtils.IsEven`函数成功确定数字**2**是偶数。
- en: We have now added our first unit test. As is the case with the UI test, you
    can run the test by opening the test explorer, expanding the tree, right-clicking
    the **VerifyEvenNumberIsEven** test, and clicking on **Run**. The test will then
    compile, deploy the unit test app, and start it. Your tests will be run and the
    unit test app will then close.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经添加了我们的第一个单元测试。与UI测试一样，您可以通过打开测试资源管理器，展开树，右键单击**VerifyEvenNumberIsEven**测试，然后单击**运行**来运行测试。然后将编译测试应用程序，部署它并启动它。您的测试将运行，然后单元测试应用程序将关闭。
- en: In the last section of this chapter, we will cover manual testing, why it is
    important, and how to approach testing accessibility manually using **Accessibility
    Insights**.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节中，我们将介绍手动测试，为什么它很重要以及如何使用**Accessibility Insights**手动测试可访问性。
- en: Performing manual testing and why it is important
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行手动测试及其重要性
- en: While automated tests help to find bugs and issues, there are certain things
    they cannot cover that still require manual testing. When developing apps that
    make use of features such as a camera, Bluetooth, or other device capabilities,
    writing automated tests is hard and sometimes even impossible. In these scenarios,
    manual testing is necessary. This is especially important with connectivity features
    to see how your app handles unstable connections and whether your app still provides
    a good user experience, especially with varying connection quality. More importantly,
    testing using emulators makes it hard to verify how the app will feel on actual
    devices, especially when thinking about the user experience, such as elements
    being the right size and easily tappable on screens.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自动化测试有助于发现错误和问题，但它们无法覆盖某些仍需要手动测试的内容。在开发利用摄像头、蓝牙或其他设备功能的应用程序时，编写自动化测试是困难的，有时甚至是不可能的。在这些情况下，手动测试是必要的。这在使用连接功能方面尤为重要，以查看您的应用程序如何处理不稳定的连接，以及您的应用程序是否仍然提供良好的用户体验，特别是在连接质量不同的情况下。更重要的是，使用模拟器进行测试很难验证应用程序在实际设备上的感觉，特别是在考虑用户体验时，例如元素的大小是否合适，并且在屏幕上是否容易点击。
- en: In addition to testing specific features that are hard to simulate as part of
    an automated test such as GPS or roaming data access, manual testing is also critical
    to ensure that your app is great usability-wise. While during development, running
    the app inside your emulator is fine, manual testing becomes more and more important
    as development progresses.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试特定功能，这些功能很难作为自动化测试的一部分进行模拟，例如GPS或漫游数据访问，手动测试也是确保您的应用在可用性方面表现出色的关键。在开发过程中，将应用程序在模拟器中运行是可以的，但随着开发的进行，手动测试变得越来越重要。
- en: Besides manually testing your app by using the app on a device or emulator,
    another important aspect is manually testing your app for accessibility. Ensuring
    that your app is accessible by users is crucial when developing apps, and while
    automated tests, such as `Axe.Windows` tests, can help find issues, they are not
    perfect. Since people with all levels of ability might use your app, making your
    app not accessible makes your app harder or even impossible to use for those customers.
    Since everyone should be able to use your app regardless of their level of ability,
    there are different tools when testing your app for accessibility. In this section,
    however, we will focus on using assistive technology and using the **Accessibility
    Insights** scanning tool.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过在设备或模拟器上使用应用程序手动测试应用程序之外，另一个重要方面是手动测试应用程序的可访问性。确保您的应用程序对用户是可访问的在开发应用程序时至关重要，虽然自动化测试，如`Axe.Windows`测试，可以帮助发现问题，但它们并不完美。由于可能有各种能力水平的人使用您的应用程序，使您的应用程序不可访问会使您的应用程序对这些客户更难甚至不可能使用。由于每个人都应该能够使用您的应用程序，无论他们的能力水平如何，因此在测试应用程序的可访问性时有不同的工具。然而，在本节中，我们将专注于使用辅助技术和使用**Accessibility
    Insights**扫描工具。
- en: 'Accessibility insights is a tool that allows you to scan your app for accessibility
    issues manually, similar to what `Axe.Windows` does. In fact, `Axe.Windows` under
    the hood. In contrast to `Axe.Windows`, Accessibility Insights also allows the
    testing of your web app and Android app for accessibility issues. In this chapter,
    you will learn how you can use Accessibility Insights for Windows. If you wish
    to learn more about Accessibility Insights, including using Accessibility Insights
    for Web and Accessibility Insights for Android, you can check out the official
    website: [https://accessibilityinsights.io/](https://accessibilityinsights.io/).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Accessibility Insights是一个允许你手动扫描应用程序的无障碍问题的工具，类似于`Axe.Windows`所做的。事实上，`Axe.Windows`就是其内部实现。与`Axe.Windows`相比，Accessibility
    Insights还允许测试你的Web应用程序和Android应用程序的无障碍问题。在本章中，你将学习如何使用Accessibility Insights for
    Windows。如果你想了解更多关于Accessibility Insights的信息，包括使用Accessibility Insights for Web和Accessibility
    Insights for Android，你可以查看官方网站：[https://accessibilityinsights.io/](https://accessibilityinsights.io/)。
- en: 'Now, let''s get started by using Accessibility Insights for Windows by using
    it on the UWP head of the UnoAutomatedTestsApp:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始使用Accessibility Insights for Windows，在UnoAutomatedTestsApp的UWP头上使用它：
- en: To do this, first, you need to download Accessibility Insights for Windows from
    [https://accessibilityinsights.io/docs/en/windows/overview/](https://accessibilityinsights.io/docs/en/windows/overview/)
    by clicking on **Download for Windows**. If you have already installed Accessibility
    Insights for Windows, you can proceed with *step 4*.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要从[https://accessibilityinsights.io/docs/en/windows/overview/](https://accessibilityinsights.io/docs/en/windows/overview/)点击**Download
    for Windows**来下载Accessibility Insights for Windows。如果你已经安装了Accessibility Insights
    for Windows，你可以继续进行*步骤4*。
- en: Once the download has finished, run the MSI Installer to install Accessibility
    Insights.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦下载完成，运行MSI安装程序安装Accessibility Insights。
- en: Once the installation process has finished, **Accessibility Insights for Windows**
    should start and you will see something similar to that shown in *Figure 7.7*
    after dismissing the telemetry dialog:![Figure 7.7 – Screenshot of Accessibility
    Insights
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装过程完成后，**Accessibility Insights for Windows**应该会启动，在关闭遥测对话框后，你会看到类似于*图7.7*所示的内容：![图7.7
    – Accessibility Insights的屏幕截图
- en: '](img/Figure_7.07_B17132.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.07_B17132.jpg)'
- en: Figure 7.7 – Screenshot of Accessibility Insights
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – Accessibility Insights的屏幕截图
- en: Once you have closed the popups, start the UWP head of `UnoAutomatedTestsApp`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你关闭了弹出窗口，启动`UnoAutomatedTestsApp`的UWP头。
- en: 'Now, if you hover over the app, you will notice that the area you are hovering
    over and the controls in that area will be surrounded by a dark blue area. In
    Accessibility Insights, you can see the different UI automation properties of
    the control, for example, the control''s `control type` or whether they are keyboard-focusable.
    To scan a control, you can either select the control from **Live Inspect tree**
    or click on the scan button in the top-right corner of the blue rectangle, as
    shown in *Figure 7.8*:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将鼠标悬停在应用程序上，你会注意到你悬停的区域和该区域的控件将被一个深蓝色区域所包围。在Accessibility Insights中，你可以看到控件的不同UI自动化属性，例如控件的“控件类型”或它们是否可以通过键盘进行焦点控制。要扫描一个控件，你可以从**Live
    Inspect tree**中选择控件，或者点击蓝色矩形框右上角的扫描按钮，如*图7.8*所示：
- en: '![Figure 7.8 – Highlighted scan icon on control'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 – 控件上突出显示的扫描图标'
- en: '](img/Figure_7.08_B17132.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.08_B17132.jpg)'
- en: Figure 7.8 – Highlighted scan icon on control
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 控件上突出显示的扫描图标
- en: While Accessibility Insights is a useful tool for finding accessibility issues,
    testing your app by using it with assistive technology is crucial to ensure that
    your app can be used by users with all levels of ability. For this, we will manually
    test the UWP head using Narrator. However, similar testing can be done on Android,
    iOS, and macOS. To learn how to start the assistive technology on different platforms,
    please refer to the *Starting the screen reader on different platforms* section
    in [*Chapter 5*](B17132_05_Final_VK_ePub.xhtml#_idTextAnchor083), *Making Your
    App Ready for the Real World*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Accessibility Insights是一个发现无障碍问题的有用工具，但通过使用辅助技术来测试你的应用程序对于确保你的应用程序可以被所有能力水平的用户使用至关重要。为此，我们将使用Narrator手动测试UWP头。然而，类似的测试也可以在Android、iOS和macOS上进行。要了解如何在不同平台上启动辅助技术，请参考[*第5章*](B17132_05_Final_VK_ePub.xhtml#_idTextAnchor083)中的*在不同平台上启动屏幕阅读器*部分，*使你的应用程序准备好迎接现实世界*。
- en: Let's walk through our app now using Narrator. To do this, start Narrator by
    pressing *Windows logo key*, *Ctrl*, and *Enter* at the same time and open `Axe.Windows`
    and Accessibility Insights for Windows did not catch. For this, enter a username
    by navigating to the username input field, entering the text `invalid`, and repeating
    the process for the password field. Upon navigating to the sign-in button and
    hitting the space bar, you will notice that you are not being notified of any
    error messages. This is an accessibility issue as users relying on assistive technology
    will not be notified of the error message and will not know what happened.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Narrator来浏览我们的应用程序。要做到这一点，按下*Windows标志键*、*Ctrl*和*Enter*同时启动Narrator，并打开`Axe.Windows`和Accessibility
    Insights for Windows没有捕捉到的内容。为此，通过导航到用户名输入字段，输入文本`invalid`，然后重复这个过程来到密码字段。在导航到登录按钮并按下空格键时，你会注意到你没有收到任何错误消息的通知。这是一个无障碍问题，因为依赖辅助技术的用户将不会收到错误消息的通知，也不会知道发生了什么。
- en: For larger apps, navigating through the app will be more complicated. While
    our test app is small and all controls are accessible, for larger apps using this
    testing, you can find crucial accessibility issues, for example, controls that
    have an unhelpful or even misleading representation for assistive technology.
    Finding these issues early in the development process makes them easier to fix
    and prevents them from impairing users.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的应用程序，浏览应用程序将会更加复杂。虽然我们的测试应用程序很小，所有控件都是可访问的，但对于使用此测试的更大的应用程序，你可以发现关键的无障碍问题，例如对辅助技术来说没有帮助甚至误导的控件表示。在开发过程中早期发现这些问题会使它们更容易修复，并防止它们影响用户。
- en: In this section, we scratched the surface of manual testing and why it is necessary.
    We also covered how to approach accessibility testing using Accessibility Insights
    and assistive technology.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们只是浅尝辄止地介绍了手动测试以及为什么它是必要的。我们还介绍了如何使用Accessibility Insights和辅助技术进行辅助功能测试的方法。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned how to write automated UI tests for your app
    using `Uno.UITest` and Selenium. We also then learned how to run those tests on
    different platforms, including running them on your app running on an emulator.
    After that, we covered how to write UI tests for the UWP head of the app using
    WinAppDriver and also write unit tests for the UWP head. Lastly, we covered manual
    testing and how to test for accessibility issues.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Uno.UITest和Selenium为您的应用程序编写自动化UI测试。然后，我们学习了如何在不同平台上运行这些测试，包括在模拟器上运行应用程序上的测试。之后，我们介绍了如何使用WinAppDriver为应用程序的UWP头部编写UI测试，并为UWP头部编写单元测试。最后，我们介绍了手动测试以及如何测试辅助功能问题。
- en: In the next chapter, we'll talk about deploying your app and how you can bring
    your `Xamarin.Form`**s** app to the web using Uno Platform. We will also cover
    how to build for other platforms and cover how you can join and even contribute
    to the Uno community.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论部署您的应用程序以及如何使用Uno平台将您的Xamarin.Forms应用程序带到Web上。我们还将介绍如何为其他平台构建，并介绍如何加入甚至为Uno社区做出贡献。
