- en: Chapter 6. Classes, Constructors, and Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。类，构造函数和方法
- en: In the heart of object-oriented programming are classes and the objects created
    from classes. The initialization of the objects occurs in constructors while the
    modification of the state of an object is carried through methods. The packaging
    of these constructors and methods is the focus of data encapsulation. The fundamentals
    of classes, constructors, methods, and data encapsulation are addressed in this
    chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的核心是类和从类创建的对象。对象的初始化发生在构造函数中，而对象状态的修改通过方法进行。这些构造函数和方法的封装是数据封装的重点。本章讨论了类，构造函数，方法和数据封装的基础知识。
- en: We start with an introduction to classes including a discussion of how objects
    are managed in memory. Common aspects of constructors and methods are then presented
    including the concept of a signature, the passing of arguments, and the uses of
    the `this` keyword.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从介绍类开始，包括如何在内存中管理对象。然后介绍了构造函数和方法的共同方面，包括签名的概念，参数的传递以及`this`关键字的用法。
- en: The usage of constructors is discussed including default constructors, how they
    are overloaded, and the use of private constructors. The Java initialization sequence
    is covered including the use of initializer lists.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论了构造函数的使用，包括默认构造函数，它们如何重载以及私有构造函数的使用。还介绍了Java初始化顺序，包括初始化程序列表的使用。
- en: Methods and how they are used is explained including how to overload them and
    the creation of accessor and mutator methods. The chapter concludes with a discussion
    of static and instance methods.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 解释了方法及其用法，包括如何重载它们以及创建访问器和修改器方法。本章最后讨论了静态方法和实例方法。
- en: Classes
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: A **class** is the definition of a data structure plus actions that operate
    on them which typically corresponds to a real world object or concept. A class
    is defined once but is not used directly within an application. Instead, objects
    are created (instantiated) based on a class and are allocated memory.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**是数据结构的定义，以及对它们进行操作的动作，通常对应于现实世界的对象或概念。类只定义一次，但不会直接在应用程序中使用。相反，基于类创建（实例化）对象，并为对象分配内存。'
- en: 'Throughout the chapter we will illustrate the use of constructors and methods
    using the `Employee` class. A part of this class is shown as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`Employee`类来说明构造函数和方法的用法。该类的一部分如下所示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This definition will be expanded to explain the concepts and techniques associated
    with classes and objects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义将被扩展，以解释与类和对象相关的概念和技术。
- en: Object creation
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象创建
- en: Objects are created using the `new` keyword. The keyword is used in conjunction
    with a classname and results in memory being allocated from the heap for the object.
    The heap is a region of memory normally located "above" the stack as discussed
    in the *Stack and heap* section in [Chapter 2](ch02.html "Chapter 2. Java Data
    Types and Their Usage"), *Java Data Types and Their Usage*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`new`关键字创建对象。该关键字与类名一起使用，导致为对象从堆中分配内存。堆是内存的一个区域，通常位于堆栈上方，如[第2章](ch02.html
    "第2章。Java数据类型及其使用")中的*堆栈和堆*部分所述，*Java数据类型及其使用*。
- en: 'When a new object is instantiated using the `new` keyword:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`new`关键字实例化新对象时：
- en: Memory is allocated for the new instance of the class
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为类的新实例分配内存
- en: A constructor is then called to perform initialization of the object
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后调用构造函数来初始化对象
- en: A reference to the object is returned
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回对象的引用
- en: 'In the following example, two instances of the `Employee` class are created
    and references are assigned to the reference variables, `employee1` and `employee2`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，创建了`Employee`类的两个实例，并将引用分配给引用变量`employee1`和`employee2`：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each instance of a class has its own set of instance variables that are independent
    of each other. This is shown in the following diagram. Notice that both instances
    of the class contain their own copies of the instance variables:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 类的每个实例都有自己独立的实例变量集。这在下图中显示。请注意，类的两个实例都包含它们自己的实例变量的副本：
- en: '![Object creation](img/7324_06_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![对象创建](img/7324_06_01.jpg)'
- en: When a new object is created, a constructor for that object is executed. The
    purpose of a constructor is to initialize an object. This process is covered in
    the *Constructors* section. The class' methods are shared among the instances
    of the class. That is, there is only one copy of the methods.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新对象时，会执行该对象的构造函数。构造函数的目的是初始化一个对象。这个过程在*构造函数*部分有详细介绍。类的方法在类的实例之间是共享的。也就是说，方法只有一个副本。
- en: Memory management
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理
- en: Java memory management is dynamic and automatic. When the `new` keyword is used,
    it automatically allocates memory on the heap.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Java内存管理是动态和自动的。当使用`new`关键字时，它会自动在堆上分配内存。
- en: 'In the following example, an instance of the `Employee` class is created and
    assigned to the `employee1` variable. Next, the `employee2` variable is assigned
    the value of the `employee1` variable. The effect of this assignment is that both
    reference variables point to the same object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，创建了`Employee`类的一个实例，并将其分配给`employee1`变量。接下来，将`employee2`变量赋值为`employee1`变量的值。这种赋值的效果是两个引用变量都指向同一个对象：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is illustrated in the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表说明了这一点：
- en: '![Memory management](img/7324_06_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![内存管理](img/7324_06_02.jpg)'
- en: 'A reference variable may de-reference an instance of an object by:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 引用变量可以通过以下方式取消引用对象的实例：
- en: Being re-assigned to another object
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被重新分配给另一个对象
- en: Setting it to null
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其设置为null
- en: When the garbage collector determines that there are no references to it, the
    object becomes eligible for removal from the heap by a garbage collection thread
    and its memory can be re-used for other objects. This garbage collection process
    is essentially beyond the control of the application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当垃圾收集器确定没有引用指向它时，对象就有资格被垃圾收集线程从堆中移除，并且它的内存可以被重新使用。这个垃圾收集过程基本上是应用程序无法控制的。
- en: Data encapsulation
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据封装
- en: Data encapsulation is concerned with hiding irrelevant information from the
    programmer and exposing the relevant information. Hiding the implementation details
    allow changes without affecting other parts of the program. For example, if a
    programmer wants to display a rectangle on the screen there are several approaches
    that can be used. It may involve drawing the rectangle pixel by pixel or drawing
    a series of lines. Hiding the details of the operation is referred to as data
    encapsulation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 数据封装涉及隐藏程序员不相关的信息，并公开相关信息。隐藏实现细节允许更改而不影响程序的其他部分。例如，如果程序员想要在屏幕上显示一个矩形，可以使用几种方法。可能涉及逐像素绘制矩形或绘制一系列线条。隐藏操作的细节称为数据封装。
- en: The primary purpose of data encapsulation is to reduce the level of software
    development complexity. By hiding the details of what is needed to perform an
    operation, the use of that operation is simpler. The method is not that complex
    to use, as the user does not have to worry about the details of its implementation.
    The user can focus on what it does, not on how it does it. This, in turn, allows
    developers to do more.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数据封装的主要目的是降低软件开发的复杂性。通过隐藏执行操作所需的细节，使用该操作变得更简单。该方法的使用并不复杂，因为用户不必担心其实现的细节。用户可以专注于它的功能，而不是它的实现方式。这反过来又使开发人员能够做更多事情。
- en: 'For example, consider the implementation of the `Employee` class. Originally,
    the instance variables were both declared as private:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`Employee`类的实现。最初，实例变量都声明为私有：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The access modifier type of the `name` variable has been changed to public and
    the access modifier for the `setAge` method has been made private. This means
    that any user of the class can access the `name` field but they can only read
    the `age` of the employee. Data encapsulation has been affected when we explicitly
    decide what should and should not be exposed to the users of a class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`变量的访问修饰符类型已更改为public，`setAge`方法的访问修饰符已更改为private。这意味着类的任何用户都可以访问`name`字段，但他们只能读取员工的`age`。当我们明确决定应该向类的用户公开什么和不公开什么时，数据封装就会受到影响。'
- en: The details of a class and its implementation should be hidden from the user.
    This allows modification of the implementation of the class' internals without
    changing the public aspects of the class. As a general rule, instance variables
    are made private and methods are made public. Exceptions to this rule are made
    based on the needs of the class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类及其实现的细节应该对用户隐藏。这允许修改类内部的实现而不改变类的公共方面。通常情况下，实例变量被设置为私有，方法被设置为公共。根据类的需求，可以对此规则进行例外处理。
- en: It is also possible to control access to constructors. This topic is covered
    in the *Constructors* section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以控制对构造函数的访问。这个主题在*构造函数*部分有所涉及。
- en: Referencing instance variables
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用实例变量
- en: 'A reference variable holds a reference, or pointer, to an object. A field or
    variable of the object is accessed by following the object reference variable
    name with a period and then the field or method name. The following code snippet
    illustrates possible references using the `Employee` class based upon the declaration
    of `Employee` found in the previous section:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 引用变量保存对对象的引用或指针。通过在对象引用变量名称后跟一个句点，然后是字段或方法名称，可以访问对象的字段或变量。以下代码片段说明了基于前一节中`Employee`声明的`Employee`类的可能引用：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that we did not use the `age` field as this was declared as private to
    the `Employee` class. The use of modifiers is covered in the *Access modifiers*
    section in [Chapter 1](ch01.html "Chapter 1. Getting Started with Java"), *Getting
    Started with Java*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有使用`age`字段，因为它被声明为`Employee`类的私有字段。修饰符的使用在[第1章](ch01.html "第1章. Java入门")的*访问修饰符*部分中有所涉及，*Java入门*。
- en: Signature
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签名
- en: 'The signature of a constructor or method is used to uniquely identify a constructor
    or method. A signature consists of:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数或方法的签名用于唯一标识构造函数或方法。签名由以下组成：
- en: Method or constructor name
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法或构造函数名称
- en: Number of parameters
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的数量
- en: Type of the parameters
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的类型
- en: Order of the parameters
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的顺序
- en: 'All constructors or methods within the same class must have unique signatures.
    Note that the return type of the method is not part of a signature. The following
    table shows the signatures that overload the `Employee` class constructor. The
    third and fourth constructors differ in the order of the constructor''s parameters.
    A method or constructor is said to be overloaded if there is more than one method
    or constructor with the same name, and in the same class, but with different signatures:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 同一类中的所有构造函数或方法必须具有唯一的签名。请注意，方法的返回类型不是签名的一部分。以下表格显示了重载`Employee`类构造函数的签名。第三个和第四个构造函数在构造函数参数的顺序上有所不同。如果同一类中有多个具有相同名称但具有不同签名的方法或构造函数，则称该方法或构造函数被重载：
- en: '| Method | Number of Arguments | Argument Types |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 参数数量 | 参数类型 |'
- en: '| --- | --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Employee()` | 0 |   |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `Employee()` | 0 |   |'
- en: '| `Employee(String name)` | 1 | `String` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `Employee(String name)` | 1 | `String` |'
- en: '| `Employee(String name, int zip)` | 2 | `String`, `int` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `Employee(String name, int zip)` | 2 | `String`, `int` |'
- en: '| `Employee(int zip, String name)` | 2 | `int`, `String` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `Employee(int zip, String name)` | 2 | `int`, `String` |'
- en: '| `Employee(String name, int zip, int age)` | 3 | `String`, `int`, `int` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `Employee(String name, int zip, int age)` | 3 | `String`, `int`, `int` |'
- en: Using the this keyword
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用this关键字
- en: 'There are four uses of the `this` keyword:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字有四种用途：'
- en: Performing constructor chaining
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行构造函数链接
- en: Accessing instance variables
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问实例变量
- en: Passing the current object to a method
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将当前对象传递给方法
- en: Returning the current object from a method
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从方法返回当前对象
- en: 'Constructor chaining is covered in the *Overloading constructors* section.
    Let''s examine the use of the `this` keyword to access instance variables. The
    `setAge` method could have been implemented as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数链接在*重载构造函数*部分进行了讨论。让我们来看一下使用`this`关键字访问实例变量的用法。`setAge`方法可以实现如下：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code would not have the intended consequences of modifying the `age` instance
    variable. The scope of the instance variables is the entire class. The scope of
    the parameters is only the method. The parameters will have "precedence" over
    the instance variables. The effect is that the age passed to the method was assigned
    to itself. The instance variable was not modified.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不会产生修改`age`实例变量的预期结果。实例变量的作用域是整个类。参数的作用域仅限于方法。参数将优先于实例变量。结果是传递给方法的年龄被分配给自己。实例变量没有被修改。
- en: 'There are two ways of correcting this problem:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 纠正这个问题有两种方法：
- en: Change the parameter name
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改参数名称
- en: Use the `this` keyword
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`this`关键字
- en: 'We could change the name of the parameter. However, devising a different name
    to designate the same thing leads to strange or awkward names. For example, we
    could have used the following method instead:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更改参数的名称。然而，为同一事物设计不同的名称会导致奇怪或尴尬的名称。例如，我们可以使用以下方法：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `initialAge` parameter will be assigned as the initial value to the member
    variable `age`. However, any number of other potentially meaningful names could
    be used. There is no standard naming convention for naming parameters of this
    type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialAge`参数将被分配为成员变量`age`的初始值。然而，也可以使用任意数量的其他可能有意义的名称。对于这种类型的参数，没有标准的命名约定。'
- en: 'Another approach is to declare the parameter as a constant using the `final`
    keyword, as shown in the following code snippet. When we take this approach, a
    syntax error is generated because we are trying to modify the parameter. As it
    is constant we cannot change it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`final`关键字将参数声明为常量，如下面的代码片段所示。当采用这种方法时，会生成语法错误，因为我们试图修改参数。由于它是常量，我们无法更改它：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The syntax error message that is generated is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的语法错误消息如下：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preferred approach is to use the `this` keyword to clearly specify which
    variable is the member variable and which is the parameter. This is illustrated
    in the following implementation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首选方法是使用`this`关键字明确指定成员变量和参数。下面是一个示例：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this assignment statement we referenced the member variable by prefixing
    it with the `this` keyword and a period. Consider the following statement:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个赋值语句中，我们使用`this`关键字和一个句点作为成员变量的前缀。考虑以下语句：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `this` keyword references the `age` instance variable, on the left-hand
    side of the assignment statement. On the right-hand side, the `age` parameter,
    was used. Thus, the parameter is assigned to the instance variable. Using the
    `this` keyword avoids having to devise some non-standard and potentially confusing
    name for parameters being assigned to a member variable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字引用了赋值语句左侧的`age`实例变量。在右侧，使用了`age`参数。因此，参数被分配给实例变量。使用`this`关键字避免了为参数分配给成员变量而设计一些非标准且可能令人困惑的名称。'
- en: 'The `this` keyword can also be used to pass or return a reference to the current
    object. In the following sequence, the `validateEmployee` method is assumed to
    be a member of the `Employee` class. If a condition is met, then the current employee,
    as identified by the `this` keyword, is added to a class maintaining department
    information as referenced by the `department` variable. A reference to the current
    object is passed to the `add` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字也可以用于传递或返回对当前对象的引用。在下面的序列中，假定`validateEmployee`方法是`Employee`类的成员。如果满足条件，则当前员工，由`this`关键字标识，将被添加到一个维护部门信息的类中，该类由`department`变量引用。对当前对象的引用被传递给`add`方法：'
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `this` keyword can also be used to return a reference to the current object.
    In the next sequence, the current object is returned by the `getReference` method
    which is assumed to be a method of the `Employee` class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字也可以用于返回对当前对象的引用。在下一个序列中，当前对象由假定为`Employee`类的`getReference`方法返回：'
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Passing parameters
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递参数
- en: Within any method there may exist two types of variables—parameters and local
    variables. Parameters contain values passed to the method when it is invoked.
    Local variables are part of the method and are used to assist the method in the
    completion of its task. The techniques discussed here apply to both constructors
    and methods though we will only use methods for the examples in this section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何方法中可能存在两种类型的变量——参数和局部变量。参数包含在调用方法时传递的值。局部变量是方法的一部分，并用于帮助方法完成其任务。这里讨论的技术适用于构造函数和方法，尽管在本节的示例中我们只使用方法。
- en: 'Parameters are passed as part of a parameter list. This list uses a comma to
    delimit the declaration of the type and name of a parameter. For example, the
    method in the following code snippet is passed two parameters—an integer and a
    string:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 参数作为参数列表的一部分传递。此列表使用逗号来分隔参数的类型和名称的声明。例如，以下代码片段中的方法传递了两个参数——一个整数和一个字符串：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Either a primitive data type or an object is passed to a method. The following
    terms are used to identify the data being passed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据类型或对象被传递给方法。以下术语用于标识被传递的数据：
- en: 'Argument: This is the variable being passed'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数：被传递的变量
- en: 'Parameter: This is the element defined within the method''s signature'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数：这是在方法签名中定义的元素
- en: 'For example, in the following code sequence `number` and `employee1` are the
    arguments while `num` and `employee` are the corresponding parameters to the `changeValues`
    method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下代码序列中，`number`和`employee1`是参数，而`num`和`employee`是`changeValues`方法的相应参数：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In Java, only primitive data types and object references are passed to a method
    or constructor. This is performed using a technique called **passing by value**
    . When a method is called, a copy of the argument is assigned to the parameter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，只有原始数据类型和对象引用被传递给方法或构造函数。这是使用一种称为**传值**的技术执行的。当调用方法时，参数被分配给参数的副本。
- en: When a primitive data type is passed, only a copy of the value is passed. This
    means if the copy in the called method is changed, the original data is not changed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递原始数据类型时，只传递值的副本。这意味着如果在被调用的方法中更改了副本，则原始数据不会更改。
- en: When a reference variable is passed, only a copy of the reference is passed.
    The object itself is not passed or copied. At this point we have two references
    to the same object—the argument reference variable and the parameter reference
    variable. We can modify the object using either reference variable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递引用变量时，只传递引用的副本。对象本身不会被传递或复制。此时我们有两个对同一对象的引用——参数引用变量和参数引用变量。我们可以使用任一引用变量修改对象。
- en: We can also change what the parameter references. That is, we can modify the
    parameter to reference a different object. If we modify the parameter we are not
    modifying the argument. The parameter and the argument reference variables are
    distinct variables.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以更改参数的引用。也就是说，我们可以修改参数以引用不同的对象。如果我们修改参数，我们并没有修改参数。参数和参数引用变量是不同的变量。
- en: Consider the following program where we pass an integer and a reference to a
    `Employee` object, to the `changeValues` method. In the method we change the integer,
    a field of the `Employee` object, and the `employee` reference variable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下程序，我们将一个整数和一个`Employee`对象的引用传递给`changeValues`方法。在方法中，我们更改整数，`Employee`对象的一个字段，以及`employee`引用变量。
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When executed we get the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时我们得到以下输出：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that when we changed the value of the `num` parameter, the `main` method's
    `number` variable did not change. Also, we changed the object's `age` field using
    the `changeValues` method's `employee` reference variable. However, when we modified
    what the `changeValues` method's `employee` reference variable pointed to by creating
    a new employee, we did not change the `main` method's `employee` reference variable.
    It still references the original object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们更改`num`参数的值时，`main`方法的`number`变量没有更改。此外，我们使用`changeValues`方法的`employee`引用变量更改了对象的`age`字段。但是，当我们通过创建一个新的employee修改了`changeValues`方法的`employee`引用变量指向的内容时，我们并没有更改`main`方法的`employee`引用变量。它仍然引用原始对象。
- en: 'The following diagram illustrates how this works. The stack and heap reflect
    the state of the application when the `changeValues` method is started and immediately
    before it returns. For simplicity, we have ignored the `args` variable:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了这是如何工作的。堆栈和堆反映了应用程序在启动`changeValues`方法时和在它返回之前的状态。为简单起见，我们忽略了`args`变量：
- en: '![Passing parameters](img/7324_06_03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![传递参数](img/7324_06_03.jpg)'
- en: Passing an object by value is an efficient parameter passing technique. It is
    efficient because we are are not copying the entire object. We only copy the reference
    to the object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值传递对象是一种高效的参数传递技术。它是高效的，因为我们不复制整个对象。我们只复制对象的引用。
- en: Variable number of arguments
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变数量的参数
- en: 'It is possible to pass a variable number of arguments to a method. However,
    there are some restrictions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将可变数量的参数传递给方法。但是，有一些限制：
- en: The variable number of parameters must all be the same type
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变数量的参数必须都是相同的类型
- en: They are treated as an array within the method
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在方法中被视为数组
- en: They must be the last parameter of the method
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须是方法的最后一个参数
- en: 'To understand these restrictions, consider the method, in the following code
    snippet, used to return the largest integer in a list of integers:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这些限制，请考虑以下代码片段中使用的方法，用于返回整数列表中的最大整数：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is not necessary to declare methods with a variable number of parameters
    as static. We do this here so that we can call it from the static `main` method.
    In the following code sequence we invoke the method twice:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要将具有可变数量参数的方法声明为静态。我们这样做是为了可以从静态的`main`方法中调用它。在以下代码序列中，我们调用该方法两次：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `largest` method assigns the first parameter, the first element of the `numbers`
    array, to `currentLargest`. It makes the assumption that the largest number is
    the first parameter. If it is not, then it will eventually be replaced. This avoids
    having to assign the smallest possible value to the `currentLargest` variable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`largest`方法将第一个参数，`numbers`数组的第一个元素，分配给`currentLargest`。它假设最大的数字是第一个参数。如果不是，那么它最终会被替换。这避免了将最小可能值分配给`currentLargest`变量。'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The largest and smallest integers are defined in the `Integer` class as `Integer.MAX_VALUE`
    and `Integer.MIN_VALUE` respectively.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最大和最小的整数分别在`Integer`类中定义为`Integer.MAX_VALUE`和`Integer.MIN_VALUE`。
- en: We used a for-each statement to compare each element of the numbers array to
    the largest variable. If the number is larger, then we replace `largest` with
    that number. The for-each statement is detailed in the *The for-each statement*
    section of [Chapter 5](ch05.html "Chapter 5. Looping Constructs"), *Looping Constructs*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用for-each语句将numbers数组的每个元素与最大变量进行比较。如果数字更大，那么我们用该数字替换`largest`。for-each语句在[第5章](ch05.html
    "第5章。循环结构")的*for-each语句*部分详细说明了循环结构。
- en: 'If we call the method with no arguments, as attempted below:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不带参数调用该方法，如下所示：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The program will execute but a `ArrayIndexOutOfBoundsException` exception will
    be generated. This occurs because we tried to access the first element of the
    array in the method which does not exist because the array is empty. If we had
    not referenced the first element in the method, this problem would not have occurred.
    That is, a method that uses a variable number of arguments can, in most circumstances,
    be called with no arguments.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将执行，但会生成`ArrayIndexOutOfBoundsException`异常。这是因为我们尝试在方法中访问数组的第一个元素，但该数组为空，因此不存在第一个元素。如果在方法中没有引用第一个元素，这个问题就不会发生。也就是说，在大多数情况下，使用可变数量的参数的方法可以不带参数调用。
- en: We could have implemented a version of the `largest` method that handles the
    situation where no arguments are passed. However, when nothing is passed what
    should the return value be? Any value we returned would imply that that number
    is the largest when, in fact, there is not a largest number. The best we can probably
    do is to return an exception reflecting this problem. However, this is effectively
    what the current version does. The exception, `ArrayIndexOutOfBoundsException`,
    is perhaps not as meaningful as a custom exception.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现一个`largest`方法的版本，处理没有传递参数的情况。然而，当没有传递任何内容时，返回值应该是什么？我们返回的任何值都会暗示该数字是最大的，而实际上并没有最大的数字。我们能做的最好可能就是返回一个反映这个问题的异常。然而，这实际上就是当前版本所做的。异常`ArrayIndexOutOfBoundsException`可能不如自定义异常有意义。
- en: 'We can use other parameters in a method possessing a variable number of arguments.
    In the following example we pass a string, and zero or more floats, to a `displayAspects`
    method. The intent of the method is to display information about the element identified
    by the first argument:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在具有可变数量参数的方法中使用其他参数。在下面的示例中，我们将一个字符串和零个或多个浮点数传递给`displayAspects`方法。该方法的目的是显示由第一个参数标识的元素的信息：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following code is an example of how the method might be invoked:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是方法可能被调用的示例：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Variable arguments must be all of the same type and must be the last ones in
    the parameter list.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数必须是相同类型，并且必须是参数列表中的最后一个参数。
- en: Immutable objects
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变对象
- en: Immutable objects are objects whose state cannot be changed. By state, we mean
    the value of its member variables. These types of objects can simplify an application
    and are less error prone. There are several classes in the JDK core that are immutable
    including the `String` class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象是其状态无法更改的对象。所谓状态，是指其成员变量的值。这些类型的对象可以简化应用程序，并且更不容易出错。JDK核心中有几个不可变的类，包括`String`类。
- en: 'To create an immutable object:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建不可变对象：
- en: Make the class final which means that it cannot be extended (covered in the
    *Using the final keyword with classes* section in [Chapter 7](ch07.html "Chapter 7. Inheritance
    and Polymorphism"), *Inheritance and Polymorphism*)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使类变为final，这意味着它不能被扩展（在[第7章](ch07.html "第7章.继承和多态")的*使用final关键字与类*部分中有介绍，*继承和多态*）
- en: Keep the fields of the class private and ideally final
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类的字段保持为私有，最好是final
- en: d. not provide any methods that modify the state of the object, that is do not
    provide setter or similar methods
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: d. 不提供任何修改对象状态的方法，即不提供setter或类似的方法
- en: d. not allow mutable field objects to be changed
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: d. 不允许可变字段对象被更改
- en: 'The following is an example of the declaration of an immutable class representing
    a header for a page:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个表示页面标题的不可变类的声明示例：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that the `getDate` method created a new `Date` object based on the header's
    `date` field. Any `Date` object is mutable, so by returning a copy of the date
    as opposed to a reference to the current date, the user is unable to access and
    otherwise modify the private field. The same approach was used in the three-argument
    constructor.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`getDate`方法创建了一个基于标题的`date`字段的新`Date`对象。任何`Date`对象都是可变的，因此通过返回日期的副本而不是当前日期的引用，用户无法访问和修改私有字段。三参数构造函数也使用了相同的方法。
- en: Constructors
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: Constructors are used to initialize the member variables of a class. When an
    object is created, memory is allocated for the object and the constructor for
    the class is executed. This typically occurs using the `new` keyword.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数用于初始化类的成员变量。当创建对象时，为对象分配内存，并执行类的构造函数。这通常使用`new`关键字来实现。
- en: Initialization of an object's instance variables is important. One of the developer's
    responsibilities is making sure that the state of an object is always valid. To
    assist in this process, constructors are executed whenever an object is created.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化对象的实例变量是重要的。开发人员的责任之一是确保对象的状态始终有效。为了协助这一过程，构造函数在创建对象时执行。
- en: An alternate approach, which is not used by Java, is to use an initialization
    method that the programmer should call after an object is created. However, the
    use of such an initialization method is not a foolproof technique. The programmer
    may not be aware that the method exists, or may forget to call the method. To
    avoid these types of problems, a constructor is automatically invoked when an
    object is created.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用初始化方法，程序员应该在创建对象后调用该方法。然而，使用这种初始化方法并不是一种万无一失的技术。程序员可能不知道该方法的存在，或者可能忘记调用该方法。为了避免这类问题，当创建对象时会自动调用构造函数。
- en: 'The important characteristics of constructors include:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的重要特点包括：
- en: Constructors have the same name as the class
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数与类名相同
- en: Constructor overloading is permitted
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数重载是允许的
- en: Constructors are not methods
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数不是方法
- en: Constructors do not have a return type, not even void
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数没有返回类型，甚至没有void
- en: 'The following code snippet illustrates how constructors are defined. In this
    example, three overloaded constructors are defined. For the moment, we have left
    out their bodies. The intent of these constructors is to initialize the three
    instance variables that make up the class:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段说明了如何定义构造函数。在这个例子中，定义了三个重载的构造函数。目前，我们省略了它们的主体。这些构造函数的目的是初始化组成类的三个实例变量：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Default constructors
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认构造函数
- en: 'A default constructor is normally present for a class. If a class does not
    have any constructors explicitly declared, it automatically has a default constructor.
    A default constructor is a constructor that has no arguments. This is illustrated
    in the following code snippet, for the `Employee` class where no constructors
    are defined:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常类都会有默认构造函数。如果一个类没有显式声明任何构造函数，它会自动拥有一个默认构造函数。默认构造函数是一个没有参数的构造函数。下面的代码片段演示了`Employee`类中没有定义构造函数的情况：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The default constructor will essentially initialize its instance variables
    to 0 as explained in the *Initializing identifiers* section in [Chapter 2](ch02.html
    "Chapter 2. Java Data Types and Their Usage"), *Java Data Types and Their Usage*.
    The values assigned to member variables are found in the following table which
    is duplicated from [Chapter 2](ch02.html "Chapter 2. Java Data Types and Their
    Usage"), *Java Data Types and Their Usage*, for your convenience:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数本质上会将其实例变量初始化为0，就像[第2章](ch02.html "第2章. Java数据类型及其使用")中的*初始化标识符*部分所解释的那样，*Java数据类型及其使用*。分配给成员变量的值在下表中找到，该表从[第2章](ch02.html
    "第2章. Java数据类型及其使用")中的*Java数据类型及其使用*部分复制过来，以方便您查阅：
- en: '| Data Type | Default Value (for fields) |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 默认值（对于字段） |'
- en: '| --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| boolean | false |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | false |'
- en: '| byte | 0 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 0 |'
- en: '| char | ''\u0000'' |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | ''\u0000'' |'
- en: '| short | 0 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 短整型 | 0 |'
- en: '| int | 0 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 整型 | 0 |'
- en: '| long | 0L |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 长整型 | 0L |'
- en: '| float | 0.0f |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数 | 0.0f |'
- en: '| double | 0.0d |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 双精度 | 0.0d |'
- en: '| String (or any object) | null |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 字符串（或任何对象） | null |'
- en: 'However, we can also add an explicit default constructor, as shown in the following
    code snippet. The default constructor is a constructor that has no arguments.
    As we can see, we are free to initialize the fields of the class to whatever values
    we choose. For those fields that we do not initialize, the JVM will initialize
    them to zeroes as detailed above:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以添加一个显式的默认构造函数，如下面的代码片段所示。默认构造函数是一个没有参数的构造函数。正如我们所看到的，我们可以自由地将类的字段初始化为我们选择的任何值。对于我们没有初始化的字段，JVM将会像上面详细说明的那样将它们初始化为零：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note the use of the `this` keyword. In this context it is used to unambiguously
    specify that the variables following the period are class member variables, and
    not some other local variables. Here, there are no other variables that might
    cause confusion. The `this` keyword was detailed in the *Using the this keyword*
    section. It is a common practice to use the `this` keyword with member variables.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`this`关键字。在这个上下文中，它用于明确指定紧随其后的变量是类成员变量，而不是其他局部变量。在这里，没有其他可能引起混淆的变量。`this`关键字在*使用this关键字*部分有详细介绍。在成员变量中使用`this`关键字是一种常见做法。
- en: 'If the programmer adds a constructor to the class, then the class will no longer
    have a default constructor added automatically. The programmer must explicitly
    add a default constructor for the class to have one. In the following declaration
    of the `Employee` class, the default constructor has been left out:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序员向类添加了构造函数，那么该类将不再自动添加默认构造函数。程序员必须显式为类添加一个默认构造函数。在下面的`Employee`类的声明中，省略了默认构造函数：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we try to create an object using the default constructor, as shown in the
    following code snippet, then we will get a syntax error:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用默认构造函数创建对象，如下面的代码片段所示，那么我们将会得到一个语法错误：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The error message that is generated is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的错误消息如下：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As a general rule, always add a default constructor to a class. This is particularly
    important when the class is a base class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则是，总是为类添加一个默认构造函数。当类是一个基类时，这一点尤为重要。
- en: Overloading the constructors
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数的重载
- en: Constructors can be overloaded. By overloading the constructors, we provide
    the users of the class with more flexibility in how an object can be created.
    This can simplify the development process.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数可以被重载。通过重载构造函数，我们为类的用户提供了更多创建对象的灵活性。这可以简化开发过程。
- en: 'Overloaded constructors have the same name but different signatures. The definition
    of a signature was provided in the *Signature* section, discussed earlier. In
    the following version of the `Employee` class we provide four constructors. Notice
    how each constructor assigns default values for those member variables not passed
    with the constructor:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 重载的构造函数具有相同的名称但不同的签名。签名的定义在之前讨论的*签名*部分中提供。在`Employee`类的以下版本中，我们提供了四个构造函数。请注意，每个构造函数为那些没有通过构造函数传递的成员变量分配了默认值：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This example duplicates work between the constructors. An alternate approach,
    shown as follows, uses the `this` keyword to reduce this duplication of effort
    and simplify the overall process:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在构造函数之间重复了工作。另一种方法如下所示，使用`this`关键字来减少这种重复的工作并简化整个过程：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this case, the `this` keyword is used at the beginning of a constructor with
    an argument list. The effect is to call the same class' constructor that matches
    the signature used. In this example, each of the first three constructors calls
    the last constructor. This is called **constructor chaining** . All of the work
    is performed in the last constructor reducing the amount of repeated work being
    performed and chances for errors, especially when new fields are added.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`this`关键字用于构造函数的参数列表开头。其效果是调用与使用的签名匹配的同一类构造函数。在这个例子中，前三个构造函数中的每一个都调用最后一个构造函数。这被称为**构造函数链**。所有的工作都是在最后一个构造函数中完成的，减少了重复工作的量和出错的机会，特别是当添加新字段时。
- en: This can be even more productive if the field variables are checked within a
    constructor prior to their assignment. For example, if we need to verify that
    the name meets a specific set of naming criteria, it only needs to be performed
    in one location instead of each constructor that is passed a name.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在构造函数中对字段变量进行赋值之前进行检查，这样会更加高效。例如，如果我们需要验证名称是否符合特定的命名标准，只需要在一个位置执行，而不是在每个传递名称的构造函数中执行。
- en: Private constructors
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有构造函数
- en: 'A constructor can be declared as private which serves to hide it from the user.
    This may be done to:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将构造函数声明为私有，以便将其隐藏。这样做可能是为了：
- en: Restrict access to some, but not all, of the class' constructors
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制对类的某些构造函数的访问，而不是全部
- en: Hide all of the constructors from a user
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏所有构造函数
- en: In some situations, we may desire to make constructors private or protected
    (See [Chapter 7](ch07.html "Chapter 7. Inheritance and Polymorphism"), *Inheritance
    and Polymorphism*, for a discussion of the `protected` keyword) to limit access
    to certain initialization sequences. For example, a private constructor may be
    used to initialize fields of a class in a less rigorous manner. As we are invoking
    the constructor from other constructors, we may be more confident of the values
    being assigned and do not feel that extensive checking of its parameters is needed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望将构造函数设置为私有或受保护（参见[第7章](ch07.html "第7章. 继承和多态")中的*继承和多态*，讨论`protected`关键字）以限制对某些初始化序列的访问。例如，私有构造函数可以用于以较不严格的方式初始化类的字段。由于我们从其他构造函数中调用构造函数，我们可能更加确信被赋值的值，并且不觉得需要对其参数进行广泛的检查。
- en: It is not uncommon to find classes where all of the constructors are declared
    as private. This restricts the creation of objects by a user to the public methods
    of the class. The `java.util.Calendar` class is an example of such a class. The
    only way to obtain an instance of this class is to use its static `getInstance`
    method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望将所有构造函数声明为私有。这将限制用户通过类的公共方法创建对象。`java.util.Calendar`类就是这样一个例子。获取此类的实例的唯一方法是使用其静态的`getInstance`方法。
- en: The use of private constructors is used to control the number of instances of
    the class that can be created by an application. The singleton design pattern
    dictates that only one instance of a class is ever created. This design pattern
    can be supported by making all of its constructors private and providing a public
    `getInstance` method that creates a single instance of the class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 私有构造函数的使用用于控制应用程序可以创建的类实例的数量。单例设计模式规定一个类只能创建一个实例。这种设计模式可以通过将所有构造函数设为私有，并提供一个公共的`getInstance`方法来创建类的单个实例来支持。
- en: 'The following illustrates this approach for the `Employee` class. The constructor
    is made private and the `getInstance` method insures that only a single object
    is ever created:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Employee`类的这种方法的示例。构造函数被设置为私有，`getInstance`方法确保只创建一个对象：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first time the `getInstance` method is called the `instance` variable is
    null, which results in a new `Employee` object being created. In subsequent calls
    to the `getInstance` method, `instance` will not be null and a new `Employee`
    object is not created. The current reference to the single object is returned.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`getInstance`方法时，`instance`变量为null，这导致创建一个新的`Employee`对象。在对`getInstance`方法的后续调用中，`instance`将不为null，不会创建新的`Employee`对象。而是返回对单个对象的当前引用。
- en: Constructor issues
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数问题
- en: 'If a "constructor" has a return type, it is actually a method that happens
    to have the same name as the class. This is true even if the return type is `void`,
    as illustrated in the following code snippet:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个“构造函数”有返回类型，实际上它是一个方法，恰好与类名相同。即使返回类型是`void`，也是如此，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can create a new instance of the `Employee` class and then apply the `Employee`
    method against this object, as shown in the following code snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建`Employee`类的新实例，然后对该对象应用`Employee`方法，如下面的代码片段所示：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: While this is legal, it is not good style and can be confusing. In addition,
    as we saw in the *Java naming conventions* section in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Java"), *Getting Started with Java*, the naming conventions for methods
    suggest that the initial word of a method's name should begin with a lowercase
    letter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是合法的，但不是良好的风格，可能会令人困惑。此外，正如我们在[第1章](ch01.html "第1章. 开始使用Java")中看到的*Java命名约定*部分，方法的命名约定建议方法名的初始单词应以小写字母开头。
- en: Java initialization sequence
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java初始化序列
- en: 'Constructors are concerned with the initialization of the fields of an object.
    However, there are two other approaches that can be used to complement the use
    of constructors. The first is to use instance variable initializers. Using the
    `Employee` class we can initialize the age to 21, shown as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数涉及对象字段的初始化。然而，还有两种方法可以用来补充构造函数的使用。第一种是使用实例变量初始化器。使用`Employee`类，我们可以将年龄初始化为21，如下所示：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If we initialize an instance variable in this manner, we do not have to initialize
    it in a constructor.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以这种方式初始化实例变量，就不必在构造函数中初始化它。
- en: 'The second approach is to use an initialization block. This type of block is
    executed before the constructor is executed. The following code snippet illustrates
    this approach:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用初始化块。这种类型的块在构造函数执行之前执行。下面的代码片段说明了这种方法：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Initialization blocks are useful when more complex initialization sequences
    are needed which cannot be supported with the simpler instance variable initializers.
    This initialization can also be performed in a constructor.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化块在需要更复杂的初始化序列时非常有用，这是无法通过更简单的实例变量初始化器支持的。这种初始化也可以在构造函数中执行。
- en: 'Thus, there are several ways of initializing member variables. If we use one
    or more of these techniques to initialize the same variable, then we may wonder
    in what order they are performed. The actual initialization sequence is a bit
    more complex than described here. However, the general order is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有几种初始化成员变量的方法。如果我们使用其中一种或多种技术来初始化相同的变量，那么我们可能会想知道它们的执行顺序。实际的初始化顺序比这里描述的要复杂一些。但是，一般的顺序如下：
- en: The zeroing of fields performed when the object is instantiated
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实例化对象时执行字段的清零
- en: The initialization of final and static variables
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: final和静态变量的初始化
- en: The assignment of instance variables initializers
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配实例变量初始化器
- en: The execution of initialization blocks
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化块的执行
- en: The code within a constructor
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数中的代码
- en: More detail about the initialization sequence can be found in the Java Language
    Specification ([http://docs.oracle.com/javase/specs/](http://docs.oracle.com/javase/specs/)).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有关初始化顺序的更多详细信息可以在Java语言规范([http://docs.oracle.com/javase/specs/](http://docs.oracle.com/javase/specs/))中找到。
- en: Methods
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: A **method** is a group of statements used to complete a specific task. A method
    has a return value, a name, a set of parameters, and a body. Parameters are passed
    to a method and are used to perform an action. If a value is to be returned from
    a method, the return statement is used. A method may have zero or more return
    statements. A method that returns void may use a return statement but the statement
    does not have an argument.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**是一组语句，用于完成特定的任务。方法具有返回值、名称、一组参数和一个主体。参数被传递给方法，并用于执行操作。如果要从方法返回一个值，则使用返回语句。一个方法可能有零个或多个返回语句。返回`void`的方法可能使用返回语句，但该语句没有参数。'
- en: Defining methods
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义方法
- en: Methods are defined as part of the class definition and normally follow the
    declaration of the instance variables. The method declaration specifies a return
    type. The return type `void` means that the method does not return a value.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是作为类定义的一部分来定义的，通常在实例变量的声明之后。方法声明指定了返回类型。返回类型`void`表示该方法不返回值。
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Java naming convention for methods specifies that the first word is not
    capitalized but subsequent words are capitalized. Method names should be verbs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Java方法的命名约定指定第一个单词不大写，但后续的单词大写。方法名应该是动词。
- en: 'In the following example, the method returns `boolean` and is passed two integer
    parameters:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，该方法返回`boolean`，并传递了两个整数参数：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'All methods within the same program must have unique signatures. Signatures
    are discussed in the *Signature* section, discussed earlier. Note that the return
    type of the method is not part of a signature. As an example, consider the declarations
    in the following code snippet:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 同一程序中的所有方法必须具有唯一的签名。签名在前面的*签名*部分中有讨论。请注意，方法的返回类型不是签名的一部分。例如，考虑以下代码片段中的声明：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The signatures for both of these methods are identical. The return type is
    not used. If we attempt to declare both methods in the `Employee` class we will
    get the following syntax error message:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的签名是相同的。返回类型不被使用。如果我们尝试在`Employee`类中声明这两种方法，将会得到以下语法错误消息：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Calling methods
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用方法
- en: 'The syntax used for invoking methods appears similar to using instance variables.
    Instance methods will always execute against an object. The normal syntax uses
    the name of the object followed by a period and then the name of the method and
    any parameters that are needed. In the following example, the `getAgeInMonths`
    method is invoked against the `employee` reference variable:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 调用方法的语法看起来类似于使用实例变量。实例方法将始终针对一个对象执行。正常的语法使用对象的名称，后跟一个句点，然后是方法的名称和任何需要的参数。在以下示例中，`getAgeInMonths`方法针对`employee`引用变量被调用：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Static methods are invoked using either the class name or an object. Consider
    the following declarations for a static variable called `entityCode`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法可以使用类名或对象来调用。考虑以下静态变量`entityCode`的声明：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Both the method calls in the following code snippet will invoke the same method:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段中的两个方法调用都将调用相同的方法：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'However, it is not good practice to use a reference variable to invoke a static
    method. Instead, always use the classname. Attempts to use an object will result
    in the following syntax warning:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用引用变量调用静态方法并不是一个好的做法。而应该始终使用类名。尝试使用对象将导致以下语法警告：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Static methods are detailed in the *Instance and static class members* section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法在*实例和静态类成员*部分有详细说明。
- en: 'A parameter list may be empty if no parameters are passed to a method. In the
    following simplified method, the age of an employee is returned in months. No
    parameters are passed to the method and an integer is returned. The method is
    simplified as the actual value would need to consider the current date and the
    date of birth for the employee:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不向方法传递参数，则参数列表可以为空。在以下简化的方法中，返回员工的年龄（以月为单位）。没有向方法传递参数，并返回一个整数。该方法被简化了，因为实际的值需要考虑员工的出生日期和当前日期：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Overloading methods
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法的重载
- en: Multiple methods with the same name are permitted in Java. This provides a convenient
    technique for implementing methods that differ in argument types. Overloaded methods
    all have the same method name. The methods are differentiated in that each overloaded
    method must have a unique signature. Signatures are discussed in the earlier *Signature*
    section. Recall that the return type of the method is not part of a signature.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Java允许具有相同名称的多个方法。这为实现参数类型不同的方法提供了一种便捷的技术。重载的方法都具有相同的方法名称。这些方法的区别在于每个重载的方法必须具有唯一的签名。签名在前面的*签名*部分中有讨论。请记住，方法的返回类型不是签名的一部分。
- en: 'The following code snippet illustrates the overloading of a method:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段说明了方法的重载：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Care must be taken when calling an overloaded method, as the compiler may be
    unable to determine which method to use. Consider the following declarations of
    the `max` method:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用重载方法时必须小心，因为编译器可能无法确定使用哪个方法。考虑以下 `max` 方法的声明：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following code sequence illustrates situations that will give the compiler
    problems:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码序列说明了会给编译器带来问题的情况：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The second and fourth assignment statements will match the method call with
    the three long argument method. This is expected for the second one. For the fourth
    assignment, only one of the arguments is long but it uses the three long argument
    method anyway. The problem with these assignments is that the method returns `long`
    and not `int`. It is unable to assign a float value to a `int` variable without
    a loss of precision, as indicated by the following syntax error message:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第四个赋值语句将与三个长参数方法调用匹配。这对于第二个是预期的。对于第四个赋值，只有一个参数是长整型，但它仍然使用了三个长参数方法。这些赋值的问题在于该方法返回
    `long` 而不是 `int`。它无法将浮点值分配给 `int` 变量而不会丢失精度，如以下语法错误消息所示：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The last assignment cannot find an acceptable overloaded method. The following
    syntax error message results:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个赋值找不到可接受的重载方法。以下语法错误消息结果如下：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Closely related to overloading is the process of overriding a method. With overriding,
    the signatures of two methods are identical but they reside in different classes.
    This topic is covered in the *Overriding Methods* section in [Chapter 7](ch07.html
    "Chapter 7. Inheritance and Polymorphism"), *Inheritance and Polymorphism*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与重载密切相关的是重写方法的过程。通过重写，两个方法的签名是相同的，但它们位于不同的类中。这个主题在[第7章](ch07.html "第7章.继承和多态")的*继承和多态*部分中有所涉及。
- en: Accessors/mutators
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问器/修改器
- en: An accessor method is one that reads or accesses a variable of a class. A mutator
    method is one that modifies a variable of a class. These methods are usually public
    and the variables are normally declared as private. This is an important part
    of data encapsulation. Private data is hidden from the user but access is provided
    through methods.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器方法是读取或访问类的变量的方法。修改器方法是修改类的变量的方法。这些方法通常是公共的，变量通常声明为私有的。这是数据封装的重要部分。私有数据对用户隐藏，但通过方法提供访问。
- en: There is a consistent naming convention that you should use with accessor and
    mutator methods. This convention uses the private member variable name as a base
    and prefixes the base with either a get or set prefix. The get method returns
    the value of the variable while the set method takes an argument that is assigned
    to the private variable. In both methods, the member variable name is capitalized.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器和修改器方法应使用一致的命名约定。该约定使用私有成员变量名称作为基础，并在基础前加上 get 或 set 前缀。get 方法返回变量的值，而 set
    方法接受一个参数，该参数被分配给私有变量。在这两种方法中，成员变量名称都是大写的。
- en: 'This approach is illustrated for the private `age` field of the `Employee`
    class:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法用于 `Employee` 类的私有 `age` 字段：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Notice that the return type of `getAge` is `int` and is also the parameter type
    of the `setAge` method. This is the standard format of accessors and mutators.
    Accessor methods are commonly referred to as getters and mutator methods are referred
    to as setters.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `getAge` 的返回类型是 `int`，也是 `setAge` 方法的参数类型。这是访问器和修改器的标准格式。访问器方法通常被称为 getters，修改器方法被称为
    setters。
- en: Private data is frequently encapsulated by making it private and providing public
    methods to access it. Fields that have private or non-existent setters are referred
    to as **read-only fields** . Fields that have private or non-existent getters
    are referred to as **write-only fields** , but are not as common. The chief reason
    for getters and setters is to restrict access and provide additional processing
    of the fields.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 私有数据通常通过将其设置为私有并提供公共方法来访问而进行封装。具有私有或不存在设置器的字段被称为**只读字段**。具有私有或不存在获取器的字段被称为**只写字段**，但不太常见。获取器和设置器的主要原因是限制访问并对字段进行额外处理。
- en: For example, we might have a `getWidth` method that returns the width of a `Rectangle`
    class. However, the value returned may be dependent on the unit of measure being
    used. It may return a value depending on whether another unit of measurement field
    is set to inches, centimeters or pixels. In a security conscious environment,
    we might want to restrict what can be read or written dependent upon the user
    or perhaps the time of day.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能有一个 `getWidth` 方法，返回 `Rectangle` 类的宽度。但是，返回的值可能取决于所使用的测量单位。它可能根据另一个测量单位字段设置为英寸、厘米或像素而返回一个值。在一个安全意识强的环境中，我们可能希望限制可以根据用户或者时间来读取或写入的内容。
- en: Instance and static class members
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例和静态类成员
- en: 'There are two types of variables or methods:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的变量或方法：
- en: Instance
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例
- en: Static
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态
- en: An instance variable is declared as a part of the class and is associated with
    an object. A static variable is declared in the same way, except that it is preceded
    by the `static` keyword. When an object is created, it has its own set of instance
    variables. However, all objects share a single copy of static variables.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量声明为类的一部分，并与对象关联。静态变量以相同的方式声明，只是在前面加上 `static` 关键字。当创建对象时，它有自己的一组实例变量。但是，所有对象共享静态变量的单个副本。
- en: Sometimes, it makes sense to have a single variable that can be shared and accessed
    by all instances of a class. When used with a variable, it is called a **class
    variable** and is local to the class itself.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有一个可以被所有类实例共享和访问的单个变量是有意义的。当与变量一起使用时，它被称为**类变量**，并且仅限于类本身。
- en: 'Consider the following `Employee` class:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 `Employee` 类：
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Each `Employee` object will have its own copies of the `name`, `zip`, and `age`
    variables. All `Employee` objects may share the same `minimumAge` variable. The
    use of a single copy of a variable insures that all of the class can access and
    use the same value, and space is conserved.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 每个“Employee”对象都将有自己的“name”、“zip”和“age”变量的副本。所有“Employee”对象可能共享相同的“minimumAge”变量。使用单个变量的副本确保了类的所有部分都可以访问和使用相同的值，并且节省了空间。
- en: 'Consider the following code sequence:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码序列：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following diagram illustrates the allocation of the two objects in the
    heap. Each object has its own set of instance variables. The single static variable
    is shown allocated above the heap in its own special area of memory:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了堆中两个对象的分配情况。每个对象都有自己的一组实例变量。单个静态变量显示在堆的上方，分配在自己的特殊内存区域中：
- en: '![Instance and static class members](img/7324_06_04.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![实例和静态类成员](img/7324_06_04.jpg)'
- en: 'There is only one copy of each method for a class regardless of whether the
    method is an instance method or a static method. A static method is declared the
    same way as an instance method, except that the `static` keyword precedes the
    declaration of the method. The static `setMinimumAge` method, in the following
    code snippet, illustrates the declaration of a static method:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 无论方法是实例方法还是静态方法，对于一个类来说，每个方法只有一个副本。静态方法的声明方式与实例方法相同，只是在方法的声明之前加上“static”关键字。以下代码片段中的静态“setMinimumAge”方法说明了静态方法的声明：
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'All instance methods must execute against an object. It is not possible to
    execute against the name of a class as it is possible with a static method. Instance
    methods are designed to access or modify instance variables. As such, it needs
    to execute against an object that possesses instance variables. If we attempt
    to execute an instance method against a classname, shown as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 所有实例方法必须针对一个对象执行。不可能像静态方法那样针对类名执行。实例方法旨在访问或修改实例变量。因此，它需要针对具有实例变量的对象执行。如果我们尝试针对类名执行实例方法，如下所示：
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It will result in the following syntax error message:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下语法错误消息：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: A static method can execute against either an object or the class name. Static
    methods may not access instance variables or call instance methods. As a static
    method can execute against a classname this means that it can execute even though
    there may not be any objects in existence. If there are no objects, then there
    cannot be any instance variables. Thus, static methods cannot access instance
    variables.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法可以针对对象或类名执行。静态方法可能无法访问实例变量或调用实例方法。由于静态方法可以针对类名执行，这意味着即使可能不存在任何对象，它也可以执行。如果没有对象，那么就不可能有实例变量。因此，静态方法无法访问实例变量。
- en: A static method may not call an instance method. If it were able to access an
    instance method, then it would indirectly be able to access an instance variable.
    As there may not be any objects in existence, the calling of instance methods
    by a static method is not allowed.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法可能不会调用实例方法。如果它能够访问实例方法，那么它间接地就能够访问实例变量。由于可能不存在任何对象，因此静态方法不允许调用实例方法。
- en: An instance method may access a static variable or call a static method. Static
    variables are always present. Thus, there is no reason why an instance method
    should not be able to access static variables and methods.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法可以访问静态变量或调用静态方法。静态变量始终存在。因此，实例方法应该能够访问静态变量和方法是毫无理由的。
- en: 'The following table summarizes the relationship between static/instance variables
    and methods:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了静态/实例变量和方法之间的关系：
- en: '|   | Variable |   | Method |   |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '|   | 变量 |   | 方法 |   |'
- en: '|   | Instance | Static | Instance | Static |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '|   | 实例 | 静态 | 实例 | 静态 |'
- en: '| Instance method | ![Instance and static class members](img/7324EN_06_05.jpg)
    | ![Instance and static class members](img/7324EN_06_05.jpg) | ![Instance and
    static class members](img/7324EN_06_05.jpg) | ![Instance and static class members](img/7324EN_06_05.jpg)
    |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 实例方法 | ![实例和静态类成员](img/7324EN_06_05.jpg) | ![实例和静态类成员](img/7324EN_06_05.jpg)
    | ![实例和静态类成员](img/7324EN_06_05.jpg) | ![实例和静态类成员](img/7324EN_06_05.jpg) |'
- en: '| Static method | ![Instance and static class members](img/7324EN_06_06.jpg)
    | ![Instance and static class members](img/7324EN_06_05.jpg) | ![Instance and
    static class members](img/7324EN_06_06.jpg) | ![Instance and static class members](img/7324EN_06_05.jpg)
    |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 静态方法 | ![实例和静态类成员](img/7324EN_06_06.jpg) | ![实例和静态类成员](img/7324EN_06_05.jpg)
    | ![实例和静态类成员](img/7324EN_06_06.jpg) | ![实例和静态类成员](img/7324EN_06_05.jpg) |'
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we examined many of the important aspects of a class. This included
    how memory is managed when an instance of a class is created, the initialization
    process, and how methods can be invoked to use a class.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考察了类的许多重要方面。这包括创建类的实例时如何管理内存，初始化过程以及如何调用方法来使用类。
- en: There are several issues relevant to both constructors and methods. These were
    discussed before the details of constructors and methods were detailed and included
    the use of the `this` keyword, passing parameters, and signatures. Constructors
    and various initialization techniques were illustrated including the order that
    these initializations take place. The declaration of methods was also discussed
    including how to overload methods.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和方法都涉及到几个问题。在详细讨论构造函数和方法的细节之前，我们讨论了使用“this”关键字、传递参数和签名。我们还举例说明了构造函数和各种初始化技术，包括这些初始化发生的顺序。还讨论了方法的声明，包括如何重载方法。
- en: We also examined the difference between instance and static, variables, and
    methods. Throughout the chapter we illustrated how memory is allocated.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还考察了实例和静态变量、方法之间的区别。在整个章节中，我们阐明了内存的分配方式。
- en: Now that we have learned about the basics of classes we are ready to address
    the topics of inheritance and polymorphism, as discussed in the next chapter.
    In that chapter we will expand upon how memory is allocated, the initialization
    sequence, and introduce new topics, such as overriding methods.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了类的基础知识，我们准备讨论继承和多态的主题，如下一章所讨论的那样。在那一章中，我们将扩展内存分配、初始化顺序，并介绍新的主题，比如重写方法。
- en: Certification objectives covered
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涵盖的认证目标
- en: 'The certification objectives covered in this chapter include:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的认证目标包括：
- en: Creating methods with arguments and return values
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有参数和返回值的方法
- en: Applying the `static` keyword to methods and fields
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`static`关键字应用于方法和字段
- en: Creating an overloaded method
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建重载方法
- en: Differentiating between default and user-defined constructors
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分默认构造函数和用户定义的构造函数
- en: Applying access modifiers
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用访问修饰符
- en: Applying encapsulation principles to a class
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将封装原则应用于类
- en: Determining the effect upon object references and primitive values when they
    are passed into methods that change the values
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定当对象引用和原始值传递到改变值的方法中时的影响
- en: Test your knowledge
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: Which of the following declares a method that takes a float and an integer returns
    an array of integers?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个声明了一个接受浮点数和整数并返回整数数组的方法？
- en: a. `public int[] someMethod(int i, float f) { return new` `int[5];}`
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: a. `public int[] someMethod(int i, float f) { return new` `int[5];}`
- en: b. `public int[] someMethod(int i, float f) { return new int[];}`
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: b. `public int[] someMethod(int i, float f) { return new int[];}`
- en: c. `public int[] someMethod(int i, float f) { return new int[i];}`
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: c. `public int[] someMethod(int i, float f) { return new int[i];}`
- en: d. `public int []someMethod(int i, float f) { return new int[5];}`
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: d. `public int []someMethod(int i, float f) { return new int[5];}`
- en: 'What happens if you try to compile and run the following code:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尝试编译和运行以下代码会发生什么？
- en: '[PRE57]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: a. Syntax error – `main` is not declared correctly.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: a. 语法错误 - `main`没有正确声明。
- en: b. Syntax error – the variable parameters cannot be used as it is in the `println`
    method.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: b. 语法错误 - 变量参数不能像在`println`方法中那样使用。
- en: c. Syntax error – `someMethod` needs to be declared as static.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: c. 语法错误 - `someMethod`需要声明为静态。
- en: d. The program will execute without errors.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: d. 程序将无错误地执行。
- en: Which of the following statements about overloaded methods are true?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关于重载方法的陈述哪些是真的？
- en: a. Static methods cannot be overloaded.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: a. 静态方法不能被重载。
- en: b. The return value is not considered when overloading a method.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: b. 在重载方法时，不考虑返回值。
- en: c. Private methods cannot be overloaded.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: c. 私有方法不能被重载。
- en: d. An overloaded method cannot throw exceptions.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: d. 重载的方法不能抛出异常。
- en: Given the following code, which of the following statements are true?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定以下代码，以下哪些陈述是真的？
- en: '[PRE58]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: a. A syntax error will occur because void cannot be used with a constructor.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: a. 由于void不能与构造函数一起使用，将会发生语法错误。
- en: b. A syntax error will occur because the first two constructors are not unique.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: b. 由于前两个构造函数不是唯一的，将会发生语法错误。
- en: c. The class does not have a default constructor.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: c. 该类没有默认构造函数。
- en: d. No syntax errors will be generated.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: d. 不会生成语法错误。
- en: Which of the following keywords cannot be used when declaring a class?
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在声明类时，以下关键字中哪个不能使用？
- en: a. `public`
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: a. `public`
- en: b. `private`
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: b. `private`
- en: c. `protected`
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: c. `protected`
- en: d. `package`
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: d. `package`
- en: Assuming that the following classes are in the same package, which statements
    are true?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设以下类在同一个包中，哪些陈述是真的？
- en: '[PRE59]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: a. `sc.method1()` will generate a syntax error.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: a. `sc.method1()`将生成语法错误。
- en: b. `sc.method2()` will generate a syntax error.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: b. `sc.method2()`将生成语法错误。
- en: c. `sc.method3()` will generate a syntax error.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: c. `sc.method3()`将生成语法错误。
- en: d. `sc.method4()` will generate a syntax error.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: d. `sc.method4()`将生成语法错误。
- en: e. No syntax errors will be generated.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: e. 不会生成语法错误。
- en: What is the output of the following code?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE60]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: a. `5 5 string 2 string 1`
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: a. `5 5 string 2 string 1`
- en: b. `6 6 string 2 string 2`
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: b. `6 6 string 2 string 2`
- en: c. `5 5 string 2 string 2`
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: c. `5 5 string 2 string 2`
- en: d. `6 5 string 2 string 1`
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: d. `6 5 string 2 string 1`
