["```cs\nprivate static long BitArrayTest(int max) \n{ \n    Stopwatch stopwatch = Stopwatch.StartNew(); \n    var bitarray = new BitArray(max); \n    for (int index = 0; index < bitarray.Length; index++) \n    { \n        bitarray[index] = !bitarray[index]; \n        WriteLine($\"'bitarray[{index}]' = {bitarray[index]}\"); \n    } \n    stopwatch.Stop(); \n    return stopwatch.ElapsedMilliseconds; \n} \nBitArray performance by applying a very simple test, where we run a for loop up to the maximum count of int MaxValue.\nbool[] to make this test simpler; we just initiated a for loop up to the maximum value of int.MaxValue:\n```", "```cs\nprivate static long BoolArrayTest(int max) \n{ \n    Stopwatch stopwatch = Stopwatch.StartNew(); \n    var boolArray = new bool[max]; \n    for (int index = 0; index < boolArray.Length; index++) \n    { \n        boolArray[index] = !boolArray[index]; \n        WriteLine($\"'boolArray[{index}]' = {boolArray[index]}\"); \n    } \n    stopwatch.Stop(); \n    return stopwatch.ElapsedMilliseconds; \n} \nBitArrayTest and BoolArrayTest methods:\n```", "```cs\nprivate static void BitArrayBoolArrayPerformance() \n{ \n    //This is a simple test \n    //Not testing bitwiseshift  etc. \n    WriteLine(\"BitArray vs. Bool Array performance test.\\n\"); \n    WriteLine($\"Total elements of bit array: {int.MaxValue}\"); \n    PressAnyKey(); \n    WriteLine(\"Starting BitArray Test:\"); \n    var bitArrayTestResult = BitArrayTest(int.MaxValue); \n    WriteLine(\"Ending BitArray Test:\"); \n    WriteLine($\"Total timeElapsed: {bitArrayTestResult}\"); \n\n    WriteLine(\"\\nStarting BoolArray Test:\"); \n    WriteLine($\"Total elements of bit array: {int.MaxValue}\"); \n    PressAnyKey(); \n    var boolArrayTestResult = BoolArrayTest(int.MaxValue); \n    WriteLine(\"Ending BitArray Test:\"); \n    WriteLine($\"Total timeElapsed: {boolArrayTestResult}\"); \n} \n```", "```cs\n    IList<Person> persons = new List<Person>()\n\npersons variable of a generic type, List. Here, we have Person as a strong type. The following is the complete code snippet that populates this strongly typed list:\n```", "```cs\nprivate static IEnumerable<Person> CreatePersonList() \n        { \n            IList<Person> persons = new List<Person> \n            { \n                new Person \n                { \n                    FirstName = \"Denim\", \n                    LastName = \"Pinto\", \n                    Age = 31 \n                }, \n                new Person \n                { \n                    FirstName = \"Vikas\", \n                    LastName = \"Tiwari\", \n                    Age = 25 \n                }, \n                new Person \n                { \n                    FirstName = \"Shivprasad\", \n                    LastName = \"Koirala\", \n                    Age = 40 \n                }, \n                new Person \n                { \n                    FirstName = \"Gaurav\", \n                    LastName = \"Aroraa\", \n                    Age = 43 \n                } \n            }; \n\n            return persons; \n        } \nPerson type and its collection items. These items can be iterated as mentioned in the following code snippet:\n```", "```cs\nprivate static void Main(string[] args) \n        { \n            WriteLine(\"Person list:\"); \n            foreach (var person in Person.GetPersonList()) \n            { \n                WriteLine($\"Name:{person.FirstName} {person.LastName}\"); \n                WriteLine($\"Age:{person.Age}\"); \n            } \n            ReadLine(); \n        } \n```", "```cs\nprivate IEnumerable<T> CreateGenericList<T>() \n{ \n    IList<T> persons = new List<T>(); \n\n    //other stuffs \n\n    return persons; \n} \nT could be Person or any related type.\n```", "```cs\nArrayList authorArrayList = new ArrayList {\"Gaurav Aroraa\", \"43\"}; \nforeach (string author in authorArrayList) \n{ \n    WriteLine($\"Name:{author}\"); \n} \n```", "```cs\nArrayList editorArrayList = new ArrayList { \"Vikas Tiwari\", 25 }; \nforeach (int editor in editorArrayList) \n{ \n    WriteLine($\"Name:{editor}\"); \n} \n```", "```cs\nList<string> authorName = new List<string> {\"Gaurav Aroraa\"}; \n```", "```cs\nList<string> authorName = new List<string>(); \nauthorName.Add(\"Gaurav Aroraa\"); \nauthorName.Add(43); \n```", "```cs\nList<Person> persons = new List<Person>(); \n```", "```cs\ninternal class Person \n{ \n    public string FirstName { get; set; } \n    public string LastName { get; set; } \n    public int Age { get; set; } \n} \n```", "```cs\nprivate static void PersonList() \n{ \n    List<Person> persons = new List<Person> \n    { \n        new Person \n        { \n            FirstName = \"Gaurav\", \n            LastName = \"Aroraa\", \n            Age = 43 \n        } \n    }; \n    WriteLine(\"Person list:\"); \n    foreach (var person in persons) \n    { \n        WriteLine($\"Name:{person.FirstName} {person.LastName}\"); \n        WriteLine($\"Age:{person.Age}\"); \n    } \n} \n```", "```cs\npublic class GenericConstraint<T> where T:class \n{ \n    public T ImplementIt(T value) \n    { \n        return value; \n    } \n} \n```", "```cs\nGenericConstraint<string> genericConstraint = new GenericConstraint<string>(); \nPerson person = genericPersonConstraint.ImplementIt(new Person()); \n```", "```cs\nGenericConstraint<int> genericConstraint = new GenericConstraint<int>(); \n```", "```cs\npublic class ValueTypeConstraint<T> where T : struct \n{ \n    public T ImplementIt(T value) \n    { \n        return value; \n    } \n} \n```", "```cs\nprivate static void ImplementValueTypeGenericClass() \n{ \n    const int age = 43; \n    ValueTypeConstraint<int> valueTypeConstraint = new\n    ValueTypeConstraint<int>(); \n    WriteLine($\"Age:{valueTypeConstraint.ImplementIt(age)}\"); \n\n} \n```", "```cs\npublic class ReferenceTypeConstraint<T> where T:class \n{ \n    public T ImplementIt(T value) \n    { \n        return value; \n    } \n} \n```", "```cs\nprivate static void ImplementReferenceTypeGenericClass() \n{ \n    const string thisIsAuthorName = \"Gaurav Aroraa\"; \n    ReferenceTypeConstraint<string> referenceTypeConstraint = new ReferenceTypeConstraint<string>(); \n    WriteLine($\"Name:{referenceTypeConstraint.ImplementIt(thisIsAuthorName)}\"); \n\n    ReferenceTypeConstraint<Person> referenceTypePersonConstraint = new ReferenceTypeConstraint<Person>(); \n\n    Person person = referenceTypePersonConstraint.ImplementIt(new Person \n    { \n        FirstName = \"Gaurav\", \n        LastName = \"Aroraa\", \n        Age = 43 \n    }); \n    WriteLine($\"Name:{person.FirstName}{person.LastName}\"); \n    WriteLine($\"Age:{person.Age}\"); \n} \n```", "```cs\npublic class DefaultConstructorConstraint<T> where T : new() \n{ \n    public T ImplementIt(T value) \n    { \n        return value; \n    } \n} \n```", "```cs\nprivate static void ImplementDefaultConstructorGenericClass() \n{ \n    DefaultConstructorConstraint<ClassWithDefautConstructor>\n    constructorConstraint = new\n    DefaultConstructorConstraint<ClassWithDefautConstructor>(); \n    var result = constructorConstraint.ImplementIt(new\n    ClassWithDefautConstructor { Name = \"Gaurav Aroraa\" }); \n    WriteLine($\"Name:{result.Name}\"); \n} \n```", "```cs\npublic class BaseClassConstraint<T> where T:Person \n{ \n    public T ImplementIt(T value) \n    { \n        return value; \n    } \n} \n```", "```cs\nprivate static void ImplementBaseClassConstraint() \n{ \n    BaseClassConstraint<Author>baseClassConstraint = new BaseClassConstraint<Author>(); \n    var result = baseClassConstraint.ImplementIt(new Author \n    { \n        FirstName = \"Shivprasad\", \n        LastName = \"Koirala\", \n         Age = 40 \n    }); \n\n    WriteLine($\"Name:{result.FirstName} {result.LastName}\"); \n    WriteLine($\"Age:{result.Age}\"); \n} \n```", "```cs\npublic class InterfaceConstraint<T>:IDisposable where T : IDisposable \n{ \n    public T ImplementIt(T value) \n    { \n        return value; \n    } \n\n    public void Dispose() \n    { \n        //dispose stuff goes here \n    } \n} \n```", "```cs\nprivate static void ImplementInterfaceConstraint() \n{ \n    InterfaceConstraint<EntityClass> entityConstraint = new InterfaceConstraint<EntityClass>(); \n    var result=entityConstraint.ImplementIt(new EntityClass {Name = \"Gaurav Aroraa\"}); \n    WriteLine($\"Name:{result.Name}\"); \n} \n```", "```cs\nprivate void PeerOperation() \n{ \n    //other stuffs \n    WriteLine(\"Level1 is completed.\"); \n    //other stuffs \n} \n```", "```cs\n[PeerInformation(\"Level1 is completed.\")] \nprivate void PeerOperation() \n{ \n    //other stuffs \n} \n```", "```cs\n[AttributeUsage(AttributeTargets.Class)] \npublic class PeerInformationAttribute : Attribute \n{ \n    public PeerInformationAttribute(string information) \n    { \n        WriteLine(information); \n    } \n} \n```", "```cs\nObsolete. You can compile and run the code even after a warning message because we have not asked this attribute to throw any error message on usage:\n```", "```cs\n[Obsolete(\"Do not use this class use 'Person' instead.\")] \npublic class Author:Person \n{ \n    //other stuff goes here \n} \n```", "```cs\n[Obsolete(\"Do not use this class use 'Person' instead.\",true)] \npublic class Author:Person \n{ \n    //other stuff goes here \n} \n```", "```cs\n#define Debug \nusing System.Diagnostics; \nusing static System.Console; \n\nnamespace Day06 \n{ \n    internal class Program \n    { \n        private static void Main(string[] args) \n        { \n            PersonList(); \n            ReadLine(); \n        } \n\n        [Conditional(\"Debug\")] \n        private static void PersonList() \n        { \n            WriteLine(\"Person list:\"); \n            foreach (var person in Person.GetPersonList()) \n            { \n                WriteLine($\"Name:{person.FirstName} {person.LastName}\"); \n                WriteLine($\"Age:{person.Age}\"); \n            } \n        } \n    } \n} \n```", "```cs\npublic class ErrorLogger : Attribute \n{ \n    public ErrorLogger(string exception) \n    { \n        switch (Env) \n        { \n            case Env.Debug: \n            case Env.Dev: \n                WriteLine($\"{exception}\"); \n                throw new Exception(exception); \n            case Env.Prod: \n                WriteLine($\"{exception}\"); \n                break; \n            default: \n                WriteLine($\"{exception}\"); \n                throw new Exception(exception); \n        } \n    } \n\n    public Env Env { get; set; } \n} \n```", "```cs\npublic class MathClass \n{ \n    [ErrorLogger(\"Add Math opetaion in development\", Env =\n    Env.Debug)] \n    public string Add(int num1, int num2) \n    { \n        return $\"Sum of {num1} and {num2} = {num1 + num2}\"; \n    } \n\n    [ErrorLogger(\"Substract Math opetaion in development\", Env =\n    Env.Dev)] \n    public string Substract(int num1, int num2) \n    { \n        return $\"Substracrion of {num1} and {num2} = {num1 -\n        num2}\"; \n    } \n\n    [ErrorLogger(\"Multiply Math opetaion in development\", Env =\n    Env.Prod)] \n    public string Multiply(int num1, int num2) \n    { \n        return $\"Multiplication of {num1} and {num2} = {num1 -\n        num2}\"; \n    } \n} \n```", "```cs\n#if ... #endif  \n```", "```cs\n#define DEBUG \n#define DEV \nusing static System.Console; \n\nnamespace Day06 \n{ \n    public class PreprocessorDirective \n    { \n        public void ConditionalProcessor() =>\n        #if (DEBUG && !DEV) \n            WriteLine(\"Symbol is DEBUG.\"); \n            #elseif (!DEBUG && DEV) \n            WriteLine(\"Symbol is DEV\"); \n            #else \n            WriteLine(\"Symbols are DEBUG & DEV\"); \n            #endif \n    } \n} \nDEBUG and DEV, and now, on the basis of our condition the following will be the output of the preceding code.\n```", "```cs\n#define DEBUG \n#define DEV \n#undef DEBUG \nusing static System.Console; \n\nnamespace Day06 \n{ \n    public class PreprocessorDirective \n    { \n        public void ConditionalProcessor() => \n#if (DEBUG && !DEV) \n            WriteLine(\"Symbol is DEBUG.\"); \n#elif (!DEBUG && DEV) \n            WriteLine(\"Symbol is DEV\"); \n#else \n            WriteLine(\"Symbols are DEBUG & DEV\"); \n#endif \n    } \n} \n```", "```cs\n        public void LinePreprocessor() \n        { \n            #line 85 \"LineprocessorIsTheFileName\" \n            WriteLine(\"This statement is at line#85 and not at\n            line# 25\");\n            #line default \n            WriteLine(\"This statement is at line#29 and not at\n            line# 28\");\n            #line hidden \n            WriteLine(\"This statement is at line#30\"); \n        } \n    } \n85 for the first statement, which was originally at line number 25.\n```", "```cs\n        public void WarningPreProcessor() \n        { \n           #if DEBUG \n           #warning \"This is a DEBUG compilation.\" \n           WriteLine(\"Environment is DEBUG.\"); \n           #endif \n        } \n    } \n```", "```cs\n        public void ErrorPreProcessor() \n        { \n           #if DEV \n           #error \"This is a DEV compilation.\" \n           WriteLine(\"Environment is DEV.\"); \n           #endif \n        } \n```", "```cs\nprivate static void TestLINQ() \n{ \n    var person = from p in Person.GetPersonList() \n        where p.Id == 1 \n        select p; \n    foreach (var per in person) \n    { \n        WriteLine($\"Person Id:{per.Id}\"); \n        WriteLine($\"Name:{per.FirstName} {per.LastName}\"); \n        WriteLine($\"Age:{per.Age}\"); \n    } \n\n} \nList of persons for *personId* =1\\. The LINQ query returns a result of IEnumerable<Person> type which can be easily accessed using foreach. This code produces the following output:\n```", "```cs\npublic unsafe void SwapNumbers(int*  num1, int* num2) \n{ \n    int tempNum = *num1; \n    *num1 = *num2; \n    *num2 = tempNum; \n} \n```", "```cs\nprivate static unsafe void TestUnsafeSwap() \n{ \n    Write(\"Enter first number:\"); \n    var num1 = Convert.ToInt32(ReadLine()); \n    Write(\"Enter second number:\"); \n    var num2 = Convert.ToInt32(ReadLine()); \n    WriteLine(\"Before calling swap function:\"); \n    WriteLine($\"Number1:{num1}, Number2:{num2}\"); \n    //call swap \n    new UnsafeSwap().SwapNumbers(&num1, &num2); \n    WriteLine(\"After calling swap function:\"); \n    WriteLine($\"Number1:{num1}, Number2:{num2}\"); \n} \n```", "```cs\npublic class FilePolling \n{ \n    public void PoleAFile(string fileName) \n    { \n        Console.Write($\"This is polling file:\n        {fileName}\"); \n        //file polling stuff goes here \n    } \n} \n```", "```cs\npublic async void PoleAFileAsync(string fileName) \n{ \n    Console.Write($\"This is polling file: {fileName}\"); \n    //file polling async stuff goes here \n} \n```", "```cs\ninternal class Program \n{ \n      private static void Main(string[] args) \n{ \n    //No exception at compile-time or run-time \n    ArrayList authorEditorArrayList = new ArrayList {\n    \"Gaurav Arora\", 43, \"Vikas Tiwari\", 25 }; \n    foreach (var authorEditor in authorEditorArrayList) \n    { \n        WriteLine($\"{authorEditor}\"); \n    } \n}     \n} \n```"]