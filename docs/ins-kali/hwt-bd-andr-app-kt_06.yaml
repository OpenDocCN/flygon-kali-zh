- en: 6\. RecyclerView
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. RecyclerView
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how to add lists and grids of items to your
    apps and effectively leverage the recycling power of `RecyclerView`. You'll also
    learn how to handle user interaction with the item views on the screen and support
    different item view types—for example, for titles. Later in the chapter, you'll
    add and remove items dynamically.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，您将学习如何向您的应用程序添加项目列表和网格，并有效地利用`RecyclerView`的回收功能。您还将学习如何处理屏幕上项目视图的用户交互，并支持不同的项目视图类型，例如标题。在本章的后面，您将动态添加和删除项目。
- en: By the end of the chapter, you will have the skills required to present your
    users with interactive lists of rich items.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将具备呈现交互式丰富项目列表所需的技能。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned how to fetch data, including lists of items
    and image URLs, from APIs, and how to load images from URLs. Combining that knowledge
    with the ability to display lists of items is the goal of this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何从API中获取数据，包括项目列表和图像URL，并如何从URL加载图像。将这些知识与显示项目列表的能力结合起来是本章的目标。
- en: Quite often, you will want to present your users with a list of items. For example,
    you might want to show them a list of pictures on their device, or let them select
    their country from a list of all countries. To do that, you would need to populate
    multiple views, all sharing the same layout but presenting different content.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会希望向用户呈现项目列表。例如，您可能希望向他们显示设备上的图片列表，或者让他们从所有国家的列表中选择自己的国家。为此，您需要填充多个视图，所有这些视图共享相同的布局，但呈现不同的内容。
- en: Historically, this was achieved by using `ListView` or `GridView`. While both
    are still viable options, they do not offer the robustness and flexibility of
    `RecyclerView`. For example, they do not support large datasets well, they do
    not support horizontal scrolling, and they do not offer rich divider customization.
    Customizing the divider between items in `RecyclerView` can be easily achieved
    using `RecyclerView.ItemDecorator`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在历史上，这是通过使用`ListView`或`GridView`来实现的。虽然这两者仍然是可行的选择，但它们不具备`RecyclerView`的健壮性和灵活性。例如，它们不太好地支持大型数据集，不支持水平滚动，并且不提供丰富的分隔符自定义。使用`RecyclerView.ItemDecorator`可以轻松实现对`RecyclerView`中项目之间的分隔符进行自定义。
- en: 'So, what does `RecyclerView` do? `RecyclerView` orchestrates the creation,
    population, and reuse (hence the name) of views representing lists of items. To
    use `RecyclerView`, you need to familiarize yourself with two of its dependencies:
    the adapter (and through it, the view holder) and the layout manager. These dependencies
    provide our `RecyclerView` with the content to show, as well as telling it how
    to present that content and how to lay it out on the screen.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`RecyclerView`是做什么的呢？`RecyclerView`协调创建、填充和重用（因此得名）表示项目列表的视图。要使用`RecyclerView`，您需要熟悉其两个依赖项：适配器（以及通过它的视图持有者）和布局管理器。这些依赖项为我们的`RecyclerView`提供要显示的内容，并告诉它如何呈现该内容以及如何在屏幕上布置它。
- en: 'The adapter provides `RecyclerView` with child views (nested Android views
    within `RecyclerView` used to represent individual data items) to draw on the
    screen, binds those views to data (via `ViewHolder` instances), and reports user
    interaction with those views. The layout manager tells `RecyclerView` how to lay
    its children out. We are provided with three layout types by default: linear,
    grid, and staggered grid—managed by `LinearLayoutManager`, `GridLayoutManager`,
    and `StaggeredGridLayoutManager`, respectively.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器为`RecyclerView`提供子视图（`RecyclerView`中用于表示单个数据项的嵌套Android视图），绑定这些视图到数据（通过`ViewHolder`实例），并报告用户与这些视图的交互。布局管理器告诉`RecyclerView`如何布置其子项。我们默认提供了三种布局类型：线性、网格和交错网格，分别由`LinearLayoutManager`、`GridLayoutManager`和`StaggeredGridLayoutManager`管理。
- en: 'In this chapter, we will develop an app that lists secret agents and whether
    they are currently active or sleeping (and thus unavailable). The app will then
    allow us to add new agents or delete existing ones by swiping them away. There
    is a twist, though—as you saw in *Chapter 5*, *Essential Libraries: Retrofit,
    Moshi, and Glide*, all our agents will be cats.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个列出秘密特工及其当前活动状态或休眠状态（因此不可用）的应用程序。然后，该应用程序将允许我们添加新特工或通过滑动将现有特工删除。不过，有一个转折，正如您在*第5章*中看到的，*基本库：Retrofit、Moshi和Glide*，我们所有的特工都将是猫。
- en: Adding RecyclerView to Our Layout
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将RecyclerView添加到我们的布局中
- en: 'In *Chapter 3*, *Screens and UI*, we saw how we can add views to our layouts
    to be inflated by activities, fragments, or custom views. `RecyclerView` is just
    another such view. To add it to our layout, we need to add the following tag to
    our layout:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3章*，*屏幕和UI*中，我们看到了如何向我们的布局中添加视图，以便由活动、片段或自定义视图膨胀。`RecyclerView`只是另一个这样的视图。要将其添加到我们的布局中，我们需要向我们的布局添加以下标签：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should already be able to recognize the `android:id` attribute, as well
    as the `android:layout_width` and `android:layout_height` ones.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经能够识别`android:id`属性，以及`android:layout_width`和`android:layout_height`属性。
- en: We can use the optional `tools:listitem` attribute to tell Android Studio which
    layout to inflate as a list item in our preview toolbar. This will give us an
    idea of how `RecyclerView` might look in our app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用可选的`tools:listitem`属性告诉Android Studio在我们的预览工具栏中膨胀哪个布局作为列表项。这将让我们对`RecyclerView`在我们的应用程序中的外观有一个概念。
- en: Adding a `RecyclerView` tag to our layout means we now have an empty container
    to hold the child views representing our list items. Once populated, it will handle
    the presenting, scrolling, and recycling of child views for us.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的布局添加`RecyclerView`标签意味着我们现在有一个空容器来容纳表示我们列表项目的子视图。一旦填充，它将为我们处理子视图的呈现、滚动和回收。
- en: 'Exercise 6.01: Adding an Empty RecyclerView to Your Main Activity'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.01：向主活动添加一个空的RecyclerView
- en: 'To use `RecyclerView` in your app, you first need to add it to one of your
    layouts. Let''s add it to the layout inflated by our main activity:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中使用`RecyclerView`，您首先需要将其添加到您的布局之一中。让我们将其添加到我们的主活动膨胀的布局中：
- en: Start by creating a new empty activity project (`File` | `New` | `New Project`
    | `Empty Activity`). Name your application `My RecyclerView App`. Make sure your
    package name is `com.example.myrecyclerviewapp`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新的空活动项目（`文件` | `新建` | `新项目` | `空活动`）。将应用程序命名为`My RecyclerView App`。确保您的包名称为`com.example.myrecyclerviewapp`。
- en: 'Set the save location to where you want to save your project. Leave everything
    else at its default values and click `Finish`. Make sure you are on the `Android`
    view in your `Project` pane:![Figure 6.1: Android view in the Project pane](img/B15216_06_01.jpg)'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将保存位置设置为您要保存项目的位置。将其他所有内容保持默认值，然后单击`完成`。确保您在`项目`窗格中处于`Android`视图下：![图6.1：项目窗格中的Android视图](img/B15216_06_01.jpg)
- en: 'Figure 6.1: Android view in the Project pane'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：项目窗格中的Android视图
- en: Open your `activity_main.xml` file in `Text` mode.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Text`模式下打开您的`activity_main.xml`文件。
- en: 'To turn your label into a title at the top of the screen under which you can
    add your `RecyclerView`, add an ID to `TextView` and align it to the top, like
    so:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的标签转换为屏幕顶部的标题，您可以在其下添加您的`RecyclerView`，为`TextView`添加一个ID，并将其对齐到顶部，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following after `TextView` tag to add an empty `RecyclerView` element
    to our layout, constrained below your `hello_label` `TextView` title:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TextView`标签之后添加以下内容，以在您的`hello_label` `TextView`标题下方添加一个空的`RecyclerView`元素：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Your layout file should now look something like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您的布局文件现在应该看起来像这样：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run your app by clicking the `Run app` button or pressing *Ctrl* + *R* (*Shift*
    + *F10* on Windows). On the emulator, it should look like this:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击`运行应用程序`按钮或按*Ctrl* + *R*（在Windows上为*Shift* + *F10*）来运行您的应用程序。在模拟器上，它应该看起来像这样：
- en: '![Figure 6.2: App with an empty RecyclerView (image cropped for space)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2：带有空的RecyclerView的应用程序（为节省空间而裁剪的图像）'
- en: '](img/B15216_06_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_02.jpg)'
- en: 'Figure 6.2: App with an empty RecyclerView (image cropped for space)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：带有空的RecyclerView的应用程序（为节省空间而裁剪的图像）
- en: As you can see, our app runs and our layout is presented on the screen. However,
    we do not see our `RecyclerView`. Why is that? At this stage, our `RecyclerView`
    has no content. `RecyclerView` with no content does not render by default—so,
    while our `RecyclerView` is indeed on the screen, it is not visible. This brings
    us to the next step—populating `RecyclerView` with content that we can actually
    see.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的应用程序正在运行，并且我们的布局显示在屏幕上。但是，我们没有看到我们的`RecyclerView`。为什么呢？在这个阶段，我们的`RecyclerView`没有内容。默认情况下，没有内容的`RecyclerView`不会呈现—因此，虽然我们的`RecyclerView`确实在屏幕上，但它是不可见的。这就带我们到下一步—填充`RecyclerView`，以便我们实际上可以看到内容。
- en: Populating the RecyclerView
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充RecyclerView
- en: So, we added `RecyclerView` to our layout. For us to benefit from `RecyclerView`,
    we need to add content to it. Let's see how we go about doing that.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将`RecyclerView`添加到我们的布局中。为了从`RecyclerView`中受益，我们需要向其中添加内容。让我们看看如何做到这一点。
- en: As we mentioned before, to add content to our `RecyclerView`, we would need
    to implement an adapter. An adapter binds our data to child views. In simpler
    terms, this means it tells `RecyclerView` how to plug data into views designed
    to present that data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，要向我们的`RecyclerView`添加内容，我们需要实现一个适配器。适配器将我们的数据绑定到子视图。简单来说，这意味着它告诉`RecyclerView`如何将数据插入到设计用于呈现该数据的视图中。
- en: For example, let's say we want to present a list of employees.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要呈现一个员工列表。
- en: 'First, we need to design our UI model. This will be a data object holding all
    the information needed by our view to present a single employee. Because this
    is a UI model, one convention is to suffix its name with `UiModel`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设计我们的UI模型。这将是一个数据对象，其中包含视图呈现单个员工所需的所有信息。因为这是一个UI模型，一个惯例是在其名称后缀中加上`UiModel`：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will define `EmployeeRole` and `Gender` as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义`EmployeeRole`和`Gender`如下：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The values are provided as an example, of course. Feel free to add more of your
    own!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值仅供参考。请随意添加更多！
- en: '![Figure 6.3: The model’s hierarchy'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3：模型的层次结构'
- en: '](img/B15216_06_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_03.jpg)'
- en: 'Figure 6.3: The model''s hierarchy'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：模型的层次结构
- en: 'Now we know what data to expect when binding to a view—so, we can design our
    view to present this data (this is a simplified version of the actual layout,
    which we''ll save as `item_employee.xml`). We''ll start with the `ImageView`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道在绑定视图时可以期望什么样的数据，因此，我们可以设计我们的视图来呈现这些数据（这是实际布局的简化版本，我们将其保存为`item_employee.xml`）。我们将从`ImageView`开始：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And then add each `TextView`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为每个`TextView`添加：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So far, there is nothing new. You should be able to recognize all of the different
    view types from *Chapter 2*, *Building User Screen Flows*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有什么新的。您应该能够从*第2章* *构建用户屏幕流*中识别出所有不同的视图类型：
- en: '![Figure 6.4: Preview of the item_cat.xml layout file'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4：item_cat.xml布局文件的预览'
- en: '](img/B15216_06_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_04.jpg)'
- en: 'Figure 6.4: Preview of the item_cat.xml layout file'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：item_cat.xml布局文件的预览
- en: 'With a data model and a layout, we now have everything we need to bind our
    data to the view. To do that, we will implement a view holder. Usually, a view
    holder has two responsibilities: it holds a reference to a view (as its name implies),
    but it also binds data to that view. We will implement our view holder as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有了数据模型和布局，我们现在拥有了将数据绑定到视图所需的一切。为此，我们将实现一个视图持有者。通常，视图持有者有两个职责：它保存对视图的引用（正如其名称所暗示的那样），但它也将数据绑定到该视图。我们将实现我们的视图持有者如下：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are a few things worth noting in the preceding code. First, by convention,
    we suffixed the name of our view holder with `ViewHolder`. Second, note that `EmployeeViewHolder`
    needs to implement the abstract `RecyclerView.ViewHolder` class. This is required
    so that the generic type of our adapter can be our view holder. Lastly, we lazily
    keep references to the views we are interested in. The first time `bindData(EmployeeUiModel)`
    is called, we will find these views in the layout and keep references to them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中有一些值得注意的事情。首先，按照惯例，我们在视图持有者的名称后缀为`ViewHolder`。其次，请注意`EmployeeViewHolder`需要实现抽象的`RecyclerView.ViewHolder`类。这是必需的，以便我们的适配器的通用类型可以是我们的视图持有者。最后，我们懒惰地保留对我们感兴趣的视图的引用。当第一次调用`bindData(EmployeeUiModel)`时，我们将在布局中找到这些视图并保留对它们的引用。
- en: Next, we introduced a `bindData(EmployeeUiModel)` function. This function will
    be called by our adapter to bind the data to the view held by the view holder.
    The last but most important thing to note is that we always make sure to set a
    state for all modified views for any possible input.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们引入了一个`bindData(EmployeeUiModel)`函数。这个函数将被我们的适配器调用，将数据绑定到视图持有者持有的视图上。最后但最重要的一点是，我们始终确保为任何可能的输入设置所有修改视图的状态。
- en: 'With our view holder set up, we can proceed to implement our adapter. We will
    start by implementing the minimum required functions, plus a function to set the
    data. Our adapter will look something like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了我们的视图持有者后，我们可以继续实现我们的适配器。我们将首先实现最少所需的函数，再加上一个设置数据的函数。我们的适配器将看起来像这样：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's go over this implementation. First, we inject our dependencies to the
    adapter via its constructor. This will make testing our adapter much easier—but
    will also allow us to change some of its behavior (for example, replace the image
    loading library) painlessly. In fact, we would not need to change the adapter
    at all in that case.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个实现。首先，我们通过构造函数向适配器注入我们的依赖项。这将使测试我们的适配器变得更容易，但也将允许我们轻松地更改一些其行为（例如，替换图像加载库）。实际上，在这种情况下，我们根本不需要更改适配器。
- en: Then, we define a private mutable list of `EmployeeUiModel` to store the data
    currently provided by the adapter to `RecyclerView`. We also introduce a method
    to set that list. Note that we keep a local list and set its contents, rather
    than allowing `employeesData` to be set directly. This is mainly because Kotlin,
    just like Java, passes variables by reference. Passing variables by reference
    means changes to the content of the list passed into the adapter would change
    the list held by the adapter. So, for example, if an item was removed from outside
    the adapter, the adapter would have that item removed as well. This becomes a
    problem because the adapter would not be aware of that change, and so would not
    be able to notify `RecyclerView`. There are other risks around the list being
    modified from outside the adapter, but covering them is beyond the scope of this
    book.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个私有的可变的`EmployeeUiModel`列表，用于存储适配器当前提供给`RecyclerView`的数据。我们还引入了一个设置该列表的方法。请注意，我们保留一个本地列表并设置其内容，而不是直接允许`employeesData`被设置。这主要是因为Kotlin和Java一样，通过引用传递变量。通过引用传递变量意味着对适配器传入的列表内容的更改将改变适配器持有的列表。因此，例如，如果在适配器外部删除了一个项目，适配器也会将该项目删除。这成为一个问题，因为适配器不会意识到这种变化，因此无法通知`RecyclerView`。列表从适配器外部修改的其他风险，但涵盖它们超出了本书的范围。
- en: Another benefit of encapsulating the modification of the data in a function
    is that we avoid the risk of forgetting to notify `RecyclerView` that the dataset
    has changed, which we do by calling `notifyDataSetChanged()`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据修改封装在一个函数中的另一个好处是，我们避免了忘记通知`RecyclerView`数据集已更改的风险，我们通过调用`notifyDataSetChanged()`来实现这一点。
- en: We proceed to implement the adapter's `onCreateViewHolder(ViewGroup, Int)` function.
    This function is called when the `RecyclerView` needs a new `ViewHolder` to render
    data on the screen. It provides us with a container `ViewGroup` and a view type
    (we'll look into view types later in this chapter). The function then expects
    us to return a view holder initialized with a view (in our case, an inflated one).
    So, we inflate the view we designed earlier, passing it to a new `EmployeeViewHolder`
    instance. Note that the last argument to the inflated function is `false`. This
    makes sure we do not attach the newly inflated view to the parent. Attaching and
    detaching views will be managed by the layout manager. Setting it to `true` or
    omitting it would result in `IllegalStateException` being thrown. Finally, we
    return the newly created `EmployeeViewHolder`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续实现适配器的`onCreateViewHolder(ViewGroup, Int)`函数。当`RecyclerView`需要一个新的`ViewHolder`来在屏幕上呈现数据时，将调用此函数。它为我们提供了一个容器`ViewGroup`和一个视图类型（我们将在本章后面讨论视图类型）。然后，该函数期望我们返回一个使用视图（在我们的情况下是一个膨胀的视图）初始化的视图持有者。因此，我们膨胀我们之前设计的视图，并将其传递给一个新的`EmployeeViewHolder`实例。请注意，膨胀函数的最后一个参数是`false`。这确保我们不将新膨胀的视图附加到父视图上。附加和分离视图将由布局管理器管理。将其设置为`true`或省略将导致`IllegalStateException`被抛出。最后，我们返回新创建的`EmployeeViewHolder`。
- en: To implement `getItemCount()`, we simply return the size of our `employeesData`
    list.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`getItemCount()`，我们只需返回我们的`employeesData`列表的大小。
- en: Lastly, we implement `onBindViewHolder(EmployeeViewHolder, Int)`. This is done
    by passing `EmployeeUiModel`, stored in `catsData`, at the given position to the
    `bindData(EmployeeUiModel)` function of our view holder. Our adapter is now ready.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了`onBindViewHolder(EmployeeViewHolder, Int)`。这是通过将存储在`catsData`中的`EmployeeUiModel`在给定位置传递给我们的视图持有者的`bindData(EmployeeUiModel)`函数来完成的。我们的适配器现在已经准备好了。
- en: 'If we tried to plug our adapter into our `RecyclerView` at this point and run
    our app, we would still see no content. This is because we are still missing two
    small steps: setting data to our adapter and assigning a layout manager to our
    `RecyclerView`. The complete working code would look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在这一点上将我们的适配器插入我们的`RecyclerView`并运行我们的应用程序，我们仍然看不到任何内容。这是因为我们仍然缺少两个小步骤：向我们的适配器设置数据和为我们的`RecyclerView`分配布局管理器。完整的工作代码将如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running our app now, we would see a list of our employees.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行我们的应用程序，我们会看到我们的员工列表。
- en: Note that we hardcoded the list of employees. In a production app, following
    a `ViewModel`. It is also important to note that we kept a reference to `employeesAdapter`.
    This is so that we could indeed, at a later time, set the data to different values.
    Some implementations rely on reading the adapter from `RecyclerView` itself—this
    can potentially result in unnecessary casting operations and unexpected states
    where the adapter is not yet assigned to `RecyclerView`, and so this is generally
    not a recommended approach.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们对员工列表进行了硬编码。在生产应用程序中，应遵循`ViewModel`。还要注意，我们保留了对`employeesAdapter`的引用。这样我们可以在以后确实将数据设置为不同的值。一些实现依赖于从`RecyclerView`本身读取适配器——这可能导致不必要的强制转换操作和适配器尚未分配给`RecyclerView`的意外状态，因此这通常不是一种推荐的方法。
- en: Lastly, note that we chose to use `LinearLayoutManager`, providing it with the
    activity for context, a `VERTICAL` orientation flag, and `false` to tell it that
    we do not want the order of the items in the list reversed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，我们选择使用`LinearLayoutManager`，为其提供活动上下文、`VERTICAL`方向标志和`false`来告诉它我们不希望列表中的项目顺序被颠倒。
- en: 'Exercise 6.02: Populating Your RecyclerView'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.02：填充您的RecyclerView
- en: '`RecyclerView` is not very interesting without any content. It is time you
    populate `RecyclerView` by adding your secret cat agents to it.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecyclerView`如果没有任何内容就不太有趣。现在是时候通过向其中添加您的秘密猫代理来填充`RecyclerView`了。'
- en: 'A quick recap before you dive in: in the previous exercise, we introduced an
    empty list designed to hold a list of secret cat agents that the users have at
    their disposal. In this exercise, you will be populating that list to present
    the users with the available secret cat agents in the agency:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，让我们快速回顾一下：在上一个练习中，我们介绍了一个空列表，用于保存用户可以使用的秘密猫代理的列表。在这个练习中，您将填充该列表，以向用户展示机构中可用的秘密猫代理：
- en: 'To keep our file structure tidy, we will start by creating a model package.
    Right-click on the package name of our app, then select `New` | `Package`:![Figure
    6.5: Creating a new package'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持文件结构的整洁，我们将首先创建一个模型包。右键单击我们应用程序的包名称，然后选择`New` | `Package`：![图6.5：创建新的包
- en: '](img/B15216_06_05.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_05.jpg)'
- en: 'Figure 6.5: Creating a new package'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：创建新的包
- en: Name the new package `model`. Click `OK` to create the package.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新包命名为`model`。单击`OK`以创建该包。
- en: To create our first model data class, right-click on the newly created model
    package, then select `New` | `Kotlin File/Class`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建我们的第一个模型数据类，请右键单击新创建的模型包，然后选择`New` | `Kotlin File/Class`。
- en: Under `name`, fill in `CatUiModel`. Leave `kind` as `File` and click on `OK`.
    This will be the class holding the data we have about every individual cat agent.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`name`下，填写`CatUiModel`。将`kind`保持为`File`，然后单击`OK`。这将是包含我们对每个猫代理的数据的类。
- en: 'Add the following to the newly created `CatUiModel.kt` file to define the data
    class with all the relevant properties of a cat agent:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到新创建的`CatUiModel.kt`文件中，以定义具有所有相关属性的数据类的猫代理：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For each cat agent, other than their name and photo, we want to know the gender,
    breed, and biography. This will help us choose the right agent for a mission.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了他们的姓名和照片之外，我们还想知道每个猫代理的性别、品种和传记。这将帮助我们为任务选择合适的代理。
- en: Again, right-click on the model package, then navigate to `New` | `Kotlin File/Class`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次右键单击模型包，然后转到`New` | `Kotlin File/Class`。
- en: This time, name the new file `CatBreed` and set `kind` to the `Enum` class.
    This class will hold our different cat breeds.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，将新文件命名为`CatBreed`，并将`kind`设置为`Enum`类。这个类将保存我们不同的猫品种。
- en: 'Update your newly created enum with some initial values, as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一些初始值更新您新创建的枚举，如下所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Repeat *steps 6* and *7*, only this time call your file `Gender`. This will
    hold the accepted values for a cat agent's gender.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤6*和*7*，只是这一次将文件命名为`Gender`。这将保存猫代理的性别的接受值。
- en: 'Update the `Gender` enum like so:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像这样更新`Gender`枚举：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, to define the layout of the view holding the data about each cat agent,
    create a new layout resource file by right-clicking on `layout` and then selecting
    `New` | `Layout resource file`:![Figure 6.6: Creating a new layout resource file'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过右键单击`layout`，然后选择`New` | `Layout resource file`来定义包含有关每个猫代理数据的视图布局资源文件：![图6.6：创建新的布局资源文件
- en: '](img/B15216_06_06.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_06.jpg)'
- en: 'Figure 6.6: Creating a new layout resource file'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：创建新的布局资源文件
- en: Name your resource `item_cat`. Leave all the other fields as they are and click `OK`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的资源命名为`item_cat`。将所有其他字段保持不变，然后单击`OK`。
- en: Update the contents of the newly created `item_cat.xml` file. (The following
    code block has been truncated for space. Use the link below to see the full code
    that you need to add.)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新新创建的`item_cat.xml`文件的内容。（以下代码块已经被截断以节省空间。使用下面的链接查看您需要添加的完整代码。）
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will create a layout with an image and text fields for a name, breed, and
    biography to be used in our list.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个布局，其中包含用于列表中使用的名称、品种和传记的图像和文本字段。
- en: 'You will notice that *line 14* is highlighted in red. This is because you haven''t
    declared `item_cat_photo` in `strings.xml` under the `res/values` folder yet.
    Do so now by placing the text cursor over `item_cat_photo` and pressing *Alt*
    + *Enter* (*Option* + *Enter* on Mac), then select `Create string value resource
    ''item_cat_photo''`:![Figure 6.7: A string resource is not yet defined'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到*第14行*被标记为红色。这是因为您还没有在`res/values`文件夹下的`strings.xml`中声明`item_cat_photo`。现在通过将文本光标放在`item_cat_photo`上，然后按*Alt*
    + *Enter*（Mac上为*Option* + *Enter*），然后选择`Create string value resource 'item_cat_photo'`来进行声明：![图6.7：尚未定义的字符串资源
- en: '](img/B15216_06_07.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_07.jpg)'
- en: 'Figure 6.7: A string resource is not yet defined'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：尚未定义的字符串资源
- en: Under `Resource value`, fill in `Photo`. Press `OK`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Resource value`下，填写`Photo`。按下`OK`。
- en: 'You will need a copy of `ImageLoader.kt`, introduced in *Chapter 5*, *Essential
    Libraries: Retrofit, Moshi, and Glide*, so right-click on the package name of
    your app, navigate to `New` | `Kotlin File/Class`, and then set the name to `ImageLoader`
    and `kind` to `Interface`, and click `OK`.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '你需要一个`ImageLoader.kt`的副本，它在*第5章* *Essential Libraries: Retrofit, Moshi, and
    Glide*中介绍，所以右键单击你的应用程序的包名称，导航到`New` | `Kotlin File/Class`，然后将名称设置为`ImageLoader`，`kind`设置为`Interface`，然后点击`OK`。'
- en: 'Similar to *Chapter 5*, *Essential Libraries: Retrofit, Moshi, and Glide*,
    you only need to add one function here:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '与*第5章* *Essential Libraries: Retrofit, Moshi, and Glide*类似，你只需要在这里添加一个函数：'
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Make sure to import `ImageView`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 确保导入`ImageView`。
- en: Right-click on the package name of your app again, then select `New` | `Kotlin
    File/Class`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次右键单击你的应用程序的包名称，然后选择`New` | `Kotlin File/Class`。
- en: Call the new file `CatViewHolder`. Click `OK`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为`CatViewHolder`。点击`OK`。
- en: 'To implement `CatViewHolder`, which will bind the cat agent data to your views,
    replace the contents of the `CatViewHolder.kt` file with the following:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现`CatViewHolder`，它将把猫特工数据绑定到你的视图，用以下内容替换`CatViewHolder.kt`文件的内容：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Still under our app package name, create a new Kotlin file named `CatsAdapter`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的应用程序包名称下，创建一个名为`CatsAdapter`的新的Kotlin文件。
- en: 'To implement `CatsAdapter`, which is responsible for storing the data for `RecyclerView`,
    as well as creating instances of your view holder and using them to bind data
    to views, replace the contents of the `CatsAdapter.kt` file with this:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现`CatsAdapter`，它负责存储`RecyclerView`的数据，以及创建视图持有者的实例并使用它们将数据绑定到视图，用以下内容替换`CatsAdapter.kt`文件的内容：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At this point, you need to include Glide in your project. Start by adding the
    following line of code to the `dependencies` block inside your app''s `gradle.build`
    file:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，你需要在你的项目中包含Glide。首先，在你的应用程序的`gradle.build`文件的`dependencies`块中添加以下代码行：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a `GlideImageLoader` class in your app package path, containing the following:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的应用程序包路径中创建一个`GlideImageLoader`类，包含以下内容：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a simple implementation assuming the loaded image should always be center-cropped.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的实现，假设加载的图像应始终是中心裁剪的。
- en: 'Update your `MainActivity` file:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的`MainActivity`文件：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will define your adapter, attach it to `RecyclerView`, and populate it
    with some hardcoded data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定义你的适配器，将它附加到`RecyclerView`，并用一些硬编码的数据填充它。
- en: 'In your `AndroidManifest.xml` file, add the following in the `manifest` tag
    before the application tag:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`AndroidManifest.xml`文件中，在应用程序标签之前的`manifest`标签中添加以下内容：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will allow your app to download images off the internet.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你的应用程序从互联网上下载图像。
- en: 'For some final touches, such as giving our title view a proper name and text,
    update your `activity_main.xml` file like so:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了一些最后的修饰，比如给我们的标题视图一个合适的名称和文本，像这样更新你的`activity_main.xml`文件：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Also, update your `strings.xml` file to give your app a proper name and title:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要更新你的`strings.xml`文件，给你的应用程序一个合适的名称和标题：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run your app. It should look like this:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用程序。它应该是这样的：
- en: '![Figure 6.8: RecyclerView with hardcoded secret cat agents'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8：具有硬编码秘密猫特工的RecyclerView'
- en: '](img/B15216_06_08.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_08.jpg)'
- en: 'Figure 6.8: RecyclerView with hardcoded secret cat agents'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：具有硬编码秘密猫特工的RecyclerView
- en: As you can see, `RecyclerView` now has content, and your app is starting to
    take shape. Note how the same layout is used to present different items based
    on the data bound to each instance. As you would expect, if you added enough items
    for them to go off-screen, scrolling works. Next, we'll look into allowing the
    user to interact with the items inside our `RecyclerView`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`RecyclerView`现在有内容，你的应用程序开始成形。请注意，相同的布局用于根据绑定到每个实例的数据呈现不同的项目。正如你所期望的，如果你添加了足够的项目使它们超出屏幕，滚动是有效的。接下来，我们将研究允许用户与我们的`RecyclerView`中的项目进行交互。
- en: Responding to Clicks in RecyclerView
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在RecyclerView中响应点击
- en: What if we want to let our users select an item from the presented list? To
    achieve that, we need to communicate clicks back to our app.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让用户从呈现的列表中选择一个项目怎么办？为了实现这一点，我们需要将点击事件传递回我们的应用程序。
- en: The first step in implementing click interaction is to capture clicks on items
    at the `ViewHolder` level.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实现点击交互的第一步是在`ViewHolder`级别捕获项目的点击。
- en: 'To maintain separation between our view holder and the adapter, we define a
    nested `OnClickListener` interface in our view holder. We choose to define the
    interface within the view holder because they are tightly coupled. The interface
    will, in our case, have only one function. The purpose of this function is to
    inform the owner of the view holder about the clicks. The owner of a view holder
    is usually a Fragment or an Activity. Since we know that a view holder can be
    reused, we know that it can be challenging to define it at construction time in
    a way that would tell us which item was clicked (since that item will change over
    time with reuse). We work around that by passing the currently presented item
    back to the owner of the view holder on clicking. This means our interface would
    look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持视图持有者和适配器之间的分离，我们在视图持有者中定义了一个嵌套的`OnClickListener`接口。我们选择在视图持有者内定义接口，因为它们是紧密耦合的。在我们的情况下，接口只有一个功能。这个功能的目的是通知视图持有者的所有者有关点击的信息。视图持有者的所有者通常是一个Fragment或一个Activity。由于我们知道视图持有者可以被重用，我们知道在构造时定义它可能会很具有挑战性，因为它会告诉我们点击了哪个项目（因为该项目会随着重用而随时间变化）。我们通过在点击时将当前呈现的项目传递回视图持有者的所有者来解决这个问题。这意味着我们的接口看起来像这样：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will also add this listener as a parameter to our `ViewHolder` constructor:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将把这个监听器作为参数添加到我们的`ViewHolder`构造函数中：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It will be used like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被用于这样：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, we want our adapter to pass in a listener. In turn, that listener will
    be responsible for informing the owner of the adapter of the click. This means
    our adapter, too, would need a nested listener interface, quite similar to the
    one we implemented in our view holder.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望我们的适配器传递一个监听器。反过来，该监听器将负责通知适配器的所有者点击事件。这意味着我们的适配器也需要一个嵌套的监听器接口，与我们在视图持有者中实现的接口非常相似。
- en: While this seems like duplication that can be avoided by reusing the same listener,
    that is not a great idea, as it leads to tight coupling between the view holder
    and the adapter through the listener. What happens when you want your adapter
    to also report other events through the listener? You would have to handle those
    events coming from the view holder, even though they would not actually be implemented
    in the view holder.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这似乎是可以通过重用相同的监听器来避免的重复，但这并不是一个好主意，因为它会导致视图持有者和适配器之间通过监听器的紧密耦合。当您希望适配器也通过监听器报告其他事件时会发生什么？即使视图持有者实际上没有实现这些事件，您也必须处理来自视图持有者的这些事件。
- en: Finally, to handle the click event and show a dialog, we define a listener in
    our activity and pass it to our adapter. We set that listener to show a dialog
    on clicking. In an MVVM implementation, you would be notifying `ViewModel` of
    the click at this point instead. `ViewModel` would then update its state, telling
    the view (our activity) that it should display the dialog.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了处理点击事件并显示对话框，我们在活动中定义一个监听器并将其传递给适配器。我们设置该监听器在点击时显示对话框。在MVVM实现中，您现在将通知`ViewModel`点击。`ViewModel`然后更新其状态，告诉视图（我们的活动）应该显示对话框。
- en: 'Exercise 6.03: Responding to Clicks'
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.03：响应点击
- en: 'Your app already shows the user a list of secret cat agents. It is time to
    allow your user to choose a secret cat agent by clicking on its view. Click events
    are delegates from the view holder to the adapter to the activity, as shown in
    *Figure 6.9*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序已经向用户显示了一组秘密猫代理。现在是时候允许用户通过点击其视图选择秘密猫代理。点击事件是从视图持有者委托给适配器再委托给活动的，如*图6.9*所示：
- en: '![Figure 6.9: The flow of click events'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9：点击事件的流程'
- en: '](img/B15216_06_09.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_09.jpg)'
- en: 'Figure 6.9: The flow of click events'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：点击事件的流程
- en: 'The following are the steps that you need to follow to complete this exercise:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您需要遵循的步骤来完成此练习：
- en: 'Open your `CatViewHolder.kt` file. Add a nested interface to it right before
    the final closing curly bracket:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的`CatViewHolder.kt`文件。在最终的闭合大括号之前添加一个嵌套接口：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will be the interface a listener would have to implement in order to register
    for click events on individual cat items.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是监听器必须实现的接口，以便在单个猫项目上注册点击事件。
- en: 'Update the `CatViewHolder` constructor to accept `OnClickListener` and make
    containerView accessible:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`CatViewHolder`构造函数以接受`OnClickListener`并使containerView可访问：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'At the top of your `bindData(CatUiModel)` function, add the following to intercept
    clicks and report them to the provided listener:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`bindData(CatUiModel)`函数顶部，添加以下内容以拦截点击并将其报告给提供的监听器：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, open your `CatsAdapter.kt` file. Add this nested interface right before
    the final closing curly bracket:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开您的`CatsAdapter.kt`文件。在最终的闭合大括号之前添加此嵌套接口：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This defines the interface that listeners would have to implement to receive
    item click events from the adapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了监听器必须实现的接口，以接收来自适配器的项目点击事件。
- en: 'Update the `CatsAdapter` constructor to accept a call implementing the `OnClickListener`
    adapter you just defined:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`CatsAdapter`构造函数，以接受刚刚定义的`OnClickListener`适配器的调用：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In `onCreateViewHolder(ViewGroup, Int)`, update the creation of the view holder,
    as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreateViewHolder(ViewGroup, Int)`中，按照以下方式更新视图持有者的创建：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, open your `MainActivity.kt` file. Update your `catsAdapter` construction
    as follows to provide the required dependencies to the adapter in the form of
    an anonymous listener handling click events by showing a dialog:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开您的`MainActivity.kt`文件。按照以下方式更新您的`catsAdapter`构造，以通过显示对话框处理点击事件来为适配器提供所需的依赖项：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following function right before the final closing curly bracket:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最终的闭合大括号之前添加以下函数：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This function will show a dialog with the name of the cat whose data was passed in.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将显示一个对话框，其中包含传递的猫数据的名称。
- en: Make sure to import the right version of `AlertDialog`, which is `androidx.appcompat.app.AlertDialog`,
    not `android.app.AlertDialog`. This is usually a better choice to support backward
    compatibility.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保导入正确版本的`AlertDialog`，即`androidx.appcompat.app.AlertDialog`，而不是`android.app.AlertDialog`。这通常是支持向后兼容的更好选择。
- en: 'Run your app. Clicking on one of the cats should now show a dialog:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序。现在点击其中一只猫应该会显示一个对话框：
- en: '![Figure 6.10: A dialog showing an agent was selected'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.10：显示已选择代理的对话框'
- en: '](img/B15216_06_10.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_10.jpg)'
- en: 'Figure 6.10: A dialog showing an agent was selected'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：显示已选择代理的对话框
- en: Try clicking the different items and note the different messages presented.
    You now know how to respond to users clicking on items inside your `RecyclerView`.
    Next, we will look at how we can support different item types in our lists.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试点击不同的项目并注意呈现的不同消息。您现在知道如何响应用户点击`RecyclerView`中的项目。接下来，我们将看看如何支持列表中的不同项目类型。
- en: Supporting Different Item Types
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持不同的项目类型
- en: In the previous sections, we learned how to handle a list of items of a single
    type (in our case, all our items were `CatUiModel`). What happens if you want
    to support more than one type of item? A good example of this would be having
    group titles within our list.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们学习了如何处理单一类型的项目列表（在我们的情况下，所有项目都是`CatUiModel`）。如果您想要支持多种类型的项目会发生什么？一个很好的例子是在我们的列表中有组标题。
- en: 'Let''s say that instead of getting a list of cats, we instead get a list containing
    happy cats and sad cats. Each of the two groups of cats is preceded by a title
    of the corresponding group. Instead of a list of `CatUiModel` instances, our list
    would now contain `ListItem` instances. `ListItem` might look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不是获取一组猫的列表，而是获取一个包含快乐猫和悲伤猫的列表。每组猫之前都有相应组的标题。我们的列表现在不再包含`CatUiModel`实例，而是包含`ListItem`实例。`ListItem`可能如下所示：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our list of items may look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目列表可能如下所示：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this case, having just one layout type will not do. Luckily, as you may have
    noticed in our earlier exercises, `RecyclerView.Adapter` provides us with a mechanism
    to handle this (remember the `viewType` parameter used in the `onCreateViewHolder(ViewGroup,
    Int)` function?).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有一个布局类型是不够的。幸运的是，正如您可能已经在我们早期的练习中注意到的那样，`RecyclerView.Adapter`为我们提供了处理这种情况的机制（记得`onCreateViewHolder(ViewGroup,
    Int)`函数中使用的`viewType`参数吗？）。
- en: 'To help the adapter determine which view type is needed for each item, we override
    its `getItemViewType(Int)` function. An example of an implementation that would
    do the trick for us is the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助适配器确定每个项目需要哪种视图类型，我们重写了它的`getItemViewType(Int)`函数。一个对我们来说可以解决问题的实现示例如下：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, `VIEW_TYPE_GROUP` and `VIEW_TYPE_CAT` are defined as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`VIEW_TYPE_GROUP`和`VIEW_TYPE_CAT`的定义如下：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This implementation maps the data type at a given position to a constant value
    representing one of our known layout types. In our case, we know of titles and
    cats, thus the two types. The values we use can be any integer values, as they're
    passed back to us as is in the `onCreateViewHolder(ViewGroup, Int)` function.
    All we need to do is make sure not to repeat the same value more than once.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现将给定位置的数据类型映射到表示我们已知布局类型之一的常量值。在我们的情况下，我们知道标题和猫，因此有两种类型。我们使用的值可以是任何整数值，因为它们会原样传递给我们在`onCreateViewHolder(ViewGroup,
    Int)`函数中。我们只需要确保不重复相同的值超过一次。
- en: 'Now that we have told the adapter which view types are needed and where, we
    also need to tell it which view holder to use for each view type. This is done
    by implementing the `onCreateViewHolder(ViewGroup, Int)` function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经告诉适配器需要哪些视图类型以及在哪里需要，我们还需要告诉它对于每种视图类型使用哪种视图持有者。这是通过实现`onCreateViewHolder(ViewGroup,
    Int)`函数来完成的：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Unlike the earlier implementations of this function, we now take the value of
    `viewType` into account.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与此函数的早期实现不同，我们现在考虑`viewType`的值。
- en: As we now know, `viewType` is expected to be one of the values we returned from
    `getItemViewType(Int)`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在知道的，`viewType`预计是我们从`getItemViewType(Int)`返回的值之一。
- en: For each of these values (`VIEW_TYPE_GROUP` and `VIEW_TYPE_CAT`), we inflate
    the corresponding layout and construct a suitable view holder. Note that we never
    expect to receive any other value, and so throw an exception if such a value is
    encountered. Depending on your needs, you could instead return a default view
    holder with a layout showing an error or nothing at all. It may also be a good
    idea to log such values to allow you to investigate why you received them and
    decide how to handle them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些值（`VIEW_TYPE_GROUP`和`VIEW_TYPE_CAT`），我们会填充相应的布局并构建一个合适的视图持有者。请注意，我们永远不希望收到任何其他值，因此如果遇到这样的值，我们会抛出异常。根据您的需求，您也可以返回一个显示错误或根本不显示任何内容的默认视图持有者。记录这些值也可能是一个好主意，以便您调查为什么收到它们并决定如何处理它们。
- en: For our title layout, a simple `TextView` may be sufficient. The `item_cat.xml`
    layout can remain as is.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的标题布局，一个简单的`TextView`可能就足够了。`item_cat.xml`布局可以保持不变。
- en: 'Now onto the view holder. We need to create a view holder for the title. This
    means we will now have two different view holders. However, our adapter only supports
    one adapter type. The easiest solution is to define a common view holder that
    both `GroupViewHolder` and `CatViewHolder` will extend. Let''s call it `ListItemViewHolder`.
    The `ListItemViewHolder` class can be abstract, as we never intend to use it directly.
    To make it easy to bind data, we can also introduce a function in our abstract
    view holder—`abstract fun bindData(listItem: ListItemUiModel)`. Our concrete implementations
    can expect to receive a specific type, and so we can add the following lines to
    both `GroupViewHolder` and `CatViewHolder`, respectively:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '现在到了视图持有者。我们需要为标题创建一个视图持有者。这意味着我们现在将有两个不同的视图持有者。然而，我们的适配器只支持一种适配器类型。最简单的解决方案是定义一个通用的视图持有者，`GroupViewHolder`和`CatViewHolder`都将扩展它。让我们称之为`ListItemViewHolder`。`ListItemViewHolder`类可以是抽象的，因为我们永远不打算直接使用它。为了方便绑定数据，我们还可以在我们的抽象视图持有者中引入一个函数——`abstract
    fun bindData(listItem: ListItemUiModel)`。我们的具体实现可以期望接收特定类型，因此我们可以分别向`GroupViewHolder`和`CatViewHolder`添加以下行：'
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can also add the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加以下内容：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Specifically, in `CatViewHolder`, thanks to some Kotlin magic, we can then use
    `define val catData = listItem.data` and leave the rest of the class unchanged.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在`CatViewHolder`中，由于一些Kotlin魔法，我们可以使用`define val catData = listItem.data`，并且保持类的其余部分不变。
- en: Having made those changes, we can now expect to see the `Happy Cats` and `Sad
    Cats` group titles, each followed by the relevant cats.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 做出这些更改后，我们现在可以期望看到“快乐的猫”和“悲伤的猫”组标题，每个标题后面跟着相关的猫。
- en: 'Exercise 6.04: Adding Titles to RecyclerView'
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.04：向RecyclerView添加标题
- en: 'We now want to be able to present our secret cat agents in two groups: active
    agents that are available for us to deploy to the field, and sleeper agents, which
    cannot currently be deployed. We will do that by adding a title above the active
    agents and another above the sleeper agents:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们希望能够在两个组中呈现我们的秘密猫特工：可部署到现场的活跃特工和目前无法部署的沉睡特工。我们将通过在活跃特工上方添加一个标题，并在沉睡特工上方添加另一个标题来实现这一点：
- en: Under `com.example.myrecyclerviewapp.model`, create a new Kotlin file called
    `ListItemUiModel`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ListItemUiModel`的新的Kotlin文件。
- en: 'Add the following to the `ListItemUiModel.kt` file, defining our two data types—titles
    and cats:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ListItemUiModel.kt`文件中添加以下内容，定义我们的两种数据类型——标题和猫：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Create a new Kotlin file in `com.example.myrecyclerviewapp` named `ListItemViewHolder`.
    This will be our base view holder.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.example.myrecyclerviewapp`中创建一个名为`ListItemViewHolder`的新的Kotlin文件。这将是我们的基本视图持有者。
- en: 'Populate the `ListItemViewHolder.kt` file with the following:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.example.myrecyclerviewapp.model`下，用以下内容填充`ListItemViewHolder.kt`文件。
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Open the `CatViewHolder.kt` file.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`CatViewHolder.kt`文件。
- en: 'Make `CatViewHolder` extend `ListItemViewHolder`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使`CatViewHolder`扩展`ListItemViewHolder`：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Replace the `bindData(CatUiModel)` parameter with `ListItemUiModel` and make
    it override the `ListItemViewHolder` abstract function:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`ListItemUiModel`替换`bindData(CatUiModel)`参数，并使其覆盖`ListItemViewHolder`的抽象函数：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add the following two lines to the top of the `bindData(ListItemUiModel)` function
    to enforce casting `ListItemUiModel` to `ListItemUiModel.Cat` and to fetch the
    cat data from it:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bindData(ListItemUiModel)`函数的顶部添加以下两行，以强制将`ListItemUiModel`转换为`ListItemUiModel.Cat`并从中获取猫数据：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Leave the rest of the file untouched.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 保持文件的其余部分不变。
- en: Create a new layout file. Name your layout `item_title`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的布局文件。将布局命名为`item_title`。
- en: 'Replace the default content of the newly created `item_title.xml` file with
    the following:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换新创建的`item_title.xml`文件的默认内容：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This new layout, containing only a `TextView` with a 16sp-sized bold font,
    will host our titles:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的布局只包含一个带有16sp大小的粗体字体的`TextView`，将承载我们的标题：
- en: '![Figure 6.11: Preview of the item_title.xml layout'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11：item_title.xml布局的预览'
- en: '](img/B15216_06_11.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_11.jpg)'
- en: 'Figure 6.11: Preview of the item_title.xml layout'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：item_title.xml布局的预览
- en: 'Implement `TitleViewHolder` in a new file with the same name under `com.example.myrecyclerviewapp`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.example.myrecyclerviewapp`下的同名文件中实现`TitleViewHolder`：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is very similar to `CatViewHolder`, but since we only set the text on `TextView`,
    it is also much simpler.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`CatViewHolder`非常相似，但由于我们只在`TextView`上设置文本，因此它也简单得多。
- en: Now, to make things tidier, select `CatViewHolder`, `ListItemViewHolder`, and
    `TitleViewHolder`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了使事情更整洁，选择`CatViewHolder`，`ListItemViewHolder`和`TitleViewHolder`。
- en: 'Move all the files to a new namespace: right-click on one of the files, and
    then select `Refactor` | `Move` (or press *F6*).'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有文件移动到新的命名空间：右键单击其中一个文件，然后选择`重构` | `移动`（或按*F6*）。
- en: Append `/viewholder` to the prefilled `To directory` field. Leave `Search references`
    and `Update package directive (Kotlin files)` checked and `Open moved files in
    editor` unchecked. Click `OK`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`/viewholder`附加到预填的`到目录`字段。保持`搜索引用`和`更新包指令（Kotlin文件）`选中，不选中`在编辑器中打开移动的文件`。单击`确定`。
- en: Open the `CatsAdapter.kt` file.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`CatsAdapter.kt`文件。
- en: Now, rename `CatsAdapter` to `ListItemsAdapter`. It is important to maintain
    the naming of variables, functions, and classes to reflect their actual usage
    to avoid future confusion. Right-click on the `CatsAdapter` class name in the
    code window, then select `Refactor` | `Rename` (or *Shift* + *F6*).
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`CatsAdapter`重命名为`ListItemsAdapter`。重命名变量，函数和类的命名以反映其实际用途是很重要的，以避免将来的混淆。在代码窗口中右键单击`CatsAdapter`类名，然后选择`重构`
    | `重命名`（或*Shift* + *F6*）。
- en: When `CatsAdapter` is highlighted, type `ListItemsAdapter` and press *Enter*.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`CatsAdapter`被突出显示时，键入`ListItemsAdapter`并按*Enter*。
- en: 'Change the adapter generic type to `ListItemViewHolder`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将适配器通用类型更改为`ListItemViewHolder`：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Update `listData` and `setData(List<CatUiModel>)` to handle `ListItemUiModel`
    instead:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`listData`和`setData(List<CatUiModel>)`以处理`ListItemUiModel`：
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Update `onBindViewHolder(CatViewHolder)` to comply with the adapter contract
    change:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`onBindViewHolder(CatViewHolder)`以符合适配器合同更改：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'At the top of the file, after the imports and before the class definition,
    add the view type constants:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部，在导入之后和类定义之前，添加视图类型常量：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Implement `getItemViewType(Int)` like so:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getItemViewType(Int)`如下：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Lastly, change your `onCreateViewHolder(ViewGroup, Int)` implementation, as
    follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更改您的`onCreateViewHolder(ViewGroup, Int)`实现如下：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Update `MainActivity` to populate the adapter with appropriate data, replacing
    the previous `catsAdapter.setData(List<CatUiModel>)` call. (Please note that the
    code below has been truncated for space. Refer to the link below to access the
    full code that you need to add.)
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`MainActivity`以使用适当的数据填充适配器，替换先前的`catsAdapter.setData(List<CatUiModel>)`调用。（请注意，以下代码已经被截断以节省空间。请参考下面的链接以访问您需要添加的完整代码。）
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Since `catsAdapter` is no longer holding `CatsAdapter` but `ListItemsAdapter`,
    rename it accordingly. Name it `listItemsAdapter`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`catsAdapter`不再持有`CatsAdapter`而是`ListItemsAdapter`，因此相应地进行重命名。将其命名为`listItemsAdapter`。
- en: 'Run the app. You should see something similar to the following:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。您应该看到类似以下的内容：
- en: '![Figure 6.12: RecyclerView with the Sleeper Agents/Active Agents header views'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12：带有休眠代理/活动代理标题视图的RecyclerView'
- en: '](img/B15216_06_12.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_12.jpg)'
- en: 'Figure 6.12: RecyclerView with the Sleeper Agents/Active Agents header views'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：带有休眠代理/活动代理标题视图的RecyclerView
- en: As you can see, we now have titles above our two agent groups. Unlike the `Our
    Agents` title, these titles will scroll with our content. Next, we will learn
    how to swipe an item to remove it from `RecyclerView`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在在两个代理组上方有标题。与`Our Agents`标题不同，这些标题将随内容滚动。接下来，我们将学习如何滑动项目以将其从`RecyclerView`中移除。
- en: Swiping to Remove Items
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滑动以删除项目
- en: In the previous sections, we learned how to present different view types. However,
    up until now, we have worked with a fixed list of items. What if you want to be
    able to remove items from the list? There are a few common mechanisms to achieve that—fixed
    delete buttons, swipe to delete, and long-click to select then a "click to delete"
    button, to name a few. In this section, we will focus on the "swipe to delete"
    approach.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的部分中，我们学习了如何呈现不同的视图类型。但是，直到现在，我们一直在使用固定的项目列表。如果您想要能够从列表中删除项目怎么办？有一些常见的机制可以实现这一点-固定的删除按钮，滑动删除，长按选择然后点击删除按钮等。在本节中，我们将专注于“滑动删除”方法。
- en: 'Let''s start by adding the deletion functionality to our adapter. To tell the
    adapter to remove an item, we need to indicate which item we want to remove. The
    simplest way to achieve this is by providing the position of the item. In our
    implementation, this will directly correlate to the position of the item in our
    `listData` list. So, our `removeItem(Int)` function should look like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先向我们的适配器添加删除功能。要告诉适配器删除一个项目，我们需要指示要删除的项目。实现这一点的最简单方法是提供项目的位置。在我们的实现中，这将直接对应于`listData`列表中项目的位置。因此，我们的`removeItem(Int)`函数应该如下所示：
- en: '[PRE56]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Just like when setting data, we need to notify `RecyclerView` that the dataset
    has changed—in this case, an item was removed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 就像设置数据时一样，我们需要通知`RecyclerView`数据集已更改-在这种情况下，已删除一个项目。
- en: Next, we need to define the swipe gesture detection. This is done by utilizing
    `ItemTouchHelper`. Now, `ItemTouchHelper` handles certain touch events, namely
    dragging and swiping, by reporting them to us via a callback. We handle these
    callbacks by implementing `ItemTouchHelper.Callback`. Also, `RecyclerView` provides
    `ItemTouchHelper.SimpleCallback`, which takes away the writing of a lot of boilerplate
    code.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义滑动手势检测。这是通过利用`ItemTouchHelper`来完成的。现在，`ItemTouchHelper`通过回调向我们报告某些触摸事件，即拖动和滑动。我们通过实现`ItemTouchHelper.Callback`来处理这些回调。此外，`RecyclerView`提供了`ItemTouchHelper.SimpleCallback`，它消除了大量样板代码的编写。
- en: 'We want to respond to swipe gestures but ignore move gestures. More specifically,
    we want to respond to swipes to the right. Moving is used to reorder items, which
    is beyond the scope of this chapter. So, our implementation of `SwipToDeleteCallback`
    will look as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望响应滑动手势，但忽略移动手势。更具体地说，我们希望响应向右滑动。移动用于重新排序项目，这超出了本章的范围。因此，我们的`SwipToDeleteCallback`的实现将如下所示：
- en: '[PRE57]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Because our implementation is tightly coupled to our adapter and its view types,
    we can comfortably define it as an inner class. The benefit we gain is the ability
    to directly call methods on the adapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的实现与我们的适配器及其视图类型紧密耦合，因此我们可以将其舒适地定义为内部类。我们获得的好处是能够直接在适配器上调用方法。
- en: As you can see, we return `false` from the `onMove(RecyclerView, ViewHolder,
    ViewHolder)` function. This means we ignore move events.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们从`onMove(RecyclerView, ViewHolder, ViewHolder)`函数中返回`false`。这意味着我们忽略移动事件。
- en: Next, we need to tell `ItemTouchHelper` which items can be swiped. We achieve
    this by overriding `getMovementFlags(RecyclerView, ViewHolder)`. This function
    is called when a user is about to start a drag or swipe gesture. `ItemTouchHelper`
    expects us to return the valid gestures for the provided view holder. We check
    the `ViewHolder` class, and if it is `CatViewHolder`, we want to allow swiping—otherwise,
    we do not. We use `makeMovementFlags(Int, Int)`, which is a helper function used
    to construct flags in a way that `ItemTouchHelper` can decipher them. Note that
    we define rules for `ACTION_STATE_IDLE`, which is the starting state of a gesture,
    thus allowing a gesture to start from the left or the right. We then combine it
    (using `or`) with the `ACTION_STATE_SWIPE` flags, allowing the ongoing gesture
    to swipe left or right. Returning `0` means neither swiping nor moving will occur
    for the provided view holder.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉`ItemTouchHelper`哪些项目可以被滑动。我们通过重写`getMovementFlags(RecyclerView, ViewHolder)`来实现这一点。当用户即将开始拖动或滑动手势时，将调用此函数。`ItemTouchHelper`希望我们返回所提供的视图持有者的有效手势。我们检查`ViewHolder`类，如果是`CatViewHolder`，我们希望允许滑动，否则不允许。我们使用`makeMovementFlags(Int,
    Int)`，这是一个帮助函数，用于以`ItemTouchHelper`可以解析的方式构造标志。请注意，我们为`ACTION_STATE_IDLE`定义了规则，这是手势的起始状态，因此允许手势从左侧或右侧开始。然后我们将其与`ACTION_STATE_SWIPE`标志结合起来（使用`or`），允许进行中的手势向左或向右滑动。返回`0`意味着对于所提供的视图持有者，既不会发生滑动也不会移动。
- en: Once a swipe action is completed, `onSwiped(ViewHolder, Int)` is called. We
    then obtain the position from the passed-in view holder by calling `adapterPosition`.
    Now, `adapterPosition` is important because it is the only reliable way to obtain
    the real position of the item presented by the view holder.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦滑动操作完成，将调用`onSwiped(ViewHolder, Int)`。然后，我们通过调用`adapterPosition`从传入的视图持有者中获取位置。现在，`adapterPosition`很重要，因为这是获取视图持有者呈现的项目的真实位置的唯一可靠方法。
- en: With the correct position, we can remove the item by calling `removeItem(Int)`
    on the adapter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有了正确的位置，我们可以通过在适配器上调用`removeItem(Int)`来移除项目。
- en: To expose our newly created `SwipeToDeleteCallback` implementation, we define
    a read-only variable within our adapter, namely `swipeToDeleteCallback`, and set
    it to a new instance of `SwipeToDeleteCallback`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了公开我们新创建的`SwipeToDeleteCallback`实现，我们在适配器中定义一个只读变量，即`swipeToDeleteCallback`，并将其设置为`SwipeToDeleteCallback`的新实例。
- en: 'Finally, to plug our `callback` mechanism to `RecyclerView`, we need to construct
    a new `ItemTouchHelper` and attach it to our `RecyclerView`. We should do this
    when setting up our `RecyclerView`, which we do in the `onCreate(Bundle?)` function
    of our main activity. This is how the creation and attaching will look:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了将我们的`callback`机制插入`RecyclerView`，我们需要构造一个新的`ItemTouchHelper`并将其附加到我们的`RecyclerView`上。我们应该在设置我们的`RecyclerView`时执行此操作，我们在主活动的`onCreate(Bundle?)`函数中执行此操作。这是创建和附加的方式：
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We can now swipe items to remove them from the list. Note how our titles cannot
    be swiped, just as we intended.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以滑动项目以将其从列表中移除。请注意，我们的标题无法被滑动，这正是我们想要的。
- en: 'You may have noticed a small glitch: the last item is cut off as it animates
    up. This is happening because `RecyclerView` shrinks to accommodate the new (smaller)
    number of items before the animation starts. A quick fix to this would be to fix
    the height of our `RecyclerView` by confining its bottom to the bottom of its
    parent.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到一个小故障：在动画向上播放时，最后一个项目被切断了。这是因为`RecyclerView`在动画开始之前会缩小以适应新的（较小）项目数量。快速修复这个问题的方法是通过将其底部限制在其父级的底部来固定我们的`RecyclerView`的高度。
- en: 'Exercise 6.05: Adding Swipe to Delete Functionality'
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.05：添加滑动删除功能
- en: 'We previously added `RecyclerView` to our app and then added items of different
    types to it. We will now allow users to delete some items (we want to let the
    users remove secret cat agents, but not titles) by swiping them left or right:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前向我们的应用程序添加了`RecyclerView`，然后向其中添加了不同类型的项目。现在，我们将允许用户通过向左或向右滑动来删除一些项目（我们希望让用户删除秘密猫特工，但不是标题）：
- en: 'To add item removal functionality to our adapter, add the following function
    to `ListItemsAdapter` right after the `setData(List<ListItemUiModel>)` function:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向我们的适配器添加项目移除功能，请在`setData(List<ListItemUiModel>)`函数之后添加以下函数到`ListItemsAdapter`中：
- en: '[PRE59]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, right before the closing curly bracket of your `ListItemsAdapter` class,
    add the following `callback` implementation to handle the user swiping a cat agent
    left or right:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在您的`ListItemsAdapter`类的闭合大括号之前，添加以下`callback`实现，以处理用户向左或向右滑动猫特工的操作：
- en: '[PRE60]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We have implemented an `ItemTouchHelper.SimpleCallback` instance, passing in
    the directions we were interested in—`LEFT` and `RIGHT`. Joining the values is
    achieved by using the `or` Boolean operator.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个`ItemTouchHelper.SimpleCallback`实例，传入我们感兴趣的方向——`LEFT`和`RIGHT`。通过使用`or`布尔运算符来连接这些值。
- en: We have overridden the `getMovementFlags` function to make sure we have only
    handled swiping on a cat agent view, not a title. Creating flags for both `ItemTouchHelper.ACTION_STATE_SWIPE`
    and `ItemTouchHelper.ACTION_STATE_IDLE` allows us to intercept both swipe and
    release events, respectively.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重写了`getMovementFlags`函数，以确保我们只处理猫代理视图上的滑动，而不是标题。为`ItemTouchHelper.ACTION_STATE_SWIPE`和`ItemTouchHelper.ACTION_STATE_IDLE`分别创建标志，允许我们拦截滑动和释放事件。
- en: Once a swipe is completed (the user has lifted their finger from the screen),
    `onSwiped` will be called, and in response, we remove the item at the position
    provided by the dragged view holder.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦滑动完成（用户从屏幕上抬起手指），`onSwiped`将被调用，作为响应，我们将删除拖动视图持有者提供的位置处的项目。
- en: 'At the top of your adapter, expose an instance of the `SwipeToDeleteCallback`
    class you just created:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的适配器顶部，暴露刚刚创建的`SwipeToDeleteCallback`类的一个实例：
- en: '[PRE61]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Lastly, tie it all together by implementing `ItemViewHelper` and attaching
    it to our `RecyclerView`. Add the following code to the `onCreate(Bundle?)` function
    of your `MainActivity` file right after assigning the layout manager to your adapter:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过实现`ItemViewHelper`并将其附加到我们的`RecyclerView`来将所有内容绑定在一起。在为适配器分配布局管理器之后，将以下代码添加到`MainActivity`文件的`onCreate(Bundle?)`函数中：
- en: '[PRE62]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To address the small visual glitch you would get when items are removed, scale
    `RecyclerView` to fit the screen by updating the code in `activity_main.xml`,
    as follows. The changes are in `RecyclerView` tag, right before the `app:layout_constraintTop_toBottomOf`
    attribute:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决当项目被移除时会出现的小视觉故障，通过更新`activity_main.xml`中的代码来缩放`RecyclerView`以适应屏幕。更改在`RecyclerView`标签中，在`app:layout_constraintTop_toBottomOf`属性之前：
- en: '[PRE63]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Run your app. You should now be able to swipe secret cat agents left or right
    to remove them from the list. Note that `RecyclerView` handles the collapsing
    animation for us:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用。现在你应该能够向左或向右滑动秘密猫代理，将它们从列表中移除。请注意，`RecyclerView`会为我们处理折叠动画：
- en: '![Figure 6.14: A cat being swiped to the right'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.14：一只猫被向右滑动'
- en: '](img/B15216_06_14.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_14.jpg)'
- en: 'Figure 6.14: A cat being swiped to the right'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14：一只猫被向右滑动
- en: Note how even though titles are item views, they cannot be swiped. You have
    implemented a callback for swiping gestures that distinguishes between different
    item types and responds to a swipe by deleting the swiped item. Now we know how
    to remove items interactively. Next, we will learn how to add new items as well.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使标题是项目视图，它们也不能被滑动。您已经实现了一个用于滑动手势的回调，它区分不同的项目类型，并通过删除被滑动的项目来响应滑动。现在我们知道如何交互地移除项目。接下来，我们将学习如何添加新项目。
- en: Adding Items Interactively
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式添加项目
- en: We have just learned how to remove items interactively. What about adding new
    items? Let's look into it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学会了如何交互地移除项目。那么添加新项目呢？让我们来看看。
- en: 'Similar to the way we implemented the removal of items, we start by adding
    a function to our adapter:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们实现移除项目的方式类似，我们首先向适配器添加一个函数：
- en: '[PRE64]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You will notice that the implementation is very similar to the `removeItem(Int)`
    function we implemented earlier. This time, we also receive an item to add and
    a position to add it. We then add it to our `listData` list and notify `RecyclerView`
    that we added an item in the requested position.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，这个实现与我们之前实现的`removeItem(Int)`函数非常相似。这一次，我们还收到要添加的项目和要添加的位置。然后我们将它添加到我们的`listData`列表中，并通知`RecyclerView`我们在请求的位置添加了一个项目。
- en: 'To trigger a call to `addItem(Int, ListItemUiModel)`, we could add a button
    to our main activity layout. This button could be as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发对`addItem(Int, ListItemUiModel)`的调用，我们可以在我们的主活动布局中添加一个按钮。这个按钮可以是这样的：
- en: '[PRE65]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The app will now look like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 应用现在看起来是这样的：
- en: '![Figure 6.15: The main layout with a button to add a cat'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.15：主布局，带有一个添加猫的按钮'
- en: '](img/B15216_06_15.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_15.jpg)'
- en: 'Figure 6.15: The main layout with a button to add a cat'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：主布局，带有一个添加猫的按钮
- en: Don't forget to update your `RecyclerView` so that its bottom will be constrained
    to the top of this button. Otherwise, the button and `RecyclerView` will overlap.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更新您的`RecyclerView`，以便其底部将受到此按钮顶部的约束。否则，按钮和`RecyclerView`将重叠。
- en: In a production app, you could add a rationale around what a new item would
    be. For example, you could have a form for the user to fill in different details.
    For the sake of simplicity, in our example, we will always add the same dummy
    item—an anonymous female secret cat agent.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产应用中，您可以添加关于新项目的理由。例如，您可以为用户填写不同的细节提供一个表单。为了简单起见，在我们的示例中，我们将始终添加相同的虚拟项目——一个匿名的女性秘密猫代理。
- en: 'To add the item, we set `OnClickListener` on our button:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加项目，我们在我们的按钮上设置`OnClickListener`：
- en: '[PRE66]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: And that is it. We add the item at position 1 so that it is added right below
    our first title, which is the item at position 0\. In a production app, you could
    have logic to determine the correct place to insert an item. It could be below
    the relevant title or always be added at the top, bottom, or in the correct place
    to preserve some existing order.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们在位置1添加项目，这样它就会添加在我们的第一个标题下面，也就是位置0的项目。在生产应用中，您可以有逻辑来确定插入项目的正确位置。它可以在相关标题下方，或者始终添加在顶部、底部，或者在正确的位置以保留一些现有的顺序。
- en: We can now run the app. We will now have a new `Add A Cat` button. Every time
    we click the button, an anonymous secret cat agent will be added to `RecyclerView`.
    The newly added cats can be swiped away to be removed, just like the hardcoded
    cats before them.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行应用程序。现在我们将有一个新的“添加猫”按钮。每次点击按钮时，一个匿名的秘密猫代理将被添加到`RecyclerView`中。新添加的猫可以被滑动移除，就像它们之前的硬编码猫一样。
- en: 'Exercise 6.06: Implementing an "Add A Cat" Button'
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.06：实现一个“添加猫”按钮
- en: 'Having implemented a mechanism to remove items, it is time we implemented a
    mechanism to add items:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了删除项目的机制之后，现在是时候实现添加项目的机制了：
- en: 'Add a function to `ListItemsAdapter` to support adding items. Add it below
    the `removeItem(Int)` function:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`ListItemsAdapter`添加一个支持添加项目的函数。将其添加到`removeItem(Int)`函数下面：
- en: '[PRE67]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Add a button to `activity_main.xml`, right after `RecyclerView` tag:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`activity_main.xml`中添加一个按钮，就在`RecyclerView`标签后面：
- en: '[PRE68]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You will notice that `android:text="Add A Cat"` is highlighted. If you hover
    your mouse over it, you will see that this is because of the hardcoded string.
    Click on the `Add` word to place the editor cursor over it.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到`android:text="Add A Cat"`被突出显示。如果您将鼠标悬停在上面，您会发现这是因为硬编码的字符串。点击`Add`单词将编辑光标放在上面。
- en: Press *Option* + *Enter* (iOS) or *Alt* + *Enter* (Windows) to show the context
    menu, then *Enter* again to show the `Extract Resource` dialog.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Option* + *Enter*（iOS）或*Alt* + *Enter*（Windows）显示上下文菜单，然后再次按*Enter*显示“提取资源”对话框。
- en: Name the resource `add_button_label`. Press `OK`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将资源命名为`add_button_label`。按下“确定”。
- en: 'To change the bottom constraint on `RecyclerView` so that the button and `RecyclerView`
    do not overlap, within your `RecyclerView` tag, locate the following:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`RecyclerView`上的底部约束，以便按钮和`RecyclerView`不重叠，在`RecyclerView`标签内部，找到以下内容：
- en: '[PRE69]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Replace it with the following line of code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码行替换它：
- en: '[PRE70]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add a lazy field holding a reference to the button at the top of the class,
    right after the definition of `recyclerView`:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部添加一个引用按钮的惰性字段，就在`recyclerView`的定义之后：
- en: '[PRE71]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Notice `addItemButton` is defined as a View. This is because in our code we
    don't need to know the type of View to add a click listener to it. Choosing the
    more abstract type allows us to later change the type of the view in the layout
    without having to modify this code.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`addItemButton`被定义为一个View。这是因为在我们的代码中，我们不需要知道View的类型来为其添加点击监听器。选择更抽象的类型允许我们以后更改布局中视图的类型，而无需修改此代码。
- en: 'Lastly, update `MainActivity` to handle the click. Find the line that says
    the following:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新`MainActivity`以处理点击。找到以下内容的行：
- en: '[PRE72]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Right after it, add the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，添加以下内容：
- en: '[PRE73]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This will add a new item to `RecyclerView` every time the button is clicked.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在每次点击按钮时向`RecyclerView`添加一个新项目。
- en: 'Run the app. You should see a new button at the bottom of your app:![Figure
    6.16: An anonymous cat is added with the click of a button'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。您应该在应用程序底部看到一个新按钮：![图6.16：点击按钮添加一个匿名猫
- en: '](img/B15216_06_16.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_16.jpg)'
- en: 'Figure 6.16: An anonymous cat is added with the click of a button'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16：点击按钮添加一个匿名猫
- en: Try clicking it a few times. Every time you click it, a new anonymous secret
    cat agent is added to your `RecyclerView`. You can swipe away the newly added
    cats just like you could the hardcoded ones.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试点击几次。每次点击时，都会向您的`RecyclerView`添加一个新的匿名秘密猫特工。您可以像删除硬编码的猫一样滑动删除新添加的猫。
- en: In this exercise, you added new items to `RecyclerView` in response to user
    interaction. You now know how to change the contents of `RecyclerView` at runtime.
    It is useful to know how to update lists at runtime because quite often, the data
    you are presenting to your users changes while the app is running, and you want
    to present your users with a fresh, up-to-date state.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您通过用户交互向`RecyclerView`添加了新项目。您现在知道如何在运行时更改`RecyclerView`的内容。了解如何在运行时更新列表很有用，因为在应用程序运行时，您向用户呈现的数据经常会发生变化，您希望向用户呈现一个新鲜、最新的状态。
- en: 'Activity 6.01: Managing a List of Items'
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动6.01：管理项目列表
- en: Imagine you want to develop a recipe management app. Your app would support
    sweet and savory recipes. Users of your app could add new sweet or savory recipes,
    scroll through the list of added recipes—grouped by flavor (sweet or savory)—click
    a recipe to get information about it, and finally, they could delete recipes by
    swiping them aside.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您想开发一个食谱管理应用程序。您的应用程序将支持甜食和咸食食谱。您的应用程序的用户可以添加新的甜食或咸食食谱，浏览已添加的食谱列表（按口味分组为甜食或咸食），点击食谱以获取有关它的信息，最后，他们可以通过滑动将食谱删除。
- en: The aim of this activity is to create an app with `RecyclerView` that lists
    the title of recipes, grouped by flavor. `RecyclerView` will support user interaction.
    Each recipe will have a title, a description, and a flavor. Interactions will
    include clicks and swipes. A click will present the user with a dialog showing
    the description of the recipe. A swipe will remove the swiped recipe from the
    app. Finally, with two `EditText` fields (see *Chapter 3, Screens and UI*) and
    two buttons, the user can add a new sweet or savory recipe, respectively, with
    the title and description set to the values set in the `EditText` fields.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的目的是创建一个带有`RecyclerView`的应用程序，列出食谱的标题，按口味分组。`RecyclerView`将支持用户交互。每个食谱都将有一个标题、一个描述和一个口味。交互将包括点击和滑动。点击将向用户显示一个对话框，显示食谱的描述。滑动将从应用程序中删除已滑动的食谱。最后，通过两个`EditText`字段（参见*第3章，屏幕和UI*）和两个按钮，用户可以分别添加新的甜食或咸食食谱，标题和描述设置为`EditText`字段中设置的值。
- en: 'The steps to complete are as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的步骤如下：
- en: Create a new empty activity app.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空活动应用程序。
- en: Add `RecyclerView` support to the app's `build.gradle` file.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的`build.gradle`文件中添加`RecyclerView`支持。
- en: 'Add `RecyclerView`, two `EditText` fields, and two buttons to the main layout.
    Your layout should look something like this:![Figure 6.17: Layout with RecyclerView,
    two EditText fields, and two buttons'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主布局中添加`RecyclerView`、两个`EditText`字段和两个按钮。您的布局应该看起来像这样：![图6.17：带有RecyclerView、两个EditText字段和两个按钮的布局
- en: '](img/B15216_06_17.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_17.jpg)'
- en: 'Figure 6.17: Layout with RecyclerView, two EditText fields, and two buttons'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：带有RecyclerView、两个EditText字段和两个按钮的布局
- en: Add models for flavor titles and recipes, and an enum for flavor.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为口味标题和食谱添加模型，并为口味添加枚举。
- en: Add a layout for flavor titles.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个口味标题的布局。
- en: Add a layout for recipe titles.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为食谱标题添加一个布局。
- en: Add view holders for flavor titles and recipe titles, as well as an adapter.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为口味标题和食谱标题添加视图持有者，以及一个适配器。
- en: Add click listeners to show a dialog with recipe descriptions.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加点击监听器以显示带有食谱描述的对话框。
- en: Update `MainActivity` to construct the new adapter and hook up the buttons for
    adding new savory and sweet recipes. Make sure the form is cleared after the recipe
    is added.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`MainActivity`以构建新的适配器并连接按钮，用于添加新的咸味和甜味食谱。确保在添加食谱后清除表单。
- en: Add a swipe helper to remove items.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个滑动助手来移除项目。
- en: 'The final output will be as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出如下：
- en: '![Figure 6.18: The Recipe Book app'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.18：食谱书应用'
- en: '](img/B15216_06_18.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_06_18.jpg)'
- en: 'Figure 6.18: The Recipe Book app'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18：食谱书应用
- en: Note
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在以下网址找到：http://packt.live/3sKj1cp
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we learned how to add `RecyclerView` to our project. We also
    learned how to add it to our layout and how to populate it with items. We went
    through adding different item types, which is particularly useful for titles.
    We covered interaction with `RecyclerView`: responding to clicks on individual
    items and responding to swipe gestures. Lastly, we learned how to dynamically
    add and remove items to and from `RecyclerView`. The world of `RecyclerView` is
    very rich, and we have only scratched the surface. Going further would be beyond
    the scope of this book. However, it is strongly recommended that you investigate
    it on your own so that you can have carousels, designed dividers, and fancier
    swipe effects in your apps. You could start your exploration here: [https://awesomeopensource.com/projects/recyclerview-adapter](https://awesomeopensource.com/projects/recyclerview-adapter).'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将`RecyclerView`添加到我们的项目中。我们还学习了如何将其添加到我们的布局中，并如何用项目填充它。我们介绍了添加不同类型的项目，这对于标题特别有用。我们涵盖了与`RecyclerView`的交互：响应单个项目的点击和响应滑动手势。最后，我们学习了如何动态地向`RecyclerView`添加和删除项目。`RecyclerView`的世界非常丰富，我们只是触及了表面。进一步的探索将超出本书的范围。然而，强烈建议您自行调查，以便在应用程序中拥有旋转木马、设计分隔线和更花哨的滑动效果。您可以从这里开始您的探索：[https://awesomeopensource.com/projects/recyclerview-adapter](https://awesomeopensource.com/projects/recyclerview-adapter)。
- en: In the next chapter, we will look into requesting special permissions on behalf
    of our app to enable performing certain tasks, such as accessing the user's contacts
    list or their microphone. We will also look into using Google's Maps API and accessing
    the user's physical location.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨代表我们的应用程序请求特殊权限，以便执行某些任务，例如访问用户的联系人列表或其麦克风。我们还将研究如何使用谷歌的地图API和访问用户的物理位置。
