- en: UI Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI设计
- en: The one feature that stands out in Android Studio above all others, including
    the Gradle build system, is the powerful **User Interface**(**UI**) development
    tools. The IDE provides a variety of views of our designs, allowing us to combine
    drag and drop construction and hard code in the development of a UI. Android Studio
    also comes equipped with a comprehensive preview system, which allows us to test
    our designs on any manner of device before running the project on an actual device.
    Along with these features, Android Studio also includes useful support libraries,
    such as the design library for creating material design layouts and the Percent
    Support Library for simplifying complex, proportional designs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio中最突出的一个特性，包括Gradle构建系统在内，就是强大的用户界面（UI）开发工具。该IDE提供了多种设计视图，允许我们在UI开发中结合拖放构建和硬编码。Android
    Studio还配备了全面的预览系统，可以让我们在实际设备上运行项目之前在任何设备上测试我们的设计。除了这些功能，Android Studio还包括有用的支持库，如用于创建材料设计布局的设计库和用于简化复杂比例设计的百分比支持库。
- en: This chapter is the first of four, covering UI development. In it, we take a
    closer look at Studio's Layout Editors and tools. We will be building working
    interfaces using each of the most useful Layout/ViewGroup classes and designing
    for and managing screen rotation. The chapter continues by exploring Studio's
    preview system and how XML layout resources are stored and applied. The chapter
    concludes by returning to themes, Material Design, and the design support library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是四章中的第一章，涵盖了UI开发。在这一章中，我们将更仔细地研究Studio的布局编辑器和工具。我们将使用最有用的布局/ViewGroup类构建工作界面，并设计和管理屏幕旋转。本章还将探讨Studio的预览系统以及XML布局资源的存储和应用。最后，本章将回顾主题、材料设计和设计支持库。
- en: 'In this chapter, you will learn how to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何：
- en: Explore the Layout Editor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索布局编辑器
- en: Apply linear and relative layouts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用线性和相对布局
- en: Install the constraint library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装约束库
- en: Create a `ConstraintLayout`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`ConstraintLayout`
- en: Apply constraints
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用约束
- en: Use the graphical constraints editor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图形约束编辑器
- en: Add constraint guidelines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加约束指南
- en: Align `TextView` baselines
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对齐`TextView`基线
- en: Apply bias
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用偏差
- en: Use auto-connect
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动连接
- en: Build a hardware profile for a virtual device
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为虚拟设备构建硬件配置文件
- en: Create a virtual SD card
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建虚拟SD卡
- en: The Layout Editor
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局编辑器
- en: 'If there were only one reason to use Android Studio, it would be the Layout
    Editor and its associated tools and preview system. The differences are apparent
    as soon as you open a project. The difference between layout and blueprint view
    is also shown in the following figure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个理由使用Android Studio，那就是布局编辑器及其相关工具和预览系统。一旦打开一个项目，差异就显而易见。布局和蓝图视图之间的差异也在下图中显示：
- en: '![](img/6d69c83c-2fb0-4383-a0c0-689c018bdb3c.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d69c83c-2fb0-4383-a0c0-689c018bdb3c.png)'
- en: The design and blueprint layout views
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和蓝图布局视图
- en: The **blueprint mode** is new to Android Studio 2.0 and portrays a simplified,
    outlined view of our UI. This is particularly useful when it comes to editing
    the spacing and proportions of complex layouts without the distraction of content.
    By default, the IDE displays both design and blueprint views side by side, but
    the editor's own toolbar allows us to view only one, and in most cases one would
    select the mode most suitable to the task in hand.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图模式是Android Studio 2.0的新功能，它展示了我们UI的简化轮廓视图。在编辑复杂布局的间距和比例时，这是特别有用的，而不会受到内容的干扰。默认情况下，IDE会并排显示设计和蓝图视图，但编辑器的工具栏允许我们只查看一个视图，在大多数情况下，我们会选择最适合当前任务的模式。
- en: The *B* key can be used to toggle between design, blueprint, and combined views
    as an alternative to the toolbar icons.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*B*键可用于在设计、蓝图和组合视图之间切换，作为工具栏图标的替代方法。'
- en: It would be perfectly possible to generate every layout required for a project
    using these graphical views without any knowledge of the underlying code. This
    is not a very professional approach though, and a good understanding of the XML
    under the hood is essential for good testing and debugging and, if we know what
    we are doing, very often tweaking the code is faster than dragging and dropping
    objects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以使用这些图形视图为项目生成所需的每个布局，而不需要了解底层代码。不过，这并不是一个非常专业的方法，了解底层XML的知识对于良好的测试和调试至关重要，而且如果我们知道自己在做什么，通常调整代码比拖放对象更快。
- en: 'The XML responsible for the previous layout is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 负责前一个布局的XML如下：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Hopefully, the terms used in the preceding code will be familiar to you. The
    use of `layout_weight` is frequently used with linear layouts to assign proportion,
    a great time saver when developing for screens with slightly different aspect
    ratios.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您对前面代码中使用的术语很熟悉。`layout_weight`的使用经常与线性布局一起使用，用于分配比例，在开发具有略有不同纵横比的屏幕时节省了大量时间。
- en: Until recently, the only choice we had for creating more complex UIs were the
    linear and relative layouts. Both of these are less than ideal, being either unnecessarily
    expensive or fiddly. Android Studio 2 introduced the constraint layout, which
    offers an elegant solution to these problems. To best appreciate its value, it
    makes sense here to first take a look at the older classes, which still have their
    place in many simpler designs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，我们创建更复杂UI的唯一选择是线性和相对布局。这两种布局都不是理想的选择，要么是不必要的昂贵，要么是琐碎的。Android Studio 2引入了约束布局，为这些问题提供了一个优雅的解决方案。为了更好地理解其价值，首先看一下旧的类是有意义的，这些类在许多简单的设计中仍然有用。
- en: Linear and relative layout classes
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性和相对布局类
- en: 'The linear layout is relatively lightweight and very useful for layouts based
    on single rows or columns. However, more complex layouts require nesting layouts
    inside each other and this very quickly becomes resource hungry. Take a look at
    the following layout:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 线性布局相对较轻，对于基于单行或单列的布局非常有用。然而，更复杂的布局需要在彼此内部嵌套布局，这很快就会变得资源密集。看一下下面的布局：
- en: '![](img/d483da95-3c6d-4df7-920f-e12192336edc.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d483da95-3c6d-4df7-920f-e12192336edc.png)'
- en: Nested linear layouts
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套线性布局
- en: 'The preceding layout was built using only linear layouts, as can be seen from
    the following Component Tree:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的布局只使用了线性布局，可以从以下组件树中看到：
- en: '![](img/76d6e913-677d-4b6b-aa83-4b253436db6d.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76d6e913-677d-4b6b-aa83-4b253436db6d.png)'
- en: The component tree
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 组件树
- en: Although perfectly workable and easy to understand, this layout is not as efficient
    as it could be. Even a single extra layer of layout nesting will have an impact
    on performance. Prior to the constraint layout, this problem was solved with the
    relative layout.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种布局完全可行且易于理解，但它的效率不如可能。即使是一个额外的布局嵌套层也会对性能产生影响。在约束布局出现之前，这个问题是通过相对布局解决的。
- en: 'As the name suggests, the relative layout allows us to place screen components
    in relation to each other, using markup such as `layout_toStartOf` or `layout_below`.
    This allows us to flatten view hierarchies and the preceding layout could be recreated
    with just one single relative, root viewgroup. The following code demonstrates
    how the row of images in the previous layout can be generated without nesting
    any new layouts:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，相对布局允许我们将屏幕组件放置在彼此之间的关系中，使用诸如`layout_toStartOf`或`layout_below`之类的标记。这使我们能够扁平化视图层次结构，并且前面的布局可以仅使用一个单独的相对根视图组来重新创建。以下代码演示了如何在不嵌套任何新布局的情况下生成前一个布局中的图像行：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Even if you are new to Android Studio, it is assumed that you will be familiar
    with linear and relative layouts. It is less likely that you will have encountered
    the constraint layout, which has been especially developed for Studio to alleviate
    the shortcomings of these older approaches.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您是Android Studio的新手，也假定您熟悉线性布局和相对布局。您可能不太可能遇到约束布局，它是专门为Studio开发的，以弥补这些旧方法的缺点。
- en: In the previous examples, we used `app:srcCompat` as opposed to `android:src`.
    This is not strictly required here, but if we wished to apply any tinting to the
    image and hope to distribute the app for older Android versions, this choice will
    enable that.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了`app:srcCompat`而不是`android:src`。这在这里并不是严格要求的，但如果我们希望对图像应用任何着色并希望将应用程序分发给较旧的Android版本，这个选择将使这成为可能。
- en: The constraint layout
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束布局
- en: The constraint layout is similar to the relative layout, in that it allows us
    to generate complex layouts without having to create memory sapping, view group
    hierarchies. Android Studio makes creating such layouts far easier, because it
    provides a visual editor that enables us to drag and drop not only screen components,
    but also their connections. Being able to experiment with layout structures so
    easily provides us with a great sandbox environment to  develop new layouts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 约束布局类似于相对布局，它允许我们生成复杂的布局，而无需创建占用内存的视图组层次结构。Android Studio使得创建这样的布局变得更加容易，因为它提供了一个可视化编辑器，使我们不仅可以拖放屏幕组件，还可以拖放它们的连接。能够如此轻松地尝试布局结构为我们提供了一个很好的沙盒环境，用于开发新的布局。
- en: The following exercise will take you through the process of installing the constraint
    library so that you can begin experimenting yourself.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习将带您完成安装约束库的过程，以便您可以开始自己进行实验。
- en: 'As of Android Studio 3.0 the `ConstraintLayout` is downloaded by default, but
    if you want to update an earlier project, you will need to open the SDK manager.
    The ConstraintLayout and constraint solver can both be found under the SDK Tools
    tab, as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Android Studio 3.0开始，默认情况下会下载`ConstraintLayout`，但如果要更新早期项目，则需要打开SDK管理器。约束布局和约束求解器都可以在SDK工具选项卡下找到，如下所示：
- en: '![](img/42d28968-df7b-4f04-8a7e-afc6f001b10c.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42d28968-df7b-4f04-8a7e-afc6f001b10c.png)'
- en: The constraint layout API
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 约束布局API
- en: Check the Show Package Details box and make a note of the version number as
    this will be required shortly.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选显示包详细信息框，并记下版本号，因为这很快将需要。
- en: Next, add the `ConstraintLayout` library to our dependencies. The simplest way
    to do this is selecting your module and then the Dependencies tab of the Project
    Structure dialog, which can be accessed from the File menu.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`ConstraintLayout`库添加到我们的依赖项中。最简单的方法是选择您的模块，然后选择项目结构对话框的依赖项选项卡，该对话框可以从文件菜单中访问。
- en: The constraint library can be found by clicking on the + button and then 1 Library
    dependency and selecting it from the list.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击+按钮，然后选择1 Library dependency并从列表中选择约束库。
- en: Finally, synchronize your project from the toolbar, the build menu, or *Ctrl*
    + *Alt* + *Y*.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从工具栏、构建菜单或*Ctrl* + *Alt* + *Y*同步您的项目。
- en: 'This is the simplest way to add module dependencies, but it is always good
    as developers to understand what is going on under the hood. In this case, we
    could have added the library manually by opening the module level `build.gradle`
    file and adding the following, highlighted text to the `dependencies` node:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是添加模块依赖项的最简单方法，但作为开发人员了解底层发生的事情总是很好。在这种情况下，我们可以通过打开模块级`build.gradle`文件并将以下突出显示的文本添加到`dependencies`节点来手动添加库：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Those of you that have developed with the relative layout will be familiar with
    commands such as `layout_toRightOf` or `layout_toTopOf`. These attributes can
    still be applied to a `ConstraintLayout`, but there are more. In particular, the
    `ConstraintLayout` allows us to position views based on individual sides, for
    example `layout_constraintTop_toBottomOf `, which aligns the top of our view to
    the bottom of the one specified.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那些使用相对布局开发的人将熟悉诸如`layout_toRightOf`或`layout_toTopOf`之类的命令。这些属性仍然可以应用于`ConstraintLayout`，但还有更多。特别是，`ConstraintLayout`允许我们基于单个边来定位视图，例如`layout_constraintTop_toBottomOf`，它将我们的视图的顶部与指定视图的底部对齐。
- en: 'Useful documentation on these attributes can be found at: [developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html](https://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些属性的有用文档可以在以下网址找到：[developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html](https://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html)。
- en: Creating a ConstraintLayout
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建约束布局
- en: 'There are two ways to create a ConstraintLayout. The first is to convert an
    existing layout to a ConstraintLayout, which can be done by right-clicking on
    the layout in either the component tree or the graphical editor and selecting
    the convert option. You will be presented with the following dialog:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以创建ConstraintLayout。第一种是将现有布局转换为ConstraintLayout，可以通过右键单击组件树或图形编辑器中的布局，然后选择转换选项来完成。然后会出现以下对话框：
- en: '![](img/2333857b-14b5-4d2d-a0f7-65c57f242b5a.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2333857b-14b5-4d2d-a0f7-65c57f242b5a.png)'
- en: The Convert to ConstraintLayout dialog
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为ConstraintLayout对话框
- en: It is usually best to check both these options, but it is worth noting that
    these conversions will not always produce the desired results and often view dimensions
    will require a little tweaking to faithfully reproduce the original.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好同时检查这两个选项，但值得注意的是，这些转换并不总是会产生期望的结果，通常视图尺寸需要进行一些微调才能忠实地复制原始布局。
- en: When it works, the previous approach provides a fast solution, but if we are
    to master the topic, we need to know how to create constraint layouts from scratch.
    This is particularly important as once we have become familiar with the working
    of the constraint layout; we will see that it is by far the easiest and most flexible
    way to design our interfaces.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当它起作用时，以前的方法提供了一个快速的解决方案，但是如果我们要掌握这个主题，我们需要知道如何从头开始创建约束布局。这一点特别重要，因为一旦我们熟悉了约束布局的工作方式，我们将会发现这是设计界面最简单、最灵活的方式。
- en: The `ConstraintLayout` is so well incorporated with the Layout Editor, that
    it is perfectly possible to design any layout we choose without ever having to
    write any XML. However, here we will be looking closely at both the graphical
    and textual perspectives, so as to develop a deeper understanding of the technology.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ConstraintLayout与布局编辑器完美结合，可以设计任何布局而无需编写任何XML。然而，我们将密切关注图形和文本两个方面，以便更深入地了解这项技术。
- en: 'You can create a fresh `ConstraintLayout` from the `res/layout` directory in
    project explorer''s context-sensitive menu as a New | Layout resource file with
    the following root element:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从项目资源管理器的上下文菜单中的res/layout目录中创建一个新的ConstraintLayout，作为一个具有以下根元素的新布局资源文件：
- en: '![](img/d2bc3fc1-d778-434b-8134-c7b5315cb046.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2bc3fc1-d778-434b-8134-c7b5315cb046.png)'
- en: Adding a new ConstraintLayout
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的ConstraintLayout
- en: 'This will produce the XML shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下XML：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As with other layout types, the constraint layer provides mechanisms for positioning
    and aligning the views and widgets within it. This is done largely through the
    use of handles that can be positioned graphically to size and align our views.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他布局类型一样，约束层提供了在其中定位和对齐视图和小部件的机制。这主要通过可以在图形上定位以调整大小和对齐视图的手柄来完成。
- en: Applying constraints
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用约束
- en: 'The best way to see how this works is to try it, as these few simple steps
    will demonstrate. Create a `ConstraintLayout` as described previously and drag
    and drop one or two views or widgets from the palette onto the blueprint screen,
    similar to following figure:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 了解其工作原理的最佳方法是尝试一下，这几个简单的步骤将进行演示。按照前面描述的方式创建ConstraintLayout，并从调色板拖放一个或两个视图或小部件到蓝图屏幕上，类似于以下图示：
- en: '![](img/34893a39-2340-4710-ae6c-9b7b94addbed.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34893a39-2340-4710-ae6c-9b7b94addbed.png)'
- en: Constraint handles
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 约束手柄
- en: Each view has constraint handles on its corners and its sides. Those on the
    corners are for simply resizing a view in the way that we are all familiar with.
    Those along the sides, however, are used to create constraints. These position
    views are relative to their parents or each other in a way that is not dissimilar
    to the relative layout.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图的角落和边上都有约束手柄。角落上的手柄用于简单地调整视图的大小，而边上的手柄用于创建约束。这些位置视图是相对于其父级或彼此的，与相对布局并没有太大不同。
- en: As this is largely a graphical form of editing, it is best demonstrated by action.
    Drag the left side anchor point of one of your views toward the left side of the
    layout and release the mouse button as prompted to create a parent constraint.
    This being a layout that contains others will be a parent constraint.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这主要是一种图形形式的编辑，最好通过操作来进行演示。将视图的左侧锚点拖向布局的左侧，并按照提示释放鼠标按钮以创建父约束。这是一个包含其他内容的布局，将成为父约束。
- en: As you experiment with constraints, you will notice how the margins automatically
    stick to those values recommended by the creative design guidelines.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试使用约束时，您会注意到边距会自动粘附到创意设计指南推荐的值。
- en: 'If you now open the text editor, you will see the constraint realized like
    so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在打开文本编辑器，您将看到约束如下所示：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will also notice from the code that an error is generated by this view.
    This is because we need both vertical and horizontal constraints for each view.
    This is achieved in exactly the same way, with something like:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到从代码中生成了一个错误。这是因为每个视图都需要垂直和水平约束。可以通过以下方式实现：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Constraints can be created between child views as well, using the same drag
    and drop technique or:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用相同的拖放技术在子视图之间创建约束，或者：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Setting a constraint on all four sides of a view will center it in its container.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图的四个边上设置约束将使其居中在其容器中。
- en: 'Constraints can be used to align sibling views as well as joining two adjacent
    sides, which generates code along these lines:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 约束可用于对齐兄弟视图以及连接两个相邻的边，生成以下代码：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A constraint can be deleted very simply, in either editor mode, by clicking
    on its originating handle.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在任一编辑模式下单击其起始手柄来简单地删除约束。
- en: This drag and drop method is not peculiar to Android Studio, but there is one
    editing tool that is unique to Android Studio by providing a editable schematic
    perspective in the Properties tool.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种拖放方法并不是Android Studio独有的，但是Android Studio提供了一个可编辑的示意图视图，通过属性工具来实现。
- en: Graphic Properties tool
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形属性工具
- en: 'You will no doubt have noticed the diagrammatic representation of a view that
    pops up in the Properties window, when a ConstraintLayout view is selected as
    follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择ConstraintLayout视图时，属性窗口中会弹出一个视图的图解表示：
- en: '![](img/a0e2a02c-07a2-4221-9001-356602d5156d.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0e2a02c-07a2-4221-9001-356602d5156d.png)'
- en: The Properties schematic.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 属性示意图。
- en: This tool allows size and position properties to be edited with a single click
    and for the output to be instantly understood in a simple schematic form. It only
    takes seconds to learn and can speed up interface design considerably, particularly
    when experimenting with different layouts.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具允许通过单击来编辑大小和位置属性，并且可以立即以简单的示意图形式理解输出。学习起来只需要几秒钟，可以大大加快界面设计的速度，特别是在尝试不同的布局时。
- en: 'Inside the central square, representing our view, there are four lines, which
    when clicked on cycle through the following three states:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在代表我们视图的中央正方形内，有四条线，单击它们会循环显示以下三种状态：
- en: '**Unbroken line**: The view is an exact width, for example, `240dp`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实线**：视图是精确的宽度，例如`240dp`'
- en: '**Fuzzy line**: The view can be any size (dependent on bias), `match_parent`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模糊线**：视图可以是任何大小（取决于偏差），`match_parent`'
- en: '**Directed line**: The view matches its own content, `wrap_content`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有向线**：视图匹配其自身内容，`wrap_content`'
- en: 'Often, we will not want to constrain a view to the very edge of its container.
    For example, we may wish to divide the layout into two or more sections and have
    views organized within them. Guidelines allow us to divide our screens into sections
    and can be used exactly like parent edges. Take the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不希望将视图约束到其容器的边缘。例如，我们可能希望将布局分成两个或多个部分，并在其中组织视图。指南允许我们将屏幕分成几个部分，并且可以像父边缘一样使用。看下面的例子：
- en: '![](img/6a533c49-852b-47ac-b844-6c7e14d366d4.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a533c49-852b-47ac-b844-6c7e14d366d4.png)'
- en: Constraint guidelines
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 约束指南
- en: 'Guidelines like this are most easily added from the constraint toolbar at the
    top of the design editor. Guidelines are added as XML components and look like
    this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的指南最容易从设计编辑器顶部的约束工具栏中添加。指南被添加为XML组件，看起来像这样：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now use these guidelines to center elements according to the whole layout
    or any of the four panes we have created, and all without nesting a single layout.
    In the following screenshot, we have a centered header and side panel with another
    view contained in a single pane, and we can of course apply bias to any of these
    sections:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这些指南来根据整个布局或我们创建的四个窗格之一来居中元素，而无需嵌套任何布局。在下面的屏幕截图中，我们有一个居中的标题和侧边栏，另一个视图包含在一个单独的窗格中，当然我们可以对这些部分应用偏差：
- en: '![](img/46252969-e6c1-41f2-a286-77d40759f680.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46252969-e6c1-41f2-a286-77d40759f680.png)'
- en: Applying constraint guidelines
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 应用约束指南
- en: If this system did not already provide enough advantages, there are more. Firstly,
    it proves very useful when aligning text as well as a more enhanced positioning
    technique referred to as bias, which performs a similar function to the weight
    attribute, but is better when it comes to designing for multiple screens. We will
    take a look first at text alignment constraints.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个系统还没有提供足够的优势，那就还有更多。首先，当对齐文本以及一种称为偏差的更强大的定位技术时，它被证明非常有用，它执行与权重属性类似的功能，但在设计多个屏幕时更好。我们首先来看一下文本对齐约束。
- en: Baseline alignment
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基线对齐
- en: Aligning text across multiple views using their baselines can be fiddly, especially
    when text is of different sizes. Fortunately, constraint layouts offer a simple
    and easy way to achieve this.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它们的基线将文本对齐到多个视图可能有些麻烦，特别是当文本大小不同时。幸运的是，约束布局提供了一种简单而轻松的方法来实现这一点。
- en: 'Any constrained view or widget designed to contain text, will contain a bar
    across its center. Hover over this for a moment, until it flashes, and then drag
    it to the view whose text you wish to align it with, as seen here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 任何受约束的视图或设计用于包含文本的小部件，都会在其中心处有一条横杠。将鼠标悬停在此处片刻，直到它闪烁，然后将其拖动到您希望将其文本与之对齐的视图，如下所示：
- en: '![](img/c95dfcb4-4527-4277-8214-63f694d4f3a0.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c95dfcb4-4527-4277-8214-63f694d4f3a0.png)'
- en: Baseline alignment.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 基线对齐。
- en: You will probably be familiar with the gravity attributes that the relative
    layout class uses to control positioning.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经熟悉相对布局类使用的重力属性来控制位置。
- en: Baseline constraints can only be connected to other baselines.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 基线约束只能连接到其他基线。
- en: The constraint layout introduces a new approach, allowing us to control the
    relative distances either side of the view.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 约束布局引入了一种新的方法，允许我们控制视图两侧的相对距离。
- en: Controlling position with bias
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用偏差控制位置
- en: Bias can be best understood here as a percentage value, but rather than position
    the view according to its center or a corner, it is the percentage of space either
    side of it. So if the bias towards the top is 33%, then the margin below will
    be twice the size of the one below it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，偏差最好理解为百分比值，但与其根据中心或角落的位置，它是它两侧空间的百分比。因此，如果向上的偏差为33％，则下方的边距将是下方边距的两倍。
- en: 'Setting bias is even easier than understanding it, as once a constraint is
    set on any opposing sides of a view, an associated slider will appear in the Properties
    graphic Properties editor:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 设置偏差甚至比理解它更容易，因为一旦在视图的任何对立面上设置了约束，属性编辑器中将出现一个关联的滑块：
- en: '![](img/8c2997bb-0521-4554-9160-70ef9728306e.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c2997bb-0521-4554-9160-70ef9728306e.png)'
- en: Applying bias with the GUI
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GUI应用偏差
- en: 'A quick glance at the generated code shows the format for this attribute as
    follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览生成的代码，显示了该属性的格式如下：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The value of using bias to position screen elements lies partly in the simplistic
    approach, but its true value comes when it comes to developing for multiple screens.
    There are so many models available and they all seem to have slightly different
    proportions. This can make design layouts that look fantastic on all of them,
    very time consuming and even shapes as similar as 720 x 1280 and 768 x 1280 can
    produce undesirable results when tested with the same layout. The use of the bias
    attribute goes a long way to solving these issues, and we shall see more of this
    later when we take a look at layout previews and the percent library.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用偏差来定位屏幕元素的价值部分在于其简单的方法，但其真正价值在于开发多个屏幕时。有这么多型号可用，它们似乎都有稍微不同的比例。这可能使得在所有这些屏幕上看起来很棒的设计布局非常耗时，即使是720
    x 1280和768 x 1280这样相似的形状在使用相同的布局进行测试时也可能产生不良结果。使用偏差属性在很大程度上解决了这些问题，我们将在稍后看到更多内容，当我们看到布局预览和百分比库时。
- en: The Design and Text modes of the editor can be switched between using *Alt*
    + Left or Right.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器的设计和文本模式可以使用*Alt* +左或右进行切换。
- en: 'As if all this didn''t make designing a layout easy enough, constraint layouts
    have two other extremely handy functions that almost automate UI design: auto-connect
    and inference.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 好像所有这些都没有使设计布局变得足够简单，约束布局还有另外两个非常方便的功能，几乎可以自动化UI设计：自动连接和推断。
- en: The constraints toolbar
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束工具栏
- en: Although we will always want to spend a lot of time perfecting our final designs,
    a lot of the development cycle will be taken up with experimentation and trying
    out new ideas. We want to test these individual designs as quickly as possible,
    and this is where auto-connect and inference come in. These functions can be accessed
    through the constraints toolbar, which contains other useful tools and is worth
    looking at in detail.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们总是希望花费大量时间完善我们的最终设计，但开发周期的大部分时间将用于实验和尝试新想法。我们希望尽快测试这些单独的设计，这就是自动连接和推断的用武之地。这些功能可以通过约束工具栏访问，其中包含其他有用的工具，值得详细了解。
- en: '![](img/b1c5a472-32d7-461c-9786-b7c28f60f3fb.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1c5a472-32d7-461c-9786-b7c28f60f3fb.png)'
- en: The constraints toolbar
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 约束工具栏
- en: From left to right, the toolbar breaks down as follows.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，工具栏分解如下。
- en: 'Show Constraints: Displays all constraints, not just those of the selected
    components.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示约束：显示所有约束，而不仅仅是所选组件的约束。
- en: 'Auto-connect: When this is enabled, new views and widgets will have their constraints
    set automatically according to where they are placed.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动连接：启用此功能后，新视图和小部件的约束将根据它们放置的位置自动设置。
- en: 'Clear All Constraints: As its title suggests, a one click solution to starting
    again. This can cause some unexpected results, so it should be used with a little
    caution.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除所有约束：顾名思义，一键解决方案。这可能会导致一些意想不到的结果，因此应该小心使用。
- en: 'Infer Constraints: Apply this once you have designed your layout. It will automatically
    apply constraint in a similar fashion to auto-connect, but it will do so to all
    views in a single pass.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推断约束：设计布局后应用此功能。它将自动应用约束，类似于自动连接，但它会一次性对所有视图应用约束。
- en: '![](img/4db07488-596a-4494-9c89-cdf2b755a3c2.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4db07488-596a-4494-9c89-cdf2b755a3c2.png)'
- en: The infer process
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 推断过程
- en: 'Default Margins: Sets the margins for the whole layout.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认边距：设置整个布局的边距。
- en: 'Pack: This offers a series of distribution patterns, which help to evenly expand
    or shrink the area used by the selected items.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pack：提供一系列分布模式，帮助均匀扩展或收缩所选项目使用的区域。
- en: 'Align: This drop-down offers the most commonly used group alignment options.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对齐：此下拉菜单提供了最常用的组对齐选项。
- en: Guidelines: Allows the quick insertion of guidelines.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指南：允许快速插入指南。
- en: Both auto-connect and infer offer intelligent and fast methods of building constraint
    layouts, and although they make fantastic tools for testing out ideas, they are
    far from perfect. Very often these automations will include unnecessary constraints
    that will need removing. Also, if you examine the XML after you have employed
    these techniques, you will notice that some values are hardcoded, and as you will
    know this is somewhat less than best practice.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 自动连接和推断都提供了智能和快速的构建约束布局的方法，虽然它们是测试想法的绝佳工具，但它们远非完美。这些自动化经常会包括不必要的约束，需要删除。此外，如果您在使用这些技术之后检查XML，您会注意到一些值是硬编码的，您会知道这不是最佳实践。
- en: As you will have hopefully have seen in this section, Android Studio and the
    ConstraintLayout are literally made for each other. This is not to say that it
    should replace the linear and relative layouts in all cases. When it comes to
    simple lists, the linear layout is still the most efficient. And for layouts with
    only two or three children, a relative layout is often cheaper too.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您在本节中已经看到，Android Studio和ConstraintLayout确实是为彼此而生的。这并不是说它应该在所有情况下取代线性和相对布局。在简单列表方面，线性布局仍然是最有效的。对于只有两个或三个子元素的布局，相对布局通常也更便宜。
- en: There is still more to the `ConstraintLayout` class, such as distribution chaining
    and runtime constraint modification, and we will return to the subject frequently
    throughout the book, but for now we will take a look at another of Android Studio's
    unique and powerful tools, device preview and emulation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConstraintLayout`类还有更多内容，比如分布链接和运行时约束修改，我们将在整本书中经常回到这个主题，但现在我们将看看Android Studio的另一个独特而强大的工具，设备预览和仿真。'
- en: Multiple screen previewing
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多屏幕预览
- en: One of the most interesting challenges an Android developer faces is the bewildering
    number of devices that employ it. Everything from wristwatches to widescreen televisions.
    It is rare that we would want to develop a single application to run across such
    a range, but even developing layouts for all mobile phones is still a daunting
    task.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Android开发人员面临的最有趣的挑战之一是使用它的设备数量令人困惑。从手表到宽屏电视，各种设备都在使用。我们很少希望开发一个单一的应用程序在这样的范围内运行，但即使为所有手机开发布局也是一项艰巨的任务。
- en: Fortunately, this process is aided by the way the SDK allows us to categorize
    features such as screen shape, size, and density into broader groups. Android
    Studio adds another powerful UI development tool, in the form of a complex preview
    system. This can be used to preview many popular device configurations as well
    as allowing us to create custom configurations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，SDK允许我们将屏幕形状、大小和密度等功能分类到更广泛的组中，从而帮助这一过程。Android Studio还添加了另一个强大的UI开发工具，即复杂的预览系统。这可以用于预览许多流行的设备配置，同时也允许我们创建自定义配置。
- en: 'In the previous section, we took a look at the ConstraintLayout toolbar, but
    as you will have noticed, there is a more generic design editor toolbar:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们看了ConstraintLayout工具栏，但正如您可能已经注意到的那样，还有一个更通用的设计编辑器工具栏：
- en: '![](img/36bb732a-af2c-4949-a5f1-ab60d7a03376.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36bb732a-af2c-4949-a5f1-ab60d7a03376.png)'
- en: Design editor toolbar
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 设计编辑器工具栏
- en: Most of these tools are self explanatory, and you will have used many of them.
    One or two, however, are worth taking a closer look at, especially if you are
    new to Android Studio.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具中的大多数都是不言自明的，您可能已经使用过其中的许多。然而，其中有一两个值得更仔细地研究，特别是如果您是Android Studio的新手。
- en: By far, one of the most useful design tools available to us is the Device in
    Editor tool, displaying in the preceding figure as Nexus 4\. This allows us to
    preview our layouts as they would appear in any number of devices, without having
    to compile the project. The drop-down provides a selection of generic and real-world
    profiles, any AVD we might have created, and the option to add our own device
    definition. It is this option that we shall look at now.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们可以使用的最有用的设计工具之一是编辑器中的设备工具，在前面的图中显示为Nexus 4。这使我们能够预览我们的布局，就像它们在任意数量的设备上显示一样，而无需编译项目。下拉菜单提供了一系列通用和真实世界的配置文件，我们可能创建的任何AVD，以及添加我们自己的设备定义的选项。现在我们将看看这个选项。
- en: Hardware profiles
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件配置文件
- en: Selecting Add Device Definition... from the Device in Editor drop-down will
    open the AVD manager. To create a new hardware profile click on the Create Virtual
    Device... button. The Select Hardware dialog allows us to install and edit all
    the device profiles listed in the previous drop-down as well as the option to
    create or import a definition.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从编辑器中的设备下拉菜单中选择“添加设备定义...”将打开AVD管理器。要创建新的硬件配置文件，请单击“创建虚拟设备...”按钮。选择硬件对话框允许我们安装和编辑前面下拉菜单中列出的所有设备配置文件，以及创建或导入定义的选项。
- en: A standalone version of the AVD manager can be run from `user\AppData\Local\Android\sdk\`.
    This can be useful on lower end machines, as AVDs can be booted up without Studio
    running.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: AVD管理器的独立版本可以从`user\AppData\Local\Android\sdk\`运行。这对于性能较低的机器非常有用，因为AVD可以在没有Studio运行的情况下启动。
- en: It is usually easier to take an existing definition and adapt it to our needs,
    but to gain further insight into the operation, here we will create one from scratch
    by clicking on the New Hardware Profile button from the Select Hardware dialog.
    This will take you to the Configure Hardware Profile dialog where you can select
    hardware emulators such as cameras and sensors as well as defining internal and
    external storage options.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常更容易采用现有的定义并根据我们的需求进行调整，但为了更深入地了解操作，我们将通过单击“选择硬件”对话框中的“新硬件配置文件”按钮，从头开始创建一个。这将带您进入“配置硬件配置文件”对话框，在那里您可以选择硬件仿真器，如摄像头和传感器，以及定义内部和外部存储选项。
- en: '![](img/68d3e3c6-b08f-46dc-9357-e8a96d74ed43.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68d3e3c6-b08f-46dc-9357-e8a96d74ed43.png)'
- en: Hardware configuration
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件配置
- en: Once you have your profile and click on Finish, you will be returned to the
    hardware selection screen where your profile will now have been added to the list.
    Before moving on, however, we should take a quick look at how we can emulate storage
    hardware.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成配置文件并点击“完成”，您将返回到硬件选择屏幕，在那里您的配置文件现在已被添加到列表中。然而，在继续之前，我们应该快速看一下如何模拟存储硬件。
- en: Virtual storage
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟存储
- en: Each profile contains an SD card disk image to emulate external storage, and
    obviously this is a useful feature. However, it would be even more useful if we
    could remove these cards and share them with other devices. Fortunately, Android
    Studio has some very handy command-line tools, which we will be encountering throughout
    this book. The command that interests us here though is `mksdcard`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每个配置文件都包含一个SD卡磁盘映像来模拟外部存储，显然这是一个有用的功能。然而，如果我们能够移除这些卡并与其他设备共享，那将更加有用。幸运的是，Android
    Studio有一些非常方便的命令行工具，我们将在本书中遇到。这里我们感兴趣的命令是`mksdcard`。
- en: 'The `mksdcard` executable can be found in `sdk/tools/` and the format for creating
    a virtual SD card is:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`mksdcard`可执行文件位于`sdk/tools/`中，创建虚拟SD卡的格式为：'
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When testing an application on a large number of virtual devices, it can save
    a lot of time to be able to share external memory, and of course such images can
    be stored on actual SD cards, which not only makes them more portable, but can
    reduce the load on a hard drive.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在大量虚拟设备上测试应用程序时，能够共享外部存储器可以节省大量时间，当然，这样的映像可以存储在实际的SD卡上，这不仅使它们更加便携，还可以减轻硬盘的负担。
- en: Our profile is now ready to be combined with a system image to form an AVD,
    but first we will export it to get a better look at how it is put together. This
    is saved as an XML file and can be achieved by right-clicking on your profile
    in the main table of the hardware selection screen. Not only does this provide
    an insight as well as a handy way to share devices across networks, but it is
    also very quick and simple to edit itself.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配置文件现在已准备好与系统映像结合，形成AVD，但首先我们将导出它，以便更好地了解它是如何组合的。这将保存为XML文件，并且可以通过右键单击硬件选择屏幕的主表中的配置文件来实现。这不仅提供了洞察力，也是跨网络共享设备的便捷方式，而且编辑本身也非常快速简单。
- en: 'The configuration itself can be quite long, so the following is a sample node
    to provide an idea:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 配置本身可能会相当长，因此以下是一个示例节点，以提供一个想法：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Looking at the way a screen is defined here, provides a useful window into the
    features and definitions we need to consider when developing for multiple devices.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里定义屏幕的方式，为我们提供了一个有用的窗口，可以了解在开发多个设备时需要考虑的功能和定义。
- en: To see our profile in action we need to connect it to a system image and run
    it on the emulator. This is done by selecting the profile and clicking on Next.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们的配置文件的实际效果，我们需要将其连接到系统映像并在模拟器上运行。这是通过选择配置文件并点击“下一步”来完成的。
- en: To test an app thoroughly, it is usually best to create an AVD for each API
    level, screen density, and hardware configuration you intend to publish the app
    on.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要彻底测试应用程序，通常最好为要发布应用程序的每个API级别、屏幕密度和硬件配置创建一个AVD。
- en: 'Having selected an image, you will be given the opportunity to tweak your hardware
    profile and then create the AVD:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 选择图像后，您将有机会调整硬件配置文件，然后创建AVD：
- en: '![](img/94b22b0f-4f29-4e67-9e72-d68afd45efac.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94b22b0f-4f29-4e67-9e72-d68afd45efac.png)'
- en: An Android AVD
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Android AVD
- en: Emulating the latest mobile devices is an impressive task, even for the toughest
    of computers and, even with HAXM hardware acceleration, it can be frustratingly
    slow, although the addition of Instant Run has considerably speeded this process
    up. There is little in the way of alternatives, with the exception of Genymotion,
    which provides faster virtual devices and several features unavailable on the
    native emulator. These include the drag and drop installation, real-time window
    resizing, working network connection, and one click mock location setting. The
    only drawbacks being that there are no system images for Android Wear, TV, or
    Auto and it is only free for personal use.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟最新的移动设备是一项令人印象深刻的任务，即使对于最坚固的计算机来说，即使使用HAXM硬件加速，速度仍然可能令人沮丧地慢，尽管即时运行的添加大大加快了这个过程。除了Genymotion之外，几乎没有其他选择，Genymotion提供了更快的虚拟设备和一些在本机模拟器上无法使用的功能。这些功能包括拖放安装、实时窗口调整大小、工作网络连接和一键模拟位置设置。唯一的缺点是Android
    Wear、TV或Auto没有系统映像，并且仅供个人免费使用。
- en: This section shows how we can preview our layouts across a large number of form
    factors and how we can build a virtual device to match the exact specifications
    of any target device, but this is only part of the story. In the next chapter,
    we will see how to create layout files for all our target devices.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了我们如何在许多形态因素上预览我们的布局，以及如何构建一个虚拟设备以匹配任何目标设备的精确规格，但这只是故事的一部分。在下一章中，我们将看到如何为所有目标设备创建布局文件。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the fundamentals of interface development, and this
    is largely a matter of using and understanding the various layout types. A lot
    of the chapter was devoted to the constraint layout as this is the latest and
    most flexible of these viewgroups and is catered for fully in Android Studio with
    intuitive visual tools.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了界面开发的基础知识，这在很大程度上是使用和理解各种布局类型的问题。本章的大部分内容都致力于约束布局，因为这是最新和最灵活的视图组之一，并且在Android
    Studio中配备了直观的可视化工具。
- en: The chapter concluded by seeing how we take the completed layouts and view them
    on an emulator using a customized hardware profile.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后介绍了如何将完成的布局在模拟器上查看，并使用自定义的硬件配置文件。
- en: In the following chapter, we will look more deeply into these layouts and see
    how the coordinator layout is used to coordinate a number of child components
    to work together with very little coding required from us.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更深入地研究这些布局，并看到协调布局是如何用来协调多个子组件一起工作的，而我们几乎不需要编写任何代码。
