["```cs\na = [1,2,3, 4...., n]\n```", "```cs\n[DllImport(\"Kernel32.dll\"), SuppressUnmanagedCodeSecurity]\npublic static extern int GetCurrentProcessorNumber();\n\nstatic void Main(string[] args)\n{\n    Thread.Sleep(2000);\n    Console.WriteLine($\"Hello {GetCurrentProcessorNumber()} Id\");\n}\n```", "```cs\nC:\\Program Files\\Microsoft MPI\\Bin>mpiexec.exe -n 5 \u201cpath to executable \u201c\n```", "```cs\nint MPIAPI MPI_Send(\n  _In_opt_ void         *buf, //pointer to buffer containing Data to send\n           int          count, //Number of elements in buffer\n           MPI_Datatype datatype,//Datatype of element in buffer\n           int          dest, //rank of destination process\n           int          tag, //tag to distinguish between messages\n           MPI_Comm     comm //Handle to communicator\n);\n```", "```cs\nint MPIAPI MPI_Recv(\n  _In_opt_ void         *buf,\n           int          count,\n           MPI_Datatype datatype,\n           int          source,\n           int          tag,\n           MPI_Comm     comm,\n  _Out_    MPI_Status   *status //Returns MPI_SUCCESS  or the error code.\n);\n```", "```cs\n#include \u201cmpi.h\u201d\n#include <iostream> int main( int argc, char *argv[]) { int rank, buffer; MPI::Init(argv, argc); rank = MPI::COMM_WORLD.Get_rank(); // Process 0 sends data as buffer and Process 1 receives data as buffer if (rank == 0) { buffer = 999999; MPI::COMM_WORLD.Send( &buffer, 1, MPI::INT, 1, 0 ); } else if (rank == 1) { MPI::COMM_WORLD.Recv( &buffer, 1, MPI::INT, 0, 0 ); std::cout << \u201cData Received \u201c << buf << \u201c\\n\u201d; } MPI::Finalize(); return 0; }\n```"]