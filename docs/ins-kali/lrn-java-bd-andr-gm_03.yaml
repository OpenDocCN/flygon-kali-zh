- en: Chapter 3. Speaking Java – Your First Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。说Java-你的第一个游戏
- en: In this chapter, we will start writing our very own Java code at the same time
    as we begin understanding Java syntax. We will learn how to store, retrieve, and
    manipulate different types of values stored in the memory. We will also look at
    making decisions and branching the flow of our code based on the values of this
    data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将开始编写我们自己的Java代码，同时开始理解Java语法。我们将学习如何存储、检索和操作存储在内存中的不同类型的值。我们还将研究如何根据这些数据的值做出决策和分支我们代码的流程。
- en: 'In this order, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个顺序，我们将：
- en: Learn some Java syntax and see how it is turned into a running app by the compiler
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一些Java语法，并看看编译器是如何将其转换为运行应用程序的
- en: Store data and use it with variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储数据并使用变量
- en: Learn how to express yourself in Java with expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何用Java表达自己
- en: Continue with the math game by asking a question
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提问继续数学游戏
- en: Learn about decisions in Java
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Java中的决策
- en: Continue with the math game by getting and checking the answer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过获取和检查答案继续数学游戏
- en: 'Acquiring the preceding Java skills will enable us to build the next two phases
    of our math game. This game will be able to ask the player a question on multiplication,
    check the answer and give feedback based on the answer given, as shown in the
    following screenshot:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 获得前述的Java技能将使我们能够构建我们数学游戏的下两个阶段。这个游戏将能够向玩家提出一个乘法问题，检查答案，并根据给出的答案给出反馈，如下图所示：
- en: '![Speaking Java – Your First Game](img/8859OS_03_06.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![说Java-你的第一个游戏](img/8859OS_03_06.jpg)'
- en: Java syntax
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java语法
- en: Throughout this book, we will use plain English to discuss some fairly technical
    things. You will never be asked to read a technical explanation of a Java or Android
    concept that has not been previously explained in a non-technical way.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用简单的英语讨论一些相当技术性的事情。你永远不会被要求阅读一个之前没有以非技术方式解释过的Java或Android概念的技术解释。
- en: Occasionally, I might ask or imply that you accept a simplified explanation
    in order to offer a fuller explanation at a more appropriate time, like the Java
    class as a black box; however, you will never need to scurry to Google in order
    to get your head around a big word or a jargon-filled sentence.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，我可能会要求或暗示您接受一个简化的解释，以便在更合适的时候提供更完整的解释，比如Java类作为一个黑匣子；但是，你永远不需要匆忙去谷歌以理解一个大词或充满术语的句子。
- en: Having said that, the Java and Android communities are full of people who speak
    in technical terms and to join in and learn from these communities, you need to
    understand the terms they use. So the approach this book takes is to learn a concept
    or appreciate an idea using an entirely plain speaking language, but at the same
    time, it introduces the jargon as part of the learning.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Java和Android社区充满了讲技术术语的人，要加入并从这些社区中学习，你需要理解他们使用的术语。因此，本书的方法是使用完全简单的语言学习概念或欣赏想法，同时将行话作为学习的一部分。
- en: Then, much of the jargon will begin to reveal its usefulness, usually as a way
    of clarification or keeping the explanation/discussion from becoming longer than
    it needs to be.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，许多行话将开始显示其有用性，通常作为澄清的一种方式，或者避免解释/讨论变得比必要的更长。
- en: The very term, "Java syntax," could be considered technical or jargon. So what
    is it? The Java syntax is the way we put together the language elements of Java
    in order to produce code that works in the Java/Dalvik virtual machine. Syntax
    should also be as clear as possible to a human reader, not least ourselves when
    we revisit our programs in the future. The Java syntax is a combination of the
    words we use and the formation of those words into sentence like structures.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: “Java语法”这个术语本身可能被认为是技术性的或术语性的。那么它是什么？Java语法是我们将Java语言元素组合在一起以便在Java/Dalvik虚拟机中运行的代码。语法也应尽可能清晰地呈现给人类读者，尤其是在未来重新访问我们的程序时。Java语法是我们使用的词和将这些词组成类似句子的结构的组合。
- en: These Java elements or words are many in number, but when taken in small chunks
    are almost certainly easier to learn than any human-spoken language. The reason
    for this is that the Java language and its syntax were specifically designed to
    be as straightforward as possible. We also have Android Studio on our side, which
    will often let us know if we make a mistake and will even sometimes think ahead
    and prompt us.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Java元素或词汇数量众多，但分成小块学习几乎肯定比任何人类语言更容易。原因在于Java语言及其语法是专门设计为尽可能简单明了。我们还有Android
    Studio在我们这边，它通常会告诉我们如果我们犯了错误，有时甚至会提前思考并提示我们。
- en: I am confident that if you can read, you can learn Java; because learning Java
    is very easy. What then separates someone who has finished an elementary Java
    course from an expert programmer? The same things that separate a student of language
    from a master poet. Mastery of the language comes through practice and further
    study.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信如果你能阅读，你就能学会Java；因为学习Java非常容易。那么，是什么让一个完成了初级Java课程的人与一个专业程序员分开呢？同样的东西也分开了语言学生和大师诗人。语言的掌握来自于实践和进一步的学习。
- en: In the last chapter, I will show you the right direction if you want to go on
    to master Java yourself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我将向你展示正确的方向，如果你想自己掌握Java。
- en: The compiler
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器
- en: The compiler is what turns our human-readable Java code into another piece of
    code that can be run in a virtual machine. This is called **compiling**. The Dalvik
    virtual machine will run this compiled code when our players tap on our app icon.
    Besides compiling Java code, the compiler will also check for mistakes. Although
    we might still have mistakes in our released app, many discovered when our code
    is compiled.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器是将我们可读的Java代码转换为可以在虚拟机中运行的另一段代码的东西。这被称为**编译**。Dalvik虚拟机将在我们的玩家点击我们应用程序图标时运行这段编译后的代码。除了编译Java代码，编译器还会检查错误。虽然我们的发布应用程序可能仍然存在错误，但许多错误是在编译我们的代码时发现的。
- en: Making code clear with comments
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用注释清晰地编写代码
- en: As you become more advanced in writing Java programs, the solutions you use
    to create your programs will become longer and more complicated. Furthermore,
    as we will see in later chapters, Java was designed to manage complexity by having
    us divide our code into separate chunks, very often across multiple files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你在编写Java程序方面变得更加高级，你用来创建程序的解决方案将变得更长、更复杂。此外，正如我们将在后面的章节中看到的，Java被设计为通过将代码分成单独的块来管理复杂性，往往跨越多个文件。
- en: '**Comments** are a part of the Java program that do not have any function in
    the program itself. The compiler ignores them. They serve to help the programmer
    to document, explain, and clarify their code to make it more understandable to
    themselves at a later date or to other programmers who might need to use or modify
    the code.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释**是Java程序的一部分，在程序本身中没有任何功能。编译器会忽略它们。它们用于帮助程序员记录、解释和澄清他们的代码，以便在以后更容易理解自己或其他需要使用或修改代码的程序员。'
- en: 'So, a good piece of code will be liberally sprinkled with lines like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个好的代码片段将大量地添加这样的行：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding comment begins with the two forward slash characters, `//`. The
    comment ends at the end of the line. It is known as a single-line comment. So
    anything on that line is for humans only, whereas anything on the next line (unless
    it''s another comment) needs to be syntactically correct Java code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的注释以两个斜杠字符`//`开头。注释在行末结束。这被称为单行注释。因此，该行上的任何内容只供人类阅读，而下一行上的任何内容（除非是另一个注释）都需要是语法正确的Java代码。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can use multiple single-line comments:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多个单行注释：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Single-line comments are also useful if we want to temporarily disable a line
    of code. We can put `//` in front of the code and it will not be included in the
    program. Recall this code, which tells Android to load our menu UI:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 单行注释也很有用，如果我们想暂时禁用一行代码。我们可以在代码前面加上`//`，这样它就不会包含在程序中。回想一下这段代码，它告诉Android加载我们的菜单UI：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding situation, the menu will not be loaded and the app will have
    a blank screen when run, as the entire line of code is ignored by the compiler.
    There is another type of comment in Java—the multiline comment. This is useful
    for longer comments and also to add things such as copyright information at the
    top of a code file. Also like the single-line comment, it can be used to temporarily
    disable code, in this case usually multiple lines.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，当运行时菜单不会被加载，应用程序将有一个空白屏幕，因为整行代码被编译器忽略。Java中还有另一种类型的注释——多行注释。这对于较长的注释以及在代码文件顶部添加版权信息等内容非常有用。与单行注释一样，它可以用于暂时禁用代码，通常是多行代码。
- en: 'Everything in between the leading `/*` signs and the ending `*/` signs is ignored
    by the compiler. Here are some examples:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前导`/*`和结束`*/`之间的所有内容都会被编译器忽略。以下是一些例子：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is no limit to the number of lines in a multiline comment. Which type
    of comment is best to use will depend upon the situation. In this book, I will
    always explain every line of code explicitly but you will often find liberally
    sprinkled comments within the code itself that add further explanation, insight
    or clarification. So it''s always a good idea to read all of the code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释中的行数没有限制。使用哪种类型的注释将取决于情况。在本书中，我将始终明确解释每一行代码，但你经常会在代码本身中发现大量的注释，这些注释会进一步解释、洞察或澄清。因此，阅读所有代码总是一个好主意：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: All the best Java programmers liberally sprinkle their code with comments.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有优秀的Java程序员都会在他们的代码中大量使用注释。
- en: Storing data and using it with variables
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储数据并使用变量
- en: We can think of a variable as a labeled storage box. They are also like a programmer's
    window to the memory of the Android device, or whatever device we are programming.
    Variables can store data in memory (the storage box), ready to be recalled or
    altered when necessary by using the appropriate label.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将变量看作是带有标签的存储箱。它们也像是程序员对Android设备内存或者我们正在编程的任何设备的窗口。变量可以在内存中存储数据（存储箱），在需要时通过适当的标签进行调用或更改。
- en: Computer memory has a highly complex system of addressing that we, fortunately,
    do not need to interact with in Java. Java variables allow us to make up convenient
    names for all the data that we want our program to work with; the JVM will handle
    all the technicalities that interact with the operating system, which in turn,
    probably through several layers of buck passing, will interact with the hardware.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机内存具有高度复杂的寻址系统，幸运的是，在Java中我们不需要与之交互。Java变量允许我们为程序中需要处理的所有数据编写方便的名称；JVM将处理与操作系统交互的所有技术细节，而操作系统可能通过几层传递交互与硬件。
- en: So we can think of our Android device's memory as a huge warehouse. When we
    assign names to our variables, they are stored in the warehouse, ready when we
    need them. When we use our variable's name, the device knows exactly what we are
    referring to. We can then tell it to do things such as "get box A and add it to
    box C, delete box B," and so on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将我们的Android设备内存想象成一个巨大的仓库。当我们为变量分配名称时，它们被存储在仓库中，等待我们需要它们时。当我们使用变量的名称时，设备会准确知道我们在引用什么。然后我们可以告诉它做一些事情，比如“拿出A箱并将其添加到C箱，删除B箱”，等等。
- en: In a game, we will likely have a variable named as something along the lines
    of `score`. It would be this `score` variable that we use to manage anything related
    to the user's score, such as adding to it, subtracting or perhaps just showing
    it to the player.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，我们可能会有一个名为`score`的变量。正是这个`score`变量，我们用来管理与用户分数相关的任何事情，比如增加、减少或者只是向玩家展示分数。
- en: 'Some of the following situations that might arise:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出现以下一些情况：
- en: The player gets a question right, so add 10 to their existing `score`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家回答正确一个问题，所以将10加到他们现有的`score`上
- en: The player views their stats screen, so print `score` on the screen
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家查看他们的统计屏幕，所以在屏幕上打印`score`
- en: The player gets the best score ever, so make `hiScore` the same as their current
    `score`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家获得了有史以来最高的分数，所以将`hiScore`设置为他们当前的`score`。
- en: These are fairly arbitrary examples of names for variables and as long as you
    don't use any of the characters keywords that Java restricts, you can actually
    call your variables whatever you like. However, in practice, it is best to adopt
    a naming convention so that your variable names will be consistent. In this book,
    we will use a loose convention of variable names starting with a lowercase letter.
    When there is more than one word in the variable's name, the second word will
    begin with an uppercase letter. This is called "camel casing."
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是相当任意的变量名称示例，只要你不使用Java限制的字符关键字，你实际上可以随意命名你的变量。然而，在实践中，最好采用一种命名约定，这样你的变量名称将是一致的。在本书中，我们将使用一个变量名称以小写字母开头的宽松约定。当变量的名称中有多个单词时，第二个单词将以大写字母开头。这被称为“驼峰命名法”。
- en: 'Here are some examples of camel casing:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些驼峰命名的示例：
- en: '`score`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`score`'
- en: '`hiScore`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hiScore`'
- en: '`playersPersonalBest`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playersPersonalBest`'
- en: Before we look at some real Java code with some variables, we need to first
    look at the types of variables we can create and use.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看一些带有变量的真正的Java代码之前，我们首先需要看一下我们可以创建和使用的变量的类型。
- en: Types of variables
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量类型
- en: It is not hard to imagine that even a simple game will probably have quite a
    few variables. In the previous section, we introduced the `hiScore` variable as
    an example. What if the game has a high score table that remembers the names of
    the top 10 players? Then we might need variables for each player.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可以想象，即使是一个简单的游戏可能也会有相当多的变量。在前一节中，我们介绍了`hiScore`变量作为一个例子。如果游戏有一个记住前10名玩家姓名的高分榜，那么我们可能需要为每个玩家创建变量。
- en: And what about the case when a game needs to know if a playable character is
    dead or alive, or perhaps has any lives/retries left? We might need code that
    tests for life and then ends the game with a nice blood spurt animation if the
    playable character is dead.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 那么当游戏需要知道可玩角色是死了还是活着，或者还有几条命/重试机会时呢？我们可能需要一些代码来测试生命，然后在可玩角色死亡时结束游戏并播放一个漂亮的血花动画。
- en: 'Another common requirement in a computer program, including games, is the right
    or wrong calculation: true or false.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序中的另一个常见要求，包括游戏，是正确或错误的计算：真或假。
- en: To cover these and many other types of information you might want to keep track
    of, Java has **types**. There are many types of variables and, as we will see
    in [Chapter 6](ch06.xhtml "Chapter 6. OOP – Using Other People's Hard Work"),
    *OOP – Using Other People's Hard Work*, we can also invent our own types or use
    other people's types. But for now, we will look at the built-in Java types. To
    be fair, they cover just about every situation we are likely to run into for a
    while. Some examples are the best way to explain this type of stuff.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了涵盖您可能想要跟踪的这些和许多其他类型的信息，Java有**类型**。有许多类型的变量，正如我们将在[第6章](ch06.xhtml "第6章。OOP
    – Using Other People's Hard Work")中看到的，*OOP – Using Other People's Hard Work*，我们也可以发明自己的类型或使用其他人的类型。但现在，我们将看看内置的Java类型。公平地说，它们几乎涵盖了我们可能会遇到的每种情况。一些示例是解释这种类型的东西的最佳方式。
- en: We have already discussed the hypothetical but highly likely `score` variable.
    The variable `score` is likely to be a number, so we have to convey this (that
    the score is a number) to the Java compiler by giving the score an appropriate
    type. The hypothetical but equally likely `playerName` will, of course, hold the
    characters that make up the player's name. Jumping ahead a couple of paragraphs,
    the type that holds a regular number is called `int`, and the type that holds
    name-like data is called `String`. And if we try and store a player name, perhaps
    "Ada Lovelace" in `score`, which is meant for numbers, we will certainly run into
    trouble.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了假设但非常可能的`score`变量。变量`score`很可能是一个数字，所以我们必须通过给分数一个适当的类型来向Java编译器传达这一点（分数是一个数字）。同样假设但同样可能的`playerName`当然将保存组成玩家姓名的字符。再往前跳几段，保存常规数字的类型称为`int`，保存类似姓名的数据的类型称为`String`。如果我们试图将一个玩家的名字，比如“Ada
    Lovelace”，存储在`score`中，而`score`是用于数字的，我们肯定会遇到麻烦。
- en: 'The compiler says no! Actually, the error would say this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器说不行！实际上，错误会说：
- en: '![Types of variables](img/8859OS_03_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![变量类型](img/8859OS_03_05.jpg)'
- en: As we can see, Java was designed to make it impossible for such errors to make
    it to a running program. Did you also spot in the previous screenshot that I had
    forgotten the semicolon at the end of the line? With this compiler identifying
    our errors, what could possibly go wrong?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Java被设计成不可能让这样的错误出现在运行的程序中。你是否也注意到在之前的截图中，我忘记了在行末加上分号？有了这个编译器来识别我们的错误，可能会出现什么问题呢？
- en: 'Here are the main types in Java. Later, we will see how to start using them:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Java中的主要类型。稍后，我们将看到如何开始使用它们：
- en: '`int`: This type is used to store integers. It uses 32 pieces (**bits**) of
    memory and can therefore store values with a magnitude a little in excess of 2
    billion, including negative values.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：这种类型用于存储整数。它使用32位内存，因此可以存储略大于20亿的值，包括负值。'
- en: '`long`: As the name hints at, this data type can be used when even larger numbers
    are required. A `long` data type uses 64 bits of memory and 2 to the power of
    63 is what we can store in this type. If you want to see what that looks like,
    try this: `9,223,372,036,854,775,807`. Perhaps surprisingly, there are uses for
    `long` variables but if a smaller variable will do, we should use it so that our
    program uses less memory.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`：顾名思义，当需要更大的数字时可以使用这种数据类型。`long`数据类型使用64位内存，我们可以在这种类型中存储2的63次方。如果你想看看它是什么样子，试试这个：`9,223,372,036,854,775,807`。也许令人惊讶的是，`long`变量也有用处，但如果较小的变量可以胜任，我们应该使用它，这样我们的程序就会使用更少的内存。'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering when you might use numbers of this magnitude. The obvious
    examples would be math or science applications that do complex calculations but
    another use might be for timing. When you time how long something takes, the Java
    `Date` class uses the number of milliseconds since January 1, 1970\. The `long`
    data type could be useful to subtract a start time from an end time to determine
    an elapsed time. We will use `long` in [Chapter 5](ch05.xhtml "Chapter 5. Gaming
    and Java Essentials"), *Gaming and Java Essentials*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道何时会使用这么大的数字。明显的例子可能是进行复杂计算的数学或科学应用，但另一个用途可能是用于计时。当你计算某事花费的时间时，Java `Date`类使用自1970年1月1日以来的毫秒数。`long`数据类型可能有用，用于从开始时间减去结束时间以确定经过的时间。我们将在[第5章](ch05.xhtml
    "第5章。游戏和Java基础")*游戏和Java基础*中使用`long`。
- en: '`float`: This is for floating-point numbers, that is, numbers where there is
    precision beyond the decimal point. As the fractional part of a number takes memory
    space just as the whole number portion, the range of numbers possible in a float
    is therefore decreased compared to non-floating-point numbers. So, unless our
    variable will definitely use the extra precision, float would not be our data
    type of choice.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`：这是用于浮点数的，也就是说，小数点后有精度的数字。由于数字的小数部分占用的内存空间与整数部分一样，因此与非浮点数相比，浮点数的可能范围会减少。因此，除非我们的变量肯定会使用额外的精度，否则浮点数不会是我们的数据类型选择。'
- en: '`double`: When the precision in `float` is not enough we have `double`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`：当`float`中的精度不够时，我们有`double`。'
- en: '`short`: When even an `int` data type is overkill, the super-skinny short fits
    into the tiniest of storage boxes, but we can only store around 64,000 values,
    from -32,768 to 32,767.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`：当即使是`int`数据类型都过度时，超薄的short适合于最小的存储盒，但我们只能存储大约64,000个值，从-32,768到32,767。'
- en: '`byte`: This is an even smaller storage box than a short type. There is plenty
    of room for these in memory but a byte can only store values from -128 to 127.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`：这是比short类型更小的存储盒。内存中有足够的空间，但一个字节只能存储-128到127的值。'
- en: '`boolean`: We will be using plenty of Booleans throughout the book. A Boolean
    variable can be either true or false—nothing else. Perhaps Booleans answer questions
    such as:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`：我们将在整本书中大量使用布尔值。布尔变量只能是真或假，没有其他选项。也许布尔值可以回答这样的问题：'
- en: Is the player alive?
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家还活着吗？
- en: Has a new high score been reached?
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否达到了新的最高分？
- en: Are two examples for a Boolean variable enough?
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔变量的两个例子足够吗？
- en: '`char`: This stores a single alphanumeric character. It''s not going to change
    anything on its own but it could be useful if we put lots of them together.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`：这存储一个单个的字母数字字符。它本身不会改变任何东西，但如果我们把它们放在一起，它可能会有用。'
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I have kept this discussion of data types to a practical level that is useful
    in the context of this book. If you are interested in how a data type's value
    is stored and why the limits are what they are, visit the Oracle Java tutorials
    site at [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html).
    Note that you do not need any more information than we have already discussed
    to continue with this book.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这种数据类型的讨论保持在一个在本书的上下文中有用的实际水平上。如果你对数据类型的值是如何存储的以及为什么限制是什么感兴趣，请访问Oracle Java教程网站[http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)。请注意，你不需要比我们已经讨论过的更多信息来继续阅读本书。
- en: As we just learned, each type of data that we might want to store will require
    a specific amount of memory. So we must let the Java compiler know the type of
    the variable before we begin to use it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚学到的，我们可能想要存储的每种数据类型都需要特定的内存量。因此，在我们开始使用变量之前，我们必须让Java编译器知道变量的类型。
- en: The preceding variables are known as the **primitive** types. They use predefined
    amounts of memory and so, using our storage analogy, fit into predefined sizes
    of the storage box.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的变量被称为**原始**类型。它们使用预定义的内存量，因此，使用我们的存储类比，适合于预定义大小的存储盒。
- en: As the "primitive" label suggests, they are not as sophisticated as the reference
    types.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如“原始”标签所示，它们不像引用类型那样复杂。
- en: Reference types
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用类型
- en: You might have noticed that we didn't cover the `String` variable type that
    we previously used to introduce the concept of variables.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们没有涵盖我们之前用来介绍变量概念的`String`变量类型。
- en: 'Strings are a special type of variable known as a reference type. They quite
    simply refer to a place in memory where the storage of the variable begins, but
    the reference type itself does not define a specific amount of memory. The reason
    for this is fairly straightforward: we don''t always know how much data will need
    to be stored until the program is actually run.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一种特殊的变量类型，称为引用类型。它们简单地指向内存中变量存储开始的位置，但引用类型本身并不定义特定的内存量。这样做的原因非常简单：我们并不总是知道在程序实际运行之前需要存储多少数据。
- en: We can think of strings and other reference types as continually expanding and
    contracting storage boxes. So won't one of these `String` reference types bump
    into another variable eventually? If you think about the devices memory as a huge
    warehouse full of racks of labeled storage boxes, then you can think of the Dalvik
    virtual machine as a super-efficient forklift truck driver that puts the different
    types of storage boxes in the most appropriate place.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将字符串和其他引用类型视为不断扩展和收缩的存储盒。那么这些`String`引用类型中的一个不会最终碰到另一个变量吗？如果你把设备的内存想象成一个满是标记存储盒的货架的巨大仓库，那么你可以把达尔维克虚拟机想象成一个超级高效的叉车司机，把不同类型的存储盒放在最合适的地方。
- en: And if it becomes necessary, the virtual machine will quickly move stuff around
    in a fraction of a second to avoid collisions. It will even incinerate unwanted
    storage boxes when appropriate. This happens at the same time as constantly unloading
    new storage boxes of all types and placing them in the best place, for that type
    of variable. Dalvik tends to keep reference variables in a part of the warehouse
    that is different from the part for the primitive variables, and we will learn
    more details about this in [Chapter 6](ch06.xhtml "Chapter 6. OOP – Using Other
    People's Hard Work"), *OOP – Using Other People's Hard Work*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有必要的话，虚拟机会在一秒钟内迅速移动物品，以避免碰撞。在适当的时候，它甚至会焚毁不需要的存储盒。这与不断卸载各种类型的新存储盒并将它们放在最佳位置同时发生，对于该类型的变量。Dalvik倾向于将引用变量保存在仓库的一个部分，这与原始变量的部分不同，我们将在[第6章](ch06.xhtml
    "第6章 OOP – 使用其他人的辛勤工作")中了解更多细节，*OOP – 使用其他人的辛勤工作*。
- en: So strings can be used to store any keyboard character, like a `char` data type
    but of almost any length. Anything from a player's name to an entire book can
    be stored in a single string. We will be using strings regularly including in
    this chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，字符串可以用来存储任何键盘字符，就像`char`数据类型，但长度几乎可以是任意的。从玩家的名字到整本书都可以存储在一个字符串中。我们将经常使用字符串，包括在本章中。
- en: There are a couple more reference types we will explore. Arrays are a way to
    store lots of variables of the same type, ready for quick and efficient access.
    We will look at arrays in [Chapter 5](ch05.xhtml "Chapter 5. Gaming and Java Essentials"),
    *Gaming and Java Essentials*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些我们将要探索的引用类型。数组是一种存储大量相同类型变量的方法，可以快速高效地访问。我们将在[第5章](ch05.xhtml "第5章 游戏和Java基础")中研究数组，*游戏和Java基础*。
- en: Think of an array as an aisle in our warehouse with all the variables of a certain
    type lined up in a precise order. Arrays are reference types, so Dalvik keeps
    these in the same part of the warehouse as strings.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组视为仓库中的一条通道，其中按照精确的顺序排列了某种类型的所有变量。数组是引用类型，因此Dalvik将它们保存在与字符串相同的仓库部分。
- en: The other reference type is the mysterious object or class that we will look
    at in [Chapter 6](ch06.xhtml "Chapter 6. OOP – Using Other People's Hard Work"),
    *OOP –* *Using Other People's Hard Work*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种引用类型是神秘的对象或类，我们将在[第6章](ch06.xhtml "第6章 OOP – 使用其他人的辛勤工作")中进行讨论，*OOP – 使用其他人的辛勤工作*。
- en: So we know that each type of data that we might want to store will require an
    amount of memory. Hence, we must let the Java compiler know the type of the variable
    before we begin to use it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道我们可能想要存储的每种数据类型都需要一定的内存。因此，在开始使用变量之前，我们必须让Java编译器知道变量的类型。
- en: Declaration
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明
- en: That's enough of theory. Let's see how we would actually use our variables and
    types. Remember that each primitive type requires a specific amount of real device
    memory. This is one of the reasons that the compiler needs to know what type a
    variable will be of. So we must first **declare** a variable and its type before
    we attempt to do anything with it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就够了。让我们看看我们实际上如何使用我们的变量和类型。请记住，每种原始类型都需要特定数量的真实设备内存。这是编译器需要知道变量类型的原因之一。因此，在尝试对其进行任何操作之前，我们必须首先**声明**变量及其类型。
- en: 'To declare a variable of type `int` with the name `score`, we would type:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个名为`score`的`int`类型的变量，我们会这样输入：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's it! Simply state the type, in this case `int`, then leave a space, and
    type the name you want to use for this variable. Also note the semicolon on the
    end of the line as usual to show the compiler that we are done with this line
    and what follows, if anything, is not part of the declaration.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！只需声明类型，比如`int`，然后留下一个空格，输入您要用于此变量的名称。还要注意分号，像往常一样在行尾，以告诉编译器我们已经完成了这一行，接下来的内容（如果有的话）不是声明的一部分。
- en: 'For almost all the other variable types, declaration would occur in the same
    way. Here are some examples. The variable names are arbitrary. This is like reserving
    a labeled storage box in the warehouse:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于几乎所有其他变量类型，声明都是以相同的方式进行的。以下是一些示例。变量名是任意的。这就像在仓库中预留一个带标签的存储盒：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Initialization
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化
- en: 'Here, for each type, we initialize a value to the variable. Think about placing
    a value inside the storage box, as shown in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对于每种类型，我们将一个值初始化到变量中。想象一下将一个值放入存储盒中，就像下面的代码所示：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Whether we declare and initialize separately or together is probably dependent
    upon the specific situation. The important thing is that we must do both:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否分开声明和初始化可能取决于具体情况。重要的是我们必须两者都做：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code would cause the following result:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将导致以下结果：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is a significant exception to this rule. Under certain circumstances variables
    can have **default values**. We will see this in [Chapter 6](ch06.xhtml "Chapter 6. OOP
    – Using Other People's Hard Work"), *OOP – Using Other People's Hard Work*. But
    it is good practice to both declare and initialize variables.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则有一个重要的例外。在某些情况下，变量可以有**默认值**。我们将在[第6章](ch06.xhtml "第6章 OOP – 使用其他人的辛勤工作")中看到这一点，但是良好的做法是同时声明和初始化变量。
- en: Changing variables with operators
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用运算符更改变量
- en: 'Of course, in almost any program, we are going to need to do something with
    these values. Here is a list of perhaps the most common Java operators that allow
    us to manipulate variables. You do not need to memorize them as we will look at
    every line of code when we use them for the first time:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在几乎任何程序中，我们都需要对这些值进行操作。以下是可能是最常见的Java运算符列表，它们允许我们操作变量。您不需要记住它们，因为我们第一次使用它们时会逐行查看代码：
- en: '**The assignment operator (=)**: This makes the variable to the left of the
    operator the same as the value to the right. For example, `hiScore = score;` or
    `score = 100;`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**赋值运算符（=）**：这使得操作符左边的变量与右边的值相同。例如，`hiScore = score;`或`score = 100;`。'
- en: '**The addition operator (+)**: This adds the values on either side of the operator.
    It is usually used in conjunction with the assignment operator, such as `score
    = aliensShot + wavesCleared;` or `score = score + 100;`. Notice that it is perfectly
    acceptable to use the same variable simultaneously on both sides of an operator.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加法运算符（+）**：这会将运算符两侧的值相加。通常与赋值运算符一起使用，例如`score = aliensShot + wavesCleared;`或`score
    = score + 100;`。请注意，同时在运算符的两侧使用相同的变量是完全可以接受的。'
- en: '**The subtraction operator (-)**: This subtracts the value on the right side
    of the operator from the value on the left. It is usually used in conjunction
    with the assignment operator, such as `lives = lives - 1;` or `balance = income
    - outgoings;`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减法运算符（-）**：这会将运算符右侧的值从左侧的值中减去。通常与赋值运算符一起使用，例如`lives = lives - 1;`或`balance
    = income - outgoings;`。'
- en: '**The division operator (/)**: This divides the number on the left by the number
    on the right. Again, it is usually used in conjunction with the assignment operator,
    as shown in `fairShare = numSweets / numChildren;` or `recycledValueOfBlock =
    originalValue / .9;`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**除法运算符（/）**：这会将左侧的数字除以右侧的数字。同样，通常与赋值运算符一起使用，如`fairShare = numSweets / numChildren;`或`recycledValueOfBlock
    = originalValue / .9;`。'
- en: '**The multiplication operator (*)**: This multiplies variables and numbers,
    such as `answer = 10 * 10;` or `biggerAnswer = 10 * 10 * 10;`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乘法运算符（*）**：这会将变量和数字相乘，例如`answer = 10 * 10;`或`biggerAnswer = 10 * 10 * 10;`。'
- en: '**The increment operator (++)**: This is a really neat way to add `1` to the
    value of a variable. The `myVariable = myVariable + 1;` statement is the same
    as `myVariable++;`.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递增运算符（++）：这是一个非常简洁的方法，可以将变量的值加1。`myVariable = myVariable + 1;`语句与`myVariable++;`相同。
- en: '**The decrement operator (--)**: You guessed it: a really neat way to subtract
    `1` from something. The `myVariable = myVariable -1;` statement is the same as
    `myVariable--;`.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**递减运算符（--）**：你猜对了：这是一个非常简洁的方法，可以从某个值中减去1。`myVariable = myVariable -1;`语句与`myVariable--;`相同。'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The formal names for these operators are slightly different from the names used
    here for explanation. For example, the division operator is actually one of the
    multiplicative operators. But the preceding names are far more useful for the
    purpose of learning Java and if you used the term "division operator", while conversing
    with someone from the Java community, they would know exactly what you mean.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符的正式名称与此处用于解释的名称略有不同。例如，除法运算符实际上是乘法运算符之一。但是，前面的名称对于学习Java来说更有用，如果您在与Java社区的某人交谈时使用术语“除法运算符”，他们会完全明白您的意思。
- en: There are actually many more operators than these in Java. We will see a whole
    bunch later in this chapter when we learn about decisions in Java.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Java中有比这更多的运算符。当我们在本章后面学习Java中的决策时，我们将看到更多的运算符。
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are curious about operators there is a complete list of them on the Java
    website at [http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html).
    All the operators required to complete the projects in this book will be fully
    explained in this book. The link is provided for the curious among us.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对运算符感到好奇，可以在Java网站上找到完整的运算符列表[http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html)。本书中完成项目所需的所有运算符都将在本书中得到充分解释。链接是为我们中的好奇者提供的。
- en: Expressing yourself in Java
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Java表达自己
- en: Let's try using some declarations, assignments and operators. When we bundle
    these elements together into some meaningful syntax, we call it an expression.
    So let's write a quick app to try some out.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一些声明、赋值和运算符。当我们将这些元素捆绑到一些有意义的语法中时，我们称之为表达式。因此，让我们编写一个快速应用程序来尝试一些内容。
- en: Here we will make a little side project so we can play with everything we have
    learned so far. We will need to create a new project, just as we did in the previous
    chapter but we will not need a UI this time.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将制作一个小的辅助项目，以便我们可以玩转到目前为止学到的所有内容。我们需要创建一个新项目，就像我们在上一章中所做的那样，但这次我们不需要UI。
- en: 'Instead, we will simply write some Java code and examine its effects by outputting
    the values of variables to the Android console, called **logcat**. We will see
    exactly how this works by building the simple project and examining the code and
    the console output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将简单地编写一些Java代码，并通过将变量的值输出到名为**logcat**的Android控制台来检查其效果。我们将通过构建简单的项目并检查代码和控制台输出来看到这是如何工作的：
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The following is a quick reminder of how to create a new project.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何创建新项目的快速提醒。
- en: Close any currently open projects by navigating to **File** | **Close Project**.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**文件** | **关闭项目**关闭当前打开的任何项目。
- en: Click on **Start a** **new Android Studio project**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开始一个新的Android Studio项目**。
- en: The **Create New Project** configuration window will appear. Fill in the **Application
    name** field and **Company Domain** with `packtpub.com` or you could use your
    own company website name here instead.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建新项目**配置窗口将出现。在**应用程序名称**字段和**公司域**中填写`packtpub.com`，或者您可以在此处使用您自己公司的网站名称。'
- en: 'Now click on the **Next** button. On the next screen, make sure the **Phone
    and Tablet** checkbox has a tick in it. Now we have to choose the earliest version
    of Android we want to build our app for. Go ahead and play with a few options
    in the drop-down selector. You will see that the earlier the version we select,
    the greater is the percentage of devices our app can support. However, the trade-off
    here is that the earlier the version we select fewer cutting-edge Android features
    will be available in our apps. A good balance is to select **API 8: Android 2.2
    (Froyo)**.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击**下一步**按钮。在下一个屏幕上，确保**手机和平板电脑**复选框中有一个勾选。现在我们必须选择我们想要为其构建应用程序的最早版本的Android。随便尝试一下下拉选择器中的几个选项。您会发现我们选择的版本越早，我们的应用程序支持的设备百分比就越大。但是，这里的权衡是，我们选择的版本越早，我们的应用程序中可用的最新Android功能就越少。一个很好的平衡是选择**API
    8：Android 2.2（Froyo）**。
- en: Click on **Next**. Now select **Blank Activity** and click on **Next** again.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**下一步**。现在选择**空白活动**，然后再次单击**下一步**。
- en: On the next screen, simply change **Activity Name** to `MainActivity` and click
    on **Finish**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，只需将**Activity Name**更改为`MainActivity`，然后单击**Finish**。
- en: As we did in [Chapter 2](ch02.xhtml "Chapter 2. Getting Started with Android"),
    *Getting Started with Android*, to keep our code clear and simple, you can delete
    the two unneeded methods (`onCreateOptionsMenu` and `onOptionsItemSelected`) and
    their associated `@override` and `@import` statements. However, this is not necessary
    for the example to work.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们在[第2章](ch02.xhtml "第2章。开始使用Android")中所做的那样，*开始使用Android*，为了保持我们的代码清晰简单，您可以删除两个不需要的方法（`onCreateOptionsMenu`和`onOptionsItemSelected`）及其相关的`@override`和`@import`语句。但是，这对于示例的工作并不是必要的。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For a detailed explanation and images of creating a new project, see [Chapter
    2](ch02.xhtml "Chapter 2. Getting Started with Android"), *Getting Started with
    Android*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有关创建新项目的详细说明和图像，请参见[第2章](ch02.xhtml "第2章。开始使用Android")中的*开始使用Android*。
- en: As with all the examples and projects in this book, you can copy or review the
    code from the download bundle. You will find the code for this tutorial in the
    `Chapter3/ExpressionsInJava/MainActivity.java` file. Just create the project as
    described previously and paste the code from `MainActivity.java` file from the
    download bundle to the `MainActivity.java` file that was generated when you created
    the project in Android Studio. Just ensure that the package name is the same as
    the one you chose when the project was created. However, I strongly recommend
    going along with the tutorial so that we can learn how to do everything for ourselves.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的所有示例和项目一样，您可以从下载包中复制或查看代码。您将在`Chapter3/ExpressionsInJava/MainActivity.java`文件中找到本教程的代码。只需按照以前描述的方式创建项目，并将下载包中的`MainActivity.java`文件中的代码粘贴到在Android
    Studio中创建项目时生成的`MainActivity.java`文件中。只需确保包名称与创建项目时选择的包名称相同。但是，我强烈建议跟着教程一起学习，这样我们就可以学会如何自己做一切。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As this app uses the logcat console to show its output, you should run this
    app on the emulator only and not on a real Android device. The app will not harm
    a real device, but you just won't be able to see anything happening.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此应用程序使用logcat控制台显示其输出，因此您应该仅在模拟器上运行此应用程序，而不是在真实的Android设备上运行。该应用程序不会损害真实设备，但您将无法看到任何发生的事情。
- en: Create a new blank project called `Expressions In Java`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Expressions In Java`的新空白项目。
- en: 'Now, in the `onCreate` method just after the line where we use the `setContentView`
    method, add this code to declare and initialize some variables:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`onCreate`方法中，在我们使用`setContentView`方法的那一行之后，添加以下代码来声明和初始化一些变量：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now add the following code. This code simply outputs the value of our variables
    in a form where we can closely examine them in a minute:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加以下代码。这段代码简单地输出了我们的变量的值，以便我们可以在一分钟内仔细检查它们：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now let''s change our variables using the addition operator and another new
    operator. See if you can work out the output values for variables `a`, `b`, and
    `c` before looking at the output and the code explanation:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用加法运算符和另一个新的运算符来改变我们的变量。在查看输出和代码解释之前，看看你能否计算出变量`a`、`b`和`c`的输出值：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s output the values once more in the same way we did in step 3, but this
    time, the output should be different:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次以与步骤3相同的方式输出值，但这次，输出应该是不同的：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the program on an emulator in the usual way. You can see the output by clicking
    on the **Android** tab from our "useful tabs" area below the Project Explorer.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以通常的方式在模拟器上运行程序。您可以通过单击**Android**选项卡来查看输出，该选项卡位于项目资源管理器下方的“有用选项卡”区域。
- en: 'Here is the output, with some of the unnecessary formatting stripped off:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出，其中去掉了一些不必要的格式：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now let''s discuss what happened. In step 2, we declared and initialized three
    variables:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一下发生了什么。在第2步中，我们声明并初始化了三个变量：
- en: '`a`: This is an int that holds the value 10'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`：这是一个int，其值为10'
- en: '`b`: This is a string that holds the name of an eminent computer scientist.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`：这是一个字符串，其中包含一位杰出的计算机科学家的名字。'
- en: '`c`: This is a Boolean that holds the value false'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`：这是一个布尔值，其值为false'
- en: 'So when we output the values in step 3, it should be no surprise that we get
    the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当我们在步骤3中输出数值时，我们得到以下结果应该不足为奇：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In step 4, all the fun stuff happens. We add 1 to the value of our int `a`
    using the increment operator like this: `a++;`. Remember that `a++` is the same
    as `a = a + 1`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，所有有趣的事情发生了。我们使用增量运算符将1添加到我们的int `a`的值，就像这样：`a++;`。请记住，`a++`与`a = a + 1`是相同的。
- en: 'We then add 10 to `a`. Note we are adding 10 to `a` after having already added
    1\. So we get this output for a 10 + 1 + 10 operation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将10添加到`a`。请注意，我们是在已经添加1之后将10添加到`a`。所以我们得到了这样的输出，进行了10 + 1 + 10的操作：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now let's examine our string, `b`. We appear to be using the addition operator
    on our eminent scientist. What is happening is what you could probably guess.
    We are adding together two strings `"Alan Turing"` and `"was smarter than the
    average bear Booboo."` When you add two strings together it is called **concatenating**
    and the `+` symbol doubles as the concatenation operator.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一下我们的字符串`b`。我们似乎在我们杰出的科学家身上使用了加法运算符。正在发生的事情可能正是你猜到的。我们将两个字符串“Alan Turing”和“was
    smarter than the average bear Booboo.”相加在一起时，它被称为**连接**，`+`符号同时也是连接运算符。
- en: Finally, for our string, we appear to be adding `int a` to it. This is allowed
    and the value of `a` is concatenated to the end of `b`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于我们的字符串，我们似乎在其中添加了`int a`。这是允许的，`a`的值被连接到`b`的末尾。
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This does not work the other way round; you cannot add a string to an `int`.
    This makes sense as there is no logical answer.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不适用于反向操作；你不能将一个字符串添加到一个`int`。这是有道理的，因为没有逻辑上的答案。
- en: '`a = a + b`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`a = a + b`'
- en: '![Expressing yourself in Java](img/8859OS_03_07.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![在Java中表达自己](img/8859OS_03_07.jpg)'
- en: 'Finally, let''s look at the code that changes our Boolean, `c`, from true to
    false: `c = (1+1=3);`. Here, we are assigning to `c` the value of the expression
    contained within the brackets. This would be straightforward, but why the double
    equals (`==`)? We have jumped ahead of ourselves a little. The double equals sign
    is another operator called the **comparison** operator.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下改变我们的布尔值`c`从true变为false的代码：`c = (1+1=3);`。在这里，我们将括号中的表达式的值赋给了`c`。这本来很简单，但为什么要用双等号（`==`）呢？我们有点超前了。双等号是另一个叫做**比较**运算符的操作符。
- en: So we are really asking, *does* 1+1 equal 3? Clearly the answer is false. You
    might ask, "why use `==` instead of `=`?" Simply to make it clear to the compiler
    when we mean to assign and when we mean to compare.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们真的在问，“1+1”是否等于3？显然答案是否定的。你可能会问，“为什么要使用`==`而不是`=`？”简单地说，这是为了让编译器清楚地知道我们是要赋值还是要比较。
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Inadvertently using `=` instead of `==` is a very common error.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 无意中使用`=`而不是`==`是一个非常常见的错误。
- en: The assignment operator (`=`) assigns the value on the right to the value on
    the left, while the comparison operator (`==`) compares the values on either side.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符（`=`）将右边的值赋给左边的值，而比较运算符（`==`）比较两边的值。
- en: The compiler will warn us with an error when we do this but at first glance
    you might swear the compiler is wrong. We will learn more on this comparison operator
    and others later in the chapter and throughout the book.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，编译器会用错误警告我们，但乍一看你可能会觉得编译器错了。我们将在本章和整本书中更多地了解这个比较运算符和其他运算符。
- en: Now let's use everything we know and a bit more to make our math game project.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们利用我们所知道的一切，再加一点，来制作我们的数学游戏项目。
