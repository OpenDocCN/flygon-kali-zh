- en: '*Chapter 22*: Particle Systems and Handling Screen Touches'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第22章*：粒子系统和处理屏幕触摸'
- en: We already have the real-time system that we implemented in the previous chapter
    using a thread. In this chapter, we will create the entities that will exist and
    evolve in this real-time system as if they have a mind of their own; they will
    form the appearance of the drawings that the user can achieve.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中使用线程实现了实时系统。在本章中，我们将创建将存在并在这个实时系统中发展的实体，就好像它们有自己的思想一样；它们将形成用户可以实现的绘图的外观。
- en: We will also see how the user implements these entities by learning how to respond
    to interaction with the screen. This is different to interacting with a widget
    in a UI layout.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到用户如何通过学习如何响应与屏幕的交互来实现这些实体。这与在UI布局中与小部件交互是不同的。
- en: 'Here is what is coming up in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章即将涉及的内容：
- en: Adding custom buttons to the screen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向屏幕添加自定义按钮
- en: Coding the `Particle` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写`Particle`类
- en: Coding the `ParticleSystem` class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写`ParticleSystem`类
- en: Handling screen touches
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理屏幕触摸
- en: The Android Studio Profiler tool
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio Profiler工具
- en: We will start by adding a custom UI to our app.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为我们的应用程序添加自定义UI。
- en: WARNING
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: This app produces bright flashing colors. It may cause discomfort or seizures
    for people with photosensitive epilepsy. Reader discretion is advised. You might
    like to simply read the theory for this project and not run the completed project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序产生明亮的闪烁颜色。这可能会引起光敏性癫痫的人不适或癫痫发作。请谨慎阅读。您可能只想阅读这个项目的理论，而不运行完成的项目。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2022](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2022).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中的代码文件，网址为[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2022](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2022)。
- en: Adding custom buttons to the screen
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向屏幕添加自定义按钮
- en: We need to let the user control when to start another drawing and clear the
    screen of their previous work. We need the user to be able to decide if and when
    to bring the drawing to life. To achieve this, we will add two buttons to the
    screen, one for each of the tasks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要让用户控制何时开始另一次绘制，并清除他们以前的作品。我们需要让用户能够决定何时以及何时将绘图带到生活中。为了实现这一点，我们将在屏幕上添加两个按钮，每个任务一个按钮。
- en: 'Add the members highlighted next in the `LiveDrawingView` class:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LiveDrawingView`类中添加下面突出显示的成员：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We now have two `RectF` instances. These objects hold four floating-point coordinates
    each, one coordinate for each corner of our two proposed buttons.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个`RectF`实例。这些对象每个都包含四个浮点坐标，每个按钮的每个角落一个坐标。
- en: 'Initialize the positions in the constructor of `LiveDrawingView`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LiveDrawingView`的构造函数中初始化位置：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the `import` for the `RectF` class:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`RectF`类的`import`：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we have added actual coordinates for the buttons. If you visualize the coordinates
    on the screen, then you will see they are in the top left-hand corner with the
    pause button just below the reset/clear button.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为按钮添加了实际的坐标。如果您在屏幕上可视化坐标，您会看到它们位于左上角，暂停按钮就在重置/清除按钮的下方。
- en: 'Now we can draw the buttons. Add these two lines of code in the `draw` method
    of the `LiveDrawingView` class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以绘制按钮。在`LiveDrawingView`类的`draw`方法中添加以下两行代码：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The new code uses an overridden version of the `drawRect` method, and we simply
    pass our two `RectF` instances straight in alongside the usual `Paint` instance.
    Our buttons will now be drawn to the screen.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码使用了`drawRect`方法的重写版本，我们只需将两个`RectF`实例与通常的`Paint`实例一起传递进去。我们的按钮现在将被绘制到屏幕上。
- en: We will see how we interact with these slightly crude buttons later in the chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看到如何与这些略显粗糙的按钮进行交互。
- en: Implementing a particle system effect
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现粒子系统效果
- en: A particle system is a system that controls particles. In our case, `ParticleSystem`
    is a class we will write that will spawn instances (lots of instances) of the
    `Particle` class (also a class we will write) that will create a simple explosion-like
    effect.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统是控制粒子的系统。在我们的情况下，`ParticleSystem`是一个我们将编写的类，它将生成`Particle`类的实例（许多实例），从而创建一个简单的爆炸效果。
- en: 'Here is an image of some particles controlled by a particle system:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张由粒子系统控制的一些粒子的图像：
- en: '![Figure 22.1 – Particle system effect'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.1 - 粒子系统效果'
- en: '](img/Figure_22.01_B16773.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.01_B16773.jpg)'
- en: Figure 22.1 – Particle system effect
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.1 - 粒子系统效果
- en: Just for clarification, each of the colored squares is an instance of the `Particle`
    class and all the `Particle` instances are controlled and held by the `ParticleSystem`
    class. In addition, the user will create multiple (hundreds) of `ParticleSystem`
    instances by drawing with their finger. The particles will appear as dots or blocks
    until the user taps the pause button, when they will come to life. We will examine
    the code closely enough that you will be able to set, in code, the size, color,
    speed, and quantity of `Particle` and `ParticleSystem` instances.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，每个彩色方块都是`Particle`类的一个实例，所有`Particle`实例都由`ParticleSystem`类控制和持有。此外，用户将通过用手指绘制来创建多个（数百个）`ParticleSystem`实例。粒子将显示为点或块，直到用户点击暂停按钮时才会活跃起来。我们将仔细检查代码，以便您能够在代码中设置`Particle`和`ParticleSystem`实例的大小、颜色、速度和数量。
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is left as an exercise for the reader to add additional buttons to the screen
    to allow the user to change these properties as a feature of the app.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可以在屏幕上添加额外的按钮，以允许用户更改这些属性作为应用程序的一个特性。
- en: We will start by coding the `Particle` class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从编写`Particle`类开始。
- en: Coding the Particle class
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`Particle`类
- en: 'Add the `import` statement, the member variables, and the constructor method,
    as shown in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下代码中所示的`import`语句、成员变量和构造方法添加：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have two members: one for velocity and one for position. They are both `PointF`
    objects. `PointF` holds two float values. The position is simple; it is just a
    horizontal and vertical value. The velocity is worth explaining a little more.
    Each of the two values in `PointF` will be a speed, one horizontal and the other
    vertical. It is the combination of these two speeds that will imply a direction.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个成员变量：一个用于速度，一个用于位置。它们都是`PointF`对象。`PointF`包含两个浮点值。位置很简单；它只是一个水平和垂直值。速度值值得更详细解释。`PointF`中的两个值将是速度，一个是水平的，另一个是垂直的。这两个速度的组合将意味着一个方向。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the constructor, the two new `PointF` objects are instantiated and the `x`
    and `y` values of `mVeleocity` are initialized with the values passed in by the
    `PointF direction` parameter. Notice the way in which the values are copied from
    `direction` to `mVelocity`. Now, `PointF mVelocity` is not a reference to `PointF`
    passed in as a parameter. Each `Particle` instance will copy the values from `direction`
    (and they will be different for each instance), but `mVelocity` has no lasting
    connection to `direction`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，两个新的`PointF`对象被实例化，并且`mVeleocity`的`x`和`y`值被初始化为由`PointF direction`参数传入的值。注意值是如何从`direction`复制到`mVelocity`的。现在，`PointF
    mVelocity`不是作为参数传入的`PointF`的引用。每个`Particle`实例将从`direction`复制值（对于每个实例它们将是不同的），但`mVelocity`与`direction`没有持久的连接。
- en: 'Next, add these three methods, and then we can then talk about them:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下三种方法，然后我们可以讨论它们：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Perhaps unsurprisingly, there is an `update` method. Each `Particle` instance's
    `update` method will be called each frame of the app by the `ParticleSystem` class'
    `update` method, which in turn will be called by the `LiveDrawingView` class (again
    in the `update` method), which we will code later in the chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 也许并不奇怪，有一个`update`方法。`Particle`实例的`update`方法将由`ParticleSystem`类的`update`方法在应用程序的每一帧调用，而`ParticleSystem`类的`update`方法将由`LiveDrawingView`类（在`update`方法中）调用，我们将在本章后面编写。
- en: Inside the `update` method, the horizontal and vertical values of `mPosition`
    are updated using the corresponding values of `mVelocity`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法中，使用`mVelocity`的相应值更新`mPosition`的水平和垂直值。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that we don't bother using the current frame rate in the update. You
    could amend this if you want to be certain that your particles will all fly at
    exactly the correct speed. But all the speeds are going to be random anyway. There
    is not much to gain from adding this extra calculation (for every particle). As
    we will soon see, however, the `ParticleSystem` class will need to take account
    of the current frames per second to measure how long it should run for.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在更新中没有使用当前帧速率。如果您想确保粒子以完全正确的速度飞行，可以修改这一点。但是所有速度都将是随机的。增加这个额外的计算并没有太多好处（对于每个粒子）。然而，正如我们很快将看到的，`ParticleSystem`类将需要考虑当前每秒帧数，以测量它应该运行多长时间。
- en: Next, we coded the `setPosition` method. Notice that the method receives `PointF`,
    which is used to set the initial position. The `ParticleSystem` class will pass
    this position in when the effect is triggered.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写了`setPosition`方法。请注意，该方法接收`PointF`，用于设置初始位置。`ParticleSystem`类将在触发效果时传递此位置。
- en: Finally, we have the `getPosition` method. We need this method so that the `ParticleSystem`
    class can draw all the particles in the correct position. We could have added
    a `draw` method to the `Particle` class instead of the `getPosition` method and
    had the `Particle` class draw itself. In this implementation, there is no particular
    benefit to either option.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`getPosition`方法。我们需要这个方法，以便`ParticleSystem`类可以在正确的位置绘制所有粒子。我们本可以在`Particle`类中添加一个`draw`方法，而不是`getPosition`方法，并让`Particle`类自己绘制。在这个实现中，两种选项都没有特别的好处。
- en: Now we can move on to the `ParticleSysytem` class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续`ParticleSysytem`类。
- en: Coding the ParticleSystem class
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`ParticleSystem`类。
- en: 'The `ParticleSystem` class has a few more details than the `Particle` class,
    but it is still reasonably straightforward. Remember what we need to achieve with
    this class: hold, spawn, update, and draw a bunch (quite a big bunch) of `Particle`
    instances.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParticleSystem`类比`Particle`类有更多的细节，但仍然相当简单。记住我们需要用这个类实现的目标：保存、生成、更新和绘制一堆（相当大的一堆）`Particle`实例。'
- en: 'Add the following members and `import` statements:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下成员和`import`语句：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have four member variables: first, a `float` variable called `mDuration`
    that will be initialized to the number of seconds we want the effect to run for.
    The `ArrayList` instance called `mParticles` holds `Particle` instances and will
    hold all the `Particle` objects we instantiate.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有四个成员变量：首先，一个名为`mDuration`的`float`变量，它将被初始化为我们希望效果运行的秒数。名为`mParticles`的`ArrayList`实例保存`Particle`实例，并将保存我们实例化的所有`Particle`对象。
- en: The `Random` instance called `random` is created as a member because we need
    to generate so many random values that creating a new object each time would be
    sure to slow us down a bit.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 称为`random`的`Random`实例被创建为成员，因为我们需要生成如此多的随机值，每次创建一个新对象都会减慢速度。
- en: Finally, the `mIsRunning` Boolean will track whether the particle system is
    currently being shown (updating and drawing).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`mIsRunning`布尔值将跟踪粒子系统当前是否正在显示（更新和绘制）。
- en: Now we can code the `init` method. This method will be called each time we want
    a new `ParticleSystem`. Notice that the one and only parameter is an `int` parameter
    called `numParticles`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写`init`方法。每当我们想要一个新的`ParticleSystem`时，将调用此方法。请注意，唯一的参数是一个名为`numParticles`的`int`参数。
- en: 'When we call `init`, we can have some fun initializing crazy amounts of particles.
    Add the `init` method and then we will look more closely at the code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`init`时，我们可以有一些乐趣初始化疯狂数量的粒子。添加`init`方法，然后我们将更仔细地查看代码：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `init` method consists of just one `for` loop that does all the work. The
    `for` loop runs from zero to `numParticles-1`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`方法只包括一个`for`循环，完成所有工作。`for`循环从零到`numParticles-1`运行。'
- en: First, a random number between zero and 359 is generated and stored in the `float`
    variable called `angle`. Next, there is a little bit of math and we multiply `angle`
    by `3.14/180`. This turns the angle in degrees to radian measurements, which are
    required by the `Math` class we will use in a moment.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，生成一个介于零和359之间的随机数，并存储在名为`angle`的`float`变量中。接下来，进行一些数学运算，将`angle`乘以`3.14/180`。这将角度从度转换为弧度测量，这是`Math`类在稍后将要使用的。
- en: Then we generate another random number between 1 and 10 and assign the result
    to a `float` variable called `speed`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们生成另一个1到10之间的随机数，并将结果赋给一个名为`speed`的`float`变量。
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I have added comments to suggest different options for values in this part of
    the code. I do this in several places in the `ParticleSystem` class and when we
    get to the end of the chapter, we will have some fun altering these values to
    see what effect it has on the drawing app.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经添加了注释，建议在代码的这部分中使用不同的值。我在`ParticleSystem`类的几个地方都这样做了，当我们到达章节的末尾时，我们将乐趣地改变这些值，看看对绘图应用有什么影响。
- en: Now that we have a random angle and speed, we can convert and combine them into
    a vector that can be used inside the `update` method of the `Particle` class to
    update its position each frame.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个随机角度和速度，我们可以将它们转换并组合成一个矢量，该矢量可以在`Particle`类的`update`方法中使用，以更新其每帧的位置。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'A vector is a value that determines both direction and speed. Our vector is
    stored in the `direction` object until it is passed into the `Particle` constructor.
    Vectors can be of many dimensions. Ours is of two dimensions and therefore defines
    a heading between zero and 359 degrees and a speed between 1 and 10\. You can
    read more about vectors, headings, sine, and cosine on my website here: [http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量是一个确定方向和速度的值。我们的矢量存储在`direction`对象中，直到传递到`Particle`构造函数中。矢量可以是多维的。我们的矢量是二维的，因此定义了0到359度之间的航向和1到10之间的速度。您可以在我的网站上阅读更多关于矢量、航向、正弦和余弦的内容：[http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/)。
- en: 'The single line of code that uses `Math.sin` and `Math.cos` to create a vector
    I have decided not to explain in full, because the magic occurs partly in the
    following formulas:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Math.sin`和`Math.cos`创建矢量的单行代码，我决定不完全解释，因为其中的魔法部分在以下公式中发生：
- en: Cosine of an angle * `speed`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角度的余弦 * `speed`
- en: Sine of an angle * `speed`
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角度的正弦 * `speed`
- en: It also happens partly in the hidden calculations within the cosine and sine
    functions provided by the `Math` class. If you want to know their full details,
    see the previous tip box.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这也在`Math`类提供的余弦和正弦函数的隐藏计算中部分发生。如果您想了解它们的全部细节，请参阅前面的提示框。
- en: Finally, a new `Particle` is created and then added to the `mParticles ArrayList`
    instance.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建一个新的`Particle`，然后将其添加到`mParticles ArrayList`实例中。
- en: 'Next, we will code the `update` method. Notice that the `update` method does
    need the current frame rate as a parameter. Code the `update` method shown next:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写`update`方法。请注意，`update`方法确实需要当前帧速率作为参数。编写如下所示的`update`方法：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first thing that happens inside the `update` method is that the elapsed
    time is taken off `mDuration`. Remember that the `fps` parameter is the frames
    per second, so `1/fps` gives a value as a fraction of a second.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法内部发生的第一件事是减去`mDuration`的经过时间。请记住，`fps`参数是每秒帧数，所以`1/fps`会给出一个作为秒的分数值。'
- en: Next, there is an enhanced `for` loop that calls the `update` method for every
    `Particle` instance in the `mParticles` `ArrayList` instance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个增强的`for`循环，调用`mParticles` `ArrayList`实例中每个`Particle`实例的`update`方法。
- en: Finally, the code checks to see if the particle effect has run its course with
    `if(mDuration < 0)`, and if it has, it sets `mIsRunning` to `false`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码检查粒子效果是否已经完成，使用`if(mDuration < 0)`，如果是，则将`mIsRunning`设置为`false`。
- en: Now we can code the `emitParticles` method, which will set each `Particle` instance
    running. This is not to be confused with `init`, which creates all the new particles
    and gives them their velocities. The `init` method will be called once before
    the user gets to interact, while the `emitParticles` method will be called each
    time the effect needs to be started as the user draws on the screen.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写`emitParticles`方法，它将使每个`Particle`实例运行。这不应与`init`混淆，后者创建所有新的粒子并赋予它们速度。`init`方法将在用户开始交互之前调用一次，而`emitParticles`方法将在每次需要启动效果时调用，用户在屏幕上绘制时。
- en: 'Add the `emitParticles` method:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`emitParticles`方法：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, notice that a `PointF` reference for where all the particles will start
    is passed in as a parameter. All the particles will start at exactly the same
    position and then fan out each frame based on their individual velocities.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意将所有粒子的起始位置作为参数传递给`PointF`引用。所有粒子将从完全相同的位置开始，然后根据它们各自的速度每帧扩散。
- en: The `mIsRunning` Boolean is set to `true` and `mDuration` is set to `1f`, so
    the effect will run for one second, and the enhanced `for` loop calls `setPosition`
    for every particle to move them to the starting coordinates.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`mIsRunning`布尔值设置为`true`，`mDuration`设置为`1f`，所以效果将持续一秒，增强的`for`循环调用`setPosition`来移动每个粒子到起始坐标。'
- en: The final method for our `ParticleSysytem` class is the `draw` method, which
    will reveal the effect in all its glory. The method receives a reference to a
    `Canvas` instance and a `Paint` instance, so it can draw to the same canvas that
    the `LiveDrawingView` class has just locked in its `draw` method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`ParticleSysytem`类的最后一个方法是`draw`方法，它将展示效果的全部荣耀。该方法接收一个`Canvas`实例和一个`Paint`实例的引用，因此它可以在`LiveDrawingView`类的`draw`方法中锁定的相同画布上绘制。
- en: 'Add the `draw` method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`draw`方法：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An enhanced `for` loop steps through each of the `Particle` instances in the
    `mParticles` `ArrayList` instance. Each `Particle`, in turn, is drawn using the
    `drawRect` method and the `getPosition` method. Notice the call to the `paint.setARGB`
    method. You will see that we generate each of the color channels randomly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 增强的`for`循环遍历`mParticles` `ArrayList`实例中的每个`Particle`实例。依次使用`drawRect`方法和`getPosition`方法绘制每个`Particle`。请注意调用`paint.setARGB`方法。您将看到我们随机生成每个颜色通道。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Notice in the comments that I have suggested different options for code changes
    so we can have some fun when we have finished coding.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意评论中我建议了不同的代码更改选项，这样在完成编码后我们就可以玩得更开心。
- en: We can now start to put the particle system to work.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始让粒子系统工作了。
- en: Spawning particle systems in the LiveDrawingView class
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`LiveDrawingView`类中生成粒子系统
- en: 'Add an `ArrayList` instance full of systems and some more members to keep track
    of things. Add the highlighted code in the positions indicated by the existing
    comments:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个充满系统的`ArrayList`实例和一些其他成员来跟踪事物。在现有注释所指示的位置添加突出显示的代码：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Import the `ArrayList` class as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ArrayList`类导入如下：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can now keep track of up to 1,000 particle systems with 100 particles in
    each. Feel free to play with these numbers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以跟踪多达1000个每个系统中有100个粒子的粒子系统。随意尝试调整这些数字。
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: On a modern device, you can run particles into the millions without any trouble,
    but on the emulator, it will struggle with just hundreds of thousands.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代设备上，您可以运行数百万个粒子而不会遇到任何问题，但在模拟器上，处理数十万个粒子就会有些吃力。
- en: 'Initialize the systems in the constructor by adding this highlighted code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下突出显示的代码在构造函数中初始化系统：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code loops through the `ArrayList` instance, calling the constructor and
    then the `init` method on each of the `ParticleSystem` instances.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码循环遍历`ArrayList`实例，对每个`ParticleSystem`实例调用构造函数，然后调用`init`方法。
- en: 'Update the systems for each frame of the loop by adding this highlighted code
    in the `update` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`update`方法中添加以下突出显示的代码，为循环的每一帧更新系统：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The previous code loops through each of the `ParticleSystem` instances, first
    checking if they are active and then calling the `update` method and passing in
    the current frames per second.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码循环遍历每个`ParticleSystem`实例，首先检查它们是否活动，然后调用`update`方法并传入当前的每秒帧数。
- en: 'Draw the systems for each frame of the loop by adding this highlighted code
    to the `draw` method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此突出显示的代码添加到`draw`方法中，为循环的每一帧绘制系统：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous code loops through `mParticleSystems`, calling the `draw` method
    on each. Of course, we haven't actually spawned any instances yet. For that, we
    will need to learn how to respond to screen interactions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码循环遍历`mParticleSystems`，对每个调用`draw`方法。当然，我们实际上还没有生成任何实例。为此，我们需要学习如何响应屏幕交互。
- en: Handling touches
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理触摸
- en: 'To get started, add the `OnTouchEvent` method to the `LiveDrawingView` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请将`OnTouchEvent`方法添加到`LiveDrawingView`类中：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is an overridden method and it is called by Android every time the user
    interacts with the screen. Look at the one and only parameter of the `OnTouchEvent`
    method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重写的方法，每当用户与屏幕交互时，Android都会调用它。查看`OnTouchEvent`方法的唯一参数。
- en: 'Import the `MotionEvent` class with this line of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码行导入`MotionEvent`类：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It turns out that `motionEvent` has a whole bunch of data tucked away inside
    of it and this data contains the details of the touch that just occurred. The
    operating system sent it to us because it knows we will probably need some of
    it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 原来`motionEvent`中隐藏了大量数据，这些数据包含了刚刚发生的触摸的详细信息。操作系统将其发送给我们，因为它知道我们可能需要其中的一些数据。
- en: Notice that I said *some* of it. The `MotionEvent` class is quite extensive.
    It contains within it dozens of methods and variables.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我说的是*一些*。`MotionEvent`类非常庞大。它包含了数十种方法和变量。
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We will uncover a few details of the `MotionEvent` class in this project. You
    can explore the `MotionEvent` class in full here: [https://stuff.mit.edu/afs/sipb/project/android/docs/reference/android/view/MotionEvent.html](https://stuff.mit.edu/afs/sipb/project/android/docs/reference/android/view/MotionEvent.html).
    Note that it is not necessary to do further research to complete this project.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将揭示`MotionEvent`类的一些细节。您可以在这里完整地探索`MotionEvent`类：[https://stuff.mit.edu/afs/sipb/project/android/docs/reference/android/view/MotionEvent.html](https://stuff.mit.edu/afs/sipb/project/android/docs/reference/android/view/MotionEvent.html)。请注意，完成此项目并不需要进行进一步的研究。
- en: For now, all we need to know is the screen coordinates at the precise moment
    when the player's finger moves across the screen, touches the screen, or is removed
    from the screen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需要知道在玩家的手指在屏幕上移动、触摸屏幕或从屏幕上移开时的精确时刻的屏幕坐标。
- en: Some of the variables and methods contained within `motionEvent` that we will
    use include the following.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`motionEvent`中包含的一些变量和方法，包括以下内容。
- en: The `getAction` method, which unsurprisingly "gets" the action that was performed.
    Unfortunately, it supplies this information in a slightly encoded format, which
    explains the need for some of these other variables.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAction`方法，意料之中地“获取”执行的动作。不幸的是，它以稍微编码的格式提供这些信息，这解释了其他一些变量的必要性。'
- en: The `ACTION_MASK` variable, which provides a value known as a mask, which with
    the help of a little bit more Java trickery can be used to filter the data from
    `getAction`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACTION_MASK`变量提供一个称为掩码的值，借助一些更多的Java技巧，可以用来过滤`getAction`的数据。'
- en: The `ACTION_UP` variable, which we can use to compare and see if the action
    performed is the one we want to respond to (removing a finger from the screen).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACTION_UP`变量，我们可以使用它来比较并查看执行的动作是否是我们想要响应的动作（从屏幕上移开手指）。'
- en: The `ACTION_DOWN` variable, which we can use to compare and see if the action
    performed is the one we want to respond to.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACTION_DOWN`变量，我们可以使用它来比较并查看执行的动作是否是我们想要响应的动作。'
- en: The `ACTION_MOVE` variable, which we can use to compare and see if the action
    performed is a move/drag.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACTION_MOVE`变量，我们可以用它来比较并查看执行的动作是否是移动/拖动。'
- en: The `getX` method, which tells us a horizontal floating-point coordinate of
    where the event happened.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getX`方法告诉我们事件发生的水平浮点坐标。'
- en: The `getY` method, which tells us a vertical floating-point coordinate of where
    the event happened.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getY`方法告诉我们事件发生的垂直浮点坐标。'
- en: As a specific example, say we need to filter the data returned by the `getAction`
    method using `ACTION_MASK` and see if the result is the same as `ACTION_UP`. If
    it is, then we know that the user has just removed their finger from the screen,
    perhaps because they just tapped a button. Once we are sure the event is of the
    correct type, we will need to find out where it happened using the `getX` and
    `getY` methods.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 举个具体的例子，假设我们需要使用`ACTION_MASK`过滤`getAction`方法返回的数据，并查看结果是否与`ACTION_UP`相同。如果是，那么我们知道用户刚刚从屏幕上移开手指，也许是因为他们刚刚点击了一个按钮。一旦我们确定事件是正确类型的，我们就需要使用`getX`和`getY`方法找出事件发生的位置。
- en: There is one final complication. The "Java trickery" I referred to is the `&`
    bitwise operator, not to be confused with the logical `&&` operator we have been
    using in conjunction with the `if` keyword.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个复杂之处在于，“Java诡计”我所指的是`&`位运算符，不要与我们一直与`if`关键字一起使用的逻辑`&&`运算符混淆。
- en: The `&` bitwise operator checks to see if each corresponding parts in two values
    are true. This is the filter that is required when using `ACTION_MASK` with `getAction`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`位运算符检查两个值中的每个对应部分是否为真。这是在使用`ACTION_MASK`与`getAction`时所需的过滤器。'
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Sanity check. I was hesitant to go into detail about `MotionEvent` and bitwise
    operators. It is possible to complete this entire book and even a professional-quality
    interactive app without ever needing to fully understand them. If you know that
    the line of code we write in the next section determines the event type the player
    has just triggered, that is all you need to know. I just guessed that a discerning
    reader such as yourself would like to know the ins and outs. In summary, if you
    understand bitwise operators, great, you are good to go. If you don''t, it doesn''t
    matter, you are still good to go. If you are curious about bitwise operators (there
    are quite a few), you can read more about them here: [https://en.wikipedia.org/wiki/Bitwise_operation](https://en.wikipedia.org/wiki/Bitwise_operation).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 理智检查。我不愿详细讨论`MotionEvent`和位运算符。完全可以完成整本书甚至一个专业质量的交互式应用程序，而不需要完全理解它们。如果你知道我们在下一节中写的代码行确定了玩家刚刚触发的事件类型，那就足够了。我只是猜想像你这样挑剔的读者可能想要了解其中的细节。总之，如果你理解位运算符，很好，你可以继续。如果你不理解，没关系，你仍然可以继续。如果你对位运算符感兴趣（有很多种），你可以在这里阅读更多关于它们的信息：[https://en.wikipedia.org/wiki/Bitwise_operation](https://en.wikipedia.org/wiki/Bitwise_operation)。
- en: Now we can code the `onTouchEvent` method and see all the `MotionEvent` stuff
    in action.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写`onTouchEvent`方法并查看所有`MotionEvent`的操作。
- en: Coding the onTouchEvent method
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`onTouchEvent`方法
- en: 'Handle the user moving their finger on the screen by adding this highlighted
    code inside the `onTouchEvent` method to the code we already have:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`onTouchEvent`方法中添加以下突出显示的代码来处理用户在屏幕上移动手指：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following line of code to import the `PointF` class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码行以导入`PointF`类：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `if` condition checks to see if the type of event was the user moving their
    finger. If it was, then the next particle system in `mParticleSystems` has its
    `emitParticles` method called. Afterward, the `mNextSystem` variable is incremented
    and a test is done to see if it was the last particle system. If it was, then
    `mNextSystem` is set to zero, ready to start reusing existing particle systems
    the next time one is required.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`条件检查事件类型是否是用户移动手指。如果是，那么`mParticleSystems`中的下一个粒子系统将调用其`emitParticles`方法。之后，`mNextSystem`变量递增，并进行测试以查看是否是最后一个粒子系统。如果是，那么`mNextSystem`将被设置为零，准备在下次需要时重新使用现有的粒子系统。'
- en: 'Handle the user pressing one of the buttons by adding this highlighted code
    right after the code we just discussed and before the `return` statement we have
    already coded:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们刚讨论过的代码之后并在我们已经编写的`return`语句之前添加以下突出显示的代码来处理用户按下按钮之一：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The condition of the `if` statement checks to see if the user has tapped the
    screen. If they have, then the `contains` method of the `RectF` class is used
    in conjunction with the `getX` and `getY` methods to see if that press was inside
    one of our custom buttons. If the reset button was pressed, all the particles
    will disappear because `mNextSystem` is set to zero. If the paused button is pressed,
    then the value of `mPaused` is toggled, causing the `update` method to stop/start
    being called in the thread.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句的条件检查用户是否点击了屏幕。如果是，那么`RectF`类的`contains`方法与`getX`和`getY`方法一起被用来检查这次按压是否在我们自定义按钮的范围内。如果按下重置按钮，所有的粒子都会消失，因为`mNextSystem`被设置为零。如果按下暂停按钮，那么`mPaused`的值将被切换，导致线程中的`update`方法停止/开始被调用。'
- en: Finishing the HUD
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成HUD
- en: 'Add the highlighted code to the `printDebuggingText` method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下突出显示的代码添加到`printDebuggingText`方法中：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code will print some interesting statistics to the screen to tell us how
    many particles and systems are currently being drawn.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在屏幕上打印一些有趣的统计数据，告诉我们当前绘制了多少粒子和系统。
- en: WARNING
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: This app produces bright flashing colors. It may cause discomfort or seizures
    for people with photosensitive epilepsy. Reader discretion is advised. You might
    like to simply read the theory for this project and not run the completed project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序会产生明亮的闪烁颜色。这可能会引起光敏性癫痫的人感到不适或发作。请谨慎阅读。您可能只想阅读这个项目的理论，而不运行已完成的项目。
- en: Running the app
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: Now we get to see the live drawing app in action and play with some of the different
    options we commented out in the code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到实时绘图应用程序的运行并尝试一些我们在代码中注释掉的不同选项。
- en: 'Run the app with small, round, colorful, fast particles. Just tap the screen
    in a few places:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小型、圆形、彩色、快速粒子运行应用程序。只需在屏幕上轻点几下：
- en: '![Figure 22.2 – Tap the screen'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.2 – 点击屏幕'
- en: '](img/Figure_22.2_B16773.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.2_B16773.jpg)'
- en: Figure 22.2 – Tap the screen
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.2 – 点击屏幕
- en: 'Then resume drawing:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后恢复绘图：
- en: '![Figure 22.3 – Tap results'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.3 – 点击结果'
- en: '](img/Figure_22.3_B16773.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.3_B16773.jpg)'
- en: Figure 22.3 – Tap results
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.3 – 点击结果
- en: 'Do a kid''s-style drawing with small, white, square, slow, long-duration particles:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小型、白色、方形、缓慢、长时间的粒子进行儿童风格的绘图：
- en: '![Figure 22.4 – The kid''s-style drawing'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.4 – 儿童风格的绘图'
- en: '](img/Figure_22.4_B16773.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.4_B16773.jpg)'
- en: Figure 22.4 – The kid's-style drawing
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.4 – 儿童风格的绘图
- en: 'Then un-pause the drawing and wait for 20 seconds while the drawing comes to
    life and changes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后取消绘图暂停，等待20秒，直到绘图活跃起来并发生变化：
- en: '![Figure 22.5 – The kid''s-style drawing result'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.5 – 儿童风格的绘图结果'
- en: '](img/Figure_22.5_B16773.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.5_B16773.jpg)'
- en: Figure 22.5 – The kid's-style drawing result
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.5 – 儿童风格的绘图结果
- en: Before we move on to our next project, the Live Drawing app gives us an excellent
    opportunity to explore another feature of Android Studio.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行下一个项目之前，Live Drawing应用程序为我们提供了一个很好的机会，可以探索Android Studio的另一个功能。
- en: The Android Studio Profiler tool
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Studio Profiler工具
- en: The Android Studio Profiler tool is quite complex and deep. But it is very simple
    to use it to do some really significant measurements with our app. We can see
    how much of the device's resources our app is using and therefore attempt to improve
    the efficiency of our app to make it run more efficiently and use less in the
    way of resources. By resources, I am talking about CPU and memory usage.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio Profiler工具非常复杂和深入。但是，使用它来进行一些真正重要的测量非常简单。我们可以看到我们的应用程序使用了设备资源的多少，因此可以尝试提高应用程序的效率，使其运行更高效，并且使用更少的资源。资源包括CPU和内存使用率。
- en: Code optimization is beyond the scope of the book, but a look at how we begin
    to monitor our app's performance is a good introduction. Select **View** from
    the main Android Studio menu and then select **Tool Windows** | **Profiler**.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 代码优化超出了本书的范围，但是我们开始监视应用程序性能的方式是一个很好的介绍。从主Android Studio菜单中选择**View**，然后选择**Tool
    Windows** | **Profiler**。
- en: 'You will see the following window in the lower area of Android Studio:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在Android Studio的下部区域看到以下窗口：
- en: '![Figure 22.6 – Android Studio window'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.6 – Android Studio窗口'
- en: '](img/Figure_22.6_B16773.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.6_B16773.jpg)'
- en: Figure 22.6 – Android Studio window
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.6 – Android Studio窗口
- en: To get started using the Profiler tool, run the Live Drawing app. The Profiler
    tool should begin to display graphs and data as shown in the next figure.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Profiler工具，请运行Live Drawing应用程序。Profiler工具应该开始显示图表和数据，如下图所示。
- en: 'Depending on the configuration of your PC firewall software, you might have
    to allow access for the Profiler tool to run. In addition, it is possible, but
    not certain, that you will have to left-click the **+** icon in the top left of
    the **Profiler** window, as highlighted in the preceding figure, and then select
    your AVD for the Profiler tool to connect to:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的PC防火墙软件的配置，您可能需要允许Profiler工具运行。此外，您可能需要在**Profiler**窗口左上角的**+**图标上单击，然后选择您的AVD，以便Profiler工具连接到：
- en: '![Figure 22.7 – live graph data'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.7 – 实时图表数据'
- en: '](img/Figure_22.7_B16773.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.7_B16773.jpg)'
- en: Figure 22.7 – live graph data
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.7 – 实时图表数据
- en: In the preceding figure, we can see live graph data for CPU usage, memory usage,
    network usage, and energy/battery usage. We will focus on CPU and memory usage.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到CPU使用率、内存使用率、网络使用率和能量/电池使用率的实时图表数据。我们将重点关注CPU和内存使用率。
- en: 'Hover your mouse over the **CPU** row and then the **MEMORY** row to see pop-up
    details for each of these metrics. This next figure shows the details on my PC
    for these two metrics, photoshopped together:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将鼠标悬停在**CPU**行，然后悬停在**MEMORY**行上，以查看每个指标的弹出详细信息。下图显示了我PC上这两个指标的详细信息，经过了Photoshop处理：
- en: '![Figure 22.8 – Pop-up details for each metric'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图22.8 – 每个指标的弹出详细信息'
- en: '](img/Figure_22.8_B16773.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_22.8_B16773.jpg)'
- en: Figure 22.8 – Pop-up details for each metric
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.8 – 每个指标的弹出详细信息
- en: It is possible, even likely, that you will see different values to me. The previous
    figure shows that roughly a quarter of the CPU is in use and around 121 MB of
    RAM is in use.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会看到与我不同的值。前面的图表显示大约四分之一的CPU正在使用，大约使用了121MB的RAM。
- en: 'Next, let''s alter our code a little and observe the effect. In the `LiveDrawingView`
    class, edit the initialization of the `mParticlesPerSystem` member variable:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们稍微修改我们的代码并观察效果。在`LiveDrawingView`类中，编辑`mParticlesPerSystem`成员变量的初始化：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Change it to this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have now increased the particle count per system by 10x. We did this to get
    a spike in our profiler data, as we will now use the app to draw some particle
    systems.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将每个系统的粒子数量增加了10倍。我们这样做是为了在分析器数据中获得一个峰值，因为我们现在将使用应用程序来绘制一些粒子系统。
- en: When you run the app again, draw a large number of particle systems by moving
    your finger/pointer across the screen. Notice that the CPU usage spikes when you
    draw some particle systems on the screen, though perhaps not as much as you expected.
    Mine spiked to just under 40% while the particles were moving and then settled
    back down to just over 25%. What might be more surprising if you have never played
    with a tool like a profiler before is that the memory usage barely changes at
    all.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当您再次运行应用程序时，通过在屏幕上移动手指/指针来绘制大量的粒子系统。请注意，当您在屏幕上绘制一些粒子系统时，CPU使用率会急剧上升，尽管可能没有您预期的那么多。当粒子移动时，我的CPU使用率急剧上升到接近40%，然后回落到25%以上。如果您以前从未使用过类似分析器的工具，更令人惊讶的是内存使用几乎没有变化。
- en: The reason we got the results that we did is that the calculations of thousands
    of particles take up quite significant amounts of CPU. However, drawing particles
    on the screen does not require increased memory. The reason for this is that the
    memory for the app is all allocated near the start of the execution. Whether or
    not the particles are currently being shown to the user is not significant.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到这样的结果的原因是，成千上万个粒子的计算占用了相当大量的CPU。然而，在屏幕上绘制粒子并不需要增加内存。原因在于应用程序的内存都是在执行开始时分配的。无论粒子当前是否显示给用户都不重要。
- en: This short section was not intended to even scratch the surface of how we might
    optimize our graphics or CPU-intensive apps; it was just meant to introduce the
    idea that you might like to add optimization to your list of things to investigate
    further.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这一小节并不打算深入探讨如何优化我们的图形或CPU密集型应用程序；它只是想介绍一下，您可能希望将优化添加到您进一步调查的事项列表中。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how we can add thousands of self-contained entities
    to our real-time system. The entities were controlled by the `ParticleSystem`
    class, which in turn interacted with, and was controlled by, the game loop. As
    the game loop was running in a thread, we saw that the user can still interact
    seamlessly with the screen, and the operating system sends us the details of these
    interactions via the `onTouchEvent` method.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何向我们的实时系统添加成千上万个独立的实体。这些实体由`ParticleSystem`类控制，而`ParticleSystem`类又与游戏循环进行交互和控制。由于游戏循环在一个线程中运行，我们看到用户仍然可以无缝地与屏幕进行交互，操作系统通过`onTouchEvent`方法向我们发送这些交互的详细信息。
- en: In the next chapter, our apps will finally get a bit noisier when we explore
    how to play sound effects; we'll also learn how to detect different versions of
    Android.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，当我们探讨如何播放音效时，我们的应用程序最终会变得有些喧闹；我们还将学习如何检测不同版本的安卓系统。
