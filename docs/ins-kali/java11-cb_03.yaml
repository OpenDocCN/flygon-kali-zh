- en: Modular Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化编程
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下技巧：
- en: Using jdeps to find dependencies in a Java application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jdeps在Java应用程序中查找依赖关系
- en: Creating a simple modular application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的模块化应用程序
- en: Creating a modular JAR
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模块化JAR
- en: Using a module JAR with pre-Project Jigsaw JDK applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用Pre-Project Jigsaw JDK应用程序中使用模块JAR
- en: Bottom-up migration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自下而上的迁移
- en: Top-down migration
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自上而下的迁移
- en: Using services to create loose coupling between the consumer and provider modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务来创建消费者和提供者模块之间的松耦合
- en: Creating a custom modular runtime image using jlink
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jlink创建自定义模块化运行时映像
- en: Compiling for older platform versions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为旧平台版本编译
- en: Creating multi-release JARs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多版本JAR
- en: Using Maven to develop a modular application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maven开发模块化应用程序
- en: Making your library module-path-friendly
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的库对模块路径友好
- en: How to open a module for reflection
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为反射打开一个模块
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'Modular programming enables one to organize code into independent, cohesive
    modules, which can be combined to achieve the desired functionality. This allows
    us to create code that is:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程使我们能够将代码组织成独立的、内聚的模块，这些模块可以组合在一起以实现所需的功能。这使我们能够创建代码：
- en: More cohesive, because the modules are built with a specific purpose, so the
    code that resides there tends to cater to that specific purpose.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更加内聚，因为模块是为特定目的构建的，所以驻留在那里的代码往往倾向于迎合特定目的。
- en: Encapsulated, because modules can interact with only those APIs that have been
    made available by the other modules.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装，因为模块只能与其他模块提供的API进行交互。
- en: Reliable, because the discoverability is based on the modules and not on the
    individual types. This means that if a module is not present, the dependent module
    cannot be executed until it is discoverable by the dependent module. This helps
    to prevent runtime errors.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠，因为可发现性是基于模块而不是基于个别类型的。这意味着如果一个模块不存在，依赖的模块在被依赖的模块发现之前无法执行。这有助于防止运行时错误。
- en: Loosely coupled. If you use service interfaces, the module interface and the
    service interface implementation can be loosely coupled.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松耦合。如果使用服务接口，模块接口和服务接口实现可以松散耦合。
- en: So, the thought process in designing and organizing the code will now involve
    identifying the modules, code, and configuration files that go into the module
    and the packages in which the code is organized within the module. After that,
    we have to decide upon the public APIs of the module, thereby making them available
    for use by dependent modules.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在设计和组织代码的思考过程中，现在将涉及识别模块、代码和配置文件进入模块以及代码在模块内部组织的包。之后，我们必须决定模块的公共API，从而使它们可供依赖模块使用。
- en: 'Coming to the development of the **Java Platform Module System**, it is being
    governed by **J****ava Specification Request** (**JSR**) 376 ([https://www.jcp.org/en/jsr/detail?id=376](https://www.jcp.org/en/jsr/detail?id=376)).
    The JSR mentions that a module system should address the following fundamental
    issues:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**Java平台模块系统**的开发，它由**Java规范请求**（JSR）376（[https://www.jcp.org/en/jsr/detail?id=376](https://www.jcp.org/en/jsr/detail?id=376)）进行管理。JSR提到，模块系统应该解决以下基本问题：
- en: '**Reliable configuration**: Provide an alternative to the classpath for declaring
    dependency between components such that developers can prevent their applications
    from throwing surprises on runtime due to missing dependencies in the classpath.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠的配置**：提供了一个替代类路径的方式来声明组件之间的依赖关系，使开发人员可以防止他们的应用程序由于类路径中缺少依赖关系而在运行时出现意外。'
- en: '**Strong encapsulation**: Provide more strict access-control such that something
    private to a component is private in true sense i.e not accessible even via Reflection
    and allow the developer to selectively expose parts in the component for use by
    other components.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强封装**：提供更严格的访问控制，使组件中的私有内容真正私有，即使通过反射也无法访问，并允许开发人员有选择地公开组件中的部分内容供其他组件使用。'
- en: 'The JSR lists the advantages that result from addressing the preceding issues:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JSR列出了解决上述问题所带来的优势：
- en: '**A scalable platform**: The specification in JSR 376 will allow leveraging
    the different profiles introduced in JSR 337 in the right way by allowing the
    creation of profiles using different components/modules created in the new platform.
    This modular platform will also allow other developers to package different components
    of the Java Platform to create custom runtime thereby giving them an option to
    create runtime just enough for their use.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展的平台**：JSR 376中的规范将允许通过使用新平台创建的不同组件/模块来正确地利用JSR 337中引入的不同配置文件，从而创建配置文件。这个模块化平台还将允许其他开发人员打包Java平台的不同组件，以创建自定义运行时，从而为他们提供创建仅适合他们使用的运行时的选项。'
- en: '**Greater platform integrity**: The strong encapsulation will prevent the purposeful
    or accidental use of the Java internal APIs thereby giving greater platform integrity.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更大的平台完整性**：强封装将阻止有意或意外地使用Java内部API，从而提供更大的平台完整性。'
- en: '**Improved performance**: With the clear dependency between components, it
    now becomes much easier to optimize the individual components based on the components
    they interact within in the Java SE platform and outside of it.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能提升**：由于组件之间的明确依赖关系，现在更容易根据它们在Java SE平台内部和外部交互的组件来优化各个组件。'
- en: In this chapter, we will look at a few important recipes that will help you
    get started with modular programming.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些重要的技巧，帮助您开始模块化编程。
- en: Using jdeps to find dependencies in a Java application
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jdeps在Java应用程序中查找依赖关系
- en: The first step in modularizing your application is to identify its dependencies.
    A static analysis tool called `jdeps` was introduced in JDK 8 to enable developers
    to find the dependencies of their applications. There are multiple options supported
    in the command, which enables developers to check for dependencies in the JDK
    internal APIs, show the dependencies at the package level, show the dependencies
    at the class level, and filter the dependencies, among other options.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化应用程序的第一步是识别其依赖关系。JDK 8引入了一个名为`jdeps`的静态分析工具，使开发人员能够找到其应用程序的依赖关系。命令中支持多个选项，使开发人员能够检查JDK内部API的依赖关系，显示包级别的依赖关系，显示类级别的依赖关系，并过滤依赖关系等。
- en: In this recipe, we will look at how to make use of the `jdeps` tool by exploring
    its functionality and using the multiple command-line options it supports.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将探讨如何使用`jdeps`工具来探索其功能，并使用它支持的多个命令行选项。
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We need a sample application that we can run against the `jdeps` command to
    find its dependencies. So, we thought of creating a very simple application that
    uses the Jackson API to consume JSON from the REST API: [http://jsonplaceholder.typicode.com/users](http://jsonplaceholder.typicode.com/users).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个示例应用程序，可以针对`jdeps`命令运行以查找其依赖关系。因此，我们考虑创建一个非常简单的应用程序，使用Jackson API来消耗来自REST
    API的JSON：[http://jsonplaceholder.typicode.com/users](http://jsonplaceholder.typicode.com/users)。
- en: In the sample code, we also added a call to the deprecated JDK internal API,
    called `sun.reflect.Reflection.getCallerClass()`. This way, we can see how `jdeps`
    helps in finding dependencies for the JDK internal APIs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码中，我们还添加了对已弃用的JDK内部API`sun.reflect.Reflection.getCallerClass()`的调用。这样，我们可以看到`jdeps`如何帮助找到JDK内部API的依赖关系。
- en: 'The following steps will help you to set up the prerequisites for this recipe:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您设置此示例的先决条件：
- en: You can get the complete code for the sample from `Chapter03/1_json-jackson-sample`.
    We have built this code against Java 9 and also using Java 8, and it compiles
    well. So, you only need to install Java 9 to compile it. If you try to compile
    with JDK 11, you will face an error due to the deprecated internal API, which
    is no longer available.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以从`Chapter03/1_json-jackson-sample`获取示例的完整代码。我们已经针对Java 9构建了这段代码，也使用了Java
    8，并且编译成功。因此，您只需要安装Java 9来进行编译。如果您尝试使用JDK 11进行编译，由于已弃用的内部API不再可用，您将遇到错误。
- en: 'Once you have the code, compile it by using the following:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您有了代码，就使用以下命令进行编译：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note: If your `javac` is pointing to JDK 11, you can declare environment variables
    such as `JAVA8_HOME` or `JAVA9_HOME`  that are pointing to your JDK 8 and JDK9
    installations, respectively. This way, you can compile using:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您的`javac`指向JDK 11，您可以声明环境变量，如`JAVA8_HOME`或`JAVA9_HOME`，分别指向您的JDK 8和JDK9安装。这样，您可以使用以下命令进行编译：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You will see a warning for the use of an internal API, which you can safely
    ignore. We added this with a purpose to demonstrate the capability of `jdeps`.
    Now, you should have your compiled class files in the classes directory.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到有关使用内部API的警告，您可以放心地忽略。我们添加了这个目的是为了演示`jdeps`的功能。现在，您应该在classes目录中有已编译的类文件。
- en: 'You can create an executable JAR and run the sample program by running the
    JAR using the following commands:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以创建一个可执行的JAR文件，并通过以下命令运行示例程序：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have provided the `run.bat` and `run.sh` scripts in `Chapter03/1_json-jackson-sample`.
    You can compile and run using these scripts as well.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`Chapter03/1_json-jackson-sample`中提供了`run.bat`和`run.sh`脚本。您也可以使用这些脚本进行编译和运行。
- en: A `sample.jar` file gets created in the current directory if you have used `run.bat`
    or `run.sh` or the preceding commands to create JAR. If the JAR hasn't been created,
    you can use the `build-jar.bat` or `build.-jar.sh` script to compile and build
    the JAR.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`run.bat`或`run.sh`或上述命令创建JAR，则会在当前目录中创建一个`sample.jar`文件。如果JAR尚未创建，您可以使用`build-jar.bat`或`build.-jar.sh`脚本来编译和构建JAR。
- en: So, we have a sample non-modular application that we will analyze using `jdeps`
    to find its dependencies, and also the names of the modules it possibly depends
    on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个非模块化的示例应用程序，我们将使用`jdeps`来分析其依赖关系，以及可能依赖的模块名称。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The simplest way to use `jdeps` is as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`jdeps`的最简单方法如下：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding command is equivalent to the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令等同于以下命令：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/c3c8f969-df9f-43a6-826c-ace8f1ea5606.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3c8f969-df9f-43a6-826c-ace8f1ea5606.png)'
- en: In the preceding command, we use `jdeps` to list the dependencies for the class
    file, `Sample.class`, at the package level. We have to provide `jdeps` with the
    path to search for the dependencies of the code being analyzed. This can be done
    by setting the `-classpath`, `-cp`, or `--class-path` option of the `jdeps` command.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，我们使用`jdeps`来列出包级别的类文件`Sample.class`的依赖关系。我们必须提供`jdeps`要搜索的代码依赖的路径。这可以通过设置`jdeps`命令的`-classpath`、`-cp`或`--class-path`选项来实现。
- en: The `-verbose:package` option lists the dependencies at the package level.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`-verbose:package`选项列出了包级别的依赖关系。'
- en: 'Let''s list the dependencies at the class level:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们列出类级别的依赖关系：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](img/7a210b16-f42b-4e6f-b5af-7ed6d664521f.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a210b16-f42b-4e6f-b5af-7ed6d664521f.png)'
- en: In this case, we make use of the `-verbose:class` option to list the dependencies
    at the class level, which is why you can see that the `com.packt.Sample` class
    depends on `com.packt.model.Company`, `java.lang.Exception`, `com.fasterxml.jackson.core.type.TypeReference`,
    and so on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们利用`-verbose:class`选项来列出类级别的依赖关系，这就是为什么你可以看到`com.packt.Sample`类依赖于`com.packt.model.Company`、`java.lang.Exception`、`com.fasterxml.jackson.core.type.TypeReference`等等。
- en: 'Let''s get the summary of the dependencies:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们得到依赖关系的摘要：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/ebc43ab3-e07e-4853-bc4f-a86864ee9961.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebc43ab3-e07e-4853-bc4f-a86864ee9961.png)'
- en: 'Let''s check for the dependency on the JDK internal API:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查对JDK内部API的依赖：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is the output of the preceding command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述命令的输出：
- en: '![](img/5f7a9c3e-554a-46d7-b7fd-6920ddf9b0ae.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f7a9c3e-554a-46d7-b7fd-6920ddf9b0ae.png)'
- en: The StackWalker API is the new API for traversing the call stack, which was
    introduced in Java 9\. This is the replacement for the `sun.reflect.Reflection.getCallerClass()`
    method. We will discuss this API in [Chapter 11](d8d77bf4-a30b-4474-95ca-0a166aef48c0.xhtml), *Memory
    Management and Debugging*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: StackWalker API是Java 9中引入的用于遍历调用堆栈的新API。这是`sun.reflect.Reflection.getCallerClass()`方法的替代品。我们将在[第11章](d8d77bf4-a30b-4474-95ca-0a166aef48c0.xhtml)中讨论此API，即*内存管理和调试*。
- en: 'Let''s run `jdeps` on the JAR file, `sample.jar`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对JAR文件`sample.jar`运行`jdeps`：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output we get is the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出如下：
- en: '![](img/f30a59fd-1ed6-4b4c-8ea2-e4c3bf8fc189.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f30a59fd-1ed6-4b4c-8ea2-e4c3bf8fc189.png)'
- en: The preceding information obtained after investigating the `sample.jar` using
    `jdeps` is quite useful. It clearly states the dependencies of our JAR files and
    is very useful when we try to migrate this application to a modular application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`jdeps`对`sample.jar`进行调查获得的信息非常有用。它清楚地说明了我们的JAR文件的依赖关系，在我们尝试将该应用程序迁移到模块化应用程序时非常有用。
- en: 'Let''s find whether there are any dependencies on a given package name:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们找出是否有任何依赖于给定包名称的依赖项：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/593012f7-f4cf-4d5c-b331-485c571a9205.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/593012f7-f4cf-4d5c-b331-485c571a9205.png)'
- en: 'The `-p` option is used to find dependencies on the given package name. So,
    we get to know that our code depends on the `java.util` package. Let''s try this
    with another package name:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`选项用于查找对给定包名称的依赖关系。因此，我们知道我们的代码依赖于`java.util`包。让我们尝试另一个包名称：'
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is no output, which means that our code doesn't depend on the `java.util.concurrent`
    package.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有输出，这意味着我们的代码不依赖于`java.util.concurrent`包。
- en: 'We would want to run the dependency check only for our code. Yes, this is possible.
    Suppose we run `jdeps -cp lib/* sample.jar`; you will see even the library JARs
    being analyzed. We wouldn''t want that, right? Let''s just include the classes
    of the `com.packt` package:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只想对我们的代码运行依赖性检查。是的，这是可能的。假设我们运行`jdeps -cp lib/* sample.jar`；你会看到甚至库JAR也被分析了。我们不想要那样，对吧？让我们只包括`com.packt`包的类：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/bfb4eb40-2b7b-4516-939f-6ba305d424e2.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfb4eb40-2b7b-4516-939f-6ba305d424e2.png)'
- en: 'Let''s check whether our code is dependent on a specific package:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查我们的代码是否依赖于特定包：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/c77a08a3-044a-4c1d-ae1d-636d2331977d.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c77a08a3-044a-4c1d-ae1d-636d2331977d.png)'
- en: 'We can use `jdeps` to analyze the JDK modules. Let''s pick the `java.httpclient`
    module for analysis:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`jdeps`来分析JDK模块。让我们选择`java.httpclient`模块进行分析：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is the output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![](img/09e20526-032c-4210-952a-8c9283d429ce.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09e20526-032c-4210-952a-8c9283d429ce.png)'
- en: 'We can also find out whether a given module is dependent on another module
    by using the `--require` option, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用`--require`选项找出一个给定模块是否依赖于另一个模块，如下所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![](img/82ffa439-4881-4ad7-b4a8-9e169b4ed907.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82ffa439-4881-4ad7-b4a8-9e169b4ed907.png)'
- en: In the preceding command, we tried to find out whether the `java.sql` module
    is dependent on the `java.logging` module. The output we get is the dependency
    summary of the `java.sql` module and the packages in the `java.sql` module, which
    make use of the code from the `java.logging` module.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，我们试图找出`java.sql`模块是否依赖于`java.logging`模块。我们得到的输出是`java.sql`模块的依赖摘要和`java.sql`模块中使用`java.logging`模块代码的包。
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `jdeps` command is a static-class dependency analyzer and is used to analyze
    the static dependencies of the application and its libraries. The `jdeps` command, by
    default, shows the package-level dependencies of the input files, which can be
    `.class` files, a directory, or a JAR file. This is configurable and can be changed
    to show class-level dependencies. There are multiple options available to filter
    out the dependencies and to specify the class files to be analyzed. We have seen
    a regular use of the `-cp` command-line option. This option is used to provide
    the locations to search for the analyzed code's dependencies.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`jdeps`命令是一个静态类依赖性分析器，用于分析应用程序及其库的静态依赖关系。`jdeps`命令默认显示输入文件（可以是`.class`文件、目录或JAR文件）的包级别依赖关系。这是可配置的，并且可以更改为显示类级别的依赖关系。有多个选项可用于过滤依赖关系并指定要分析的类文件。我们已经看到了`-cp`命令行选项的常规用法。此选项用于提供要搜索分析代码依赖关系的位置。'
- en: 'We have analyzed the class file, JAR files, and the JDK modules, and we also
    tried out different options of the `jdeps` command. There are a few options, such
    as `-e`, `-regex`, `--regex`, `-f`, `--filter`, and `-include`, which accept a
    regular expression (regex). It''s important to understand the output of the `jdeps`
    command. There are two parts of information for every class/JAR file being analyzed:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经分析了类文件、JAR文件和JDK模块，并尝试了`jdeps`命令的不同选项。有一些选项，如`-e`、`-regex`、`--regex`、`-f`、`--filter`和`-include`，可以接受正则表达式（regex）。了解`jdeps`命令的输出是很重要的。对于每个被分析的类/JAR文件，都有两部分信息：
- en: 'The summary of the dependency for the analyzed file (JAR or class file). This
    consists of the name of the class or the JAR file on the left and the name of
    the dependent entity on the right. The dependent entity can be a directory, a
    JAR file, or a JDK module, as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析文件（JAR或类文件）的依赖摘要。左侧是类或JAR文件的名称，右侧是依赖实体的名称。依赖实体可以是目录、JAR文件或JDK模块，如下所示：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A more verbose dependency information of the contents of the analyzed file
    at the package or class level (depending on the command-line options). This consists
    of three columns—column 1 contains the name of the package/class, column 2 contains
    the name of the dependent package, and column 3 contains the name of the module/JAR
    where the dependency is found. A sample output looks like the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包或类级别（取决于命令行选项）分析文件内容的更详细的依赖信息。这由三列组成——第1列包含包/类的名称，第2列包含依赖包的名称，第3列包含找到依赖项的模块/JAR的名称。示例输出如下：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's more...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We have seen quite a few options of the `jdeps` command. There are a few more
    related to filtering the dependencies and filtering the classes to be analyzed.
    Apart from that, there are a few options that deal with module paths.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`jdeps`命令的许多选项。还有一些与过滤依赖项和过滤要分析的类相关的选项。除此之外，还有一些处理模块路径的选项。
- en: 'The following are the options that can be tried out:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以尝试的选项：
- en: '`-e`, `-regex`, `--regex`: These find dependencies matching the given pattern.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`，`-regex`，`--regex`：这些找到与给定模式匹配的依赖项。'
- en: '`-f`, `-filter`: These exclude dependencies matching the given pattern.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`，`-filter`：这些排除与给定模式匹配的依赖项。'
- en: '`-filter:none`: This allows no filtering that''s applied via `filter:package`
    or `filter:archive`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-filter:none`：这允许不应用`filter:package`或`filter:archive`的过滤。'
- en: '`-filter:package`: This excludes dependencies within the same package. This
    is the default option. For example, if we added `-filter:none` to `jdeps sample.jar`,
    it would print the dependency of the package to itself.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-filter:package`：这排除了同一包内的依赖项。这是默认选项。例如，如果我们向`jdeps sample.jar`添加`-filter:none`，它将打印包对自身的依赖项。'
- en: '`-filter:archive`: This excludes dependencies within the same archive.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-filter:archive`：这排除了同一存档内的依赖项。'
- en: '`-filter:module`: This excludes dependencies in the same module.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-filter:module`：这排除了同一模块中的依赖项。'
- en: '`-P`, `-profile`: This is used to show the profile of the package, whether
    it is in compact1, compact2, compact3, or full JRE.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-P`，`-profile`：用于显示包的配置文件，无论它是在compact1、compact2、compact3还是完整的JRE中。'
- en: '`-R`, `-recursive`: These recursively traverse all the runtime dependencies;
    they are equivalent to the `-filter:none` option.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-R`，`-recursive`：这些递归遍历所有运行时依赖项；它们等同于`-filter:none`选项。'
- en: Creating a simple modular application
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的模块化应用程序
- en: You should be wondering what this modularity is all about, and how to create
    a modular application in Java. In this recipe, we will try to clear up the confusion
    around creating modular applications in Java by walking you through a simple example.
    Our goal is to show you how to create a modular application; hence, we picked
    a simple example so as to focus on our goal.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您一定想知道模块化是什么，以及如何在Java中创建模块化应用程序。在这个示例中，我们将尝试通过一个简单的示例来澄清在Java中创建模块化应用程序的困惑。我们的目标是向您展示如何创建一个模块化应用程序；因此，我们选择了一个简单的示例，以便专注于我们的目标。
- en: Our example is a simple advanced calculator, which checks whether a number is
    prime, calculates the sum of prime numbers, checks whether a number is even, and
    calculates the sum of even and odd numbers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例是一个简单的高级计算器，用于检查数字是否为质数，计算质数的和，检查数字是否为偶数，并计算偶数和奇数的和。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will divide our application into two modules:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用程序分为两个模块：
- en: The `math.util` module, which contains the APIs for performing the mathematical
    calculations
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含用于执行数学计算的API的`math.util`模块
- en: The `calculator` module, which launches an advanced calculator
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动高级计算器的`calculator`模块
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s implement the APIs in the `com.packt.math.MathUtil` class, starting
    with the `isPrime(Integer number)` API:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`com.packt.math.MathUtil`类中实现API，从`isPrime(Integer number)`API开始：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Implement the `sumOfFirstNPrimes(Integer count)` API:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`sumOfFirstNPrimes(Integer count)`API：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s write a function to check whether the number is even:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个函数来检查数字是否为偶数：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The negation of `isEven` tells us whether the number is odd. We can have functions
    to find the sum of the first *N* even numbers and the first *N* odd numbers, as
    shown here:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isEven`的否定告诉我们数字是否为奇数。我们可以有函数来找到前*N*个偶数和前*N*个奇数的和，如下所示：'
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can see in the preceding APIs that the following operations are repeated:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在前面的API中重复了以下操作：
- en: An infinite sequence of numbers starting from `1`
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`1`开始的无限序列
- en: Filtering the numbers based on some condition
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据某些条件过滤数字
- en: Limiting the stream of numbers to a given count
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数字流限制为给定数量
- en: Finding the sum of numbers thus obtained
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到因此获得的数字的和
- en: 'Based on our observation, we can refactor the preceding APIs and extract these
    operations into a method, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的观察，我们可以重构前面的API，并将这些操作提取到一个方法中，如下所示：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `count` is the limit of numbers we need to find the sum of, and `filter`
    is the condition for picking the numbers for summing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`count`是我们需要找到和的数字的限制，`filter`是选择数字进行求和的条件。
- en: 'Let''s rewrite the APIs based on the refactoring we just did:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据刚刚进行的重构重写API：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You must be wondering about the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您一定想知道以下内容：
- en: The `IntStream` class and the related chaining of the methods
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream`类和相关方法的链接'
- en: The use of `->` in the code base
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码库中使用`->`
- en: The use of the `IntPredicate` class
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntPredicate`类的使用'
- en: If you are indeed wondering, then you need not worry, as we will cover these
    things in [Chapter 4](69c0640b-9b2e-4515-bda6-8a481206da19.xhtml), *Going Functional,*
    and [Chapter 5](eaa70333-8e9d-453d-a9b6-063152fcc1e1.xhtml), *Streams and Pipelines*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实想知道，那么您无需担心，因为我们将在[第4章](69c0640b-9b2e-4515-bda6-8a481206da19.xhtml) *进入功能*和[第5章](eaa70333-8e9d-453d-a9b6-063152fcc1e1.xhtml)
    *流和管道*中涵盖这些内容。
- en: So far, we have seen a few APIs around mathematical computations. These APIs
    are part of our `com.packt.math.MathUtil` class. The complete code for this class
    can be found at `Chapter03/2_simple-modular-math-util/math.util/com/packt/math`,
    in the codebase downloaded for this book.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些围绕数学计算的API。这些API是我们的`com.packt.math.MathUtil`类的一部分。该类的完整代码可以在为本书下载的代码库中的`Chapter03/2_simple-modular-math-util/math.util/com/packt/math`中找到。
- en: 'Let''s make this small utility class part of a module named `math.util`. The
    following are some conventions we use to create a module:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个小型实用程序类作为名为`math.util`的模块的一部分。以下是我们用来创建模块的一些约定：
- en: Place all the code related to the module under a directory named `math.util`
    and treat this as our module root directory.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将与模块相关的所有代码放在名为`math.util`的目录下，并将其视为我们的模块根目录。
- en: In the root folder, insert a file named `module-info.java`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根文件夹中，插入一个名为`module-info.java`的文件。
- en: Place the packages and the code files under the root directory.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包和代码文件放在根目录下。
- en: 'What does `module-info.java` contain? The following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`module-info.java`包含什么？以下内容：'
- en: The name of the module
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的名称
- en: The packages it exports, that is, the one it makes available for other modules
    to use
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它导出的包，即它提供给其他模块使用的包。
- en: The modules it depends on
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它依赖的模块
- en: The services it uses
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用的服务
- en: The service for which it provides implementation
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供实现的服务
- en: As mentioned in [Chapter 1](4dbea9e1-3ed8-4fcc-8e46-8a12457e3434.xhtml), *Installation
    and a Sneak Peek into Java 11*, the JDK comes bundled with a lot of modules, that
    is, the existing Java SDK has been modularized! One of those modules is a module
    named `java.base`. All of the user-defined modules implicitly depend on (or require)
    the `java.base` module (think of every class implicitly extending the `Object`
    class).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](4dbea9e1-3ed8-4fcc-8e46-8a12457e3434.xhtml)中所述，*安装和Java 11的预览*，JDK捆绑了许多模块，即现有的Java
    SDK已经模块化！其中一个模块是名为`java.base`的模块。所有用户定义的模块都隐式依赖于（或需要）`java.base`模块（可以将每个类都隐式扩展`Object`类）。
- en: 'Our `math.util` module doesn''t depend on any other module (except, of course,
    the `java.base` module). However, it makes its API available for other modules
    (if not, then this module''s existence is questionable). Let''s go ahead and put
    this statement into code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`math.util`模块不依赖于任何其他模块（当然，除了`java.base`模块）。但是，它使其API可用于其他模块（如果不是这样，那么该模块的存在就是有问题的）。让我们继续并将此语句放入代码中：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We are telling the Java compiler and runtime that our `math.util` module is
    *exporting* the code in the `com.packt.math` package to any module that depends
    on `math.util`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉Java编译器和运行时，我们的`math.util`模块正在*导出*`com.packt.math`包中的代码给任何依赖于`math.util`的模块。
- en: The code for this module can be found at `Chapter03/2_simple-modular-math-util/math.util`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块的代码可以在`Chapter03/2_simple-modular-math-util/math.util`中找到。
- en: 'Now, let''s create another module calculator that uses the `math.util` module.
    This module has a `Calculator` class whose work is to accept the user''s choice
    for which mathematical operation to execute and then the input required to execute
    the operation. The user can choose from five available mathematical operations:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个使用`math.util`模块的计算器模块。该模块有一个`Calculator`类，其工作是接受用户选择要执行的数学运算，然后输入执行操作所需的输入。用户可以从五种可用的数学运算中进行选择：
- en: Prime number check
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 素数检查
- en: Even number check
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偶数检查
- en: Sum of *N* primes
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*N*个素数的和'
- en: Sum of *N* evens
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*N*个偶数的和'
- en: Sum of *N* odds
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*N*个奇数的和'
- en: 'Let''s see this in code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中看看这个：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, for each of the choices, we accept the required input and invoke the
    corresponding `MathUtil` API, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每个选择，我们接受所需的输入并调用相应的`MathUtil` API，如下所示：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The complete code for the `Calculator` class can be found at `Chapter03/2_simple-modular-math-util/calculator/com/packt/calculator/Calculator.java`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calculator`类的完整代码可以在`Chapter03/2_simple-modular-math-util/calculator/com/packt/calculator/Calculator.java`中找到。'
- en: 'Let''s create the module definition for our `calculator` module in the same
    way we created it for the `math.util` module:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以与`math.util`模块相同的方式创建我们的`calculator`模块的模块定义：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding module definition, we mentioned that the `calculator` module
    depends on the `math.util` module by using the `required` keyword.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模块定义中，我们提到`calculator`模块使用`required`关键字依赖于`math.util`模块。
- en: The code for this module can be found at `Chapter03/2_simple-modular-math-util/calculator`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块的代码可以在`Chapter03/2_simple-modular-math-util/calculator`中找到。
- en: 'Let''s compile the code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译代码：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding command has to be executed from `Chapter03/2_simple-modular-math-util`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令必须从`Chapter03/2_simple-modular-math-util`执行。
- en: Also, you should have the compiled code from across both the modules, `math.util`
    and `calculator`, in the `mods` directory. Just a single command and everything
    including the dependency between the modules is taken care of by the compiler.
    We didn't require build tools such as `ant` to manage the compilation of modules.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您应该在`mods`目录中跨两个模块`math.util`和`calculator`的编译代码。编译器负责处理所有内容，包括模块之间的依赖关系。我们不需要构建工具（如`ant`）来管理模块的编译。
- en: The `--module-source-path` command is the new command-line option for `javac`,
    specifying the location of our module source code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`--module-source-path`命令是`javac`的新命令行选项，指定我们模块源代码的位置。'
- en: 'Let''s execute the preceding code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行上述代码：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `--module-path` command, similar to `--classpath`, is the new command-line
    option  `java`, specifying the location of the compiled modules.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`--module-path`命令，类似于`--classpath`，是`java`的新命令行选项，指定编译模块的位置。'
- en: 'After running the preceding command, you will see the calculator in action:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述命令之后，您将看到计算器在运行中：
- en: '![](img/11c0340c-401d-4a57-b8af-614a95011b6f.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11c0340c-401d-4a57-b8af-614a95011b6f.png)'
- en: Congratulations! With this, we have a simple modular application up and running.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！有了这个，我们有一个简单的模块化应用程序正在运行。
- en: We have provided scripts to test out the code on both Windows and Linux platforms.
    Please use `run.bat` for Windows and `run.sh` for Linux.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提供了脚本来测试在Windows和Linux平台上的代码。 请在Windows上使用`run.bat`，在Linux上使用`run.sh`。
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now that you have been through the example, we will look at how to generalize
    it so that we can apply the same pattern in all our modules. We followed a particular
    convention to create the modules:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经通过了示例，我们将看看如何将其概括，以便我们可以在所有模块中应用相同的模式。 我们遵循了特定的约定来创建模块：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We place the module-specific code within its folders with a corresponding `module-info.java` file
    at the root of the folder. This way, the code is organized well.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模块特定的代码放在其文件夹中，并在文件夹的根目录下放置一个相应的`module-info.java`文件。 这样，代码就组织得很好。
- en: 'Let''s look into what `module-info.java` can contain. From the Java language
    specification ([http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html](http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html)),
    a module declaration is of the following form:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`module-info.java`可以包含什么。 从Java语言规范（[http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html](http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html)）中，模块声明的形式如下：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here''s the syntax, explained:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是语法，解释如下：
- en: '`{Annotation}`: This is any annotation of the form `@Annotation(2)`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{Annotation}`：这是任何形式为`@Annotation(2)`的注释。'
- en: '`open`: This keyword is optional. An open module makes all its components accessible
    at runtime via reflection. However, at compile-time and runtime, only those components
    that are explicitly exported are accessible.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`：这个关键字是可选的。 开放模块通过反射在运行时使其所有组件可访问。 但是，在编译时和运行时，只有明确导出的组件才可访问。'
- en: '`module`: This is the keyword used to declare a module.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module`：这是用于声明模块的关键字。'
- en: '`ModuleName`: This is the name of the module that is a valid Java identifier
    with a permissible dot (`.`) between the identifier names—similar to `math.util`.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModuleName`：这是模块的名称，是一个有效的Java标识符，标识符名称之间可以使用允许的点（`.`）-类似于`math.util`。'
- en: '`{ModuleStatement}`: This is a collection of the permissible statements within
    a module definition. Let''s expand this next.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ModuleStatement}`：这是模块定义中允许的语句的集合。 让我们接下来扩展这个。'
- en: 'A module statement is of the following form:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 模块语句的形式如下：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The module statement is decoded here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 模块语句在这里被解码：
- en: '`requires`: This is used to declare a dependency on a module. `{RequiresModifier}`
    can be **transitive**, **static**, or both. Transitive means that any module that
    depends on the given module also implicitly depends on the module that is required
    by the given module transitively. Static means that the module dependence is mandatory
    at compile time, but optional at runtime. Some examples are `requires math.util`,
    `requires transitive math.util`, and `requires static math.util`.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requires`：这用于声明对模块的依赖关系。 `{RequiresModifier}`可以是**transitive**，**static**，或两者兼有。
    Transitive表示任何依赖于给定模块的模块也隐式地依赖于给定模块传递地。 Static表示模块依赖在编译时是强制性的，但在运行时是可选的。 一些示例是`requires
    math.util`，`requires transitive math.util`，和`requires static math.util`。'
- en: '`exports`: This is used to make the given packages accessible to the dependent
    modules. Optionally, we can force the package''s accessibility to specific modules
    by specifying the module name, such as `exports com.package.math to claculator`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exports`：这用于使给定的包对依赖模块可访问。 可选地，我们可以通过指定模块名称来强制包的可访问性到特定模块，例如`exports com.package.math
    to claculator`。'
- en: '`opens`: This is used to open a specific package. We saw earlier that we can
    open a module by specifying the `open` keyword with the module declaration. But
    this can be less restrictive. So, to make it more restrictive, we can open a specific
    package for reflective access at runtime by using the `opens` keyword—`opens com.packt.math`.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opens`：这用于打开特定包。 我们之前看到可以通过在模块声明中使用`open`关键字来打开模块。 但这可能不够严格。 因此，我们可以使用`opens`关键字在运行时打开特定包以进行反射访问-`opens
    com.packt.math`。'
- en: '`uses`: This is used to declare a dependency on a service interface that is
    accessible via `java.util.ServiceLoader`. The service interface can be in the
    current module or in any module that the current module depends on.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uses`：这用于声明对通过`java.util.ServiceLoader`可访问的服务接口的依赖关系。 服务接口可以在当前模块中或在当前模块依赖的任何模块中。'
- en: '`provides`: This is used to declare a service interface and provide it with
    at least one implementation. The service interface can be declared in the current
    module or in any other dependent module. However, the service implementation must
    be provided in the same module; otherwise, a compile-time error will occur.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`provides`：这用于声明服务接口并提供至少一个实现。 服务接口可以在当前模块中声明，也可以在任何其他依赖模块中声明。 但是，服务实现必须在同一模块中提供；
    否则，将发生编译时错误。'
- en: We will look at the `uses` and `provides` clauses in more detail in the *Using
    services to create loose coupling between the consumer and provider modules* recipe.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更详细地查看`uses`和`provides`子句，*使用服务来创建消费者和提供者模块之间的松耦合*的示例中。
- en: The module source of all modules can be compiled at once using the `--module-source-path`
    command-line option. This way, all the modules will be compiled and placed in
    their corresponding directories under the directory provided by the `-d` option.
    For example, `javac -d mods --module-source-path . $(find . -name "*.java")` compiles
    the code in the current directory into a `mods` directory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模块的模块源可以使用`--module-source-path`命令行选项一次性编译。 这样，所有模块将被编译并放置在由`-d`选项提供的目录下的相应目录中。
    例如，`javac -d mods --module-source-path . $(find . -name "*.java")`将当前目录中的代码编译成一个`mods`目录。
- en: Running the code is equally simple. We specify the path where all our modules
    are compiled into using the command-line option `--module-path`. Then, we mention
    the module name along with the fully qualified main class name using the command-line
    option `-m`, for example, `java --module-path mods -m calculator/com.packt.calculator.Calculator`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码同样简单。我们使用命令行选项`--module-path`指定我们所有模块编译后的路径。然后，我们使用命令行选项`-m`指定模块名称以及完全限定的主类名称，例如，`java
    --module-path mods -m calculator/com.packt.calculator.Calculator`。
- en: See also
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Compiling and running a Java application* recipe in [Chapter 1](4dbea9e1-3ed8-4fcc-8e46-8a12457e3434.xhtml),
    *Installation and a Sneak Peek into Java 11*
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](4dbea9e1-3ed8-4fcc-8e46-8a12457e3434.xhtml)的*编译和运行Java应用程序*中，*安装和预览Java
    11*
- en: Creating a modular JAR
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模块化JAR
- en: Compiling modules into a class is good, but it is not suitable for sharing binaries
    and deployment. JARs are better formats for sharing and deployment. We can package
    the compiled module into JARs, and the JARs that contain `module-info.class` at
    its top level are called **modular JARs**. In this recipe, we will look at how
    to create modular JARs, and we'll also look at how to execute the application,
    which is composed of multiple modular JARs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块编译成类是不错的，但不适合共享二进制文件和部署。JAR是更好的共享和部署格式。我们可以将编译后的模块打包成JAR，并且包含`module-info.class`的JAR文件被称为**模块化JAR**。在这个示例中，我们将看看如何创建模块化JAR，并且还将看看如何执行由多个模块化JAR组成的应用程序。
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We have seen and created a simple modular application in the *Creating a simpler
    modular application* recipe. In order to build a modular JAR, we will make use
    of the sample code available at `Chapter03/3_modular_jar`. This sample code contains
    two modules: `math.util` and `calculator`. We will create modular JARs for both
    the modules.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在*创建一个更简单的模块化应用程序*中看到并创建了一个简单的模块化应用程序。为了构建一个模块化JAR，我们将使用`Chapter03/3_modular_jar`中提供的示例代码。这个示例代码包含两个模块：`math.util`和`calculator`。我们将为这两个模块创建模块化JAR文件。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Compile the code and place the compiled classes in a directory, say, `mods`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并将编译后的类放入一个目录，比如`mods`：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Build a modular JAR for the `math.util` module:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`math.util`模块构建一个模块化JAR：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Do not forget the dot (`.`) at the end of the preceding code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在上述代码的末尾加上点（`.`）。
- en: 'Build a modular JAR for the `calculator` module, specifying the main class
    to make the JAR executable:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`calculator`模块构建一个模块化JAR，指定主类以使JAR可执行：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The critical piece in the preceding command is the `--main-class` option. This
    enables us to execute the JAR without providing the main class information during
    execution.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令中的关键部分是`--main-class`选项。这使我们能够在执行时不提供主类信息来执行JAR文件。
- en: 'Now, we have two JARs in the `mlib` directory: `math.util@1.0.jar` and `calculator@1.0.jar`.
    These JARs are called modular JARs. If you want to run the example, you can use
    the following command:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在`mlib`目录中有两个JAR文件：`math.util@1.0.jar`和`calculator@1.0.jar`。这些JAR文件被称为模块化JAR文件。如果您想要运行示例，可以使用以下命令：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A new command-line option for the JAR command has been introduced in Java 9,
    called `-d` , or  `--describe-module`. This prints the information about the module
    that the modular JAR contains:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java 9中引入了JAR命令的一个新的命令行选项，称为`-d`或`--describe-module`。这会打印模块化JAR包含的模块信息：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of `jar -d` for `calculator@1.0.jar` is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculator@1.0.jar`的`jar -d`输出如下：'
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output of `jar -d` for `math.util@1.0.jar` is as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`math.util@1.0.jar`的`jar -d`输出如下：'
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We have provided the following scripts to try out the recipe code on Windows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提供了以下脚本来在Windows上尝试示例代码：
- en: '`compile-math.bat`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile-math.bat`'
- en: '`compile-calculator.bat`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile-calculator.bat`'
- en: '`jar-math.bat`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jar-math.bat`'
- en: '`jar-calculator.bat`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jar-calculator.bat`'
- en: '`run.bat`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run.bat`'
- en: 'We have provided the following scripts to try out the recipe code on Linux:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提供了以下脚本来在Linux上尝试示例代码：
- en: '`compile.sh`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile.sh`'
- en: '`jar-math.sh`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jar-math.sh`'
- en: '`jar-calculator.sh`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jar-calculator.sh`'
- en: '`run.sh`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run.sh`'
- en: You have to run the scripts in the order they have been listed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须按照它们列出的顺序运行脚本。
- en: Using a module JAR with pre-Project Jigsaw JDK applications
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Project Jigsaw JDK应用程序之前使用模块JAR
- en: It would be amazing if our modular JARs could be run with pre-Project Jigsaw JDK applications.
    This way, we will not be concerned with writing another version of our API for
    pre-JDK 9 applications. The good news is that we can use our modular JARs just
    as if they were ordinary JARs, that is, JARs without `module-info.class` at their
    root. We will see how to do so in this recipe.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的模块化JAR可以在Project Jigsaw JDK应用程序之前运行，那将是很棒的。这样，我们就不需要为JDK 9之前的应用程序编写另一个版本的API。好消息是，我们可以像使用普通JAR一样使用我们的模块化JAR，也就是说，没有`module-info.class`的JAR。我们将在这个示例中看到如何做到这一点。
- en: Getting ready
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need a modular jar and a non-modular application.
    Our modular code can be found at `Chapter03/4_modular_jar_with_pre_java9/math.util` (this
    is the same `math.util` module that we created in our *Creating a simple modular
    application* recipe). Let''s compile this modular code and create a modular JAR
    by using the following commands:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将需要一个模块化JAR和一个非模块化应用程序。我们的模块化代码可以在`Chapter03/4_modular_jar_with_pre_java9/math.util`中找到（这是我们在*创建一个简单的模块化应用程序*中创建的相同的`math.util`模块）。让我们使用以下命令编译这个模块化代码并创建一个模块化JAR：
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We have also provided a `jar-math.bat` script at `Chapter03/4_modular_jar_with_pre_java9`,
    which can be used to create modular JARs on Windows. We have our modular JAR.
    Let''s verify it by using the `-d` option of the `jar` command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`Chapter03/4_modular_jar_with_pre_java9`中提供了一个`jar-math.bat`脚本，可以用于在Windows上创建模块化JAR。我们有我们的模块化JAR。让我们使用`jar`命令的`-d`选项来验证它：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Now, let's create a simple application, which is non-modular. Our application
    will consist of one class named `NonModularCalculator`, which borrows its code
    from the `Calculator` class, in the *Creating a simple modular application* recipe.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个非模块化的简单应用程序。我们的应用程序将包含一个名为`NonModularCalculator`的类，它从*创建一个简单的模块化应用程序*中的`Calculator`类中借用其代码。
- en: You can find the `NonModularCalculator` class definition in the `com.packt.calculator`
    package under the  `Chapter03/4_modular_jar_with_pre_java9/calculator` directory.
    As it is non-modular, it doesn't need a `module-info.java` file. This application
    makes use of our modular JAR `math.util.jar` to execute some mathematical calculations.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Chapter03/4_modular_jar_with_pre_java9/calculator`目录下的`com.packt.calculator`包中找到`NonModularCalculator`类的定义。由于它是非模块化的，所以不需要`module-info.java`文件。该应用程序利用我们的模块化JAR`math.util.jar`来执行一些数学计算。
- en: 'At this point, you should have the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该拥有以下内容：
- en: A modular JAR named `math.util@1.0.jar`
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`math.util@1.0.jar`的模块化JAR
- en: A non-modular application consisting of the `NonModularCalculator` package
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由`NonModularCalculator`包组成的非模块化应用程序
- en: 'Now, we need to compile our `NonModularCalculator` class:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要编译我们的`NonModularCalculator`类：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After running the previous command, you will see a list of errors saying that
    the `com.packt.math` package doesn''t exist, the `MathUtil` symbol cannot be found, and
    so on. You''ve guessed it; we didn''t provide the location of our modular JAR
    for the compiler. Let''s add the modular `jar` location using the `--class-path`
    option:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上一个命令后，您将看到一系列错误，指出`com.packt.math`包不存在，找不到`MathUtil`符号等等。您已经猜到了；我们没有为编译器提供我们的模块化JAR的位置。让我们使用`--class-path`选项添加模块化`jar`的位置：
- en: '[PRE42]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we have successfully compiled our non-modular code, which was dependent
    on the modular JAR. Let''s run the compiled code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已成功编译了依赖于模块化JAR的非模块化代码。让我们运行编译后的代码：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Congratulations! You have successfully used your modular JAR with a non-modular
    application. Amazing, right?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功地将您的模块化JAR用于非模块化应用程序。很棒，对吧？
- en: 'We have provided the following scripts at `Chapter03/4_modular_jar_with_pre_java9` to
    run the code on the Windows platform:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Chapter03/4_modular_jar_with_pre_java9`提供了以下脚本来在Windows平台上运行代码：
- en: '`compile-calculator.bat`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile-calculator.bat`'
- en: '`run.bat`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run.bat`'
- en: Bottom-up migration
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自下而上的迁移
- en: 'Now that Java 9 is out of the door, the much-awaited modularity feature is
    now available to be adopted by developers. At some point or another, you will
    be involved in migrating your application to Java 9 and, hence, trying to modularize
    it. A change of such magnitude, which involves third-party libraries and rethinking
    the code structure, would require proper planning and implementation. The Java
    team has suggested two migration approaches:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Java 9已经发布，备受期待的模块化功能现在可以被开发人员采用。在某个时候，您将参与将您的应用程序迁移到Java 9，并因此尝试将其模块化。这种涉及第三方库和重新思考代码结构的重大变化需要适当的规划和实施。Java团队提出了两种迁移方法：
- en: Bottom-up migration
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自下而上的迁移
- en: Top-down migration
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自上而下的迁移
- en: Before going into learning about bottom-up migration, it's important to understand
    what an unnamed module and an automatic module are. Suppose you are accessing
    a type that's not available in any of the modules; in such a case, the module
    system will search for the type on the classpath, and if found, the type becomes
    part of an unnamed module. This is similar to the classes we write that do not
    belong to any package, but Java adds them to an unnamed package so as to simplify
    the creation of new classes.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习自下而上的迁移之前，了解无名模块和自动模块是很重要的。假设您正在访问一个在任何模块中都不可用的类型；在这种情况下，模块系统将在类路径上搜索该类型，如果找到，该类型将成为无名模块的一部分。这类似于我们编写的不属于任何包的类，但Java会将它们添加到无名包中，以简化新类的创建。
- en: So, an unnamed module is a catch-all module without a name that contains all
    those types that are not part of any modules, but are found in the classpath.
    An unnamed module can access all the exported types of all the named modules (user-defined
    modules) and built-in modules (Java platform modules). On the other hand, a named
    module (user-defined module) will not be able to access the types in the unnamed
    module. In other words, a named module cannot declare dependency on an unnamed
    module. If you want to declare a dependency, how would you do that? An unnamed
    module doesn't have a name!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无名模块是一个没有名称的通用模块，其中包含所有那些不属于任何模块但在类路径中找到的类型。无名模块可以访问所有命名模块（用户定义的模块）和内置模块（Java平台模块）的所有导出类型。另一方面，命名模块（用户定义的模块）将无法访问无名模块中的类型。换句话说，命名模块无法声明对无名模块的依赖关系。如果您想声明依赖关系，该怎么办？无名模块没有名称！
- en: With the concept of unnamed modules, you can take your Java 8 application as
    is and run it on Java 9 (except for any deprecated internal APIs, which might
    not be available for user code in Java 9).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有了无名模块的概念，您可以将您的Java 8应用程序保持原样，并在Java 9上运行它（除了任何已弃用的内部API，这些API在Java 9中可能不可用于用户代码）。
- en: You may have seen this if you have tried out the *Using jdeps to find dependencies
    in a Java application* recipe, where we had a non-modular application and were
    able to run it on Java 9\. However, running as is on Java 9 would defeat the purpose
    of introducing the modular system.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试过*使用jdeps在Java应用程序中查找依赖项*的示例，您可能已经看到了这一点，在那个示例中，我们有一个非模块化的应用程序，并且能够在Java
    9上运行它。然而，在Java 9上按原样运行将违背引入模块化系统的初衷。
- en: If a package is defined in both named and unnamed modules, the one in the named
    module would be given preference over the one in the unnamed module. This helps
    to prevent package conflicts when they come from both named and unnamed modules.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个包在命名模块和无名模块中都有定义，那么命名模块中的包将优先于无名模块中的包。这有助于防止当它们来自命名模块和无名模块时的包冲突。
- en: Automatic modules are those that are automatically created by the JVM. These
    modules are created when we introduce the classes packaged in JARs in the module
    path instead of the classpath. The name of this module will be derived from the
    name of the JAR without the `.jar` extension and, hence, is different from unnamed
    modules. Alternatively, one can provide the name for these automatic modules by
    providing the module name against `Automatic-Module-Name` in the JAR manifest
    file. These automatic modules export all the packages present in it and also depend
    on all the automatic and named (user/JDK) modules.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 自动模块是JVM自动创建的模块。当我们将打包在JAR中的类引入模块路径而不是类路径时，将创建这些模块。该模块的名称将从JAR的名称中派生，因此与未命名模块不同。或者，可以通过在JAR清单文件中对`Automatic-Module-Name`提供模块名称来为这些自动模块提供名称。这些自动模块导出其中的所有包，并且还依赖于所有自动和命名（用户/JDK）模块。
- en: 'Based on this explanation, modules can be classified into the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个解释，模块可以分为以下几类：
- en: '**Unnamed modules**: The code available on the classpath and not available
    on the module path is placed in an unnamed module.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未命名模块**：在类路径上可用但在模块路径上不可用的代码放置在未命名模块中。'
- en: '**Named modules**: All those modules that have a name associated with them—these
    can be user-defined modules and JDK modules.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名模块**：所有具有与之关联的名称的模块 - 这些可以是用户定义的模块和JDK模块。'
- en: '**Automatic modules**: All those modules that are implicitly created by JVM
    based on the JAR files present in the module path.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动模块**：所有由JVM根据模块路径中存在的JAR文件隐式创建的模块。'
- en: '**Implicit modules**: Modules which are implicitly created. They are the same
    as automatic modules.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式模块**：隐式创建的模块。它们与自动模块相同。'
- en: '**Explicit modules**: All modules which are created explicitly by the user
    or JDK.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式模块**：所有由用户或JDK显式创建的模块。'
- en: But the unnamed module and automatic module are a good first step to start your
    migration. So, let's get started!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 但未命名模块和自动模块是开始迁移的良好第一步。所以，让我们开始吧！
- en: Getting ready
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need a non-modular application that we will eventually modularize. We have
    already created a simple application, whose source code is available at `Chapter03/6_bottom_up_migration_before`.
    This simple application has three parts to it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个非模块化的应用程序，最终我们将对其进行模块化。我们已经创建了一个简单的应用程序，其源代码位于`Chapter03/6_bottom_up_migration_before`。这个简单的应用程序有三个部分：
- en: 'A math utility library that contains our favorite mathematical APIs: prime
    checker, even number checker, sum of primes, sum of evens, and sum of odds. The
    code for this is available at `Chapter03/6_bottom_up_migration_before/math_util`.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含我们最喜爱的数学API的数学实用程序库：素数检查器，偶数检查器，素数之和，偶数之和和奇数之和。其代码位于`Chapter03/6_bottom_up_migration_before/math_util`。
- en: A banking utility library that contains APIs to compute simple interest and
    compound interest. The code for this is available at `Chapter03/6_bottom_up_migration_before/banking_util`.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个银行实用程序库，其中包含用于计算简单利息和复利的API。其代码位于`Chapter03/6_bottom_up_migration_before/banking_util`。
- en: Our calculator app helps us with our mathematical and banking calculations.
    To make this more interesting, we will output the results in JSON and for this,
    we will make use of Jackson JSON API. The code for this is available at  `Chapter03/6_bottom_up_migration_before/calculator`.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的计算器应用程序帮助我们进行数学和银行业务计算。为了使其更有趣，我们将以JSON格式输出结果，为此我们将使用Jackson JSON API。其代码位于`Chapter03/6_bottom_up_migration_before/calculator`。
- en: 'After you have copied or downloaded the code, we will compile and build the
    respective JARs. So, use the following commands to compile and build the JARs:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在您复制或下载了代码之后，我们将编译和构建相应的JAR。因此，请使用以下命令来编译和构建JAR：
- en: '[PRE44]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s also create a JAR for this (we will make use of the JAR to build the
    dependency graph, but not for running the app):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也为此创建一个JAR（我们将使用该JAR来构建依赖关系图，但不用于运行应用程序）：
- en: '[PRE45]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Please note that our Jackson JARs are in the calculator/lib, so you don''t
    need to worry about downloading them. Let''s run our calculator using the following
    command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的Jackson JARs位于calculator/lib中，所以您不需要担心下载它们。让我们使用以下命令运行我们的计算器：
- en: '[PRE46]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You will see a menu asking for the choice of operation, and then you can play
    around with different operations. Now, let's modularize this application!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个菜单询问操作的选择，然后您可以尝试不同的操作。现在，让我们对这个应用程序进行模块化！
- en: We have provided `package-*.bat` and run.bat to the package and run the application
    on Windows. You can use `package-*.sh` and `run.sh` for the package and run the
    application on Linux.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了`package-*.bat`和run.bat来在Windows上打包和运行应用程序。您可以使用`package-*.sh`和`run.sh`在Linux上打包和运行应用程序。
- en: How to do it...
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first step in modularizing your application is to understand its dependency
    graph. Let''s create a dependency graph for our application. For that, we make
    use of the `jdeps` tool. If you are wondering what the `jdeps` tool is, stop right
    now and read the *Using jdeps to find dependencies in a Java application* recipe.
    OK, so let''s run the `jdeps` tool:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化应用程序的第一步是了解其依赖关系图。让我们为我们的应用程序创建一个依赖关系图。为此，我们使用`jdeps`工具。如果您想知道`jdeps`工具是什么，请立即阅读*在Java应用程序中使用jdeps查找依赖关系*。好的，让我们运行`jdeps`工具：
- en: '[PRE47]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We are asking `jdeps` to give us a summary of the dependencies of our `calculator.jar`
    and then do this recursively for each dependency of `calculator.jar`. The output
    we get is as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求`jdeps`给我们`calculator.jar`的依赖关系摘要，然后对`calculator.jar`的每个依赖项进行递归处理。我们得到的输出如下：
- en: '[PRE48]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding output is hard to understand and the same can be diagrammatically,
    as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出很难理解，可以用图表形式表示如下：
- en: '![](img/93b83846-6af9-420c-b832-333dbaa80c30.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93b83846-6af9-420c-b832-333dbaa80c30.png)'
- en: In bottom-up migration, we start by modularizing the leaf nodes. In our graph,
    the `java.xml`, `java.sql`, `java.base`, and `java.logging` leaf nodes are already
    modularized. Let's modularize `banking.util.jar`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在自下而上的迁移中，我们首先将叶节点模块化。在我们的图中，`java.xml`，`java.sql`，`java.base`和`java.logging`叶节点已经被模块化。让我们将`banking.util.jar`模块化。
- en: All the code for this recipe is available at `Chapter03/6_bottom_up_migration_after`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的所有代码都可以在`Chapter03/6_bottom_up_migration_after`中找到。
- en: Modularizing banking.util.jar
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化banking.util.jar
- en: 'Copy `BankUtil.java` from `Chapter03/6_bottom_up_migration_before/banking_util/src/com/packt/banking`
    to `Chapter03/6_bottom_up_migration_after/src/banking.util/com/packt/banking`.
    There are two things to take a note of:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BankUtil.java`从`Chapter03/6_bottom_up_migration_before/banking_util/src/com/packt/banking`复制到`Chapter03/6_bottom_up_migration_after/src/banking.util/com/packt/banking`。有两件事需要注意：
- en: We have renamed the folder from `banking_util` to `banking.util`. This is to
    follow the convention of placing module-related code under the folder bearing
    the module name.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经将文件夹从`banking_util`改名为`banking.util`。这是为了遵循将与模块相关的代码放在带有模块名称的文件夹下的惯例。
- en: We have placed the package directly under the `banking.util` folder and not
    under `src`. Again, this is to follow the convention. We will be placing all our
    modules under the `src` folder.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将包直接放在`banking.util`文件夹下，而不是放在`src`下。同样，这是为了遵循惯例。我们将把所有的模块放在`src`文件夹下。
- en: 'Create the module definition file `module-info.java` under `Chapter03/6_bottom_up_migration_after/src/banking.util` with
    the following definition:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter03/6_bottom_up_migration_after/src/banking.util`下创建模块定义文件`module-info.java`，内容如下：
- en: '[PRE49]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'From within the `6_bottom_up_migration_after` folder, compile the java code
    of the modules by running the command:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`6_bottom_up_migration_after`文件夹中，通过运行以下命令编译模块的Java代码：
- en: '[PRE50]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You will see that the java code in the module `banking.util` is compiled into
    the mods directory.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到`banking.util`模块中的Java代码被编译到了mods目录中。
- en: 'Let''s create a modular JAR for this module:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为这个模块创建一个模块化的JAR：
- en: '[PRE51]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you are wondering what a modular JAR is, feel free to read through the *Creating
    a modular JAR*recipein this chapter.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道什么是模块化的JAR，请随意阅读本章节中的*创建模块化JAR*部分。
- en: 'Now that we have modularized `banking.util.jar`, let''s use this modular `jar`
    in place of the non-modular JAR used in the *Getting ready* section earlier. You
    should execute the following from the `6_bottom_up_migration_before` folder because
    we haven''t yet completely modularized the app:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将`banking.util.jar`模块化了，让我们在*准备工作*部分之前使用这个模块化的`jar`来替代之前使用的非模块化JAR。你应该从`6_bottom_up_migration_before`文件夹中执行以下操作，因为我们还没有完全将应用程序模块化：
- en: '[PRE52]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `--add-modules` option tells the Java runtime to include the modules either
    by module name or by predefined constants, namely `ALL-MODULE-PATH`, `ALL-DEFAULT`,
    and `ALL-SYSTEM`. We made use of `ALL-MODULE-PATH` to add the module that is available
    on our module path.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`--add-modules`选项告诉Java运行时要包含模块，可以通过模块名称或预定义常量，即`ALL-MODULE-PATH`，`ALL-DEFAULT`和`ALL-SYSTEM`来实现。我们使用了`ALL-MODULE-PATH`来添加模块，该模块可在我们的模块路径上使用。'
- en: The `--module-path` option tells the Java runtime the location of our modules.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`--module-path`选项告诉Java运行时我们模块的位置。'
- en: 'You will see that our calculator is running as usual. Try out a simple interest
    calculation, a compound interest calculation, to check if the `BankUtil` class
    is found. So, our dependency graph now looks like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我们的计算器正常运行。尝试简单利息计算，复利计算，以检查`BankUtil`类是否被找到。因此，我们的依赖图现在如下所示：
- en: '![](img/d708231d-d5e9-4fea-b1ab-44d956a531c8.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d708231d-d5e9-4fea-b1ab-44d956a531c8.png)'
- en: Modularizing math.util.jar
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化math.util.jar
- en: Copy `MathUtil.java` from `Chapter03/6_bottom_up_migration_before/math_util/src/com/packt/math`
    to `Chapter03/6_bottom_up_migration_after/src/math.util/com/packt/math`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MathUtil.java`从`Chapter03/6_bottom_up_migration_before/math_util/src/com/packt/math`复制到`Chapter03/6_bottom_up_migration_after/src/math.util/com/packt/math`。
- en: 'Create the module definition file, `module-info.java`, under `Chapter03/6_bottom_up_migration_after/src/math.util` with
    the following definition:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter03/6_bottom_up_migration_after/src/math.util`下创建模块定义文件`module-info.java`，内容如下：
- en: '[PRE53]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'From within the `6_bottom_up_migration_after` folder, compile the Java code
    of the modules by running the following command:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`6_bottom_up_migration_after`文件夹中，通过运行以下命令编译模块的Java代码：
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You will see that the Java code in the `math.util` and `banking.util` modules
    is compiled into the `mods` directory.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到`math.util`和`banking.util`模块中的Java代码被编译到了`mods`目录中。
- en: 'Let''s create a modular JAR for this module:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为这个模块创建一个模块化的JAR：
- en: '[PRE55]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you are wondering what a modular `jar` is, feel free to read through the *Creating
    a modular JAR* recipe in this chapter.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道什么是模块化的`jar`，请随意阅读本章节中的*创建模块化JAR*部分。
- en: 'Now that we have modularized `math.util.jar`, let''s use this modular `jar`
    in place of the non-modular `jar` that we used in the *Getting ready* section
    earlier. You should execute the following from the `6_bottom_up_migration_before`
    folder because we haven''t completely modularized the app yet:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将`math.util.jar`模块化了，让我们在*准备工作*部分之前使用这个模块化的`jar`来替代非模块化的`jar`。你应该从`6_bottom_up_migration_before`文件夹中执行以下操作，因为我们还没有完全将应用程序模块化：
- en: '[PRE56]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Our app is running fine, and the dependency graph looks as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序运行正常，并且依赖图如下所示：
- en: '![](img/a82c6458-5c5b-4270-a8a5-308a39b9eb12.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a82c6458-5c5b-4270-a8a5-308a39b9eb12.png)'
- en: We cannot modularize `calculator.jar` because it depends on another non-modular
    code, `jackson-databind`, and we cannot modularize `jackson-databind` as it is
    not maintained by us. This means that we cannot achieve 100% modularity for our
    application. We introduced you to Unnamed modules at the beginning of this recipe.
    All our non-modular code in the classpath are grouped in unnamed modules, which
    means all jackson-related code can still remain in the unnamed module and we can
    try to modularize `calculator.jar`. But we cannot do so because `calculator.jar` cannot
    declare a dependency on `jackson-databind-2.8.4.jar` (because it is an unnamed
    module and named modules cannot declare dependency on unnamed modules).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法将`calculator.jar`模块化，因为它依赖于另一个非模块化的代码`jackson-databind`，而我们无法将`jackson-databind`模块化，因为它不是我们维护的。这意味着我们无法为我们的应用程序实现100%的模块化。我们在本教程开始时向您介绍了未命名模块。我们类路径中的所有非模块化代码都被分组在未命名模块中，这意味着所有与jackson相关的代码仍然可以保留在未命名模块中，我们可以尝试将`calculator.jar`模块化。但是我们无法这样做，因为`calculator.jar`不能声明对`jackson-databind-2.8.4.jar`的依赖（因为它是一个未命名模块，命名模块不能声明对未命名模块的依赖）。
- en: 'A way to get around this is to make the jackson-related code as automatic modules.
    We can do this by moving the jars related to jackson:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是将与jackson相关的代码作为自动模块。我们可以通过移动与jackson相关的jar来实现这一点：
- en: '`jackson-databind-2.8.4.jar`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jackson-databind-2.8.4.jar`'
- en: '`jackson-annotations-2.8.4.jar`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jackson-annotations-2.8.4.jar`'
- en: '`jackson-core-2.8.4.jar`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jackson-core-2.8.4.jar`'
- en: 'We''ll move them under the `6_bottom_up_migration_after` folder using the following
    commands:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令将它们移动到`6_bottom_up_migration_after`文件夹下：
- en: '[PRE57]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The reason for renaming the jars is that the name of the module has to be a
    valid identifier (should not be only numeric, should not contain `-`, and other
    rules) separated with `.`. As the names are derived from the name of the JAR files,
    we had to rename the JAR files to conform to the Java identifier rules.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名JAR的原因是模块的名称必须是有效的标识符（不能仅为数字，不能包含“-”和其他规则），用`.`分隔。由于名称是从JAR文件的名称派生的，我们必须将JAR文件重命名以符合Java标识符规则。
- en: Create a new `mlib` directory, if it is not present, under `6_bottom_up_migration_after`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在，创建一个新的`mlib`目录，在`6_bottom_up_migration_after`下。
- en: 'Now, let''s run our calculator program again using the following command:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行我们的计算器程序，使用以下命令：
- en: '[PRE58]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The application will run as usual. You will notice that our `-cp` option value
    is getting smaller as all the dependent libraries have been moved as modules in
    the module path. The dependency graph now looks like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将像往常一样运行。您会注意到我们的`-cp`选项值正在变小，因为所有依赖库都已经作为模块移动到了模块路径中。依赖关系图现在看起来像这样：
- en: '![](img/235a1fd5-2c09-4046-8c84-fb0abafd266b.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/235a1fd5-2c09-4046-8c84-fb0abafd266b.png)'
- en: Modularizing calculator.jar
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化calculator.jar
- en: 'The last step in the migration is to modularize `calculator.jar`. Follow these
    steps to modularize it:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移的最后一步是将`calculator.jar`模块化。按照以下步骤进行模块化：
- en: Copy the `com` folder from `Chapter03/6_bottom_up_migration_before/calculator/src`
    to `Chapter03/6_bottom_up_migration_after/src/calculator`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Chapter03/6_bottom_up_migration_before/calculator/src`中的`com`文件夹复制到`Chapter03/6_bottom_up_migration_after/src/calculator`。
- en: 'Create the module definition file, `module-info.java`, under `Chapter03/6_bottom_up_migration_after/src/calculator`,
    with the following definition:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter03/6_bottom_up_migration_after/src/calculator`下创建模块定义文件`module-info.java`，定义如下：
- en: '[PRE59]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'From within the `6_bottom_up_migration_after` folder, compile the Java code
    of the modules by running the following command:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`6_bottom_up_migration_after`文件夹中，通过运行以下命令编译模块的Java代码：
- en: '[PRE60]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You will see that the Java code in all our modules is compiled into the mods
    directory. Please note that you should have the automatic modules (that is, jackson-related
    JARs) already placed in the `mlib` directory.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到我们所有模块中的Java代码都编译到了mods目录中。请注意，您应该已经将自动模块（即与jackson相关的JAR）放置在`mlib`目录中。
- en: 'Let''s create a modular JAR for this module and also mention which is the `main`
    class:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为这个模块创建一个模块化的JAR，并指定哪个是`main`类：
- en: '[PRE61]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, we have a modular JAR for our calculator module, which is our main module
    as it contains the `main` class. With this, we have also modularized our complete
    application. Let''s run the following command from the folder: `6_bottom_up_migration_after`:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有了我们的计算器模块的模块化JAR，这是我们的主要模块，因为它包含了`main`类。通过这样做，我们还模块化了我们的完整应用程序。让我们从文件夹`6_bottom_up_migration_after`运行以下命令：
- en: '[PRE62]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'So, we have seen how to modularize a non-modular application using a bottom-up
    migration approach. The final dependency graph looks something like this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了如何使用自下而上的迁移方法将非模块化的应用程序模块化。最终的依赖关系图看起来像这样：
- en: '![](img/68490d34-cdaf-44a0-b7bd-02e6754c10bf.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68490d34-cdaf-44a0-b7bd-02e6754c10bf.png)'
- en: The final code for this modular application can be found at `Chapter03/6_bottom_up_migration_after`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块化应用程序的最终代码可以在`Chapter03/6_bottom_up_migration_after`中找到。
- en: We could have done modification in line, that is, modularize the code in the
    same directory, `6_bottom_up_migration_before`. But we prefer to do it separately
    in a different directory, `6_bottom_up_migration_after`, so as to keep it clean
    and not disturb the existing codebase.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以在同一目录`6_bottom_up_migration_before`中进行修改，即在同一目录中对代码进行模块化。但我们更喜欢在不同的目录`6_bottom_up_migration_after`中单独进行，以保持代码整洁，不干扰现有的代码库。
- en: How it works...
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The concept of unnamed modules helped us to run our non-modular application
    on Java 9\. The use of both module path and classpath helped us to run the partly
    modular application while we were doing the migration. We started with modularizing
    those codebases that were not dependent on any non-modular code, and any codebase
    that we couldn't modularize, we converted into automatic modules, thereby enabling
    us to modularize the code which was dependent on such a code base. Eventually,
    we ended up with a completely modular application.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 未命名模块的概念帮助我们在Java 9上运行我们的非模块化应用程序。在迁移过程中，模块路径和类路径的使用帮助我们运行部分模块化的应用程序。我们从模块化那些不依赖于任何非模块化代码的代码库开始，而我们无法模块化的任何代码库，我们将其转换为自动模块，从而使我们能够模块化依赖于这样一个代码库的代码。最终，我们得到了一个完全模块化的应用程序。
- en: Top-down migration
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自上而下的迁移
- en: The other technique for migration is  top-down migration. In this approach,
    we start with the root JAR in the dependency graph of the JARs.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移的另一种技术是自上而下的迁移。在这种方法中，我们从JAR的依赖图中的根JAR开始。
- en: JARs indicate a codebase. We have assumed that the codebase is available in
    the form of JARs and hence the dependency graph that we get has nodes, which are
    JARs.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: JAR表示一个代码库。我们假设代码库以JAR的形式可用，因此我们得到的依赖图具有节点，这些节点是JAR。
- en: 'Modularizing the root of the dependency graph would mean that all other JARs
    on which this root depends have to be modular. Otherwise, this modular root cannot
    declare a dependency on unnamed modules. Let''s consider the example non-modular
    application we introduced in our Bottom-Up Migration recipe. The dependency graph
    looks something like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 将依赖图的根模块化意味着该根模块依赖的所有其他JAR都必须是模块化的。否则，这个模块化根模块就无法声明对未命名模块的依赖。让我们考虑一下我们在底向上迁移食谱中介绍的非模块化应用程序的例子。依赖图看起来像这样：
- en: '![](img/90299e09-6b9c-4e5e-a65f-e6e31db6158d.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90299e09-6b9c-4e5e-a65f-e6e31db6158d.png)'
- en: We extensively make use of automatic modules in top-down migration. Automatic
    modules are modules that are implicitly created by the JVM. These are created
    based on the non-modular JARs available in the module path.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在自上而下的迁移中广泛使用自动模块。自动模块是由JVM隐式创建的模块。这些模块是基于模块路径中可用的非模块化JAR创建的。
- en: Getting ready
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will make use of the calculator example that we introduced in the previous
    recipe, *Bottom-up migration*. Go ahead and copy the non-modular code from `Chapter03/7_top_down_migration_before`.
    Use the following commands if you wish to run it and see whether it''s working:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在前一篇食谱*自下而上的迁移*中介绍的计算器示例。继续从`Chapter03/7_top_down_migration_before`复制非模块化代码。如果您希望运行它并查看它是否正常工作，请使用以下命令：
- en: '[PRE63]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We have provided `package-*.bat` and `run.bat` to the package and run the code
    on Windows, and used `package-*.sh` and `run.sh` on the package and run the code
    on Linux.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了`package-*.bat`和`run.bat`来在Windows上打包和运行代码，并在Linux上使用`package-*.sh`和`run.sh`来打包和运行代码。
- en: How to do it...
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will be modularizing the application under the `Chapter03/7_top_down_migration_after` directory.
    Create two directories, `src` and `mlib`, under `Chapter03/7_top_down_migration_after`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对`Chapter03/7_top_down_migration_after`目录下的应用程序进行模块化。在`Chapter03/7_top_down_migration_after`下创建两个目录，`src`和`mlib`。
- en: Modularizing the calculator
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化计算器
- en: 'We cannot modularize the calculator until we have modularized all its dependencies.
    But modularizing its dependencies might be easier at times and not so at other
    times, especially in cases where the dependency is from a third party. In such
    scenarios, we make use of automatic modules. We copy the non-modular JARs under
    the folder `mlib` and ensuring that the name of the JAR is in the form `<identifier>(.<identifier>)*`, 
    where `<identifier>` is a valid Java identifier:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们模块化所有依赖项之前，我们无法模块化计算器。但是，在某些情况下，模块化其依赖项可能更容易，而在其他情况下可能不那么容易，特别是在依赖项来自第三方的情况下。在这种情况下，我们使用自动模块。我们将非模块化的JAR复制到`mlib`文件夹中，并确保JAR的名称采用`<identifier>(.<identifier>)*`的形式，其中`<identifier>`是有效的Java标识符。
- en: '[PRE64]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We have provided the `copy-non-mod-jar.bat` and `copy-non-mod-jar.sh` scripts
    to copy the jars easily.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提供了`copy-non-mod-jar.bat`和`copy-non-mod-jar.sh`脚本，以便轻松复制jar包。
- en: 'Let''s see what we copied into `mlib`:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们复制到`mlib`中的内容：
- en: '[PRE65]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`banking.util.jar` and `math.util.jar` will exist only if you have compiled
    and JAR-ed the code in the `Chapter03/7_top_down_migration_before/banking_util`
    and `Chapter03/7_top_down_migration_before/math_util` directories. We did this
    in the *Getting ready*section earlier.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`banking.util.jar`和`math.util.jar`只有在您已经在`Chapter03/7_top_down_migration_before/banking_util`和`Chapter03/7_top_down_migration_before/math_util`目录中编译和打包了代码时才会存在。我们在*准备工作*部分中已经做过这个。我们在*准备工作*部分中已经做过这个。'
- en: Create a new `calculator` folder under `src`. This will contain the code for
    the `calculator` module.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`下创建一个新的`calculator`文件夹。这将包含`calculator`模块的代码。
- en: Create `module-info.java` under the `Chapter03/7_top_down_migration_after/src/calculator`
    directory that contains the following**:**
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter03/7_top_down_migration_after/src/calculator`目录下创建`module-info.java`，其中包含以下内容**：**
- en: '[PRE66]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Copy the `Chapter03/7_top_down_migration_before/calculator/src/com` directory
    and all the code under it to `Chapter03/7_top_down_migration_after/src/calculator`.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Chapter03/7_top_down_migration_before/calculator/src/com`目录及其下的所有代码复制到`Chapter03/7_top_down_migration_after/src/calculator`。
- en: 'Compile the calculator module:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译calculator模块：
- en: '[PRE67]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create the modular JAR for the `calculator` module:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`calculator`模块创建模块化JAR：
- en: '[PRE68]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Run the `calculator` module:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`calculator`模块：
- en: '[PRE69]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We will see that our calculator is executing correctly. You can try out different
    operations to verify if all of them are executing correctly.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到我们的计算器是否正确执行。您可以尝试不同的操作来验证它们是否都正确执行。
- en: Modularizing banking.util
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化banking.util
- en: 'As this doesn''t depend on other non-module code, we can directly convert this
    into a module by following these steps:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这不依赖于其他非模块化代码，我们可以通过以下步骤直接将其转换为模块：
- en: Create a new `banking.util` folder under `src`. This will contain the code for
    the `banking.util` module.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`下创建一个新的`banking.util`文件夹。这将包含`banking.util`模块的代码。
- en: Create `module-info.java` under the `Chapter03/7_top_down_migration_after/src/banking.util`directory**, **which
    contains the following**:**
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter03/7_top_down_migration_after/src/banking.util`目录下创建`module-info.java`，其中包含以下内容：
- en: '[PRE70]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Copy the `Chapter03/7_top_down_migration_before/banking_util/src/com` directory
    and all the code under it to `Chapter03/7_top_down_migration_after/src/banking.util`.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Chapter03/7_top_down_migration_before/banking_util/src/com`目录及其下所有代码复制到`Chapter03/7_top_down_migration_after/src/banking.util`。
- en: 'Compile the modules:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译模块：
- en: '[PRE71]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create a modular JAR for the `banking.util` module. This will replace the non-modular
    `banking.util.jar` already present in `mlib`:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`banking.util`模块创建一个模块化的JAR。这将替换`mlib`中已经存在的非模块化`banking.util.jar`：
- en: '[PRE72]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Run the `calculator` module to test whether the `banking.util` modular JAR
    has been created successfully:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`calculator`模块，测试`banking.util`模块化JAR是否已成功创建：
- en: '[PRE73]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You should see the calculator getting executed. Play around with different operations
    to ensure that there are no "class not found" issues.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到计算器被执行。尝试不同的操作，以确保没有“找不到类”的问题。
- en: Modularizing math.util
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化math.util
- en: Create a new `math.util` folder under `src`. This will contain the code for
    the `math.util` module.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`下创建一个新的`math.util`文件夹。这将包含`math.util`模块的代码。
- en: Create `module-info.java` under the `Chapter03/7_top_down_migration_after/src/math.util`directory,
    which contains the following**:**
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter03/7_top_down_migration_after/src/math.util`目录下创建`module-info.java`，其中包含以下内容：
- en: '[PRE74]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Copy the `Chapter03/7_top_down_migration_before/math_util/src/com` directory
    and all the code under it to `Chapter03/7_top_down_migration_after/src/math.util`.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Chapter03/7_top_down_migration_before/math_util/src/com`目录及其下所有代码复制到`Chapter03/7_top_down_migration_after/src/math.util`。
- en: 'Compile the modules:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译模块：
- en: '[PRE75]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create a modular JAR for the `banking.util` module. This will replace the non-modular
    `banking.util.jar` already present in `mlib`:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`banking.util`模块创建一个模块化的JAR。这将替换`mlib`中已经存在的非模块化`banking.util.jar`：
- en: '[PRE76]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Run the `calculator` module to test whether the `math.util` modular JAR has
    been created successfully.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`calculator`模块，测试`math.util`模块化JAR是否已成功创建。
- en: '[PRE77]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You should see the calculator getting executed. Play around with different operations
    to ensure that there are no *class not found* issues.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到计算器被执行。尝试不同的操作，以确保没有*找不到类*的问题。
- en: With this, we have completely modularized the application, baring the Jackson
    libraries which we have converted to automatic modules.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经完全模块化了应用程序，除了Jackson库，我们已经将其转换为自动模块。
- en: We prefer the top-down approach for migration. This is because we don't have
    to deal with classpath and module-path at the same time. We can make everything
    into automatic modules and then use the module-path as we keep migrating the non-modular
    JARs into modular JARs.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢自上而下的迁移方法。这是因为我们不必同时处理类路径和模块路径。我们可以将所有内容都转换为自动模块，然后在将非模块化的JAR迁移到模块化JAR时使用模块路径。
- en: Using services to create loose coupling between the consumer and provider modules
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务来创建消费者和提供者模块之间的松耦合
- en: Generally, in our applications, we have some interfaces and multiple implementations
    of those interfaces. Then, at runtime, depending on certain conditions, we make
    use of specific implementations. This principle is called **Dependency Inversion**.
    This principle is used by dependency injection frameworks, such as Spring, to
    create objects of concrete implementations and assign (or inject) into the references
    of the abstract interface type.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在我们的应用程序中，我们有一些接口和这些接口的多个实现。然后，在运行时，根据某些条件，我们使用特定的实现。这个原则叫做**依赖反转**。依赖注入框架（如Spring）使用这个原则来创建具体实现的对象，并将其分配（或注入）到抽象接口类型的引用中。
- en: For a long time, Java (since Java 6) has supported service-provider loading
    facilities via the `java.util.ServiceLoader` class. Using Service Loader, you
    can have a **service provider interface** (**SPI**) and multiple implementations
    of the SPI simply called service provider. These service providers are located
    in the classpath and loaded at runtime. When these service providers are located
    within modules, and as we no longer depend on the classpath scanning to load the
    service provider, we need a mechanism to tell our modules about the service provider
    and the service provider interface for which it is providing an implementation.
    In this recipe, we will look at this mechanism by using a simple example.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间以来，Java（自Java 6以来）一直支持通过`java.util.ServiceLoader`类进行服务提供者加载。使用Service
    Loader，您可以有一个**服务提供者接口**（SPI）和SPI的多个实现，简称服务提供者。这些服务提供者位于类路径中，并在运行时加载。当这些服务提供者位于模块中时，由于我们不再依赖于类路径扫描来加载服务提供者，我们需要一种机制来告诉我们的模块有关服务提供者和服务提供者接口的机制，以及它提供实现的服务提供者。在这个配方中，我们将通过一个简单的例子来看一下这种机制。
- en: Getting ready
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: There is nothing specific we need to set up for this recipe. In this recipe,
    we will take a simple example. We have one `BookService` abstract class, which
    supports CRUD operations. Now, these CRUD operations can work on a SQL DB, MongoDB,
    a filesystem, and so on. This flexibility can be provided by using the service
    provider interface and the `ServiceLoader` class to load the required service
    provider implementation.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们没有特定的设置。在这个配方中，我们将举一个简单的例子。我们有一个`BookService`抽象类，支持CRUD操作。现在，这些CRUD操作可以在SQL
    DB、MongoDB、文件系统等上工作。通过使用服务提供者接口和`ServiceLoader`类来加载所需的服务提供者实现，可以提供这种灵活性。
- en: How to do it...
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We have four modules in this recipe:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个配方中有四个模块：
- en: '`book.service`: This is the module that contains our service provider interface,
    that is, the service'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`book.service`：这是包含我们服务提供者接口的模块，也就是服务'
- en: '`mongodb.book.service`: This is one of the service provider modules'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongodb.book.service`：这是其中一个服务提供者模块'
- en: '`sqldb.book.service`: This is the other service provider module'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqldb.book.service`：这是另一个服务提供者模块'
- en: '`book.manage`: This is the service consumer module'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`book.manage`：这是服务消费者模块'
- en: 'The following steps demonstrate how to make use of `ServiceLoader` to achieve
    loose coupling:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了如何利用`ServiceLoader`实现松耦合：
- en: Create a `book.service` folder under the `Chapter03/8_services/src` directory.
    All our code for the `book.service` module will be under this folder.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter03/8_services/src`目录下创建一个名为`book.service`的文件夹。我们的`book.service`模块的所有代码将放在这个文件夹中。
- en: 'Create a new package, `com.packt.model`, and a new class, `Book`, under the
    new package. This is our model class, which contains the following properties:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的包`com.packt.model`，并在新包下创建一个名为`Book`的新类。这是我们的模型类，包含以下属性：
- en: '[PRE78]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create a new package, `com.packt.service`, and a new class, `BookService`,
    under the new package. This is our main service interface, and the service providers
    will provide an implementation for this service. Apart from the abstract methods
    for CRUD operations, one method worth mentioning is `getInstance()`. This method
    uses the `ServiceLoader` class to load any one service provider (the last one,
    to be specific) and then use that service provider to get an implementation of `BookService`.
    Let''s see the following code:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的包`com.packt.service`，并在新包下创建一个名为`BookService`的新类。这是我们的主要服务接口，服务提供者将为此服务提供实现。除了CRUD操作的抽象方法之外，值得一提的是`getInstance()`方法。该方法使用`ServiceLoader`类加载任何一个服务提供者（具体来说是最后一个），然后使用该服务提供者获取`BookService`的实现。让我们看一下以下代码：
- en: '[PRE79]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The first `while` loop is just for demonstrating that the `ServiceLoader` loads
    all the service providers and we pick one of the service providers. You can conditionally
    return the service provider as well, but that all depends on the requirements.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`while`循环只是为了演示`ServiceLoader`加载所有服务提供者，然后我们选择其中一个服务提供者。您也可以有条件地返回服务提供者，但这完全取决于要求。
- en: 'The other important part is the actual service provider interface. The responsibility
    of this is to return an appropriate instance of the service implementation. In
    our recipe, `BookServiceProvider` in the `com.packt.spi` package is a service
    provider interface:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个重要部分是实际的服务提供者接口。其责任是返回服务实现的适当实例。在我们的示例中，`com.packt.spi`包中的`BookServiceProvider`是一个服务提供者接口：
- en: '[PRE80]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We create `module-info.java` under the `Chapter03/8_services/src/book.service` directory,
    which contains the following:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`Chapter03/8_services/src/book.service`目录下创建`module-info.java`，其中包含以下内容：
- en: '[PRE81]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `uses` statement in the preceding module definition specifies the service
    interface that the module discovers using `ServiceLoader`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模块定义中，`uses`语句指定了模块使用`ServiceLoader`发现的服务接口。
- en: Now let's create a service provider module called `mongodb.book.service`. This
    will provide an implementation for our `BookService` and `BookServiceProvider`
    interface in the `book.service` module. Our idea is that this service provider
    will implement the CRUD operations using the MongoDB datastore.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个名为`mongodb.book.service`的服务提供者模块。这将在`book.service`模块中为`BookService`和`BookServiceProvider`接口提供实现。我们的想法是，这个服务提供者将使用MongoDB数据存储实现CRUD操作。
- en: Create a `mongodb.book.service` folder under the `Chapter03/8_services/src` directory.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter03/8_services/src`目录下创建一个`mongodb.book.service`文件夹。
- en: 'Create a `MongoDbBookService` class in the `com.packt.mongodb.service` package,
    which extends the `BookService` abstract class and provides an implementation
    of our abstract CRUD operation methods:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packt.mongodb.service`包中创建一个`MongoDbBookService`类，它继承了`BookService`抽象类，并提供了我们的抽象CRUD操作方法的实现：
- en: '[PRE82]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Create a `MongoDbBookServiceProvider` class in the `com.packt.mongodb` package,
    which implements the `BookServiceProvider` interface. This is our service-discovery
    class. Basically, it returns a relevant instance of the `BookService` implementation.
    It overrides the method in the `BookServiceProvider` interface, as follows:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packt.mongodb`包中创建一个`MongoDbBookServiceProvider`类，它实现了`BookServiceProvider`接口。这是我们的服务发现类。基本上，它返回`BookService`实现的相关实例。它重写了`BookServiceProvider`接口中的方法，如下所示：
- en: '[PRE83]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The module definition is quite interesting. We have to declare in the module
    definition that this module is a service provider for the `BookServiceProvider` interface,
    and that can be done as follows:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块定义非常有趣。我们必须在模块定义中声明该模块是`BookServiceProvider`接口的服务提供者，可以这样做：
- en: '[PRE84]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `provides .. with ..` statement is used to specify the service interface
    and one of the service providers.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`provides .. with ..`语句用于指定服务接口和其中一个服务提供者。'
- en: Now let's create a service consumer module called `book.manage`.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个名为`book.manage`的服务使用者模块。
- en: Create a new `book.manage` folder under `Chapter03/8_services/src` which will
    contain the code for the module.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter03/8_services/src`下创建一个新的`book.manage`文件夹，其中将包含模块的代码。
- en: 'Create a new class called `BookManager` in the `com.packt.manage` package.
    The main aim of this class is to get an instance of `BookService` and then execute
    its CRUD operations. The instance returned is decided by the service providers
    loaded by the `ServiceLoader`. The `BookManager` class looks something like this:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packt.manage`包中创建一个名为`BookManager`的新类。这个类的主要目的是获取`BookService`的实例，然后执行其CRUD操作。由`ServiceLoader`加载的服务提供者决定返回的实例。`BookManager`类大致如下：
- en: '[PRE85]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let''s compile and run our main module by using the following commands:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令编译和运行我们的主模块：
- en: '[PRE86]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the preceding output, the first line states the service providers that are
    available and the second line states which `BookService` implementation we are
    using.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，第一行列出了可用的服务提供者，第二行列出了我们正在使用的`BookService`实现。
- en: 'With one service provider, it looks simple. Let''s go ahead and add another
    module, `sqldb.book.service`, whose module definition would be as follows:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了一个服务提供者，看起来很简单。让我们继续添加另一个模块`sqldb.book.service`，其模块定义如下：
- en: '[PRE87]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `SqlDbBookServiceProvider` class in the `com.packt.sqldb` package is an
    implementation of the `BookServiceProvider` interface, as follows:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`com.packt.sqldb`包中的`SqlDbBookServiceProvider`类是`BookServiceProvider`接口的实现，如下所示：'
- en: '[PRE88]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The implementation of CRUD operations is done by the `SqlDbBookService` class
    in the package `com.packt.sqldb.service` package.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CRUD操作的实现由`com.packt.sqldb.service`包中的`SqlDbBookService`类完成。
- en: 'Let''s compile and run the main module, this time with two service providers:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行主模块，这次使用两个服务提供程序：
- en: '[PRE89]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The first two lines print the class names of the available service providers
    and the third line prints which `BookService` implementation we are using.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行打印出可用服务提供程序的类名，第三行打印出我们正在使用哪个`BookService`实现。
- en: Creating a custom modular runtime image using jlink
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jlink创建自定义模块化运行时镜像
- en: 'Java comes in two flavors:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: Java有两种版本：
- en: 'Java runtime only, also known as JRE: This supports the execution of Java applications'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅Java运行时，也称为JRE：支持Java应用程序的执行
- en: 'Java development kit with Java runtime, also called JDK: This supports the
    development and execution of Java applications'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有Java运行时的Java开发工具包，也称为JDK：支持Java应用程序的开发和执行
- en: 'Apart from this, there were three compact profiles introduced in Java 8 with
    the aim of providing runtimes with a smaller footprint in order to run on embedded
    and smaller devices shown as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Java 8引入了三个紧凑配置文件，旨在提供较小的占地面积的运行时，以便在嵌入式和较小的设备上运行，如下所示：
- en: '![](img/ee1d7126-b787-41bf-8b20-96920bb76650.png)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee1d7126-b787-41bf-8b20-96920bb76650.png)'
- en: The preceding image shows the different profiles and the features supported
    by them.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像显示了不同的配置文件和它们支持的功能。
- en: A new tool, called `jlink` was introduced in Java 9 that enables the creation
    of modular runtime images. These runtime images are nothing but a collection of
    a set of modules and their dependencies. There is a Java enhancement proposal,
    JEP 220, governing the structure of this runtime image.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9引入了一个名为`jlink`的新工具，它使得可以创建模块化运行时镜像。这些运行时镜像实际上是一组模块及其依赖项的集合。有一个名为JEP 220的Java增强提案，规定了这个运行时镜像的结构。
- en: In this recipe, we will use `jlink` to create a runtime image consisting of
    our `math.util`, `banking.util`, and `calculator` modules, along with the Jackson
    automatic modules.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`jlink`创建一个运行时镜像，其中包括我们的`math.util`，`banking.util`和`calculator`模块，以及Jackson自动模块。
- en: Getting ready
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the *Creating a simple modular application* recipe, we created a simple
    modular application consisting of the following modules:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在*创建一个简单的模块化应用程序*的示例中，我们创建了一个简单的模块化应用程序，包括以下模块：
- en: '`math.util`'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`math.util`'
- en: '`calculator`: Consists of the main class'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculator`：包括主类'
- en: We will reuse the same set of modules and code to demonstrate the use of the `jlink`
    tool. For the convenience of our readers, the code can be found at `Chapter03/9_jlink_modular_run_time_image`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用相同的模块和代码来演示`jlink`工具的使用。为了方便我们的读者，代码可以在`Chapter03/9_jlink_modular_run_time_image`中找到。
- en: How to do it...
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s compile the modules:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译这些模块：
- en: '[PRE90]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Let''s create the modular JAR for all the modules:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为所有模块创建模块化JAR：
- en: '[PRE91]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let''s use `jlink` to create a runtime image consisting of the `calculator` and `math.util` modules
    and their dependencies:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`jlink`创建一个运行时镜像，其中包括`calculator`和`math.util`模块及其依赖项：
- en: '[PRE92]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The runtime image gets created at the location specified with the `--output`
    command-line option.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时镜像在指定位置使用`--output`命令行选项创建。
- en: 'The runtime image created under the directory image contains the `bin` directory,
    among other directories. This `bin` directory consists of a shell script named `calculator`.
    This can be used to launch our application:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在image目录下创建的运行时镜像包含`bin`目录等其他目录。这个`bin`目录包含一个名为`calculator`的shell脚本。这可以用来启动我们的应用程序。
- en: '[PRE93]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We cannot create a runtime image of modules that contain automatic modules.
    Jlink gives an error if the JAR files are not modular or if there is no `module-info.class`.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法创建包含自动模块的模块的运行时镜像。如果JAR文件不是模块化的，或者没有`module-info.class`，`jlink`会报错。
- en: Compiling for older platform versions
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为旧平台版本编译
- en: We have, at some point, used the `-source` and `-target` options to create a
    java build. The `-source` option is used to indicate the version of Java language accepted
    by the compiler, and the `-target` option is used to indicate the version supported
    by the class files. Often, we forget to use the `-source` option and by default,
    `javac` compiles against the latest available Java version. Due to this, there
    are chances of newer APIs being used and as a result, the build doesn't run as
    expected on the target version.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，我们使用`-source`和`-target`选项来创建Java构建。`-source`选项用于指示编译器接受的Java语言版本，`-target`选项用于指示类文件支持的版本。通常，我们忘记使用`-source`选项，默认情况下，`javac`会针对最新可用的Java版本进行编译。由于这个原因，有可能使用了新的API，结果在目标版本上构建不会按预期运行。
- en: To overcome the confusion of providing two different command-line options, a
    new command-line option, `--release`, was introduced in Java 9\. This acts as
    a substitute to the `-source`, `-target` and `-bootclasspath` options. `-bootclasspath`
    is used to provide the location of the bootstrap class files for a given version, *N*.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服提供两个不同命令行选项的混淆，Java 9引入了一个新的命令行选项`--release`。这充当了`-source`，`-target`和`-bootclasspath`选项的替代。`-bootclasspath`用于提供给定版本的引导类文件的位置*N*。
- en: Getting ready
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We have created a simple module, called demo, that contains a very simple class
    called `CollectionsDemo` that just puts a few values in the map and iterates over
    them as follows:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的模块，名为demo，其中包含一个非常简单的名为`CollectionsDemo`的类，该类只是将一些值放入地图并对其进行迭代，如下所示：
- en: '[PRE94]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Let''s compile and run it to see its output:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行它以查看其输出：
- en: '[PRE95]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output we get is as follow:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出如下：
- en: '[PRE96]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Now let's compile this to run on Java 8 and then run it on Java 8.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编译它以在Java 8上运行，然后在Java 8上运行它。
- en: How to do it...
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As the older versions of Java, Java 8 and before, don''t support modules, so
    we would have to get rid of  `module-info.java` if we were compiling on an older
    version. That is why we did not include `module-info.java` during our compilation.
    We compiled using the following code:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于较旧版本的Java，即Java 8及之前，不支持模块，因此如果我们在较旧版本上进行编译，就必须摆脱`module-info.java`。这就是为什么我们在编译过程中没有包括`module-info.java`。我们使用以下代码进行编译：
- en: '[PRE97]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: You can see that we are using the `--release` option, targeting Java 8 and not
    compiling `module-info.java`.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们使用了`--release`选项，针对Java 8，而不是编译`module-info.java`。
- en: 'Let''s create a JAR file because it becomes easier to transport the java build
    instead of copying all the class files:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个JAR文件，因为这样可以更容易地传输Java构建，而不是复制所有类文件：
- en: '[PRE98]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Let''s run the preceding JAR in Java 9:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在Java 9上运行上述JAR：
- en: '[PRE99]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Let''s run the JAR in Java 8:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在Java 8上运行这个JAR：
- en: '[PRE100]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'What if we did not use the `-release` option while building on Java 9? Let''s
    try that as well:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在构建Java 9时没有使用`-release`选项会怎样？我们也试试这个：
- en: 'Compile without using the `--release` option and create a JAR out of the resulting
    class files:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译时不使用`--release`选项，并将生成的类文件创建为JAR：
- en: '[PRE101]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Let''s run the JAR on Java 9:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在Java 9上运行这个JAR：
- en: '[PRE102]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: It works as expected.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 它按预期工作。
- en: 'Let''s run the JAR on Java 8:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在Java 8上运行这个JAR：
- en: '[PRE103]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The output is as follow:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE104]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: It is clearly stating that there is a mismatch in the version of the class file.
    As it was compiled for Java 9 (version 53.0), it doesn't run on Java 8 (version
    52.0).
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 它清楚地说明了类文件版本不匹配。因为它是为Java 9（版本53.0）编译的，所以在Java 8（版本52.0）上无法运行。
- en: How it works...
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: The data required for compiling to a target older version is stored in the `$JDK_ROOT/lib/ct.sym`
    file. This information is used by the `--release` option to locate `bootclasspath`. The
    `ct.sym` file is a ZIP file containing stripped-down class files corresponding
    to class files from the target platform versions (taken verbatim from [http://openjdk.java.net/jeps/247](http://openjdk.java.net/jeps/247)).
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 编译到较旧版本所需的数据存储在`$JDK_ROOT/lib/ct.sym`文件中。此信息被`--release`选项用于定位`bootclasspath`。`ct.sym`文件是一个ZIP文件，其中包含与目标平台版本的类文件对应的剥离类文件（直接从[http://openjdk.java.net/jeps/247](http://openjdk.java.net/jeps/247)复制）。
- en: Creating multi-release JARs
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多版本JAR
- en: Prior to Java 9, it was hard for the developers of a library to adopt the new
    features introduced in the language without releasing a new library version. But
    in Java 9, multi-release JARs provide such a functionality where you can bundle
    certain class files to run when a higher version of Java is being used.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，对于库的开发人员来说，要采用语言中引入的新功能而不发布新的库版本是很困难的。但是在Java 9中，多版本JAR提供了这样一个功能，可以在使用更高版本的Java时捆绑某些类文件以运行。
- en: In this recipe, we will show you how to create such a multi-release JAR.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将向您展示如何创建这样一个多版本JAR。
- en: How to do it...
  id: totrans-541
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create the required Java code for the Java 8 platform. We will add two classes, `CollectionUtil.java`
    and `FactoryDemo.java`, in the `src8compackt` directory:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Java 8平台创建所需的Java代码。我们将在`src8compackt`目录中添加两个类，`CollectionUtil.java`和`FactoryDemo.java`：
- en: '[PRE105]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We wish to make use of the `Collection` factory methods that were introduced
    in Java 9\. So, we will create another subdirectory under `src` to place our Java-9-related
    code: `src9compackt`. This is where we will add another `CollectionUtil` class:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望使用在Java 9中引入的`Collection`工厂方法。因此，我们将在`src`下创建另一个子目录，将我们的与Java 9相关的代码放在其中：`src9compackt`。在这里，我们将添加另一个`CollectionUtil`类：
- en: '[PRE106]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The preceding code uses the Java 9 collection factory methods. Compile the
    source code using the following commands:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码使用了Java 9集合工厂方法。使用以下命令编译源代码：
- en: '[PRE107]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Make a note of the `--release` option that's used to compile the code for different
    java versions.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`--release`选项为不同的Java版本编译代码。
- en: 'Now let''s create the multi-release JAR:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建多版本JAR：
- en: '[PRE108]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: While creating the JAR, we have also mentioned that, when running on Java 9,
    we make use of the Java-9-specific code.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建JAR时，我们还提到，当在Java 9上运行时，我们使用了Java 9特定的代码。
- en: 'We will run `mr.jar` on Java 9:'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在Java 9上运行`mr.jar`：
- en: '[PRE109]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We will run `mr.jar` on Java 8:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在Java 8上运行`mr.jar`：
- en: '[PRE110]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: How it works...
  id: totrans-556
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: 'Let''s look at the layout of the content in `mr.jar`:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`mr.jar`中内容的布局：
- en: '[PRE111]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The contents of the JAR is as follows:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: JAR的内容如下：
- en: '![](img/ea10f27a-5853-477a-a589-4beba6202ae3.png)'
  id: totrans-560
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea10f27a-5853-477a-a589-4beba6202ae3.png)'
- en: 'In the preceding layout, we have `META-INF/versions/9`, which contains the
    Java 9-specific code. Another important thing to note is the contents of the `META-INF/MANIFEST.MF`
    file. Let''s extract the JAR and view its contents:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述布局中，我们有`META-INF/versions/9`，其中包含Java 9特定的代码。另一个重要的事情是注意`META-INF/MANIFEST.MF`文件的内容。让我们提取JAR并查看其内容：
- en: '[PRE112]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The new `Multi-Release` manifest attribute is used to indicate whether the JAR
    is a multi-release JAR.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`Multi-Release`清单属性用于指示JAR是否是多版本JAR。
- en: Using Maven to develop a modular application
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven开发模块化应用程序
- en: In this recipe, we will look at using Maven, the most popular build tool in
    the Java ecosystem, to develop a simple modular application. We will reuse the
    idea we introduced in the *Services* recipe in this chapter.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Maven，Java生态系统中最流行的构建工具，开发一个简单的模块化应用程序。我们将在本章的*服务*示例中介绍的想法。
- en: Getting ready
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We have the following modules in our example:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例中有以下模块：
- en: '`book.manage`: This is the main module that interacts with the data source'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`book.manage`：这是与数据源交互的主模块'
- en: '`book.service`: This is the module that contains the service-provider interface'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`book.service`：这是包含服务提供者接口的模块'
- en: '`mongodb.book.service`: This is the module that provides an implementation
    to the service-provider interface'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongodb.book.service`：这是为服务提供者接口提供实现的模块'
- en: '`sqldb.book.service`: This is the module that provides another implementation
    to the service-provider interface'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqldb.book.service`：这是为服务提供者接口提供另一个实现的模块'
- en: In the course of this recipe, we will create a maven project and include the
    preceding JDK modules as maven modules. So let's get started.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将创建一个maven项目，并将之前的JDK模块作为maven模块包含进来。让我们开始吧。
- en: How to do it...
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a folder to contain all the modules. We have called it `12_services_using_maven`
    with the following folder structure:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含所有模块的文件夹。我们称之为`12_services_using_maven`，具有以下文件夹结构：
- en: '[PRE113]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The `pom.xml` for the parent is as follows:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父级的`pom.xml`如下：
- en: '[PRE114]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Let''s create the structure for the `book-service` Maven module as follows:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们按照以下方式创建`book-service` Maven模块的结构：
- en: '[PRE115]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The content of `pom.xml` for the `book-service` Maven module is:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`book-service` Maven模块的`pom.xml`内容如下：'
- en: '[PRE116]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Here is `module-info.java`:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`module-info.java`：
- en: '[PRE117]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Here is `Book.java`:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`Book.java`：
- en: '[PRE118]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Here is `BookService.java`:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`BookService.java`：
- en: '[PRE119]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Here is `BookServiceProvider.java`:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`BookServiceProvider.java`：
- en: '[PRE120]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: On similar lines, we define the other three Maven modules, `mongodb-book-service`,
    `sqldb-book-service`, and `book-manager`. The code for this can be found at `Chapter03/12_services_using_maven`.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们定义了另外三个Maven模块，`mongodb-book-service`，`sqldb-book-service`和`book-manager`。此代码可以在`Chapter03/12_services_using_maven`找到。
- en: 'We can compile the classes and build the required JAR files using the following
    command:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令编译类并构建所需的JAR文件：
- en: '[PRE121]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: We have provided `run-with-mongo.*` to use `mongodb-book-service` as the service-provider
    implementation and `run-with-sqldb.*` to use `sqldb-book-service` as the service-provider
    implementation.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了`run-with-mongo.*`来使用`mongodb-book-service`作为服务提供者实现，以及`run-with-sqldb.*`来使用`sqldb-book-service`作为服务提供者实现。
- en: The complete code for this recipe can be found at `Chapter03/12_services_using_maven`.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的完整代码可以在`Chapter03/12_services_using_maven`找到。
- en: Making your library module-path-friendly
  id: totrans-595
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使您的库模块路径友好
- en: For an application to be fully modular, it should have itself modularized as
    well as its dependents. Now, making a third party modular is not in the hands
    of the application developer. One approach is to include the third-party `jar`
    in the module path and use the name of the `jar` as the name of the module to
    declare the dependency. In such cases, the `jar` becomes an automatic module.
    This is OK, but often the name of the `jar` is not module-name-friendly or doesn't
    conform to the syntax of a valid module name. In such cases, we make use of another
    support added in JDK 9 wherein one can define the name of the `jar` in the `MANIFEST.mf`
    file of the `jar`, and the library consumer can then declare a dependency on the
    defined name. This way, in the future, the library developer can modularize their
    library while still using the same module name.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 要使应用程序完全模块化，它应该自身模块化以及其依赖项。现在，使第三方模块化不在应用程序开发人员的手中。一种方法是将第三方`jar`包含在模块路径中，并使用`jar`的名称作为模块的名称来声明依赖关系。在这种情况下，`jar`将成为自动模块。这是可以的，但通常`jar`的名称不符合模块名称的规范。在这种情况下，我们可以利用JDK
    9中添加的另一种支持，其中可以在`jar`的`MANIFEST.mf`文件中定义`jar`的名称，库使用者可以声明对定义名称的依赖关系。这样，将来，库开发人员可以将他们的库模块化，同时仍然使用相同的模块名称。
- en: In this recipe, we will show you how to provide a  name for the automatic module
    created from the non-modular `jar`. First, we will show you how to achieve this
    using maven and then in the *There's more...* section, we will see how to create
    a JAR without using any build tools.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将向您展示如何为从非模块化`jar`创建的自动模块提供名称。首先，我们将向您展示如何使用maven实现这一点，然后在*更多内容*部分中，我们将看到如何在不使用任何构建工具的情况下创建一个JAR。
- en: Getting ready
  id: totrans-598
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You would need at least JDK 9 to run this recipe, but we will be using JDK 11
    in the Maven build plugin. You will also need to install Maven to be able to use
    it. You can search on the internet to find the installation procedure for Maven.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 您至少需要JDK 9来运行这个示例，但我们将在Maven构建插件中使用JDK 11。您还需要安装Maven才能使用它。您可以在互联网上搜索Maven的安装过程。
- en: How to do it...
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Generate an empty project using Maven:'
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Maven生成一个空项目：
- en: '[PRE122]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Update the dependencies in the `pom.xml` file located in the `13_automatic_module` directory
    by copying the following dependencies:'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制以下依赖项，更新位于`13_automatic_module`目录中的`pom.xml`文件中的依赖项：
- en: '[PRE123]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We need to configure `maven-compiler-plugin` to be able to compile for JDK
    11\. So, we will add the following plugin configuration right after `<dependencies></dependencies>`:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要配置`maven-compiler-plugin`以便能够编译JDK 11。因此，我们将在`<dependencies></dependencies>`之后添加以下插件配置：
- en: '[PRE124]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Configure `maven-jar-plugin` to provide the automatic module name by providing
    the name in the  new `<Automatic-Module-Name>` tag, as shown here:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`maven-jar-plugin`，通过在新的`<Automatic-Module-Name>`标签中提供名称来提供自动模块名称，如下所示：
- en: '[PRE125]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'We will add an API to calculate simple interest in the `com.packt.banking.Banking`
    class, which is shown as follows:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`com.packt.banking.Banking`类中添加一个用于计算简单利息的API，如下所示：
- en: '[PRE126]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We also added a test, which you can find at `Chapter03\13_automatic_module\src\test\java\com\packt\banking`
    in the code downloaded for this chapter. Let''s run the `mvn package` command
    to build a JAR. If everything goes fine, you will see the following:'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了一个测试，您可以在本章下载的代码中的`Chapter03\13_automatic_module\src\test\java\com\packt\banking`找到。让我们运行`mvn
    package`命令来构建一个JAR。如果一切顺利，您将看到以下内容：
- en: '![](img/20cf9b91-b447-44bd-be79-2ae8dc64ce9c.png)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20cf9b91-b447-44bd-be79-2ae8dc64ce9c.png)'
- en: 'You can use any compression utility, such as 7z, to view the contents of the
    JAR, especially the `Manifest.MF` file, whose contents are as follows:'
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用任何压缩实用程序，例如7z，来查看JAR的内容，特别是`Manifest.MF`文件，其内容如下：
- en: '[PRE127]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The code for these steps can be found at `Chapter03\13_automatic_module`.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤的代码可以在`Chapter03\13_automatic_module`找到。
- en: How it works...
  id: totrans-616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: So far, we have created a Java library JAR with an automatic module name. Now,
    let's see how to use this non-modular JAR as an automatic module in a modular
    application. The complete code for this can be found at `Chapter03\13_using_automatic_module`.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个具有自动模块名称的Java库JAR。现在，让我们看看如何在模块化应用程序中将这个非模块化JAR用作自动模块。这个示例的完整代码可以在`Chapter03\13_using_automatic_module`找到。
- en: Let's copy the `jar` file created in the How to do it... section, which you
    can find in `13_automatic_module\target\13_automatic_module-1.0.jar`, into the `13_using_automatic_module\mods` folder.
    This enables our upcoming modular application to make use of the `com.packt.banking`
    module that was shipped with the `jar`.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将在`How to do it...`部分创建的`jar`文件复制到`13_automatic_module\target\13_automatic_module-1.0.jar`中，然后放入`13_using_automatic_module\mods`文件夹中。这样我们即可让即将创建的模块化应用程序使用随`jar`一起提供的`com.packt.banking`模块。
- en: 'After copying the jar, we need to create a module definition for our module
    and declare its dependencies in `module-info.java`, placed in `13_using_automatic_module\src\banking.demo`:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 复制jar文件后，我们需要为我们的模块创建模块定义，并在`module-info.java`中声明其依赖项，放置在`13_using_automatic_module\src\banking.demo`中：
- en: '[PRE128]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Next is to create the main `com.packt.demo.BankingDemo` class, which will make
    use of the banking utilities. This will be created in the `13_using_automatic_module\src\banking.demo\com\packt\demo` path,
    as follows:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是创建`main` `com.packt.demo.BankingDemo`类，它将使用银行工具。创建路径为`13_using_automatic_module\src\banking.demo\com\packt\demo`，如下所示：
- en: '[PRE129]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'We can compile the preceding code using the following command, executed from `13_using_automatic_module`:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用从`13_using_automatic_module`执行的以下命令来编译前面的代码：
- en: '[PRE130]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'And then run the preceding code using the following command, executed from
    the same location:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过使用从相同位置执行的以下命令来运行前面的代码：
- en: '[PRE131]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'You will see the following output:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE132]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Note: You can make use of the `run.bat` or `run.sh` scripts to compile and
    run the code.'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以使用`run.bat`或`run.sh`脚本来编译和运行代码。
- en: 'So, with this, we have:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过这样做，我们有：
- en: Created a non-modular JAR with an automatic module name.
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个非模块化的JAR，并自动命名模块。
- en: Used the non-modular JAR as an automatic module by declaring a dependency on
    it by using its automatic module name.
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用其自动模块名称声明对其的依赖，将非模块化的JAR用作自动模块。
- en: You will also see that we have totally removed the use of classpath, instead
    of using only the module path; this is our first step toward a completely modular
    application.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将看到，我们已完全删除了对类路径的使用，而仅使用模块路径；这是我们迈向完全模块化应用程序的第一步。
- en: There's more...
  id: totrans-634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We will show you how to create a JAR of your banking utility, along with the
    automatic module name if you don't use Maven. The code for this can be found at `Chapter03\13_automatic_module_no_maven`.
    We will still have the same `Banking .java` copied into the `13_automatic_module_no_maven\src\com\packt\banking` directory.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您展示如何创建您的银行实用程序的JAR，以及自动模块名称（如果您不使用Maven）。此代码可以在`Chapter03\13_automatic_module_no_maven`中找到。我们仍将把`Banking
    .java`复制到`13_automatic_module_no_maven\src\com\packt\banking`目录中。
- en: 'Next, we need to define a `manifest.mf` manifest file that will contain the
    following automatic module name:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个包含以下自动模块名称的`manifest.mf`清单文件：
- en: '[PRE133]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'We can compile the preceding class by issuing the following command from `Chapter03\13_automatic_module_no_maven`:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从`Chapter03\13_automatic_module_no_maven`发出以下命令来编译前面的类：
- en: '[PRE134]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'And then build a `jar` by issuing the following command from the same location:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过从相同位置发出以下命令来构建一个`jar`：
- en: '[PRE135]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: We have also provided scripts for creating your `jar`. You can use `build-jar.bat`
    or `build-jar.sh` to compile and create a `jar`. Now, you can copy `banking-1.0.jar`
    to `Chapter03\13_using_automatic_module\mods` and replace `13_automati_module-1.0.jar`.
    Then, run the code in `Chapter03\13_using_automatic_module` using the `run.bat`
    or `run.sh` scripts, depending on your platform. You will still see the same output
    as in the previous section.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了用于创建您的`jar`的脚本。您可以使用`build-jar.bat`或`build-jar.sh`来编译和创建`jar`。现在，您可以将`banking-1.0.jar`复制到`Chapter03\13_using_automatic_module\mods`并替换`13_automati_module-1.0.jar`。然后，使用`run.bat`或`run.sh`脚本在`Chapter03\13_using_automatic_module`中运行代码，具体取决于您的平台。您仍将看到与上一节相同的输出。
- en: How to open a module for reflection
  id: totrans-643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何为反射打开模块
- en: The module system introduces strict encapsulation of classes within its module
    and a strictness level that, if the class isn't explicitly allowed for reflection,
    then its private members cannot be accessed via reflection. Most of the libraries,
    such as hibernate and Jackson, rely on reflection to achieve their purpose. A
    strict encapsulation offered by the module system would break these libraries
    on the new JDK 9 and later right away.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统引入了严格的封装，如果类没有明确允许反射，则其私有成员不能通过反射访问。大多数库，如hibernate和Jackson，依赖于反射来实现其目的。模块系统提供的严格封装将立即破坏这些库在新的JDK
    9及更高版本上的运行。
- en: In order to support such important libraries, the Java team decided to introduce
    features wherein the module developer can declare a few packages or complete packages
    that are open for inspection by reflection. In this recipe, we will look at how
    exactly to achieve that.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这样重要的库，Java团队决定引入功能，模块开发人员可以声明一些包或完整包，以便通过反射进行检查。在本教程中，我们将看看如何确切地实现这一点。
- en: Getting ready
  id: totrans-646
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need JDK 9 or later installed. We will be using the Jackson API in this
    recipe, and its `jar` files can be found at `Chapter03/14_open_module_for_rflxn/mods`
    of the code download for this book. These `jar` files are important as we will
    create a JSON string from a Java object using the Jackson API. These Jackson APIs
    will be used as automatic modules.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装JDK 9或更高版本。在本教程中，我们将使用Jackson API，其`jar`文件可以在本书的代码下载的`Chapter03/14_open_module_for_rflxn/mods`中找到。这些`jar`文件很重要，因为我们将使用Jackson
    API从Java对象创建JSON字符串。这些Jackson API将被用作自动模块。
- en: How to do it...
  id: totrans-648
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a `Person` class in `14_open_module_for_rflxn/src/demo/com/packt/demo`
    with the following definition:'
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`14_open_module_for_rflxn/src/demo/com/packt/demo`中创建一个`Person`类，定义如下：
- en: '[PRE136]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Create a `OpenModuleDemo` class that creates an instance of the `Person` class
    and uses `com.fasterxml.jackson.databind.ObjectMapper` to serialize it into JSON.
    The serialization of the new date-time APIs requires some configuration changes
    to the `ObjectMapper` instance, which has also been done in the static initialization
    block, as follows:'
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`OpenModuleDemo`类，该类创建一个`Person`类的实例，并使用`com.fasterxml.jackson.databind.ObjectMapper`将其序列化为JSON。新日期时间API的序列化需要对`ObjectMapper`实例进行一些配置更改，这也在静态初始化块中完成，如下所示：
- en: '[PRE137]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Create `module-info.java` in `14_open_module_for_rflxn/src/demo`, which declares
    the name of the module, its dependencies, and another interesting thing called
    `opens`. `opens` is the solution to allow reflection from external libraries,
    as shown here:'
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`14_open_module_for_rflxn/src/demo`中创建`module-info.java`，它声明了模块的名称、其依赖关系，以及另一个有趣的东西叫做`opens`。`opens`是允许外部库进行反射的解决方案，如下所示：
- en: '[PRE138]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: How it works...
  id: totrans-655
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There are two ways of opening up a module for inspection by reflection:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以打开模块以供反射检查：
- en: 'Declaring open on the module level:'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块级别上声明开放：
- en: '[PRE139]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Declaring opens on the individual package level:'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单个包级别上声明开放：
- en: '[PRE140]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The latter is more restrictive (that is, making only a package available for
    reflection) than the former. There is another way to achieve this, and that is
    by exporting the specific package to the right Jackson package, as follows:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 后者比前者更加严格（即只能使一个包对反射可用）。还有另一种方法可以实现这一点，那就是将特定包导出到正确的Jackson包，如下所示：
- en: '[PRE141]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
