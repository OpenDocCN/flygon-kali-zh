- en: Chapter 2. Visual Scripting with Flowgraph
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。使用Flowgraph进行可视脚本编写
- en: The CryENGINE flowgraph is a powerful node-based visual scripting system, aiding
    developers in rapidly prototyping features and creating level specific logic without
    having to work with complicated codebases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: CryENGINE flowgraph是一个强大的基于节点的可视脚本系统，帮助开发人员快速原型化功能，并创建特定于关卡的逻辑，而无需处理复杂的代码库。
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Discuss the concept of flowgraphs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论flowgraph的概念
- en: Create new flowgraphs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的flowgraph
- en: Debug our flowgraph
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试我们的flowgraph
- en: Create a custom flowgraph node (flownode) in Lua, C#, and C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Lua、C#和C++中创建自定义flowgraph节点（flownode）
- en: Concept of flowgraphs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: flowgraph的概念
- en: For years, writing code has been the primary, if not the exclusive method of
    creating behaviors and logic for games. Let's take the example of a level designer,
    building a combat section for the latest title.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，编写代码一直是创建游戏行为和逻辑的主要方法，如果不是唯一的方法。让我们以一个关卡设计师为例，为最新的游戏创建一个战斗部分。
- en: 'Traditionally, the said designer would have to ask a programmer to create the
    logic for this scenario. This has several problems:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，设计师必须要求程序员为这种情况创建逻辑。这有几个问题：
- en: It creates a disconnect between the design and the implementation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这会导致设计和实现之间的脱节
- en: Programmers are forced into spending time which is really a designer's job
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员被迫花费时间，这实际上是设计师的工作
- en: The designer has no immediate feedback on how his/her section plays out
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计师无法立即了解他/她的部分如何进行
- en: This is the problem that CryENGINE's **flowgraph**, often referred to as **FG**,
    solves. It provides a set of flownodes, best thought of as convenient Lego blocks
    of logic, which the designer can utilize to piece together entire scenarios. No
    more requests to the game code team; designers can go ahead and realize their
    ideas instantly! We'll discuss creating the nodes themselves in more detail later,
    but for now, let's take a look at some simple flowgraphs, so you can take your
    first steps into CryENGINE game logic!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是CryENGINE的**flowgraph**，通常称为**FG**，解决的问题。它提供了一组flownode，最好将其视为方便的逻辑乐高积木，设计师可以利用它们来拼凑整个场景。不再需要向游戏代码团队发送请求；设计师可以立即实现他们的想法！我们将稍后更详细地讨论创建节点本身，但现在让我们看一些简单的flowgraph，这样您就可以迈出CryENGINE游戏逻辑的第一步！
- en: Opening the Flowgraph Editor
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开Flowgraph编辑器
- en: To get started, we need to open up Sandbox. Sandbox contains the Flowgraph Editor
    as one of its many useful tools, and it can be opened via **View** | **Open View
    Pane**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要打开Sandbox。Sandbox包含Flowgraph编辑器作为其众多有用工具之一，可以通过**视图**|**打开视图窗格**来打开它。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should always have a level loaded when opening the Flowgraph Editor, as
    flowgraphs are unique to levels. Flick back to [Chapter 1](ch01.html "Chapter 1. Introduction
    and Setup"), *Introduction and Setup*, if you've forgotten how to create a new
    level!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开Flowgraph编辑器时，您应该始终加载一个关卡，因为flowgraph是与关卡相关的。如果您忘记了如何创建新关卡，请返回到[第1章](ch01.html
    "第1章。介绍和设置")*介绍和设置*！
- en: '![Opening the Flowgraph Editor](img/5909_02_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![打开Flowgraph编辑器](img/5909_02_01.jpg)'
- en: You've just accessed your first Sandbox tool! You should be presented with a
    new window with lots of subsections and features, but don't fret, let's tackle
    them one by one.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚访问了您的第一个Sandbox工具！您应该会看到一个新窗口，其中有许多子部分和功能，但不要担心，让我们逐个解决它们。
- en: A tour of the Flowgraph Editor
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flowgraph编辑器之旅
- en: Flowgraphs are saved on the disk as XML files, but can be parsed and edited
    by the Flowgraph Editor in order to provide a visual interface to the process
    of creating game logic.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: flowgraph被保存在磁盘上作为XML文件，但可以被Flowgraph编辑器解析和编辑，以提供创建游戏逻辑过程的可视界面。
- en: '![A tour of the Flowgraph Editor](img/5909_02_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Flowgraph编辑器之旅](img/5909_02_02.jpg)'
- en: Components
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: 'This section of the Editor contains all the flownodes in your project, organized
    into neat categories. Let''s take a quick look inside this, open up the **Misc**
    folder. You should be presented with a set of nodes, assigned to categories:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器的这一部分包含项目中的所有flownode，组织成整洁的类别。让我们快速查看一下这个，打开**Misc**文件夹。您应该会看到一组节点，分配到不同的类别：
- en: '![Components](img/5909_02_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![组件](img/5909_02_03.jpg)'
- en: Terminology
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 术语
- en: '**Graph**: This refers to a context containing a set of nodes linked to each
    other.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图**：这指的是包含一组相互链接的节点的上下文。'
- en: '**Node**: This is a visual representation of a class that can receive data
    and events from its input ports, as well as send data via its output ports. It
    is connected to other nodes in graphs to create logic.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：这是一个类的可视表示，它可以从其输入端口接收数据和事件，也可以通过其输出端口发送数据。它连接到图中的其他节点以创建逻辑。'
- en: '**Port**: This is a visual representation of a function. Nodes can specify
    multiple input and output ports, and can then send or receive events from them.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**：这是一个函数的可视表示。节点可以指定多个输入和输出端口，然后可以从中发送或接收事件。'
- en: Component categories
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件类别
- en: You may be missing the node marked as **Debug** here; CryENGINE assigns categories
    to nodes as a way of indicating where it's appropriate for them to be used.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会错过这里标记为**调试**的节点；CryENGINE为节点分配类别，以指示它们适合在哪里使用。
- en: '**Release**: This node is suitable for use in production'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**：此节点适用于生产'
- en: '**Advanced**: While this node is suitable for use in production, it may have
    complex behavior in certain situations'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级**：虽然此节点适用于生产，但在某些情况下可能具有复杂的行为'
- en: '**Debug**: This node should only be used for internal tests'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**：此节点只应用于内部测试'
- en: '**Obsolete**: This node should not be used, and this node will not be visible
    in the components list'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过时**：不应使用此节点，此节点将不会在组件列表中可见'
- en: 'For example, while working on a level that''s intended to be shipped to the
    public, you might not want to accidentally include any Debug nodes! We can enable
    or disable the viewing of the first three categories inside the Flowgraph Editor
    via **View** | **Components**:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在制作一个打算发布给公众的关卡时，您可能不希望意外包含任何调试节点！我们可以通过**视图**|**组件**来启用或禁用Flowgraph编辑器中的前三个类别的查看：
- en: '![Component categories](img/5909_02_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![组件类别](img/5909_02_04.jpg)'
- en: Flowgraph types
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流程图类型
- en: Before creating a new flowgraph, we'll want to know of what type our purpose
    is most relevant to. Different flowgraph types allow for specialization, for example,
    to create **UI graphs** that handle the layout and drawing of the player's user
    interface.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的流程图之前，我们需要知道我们的目的最相关的类型是什么。不同的流程图类型允许专门化，例如，创建处理玩家用户界面的**UI图形**。
- en: '![Flowgraph types](img/5909_02_05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![流程图类型](img/5909_02_05.jpg)'
- en: AI Actions
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AI操作
- en: These are flowgraphs you can create to wrap up AI behaviors into convenient
    nodes that can be reused elsewhere. We'll address these later when you learn about
    **Artificial Intelligence** (**AI**).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是您可以创建的流程图，将AI行为封装成方便的节点，可以在其他地方重复使用。当您学习**人工智能**（**AI**）时，我们稍后会讨论这些。
- en: UI Actions
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI操作
- en: CryENGINE allows you to script your user interfaces and in-game heads-up-displays
    using flowgraphs, via a system of UI events. We'll discuss these in [Chapter 7](ch07.html
    "Chapter 7. The User Interface"), *The User Interface*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: CryENGINE允许您使用流程图脚本化用户界面和游戏中的抬头显示，通过UI事件系统。我们将在[第7章](ch07.html "第7章。用户界面")中讨论这些，*用户界面*。
- en: Material FX
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 材质FX
- en: CryENGINE supports convenient designer-editable flowgraphs to control how material
    events are handled, for example, spawning a dirt particle and obscuring the player's
    screen with a layer of dust when the ground is shot nearby.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: CryENGINE支持方便的可设计的流程图，用于控制如何处理材质事件，例如，在附近射击地面时生成一个灰尘粒子并用一层灰尘遮挡玩家的屏幕。
- en: FG Modules
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FG模块
- en: You can package up flowgraphs into handy modules for reuse across different
    situations. We'll describe these in depth later.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将流程图打包成方便的模块，以便在不同情况下重复使用。我们稍后会详细描述这些。
- en: Entities
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实体
- en: This is where we'll spend most of our time in this chapter! 90 percent of the
    time,a flowgraph is assigned to an entity, otherwise known as the **graph entity**,
    and this logic takes place in the game world.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在本章中将花费大部分时间的地方！90%的时间，流程图都分配给一个实体，也就是**图实体**，这个逻辑发生在游戏世界中。
- en: Prefabs
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预制件
- en: CryENGINE supports prefabs, a collection of entities packaged into a single
    convenient file for reuse. Any entity flowgraphs inside a prefab will be displayed
    in this folder.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CryENGINE支持预制件，这是一组实体打包成一个方便的文件以供重复使用。预制件中的任何实体流程图都将显示在此文件夹中。
- en: Creating a flowgraph
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建流程图
- en: Now that we have a basic understanding of how the Flowgraph Editor works, let's
    dive right in and create our first flowgraph! You can close the Flowgraph Editor
    for the moment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对流程图编辑器的工作原理有了基本的了解，让我们立即开始创建我们的第一个流程图！您可以暂时关闭流程图编辑器。
- en: The flowgraph entity
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流程图实体
- en: The flowgraph entity is an extremely lightweight CryENGINE object, designed
    to be used when you need a flowgraph that isn't applied to any specific entity.
    Like all entities, it can be found in **RollupBar** inside Sandbox.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 流程图实体是一个极其轻量级的CryENGINE对象，设计用于在您需要一个不应用于任何特定实体的流程图时使用。与所有实体一样，它可以在Sandbox的**RollupBar**中找到。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're not sure what an entity is, skip this section until you have read
    [Chapter 3](ch03.html "Chapter 3. Creating and Utilizing Custom Entities"), *Creating
    and Utilizing Custom Entities*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定实体是什么，请跳过本节，直到您阅读完[第3章](ch03.html "第3章。创建和使用自定义实体")为止，*创建和使用自定义实体*。
- en: '![The flowgraph entity](img/5909_02_06.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![流程图实体](img/5909_02_06.jpg)'
- en: Spawning FlowgraphEntity
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成FlowgraphEntity
- en: Select **FlowgraphEntity** and then either double-click and click again on the
    viewport, or click and drag it into the level. You should now see a whole new
    set of options in **RollupBar**, including entity params, material layers, but
    mostly important for us, the **Entity:** **FlowgraphEntity** section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**流程图实体**，然后双击并再次单击视口，或单击并将其拖动到级别中。您现在应该在**RollupBar**中看到一整套新选项，包括实体参数、材质层，但对我们来说最重要的是**实体：流程图实体**部分。
- en: Attaching a new flowgraph
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加一个新的流程图
- en: 'Inside the **Entity: FlowgraphEntity** section, we need to find the **Flow
    Graph** subsection, and then click on the **Create** button:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在**实体：流程图实体**部分，我们需要找到**流程图**子部分，然后单击**创建**按钮：
- en: '![Attaching a new flowgraph](img/5909_02_07.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![附加新的流程图](img/5909_02_07.jpg)'
- en: From here, you'll be presented with the option to assign your flowgraph to a
    group. Whether you do or not isn't really important for now, but it's useful for
    grouping related graphs together, particularly when working on larger projects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，您将有选择将您的流程图分配给一个组。现在是否这样做并不重要，但在处理较大项目时，将相关图形分组在一起是很有用的。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Groups are used to create a structure for flowgraphs, allowing developers to
    sort different graphs into folders.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 组用于为流程图创建结构，允许开发人员将不同的图形分类到文件夹中。
- en: Once this is done, you should see the Flowgraph Editor appear with a faint grid
    overlaid on the background. We're now ready to start creating logic!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您应该看到流程图编辑器出现在背景上叠加了淡淡的网格。我们现在准备开始创建逻辑！
- en: Adding nodes into flowgraphs
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将节点添加到流程图中
- en: The simplest method of adding a node into a new graph is to browse through the
    **Components** list and drag new nodes in. However, this isn't very efficient
    if you know the name of the node you want to add. Therefore, you can also use
    the *Q* shortcut key inside the Flowgraph Editor to bring up the search function,
    and just type in the name of the node you'd like to add.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将节点添加到新图形的最简单方法是浏览**组件**列表并拖动新节点。但是，如果您知道要添加的节点的名称，这并不是很有效。因此，您还可以在流程图编辑器中使用*Q*快捷键来调出搜索功能，然后只需输入要添加的节点的名称。
- en: 'In our case, we''re going to begin with the **Misc:Start** node, which is a
    simple node used to set off other events when the level is loaded, or when an
    Editor test session is started:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将从**Misc:Start**节点开始，这是一个简单的节点，用于在加载级别时或编辑器测试会话启动时触发其他事件：
- en: '![Adding nodes into flowgraphs](img/5909_02_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![将节点添加到流程图中](img/5909_02_08.jpg)'
- en: Input and output ports
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入和输出端口
- en: 'Once the node is placed, you should see your first example of a node''s input
    and output ports. In this case, we have two input values, **InGame** and **InEditor**,
    as well as a single output port, conveniently named **output** in this case:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 放置节点后，您应该看到节点输入和输出端口的第一个示例。在这种情况下，我们有两个输入值**InGame**和**InEditor**，以及一个单一的输出端口，在这种情况下方便地命名为**output**：
- en: '![Input and output ports](img/5909_02_09.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![输入和输出端口](img/5909_02_09.jpg)'
- en: Input ports are used to feed data into the node, or trigger events, and output
    ports are used to relay data and events to other nodes in the graph. In this example,
    the **Misc:Start** node can be edited to define in which game contexts it will
    actually be executed. Perhaps you have some debugging logic you'd like to only
    run in the Editor, in which case we could set **InGame** to false, or zero.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输入端口用于向节点提供数据或触发事件，输出端口用于将数据和事件传递给图中的其他节点。在这个例子中，**Misc:Start**节点可以被编辑以定义它将在哪些游戏上下文中实际执行。也许您有一些调试逻辑只想在编辑器中运行，这种情况下我们可以将**InGame**设置为false或零。
- en: Port types
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端口类型
- en: In order to specify what type of data a port will handle, we need to know its
    port type. We can tell which type a port is in the Flowgraph Editor by looking
    at its color.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定端口将处理什么类型的数据，我们需要知道它的端口类型。我们可以通过查看端口的颜色在Flowgraph编辑器中确定端口的类型。
- en: 'Following is a list of the available port types:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可用端口类型的列表：
- en: '**Void**: This is used for ports that don''t pass a specific value, but are
    activated to signal an event'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Void**：用于不传递特定值的端口，但激活以发出事件信号'
- en: '**Int**: This is used when the port should only receive integer values'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Int**：当端口应该只接收整数值时使用'
- en: '**Float**: This is used to indicate that the port handles floating point values'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Float**：用于指示端口处理浮点值'
- en: '**EntityId**: This indicates that the port expects an entity identifier. (Refer
    to [Chapter 3](ch03.html "Chapter 3. Creating and Utilizing Custom Entities"),
    *Creating and Utilizing Custom Entities* for more information on entity IDs)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EntityId**：这表示端口期望一个实体标识符。（有关实体ID的更多信息，请参阅[第3章](ch03.html "第3章。创建和利用自定义实体")，“创建和利用自定义实体”）'
- en: '**Vec3**: This is used for ports that handle three-dimensional vectors'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vec3**：用于处理三维向量的端口'
- en: '**String**: In this, the port expects a string'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**String**：在这种情况下，端口期望一个字符串'
- en: '**Bool**: This is used when the port expects a Boolean value of true or false'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bool**：当端口期望真或假的布尔值时使用'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Linking ports with different types will result in the value being automatically
    converted.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 链接具有不同类型的端口将自动转换值。
- en: Target entities
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标实体
- en: Flownodes can feature a target entity, allowing the user to link an entity from
    the current level to the flownode. This is useful for nodes that are meant to
    impact entities in the game world, for example the **Entity:GetPos** node, as
    shown in the following screenshot, gets the world transformation of the specified
    entity.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 流节点可以具有目标实体，允许用户将当前级别中的实体链接到流节点。这对于旨在影响游戏世界中的实体的节点非常有用，例如**Entity:GetPos**节点，如下面的截图所示，获取指定实体的世界变换。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can also specify entities dynamically by linking an **EntityId** output port
    to the **Choose Entity** port.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过将**EntityId**输出端口链接到**Choose Entity**端口来动态指定实体。
- en: '![Target entities](img/5909_02_10.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![目标实体](img/5909_02_10.jpg)'
- en: 'There are two ways of assigning an entity to a node that supports it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种分配实体给支持它的节点的方法：
- en: By linking another flownodes' **EntityId** output to the **Choose Entity** input
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将另一个流节点的**EntityId**输出链接到**Choose Entity**输入
- en: 'By right-clicking on the **Choose Entity** input and selecting:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过右键单击**Choose Entity**输入并选择：
- en: '**Assign selected entity**: This links the node to the entity currently selected
    in the Editor viewport'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分配选定的实体**：这将链接节点到编辑器视口中当前选定的实体'
- en: '**Assign graph entity**: This links the node to the entity this graph is assigned
    to'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分配图形实体**：这将链接节点到分配给该图形的实体'
- en: Linking flownodes
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接流节点
- en: 'A single flownode isn''t capable of much; let''s connect two, and build a proper
    graph! For demonstration purposes, we''ll use the **Time:TimeOfDay** node:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 单个流节点并不能做太多事情；让我们连接两个，并构建一个适当的图！为了演示目的，我们将使用**Time:TimeOfDay**节点：
- en: '![Linking flownodes](img/5909_02_11.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![链接流节点](img/5909_02_11.jpg)'
- en: To create a link between ports as shown in the previous screenshot, simply click
    on an output port and drag your cursor to an input port with the mouse button
    held down. Release the mouse, and the connection should be created!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建端口之间的链接，只需单击输出端口，按住鼠标按钮拖动光标到输入端口，然后释放鼠标，连接就会创建！
- en: 'We''ve also edited the value of the **Time** input port; input ports can either
    be fed data via output ports, or have their values edited directly in the Editor.
    To do this, just click on the node and see the **Inputs** section of the Flowgraph
    Editor. From there, you can simply edit the values:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还编辑了**Time**输入端口的值；输入端口可以通过输出端口提供数据，也可以直接在编辑器中编辑它们的值。只需单击节点，查看Flowgraph编辑器的**Inputs**部分。从那里，您可以简单地编辑这些值：
- en: '![Linking flownodes](img/5909_02_12.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![链接流节点](img/5909_02_12.jpg)'
- en: 'You can also see valuable information about the node: for example, here we
    can see that this node is used to set the time of day, and the speed at which
    time passes in game.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以查看有关节点的有价值的信息：例如，在这里我们可以看到这个节点用于设置白天的时间，以及游戏中时间流逝的速度。
- en: With this done, you can close the Flowgraph Editor for now. Flowgraphs don't
    have to be saved manually; they're automatically saved with the level.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，您可以暂时关闭Flowgraph编辑器。Flowgraphs不需要手动保存；它们会自动保存在关卡中。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although flowgraphs save with the level, it is good practice to save manually
    often using **File** | **Save** to avoid losing your work.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管流图与关卡一起保存，但最好经常手动保存，以避免丢失工作。
- en: Testing our flowgraph
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的流图
- en: As we learned in the previous chapter, testing logic in the CryENGINE is incredibly
    simple using Sandbox. Simply press the *Ctrl* + *G* shortcut key combination,
    and watch as you enter game mode. Now, when you do this, you should see the lighting
    and general atmosphere of the level changing,as you've just changed the time of
    day!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中学到的，使用Sandbox在CryENGINE中测试逻辑非常简单。只需按下*Ctrl* + *G*快捷键组合，然后观察您进入游戏模式。现在，当您这样做时，您应该看到级别的照明和一般氛围发生变化，因为您刚刚改变了白天的时间！
- en: Congratulations, you've just taken your first step to creating games using CryENGINE!
    It doesn't seem like much right now, but let's make this graph do a bit more.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您刚刚迈出了使用CryENGINE创建游戏的第一步！现在看起来可能不是很多，但让我们让这个图表做更多事情。
- en: The stock flownode overview
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储的flownode概述
- en: To make something a little more complex, we're going to need an understanding
    of what nodes the CryENGINE provides for us by default.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做一些更复杂的事情，我们需要了解CryENGINE默认提供的节点。
- en: Building a clock
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建时钟
- en: One of the most useful nodes we have access to, at least for debugging purposes,
    is the **HUD:DisplayDebugMessage** node. It allows you to display information
    in the game window, optionally with a timeout. With that in mind, let's build
    a little debug clock based on the time information we learnt about earlier.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以访问的最有用的节点之一，至少用于调试目的，是**HUD:DisplayDebugMessage**节点。它允许您在游戏窗口中显示信息，可选地带有超时。考虑到这一点，让我们基于我们之前学到的时间信息构建一个小的调试时钟。
- en: The **Time:TimeOfDay** node outputs the current time in the CryENGINE time format,
    which is defined as hours plus minutes divided by 60\. For example, 1:30 p.m.
    would be expressed as 13.5 in CryENGINE time. We now know we're going to need
    some mathematical operations, so it's time to check the Math flownode category.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**Time:TimeOfDay**节点以CryENGINE时间格式输出当前时间，该格式定义为小时加上分钟除以60。例如，下午1:30会在CryENGINE时间中表示为13.5。我们现在知道我们将需要一些数学运算，所以是时候检查Math
    flownode类别了。'
- en: 'The first thing we''ll do is get the time in hours by rounding the current
    time down. To do this, place **Math:Floor**, then connect the **CurTime** output
    from our **Time:TimeOfDay** node to Floor''s **A** input port. Then, feed this
    into a Debug Message node:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是通过将当前时间向下取整来获取小时数。为此，将**Math:Floor**放置在**Time:TimeOfDay**节点的**CurTime**输出上，然后将其连接到Floor的**A**输入端口。然后，将其馈送到Debug
    Message节点：
- en: '![Building a clock](img/5909_02_13.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![构建时钟](img/5909_02_13.jpg)'
- en: Jump into game right now, and you should see the current time in hours displayed
    on your screen.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在立即进入游戏，您应该在屏幕上看到当前的小时数。
- en: 'We then need to subtract our new value from our original to get the minutes
    portion. To do this, we need **Math:Sub** to subtract the rounded hours from the
    original **CurTime** value. After that, a **Math:Mul** node will scale up the
    new time by 60, so your graph should look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要从原始值中减去我们的新值以获得分钟部分。为此，我们需要**Math:Sub**来从原始**CurTime**值中减去四舍五入的小时数。之后，**Math:Mul**节点将新时间放大60倍，因此您的图应该如下所示：
- en: '![Building a clock](img/5909_02_14.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![构建时钟](img/5909_02_14.jpg)'
- en: Remember to set **posY** of the second Debug node to move it down which will
    enable you to see both at the same time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将第二个Debug节点的**posY**设置为向下移动，这样您就可以同时看到两者。
- en: If you jump in game again, you should now see the current hours and minutes
    printed!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次进入游戏，现在应该看到当前的小时和分钟被打印出来！
- en: Listening for player input
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听玩家输入
- en: What if now, we wanted to allow the player to test moving through different
    times of the day? Generally speaking, it's the easiest way to set up a key listener,
    where we fire an event when a certain key is pressed. Fortunately CryENGINE encapsulates
    this functionality nicely into a single node, **Input:Key**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在我们想要允许玩家测试不同时间的移动怎么办？一般来说，设置一个按键监听器是最简单的方法，在这里我们在按下某个键时触发一个事件。幸运的是，CryENGINE将这个功能封装得很好，放入了一个单一的节点**Input:Key**。
- en: Let's now set it up so that pressing the *P* key will make time move extremely
    fast, and that pressing *O* will stop it again.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们设置按下*P*键会使时间快速移动，按下*O*键会再次停止时间。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **Input:Key** node is a Debug node. It is generally considered a bad practice
    to use Debug nodes in production, as unexpected results may occur, so please don't
    use this node for actual game logic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**Input:Key**节点是一个调试节点。通常认为在生产中使用调试节点是一个不好的做法，因为可能会出现意外的结果，所以请不要将此节点用于实际游戏逻辑。'
- en: 'We need to set the **Speed** value of our **Time:TimeOfDay** node, but in this
    case, we''ll also need to feed two values in! CryENGINE provides a node called
    **Logic:Any** that features multiple input ports and just passes on any data given
    to it, which we can use here to receive both input values. We use two key nodes
    which call **Math:SetNumber** nodes, and the **Logic:Any** node then relays this
    information to our **Time:TimeOfDay** node, as well as calling **SetSpeed**:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置**Time:TimeOfDay**节点的**Speed**值，但在这种情况下，我们还需要输入两个值！CryENGINE提供了一个名为**Logic:Any**的节点，它具有多个输入端口，并且只是传递给它的任何数据，我们可以在这里使用它来接收两个输入值。我们使用两个调用**Math:SetNumber**节点的关键节点，然后**Logic:Any**节点将这些信息传递给我们的**Time:TimeOfDay**节点，并调用**SetSpeed**：
- en: '![Listening for player input](img/5909_02_15.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![监听玩家输入](img/5909_02_15.jpg)'
- en: Jump in game now, and press *P* to start the day moving! Press *O* again, and
    the time of day should freeze.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入游戏，按*P*键开始一天的运行！再次按*O*键，白天的时间应该会停止。
- en: Executing on a loop
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在循环中执行
- en: 'You might have noticed that our clock isn''t updating correctly any more. This
    is because most nodes won''t output data unless triggered; in this case, we''ll
    get no output if we don''t trigger either **GetTime** or **SetTime**. We have
    two options for calling this: we can either use **Time:Time** to execute it every
    frame, or **Time:Timer**.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们的时钟不再正确更新。这是因为大多数节点不会输出数据，除非触发；在这种情况下，如果我们不触发**GetTime**或**SetTime**，我们将得不到任何输出。我们有两种调用的选择：我们可以使用**Time:Time**每帧执行它，或者**Time:Timer**。
- en: The latter can control the granularity of the tick, but in this case, we probably
    want it to be updated every frame while moving fast, so let's keep it simple.
    Connect the **tick** output to our **GetTime** input, and our clock should be
    updating correctly once again!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 后者可以控制tick的粒度，但在这种情况下，我们可能希望在快速移动时每帧更新，所以让我们保持简单。将**tick**输出连接到我们的**GetTime**输入，我们的时钟应该再次正确更新！
- en: '![Executing on a loop](img/5909_02_16.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![在循环中执行](img/5909_02_16.jpg)'
- en: Flowgraph modules
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程图模块
- en: The flowgraph module system allows flowgraphs to be exported as a module that
    can be triggered from another graph.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 流程图模块系统允许将流程图导出为可以从另一个图中触发的模块。
- en: By creating modules, we can reuse logic in multiple levels without having to
    maintain several versions of the same graph. It's also possible to send and receive
    unique data to and from the modules, allowing dynamic logic in a very modular
    manner.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建模块，我们可以在多个级别中重用逻辑，而无需维护相同图的多个版本。还可以以非常模块化的方式发送和接收模块的唯一数据，实现动态逻辑。
- en: Creating a module
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模块
- en: 'To start with creating your own module, open the Flowgraph Editor and select
    **File** | **New FG Module...** | **Global**:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建自己的模块，打开流程图编辑器，选择**文件** | **新建FG模块...** | **全局**：
- en: '![Creating a module](img/5909_02_17.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![创建模块](img/5909_02_17.jpg)'
- en: 'In the resulting **Save** dialog box, save the module with a name of your choice.
    You''ll then be shown the default view of a module:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果的**保存**对话框中，使用您选择的名称保存模块。然后，您将看到模块的默认视图：
- en: '![Creating a module](img/5909_02_18.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![创建模块](img/5909_02_18.jpg)'
- en: The module contains two nodes by default; **Module:Start_MyModule** and **Module:End_MyModule**.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块默认包含两个节点；**Module:Start_MyModule**和**Module:End_MyModule**。
- en: '**Module:Start_MyModule** contains three output ports:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Module:Start_MyModule**包含三个输出端口：'
- en: '**Start**: This is called when the module is loaded'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始**：当模块加载时调用'
- en: '**Update**: This is called when the module should be updated'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**：当模块应更新时调用'
- en: '**Cancel**: This is called when the module should cancel, and it is connected
    to the **Cancel** input of **Module:End_MyModule** by default'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消**：当模块应取消时调用，它默认连接到**Module:End_MyModule**的**取消**输入'
- en: '**Module:End_MyModule** contains two input ports:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Module:End_MyModule**包含两个输入端口：'
- en: '**Success**: This should be called when finalizing the module, and passes a
    "success" status to the caller'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功**：当完成模块时应调用此函数，并将“成功”状态传递给调用者'
- en: '**Cancel**: This is used to end the module prematurely, and passes a "cancelled"
    status to the caller'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消**：用于提前结束模块，并将“取消”状态传递给调用者'
- en: Finally, to fill your module with logic, simply connect the **Start** output
    port to your logic nodes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要填充您的模块逻辑，只需将**Start**输出端口连接到您的逻辑节点。
- en: Calling a module
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用模块
- en: 'To call an existing module, find the relevant node in the Module node category.
    The call nodes are named as `Module:Call_<ModuleName>`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用现有模块，请在模块节点类别中找到相关节点。调用节点的名称为`Module:Call_<ModuleName>`：
- en: '![Calling a module](img/5909_02_19.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![调用模块](img/5909_02_19.jpg)'
- en: Then simply trigger the **Call** port to activate your module, and **Cancel**
    to abort it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后简单地触发**Call**端口以激活您的模块，**Cancel**以中止它。
- en: Module parameters/ports
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块参数/端口
- en: From what we've learned previously, we're able to call modules with a void port.
    This is not optimal in all cases, as you might want to pass additional data to
    the module.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前学到的知识，我们能够使用void端口调用模块。这在所有情况下都不是最佳选择，因为您可能希望向模块传递附加数据。
- en: 'To allow this, the module system exposes module parameters. By selecting **Tools**
    | **Edit Module...** in the Flowgraph Editor, we can add a set of parameters to
    our module:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，模块系统公开了模块参数。通过在流程图编辑器中选择**工具** | **编辑模块...**，我们可以为我们的模块添加一组参数：
- en: '![Module parameters/ports](img/5909_02_20.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![模块参数/端口](img/5909_02_20.jpg)'
- en: 'This action opens the **Module Ports** window, which allows us to add and remove
    ports:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作将打开**模块端口**窗口，允许我们添加和删除端口：
- en: '![Module parameters/ports](img/5909_02_21.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![模块参数/端口](img/5909_02_21.jpg)'
- en: By selecting **New Input** or **New Output**, we'll be able to add new ports
    that can be used when activating the module.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择**新输入**或**新输出**，我们将能够添加新的端口，可以在激活模块时使用。
- en: '![Module parameters/ports](img/5909_02_22.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![模块参数/端口](img/5909_02_22.jpg)'
- en: 'Adding a new input or output will automatically output its **Module:Start_MyModule**
    or **Module:End_MyModule** node, allowing you to receive the data:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的输入或输出将自动输出其**Module:Start_MyModule**或**Module:End_MyModule**节点，允许您接收数据：
- en: '![Module parameters/ports](img/5909_02_23.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![模块参数/端口](img/5909_02_23.jpg)'
- en: 'All **Module:Call_MyModule** nodes are also updated automatically, giving you
    access to the new parameter right away:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有**Module:Call_MyModule**节点也会自动更新，让您立即访问新参数：
- en: '![Module parameters/ports](img/5909_02_24.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![模块参数/端口](img/5909_02_24.jpg)'
- en: Custom flownodes
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义流节点
- en: To summarize, CryENGINE provides many useful nodes by default, encompassing
    a whole range of functionality. However, as a programmer, you'll often find that
    designers will request access to some hidden functionality that the flowgraph
    isn't capable of providing by default.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，CryENGINE默认提供了许多有用的节点，涵盖了整个功能范围。然而，作为程序员，您经常会发现设计师会要求访问一些默认情况下流程图无法提供的隐藏功能。
- en: For example, let's say you're creating a role-playing game, and you have an
    experience system. There are plenty of ways to reward the player with experience
    in the code you've written, but a level designer also wants to be able to make
    use of this functionality at arbitrary points in a level.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您正在创建一个角色扮演游戏，并且有一个经验系统。在您编写的代码中，有很多方法可以奖励玩家的经验，但级别设计师还希望能够在关卡的任意点使用这个功能。
- en: In this situation, you're well-placed to create a custom flownode; you can create
    a simplified representation of the system that exists in code, perhaps allowing
    the designer to simply specify the number of experience points to award to the
    player when the node is triggered.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以很好地创建一个自定义流节点；你可以创建一个简化的代码中存在的系统的表示，也许允许设计师简单地指定在触发节点时奖励给玩家的经验点数。
- en: For now though, we're going to take a look at something a little simpler. Let's
    pretend we have no existing CryENGINE nodes to work with, and we'd like to implement
    the **Math:Mul** node we saw earlier. To recap, it's just a simple node that implements
    multiplication inside a flowgraph.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，现在我们要看一些更简单的东西。假设我们没有现有的CryENGINE节点可供使用，我们想要实现我们之前看到的**Math:Mul**节点。简而言之，它只是一个在流程图中实现乘法的简单节点。
- en: '![Custom flownodes](img/5909_02_25.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![自定义流节点](img/5909_02_25.jpg)'
- en: Creating a custom node in C++
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中创建自定义节点
- en: Back in [Chapter 1](ch01.html "Chapter 1. Introduction and Setup"), *Introduction
    and Setup*, we took a first look at compiling and running the GameDLL, packaged
    here as `MiniMonoGameSample.sln` for Visual Studio. Let's load that up again,
    making sure that any CryENGINE instances such as the Launcher or Sandbox are closed,
    as we're going to overwrite the `CryGame.dll` file that's used at runtime.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第1章](ch01.html "第1章。介绍和设置"), *介绍和设置*，我们首次编译和运行GameDLL，这里打包为Visual Studio的`MiniMonoGameSample.sln`。让我们再次加载它，确保任何CryENGINE实例，比如启动器或沙盒，都已关闭，因为我们将要覆盖运行时使用的`CryGame.dll`文件。
- en: Organizing nodes
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织节点
- en: The standard practice for CryENGINE games is to have a filter in the GameDLL
    project, **CryGame**, called **Nodes**. If this doesn't exist, go ahead and create
    it now.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: CryENGINE游戏的标准做法是在GameDLL项目**CryGame**中有一个名为**Nodes**的过滤器。如果不存在，现在就创建它。
- en: '![Organizing nodes](img/5909_02_26.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![组织节点](img/5909_02_26.jpg)'
- en: Creating a new node file
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的节点文件
- en: Nodes are never referenced in other areas of the project, so it's fine to simply
    implement a node as a single `.cpp` file without a header.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 节点在项目的其他区域中从未被引用，所以可以简单地将节点实现为一个单独的`.cpp`文件，而不需要头文件。
- en: 'In our case, let''s just add a new file, `TutorialNode.cpp`, and create the
    basic structure:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，让我们只添加一个新文件`TutorialNode.cpp`，并创建基本结构：
- en: '[PRE0]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Breaking down of code
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码分解
- en: Firstly, we included `stdafx.h`; this provides common functionality and some
    standardized "includes" for your file. This is also required to compile files.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含了`stdafx.h`；这提供了文件的常见功能和一些标准化的“包含”。这也是编译文件所需的。
- en: After that, we included a second file, `Nodes/G2FlowBaseNode.h`. While it's
    not strictly a CryENGINE component, this file is widely used in CryENGINE games
    to encapsulate node functionality into an easily accessible base class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们包含了第二个文件，`Nodes/G2FlowBaseNode.h`。虽然它不是严格意义上的CryENGINE组件，但这个文件在CryENGINE游戏中被广泛使用，将节点功能封装成一个易于访问的基类。
- en: We then create our actual class definition. We inherit from the aforementioned
    base node, and then specify that our node is an instanced node; generally speaking,
    you'll work with instanced nodes in CryENGINE.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建我们的实际类定义。我们从前面提到的基本节点继承，然后指定我们的节点是一个实例化节点；一般来说，你会在CryENGINE中使用实例化节点。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: CryENGINE uses some limited Hungarian notation prefixes as you see here. Classes
    are `CMyClass`, structs become `SMyData`, and interfaces are `IMyInterface`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: CryENGINE使用一些有限的匈牙利命名前缀，就像你在这里看到的那样。类是`CMyClass`，结构体变成`SMyData`，接口是`IMyInterface`。
- en: It's also common to use the `m_` prefix for fields, such as `m_memberVariable`,
    and `p` for pointer variables, such as `*pAnInstance`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字段，如`m_memberVariable`，通常使用`m_`前缀，对于指针变量，如`*pAnInstance`，通常使用`p`。
- en: In order to make node registration easier, CryENGINE exposes `REGISTER_FLOW_NODE`
    pre-processor macro. This system will automatically handle registration of your
    node during startup.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使节点注册更容易，CryENGINE暴露了`REGISTER_FLOW_NODE`预处理宏。这个系统将在启动时自动处理节点的注册。
- en: The node functions overview
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点函数概述
- en: 'For the purposes of the node we are creating, we don''t need to store any private
    information, so simply make all node information public using the C++ modifier
    as the first line inside your class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们正在创建的节点，我们不需要存储任何私有信息，所以只需使用C++修饰符将所有节点信息公开为类内的第一行：
- en: '[PRE1]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We then start off by implementing two functions, the constructor and the `Clone`
    method. We don''t need any logic in either of these, so the implementations are
    very simple; the constructor doesn''t initialize anything, and `Clone` simply
    returns a new instance of the current node:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们开始实现两个函数，构造函数和`Clone`方法。我们在这两个函数中都不需要任何逻辑，所以实现非常简单；构造函数不初始化任何东西，`Clone`只是返回当前节点的一个新实例：
- en: '[PRE2]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we're also introduced to `SActivationInfo` for the first time. This struct
    contains information about the node's present state, as well as the graph it's
    contained within, and we'll be using this elsewhere later.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还第一次介绍了`SActivationInfo`。这个结构包含了关于节点当前状态的信息，以及它所包含的图表，我们稍后会在其他地方使用它。
- en: 'Now, three more functions are required for our node to at least compile:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的节点至少需要三个额外的函数才能编译：
- en: '[PRE3]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`ProcessEvent` is where we''ll be doing most of our node logic; this function
    is called when interesting things happen to our node, such as ports being triggered.
    `GetConfiguration` controls how the node will be displayed, as well as what input
    and output ports it contains. `GetMemoryUsage` doesn''t need any extra implementation
    from us, so we can just add a reference to this node for memory usage tracking.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessEvent`是我们将要做大部分节点逻辑的地方；当有有趣的事情发生在我们的节点上时，比如端口被触发，就会调用这个函数。`GetConfiguration`控制节点的显示方式，以及它包含的输入和输出端口。`GetMemoryUsage`不需要我们额外的实现，所以我们可以只是为内存使用跟踪添加对这个节点的引用。'
- en: Now, it would be a good point to verify that your code compiles; if not, check
    whether you've declared all the function signatures correctly, and included the
    headers.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，验证你的代码是否能编译是一个好的起点；如果不能，检查你是否正确声明了所有函数签名，并包含了头文件。
- en: Implementing GetConfiguration
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现GetConfiguration
- en: 'As mentioned earlier, `GetConfiguration` is where we set up how our node can
    be used in the Flowgraph Editor. Firstly, let''s set up `enum` to describe our
    input ports; we''re going to use two values, left and right, as well as an activation
    port to trigger the calculation. Declare this inside the class:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`GetConfiguration`是我们设置节点在Flowgraph Editor中如何使用的地方。首先，让我们设置`enum`来描述我们的输入端口；我们将使用两个值，左和右，以及一个激活端口来触发计算。在类内部声明：
- en: '[PRE4]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Of course, we also need an output port for the calculation, so let''s create
    `enum` with a single value for that also. It''s not required, but it''s a good
    practice to be consistent, and most nodes will have more than one output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要一个用于计算的输出端口，因此让我们也创建一个单一值的`enum`。虽然不是必需的，但保持一致是一个好习惯，大多数节点将具有多个输出：
- en: '[PRE5]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating ports
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建端口
- en: With those declared, we can start building up our node. Ports are defined as
    entries in a constant static array declared in `GetConfiguration`, and are constructed
    using some helper functions, namely `InputPortConfig<T>` for a specific type of
    value, as well as `InputPortConfig_AnyType` for allowing all values, and `InputPortConfig_Void`
    for ports that use no data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些声明，我们就可以开始构建我们的节点。端口被定义为`GetConfiguration`中声明的常量静态数组中的条目，并且使用一些辅助函数进行构造，即`InputPortConfig<T>`用于特定类型的值，以及`InputPortConfig_AnyType`用于允许所有值，以及`InputPortConfig_Void`用于不使用数据的端口。
- en: With that in mind, we know that a void input will be required for our trigger
    input on top of two float templated ports. We'll also need a float output.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们知道除了两个浮点模板端口外，我们的触发输入还需要一个void输入。我们还需要一个浮点输出。
- en: '[PRE6]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we get to specify the name of the port, the description, as
    well as a default value for ports that use data. They should match the order of
    the enums that we declared earlier.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们可以指定端口的名称、描述，以及对使用数据的端口设置默认值。它们应该与我们之前声明的枚举的顺序相匹配。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Changing port names for nodes that are already used will break existing graphs.
    Fill in the optional `humanName` parameter to change the display name.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 更改已使用的节点的端口名称将破坏现有的图表。填写可选的`humanName`参数以更改显示名称。
- en: 'Now we repeat that process, except we use the output set of functions:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们重复该过程，只是使用输出函数集：
- en: '[PRE7]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Assigning arrays to the node configuration
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数组分配给节点配置
- en: 'Following the process of creating our ports, we need to assign these arrays
    to our `config` parameter, as well as provide a description and category:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建端口的过程之后，我们需要将这些数组分配给我们的`config`参数，并提供描述和类别：
- en: '[PRE8]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you compile the code now, the node should be fully visible in the Editor.
    But as you'll see, it does nothing yet; to fix that, we have to implement `ProcessEvent`!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在编译代码，节点应该完全显示在编辑器中。但是正如您将看到的那样，它还没有做任何事情；为了解决这个问题，我们必须实现`ProcessEvent`！
- en: Flownode configuration flags
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: flownode配置标志
- en: 'The `SFlowNodeConfig` struct allows you to assign optional flags to the flownode,
    listed as shown:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`SFlowNodeConfig`结构允许您为flownode分配可选标志，如下所示列出：'
- en: '`EFLN_TARGET_ENTITY`: This is used to indicate that this node should support
    a target entity. To obtain the currently assigned target entity, have a look at
    `SActivationInfo::pEntity`.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EFLN_TARGET_ENTITY`：这用于指示此节点应支持目标实体。要获取当前分配的目标实体，请查看`SActivationInfo::pEntity`。'
- en: '`EFLN_HIDE_UI`: This hides the node from the user in the flowgraph UI.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EFLN_HIDE_UI`：这将在flowgraph UI中隐藏节点。'
- en: '`EFLN_UNREMOVEABLE`: This disables the ability for the user to remove the node.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EFLN_UNREMOVEABLE`：这禁用了用户删除节点的功能。'
- en: 'To append a flag within `GetConfiguration`, in this case to support a target
    entity, simply add the flag to the `nFlags` variable:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`GetConfiguration`中添加一个标志，以支持目标实体，只需将标志添加到`nFlags`变量中：
- en: '[PRE9]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Implementing ProcessEvent
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现ProcessEvent
- en: '`ProcessEvent` is where we catch all the interesting events for our node, such
    as ports being triggered. In our case, we want to perform a calculation whenever
    our `Activate` port is triggered, so we need to check for port activations. First
    though, we can save ourselves some processing by checking which event we''d like
    to handle.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessEvent`是我们捕获节点的所有有趣事件的地方，例如触发端口。在我们的情况下，我们希望在触发我们的`Activate`端口时执行计算，因此我们需要检查端口的激活。不过，首先，我们可以通过检查我们想要处理的事件来节省一些处理时间。'
- en: '[PRE10]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Usually you'll be handling more than one event, so it's good to get into the
    habit of using a `switch` statement here.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您将处理多个事件，因此养成在此处使用`switch`语句的习惯是很好的。
- en: 'Inside that, let''s take a look at the various flownode functions we use to
    check for activations, to retrieve data, and then trigger an output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，让我们看一下我们用来检查激活、检索数据，然后触发输出的各种flownode函数：
- en: '[PRE11]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To summarize, we use our activation information in all these functions to represent
    the current state. We can then retrieve values using the `GetPort*` functions
    for the various port types, and then trigger an output with data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们在所有这些函数中使用我们的激活信息来表示当前状态。然后，我们可以使用`GetPort*`函数检索各种端口类型的值，然后触发带有数据的输出。
- en: It's time to load up the Editor and test; if all's gone well, you should be
    able to see your node in the Tutorial category. Congratulations, you've just written
    your first C++ code for CryENGINE!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候加载编辑器并进行测试了；如果一切顺利，您应该能够在教程类别中看到您的节点。恭喜，您刚刚为CryENGINE编写了您的第一个C++代码！
- en: '![Implementing ProcessEvent](img/5909_02_27.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![实现ProcessEvent](img/5909_02_27.jpg)'
- en: Creating a custom node in C#
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中创建自定义节点
- en: CryMono also supports the creation of custom nodes using idioms that C# developers
    will feel accustomed to, such as attribute metaprogramming. To get started with
    C# CryENGINE scripts, open up the sample scripts solution in `Game/Scripts/CryGameCode.sln`.
    Add a new `.cs` file to the flownodes folder, and we'll start creating the same
    node in C#, so you can see how the creation varies.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: CryMono还支持使用C#开发人员熟悉的习惯用法来创建自定义节点，例如属性元编程。要开始使用C# CryENGINE脚本，请打开`Game/Scripts/CryGameCode.sln`中的示例脚本解决方案。在flownodes文件夹中添加一个新的`.cs`文件，然后我们将开始在C#中创建相同的节点，以便您可以看到创建方式的不同。
- en: 'To start with, let''s create a basic skeleton node. We need to bring the correct
    namespace into scope for the `Flowgraph` classes, as well as set up some basic
    attributes for our node:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个基本的骨架节点。我们需要为我们的节点引入正确的命名空间，以及为我们的节点设置一些基本属性：
- en: '[PRE12]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As in C++, nodes aren't referenced anywhere else in the project, so we assign
    a separate namespace for our nodes to keep them from polluting the main namespaces.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++一样，节点在项目中没有其他引用，因此我们为我们的节点分配了一个单独的命名空间，以防止它们污染主要命名空间。
- en: We use the `FlowNodeAttribute` class in place of `GetConfiguration` to set up
    metadata for our node, such as the correct category and visibility level. Your
    node must include this attribute and inherit it from `FlowNode` in order to be
    registered by the CryENGINE; there's no need for any manual registration calls.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`FlowNodeAttribute`类来设置节点的元数据，例如正确的类别和可见性级别，而不是使用`GetConfiguration`。您的节点必须包括此属性，并从`FlowNode`继承，以便被CryENGINE注册；不需要任何手动注册调用。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that attributes can be placed without the last `Attribute` of its name.
    For example, `FlowNodeAttribute` can be placed as both `[FlowNodeAttribute]` and
    `[FlowNode]`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，属性可以放置在其名称的最后一个“Attribute”之外。例如，`FlowNodeAttribute`可以放置为`[FlowNodeAttribute]`和`[FlowNode]`。
- en: Adding inputs
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加输入
- en: 'Inputs are defined as functions in CryMono, and they take either a single parameter
    which defines the data type, or no parameter for void ports. They also need to
    be decorated with the `Port` attribute. In our case, let''s set up the same three
    inputs we had in the C++ version of the node:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在CryMono中，输入被定义为函数，并且它们接受定义数据类型的单个参数，或者对于void端口，不接受参数。它们还需要用`Port`属性进行修饰。在我们的情况下，让我们设置与节点的C++版本中相同的三个输入：
- en: '[PRE13]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll come back to the implementation of `Activate` in just a second. While
    you can override the port name by setting optional parameters in the attribute,
    it's easier way to just let your function name define how the node appears in
    the Editor.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的实现中回到“Activate”。虽然你可以通过在属性中设置可选参数来覆盖端口名称，但更容易的方法是让你的函数名称定义节点在编辑器中的显示方式。
- en: Adding outputs
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加输出
- en: 'Outputs are stored as instances of either `OutputPort` or `OutputPort<T>`,
    if values are required. Let''s add our `Result` output now as a property on the
    class:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 输出被存储为`OutputPort`或`OutputPort<T>`的实例，如果需要值。让我们现在将我们的`Result`输出作为类的属性添加进去：
- en: '[PRE14]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Implementing Activate
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现激活
- en: 'Let''s jump back to our `Activate` input; again, we need to retrieve our two
    values and then fire an output. The `FlowNode` class has convenient functions
    for these:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的“Activate”输入；同样，我们需要检索我们的两个值，然后触发一个输出。`FlowNode`类有方便的函数来实现这些：
- en: '[PRE15]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That''s it! Next time you open the Flowgraph Editor, you''ll see your new **CSharpTutorial:Multiplier**
    node, with the exact same functionality as the C++ equivalent you implemented
    earlier:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！下次您打开流程图编辑器时，您将看到您的新的**CSharpTutorial:Multiplier**节点，具有与您之前实现的C++等效节点完全相同的功能：
- en: '![Implementing Activate](img/5909_02_28.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![实现激活](img/5909_02_28.jpg)'
- en: Congratulations once again, as you've taken your first step to writing game
    code using the .NET platform and CryENGINE!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 再次恭喜你，因为你已经迈出了使用.NET平台和CryENGINE编写游戏代码的第一步！
- en: Target entities
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标实体
- en: 'Adding support for target entities in CryMono is easy, simply set the `TargetsEntity`
    property in your `FlowNode` attribute to true:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在CryMono中添加对目标实体的支持很容易，只需将您的`FlowNode`属性中的`TargetsEntity`属性设置为true即可。
- en: '[PRE16]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can then obtain the entity instance via `FlowNode.TargetEntity`, assuming
    it was assigned inside the flowgraph containing the node.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过`FlowNode.TargetEntity`获取实体实例，假设它是在包含节点的流程图中分配的。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learnt why flowgraphs can be useful to empower designers,
    and created our own flowgraph.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学会了为什么流程图对设计师有用，并创建了我们自己的流程图。
- en: We've also investigated a selection of the existing nodes provided by CryENGINE,
    and then created our own nodes in two programming languages. You should now have
    a good understanding of the flowgraph system, and how to use it to your advantage.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还调查了CryENGINE提供的一些现有节点，然后用两种编程语言创建了我们自己的节点。现在，您应该对流程图系统有了很好的理解，并且知道如何利用它。
- en: In future chapters, we'll look at some of the additional things flowgraphs can
    achieve, including designing user interfaces, implementing material effects, creating
    special flownodes to represent entities in the world, and wrapping up AI functionality
    into convenient reusable modules.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的章节中，我们将探讨流程图可以实现的一些其他功能，包括设计用户界面、实现材质效果、创建特殊的流节点来表示世界中的实体，并将AI功能封装成方便的可重用模块。
- en: For now, if you'd like to explore the world of flowgraphs more, why not have
    a go at figuring out how more of the stock nodes can be implemented? Familiarize
    yourself with the differences between writing C++ and C# nodes, and see which
    you prefer.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更多地探索流程图的世界，为什么不试着找出如何实现更多的标准节点呢？熟悉一下编写C++和C#节点之间的区别，看看你更喜欢哪个。
- en: If you'd like to experiment with CryMono in particular, try editing your node
    scripts and saving them with Sandbox running; you may be pleasantly surprised
    to find that they're recompiled and reloaded in the background! This should help
    you test new node ideas without having your experimentation hindered by compile
    times and restarts.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您特别想尝试CryMono，请尝试编辑您的节点脚本，并在运行Sandbox时保存它们；您可能会惊喜地发现它们在后台重新编译和重新加载！这应该帮助您测试新的节点想法，而不会因为编译时间和重新启动而受到阻碍。
