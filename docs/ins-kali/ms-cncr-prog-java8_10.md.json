["```java\n    productsByBuyer.forEach( (id, list) -> System.out.println(id+\": \"+list.size()));\n```", "```java\n    productsByBuyer.forEach( (id, list) -> {\n        double average=list.stream().mapToDouble(item -> item.getValue()).average().getAsDouble();\n        System.out.println(id+\": \"+average);\n    });\n```", "```java\n    ExtendedProduct firstProduct=productsByBuyer.search(100,\n        (id, products) -> {\n            for (ExtendedProduct product: products) {\n                if (product.getTitle() .toLowerCase().contains(\"java\")) {\n                    return product;\n                }\n            }\n        return null;\n    });\n    if (firstProduct!=null) {\n        System.out.println(firstProduct.getBuyer()+\":\"+ firstProduct.getTitle());\n    }\n```", "```java\nBiFunction<String, List<ExtendedProduct>, List<ExtendedProduct>> transformer = (key, value) -> value.stream().filter(product -> product.getValue() == 1).collect(Collectors.toList());\n```", "```java\nBinaryOperator<List<ExtendedProduct>> reducer = (list1, list2) ->{\n        list1.addAll(list2);\n        return list1;\n};\n```", "```java\n    List<ExtendedProduct> badReviews=productsByBuyer.reduce(10, transformer, reducer);\n    badReviews.forEach(product -> {\n        System.out.println(product.getTitle()+\":\"+ product.getBuyer()+\":\"+product.getValue());\n    });\n```", "```java\n    ConcurrentHashMap<String, LongAdder> counter=new ConcurrentHashMap<>();\n```", "```java\n    badReviews.forEach(product -> {\n        counter.computeIfAbsent(product.getTitle(), title -> new LongAdder()).increment();\n    });\n    counter.forEach((title, count) -> {\n        System.out.println(title+\":\"+count);\n    });\n```", "```java\n        Path path=Paths.get(\"data\\\\amazon\\\\1995.txt\");\n        ConcurrentHashMap<BasicProduct, ConcurrentLinkedDeque<BasicReview>> products1995=BasicProductLoader.load(path);\n        showData(products1995);\n\n        path=Paths.get(\"data\\\\amazon\\\\1996.txt\");\n        ConcurrentHashMap<BasicProduct, ConcurrentLinkedDeque<BasicReview>> products1996=BasicProductLoader.load(path);\n        System.out.println(products1996.size());\n        showData(products1996);\n```", "```java\n        products1996.forEach(10,(product, reviews) -> {\n            products1995.merge(product, reviews, (reviews1, reviews2) -> {\n                System.out.println(\"Merge for: \"+product.getAsin());\n                reviews1.addAll(reviews2);\n                return reviews1;\n            });\n        });\n```", "```java\n    System.out.println(\"Products: \"+productList.size());\n    productList.removeIf(product -> product.getSalesrank() > 1000);\n    System.out.println(\"Products; \"+productList.size());\n    productList.forEach(product -> {\n        System.out.println(product.getTitle()+\": \"+product.getSalesrank());\n    });\n```", "```java\npublic class SpliteratorTask implements Runnable {\n\n    private Spliterator<Product> spliterator;\n\n    public SpliteratorTask (Spliterator<Product> spliterator) {\n        this.spliterator=spliterator;\n    }\n\n    @Override\n    public void run() {\n        int counter=0;\n        while (spliterator.tryAdvance(product -> {\n            product.setTitle(product.getTitle().toLowerCase());\n        })) {\n            counter++;\n        };\n        System.out.println(Thread.currentThread().getName() +\":\"+counter);\n    }\n\n}\n```", "```java\n    Spliterator<Product> split1=productList.spliterator();\n    System.out.println(split1.hasCharacteristics (Spliterator.CONCURRENT));\n    System.out.println(split1.hasCharacteristics (Spliterator.SUBSIZED));\n    System.out.println(split1.estimateSize());\n```", "```java\n    Spliterator<Product> split2=split1.trySplit();\n    System.out.println(split1.estimateSize());\n    System.out.println(split2.estimateSize());\n```", "```java\n    ThreadPoolExecutor executor=(ThreadPoolExecutor) Executors.newCachedThreadPool();\n    executor.execute(new SpliteratorTask(split1));\n    executor.execute(new SpliteratorTask(split2));\n```", "```java\n            LongAccumulator accumulator=new LongAccumulator((x,y) -> x*y, 1);\n\n        IntStream.range(1, 10).parallel().forEach(x -> accumulator.accumulate(x));\n\n        System.out.println(accumulator.get());\n```", "```java\npublic class CommonTask {\n\n    public static void doTask() {\n        long duration = ThreadLocalRandom.current().nextLong(10);\n        System.out.printf(\"%s-%s: Working %d seconds\\n\",new Date(),Thread.currentThread().getName(),duration);\n        try {\n            TimeUnit.SECONDS.sleep(duration);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n```", "```java\npublic class LockTask implements Runnable {\n\n    private static ReentrantLock lock = new ReentrantLock();\n    private String name;\n\n    public LockTask(String name) {\n        this.name=name;\n    }\n\n    @Override\n    public void run() {\n        try {\n            lock.lock();\n            System.out.println(\"Task: \" + name + \"; Date: \" + new Date() + \": Running the task\");\n            CommonTask.doTask();\n            System.out.println(\"Task: \" + name + \"; Date: \" + new Date() + \": The execution has finished\");\n        } finally {\n            lock.unlock();\n        }\n\n    }\n}\n```", "```java\npublic class LockMain {\n\n    public static void main(String[] args) {\n        ThreadPoolExecutor executor=(ThreadPoolExecutor) Executors.newCachedThreadPool();\n        for (int i=0; i<10; i++) {\n            executor.execute(new LockTask(\"Task \"+i));\n        }\n        executor.shutdown();\n        try {\n            executor.awaitTermination(1, TimeUnit.DAYS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```", "```java\npublic class SemaphoreTask implements Runnable{\n    private Semaphore semaphore;\n    public SemaphoreTask(Semaphore semaphore) {\n        this.semaphore=semaphore;\n    }\n    @Override\n    public void run() {\n        try {\n            semaphore.acquire();\n            CommonTask.doTask();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            semaphore.release();\n        }\n    }\n}\n```", "```java\n    public static void main(String[] args) {\n\n        Semaphore semaphore=new Semaphore(2);\n        ThreadPoolExecutor executor=(ThreadPoolExecutor) Executors.newCachedThreadPool();\n\n        for (int i=0; i<10; i++) {\n            executor.execute(new SemaphoreTask(semaphore));\n        }\n\n        executor.shutdown();\n        try {\n            executor.awaitTermination(1, TimeUnit.DAYS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n```", "```java\npublic class CountDownTask implements Runnable {\n\n    private CountDownLatch countDownLatch;\n\n    public CountDownTask(CountDownLatch countDownLatch) {\n        this.countDownLatch=countDownLatch;\n    }\n\n    @Override\n    public void run() {\n        CommonTask.doTask();\n        countDownLatch.countDown();\n\n    }\n}\n```", "```java\n    public static void main(String[] args) {\n\n        CountDownLatch countDownLatch=new CountDownLatch(10);\n\n        ThreadPoolExecutor executor=(ThreadPoolExecutor) Executors.newCachedThreadPool();\n\n        System.out.println(\"Main: Launching tasks\");\n        for (int i=0; i<10; i++) {\n            executor.execute(new CountDownTask(countDownLatch));\n        }\n\n        try {\n            countDownLatch.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.\n\n        executor.shutdown();\n    }\n```", "```java\npublic class BarrierTask implements Runnable {\n\n    private CyclicBarrier barrier;\n\n    public BarrierTask(CyclicBarrier barrier) {\n        this.barrier=barrier;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+\": Phase 1\");\n        CommonTask.doTask();\n        try {\n            barrier.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName()+\": Phase 2\");\n\n    }\n}\n```", "```java\npublic class FinishBarrierTask implements Runnable {\n\n    @Override\n    public void run() {\n        System.out.println(\"FinishBarrierTask: All the tasks have finished\");\n    }\n}\n```", "```java\n    public static void main(String[] args) {\n        CyclicBarrier barrier=new CyclicBarrier(10,new FinishBarrierTask());\n\n        ThreadPoolExecutor executor=(ThreadPoolExecutor) Executors.newCachedThreadPool();\n\n        for (int i=0; i<10; i++) {\n            executor.execute(new BarrierTask(barrier));\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(1, TimeUnit.DAYS);\n        } catch (InterruptedException e) {\n             e.printStackTrace();\n        }\n    }\n```", "```java\npublic class LoadTask implements Supplier<List<Product>> {\n\n    private Path path;\n\n    public LoadTask (Path path) {\n        this.path=path;\n    }\n    @Override\n    public List<Product> get() {\n        List<Product> productList=null;\n        try {\n            productList = Files.walk(path, FileVisitOption.FOLLOW_LINKS).parallel()\n                    .filter(f -> f.toString().endsWith(\".txt\")) .map(ProductLoader::load).collect (Collectors.toList());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return productList;\n    }\n}\n```", "```java\npublic class SearchTask implements Function<List<Product>, List<Product>> {\n\n    private String query;\n\n    public SearchTask(String query) {\n        this.query=query;\n    }\n\n    @Override\n    public List<Product> apply(List<Product> products) {\n        System.out.println(new Date()+\": CompletableTask: start\");\n        List<Product> ret = products.stream()\n                .filter(product -> product.getTitle() .toLowerCase().contains(query))\n                .collect(Collectors.toList());\n        System.out.println(new Date()+\": CompletableTask: end: \"+ret.size());\n        return ret;\n    }\n\n}\n```", "```java\npublic class WriteTask implements Consumer<List<Product>> {\n\n    @Override\n    public void accept(List<Product> products) {\n        // implementation is omitted\n    }\n}\n```", "```java\npublic class CompletableMain {\n\n    public static void main(String[] args) {\n        Path file = Paths.get(\"data\",\"category\");\n\n        System.out.println(new Date() + \": Main: Loading products\");\n        LoadTask loadTask = new LoadTask(file);\n        CompletableFuture<List<Product>> loadFuture = CompletableFuture\n                .supplyAsync(loadTask);\n```", "```java\n        System.out.println(new Date() + \": Main: Then apply for search\");\n\n        CompletableFuture<List<Product>> completableSearch = loadFuture\n                .thenApplyAsync(new SearchTask(\"love\"));\n```", "```java\n        CompletableFuture<Void> completableWrite = completableSearch\n                .thenAcceptAsync(new WriteTask());\n\n        completableWrite.exceptionally(ex -> {\n            System.out.println(new Date() + \": Main: Exception \"\n                    + ex.getMessage());\n            return null;\n        });\n```", "```java\n        System.out.println(new Date() + \": Main: Then apply for users\");\n\n        CompletableFuture<List<String>> completableUsers = loadFuture\n                .thenApplyAsync(resultList -> {\n\n                    System.out.println(new Date()\n                            + \": Main: Completable users: start\");\n                                        List<String> users = resultList.stream()\n                .flatMap(p -> p.getReviews().stream())\n                .map(review -> review.getUser())\n                .distinct()\n                .collect(Collectors.toList());\n                    System.out.println(new Date()\n                            + \": Main: Completable users: end\");\n\n                    return users;\n                });\n```", "```java\n        System.out.println(new Date()\n                + \": Main: Then apply for best rated product....\");\n\n        CompletableFuture<Product> completableProduct = loadFuture\n                .thenApplyAsync(resultList -> {\n                    Product maxProduct = null;\n                    double maxScore = 0.0;\n\n                    System.out.println(new Date()\n                            + \": Main: Completable product: start\");\n                    for (Product product : resultList) {\n                        if (!product.getReviews().isEmpty()) {\n                            double score = product.getReviews().stream()\n                                    .mapToDouble(review -> review.getValue())\n                                    .average().getAsDouble();\n                            if (score > maxScore) {\n                                maxProduct = product;\n                                maxScore = score;\n                            }\n                        }\n                    }\n                    System.out.println(new Date()\n                            + \": Main: Completable product: end\");\n                    return maxProduct;\n                });\n\n        System.out.println(new Date()\n                + \": Main: Then apply for best selling product....\");\n        CompletableFuture<Product> completableBestSellingProduct = loadFuture\n                .thenApplyAsync(resultList -> {\n                    System.out.println(new Date() + \": Main: Completable best selling: start\");\n                  Product bestProduct = resultList\n                .stream()\n                .min(Comparator.comparingLong (Product::getSalesrank))\n                .orElse(null);\n                    System.out.println(new Date()\n                            + \": Main: Completable best selling: end\");\n                    return bestProduct;\n\n                });\n```", "```java\n        CompletableFuture<String> completableProductResult = completableBestSellingProduct\n        .thenCombineAsync(\n             completableProduct, (bestSellingProduct, bestRatedProduct) -> {\n        System.out.println(new Date() + \": Main: Completable product result: start\");\n        String ret = \"The best selling product is \" + bestSellingProduct.getTitle() + \"\\n\";\n        ret += \"The best rated product is \"\n            + bestRatedProduct.getTitle();\n        System.out.println(new Date() + \": Main: Completable product result: end\");\n        return ret;\n    });\n```", "```java\n        System.out.println(new Date() + \": Main: Waiting for results\");\n        CompletableFuture<Void> finalCompletableFuture = CompletableFuture\n                .allOf(completableProductResult, completableUsers,\n                        completableWrite);\n        finalCompletableFuture.join();\n\n        try {\n            System.out.println(\"Number of loaded products: \"\n                    + loadFuture.get().size());\n            System.out.println(\"Number of found products: \"\n                    + completableSearch.get().size());\n            System.out.println(\"Number of users: \"\n                    + completableUsers.get().size());\n            System.out.println(\"Best rated product: \"\n                    + completableProduct.get().getTitle());\n            System.out.println(\"Best selling product: \"\n                    + completableBestSellingProduct.get() .getTitle());\n            System.out.println(\"Product result: \"+completableProductResult.get());\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n```"]