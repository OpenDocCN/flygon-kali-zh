["```kt\n     com.journaler.database \n```", "```kt\n    package com.journaler.database \n\n    abstract class DbModel { \n      abstract var id: Long \n    } \n```", "```kt\n    package com.journaler.model \n\n    import android.location.Location \n    import com.journaler.database.DbModel \n\n    abstract class Entry( \n      var title: String, \n      var message: String, \n      var location: Location \n    ) : DbModel() \n    Note class: \n    package com.journaler.model \n\n    import android.location.Location \n\n    class Note( \n      title: String, \n      message: String, \n      location: Location \n    ) : Entry( \n        title, \n        message, \n        location \n        ) { \n         override var id = 0L \n        } \n```", "```kt\n    package com.journaler.model \n\n    import android.location.Location \n\n    class Todo( \n      title: String, \n      message: String, \n      location: Location, \n      var scheduledFor: Long \n    ) : Entry( \n        title, \n        message, \n        location \n    ) { \n    override var id = 0L \n    } \n```", "```kt\n    package com.journaler.database \n\n    import android.database.sqlite.SQLiteDatabase \n    import android.database.sqlite.SQLiteOpenHelper \n    import android.util.Log \n    import com.journaler.Journaler \n\n    class DbHelper(val dbName: String, val version: Int) :   \n    SQLiteOpenHelper( \n      Journaler.ctx, dbName, null, version \n    ) { \n\n      companion object { \n        val ID: String = \"_id\" \n        val TABLE_TODOS = \"todos\" \n        val TABLE_NOTES = \"notes\" \n        val COLUMN_TITLE: String = \"title\" \n        val COLUMN_MESSAGE: String = \"message\" \n        val COLUMN_SCHEDULED: String = \"scheduled\" \n        val COLUMN_LOCATION_LATITUDE: String = \"latitude\" \n        val COLUMN_LOCATION_LONGITUDE: String = \"longitude\" \n      } \n\n      private val tag = \"DbHelper\" \n\n      private val createTableNotes =  \"\"\" \n        CREATE TABLE if not exists $TABLE_NOTES \n           ( \n             $ID integer PRIMARY KEY autoincrement, \n             $COLUMN_TITLE text, \n             $COLUMN_MESSAGE text, \n             $COLUMN_LOCATION_LATITUDE real, \n             $COLUMN_LOCATION_LONGITUDE real \n           ) \n          \"\"\" \n\n      private val createTableTodos =  \"\"\" \n        CREATE TABLE if not exists $TABLE_TODOS \n           ( \n              $ID integer PRIMARY KEY autoincrement, \n              $COLUMN_TITLE text, \n              $COLUMN_MESSAGE text, \n              $COLUMN_SCHEDULED integer, \n              $COLUMN_LOCATION_LATITUDE real, \n              $COLUMN_LOCATION_LONGITUDE real \n           ) \n         \"\"\" \n\n       override fun onCreate(db: SQLiteDatabase) { \n        Log.d(tag, \"Database [ CREATING ]\") \n        db.execSQL(createTableNotes) \n        db.execSQL(createTableTodos) \n        Log.d(tag, \"Database [ CREATED ]\") \n       } \n\n      override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int,\n      newVersion: Int) { \n        // Ignore for now. \n      } \n\n    } \n```", "```kt\n     interface Crud<T> where T : DbModel { \n\n       companion object { \n        val BROADCAST_ACTION = \"com.journaler.broadcast.crud\" \n        val BROADCAST_EXTRAS_KEY_CRUD_OPERATION_RESULT = \"crud_result\" \n       } \n\n      /** \n       * Returns the ID of inserted item. \n       */ \n      fun insert(what: T): Long \n\n      /** \n       * Returns the list of inserted IDs. \n       */ \n      fun insert(what: Collection<T>): List<Long> \n\n      /** \n      * Returns the number of updated items. \n      */ \n      fun update(what: T): Int \n\n      /** \n      * Returns the number of updated items. \n      */ \n      fun update(what: Collection<T>): Int \n\n      /** \n      * Returns the number of deleted items. \n      */ \n      fun delete(what: T): Int \n\n      /** \n      * Returns the number of deleted items. \n      */ \n      fun delete(what: Collection<T>): Int \n\n      /** \n      * Returns the list of items. \n      */ \n      fun select(args: Pair<String, String>): List<T> \n\n      /** \n      * Returns the list of items. \n      */ \n      fun select(args: Collection<Pair<String, String>>): List<T> \n\n      /** \n      * Returns the list of items. \n      */ \n      fun selectAll(): List<T> \n\n    } \n```", "```kt\n     package com.journaler.database \n\n     import android.content.ContentValues \n     import android.location.Location \n     import android.util.Log \n     import com.journaler.model.Note \n     import com.journaler.model.Todo \n\n     object Db { \n\n      private val tag = \"Db\" \n      private val version = 1 \n      private val name = \"students\" \n\n      val NOTE = object : Crud<Note> { \n        // Crud implementations \n      } \n\n      val TODO = object : Crud<NoteTodo { \n         // Crud implementations \n      } \n    }  \n```", "```kt\n    val NOTE = object : Crud<Note> { \n      ... \n      override fun insert(what: Note): Long { \n        val inserted = insert(listOf(what)) \n        if (!inserted.isEmpty()) return inserted[0] \n        return 0 \n      } \n\n     override fun insert(what: Collection<Note>): List<Long> { \n       val db = DbHelper(name, version).writableDatabase \n       db.beginTransaction() \n       var inserted = 0 \n       val items = mutableListOf<Long>() \n       what.forEach { item -> \n         val values = ContentValues() \n         val table = DbHelper.TABLE_NOTES \n         values.put(DbHelper.COLUMN_TITLE, item.title) \n         values.put(DbHelper.COLUMN_MESSAGE, item.message) \n         values.put(DbHelper.COLUMN_LOCATION_LATITUDE,\n           item.location.latitude) \n         values.put(DbHelper.COLUMN_LOCATION_LONGITUDE,\n           item.location.longitude) \n         val id = db.insert(table, null, values) \n           if (id > 0) { \n             items.add(id) \n             Log.v(tag, \"Entry ID assigned [ $id ]\") \n               inserted++ \n             } \n           } \n           val success = inserted == what.size \n           if (success) { \n                db.setTransactionSuccessful() \n           } else { \n                items.clear() \n           } \n            db.endTransaction() \n            db.close() \n            return items \n          } \n          ... \n    } \n    ... \n    val TODO = object : Crud<Todo> { \n      ... \n      override fun insert(what: Todo): Long { \n        val inserted = insert(listOf(what)) \n        if (!inserted.isEmpty()) return inserted[0] \n        return 0 \n      } \n\n      override fun insert(what: Collection<Todo>): List<Long> { \n        val db = DbHelper(name, version).writableDatabase \n        db.beginTransaction() \n        var inserted = 0 \n        val items = mutableListOf<Long>() \n        what.forEach { item -> \n          val table = DbHelper.TABLE_TODOS \n          val values = ContentValues() \n          values.put(DbHelper.COLUMN_TITLE, item.title) \n          values.put(DbHelper.COLUMN_MESSAGE, item.message) \n          values.put(DbHelper.COLUMN_LOCATION_LATITUDE,\n          item.location.latitude) \n          values.put(DbHelper.COLUMN_LOCATION_LONGITUDE,\n          item.location.longitude) \n          values.put(DbHelper.COLUMN_SCHEDULED, item.scheduledFor) \n            val id = db.insert(table, null, values) \n            if (id > 0) { \n              item.id = id \n              Log.v(tag, \"Entry ID assigned [ $id ]\") \n              inserted++ \n            } \n           } \n           val success = inserted == what.size \n           if (success) { \n                db.setTransactionSuccessful() \n           } else { \n               items.clear() \n           } \n           db.endTransaction() \n           db.close() \n           return items \n          } \n         ... \n     } \n     ... \n```", "```kt\n    val NOTE = object : Crud<Note> { \n       ... \n       override fun update(what: Note) = update(listOf(what)) \n\n       override fun update(what: Collection<Note>): Int { \n         val db = DbHelper(name, version).writableDatabase \n         db.beginTransaction() \n         var updated = 0 \n         what.forEach { item -> \n           val values = ContentValues() \n           val table = DbHelper.TABLE_NOTES \n           values.put(DbHelper.COLUMN_TITLE, item.title) \n           values.put(DbHelper.COLUMN_MESSAGE, item.message) \n           values.put(DbHelper.COLUMN_LOCATION_LATITUDE,\n           item.location.latitude) \n           values.put(DbHelper.COLUMN_LOCATION_LONGITUDE,\n           item.location.longitude) \n           db.update(table, values, \"_id = ?\", \n           arrayOf(item.id.toString())) \n                updated++ \n           } \n           val result = updated == what.size \n           if (result) { \n             db.setTransactionSuccessful() \n           } else { \n             updated = 0 \n           } \n           db.endTransaction() \n           db.close() \n           return updated \n          } \n          ... \n        } \n        ... \n      val TODO = object : Crud<Todo> { \n        ... \n        override fun update(what: Todo) = update(listOf(what)) \n\n        override fun update(what: Collection<Todo>): Int { \n          val db = DbHelper(name, version).writableDatabase \n          db.beginTransaction() \n          var updated = 0 \n          what.forEach { item -> \n             val table = DbHelper.TABLE_TODOS \n             val values = ContentValues() \n             values.put(DbHelper.COLUMN_TITLE, item.title) \n             values.put(DbHelper.COLUMN_MESSAGE, item.message) \n             values.put(DbHelper.COLUMN_LOCATION_LATITUDE,\n             item.location.latitude) \n            values.put(DbHelper.COLUMN_LOCATION_LONGITUDE,\n            item.location.longitude) \n            values.put(DbHelper.COLUMN_SCHEDULED, item.scheduledFor) \n            db.update(table, values, \"_id = ?\",  \n            arrayOf(item.id.toString())) \n               updated++ \n            } \n            val result = updated == what.size \n            if (result) { \n              db.setTransactionSuccessful() \n            } else { \n              updated = 0 \n            } \n            db.endTransaction() \n            db.close() \n            return updated \n            } \n           ... \n      } \n     ...  \n```", "```kt\n    val NOTE = object : Crud<Note> { \n      ... \n      override fun delete(what: Note): Int = delete(listOf(what)) \n         override fun delete(what: Collection<Note>): Int { \n         val db = DbHelper(name, version).writableDatabase \n         db.beginTransaction() \n         val ids = StringBuilder() \n         what.forEachIndexed { index, item -> \n         ids.append(item.id.toString()) \n           if (index < what.size - 1) { \n              ids.append(\", \") \n           } \n         } \n         val table = DbHelper.TABLE_NOTES \n         val statement = db.compileStatement( \n           \"DELETE FROM $table WHERE ${DbHelper.ID} IN ($ids);\" \n         ) \n         val count = statement.executeUpdateDelete() \n         val success = count > 0 \n         if (success) { \n           db.setTransactionSuccessful() \n           Log.i(tag, \"Delete [ SUCCESS ][ $count ][ $statement ]\") \n         } else { \n            Log.w(tag, \"Delete [ FAILED ][ $statement ]\") \n         } \n          db.endTransaction() \n          db.close() \n          return count \n        } \n        ... \n     } \n     ... \n     val TODO = object : Crud<Todo> { \n       ... \n       override fun delete(what: Todo): Int = delete(listOf(what)) \n       override fun delete(what: Collection<Todo>): Int { \n         val db = DbHelper(name, version).writableDatabase \n         db.beginTransaction() \n         val ids = StringBuilder() \n         what.forEachIndexed { index, item -> \n         ids.append(item.id.toString()) \n            if (index < what.size - 1) { \n                ids.append(\", \") \n            } \n        } \n        val table = DbHelper.TABLE_TODOS \n        val statement = db.compileStatement( \n          \"DELETE FROM $table WHERE ${DbHelper.ID} IN ($ids);\" \n        ) \n        val count = statement.executeUpdateDelete() \n        val success = count > 0 \n        if (success) { \n           db.setTransactionSuccessful() \n           Log.i(tag, \"Delete [ SUCCESS ][ $count ][ $statement ]\") \n        } else { \n           Log.w(tag, \"Delete [ FAILED ][ $statement ]\") \n        } \n         db.endTransaction() \n         db.close() \n         return count \n        } \n        ... \n    } \n    ...  \n```", "```kt\n     val NOTE = object : Crud<Note> { \n        ... \n        override fun select( \n            args: Pair<String, String> \n        ): List<Note> = select(listOf(args)) \n\n        override fun select(args: Collection<Pair<String, String>>):\n        List<Note> { \n          val db = DbHelper(name, version).writableDatabase \n          val selection = StringBuilder() \n          val selectionArgs = mutableListOf<String>() \n          args.forEach { arg -> \n              selection.append(\"${arg.first} == ?\") \n              selectionArgs.add(arg.second) \n          } \n          val result = mutableListOf<Note>() \n          val cursor = db.query( \n              true, \n              DbHelper.TABLE_NOTES, \n              null, \n              selection.toString(), \n              selectionArgs.toTypedArray(), \n              null, null, null, null \n          ) \n          while (cursor.moveToNext()) { \n          val id = cursor.getLong(cursor.getColumnIndexOrThrow\n          (DbHelper.ID)) \n          val titleIdx = cursor.getColumnIndexOrThrow\n          (DbHelper.COLUMN_TITLE) \n          val title = cursor.getString(titleIdx) \n          val messageIdx = cursor.getColumnIndexOrThrow\n          (DbHelper.COLUMN_MESSAGE) \n          val message = cursor.getString(messageIdx) \n          val latitudeIdx = cursor.getColumnIndexOrThrow( \n             DbHelper.COLUMN_LOCATION_LATITUDE \n          ) \n          val latitude = cursor.getDouble(latitudeIdx) \n          val longitudeIdx = cursor.getColumnIndexOrThrow( \n             DbHelper.COLUMN_LOCATION_LONGITUDE \n          ) \n          val longitude = cursor.getDouble(longitudeIdx) \n          val location = Location(\"\") \n          location.latitude = latitude \n          location.longitude = longitude \n          val note = Note(title, message, location) \n          note.id = id \n          result.add(note) \n        } \n          cursor.close() \n          return result \n       } \n\n       override fun selectAll(): List<Note> { \n         val db = DbHelper(name, version).writableDatabase \n         val result = mutableListOf<Note>() \n         val cursor = db.query( \n            true, \n            DbHelper.TABLE_NOTES, \n            null, null, null, null, null, null, null \n         ) \n         while (cursor.moveToNext()) { \n                val id = cursor.getLong(cursor.getColumnIndexOrThrow\n               (DbHelper.ID)) \n                val titleIdx = cursor.getColumnIndexOrThrow\n                (DbHelper.COLUMN_TITLE) \n                val title = cursor.getString(titleIdx) \n                val messageIdx = cursor.getColumnIndexOrThrow\n                (DbHelper.COLUMN_MESSAGE) \n                val message = cursor.getString(messageIdx) \n                val latitudeIdx = cursor.getColumnIndexOrThrow( \n                  DbHelper.COLUMN_LOCATION_LATITUDE \n                ) \n                val latitude = cursor.getDouble(latitudeIdx) \n                val longitudeIdx = cursor.getColumnIndexOrThrow( \n                   DbHelper.COLUMN_LOCATION_LONGITUDE \n                ) \n                val longitude = cursor.getDouble(longitudeIdx) \n                val location = Location(\"\") \n                location.latitude = latitude \n                location.longitude = longitude \n                val note = Note(title, message, location) \n                note.id = id \n                result.add(note) \n              } \n             cursor.close() \n             return result \n            } \n            ... \n          } \n          ... \n       val TODO = object : Crud<Todo> { \n        ... \n        override fun select(args: Pair<String, String>): List<Todo> =\n        select(listOf(args)) \n\n        override fun select(args: Collection<Pair<String, String>>): \n        List<Todo> { \n          val db = DbHelper(name, version).writableDatabase \n          val selection = StringBuilder() \n          val selectionArgs = mutableListOf<String>() \n          args.forEach { arg -> \n             selection.append(\"${arg.first} == ?\") \n             selectionArgs.add(arg.second) \n          } \n          val result = mutableListOf<Todo>() \n          val cursor = db.query( \n             true, \n             DbHelper.TABLE_NOTES, \n             null, \n             selection.toString(), \n             selectionArgs.toTypedArray(), \n             null, null, null, null \n            ) \n            while (cursor.moveToNext()) { \n                val id = cursor.getLong(cursor.getColumnIndexOrThrow\n                (DbHelper.ID)) \n                val titleIdx = cursor.getColumnIndexOrThrow\n                (DbHelper.COLUMN_TITLE) \n                val title = cursor.getString(titleIdx) \n                val messageIdx = cursor.getColumnIndexOrThrow\n                (DbHelper.COLUMN_MESSAGE) \n                val message = cursor.getString(messageIdx) \n                val latitudeIdx = cursor.getColumnIndexOrThrow( \n                    DbHelper.COLUMN_LOCATION_LATITUDE \n                ) \n                val latitude = cursor.getDouble(latitudeIdx) \n                val longitudeIdx = cursor.getColumnIndexOrThrow( \n                    DbHelper.COLUMN_LOCATION_LONGITUDE \n                ) \n                val longitude = cursor.getDouble(longitudeIdx) \n                val location = Location(\"\") \n                val scheduledForIdx = cursor.getColumnIndexOrThrow( \n                    DbHelper.COLUMN_SCHEDULED \n                ) \n                val scheduledFor = cursor.getLong(scheduledForIdx) \n                location.latitude = latitude \n                location.longitude = longitude \n                val todo = Todo(title, message, location, scheduledFor) \n                todo.id = id \n                result.add(todo) \n               } \n              cursor.close() \n              return result \n            } \n\n            override fun selectAll(): List<Todo> { \n            val db = DbHelper(name, version).writableDatabase \n            val result = mutableListOf<Todo>() \n            val cursor = db.query( \n              true, \n              DbHelper.TABLE_NOTES, \n              null, null, null, null, null, null, null \n            ) \n            while (cursor.moveToNext()) { \n                val id = cursor.getLong(cursor.getColumnIndexOrThrow\n                (DbHelper.ID)) \n                val titleIdx = cursor.getColumnIndexOrThrow\n                (DbHelper.COLUMN_TITLE) \n                val title = cursor.getString(titleIdx) \n                val messageIdx = cursor.getColumnIndexOrThrow\n                (DbHelper.COLUMN_MESSAGE) \n                val message = cursor.getString(messageIdx) \n                val latitudeIdx = cursor.getColumnIndexOrThrow( \n                    DbHelper.COLUMN_LOCATION_LATITUDE \n                ) \n                val latitude = cursor.getDouble(latitudeIdx) \n                val longitudeIdx = cursor.getColumnIndexOrThrow( \n                    DbHelper.COLUMN_LOCATION_LONGITUDE \n                ) \n                val longitude = cursor.getDouble(longitudeIdx) \n                val location = Location(\"\") \n                val scheduledForIdx = cursor.getColumnIndexOrThrow( \n                    DbHelper.COLUMN_SCHEDULED \n                ) \n                val scheduledFor = cursor.getLong(scheduledForIdx) \n                location.latitude = latitude \n                location.longitude = longitude \n                val todo = Todo(title, message, location, scheduledFor) \n                todo.id = id \n                result.add(todo) \n              } \n              cursor.close() \n               return result \n             } \n             ... \n        } \n        ... \n```", "```kt\n     object LocationProvider { \n       private val tag = \"Location provider\" \n       private val listeners =   CopyOnWriteArrayList\n       <WeakReference<LocationListener>>() \n\n       private val locationListener = object : LocationListener { \n       ... \n       } \n\n      fun subscribe(subscriber: LocationListener): Boolean { \n        val result = doSubscribe(subscriber) \n        turnOnLocationListening() \n        return result \n      } \n\n      fun unsubscribe(subscriber: LocationListener): Boolean { \n        val result = doUnsubscribe(subscriber) \n        if (listeners.isEmpty()) { \n            turnOffLocationListening() \n        } \n        return result \n      } \n\n      private fun turnOnLocationListening() { \n      ... \n      } \n\n      private fun turnOffLocationListening() { \n      ... \n      } \n\n      private fun doSubscribe(listener: LocationListener): Boolean { \n      ... \n      } \n\n      private fun doUnsubscribe(listener: LocationListener): Boolean { \n       ... \n      } \n    } \n```", "```kt\n     private val locationListener = object : LocationListener { \n        override fun onLocationChanged(location: Location) { \n            Log.i( \n                    tag, \n                    String.format( \n                            Locale.ENGLISH, \n                            \"Location [ lat: %s ][ long: %s ]\",\n                            location.latitude, location.longitude \n                    ) \n            ) \n            val iterator = listeners.iterator() \n            while (iterator.hasNext()) { \n                val reference = iterator.next() \n                val listener = reference.get() \n                listener?.onLocationChanged(location) \n            } \n         } \n\n        override fun onStatusChanged(provider: String, status: Int,\n        extras: Bundle) { \n            Log.d( \n                    tag, \n                    String.format(Locale.ENGLISH, \"Status changed [ %s\n                    ][ %d ]\", provider, status) \n            ) \n            val iterator = listeners.iterator() \n            while (iterator.hasNext()) { \n                val reference = iterator.next() \n                val listener = reference.get() \n                listener?.onStatusChanged(provider, status, extras) \n            } \n        } \n\n        override fun onProviderEnabled(provider: String) { \n            Log.i(tag, String.format(\"Provider [ %s ][ ENABLED ]\",\n            provider)) \n            val iterator = listeners.iterator() \n            while (iterator.hasNext()) { \n                val reference = iterator.next() \n                val listener = reference.get() \n                listener?.onProviderEnabled(provider) \n            } \n        } \n\n        override fun onProviderDisabled(provider: String) { \n            Log.i(tag, String.format(\"Provider [ %s ][ ENABLED ]\",\n            provider)) \n            val iterator = listeners.iterator() \n            while (iterator.hasNext()) { \n                val reference = iterator.next() \n                val listener = reference.get() \n                listener?.onProviderDisabled(provider) \n            } \n          } \n         } \n```", "```kt\n    turnOnLocationListening(): \n\n    private fun turnOnLocationListening() { \n       Log.v(tag, \"We are about to turn on location listening.\") \n       val ctx = Journaler.ctx \n       if (ctx != null) { \n            Log.v(tag, \"We are about to check location permissions.\") \n\n            val permissionsOk = \n            ActivityCompat.checkSelfPermission(ctx,\n            Manifest.permission.ACCESS_FINE_LOCATION) ==  \n            PackageManager.PERMISSION_GRANTED  \n            &&  \n            ActivityCompat.checkSelfPermission(ctx, \n            Manifest.permission.ACCESS_COARSE_LOCATION) ==\n            PackageManager.PERMISSION_GRANTED \n\n            if (!permissionsOk) { \n                throw IllegalStateException( \n                \"Permissions required [ ACCESS_FINE_LOCATION ]\n                 [ ACCESS_COARSE_LOCATION ]\" \n                ) \n            } \n            Log.v(tag, \"Location permissions are ok. \n            We are about to request location changes.\") \n            val locationManager =\n            ctx.getSystemService(Context.LOCATION_SERVICE)\n            as LocationManager \n\n            val criteria = Criteria() \n            criteria.accuracy = Criteria.ACCURACY_FINE \n            criteria.powerRequirement = Criteria.POWER_HIGH \n            criteria.isAltitudeRequired = false \n            criteria.isBearingRequired = false \n            criteria.isSpeedRequired = false \n            criteria.isCostAllowed = true \n\n            locationManager.requestLocationUpdates( \n                    1000, 1F, criteria, locationListener, \n                    Looper.getMainLooper() \n            ) \n            } else { \n             Log.e(tag, \"No application context available.\") \n          } \n        } \n```", "```kt\n     turnOffLocationListening():private fun turnOffLocationListening() \n     { \n       Log.v(tag, \"We are about to turn off location listening.\") \n       val ctx = Journaler.ctx \n       if (ctx != null) { \n         val locationManager =  \n         ctx.getSystemService(Context.LOCATION_SERVICE)\n         as LocationManager \n\n         locationManager.removeUpdates(locationListener) \n        } else { \n            Log.e(tag, \"No application context available.\") \n        } \n     } \n```", "```kt\n      private fun doSubscribe(listener: LocationListener): Boolean { \n        val iterator = listeners.iterator() \n        while (iterator.hasNext()) { \n          val reference = iterator.next() \n          val refListener = reference.get() \n          if (refListener != null && refListener === listener) { \n                Log.v(tag, \"Already subscribed: \" + listener) \n                return false \n            } \n         } \n         listeners.add(WeakReference(listener)) \n         Log.v(tag, \"Subscribed, subscribers count: \" + listeners.size) \n         return true \n      }  \n```", "```kt\n      private fun doUnsubscribe(listener: LocationListener): Boolean { \n        var result = true \n        val iterator = listeners.iterator() \n        while (iterator.hasNext()) { \n            val reference = iterator.next() \n            val refListener = reference.get() \n            if (refListener != null && refListener === listener) { \n                val success = listeners.remove(reference) \n                if (!success) { \n                    Log.w(tag, \"Couldn't un subscribe, subscribers\n                    count: \" + listeners.size) \n                } else { \n                    Log.v(tag, \"Un subscribed, subscribers count: \" +\n                    listeners.size) \n                } \n                if (result) { \n                    result = success \n                } \n               } \n             } \n            return result \n        } \n```", "```kt\n     class NoteActivity : ItemActivity() { \n       private var note: Note? = null \n       override val tag = \"Note activity\" \n       private var location: Location? = null \n       override fun getLayout() = R.layout.activity_note \n\n      private val textWatcher = object : TextWatcher { \n        override fun afterTextChanged(p0: Editable?) { \n            updateNote() \n        } \n\n        override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2:\n        Int, p3: Int) {} \n        override fun onTextChanged(p0: CharSequence?, p1: Int, p2:\n        Int, p3: Int) {} \n      } \n\n      private val locationListener = object : LocationListener { \n        override fun onLocationChanged(p0: Location?) { \n            p0?.let { \n                LocationProvider.unsubscribe(this) \n                location = p0 \n                val title = getNoteTitle() \n                val content = getNoteContent() \n                note = Note(title, content, p0) \n                val task = object : AsyncTask<Note, Void, Boolean>() { \n                    override fun doInBackground(vararg params: Note?):\n                    Boolean { \n                        if (!params.isEmpty()) { \n                            val param = params[0] \n                            param?.let { \n                                return Db.NOTE.insert(param) > 0 \n                            } \n                        } \n                        return false \n                    } \n\n                    override fun onPostExecute(result: Boolean?) { \n                        result?.let { \n                            if (result) { \n                                Log.i(tag, \"Note inserted.\") \n                            } else { \n                                Log.e(tag, \"Note not inserted.\") \n                            } \n                        } \n                     } \n                  } \n                task.execute(note) \n              } \n          } \n\n         override fun onStatusChanged(p0: String?, p1: Int, p2:\n         Bundle?) {} \n         override fun onProviderEnabled(p0: String?) {} \n         override fun onProviderDisabled(p0: String?) {} \n        } \n\n        override fun onCreate(savedInstanceState: Bundle?) { \n          super.onCreate(savedInstanceState) \n          note_title.addTextChangedListener(textWatcher) \n          note_content.addTextChangedListener(textWatcher) \n        } \n\n       private fun updateNote() { \n         if (note == null) { \n          if (!TextUtils.isEmpty(getNoteTitle()) &&\n          !TextUtils.isEmpty(getNoteContent())) { \n             LocationProvider.subscribe(locationListener) \n          } \n         } else { \n            note?.title = getNoteTitle() \n            note?.message = getNoteContent() \n            val task = object : AsyncTask<Note, Void, Boolean>() { \n                override fun doInBackground(vararg params: Note?):\n            Boolean { \n              if (!params.isEmpty()) { \n                 val param = params[0] \n                 param?.let { \n                   return Db.NOTE.update(param) > 0 \n                  } \n                } \n                  return false \n              } \n\n              override fun onPostExecute(result: Boolean?) { \n                result?.let { \n                   if (result) { \n                       Log.i(tag, \"Note updated.\") \n                   } else { \n                       Log.e(tag, \"Note not updated.\") \n                   } \n                 } \n               } \n            } \n            task.execute(note) \n          } \n       } \n\n       private fun getNoteContent(): String { \n         return note_content.text.toString() \n       } \n\n       private fun getNoteTitle(): String { \n         return note_title.text.toString() \n       } \n\n     } \n```", "```kt\n    I/Note activity: Note inserted. \n    I/Note activity: Note updated. \n    I/Note activity: Note updated. \n    I/Note activity: Note updated. \n```"]