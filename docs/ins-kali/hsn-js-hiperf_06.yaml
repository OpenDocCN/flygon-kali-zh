- en: Message Passing - Learning about the Different Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息传递 - 了解不同类型
- en: In the previous chapter, we looked at Node.js and the base environment we need
    to create server-side applications. Now, we will look at how we can use the communication
    techniques we looked at previously to write scalable systems. Message passing
    is a great way for applications to be decoupled yet still work together. This
    means that we can create modules that work independently from each other, either
    through processes or threads, and still achieve a common goal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了Node.js和我们需要创建服务器端应用程序的基本环境。现在，我们将看看如何利用我们之前学习的通信技术来编写可扩展的系统。消息传递是应用程序解耦但仍然能够共同工作的一种很好的方式。这意味着我们可以创建相互独立工作的模块，无论是通过进程还是线程，仍然可以实现共同的目标。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Local communication using the net module
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用net模块进行本地通信
- en: Utilizing the network
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用网络
- en: A quick glance at HTTP/3
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速浏览HTTP/3
- en: We will also take a look at the future of client/server communication while
    looking at the HTTP/3 standard that is being developed. Then, we will look at
    the implementation of the QUIC protocol, a protocol developed by Google that HTTP/3
    takes some of its ideas from.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在查看正在开发的HTTP/3标准时，了解客户端/服务器通信的未来。然后，我们将查看QUIC协议的实现，这是由Google开发的协议，HTTP/3从中汲取了一些想法。
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you''ll need the following technical requirements:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将需要以下技术要求：
- en: An IDE or code editor (VS Code is preferred)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个IDE或代码编辑器（首选VS Code）
- en: A running Node.js environment
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行中的Node.js环境
- en: OpenSSL or the ability to install Cygwin
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSL或安装Cygwin的能力
- en: This chapter's code, which can be found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter06).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter06)找到。
- en: Local communication using the net module
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用net模块进行本地通信
- en: While many applications can run on a single thread and utilize the event loop
    to run, when we are writing server applications we will want to try and utilize
    all of the cores that we have available to us. We can do this through the use
    of **processes** or **threads**. In most cases, we are going to want to use threads
    since they are lighter and faster to start.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多应用程序可以在单个线程上运行并利用事件循环来运行，但当我们编写服务器应用程序时，我们将希望尽量利用我们可用的所有核心。我们可以通过使用**进程**或**线程**来实现这一点。在大多数情况下，我们将希望使用线程，因为它们更轻量级且启动速度更快。
- en: We can find out whether we need a process or a thread based on whether we need
    to have the subsystem still running if the main system dies. If we don't care,
    we should utilize a thread, but if we need to have that subsystem still running
    even after the main process dies, we should utilize a decoupled process. This
    is only one way of thinking about when to use a process or a thread, but it is
    a good indicator.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据我们是否需要在主系统死机后仍然运行子系统来确定我们是否需要进程还是线程。如果我们不在乎，我们应该利用线程，但如果我们需要在主进程死机后仍然运行该子系统，我们应该利用一个解耦的进程。这只是考虑何时使用进程或线程的一种方式，但它是一个很好的指标。
- en: In both the browser and Node.js, we have web workers that take the place of
    threads in traditional systems. While they have many of the same concepts as the
    threads of other languages, they are unable to share state (in our case, this
    is preferred).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器和Node.js中，我们有Web Workers来代替传统系统中的线程。虽然它们与其他语言的线程有许多相同的概念，但它们无法共享状态（在我们的情况下，这是首选）。
- en: There's a way to share state between workers. This can be done through `SharedArrayBuffer`.
    While we can utilize this to share state, we want to highlight that the event
    system and IPC are almost always fast enough to move state and coordinate between
    different pieces. Also, we don't have to deal with concepts such as locks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以在worker之间共享状态。这可以通过`SharedArrayBuffer`来实现。虽然我们可以利用这一点来共享状态，但我们要强调事件系统和IPC几乎总是足够快，可以在不同的部分之间移动状态和协调。此外，我们不必处理锁等概念。
- en: 'To start up a worker, we need to call `new Worker(<script here>)`. Let''s go
    over this concept:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个worker，我们需要调用`new Worker(<script here>)`。让我们来看看这个概念：
- en: 'Create a file called `Main_Worker.js` and add the following code to it:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Main_Worker.js`的文件，并将以下代码添加到其中：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a file called `worker.js` and add the following code to it:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`worker.js`的文件，并将以下代码添加到其中：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, this system is similar to the one in the browser. First, we import
    the worker from the `worker_threads` module. Then, we start it up. The thread
    will start, which means we post messages to it and listen for events, similar
    to the way we were able to with processes in the previous chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个系统与浏览器中的系统类似。首先，我们从`worker_threads`模块中导入worker。然后，我们启动它。线程将启动，这意味着我们可以向其发送消息并监听事件，就像我们在上一章中能够与进程一样。
- en: Inside of the `worker.js` file, we import the `parentPort` message channels
    from the `worker_threads` module. We listen and pass messages the same way as
    the parent does. Once we receive a message, we state that we received the message.
    The parent then terminates us and we print out that we have been terminated.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在`worker.js`文件中，我们从`worker_threads`模块中导入`parentPort`消息通道。我们监听并传递消息的方式与父级相同。一旦我们收到消息，我们就会声明我们收到了消息。然后父级终止我们，我们打印出我们已经被终止。
- en: Now, this form of message passing is perfectly fine if we want to tightly couple
    all of our subsystems together. But what if we want different threads to have
    different jobs? We could have one that just caches data for us. Another one could
    potentially make requests for us. Finally, our main thread (the starting process)
    can move all of this data and take in data from the command line.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要紧密耦合所有子系统，这种形式的消息传递是完全可以的。但是，如果我们希望不同的线程有不同的工作，该怎么办？我们可以有一个只为我们缓存数据的线程。另一个可能为我们发出请求。最后，我们的主线程（起始进程）可以移动所有这些数据并从命令行中接收数据。
- en: 'To do all of this, we could simply use the built-in system. Alternatively,
    we could utilize the mechanism that we looked at in the previous chapter. Not
    only does this give us a highly scalable system, but it also allows us to change
    these various subsystems from threads into processes if we need to. This also
    allows us to write these separate subsystems in another language, if needed. Let''s
    go over this now:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到所有这些，我们可以简单地使用内置系统。或者，我们可以利用我们在上一章中看到的机制。这不仅使我们拥有高度可扩展的系统，还允许我们将这些各个子系统从线程转换为进程，如果需要的话。这也允许我们在需要时用另一种语言编写这些单独的子系统。现在让我们来看一下：
- en: 'Let''s go ahead and make this system. We are going to create four files: `main.js`,
    `cache.js`, `send.js`, and `package.json`. Our `package.json` file should look
    something like this:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续制作这个系统。我们将创建四个文件：`main.js`，`cache.js`，`send.js`和`package.json`。我们的`package.json`文件应该看起来像这样：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, add the following code to the `cache.js` file:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下代码添加到`cache.js`文件中：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is definitely not a foolproof mechanism for handling streaming data. `!!!BEGIN!!!`
    and other command messages could be chunked and we would never see them. While
    we are keeping this simple, remember that production-level streaming needs to
    handle all of these types of issues.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对不是处理流数据的万无一失的机制。`!!!BEGIN!!!`和其他命令消息可能会被分块，我们永远看不到它们。虽然我们保持简单，但要记住，生产级别的流处理需要处理所有这些类型的问题。
- en: 'The `cache` submodule checks for different headers on the message. Depending
    on each type, we will do that type of action. This can be thought of as a simple
    way to do remote procedure calls. The following list describes what we do, depending
    on each event:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache`子模块检查消息上的不同标头。根据每种类型，我们将执行该类型的操作。这可以被视为一种简单的远程过程调用。以下列表描述了我们根据每个事件所做的操作：'
- en: '`!!!BEGIN!!!`: We need to start listening for more data on the line since this
    means we are going to store the data.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!!!BEGIN!!!`：我们需要开始监听线路上的更多数据，因为这意味着我们将存储数据。'
- en: '`!!!END!!!`: Once we see this message, we can put all of this data together
    and store it, based on our count in the cache.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!!!END!!!`：一旦我们看到这条消息，我们就可以将所有这些数据放在一起并根据缓存中的计数存储它。'
- en: '`!!!GET!!!`: We are going to try to get the file stored at the numbered location
    that''s supplied to us by the server.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!!!GET!!!`：我们将尝试获取由服务器提供给我们的编号位置存储的文件。'
- en: '`!!!DELETE!!!`: If the length of the message is as long as this string, this
    means we want to delete everything from the cache. Otherwise, we will try to delete
    the data at the location specified later in the message.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!!!DELETE!!!`：如果消息的长度与此字符串一样长，这意味着我们想要从缓存中删除所有内容。否则，我们将尝试删除稍后在消息中指定的位置的数据。'
- en: 'Add the following code to the `send.js` file:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`send.js`文件中：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For each of the submodules that we have, we handle specific commands that may
    come across the wire. As shown by the `send` submodule, we handle anything on
    the wire other than the `WHOIS` command, which tells the main application who
    is connected to it. We try to grab the file from the specified address and write
    it back to the main application so that it's stored in the cache.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们拥有的每个子模块，我们处理可能通过网络传输的特定命令。正如`send`子模块所示，我们处理除了`WHOIS`命令之外的任何网络传输，该命令告诉主应用程序谁连接到它。我们尝试从指定的地址获取文件并将其写回主应用程序，以便将其存储在缓存中。
- en: We also added our own *protocol* to send the data. While this system is not
    foolproof and we should add some type of locking (such as a Boolean, so that we
    don't try to take in any more data before fully sending out the current data),
    it does showcase how we can send data across our system. In [Chapter 7](81cf1aa1-6ded-4d94-8686-e2bd65db6a8c.xhtml),
    *Streams - Understanding Streams and Non-Blocking I/O*, we will look at a similar
    concept, but we will utilize streams so that we don't use so much memory per thread.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了我们自己的*协议*来发送数据。虽然这个系统并非万无一失，我们应该添加某种类型的锁定（比如一个布尔值，这样我们在完全发送当前数据之前不会尝试接收更多数据），但它展示了我们如何在系统中发送数据。在[第7章](81cf1aa1-6ded-4d94-8686-e2bd65db6a8c.xhtml)中，*流-理解流和非阻塞I/O*，我们将看到一个类似的概念，但我们将利用流，这样我们就不会在每个线程中使用太多内存。
- en: As we can see, we're only importing the `https` module. This means that we are
    only allowed to make requests to addresses that are served over HTTPS. If we wanted
    to support HTTP, we would have to import the `http` module and then check the
    address that the user types in. In our case, we made it as simple as possible.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们只导入了`https`模块。这意味着我们只能向通过HTTPS提供的地址发出请求。如果我们想要支持HTTP，我们将不得不导入`http`模块，然后检查用户输入的地址。在我们的情况下，我们尽可能地简化了它。
- en: When we want to send data, we send the `!!!BEGIN!!!` message to let the receiver
    know that we are about to send data that will not fit into a single frame. Then,
    we end our message with the `!!!END!!!` message.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要发送数据时，我们发送`!!!BEGIN!!!`消息，以让接收方知道我们将发送无法适应单个帧的数据。然后，我们用`!!!END!!!`消息结束我们的消息。
- en: If we can't read the endpoint that we are trying to grab or our connection times
    out (both of these will drop into the error condition), we will send a `!!!FALSE!!!`
    message to let the receiver know that we are unable to fully transmit the data.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法读取我们尝试抓取的端点或者我们的连接超时（这两种情况都会进入错误条件），我们将发送`!!!FALSE!!!`消息，以让接收方知道我们无法完全传输数据。
- en: This concept of wrapping our data in *frames* is used in almost all data transmission
    systems. Without framing, we would have to send a header that says how large the
    data transmission is. However that would mean we need to know the size of the
    content before we send it. Framing gives us the option of not sending the length
    of messages, so we can process infinitely large messages.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有数据传输系统中，都使用了将我们的数据包装在*帧*中的概念。没有帧，我们将不得不发送一个标头，说明数据传输的大小。然而，这意味着我们需要在发送之前知道内容的大小。帧给了我们选择不发送消息的长度的选项，因此我们可以处理无限大的消息。
- en: Framing or even boxing the data is done everywhere. If we were to look at how
    packets are created, for example, the concept still applies. Understanding this
    concept is key to understanding lower levels of the communication stack. Another
    concept that is good to know about is that not all of this data is sent at once.
    It is sent in pieces. The amount that can be sent at one time is usually set at
    the operating system level. One of the only properties that we can set is the
    `highWaterMark` property on streams. This property allows us to say how much data
    we will hold in memory before we stop reading/writing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何地方都会对数据进行包装或装箱。例如，如果我们看一下如何创建数据包，这个概念仍然适用。理解这个概念是理解通信堆栈的较低层次的关键。另一个需要了解的概念是，并非所有数据都一次性发送。它是分批发送的。一次可以发送的数量通常在操作系统级别设置。我们可以设置的唯一属性之一是流的`highWaterMark`属性。该属性允许我们说出在停止读取/写入之前我们将在内存中保存多少数据。
- en: The cache application acts similar to the send submodule, except it responds
    to more commands. If we get a `get` command, we can try and grab that item from
    the cache and send it back to the main module; otherwise, we just send back `null`.
    If we get a `delete` command, we will delete the entire cache if we get no other
    arguments; otherwise, we delete the item at that specific location. Finally, if
    we get the beginning or ending wrappers, we will process the data and cache it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存应用程序类似于发送子模块，只是它响应更多的命令。如果我们收到一个`get`命令，我们可以尝试从缓存中获取该项并将其发送回主模块；否则，我们只是发送回`null`。如果我们收到一个`delete`命令，如果没有其他参数，我们将删除整个缓存；否则，我们将删除特定位置的项目。最后，如果我们收到开始或结束包装，我们将处理数据并将其缓存。
- en: Currently, we infinitely increase our cache. We could easily add a concept of
    a certain time threshold that is allowed for data to stay in the cache (**Time
    To Live** or **TTL**) or only hold a certain number of records, usually by utilizing
    a **Least Recently Used** (**LRU**) destroy system. We will look at how to implement
    caching strategies in [Chapter 9](bbac23b7-12e2-412e-9aaa-f31b1c321dab.xhtml),
    *Practical Example - Building a Static Server*. Just note that these concepts
    are quite ubiquitous with caches and caching strategies.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的缓存是无限增加的。我们可以很容易地添加一个允许数据在缓存中停留的一定时间阈值（**生存时间**或**TTL**），或者只保留一定数量的记录，通常通过利用**最近最少使用**（**LRU**）销毁系统。我们将看看如何在[第9章](bbac23b7-12e2-412e-9aaa-f31b1c321dab.xhtml)中实现缓存策略，*实际示例
    - 构建静态服务器*。只需注意，这些概念在缓存和缓存策略中是非常普遍的。
- en: 'Heading back into the code, create `main.js` and add the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码中，创建`main.js`并添加以下代码：
- en: 'Create placeholders for our state variables. These correspond to the various
    states that our messages could be in and the data that is passing through the
    socket:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的状态变量创建占位符。这些对应于我们的消息可能处于的各种状态以及通过套接字传递的数据：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create the method to handle data that comes in through our cache:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建处理通过我们的缓存传入的数据的方法：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, add the method that will handle the messages from our `send` worker:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个方法来处理我们的`send`工作进程发送的消息：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create two final helper methods. These will test the number of workers we have
    to know when we are ready to start and the other will add the method handlers
    to each worker socket:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个最终的辅助方法。这些方法将测试我们拥有的工作进程数量，以便知道何时准备就绪，另一个将向每个工作进程套接字添加方法处理程序：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The final large method will handle all of the messages that we receive via
    the command-line:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的大型方法将处理我们通过命令行接收到的所有消息：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, create the server and start the workers:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建服务器并启动工作进程：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Certain parts of the main file have been removed to shorten the amount of code
    in this book. The full example can be found in this book's GitHub repository.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缩短本书中的代码量，主文件的某些部分已被删除。完整的示例可以在本书的GitHub存储库中找到。
- en: Here, we have a bunch of helpers that will handle messages from the cache and
    send subsystems. We also map the socket to our handler. The utilization of a `WeakMap`
    means that we don't need to clean up if these subsystems ever crash or are somehow
    removed. We also map the name of the subsystem to the socket so that we can easily
    send messages to the correct subsystem. Finally, we create a server and handle
    the incoming connections. In our case, we only want to check for two subsystems.
    Once we can see two, we start our program.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一堆辅助程序，将处理来自缓存和发送子系统的消息。我们还将套接字映射到我们的处理程序。使用`WeakMap`的好处是，如果这些子系统崩溃或以某种方式被移除，我们就不需要清理。我们还将子系统的名称映射到套接字，以便我们可以轻松地向正确的子系统发送消息。最后，我们创建一个服务器并处理传入的连接。在我们的情况下，我们只想检查两个子系统。一旦我们看到两个，我们就启动我们的程序。
- en: There are some flaws in the way we wrap our messages, and testing the number
    of connections to see whether we are ready is also not the best way to handle
    our program. However, this does allow us to create a somewhat complex application
    so that we can quickly test the ideas that can be seen here. With this application,
    we are now able to cache various files from a remote resource and grab them when
    we want them. This is a system that is similar to how some static servers work.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包装消息的方式存在一些缺陷，测试连接数量以查看我们是否准备就绪也不是处理程序的最佳方式。然而，这确实使我们能够创建一个相当复杂的应用程序，以便我们可以快速测试这里所见的想法。有了这个应用程序，我们现在能够从远程资源缓存各种文件，并在需要时获取它们。这是一种类似于某些静态服务器工作方式的系统。
- en: By looking at the preceding application, it is easy to see how we can utilize
    local connections to create a message-passing system with only the core Node.js
    system. What is also interesting is that we can replace the `listen` method's
    argument from a pipe name with a port number and we would be able to turn this
    application from utilizing named pipes/Unix domain sockets to utilizing TCP sockets.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看前面的应用程序，很容易看出我们可以利用本地连接来创建一个只使用核心Node.js系统的消息传递系统。同样有趣的是，我们可以将`listen`方法的参数从管道名称替换为端口号，这样我们就可以将这个应用程序从使用命名管道/Unix域套接字转换为使用TCP套接字。
- en: Before we had these worker threads inside of Node.js, we had to separate everything
    out with processes. In the beginning, we only had the fork system. This made some
    systems quite complex when we started creating more processes. To help us with
    this concept, the `cluster` module was created. With the `cluster` module, it's
    easier to manage processes in a master/slave architecture.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中有这些工作线程之前，我们必须用进程将所有东西分开。起初，我们只有fork系统。当我们开始创建更多的进程时，这使得一些系统变得非常复杂。为了帮助我们理解这个概念，创建了`cluster`模块。使用`cluster`模块，更容易管理主/从架构中的进程。
- en: Understanding the cluster module
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解cluster模块
- en: While the `cluster` module may not be used as much as it was in the past, since
    we have worker threads inside of Node.js, one concept still makes it powerful.
    We are able to share server connections between the various worker threads that
    are in our application. Our main process will use a strategy so that we only send
    requests to one of the slave processes. This allows us to handle quite a few simultaneous
    connections that are all running on the exact same address and port.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`cluster`模块可能不像过去那样经常使用，因为我们在Node.js中有工作线程，但仍有一个概念使其强大。我们能够在应用程序中的各个工作线程之间共享服务器连接。我们的主进程将使用一种策略，以便我们只向其中一个从进程发送请求。这使我们能够处理许多同时运行在完全相同的地址和端口上的连接。
- en: 'With this concept, let''s implement the preceding program but by utilizing
    the `cluster` module. Now, we will ensure the send and cache subsystems are tied
    to the main process. Our child processes will be tied to handling requests that
    come over our server. One thing to remember is that if the parent process dies,
    our child processes will also die. If we don''t want this behavior, when we call
    the fork inside our main process, we can pass the `detached : true` option. This
    will allow the worker threads to still run. This is usually not a behavior that
    we want when we are using the `cluster` module, but it is good to know that it''s
    available.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '有了这个概念，让我们利用`cluster`模块来实现前面的程序。现在，我们将确保发送和缓存子系统与主进程绑定。我们的子进程将负责处理通过我们的服务器传入的请求。要记住的一件事是，如果父进程死亡，我们的子进程也会死亡。如果我们不希望出现这种行为，在我们的主进程内调用fork时，我们可以传递`detached
    : true`选项。这将允许工作线程继续运行。这通常不是我们在使用`cluster`模块时想要的行为，但知道它是可用的是很好的。'
- en: We have split up the following program into more manageable chunks. To see the
    full program, head over to the code repository for this chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将以下程序分成更易管理的块。要查看完整的程序，请转到本章的代码存储库。
- en: 'Now, we should be able to write a program that''s similar to our IPC program.
    Let''s take a look:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够编写一个类似于我们的IPC程序的程序。让我们来看一下：
- en: 'First, we will import all of the Node modules that are needed to implement
    our previous example in `cluster` mode:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入在`cluster`模式下实现我们之前示例所需的所有Node模块：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we set up the constants that we can use across our processes:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置可以在各个进程中使用的常量：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After, we add an `if/else` check to see whether we are the master process or
    whether we are a slave process. The same file is used for both types of processes,
    so we need a way to distinguish between the two:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个`if/else`检查，以查看我们是主进程还是从进程。同一文件用于两种类型的进程，因此我们需要一种区分两者的方法：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, write the master code. This will go into the first block of the `if/else`
    statement. Our master node needs to spin the slave nodes up, as well as initialize
    our cache:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写主代码。这将进入`if/else`语句的第一个块中。我们的主节点需要启动从节点，并初始化我们的缓存：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add some code that will handle each of the requests, just like we did in the
    previous example. Remember that if we stop our main process, it will destroy all
    of the slave processes. If we receive the `STOP` command, we will just kill the
    main process:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些代码来处理每个请求，就像我们在之前的例子中所做的那样。记住，如果我们停止主进程，它将销毁所有从进程。如果我们收到`STOP`命令，我们将只杀死主进程：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Write the `GRAB` case statement. To do this, utilize the `https` module to
    make the request for the resource:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`GRAB` case语句。为此，利用`https`模块请求资源：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we will write the slave code. All of this will be held in the `else` block.
    Remember that we can share the same server location and port between the slaves.
    We will also handle all incoming requests through the search parameters of the
    URL being passed to us. This is why we imported the `URL` class from the `url`
    module. Let''s get started:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写从节点代码。所有这些将保存在`else`块中。记住我们可以在从节点之间共享相同的服务器位置和端口。我们还将通过传递给我们的URL的搜索参数来处理所有传入的请求。这就是为什么我们从`url`模块导入了`URL`类。让我们开始吧：
- en: 'Start the slave code by starting an `HTTP` server. Remember that they will
    all share the same location and port:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过启动一个`HTTP`服务器来启动从节点代码。记住它们将共享相同的位置和端口：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can handle the command that''s been passed to us. This will be similar
    to our previous example, except we will talk to the master process through **Inter-Process
    Communication** (**IPC**) and handle the requests through the HTTP/2 server. Only
    the `get` command is shown here; the rest can be found in this chapter''s GitHub
    repository:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以处理传递给我们的命令。这将类似于我们之前的例子，只是我们将通过**进程间通信**（**IPC**）与主进程交谈，并通过HTTP/2服务器处理请求。这里只显示了`get`命令；其余内容可以在本章的GitHub存储库中找到：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we can see that both of the workers create an `HTTP` server. While they
    are both creating separate objects, they are sharing the underlying port. This
    is completely hidden from us, but this is done with the `cluster` module. If we
    tried doing something similar to this with our own version while utilizing the
    `child_process` fork method, we would get an error stating `EADDRINUSE`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到两个工作进程都创建了一个`HTTP`服务器。虽然它们都创建了独立的对象，但它们共享底层端口。这对我们来说完全是隐藏的，但这是通过`cluster`模块完成的。如果我们尝试使用自己的版本来做类似的事情，同时使用`child_process`的fork方法，我们将会收到一个错误，指出`EADDRINUSE`。
- en: If we request the data that we stored in HTML format, we'll see it come back
    as pure text. This is in relation to the `writeHead` method. We are telling the
    browser that we are writing `text/plain`. The browser takes this information and
    utilizes it to see how it needs to parse the data. Since it gets told that the
    data is plain, it will just display it on the screen. If we change that to `text/html`
    when we get HTML data, it will parse it and try to render it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们请求以HTML格式存储的数据，我们将看到它以纯文本形式返回。这涉及到`writeHead`方法。我们告诉浏览器我们正在写`text/plain`。浏览器接收这些信息并利用它来查看它需要如何解析数据。由于它被告知数据是纯文本，它将只是在屏幕上显示它。如果我们在获取HTML数据时将其更改为`text/html`，它将解析并尝试呈现它。
- en: With these two methods, we are able to write programs that can fully utilize
    all of the cores on our system while still being able to work together. The first
    architecture gives us a nice decoupled system and is how most applications should
    be written, but the `cluster` module gives us a nice way to handle servers. By
    mixing these two methods, we can create a high throughput server. While building
    these client/server applications can be easy in Node.js, there are some things
    to watch out for.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两种方法，我们能够编写能够充分利用系统上所有核心的程序，同时仍然能够协同工作。第一种架构为我们提供了一个良好的解耦系统，是大多数应用程序应该编写的方式，但`cluster`模块为我们提供了一个处理服务器的好方法。通过结合这两种方法，我们可以创建一个高吞吐量的服务器。在Node.js中构建这些客户端/服务器应用程序可能很容易，但也有一些需要注意的事项。
- en: Common pitfalls for new developers
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新开发人员常见的陷阱
- en: 'While utilizing the Unix domain sockets/Windows named pipes are great, there
    are a couple of differences between the two systems. Node.js tries to hide these
    details so that we can focus on the applications that we want to write, but they
    still show up. Two of the most common causes that can trip up new developers are
    as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Unix域套接字/Windows命名管道时，这两个系统之间存在一些差异。Node.js试图隐藏这些细节，以便我们可以专注于我们想要编写的应用程序，但它们仍然会显现出来。新开发人员可能会遇到的两个最常见的问题是：
- en: Windows named pipes will automatically be destroyed when the application quits.
    Unix domain sockets will not. This means that when we exit our application, we
    should try to utilize the `fs` module and unlink the file through the `unlink`
    or `unlinkSync` methods. We should also check to see whether it exists when we
    start up, just in case we don't exit gracefully.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows命名管道在应用程序退出时会自动销毁。Unix域套接字则不会。这意味着当我们退出应用程序时，我们应该尝试使用`fs`模块，并通过`unlink`或`unlinkSync`方法取消链接文件。我们还应该在启动时检查它是否存在，以防我们不能正常退出。
- en: Windows' framing of data can be larger than the Unix domain sockets. This means
    an application can appear to work on Windows but will fail on Unix systems. This
    is why we created the framing system that we did. It is good to keep this in mind,
    especially when we might want to use external libraries to handle parts of building
    the IPC systems. Some of these systems do not keep this idea in mind, and bugs
    can easily creep up because of this.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows的数据帧可能比Unix域套接字大。这意味着一个应用程序在Windows上可能正常工作，但在Unix系统上会失败。这就是我们创建我们所做的数据帧系统的原因。特别是当我们可能想要使用外部库来处理构建IPC系统的部分时，要牢记这一点是很重要的，因为一些系统并没有考虑到这一点，因此可能会很容易出现错误。
- en: Node.js aims to be completely cross-operating system compatible, but these systems
    always have slight quirks when it comes to actually operating across systems.
    If we want to make sure that it works, just like we have to do if we can't guarantee
    what browser our end users will use, then we need to test it on all of our systems.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的目标是完全跨操作系统兼容，但这些系统在实际跨系统操作时总是有一些小问题。如果我们想要确保它能够正常工作，就像我们必须在不能保证我们的最终用户将使用什么浏览器一样，那么我们需要在所有系统上进行测试。
- en: While developing server applications that span a single computer is common,
    we still need to hook all of these applications up. When we are no longer able
    to utilize a single computer, we will need to talk over the network. We'll take
    a look at these protocols next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然开发跨越单台计算机的服务器应用程序很常见，但我们仍然需要连接所有这些应用程序。当我们不能再使用单台计算机时，我们需要通过网络进行通信。接下来我们将看看这些协议。
- en: Utilizing the network
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用网络
- en: While building applications that can talk among themselves on the same machine
    can be cool, eventually, we'll need to talk to external systems. Most of these
    systems will be browsers in our case, but they may be other servers. Since we
    can't use named pipes/Unix domain sockets over these channels, we need to use
    various protocols of a network.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 构建能够在同一台机器上相互通信的应用程序可能很酷，但最终我们需要与外部系统进行通信。在我们的情况下，大多数这些系统将是浏览器，但它们也可能是其他服务器。由于我们无法通过这些通道使用命名管道/Unix域套接字，我们需要使用各种网络协议。
- en: Technically, we could still use the preceding two concepts across servers by
    utilizing shared drives/filesystem sharing, but this isn't a good idea. We've
    already shown that we can change the `listen` method from pointing to a file to
    pointing to a port. In the worst case, we can use a shared filesystem, but it
    is nowhere near optimal and it should be converted into utilizing one of the protocols
    we'll cover here.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们仍然可以通过使用共享驱动器/文件系统共享来跨服务器使用前面两个概念，但这不是一个好主意。我们已经表明我们可以将`listen`方法从指向文件更改为指向端口。在最坏的情况下，我们可以使用共享文件系统，但这远非最佳选择，应该转换为使用我们将在这里介绍的协议之一。
- en: 'The protocols that we will focus on are the two low-level protocols known as
    **Transmission Control Protocol** (**TCP**) and **User** **Datagram** **Protocol**
    (**UDP**). We will also take a look at the higher-level protocol of the web: **Hyper
    Text Transfer Protocol** **version 2** (**HTTP/2**). With these protocols, we
    will be able to create highly available applications that can be accessed over
    a network.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点关注两种低级协议，即传输控制协议（TCP）和用户数据报协议（UDP）。我们还将研究网络的高级协议：超文本传输协议版本2（HTTP/2）。通过这些协议，我们将能够创建高度可用的应用程序，可以通过网络访问。
- en: TCP/UDP
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/UDP
- en: TCP and UDP are the two low-level network protocols that we have access to in
    Node.js. Either of these allows us to send and receive messages, but they differ
    in a couple of key areas. First, TCP needs to have a receiver and sender for the
    connection. Because of this, we can't just broadcast on a channel and not care
    whether anybody is listening.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP是Node.js中我们可以访问的两种低级网络协议。这两种协议都允许我们发送和接收消息，但它们在一些关键领域有所不同。首先，TCP需要连接的接收方和发送方。因此，我们不能只在一个通道上广播，而不关心是否有人在听。
- en: Second, on top of TCP needing the handshake process, it also gives us guaranteed
    transmission. This means that we know when we send data that it should get to
    the other end (obviously, there are ways for this to fail, but we aren't going
    to look at that). Finally, TCP guarantees the order of delivery. If we send data
    on a channel to a receiver, it will get the data in the order that we sent it.
    Because of these reasons, we utilize TCP when we need to guarantee delivery and
    ordering.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，除了TCP需要握手过程外，它还为我们提供了可靠的传输。这意味着我们知道当我们发送数据时，它应该到达另一端（显然，这也有失败的可能，但我们不打算讨论这个）。最后，TCP保证了传递的顺序。如果我们在一个通道上向接收方发送数据，它将按照我们发送的顺序接收数据。因为这些原因，当我们需要保证传递和顺序时，我们使用TCP。
- en: TCP actually doesn't necessarily need to send the data in order. Everything
    is sent in packets. They can actually go to different servers and the routing
    logic can mean that later packets arrive at the receiver earlier than later ones.
    However, our receiver's network card reorders them for us so that it looks like
    we are getting them sequentially. There are many other cool aspects that go into
    TCP, including the transmission of data, that are outside the scope of this book,
    but anyone can look up networking and look at more of these concepts and how they
    are implemented.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，TCP并不一定需要按顺序发送数据。所有数据都是以数据包的形式发送的。它们实际上可以发送到不同的服务器，路由逻辑可能意味着后续数据包会比后来的更早到达接收方。然而，我们接收方的网络卡会为我们重新排序它们，使得看起来我们是按顺序接收它们的。TCP还有许多其他很酷的方面，包括数据的传输，这些都超出了本书的范围，但任何人都可以查阅网络并了解更多这些概念以及它们是如何实现的。
- en: This being said, TCP seems like something that we would always want to use.
    Why wouldn't we use something that guarantees delivery? Also, we don't necessarily
    need to broadcast if we can just loop through all of the current connections and
    send the data to everyone. However, because of all of these guarantees, this makes
    TCP heavier and slower. This isn't good for systems that we need to send data
    as fast as possible over. For this type of data transmission, we can utilize UDP.
    UDP gives us something called stateless transmission. Stateless transmission means
    we can send data on a channel and it will blast the data out and forget it. We
    don't need to connect to an address; instead, we can just send the data (as long
    as no one else is bound to that address and port). We can even set up a multicast
    system where anyone can listen to that address and it might pick up the data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，TCP似乎是我们总是想要使用的东西。为什么我们不使用能够保证传递的东西呢？此外，如果我们可以遍历所有当前的连接并将数据发送给每个人，我们就不需要广播。然而，由于所有这些保证，这使得TCP更加沉重和缓慢。这对于我们需要尽快发送数据的系统来说并不好。对于这种类型的数据传输，我们可以利用UDP。UDP给我们提供了一种称为无状态传输的东西。无状态传输意味着我们可以在一个通道上发送数据，它会将数据发送出去然后忘记。我们不需要连接到一个地址；相反，我们可以直接发送数据（只要没有其他人绑定到该地址和端口）。我们甚至可以建立一个多播系统，任何人都可以收听该地址，它可能会接收到数据。
- en: 'Some areas where this type of transmission is wanted/needed are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的传输希望/需要的一些领域如下：
- en: Send buy/sell orders for a stock exchange. Since the data moves fast, we only
    care about the latest information. Due to this, if we don't receive some of the
    buy/sell orders, it doesn't really matter.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送股票交易的买卖订单。由于数据传输速度很快，我们只关心最新的信息。因此，如果我们没有收到一些买卖订单，也并不重要。
- en: Player position data for video games. We can only update the game so fast. We
    can also interpolate or *infer* where a player is on the screen if we already
    know which direction they were moving and the speed that they were going at. Because
    of this, we can receive a player position at any rate and figure out where they
    should be (this is sometimes known as the tick rate of the server).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频游戏中的玩家位置数据。我们只能以有限的速度更新游戏。如果我们已经知道玩家移动的方向和速度，我们还可以插值或推断玩家在屏幕上的位置。因此，我们可以以任何速率接收玩家位置，并计算出他们应该在哪里（这有时被称为服务器的tick率）。
- en: Telecommunication data does not necessarily care if we send all of the data
    as long as we sent most of it. We don't need to guarantee delivery of the full
    video/audio signal since we can still give a great picture with most of the data.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电信数据并不一定在乎我们发送的所有数据，只要我们发送了大部分数据即可。我们不需要保证完整视频/音频信号的传递，因为我们仍然可以用大部分数据获得很好的画面。
- en: 'These are just a couple of the areas where UDP comes in handy. With an understanding
    of both these systems, we will take a look at them by building a highly simplified
    and impractical stock application. The behavior will be as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是UDP发挥作用的一些领域。通过对这两种系统的理解，我们将通过构建一个高度简化和不切实际的股票应用程序来研究它们。行为将如下所示：
- en: The server will post new stock symbols and the amount of stock that is available.
    Then, it will blast the information on a known port to everyone over UDP.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将发布新的股票代码和可用股票数量。然后，它将在已知端口上通过UDP向所有人广播信息。
- en: The server will store all of the information related to a client's positions.
    This way, there is no way for a client to be able to manipulate how many shares
    they may have.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将存储与客户持仓相关的所有信息。这样，客户端就无法操纵他们可能拥有的股票数量。
- en: A client will send a buy or sell order to the server. The server will figure
    out whether it can handle the request. All of this traffic will be over TCP since
    we need to guarantee that we know the server received our message.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将向服务器发送买入或卖出订单。服务器将确定它是否能处理该请求。所有这些流量都将通过TCP进行，因为我们需要确保知道服务器收到了我们的消息。
- en: The server will respond with an error or a success message, telling the client
    that their book has updated.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将以错误或成功的消息作出回应，告诉客户端他们的订单已更新。
- en: The server will blast that a buy or sell happened for stock over the UDP channel.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将通过UDP通道广播股票的买入或卖出发生了。
- en: 'This application looks as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序看起来如下：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Most of the preceding program should be familiar, except for the new module
    that we are utilizing: the `dgram` module. This module allows us to send data
    while utilizing UDP.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的大部分程序应该是熟悉的，除了我们正在使用的新模块：`dgram`模块。这个模块允许我们在使用UDP时发送数据。
- en: 'Here, we are creating a socket that is utilizing UDP4 (UDP over IPv4, or what
    we normally know as IP addresses). We also state that we are reusing the address
    and port. We''re doing this so that we can test this locally. We wouldn''t want
    this in any other scenario:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个使用UDP4（IPv4上的UDP，或者我们通常知道的IP地址）的套接字。我们还声明我们正在重用地址和端口。我们这样做是为了在本地测试。在其他情况下我们不希望这样做：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We bind to port `3000` since that is where the server is going to send data.
    Then, we state that we want to add ourselves to the multicast address. For multicasting
    to work, the server needs to send data over a multicast address. These addresses
    are usually specific addresses that the OS has set up. Each OS can decide what
    addresses to use, but the one we have chosen should work on any OS.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绑定到端口`3000`，因为服务器将在那里发送数据。然后，我们声明我们要将自己添加到多播地址。为了使多播工作，服务器需要通过多播地址发送数据。这些地址通常是操作系统设置的特定地址。每个操作系统都可以决定使用哪些地址，但我们选择的地址应该在任何操作系统上都可以使用。
- en: Once we receive a message, we print it out. Again, this should look familiar.
    Node.js is based around events and streams and they are usually named the same
    thing for consistency.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们收到消息，我们就打印出来。再次，这应该看起来很熟悉。Node.js是基于事件和流的，它们通常以相同的名称命名以保持一致性。
- en: The other pieces of this program handle user input and then send data over the
    TCP channel that we opened up when we created a new socket (this should look similar
    to our IPC program from before, except we pass a port and an IP address).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的其他部分处理用户输入，然后通过我们创建新套接字时打开的TCP通道发送数据（这应该类似于我们之前的IPC程序，只是我们传递了一个端口和一个IP地址）。
- en: 'The server for this application is a bit more involved since it holds all of
    the logic of the stock application. We will break this down into several steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的服务器涉及的内容更多，因为它包含了股票应用程序的所有逻辑。我们将把这个过程分解为几个步骤：
- en: 'Create a file called `main.js` and import the `dgram` and `net` modules into
    it:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.js`的文件，并将`dgram`和`net`模块导入其中：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add some constants for our multicast address, the error message for bad input,
    and the `Maps` for our stock tickers and clients:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的多播地址、错误消息和股票代码和客户端的`Maps`添加一些常量：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we create two servers. The first is used to listen for UDP messages,
    while the second is used to receive TCP messages. We will utilize the TCP server
    to process client requests. TCP is reliable, while UDP isn''t:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建两个服务器。第一个用于监听UDP消息，而第二个用于接收TCP消息。我们将利用TCP服务器来处理客户端请求。TCP是可靠的，而UDP不是：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we need to set up a listener on the TCP server for any connections. Once
    we have a client connection, we will set them up with a temporary table so that
    we can store their portfolio:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在TCP服务器上设置一个监听器以接受任何连接。一旦有客户端连接，我们将为他们设置一个临时表，以便我们可以存储他们的投资组合：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, set up a data listener for the client. When we receive data, we will parse
    the message according to the following format, `SELL/BUY <Ticker> <Number>`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为客户端设置一个数据监听器。当我们收到数据时，我们将根据以下格式解析消息，`SELL/BUY <Ticker> <Number>`：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Based on this parsing, we check to see whether the client can perform the action.
    If they can, we will change their portfolio and send them a message stating the
    change was successful:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据这个解析，我们检查客户端是否能执行这个操作。如果可以，我们将更改他们的投资组合，并发送一条消息告诉他们更改成功了：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once we have told the client that we have processed their request, we can write
    to all of the clients through the UDP server:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们告诉客户端我们已处理他们的请求，我们可以通过UDP服务器向所有客户端写入：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we need to process new stock tickers from the server through our standard
    input. Once we have processed the request, we send the data out on the UDP server
    so that every client knows about the new stock:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要通过标准输入处理来自服务器的新股票代码。一旦我们处理了请求，我们就通过UDP服务器发送数据，以便每个客户端都知道新股票的情况。
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Almost all of the error logic has been removed for clarity, but you can find
    it in this book's GitHub repository. As shown in the preceding example, it is
    very simple to utilize all of the interfaces for sending data to various other
    points, be it other parts of our application or remote clients that are listening
    for data. They all use almost the exact same interface and only differ in slight
    implementation details. Just remember that if there needs to be a guarantee of
    delivery, TCP should be used; otherwise, UDP isn't a bad choice.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，几乎所有的错误逻辑都已被移除，但你可以在本书的GitHub存储库中找到它们。正如前面的例子所示，利用所有接口向其他点发送数据非常简单，无论是我们应用程序的其他部分还是监听数据的远程客户端。它们几乎都使用相同的接口，只在细微的实现细节上有所不同。只需记住，如果需要保证交付，应使用TCP；否则，UDP也是一个不错的选择。
- en: Next, we will look at the HTTP/2 standard and how the server system is a bit
    different in Node.js compared to the `net`, `dgram`, and `http`/`https` modules.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下HTTP/2标准以及与`net`、`dgram`和`http`/`https`模块相比，Node.js中的服务器系统有些不同。
- en: HTTP/2
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP/2
- en: While it was introduced in 2015, the adoption of the technology is slow. HTTP/2
    builds on the HTTP/1.1 protocol to allow for various features that caused issues
    for the previous system. This gives us the ability to use a single TCP connection
    to receive different requests. This wasn't possible with HTTP/1.1 and it caused
    an issue called head of line blocking. This meant that we could only really handle
    so many TCP connections and that if we had a long-running TCP connection, it could
    block all of the requests after it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它是在2015年引入的，但技术的采用速度很慢。HTTP/2建立在HTTP/1.1协议的基础上，允许各种功能，这些功能在以前的系统中引起了问题。这使我们能够使用单个TCP连接接收不同的请求。这在HTTP/1.1中是不可能的，它引起了一个叫做头部阻塞的问题。这意味着我们实际上只能处理那么多的TCP连接，如果我们有一个长时间运行的TCP连接，它可能会阻塞之后的所有请求。
- en: HTTP/2 also gave us the ability to push server-side resources. This means that
    if a server knows that a resource is going to be needed by a browser, such as
    a CSS file, it could push it to the server before it was needed. Finally, HTTP/2
    gave us built-in streaming capabilities. This means we're able to use a connection
    and send data down as a stream instead of needing to send it all at once.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2还赋予了我们推送服务器端资源的能力。这意味着如果服务器知道浏览器将需要一个资源，比如一个CSS文件，它可以在需要之前将其推送到服务器。最后，HTTP/2赋予了我们内置的流式传输能力。这意味着我们能够使用连接并将数据作为流发送，而不需要一次性发送所有数据。
- en: There are other benefits that HTTP/2 gives us, but these are the main ones.
    While the `http` and `https` modules will probably still be used for some time
    to come, the `http2` module in Node.js should be used for any new applications.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2还给我们带来了其他好处，但这些是主要的好处。虽然`http`和`https`模块可能还会在未来一段时间内使用，但Node.js中的`http2`模块应该用于任何新的应用程序。
- en: 'The `http2` module in Node.js differs from the `http` and `https` modules in
    a few ways. While it doesn''t follow the standards that many of the other IPC/networking
    modules give us, it does give us some nice ways to send data over HTTP/2\. One
    of these allows us to stream files directly from the filesystem instead of needing
    to create a pipe for the file and send it to the sender. An example of some of
    these differences can be seen in the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中的`http2`模块与`http`和`https`模块有一些不同之处。虽然它不遵循许多其他IPC/网络模块给我们的标准，但它确实为我们提供了一些很好的方法来通过HTTP/2发送数据。其中一个允许我们直接从文件系统流式传输文件，而不需要为文件创建管道并将其发送给发送方。以下代码中可以看到其中一些差异：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'First, notice that the server needs a private key and a public certificate.
    These are used to make sure that the connection that is set up is secure, meaning
    that no one can see what''s being sent. For us to be able to do this, we need
    a tool such as `openssl` to create these keys and certificates. With Windows 10
    and other Unix operating systems, we get this for free. Otherwise, we need to
    download Cygwin ([http://www.cygwin.com/](http://www.cygwin.com/)). With `openssl`,
    we can run the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意服务器需要一个私钥和一个公共证书。这些用于确保建立的连接是安全的，这意味着没有人可以看到正在发送的内容。为了能够做到这一点，我们需要一个工具，比如`openssl`来创建这些密钥和证书。在Windows
    10和其他Unix操作系统中，我们可以免费获得这个工具。否则，我们需要下载Cygwin（[http://www.cygwin.com/](http://www.cygwin.com/)）。使用`openssl`，我们可以运行以下命令：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This command generates the necessary private key and public certificate for
    the server and clients to communicate securely. We won''t go into the details
    of how this is implemented here, but information on how this can be achieved with
    SSL/TLS can be found at: [https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/](https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令生成了服务器和客户端进行安全通信所需的私钥和公共证书。我们不会在这里详细介绍它是如何实现的，但关于如何使用SSL/TLS实现这一点的信息可以在这里找到：[https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/](https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/)。
- en: With our certificate and key generated, we can read them in so that our server
    can start running. We will also notice that instead of responding to a message
    event or a request event, we respond to the stream event. HTTP/2 utilizes streams
    instead of trying to send all of the data at once. While Node.js wrapped the requests
    and responses in streams for us, this is not how it may be handled at the OS layer.
    HTTP/2 utilizes streaming right away. This is the reason why the event is called
    a stream.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 生成了我们的证书和密钥后，我们可以读取它们，以便我们的服务器可以开始运行。我们还会注意到，与响应消息事件或请求事件不同，我们响应流事件。HTTP/2使用流而不是尝试一次性发送所有数据。虽然Node.js为我们封装了流的请求和响应，但这并不是操作系统层面可能处理的方式。HTTP/2立即使用流。这就是为什么事件被称为流的原因。
- en: Next, instead of calling the `writeHead` method, we are just responding to the
    stream. When we want to send information, we utilize the `respond` method and
    send the headers this way. We will also notice that some of the headers are prefixed
    with a colon. This is specific to the `http2` module and if problems are found
    when sending specific headers, putting a colon in front may solve the issue.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们不是调用`writeHead`方法，而是响应流。当我们想要发送信息时，我们利用`respond`方法并以这种方式发送头部。我们还会注意到一些头部是以冒号为前缀的。这是`http2`模块特有的，如果在发送特定头部时发现问题，加上冒号可能会解决问题。
- en: 'Other than what we''ve talked about here, this should look quite similar to
    a normal HTTP(s) server that we write in Node.js. There are some other benefits
    that we get with the `http2` module, however, and one of them is responding with
    a file instead of having to read in that file and send it that way. This can be
    seen in the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在这里讨论的内容之外，这应该看起来与我们在Node.js中编写的普通HTTP(s)服务器非常相似。然而，`http2`模块还有一些其他好处，其中之一是响应文件而不是必须读取文件并以这种方式发送。这可以在以下代码中看到：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The program numbers are key points of interest, and they work as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 程序编号是关键的兴趣点，它们的工作方式如下：
- en: We are reading information from the `package.json` file, just like we did in
    the previous chapter. We are also running this through the `npm run <script>`
    command. Check out the previous chapter to see how to do this and how we can use
    configuration data from the `package.json` file in our programs.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在从`package.json`文件中读取信息，就像我们在上一章中所做的那样。我们还通过`npm run <script>`命令运行这个。查看上一章，了解如何做到这一点，以及我们如何在程序中使用`package.json`文件中的配置数据。
- en: We have set a specific configuration option for our server. If the client that
    connects to us can't use HTTP/2, then we will automatically convert everything
    back into the negotiated protocol, for example, HTTP/1.1.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为服务器设置了特定的配置选项。如果连接到我们的客户端无法使用HTTP/2，那么我们将自动将一切转换回协商的协议，例如HTTP/1.1。
- en: We grab the extension from the URL. This way, we can see whether we support
    that file type and send the appropriate file; otherwise, we will pass back a 400
    error message and state that it was a bad request.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从URL中获取扩展名。这样，我们可以看到我们是否支持该文件类型，并发送适当的文件；否则，我们将返回一个400错误消息，并声明这是一个错误的请求。
- en: This method allows us to pass a path in. Then, the core system will handle sending
    the file for us. All we need to do is make sure that we set the content type correctly
    so that the browser can interpret the data for us.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种方法允许我们传入一个路径。然后，核心系统将帮助我们发送文件。我们所需要做的就是确保正确设置内容类型，以便浏览器可以解释数据。
- en: If there is an error at any point, such as the file not existing, we will respond
    with the correct status, such as a 404 or a 500 error.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在任何时候出现错误，比如文件不存在，我们将以正确的状态做出响应，比如404或500错误。
- en: While what we've presented here is just a small fraction of the `http2` module,
    this showcases how the `http2` module is different and how we can set one up quite
    quickly. If need be, refer back to [https://Node.js.org/dist/latest-v12.x/docs/api/http2.html](https://nodejs.org/dist/latest-v12.x/docs/api/http2.html)
    to see how the `http2` module is different from `http` and all of the capabilities
    that come with it. Now, we will take a look at the future state of the web and
    take a look at HTTP/3 in Node.js.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里呈现的只是`http2`模块的一小部分，但这展示了`http2`模块的不同之处，以及我们如何可以快速设置一个。如果需要，可以参考[https://Node.js.org/dist/latest-v12.x/docs/api/http2.html](https://nodejs.org/dist/latest-v12.x/docs/api/http2.html)来了解`http2`模块与`http`的不同之处以及它带来的所有功能。现在，我们将看一下网络的未来状态，并了解Node.js中的HTTP/3。
- en: A quick glance at HTTP/3
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速浏览HTTP/3
- en: While what we have talked about is the present state of communicating among
    processes, threads, and other computers, there is a new way for information to
    be passed around. The new standard is called HTTP/3 and it differs from the previous
    two iterations significantly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们所讨论的是进程、线程和其他计算机之间通信的现状，但有一种新的信息传递方式。新标准称为HTTP/3，与前两个版本有很大不同。
- en: The QUIC protocol
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QUIC协议
- en: '**Quick UDP Internet Connections** (**QUIC**) was introduced by Google in 2012\.
    It is a protocol similar to the TCP, **Transport Layer Security** (**TLS**), and
    HTTP/2 protocols, but it is all transmitted over UDP. This means that a lot of
    the overhead that is built into TCP has been removed and replaced with a new method
    of sending data. On top of this, since TLS is built into the protocol, it means
    that the overhead of adding security to an already defined protocol has been removed.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**Quick UDP Internet Connections** (**QUIC**)是由Google于2012年推出的。它是一种类似于TCP、**传输层安全**（**TLS**）和HTTP/2协议的协议，但它全部通过UDP传输。这意味着TCP中内置的许多开销已经被移除，并用一种新的发送数据的方法替代。除此之外，由于TLS内置到协议中，这意味着在已定义的协议中添加安全性的开销已经被移除。'
- en: QUIC is currently used by Google for things such as YouTube. While QUIC never
    gained mass appeal, it helped spawn the group that would create the HTTP/3 standard
    committee and helped guide the committee to utilize UDP as the base layer for
    the protocol. It also showcased how security can be built into the protocol and
    has lead HTTP/3 to have it built into it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC目前被Google用于诸如YouTube之类的事物。虽然QUIC从未获得大规模的吸引力，但它帮助产生了将创建HTTP/3标准委员会的团体，并帮助指导委员会利用UDP作为协议的基础层。它还展示了安全性可以内置到协议中，并已经使HTTP/3具备了这一特性。
- en: 'Other companies have started to implement the QUIC protocol while HTTP/3 is
    being developed. One notable inclusion to this list is Cloudflare. Their blogpost
    on implementing QUIC can be found here: [https://blog.cloudflare.com/the-road-to-quic/](https://blog.cloudflare.com/the-road-to-quic/).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其他公司已经开始实施QUIC协议，而HTTP/3正在开发中。这个名单中一个显著的包括Cloudflare。他们关于实施QUIC的博客文章可以在这里找到：[https://blog.cloudflare.com/the-road-to-quic/](https://blog.cloudflare.com/the-road-to-quic/)。
- en: While HTTP/3 has not been added to Node.js, there are some packages that implement
    the QUIC protocol.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HTTP/3尚未添加到Node.js中，但有一些包实现了QUIC协议。
- en: A look at node-quic
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对node-quic的一瞥
- en: While QUIC is not the easiest to work with right now and the only official implementation
    is written in the Chromium source, there have been other implementations that
    allow us to play around with this protocol. The `node-quic` module has been deprecated
    in favor of the QUIC implementation that is trying to be built into Node.js directly,
    but we can still use it to see how we might utilize QUIC or even HTTP/3 in the
    future.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然QUIC目前不是最容易使用的，而且唯一的官方实现是在Chromium源代码中编写的，但已经有其他实现允许我们玩弄这个协议。`node-quic`模块已经被弃用，而QUIC实现正在尝试直接构建到Node.js中，但我们仍然可以使用它来看看我们将来如何利用QUIC甚至HTTP/3。
- en: 'First, we need to install the module by running the `npm install node-quic`
    command. With this, we are able to write a simple client-server application. The
    client should look something like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过运行`npm install node-quic`命令来安装模块。有了这个，我们就能够编写一个简单的客户端-服务器应用程序。客户端应该看起来像下面这样：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We will notice that sending data is similar to how we would do so in the UDP
    system; that is, we can send data without actually needing to bind to the port
    and address. Other than this, the system runs similarly to how other applications
    would run when written with the `http` or `http2` module. One interesting thing
    to note here is that data is automatically converted into a string for us when
    we receive it from the `quic` stream.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会注意到，发送数据类似于我们在UDP系统中所做的方式；也就是说，我们可以发送数据而不需要绑定到端口和地址。除此之外，该系统运行方式类似于使用`http`或`http2`模块编写的其他应用程序。这里值得注意的一件事是，当我们从`quic`流中接收数据时，数据会自动转换为字符串。
- en: 'A server for the previous client would look as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个客户端的服务器将如下所示：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Again, it should look familiar to the other applications that we have written.
    One of the major differences here is that this module was written with promises
    in mind. Other than this, the data we receive is a string, so we turn ourselves
    off if we receive `quit` by running the `stopListening` method. Otherwise, we
    write the data we want to send to the steam, similar to what we do with the HTTP/2
    protocol.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这应该看起来与我们编写的其他应用程序类似。这里的一个主要区别是，这个模块是针对promise编写的。除此之外，我们接收的数据是一个字符串，所以如果我们接收到`quit`，我们通过运行`stopListening`方法关闭自己。否则，我们将要发送的数据写入流中，类似于我们在HTTP/2协议中所做的。
- en: 'To stay on top of the implementation status for HTTP/3, it is recommended that
    you check out the following link and check it periodically: [https://quicwg.org/](https://quicwg.org/).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解HTTP/3的实现状态，建议您查看以下链接并定期检查：[https://quicwg.org/](https://quicwg.org/)。
- en: As we can see, it is quite simple to utilize the QUIC protocol with this module.
    This may also be useful for internal applications. Just note that neither the
    QUC protocol nor the HTTP/3 standard has been fully finished and probably won't
    be for a few more years. This doesn't mean that you shouldn't utilize them—it
    just means that things can change quite quickly while the standard is in flux.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用这个模块来利用QUIC协议是相当简单的。这对内部应用程序也可能很有用。只要注意，QUC协议和HTTP/3标准都还没有完全完成，可能还需要几年的时间。这并不意味着你不应该利用它们，只是意味着在标准不稳定的时候事情可能会发生很快。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Sending data between different systems, be it threads, processes, or even other
    computers, is what we do as developers. There are many tools we can use to do
    this, and we have looked at most of them. Just remember that while one option
    can appear to make an application simple, that doesn't always mean it is the best
    choice. When it comes to breaking our systems up, we usually want to assign a
    specific job to a unit and use some form of IPC, such as named pipes, to communicate.
    If we need to move that task to another computer, we can always switch it out
    for TCP.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同系统之间发送数据，无论是线程、进程，甚至其他计算机，这是我们作为开发人员所做的。我们可以使用许多工具来做到这一点，我们已经看过大部分。只要记住，虽然一个选项可能使应用程序变得简单，但这并不总是意味着它是最好的选择。当我们需要拆分系统时，通常希望将特定的工作分配给一个单元，并使用某种形式的IPC，比如命名管道，进行通信。如果我们需要将该任务移动到另一台计算机，我们总是可以切换到TCP。
- en: With these IPC and web protocols under our belt, we will be able to tackle most
    problems with ease in Node.js and to write both the client-side and server-side
    code when it comes to web applications. However, Node.js isn't just built for
    web applications. We can pretty much do anything that other languages can and
    even have most of the tools that these other languages have. This chapter should
    have helped to clarify that and helped solidify how Node.js can be built into
    an already developed application ecosystem.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些IPC和Web协议的基础，我们将能够轻松解决Node.js中的大多数问题，并在涉及Web应用程序时编写客户端和服务器端代码。然而，Node.js并不仅仅是为Web应用程序而构建的。我们几乎可以做任何其他语言可以做的事情，甚至拥有大多数其他语言拥有的工具。本章应该有助于澄清这一点，并帮助巩固Node.js如何构建到已经开发的应用程序生态系统中。
- en: With all of this in mind, we will be looking at streaming and how we can implement
    our own streams in Node.js.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，我们将研究流和如何在Node.js中实现我们自己的流。
