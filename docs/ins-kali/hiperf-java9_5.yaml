- en: Chapter 5. Making Use of New APIs to Improve Your Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。利用新的API来改进您的代码
- en: In the previous lessons, we talked about possible ways to improve the performance
    of your Java application--from using the new command and monitoring tools to adding
    multithreading and introducing reactive programming and even to radically re-architecting
    your current solution into an unruly and flexible bunch of small independent deployment
    units and microservices. Without knowing your particular situation, there is no
    way for us to guess which of the provided recommendations can be helpful to you.
    That's why, in this lesson, we will describe a few recent additions to the JDK
    that can be helpful to you too. As we mentioned in the previous lesson, the gain
    in performance and overall code improvement does not always require us to radically
    redesign it. Small incremental changes can sometimes bring more significant improvements
    than we could have expected.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的课程中，我们谈到了改进Java应用程序性能的可能方法--从使用新的命令和监控工具到添加多线程和引入响应式编程，甚至到将当前解决方案彻底重新架构为一组不规则且灵活的小独立部署单元和微服务。在不了解您特定情况的情况下，我们无法猜测提供的建议中哪些对您有帮助。这就是为什么在本课程中，我们还将描述JDK的一些最新添加，这对您也可能有帮助。正如我们在上一课中提到的，性能和整体代码改进并不总是需要我们彻底重新设计它。小的增量变化有时会带来比我们预期的更显著的改进。
- en: To bring back our analogy of a pyramid building, instead of trying to change
    the logistics of the delivery of the stones to the final destination--in order
    to shorten the construction time--it is often prudent to look closer at the tools
    the builders are using first. If each operation can be completed in half the time,
    the overall time of the project's delivery can be shortened accordingly, even
    if each of the stone blocks travels the same, if not a larger, distance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们建造金字塔的类比，与其试图改变石块交付到最终目的地的物流以缩短建造时间，通常更明智的是首先仔细查看建筑工人正在使用的工具。如果每个操作都可以在一半的时间内完成，那么项目交付的整体时间可以相应缩短，即使每个石块的旅行距离相同，甚至更大。
- en: 'These are the improvements of the programming tools we will discuss in this
    lesson:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将在本课程中讨论的编程工具的改进：
- en: Using filters on streams as a way to find what you need and to decrease workload
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流上的过滤器作为查找所需内容和减少工作量的方法
- en: A new stack-walking API as the way analyze the stack trace programmatically
    in order to apply an automatic correction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种新的堆栈遍历API，作为分析堆栈跟踪的方式，以便自动应用更正
- en: New convenient static factory methods that create compact, unmodifiable collection
    instances
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建紧凑的、不可修改的集合实例的新便利的静态工厂方法
- en: The new `CompletableFuture` class as a way to access the results of asynchronous
    processing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`CompletableFuture`类作为访问异步处理结果的方法
- en: The JDK 9 stream API improvements that can speed up processing while making
    your code more readable
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 9流API的改进，可以加快处理速度，同时使您的代码更易读
- en: Filtering Streams
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤流
- en: The `java.util.streams.Stream` interface was introduced in Java 8\. It emits
    elements and supports a variety of operations that perform computations based
    on these elements. A stream can be finite or infinite, slow or fast emitting.
    Naturally, there is always a concern that the rate of the newly emitted elements
    may be higher than the rate of the processing. Besides, the ability to keep up
    with the input reflects the application's performance. The `Stream` implementations
    address the backpressure (when the rate of the element processing is lower than
    their emitting rate) by adjusting the emitting and processing rates using a buffer
    and various other techniques. In addition, it is always helpful if an application
    developer makes sure that the decision about processing or skipping each particular
    element is made as early as possible so that the processing resources are not
    wasted. Depending on the situation, different operations can be used for filtering
    the data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.streams.Stream`接口是在Java 8中引入的。它发出元素并支持执行基于这些元素的各种操作的计算。流可以是有限的或无限的，发射速度快或慢。自然地，总是担心新发出的元素的速率可能高于处理的速率。此外，跟上输入的能力反映了应用程序的性能。`Stream`实现通过使用缓冲区和其他各种技术来调整发射和处理速率来解决反压（当元素处理速率低于它们的发射速率时）。此外，如果应用程序开发人员确保尽早做出有关处理或跳过每个特定元素的决定，以便不浪费处理资源，这总是有帮助的。根据情况，可以使用不同的操作来过滤数据。'
- en: Basic Filtering
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本过滤
- en: 'The first and the most straightforward way to do filtering is using the `filter()`
    operation. To demonstrate all the following capabilities, we will use the `Senator`
    class:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 进行过滤的第一种最直接的方法是使用`filter()`操作。为了演示所有以下的功能，我们将使用`Senator`类：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, this class captures a senator's name, party, and how they voted
    for each of the issues (`0` means `No` and `1` means `Yes`). If for a particular
    issue `i`, `voteYes[i]=0` , and `voteNo[i]=0`, it means that the senator was not
    present. It is not possible to have `voteYes[i]=1` and `voteNo[i]=1` for the same
    issue.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个类捕获了参议员的姓名、政党以及他们对每个问题的投票情况（`0`表示`否`，`1`表示`是`）。对于特定问题`i`，如果`voteYes[i]=0`，而`voteNo[i]=0`，这意味着参议员不在场。对于同一个问题，不可能同时有`voteYes[i]=1`和`voteNo[i]=1`。
- en: 'Let''s assume that there are 100 senators, each belonging to one of the two
    parties: `Party1` or `Party2`. We can use these objects to collect statistics
    of how senators voted for the last 10 issues using the `Senate` class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有100名参议员，每个人属于两个政党中的一个：`Party1`或`Party2`。我们可以使用这些对象来收集参议员对最近10个问题的投票统计，使用`Senate`类：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We hardcoded statistics for the first five senators so we can get predictable
    results while testing our filters and verify that the filters work. We also hardcoded
    voting statistics for the last two senators so we can have a predictable count
    while looking for senators who voted only `Yes` or only `No` for each of the ten
    issues. And we added the `timesVotedYes()` method, which provides the count of
    how many times the given `senator` voted `Yes`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为前五位参议员硬编码了统计数据，这样我们在测试我们的过滤器时可以获得可预测的结果，并验证过滤器的工作。我们还为最后两位参议员硬编码了投票统计数据，这样我们在寻找只对每个问题投了“是”或只投了“否”的参议员时可以获得可预测的计数。我们还添加了`timesVotedYes()`方法，它提供了给定`senator`投了多少次“是”的计数。
- en: 'Now we can collect some data from the `Senate` class. For example, let''s see
    how many members of each party comprise the `Senate` class:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从`Senate`类中收集一些数据。例如，让我们看看每个党派在`Senate`类中有多少成员：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result of the preceding code differs from run to run because of the random
    value generator we used in the `Senate` class, so do not expect to see exactly
    the same numbers if you try to run the examples. What is important is that the
    total of the two party members should be equal 100--the total number of the senators
    in the `Senate` class:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`Senate`类中使用了随机值生成器，因此前面代码的结果会因运行不同而不同，因此如果您尝试运行示例，不要期望看到完全相同的数字。重要的是两个党派成员的总数应该等于100——`Senate`类中参议员的总数：
- en: '![Basic Filtering](img/05_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![基本过滤](img/05_01.jpg)'
- en: The expression `s -> s.getParty()=="Party1"` is the predicate that filters out
    only those senators who are members of `Party1`. So, the elements (`Senator` objects)
    of `Party2` do not get through and are not included in the count. That was pretty
    straightforward.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`s -> s.getParty()=="Party1"`是过滤器，只过滤出那些属于`Party1`的参议员。因此，`Party2`的元素（`Senator`对象）不会通过，也不会包括在计数中。这很直接了当。
- en: 'Now let''s look at a more complex example of filtering. Let''s count how many
    senators of each party voted on `issue 3`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个更复杂的过滤示例。让我们计算每个党派有多少名参议员在`issue 3`上投票：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For `Party1`, we used two filters. For `Party2`, we combined them just to show
    another possible solution. The important point here is to use the filter by a
    party (`s -> s.getParty() == "Party1"`) first before the filter that selects only
    those who voted. This way, the second filter is used only for approximately half
    of the elements. Otherwise, if the filter that selects only those who voted were
    placed first, it would be applied to all 100 of `Senate` members.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Party1`，我们使用了两个过滤器。对于`Party2`，我们将它们合并只是为了展示另一个可能的解决方案。这里的重点是首先使用按党派过滤（`s
    -> s.getParty() == "Party1"`）的过滤器，然后再使用选择只投票的过滤器。这样，第二个过滤器只用于大约一半的元素。否则，如果首先放置选择只投票的过滤器，它将应用于`Senate`的全部100名成员。
- en: 'The result looks like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Basic Filtering](img/05_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![基本过滤](img/05_02.jpg)'
- en: 'Similarly, we can calculate how many members of each party voted `Yes` on `issue
    3`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以计算每个党派有多少成员在`issue 3`上投了“是”：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result of the preceding code is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的结果如下：
- en: '![Basic Filtering](img/05_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![基本过滤](img/05_03.jpg)'
- en: 'We can refactor the preceding examples by taking advantage of the Java functional
    programming capability (using lambda expressions) and creating the `countAndPrint()`
    method:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用Java的函数式编程能力（使用lambda表达式）并创建`countAndPrint()`方法来重构前面的示例：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now all the earlier code can be expressed in a more compact way:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有之前的代码可以以更紧凑的方式表达：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We created four predicates, `party1`, `party2`, `voted3`, and `yes3`, and we
    used each of them several times as parameters of the `countAndPrint()` method.
    The output of this code is the same as that of the earlier examples:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了四个谓词，`party1`，`party2`，`voted3`和`yes3`，并且我们多次将它们用作`countAndPrint()`方法的参数。这段代码的输出与之前的示例相同：
- en: '![Basic Filtering](img/05_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![基本过滤](img/05_04.jpg)'
- en: Using the `filter()` method of the `Stream` interface is the most popular way
    of filtering. But it is possible to use other `Stream` methods to accomplish the
    same effect.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Stream`接口的`filter()`方法是过滤的最流行方式。但是也可以使用其他`Stream`方法来实现相同的效果。
- en: Using Other Stream Operations for Filtering
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用其他Stream操作进行过滤
- en: Alternatively, or in addition to the basic filtering described in the previous
    section, other operations (methods of the `Stream` interface) can be used for
    selection and filtering emitted stream elements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，或者除了前一节中描述的基本过滤之外，其他操作（`Stream`接口的方法）也可以用于选择和过滤发出的流元素。
- en: 'For example, let''s use the `flatMap()` method to filter out the members of
    the Senate by their party membership:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用`flatMap()`方法按其党派成员身份过滤出参议院成员：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This method takes advantage of the `Stream.of()` (produces a stream of one
    element) and `Stream.empty()`factory methods (it produces a stream without elements,
    so nothing is emitted further downstream). Alternatively, the same effect can
    be achieved using a new factory method (introduced in Java 9) called `Stream.ofNullable()`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法利用了`Stream.of()`（生成一个元素的流）和`Stream.empty()`工厂方法（它生成一个没有元素的流，因此不会向下游发出任何内容）。或者，可以使用一个新的工厂方法（在Java
    9中引入）`Stream.ofNullable()`来实现相同的效果：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Stream.ofNullable()` method creates a stream of one element if not `null`;
    otherwise, it creates an empty stream, as in the previous example. Both the preceding
    code snippets--produce the same output if we run them for the same senate composition:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream.ofNullable()`方法如果不是`null`则创建一个元素的流；否则，创建一个空流，就像前面的示例一样。如果我们对相同的参议院组成运行它们，那么前面的两个代码片段会产生相同的输出：'
- en: '![Using Other Stream Operations for Filtering](img/05_05.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他Stream操作进行过滤](img/05_05.jpg)'
- en: 'However, the same result can be achieved using a `java.uti.Optional` class
    that may or may not contain a value. If a value is present (and not `null`), its
    `isPresent()` method returns `true` and the `get()` method returns the value.
    Here is how we can use it to filter out the members of one party:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`java.uti.Optional`类也可以实现相同的结果，该类可能包含或不包含值。如果值存在（且不为`null`），则其`isPresent()`方法返回`true`，`get()`方法返回该值。以下是我们如何使用它来过滤一个党派的成员：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, we map (transform) an element (the `Senator` object) to an `Optional`
    object with or without the value. Next, we use the `flatMap()` method to either
    generate a stream of a single element or else an empty stream, and then we count
    the elements that made it through. In Java 9, the `Optional` class acquired a
    new factory `stream()` method that produces a stream of one element if the `Optional`
    object carries a non-null value; otherwise, it produces an empty stream. Using
    this new method, we can rewrite the previous code as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将一个元素（`Senator`对象）映射（转换）为一个带有或不带有值的`Optional`对象。接下来，我们使用`flatMap()`方法来生成一个单个元素的流，或者是一个空流，然后计算通过的元素数量。在Java
    9中，`Optional`类获得了一个新的工厂`stream()`方法，如果`Optional`对象携带非空值，则生成一个元素的流；否则，生成一个空流。使用这个新方法，我们可以将前面的代码重写如下：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Both the previous examples produce the same output if we run them for the same
    senate composition:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对相同的参议院组成运行这两个示例，前面两个示例的输出结果是相同的：
- en: '![Using Other Stream Operations for Filtering](img/05_06.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_06.jpg)'
- en: 'We can apply another kind of filtering when we need to capture the first element
    emitted by the stream. This means that we terminate the stream after the first
    element is emitted. For example, let''s find the first senator of `Party1`who
    voted `Yes` on `issue 3`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要捕获流发出的第一个元素时，我们可以应用另一种过滤。这意味着在发出第一个元素后终止流。例如，让我们找到`Party1`中投了`issue 3`上的第一位参议员：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![Using Other Stream Operations for Filtering](img/05_07.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_07.jpg)'
- en: This was exactly what we expected when we seeded data in the `Senate` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在`Senate`类中设置数据时所期望的。
- en: 'Similarly, we can use the `findAny()` method to find any `senator` who voted
    `Yes` on `issue 3`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`findAny()`方法来找到在`issue 3`上投了`Yes`的任何`senator`：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result is also as we expected:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 结果也和我们预期的一样：
- en: '![Using Other Stream Operations for Filtering](img/05_08.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_08.jpg)'
- en: It is typically (but not necessarily) the first element of the stream. But one
    should not rely on this assumption, especially in the case of parallel processing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常（但不一定）是流的第一个元素。但是，人们不应该依赖这一假设，特别是在并行处理的情况下。
- en: 'The `Stream` interface also has three `match` methods that, although they return
    a Boolean value, can be used for filtering too if the specific object is not required
    and we only need to establish the fact that such an object exists or not. The
    names of these methods are `anyMatch()`, `allMatch()`, and `noneMatch()`. Each
    of them takes a predicate and returns a Boolean. Let''s start by demonstrating
    the `anyMatch()` method. We will use it to find out if there is at least one `senator`
    of `Party1` who voted `Yes` on `issue 3`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`接口还有三种`match`方法，虽然它们返回一个布尔值，但如果不需要特定对象，只需要确定这样的对象是否存在，也可以用于过滤。这些方法的名称分别是`anyMatch()`、`allMatch()`和`noneMatch()`。它们每个都接受一个谓词并返回一个布尔值。让我们从演示`anyMatch()`方法开始。我们将使用它来查找`Party1`中至少有一个投了`issue
    3`上的`Yes`的`senator`：'
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The result of running the previous code should look like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面代码的结果应该如下所示：
- en: '![Using Other Stream Operations for Filtering](img/05_09.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_09.jpg)'
- en: 'To demonstrate the `allMatch()` method, we will use it to find out if all the
    members of `Party1` in the `Senate` class have voted `Yes` on `issue 3`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`allMatch()`方法，我们将使用它来查找`Senate`类中`Party1`的所有成员是否在`issue 3`上投了`Yes`：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result of the previous code may look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的结果可能如下所示：
- en: '![Using Other Stream Operations for Filtering](img/05_10.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_10.jpg)'
- en: 'And the last of the three `match` methods--the `noneMatch()` method--will be
    used to figure out if some senators of `Party1` have voted `Yes` on `issue 3`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 三种`match`方法中的最后一种--`noneMatch()`方法--将用于确定`Party1`的一些参议员是否在`issue 3`上投了`Yes`：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The result of the earlier example is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的结果如下：
- en: '![Using Other Stream Operations for Filtering](img/05_11.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_11.jpg)'
- en: However, in real life, it could be very different because quite a few issues
    in the `Senate` class are voted for along party lines.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现实生活中，情况可能会截然不同，因为`Senate`类中有相当多的问题是按党派线投票的。
- en: 'Yet another type of filtering is required when we need to skip all the duplicate
    elements in a stream and select only unique ones. The `distinct()` method is designed
    for the purpose. We will use it to find the names of the parties that have their
    members in the `Senate` class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要跳过流中的所有重复元素并仅选择唯一元素时，我们需要另一种类型的过滤。`distinct()`方法就是为此设计的。我们将使用它来找到在`Senate`类中有成员的党派的名称：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The result, as expected, is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如预期的那样：
- en: '![Using Other Stream Operations for Filtering](img/05_12.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_12.jpg)'
- en: Well, no surprise there?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这一点并不奇怪吧？
- en: 'We can also filter out all the elements of the `stream` except the certain
    count of the first ones, using the `limit()` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`limit()`方法来过滤掉`stream`中除了前几个元素之外的所有元素：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you remember how we have set up the first five senators in the list, you
    could predict that the result will be as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我们如何设置列表中的前五位参议员，你可以预测结果会是这样的：
- en: '![Using Other Stream Operations for Filtering](img/05_13.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_13.jpg)'
- en: 'Now let''s find only one element in a stream--the biggest one. To do this,
    we can use the `max()` method of the `Stream` interface and the `Senate.timeVotedYes()`
    method (we will apply it on each senator):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们只在流中找到一个元素--最大的一个。为此，我们可以使用`Stream`接口的`max()`方法和`Senate.timeVotedYes()`方法（我们将对每个参议员应用它）：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Using Other Stream Operations for Filtering](img/05_14.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_14.jpg)'
- en: Yes, we got `Senator100` filtered as the one who voted `Yes` on all 10 issues.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们过滤出了`Senator100`，他是在所有10个问题上都投了赞成票的人。
- en: 'Similarly, we can find the senator who voted `No` on all 10 issues:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以找到在所有10个问题上都投了反对票的参议员：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We expect it to be `Senator99`, and here is the result:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望它是`Senator99`，结果如下：
- en: '![Using Other Stream Operations for Filtering](img/05_15.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_15.jpg)'
- en: That's why we hardcoded several stats in the `Senate` class, so we can verify
    that our queries work correctly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们在`Senate`类中硬编码了几个统计数据，这样我们就可以验证我们的查询是否正确。
- en: 'As the last two methods can help us with filtering, we will demonstrate the
    `takeWhile()` and `dropWhile()`methods introduced in JDK 9\. We will first print
    the data of all the first five senators and then use the `takeWhile()`method to
    print the first senators until we encounter the one who voted `Yes` more than
    four times, and then stop printing:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最后两种方法可以帮助我们进行过滤，我们将演示JDK 9中引入的`takeWhile()`和`dropWhile()`方法。我们将首先打印出前五位参议员的数据，然后使用`takeWhile()`方法打印出第一位参议员，直到我们遇到投票超过四次的参议员，然后停止打印：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result for the previous code is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的结果如下：
- en: '![Using Other Stream Operations for Filtering](img/05_16.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_16.jpg)'
- en: 'The `dropWhile()` method can be used for the opposite effect, that is, to filter
    away, to skip the first senators until we encounter the one who voted `Yes` more
    than four times, then continue printing all the rest of the senators:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropWhile()`方法可以用于相反的效果，即过滤掉，跳过前几位参议员，直到我们遇到投票超过四次的参议员，然后继续打印剩下的所有参议员：'
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The result will be as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下：
- en: '![Using Other Stream Operations for Filtering](img/05_17.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他流操作进行过滤](img/05_17.jpg)'
- en: This concludes our demonstration of the ways in which a stream of elements can
    be filtered. We hope you have learned enough to be able to find a solution for
    any of your filtering needs. Nevertheless, we encourage you to study and experiment
    with the Stream API on your own, so you can retain what you have learned so far
    and acquire your own view on the rich APIs of Java 9.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对元素流可以被过滤的方式的演示。我们希望您已经学会了足够的知识，能够为您的任何过滤需求找到解决方案。然而，我们鼓励您自己学习和尝试Stream
    API，这样您就可以保留到目前为止学到的知识，并对Java 9丰富的API有自己的看法。
- en: Stack-Walking APIs
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈遍历API
- en: Exceptions do happen, especially during development or the period of software
    stabilization. But in a big complex system, the chance of getting an exception
    is possible even in production, especially when several third-party systems are
    brought together and the need arises to analyze the stack trace programmatically
    in order to apply an automatic correction. In this section, we will discuss how
    it can be done.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 异常确实会发生，特别是在开发过程中或软件稳定期间。但在一个大型复杂系统中，即使在生产环境中，也有可能出现异常，特别是当多个第三方系统被整合在一起，并且需要以编程方式分析堆栈跟踪以应用自动修正时。在本节中，我们将讨论如何做到这一点。
- en: Stack Analysis before Java 9
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 9之前的堆栈分析
- en: 'The traditional reading of the stack trace, using objects of the `java.lang.Thread`
    and `java.lang.Throwable`classes, was accomplished by capturing it from the standard
    output. For example, we can include this line in any section of the code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`java.lang.Thread`和`java.lang.Throwable`类的对象来传统地读取堆栈跟踪是通过从标准输出中捕获它来完成的。例如，我们可以在代码的任何部分包含这行：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The previous line will produce the following output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行将产生以下输出：
- en: '![Stack Analysis before Java 9](img/05_18.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Java 9之前的堆栈分析](img/05_18.jpg)'
- en: 'Similarly, we can include this line in the code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在代码中包含这行：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output will then look like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后输出看起来像这样：
- en: '![Stack Analysis before Java 9](img/05_19.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Java 9之前的堆栈分析](img/05_19.jpg)'
- en: This output can be captured, read, and analyzed programmatically, but requires
    quite a bit of custom code writing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出可以被程序捕获、读取和分析，但需要相当多的自定义代码编写。
- en: 'JDK 8 made this easier via the usage of streams. Here is the code that allows
    reading the stack trace from the stream:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 8通过使用流使这变得更容易。以下是允许从流中读取堆栈跟踪的代码：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The previous line produces the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行产生以下输出：
- en: '![Stack Analysis before Java 9](img/05_20.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Java 9之前的堆栈分析](img/05_20.jpg)'
- en: 'Alternatively, we could use this code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用这段代码：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of the previous code shows the stack trace in a similar way:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出以类似的方式显示堆栈跟踪：
- en: '![Stack Analysis before Java 9](img/05_21.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Java 9之前的堆栈分析](img/05_21.jpg)'
- en: 'If, for example, you would like to find the fully qualified name of the caller
    class, you can use one of these approaches:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想要找到调用者类的完全限定名，可以使用以下方法之一：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Such coding is possible because the `getStackTrace()` method returns an array
    of objects of the `java.lang.StackTraceElement` class, each representing a stack
    frame in a stack trace. Each object carries stack trace information accessible
    by the `getFileName()`, `getClassName()`, `getMethodName()`, and `getLineNumber()`
    methods.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编码是可能的，因为`getStackTrace()`方法返回`java.lang.StackTraceElement`类的对象数组，每个对象代表堆栈跟踪中的一个堆栈帧。每个对象都携带着可以通过`getFileName()`、`getClassName()`、`getMethodName()`和`getLineNumber()`方法访问的堆栈跟踪信息。
- en: 'To demonstrate how it works, we have created three classes, `Clazz01`, `Clazz02`,
    and `Clazz03`, that call each other:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示它是如何工作的，我们创建了三个类，`Clazz01`、`Clazz02`和`Clazz03`，它们相互调用：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s call the `method()` method of `Clazz01`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调用`Clazz01`的`method()`方法：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here are two (the second and the third) of the six stack trace frames printed
    out by the preceding code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码打印出的六个堆栈跟踪帧中的两个（第二个和第三个）：
- en: '![Stack Analysis before Java 9](img/05_22.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Java 9之前的堆栈分析](img/05_22.jpg)'
- en: In principle, every called class has access to this information. But to find
    out which class called the current class may not be so easy because you need to
    figure out which frame represents the caller. Also, in order to provide this info,
    JVM captures the entire stack (except for the hidden stack frames), and it may
    affect performance.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，每个被调用的类都可以访问这些信息。但是要找出哪个类调用了当前类可能并不容易，因为你需要找出哪个帧代表了调用者。此外，为了提供这些信息，JVM会捕获整个堆栈（除了隐藏的堆栈帧），这可能会影响性能。
- en: That was the motivation for introducing the `java.lang.StackWalker` class, its
    nested `Option` class, and the `StackWalker.StackFrame` interface in JDK 9.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是引入JDK 9中的`java.lang.StackWalker`类、其嵌套的`Option`类和`StackWalker.StackFrame`接口的动机。
- en: New Better Way to Walk the Stack
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的堆栈遍历方式
- en: 'The `StackWalker` class has four `getInstance()` static factory methods:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackWalker`类有四个`getInstance()`静态工厂方法：'
- en: '`getInstance()`: This returns a `StackWalker` class instance configured to
    skip all hidden frames and the caller class reference'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInstance()`: 这返回一个配置为跳过所有隐藏帧和调用者类引用的`StackWalker`类实例'
- en: '`getInstance(StackWalker.Option option)`: This creates a `StackWalker` class
    instance with the given option specifying the stack frame information it can access'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInstance(StackWalker.Option option)`: 这创建一个具有给定选项的`StackWalker`类实例，指定它可以访问的堆栈帧信息'
- en: '`getInstance(Set<StackWalker.Option> options)`: This creates a `StackWalker`
    class instance with the given set of options'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInstance(Set<StackWalker.Option> options)`: 这创建一个具有给定选项集的`StackWalker`类实例'
- en: '`getInstance(Set<StackWalker.Option> options, int estimatedDepth)`: This allows
    you to pass in the `estimatedDepth` parameter that specifies the estimated number
    of stack frames this instance will traverse so that the Java machine can allocate
    the appropriate buffer size it might need'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getInstance(Set<StackWalker.Option> options, int estimatedDepth)`: 这允许您传入指定估计堆栈帧数量的`estimatedDepth`参数，以便Java虚拟机可以分配可能需要的适当缓冲区大小。'
- en: 'The value passed as an option can be one of the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 作为选项传递的值可以是以下之一：
- en: '`StackWalker.Option.RETAIN_CLASS_REFERENCE`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackWalker.Option.RETAIN_CLASS_REFERENCE`'
- en: '`StackWalker.Option.SHOW_HIDDEN_FRAMES`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackWalker.Option.SHOW_HIDDEN_FRAMES`'
- en: '`StackWalker.Option.SHOW_REFLECT_FRAMES`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackWalker.Option.SHOW_REFLECT_FRAMES`'
- en: 'The other three methods of the `StackWalker` class are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackWalker`类的另外三种方法如下：'
- en: '`T walk(Function<Stream<StackWalker.StackFrame>, T> function)`: This applies
    the passed in function to the stream of stack frames, the first frame representing
    the method that called this `walk()` method'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T walk(Function<Stream<StackWalker.StackFrame>, T> function)`: 这将传入的函数应用于堆栈帧流，第一个帧代表调用`walk()`方法的方法'
- en: '`void forEach(Consumer<StackWalker.StackFrame> action)`: This performs the
    passed in action on each element (of the `StalkWalker.StackFrame` interface type)
    of the stream of the current thread'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void forEach(Consumer<StackWalker.StackFrame> action)`: 这对当前线程的流中的每个元素（`StalkWalker.StackFrame`接口类型）执行传入的操作'
- en: '`Class<?> getCallerClass()`: This gets objects of the `Class` class of the
    caller class'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Class<?> getCallerClass()`: 这获取调用者类的`Class`类对象'
- en: 'As you can see, it allows much more straightforward stack trace analysis. Let''s
    modify our demo classes using the following code and access the caller name in
    one line:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它允许更加直接的堆栈跟踪分析。让我们使用以下代码修改我们的演示类，并在一行中访问调用者名称：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The previous code will produce this output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将产生以下输出：
- en: '![New Better Way to Walk the Stack](img/05_23.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![更好的堆栈遍历方式](img/05_23.jpg)'
- en: 'You can appreciate the simplicity of the solution. If we need to see the entire
    stack trace, we can add the following line to the code in `Clazz03`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以欣赏到这种解决方案的简单性。如果我们需要查看整个堆栈跟踪，我们可以在`Clazz03`的代码中添加以下行：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The resulting output will be as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的输出将如下所示：
- en: '![New Better Way to Walk the Stack](img/05_24.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![更好的堆栈遍历方式](img/05_24.jpg)'
- en: 'Again, with only one line of code, we have achieved much more readable output.
    We could achieve the same result by using the `walk()` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，只需一行代码，我们就实现了更加可读的输出。我们也可以使用`walk()`方法来实现相同的结果：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Instead of just printing `StackWalker.StackFrame`, we also could run a deeper
    analysis on it, if need be, using its API, which is more extensive than the API
    of `java.lang.StackTraceElement`. Let''s run the code example that prints every
    stack frame and its information:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以打印`StackWalker.StackFrame`，如果需要的话，还可以对其进行更深入的分析，因为它的API比`java.lang.StackTraceElement`的API更加广泛。让我们运行打印每个堆栈帧及其信息的代码示例：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of the previous code is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![New Better Way to Walk the Stack](img/05_25.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![更好的堆栈遍历方式](img/05_25.jpg)'
- en: Note the `StackFrameInfo` class that implements the `StackWalker.StackFrame`
    interface and actually does the job. The API also allows converting back to the
    familiar `StackTraceElement` object for backward compatibility and for the enjoyment
    of those who are used to it and do not want to change their code and habits.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`StackFrameInfo`类实现了`StackWalker.StackFrame`接口并实际执行了任务。该API还允许将其转换回熟悉的`StackTraceElement`对象，以实现向后兼容性，并让那些习惯于它并且不想改变他们的代码和习惯的人享受它。
- en: In contrast, with the full stack trace generated and stored in the array in
    the memory (like in the case of the traditional stack trace implementation), the
    `StackWalker` class brings only the requested elements. This is another motivation
    for its introduction in addition to the demonstrated simplicity of use. More details
    about the `StackWalker` class API and its usage can be found at [https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.html](https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.html).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，与在内存中生成并存储完整堆栈跟踪（就像传统堆栈跟踪实现的情况）不同，`StackWalker`类只提供了请求的元素。这是它引入的另一个动机，除了演示的使用简单性。有关`StackWalker`类API及其用法的更多详细信息，请参阅[https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.html](https://docs.oracle.com/javase/9/docs/api/java/lang/StackWalker.html)。
- en: Convenience Factory Methods for Collections
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合的便利工厂方法
- en: 'With the introduction of functional programming in Java, the interest in and
    need for immutable objects increased. The functions passed into the methods may
    be executed in substantially different contexts than the one they were created
    in, so the need to decrease the chances of unexpected side effects made the case
    for immutability stronger. Besides, the Java way of creating an unmodifiable collection
    was quite verbose anyway, so the issue was addressed in Java 9\. Here is an example
    of the code that creates an immutable collection of the `Set` interface in Java
    8:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Java中函数式编程的引入，对不可变对象的兴趣和需求增加了。传递到方法中的函数可能在与创建它们的上下文大不相同的情况下执行，因此减少意外副作用的可能性使得不可变性的案例更加有力。此外，Java创建不可修改集合的方式本来就相当冗长，所以这个问题在Java
    9中得到了解决。以下是在Java 8中创建`Set`接口的不可变集合的代码示例：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After one does it several times, the need for a convenience method comes up
    naturally as the basic refactoring consideration that always lingers in the background
    thinking of any software professional. In Java 8, the previous code could be changed
    to the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 做了几次之后，作为任何软件专业人员思考的基本重构考虑的一部分，自然而然地会出现对方便方法的需求。在Java 8中，前面的代码可以改为以下形式：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Alternatively, if streams are your friends, you could write the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果流是你的朋友，你可以写如下代码：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another version of the previous code is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的另一个版本如下：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, it has more boilerplate code than the values you are trying to encapsulate.
    So, in Java 9, a shorter version of the previous code became possible:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它比你试图封装的值有更多的样板代码。因此，在Java 9中，前面的代码的更短版本成为可能：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Similar factories were introduced to generate immutable collections of `List`
    interfaces and `Map` interfaces:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的工厂被引入来生成`List`接口和`Map`接口的不可变集合：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Why New Factory Methods?
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要使用新的工厂方法？
- en: 'The ability to express the same functionality in more compact manner is very
    helpful, but it would probably not be enough motivation to introduce these new
    factories. It was much more important to address the weakness of the existing
    implementation of `Collections.unmodifiableList()`, `Collections.unmodifiableSet()`,
    and `Collections.unmodifiableMap()`. Although the collections created using these
    methods throw an `UnsupportedOperationException` class when you try to modify
    or add/remove their elements, they are just wrappers around the traditional modifiable
    collections and can thus be susceptible to modifications, depending on the way
    you construct them. Let''s walk through examples to illustrate the point. By the
    way, another weakness of the existing unmodifiable implementation is that it does
    not change how the source collection is constructed, so the difference between
    `List`, `Set`, and `Map`--the ways in which they can be constructed--remains in
    place, which may be a source of bugs or even frustration when a programmer uses
    them. The new factory methods address this issue too, providing a more unified
    approach using the `of()` factory method (and the additional `ofEntries()` method
    for `Map`) only. Having said that, let''s get back to the examples. Look at the
    following code snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 能够以更紧凑的方式表达相同的功能是非常有帮助的，但这可能不足以成为引入这些新工厂的动机。更重要的是要解决现有的`Collections.unmodifiableList()`、`Collections.unmodifiableSet()`和`Collections.unmodifiableMap()`实现的弱点。虽然使用这些方法创建的集合在尝试修改或添加/删除元素时会抛出`UnsupportedOperationException`类，但它们只是传统可修改集合的包装器，因此可能会受到修改的影响，取决于构造它们的方式。让我们通过示例来说明这一点。另外，现有的不可修改实现的另一个弱点是它不会改变源集合的构造方式，因此`List`、`Set`和`Map`之间的差异--它们可以被构造的方式--仍然存在，这可能是程序员在使用它们时的错误或甚至是挫折的来源。新的工厂方法也解决了这个问题，只使用`of()`工厂方法（以及`Map`的附加`ofEntries()`方法）。话虽如此，让我们回到示例。看一下以下代码片段：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Attempts of direct modification of the elements of `unmodifiableList1` lead
    to `UnsupportedOperationException`. Nevertheless, we can modify them via the underlying
    `list` object. If we run the previous example, the output will be as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 直接修改`unmodifiableList1`的元素会导致`UnsupportedOperationException`。然而，我们可以通过底层的`list`对象来修改它们。如果我们运行前面的示例，输出将如下所示：
- en: '![Why New Factory Methods?](img/05_26.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![为什么要使用新的工厂方法？](img/05_26.jpg)'
- en: 'Even if we use `Arrays.asList()` for the source list creation, it will only
    protect the created collection from adding a new element, but not from modifying
    the existing one. Here is a code example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们使用`Arrays.asList()`来创建源列表，它也只能保护创建的集合免受添加新元素的影响，而不能防止修改现有元素。以下是一个代码示例：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we run the previous code, the output will be as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，输出将如下所示：
- en: '![Why New Factory Methods?](img/05_27.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![为什么要使用新的工厂方法？](img/05_27.jpg)'
- en: We also included a `null` element to demonstrate how the existing implementation
    treats them, because, by contrast, the new factories of immutable collections
    do not allow `null` to be included. By the way, they do not allow duplicate elements
    in `Set` either (while the existing implementation just ignores them), but we
    will demonstrate this aspect later while using the new factory methods in code
    examples.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包括了一个`null`元素来演示现有实现如何处理它们，因为相比之下，不可变集合的新工厂不允许包含`null`。另外，它们也不允许在`Set`中包含重复元素（而现有的实现只是忽略它们），但我们将在后面的代码示例中使用新的工厂方法来演示这一方面。
- en: 'To be fair, there is a way to create a truly immutable collection of `List`
    interfaces with the existing implementation too. Look at the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，使用现有的实现也可以创建`List`接口的真正不可变集合。看一下以下代码：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Another way to create an immutable list is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建不可变列表的另一种方法如下：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following is a variation of the earlier code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的变体：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we run the previous three examples, we will see the following output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的三个示例，将看到以下输出：
- en: '![Why New Factory Methods?](img/05_28.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![为什么要使用新的工厂方法？](img/05_28.jpg)'
- en: Note that although we cannot modify the content of these lists, we can put `null`
    in them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们不能修改这些列表的内容，但我们可以在其中放入`null`。
- en: 'The situation with `Set` is quite similar to what we have seen with the lists
    earlier. Here is the code that shows how an unmodifiable collection of `Set` interfaces
    can be modified:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前看到的列表情况相似，`Set`的情况也是如此。以下是显示如何修改不可修改的`Set`接口集合的代码：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The resulting collection of `Set` interfaces can be modified even if we convert
    the original collection from an array to a list and then to a set, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将原始集合从数组转换为列表，然后再转换为集合，也可以修改`Set`接口的结果集合，如下所示：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here is the output of running the previous two examples:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前两个示例的输出如下：
- en: '![Why New Factory Methods?](img/05_29.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![为什么要使用新的工厂方法？](img/05_29.jpg)'
- en: If you have not worked with sets in Java 9, you may be surprised to see the
    unusually messed up order of the set elements in the output. In fact, it is another
    new feature of set and maps introduced in JDK 9\. In the past, `Set` and `Map`
    implementations did not guarantee to preserve the elements' order. But more often
    than not, the order was preserved and some programmers wrote code that relied
    on it, thus introducing an annoyingly inconsistent and not easily reproducible
    defect into an application. The new `Set` and `Map` implementations change the
    order more often, if not at every new run of the code. This way, it exposes potential
    defects early in development and decreases the chance of its propagation into
    production.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Java 9中没有使用集合，可能会对输出中集合元素的异常顺序感到惊讶。实际上，这是JDK 9中引入的集合和映射的另一个新特性。过去，`Set`和`Map`的实现不能保证保留元素的顺序。但很多时候，顺序是被保留的，一些程序员编写了依赖于此的代码，从而在应用程序中引入了一个令人讨厌的不一致且不易重现的缺陷。新的`Set`和`Map`实现更经常地改变顺序，如果不是在每次运行代码时都改变。这样，它可以在开发的早期暴露潜在的缺陷，并减少其传播到生产环境的机会。
- en: 'Similar to the lists, we can create immutable sets even without using Java
    9''s new immutable set factory. One way to do it is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表类似，即使不使用Java 9的新不可变集合工厂，我们也可以创建不可变集合。其中一种方法如下：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Also, as in the case with lists, here is another way to do it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表的情况一样，这里还有另一种方法：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Another variant of the previous code is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的另一种变体如下：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we run all three examples of creating an immutable collection of `iSet`
    interfaces that we have just introduced, the result would be as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行刚刚介绍的创建`iSet`接口的不可变集合的三个示例，结果将如下：
- en: '![Why New Factory Methods?](img/05_30.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![为什么要使用新的工厂方法？](img/05_30.jpg)'
- en: 'With `Map` interfaces, we were able to come up with only one way to modify
    the `unmodifiableMap` object:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Map`接口，我们只能想出一种修改`unmodifiableMap`对象的方法：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output of the previous code is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![Why New Factory Methods?](img/05_31.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![为什么要使用新的工厂方法？](img/05_31.jpg)'
- en: 'We found four ways to create an immutable collection of `Map` interfaces without
    using Java 9 enhancements. Here is the first example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了四种在不使用Java 9增强功能的情况下创建`Map`接口的不可变集合的方法。以下是第一个示例：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The second example has a bit of a complication:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例有点复杂：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'A variant of the previous code is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的另一种变体如下：
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After we run all the four last examples, the output is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行了所有四个最后的示例之后，输出如下：
- en: '![Why New Factory Methods?](img/05_32.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![为什么要使用新的工厂方法？](img/05_32.jpg)'
- en: With that revision of the existing collections implementations, we can now discuss
    and appreciate the new factory methods of collections in Java 9.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对现有集合实现的修订，我们现在可以讨论并欣赏Java 9中集合的新工厂方法。
- en: The New Factory Methods in Action
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在实践中使用新的工厂方法
- en: 'After revisiting the existing methods of collection creation, we can now review
    and enjoy the related API introduced in Java 9\. As in a previous section, we
    start with the `List` interface. Here is how simple and consistent the immutable
    list creation can be using the new `List.of()` factory method:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新审视集合创建的现有方法之后，我们现在可以回顾并享受Java 9中引入的相关API。就像在前一节中一样，我们从`List`接口开始。使用新的`List.of()`工厂方法创建不可变列表是多么简单和一致：
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see from the previous code comments, the new factory method does
    not allow including `null` as the list value.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码注释中可以看出，新的工厂方法不允许将`null`包括在列表值中。
- en: 'The `immutableSet` creation looks similar to this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`immutableSet`的创建看起来类似于这样：'
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see from the previous code comments, the `Set.of()` factory method
    does not allow adding `null` or a duplicate element when creating an immutable
    collection of `Set` interfaces.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码注释中可以看出，`Set.of()`工厂方法在创建`Set`接口的不可变集合时不允许添加`null`或重复元素。
- en: 'The immutable collection of `Map` interfaces has similar format too:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变的`Map`接口集合格式也类似：
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `Map.of()` method does not allow `null` as a value either. Another feature
    of the `Map.of()` method is that it allows a compile-time check of the element
    type, which decreases the chances of a runtime problem.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map.of()`方法也不允许值为`null`。`Map.of()`方法的另一个特性是它允许在编译时检查元素类型，这减少了运行时问题的可能性。'
- en: 'For those who prefer more compact code, here is another way to express the
    same functionality:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些更喜欢更紧凑代码的人，这是另一种表达相同功能的方法：
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And here is the output if we run all the previous examples of the usage of
    the new factory methods:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行所有先前使用新工厂方法的示例，输出如下：
- en: '![The New Factory Methods in Action](img/05_33.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![实践中使用新的工厂方法](img/05_33.jpg)'
- en: 'As we mentioned already, the ability to have immutable collections, including
    empty ones, is very helpful for functional programming as this feature makes sure
    that such a collection cannot be modified as a side effect and cannot introduce
    unexpected and difficult to trace defects. The full variety of the new factories
    methods includes up to 10 explicit entries plus one with an arbitrary number of
    elements. Here''s how it looks for `List` interface:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，具有不可变集合的能力，包括空集合，对于函数式编程非常有帮助，因为这个特性确保这样的集合不能作为副作用被修改，也不能引入意外和难以追踪的缺陷。新工厂方法的完整种类包括多达10个显式条目，再加上一个具有任意数量元素的条目。对于`List`接口，它看起来是这样的：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `Set` factory methods look similar:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`工厂方法看起来类似：'
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Also, the `Map` factory methods follow suit:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Map`工厂方法也遵循相同的规则：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The decision not to add new interfaces for immutable collections left them susceptible
    to causing occasional confusion when programmers assumed they could call `add()`
    or `put()` on them. Such an assumption, if not tested, will cause a runtime error
    that throws an `UnsupportedOperationException`. Despite this potential pitfall,
    the new factory methods for immutable collection creation are very useful additions
    to Java.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 决定不为不可变集合添加新接口使它们容易引起偶尔的混淆，当程序员假设可以在它们上调用`add()`或`put()`时。如果没有经过测试，这样的假设会导致抛出`UnsupportedOperationException`的运行时错误。尽管存在这种潜在的陷阱，不可变集合创建的新工厂方法是Java中非常有用的补充。
- en: CompletableFuture in Support of Asynchronous Processing
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持异步处理的CompletableFuture
- en: The `java.util.concurrent.CompletableFuture<T>` class was first introduced in
    Java 8\. It is the next level of asynchronous call control over `java.util.concurrent.Future<T>`
    interface. It actually implements `Future`, as well as `java.util.concurrent.CompletionStage<T>`.
    In Java 9, `CompletableFuture` was enhanced by adding new factory methods, support
    for delays and timeouts, and improved subclassing--we will discuss these features
    in more details in the sections to follow. But first, let's have an overview of
    the `CompletableFuture` API.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.CompletableFuture<T>`类首次在Java 8中引入。它是对`java.util.concurrent.Future<T>`接口的异步调用控制的下一级。它实际上实现了`Future`，以及`java.util.concurrent.CompletionStage<T>`。在Java
    9中，通过添加新的工厂方法、支持延迟和超时以及改进的子类化，增强了`CompletableFuture`——我们将在接下来的章节中更详细地讨论这些特性。但首先，让我们概述一下`CompletableFuture`的API。'
- en: The CompletableFuture API Overview
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`CompletableFuture` API概述'
- en: The `CompletableFuture` API consists of more than 70 methods, 38 of which are
    implementations of the `CompletionStage` interface, and five are the implementations
    of `Future`. Because the `CompletableFuture`class implements the `Future` interface,
    it can be treated as `Future` and will not break the existing functionality based
    on the `Future` API.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture`的API包括70多个方法，其中38个是`CompletionStage`接口的实现，5个是`Future`的实现。因为`CompletableFuture`类实现了`Future`接口，它可以被视为`Future`，并且不会破坏基于`Future`API的现有功能。'
- en: 'So, the bulk of the API comes from `CompletionStage`. Most of the methods return
    `CompletableFuture` (in the `CompletionStage` interface, they return `CompletionStage`,
    but they are converted to `CompletableFuture`when implemented in `CompletableFuture`
    class), which means that they allow chaining the operations similar to how the
    `Stream` methods do when only one element goes through a pipe. Each method has
    a signature that accepts a function. Some methods accept `Function<T,U>`, which
    is going to be applied to the passed-in value `T` and return the result `U`. Other
    methods accept `Consumer<T>`, which takes the passed-in value and returns `void`.
    Yet other methods accept `Runnable`, which does not take any input and returns
    `void`. Here is one group of these methods:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，API的大部分来自`CompletionStage`。大多数方法返回`CompletableFuture`（在`CompletionStage`接口中，它们返回`CompletionStage`，但在`CompletableFuture`类中实现时会转换为`CompletableFuture`），这意味着它们允许链接操作，类似于`Stream`方法在管道中只有一个元素通过时的操作。每个方法都有一个接受函数的签名。一些方法接受`Function<T,U>`，它将被应用于传入的值`T`并返回结果`U`。其他方法接受`Consumer<T>`，它接受传入的值并返回`void`。还有其他方法接受`Runnable`，它不接受任何输入并返回`void`。以下是其中一组这些方法：
- en: '[PRE64]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'They all return `CompletableFuture`, which carries the result of the function
    or void (in the case of `Runnable`and `Consumer`). Each of them has two companion
    methods that perform the same function asynchronously. For example, let''s take
    the `thenRun(Runnable action)` method. The following are its companions:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都返回`CompletableFuture`，它携带函数或void的结果（在`Runnable`和`Consumer`的情况下）。它们每个都有两个执行相同功能的异步伴侣方法。例如，让我们看一下`thenRun(Runnable
    action)`方法。以下是它的伴侣们：
- en: The `thenRunAsync(Runnable action)` method, which runs the action in another
    thread from the default `ForkJoinPool.commonPool()` pool
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenRunAsync(Runnable action)`方法会在另一个线程中运行操作，使用默认的`ForkJoinPool.commonPool()`线程池。'
- en: The `thenRun(Runnable action, Executor executor)` method, which runs the action
    in another thread from the pool passed in as the parameter executor
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenRun(Runnable action, Executor executor)`方法会在传入的参数executor作为线程池的另一个线程中运行操作。'
- en: With that, we have covered nine methods of the `CompletionStage` interface.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经介绍了`CompletionStage`接口的九种方法。
- en: 'Another group of methods consists of the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组方法包括以下内容：
- en: '[PRE65]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: These methods execute the passed in action after one or both the `CompletableFuture`
    (or `CompletionStage`) objects produce a result that is used as an input to the
    action. By both, we mean the `CompletableFuture` that provides the method and
    the one that is passed in as a parameter of the method. From the name of these
    methods, you can quite reliably guess what their intent is. We will demonstrate
    some of them in the following examples. Each of these seven methods has two companions
    for asynchronous processing, too. This means that we have already described 30
    (out of 38) methods of the `CompletionStage` interface.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在一个或两个`CompletableFuture`（或`CompletionStage`）对象产生作为输入传递给操作的结果后执行传入的操作。这里的“两个”指的是提供方法的`CompletableFuture`和作为方法参数传入的`CompletableFuture`。从这些方法的名称中，你可以相当可靠地猜测它们的意图。我们将在接下来的示例中演示其中一些。每个这七个方法都有两个用于异步处理的伴侣。这意味着我们已经描述了`CompletionStage`接口的30种（共38种）方法。
- en: 'There is a group of two methods that are typically used as terminal operations
    because they can handle either the result of the previous method (passed in as
    `T`) or an exception (passed in as `Throwable`):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一组通常用作终端操作的两种方法，因为它们可以处理前一个方法的结果（作为`T`传入）或异常（作为`Throwable`传入）：
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We will see an example of the use of these methods later. When an exception
    is thrown by a method in the chain, all the rest of the chained methods are skipped
    until the first `handle()` method or `whenComplete()` is encountered. If neither
    of these two methods are present in the chain, then the exception will bubble
    up as any other Java exception. These two also have asynchronous companions, which
    means that we talked about 36 (out of 38) methods of `CompletionStage` interface
    already.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将看到这些方法的使用示例。当链中的方法抛出异常时，所有其余的链接方法都会被跳过，直到遇到第一个`handle()`方法或`whenComplete()`方法。如果链中没有这两个方法中的任何一个，那么异常将像其他Java异常一样冒泡。这两个方法也有异步伴侣，这意味着我们已经讨论了`CompletionStage`接口的36种（共38种）方法。
- en: 'There is also a method that handles exceptions only (similar to a catch block
    in the traditional programming):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个仅处理异常的方法（类似于传统编程中的catch块）：
- en: '[PRE67]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This method does not have asynchronous companions, just like the last remaining
    method:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法没有异步伴侣，就像最后剩下的方法一样。
- en: '[PRE68]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It just returns a `CompletableFuture` object with the same properties as this
    stage. With that, we have described all 38 methods of the `CompletionStage` interface.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 它只返回一个具有与此阶段相同属性的`CompletableFuture`对象。有了这个，我们已经描述了`CompletionStage`接口的所有38种方法。
- en: 'There are also some 30 methods in the `CompletableFuture` class that do not
    belong to any of the implemented interfaces. Some of them return the `CompletableFuture`
    object after asynchronously executing the provided function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture`类中还有大约30种不属于任何实现接口的方法。其中一些在异步执行提供的函数后返回`CompletableFuture`对象：'
- en: '[PRE69]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Others execute several objects of `CompletableFuture` in parallel:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 其他人并行执行几个`CompletableFuture`对象：
- en: '[PRE70]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'There is also a group of the methods that generate completed futures, so the
    `get()` method on the returned `CompletableFuture` object will not block any more:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一组生成已完成future的方法，因此返回的`CompletableFuture`对象上的`get()`方法将不再阻塞：
- en: '[PRE71]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The rest of the methods perform various other functions that can be helpful:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的方法执行各种其他有用的功能：
- en: '[PRE72]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Refer to the official Oracle documentation, which describes these and other
    methods of the `CompletableFuture` API at [http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html](http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考官方Oracle文档，其中描述了`CompletableFuture` API的这些和其他方法，网址为[http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html](http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html)。
- en: The CompletableFuture API Enhancements in Java 9
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 9中的`CompletableFuture` API增强
- en: 'Java 9 introduces several enhancements to `CompletableFuture`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9为`CompletableFuture`引入了几项增强功能：
- en: The `CompletionStage<U> failedStage(Throwable ex)` factory method returns the
    `CompletionStage` object completed with the given exception
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<U> failedStage(Throwable ex)`工厂方法返回使用给定异常完成的`CompletionStage`对象'
- en: The `CompletableFuture<U> failedFuture(Throwable ex)` factory method returns
    the `CompletableFuture`object completed with the given exception
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<U> failedFuture(Throwable ex)`工厂方法返回使用给定异常完成的`CompletableFuture`对象'
- en: The new `CompletionStage<U> completedStage(U value)` factory method returns
    the `CompletionStage` object completed with the given `U` value
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`CompletionStage<U> completedStage(U value)`工厂方法返回使用给定`U`值完成的`CompletionStage`对象
- en: '`CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit unit)`
    completes `CompletableFuture` task with the given `T` value if not otherwise completed
    before the given timeout'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit unit)`如果在给定的超时之前未完成，则使用给定的`T`值完成`CompletableFuture`任务'
- en: '`CompletableFuture<T> orTimeout(long timeout, TimeUnit unit)` completes `CompletableFuture`
    with `java.util.concurrent.TimeoutException` if not completed before the given
    timeout'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<T> orTimeout(long timeout, TimeUnit unit)`如果在给定的超时之前未完成，则使用`java.util.concurrent.TimeoutException`完成`CompletableFuture`'
- en: It is possible now to override the `defaultExecutor()` method to support another
    default executor
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在可以重写`defaultExecutor()`方法以支持另一个默认执行程序
- en: A new method, `newIncompleteFuture()`, makes it easier to subclass the `CompletableFuture`
    class
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新方法`newIncompleteFuture()`使得子类化`CompletableFuture`类更容易
- en: The Problem and the Solution using Future
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题和解决方案使用Future
- en: 'To demonstrate and appreciate the power of `CompletableFuture`, let''s start
    with a problem implemented using just `Future` and then see how much more effectively
    it can be solved with `CompletableFuture`. Let''s imagine that we are tasked with
    modeling a building that consists of four stages:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示和欣赏`CompletableFuture`的强大功能，让我们从使用`Future`解决的问题开始，然后看看使用`CompletableFuture`可以更有效地解决多少。假设我们的任务是对由四个阶段组成的建筑进行建模：
- en: Collecting materials for the foundation, walls, and roof
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集地基、墙壁和屋顶的材料
- en: Installing the foundation
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装地基
- en: Raising up the walls
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竖起墙壁
- en: Constructing and finishing the roof
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搭建和完成屋顶
- en: 'In the traditional sequential programming for the single thread, the model
    would look like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的单线程顺序编程中，模型如下：
- en: '[PRE73]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here, `Stage` is an enumeration:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Stage`是一个枚举：
- en: '[PRE74]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `doStage()` method has two overloaded versions. Here is the first one:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`doStage()`方法有两个重载版本。这是第一个版本：'
- en: '[PRE75]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The second version is as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本如下：
- en: '[PRE76]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `sleepSec()`, `isSuccess()`, and `getResult()` methods look like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleepSec()`、`isSuccess()`和`getResult()`方法如下：'
- en: '[PRE77]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The successful house construction (if we run the previous code without assigning
    any value to the `failedStage` variable) looks like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的房屋建造（如果我们运行之前的代码而没有为`failedStage`变量分配任何值）如下所示：
- en: '![The Problem and the Solution using Future](img/05_34.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![使用Future的问题和解决方案](img/05_34.jpg)'
- en: 'If we set `failedStage=Stage.Walls`, the result will be as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设置`failedStage=Stage.Walls`，结果将如下：
- en: '![The Problem and the Solution using Future](img/05_35.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![使用Future的问题和解决方案](img/05_35.jpg)'
- en: 'Using `Future`, we can shorten the time it takes to build the house:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Future`，我们可以缩短建造房屋所需的时间：
- en: '[PRE78]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here, the `getSuccessOrFirstFailure()` method looks like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`getSuccessOrFirstFailure()`方法如下：
- en: '[PRE79]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The successful building of the house now is faster because material collection
    happens in parallel:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在成功建造房屋的速度更快，因为材料收集是并行进行的：
- en: '![The Problem and the Solution using Future](img/05_36.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![使用Future的问题和解决方案](img/05_36.jpg)'
- en: 'By taking advantage of Java functional programming, we can change the second
    half of our implementation to the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用Java函数式编程，我们可以将实现的后半部分改为以下内容：
- en: '[PRE80]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The chain of the previous nested functions is triggered by `supplier5.get()`
    in the last line. It blocks until all the functions are completed sequentially,
    so there is no performance improvement:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 前面嵌套函数的链由最后一行的`supplier5.get()`触发。它会阻塞，直到所有函数按顺序完成，因此没有性能改进：
- en: '![The Problem and the Solution using Future](img/05_38.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![使用Future的问题和解决方案](img/05_38.jpg)'
- en: And that is as far as we can go with `Future`. Now let's see if we can improve
    the previous code using `CompletableFuture`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们可以使用`Future`的地方。现在让我们看看是否可以使用`CompletableFuture`改进之前的代码。
- en: The Solution with CompletableFuture
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CompletableFuture的解决方案
- en: 'Here''s how we can chain the same operations using the `CompletableFuture`
    API:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用`CompletableFuture` API链接相同操作的方式：
- en: '[PRE81]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To make it work, we had to change the implementation of one of the `doStage()`
    to `doStageEx()` methods:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，我们不得不将`doStage()`中的一个实现更改为`doStageEx()`方法：
- en: '[PRE82]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, let''s see how the system behaves if one of the first stages of collecting
    materials fails (`failedStage = Stage.WallsMaterials`):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看系统在收集材料的第一个阶段失败时的行为（`failedStage = Stage.WallsMaterials`）：
- en: '![The Solution with CompletableFuture](img/05_39.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![使用CompletableFuture的解决方案](img/05_39.jpg)'
- en: The exception was thrown by the `WallsMaterials` stage and caught by the `handleAsync()`
    method, as expected. And, again, the processing was done asynchronously after
    the `Out!!!!!` message was printed.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 异常由`WallsMaterials`阶段抛出，并被`handleAsync()`方法捕获，正如预期的那样。而且，在打印`Out!!!!!`消息后，处理是异步进行的。
- en: Other Useful Features of CompletableFuture
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CompletableFuture的其他有用功能
- en: 'One of the great advantages of `CompletableFuture` is that it can be passed
    around as an object and used several times to start different chains of operations.
    To demonstrate this capability, let''s create several new operations:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture`的一个巨大优势是它可以作为对象传递并多次使用，以启动不同的操作链。为了演示这种能力，让我们创建几个新操作：'
- en: '[PRE84]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The results of these operations are going to be handled by the `myHandler()`
    method:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作的结果将由`myHandler()`方法处理：
- en: '[PRE85]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Note all the different types returned by the operations. Now we can build a
    chain that forks in two at some point:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有操作返回的不同类型。现在我们可以构建一个在某个点分叉的链：
- en: '[PRE86]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The result of this example is as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的结果如下：
- en: '![Other Useful Features of CompletableFuture](img/05_40.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![CompletableFuture的其他有用功能](img/05_40.jpg)'
- en: The `CompletableFuture` API provides a very rich and well-thought-through API
    that supports, among other things, the latest trends in reactive microservices
    because it allows processing data fully asynchronously as it comes in, splitting
    the flow if needed, and scaling to accommodate the increase of the input. We encourage
    you to study the examples (many more are provided in the code that accompanies
    this book) and look at the API at [http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html](http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture` API提供了一个非常丰富和经过深思熟虑的API，支持最新的反应式微服务趋势，因为它允许完全异步地处理数据，根据需要拆分流，并扩展以适应输入的增加。我们鼓励您学习示例（本书附带的代码提供了更多示例），并查看API：[http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html](http://download.java.net/java/jdk9/docs/api/index.html?java/util/concurrent/CompletableFuture.html)。'
- en: Stream API Improvements
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stream API改进
- en: 'Most of the new `Stream` API features in Java 9 have already been demonstrated
    in the section that describes `Stream` filtering. To remind you, here are the
    examples we have demonstrated based on the `Stream` API improvements in JDK 9:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9中大多数新的`Stream` API功能已经在描述`Stream`过滤的部分中进行了演示。为了提醒您，以下是我们基于JDK 9中`Stream`
    API改进所演示的示例：
- en: '[PRE87]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The only one we have not mentioned yet is the new overloaded `iterate()` method:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有提到的是新的重载`iterate()`方法：
- en: '[PRE88]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'An example of its usage is as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 其用法示例如下：
- en: '[PRE89]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We had to add `limit(5)` because this version of the `iterate()` method creates
    an unlimited stream of integer numbers. The result of the previous code is as
    follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不添加`limit(5)`，因为`iterate()`方法的这个版本创建了一个无限的整数流。前面代码的结果如下：
- en: '![Stream API Improvements](img/05_41.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![Stream API改进](img/05_41.jpg)'
- en: 'In Java 9, an overloaded `iterate()` method was added:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，新增了一个重载的`iterate()`方法：
- en: '[PRE90]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'As you see, it has now a `Predicate` functional interface as a parameter that
    allows limiting the stream as needed. For example, the following code produces
    exactly the same result as the previous example with `limit(5)`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，现在它作为参数具有`Predicate`函数接口，允许根据需要限制流。例如，以下代码产生的结果与先前的`limit(5)`示例完全相同：
- en: '[PRE91]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note that the type of the stream element does not need to be an integer. It
    can be any type produced by the source. So, the new `iterate()` method can be
    used to provide criteria for the termination of the stream of any type of data.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，流元素的类型不需要是整数。它可以是源产生的任何类型。因此，新的`iterate()`方法可以用于提供任何类型数据流终止的条件。
- en: Summary
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this lesson, we covered a lot of ground in the area of the new features introduced
    with Java 9\. First, we looked at many ways to stream filtering, starting with
    the basic `filter()` method and ending up using the `Stream` API additions of
    JDK 9\. Then, you learned a better way to analyze the stack trace using the new
    `StackWalker` class. The discussion was illustrated by specific examples that
    help you to see the real working code.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这节课中，我们涵盖了Java 9引入的新功能领域。首先，我们从基本的`filter()`方法开始，介绍了许多流过滤的方法，并最终使用了JDK 9的`Stream`
    API新增功能。然后，您学会了使用新的`StackWalker`类来分析堆栈跟踪的更好方法。讨论通过具体示例进行了说明，帮助您看到真正的工作代码。
- en: We used the same approach while presenting new convenient factory methods for
    creating immutable collections and new capabilities for asynchronous processing
    that came with the `CompletableFuture` class and its enhancements in JDK 9.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在为创建不可变集合的新便利工厂方法和与`CompletableFuture`类及其JDK 9中的增强一起提供的新异步处理功能时使用了相同的方法。
- en: We ended this lesson by enumerating the improvements to the `Stream` API--those
    we have demonstrated in the filtering code examples and the new `iterate()` method.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过列举`Stream` API的改进来结束了这节课--这些改进我们在过滤代码示例和新的`iterate()`方法中已经演示过。
- en: With this, we come to the end of this book. You can now try and apply the tips
    and techniques you have learned to your project or, if it is not suitable for
    that, to build your own Java project for high performance. While doing that, try
    to solve real problems. That will force you to learn new skills and frameworks
    instead of just applying the knowledge you have already, although the latter is
    helpful too--it keeps your knowledge fresh and practical.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些内容，我们结束了这本书。现在你可以尝试将你学到的技巧和技术应用到你的项目中，或者如果不适合，可以为高性能构建自己的Java项目。在这个过程中，尝试解决真实的问题。这将迫使你学习新的技能和框架，而不仅仅是应用你已经掌握的知识，尽管后者也很有帮助--它可以保持你的知识更新和实用。
- en: The best way to learn is to do it yourself. As Java continues to improve and
    expand, watch out for new editions of this and similar books by Packt.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 学习的最佳方式是自己动手。随着Java的不断改进和扩展，敬请期待Packt出版的本书及类似书籍的新版本。
- en: Assessments
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: The _______ interface was introduced in Java 8 to emit elements and supports
    a variety of operations that perform computations based on stream elements.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java 8中引入了_______接口，用于发出元素并支持执行基于流元素的各种操作的计算。
- en: Which of the following factory methods of the `StackWalker` class creates a
    `StackWalker` class instance with the given option of specifying the stack frame
    information that it can access?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StackWalker`类的以下哪个工厂方法创建具有指定堆栈帧信息访问权限的`StackWalker`类实例？'
- en: '`getInstance()`'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getInstance()`'
- en: '`getInstance(StackWalker.Option option)`'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getInstance(StackWalker.Option option)`'
- en: '`getInstance(Set<StackWalker.Option> options)`'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getInstance(Set<StackWalker.Option> options)`'
- en: '`getInstance(Set<StackWalker.Option> options, int estimatedDepth)`'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getInstance(Set<StackWalker.Option> options, int estimatedDepth)`'
- en: 'State whether True or False: The `CompletableFuture` API consists of many methods
    which are implementations of the `CompletionStage` interface, and are the implementations
    of `Future`.'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '判断是True还是False：`CompletableFuture` API由许多方法组成，这些方法是`CompletionStage`接口的实现，并且是`Future`的实现。 '
- en: Which among the following methods is used when a type of filtering is required
    to skip all the duplicate elements in a stream and select only unique element.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种方法用于在流中需要进行过滤类型以跳过所有重复元素并仅选择唯一元素。
- en: '`distinct()`'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`distinct()`'
- en: '`unique()`'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unique()`'
- en: '`selectall()`'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`selectall()`'
- en: '`filtertype()`'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`filtertype()`'
- en: 'State whether True or False: One of the great advantages of `CompletableFuture`
    is that it can be passed around as an object and used several times to start different
    chains of operations.'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断是True还是False：`CompletableFuture`的一个巨大优势是它可以作为对象传递并多次使用，以启动不同的操作链。
