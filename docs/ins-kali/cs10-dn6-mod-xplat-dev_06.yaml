- en: '06'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '06'
- en: Implementing Interfaces and Inheriting Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口和继承类
- en: This chapter is about deriving new types from existing ones using **object-oriented
    programming** (**OOP** ). You will learn about defining operators and local functions
    for performing simple actions and delegates and events for exchanging messages
    between types. You will implement interfaces for common functionality. You will
    learn about generics and the difference between reference and value types. You
    will create a derived class to inherit from a base class to reuse functionality,
    override an inherited type member, and use polymorphism. Finally, you will learn
    how to create extension methods and how to cast between classes in an inheritance
    hierarchy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用**面向对象编程**（**OOP**）从现有类型派生新类型。您将学习定义运算符和执行简单操作的本地函数，以及在类型之间交换消息的委托和事件。您将为常见功能实现接口。您将学习泛型和引用类型与值类型之间的区别。您将创建一个派生类，以从基类继承功能，重写继承的类型成员，并使用多态。最后，您将学习如何创建扩展方法以及如何在继承层次结构中进行类之间的转换。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Setting up a class library and console application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置类库和控制台应用程序
- en: More about methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于方法
- en: Raising and handling events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引发和处理事件
- en: Making types safely reusable with generics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型使类型安全地可重用
- en: Implementing interfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现接口
- en: Managing memory with reference and value types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用引用和值类型管理内存
- en: Working with null values
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理空值
- en: Inheriting from classes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从类继承
- en: Casting within inheritance hierarchies
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在继承层次结构中进行转换
- en: Inheriting and extending .NET types
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承和扩展.NET类型
- en: Using an analyzer to write better code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分析器编写更好的代码
- en: Setting up a class library and console application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置类库和控制台应用程序
- en: 'We will start by defining a workspace/solution with two projects like the one
    created in *Chapter 5* , *Building Your Own Types with Object-Oriented Programming*
    . Even if you completed all the exercises in that chapter, follow the instructions
    below because we will use C# 10 features in the class library, so it needs to
    target .NET 6.0 rather than .NET Standard 2.0:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个包含两个项目的工作空间/解决方案，就像在*第5章*，*使用面向对象编程构建自己的类型*中创建的那样。即使您在该章节中完成了所有的练习，也请按照以下说明操作，因为我们将在类库中使用C#
    10功能，因此它需要针对.NET 6.0而不是.NET Standard 2.0进行目标设置：
- en: Use your preferred coding tool to create a new workspace/solution named `Chapter06`
    .
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具创建一个名为`Chapter06`的新工作空间/解决方案。
- en: 'Add a class library project, as defined in the following list:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类库项目，如下列表所定义的那样：
- en: 'Project template: **Class Library** / `classlib`'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**类库** / `classlib`
- en: 'Workspace/solution file and folder: `Chapter06`'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作空间/解决方案文件和文件夹：`Chapter06`
- en: 'Project file and folder: `PacktLibrary`'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`PacktLibrary`
- en: 'Add a console app project, as defined in the following list:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个控制台应用程序项目，如下列表所定义的那样：
- en: 'Project template: **Console Application** / `console`'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Workspace/solution file and folder: `Chapter06`'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作空间/解决方案文件和文件夹：`Chapter06`
- en: 'Project file and folder: `PeopleApp`'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`PeopleApp`
- en: In the `PacktLibrary` project, rename the file named `Class1.cs` to `Person.cs`
    .
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，将名为`Class1.cs`的文件重命名为`Person.cs`。
- en: 'Modify the `Person.cs` file contents, as shown in the following code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Person.cs`文件内容，如下所示的代码：
- en: '```cs'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: System.Console;
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console;
- en: namespace
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: class
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Person
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Person
- en: ': object'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ：对象
- en: '{'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // fields
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: // 字段
- en: public
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: string
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: '? Name;    // ? allows null'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ？ 名称；    // ？允许为空
- en: public
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: DateTime DateOfBirth;
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime DateOfBirth;
- en: public
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: List<Person> Children = new
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> Children = new
- en: (); // C# 9 or later
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: (); // C# 9或更高版本
- en: // methods
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: // 方法
- en: public
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: void
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: WriteToConsole
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: WriteToConsole
- en: ()
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{Name}'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '{Name}'
- en: was born on a
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 出生于
- en: '{DateOfBirth:dddd}'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '{DateOfBirth:dddd}'
- en: ."
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 。"
- en: );
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the `PeopleApp` project, add a project reference to `PacktLibrary` , as
    shown highlighted in the following markup:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PeopleApp`项目中，添加对`PacktLibrary`的项目引用，如下标记中所示：
- en: '```cs'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <Project Sdk="Microsoft.NET.Sdk"
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <Project Sdk="Microsoft.NET.Sdk"
- en: '>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <PropertyGroup>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <PropertyGroup>
- en: <OutputType>Exe</OutputType>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <OutputType>Exe</OutputType>
- en: <TargetFramework>net6.0
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <TargetFramework>net6.0
- en: </TargetFramework>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: </TargetFramework>
- en: <Nullable>enable</Nullable>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <Nullable>enable</Nullable>
- en: <ImplicitUsings>enable</ImplicitUsings>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <ImplicitUsings>enable</ImplicitUsings>
- en: </PropertyGroup>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: </PropertyGroup>
- en: '**<ItemGroup>**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**<ItemGroup>**'
- en: '**<ProjectReference**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**<ProjectReference**'
- en: '**Include=**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**Include=**'
- en: '**"..\PacktLibrary\PacktLibrary.csproj"**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**"..\PacktLibrary\PacktLibrary.csproj"**'
- en: '**/>**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**/>**'
- en: '**</ItemGroup>**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**</ItemGroup>**'
- en: </Project>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: </Project>
- en: '```'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Build the `PeopleApp` project and note the output indicating that both projects
    have been built successfully.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`PeopleApp`项目，并注意输出指示两个项目都已成功构建。
- en: More about methods
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于方法
- en: We might want two instances of `Person` to be able to procreate. We can implement
    this by writing methods. Instance methods are actions that an object does to itself;
    static methods are actions the type does.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望两个`Person`的实例能够繁殖。我们可以通过编写方法来实现这一点。实例方法是对象对自身执行的操作；静态方法是类型执行的操作。
- en: Which you choose depends on what makes the most sense for the action.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您的选择取决于对操作最合理的选择。
- en: '**Good Practice** : Having both static and instance methods to perform similar
    actions often makes sense. For example, `string` has both a `Compare` static method
    and a `CompareTo` instance method. This puts the choice of how to use the functionality
    in the hands of the programmers using your type, giving them more flexibility.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：同时具有静态方法和实例方法来执行类似的操作通常是有意义的。例如，`string`既有`Compare`静态方法，也有`CompareTo`实例方法。这样做将功能的使用方式放在了使用您的类型的程序员手中，为他们提供了更多的灵活性。'
- en: Implementing functionality using methods
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法实现功能
- en: 'Let''s start by implementing some functionality by using both static and instance
    methods:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过使用静态和实例方法来实现一些功能：
- en: 'Add one instance method and one static method to the `Person` class that will
    allow two `Person` objects to procreate, as shown in the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Person`类添加一个实例方法和一个静态方法，允许两个`Person`对象繁殖，如下面的代码所示：
- en: '```cs'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // static method to "multiply"
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: // "乘法"的静态方法
- en: public
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: static
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: Person
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 人
- en: Procreate
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 繁殖
- en: (
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: Person p1, Person p2
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Person p1, Person p2
- en: )
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Person baby = new
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Person baby = new
- en: ()
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Name = $"Baby of
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Name = $"Baby of
- en: '{p1.Name}'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '{p1.Name}'
- en: and
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '{p2.Name}'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '{p2.Name}'
- en: '"'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: '};'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: p1.Children.Add(baby);
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: p1.Children.Add(baby);
- en: p2.Children.Add(baby);
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: p2.Children.Add(baby);
- en: return
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: baby;
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: baby;
- en: '}'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // instance method to "multiply"
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: // 实例方法来“乘法”
- en: public
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: Person
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 人
- en: ProcreateWith
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与arg1繁殖
- en: (
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: Person partner
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Person partner
- en: )
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Procreate(this
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Procreate(this
- en: ', partner);'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ，partner);
- en: '}'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Note the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: In the `static` method named `Procreate` , the `Person` objects to procreate
    are passed as parameters named `p1` and `p2` .
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在名为`Procreate`的`static`方法中，传递了要繁殖的`Person`对象作为名为`p1`和`p2`的参数。
- en: A new `Person` class named `baby` is created with a name composed of a combination
    of the two people who have procreated. This could be changed later by setting
    the returned `baby` variable's `Name` property.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`baby`的新`Person`类，其名称由已经繁殖的两个人的组合组成。稍后可以通过设置返回的`baby`变量的`Name`属性来更改这一点。
- en: The `baby` object is added to the `Children` collection of both parents and
    then returned. Classes are reference types, meaning a reference to the `baby`
    object stored in memory is added, not a clone of the `baby` object. You will learn
    the difference between reference types and value types later in this chapter.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baby`对象被添加到两个父母的`Children`集合中，然后返回。类是引用类型，这意味着在内存中添加的是对`baby`对象的引用，而不是`baby`对象的克隆。您将在本章后面学习引用类型和值类型之间的区别。'
- en: In the instance method named `ProcreateWith` , the `Person` object to procreate
    with is passed as a parameter named `partner` , and it, along with `this` , is
    passed to the static `Procreate` method to reuse the method implementation. `this`
    is a keyword that references the current instance of the class.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在名为`ProcreateWith`的实例方法中，传递了要繁殖的`Person`对象作为名为`partner`的参数，它和`this`一起传递给静态的`Procreate`方法以重用方法的实现。`this`是一个关键字，用于引用类的当前实例。
- en: '**Good Practice** : A method that creates a new object, or modifies an existing
    object, should return a reference to that object so that the caller can access
    the results.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：创建新对象或修改现有对象的方法应返回对该对象的引用，以便调用者可以访问结果。'
- en: 'In the `PeopleApp` project, at the top of the `Program.cs` file, delete the
    comment and import the namespace for our `Person` class and statically import
    the `Console` type, as shown in the following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PeopleApp`项目中，在`Program.cs`文件的顶部，删除注释并导入我们的`Person`类的命名空间，并静态导入`Console`类型，如下面的代码所示：
- en: '```cs'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: Packt.Shared;
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared;
- en: using
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: System.Console;
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console;
- en: '```'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , create three people and have them procreate with each other,
    noting that to add a double-quote character into a `string` , you must prefix
    it with a backslash character like this, `\"` , as shown in the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`Program.cs`中，创建三个人，并让他们相互繁殖，注意，要将双引号字符添加到`string`中，必须使用反斜杠字符进行前缀处理，如下面的代码所示： '
- en: '```cs'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Person harry = new
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Person harry = new
- en: () { Name = "Harry"
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Harry"
- en: '};'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: Person mary = new
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Person mary = new
- en: () { Name = "Mary"
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Mary"
- en: '};'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: Person jill = new
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Person jill = new
- en: () { Name = "Jill"
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Jill"
- en: '};'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: // call instance method
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: // 调用实例方法
- en: Person baby1 = mary.ProcreateWith(harry);
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Person baby1 = mary.ProcreateWith(harry);
- en: baby1.Name = "Gary"
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: baby1.Name = "Gary"
- en: ;
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: // call static method
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: // 调用静态方法
- en: Person baby2 = Person.Procreate(harry, jill);
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Person baby2 = Person.Procreate(harry, jill);
- en: WriteLine($"
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{harry.Name}'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '{harry.Name}'
- en: has
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有
- en: '{harry.Children.Count}'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '{harry.Children.Count}'
- en: children."
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: children."
- en: );
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{mary.Name}'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '{mary.Name}'
- en: has
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有
- en: '{mary.Children.Count}'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '{mary.Children.Count}'
- en: children."
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 孩子们。
- en: );
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{jill.Name}'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '{jill.Name}'
- en: has
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有
- en: '{jill.Children.Count}'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '{jill.Children.Count}'
- en: children."
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: children."
- en: );
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine(
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(
- en: 'format: "{0}''s first child is named \"{1}\"."'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 格式："{0}的第一个孩子名为“{1}”"
- en: ','
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg0: harry.Name,'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: harry.Name,'
- en: 'arg1: harry.Children[0'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: harry.Children[0
- en: '].Name);'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '].Name);'
- en: '```'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Harry has 2 children.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Harry有2个孩子。
- en: Mary has 1 children.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Mary有1个孩子。
- en: Jill has 1 children.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Jill有1个孩子。
- en: Harry's first child is named "Gary".
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Harry的第一个孩子名为“Gary”。
- en: '```'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Implementing functionality using operators
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用运算符实现功能
- en: 'The `System.String` class has a `static` method named `Concat` that concatenates
    two string values and returns the result, as shown in the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.String`类有一个名为`Concat`的`static`方法，它连接两个字符串值并返回结果，如下面的代码所示：'
- en: '```cs'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: s1 = "Hello "
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: s1 = "Hello "
- en: ;
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: string
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: s2 = "World!"
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: s2 = "World!"
- en: ;
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: string
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: s3 = string
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: s3 = string
- en: .Concat(s1, s2);
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: .Concat(s1, s2);
- en: WriteLine(s3); // Hello World!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(s3); // Hello World!
- en: '```'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Calling a method like `Concat` works, but it might be more natural for a programmer
    to use the `+` symbol operator to "add" two `string` values together, as shown
    in the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 像`Concat`这样的方法是有效的，但程序员可能更自然地使用`+`符号运算符将两个`string`值“相加”在一起，如下面的代码所示：
- en: '```cs'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: s3 = s1 + s2;
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: s3 = s1 + s2;
- en: '```'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: A well-known biblical phrase is *Go forth and multiply* , meaning to procreate.
    Let's write code so that the `*` (multiply) symbol will allow two `Person` objects
    to procreate.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一个众所周知的圣经短语是*去生育繁衍*，意思是生育。让我们编写代码，使`*`（乘）符号允许两个`Person`对象繁殖。
- en: We do this by defining a `static` operator for the `*` symbol. The syntax is
    rather like a method, because in effect, an operator *is* a method, but uses a
    symbol instead of a method name, which makes the syntax more concise.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过为`*`符号定义一个`static`运算符来实现这一点。语法有点像方法，因为实际上，运算符*就是一个方法，但是使用符号而不是方法名，这使得语法更加简洁。
- en: 'In `Person.cs` , create a `static` operator for the `*` symbol, as shown in
    the following code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，为`*`符号创建一个`static`运算符，如下面的代码所示：
- en: '```cs'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // operator to "multiply"
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: // 乘法运算符
- en: public
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: static
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: Person operator
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Person operator
- en: '*(Person p1, Person p2)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*（Person p1，Person p2）'
- en: '{'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Person.Procreate(p1, p2);
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Person.Procreate（p1，p2）;
- en: '}'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : Unlike methods, operators do not appear in IntelliSense
    lists for a type. For every operator that you define, make a method as well, because
    it may not be obvious to a programmer that the operator is available. The implementation
    of the operator can then call the method, reusing the code you have written. A
    second reason for providing a method is that operators are not supported by every
    language compiler; for example, although arithmetic operators like * are supported
    by Visual Basic and F#, there is no requirement that other languages support all
    operators supported by C#.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的实践**：与方法不同，运算符不会出现在类型的IntelliSense列表中。对于您定义的每个运算符，都要创建一个方法，因为程序员可能不明显地知道该运算符是可用的。然后，运算符的实现可以调用该方法，重用您编写的代码。提供方法的第二个原因是，并非每种语言编译器都支持运算符；例如，虽然Visual
    Basic和F#支持算术运算符，如*，但并没有要求其他语言支持C#支持的所有运算符。'
- en: 'In `Program.cs` , after calling the `Procreate` method and before the statements
    that write to the console, use the `*` operator to make another baby, as shown
    highlighted in the following code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在调用`Procreate`方法之后并在写入控制台的语句之前，使用`*`运算符再生一个宝宝，如下面代码中所示：
- en: '```cs'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // call static method
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: //调用静态方法
- en: Person baby2 = Person.Procreate(harry, jill);
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Person baby2 = Person.Procreate（harry，jill）;
- en: '**// call an operator**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**//调用一个运算符**'
- en: '**Person baby3 = harry * mary;**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**Person baby3 = harry * mary;**'
- en: '```'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Harry has 3 children.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 哈利有3个孩子。
- en: Mary has 2 children.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 玛丽有2个孩子。
- en: Jill has 1 children.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 吉尔有1个孩子。
- en: Harry's first child is named "Gary".
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 哈利的第一个孩子叫“加里”。
- en: '```'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Implementing functionality using local functions
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用本地函数实现功能
- en: A language feature introduced in C# 7.0 is the ability to define a **local function**
    .
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0引入的一种语言特性是能够定义**本地函数**。
- en: Local functions are the method equivalent of local variables. In other words,
    they are methods that are only accessible from within the containing method in
    which they have been defined. In other languages, they are sometimes called **nested**
    or **inner functions** .
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 本地函数是本地变量的方法等价物。换句话说，它们是仅从定义它们的包含方法中访问的方法。在其他语言中，它们有时被称为**嵌套**或**内部函数**。
- en: 'Local functions can be defined anywhere inside a method: the top, the bottom,
    or even somewhere in the middle!'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本地函数可以在方法的任何地方定义：顶部，底部，甚至中间的某个地方！
- en: 'We will use a local function to implement a factorial calculation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本地函数来实现阶乘计算：
- en: 'In `Person.cs` , add statements to define a `Factorial` function that uses
    a local function inside itself to calculate the result, as shown in the following
    code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句来定义一个使用本地函数内部计算结果的`Factorial`函数，如下面的代码所示：
- en: '```cs'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // method with a local function
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: //带有本地函数的方法
- en: public
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: static
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的
- en: int
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: Factorial
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘
- en: (
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: int
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: number
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 数字
- en: )
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: '{'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (number < 0
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: （数字<0
- en: )
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: '{'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: throw
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出
- en: new
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 新的
- en: ArgumentException(
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 参数异常（
- en: $"
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: $"
- en: '{'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: nameof
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: nameof
- en: (number)}
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: （数字）}
- en: cannot be less than zero."
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 不能小于零。"
- en: );
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: localFactorial(number);
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: localFactorial（数字）;
- en: int
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: localFactorial
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: localFactorial
- en: (
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: int
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: localNumber
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: localNumber
- en: )
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: // local function
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: //本地函数
- en: '{'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (localNumber < 1
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本地号码小于1
- en: ) return
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ）返回
- en: '1'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: ;
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: return
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: localNumber * localFactorial(localNumber - 1
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: localNumber * localFactorial(localNumber - 1
- en: );
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add a statement to call the `Factorial` function and write
    the return value to the console, as shown in the following code:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一个语句来调用`Factorial`函数并将返回值写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine($"5! is
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（$“5！是
- en: '{Person.Factorial('
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '{Person.Factorial（'
- en: '5'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: )}
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: )}
- en: '"'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '```'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 5! is 120
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 5！是120
- en: '```'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Raising and handling events
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引发和处理事件
- en: Methods are often described as *actions that an object can perform, either on
    itself or on related objects* . For example, `List<T>` can add an item to itself
    or clear itself, and `File` can create or delete a file in the filesystem.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 方法经常被描述为*对象可以执行的动作，可以是在自身上执行，也可以是在相关对象上执行*。例如，`List<T>`可以向自身添加项目或清除自身，而`File`可以在文件系统中创建或删除文件。
- en: Events are often described as *actions that happen to an object* . For example,
    in a user interface, `Button` has a `Click` event, a click being something that
    happens to a button, and `FileSystemWatcher` listens to the filesystem for change
    notifications and raises events like `Created` and `Deleted` that are triggered
    when a directory or file changes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 事件经常被描述为*发生在对象上的动作*。例如，在用户界面中，`Button`有一个`Click`事件，点击是发生在按钮上的事情，而`FileSystemWatcher`监听文件系统的更改通知，并触发`Created`和`Deleted`等事件，当目录或文件发生更改时会触发这些事件。
- en: Another way of thinking of events is that they provide a way of exchanging messages
    between two objects.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考事件的方式是它们提供了两个对象之间交换消息的方式。
- en: Events are built on **delegates** , so let's start by having a look at what
    delegates are and how they work.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 事件建立在**委托**之上，所以让我们先看看委托是什么以及它们是如何工作的。
- en: Calling methods using delegates
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用委托调用方法
- en: 'You have already seen the most common way to call or execute a method: use
    the `.` operator to access the method using its name. For example, `Console.WriteLine`
    tells the `Console` type to access its `WriteLine` method.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了调用或执行方法的最常见方式：使用“.”运算符访问其名称。例如，`Console.WriteLine`告诉`Console`类型访问其`WriteLine`方法。
- en: The other way to call or execute a method is to use a delegate. If you have
    used languages that support **function pointers** , then think of a delegate as
    being a **type-safe method pointer** .
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 调用或执行方法的另一种方式是使用委托。如果您使用过支持**函数指针**的语言，那么将委托视为**类型安全的方法指针**。
- en: In other words, a delegate contains the memory address of a method that matches
    the same signature as the delegate so that it can be called safely with the correct
    parameter types.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，委托包含与委托相同签名的方法的内存地址，以便可以安全地使用正确的参数类型调用它。
- en: 'For example, imagine there is a method in the `Person` class that must have
    a `string` type passed as its only parameter, and it returns an `int` type, as
    shown in the following code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下`Person`类中有一个方法，它必须传递一个`string`类型作为它唯一的参数，并返回一个`int`类型，如下面的代码所示：
- en: '```cs'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: int
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: MethodIWantToCall
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要调用的方法
- en: (
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: input
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 输入
- en: )
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: input.Length; // it doesn't matter what the method does
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: input.Length; // 方法的具体操作并不重要
- en: '}'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'I can call this method on an instance of `Person` named `p1` like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以这样在名为`p1`的`Person`实例上调用这个方法：
- en: '```cs'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: answer = p1.MethodIWantToCall("Frog"
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: answer = p1.MethodIWantToCall("Frog"
- en: );
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Alternatively, I can define a delegate with a matching signature to call the
    method indirectly. Note that the names of the parameters do not have to match.
    Only the types of parameters and return values must match, as shown in the following
    code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我可以定义一个具有匹配签名的委托来间接调用方法。请注意，参数的名称不必匹配。只有参数和返回值的类型必须匹配，如下面的代码所示：
- en: '```cs'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: delegate
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 委托
- en: int
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: DelegateWithMatchingSignature
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 具有匹配签名的委托
- en: (
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: s
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: s
- en: )
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: ;
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Now, I can create an instance of the delegate, point it at the method, and
    finally, call the delegate (which calls the method), as shown in the following
    code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以创建一个委托的实例，将其指向方法，最后调用委托（调用方法），如下面的代码所示：
- en: '```cs'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // create a delegate instance that points to the method
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: // 创建一个委托实例，指向方法
- en: DelegateWithMatchingSignature d = new
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 具有匹配签名的委托 d = new
- en: (p1.MethodIWantToCall);
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: (p1.MethodIWantToCall);
- en: // call the delegate, which calls the method
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: // 调用委托，调用方法
- en: int
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: answer2 = d("Frog"
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 答案2 = d("Frog"
- en: );
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You are probably thinking, "What's the point of that?" Well, it provides flexibility.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“这有什么意义呢？”嗯，它提供了灵活性。
- en: For example, we could use delegates to create a queue of methods that need to
    be called in order. Queuing actions that need to be performed is common in services
    to provide improved scalability.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用委托来创建一个需要按顺序调用的方法队列。在服务中排队执行需要执行的操作是很常见的，以提供更好的可伸缩性。
- en: Another example is to allow multiple actions to perform in parallel. Delegates
    have built-in support for asynchronous operations that run on a different thread,
    and that can provide improved responsiveness. You will learn how to do this in
    *Chapter 12* , *Improving Performance and Scalability Using Multitasking* .
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是允许多个操作并行执行。委托内置支持在不同线程上运行的异步操作，并且可以提供改进的响应性。您将在*第12章*中学习如何做到这一点，*使用多任务改进性能和可伸缩性*。
- en: The most important example is that delegates allow us to implement events for
    sending messages between different objects that do not need to know about each
    other. Events are an example of loose coupling between components because the
    components do not need to know about each other, they just need to know the event
    signature.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的例子是，委托允许我们实现事件，以在不需要相互了解的不同对象之间发送消息。事件是组件之间松散耦合的一个例子，因为组件不需要相互了解，它们只需要知道事件签名。
- en: Delegates and events are two of the most confusing features of C# and can take
    a few attempts to understand, so don't worry if you feel lost!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 委托和事件是C#中最令人困惑的特性之一，可能需要几次尝试才能理解，所以如果你感到迷茫，不要担心！
- en: Defining and handling delegates
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和处理委托
- en: 'Microsoft has two predefined delegates for use as events. Their signatures
    are simple, yet flexible, as shown in the following code:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 微软有两个预定义的委托，用作事件。它们的签名很简单，但灵活，如下面的代码所示：
- en: '```cs'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: delegate
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 委托
- en: void
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: EventHandler
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: EventHandler
- en: (
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: object
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: '? sender, EventArgs e'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '? sender, EventArgs e'
- en: )
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: ;
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: delegate
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 委托
- en: void
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: EventHandler
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: EventHandler
- en: <
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: <
- en: TEventArgs
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: TEventArgs
- en: '>('
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '>('
- en: object
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: '? sender, TEventArgs e'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '? sender, TEventArgs e'
- en: )
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: ;
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : When you want to define an event in your own types, you
    should use one of these two predefined delegates.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：当您想在自己的类型中定义事件时，应该使用这两个预定义的委托之一。'
- en: 'Let''s explore delegates and events:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨委托和事件：
- en: 'Add statements to the `Person` class and note the following points, as shown
    in the following code:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person`类中添加语句，并注意以下几点，如下面的代码所示：
- en: It defines an `EventHandler` delegate field named `Shout` .
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个名为`Shout`的`EventHandler`委托字段。
- en: It defines an `int` field to store `AngerLevel` .
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个`int`字段来存储`AngerLevel`。
- en: It defines a method named `Poke` .
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个名为`Poke`的方法。
- en: 'Each time a person is poked, their `AngerLevel` increments. Once their `AngerLevel`
    reaches three, they raise the `Shout` event, but only if there is at least one
    event delegate pointing at a method defined somewhere else in the code; that is,
    it is not `null` :'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次戳一个人，他们的`AngerLevel`都会增加。一旦他们的`AngerLevel`达到三，他们就会触发`Shout`事件，但前提是代码中的某个地方定义了至少一个事件委托指向另一个方法；也就是说，它不是`null`：
- en: '```cs'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // delegate field
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: // 委托字段
- en: public
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: EventHandler? Shout;
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: EventHandler? Shout;
- en: // data field
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: // 数据字段
- en: public
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: int
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: AngerLevel;
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: AngerLevel;
- en: // method
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: // 方法
- en: public
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: void
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Poke
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 戳
- en: ()
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: AngerLevel++;
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: AngerLevel++;
- en: if
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (AngerLevel >= 3
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: (AngerLevel >= 3
- en: )
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // if something is listening...
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: // 如果有监听...
- en: if
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (Shout != null
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: (Shout != null
- en: )
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // ...then call the delegate
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: // ...然后调用委托
- en: Shout(this
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: Shout(this
- en: ', EventArgs.Empty);'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: ', EventArgs.Empty);'
- en: '}'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Checking whether an object is not `null` before calling one of its methods
    is very common. C# 6.0 and later allows `null` checks to be simplified inline
    using a `?` symbol before the `.` operator, as shown in the following code:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用对象的方法之前检查对象是否不为`null`是非常常见的。C# 6.0及更高版本允许使用`?`符号在`.`运算符之前内联简化`null`检查，如下面的代码所示：
- en: '```cs'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Shout?.Invoke(this
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: Shout?.Invoke(this
- en: ', EventArgs.Empty);'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ', EventArgs.Empty);'
- en: '```'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'At the bottom of `Program.cs` , add a method with a matching signature that
    gets a reference to the `Person` object from the `sender` parameter and outputs
    some information about them, as shown in the following code:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的底部，添加一个具有匹配签名的方法，该方法从`sender`参数获取对`Person`对象的引用，并输出有关它们的一些信息，如下面的代码中所示：
- en: '```cs'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: static
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的
- en: void
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Harry_Shout
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: Harry_Shout
- en: (
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: object
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 对象
- en: '? sender, EventArgs e'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '? 发送者，事件参数'
- en: )
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (sender is
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: （发送者是
- en: 'null'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 'null'
- en: ) return
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: ) return
- en: ;
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: Person p = (Person)sender;
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: Person p = (Person)sender;
- en: WriteLine($"
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{p.Name}'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '{p.Name}'
- en: 'is this angry:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生气的吗：
- en: '{p.AngerLevel}'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '{p.AngerLevel}'
- en: ."
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ."
- en: );
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Microsoft's convention for method names that handle events is `ObjectName_EventName`
    .
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 处理事件的方法名称的微软约定是`ObjectName_EventName`。
- en: 'In `Program.cs` , add a statement to assign the method to the delegate field,
    as shown in the following code:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一个语句将该方法分配给委托字段，如下面的代码中所示：
- en: '```cs'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: harry.Shout = Harry_Shout;
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: harry.Shout = Harry_Shout;
- en: '```'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Add statements to call the `Poke` method four times, after assigning the method
    to the `Shout` event, as shown highlighted in the following code:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以调用`Poke`方法四次，然后将该方法分配给`Shout`事件，如下面的代码中所示：
- en: '```cs'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: harry.Shout = Harry_Shout;
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: harry.Shout = Harry_Shout;
- en: '**harry.Poke();**'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**harry.Poke();**'
- en: '**harry.Poke();**'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**harry.Poke();**'
- en: '**harry.Poke();**'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**harry.Poke();**'
- en: '**harry.Poke();**'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '**harry.Poke();**'
- en: '```'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, and note that Harry says nothing the first
    two times he is poked, and only gets angry enough to shout once he''s been poked
    at least three times, as shown in the following output:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，注意Harry在被戳两次时不说话，只有在被戳至少三次后才生气到大喊大叫，如下面的输出所示：
- en: '```cs'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Harry is this angry: 3\.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 'Harry is this angry: 3\.'
- en: 'Harry is this angry: 4.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 'Harry is this angry: 4.'
- en: '```'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Defining and handling events
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和处理事件
- en: 'You''ve now seen how delegates implement the most important functionality of
    events: the ability to define a signature for a method that can be implemented
    by a completely different piece of code, and then call that method and any others
    that are hooked up to the delegate field.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到委托如何实现事件的最重要功能：定义一个方法的签名，该方法可以由完全不同的代码实现，然后调用该方法和任何其他连接到委托字段的方法。
- en: But what about events? There is less to them than you might think.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 但是事件呢？它们比您想象的要少。
- en: When assigning a method to a delegate field, you should not use the simple assignment
    operator as we did in the preceding example.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在将方法分配给委托字段时，不应使用简单的赋值运算符，就像我们在前面的示例中所做的那样。
- en: Delegates are multicast, meaning that you can assign multiple delegates to a
    single delegate field. Instead of the `=` assignment, we could have used the `+=`
    operator so we could add more methods to the same delegate field. When the delegate
    is called, all the assigned methods are called, although you have no control over
    the order in which they are called.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 委托是多播的，这意味着您可以将多个委托分配给单个委托字段。我们可以使用`+=`运算符而不是`=`赋值，以便将更多方法添加到相同的委托字段。当调用委托时，将调用所有分配的方法，尽管您无法控制调用它们的顺序。
- en: 'If the `Shout` delegate field was already referencing one or more methods,
    by assigning a method, it would replace all the others. With delegates that are
    used for events, we usually want to make sure that a programmer only ever uses
    either the `+=` operator or the `-=` operator to assign and remove methods:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Shout`委托字段已经引用了一个或多个方法，通过分配一个方法，它将替换所有其他方法。对于用于事件的委托，我们通常希望确保程序员只使用`+=`运算符或`-=`运算符来分配和删除方法：
- en: 'To enforce this, in `Person.cs` , add the `event` keyword to the delegate field
    declaration, as shown highlighted in the following code:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了强制执行这一点，在`Person.cs`中，添加`event`关键字到委托字段声明，如下面的代码中所示：
- en: '```cs'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: '**event**'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**'
- en: EventHandler? Shout;
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: EventHandler? Shout;
- en: '```'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Build the `PeopleApp` project and note the compiler error message, as shown
    in the following output:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`PeopleApp`项目并注意编译器错误消息，如下面的输出所示：
- en: '```cs'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Program.cs(41,13): error CS0079: The event ''Person.Shout'' can only appear
    on the left hand side of += or -='
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 'Program.cs(41,13): error CS0079: The event ''Person.Shout'' can only appear
    on the left hand side of += or -='
- en: '```'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This is (almost) all that the `event` keyword does! If you will never have more
    than one method assigned to a delegate field, then technically you do not need
    "events," but it is still good practice to indicate your meaning and that you
    expect a delegate field to be used as an event.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`event`关键字的（几乎）全部作用！如果您永远不会将多个方法分配给委托字段，那么从技术上讲，您不需要“事件”，但表明您的意思并且期望委托字段被用作事件仍然是一个好习惯。
- en: 'Modify the method assignment to use `+=` , as shown in the following code:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改方法分配以使用`+=`，如下面的代码中所示：
- en: '```cs'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: harry.Shout += Harry_Shout;
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: harry.Shout += Harry_Shout;
- en: '```'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Run the code and note that it has the same behavior as before.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意它具有与以前相同的行为。
- en: Making types safely reusable with generics
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型使类型可以安全重用
- en: In 2005, with C# 2.0 and .NET Framework 2.0, Microsoft introduced a feature
    named **generics** , which enables your types to be more safely reusable and more
    efficient. It does this by allowing a programmer to pass types as parameters,
    similar to how you can pass objects as parameters.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年，随着C# 2.0和.NET Framework 2.0，微软引入了一个名为**泛型**的功能，它使您的类型可以更安全地重用并且更有效。它通过允许程序员将类型作为参数传递来实现这一点，类似于您可以将对象作为参数传递。
- en: Working with non-generic types
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用非泛型类型
- en: First, let's look at an example of working with a non-generic type so that you
    can understand the problem that generics are designed to solve, such as weakly
    typed parameters and values, and performance problems caused by using `System.Object`
    .
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个使用非泛型类型的示例，以便您可以了解泛型旨在解决的问题，例如弱类型参数和值，以及使用`System.Object`引起的性能问题。
- en: '`System.Collections.Hashtable` can be used to store multiple values each with
    a unique key that can later be used to quickly look up its value. Both the key
    and value can be any object because they are declared as `System.Object` . Although
    this provides flexibility when storing value types like integers, it is slow,
    and bugs are easier to introduce because no type checks are made when adding items.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Hashtable`可用于存储多个值，每个值都有一个唯一的键，以便以后可以快速查找其值。键和值都可以是任何对象，因为它们声明为`System.Object`。尽管这在存储整数等值类型时提供了灵活性，但它很慢，并且在添加项目时很容易引入错误，因为不进行类型检查。'
- en: 'Let''s write some code:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码：
- en: 'In `Program.cs` , create an instance of the non-generic collection, `System.Collections.Hashtable`
    , and then add four items to it, as shown in the following code:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建一个非泛型集合`System.Collections.Hashtable`的实例，然后向其中添加四个项目，如下面的代码所示：
- en: '```cs'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // non-generic lookup collection
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: // 非泛型查找集合
- en: System.Collections.Hashtable lookupObject = new
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: System.Collections.Hashtable lookupObject = new
- en: ();
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: 'lookupObject.Add(key: 1'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupObject.Add(key: 1'
- en: ', value'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: ，值
- en: ': "Alpha"'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Alpha"'
- en: );
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'lookupObject.Add(key: 2'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupObject.Add(key: 2'
- en: ', value'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: ，值
- en: ': "Beta"'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Beta"'
- en: );
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'lookupObject.Add(key: 3'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupObject.Add(key: 3'
- en: ', value'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: ', value'
- en: ': "Gamma"'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Gamma"'
- en: );
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'lookupObject.Add(key: harry, value'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupObject.Add(key: harry, value'
- en: ': "Delta"'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Delta"'
- en: );
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Add statements to define a `key` with the value of `2` and use it to look up
    its value in the hash table, as shown in the following code:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以定义一个`key`，其值为`2`，并使用它在哈希表中查找其值，如下面的代码所示：
- en: '```cs'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: key = 2
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: key = 2
- en: ; // lookup the value that has 2 as its key
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 查找具有2作为其键的值
- en: 'WriteLine(format: "Key {0} has value: {1}"'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine(format: "Key {0} has value: {1}"'
- en: ','
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: 'arg0: key,'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: key,'
- en: 'arg1: lookupObject[key]);'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg1: lookupObject[key]);'
- en: '```'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Add statements to use the `harry` object to look up its value, as shown in
    the following code:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以使用`harry`对象查找其值，如下面的代码所示：
- en: '```cs'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // lookup the value that has harry as its key
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: // 查找具有harry作为其键的值
- en: 'WriteLine(format: "Key {0} has value: {1}"'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine(format: "Key {0} has value: {1}"'
- en: ','
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg0: harry,'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: harry,'
- en: 'arg1: lookupObject[harry]);'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg1: lookupObject[harry]);'
- en: '```'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note that it works, as shown in the following output:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意它的工作原理，如下面的输出所示：
- en: '```cs'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Key 2 has value: Beta'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 键2的值为：Beta
- en: 'Key Packt.Shared.Person has value: Delta'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 'Key Packt.Shared.Person has value: Delta'
- en: '```'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Although the code works, there is potential for mistakes because literally any
    type can be used for the key or value. If another developer used your lookup object
    and expected all the items to be a certain type, they might cast them to that
    type and get exceptions because some values might be a different type. A lookup
    object with lots of items would also give poor performance.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码可以工作，但是由于键或值可以使用任何类型，因此存在出错的可能性。如果另一个开发人员使用您的查找对象，并且期望所有项目都是某种类型，他们可能会将它们转换为该类型并因为某些值可能是不同类型而导致异常。具有大量项目的查找对象也会导致性能不佳。
- en: '**Good Practice** : Avoid types in the `System.Collections` namespace.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：避免在`System.Collections`命名空间中使用类型。'
- en: Working with generic types
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用泛型类型
- en: '`System.Collections.Generic.Dictionary<TKey, TValue>` can be used to store
    multiple values each with a unique key that can later be used to quickly look
    up its value. Both the key and value can be any object, but you must tell the
    compiler what the types of the key and value will be when you first instantiate
    the collection. You do this by specifying types for the **generic parameters**
    in angle brackets `<>` , `TKey` , and `TValue` .'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Generic.Dictionary<TKey, TValue>`可用于存储多个值，每个值都有一个唯一的键，以便以后可以快速查找其值。键和值都可以是任何对象，但是在首次实例化集合时，必须告诉编译器键和值的类型是什么。您可以通过在尖括号`<>`，`TKey`和`TValue`中指定**泛型参数**的类型来实现这一点。'
- en: '**Good Practice** : When a generic type has one definable type, it should be
    named `T` , for example, `List<T>` , where `T` is the type stored in the list.
    When a generic type has multiple definable types, they should use `T` as a name
    prefix and have a sensible name, for example, `Dictionary<TKey, TValue>` .'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：当泛型类型有一个可定义的类型时，应将其命名为`T`，例如`List<T>`，其中`T`是列表中存储的类型。当泛型类型有多个可定义的类型时，它们应该使用`T`作为名称前缀，并具有合理的名称，例如`Dictionary<TKey,
    TValue>`。'
- en: This provides flexibility, it is faster, and bugs are easier to avoid because
    type checks are made when adding items.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了灵活性，速度更快，并且更容易避免错误，因为在添加项目时进行了类型检查。
- en: 'Let''s write some code to solve the problem by using generics:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来使用泛型解决问题：
- en: 'In `Program.cs` , create an instance of the generic lookup collection `Dictionary<TKey,
    TValue>` and then add four items to it, as shown in the following code:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建一个泛型查找集合`Dictionary<TKey, TValue>`的实例，然后向其中添加四个项目，如下面的代码所示：
- en: '```cs'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // generic lookup collection
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: // 泛型查找集合
- en: Dictionary<int
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: Dictionary<int
- en: ', string'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: ', string'
- en: lookupIntString = new
  id: totrans-552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lookupIntString = new
- en: ();
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: 'lookupIntString.Add(key: 1'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupIntString.Add(key: 1'
- en: ', value'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: ', value'
- en: ': "Alpha"'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Alpha"'
- en: );
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'lookupIntString.Add(key: 2'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupIntString.Add(key: 2'
- en: ', value'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: ', value'
- en: ': "Beta"'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Beta"'
- en: );
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'lookupIntString.Add(key: 3'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupIntString.Add(key: 3'
- en: ', value'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: ', value'
- en: ': "Gamma"'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Gamma"'
- en: );
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'lookupIntString.Add(key: harry, value'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupIntString.Add(key: harry, value'
- en: ': "Delta"'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Delta"'
- en: );
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Note the compile error when using `harry` as a key, as shown in the following
    output:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意在使用`harry`作为键时的编译错误，如下面的输出所示：
- en: '```cs'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '/Users/markjprice/Code/Chapter06/PeopleApp/Program.cs(98,32): error CS1503:
    Argument 1: cannot convert from ''Packt.Shared.Person'' to ''int'' [/Users/markjprice/Code/Chapter06/PeopleApp/PeopleApp.csproj]'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '/Users/markjprice/Code/Chapter06/PeopleApp/Program.cs(98,32): error CS1503:
    Argument 1: cannot convert from ''Packt.Shared.Person'' to ''int'' [/Users/markjprice/Code/Chapter06/PeopleApp/PeopleApp.csproj]'
- en: '```'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Replace `harry` with `4` .
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`4`替换`harry`。
- en: 'Add statements to set the `key` to `3` and use it to look up its value in the
    dictionary, as shown in the following code:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以将`key`设置为`3`，并使用它在字典中查找其值，如下面的代码所示：
- en: '```cs'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: key = 3
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: key = 3
- en: ;
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: 'WriteLine(format: "Key {0} has value: {1}"'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine(format: "Key {0} has value: {1}"'
- en: ','
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: 'arg0: key,'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: key,'
- en: 'arg1: lookupIntString[key]);'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg1: lookupIntString[key]);'
- en: '```'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note that it works, as shown in the following output:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意它可以工作，如下面的输出所示：
- en: '```cs'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Key 3 has value: Gamma'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 键3的值为：Gamma
- en: '```'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Implementing interfaces
  id: totrans-588
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口
- en: Interfaces are a way of connecting different types to make new things. Think
    of them like the studs on top of LEGO™ bricks, which allow them to "stick" together,
    or electrical standards for plugs and sockets.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是连接不同类型以创建新事物的一种方式。将它们视为LEGO™积木顶部的凸起，使它们可以“粘”在一起，或者是插头和插座的电气标准。
- en: If a type implements an interface, then it is making a promise to the rest of
    .NET that it supports specific functionality. This is why they are sometimes described
    as being contracts.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型实现了接口，那么它就承诺.NET的其余部分支持特定功能。这就是为什么有时它们被描述为合同。
- en: Common interfaces
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见接口
- en: 'Here are some common interfaces that your types might need to implement:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些您的类型可能需要实现的常见接口：
- en: '| Interface | Method(s) | Description |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | 方法 | 描述 |'
- en: '| `IComparable` | `CompareTo(other)` | This defines a comparison method that
    a type implements to order or sort its instances. |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '| `IComparable` | `CompareTo(other)` | 这定义了一个类型实现的比较方法，用于对其实例进行排序。|'
- en: '| `IComparer` | `Compare(first, second)` | This defines a comparison method
    that a secondary type implements to order or sort instances of a primary type.
    |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '| `IComparer` | `Compare(first, second)` | 这定义了一个次要类型实现的比较方法，用于对主类型的实例进行排序。|'
- en: '| `IDisposable` | `Dispose()` | This defines a disposal method to release unmanaged
    resources more efficiently than waiting for a finalizer (see the *Releasing unmanaged
    resources* section later in this chapter for more details. |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
  zh: '| `IDisposable` | `Dispose()` | 这定义了一种释放非托管资源的处理方法，比等待终结器更有效（有关更多详细信息，请参见本章后面的*释放非托管资源*部分。|'
- en: '| `IFormattable` | `ToString(format, culture)` | This defines a culture-aware
    method to format the value of an object into a string representation. |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| `IFormattable` | `ToString(format, culture)` | 这定义了一个具有文化意识的方法，将对象的值格式化为字符串表示形式。|'
- en: '| `IFormatter` | `Serialize(stream, object)``Deserialize(stream)` | This defines
    methods to convert an object to and from a stream of bytes for storage or transfer.
    |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| `IFormatter` | `Serialize(stream, object)``Deserialize(stream)` | 这定义了将对象转换为字节流并从中转换的方法，以便进行存储或传输。|'
- en: '| `IFormatProvider` | `GetFormat(type)` | This defines a method to format inputs
    based on a language and region. |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| `IFormatProvider` | `GetFormat(type)` | 这定义了一种根据语言和地区格式化输入的方法。|'
- en: Comparing objects when sorting
  id: totrans-600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在排序时比较对象
- en: 'One of the most common interfaces that you will want to implement is `IComparable`
    . It has one method named `CompareTo` . It has two variations, one that works
    with a nullable `object` type and one that works with a nullable generic type
    `T` , as shown in the following code:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想要实现的最常见的接口之一是`IComparable`。它有一个名为`CompareTo`的方法。它有两种变体，一种适用于可空的`object`类型，一种适用于可空的泛型类型`T`，如下面的代码所示：
- en: '```cs'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: namespace
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: namespace
- en: System
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: System
- en: '{'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: interface
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: interface
- en: IComparable
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: IComparable
- en: '{'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: CompareTo
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: CompareTo
- en: (
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: object
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: '? obj'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '? obj'
- en: )
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: ;
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: interface
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: interface
- en: IComparable
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: IComparable
- en: <in
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: <in
- en: T
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: T
- en: '>'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '{'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: CompareTo
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: CompareTo
- en: (
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: T? other
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: T? other
- en: )
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: ;
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: For example, the `string` type implements `IComparable` by returning `-1` if
    the `string` is less than the `string` being compared to or `1` if it is greater.
    The `int` type implements `IComparable` by returning `-1` if the `int` is less
    than the `int` being compared to or `1` if it is greater.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`string`类型通过返回`-1`来实现`IComparable`，如果`string`小于要比较的`string`，则返回`1`。`int`类型通过返回`-1`来实现`IComparable`，如果`int`小于要比较的`int`，则返回`1`。
- en: If a type implements one of the `IComparable` interfaces, then arrays and collections
    can sort it.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型实现了`IComparable`接口之一，则数组和集合可以对其进行排序。
- en: 'Before we implement the `IComparable` interface and its `CompareTo` method
    for the `Person` class, let''s see what happens when we try to sort an array of
    `Person` instances:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为`Person`类实现`IComparable`接口及其`CompareTo`方法之前，让我们看看当我们尝试对`Person`实例数组进行排序时会发生什么：
- en: 'In `Program.cs` , add statements that create an array of `Person` instances
    and write the items to the console, and then attempt to sort the array and write
    the items to the console again, as shown in the following code:'
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句创建`Person`实例数组并将项目写入控制台，然后尝试对数组进行排序并再次将项目写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Person[] people =
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: Person[] people =
- en: '{'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: new
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: () { Name = "Simon"
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Simon"
- en: '},'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: new
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: () { Name = "Jenny"
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Jenny"
- en: '},'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: new
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: () { Name = "Adam"
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Adam"
- en: '},'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: new
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: () { Name = "Richard"
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Richard"
- en: '}'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: WriteLine("Initial list of people:"
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("人员的初始列表："
- en: );
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: foreach
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: foreach
- en: (Person p in
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: (Person p in
- en: people)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: people)
- en: '{'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{p.Name}'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '{p.Name}'
- en: '"'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: WriteLine("Use Person's IComparable implementation to sort:"
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("使用Person的IComparable实现进行排序："
- en: );
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Array.Sort(people);
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: Array.Sort(people);
- en: foreach
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: foreach
- en: (Person p in
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: (Person p in
- en: people)
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: people)
- en: '{'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{p.Name}'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '{p.Name}'
- en: '"'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and an exception will be thrown. As the message explains, to fix
    the problem, our type must implement `IComparable` , as shown in the following
    output:'
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码会抛出异常。正如消息所解释的那样，为了解决问题，我们的类型必须实现`IComparable`，如下面的输出所示：
- en: '```cs'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Unhandled Exception: System.InvalidOperationException: Failed to compare two
    elements in the array. ---> System.ArgumentException: At least one object must
    implement IComparable.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 未处理的异常：System.InvalidOperationException：无法比较数组中的两个元素。--->System.ArgumentException：至少一个对象必须实现IComparable。
- en: '```'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Person.cs` , after inheriting from `object` , add a comma and enter `IComparable<Person>`
    , as shown in the following code:'
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，从`object`继承后，添加逗号并输入`IComparable<Person>`，如下面的代码所示：
- en: '```cs'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: class
- en: Person
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: Person
- en: ': object'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: ': object'
- en: ', IComparable'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: ', IComparable'
- en: <Person
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: <Person
- en: '>'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '```'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Your code editor will draw a red squiggle under the new code to warn you that
    you have not yet implemented the method you have promised to. Your code editor
    can write the skeleton implementation for you if you click on the light bulb and
    choose the **Implement interface** option.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码编辑器将在新代码下面绘制红色波浪线，以警告您尚未实现您承诺的方法。如果单击灯泡并选择**实现接口**选项，则代码编辑器可以为您编写骨架实现。
- en: 'Scroll down to the bottom of the `Person` class to find the method that was
    written for you and delete the statement that throws the `NotImplementedException`
    error, as shown highlighted in the following code:'
  id: totrans-693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动到`Person`类的底部，找到为您编写的方法，并删除抛出`NotImplementedException`错误的语句，如下面代码中所示：
- en: '```cs'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: int
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: CompareTo
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: CompareTo
- en: (
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: Person? other
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: Person? 其他
- en: )
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '**throw**'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '**抛出**'
- en: '**new**'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '**新**'
- en: '**NotImplementedException();**'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '**NotImplementedException();**'
- en: '}'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Add a statement to call the `CompareTo` method of the `Name` field, which uses
    the `string` type''s implementation of `CompareTo` and return the result, as shown
    highlighted in the following code:'
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个语句来调用`Name`字段的`CompareTo`方法，该方法使用`string`类型的`CompareTo`实现并返回结果，如下面代码中所示：
- en: '```cs'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: int
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: CompareTo
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: CompareTo
- en: (
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: Person? other
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: Person? 其他
- en: )
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (Name is
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: (Name is
- en: 'null'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 'null'
- en: ) return
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: ) 返回
- en: '0'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: ;
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '**return**'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**'
- en: '**Name.CompareTo(other?.Name);**'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '**Name.CompareTo(other?.Name);**'
- en: '}'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We have chosen to compare two `Person` instances by comparing their `Name` fields.
    `Person` instances will, therefore, be sorted alphabetically by their name. For
    simplicity, I have not added `null` checks throughout these examples.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择通过比较它们的`Name`字段来比较两个`Person`实例。因此，`Person`实例将按其名称的字母顺序排序。为简单起见，我在这些示例中没有添加`null`检查。
- en: 'Run the code and note that this time it works as it should, as shown in the
    following output:'
  id: totrans-727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意，这次它按预期工作，如下面的输出所示：
- en: '```cs'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Initial list of people:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 人员的初始列表：
- en: Simon
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 西蒙
- en: Jenny
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 珍妮
- en: Adam
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 亚当
- en: Richard
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 理查德
- en: 'Use Person''s IComparable implementation to sort:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Person的IComparable实现进行排序：
- en: Adam
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 亚当
- en: Jenny
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 珍妮
- en: Richard
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 理查德
- en: Simon
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 西蒙
- en: '```'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : If anyone will want to sort an array or collection of instances
    of your type, then implement the `IComparable` interface.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果有人想要对您的类型的实例数组或集合进行排序，则实现`IComparable`接口。'
- en: Comparing objects using a separate class
  id: totrans-741
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单独类比较对象
- en: 'Sometimes, you won''t have access to the source code for a type, and it might
    not implement the `IComparable` interface. Luckily, there is another way to sort
    instances of a type. You can create a separate type that implements a slightly
    different interface, named `IComparer` :'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能无法访问类型的源代码，并且它可能没有实现`IComparable`接口。幸运的是，还有另一种方法可以对类型的实例进行排序。您可以创建一个实现略有不同接口的单独类型，名为`IComparer`：
- en: 'In the `PacktLibrary` project, add a new class file named `PersonComparer.cs`
    containing a class that implements the `IComparer` interface that will compare
    two people, that is, two `Person` instances. Implement it by comparing the length
    of their `Name` field, or if the names are the same length, then by comparing
    the names alphabetically, as shown in the following code:'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`PersonComparer.cs`的新类文件，其中包含一个实现`IComparer`接口的类，该接口将比较两个人，即两个`Person`实例。通过比较它们的`Name`字段的长度来实现它，或者如果名称长度相同，则按字母顺序比较名称，如下面的代码所示：
- en: '```cs'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: namespace
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: PersonComparer
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: PersonComparer
- en: ': IComparer'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: ': IComparer'
- en: <Person
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: <Person
- en: '>'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '{'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: int
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: Compare
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 比较
- en: (
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: Person? x, Person? y
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: Person? x, Person? y
- en: )
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (x is
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: (x is
- en: 'null'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 'null'
- en: '|| y is'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '|| y is'
- en: 'null'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 'null'
- en: )
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '0'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: ;
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // Compare the Name lengths...
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: // 比较名称长度...
- en: int
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: result = x.Name.Length.CompareTo(y.Name.Length);
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: result = x.Name.Length.CompareTo(y.Name.Length);
- en: // ...if they are equal...
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: // ...如果它们相等...
- en: if
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (result == 0
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: (result == 0
- en: )
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // ...then compare by the Names...
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: // ...然后按名称比较...
- en: return
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: x.Name.CompareTo(y.Name);
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: x.Name.CompareTo(y.Name);
- en: '}'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 否则
- en: // result will be -1 or 1
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: // 结果将是-1或1
- en: '{'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // ...otherwise compare by the lengths.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: // ...否则按长度比较。
- en: return
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: result;
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: result;
- en: '}'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to sort the array using this alternative implementation,
    as shown in the following code:'
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以使用此替代实现对数组进行排序，如下面的代码所示：
- en: '```cs'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine("Use PersonComparer's IComparer implementation to sort:"
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("使用PersonComparer的IComparer实现进行排序："
- en: );
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Array.Sort(people, new
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: Array.Sort(people, new
- en: PersonComparer());
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: PersonComparer());
- en: foreach
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: foreach
- en: (Person p in
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: (Person p in
- en: people)
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 人)
- en: '{'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{p.Name}'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '{p.Name}'
- en: '"'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-811
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Use PersonComparer''s IComparer implementation to sort:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PersonComparer的IComparer实现进行排序：
- en: Adam
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 亚当
- en: Jenny
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 珍妮
- en: Simon
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 西蒙
- en: Richard
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 理查德
- en: '```'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This time, when we sort the `people` array, we explicitly ask the sorting algorithm
    to use the `PersonComparer` type instead, so that the people are sorted with the
    shortest names first, like Adam, and the longest names last, like Richard; and
    when the lengths of two or more names are equal, to sort them alphabetically,
    like Jenny and Simon.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们对`people`数组进行排序时，我们明确要求排序算法使用`PersonComparer`类型，以便首先对人员进行排序，例如亚当，最后对最长的名称进行排序，例如理查德；当两个或更多名称的长度相等时，按字母顺序对它们进行排序，例如珍妮和西蒙。
- en: Implicit and explicit interface implementations
  id: totrans-820
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式和显式接口实现
- en: Interfaces can be implemented implicitly and explicitly. Implicit implementations
    are simpler and more common. Explicit implementations are only necessary if a
    type must have multiple methods with the same name and signature.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以被隐式和显式地实现。隐式实现更简单，更常见。只有在类型必须具有多个具有相同名称和签名的方法时，才需要显式实现。
- en: 'For example, both `IGamePlayer` and `IKeyHolder` might have a method called
    `Lose` with the same parameters because both a game and a key can be lost. In
    a type that must implement both interfaces, only one implementation of `Lose`
    can be the implicit method. If both interfaces can share the same implementation,
    that works, but if not then the other `Lose` method will have to be implemented
    differently and called explicitly, as shown in the following code:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`IGamePlayer`和`IKeyHolder`都可能有一个名为`Lose`的方法，因为游戏和钥匙都可以丢失。在必须实现两个接口的类型中，`Lose`的实现只能是隐式方法。如果两个接口可以共享相同的实现，那么可以，但如果不行，那么另一个`Lose`方法将必须以不同的方式实现并显式调用，如下面的代码所示：
- en: '```cs'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: interface
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 接口
- en: IGamePlayer
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: IGamePlayer
- en: '{'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: void
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Lose
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 失去
- en: ()
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: ;
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: interface
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 接口
- en: IKeyHolder
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: IKeyHolder
- en: '{'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: void
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Lose
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 失去
- en: ()
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: ;
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: class
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Person
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 人
- en: ': IGamePlayer'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: ': IGamePlayer'
- en: ', IKeyHolder'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: ', IKeyHolder'
- en: '{'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: void
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Lose
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 失去
- en: ()
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: // implicit implementation
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: // 隐式实现
- en: '{'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // implement losing a key
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: // 实现失去钥匙
- en: '}'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: IGamePlayer.Lose() // explicit implementation
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: IGamePlayer.Lose() // 显式实现
- en: '{'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // implement losing a game
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: // 实现失去游戏
- en: '}'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // calling implicit and explicit implementations of Lose
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: // 调用Lose的隐式和显式实现
- en: Person p = new
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 人 p = new
- en: ();
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: p.Lose(); // calls implicit implementation of losing a key
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: p.Lose(); // 调用失去钥匙的隐式实现
- en: ((IGamePlayer)p).Lose(); // calls explicit implementation of losing a game
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: ((IGamePlayer)p).Lose(); // 调用失去游戏的显式实现
- en: IGamePlayer player = p as
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: IGamePlayer player = p as
- en: IGamePlayer;
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: IGamePlayer;
- en: player.Lose(); // calls explicit implementation of losing a game
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: player.Lose(); // 调用失去游戏的显式实现
- en: '```'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Defining interfaces with default implementations
  id: totrans-871
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义具有默认实现的接口
- en: 'A language feature introduced in C# 8.0 is **default implementations** for
    an interface. Let''s see it in action:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8.0引入的一种语言特性是接口的**默认实现**。让我们看看它的作用：
- en: In the `PacktLibrary` project, add a new file named `IPlayable.cs` .
  id: totrans-873
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`IPlayable.cs`的新文件。
- en: 'Modify the statements to define a public `IPlayable` interface with two methods
    to `Play` and `Pause` , as shown in the following code:'
  id: totrans-874
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改语句以定义一个公共的`IPlayable`接口，其中包含两个`Play`和`Pause`方法，如下面的代码所示：
- en: '```cs'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: namespace
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: namespace
- en: Packt.Shared
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: interface
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 接口
- en: IPlayable
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: IPlayable
- en: '{'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: void
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Play
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 播放
- en: ()
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: ;
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: void
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Pause
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停
- en: ()
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: ;
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the `PacktLibrary` project, add a new class file named `DvdPlayer.cs` .
  id: totrans-893
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`DvdPlayer.cs`的新类文件。
- en: 'Modify the statements in the file to implement the `IPlayable` interface, as
    shown in the following code:'
  id: totrans-894
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改文件中的语句以实现`IPlayable`接口，如下面的代码所示：
- en: '```cs'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的
- en: System.Console;
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console;
- en: namespace
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: namespace
- en: Packt.Shared
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: class
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: DvdPlayer
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: DvdPlayer
- en: ': IPlayable'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: ': IPlayable'
- en: '{'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: void
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Pause
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停
- en: ()
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("DVD player is pausing."
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 写行("DVD播放器正在暂停。"
- en: );
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: void
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Play
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 播放
- en: ()
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("DVD player is playing."
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 写行("DVD播放器正在播放。"
- en: );
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This is useful, but what if we decide to add a third method named `Stop` ? Before
    C# 8.0, this would be impossible once at least one type implements the original
    interface. One of the main points of an interface is that it is a fixed contract.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有用，但如果我们决定添加一个名为`Stop`的第三个方法怎么办？在C# 8.0之前，一旦至少有一个类型实现了原始接口，这将是不可能的。接口的主要目的之一是它是一个固定的合同。
- en: C# 8.0 allows an interface to add new members after release as long as they
    have a default implementation. C# purists do not like the idea, but for practical
    reasons, such as avoiding breaking changes or having to define a whole new interface,
    it is useful, and other languages such as Java and Swift enable similar techniques.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8.0允许接口在发布后添加新成员，只要它们有默认实现。C#纯粹主义者不喜欢这个想法，但出于实际原因，比如避免破坏性更改或不得不定义一个全新的接口，这是有用的，其他语言如Java和Swift也支持类似的技术。
- en: Support for default interface implementations requires some fundamental changes
    to the underlying platform, so they are only supported with C# if the target framework
    is .NET 5.0 or later, .NET Core 3.0 or later, or .NET Standard 2.1\. They are
    therefore not supported by .NET Framework.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 默认接口实现的支持需要对底层平台进行一些基本更改，因此只有在目标框架为.NET 5.0或更高版本、.NET Core 3.0或更高版本、或.NET Standard
    2.1时才支持。因此，它们不受.NET Framework的支持。
- en: 'Modify the `IPlayable` interface to add a `Stop` method with a default implementation,
    as shown highlighted in the following code:'
  id: totrans-928
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`IPlayable`接口以添加一个具有默认实现的`Stop`方法，如下面代码中的高亮部分所示：
- en: '```cs'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '**using**'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用**'
- en: '**static**'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态的**'
- en: '**System.Console;**'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '**System.Console;**'
- en: namespace
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: namespace
- en: Packt.Shared
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: interface
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 接口
- en: IPlayable
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: IPlayable
- en: '{'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: void
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Play
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 播放
- en: ()
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: ;
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: void
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Pause
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停
- en: ()
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: ;
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '**void**'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '**void**'
- en: '**Stop**'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '**停止**'
- en: '**()**'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '**()**'
- en: '**// default interface implementation**'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 默认接口实现**'
- en: '**{**'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**WriteLine(**'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '**写行(**'
- en: '**"Default implementation of Stop."**'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '**"停止的默认实现。"**'
- en: '**);**'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '**);**'
- en: '**}**'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '}'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Build the `PeopleApp` project and note that the projects compile successfully
    despite the `DvdPlayer` class not implementing `Stop` . In the future, we could
    override the default implementation of `Stop` by implementing it in the `DvdPlayer`
    class.
  id: totrans-959
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`PeopleApp`项目，并注意尽管`DvdPlayer`类没有实现`Stop`，但项目仍然成功编译。将来，我们可以通过在`DvdPlayer`类中实现它来覆盖`Stop`的默认实现。
- en: Managing memory with reference and value types
  id: totrans-960
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用引用和值类型管理内存
- en: I have mentioned reference types a couple of times. Let's look at them in more
    detail.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经多次提到引用类型。让我们更详细地看看它们。
- en: 'There are two categories of memory: **stack** memory and **heap** memory. With
    modern operating systems, the stack and heap can be anywhere in physical or virtual
    memory.'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 内存有两种类别：**栈**内存和**堆**内存。在现代操作系统中，栈和堆可以位于物理或虚拟内存中的任何位置。
- en: Stack memory is faster to work with (because it is managed directly by the CPU
    and because it uses a last-in, first-out mechanism, it is more likely to have
    the data in its L1 or L2 cache) but limited in size, while heap memory is slower
    but much more plentiful.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈内存的工作速度更快（因为它由CPU直接管理，并且因为它使用后进先出机制，更有可能在其L1或L2缓存中有数据），但大小有限，而堆内存速度较慢，但更加丰富。
- en: For example, in a macOS terminal, I can enter the command `ulimit -a` to discover
    that the stack size is limited to 8,192 KB and that other memory is "unlimited."
    This limited amount of stack memory is why it is so easy to fill it up and get
    a "stack overflow."
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在macOS终端中，我可以输入命令`ulimit -a`来发现堆栈大小限制为8192 KB，其他内存为“无限”。这有限的堆栈内存量是为什么很容易填满并出现“堆栈溢出”的原因。
- en: Defining reference and value types
  id: totrans-965
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义引用类型和值类型
- en: 'There are three C# keywords that you can use to define object types: `class`
    , `record` , and `struct` . All can have the same members, such as fields and
    methods. One difference between them is how memory is allocated.'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个C#关键字可以用来定义对象类型：`class`，`record`和`struct`。所有这些都可以有相同的成员，比如字段和方法。它们之间的一个区别是内存分配的方式。
- en: When you define a type using `record` or `class` , you are defining a **reference
    type** . This means that the memory for the object itself is allocated on the
    heap, and only the memory address of the object (and a little overhead) is stored
    on the stack.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`record`或`class`定义类型时，你正在定义一个**引用类型**。这意味着对象本身的内存分配在堆上，只有对象的内存地址（和一些开销）存储在堆栈上。
- en: When you define a type using `record struct` or `struct` , you are defining
    a **value type** . This means that the memory for the object itself is allocated
    on the stack.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`record struct`或`struct`定义类型时，你正在定义一个**值类型**。这意味着对象本身的内存分配在堆栈上。
- en: If a `struct` uses field types that are not of the `struct` type, then those
    fields will be stored on the heap, meaning the data for that object is stored
    in both the stack and the heap!
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个`struct`使用的字段类型不是`struct`类型，那么这些字段将存储在堆上，这意味着该对象的数据同时存储在堆和堆栈中！
- en: 'These are the most common struct types:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最常见的结构类型：
- en: '**Number** `System` **types** : `byte` , `sbyte` , `short` , `ushort` , `int`
    , `uint` , `long` , `ulong` , `float` , `double` , and `decimal`'
  id: totrans-971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字**`System`**类型**：`byte`，`sbyte`，`short`，`ushort`，`int`，`uint`，`long`，`ulong`，`float`，`double`，和`decimal`'
- en: '**Other** `System` **types** : `char` , `DateTime` , and `bool`'
  id: totrans-972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他**`System`**类型**：`char`，`DateTime`，和`bool`'
- en: '`System.Drawing` **types** : `Color` , `Point` , and `Rectangle`'
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Drawing`**类型**：`Color`，`Point`，和`Rectangle`'
- en: Almost all the other types are `class` types, including `string` .
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有其他类型都是`class`类型，包括`string`。
- en: Apart from the difference in terms of where in memory the data for a type is
    stored, the other major difference is that you cannot inherit from a `struct`
    .
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在内存中存储类型数据的位置不同之外，另一个主要区别是你不能从`struct`继承。
- en: How reference and value types are stored in memory
  id: totrans-976
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型和值类型在内存中的存储方式
- en: 'Imagine that you have a console app that declares some variables, as shown
    in the following code:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个控制台应用程序，声明了一些变量，如下面的代码所示：
- en: '```cs'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: number1 = 49
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: number1 = 49
- en: ;
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: ；
- en: long
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: long
- en: number2 = 12
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: number2 = 12
- en: ;
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: ；
- en: System.Drawing.Point location = new
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: System.Drawing.Point location = new
- en: '(x: 4'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: （x：4
- en: ', y: 5'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: ，y：5
- en: );
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: Person kevin = new
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: Person kevin = new
- en: () { Name = "Kevin"
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Kevin"
- en: ','
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: DateOfBirth = new
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: DateOfBirth = new
- en: '(year: 1988'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: （年份：1988
- en: ', month: 9'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: ，月：9
- en: ', day: 23'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: ，日：23
- en: ) };
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: ) };
- en: Person sally;
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: Person sally;
- en: '```'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Let''s review what memory is allocated on the stack and heap when these statements
    execute, as shown in *Figure 6.1* and as described in the following list:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下当这些语句执行时，在堆栈和堆上分配了哪些内存，如*图6.1*所示，并在以下列表中描述：
- en: The `number1` variable is a value type (also known as `struct` ) so it is allocated
    on the stack and it uses 4 bytes of memory since it is a 32-bit integer. Its value,
    49, is stored directly in the variable.
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number1`变量是一个值类型（也称为`struct`），因此它在堆栈上分配，并且使用4个字节的内存，因为它是一个32位整数。它的值49直接存储在变量中。'
- en: The `number2` variable is also a value type so it is also allocated on the stack,
    and it uses 8 bytes since it is a 64-bit integer.
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number2`变量也是一个值类型，因此也在堆栈上分配，并且使用8个字节，因为它是一个64位整数。'
- en: The `location` variable is also a value type so it is allocated on the stack
    and it uses 8 bytes since it is made up of two 32-bit integers, `x` and `y` .
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`变量也是一个值类型，因此它在堆栈上分配，并且使用8个字节，因为它由两个32位整数`x`和`y`组成。'
- en: The `kevin` variable is a reference type (also known as `class` ) so 8 bytes
    for a 64-bit memory address (assuming a 64-bit operating system) is allocated
    on the stack and enough bytes on the heap to store an instance of a `Person` .
  id: totrans-1003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kevin`变量是一个引用类型（也称为`class`），因此在堆栈上分配了8个字节用于64位内存地址（假设64位操作系统），并在堆上分配了足够的字节来存储`Person`的实例。'
- en: The `sally` variable is a reference type so 8 bytes for a 64-bit memory address
    is allocated on the stack. It is currently `null` , meaning no memory has yet
    been allocated for it on the heap.
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sally`变量是一个引用类型，因此在堆栈上分配了8个字节用于64位内存地址。它目前是`null`，意味着尚未为它在堆上分配内存。'
- en: '![](img/Image00069.jpg)'
  id: totrans-1005
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00069.jpg)'
- en: 'Figure 6.1: How value and reference types are allocated in the stack and heap'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：值类型和引用类型在堆栈和堆中的分配方式
- en: All the allocated memory for a reference type is stored on the heap. If a value
    type such as `DateTime` is used for a field of a reference type like `Person`
    , then the `DateTime` value is stored on the heap.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型的所有分配的内存都存储在堆上。如果引用类型如`Person`的字段使用值类型如`DateTime`，那么`DateTime`的值将存储在堆上。
- en: If a value type has a field that is a reference type, then that part of the
    value type is stored on the heap. `Point` is a value type that consists of two
    fields, both of which are themselves value types, so the entire object can be
    allocated on the stack. If the `Point` value type had a field that was a reference
    type, like `string` , then the `string` bytes would be stored on the heap.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值类型有一个字段是引用类型，那么值类型的那部分存储在堆上。`Point`是一个值类型，由两个字段组成，它们都是值类型，因此整个对象可以分配在堆栈上。如果`Point`值类型有一个字段是引用类型，比如`string`，那么`string`的字节将存储在堆上。
- en: Equality of types
  id: totrans-1009
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型的相等性
- en: It is common to compare two variables using the `==` and `!=` operators. The
    behavior of these two operators is different for reference types and value types.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个变量使用`==`和`!=`运算符是很常见的。这两个运算符的行为对于引用类型和值类型是不同的。
- en: 'When you check the equality of two value type variables, .NET literally compares
    the values of those two variables on the stack and returns `true` if they are
    equal, as shown in the following code:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 当您检查两个值类型变量的相等性时，.NET会在堆栈上直接比较这两个变量的值，并在它们相等时返回`true`，如下面的代码所示：
- en: '```cs'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: a = 3
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: a = 3
- en: ;
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: b = 3
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: b = 3
- en: ;
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: 'WriteLine($"a == b:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine($"a == b:'
- en: '{(a == b)}'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '{(a == b)}'
- en: '"'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: ); // true
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: ); // true
- en: '```'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'When you check the equality of two reference type variables, .NET compares
    the memory addresses of those two variables and returns `true` if they are equal,
    as shown in the following code:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 当您检查两个引用类型变量的相等性时，.NET比较这两个变量的内存地址，并在它们相等时返回`true`，如下面的代码所示：
- en: '```cs'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Person a = new
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: Person a = new
- en: () { Name = "Kevin"
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Kevin"
- en: '};'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: Person b = new
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: Person b = new
- en: () { Name = "Kevin"
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Kevin"
- en: '};'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'WriteLine($"a == b:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine($"a == b:'
- en: '{(a == b)}'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '{(a == b)}'
- en: '"'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: ); // false
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: ); // false
- en: '```'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This is because they are not the same object. If both variables literally point
    to the same object on the heap, then they would be equal, as shown in the following
    code:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为它们不是相同的对象。如果两个变量指向堆上的同一个对象，那么它们将相等，如下面的代码所示：
- en: '```cs'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Person a = new
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: Person a = new
- en: () { Name = "Kevin"
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Kevin"
- en: '};'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: Person b = a;
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: Person b = a;
- en: 'WriteLine($"a == b:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine($"a == b:'
- en: '{(a == b)}'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '{(a == b)}'
- en: '"'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: ); // true
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: ); // true
- en: '```'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The one exception to this behavior is the `string` type. It is a reference
    type, but the equality operators have been overridden to make them behave as if
    they were value types, as shown in the following code:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的一个例外是`string`类型。它是一个引用类型，但相等运算符已被重写，使它们的行为就像值类型一样，如下面的代码所示：
- en: '```cs'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: a = "Kevin"
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: a = "Kevin"
- en: ;
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: string
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: b = "Kevin"
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: b = "Kevin"
- en: ;
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: 'WriteLine($"a == b:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine($"a == b:'
- en: '{(a == b)}'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '{(a == b)}'
- en: '"'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: ); // true
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: ); // true
- en: '```'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You can do something similar with your classes to make the equality operators
    return `true` even if they are not the same object (same memory address on the
    heap) but instead if their fields have the same values, but that is beyond the
    scope of this book. Alternatively, use a `record class` because one of their benefits
    is that they implement this behavior for you.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以对您的类做类似的事情，使相等运算符返回`true`，即使它们不是相同的对象（堆上的相同内存地址），而是如果它们的字段具有相同的值，但这超出了本书的范围。或者，使用`record
    class`，因为它们的一个好处是它们为您实现了这种行为。
- en: Defining struct types
  id: totrans-1062
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义结构类型
- en: 'Let''s explore defining your own value types:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索定义自己的值类型：
- en: In the `PacktLibrary` project, add a file named `DisplacementVector.cs` .
  id: totrans-1064
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`DisplacementVector.cs`的文件。
- en: 'Modify the file, as shown in the following code, and note the following:'
  id: totrans-1065
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改文件，如下面的代码所示，并注意以下内容：
- en: The type is declared using `struct` instead of `class` .
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型是使用`struct`而不是`class`声明的。
- en: It has two `int` fields, named `X` and `Y` .
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有两个`int`字段，名为`X`和`Y`。
- en: It has a constructor for setting initial values for `X` and `Y` .
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个用于设置`X`和`Y`的初始值的构造函数。
- en: It has an operator for adding two instances together that returns a new instance
    of the type with `X` added to `X` , and `Y` added to `Y` .
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个用于将两个实例相加并返回类型的新实例的操作符，其中`X`添加到`X`，`Y`添加到`Y`。
- en: '```cs'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: namespace
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: struct
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 结构
- en: DisplacementVector
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: DisplacementVector
- en: '{'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: int
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: X;
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: X;
- en: public
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: int
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: Y;
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: Y;
- en: public
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: DisplacementVector
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 位移向量
- en: (
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: int
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: initialX,
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: initialX，
- en: int
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: initialY
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: initialY
- en: )
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: X = initialX;
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: X = initialX;
- en: Y = initialY;
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: Y = initialY;
- en: '}'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: static
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: DisplacementVector operator
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: DisplacementVector operator
- en: +(
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: +(
- en: DisplacementVector vector1,
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: DisplacementVector vector1，
- en: DisplacementVector vector2)
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: DisplacementVector vector2)
- en: '{'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: new
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 新
- en: (
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: vector1.X + vector2.X,
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: vector1.X + vector2.X，
- en: vector1.Y + vector2.Y);
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: vector1.Y + vector2.Y);
- en: '}'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to create two new instances of `DisplacementVector`
    , add them together, and output the result, as shown in the following code:'
  id: totrans-1111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句创建两个新的`DisplacementVector`实例，将它们相加，并输出结果，如下面的代码所示：
- en: '```cs'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: DisplacementVector dv1 = new
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: DisplacementVector dv1 = new
- en: (3
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: (3
- en: ', 5'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: ，5
- en: );
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: DisplacementVector dv2 = new
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: DisplacementVector dv2 = new
- en: (-2
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: (-2
- en: ', 7'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: ，7
- en: );
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: DisplacementVector dv3 = dv1 + dv2;
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: DisplacementVector dv3 = dv1 + dv2;
- en: WriteLine($"(
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"(
- en: '{dv1.X}'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '{dv1.X}'
- en: ','
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: '{dv1.Y}'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '{dv1.Y}'
- en: ) + (
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: ) + (
- en: '{dv2.X}'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: '{dv2.X}'
- en: ','
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: '{dv2.Y}'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '{dv2.Y}'
- en: ) = (
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: ) = (
- en: '{dv3.X}'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '{dv3.X}'
- en: ','
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: '{dv3.Y}'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '{dv3.Y}'
- en: )"
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: )"
- en: );
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: (3, 5) + (-2, 7) = (1, 12)
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: (3, 5) + (-2, 7) = (1, 12)
- en: '```'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : If the total bytes used by all the fields in your type
    is 16 bytes or less, your type only uses value types for its fields, and you will
    never want to derive from your type, then Microsoft recommends that you use `struct`
    . If your type uses more than 16 bytes of stack memory, if it uses reference types
    for its fields, or if you might want to inherit from it, then use `class` .'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果类型中所有字段使用的总字节数不超过16字节，类型只使用值类型作为其字段，并且永远不想从类型派生，那么Microsoft建议使用`struct`。如果类型使用的堆栈内存超过16字节，如果它使用引用类型作为其字段，或者可能想要从中继承，那么使用`class`。'
- en: Working with record struct types
  id: totrans-1142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用记录结构类型
- en: C# 10 introduced the ability to use the `record` keyword with `struct` types
    as well as with class types.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10引入了使用`record`关键字与`struct`类型以及类类型一起使用的能力。
- en: 'We could define the `DisplacementVector` type, as shown in the following code:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义`DisplacementVector`类型，如下面的代码所示：
- en: '```cs'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: record
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 记录
- en: struct
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 结构
- en: DisplacementVector
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 位移矢量
- en: (
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: （
- en: int
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: X,
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: X，
- en: int
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: Y
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: Y
- en: )
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: ;
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'With this change, Microsoft recommends explicitly specifying `class` if you
    want to define a `record class` even though the `class` keyword is optional, as
    shown in the following code:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个改变，微软建议如果要定义`record class`，则明确指定`class`，即使`class`关键字是可选的，如下面的代码所示：
- en: '```cs'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: record
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 记录
- en: class
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: ImmutableAnimal
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: ImmutableAnimal
- en: (
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: （
- en: string
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: Name
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 名称
- en: )
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: ;
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Releasing unmanaged resources
  id: totrans-1170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 释放非托管资源
- en: In the previous chapter, we saw that constructors can be used to initialize
    fields and that a type may have multiple constructors. Imagine that a constructor
    allocates an unmanaged resource; that is, anything that is not controlled by .NET,
    such as a file or mutex under the control of the operating system. The unmanaged
    resource must be manually released because .NET cannot do it for us using its
    automatic garbage collection feature.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们看到构造函数可以用来初始化字段，并且一个类型可以有多个构造函数。想象一下，一个构造函数分配了一个非托管资源；也就是说，任何不受.NET控制的东西，比如操作系统控制下的文件或互斥体。非托管资源必须手动释放，因为.NET无法使用其自动垃圾收集功能为我们释放它。
- en: Garbage collection is an advanced topic, so for this topic, I will show some
    code examples, but you do not need to write the code yourself.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集是一个高级主题，所以在这个主题中，我将展示一些代码示例，但您不需要自己编写代码。
- en: Each type can have a single **finalizer** that will be called by the .NET runtime
    when the resources need to be released. A finalizer has the same name as a constructor;
    that is, the type name, but it is prefixed with a tilde, `~` .
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型都可以有一个**终结器**，当需要释放资源时，.NET运行时将调用该终结器。终结器与构造函数具有相同的名称；也就是说，类型名称，但前缀是波浪号`~`。
- en: 'Do not confuse a finalizer (also known as a **destructor** ) with a `Deconstruct`
    method. A destructor releases resources; that is, it destroys an object in memory.
    A `Deconstruct` method returns an object split up into its constituent parts and
    uses the C# deconstruction syntax, for example, when working with tuples:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将终结器（也称为**析构函数**）与`Deconstruct`方法混淆。析构函数释放资源；也就是说，它在内存中销毁对象。`Deconstruct`方法返回一个分解为其组成部分的对象，并使用C#分解语法，例如，在使用元组时：
- en: '```cs'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: class
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Animal
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 动物
- en: '{'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: Animal
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 动物
- en: ()
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: （）
- en: // constructor
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: //构造函数
- en: '{'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // allocate any unmanaged resources
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: //分配任何非托管资源
- en: '}'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ~Animal() // Finalizer aka destructor
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: ~动物（）//终结器也称为析构函数
- en: '{'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // deallocate any unmanaged resources
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: // 释放任何非托管资源
- en: '}'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The preceding code example is the minimum you should do when working with unmanaged
    resources. But the problem with only providing a finalizer is that the .NET garbage
    collector requires two garbage collections to completely release the allocated
    resources for this type.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理非托管资源时，上述代码示例是您应该做的最少工作。但是，仅提供终结器的问题在于，.NET垃圾收集器需要两次垃圾收集才能完全释放为该类型分配的资源。
- en: Though optional, it is recommended to also provide a method to allow a developer
    who uses your type to explicitly release resources so that the garbage collector
    can release managed parts of an unmanaged resource, such as a file, immediately
    and deterministically, and then release the managed memory part of the object
    in a single garbage collection instead of two rounds of garbage collection.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可选，但建议还提供一个方法，允许使用您的类型的开发人员显式释放资源，以便垃圾收集器可以立即和确定地释放非托管资源的托管部分，比如文件，然后在单次垃圾收集中释放对象的托管内存部分，而不是两轮垃圾收集。
- en: 'There is a standard mechanism for doing this by implementing the `IDisposable`
    interface, as shown in the following example:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个实现`IDisposable`接口的标准机制，如下例所示：
- en: '```cs'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: class
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Animal
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 动物
- en: ': IDisposable'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: ：IDisposable
- en: '{'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: Animal
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 动物
- en: ()
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: （）
- en: '{'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // allocate unmanaged resource
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: //分配非托管资源
- en: '}'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ~Animal() // Finalizer
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: ~动物（）//终结器
- en: '{'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Dispose(false
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: Dispose(false
- en: );
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: bool
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔
- en: disposed = false
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 已处理=假
- en: ; // have resources been released?
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: ; //资源是否已被释放？
- en: public
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: void
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 无效
- en: Dispose
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 处理
- en: ()
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: （）
- en: '{'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Dispose(true
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: Dispose(true
- en: );
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: // tell garbage collector it does not need to call the finalizer
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: //告诉垃圾收集器不需要调用终结器
- en: GC.SuppressFinalize(this
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: GC.SuppressFinalize(this
- en: );
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: protected
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: protected
- en: virtual
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟
- en: void
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 无效
- en: Dispose
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 处理
- en: (
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: （
- en: bool
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔
- en: disposing
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 处理
- en: )
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: '{'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (disposed) return
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: （已处理）返回
- en: ;
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: // deallocate the *unmanaged* resource
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: //释放*非托管*资源
- en: // ...
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: if
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (disposing)
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: （处理）
- en: '{'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // deallocate any other *managed* resources
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: // 释放任何其他*托管*资源
- en: // ...
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '}'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: disposed = true
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 已处理=真
- en: ;
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'There are two `Dispose` methods, one `public` and one `protected` :'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个`Dispose`方法，一个`public`，一个`protected`：
- en: The `public void Dispose` method will be called by a developer using your type.
    When called, both unmanaged and managed resources need to be deallocated.
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void Dispose`方法将由使用您的类型的开发人员调用。调用时，需要释放非托管和托管资源。'
- en: The `protected virtual void Dispose` method with a `bool` parameter is used
    internally to implement the deallocation of resources. It needs to check the `disposing`
    parameter and `disposed` field because if the finalizer thread has already run
    and it called the `~Animal` method, then only unmanaged resources need to be deallocated.
  id: totrans-1254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有`bool`参数的`protected virtual void Dispose`方法在内部用于实现资源的释放。它需要检查`disposing`参数和`disposed`字段，因为如果终结器线程已经运行并调用了`~Animal`方法，那么只需要释放非托管资源。
- en: The call to `GC.SuppressFinalize(this)` is what notifies the garbage collector
    that it no longer needs to run the finalizer, and removes the need for a second
    garbage collection.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`GC.SuppressFinalize(this)`是通知垃圾收集器不再需要运行终结器，并且消除了需要进行第二次垃圾收集。
- en: Ensuring that Dispose is called
  id: totrans-1256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保调用Dispose
- en: 'When someone uses a type that implements `IDisposable` , they can ensure that
    the public `Dispose` method is called with the `using` statement, as shown in
    the following code:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人使用实现了`IDisposable`的类型时，他们可以确保使用`using`语句调用公共的`Dispose`方法，如下面的代码所示：
- en: '```cs'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: (Animal a = new
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: （Animal a = new
- en: ())
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: （）
- en: '{'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // code that uses the Animal instance
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用Animal实例的代码
- en: '}'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The compiler converts your code into something like the following, which guarantees
    that even if an exception occurs, the `Dispose` method will still be called:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将您的代码转换为以下内容，这样即使发生异常，`Dispose`方法仍将被调用：
- en: '```cs'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Animal a = new
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: Animal a = new
- en: ();
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: try
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: try
- en: '{'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // code that uses the Animal instance
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用Animal实例的代码
- en: '}'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: finally
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 最终
- en: '{'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: (a != null
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: (a != null
- en: ) a.Dispose();
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: ）a.Dispose();
- en: '}'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You will see practical examples of releasing unmanaged resources with `IDisposable`
    , `using` statements, and `try` ...`finally` blocks in *Chapter 9* , *Working
    with Files, Streams, and Serialization* .
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到使用`IDisposable`、`using`语句和`try`...`finally`块释放非托管资源的实际示例，*第9章*，*使用文件、流和序列化*中有详细介绍。
- en: Working with null values
  id: totrans-1282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用null值
- en: You have seen how to store primitive values like numbers in `struct` variables.
    But what if a variable does not yet have a value? How can we indicate that? C#
    has the concept of a `null` value, which can be used to indicate that a variable
    has not been set.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到如何将诸如数字之类的原始值存储在`struct`变量中。但是如果一个变量还没有值怎么办？我们如何表示？C#有一个`null`值的概念，可以用来表示一个变量还没有被设置。
- en: Making a value type nullable
  id: totrans-1284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使值类型可空
- en: By default, value types like `int` and `DateTime` must always have a value,
    hence their name. Sometimes, for example, when reading values stored in a database
    that allows empty, missing, or null values, it is convenient to allow a value
    type to be `null` . We call this a **nullable value type** .
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，像`int`和`DateTime`这样的值类型必须始终有一个值，因此它们的名称。有时，例如在读取存储在允许空、缺失或空值的数据库中的值时，允许值类型为`null`是方便的。我们称之为**可空值类型**。
- en: You can enable this by adding a question mark as a suffix to the type when declaring
    a variable.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在声明变量时在类型后面添加问号来启用此功能。
- en: 'Let''s see an example:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter06`
    workspace/solution named `NullHandling` . This section requires a full application
    with a project file, so you will not be able to use a .NET Interactive notebook.
  id: totrans-1288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具将一个新的**控制台应用程序**添加到名为`NullHandling`的`Chapter06`工作区/解决方案中。本节需要一个带有项目文件的完整应用程序，因此您将无法使用.NET交互式笔记本。
- en: In Visual Studio Code, select `NullHandling` as the active OmniSharp project.
    In Visual Studio, set `NullHandling` as the startup project.
  id: totrans-1289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`NullHandling`作为活动的OmniSharp项目。在Visual Studio中，将`NullHandling`设置为启动项目。
- en: 'In `Program.cs` , type statements to declare and assign values, including `null`
    , to `int` variables, as shown in the following code:'
  id: totrans-1290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，输入语句来声明和赋值，包括`null`，给`int`变量，如下面的代码所示：
- en: '```cs'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: thisCannotBeNull  = 4
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: thisCannotBeNull  = 4
- en: ;
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: thisCannotBeNull = null
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: thisCannotBeNull = null
- en: ; // compile error!
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 编译错误！
- en: int
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: '? thisCouldBeNull = null'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: '? thisCouldBeNull = null```'
- en: ;
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: WriteLine(thisCouldBeNull);
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(thisCouldBeNull);
- en: WriteLine(thisCouldBeNull.GetValueOrDefault());
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(thisCouldBeNull.GetValueOrDefault());
- en: thisCouldBeNull = 7
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: thisCouldBeNull = 7
- en: ;
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: WriteLine(thisCouldBeNull);
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(thisCouldBeNull);
- en: WriteLine(thisCouldBeNull.GetValueOrDefault());
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(thisCouldBeNull.GetValueOrDefault());
- en: '```'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Comment out the statement that gives a compile error.
  id: totrans-1307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉导致编译错误的语句。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '0'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '7'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '7'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '```'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The first line is blank because it is outputting the `null` value!
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是空的，因为它输出了`null`值！
- en: Understanding nullable reference types
  id: totrans-1315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解可空引用类型
- en: The use of the `null` value is so common, in so many languages, that many experienced
    programmers never question the need for its existence. But there are many scenarios
    where we could write better, simpler code if a variable is not allowed to have
    a `null` value.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`值的使用是如此普遍，在许多语言中都是如此，以至于许多有经验的程序员从未质疑其存在的必要性。但有许多情况下，如果一个变量不允许有`null`值，我们可以编写更好、更简单的代码。'
- en: The most significant change to the language in C# 8 was the introduction of
    nullable and non- nullable reference types. "But wait!", you are probably thinking,
    "Reference types are already nullable!"
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8中对语言最重大的改变是引入了可空和非可空引用类型。"但等等!"，你可能会想，"引用类型已经是可空的了!"
- en: And you would be right, but in C# 8 and later, reference types can be configured
    to no longer allow the `null` value by setting a file- or project-level option
    to enable this useful new feature. Since this is a big change for C#, Microsoft
    decided to make the feature opt-in.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 你是对的，但在C# 8及以后的版本中，可以通过设置文件或项目级选项来配置引用类型不再允许`null`值，从而启用这一有用的新功能。由于这对C#来说是一个重大的改变，微软决定将这一功能设置为选择性的。
- en: It will take multiple years for this new C# language feature to make an impact
    since thousands of existing library packages and apps will expect the old behavior.
    Even Microsoft did not have time to fully implement this new feature in all the
    main .NET packages until .NET 6.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 由于成千上万的现有库包和应用程序将期望旧的行为，这种新的C#语言特性需要多年的时间才能产生影响。即使是微软也没有时间在.NET 6之前在所有主要的.NET包中完全实现这一新功能。
- en: 'During the transition, you can choose between several approaches for your own
    projects:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 在过渡期间，您可以为自己的项目选择几种方法：
- en: '**Default** : No changes are needed. Non-nullable reference types are not supported.'
  id: totrans-1321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认**：不需要更改。不支持非可空引用类型。'
- en: '**Opt-in project, opt-out files** : Enable the feature at the project level
    and, for any files that need to remain compatible with old behavior, opt out.
    This is the approach Microsoft is using internally while it updates its own packages
    to use this new feature.'
  id: totrans-1322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择性项目，选择性文件**：在项目级别启用该功能，并对需要保持与旧行为兼容的任何文件进行选择性退出。这是微软在更新自己的包以使用这一新功能时内部使用的方法。'
- en: '**Opt-in files** : Only enable the feature for individual files.'
  id: totrans-1323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择性文件**：仅为单个文件启用该功能。'
- en: Enabling nullable and non-nullable reference types
  id: totrans-1324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用可空和非空引用类型
- en: 'To enable the feature at the project level, add the following to your project
    file:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目级别启用该功能，请将以下内容添加到项目文件中：
- en: '```cs'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <PropertyGroup>
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: <PropertyGroup>
- en: '...'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: <Nullable>enable</Nullable>
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: <Nullable>enable</Nullable>
- en: </PropertyGroup>
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: </PropertyGroup>
- en: '```'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This is now done by default in project templates that target .NET 6.0.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在是项目模板的默认设置，目标为.NET 6.0。
- en: 'To disable the feature at the file level, add the following to the top of a
    code file:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件级别禁用该功能，请在代码文件顶部添加以下内容：
- en: '```cs'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '#nullable disable'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '#nullable disable'
- en: '```'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To enable the feature at the file level, add the following to the top of a
    code file:'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件级别启用该功能，请在代码文件顶部添加以下内容：
- en: '```cs'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '#nullable enable'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: '#nullable enable'
- en: '```'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Declaring non-nullable variables and parameters
  id: totrans-1341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明非空变量和参数
- en: If you enable nullable reference types and you want a reference type to be assigned
    the `null` value, then you will have to use the same syntax as making a value
    type nullable, that is, adding a `?` symbol after the type declaration.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您启用了可空引用类型，并且希望将引用类型分配为`null`值，则必须使用与使值类型可空相同的语法，即在类型声明后添加`?`符号。
- en: 'So, how do nullable reference types work? Let''s look at an example. When storing
    information about an address, you might want to force a value for the street,
    city, and region, but the building can be left blank, that is, `null` :'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，可空引用类型是如何工作的呢？让我们看一个例子。当存储有关地址的信息时，您可能希望强制对街道、城市和地区进行赋值，但建筑可以留空，即`null`：
- en: 'In `NullHandling.csproj` , in `Program.cs` , at the bottom of the file, add
    statements to declare an `Address` class with four fields, as shown in the following
    code:'
  id: totrans-1344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NullHandling.csproj`文件的`Program.cs`文件中，向文件底部添加语句来声明一个具有四个字段的`Address`类，如下面的代码所示：
- en: '```cs'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: class
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Address
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 地址
- en: '{'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: string
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: '? Building;'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: ？建筑;
- en: public
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: string
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: Street;
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 街道;
- en: public
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: string
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: City;
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 城市;
- en: public
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: string
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: Region;
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 地区;
- en: '}'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: After a few seconds, note the warnings about non-nullable fields, like `Street`
    not being initialized, as shown in *Figure 6.2* :![Graphical user interface, text,
    application, chat or text message Description automatically generated](img/Image00070.jpg)
  id: totrans-1363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，注意警告，比如`Street`未初始化，如*图6.2*所示：![图形用户界面，文本，应用程序，聊天或短信描述自动生成](img/Image00070.jpg)
- en: 'Figure 6.2: Warning messages about non-nullable fields in the PROBLEMS window'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：PROBLEMS窗口中关于非空字段的警告消息
- en: 'Assign the empty `string` value to each of the three fields that are non-nullable,
    as shown in the following code:'
  id: totrans-1365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将空的`string`值分配给三个非空字段，如下面的代码所示：
- en: '```cs'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: string
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: Street = string
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 街道=字符串
- en: .Empty;
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: .Empty;
- en: public
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: string
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: City = string
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 城市=字符串
- en: .Empty;
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: .Empty;
- en: public
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: string
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: Region = string
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 地区=字符串
- en: .Empty;
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: .Empty;
- en: '```'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , at the top of the file, statically import `Console` and then
    add statements to instantiate an `Address` and set its properties, as shown in
    the following code:'
  id: totrans-1380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件的顶部，静态导入`Console`，然后添加语句来实例化`Address`并设置其属性，如下面的代码所示：
- en: '```cs'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Address address = new
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: Address address = new
- en: ();
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: address.Building = null
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: address.Building=null
- en: ;
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: address.Street = null
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: address.Street = null
- en: ;
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: address.City = "London"
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: address.City = "伦敦"
- en: ;
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: address.Region = null
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: address.Region=null
- en: ;
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Note the warnings, as shown in *Figure 6.3* :![Graphical user interface, text,
    application, chat or text message, email Description automatically generated](img/Image00071.jpg)
  id: totrans-1393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意警告，如*图6.3*所示：![图形用户界面，文本，应用程序，聊天或短信，电子邮件描述自动生成](img/Image00071.jpg)
- en: 'Figure 6.3: Warning message about assigning null to a non-nullable field'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：关于将null赋给非空字段的警告消息
- en: So, this is why the new language feature is named nullable reference types.
    Starting with C# 8.0, unadorned reference types can become non-nullable, and the
    same syntax is used to make a reference type nullable as is used for value types.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是为什么新的语言特性被称为可空引用类型。从C# 8.0开始，未装饰的引用类型可以变为非空，而使引用类型可空的语法与使值类型可空的语法相同。
- en: Checking for null
  id: totrans-1396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查null
- en: 'Checking whether a nullable reference type or nullable value type variable
    currently contains `null` is important because if you do not, a `NullReferenceException`
    can be thrown, which results in an error. You should check for a `null` value
    before using a nullable variable, as shown in the following code:'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 检查可空引用类型或可空值类型变量当前是否包含`null`很重要，因为如果不这样做，可能会抛出`NullReferenceException`，导致错误。在使用可空变量之前，应检查是否为`null`值，如下面的代码所示：
- en: '```cs'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // check that the variable is not null before using it
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: //在使用之前检查变量是否为null
- en: if
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (thisCouldBeNull != null
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: （thisCouldBeNull != null
- en: )
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // access a member of thisCouldBeNull
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: //访问thisCouldBeNull的成员
- en: int
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: length = thisCouldBeNull.Length; // could throw exception
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 长度= thisCouldBeNull.Length; //可能会抛出异常
- en: '...'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'C# 7 introduced `is` combined with the `!` (not) operator as an alternative
    to `!=` , as shown in the following code:'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7引入了`is`与`!`（非）运算符结合，作为`!=`的替代，如下面的代码所示：
- en: '```cs'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: if
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (!(thisCouldBeNull is
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: (!(thisCouldBeNull is
- en: 'null'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 'null'
- en: ))
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: ))
- en: '{'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '```'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'C# 9 introduced `is not` as an even clearer alternative, as shown in the following
    code:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9引入了`is not`作为更清晰的替代方案，如下面的代码所示：
- en: '```cs'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: if
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (thisCouldBeNull is
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: （这可能为空
- en: not
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 不是
- en: 'null'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 'null'
- en: )
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '```'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If you are trying to use a member of a variable that might be `null` , use
    the null-conditional operator `?.` , as shown in the following code:'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试使用可能为`null`的变量的成员，请使用空值条件运算符`?.`进行检查，如下面的代码所示：
- en: '```cs'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: authorName = null
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: authorName=null
- en: ;
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: // the following throws a NullReferenceException
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: //以下会引发NullReferenceException
- en: int
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: x = authorName.Length;
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: x = authorName.Length;
- en: // instead of throwing an exception, null is assigned to y
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: //而不是抛出异常，将null分配给y
- en: int
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: '? y = authorName?.Length;'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: ？y=authorName?.Length;
- en: '```'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Sometimes you want to either assign a variable to a result or use an alternative
    value, such as `3` , if the variable is `null` . You do this using the null-coalescing
    operator, `??` , as shown in the following code:'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望将变量分配给结果，或者在变量为`null`时使用替代值，例如`3`。您可以使用空值合并运算符`??`来实现这一点，如下面的代码所示：
- en: '```cs'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // result will be 3 if authorName?.Length is null
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: // 如果authorName?.Length为null，则结果将为3
- en: int
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: result = authorName?.Length ?? 3
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: result = authorName?.Length ?? 3
- en: ;
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: Console.WriteLine(result);
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine(result);
- en: '```'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : Even if you enable nullable reference types, you should
    still check non-nullable parameters for `null` and throw an `ArgumentNullException`
    .'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：即使启用了可空引用类型，您仍应检查非可空参数是否为`null`并抛出`ArgumentNullException`。'
- en: Checking for null in method parameters
  id: totrans-1448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查方法参数中的null
- en: When defining methods with parameters, it is good practice to check for `null`
    values.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义带参数的方法时，最好检查`null`值。
- en: 'In earlier versions of C#, you would have to write `if` statements to check
    for `null` parameter values and then throw an `ArgumentNullException` for any
    parameter that is `null` , as shown in the following code:'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#的早期版本中，您将不得不编写`if`语句来检查`null`参数值，然后为任何`null`参数抛出`ArgumentNullException`，如下面的代码所示：
- en: '```cs'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: void
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Hire
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 雇佣
- en: (
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: （
- en: Person manager, Person employee
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 人经理，人员工
- en: )
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: '{'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (manager == null
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: （经理== null
- en: )
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: '{'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: throw
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出
- en: new
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 新
- en: ArgumentNullException(nameof
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: ArgumentNullException(nameof
- en: (manager));
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: （经理）;
- en: '}'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (employee == null
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: （员工== null
- en: )
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: '{'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: throw
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出
- en: new
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 新
- en: ArgumentNullException(nameof
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: ArgumentNullException(nameof
- en: (employee));
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: （员工）;
- en: '}'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '...'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'C# 11 might introduce a new `!!` suffix that does this for you, as shown in
    the following code:'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: C# 11可能会引入一个新的`!!`后缀，为您执行此操作，如下面的代码所示：
- en: '```cs'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: void
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Hire
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 雇佣
- en: (
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: Person manager!!, Person employee!!
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 人经理！！，人员工！！
- en: )
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '...'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `if` statement and throwing of the exception are done for you.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句和抛出异常已经为您完成。'
- en: Inheriting from classes
  id: totrans-1493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从类继承
- en: 'The `Person` type we created earlier derived (inherited) from `object` , the
    alias for `System.Object` . Now, we will create a subclass that inherits from
    `Person` :'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建的`Person`类型派生（继承）自`object`，即`System.Object`的别名。现在，我们将创建一个从`Person`继承的子类：
- en: In the `PacktLibrary` project, add a new class file named `Employee.cs` .
  id: totrans-1495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`Employee.cs`的新类文件。
- en: 'Modify its contents to define a class named `Employee` that derives from `Person`
    , as shown in the following code:'
  id: totrans-1496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改其内容以定义一个名为`Employee`的从`Person`派生的类，如下面的代码所示：
- en: '```cs'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System;
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: System;
- en: namespace
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: class
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Employee
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 员工
- en: ': Person'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: ：人
- en: '{'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '}'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to create an instance of the `Employee` class,
    as shown in the following code:'
  id: totrans-1510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句来创建`Employee`类的一个实例，如下面的代码所示：
- en: '```cs'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Employee john = new
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: Employee john = new
- en: ()
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Name = "John Jones"
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: Name = "John Jones"
- en: ','
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: DateOfBirth = new
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: DateOfBirth = new
- en: '(year: 1990'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: （年份：1990
- en: ', month: 7'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: ，月：7
- en: ', day: 28'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: ，日：28
- en: )
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '};'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: john.WriteToConsole();
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: john.WriteToConsole();
- en: '```'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: John Jones was born on a Saturday.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: John Jones出生于一个星期六。
- en: '```'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Note that the `Employee` class has inherited all the members of `Person` .
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Employee`类继承了`Person`的所有成员。
- en: Extending classes to add functionality
  id: totrans-1530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展类以添加功能
- en: Now, we will add some employee-specific members to extend the class.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一些特定于员工的成员以扩展该类。
- en: 'In `Employee.cs` , add statements to define two properties for an employee
    code and the date they were hired, as shown in the following code:'
  id: totrans-1532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Employee.cs`中，添加语句来定义员工代码和他们被雇佣的日期两个属性，如下面的代码所示：
- en: '```cs'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: string
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: '? EmployeeCode { get'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: '? EmployeeCode { get'
- en: ; set
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: ; set
- en: ; }
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: public
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: DateTime HireDate { get
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime HireDate { get
- en: ; set
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: ; set
- en: ; }
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: '```'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to set John''s employee code and hire date,
    as shown in the following code:'
  id: totrans-1544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句来设置John的员工代码和雇佣日期，如下面的代码所示：
- en: '```cs'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: john.EmployeeCode = "JJ001"
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: john.EmployeeCode = "JJ001"
- en: ;
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: john.HireDate = new
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: john.HireDate = new
- en: '(year: 2014'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: （年份：2014
- en: ', month: 11'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: ，月：11
- en: ', day: 23'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: ，日：23
- en: );
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: WriteLine($"
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{john.Name}'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: '{john.Name}'
- en: was hired on
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 被雇佣于
- en: '{john.HireDate:dd/MM/yy}'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: '{john.HireDate:dd/MM/yy}'
- en: '"'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '```'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: John Jones was hired on 23/11/14
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: John Jones于23/11/14被雇佣
- en: '```'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Hiding members
  id: totrans-1564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏成员
- en: 'So far, the `WriteToConsole` method is inherited from `Person` , and it only
    outputs the employee''s name and date of birth. We might want to change what this
    method does for an employee:'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`WriteToConsole`方法是从`Person`继承的，它只输出员工的姓名和出生日期。我们可能希望更改此方法对于员工的操作：
- en: 'In `Employee.cs` , add statements to redefine the `WriteToConsole` method,
    as shown highlighted in the following code:'
  id: totrans-1566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Employee.cs`中，添加语句来重新定义`WriteToConsole`方法，如下面的代码中所突出显示的那样：
- en: '```cs'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '**using**'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用**'
- en: '**static**'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态**'
- en: '**System.Console;**'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: '**System.Console;**'
- en: namespace
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: class
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Employee
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 员工
- en: ': Person'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: ：人
- en: '{'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: string
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: '? EmployeeCode { get'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: '? EmployeeCode { get'
- en: ; set
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: ; set
- en: ; }
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: public
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: DateTime HireDate { get
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime HireDate { get
- en: ; set
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: ; set
- en: ; }
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: ; }
- en: '**public**'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共**'
- en: '**void**'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: '**void**'
- en: '**WriteToConsole**'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: '**WriteToConsole**'
- en: '**()**'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: '**()**'
- en: '**{**'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**WriteLine(format:**'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: '**WriteLine（格式：**'
- en: '**"{0} was born on {1:dd/MM/yy} and hired on {2:dd/MM/yy}"**'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: '**"{0}出生于{1:dd/MM/yy}，并于{2:dd/MM/yy}被雇佣"**'
- en: '**,**'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: '**，**'
- en: '**arg0: Name,**'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: '**arg0：姓名，**'
- en: '**arg1: DateOfBirth,**'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 参数1：出生日期，
- en: '**arg2: HireDate);**'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: '**arg2：HireDate）;**'
- en: '**}**'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '}'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: John Jones was born on 28/07/90 and hired on 01/01/01
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: John Jones出生于28/07/90，于01/01/01被雇佣
- en: John Jones was hired on 23/11/14
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: John Jones于23/11/14被雇佣
- en: '```'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Your coding tool warns you that your method now hides the method from `Person`
    by drawing a squiggle under the method name, the **PROBLEMS** /**Error List**
    window includes more details, and the compiler will output the warning when you
    build and run the console application, as shown in *Figure 6.4* :'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 您的编码工具警告您，您的方法现在通过在方法名称下绘制一个波浪线来隐藏`Person`的方法，**PROBLEMS**/**Error List**窗口包含更多详细信息，当您构建和运行控制台应用程序时，编译器将输出警告，如*图6.4*所示：
- en: '![Graphical user interface, text, application, email Description automatically
    generated](img/Image00072.jpg)'
  id: totrans-1608
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件描述自动生成](img/Image00072.jpg)'
- en: 'Figure 6.4: Hidden method warning'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：隐藏方法警告
- en: 'As the warning describes, you can hide this message by applying the `new` keyword
    to the method, to indicate that you are deliberately replacing the old method,
    as shown highlighted in the following code:'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 如警告所述，您可以通过对方法应用`new`关键字来隐藏此消息，以表明您有意替换旧方法，如下面的代码中所突出显示的那样：
- en: '```cs'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: '**new**'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: '**new**'
- en: void
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: WriteToConsole
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: WriteToConsole
- en: ()
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '```'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Overriding members
  id: totrans-1618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖成员
- en: Rather than hiding a method, it is usually better to **override** it. You can
    only override if the base class chooses to allow overriding, by applying the `virtual`
    keyword to any methods that should allow overriding.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 与其隐藏一个方法，通常最好是**覆盖**它。只有在基类选择允许覆盖时，才能覆盖，方法是通过对应用`virtual`关键字到应允许覆盖的任何方法。
- en: 'Let''s see an example:'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: 'In `Program.cs` , add a statement to write the value of the `john` variable
    to the console using its `string` representation, as shown in the following code:'
  id: totrans-1621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一条语句，使用其`string`表示形式将`john`变量的值写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine(john.ToString());
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(john.ToString());
- en: '```'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note that the `ToString` method is inherited from `System.Object`
    , so the implementation returns the namespace and type name, as shown in the following
    output:'
  id: totrans-1625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意`ToString`方法是从`System.Object`继承的，因此实现返回命名空间和类型名称，如下面的输出所示：
- en: '```cs'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Packt.Shared.Employee
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared.Employee
- en: '```'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Person.cs` , override this behavior by adding a `ToString` method to output
    the name of the person as well as the type name, as shown in the following code:'
  id: totrans-1629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，通过添加一个`ToString`方法来覆盖这种行为，以输出人的姓名以及类型名称，如下面的代码所示：
- en: '```cs'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // overridden methods
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: // 覆盖的方法
- en: public
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: override
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖
- en: string
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: ToString
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: ToString
- en: ()
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: $"
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: $"
- en: '{Name}'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: '{Name}'
- en: is a
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个
- en: '{'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: base
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 基类
- en: .ToString()}
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: .ToString()}
- en: '"'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: ;
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `base` keyword allows a subclass to access members of its superclass; that
    is, the **base class** that it inherits or derives from.
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: '`base`关键字允许子类访问其超类的成员；即，它继承或派生自的**基类**。'
- en: 'Run the code and view the result. Now, when the `ToString` method is called,
    it outputs the person''s name, as well as returning the base class''s implementation
    of `ToString` , as shown in the following output:'
  id: totrans-1650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果。现在，当调用`ToString`方法时，它会输出人的姓名，并返回基类的`ToString`实现，如下面的输出所示：
- en: '```cs'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: John Jones is a Packt.Shared.Employee
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: John Jones是Packt.Shared.Employee
- en: '```'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : Many real-world APIs, for example, Microsoft''s Entity
    Framework Core, Castle''s DynamicProxy, and Episerver''s content models, require
    the properties that you define in your classes to be marked as `virtual` so that
    they can be overridden. Carefully decide which of your method and property members
    should be marked as `virtual` .'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：许多现实世界的API，例如Microsoft的Entity Framework Core，Castle的DynamicProxy和Episerver的内容模型，要求您在类中定义的属性标记为`virtual`，以便它们可以被覆盖。仔细决定哪些方法和属性成员应标记为`virtual`。'
- en: Inheriting from abstract classes
  id: totrans-1655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从抽象类继承
- en: Earlier in this chapter, you learned about interfaces that can define a set
    of members that a type must have to meet a basic level of functionality. These
    are very useful, but their main limitation is that until C# 8 they could not provide
    any implementation of their own.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，您了解了可以定义一组成员的接口，以满足基本功能的要求。这些非常有用，但它们的主要限制是，在C# 8之前，它们不能提供任何自己的实现。
- en: This is a particular problem if you still need to create class libraries that
    will work with .NET Framework and other platforms that do not support .NET Standard
    2.1.
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特殊的问题，如果您仍然需要创建将与.NET Framework和其他不支持.NET Standard 2.1的平台一起使用的类库。
- en: In those earlier platforms, you could use abstract classes as a sort of halfway
    house between a pure interface and a fully implemented class.
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的平台上，您可以使用抽象类作为纯接口和完全实现的类之间的一种中间状态。
- en: When a class is marked as `abstract` , this means that it cannot be instantiated
    because you are indicating that the class is not complete. It needs more implementation
    before it can be instantiated.
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类被标记为`abstract`时，这意味着它不能被实例化，因为您表明该类不完整。在可以实例化之前，它需要更多的实现。
- en: For example, the `System.IO.Stream` class is abstract because it implements
    common functionality that all streams would need but is not complete, so you cannot
    instantiate it using `new Stream()` .
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`System.IO.Stream`类是抽象的，因为它实现了所有流都需要的常见功能，但它并不完整，因此您不能使用`new Stream()`来实例化它。
- en: 'Let''s compare the two types of interface and two types of class, as shown
    in the following code:'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较两种类型的接口和两种类型的类，如下面的代码所示：
- en: '```cs'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: interface
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 接口
- en: INoImplementation
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: INoImplementation
- en: // C# 1.0 and later
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: // C# 1.0及更高版本
- en: '{'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: void
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Alpha
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: Alpha
- en: ()
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: ; // must be implemented by derived type
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 必须由派生类型实现
- en: '}'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: interface
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 接口
- en: ISomeImplementation
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: ISomeImplementation
- en: // C# 8.0 and later
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: // C# 8.0及更高版本
- en: '{'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: void
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Alpha
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: Alpha
- en: ()
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: ; // must be implemented by derived type
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 必须由派生类型实现
- en: void
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Beta
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: Beta
- en: ()
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // default implementation; can be overridden
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: // 默认实现；可以被覆盖
- en: '}'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: abstract
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象
- en: class
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: PartiallyImplemented
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 部分实现
- en: // C# 1.0 and later
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: // C# 1.0及更高版本
- en: '{'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: abstract
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象
- en: void
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Gamma
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: Gamma
- en: ()
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: ; // must be implemented by derived type
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 必须由派生类型实现
- en: public
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: virtual
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟
- en: void
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Delta
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: Delta
- en: ()
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: // can be overridden
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: // 可以被覆盖
- en: '{'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // implementation
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: // 实现
- en: '}'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: class
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: FullyImplemented
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: FullyImplemented
- en: ': PartiallyImplemented'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: ': 部分实现'
- en: ', ISomeImplementation'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: ', ISomeImplementation'
- en: '{'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: void
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Alpha
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 阿尔法
- en: ()
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // implementation
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: // 实现
- en: '}'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: override
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖
- en: void
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Gamma
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 伽玛
- en: ()
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // implementation
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: // 实现
- en: '}'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // you can only instantiate the fully implemented class
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: // 您只能实例化完全实现的类
- en: FullyImplemented a = new
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: FullyImplemented a = 新的
- en: ();
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: // all the other types give compile errors
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: // 所有其他类型都会导致编译错误
- en: PartiallyImplemented b = new
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 部分实现b = 新的
- en: (); // compile error!
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: (); // 编译错误！
- en: ISomeImplementation c = new
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: ISomeImplementation c = 新的
- en: (); // compile error!
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: (); // 编译错误！
- en: INoImplementation d = new
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: INoImplementation d = 新的
- en: (); // compile error!
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: (); // 编译错误！
- en: '```'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Preventing inheritance and overriding
  id: totrans-1744
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止继承和覆盖
- en: 'You can prevent another developer from inheriting from your class by applying
    the `sealed` keyword to its definition. No one can inherit from Scrooge McDuck,
    as shown in the following code:'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在其定义中应用 `sealed` 关键字来防止另一个开发人员从您的类继承。如下面的代码所示，没有人可以从Scrooge McDuck继承：
- en: '```cs'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: sealed
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 封闭
- en: class
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: ScroogeMcDuck
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: ScroogeMcDuck
- en: '{'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '}'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: An example of `sealed` in .NET is the `string` class. Microsoft has implemented
    some extreme optimizations inside the `string` class that could be negatively
    affected by your inheritance, so Microsoft prevents that.
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中`sealed`的一个例子是`string`类。微软在`string`类内部实现了一些极端的优化，可能会受到您的继承的负面影响，因此微软阻止了这种情况。
- en: 'You can prevent someone from further overriding a `virtual` method in your
    class by applying the `sealed` keyword to the method. No one can change the way
    Lady Gaga sings, as shown in the following code:'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在方法中应用 `sealed` 关键字防止其他人进一步覆盖 `virtual` 方法。没有人可以改变Lady Gaga唱歌的方式，如下面的代码所示：
- en: '```cs'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: System.Console;
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console;
- en: namespace
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: class
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Singer
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 歌手
- en: '{'
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // virtual allows this method to be overridden
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: // 虚拟允许此方法被覆盖
- en: public
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: virtual
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟
- en: void
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Sing
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: 唱歌
- en: ()
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("Singing..."
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("唱歌..."
- en: );
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: class
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: LadyGaga
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: LadyGaga
- en: ': Singer'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: ': 歌手'
- en: '{'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // sealed prevents overriding the method in subclasses
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: // 封闭防止在子类中覆盖该方法
- en: public
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: sealed
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 封闭
- en: override
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖
- en: void
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Sing
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 唱歌
- en: ()
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("Singing with style..."
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("以风格唱歌..."
- en: );
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You can only seal an overridden method.
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能封闭一个被覆盖的方法。
- en: Understanding polymorphism
  id: totrans-1797
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解多态性
- en: You have now seen two ways to change the behavior of an inherited method. We
    can *hide* it using the `new` keyword (known as **non-polymorphic inheritance**
    ), or we can *override* it (known as **polymorphic inheritance** ).
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到了两种改变继承方法行为的方式。我们可以使用 `new` 关键字*隐藏*它（称为**非多态继承**），或者我们可以*覆盖*它（称为**多态继承**）。
- en: Both ways can access members of the base or superclass by using the `base` keyword,
    so what is the difference?
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方式都可以使用 `base` 关键字访问基类或超类的成员，那么有什么区别呢？
- en: It all depends on the type of variable holding a reference to the object. For
    example, a variable of the `Person` type can hold a reference to a `Person` class,
    or any type that derives from `Person` .
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全取决于持有对象引用的变量的类型。例如，`Person` 类型的变量可以持有对 `Person` 类的引用，或者从 `Person` 派生的任何类型的引用。
- en: 'Let''s see how this could affect your code:'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这如何影响您的代码：
- en: 'In `Employee.cs` , add statements to override the `ToString` method so it writes
    the employee''s name and code to the console, as shown in the following code:'
  id: totrans-1802
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Employee.cs` 中，添加语句覆盖 `ToString` 方法，以便将员工的姓名和代码写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: override
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖
- en: string
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: ToString
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: ToString
- en: ()
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: $"
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: $"
- en: '{Name}'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: '{Name}'
- en: '''s code is'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: 的代码是
- en: '{EmployeeCode}'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: '{EmployeeCode}'
- en: '"'
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: ;
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , write statements to create a new employee named Alice, store
    it in a variable of type `Person` , and call both variables'' `WriteToConsole`
    and `ToString` methods, as shown in the following code:'
  id: totrans-1819
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，编写语句创建一个名为Alice的新员工，将其存储在 `Person` 类型的变量中，并调用两个变量的 `WriteToConsole`
    和 `ToString` 方法，如下面的代码所示：
- en: '```cs'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Employee aliceInEmployee = new
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: 雇员aliceInEmployee = 新的
- en: ()
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{ Name = "Alice"'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 名字 = "爱丽丝"'
- en: ', EmployeeCode = "AA123"'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: ', EmployeeCode = "AA123"'
- en: '};'
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: Person aliceInPerson = aliceInEmployee;
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: Person aliceInPerson = aliceInEmployee;
- en: aliceInEmployee.WriteToConsole();
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: aliceInEmployee.WriteToConsole();
- en: aliceInPerson.WriteToConsole();
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: aliceInPerson.WriteToConsole();
- en: WriteLine(aliceInEmployee.ToString());
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(aliceInEmployee.ToString());
- en: WriteLine(aliceInPerson.ToString());
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(aliceInPerson.ToString());
- en: '```'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1832
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Alice was born on 01/01/01 and hired on 01/01/01
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝是在01/01/01出生的，雇佣于01/01/01
- en: Alice was born on a Monday
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝是在星期一出生的
- en: Alice's code is AA123
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: Alice的代码是AA123
- en: Alice's code is AA123
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: Alice的代码是AA123
- en: '```'
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: When a method is hidden with `new` , the compiler is not smart enough to know
    that the object is an `Employee` , so it calls the `WriteToConsole` method in
    `Person` .
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法被 `new` 隐藏时，编译器不够聪明，不知道对象是 `Employee`，所以调用 `Person` 中的 `WriteToConsole`
    方法。
- en: When a method is overridden with `virtual` and `override` , the compiler is
    smart enough to know that although the variable is declared as a `Person` class,
    the object itself is an `Employee` class and, therefore, the `Employee` implementation
    of `ToString` is called.
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法被 `virtual` 和 `override` 覆盖时，编译器足够聪明，知道虽然变量声明为 `Person` 类，但对象本身是 `Employee`
    类，因此调用 `Employee` 的 `ToString` 实现。
- en: 'The member modifiers and the effect they have are summarized in the following
    table:'
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: 成员修饰符及其影响总结在下表中：
- en: '| Variable type | Member modifier | Method executed | In class |'
  id: totrans-1842
  prefs: []
  type: TYPE_TB
  zh: '| 变量类型 | 成员修饰符 | 执行的方法 | 在类中 |'
- en: '| `Person` |  | `WriteToConsole` | `Person` |'
  id: totrans-1843
  prefs: []
  type: TYPE_TB
  zh: '| `人` |  | `写入控制台` | `人` |'
- en: '| `Employee` | `new` | `WriteToConsole` | `Employee` |'
  id: totrans-1844
  prefs: []
  type: TYPE_TB
  zh: '| `雇员` | `新` | `WriteToConsole` | `雇员` |'
- en: '| `Person` | `virtual` | `ToString` | `Employee` |'
  id: totrans-1845
  prefs: []
  type: TYPE_TB
  zh: '| `人` | `虚拟` | `ToString` | `雇员` |'
- en: '| `Employee` | `override` | `ToString` | `Employee` |'
  id: totrans-1846
  prefs: []
  type: TYPE_TB
  zh: '| `雇员` | `覆盖` | `ToString` | `雇员` |'
- en: In my opinion, polymorphism is academic to most programmers. If you get the
    concept, that's cool; but, if not, I suggest that you don't worry about it. Some
    people like to make others feel inferior by saying understanding polymorphism
    is important for all C# programmers to learn, but IMHO it's not.
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，多态对大多数程序员来说是学术性的。如果你理解这个概念，那很好；但是，如果不理解，我建议你不要担心。有些人喜欢通过说理解多态对所有C#程序员来说都很重要来让其他人感到自卑，但在我看来并不是这样。
- en: You can have a successful career with C# and never need to be able to explain
    polymorphism, just as a racing car driver doesn't need to be able to explain the
    engineering behind fuel injection.
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在C#中有一个成功的职业，而不需要能够解释多态性，就像赛车手不需要能够解释燃油喷射背后的工程一样。
- en: '**Good Practice** : You should use `virtual` and `override` rather than `new`
    to change the implementation of an inherited method whenever possible.'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的实践**：您应该尽可能使用`virtual`和`override`而不是`new`来更改继承方法的实现。'
- en: Casting within inheritance hierarchies
  id: totrans-1850
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在继承层次结构内进行转换
- en: Casting between types is subtly different from converting between types. Casting
    is between similar types, like between a 16-bit integer and a 32-bit integer,
    or between a superclass and one of its subclasses. Converting is between dissimilar
    types, such as between text and a number.
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 类型之间的转换与类型之间的转换略有不同。转换是在相似类型之间进行的，比如在16位整数和32位整数之间，或者在超类和其子类之间。转换是在不同类型之间进行的，比如在文本和数字之间。
- en: Implicit casting
  id: totrans-1852
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式转换
- en: In the previous example, you saw how an instance of a derived type can be stored
    in a variable of its base type (or its base's base type, and so on). When we do
    this, it is called **implicit casting** .
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您看到了如何将派生类型的实例存储在其基类型的变量中（或其基类型的基类型，依此类推）。当我们这样做时，它被称为**隐式转换**。
- en: Explicit casting
  id: totrans-1854
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式转换
- en: 'Going the other way is an explicit cast, and you must use parentheses around
    the type you want to cast into as a prefix to do it:'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是显式转换，您必须使用括号将要转换为的类型作为前缀来执行：
- en: 'In `Program.cs` , add a statement to assign the `aliceInPerson` variable to
    a new `Employee` variable, as shown in the following code:'
  id: totrans-1856
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一个语句将`aliceInPerson`变量赋值给一个新的`Employee`变量，如下面的代码所示：
- en: '```cs'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Employee explicitAlice = aliceInPerson;
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: Employee explicitAlice = aliceInPerson;
- en: '```'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Your coding tool displays a red squiggle and a compile error, as shown in *Figure
    6.5* :![Graphical user interface, text, application, email, website Description
    automatically generated](img/Image00073.jpg)
  id: totrans-1860
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的编码工具显示了一个红色的波浪线和一个编译错误，如*图6.5*所示：![图形用户界面，文本，应用程序，电子邮件，网站描述自动生成](img/Image00073.jpg)
- en: 'Figure 6.5: A missing explicit cast compile error'
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：缺少显式转换编译错误
- en: 'Change the statement to prefix the assigned variable named with a cast to the
    `Employee` type, as shown in the following code:'
  id: totrans-1862
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改语句，将分配的变量名前缀为`Employee`类型的转换，如下面的代码所示：
- en: '```cs'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Employee explicitAlice = (Employee)aliceInPerson;
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: Employee explicitAlice = (Employee)aliceInPerson;
- en: '```'
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Avoiding casting exceptions
  id: totrans-1866
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免转换异常
- en: The compiler is now happy; but, because `aliceInPerson` might be a different
    derived type, like `Student` instead of `Employee` , we need to be careful. In
    a real application with more complex code, the current value of this variable
    could have been set to a `Student` instance, and then this statement would throw
    an `InvalidCastException` error.
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译器很高兴了；但是，因为`aliceInPerson`可能是一个不同的派生类型，比如`学生`而不是`员工`，我们需要小心。在一个更复杂的代码的真实应用中，这个变量的当前值可能已经被设置为`学生`实例，然后这个语句会抛出`InvalidCastException`错误。
- en: 'We can handle this by writing a `try` statement, but there is a better way.
    We can check the type of an object using the `is` keyword:'
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编写`try`语句来处理这个问题，但有一个更好的方法。我们可以使用`is`关键字来检查对象的类型：
- en: 'Wrap the explicit cast statement in an `if` statement, as shown highlighted
    in the following code:'
  id: totrans-1869
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将显式转换语句包装在`if`语句中，如下面的代码中所突出显示的那样：
- en: '```cs'
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '**if**'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: '**if**'
- en: '**(aliceInPerson**'
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: '**(aliceInPerson**'
- en: '**is**'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: '**是**'
- en: '**Employee)**'
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: '**员工)**'
- en: '**{**'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**WriteLine(**'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: '**WriteLine(**'
- en: '**$"**'
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: '**$"**'
- en: '**{**'
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**nameof**'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: '**nameof**'
- en: '**(aliceInPerson)}**'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: '**(aliceInPerson)}**'
- en: '**IS an Employee"**'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: '**是员工"**'
- en: '**);**'
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: '**);**'
- en: Employee explicitAlice = (Employee)aliceInPerson;
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: Employee explicitAlice = (Employee)aliceInPerson;
- en: '**// safely do something with explicitAlice**'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: '**// 安全地对explicitAlice进行一些操作**'
- en: '**}**'
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '```'
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1887
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '```cs'
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: aliceInPerson IS an Employee
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: aliceInPerson是员工
- en: '```'
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'You can simplify the code further using a declaration pattern and this will
    avoid needing to perform an explicit cast, as shown in the following code:'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以进一步简化代码，使用声明模式，这将避免需要执行显式转换，如下面的代码所示：
- en: '```cs'
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: if
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: (aliceInPerson is
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: (aliceInPerson is
- en: Employee explicitAlice)
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: Employee explicitAlice)
- en: '{'
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{'
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: '{**'
- en: nameof
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
  zh: nameof
- en: (aliceInPerson)}
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: (aliceInPerson)}
- en: IS an Employee"
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 是员工"
- en: );
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: // safely do something with explicitAlice
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: // 安全地对explicitAlice进行一些操作
- en: '}'
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Alternatively, you can use the `as` keyword to cast. Instead of throwing an
    exception, the `as` keyword returns `null` if the type cannot be cast.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`as`关键字进行转换。与抛出异常不同，`as`关键字在无法转换类型时返回`null`。
- en: 'In `Main` , add the statements to cast Alice using the `as` keyword and then
    check whether the return value is not null, as shown in the following code:'
  id: totrans-1907
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`中，添加使用`as`关键字对Alice进行转换然后检查返回值是否不为空的语句，如下面的代码所示：
- en: '```cs'
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Employee? aliceAsEmployee = aliceInPerson as
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: Employee? aliceAsEmployee = aliceInPerson as
- en: Employee; // could be null
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: 员工；//可能为空
- en: if
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: (aliceAsEmployee != null
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
  zh: (aliceAsEmployee != null
- en: )
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{'
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: nameof
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: nameof
- en: (aliceInPerson)}
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: (aliceInPerson)}
- en: AS an Employee"
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: 作为员工"
- en: );
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: // safely do something with aliceAsEmployee
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
  zh: // 安全地对aliceAsEmployee进行一些操作
- en: '}'
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Since accessing a member of a `null` variable will throw a `NullReferenceException`
    error, you should always check for `null` before using the result.
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: 由于访问`null`变量的成员将抛出`NullReferenceException`错误，因此在使用结果之前，您应该始终检查`null`。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1925
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '```cs'
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: aliceInPerson AS an Employee
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: aliceInPerson作为员工
- en: '```'
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: What if you want to execute a block of statements when Alice is not an employee?
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Alice不是员工时执行一系列语句怎么办？
- en: 'In the past, you would have had to use the `!` (not) operator, as shown in
    the following code:'
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，您将不得不使用`！`（非）运算符，如下面的代码所示：
- en: '```cs'
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: if
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (!(aliceInPerson is
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: （！（aliceInPerson是
- en: Employee))
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 员工）
- en: '```'
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'With C# 9 and later, you can use the `not` keyword, as shown in the following
    code:'
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C# 9及更高版本，您可以使用`not`关键字，如下面的代码所示：
- en: '```cs'
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: if
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (aliceInPerson is
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: （aliceInPerson是
- en: not
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: 不
- en: Employee)
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: 员工）
- en: '```'
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : Use the `is` and `as` keywords to avoid throwing exceptions
    when casting between derived types. If you don''t do this, you must write `try`
    -`catch` statements for `InvalidCastException` .'
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：使用`is`和`as`关键字在派生类型之间进行强制转换时避免抛出异常。如果不这样做，您必须为`InvalidCastException`编写`try`-`catch`语句。'
- en: Inheriting and extending .NET types
  id: totrans-1944
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和扩展.NET类型
- en: .NET has prebuilt class libraries containing hundreds of thousands of types.
    Rather than creating your own completely new types, you can often get a head start
    by deriving from one of Microsoft's types to inherit some or all of its behavior
    and then overriding or extending it.
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: .NET有预构建的类库，包含数十万种类型。您通常可以通过从Microsoft的类型中派生来继承其部分或全部行为，然后重写或扩展它，而不是创建自己完全新的类型。
- en: Inheriting exceptions
  id: totrans-1946
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承异常
- en: 'As an example of inheritance, we will derive a new type of exception:'
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: 作为继承的一个例子，我们将派生一个新的异常类型：
- en: In the `PacktLibrary` project, add a new class file named `PersonException.cs`
    .
  id: totrans-1948
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`PersonException.cs`的新类文件。
- en: 'Modify the contents of the file to define a class named `PersonException` with
    three constructors, as shown in the following code:'
  id: totrans-1949
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改文件的内容，定义一个名为`PersonException`的类，有三个构造函数，如下面的代码所示：
- en: '```cs'
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: namespace
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: class
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: PersonException
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: PersonException
- en: ': Exception'
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: ：异常
- en: '{'
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: PersonException
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: PersonException
- en: '() :'
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
  zh: （）：
- en: base
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: 基础
- en: ()
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
  zh: （）
- en: '{ }'
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
  zh: '{ }'
- en: public
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: PersonException
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
  zh: PersonException
- en: (
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: （
- en: string
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: message
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: 消息
- en: ') :'
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: )：
- en: base
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 基础
- en: (
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
  zh: （
- en: message
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: 消息
- en: )
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: '{ }'
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
  zh: '{ }'
- en: public
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: PersonException
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: PersonException
- en: (
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: message, Exception innerException
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
  zh: 消息，异常innerException
- en: )
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: ':'
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: ：
- en: base
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: 基础
- en: (
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: （
- en: message, innerException
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
  zh: 消息，innerException
- en: )
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: '{ }'
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
  zh: '{ }'
- en: '}'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Unlike ordinary methods, constructors are not inherited, so we must explicitly
    declare and explicitly call the base constructor implementations in `System.Exception`
    to make them available to programmers who might want to use those constructors
    with our custom exception.
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通方法不同，构造函数不会被继承，因此我们必须显式声明并显式调用`System.Exception`中的基础构造函数实现，以使它们对可能想要使用我们自定义异常的程序员可用。
- en: 'In `Person.cs` , add statements to define a method that throws an exception
    if a date/time parameter is earlier than a person''s date of birth, as shown in
    the following code:'
  id: totrans-1991
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句来定义一个方法，如果日期/时间参数早于一个人的出生日期，则抛出异常，如下面的代码所示：
- en: '```cs'
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: void
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: TimeTravel
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
  zh: 时间旅行
- en: (
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: （
- en: DateTime
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
  zh: 日期时间
- en: when
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 当
- en: )
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: '{'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (when
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: （当
- en: <= DateOfBirth)
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
  zh: <= 出生日期)
- en: '{'
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: throw
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出
- en: new
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: 新
- en: PersonException("If you travel back in time to a date earlier than your own
    birth, then the universe will explode!"
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
  zh: PersonException("如果你回到比自己出生日期更早的日期，那么宇宙将爆炸！"
- en: );
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: 其他
- en: '{'
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"Welcome to
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（“欢迎来到
- en: '{'
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: when
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: 当
- en: :yyyy}
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
  zh: :yyyy}
- en: '!"'
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: ！”
- en: );
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to test what happens when employee John Jones
    tries to time travel too far back, as shown in the following code:'
  id: totrans-2021
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句来测试当员工John Jones试图时间旅行太久时会发生什么，如下面的代码所示：
- en: '```cs'
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: try
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试
- en: '{'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: john.TimeTravel(when
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: john.TimeTravel(when
- en: ': new'
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: ：新
- en: (1999
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: （1999
- en: ', 12'
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
  zh: ，12
- en: ', 31'
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: ，31
- en: ));
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: john.TimeTravel(when
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: john.TimeTravel(when
- en: ': new'
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
  zh: ：新
- en: (1950
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: （1950
- en: ', 12'
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
  zh: ，12
- en: ', 25'
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
  zh: ，25
- en: ));
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: catch (PersonException ex)
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获（PersonException ex）
- en: '{'
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine(ex.Message);
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（ex.Message）;
- en: '}'
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-2043
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Welcome to 1999!
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到1999年！
- en: If you travel back in time to a date earlier than your own birth, then the universe
    will explode!
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到比自己出生日期更早的日期，那么宇宙将爆炸！
- en: '```'
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : When defining your own exceptions, give them the same three
    constructors that explicitly call the built-in ones.'
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在定义自己的异常时，给它们相同的三个构造函数，显式调用内置的构造函数。'
- en: Extending types when you can't inherit
  id: totrans-2049
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在无法继承时扩展类型
- en: Earlier, we saw how the `sealed` modifier can be used to prevent inheritance.
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到`sealed`修饰符可以用来防止继承。
- en: Microsoft has applied the `sealed` keyword to the `System.String` class so that
    no one can inherit and potentially break the behavior of strings.
  id: totrans-2051
  prefs: []
  type: TYPE_NORMAL
  zh: 微软已经对`System.String`类应用了`sealed`关键字，以防止任何人继承并潜在地破坏字符串的行为。
- en: Can we still add new methods to strings? Yes, if we use a language feature named
    **extension methods** , which was introduced with C# 3.0.
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能给字符串添加新的方法吗？是的，如果我们使用一种名为**扩展方法**的语言特性，这是在C# 3.0中引入的。
- en: Using static methods to reuse functionality
  id: totrans-2053
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用静态方法重用功能
- en: Since the first version of C#, we've been able to create `static` methods to
    reuse functionality, such as the ability to validate that a `string` contains
    an email address. The implementation will use a regular expression that you will
    learn more about in *Chapter 8* , *Working with Common .NET Types* .
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
  zh: 自C#的第一个版本以来，我们就能够创建`static`方法来重用功能，比如验证一个`string`是否包含电子邮件地址的能力。实现将使用一个正则表达式，您将在*第8章*
    *使用常见的.NET类型*中了解更多。
- en: 'Let''s write some code:'
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码：
- en: 'In the `PacktLibrary` project, add a new class named `StringExtensions` , as
    shown in the following code, and note the following:'
  id: totrans-2056
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`StringExtensions`的新类，如下面的代码所示，并注意以下内容：
- en: The class imports a namespace for handling regular expressions.
  id: totrans-2057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类导入了一个处理正则表达式的命名空间。
- en: The `IsValidEmail` method is `static` and it uses the `Regex` type to check
    for matches against a simple email pattern that looks for valid characters before
    and after the `@` symbol.
  id: totrans-2058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsValidEmail`方法是`static`的，它使用`Regex`类型来检查与一个简单的电子邮件模式的匹配，该模式在`@`符号之前和之后寻找有效字符。'
- en: '```cs'
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System.Text.RegularExpressions;
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
  zh: System.Text.RegularExpressions;
- en: namespace
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: class
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: StringExtensions
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
  zh: StringExtensions
- en: '{'
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: static
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: bool
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔
- en: IsValidEmail
  id: totrans-2072
  prefs: []
  type: TYPE_NORMAL
  zh: IsValidEmail
- en: (
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: input
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
  zh: 输入
- en: )
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // use simple regular expression to check
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用简单的正则表达式进行检查
- en: // that the input string is a valid email
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
  zh: // 输入字符串是有效的电子邮件
- en: return
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: Regex.IsMatch(input,
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: Regex.IsMatch(input，
- en: '@"[a-zA-Z0-9\.-_]+@[a-zA-Z0-9\.-_]+"'
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
  zh: '@"[a-zA-Z0-9\.-_]+@[a-zA-Z0-9\.-_]+"'
- en: );
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-2085
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to validate two examples of email addresses,
    as shown in the following code:'
  id: totrans-2087
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以验证两个示例的电子邮件地址，如下面的代码所示：
- en: '```cs'
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: email1 = "pamela@test.com"
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: email1 = "pamela@test.com"
- en: ;
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: string
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: email2 = "ian&test.com"
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
  zh: email2 = "ian&test.com"
- en: ;
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: 'WriteLine("{0} is a valid e-mail address: {1}"'
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("{0}是一个有效的电子邮件地址：{1}"
- en: ','
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg0: email1,'
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
  zh: arg0：email1，
- en: 'arg1: StringExtensions.IsValidEmail(email1));'
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: arg1：StringExtensions.IsValidEmail(email1));
- en: 'WriteLine("{0} is a valid e-mail address: {1}"'
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("{0}是一个有效的电子邮件地址：{1}"
- en: ','
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg0: email2,'
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: arg0：email2，
- en: 'arg1: StringExtensions.IsValidEmail(email2));'
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: arg1：StringExtensions.IsValidEmail(email2));
- en: '```'
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-2104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'pamela@test.com is a valid e-mail address: True'
  id: totrans-2106
  prefs: []
  type: TYPE_NORMAL
  zh: pamela@test.com是一个有效的电子邮件地址：True
- en: 'ian&test.com is a valid e-mail address: False'
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: ian&test.com是一个有效的电子邮件地址：False
- en: '```'
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This works, but extension methods can reduce the amount of code we must type
    and simplify the usage of this function.
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是有效的，但扩展方法可以减少我们必须键入的代码量，并简化此函数的使用。
- en: Using extension methods to reuse functionality
  id: totrans-2110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用扩展方法重用功能
- en: 'It is easy to make `static` methods into extension methods:'
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: 将`static`方法转换为扩展方法很容易：
- en: 'In `StringExtensions.cs` , add the `static` modifier before the class, and
    add the `this` modifier before the `string` type, as highlighted in the following
    code:'
  id: totrans-2112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StringExtensions.cs`中，在类之前添加`static`修饰符，并在`string`类型之前添加`this`修饰符，如下面的代码所示：
- en: '```cs'
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: '**static**'
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态**'
- en: class
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: StringExtensions
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
  zh: StringExtensions
- en: '{'
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: static
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: bool
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔
- en: IsValidEmail
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
  zh: IsValidEmail
- en: (
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: '**this**'
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
  zh: '**this**'
- en: string
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: input
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
  zh: 输入
- en: )
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '```'
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: These two changes tell the compiler that it should treat the method as one that
    extends the `string` type.
  id: totrans-2130
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个更改告诉编译器应该将该方法视为扩展`string`类型的方法。
- en: 'In `Program.cs` , add statements to use the extension method for `string` values
    that need to be checked for valid email addresses, as shown in the following code:'
  id: totrans-2131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以使用`string`值的扩展方法，这些值需要检查是否为有效的电子邮件地址，如下面的代码所示：
- en: '```cs'
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'WriteLine("{0} is a valid e-mail address: {1}"'
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("{0}是一个有效的电子邮件地址：{1}"
- en: ','
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg0: email1,'
  id: totrans-2135
  prefs: []
  type: TYPE_NORMAL
  zh: arg0：email1，
- en: 'arg1: email1.IsValidEmail());'
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
  zh: arg1：email1.IsValidEmail());
- en: 'WriteLine("{0} is a valid e-mail address: {1}"'
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("{0}是一个有效的电子邮件地址：{1}"
- en: ','
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg0: email2,'
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
  zh: arg0：email2，
- en: 'arg1: email2.IsValidEmail());'
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
  zh: arg1：email2.IsValidEmail());
- en: '```'
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Note the subtle simplification in the syntax for calling the `IsValidEmail`
    method. The older, longer syntax still works too.
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意调用`IsValidEmail`方法的语法上的微妙简化。旧的、更长的语法仍然有效。
- en: The `IsValidEmail` extension method now appears to be a method just like all
    the actual instance methods of the `string` type, such as `IsNormalized` and `Insert`
    , as shown in *Figure 6.6* :![Graphical user interface, text, application Description
    automatically generated](img/Image00074.jpg)
  id: totrans-2143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IsValidEmail`扩展方法现在看起来就像`string`类型的所有实际实例方法一样，例如`IsNormalized`和`Insert`，如*图6.6*所示：![图形用户界面，文本，应用程序描述自动生成](img/Image00074.jpg)'
- en: 'Figure 6.6: Extension methods appear in IntelliSense alongside instance methods'
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：扩展方法出现在IntelliSense中，与实例方法并列
- en: Run the code and view the result, which will be the same as before.
  id: totrans-2145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，结果将与以前相同。
- en: '**Good Practice** : Extension methods cannot replace or override existing instance
    methods. You cannot, for example, redefine the `Insert` method. The extension
    method will appear as an overload in IntelliSense, but an instance method will
    be called in preference to an extension method with the same name and signature.'
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：扩展方法不能替换或覆盖现有的实例方法。例如，您不能重新定义`Insert`方法。扩展方法将出现为IntelliSense中的重载，但实例方法将优先于具有相同名称和签名的扩展方法。'
- en: Although extension methods might not seem to give a big benefit, in *Chapter
    11* , *Querying and Manipulating Data Using LINQ* , you will see some extremely
    powerful uses of extension methods.
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管扩展方法可能看起来并没有带来很大的好处，在*第11章*，*使用LINQ查询和操作数据*中，您将看到一些极其强大的扩展方法的用法。
- en: Using an analyzer to write better code
  id: totrans-2148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分析器编写更好的代码
- en: .NET analyzers find potential issues and suggest fixes for them. **StyleCop**
    is a commonly used analyzer for helping you write better C# code.
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
  zh: .NET分析器会发现潜在问题并为其提供修复建议。**StyleCop**是一个常用的分析器，可帮助您编写更好的C#代码。
- en: 'Let''s see it in action, advising how to improve the code in the project template
    for a console app when targeting .NET 5.0 so that the console app already has
    a `Program` class with a `Main` method:'
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的作用，建议如何改进针对.NET 5.0的控制台应用程序的项目模板，以便控制台应用程序已经具有`Program`类和`Main`方法：
- en: 'Use your preferred code editor to add a console app project, as defined in
    the following list:'
  id: totrans-2151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器添加控制台应用程序项目，如下列表所示：
- en: 'Project template: **Console Application** / `console -f net5.0`'
  id: totrans-2152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console -f net5.0`
- en: 'Workspace/solution file and folder: `Chapter06`'
  id: totrans-2153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter06`
- en: 'Project file and folder: `CodeAnalyzing`'
  id: totrans-2154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`CodeAnalyzing`
- en: 'Target framework: **.NET 5.0 (Current)**'
  id: totrans-2155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标框架：**.NET 5.0 (当前)**
- en: In the `CodeAnalyzing` project, add a package reference for `StyleCop.Analyzers`
    .
  id: totrans-2156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CodeAnalyzing`项目中，添加一个`StyleCop.Analyzers`的包引用。
- en: Add a JSON file to your project named `stylecop.json` for controlling StyleCop
    settings.
  id: totrans-2157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目添加一个名为`stylecop.json`的JSON文件，用于控制StyleCop设置。
- en: 'Modify its contents, as shown in the following markup:'
  id: totrans-2158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改其内容，如下标记所示：
- en: '```cs'
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '{'
  id: totrans-2160
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"$schema"'
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: '"$schema"'
- en: ': "https://raw.githubusercontent.com/DotNetAnalyzers/StyleCopAnalyzers/master/StyleCop.Analyzers/StyleCop.Analyzers/Settings/stylecop.schema.json"'
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
  zh: ': "https://raw.githubusercontent.com/DotNetAnalyzers/StyleCopAnalyzers/master/StyleCop.Analyzers/StyleCop.Analyzers/Settings/stylecop.schema.json"'
- en: ','
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: '"settings"'
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
  zh: '"settings"'
- en: ': {'
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: ': {'
- en: '}'
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `$schema` entry enables IntelliSense while editing the `stylecop.json` file
    in your code editor.
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
  zh: '`$schema`条目使您在代码编辑器中编辑`stylecop.json`文件时启用智能感知。'
- en: 'Edit the project file, change the target framework to `net6.0` , add entries
    to configure the file named `stylecop.json` to not be included in published deployments,
    and to enable it as an additional file for processing during development, as shown
    highlighted in the following markup:'
  id: totrans-2170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑项目文件，将目标框架更改为`net6.0`，添加条目来配置名为`stylecop.json`的文件不包含在发布部署中，并在开发过程中将其作为附加文件进行处理，如下标记所示：
- en: '```cs'
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <Project Sdk="Microsoft.NET.Sdk"
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
  zh: <Project Sdk="Microsoft.NET.Sdk"
- en: '>'
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <PropertyGroup>
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: <PropertyGroup>
- en: <OutputType>Exe</OutputType>
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
  zh: <OutputType>Exe</OutputType>
- en: <TargetFramework>net6.0
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: <TargetFramework>net6.0
- en: </TargetFramework>
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
  zh: </TargetFramework>
- en: </PropertyGroup>
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: </PropertyGroup>
- en: '**<ItemGroup>**'
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
  zh: '**<ItemGroup>**'
- en: '**<None Remove=**'
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
  zh: '**<None Remove=**'
- en: '**"stylecop.json"**'
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
  zh: '**"stylecop.json"**'
- en: '**/>**'
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: '**/>**'
- en: '**</ItemGroup>**'
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
  zh: '**</ItemGroup>**'
- en: '**<ItemGroup>**'
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
  zh: '**<ItemGroup>**'
- en: '**<AdditionalFiles Include=**'
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
  zh: '**<AdditionalFiles Include=**'
- en: '**"stylecop.json"**'
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
  zh: '**"stylecop.json"**'
- en: '**/>**'
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
  zh: '**/>**'
- en: '**</ItemGroup>**'
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: '**</ItemGroup>**'
- en: <ItemGroup>
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
  zh: <ItemGroup>```
- en: <PackageReference Include="StyleCop.Analyzers"
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: <PackageReference Include="StyleCop.Analyzers"
- en: Version="1.2.0-*"
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
  zh: Version="1.2.0-*"
- en: '>'
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <PrivateAssets>all</PrivateAssets>
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
  zh: <PrivateAssets>all</PrivateAssets>
- en: <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
  zh: <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
- en: </PackageReference>
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: </PackageReference>
- en: </ItemGroup>
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
  zh: </ItemGroup>
- en: </Project>
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
  zh: </Project>
- en: '```'
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Build your project.
  id: totrans-2199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建您的项目。
- en: You will see warnings for everything it thinks is wrong, as shown in *Figure
    6.7* :![](img/Image00075.jpg)
  id: totrans-2200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到它认为有问题的所有警告，如*图6.7*所示：![](img/Image00075.jpg)
- en: 'Figure 6.7: StyleCop code analyzer warnings'
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：StyleCop代码分析器警告
- en: 'For example, it wants `using` directives to be put within the namespace declaration,
    as shown in the following output:'
  id: totrans-2202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，它希望`using`指令放在命名空间声明内，如下面的输出所示：
- en: '```cs'
  id: totrans-2203
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'C:\Code\Chapter06\CodeAnalyzing\Program.cs(1,1): warning SA1200: Using directive
    should appear within a namespace declaration [C:\Code\Chapter06\CodeAnalyzing\CodeAnalyzing.csproj]'
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: 'C:\Code\Chapter06\CodeAnalyzing\Program.cs(1,1): warning SA1200: Using directive
    should appear within a namespace declaration [C:\Code\Chapter06\CodeAnalyzing\CodeAnalyzing.csproj]'
- en: '```'
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Suppressing warnings
  id: totrans-2206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抑制警告
- en: To suppress a warning, you have several options, including adding code and setting
    configuration.
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
  zh: 要抑制警告，您有几个选项，包括添加代码和设置配置。
- en: 'To suppress using an attribute, as shown in the following code:'
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 要抑制使用属性，如下面的代码所示：
- en: '```cs'
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '[assembly:SuppressMessage('
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
  zh: '[assembly:SuppressMessage('
- en: '"StyleCop.CSharp.OrderingRules"'
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
  zh: '"StyleCop.CSharp.OrderingRules"'
- en: ','
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: '"SA1200:UsingDirectivesMustBePlacedWithinNamespace"'
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
  zh: '"SA1200:UsingDirectivesMustBePlacedWithinNamespace"'
- en: ', Justification ='
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
  zh: ', Justification ='
- en: '"Reviewed."'
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
  zh: '"Reviewed."'
- en: )
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: ']'
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '```'
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To suppress using a directive, as shown in the following code:'
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
  zh: 要抑制使用指令，如下面的代码所示：
- en: '```cs'
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '#'
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: pragma
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
  zh: pragma
- en: warning
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: warning
- en: disable SA1200 // UsingDirectivesMustBePlacedWithinNamespace
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
  zh: disable SA1200 // UsingDirectivesMustBePlacedWithinNamespace
- en: using
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
  zh: using
- en: System;
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
  zh: System;
- en: '#'
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
  zh: '#'
- en: pragma
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
  zh: pragma
- en: warning
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
  zh: warning
- en: restore SA1200 // UsingDirectivesMustBePlacedWithinNamespace
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
  zh: restore SA1200 // UsingDirectivesMustBePlacedWithinNamespace
- en: '```'
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Let''s suppress the warning by modifying the `stylecop.json` file:'
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过修改`stylecop.json`文件来抑制警告：
- en: 'In `stylecop.json` , add a configuration option to set `using` statements to
    be allowable outside a namespace, as shown highlighted in the following markup:'
  id: totrans-2233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `stylecop.json` 中，添加一个配置选项来设置`using`语句允许在命名空间外部，如下标记所示：
- en: '```cs'
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '{'
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"$schema"'
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
  zh: '"$schema"'
- en: ': "https://raw.githubusercontent.com/DotNetAnalyzers/StyleCopAnalyzers/master/StyleCop.Analyzers/StyleCop.Analyzers/Settings/stylecop.schema.json"'
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
  zh: ': "https://raw.githubusercontent.com/DotNetAnalyzers/StyleCopAnalyzers/master/StyleCop.Analyzers/StyleCop.Analyzers/Settings/stylecop.schema.json"'
- en: ','
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: '"settings"'
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
  zh: '"settings"'
- en: ': {'
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
  zh: ': {'
- en: '"orderingRules"'
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
  zh: '"orderingRules"'
- en: ': {'
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
  zh: ': {'
- en: '"usingDirectivesPlacement"'
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
  zh: '"usingDirectivesPlacement"'
- en: ': "outsideNamespace"'
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: ': "outsideNamespace"'
- en: '}'
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Build the project and note that warning SA1200 has disappeared.
  id: totrans-2249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并注意警告SA1200已经消失。
- en: 'In `stylecop.json` , set the using directives placement to `preserve` , which
    allows `using` statements both inside and outside a namespace, as shown in the
    following markup:'
  id: totrans-2250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `stylecop.json` 中，将使用指令放置设置为`preserve`，这允许`using`语句在命名空间内外都可以使用，如下标记所示：
- en: '```cs'
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '"orderingRules"'
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
  zh: '"orderingRules"'
- en: ': {'
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
  zh: ': {'
- en: '"usingDirectivesPlacement"'
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
  zh: '"usingDirectivesPlacement"'
- en: ': "preserve"'
  id: totrans-2255
  prefs: []
  type: TYPE_NORMAL
  zh: ': "preserve"'
- en: '}'
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Fixing the code
  id: totrans-2258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复代码
- en: 'Now, let''s fix all the other warnings:'
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修复所有其他警告：
- en: 'In `CodeAnalyzing.csproj` , add an element to automatically generate an XML
    file for documentation, as shown highlighted in the following markup:'
  id: totrans-2260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CodeAnalyzing.csproj` 中，添加一个元素来自动生成一个文档的XML文件，如下标记所示：
- en: '```cs'
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <Project Sdk="Microsoft.NET.Sdk"
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: <Project Sdk="Microsoft.NET.Sdk"
- en: '>'
  id: totrans-2263
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <PropertyGroup>
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
  zh: <PropertyGroup>
- en: <OutputType>Exe</OutputType>
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
  zh: <OutputType>Exe</OutputType>
- en: <TargetFramework>net6.0
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
  zh: <TargetFramework>net6.0
- en: </TargetFramework>
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
  zh: </TargetFramework>
- en: '**<GenerateDocumentationFile>**'
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
  zh: '**<GenerateDocumentationFile>**'
- en: '**true**'
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
  zh: '**true**'
- en: '**</GenerateDocumentationFile>**'
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
  zh: '**</GenerateDocumentationFile>**'
- en: </PropertyGroup>
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
  zh: </PropertyGroup>
- en: '```'
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `stylecop.json` , add a configuration option to provide values for documentation
    for the company name and copyright text, as shown highlighted in the following
    markup:'
  id: totrans-2273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `stylecop.json` 中，添加一个配置选项来为公司名称和版权文本提供值，如下标记所示：
- en: '```cs'
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '{'
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"$schema"'
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
  zh: '"$schema"'
- en: ': "https://raw.githubusercontent.com/DotNetAnalyzers/StyleCopAnalyzers/master/StyleCop.Analyzers/StyleCop.Analyzers/Settings/stylecop.schema.json"'
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: ': "https://raw.githubusercontent.com/DotNetAnalyzers/StyleCopAnalyzers/master/StyleCop.Analyzers/StyleCop.Analyzers/Settings/stylecop.schema.json"'
- en: ','
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: '"settings"'
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
  zh: '"settings"'
- en: ': {'
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
  zh: ': {'
- en: '"orderingRules"'
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
  zh: '"orderingRules"'
- en: ': {'
  id: totrans-2282
  prefs: []
  type: TYPE_NORMAL
  zh: ': {'
- en: '"usingDirectivesPlacement"'
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
  zh: '"usingDirectivesPlacement"'
- en: ': "preserve"'
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
  zh: ': "preserve"'
- en: '},'
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '**"documentationRules"**'
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: '**"documentationRules"**'
- en: '**: {**'
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
  zh: '**: {**'
- en: '**"companyName"**'
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
  zh: '**"companyName"**'
- en: '**:**'
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
  zh: '**:**'
- en: '**"Packt"**'
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
  zh: '**"Packt"**'
- en: '**,**'
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: '**,**'
- en: '**"copyrightText"**'
  id: totrans-2292
  prefs: []
  type: TYPE_NORMAL
  zh: '**"copyrightText"**'
- en: '**:**'
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
  zh: '**:**'
- en: '**"Copyright (c) Packt. All rights reserved."**'
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
  zh: '**"Copyright (c) Packt. All rights reserved."**'
- en: '**}**'
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '}'
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-2298
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add comments for a file header with company and copyright
    text, move the `using System;` declaration inside the namespace, and set explicit
    access modifiers and XML comments for the class and method, as shown in the following
    code:'
  id: totrans-2299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加公司和版权文本的文件头注释，将`using System;`声明移动到命名空间内，并为类和方法设置显式访问修饰符和XML注释，如下面的代码所示：
- en: '```cs'
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // <copyright file="Program.cs" company="Packt">
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
  zh: // <版权文件="Program.cs"公司="Packt">
- en: // Copyright (c) Packt. All rights reserved.
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: // 版权所有（c）Packt。保留所有权利。
- en: // </copyright>
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
  zh: // </版权>
- en: namespace
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: CodeAnalyzing
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分析
- en: '{'
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: using
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System;
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
  zh: 系统;
- en: ///
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
  zh: ///
- en: <summary>
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: <摘要>
- en: ///
  id: totrans-2311
  prefs: []
  type: TYPE_NORMAL
  zh: ///
- en: The main class for this console app.
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制台应用程序的主类。
- en: ///
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
  zh: ///
- en: </summary>
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: </摘要>
- en: public
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: class
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Program
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
  zh: 程序
- en: '{'
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: ///
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
  zh: ///
- en: <summary>
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
  zh: <摘要>
- en: ///
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
  zh: ///
- en: The main entry point for this console app.
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制台应用程序的主入口点。
- en: ///
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
  zh: ///
- en: </summary>
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: </摘要>
- en: ///
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
  zh: ///
- en: <param name="args">
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: <param name="args">
- en: A string array of arguments passed to the console app.
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给控制台应用程序的参数的字符串数组。
- en: </param>
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
  zh: </参数>
- en: public
  id: totrans-2329
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: static
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的
- en: void
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
  zh: 空
- en: Main
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的
- en: (
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: '[] args'
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
  zh: '[] args'
- en: )
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine("Hello World!"
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
  zh: Console.WriteLine("Hello World!"
- en: );
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Build the project.
  id: totrans-2344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。
- en: 'Expand the `bin/Debug/net6.0` folder and note the autogenerated file named
    `CodeAnalyzing.xml` , as shown in the following markup:'
  id: totrans-2345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开`bin/Debug/net6.0`文件夹，并注意自动生成的名为`CodeAnalyzing.xml`的文件，如下标记所示：
- en: '```cs'
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <?xml version="1.0"?>
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
  zh: <?xml version="1.0"?>
- en: <
  id: totrans-2348
  prefs: []
  type: TYPE_NORMAL
  zh: <
- en: doc
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
  zh: 文档
- en: '>'
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
  zh: <
- en: assembly
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集
- en: '>'
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
  zh: <
- en: name
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
  zh: 名称
- en: '>'
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: CodeAnalyzing</
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分析</
- en: name
  id: totrans-2358
  prefs: []
  type: TYPE_NORMAL
  zh: 名称
- en: '>'
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: </
  id: totrans-2360
  prefs: []
  type: TYPE_NORMAL
  zh: </
- en: assembly
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集
- en: '>'
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <
  id: totrans-2363
  prefs: []
  type: TYPE_NORMAL
  zh: <
- en: members
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
  zh: 成员
- en: '>'
  id: totrans-2365
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
  zh: <
- en: member
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
  zh: 成员
- en: name
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
  zh: 名称
- en: '='
  id: totrans-2369
  prefs: []
  type: TYPE_NORMAL
  zh: '='
- en: '"T:CodeAnalyzing.Program"'
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
  zh: '"T:CodeAnalyzing.Program"'
- en: '>'
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
  zh: <
- en: summary
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: '>'
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: The main class for this console app.
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制台应用程序的主类。
- en: </
  id: totrans-2376
  prefs: []
  type: TYPE_NORMAL
  zh: </
- en: summary
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: '>'
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: </
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
  zh: </
- en: member
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
  zh: 成员
- en: '>'
  id: totrans-2381
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
  zh: <
- en: member
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
  zh: 成员
- en: name
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
  zh: 名称
- en: '='
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
  zh: '='
- en: '"M:CodeAnalyzing.Program.Main(System.String[])"'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
  zh: '"M:CodeAnalyzing.Program.Main(System.String[])"'
- en: '>'
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
  zh: <
- en: summary
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: '>'
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: The main entry point for this console app.
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制台应用程序的主入口点。
- en: </
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
  zh: </
- en: summary
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: '>'
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <
  id: totrans-2395
  prefs: []
  type: TYPE_NORMAL
  zh: <
- en: param
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: name
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
  zh: 名称
- en: '='
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
  zh: '='
- en: '"args"'
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
  zh: '"args"'
- en: '>'
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: A string array of arguments passed to the console app.</
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给控制台应用程序的参数的字符串数组。</
- en: param
  id: totrans-2402
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: '>'
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: </
  id: totrans-2404
  prefs: []
  type: TYPE_NORMAL
  zh: </
- en: member
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
  zh: 成员
- en: '>'
  id: totrans-2406
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: </
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
  zh: </
- en: members
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
  zh: 成员
- en: '>'
  id: totrans-2409
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: </
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
  zh: </
- en: doc
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
  zh: 文档
- en: '>'
  id: totrans-2412
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '```'
  id: totrans-2413
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Understanding common StyleCop recommendations
  id: totrans-2414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解常见的StyleCop建议
- en: 'Inside a code file, you should order the contents, as shown in the following
    list:'
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码文件中，应按照以下列表中显示的顺序排列内容：
- en: External alias directives
  id: totrans-2416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外部别名指令
- en: Using directives
  id: totrans-2417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指令
- en: Namespaces
  id: totrans-2418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Delegates
  id: totrans-2419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 委托
- en: Enums
  id: totrans-2420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举
- en: Interfaces
  id: totrans-2421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口
- en: Structs
  id: totrans-2422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构体
- en: Classes
  id: totrans-2423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类
- en: 'Within a class, record, struct, or interface, you should order the contents,
    as shown in the following list:'
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
  zh: 在类、记录、结构体或接口中，应按照以下列表中显示的顺序排列内容：
- en: Fields
  id: totrans-2425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段
- en: Constructors
  id: totrans-2426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数
- en: Destructors (finalizers)
  id: totrans-2427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 析构函数（终结器）
- en: Delegates
  id: totrans-2428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 委托
- en: Events
  id: totrans-2429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件
- en: Enums
  id: totrans-2430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举
- en: Interfaces
  id: totrans-2431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口
- en: Properties
  id: totrans-2432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性
- en: Indexers
  id: totrans-2433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引器
- en: Methods
  id: totrans-2434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法
- en: Structs
  id: totrans-2435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构体
- en: Nested classes and records
  id: totrans-2436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嵌套类和记录
- en: '**Good Practice** : You can learn about all the StyleCop rules at the following
    link: [https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/DOCUMENTATION.md](https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/DOCUMENTATION.md)
    .'
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：您可以在以下链接了解所有StyleCop规则：[https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/DOCUMENTATION.md](https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/DOCUMENTATION.md)
    。'
- en: Practicing and exploring
  id: totrans-2438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions. Get some
    hands-on practice and explore this chapter's topics with more in-depth research.
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题来测试您的知识和理解。进行一些动手实践，并通过更深入的研究探索本章的主题。
- en: Exercise 6.1 – Test your knowledge
  id: totrans-2440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.1-测试你的知识
- en: 'Answer the following questions:'
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What is a delegate?
  id: totrans-2442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是委托？
- en: What is an event?
  id: totrans-2443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是事件？
- en: How are a base class and a derived class related, and how can the derived class
    access the base class?
  id: totrans-2444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基类和派生类之间有什么关系，派生类如何访问基类？
- en: What is the difference between `is` and `as` operators?
  id: totrans-2445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`is`和`as`运算符之间有什么区别？'
- en: Which keyword is used to prevent a class from being derived from or a method
    from being further overridden?
  id: totrans-2446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个关键字用于防止类被派生或方法被进一步覆盖？
- en: Which keyword is used to prevent a class from being instantiated with the `new`
    keyword?
  id: totrans-2447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个关键字用于防止使用`new`关键字实例化类？
- en: Which keyword is used to allow a member to be overridden?
  id: totrans-2448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个关键字用于允许成员被覆盖？
- en: What's the difference between a destructor and a deconstruct method?
  id: totrans-2449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 析构函数和解构方法有什么区别？
- en: What are the signatures of the constructors that all exceptions should have?
  id: totrans-2450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有异常应该具有的构造函数签名是什么？
- en: What is an extension method, and how do you define one?
  id: totrans-2451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是扩展方法，如何定义一个？
- en: Exercise 6.2 – Practice creating an inheritance hierarchy
  id: totrans-2452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.2-练习创建继承层次结构
- en: 'Explore inheritance hierarchies by following these steps:'
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤探索继承层次结构：
- en: Add a new console application named `Exercise02` to your `Chapter06` solution/workspace.
  id: totrans-2454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个名为`Exercise02`的新控制台应用程序添加到您的`Chapter06`解决方案/工作区中。
- en: Create a class named `Shape` with properties named `Height` , `Width` , and
    `Area` .
  id: totrans-2455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Shape`的类，其中包含名为`Height`，`Width`和`Area`的属性。
- en: Add three classes that derive from it—`Rectangle` , `Square` , and `Circle`
    —with any additional members you feel are appropriate and that override and implement
    the `Area` property correctly.
  id: totrans-2456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加三个从中派生的类-`矩形`，`正方形`和`圆`-以及您认为合适的任何其他成员，并正确覆盖和实现`Area`属性。
- en: 'In `Main` , add statements to create one instance of each shape, as shown in
    the following code:'
  id: totrans-2457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`中，添加语句以创建每种形状的一个实例，如下面的代码所示：
- en: '```cs'
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Rectangle r = new
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形r = 新的
- en: '(height: 3'
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
  zh: （高度：3
- en: ', width: 4.5'
  id: totrans-2461
  prefs: []
  type: TYPE_NORMAL
  zh: ，宽度：4.5
- en: );
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'WriteLine($"Rectangle H:'
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine($"矩形 H:'
- en: '{r.Height}'
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
  zh: '{r.Height}'
- en: ', W:'
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
  zh: '，W:'
- en: '{r.Width}'
  id: totrans-2466
  prefs: []
  type: TYPE_NORMAL
  zh: '{r.Width}'
- en: ', Area:'
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
  zh: ，面积：
- en: '{r.Area}'
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
  zh: '{r.Area}'
- en: '"'
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Square s = new
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
  zh: 正方形s = 新的
- en: (5
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
  zh: （5
- en: );
  id: totrans-2473
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'WriteLine($"Square H:'
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine($"正方形 H:'
- en: '{s.Height}'
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
  zh: '{s.Height}'
- en: ', W:'
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
  zh: ，W：
- en: '{s.Width}'
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
  zh: '{s.Width}'
- en: ', Area:'
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
  zh: ，面积：
- en: '{s.Area}'
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: '{s.Area}'
- en: '"'
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Circle c = new
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形c = 新的
- en: '(radius: 2.5'
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
  zh: （半径：2.5
- en: );
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'WriteLine($"Circle H:'
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine($"圆 H:'
- en: '{c.Height}'
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
  zh: '{c.Height}'
- en: ', W:'
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
  zh: ，W：
- en: '{c.Width}'
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
  zh: '{c.Width}'
- en: ', Area:'
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
  zh: ，面积：
- en: '{c.Area}'
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
  zh: '{c.Area}'
- en: '"'
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the console application and ensure that the result looks like the following
    output:'
  id: totrans-2494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并确保结果看起来像以下输出：
- en: '```cs'
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Rectangle H: 3, W: 4.5, Area: 13.5'
  id: totrans-2496
  prefs: []
  type: TYPE_NORMAL
  zh: '矩形 H: 3，W: 4.5，面积：13.5'
- en: 'Square H: 5, W: 5, Area: 25'
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
  zh: '正方形 H: 5，W: 5，面积：25'
- en: 'Circle H: 5, W: 5, Area: 19.6349540849362'
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
  zh: '圆形 H: 5，W: 5，面积：19.6349540849362'
- en: '```'
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Exercise 6.3 – Explore topics
  id: totrans-2500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.3 – 探索主题
- en: 'Use the links on the following page to learn more about the topics covered
    in this chapter:'
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接了解本章涵盖的主题：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes)'
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes)'
- en: Summary
  id: totrans-2503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about local functions and operators, delegates
    and events, implementing interfaces, generics, and deriving types using inheritance
    and OOP. You also learned about base and derived classes, and how to override
    a type member, use polymorphism, and cast between types.
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了关于本地函数和运算符、委托和事件、实现接口、泛型和使用继承和面向对象编程派生类型。您还学习了关于基类和派生类，以及如何重写类型成员，使用多态性和类型之间的转换。
- en: In the next chapter, you will learn how .NET is packaged and deployed, and,
    in subsequent chapters, the types that it provides you with to implement common
    functionality such as file handling, database access, encryption, and multitasking.
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习.NET如何打包和部署，并在随后的章节中，它为您提供的类型，以实现诸如文件处理、数据库访问、加密和多任务处理等常见功能。
