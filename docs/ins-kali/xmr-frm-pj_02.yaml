- en: Building Our First Xamarin.Forms App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个Xamarin.Forms应用程序
- en: In this chapter, we will create a to-do list app and, in doing so, we'll explore
    all the bits and pieces of what makes an app. We will look at creating pages,
    adding content to those pages, navigating between them, and creating a stunning
    layout. Well, *stunning* might be a bit of a stretch, but we will be sure to design
    the app so that you can tweak it to your needs once it is complete!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个待办事项列表应用程序，并在此过程中探讨构建应用程序的各个方面。我们将研究创建页面，向这些页面添加内容，导航之间切换，并创建一个令人惊叹的布局。嗯，*令人惊叹*可能有点牵强，但我们一定会设计应用程序，以便在完成后您可以根据自己的需求进行调整！
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up the project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目
- en: Persisting data locally on a device
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设备上本地持久化数据
- en: Using the repository pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存储库模式
- en: What MVVM is and why it's a great fit for Xamarin.Forms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM是什么以及为什么它非常适合Xamarin.Forms
- en: Using Xamarin.Forms pages (as Views) and navigating between them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Xamarin.Forms页面（作为视图）并在它们之间导航
- en: Using Xamarin.Forms Control in XAML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在XAML中使用Xamarin.Forms控件
- en: Using data binding
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据绑定
- en: Using styling in Xamarin.Forms
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Xamarin.Forms中使用样式
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To be able to complete this project, we need to have Visual Studio for Mac or
    PC installed, as well as the Xamarin components. See [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction
    to Xamarin,* for more details on how to set up your environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够完成这个项目，我们需要安装Visual Studio for Mac或PC，以及Xamarin组件。有关如何设置您的环境的更多详细信息，请参阅[Xamarin简介](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml)。
- en: An overview of the project
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: Everyone needs a way of keeping track of things. To kick-start our Xamarin.Forms
    development learning curve, we've decided that a to-do list app is the best way
    to get started and also to help you keep track of things. A simple, classic, win-win
    scenario.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都需要一种跟踪事物的方式。为了启动我们的Xamarin.Forms开发学习曲线，我们决定一个待办事项列表应用程序是最好的开始方式，也可以帮助您跟踪事物。一个简单的，经典的，双赢的场景。
- en: We will start by creating the project and defining a repository in which to
    store the items of a to-do list. We will render these items in list form and allow
    the user to edit them using a detailed user interface. We will also look at how
    to store the to-do list items locally on the device through **SQLite-net** so
    they don't get lost when we exit the app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建项目，并定义一个存储库，用于存储待办事项列表的项目。我们将以列表形式呈现这些项目，并允许用户使用详细的用户界面对其进行编辑。我们还将看看如何通过**SQLite-net**在设备上本地存储待办事项，以便在退出应用程序时不会丢失。
- en: The build time for this project is about two hours.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的构建时间约为两个小时。
- en: Beginning the project
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始项目
- en: It's time to start coding! Before moving on, however, make sure you have your
    development environment set up as described in [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction
    to Xamarin*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始编码了！然而，在继续之前，请确保您已按照[Xamarin简介](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml)中描述的设置好开发环境。
- en: This chapter will be a classic File | New Project chapter, guiding you step-by-step
    through the process of creating your first to-do list app. There will be no downloads
    required whatsoever.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将是一个经典的文件|新建项目章节，将逐步指导您创建您的第一个待办事项列表应用程序的过程。完全不需要下载。
- en: Setting up the project
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'A Xamarin app can essentially be created using one of two code-sharing strategies:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin应用程序基本上可以使用两种代码共享策略之一来创建：
- en: As a shared project
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为共享项目
- en: As a .NET Standard library
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为.NET标准库
- en: The first choice, a **shared project**, will create a project type that is essentially
    a linked copy of each file in it. The file exists in one common place and is linked
    in at build time. This means that we cannot determine the runtime when writing
    the code and we are only allowed to access the APIs that are available on each
    target platform. It does allow us to use conditional compilations, which can be
    useful in certain circumstances but can also be confusing for someone who reads
    the code later on. Going for the shared project option may also be a bad choice
    as it locks down our code to specific platforms.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选择，**共享项目**，将创建一个项目类型，实质上是其中每个文件的链接副本。文件存在于一个共同的位置，并在构建时链接。这意味着我们在编写代码时无法确定运行时，并且只能访问每个目标平台上可用的API。它确实允许我们使用条件编译，在某些情况下可能有用，但对于以后阅读代码的人来说可能也会令人困惑。选择共享项目选项也可能是一个不好的选择，因为它将我们的代码锁定到特定的平台。
- en: We will use the second choice, a .**NET Standard library**. This is, of course,
    a matter of choice and both ways will still work. With a little imagination, you
    can still follow this chapter, even if you select a shared project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第二个选择，**.NET标准库**。当然，这是一个选择的问题，两种方式仍然有效。稍加想象力，即使选择了共享项目，您仍然可以遵循本章的内容。
- en: Let's get started!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Creating the new project
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新项目
- en: 'The first step is to create a new Xamarin.Forms project. Open up Visual Studio
    2017 and click on File | New| Project:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个新的Xamarin.Forms项目。打开Visual Studio 2017，然后单击文件|新建|项目：
- en: '![](img/0968d7e6-303e-4f48-886e-6bdac6b71cbd.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0968d7e6-303e-4f48-886e-6bdac6b71cbd.png)'
- en: 'This will open the New Project dialog box. Expand the Visual C# node and click
    on Cross-Platform. Select the Mobile App (Xamarin.Forms) item in the list. Complete
    the form by naming your project and click OK**.** Make sure to name the project `DoToo`
    to avoid namespace issues:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开新项目对话框。展开Visual C#节点，然后单击跨平台。在列表中选择移动应用程序（Xamarin.Forms）项目。通过命名项目并单击确定来完成表单。确保命名项目为“DoToo”以避免命名空间问题：
- en: '![](img/bd6167ef-879a-4903-99a3-52c864466596.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd6167ef-879a-4903-99a3-52c864466596.png)'
- en: 'The next step is to select a project template and a Code Sharing Strategy to
    use. Select Blank App to create a bare Xamarin.Forms app and change the Code Sharing
    Strategy to .NET Standard. Finalize the setup by clicking OK and wait for Visual
    Studio to create the necessary projects:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是选择一个项目模板和代码共享策略。选择空白应用程序以创建一个裸的Xamarin.Forms应用程序，并将代码共享策略更改为.NET标准。点击确定完成设置，并等待Visual
    Studio创建必要的项目：
- en: '![](img/831eed3d-b0da-47d5-b6ba-bb04056ab66f.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/831eed3d-b0da-47d5-b6ba-bb04056ab66f.png)'
- en: Congratulations, we've just created our first Xamarin.Forms app!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，我们刚刚创建了我们的第一个Xamarin.Forms应用程序！
- en: Examining the files
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件
- en: 'The template selected has now created four projects:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所选模板现在已创建了四个项目：
- en: DoToo:This is a .NET Standard library targeting .NET Standard 2.0. It can be
    imported by any runtime that supports this version of .NET Standard.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DoToo:这是一个.NET标准库，目标是.NET标准2.0。它可以被支持这个版本的.NET标准的任何运行时导入。
- en: DoToo.Android:This is an Android app for bootstrapping Xamarin.Forms on Android.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DoToo.Android:这是一个用于在Android上引导Xamarin.Forms的Android应用程序。
- en: DoToo.iOS:This is an iOS app for bootstrapping Xamarin.Forms on iOS.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DoToo.iOS:这是一个用于在iOS上引导Xamarin.Forms的iOS应用程序。
- en: DoToo.UWP:This is a **Universal Windows Platform** (**UWP**) app for bootstrapping
    Xamarin.Forms on UWP.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DoToo.UWP:这是一个用于在UWP上引导Xamarin.Forms的**Universal Windows Platform**（**UWP**）应用程序。
- en: The three platform-specific libraries reference the .NET Standard library. Most
    of our code will be written in the .NET Standard library and only a small portion
    of platform-specific code will be added to each target platform.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个特定平台的库引用了.NET标准库。我们的大部分代码将在.NET标准库中编写，只有一小部分特定平台的代码将被添加到每个目标平台。
- en: 'The project should now look like as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 项目现在应该如下所示：
- en: '![](img/76f6af76-cc51-4298-961f-31dbfd108828.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76f6af76-cc51-4298-961f-31dbfd108828.png)'
- en: We will highlight a few important files in each project so that we can have
    a basic understanding of what they each are. We'll go through these project by
    project.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点介绍每个项目中的一些重要文件，以便我们对它们有一个基本的了解。我们将逐个项目进行介绍。
- en: DoToo
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DoToo
- en: 'This is the .NET Standard library that all the platform-specific projects reference
    and the location to which most of our code will be added. The following screenshot
    displays the structure of the .NET Standard library:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是.NET标准库，所有特定平台的项目都引用它，大部分我们的代码将被添加到这里。以下截图显示了.NET标准库的结构：
- en: '![](img/337ef0a9-629d-4ec7-a6a8-ecbcc20f73f8.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/337ef0a9-629d-4ec7-a6a8-ecbcc20f73f8.png)'
- en: Under Dependencies, we will find references to external dependencies such as
    Xamarin.Forms. We will update the Xamarin.Forms package version in the *Updating
    Xamarin.Forms packages*section. We will add more dependencies as we progress throughout
    the chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖项下，我们将找到对外部依赖项（如Xamarin.Forms）的引用。我们将在*更新Xamarin.Forms包*部分中更新Xamarin.Forms包的版本。随着我们在本章中的进展，我们将添加更多依赖项。
- en: The `App.xaml` file is a XAML file that represents the app. This is a good place
    to put application-wide resources, which we will do later on. We can also see
    the `App.xaml.cs` file, which contains the startup code and some lifetime events
    to which we can add custom code, such as `OnStart` or `OnSleep`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.xaml`文件是一个代表应用程序的XAML文件。这是放置应用程序范围资源的好地方，我们稍后会这样做。我们还可以看到`App.xaml.cs`文件，其中包含启动代码和一些生命周期事件，我们可以在其中添加自定义代码，例如`OnStart`或`OnSleep`。'
- en: 'If we open up `App.xaml.cs`, we can see the starting point for our Xamarin.Forms
    application:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开`App.xaml.cs`，我们可以看到我们的Xamarin.Forms应用程序的起点：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The assignment of a page to the `MainPage`property is particularly important,
    as this is what determines which page will be displayed to the user first. In
    the template, this is the `DoToo.MainPage()` class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将页面分配给`MainPage`属性特别重要，因为这决定了用户首先将显示哪个页面。在模板中，这是`DoToo.MainPage()`类。
- en: The last two files are the `MainPage.xaml` file, which contains the first page
    of the application and the code-behind file, which is called `MainPage.xaml.cs`.
    These files will be removed in order to comply with the **Model–View–ViewModel** (**MVVM**)
    naming standards.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个文件是`MainPage.xaml`文件，其中包含应用程序的第一个页面，以及称为`MainPage.xaml.cs`的代码后台文件。为了符合**Model-View-ViewModel**（**MVVM**）命名标准，这些文件将被删除。
- en: DoToo.Android
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DoToo.Android
- en: 'This is the Android app. It only has one file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Android应用程序。它只有一个文件：
- en: '![](img/e61e5203-3712-4ef3-9b7b-62f81f601a4e.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e61e5203-3712-4ef3-9b7b-62f81f601a4e.png)'
- en: The important file here is `MainActivity.cs`. This contains the entry point
    for our application if we run the app on an Android device. The entry point method
    for an Android app is `OnCreate(...)`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要文件是`MainActivity.cs`。如果我们在Android设备上运行应用程序，这个文件包含应用程序的入口点方法。Android应用程序的入口点方法是`OnCreate(...)`。
- en: 'If you open the `MainActivity.cs` and examine the `OnCreate(...)` method, it
    should look something like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开`MainActivity.cs`并检查`OnCreate(...)`方法，它应该看起来像这样：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first two lines assign resources for the `Tabbar` and the `Toolbar`. We
    then call the base method, followed by the mandatory initialization of Xamarin.Forms.
    Finally, we have the call to load the Xamarin.Forms application that we have defined
    in the .NET Standard library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行为`Tabbar`和`Toolbar`分配资源。然后我们调用基本方法，接着是Xamarin.Forms的强制初始化。最后，我们调用加载我们在.NET标准库中定义的Xamarin.Forms应用程序。
- en: We don't need to understand these files in detail, just remember that they are
    important for the initialization of our app.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要详细了解这些文件，只需记住它们对于我们应用程序的初始化很重要。
- en: DoToo.iOS
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DoToo.iOS
- en: 'This is the iOS app. It contains a few more files than its Android counterpart:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是iOS应用程序。它包含的文件比其Android对应文件多一些：
- en: '![](img/64c398b1-b14b-4851-b11e-4e2342e5152b.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64c398b1-b14b-4851-b11e-4e2342e5152b.png)'
- en: 'The `AppDelegate.cs` file is the entry point for an iOS app. This file contains
    a method called `FinishedLaunching(...)`, which is where we start writing code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppDelegate.cs`文件是iOS应用程序的入口点。这个文件包含一个叫做`FinishedLaunching(...)`的方法，这是我们开始编写代码的地方：'
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code starts off by initializing Xamarin.Forms and then loads the application
    from the .NET Standard library. After that, it returns the control to iOS. It
    must do this within 17 seconds, or the app will be terminated by the OS.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从初始化Xamarin.Forms开始，然后从.NET标准库加载应用程序。之后，它将控制返回到iOS。必须在17秒内完成此操作，否则应用程序将被操作系统终止。
- en: The `info.plist` file is an iOS-specific file that contains information about
    the app, such as the bundle ID and its provisioning profiles. It has a graphical
    editor, but can also be edited in any text editor, since it's a standard XML file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`info.plist`文件是一个iOS特定的文件，包含有关应用程序的信息，例如捆绑ID及其配置文件。它有一个图形编辑器，但也可以在任何文本编辑器中编辑，因为它是一个标准的XML文件。'
- en: The `Entitlements.plist` file is also an iOS-specific file that configures the
    entitlements that we want our app to take advantage of, such as **in-app purchases** or **push
    notifications**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entitlements.plist`文件也是一个iOS特定的文件，用于配置我们希望应用程序利用的权限，例如**应用内购买**或**推送通知**。'
- en: As with the Android app's startup code, we don't need to understand what is
    going on here in detail, other than that it's important for the initialization
    of our app.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与Android应用程序的启动代码一样，我们不需要详细了解这里发生了什么，只需知道这对于我们应用程序的初始化非常重要。
- en: DoToo.UWP
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DoToo.UWP
- en: 'The last project to examine is the UWP app. The file structure of the project
    looks like the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查的最后一个项目是UWP应用程序。项目的文件结构如下截图所示：
- en: '![](img/a326f5d0-d1d7-40e4-8a1d-946afe2be4f9.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a326f5d0-d1d7-40e4-8a1d-946afe2be4f9.png)'
- en: It has an `App.xaml` file, which is similar to the one in the .NET Standard
    library, but specific to the UWP app. It also has a related file called `App.xaml.cs`.
    This contains a method called `OnLaunched(...)`, which is the entry point for
    a UWP app. This file is quite large, so we won't be printing it out here, but
    do open it up and see if we can locate the Xamarin.Forms initialization code in
    it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个`App.xaml`文件，类似于.NET标准库中的文件，但特定于UWP应用程序。它还有一个名为`App.xaml.cs`的相关文件。其中包含一个名为`OnLaunched(...)`的方法，是UWP应用程序的入口点。这个文件非常大，所以我们不会在这里打印出来，但是打开它，看看我们是否可以在其中找到Xamarin.Forms初始化代码。
- en: Updating the Xamarin.Forms packages
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Xamarin.Forms软件包
- en: 'After creating the project, we should always update our Xamarin.Forms packages
    to the latest version. To do this, follow these steps:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，我们应该始终将Xamarin.Forms软件包更新到最新版本。要执行此操作，请按照以下步骤进行：
- en: Right-click on our Solution in the Solution Explorer.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中右键单击我们的解决方案。
- en: 'Click on Manage NuGet Packages for Solution...:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“管理解决方案的NuGet软件包...”：
- en: '![](img/b16aacf6-cee3-4980-9ac8-cf1940d124bb.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b16aacf6-cee3-4980-9ac8-cf1940d124bb.png)'
- en: 'This brings up the NuGet Package Manager in Visual Studio:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在Visual Studio中打开NuGet软件包管理器：
- en: '![](img/add08ce1-c4cd-4a91-b7a6-b1678169e278.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/add08ce1-c4cd-4a91-b7a6-b1678169e278.png)'
- en: 'To update Xamarin.Forms to the latest version, do this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Xamarin.Forms更新到最新版本，请执行以下操作：
- en: Click the Updates tab
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“更新”选项卡
- en: Check Xamarin.Forms and click Update
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查Xamarin.Forms并单击更新
- en: Accept any license agreements
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受任何许可协议
- en: Keep an eye on the output pane and wait for all the packages to be updated.
    However, ensure that you don't update any Android packages manually, as this might
    break your application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 密切关注输出窗格，并等待所有软件包更新。但是，请确保不要手动更新任何Android软件包，因为这可能会破坏您的应用程序。
- en: Removing the MainPage file
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除MainPage文件
- en: 'In Xamarin.Forms, we have the concept of pages. This is not the case, however,
    for the MVVM architectural pattern, which instead uses the concept of views. Views
    are the same thing as pages but they are not suffixed with -Page, so we will delete
    the `MainPage` generated by the template. We will go into more detail on MVVM
    shortly, but for the time being, we will remove the `MainPage.cs` class from the
    solution. This can be done as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.Forms中，我们有页面的概念。然而，对于MVVM架构模式来说并非如此，它使用视图的概念。视图与页面是相同的，但它们没有后缀-Page，因此我们将删除模板生成的`MainPage`。我们将很快详细介绍MVVM，但目前，我们将从解决方案中删除`MainPage.cs`类。可以按照以下步骤完成：
- en: Right-click on the `MainPage.xaml` file in the `DoToo` project (the .NET Standard
    library)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DoToo`项目（.NET标准库）中右键单击`MainPage.xaml`文件
- en: Click Delete and confirm the delete action
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击删除并确认删除操作
- en: Creating a repository and a TodoItem model
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建存储库和TodoItem模型
- en: Any good architecture always involves abstraction. In this app, we need something
    to store and retrieve the items of our to-do list. These will later be stored
    in an SQLite database, but adding a reference to the database directly from the
    code that is responsible for the GUI is generally a bad idea.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 任何良好的架构都涉及抽象。在这个应用程序中，我们需要存储和检索待办事项列表中的项目。这些将稍后存储在SQLite数据库中，但是直接从负责GUI的代码中添加对数据库的引用通常是一个坏主意。
- en: What we need instead is something to abstract our database from the GUI. For
    this app, we've chosen to use a simple repository pattern. This repository is
    simply a class that sits in between the SQLite database and our upcoming `ViewModels`.
    This is the class that handles the interaction with the view, which in turn handles
    the GUI.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要的是将数据库从GUI中抽象出来。对于这个应用程序，我们选择使用简单的存储库模式。这个存储库只是一个简单的类，位于SQLite数据库和我们即将到来的`ViewModels`之间。这是处理与视图的交互的类，而视图又处理GUI。
- en: The repository will expose methods for getting items, adding items, and updating
    items, as well as events that allow other parts of the app to react to changes
    in the repository. It will be hidden behind an interface so that we can replace
    the entire implementation later on, without modifying anything but a line of code
    in the initialization of the app. This is made possible by **Autofac**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库将公开用于获取项目、添加项目和更新项目的方法，以及允许应用程序其他部分对存储库中更改做出反应的事件。它将隐藏在接口后面，以便我们稍后可以替换整个实现，而不必修改应用程序初始化中的代码行以外的任何内容。这是由**Autofac**实现的。
- en: Defining a to-do list item
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义待办事项列表项目
- en: 'We will start off by creating a `TodoItem` class, which will represent a single
    item in the list. This will be a simple **Plain Old CLR Object** (**POCO**) class,
    where **CLR** stands from **Common Language Runtime**. In other words, this will
    be a .NET class without any dependencies on third-party assemblies. To create
    the class, follow the steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个`TodoItem`类，它将表示列表中的单个项目。这将是一个简单的**Plain Old CLR Object**（**POCO**）类，其中**CLR**代表**Common
    Language Runtime**。换句话说，这将是一个没有依赖于第三方程序集的.NET类。要创建该类，请按照以下步骤：
- en: In the .NET Standard library project, create a folder called `Models`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET Standard库项目中，创建一个名为`Models`的文件夹。
- en: 'Add a class called `TodoItem.cs` in that folder and enter the following code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中创建一个名为`TodoItem.cs`的类，并输入以下代码：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code is pretty self-explanatory; it's a simple **Plain Old CLR Object** (**POCO**)
    class that only contains properties and no logic. We have a `Title` that describes
    what we want to be done, a flag (`Completed`) that determines if the to-do list
    item is done, a `Due` date when we expect it to be done, and a unique `id` that
    we need later on for the database.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单易懂；这是一个简单的**Plain Old CLR Object**（**POCO**）类，只包含属性而没有逻辑。我们有一个`Title`描述我们想要完成的任务，一个标志（`Completed`）确定待办事项是否已完成，一个`Due`日期我们期望完成它，以及一个我们以后需要用到的唯一`id`。
- en: Creating a repository and its interface
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建存储库及其接口
- en: 'Now that we have the `TodoItem` class, let''s define an interface that describes
    a repository to store our to-do list items:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`TodoItem`类，让我们定义一个描述存储待办事项的存储库的接口：
- en: In the .NET Standard library project, create a folder called `Repositories`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET Standard库项目中，创建一个名为`Repositories`的文件夹。
- en: 'Create an interface called `ITodoItemRepository.cs` in the `Repositories` folder
    and write the following code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Repositories`文件夹中创建一个名为`ITodoItemRepository.cs`的接口，并编写以下代码：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The eagle-eyed among you might notice that we are not defining a `Delete` method
    in this interface. This is definitely something that should be there in a real-world
    app. While the app that we are creating in this chapter will not support the deleting
    of items, we are quite sure that you could add this yourself if you want to!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的读者可能会注意到，我们在这个接口中没有定义`Delete`方法。这绝对是真实世界应用程序中应该有的内容。虽然我们在本章中创建的应用程序不支持删除项目，但我们相当确定，如果您愿意，您可以自行添加这个功能！
- en: This interface defines everything we need for our app. It is there to create
    logical insulation between your implementation of a repository and the user of
    that repository. If any other part of your application wants an instance of `TodoItemRepository`,
    we can pass it any object that implements `ITodoItemRepository`, regardless of
    how it's implemented.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口定义了我们应用程序所需的一切。它用于在存储库的实现和存储库的用户之间创建逻辑隔离。如果应用程序的其他部分需要`TodoItemRepository`的实例，我们可以传递任何实现`ITodoItemRepository`的对象，而不管它是如何实现的。
- en: 'Having that said, let''s implement `ITodoItemRepository`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，让我们实现`ITodoItemRepository`：
- en: Create a class called `TodoItemRepository.cs`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`TodoItemRepository.cs`的类。
- en: 'Enter the following code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code is the bare-bones implementation of the interface, except for the
    `AddOrUpdate(...)` method. This handles a small piece of logic that states that
    if the ID of an item is `0`, it's a new item. Any item with an ID larger than
    `0` is stored in the database. This is because the database assigns a value larger
    than zero when we create rows in a table.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是接口的最基本实现，除了`AddOrUpdate(...)`方法。这处理了一个小段逻辑，即如果项目的ID为`0`，则它是一个新项目。任何ID大于`0`的项目都存储在数据库中。这是因为当我们在表中创建行时，数据库会分配一个大于零的值。
- en: There are also two events defined in the preceding code. These will be used
    for notifying any subscriber that items have been updated or added.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中还定义了两个事件。这将用于通知任何订阅者项目已更新或已添加。
- en: Connecting SQLite to persist data
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接SQLite以持久化数据
- en: We now have an interface and a skeleton to implement that interface. The last
    thing we need to do to finish this section is to connect SQLite inside the implementation
    of the repository.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个接口和一个实现该接口的骨架。完成本节的最后一件事是在存储库的实现中连接SQLite。
- en: Adding the SQLite NuGet package
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加SQLite NuGet包
- en: 'To access SQLite in this project, we need to add a NuGet package called sqlite-net-pcl
    to the .NET Standard library project. To do this, right-click on the Dependencies
    item under the DoToo project node of the Solution and click Manage NuGet Packages:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此项目中访问SQLite，我们需要向.NET Standard库项目添加一个名为sqlite-net-pcl的NuGet包。要做到这一点，请右键单击解决方案的DoToo项目节点下的依赖项，然后单击管理NuGet包：
- en: '![](img/9325577f-3323-4e97-b089-91787f868c17.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9325577f-3323-4e97-b089-91787f868c17.png)'
- en: You might notice that the NuGet package is suffixed with -pcl. This is an example
    of what happens when naming conventions go wrong. This package actually supports
    .NET Standard 1.0, even though the name says **Portable Class Library** (**PCL**),
    which was the predecessor to .NET Standard.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到NuGet包的后缀为-pcl。这是命名约定出错时发生的情况。这个包实际上支持.NET Standard 1.0，尽管名称中说的是**Portable
    Class Library**（**PCL**），这是.NET Standard的前身。
- en: 'This brings up the NuGet Package Manager:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这会弹出NuGet包管理器：
- en: '![](img/9bb454fb-b159-4236-8fb3-6d5dc3500318.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bb454fb-b159-4236-8fb3-6d5dc3500318.png)'
- en: Click Browse and enter sqlite-net-pcl in the search box
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击浏览并在搜索框中输入sqlite-net-pcl
- en: Select the package by Frank A. Krueger and click Install
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Frank A. Krueger的包，然后单击安装
- en: Wait for the installation to complete. We'll then add some code to the `TodoItem`
    class and the repository.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 等待安装完成。然后我们将向`TodoItem`类和存储库添加一些代码。
- en: Updating the TodoItem class
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新TodoItem类
- en: 'Since SQLite is a relational database, it needs to know some basic information
    about how to create the tables that will store our objects. This is done using
    attributes, which are defined in the SQLite namespace:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SQLite是一个关系型数据库，它需要知道一些关于如何创建将存储我们对象的表的基本信息。这是使用属性完成的，这些属性在SQLite命名空间中定义：
- en: Open up the `Models/TodoItem`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Models/TodoItem`。
- en: 'Add a `using SQLite` statement at the start of the file right below the existing `using`
    statements, as shown in the following code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的开头下面的现有`using`语句之后添加一个`using SQLite`语句，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the `PrimaryKey` and `AutoIncrement` attributes right before the ID property,
    as demonstrated in the following code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ID属性之前添加`PrimaryKey`和`AutoIncrement`属性，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `PrimaryKey` attribute instructs SQLite that the `Id` property is the primary
    key of the table. The `AutoIncrement` attribute will make sure that the value
    of `Id` will be increased by one for each new `TodoItem` class that is added to
    the table.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrimaryKey`属性指示SQLite`Id`属性是表的主键。`AutoIncrement`属性将确保`Id`的值对于添加到表中的每个新的`TodoItem`类都会增加一。'
- en: Creating a connection to the SQLite database
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建与SQLite数据库的连接
- en: 'We will now add all the code needed to communicate with the database. The first
    thing we need to do is to define a connection field that will hold the connection
    to the database:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加所有与数据库通信所需的代码。我们首先需要定义一个连接字段，用于保存与数据库的连接：
- en: Open up the `Repositories/TodoItemRepository` file.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Repositories/TodoItemRepository`文件。
- en: 'Add a** `using SQLite` **statement at the start of the file right below the
    existing `using` statements, as shown in the following code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的开头下面的现有`using`语句之后添加一个**`using SQLite`**语句，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following field right below the class declaration:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类声明的下面添加以下字段：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The connection needs to be initialized. Once it is initialized, it can be reused
    throughout the lifespan of the repository. Since the method is asynchronous, it
    cannot be called from the constructor without introducing a locking strategy.
    To keep things simple, we will simply call it from each of the methods that are
    defined by the interface:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 连接需要初始化。一旦初始化，它就可以在存储库的整个生命周期内重复使用。由于该方法是异步的，不能从构造函数中调用它而不引入锁定策略。为了保持简单，我们将简单地从每个由接口定义的方法中调用它：
- en: Add the following code to the `TodoItemRepository` class.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`TodoItemRepository`类中。
- en: 'Add a `using System.IO` statement at the start of the file so that we can use
    `Path.Combine(...)`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的开头添加一个`using System.IO`语句，以便我们可以使用`Path.Combine(...)`：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The method begins by checking whether we already have a connection. If we do,
    we can simply return. If we don't have a connection set up, we define a path on
    the disk to indicate where we want the database file to be located. In this case,
    we will choose the `MyDocuments` folder. Xamarin will find the closest match to
    this on each platform that we target.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先检查我们是否已经有连接。如果有，我们可以简单地返回。如果我们没有设置连接，我们定义一个磁盘上的路径来指示我们希望数据库文件位于何处。在这种情况下，我们将选择`MyDocuments`文件夹。Xamarin将在我们针对的每个平台上找到与此最接近的匹配项。
- en: We then create the connection and store the reference to that connection in
    the `connection` field. We need to make sure that SQLite has created a table that
    mirrors the schema of the `TodoItem` table. To make the development of the app
    easier, we add a default to-do list item if the `TodoItem` table is empty.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建连接并将该连接的引用存储在`connection`字段中。我们需要确保SQLite已创建一个与`TodoItem`表的模式相匹配的表。为了使应用程序的开发更加简单，如果`TodoItem`表为空，我们将添加一个默认的待办事项。
- en: Implementing the Get, Add, and Update methods
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现获取、添加和更新方法
- en: 'The only thing left to do in the repository is to implement the methods for
    getting, adding, and updating items:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中剩下的唯一事情是实现获取、添加和更新项目的方法：
- en: Locate the `GetItems()` method in the `TodoItemRepository` class.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TodoItemRepository`类中找到`GetItems()`方法。
- en: 'Update the `GetItems()` method with the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新`GetItems()`方法：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To ensure that the connection to the database is valid, we call the `CreateConnection()`
    method we created in the previous section. When this method returns, we can make
    sure that it is initialized and that the `TodoItem` table has been created.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保与数据库的连接有效，我们调用了在上一节中创建的`CreateConnection()`方法。当此方法返回时，我们可以确保它已初始化并且`TodoItem`表已创建。
- en: We then use the connection to access the `TodoItem` table and return a `List<TodoItem>`
    that contains all the to-do list items in the database.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用连接访问`TodoItem`表，并返回一个包含数据库中所有待办事项的`List<TodoItem>`。
- en: SQLite supports querying data using **Language Integrated Query** (**LINQ**).
    You could play around with this after the project is complete to get a better
    understanding of how to work with databases inside your app.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite支持使用**语言集成查询**（**LINQ**）查询数据。在项目完成后，您可以尝试使用它来更好地了解如何在应用程序内部使用数据库。
- en: 'The code for adding items is even simpler:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 添加项目的代码甚至更简单：
- en: Locate the `AddItem()` method in the `TodoItemRepository` class.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TodoItemRepository`类中找到`AddItem()`方法。
- en: 'Update the `AddItem()` method with the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新`AddItem()`方法：
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The call to `CreateConnection()` makes sure that we have a connection in the
    same way as we did for the `GetItems()` method. After this, we perform the actual
    insertion into the database using the `InsertAsync(...)` method on the connection
    object. After an item has been inserted into the table, we invoke the `OnItemAdded`
    event to notify any subscribers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对`CreateConnection()`的调用确保我们以与`GetItems()`方法相同的方式建立连接。之后，我们使用连接对象上的`InsertAsync(...)`方法在数据库中执行实际的插入操作。在项目被插入到表中后，我们调用`OnItemAdded`事件通知任何订阅者。
- en: 'The code to update an item is basically the same as the `AddItem()` method,
    but also includes calls to `UpdateAsync` and `OnItemUpdated`. Let''s finish up
    by updating the `UpdateItem()` method with the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 更新项目的代码基本上与`AddItem()`方法相同，但还包括对`UpdateAsync`和`OnItemUpdated`的调用。让我们通过使用以下代码更新`UpdateItem()`方法来完成：
- en: Locate the `UpdateItem()` method in the `TodoItemRepository` class.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TodoItemRepository`类中找到`UpdateItem()`方法。
- en: 'Update the `UpdateItem()` method with the following code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新`UpdateItem()`方法：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the next section, we'll get started with MVVM. Grab a cup of coffee and let's
    get started.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始使用MVVM。来杯咖啡，让我们开始吧。
- en: Using MVVM – creating Views and ViewModels
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MVVM - 创建视图和视图模型
- en: 'MVVM is all about the separation of concerns. Each part has a specific meaning:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM的关键在于关注点的分离。每个部分都有特定的含义：
- en: '**Model**:This relates to anything that represents data and that can be referenced
    by the `ViewModel`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这与表示数据并可以由`ViewModel`引用的任何东西有关'
- en: '**View**:This is the visual component. In Xamarin.Forms, this is represented
    by a page'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这是可视化组件。在Xamarin.Forms中，这由一个页面表示'
- en: '**ViewModel**:This is a class that acts as the glue between the Model and the
    View'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ViewModel**：这是在模型和视图之间充当中介的类'
- en: In our app, we could say that the Model is the repository and the to-do list
    items it returns. The `ViewModel` has a reference to this repository and exposes
    properties that the View can bind to. The ground rule is that any logic should
    reside in the ViewModel and no logic should be in the View. The View should know
    how to present data, such as converting a Boolean value to *Yes* or *No*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们可以说模型是存储库和它返回的待办事项列表项。`ViewModel`引用这个存储库并公开属性，供视图绑定。基本规则是任何逻辑都应该驻留在ViewModel中，视图中不应该有任何逻辑。视图应该知道如何呈现数据，比如将布尔值转换为“是”或“否”。
- en: MVVM can be implemented in many ways and there are quite a few frameworks that
    we could use. In this chapter, we have chosen to keep things simple and implement
    MVVM in a vanilla way, without any framework at all.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM可以以许多方式实现，有很多框架可以使用。在本章中，我们选择保持简单，以纯净的方式实现MVVM，而不使用任何框架。
- en: Defining a ViewModel base class
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个ViewModel基类
- en: 'A `ViewModel` is the mediator between the View and the Model. We can benefit
    greatly by creating a common base class for all our `ViewModels` to inherit from.
    To do this, follow these steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel`是视图和模型之间的中介。通过为所有`ViewModels`创建一个通用的基类，我们可以获得很大的好处。要做到这一点，请按照以下步骤操作：'
- en: Create a folder called `ViewModels` in the `DoToo` .NET Standard project.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在DoToo .NET Standard项目中创建一个名为`ViewModels`的文件夹。
- en: Create a class called `ViewModel` in the `ViewModels` folder .
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ViewModels文件夹中创建一个名为`ViewModel`的类。
- en: 'Resolve references to `System.ComponentModel` and Xamarin.Forms and add the
    following code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决对`System.ComponentModel`和Xamarin.Forms的引用，并添加以下代码：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ViewModel` class is a base class for all `ViewModels`. This is not meant
    to be instantiated on its own, so we mark it as abstract. It implements `INotifyPropertyChanged`, which
    is an interface defined in `System.ComponentModel` in the .NET base class libraries.
    This interface only defines one thing: the `PropertyChanged` event. Our `ViewModel`
    must raise this event whenever we want the GUI to be aware of any changes to a
    property. This can be done manually, by adding code to a setter in a property,
    or by using an **i****ntermediate language** (**IL**) weaver such as `PropertyChanged.Fody`.
    We will talk about this in detail in the next section.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel`类是所有`ViewModels`的基类。这不是要单独实例化的，所以我们将其标记为抽象。它实现了`INotifyPropertyChanged`，这是在.NET基类库中的`System.ComponentModel`中定义的一个接口。这个接口只定义了一件事：`PropertyChanged`事件。我们的`ViewModel`必须在我们希望GUI意识到属性的任何更改时引发此事件。这可以通过手动添加代码到属性的setter中来完成，也可以使用**中间语言**（**IL**）编织器，比如`PropertyChanged.Fody`。我们将在下一节详细讨论这个问题。'
- en: We are also taking a little shortcut here by adding an `INavigation` property
    in the `ViewModel`. This will help us with navigation later on. This is also something
    that can (and should) be abstracted, since we don't want the `ViewModel` to be
    dependent on Xamarin.Forms, in order to be able to reuse the `ViewModels` on any
    platform.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在这里采取了一个小捷径，通过在`ViewModel`中添加一个`INavigation`属性。这将在以后帮助我们进行导航。这也是可以（也应该）抽象的，因为我们不希望`ViewModel`依赖于Xamarin.Forms，以便能够在任何平台上重用`ViewModels`。
- en: Introducing PropertyChanged.Fody
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍PropertyChanged.Fody
- en: 'The traditional way of implementing a `ViewModel` is to inherit from a base
    class (such as the `ViewModel` that we defined previously) and then add code that
    might look as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`ViewModel`的传统方式是从基类（比如我们之前定义的`ViewModel`）继承，然后添加以下代码：
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each property that we want to add to a `ViewModel` yields six lines of code.
    Not too bad, you might think. However, considering that a `ViewModel` could potentially contain
    10 to 20 properties, this rapidly turns into a lot of code. We can do better than
    this.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要添加到`ViewModel`的每个属性都会产生六行代码。你可能会认为这并不太糟糕。然而，考虑到一个`ViewModel`可能潜在地包含10到20个属性，这很快就会变成大量的代码。我们可以做得更好。
- en: 'In just a few simple steps, we can use a tool called `PropertyChanged.Fody`
    to automatically inject almost all the code during the build process:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几个简单的步骤，我们就可以使用一个名为`PropertyChanged.Fody`的工具，在构建过程中自动注入几乎所有的代码：
- en: In the .NET Standard library, install the `PropertyChanged.Fody` NuGet package.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET Standard库中，安装`PropertyChanged.Fody` NuGet包。
- en: 'Create a file called `FodyWeavers.xml` and add the following XML to it:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FodyWeavers.xml`的文件，并添加以下XML代码：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`PropertyChanged.Fody` will scan the assembly for any class that implements
    the `INotifyPropertyChanged` interface and adds the code needed to raise the `PropertyChanged`
    event. It will also take care of dependencies between properties, meaning that
    if you have a property that returns values based on two other properties, it will
    be raised if either of those two values changes.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyChanged.Fody`将扫描程序集，查找实现`INotifyPropertyChanged`接口的任何类，并添加所需的代码来引发`PropertyChanged`事件。它还会处理属性之间的依赖关系，这意味着如果您有一个属性根据其他两个属性返回值，那么如果这两个值中的任何一个发生变化，它都会被引发。'
- en: 'The result is that the test class we had previously is reduced to a single
    line of code per property. This makes the code base more readable because everything
    happens behind the scenes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是我们之前的测试类每个属性的代码都被简化为一行。这使得代码更易读，因为一切都是在幕后发生的：
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is worth noting that there are a lot of different plugins that can be used
    to make Fody automate tasks, such as logging or method decoration. Check out [https://github.com/Fody/Fody](https://github.com/Fody/Fody)
    for more info.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，有许多不同的插件可以用来使Fody自动化任务，例如日志记录或方法装饰。查看[https://github.com/Fody/Fody](https://github.com/Fody/Fody)获取更多信息。
- en: Creating the MainViewModel
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MainViewModel
- en: 'Up to this point, we have mainly been preparing to write the code that will
    make up the app itself. The `MainViewModel` is the `ViewModel` for the first view
    that will be displayed to the user. It will be responsible for providing data
    and logic to a list of to-do list items. We will create the bare-bones `ViewModels`
    and add code to them as we move through the chapter:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要是在准备编写构成应用程序本身的代码。`MainViewModel`是将显示给用户的第一个视图的`ViewModel`。它将负责为待办事项列表提供数据和逻辑。随着我们在本章中的进展，我们将创建基本的`ViewModels`并向其中添加代码：
- en: Create a class called `MainViewModel` inside the `ViewModels` folder.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewModels`文件夹中创建一个名为`MainViewModel`的类。
- en: 'Add the following template code and resolve the references:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下模板代码并解决引用：
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The structure in this class is something that we will reuse for all the `ViewModels`
    to come.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中的结构是我们将来会重用的所有`ViewModels`。
- en: 'Let''s summarize the important features we want the `ViewModel` to have:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们希望`ViewModel`具有的重要功能：
- en: We inherit from the `ViewModel` to gain access to shared logic, such as the `INotifyPropertyChanged` interface
    and common navigation code.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从`ViewModel`继承以获得共享逻辑，例如`INotifyPropertyChanged`接口和常见导航代码。
- en: All dependencies to other classes, such as repositories and services, are passed
    through the constructor of the `ViewModel`. This will be handled by the **d****ependency
    injection** pattern and, more specifically for our case, by Autofac, which is
    the implementation of dependency injection we are using.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有对其他类的依赖项，例如存储库和服务，都通过`ViewModel`的构造函数传递。这将由**依赖注入**模式处理，更具体地说，由我们使用的依赖注入实现Autofac处理。
- en: We use an asynchronous call to `LoadData()` as an entry point to initialize
    the `ViewModel`. Different MVVM libraries might do this in different ways, but
    the basic functionally is the same.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用异步调用`LoadData()`作为初始化`ViewModel`的入口点。不同的MVVM库可能以不同的方式执行此操作，但基本功能是相同的。
- en: Creating the TodoItemViewModel
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建TodoItemViewModel
- en: The `TodoItemViewModel` is the `ViewModel` that represents each item in the
    to-do list on the `MainView`. It will not have an entire view of its own (although
    it could have), but instead will be rendered by a template in the `ListView`.
    We will get back to this when we create the controls for the `MainView`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoItemViewModel`是在`MainView`上表示待办事项列表中每个项目的`ViewModel`。它不会有自己的整个视图（尽管可能会有），而是将由`ListView`中的模板呈现。当我们为`MainView`创建控件时，我们将回到这一点。'
- en: The important thing here is that this `ViewModel` will represent a single item,
    regardless of where we choose to render it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，这个`ViewModel`将代表一个单个项目，无论我们选择在哪里呈现它。
- en: 'Let''s create the `TodoItemViewModel`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`TodoItemViewModel`：
- en: Create a class called `TodoItemViewModel` inside the `ViewModels` folder.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewModels`文件夹中创建一个名为`TodoItemViewModel`的类。
- en: 'Add the following template code and resolve the references:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下模板代码并解决引用：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As with any other `ViewModel`, we inherit the `TodoItemViewModel` from `ViewModel`.
    We conform to the pattern of injecting all dependencies in the constructor. In
    this case, we pass an instance of the `TodoItem` class in the constructor that
    the `ViewModel` will use to expose to the view.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他`ViewModel`一样，我们从`ViewModel`继承`TodoItemViewModel`。我们遵循在构造函数中注入所有依赖项的模式。在这种情况下，我们在构造函数中传递`TodoItem`类的实例，`ViewModel`将使用它来向视图公开。
- en: The `ItemStatusChanged` event handler will be used later when we want to signal
    to the view that the state of the `TodoItem` has changed. The `Item` property
    allows us to access the item that we passed in.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemStatusChanged`事件处理程序将在以后用于向视图发出信号，表明`TodoItem`的状态已更改。`Item`属性允许我们访问传入的项目。'
- en: The `StatusText` property is used for making the status of the to-do item human
    readable in the view.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatusText`属性用于使待办事项的状态在视图中可读。'
- en: Creating the ItemViewModel
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ItemViewModel
- en: 'The `ItemViewModel` represents the to-do list item in a view that can be used
    to create new items and to edit existing items:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemViewModel`表示待办事项列表中的项目，可用于创建新项目和编辑现有项目的视图：'
- en: In the `ViewModels` folder, create a class called `ItemViewModel`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewModels`文件夹中，创建一个名为`ItemViewModel`的类。
- en: 'Add the code as following:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码添加代码：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The pattern is the same as for the previous two `ViewModels`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 模式与前两个`ViewModels`相同：
- en: We use dependency injection to pass the `TodoItemRepository` into the `ViewModel`
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用依赖注入将`TodoItemRepository`传递给`ViewModel`
- en: We use inheritance from the `ViewModel` base class to add the common features
    defined by the base class
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用从`ViewModel`基类继承来添加基类定义的公共功能
- en: Creating the MainView
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MainView
- en: 'Now that we are done with the `ViewModels`, let''s create the skeleton code
    and the XAML needed for the views. The first view that we are going to create
    is the `MainView`, which is the view that will be loaded first:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`ViewModels`，让我们创建视图所需的骨架代码和XAML。我们要创建的第一个视图是`MainView`，这是将首先加载的视图：
- en: Create a folder named `Views` in the .NET Standard library.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET Standard库中创建一个名为`Views`的文件夹。
- en: Right-click the `Views` folder, select Add, and then click New Item....
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`Views`文件夹，选择添加，然后单击新建项....
- en: Select Xamarin.Forms under the Visual C# Items node on the left.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的Visual C# Items节点下选择Xamarin.Forms。
- en: SelectContent Page and name it `MainView`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Content Page并将其命名为`MainView`。
- en: 'Click Add to create the page:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击添加以创建页面：
- en: '![](img/675b96dd-3e2c-4935-afe2-cda0047cfcf9.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/675b96dd-3e2c-4935-afe2-cda0047cfcf9.png)'
- en: 'Let''s add some content to the newly created view:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向新创建的视图添加一些内容：
- en: Open `MainView.xaml`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainView.xaml`。
- en: 'Remove all the template code below the `ContentPage` root node and add the
    XAML code marked in bold in the following code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`ContentPage`根节点下面的所有模板代码，并在以下代码中添加标记为粗体的XAML代码：
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To be able to access custom converters, we need to add a reference to a local
    namespace. The line  `defines this namespace for us. We will not be using it directly
    in this case, but it's a good idea to have a local namespace defined. If we create
    custom controls, we can then access these by writing something like `<local:MyControl
    />`.`
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够访问自定义转换器，我们需要添加对本地命名空间的引用。行`为我们定义了这个命名空间。在这种情况下，我们不会直接使用它，但定义本地命名空间是一个好主意。如果我们创建自定义控件，我们可以通过编写类似`<local:MyControl
    />`的方式来访问它们。
- en: The `Title` property on the `ContentPage` gives the page a title. Depending
    on the platform we are running on, the title is displayed differently. If we are
    using a standard navigation bar, it will be displayed at the top in both iOS and
    Android, for example. A page should always have a title.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentPage`上的`Title`属性为页面提供标题。根据我们运行的平台不同，标题的显示方式也不同。例如，如果我们使用标准导航栏，它将在iOS和Android的顶部显示。页面应该始终有一个标题。'
- en: The `ContentPage.Toolbar` node defines a toolbar item for adding new to-do items.
    It will also be rendered differently based on the platform, but it will always
    follow the platform-specific UI guidelines.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentPage.Toolbar`节点定义了一个工具栏项，用于添加新的待办事项。它也会根据平台的不同而呈现不同的样式，但它始终遵循特定于平台的UI指南。'
- en: A page in Xamarin.Forms (and also an XML document in general) can only have
    one root node. The root node in a Xamarin.Forms page will populate the `Content`
    property of the page itself. Since we want our `MainView` to contain a list of
    items and a button at the top to toggle a filter (to switch between all items
    and only active items), we need to add a `Layout` control to position them on
    the page. The `Grid` is a control that allows you to partition the available space
    based on rows and columns.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms页面（以及一般的XML文档）只能有一个根节点。Xamarin.Forms页面中的根节点将填充页面本身的`Content`属性。由于我们希望我们的`MainView`包含一个项目列表和页面顶部的按钮来切换过滤器（在所有项目和仅活动项目之间切换），我们需要添加一个`Layout`控件来定位它们在页面上的位置。`Grid`是一个控件，允许您根据行和列来划分可用空间。
- en: For our `MainView`, we want to add two rows. The first row is a space calculated
    by the height of the button (`Height="auto"`) and the second row takes up all
    of the remaining available space for the `Listview` (`Height="*"`). Elements,
    like the `ListView`, are positioned in the grid using the `Grid.Row` and `Grid.Column`
    attributes. Both of these properties default to `0` if they are not specified, just
    like the `Button`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`MainView`，我们想要添加两行。第一行是由按钮的高度计算出的空间（`Height="auto"`），第二行占用所有剩余的可用空间用于`Listview`（`Height="*"`）。像`ListView`这样的元素是使用`Grid.Row`和`Grid.Column`属性在网格中定位的。如果未指定这些属性，这两个属性都默认为`0`，就像`Button`一样。
- en: If you are interested in how the `Grid` works, you should search for more information
    about Xamarin.Forms `Grid` on the internet or study the official documentation
    at [https://docs.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/layouts/grid](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/layouts/grid).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对`Grid`的工作原理感兴趣，您应该在互联网上搜索有关Xamarin.Forms `Grid`的更多信息，或者学习官方文档[https://docs.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/layouts/grid](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/layouts/grid)。
- en: 'We also need to wire up the `ViewModel` to the view. This can be done by passing
    the `ViewModel` in the constructor of the view:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将`ViewModel`与视图连接起来。这可以通过在视图的构造函数中传递`ViewModel`来完成：
- en: Open up the code-behind file of the `MainView` by expanding the `MainView.xaml`
    file in the Solution Explorer.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过展开解决方案资源管理器中的`MainView.xaml`文件，打开`MainView`的代码后文件。
- en: Add a <q>using </q>`DoToo.ViewModels` statement at the top of the following
    file the existing `using` statements.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下文件的顶部添加`using DoToo.ViewModels`语句，以及现有的`using`语句。
- en: 'Modify the constructor of the class to look like the following code by adding
    the code marked in bold:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加下面代码中标记为粗体的代码，修改类的构造函数如下：
- en: '[PRE22]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We follow the same pattern as we did with the `ViewModels` by passing any dependencies
    through the constructor. A view is always dependent on a `ViewModel`. To simplify
    the project, we also assign the `Navigation` property of the page directly to
    the `Navigation` property defined in the `ViewModel` base class. In a larger project,
    we might want to abstract this property as well, to make sure that we separate
    the `ViewModels` completely from Xamarin.Forms. For the sake of this app, however,
    it is OK to reference it directly.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过与`ViewModels`相同的模式，通过构造函数传递任何依赖项来实现。视图始终依赖于`ViewModel`。为了简化项目，我们还将页面的`Navigation`属性直接分配给`ViewModel`基类中定义的`Navigation`属性。在较大的项目中，我们可能还希望将此属性抽象化，以确保我们将`ViewModels`与Xamarin.Forms完全分离。但是，对于这个应用程序来说，直接引用它是可以的。
- en: Lastly, we assign the `ViewModel` to the `BindingContext` of the page. This
    tells the Xamarin.Forms binding engine to use our `ViewModel` for the bindings
    that we will create later on.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`ViewModel`分配给页面的`BindingContext`。这告诉Xamarin.Forms绑定引擎使用我们的`ViewModel`来创建后续的绑定。
- en: Creating the ItemView
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ItemView
- en: 'Next up is the second view. We will use this for adding and editing to-do list
    items:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是第二个视图。我们将用它来添加和编辑待办事项列表项：
- en: Create a new Content Page (the same way as we created the `MainView`) and name
    it `ItemView`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Content Page（与我们创建`MainView`的方式相同），并将其命名为`ItemView`。
- en: 'Edit the XAML and make it look like the following code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑XAML，并使其看起来像以下代码：
- en: '[PRE23]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As with the `MainView`, we need a title. We will give it a default title of `"New
    todo item"` for now, but we will change this to `"Edit todo item"` when we reuse
    this view for editing later on. The user must be able to save a new or edited
    item, so we have added a toolbar save button. The content of the page uses a `StackLayout`
    to structure the controls. A `StackLayout` adds an element vertically (the default
    option) or horizontally based on the space it calculates that the element takes
    up. This is a CPU-intensive process, so we should only use it on small portions
    of our layout. In the `StackLayout`, we add a `Label` that will be a line of text
    over the `Entry` control that comes underneath it. The `Entry` control is a text
    input control that will contain the name of the to-do list item. We then have
    a section for a `DatePicker`, where the user can select a due date for the to-do
    list item. The final control is a `Switch` control, which renders a toggle button
    to control when an item is completed, and a heading next to that. Since we want
    these to be displayed next to each other horizontally, we use a horizontal `StackLayout`
    to do this.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 与`MainView`一样，我们需要一个标题。我们现在将为其提供一个默认标题`"New todo item"`，但以后当我们重用此视图进行编辑时，我们将将其更改为`"Edit
    todo item"`。用户必须能够保存新的或编辑后的项目，因此我们添加了一个工具栏保存按钮。页面的内容使用`StackLayout`来组织控件。`StackLayout`根据它计算出的元素占用的空间，垂直（默认选项）或水平地添加元素。这是一个CPU密集型的过程，因此我们应该只在布局的小部分上使用它。在`StackLayout`中，我们添加一个`Label`，它将是`Entry`控件下面的一行文本。`Entry`控件是一个文本输入控件，将包含待办事项列表项的名称。然后我们有一个`DatePicker`的部分，用户可以在其中选择待办事项的截止日期。最后一个控件是一个`Switch`控件，它呈现一个切换按钮来控制项目何时完成，并在其旁边有一个标题。由于我们希望这些控件在水平方向上显示在一起，因此我们使用水平`StackLayout`来实现这一点。
- en: 'The last step for the views is to wire up the `ItemViewModel` to the `ItemView`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的最后一步是将`ItemViewModel`连接到`ItemView`：
- en: Open up the code-behind file of the `ItemView` by expanding the `ItemView.xaml` file
    in the Solution Explorer.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过展开解决方案资源管理器中的`ItemView.xaml`文件来打开`ItemView`的代码文件。
- en: Modify the constructor of the class to look like the following code. Add the
    code that is marked in bold.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类的构造函数，使其看起来像以下代码。添加粗体标记的代码。
- en: 'Add a using `DoToo.ViewModels` statement at the top of the following file the
    existing `using` statements:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有的`using`语句下面的文件顶部添加`DoToo.ViewModels`语句：
- en: '[PRE24]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code is identical to the code that we added for `MainView`, except for
    the type of the `ViewModel`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们为`MainView`添加的代码相同，只是`ViewModel`的类型不同。
- en: Wiring up a dependency injection through Autofac
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Autofac进行依赖注入的连接
- en: 'Earlier, we discussed the dependency injection pattern, which states that all
    dependencies, such as the repositories and view models, must be passed through
    the constructor of the class. This has several benefits:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们讨论了依赖注入模式，该模式规定所有依赖项（例如存储库和视图模型）必须通过类的构造函数传递。这有几个好处：
- en: It increases the readability of the code, since we can quickly determine all
    external dependencies
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它增加了代码的可读性，因为我们可以快速确定所有外部依赖关系
- en: It makes dependency injection possible
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使依赖注入成为可能
- en: It makes unit testing possible by mocking classes
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过模拟类使单元测试成为可能
- en: We can control the lifetime of an object by specifying whether it should be
    a singleton or a new instance for each resolution
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过指定对象是单例还是每次解析都是一个新实例来控制对象的生命周期
- en: Dependency injection is a pattern that lets us determine at runtime which instance
    of an object should be passed to a constructor when an object is created. We do
    this by defining a container where we register all the types of a class. We let
    the framework that we are using resolve any dependencies between them. Let's say
    that we ask the container for a `MainView`. The container takes care of resolving
    the `MainViewModel` and any dependencies that the class has.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种模式，它让我们能够在运行时确定在创建对象时应将对象的哪个实例传递给构造函数。我们通过定义一个容器来注册所有类的类型来实现这一点。我们让我们正在使用的框架解析它们之间的任何依赖关系。假设我们要求容器提供`MainView`。容器负责解析`MainViewModel`和类之间的任何依赖关系。
- en: To set this up, we need to reference a library called Autofac. There are other
    options out there, so feel free to switch to one that better fits your needs.
    We also need an entry point to resolve the types into instances. To do this, we
    will define a bare-bones `Resolver` class. To wrap it all up, we need a bootstrapper
    that we will call to initialize the dependency injection configuration.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置这一点，我们需要引用一个名为Autofac的库。还有其他选择，所以请随意切换到更适合您需求的选项。我们还需要一个入口点来将类型解析为实例。为此，我们将定义一个基本的`Resolver`类。为了将所有内容包装起来，我们需要一个引导程序，我们将调用它来初始化依赖注入配置。
- en: Adding a reference to Autofac
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Autofac添加引用
- en: 'We need a reference to Autofac to get started. We will use NuGet to install
    the packages needed:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要引用Autofac才能开始。我们将使用NuGet来安装所需的软件包：
- en: Open up the NuGet-manager by right-clicking on the Solution node and clicking
    on Manage NuGet packages for solution....
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击解决方案节点并单击“管理解决方案的NuGet软件包”来打开NuGet管理器。
- en: Click on Browse and type `autofac` in the search box.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击浏览，然后在搜索框中键入`autofac`。
- en: 'Tick all checkboxes under Project, scroll down, and click Install:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目下的所有复选框中打勾，然后向下滚动，单击安装：
- en: '![](img/2454a7ee-4123-4a08-8ddf-e7dcc11be688.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2454a7ee-4123-4a08-8ddf-e7dcc11be688.png)'
- en: Creating the resolver
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建解析器
- en: 'The resolver will be responsible for creating our objects for us based on the
    type that we request. Let''s create the resolver:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器将负责根据我们请求的类型为我们创建对象。让我们创建解析器：
- en: In the root of the .NET Standard library project, create a new file called `Resolver.cs`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET Standard库项目的根目录中，创建一个名为`Resolver.cs`的新文件。
- en: 'Add the following code to the file:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到文件中：
- en: '[PRE25]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `container` property of the `IContainer` type is defined in `Autofac` and
    represents a container that holds the configuration on how to resolve types. The
    `Initialize` method takes an instance of an object that implements the `IContainer` interface
    and assigns it to the `container` property. The `Resolve` method uses the `container`
    to resolve a type to an instance of an object. While it might seem strange to
    use this at first, it will become much easier with experience.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`IContainer`类型的`container`属性在`Autofac`中定义，并表示一个保存如何解析类型的配置的容器。`Initialize`方法接受实现`IContainer`接口的对象的实例，并将其分配给`container`属性。`Resolve`方法使用`container`将类型解析为对象的实例。虽然一开始可能会觉得奇怪使用这个，但随着经验的增加，它会变得更容易。'
- en: Creating the bootstrapper
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建bootstrapper
- en: 'The bootstrapper''s responsibility is to initialize Autofac. It will be called
    at the startup of the application. We can create it as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: bootstrapper的责任是初始化Autofac。它将在应用程序启动时被调用。我们可以按以下方式创建它：
- en: In the root of the .NET Standard library project, create a new file called `Bootstrapper.cs`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET Standard库的根目录中，创建一个名为`Bootstrapper.cs`的新文件。
- en: 'Enter the following code:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码：
- en: '[PRE26]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `Bootstrapper` will be inherited by each platform since this is where the
    execution of the app begins. This will also give us the option to add platform-specific
    configurations. To ensure that we inherit from the class, we define it as abstract.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bootstrapper`将被每个平台继承，因为这是应用程序执行的起点。这也给了我们添加特定于平台的配置的选项。为了确保我们从该类继承，我们将其定义为抽象的。'
- en: The `ContainerBuilder` is a class defined in `Autofac` that takes care of creating
    the `container` for us after we are finished with the configuration. The building
    of the `container` happens in the `FinishInitialization` method defined at the
    end and is called by the constructor right after we call the virtual `Initialize`
    method. We can override the `Initialize` method to add custom registrations on
    each platform.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContainerBuilder`是在`Autofac`中定义的一个类，它在我们完成配置后负责为我们创建`container`。`container`的构建发生在最后定义的`FinishInitialization`方法中，并且在构造函数调用虚拟的`Initialize`方法后立即调用。我们可以重写`Initialize`方法在每个平台上添加自定义注册。'
- en: The `Initialize` method scans the assembly for any types that inherit from the `Page`
    or `ViewModel` and adds them to the `container`. It also adds the `TodoItemRepository`
    as a singleton to the `container`. This means that each time we ask for a `TodoItemRepository`,
    we will get the same instance. The default behavior for Autofac (this may vary
    between libraries) is that we get a new instance for each resolution.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`Initialize`方法扫描程序集中从`Page`或`ViewModel`继承的任何类型，并将它们添加到`container`中。它还将`TodoItemRepository`作为单例添加到`container`中。这意味着每次我们请求`TodoItemRepository`时，我们将获得相同的实例。Autofac的默认行为（这可能在不同的库之间有所不同）是每次解析时获得一个新实例。'
- en: Adding a bootstrapper on iOS
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在iOS上添加bootstrapper
- en: 'The `Bootstrapper` for iOS is a simple wrapper for the common bootstrapper
    defined in the .NET Standard library, but with the addition of an `Init` method
    that will be called at startup:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: iOS的`Bootstrapper`是.NET Standard库中通用bootstrapper的简单包装器，但增加了一个`Init`方法，在启动时将被调用：
- en: In the root of the iOS project, create a new class called `Bootstrapper.cs`.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在iOS项目的根目录中，创建一个名为`Bootstrapper.cs`的新类。
- en: 'Add the following code to it:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其中添加以下代码：
- en: '[PRE27]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `Init` method may look strange since we don't retain a reference to the
    instance we create. Keep in mind, however, that we do keep a reference to a `Resolver`
    instance inside the `Resolver` class, which is itself a singleton.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`Init`方法可能看起来很奇怪，因为我们没有保留对我们创建的实例的引用。但请记住，我们确实在`Resolver`类内部保留对`Resolver`实例的引用，而`Resolver`本身是一个单例。'
- en: 'The final step for iOS is to call this `Init` method in the right place:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: iOS的最后一步是在正确的位置调用`Init`方法：
- en: Open up `AppDelegate.cs`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AppDelegate.cs`。
- en: 'Locate the `FinishedLaunching` method and add the code in bold:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`FinishedLaunching`方法并添加粗体代码：
- en: '[PRE28]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Adding a bootstrapper in Android
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android中添加bootstrapper
- en: 'Just like for iOS, the `Bootstrapper` for Android is a simple wrapper for the
    common bootstrapper defined in the .NET Standard library, but with the addition
    of an `Init` method that will be called at startup:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 与iOS一样，Android的`Bootstrapper`是.NET Standard库中通用bootstrapper的简单包装器，但增加了一个在启动时将被调用的`Init`方法：
- en: In the root of the Android project, create a new class called `Bootstrapper.cs`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android项目的根目录中，创建一个名为`Bootstrapper.cs`的新类。
- en: 'Add the following code to it:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其中添加以下代码：
- en: '[PRE29]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then need to call this `Init` method. A good place to do this is right before
    the `LoadApplication` call in `OnCreate`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要调用这个`Init`方法。在`OnCreate`中调用`LoadApplication`之前做这件事是一个好地方：
- en: Open up `MainActivity.cs`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.cs`。
- en: 'Locate the `OnCreate` method and add the code in bold:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`OnCreate`方法并添加粗体代码：
- en: '[PRE30]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Adding a bootstrapper in UWP
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在UWP中添加bootstrapper
- en: 'The bootstrapper for UWP is identical to the other platforms:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: UWP的bootstrapper与其他平台相同：
- en: In the root of the UWP project, create a new class called `Bootstrapper.cs`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UWP项目的根目录中，创建一个名为`Bootstrapper.cs`的新类。
- en: 'Add the following code to it:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其中添加以下代码：
- en: '[PRE31]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And as with the other platforms, we need to call the `Init` method in a good
    place:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他平台一样，我们需要在适当的位置调用`Init`方法：
- en: In the UWP project, open up the `App.xaml.cs` file.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UWP项目中，打开`App.xaml.cs`文件。
- en: 'Locate the call to the `Xamarin.Forms.Forms.Init()`method and add the code
    in bold:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到对`Xamarin.Forms.Forms.Init()`方法的调用，并添加粗体代码：
- en: '[PRE32]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Making the app run
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使应用程序运行
- en: 'We can start the app for the first time as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式首次启动应用程序：
- en: Open up `App.xaml.cs` by expanding the `App.xaml` node in the .NET Standard
    library.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过展开.NET Standard库中的`App.xaml`节点，打开`App.xaml.cs`。
- en: Locate the constructor.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到构造函数。
- en: 'Add a `using` statement for `DoToo.Views` and add the following code line in
    bold:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`using`语句以使用`DoToo.Views`，并添加以下粗体代码行：
- en: '[PRE33]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The line added resolves the `MainView` (and all dependencies, including `MainViewModel`
    and the `TodoItemRepository`) and wraps it into a `NavigationPage`. The `NavigationPage`
    is a page defined in Xamarin.Forms that adds a navigation bar and enables the
    user to navigate to other views.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的行解决了`MainView`（以及所有依赖项，包括`MainViewModel`和`TodoItemRepository`）并将其包装成`NavigationPage`。`NavigationPage`是Xamarin.Forms中定义的一个页面，它添加了导航栏并允许用户导航到其他视图。
- en: 'That''s it! At this point, your project should start. Depending on the platform
    you are using, it might look like the following screenshot:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！此时，您的项目应该启动。根据您使用的平台不同，它可能看起来像下面的截图：
- en: '![](img/4adb68f9-ea33-467f-96c3-1a0bc8c7c3f7.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4adb68f9-ea33-467f-96c3-1a0bc8c7c3f7.png)'
- en: Adding data bindings
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加数据绑定
- en: 'Data binding is the heart and soul of MVVM. This is the way that the `Views` and
    the `ViewModel` communicate with each other. In Xamarin.Forms, we need two things
    to make data binding happen:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定是MVVM的核心。这是`Views`和`ViewModel`相互通信的方式。在Xamarin.Forms中，我们需要两样东西来实现数据绑定：
- en: We need an object to implement `INotifyPropertyChanged`.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个对象来实现`INotifyPropertyChanged`。
- en: We need to set the `BindingContext` of the page to that object. We already do
    this on both the `ItemView` and the `MainView`.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将页面的`BindingContext`设置为该对象。我们已经在`ItemView`和`MainView`上都这样做了。
- en: 'A really useful feature of data binding is that it allows us to use two-way
    communication. For example, when data binding text to an `Entry` control, the
    property on the data-bound object will be updated directly. Consider the following
    XAML:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定的一个非常有用的特性是它允许我们进行双向通信。例如，当将文本绑定到`Entry`控件时，数据绑定对象上的属性将直接更新。考虑以下XAML：
- en: '[PRE34]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To make this work, we need a property named `Title` on the object that is a
    string. We have to look at the documentation, define an object, and let **Intellisense**
    provide us with a hint to find out what type our property should be.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，我们需要在对象上有一个名为`Title`的字符串属性。我们必须查看文档，定义一个对象，并让**Intellisense**为我们提供提示，以找出我们的属性应该是什么类型。
- en: Controls that perform some kind of action, like a `Button`, usually expose a
    property called `Command`. This property is of the `ICommand` type and we can
    either return a `Xamarin.Forms.Command` or an implementation of our own. The `Command`
    property is explained in the next section, where we will use it to navigate to
    the `ItemView`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 执行某种操作的控件，比如`Button`，通常会公开一个名为`Command`的属性。这个属性是`ICommand`类型的，我们可以返回一个`Xamarin.Forms.Command`或我们自己的实现。`Command`属性将在下一节中解释，我们将使用它来导航到`ItemView`。
- en: Navigating from the MainView to the ItemView to add a new item
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从`MainView`导航到`ItemView`以添加新项目
- en: 'We have an Addtoolbar button in the `MainView`. When the user taps this button,
    we want to navigate to the `ItemView`. The MVVM way to do this is to define a
    command and then bind that command to the button. Let''s add the code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainView`中有一个`Addtoolbar`按钮。当用户点击此按钮时，我们希望导航到`ItemView`。这样做的MVVM方式是定义一个命令，然后将该命令绑定到按钮。让我们添加代码：
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewModels/MainViewModel.cs`。
- en: Add `using` statements for `System.Windows.Input`, `DoToo.Views`,and `Xamarin.Forms`.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`System.Windows.Input`，`DoToo.Views`和`Xamarin.Forms`添加`using`语句。
- en: 'Add the following property to the class:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到类中：
- en: '[PRE35]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All commands should be exposed as a generic `ICommand`. This abstracts the actual
    command implementation, which is a good general practice to follow. The command
    must be a property; in our case, we are creating a new `Command` object that we
    assign to this property. The property is read-only, which is usually fine for
    a `Command`. The action of the command (the code that we want to run when the
    command is executed) is passed to the constructor of the `Command` object.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命令都应公开为通用的`ICommand`。这样可以抽象出实际的命令实现，这是一个很好的一般实践。命令必须是一个属性；在我们的情况下，我们正在创建一个新的`Command`对象，然后将其分配给这个属性。该属性是只读的，对于`Command`来说通常是可以的。命令的操作（当执行命令时要运行的代码）被传递给`Command`对象的构造函数。
- en: The action of the command creates a new `ItemView` through the `Resolver` and
    Autofac builds the necessary dependencies. Once the new `ItemView` has been created,
    we simply tell the `Navigation` service to push it onto the stack for us.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的操作通过`Resolver`创建一个新的`ItemView`，并且Autofac构建必要的依赖项。一旦创建了新的`ItemView`，我们只需告诉`Navigation`服务为我们将其推送到堆栈上。
- en: 'After that, we just have to wire up the `AddItem`command from the `ViewModel`
    to the add button in the view:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们只需将`ViewModel`中的`AddItem`命令与视图中的添加按钮连接起来：
- en: Open `Views/MainView.xaml`.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Views/MainView.xaml`。
- en: 'Add the `Command` attribute to the `ToolbarItem`:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`ToolbarItem`添加`Command`属性：
- en: '[PRE36]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run the app and tap the Add button to navigate to the new item view. Notice
    that the back button appears automatically.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并点击“添加”按钮以导航到新项目视图。请注意，返回按钮会自动出现。
- en: Adding new items to the list
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向列表中添加新项目
- en: 'We have now finished adding the navigation to a new item. Let''s now add the
    code needed to create a new item and save it to the database:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了导航到新项目的添加。现在让我们添加所需的代码来创建一个新项目并将其保存到数据库中：
- en: Open up `ViewModels/ItemViewModel.cs`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewModels/ItemViewModel.cs`。
- en: Add the following code in bold.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在粗体中添加以下代码。
- en: 'Resolve the reference to `System.Windows.Input`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决对`System.Windows.Input`的引用：
- en: '[PRE37]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `Item` property holds a reference to the current item that we want to add
    or edit. A new item is created in the constructor and when we want to edit an
    item, we can simply assign our own item to this property. The new item is not
    added to the database unless we execute the `Save` command defined at the end.
    After the item is added or updated, we remove the view from the navigation stack
    and return to the `MainView` again.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item`属性保存对我们要添加或编辑的当前项目的引用。在构造函数中创建一个新项目，当我们想要编辑一个项目时，我们可以简单地将我们自己的项目分配给这个属性。除非我们执行最后定义的`Save`命令，否则新项目不会添加到数据库中。项目添加或更新后，我们将视图从导航堆栈中移除，并再次返回到`MainView`。'
- en: Since the navigation keeps pages in a stack, the framework declares methods
    that reflect operations that you can perform on a stack. The operation of removing
    the topmost item in a stack is known as **popping the stack**, so instead of `RemoveAsync()`,
    we have `PopAsync()`. To add a page to the navigation stack, we push it, so that
    method is called `PushAsync()`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由于导航将页面保留在堆栈中，框架声明了反映可以在堆栈上执行的操作的方法。从堆栈中移除顶部项目的操作称为**弹出堆栈**，因此我们有`PopAsync()`而不是`RemoveAsync()`。要将页面添加到导航堆栈中，我们将其推送，因此该方法称为`PushAsync()`。
- en: 'Now that we have extended the `ItemViewModel` with the necessary commands and
    properties, it''s time to data-bind them in the XAML:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用必要的命令和属性扩展了`ItemViewModel`，是时候在XAML中对它们进行数据绑定了：
- en: Open `ViewModels/ItemView.xaml`.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewModels/ItemView.xaml`。
- en: 'Add the code marked in bold:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加粗体标记的代码：
- en: '[PRE38]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The binding to the `ToolbarItems` command attribute triggers the `Save` command
    exposed by the `ItemViewModel` when a user taps the `Save` link. It's worth nothing
    again that any attribute called `Command` indicates that an action will take place
    and that we must bind it to an instance of an object implementing the `ICommand`
    interface.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 对`ToolbarItems`命令属性的绑定会在用户点击`Save`链接时触发`ItemViewModel`公开的`Save`命令。值得再次注意的是，任何名为`Command`的属性都表示将发生某种操作，我们必须将其绑定到实现`ICommand`接口的对象的实例。
- en: The `Entry` control that represents the title is data-bound to the `Item.Title`
    property of the `ItemViewModel`, and the `Datepicker` and `Switch` control bind
    in a similar way to their respective properties.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 代表标题的`Entry`控件被数据绑定到`ItemViewModel`的`Item.Title`属性，`Datepicker`和`Switch`控件以类似的方式绑定到它们各自的属性。
- en: We could have exposed  `Title`, `Due`, and `Complete` as properties directly
    on the `ItemViewModel`, but chose to reuse the already existing `TodoItem` as
    a reference. This is fine, as long as the properties of the `TodoItem` object
    implement the `INotifyPropertyChange` interface.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以直接在`ItemViewModel`上公开`Title`、`Due`和`Complete`作为属性，但选择重用已经存在的`TodoItem`作为引用。只要`TodoItem`对象的属性实现了`INotifyPropertyChange`接口，这是可以的。
- en: Binding the ListView in the MainView
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MainView中绑定ListView
- en: 'A to-do list is not much use without a list of items. Let''s extend the `MainViewModel`
    with a list of items:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 没有项目列表的待办事项列表没有多大用处。让我们用项目列表扩展`MainViewModel`：
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewModels/MainViewModel.cs`。
- en: Add `using` statements for `System.Collections.ObjectModel` and `System.Linq`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`System.Collections.ObjectModel`和`System.Linq`的`using`语句。
- en: 'Add a property for the to-do list items:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为待办事项列表项添加一个属性：
- en: '[PRE39]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: An `ObservableCollection` is like an ordinary collection, but it has a useful
    superpower. It can notify listeners about changes in the list, such as when `items`
    are added or deleted. The `Listview` will listen to changes in the list and update
    itself automatically based on these.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObservableCollection`就像普通集合，但它有一个有用的超能力。它可以通知监听器列表中的更改，例如添加或删除`items`。`Listview`将侦听列表中的更改，并根据这些更改自动更新自身。'
- en: 'We now need some data:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一些数据：
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewModels/MainViewModel.cs`。
- en: Replace (or complete) the `LoadData` method and create the `CreateTodoItemViewModel`
    and `ItemStatusChanged` methods.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换（或完成）`LoadData`方法，并创建`CreateTodoItemViewModel`和`ItemStatusChanged`方法。
- en: 'Resolve the reference to `DoToo.Models` by adding a `using` statement:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加`using`语句解析对`DoToo.Models`的引用：
- en: '[PRE40]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `LoadData` method calls the repository to fetch all items. We then wrap
    each to-do list item in the `TodoItemViewModel`. This will contain more information
    that is specific to the view and that we don't want to add to the `TodoItem` class.
    It is a good practice to wrap plain objects in a `ViewModel`; this makes it simpler
    to add actions or extra properties to it. The `ItemStatusChanged` is a stub that
    will be called when we change the status of the to-do list item from *active*
    to *completed* and vice versa.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadData`方法调用存储库以获取所有项目。然后我们将每个待办事项包装在`TodoItemViewModel`中。这将包含特定于视图的更多信息，我们不希望将其添加到`TodoItem`类中。将普通对象包装在`ViewModel`中是一个很好的做法；这样可以更简单地向其添加操作或额外的属性。`ItemStatusChanged`是一个存根，当我们将待办事项的状态从*活动*更改为*已完成*或反之时将调用它。'
- en: 'We also need to hook up some events from the repository to know when data changes:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要连接一些来自存储库的事件，以了解数据何时发生变化：
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewModels/MainViewModel.cs`。
- en: 'Add the following code in bold:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下粗体代码：
- en: '[PRE41]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When an item is added to the repository, no matter who added it, the `MainView`
    will add it to the items list. Since the items collection is an observable collection,
    the list will update. If an item gets updated, we simply reload the list.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目添加到存储库时，无论是谁添加的，`MainView`都会将其添加到项目列表中。由于项目集合是可观察集合，列表将会更新。如果项目得到更新，我们只需重新加载列表。
- en: 'Let''s data-bind our items to the `ListView`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的项目数据绑定到`ListView`：
- en: Open up `MainView.xaml` and locate the `ListView` element.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainView.xaml`并找到`ListView`元素。
- en: 'Modify it to reflect the following code:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改以反映以下代码：
- en: '[PRE42]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `ItemsSource` binding tells the `ListView` where to find the collection
    to iterate over and is local to the `ViewModel`. Any bindings inside the `ViewCell`
    node, however, are local to each item that we iterate in the list. In this case,
    we are binding to the `TodoItemViewModel`, which contains a property named `Item`.
    This, in turn, has properties such as `Title`, `Due`, and `Completed`. We can
    navigate down the hierarchy of objects without any problem when defining a binding.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemsSource`绑定告诉`ListView`在哪里找到要迭代的集合，并且是本地的`ViewModel`。然而，在`ViewCell`节点内部的任何绑定都是针对我们在列表中迭代的每个项目的本地绑定。在这种情况下，我们绑定到`TodoItemViewModel`，其中包含名为`Item`的属性。这又有诸如`Title`、`Due`和`Completed`之类的属性。在定义绑定时，我们可以毫无问题地导航到对象的层次结构。'
- en: The `DataTemplate` defined what each row will look like. We use a grid to partition
    the space just like we did earlier.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataTemplate`定义了每一行的外观。我们使用网格来分割空间，就像我们之前做的那样。'
- en: Creating a ValueConverter for the item status
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为项目状态创建一个ValueConverter
- en: 'Sometimes, we want to bind to objects that are a representation of the original
    value. This could be a piece of text that is based on a Boolean value. Instead
    of *true* and *false*, for example, we might want to write *Yes* and *No*, or
    return a color. This is where `ValueConverter` comes in handy. It can be used
    to convert a value to and from another value. We are going to write a `ValueConverter`
    that converts the status of a to-do list item to a color:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望绑定到原始值的表示对象。这可能是基于布尔值的文本片段。例如，我们可能希望写*Yes*和*No*，或者返回一个颜色，而不是*true*和*false*。这就是`ValueConverter`派上用场的地方。它可以用于将一个值转换为另一个值。我们将编写一个`ValueConverter`，将待办事项的状态转换为颜色：
- en: In the root of the .NET Standard library project, create a folder called `Converters`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET Standard库项目的根目录下，创建一个名为`Converters`的文件夹。
- en: 'Create a class called `StatusColorConverter.cs` and add the following code:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`StatusColorConverter.cs`的类，并添加以下代码：
- en: '[PRE43]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: A `ValueConverter` is a class that implements `IValueConverter`. This, in turn, only
    has two methods defined. The `Convert` method is called when the view reads data
    from the `ViewModel`, and the `ConvertBack` method is used when the `ViewModel`
    gets data from the view. The `ConvertBack` method is only used for controls that
    return data from plain text, such as the `Entry` control.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueConverter`是实现`IValueConverter`的类。这只有两个方法被定义。当视图从`ViewModel`读取数据时，将调用`Convert`方法，而当`ViewModel`从视图获取数据时，将使用`ConvertBack`方法。`ConvertBack`方法仅用于从纯文本返回数据的控件，例如`Entry`控件。'
- en: 'If we look at the implementation of the `Convert` method, we notice that any
    value passed into the method is of the object type. This is because we don''t
    know what type the user has bound to the property to which we are adding this
    `ValueConverter`. We may also notice that we fetch colors from a resource file.
    We could have defined the colors in the code, but this is not recommended, so
    instead, we went the extra mile and added them as a global resource in the `App.xaml`
    file. Resources are a good thing to take another look at once we''ve finished
    with the chapter:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`Convert`方法的实现，我们会注意到传递给该方法的任何值都是对象类型。这是因为我们不知道用户将什么类型绑定到我们正在添加`ValueConverter`的属性。我们还可能注意到，我们从资源文件中获取颜色。我们本可以在代码中定义颜色，但这是不推荐的，所以我们走了额外的路程，并将它们添加为`App.xaml`文件中的全局资源。资源是在完成本章后再次查看的好东西：
- en: Open `App.xaml` in the .NET Standard library project.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET Standard库项目中打开`App.xaml`。
- en: 'Add the following `ResourceDictionary`:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`ResourceDictionary`：
- en: '[PRE44]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: A `ResourceDictionary` can define a wide range of different objects. We settle
    for the two colors that we want to access from the `ValueConverter`. Notice that
    these are accessible by the key given to them and they can also be accessed from
    any other XAML file using a static resource binding. The `ValueConverter` itself
    will be referenced as a static resource, but from a local scope.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceDictionary`可以定义各种不同的对象。我们只需要两种颜色，这两种颜色可以从`ValueConverter`中访问。请注意，这些可以通过给定的键访问，并且还可以使用静态资源绑定从任何其他XAML文件中访问。`ValueConverter`本身将被引用为静态资源，但来自本地范围。'
- en: Using the ValueConverter
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ValueConverter
- en: 'We want to use our brand new `StatusColorConverter` in the `MainView`. Unfortunately,
    we have to jump through some hoops to make this happen. We need to do three things:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要在`MainView`中使用我们全新的`StatusColorConverter`。不幸的是，我们必须经过一些步骤才能实现这一点。我们需要做三件事：
- en: Define a namespace in XAML
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在XAML中定义命名空间
- en: Define a local resource that represents an instance of the converter
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个表示转换器实例的本地资源
- en: Declare in the binding that we want to use that converter
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在绑定中声明我们要使用该转换器
- en: 'Let''s start with the namespace:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从命名空间开始：
- en: Open `Views/MainView.xaml`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Views/MainView.xaml`。
- en: 'Add the following namespace to the page:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面中添加以下命名空间：
- en: '[PRE45]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add a `Resource` node to the `MainView.xaml` file:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainView.xaml`文件中添加`Resource`节点：
- en: Open Views/MainView.Xaml.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Views/MainView.Xaml。
- en: 'Add the following `ResourceDictionary`, shown in bold under the root element
    of the XAML file:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在XAML文件的根元素下添加以下`ResourceDictionary`，显示为粗体：
- en: '[PRE46]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This has the same form as the global resource dictionary, but since this one
    is defined in the `MainView`, it will only be accessible from there. We could
    have defined this in the global resource dictionary, but it's usually best to
    define objects that you only consume in one place as close to that place as possible.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这与全局资源字典具有相同的形式，但由于这个资源字典是在`MainView`中定义的，因此只能从那里访问。我们本可以在全局资源字典中定义这个，但通常最好将只在一个地方使用的对象定义在尽可能接近该位置的地方。
- en: 'The last step is to add the converter:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是添加转换器：
- en: Locate the `BoxView` node in the XAML.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在XAML中找到`BoxView`节点。
- en: 'Add the `BackgroundColor` XAML, which is marked in bold:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加粗体标记的`BackgroundColor` XAML：
- en: '[PRE47]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What we have done here is bound a Boolean value to a property that takes a `Color`
    object. Right before the data binding takes place, however, the `ValueConverter`
    converts the Boolean value to a color. This is just one of the many cases where
    a `ValueConverter` comes in handy. Keep this in mind when you are defining the
    GUI.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将一个布尔值绑定到一个接受`Color`对象的属性。然而，在数据绑定发生之前，`ValueConverter`将布尔值转换为颜色。这只是`ValueConverter`派上用场的许多情况之一。在定义GUI时请记住这一点。
- en: Navigating to an item using a command
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令导航到项目
- en: We want to be able to see the details for a selected to-do list item. When we
    tap a row, we should navigate to the item in that row.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够查看所选待办事项的详细信息。当我们点击一行时，我们应该导航到该行中的项目。
- en: 'To do this, we need to add the following code:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要添加以下代码：
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewModels/MainViewModel.cs`。
- en: 'Add the `SelectedItem` property and the `NavigateToItem`method to the class:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加`SelectedItem`属性和`NavigateToItem`方法：
- en: '[PRE48]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `SelectedItem` property is a property that we will data-bind to the `ListView`.
    When we select a row in the `ListView`, this property will be set to the `TodoItemViewModel`
    that represents that row. Since we can't really use Fody here to carry out its
    `PropertyChanged` magic, because of the need to do a method call in the setter,
    we need to go old-school and manually add a getter and a setter.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectedItem`属性是我们将数据绑定到`ListView`的属性。当我们在`ListView`中选择一行时，此属性将设置为表示该行的`TodoItemViewModel`。由于我们实际上不能在这里使用Fody来执行其`PropertyChanged`魔法，因为需要在setter中进行方法调用，所以我们需要老式地手动添加一个getter和一个setter。'
- en: The setter then calls `NavigateToItem`, which creates a new `ItemView` using
    the `Resolver`. We extract the `ViewModel` from the newly created `ItemView` and
    assign the current `TodoItem` that the `TodoItemViewModel` contains. Confused?
    Remember that the `TodoItemViewModel` actually wraps a `TodoItem` and it is that
    item that we want to pass to the `ItemView`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用`NavigateToItem`，它使用`Resolver`创建一个新的`ItemView`。我们从新创建的`ItemView`中提取`ViewModel`并分配`TodoItemViewModel`包含的当前`TodoItem`。困惑吗？请记住，`TodoItemViewModel`实际上包装了一个`TodoItem`，我们要传递的就是这个项目到`ItemView`。
- en: 'We are not done yet. We now need to data-bind the new `SelectedItem` property
    to the right place in the view:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成。现在我们需要将新的`SelectedItem`属性数据绑定到视图中的正确位置：
- en: Open `Views/MainView.xaml`.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Views/MainView.xaml`。
- en: 'Locate the `ListView` and add the attributes in bold:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`ListView`并添加以下属性：
- en: '[PRE49]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `SelectedItem` attribute binds the, `SelectedItem` property `ListView` to
    the `ViewModel` property. When the selection of an item in the `ListView` changes,
    the `ViewModels` `SelectedItem` property will be called and we will navigate to
    the new and exciting views.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectedItem`属性将`ListView`的`SelectedItem`属性绑定到`ViewModel`属性。当`ListView`中的项目选择发生变化时，`ViewModels`的`SelectedItem`属性将被调用，我们将导航到新的和令人兴奋的视图。'
- en: 'The `x:Name` attribute is for naming the `ListView`, because we do need to
    make a small and ugly hack to make this work. The `ListView` will actually stay
    selected after the navigation is done. When we navigate back, it cannot be selected
    again until we select another row. To mitigate this, we need to hook up to the
    `ItemSelected` event of `ListView` and reset the selected item directly on the
    `ListView`. This is not recommended, because we shouldn''t really have any logic
    in our `Views`, but sometimes we have no other choice:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`x:Name`属性用于命名`ListView`，因为我们确实需要进行一个小的丑陋的黑客来使其工作。导航完成后，`ListView`实际上将保持选定状态。当我们导航回来时，除非我们选择另一行，否则无法再次选择它。为了减轻这种情况，我们需要连接到`ListView`的`ItemSelected`事件，并直接重置`ListView`上的选定项目。这并不推荐，因为我们实际上不应该在我们的`Views`中有任何逻辑，但有时我们别无选择：'
- en: Open `Views/MainView.xaml.cs`.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Views/MainView.xaml.cs`。
- en: 'Add the following code in bold:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在粗体中添加以下代码：
- en: '[PRE50]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We should now be able to navigate to an item in the list.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够导航到列表中的项目。
- en: Marking an item as complete using a command
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令将项目标记为完成
- en: 'We need to add a functionality that allows us to toggle the items between *complete*
    and *active*. It is possible to navigate to the detailed view of the to-do list
    item, but this is too much work for a user. Instead, we''ll add a `ContextAction`
    to the `ListView`. In iOS, for example, this will be accessed by swiping left
    on a row:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个功能，允许我们在*完成*和*活动*之间切换项目。可以导航到待办事项列表项的详细视图，但这对用户来说太麻烦了。相反，我们将在`ListView`中添加一个`ContextAction`。例如，在iOS中，可以通过向左滑动一行来访问它：
- en: Open `ViewModel/TodoItemViewModel.cs`.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewModel/TodoItemViewModel.cs`。
- en: Add a `using` statement for `System.Windows.Input` and `Xamarin.Forms`.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`using`语句以使用`System.Windows.Input`和`Xamarin.Forms`。
- en: 'Add a command to toggle the status of the item and a piece of text that describes
    the status:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个命令来切换项目的状态和描述状态的一小段文本：
- en: '[PRE51]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, we have added a command for toggling the state of an item. When executed,
    it inverses the current state and raises the `ItemStatusChanged` event so that
    subscribers are notified. To change the text of the context action button depending
    on the status, we added a `StatusText` property. This is not a recommended practice,
    because we are adding code that only exists because of a specific UI case into
    the `ViewModel`. Ideally, this would be handled by the view, perhaps by using
    a `ValueConverter`. To save us having to implement these steps, however, we have
    left it as a string property:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经添加了一个命令来切换项目的状态。当执行时，它会反转当前的状态并触发`ItemStatusChanged`事件，以便通知订阅者。为了根据状态更改上下文操作按钮的文本，我们添加了一个`StatusText`属性。这不是一个推荐的做法，因为我们正在添加仅因特定UI情况而存在的代码到`ViewModel`中。理想情况下，这应该由视图处理，也许可以使用`ValueConverter`。然而，为了节省实现这些步骤的时间，我们将其留作一个字符串属性：
- en: Open `Views/MainView.xaml`.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Views/MainView.xaml`。
- en: 'Locate the `ListView.ItemTemplate` node and add the following `ViewCell.ContextActions`
    node:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`ListView.ItemTemplate`节点并添加以下`ViewCell.ContextActions`节点：
- en: '[PRE52]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Creating the filter toggle function using a command
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令创建过滤器切换功能
- en: We want to be able to toggle between viewing only active items and all items.
    We will create a simple mechanism to do this.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够在查看仅活动项目和所有项目之间切换。我们将创建一个简单的机制来实现这一点。
- en: 'Hook up the changes in the `MainViewModel` as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainViewModel`中进行更改：
- en: Open `ViewModels/MainViewModel.cs` and locate the `ItemStatusChangeMethod`.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewModels/MainViewModel.cs`并找到`ItemStatusChangeMethod`。
- en: 'Add the implementation to the `ItemStatusChanged` method and a property called
    `ShowAll` to control the filtering:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`ItemStatusChanged`方法的实现和一个名为`ShowAll`的属性来控制过滤：
- en: '[PRE53]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `ItemStatusChanged` event handler is triggered when we use the context action
    from the last section. Since the sender is always an object, we try to cast it
    to a `TodoItemViewModel`. If this is successful, we check whether we can remove
    it from the list if `ShowAll` is not true. This is a small optimization; we could
    have called `LoadData` and reloaded the entire list, but since the Items list
    is an `ObservableCollection`, it communicates to the `ListView` that one item
    has been removed from the list. We also call the repository to update the item
    to persist the change of status.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用上一部分的上下文操作时，`ItemStatusChanged`事件处理程序会被触发。由于发送者始终是一个对象，我们尝试将其转换为`TodoItemViewModel`。如果成功，我们检查是否可以从列表中删除它，如果`ShowAll`不为真的话。这是一个小优化；我们本可以调用`LoadData`并重新加载整个列表，但由于Items列表是一个`ObservableCollection`，它会通知`ListView`列表中已删除了一个项目。我们还调用存储库来更新项目以保持状态的更改。
- en: 'The `ShowAll` property is what controls which state our filter is in. We need
    to adjust the `LoadData` method to reflect this:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowAll`属性控制着我们的筛选器处于哪种状态。我们需要调整`LoadData`方法以反映这一点：'
- en: Locate the Load method in the `MainViewModel`.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainViewModel`中找到`Load`方法。
- en: 'Add the lines of code marked in bold:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加标记为粗体的代码行：
- en: '[PRE54]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If `ShowAll` is false, we limit the content of the list to the items that have
    not been completed. We could do this either by having two methods, `GetAllItems()`
    and `GetActiveItems()`, or by using a filter argument that could be passed to
    `GetItems()`. Take a minute to think about how we would have implemented this.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ShowAll`为假，则我们将列表的内容限制为尚未完成的项目。我们可以通过两种方法来实现这一点，即`GetAllItems()`和`GetActiveItems()`，或者使用可以传递给`GetItems()`的筛选参数。花一分钟时间思考一下我们将如何实现这一点。
- en: 'Let''s add the code that toggles the filter:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加代码来切换筛选器：
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewModels/MainViewModel.cs`。
- en: 'Add the `FilterText` and `ToggleFilter` properties:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`FilterText`和`ToggleFilter`属性：
- en: '[PRE55]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `FilterText` property is a read-only property used to display the status
    as a string in human-readable form. We could have used a `ValueConverter` for
    this, but to save some time, we simply expose it as a property. The logic for
    the `ToggleFilter` command is a simple inversion of the state and then a call
    to `LoadData`. This, in turn, causes a reload of the list.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilterText`属性是一个只读属性，用于以人类可读的形式显示状态的字符串。我们本可以使用`ValueConverter`来实现这一点，但为了节省时间，我们简单地将其公开为一个属性。`ToggleFilter`命令的逻辑是状态的简单反转，然后调用`LoadData`。这反过来会导致列表的重新加载。'
- en: 'Before we can filter the items, we need to hook up the filter button:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以筛选项目之前，我们需要连接筛选按钮：
- en: Open `Views/MainView.xaml`.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Views/MainView.xaml`。
- en: Locate the `Button` that controls the filter (the only button in the file).
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到控制筛选的`Button`（文件中唯一的按钮）。
- en: 'Adjust the code to reflect the following code:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整代码以反映以下代码：
- en: '[PRE56]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The app is now complete with regard to this feature! But it isn't very attractive;
    we'll deal with this in the following section.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 就这个功能而言，应用现在已经完成了！但它并不是很吸引人；我们将在接下来的部分处理这个问题。
- en: Laying out contents
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布置内容
- en: This last section is about making the app look a bit nicer. We are just going
    to scratch the surface of the possibilities here, but this should give you some
    ideas about how styling works.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是让应用看起来更加漂亮。我们只是浅尝辄止，但这应该能给你一些关于样式工作原理的想法。
- en: Setting an application-wide background color
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置应用程序范围的背景颜色
- en: 'Styles are a great way to apply styling to elements. They can be applied either
    to all elements of a type or to the elements referenced by a key, if you add an `x:Key`
    attribute:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 样式是将样式应用于元素的一种很好的方法。它们可以应用于类型的所有元素，也可以应用于由键引用的元素，如果您添加了`x:Key`属性：
- en: Open `App.xaml` in the .NET Standard project.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开.NET Standard项目中的`App.xaml`。
- en: 'Add the following XAML, which is in bold, to the file:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下XAML添加到文件中，该部分为粗体：
- en: '[PRE57]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first style we are going to apply is a new background color and text color
    in the navigation bar. The second style will be applied to the filter button.
    We can define a style by setting the `TargetType` that instructs Xamarin.Forms
    which type of object this style can be applied to. We can then add one or more
    properties that we want to set. The result is the same as if we had added these
    properties directly to the element in the XAML code.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要应用的第一个样式是导航栏中的新背景颜色和文本颜色。第二个样式将应用于筛选按钮。我们可以通过设置`TargetType`来定义样式，指示Xamarin.Forms可以将此样式应用于哪种类型的对象。然后，我们可以添加一个或多个要设置的属性。结果与我们直接在XAML代码中添加这些属性的效果相同。
- en: Styles that lack the `x:Key` attribute will be applied to all instances of the
    type defined in `TargetType`. The styles that have a key must be explicitly assigned
    in the XAML of the user interface. We will see examples of this when we define
    the filter button in the next section.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`x:Key`属性的样式将应用于`TargetType`中定义的类型的所有实例。具有键的样式必须在用户界面的XAML中显式分配。当我们在下一部分定义筛选按钮时，我们将看到这种情况的例子。
- en: Laying out the MainView and ListView items
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布置MainView和ListView项目
- en: In this section, we'll be improving the appearance of the `MainView` and the
    `ListView`. Open up `Views/MainView.xaml` and apply the changes in bold in the
    XAML code for each section following.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将改进`MainView`和`ListView`的外观。打开`Views/MainView.xaml`，并在XAML代码中的每个部分后面应用粗体中的更改。
- en: The filter button
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 筛选按钮
- en: 'The filter button allows us to toggle the state of the list to show only active
    to-do items and all to-do items. Let''s style it to make it stand out a bit in
    the layout:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 筛选按钮允许我们切换列表的状态，只显示活动的待办事项和所有待办事项。让我们对其进行样式设置，使其在布局中更加突出：
- en: Find the filter button.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到筛选按钮。
- en: 'Make the following changes:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行以下更改：
- en: '[PRE58]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The style is applied using a `StaticResource`. Anything defined in a resource
    dictionary, either in the `App.xaml` file or in the local XAML file, is accessible
    through it. We then set the `BackgroundColor`, based on the `ShowAll` property
    of the `MainViewModel`, and the `TextColor` to `Black`.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`StaticResource`应用样式。在资源字典中定义的任何内容，无论是在`App.xaml`文件中还是在本地XAML文件中，都可以通过它访问。然后我们根据`MainViewModel`的`ShowAll`属性设置`BackgroundColor`，并将`TextColor`设置为`Black`。
- en: The `Button.Triggers` node is a useful feature. We can define a number of types
    of triggers that fire when a certain criteria is met. In this case, we use a data
    trigger that checks whether the value of `ShowAll` changes to true. If it does,
    we set the `TextColor` to white. The coolest part is that when `ShowAll` becomes
    false again, it switches back to whichever color it was before.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button.Triggers`节点是一个有用的功能。我们可以定义多种类型的触发器，当满足某些条件时触发。在这种情况下，我们使用数据触发器来检查`ShowAll`的值是否更改为true。如果是，我们将`TextColor`设置为白色。最酷的部分是，当`ShowAll`再次变为false时，它会切换回之前的颜色。'
- en: Touching up the ListView
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触摸ListView
- en: 'The `ListView` could use a couple of minor changes. The first change is formatting
    the due-date string to a more human, readable format, and the second is to change
    the color of the completed label to a nice green tint:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`可能需要进行一些微小的更改。第一个更改是将到期日期字符串格式化为更加人性化、可读的格式，第二个更改是将已完成标签的颜色更改为漂亮的绿色色调：'
- en: Open up `Views/MainView.xaml`.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Views/MainView.xaml`。
- en: 'Locate the labels that bind `Item.Due` and `Item.Completed` in the `ListView`:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到在`ListView`中绑定`Item.Due`和`Item.Completed`的标签：
- en: '[PRE59]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We added a string formatting in the binding to format the date using a specific
    format. In this case, the `0:MMMM d, yyyy` format that will display the date as
    a string in the format of May 5, 2019.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在绑定中添加了字符串格式化，以使用特定格式格式化日期。在这种情况下，`0:MMMM d, yyyy`格式将日期显示为字符串，格式为2019年5月5日。
- en: We also added a text color to the `Completed` label that is only visible if
    an item is completed. We do this by referencing our dictionary in `App.xaml`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为`Completed`标签添加了一个文本颜色，只有在项目完成时才可见。我们通过在`App.xaml`中引用我们的字典来实现这一点。
- en: Summary
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We should now have a good grasp of all the steps involved in creating a Xamarin.Forms
    application from scratch. We have learned about the project structure and the
    important files in a newly created project. We talked about dependency injection,
    using Autofac, and learned the basics of MVVM by creating all the `Views` and
    `ViewModels` needed. We also covered data storage in SQLite, to be able to persist
    data on the device in a fast and secure way. Using the knowledge gained from this
    chapter, you should now be able to create the backbone of any app you like.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该对从头开始创建Xamarin.Forms应用程序的所有步骤有了很好的掌握。我们已经了解了项目结构和新创建项目中的重要文件。我们谈到了依赖注入，使用Autofac，并通过创建所需的所有`Views`和`ViewModels`来学习了MVVM的基础知识。我们还涵盖了在SQLite中进行数据存储，以便以快速和安全的方式在设备上持久保存数据。利用本章所学的知识，现在您应该能够创建任何您喜欢的应用程序的骨架。
- en: The next chapter will focus on creating a richer user experience by creating
    a match-making application that displays images that you can pan around the screen.
    We will take a closer look at XAML and how to create custom controls.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍创建一个更丰富的用户体验，创建一个可以在屏幕上移动的图像匹配应用程序。我们将更仔细地研究XAML以及如何创建自定义控件。
