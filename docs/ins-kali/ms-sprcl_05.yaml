- en: Distributed Configuration with Spring Cloud Config
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Config进行分布式配置
- en: It is the right time to introduce a new element in our architecture, a distributed
    configuration server. Similar to service discovery, this is one of the key concepts
    around microservices. In the previous chapter, we discussed in detail how to prepare
    discovery, both on the server and client sides. But so far, we have always provided
    a configuration for the application using properties placed inside a fat JAR file.
    That approach has one big disadvantage, it requires a recompilation and a redeployment
    of the microservice's instance. Another approach supported by Spring Boot assumes
    the use of an explicit configuration stored in a filesystem outside of the fat
    JAR. It can be easily configured for an application during startup with the `spring.config.location`
    property. That approach does not require a redeployment, but it is also not free
    from drawbacks. With a lot of microservices, a configuration management based
    on explicit files placed in a filesystem may be really troublesome. In addition,
    let’s imagine that there are many instances of every microservice and each of
    them has a specific configuration. Well, with that approach it is better not to
    imagine it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是介绍我们架构中的一个新元素的合适时机，即分布式配置服务器。与服务发现类似，这是微服务周围的关键概念之一。在上一章中，我们详细讨论了如何在服务器和客户端上准备发现。但到目前为止，我们一直使用放置在fat
    JAR文件中的属性为应用程序提供配置。这种方法有一个很大的缺点，它需要重新编译和重新部署微服务实例。Spring Boot支持的另一种方法假设使用存储在fat
    JAR之外的文件系统中的显式配置。它可以在启动时使用`spring.config.location`属性轻松配置应用程序。这种方法不需要重新部署，但也不是没有缺点。对于大量的微服务，基于显式文件放置在文件系统中的配置管理可能会非常麻烦。此外，让我们想象一下，每个微服务有许多实例，每个实例都有特定的配置。嗯，用这种方法最好不要想象。
- en: Anyway, a distributed configuration is a very popular standard in a cloud-native
    environment. Spring Cloud Config provides server-side and client-side support
    for externalized configuration in a distributed system. With that solution, we
    have one central place where we can manage external properties for applications
    across all environments. The concept is really simple and easy to implement. A
    server does nothing more than expose HTTP and resource-based API interfaces, which
    returns `property` files in JSON, YAML, or properties formats. Additionally, it
    performs decryption and encryption operations for returned property values. A
    client needs to fetch configuration settings from a server, and also decrypt them
    if such a feature has been enabled on the server side.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，分布式配置在云原生环境中是一个非常流行的标准。Spring Cloud Config为分布式系统中的外部化配置提供了服务器端和客户端支持。有了这个解决方案，我们有一个中心化的地方可以管理所有环境中应用程序的外部属性。这个概念非常简单，易于实现。服务器只是暴露HTTP和基于资源的API接口，返回JSON、YAML或属性格式的`property`文件。此外，它还执行返回属性值的解密和加密操作。客户端需要从服务器获取配置设置，并在服务器端启用了这样的功能时解密它们。
- en: Configuration data may be stored in different repositories. The default implementation
    of `EnvironmentRepository` uses a Git backend. It is also possible to set up other
    VCS systems such as SVN. If you don't want to take advantage of features provided
    by VCS as a backend, you may use the filesystem or Vault. Vault is a tool for
    managing secrets, which stores and controls access to such resources as tokens,
    passwords, certificates, and API keys.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 配置数据可以存储在不同的存储库中。`EnvironmentRepository`的默认实现使用Git后端。还可以设置其他VCS系统，如SVN。如果不想利用VCS作为后端提供的功能，可以使用文件系统或Vault。Vault是一个用于管理秘密的工具，它存储和控制对令牌、密码、证书和API密钥等资源的访问。
- en: 'The topics we will cover in this chapter are:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题有：
- en: HTTP API exposed by Spring Cloud Config Server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Config服务器提供的HTTP API
- en: Different types of repository backend on the server side
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端不同类型的存储库后端
- en: Integrating with service discovery
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与服务发现集成
- en: Reloading the configuration automatically with Spring Cloud Bus and message
    broker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Bus和消息代理自动重新加载配置
- en: Introduction to HTTP API resources
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP API资源介绍
- en: 'The Config Server provides the HTTP API, which may be invoked in various ways.
    The following endpoints are available:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务器提供了可以以各种方式调用的HTTP API。以下端点可用：
- en: '`/{application}/{profile}[/{label}]`: This returns data in a JSON format; the
    label parameter is optional'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/{application}/{profile}[/{label}]`：以JSON格式返回数据；标签参数是可选的'
- en: '`/{application}-{profile}.yml`: This returns the YAML format'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/{application}-{profile}.yml`：返回YAML格式'
- en: '`/{label}/{application}-{profile}.yml`: A variant of the previous endpoint,
    where we can pass an optional label parameter'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/{label}/{application}-{profile}.yml`：前一个端点的变体，我们可以传递一个可选的标签参数'
- en: '`/{application}-{profile}.properties`: This returns the simple key/value format
    used by properties files'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/{application}-{profile}.properties`：返回属性文件使用的简单键/值格式'
- en: '`/{label}/{application}-{profile}.properties`: A variant of the previous endpoint,
    where we can pass an optional label parameter'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/{label}/{application}-{profile}.properties`：前一个端点的变体，我们可以传递一个可选的标签参数'
- en: From a client point of view, the application parameter is the name of the application,
    which is taken from the `spring.application.name` or `spring.config.name` property,
    and profile is an active profile or comma-separated list of active profiles. The
    last available parameter `label` is an optional property, important only while
    working with Git as a backend store. It sets the name of the Git branch for configuration
    and defaults to `master`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端的角度来看，应用程序参数是应用程序的名称，它取自`spring.application.name`或`spring.config.name`属性，配置文件是一个活动配置文件或逗号分隔的活动配置文件列表。最后一个可用的参数`label`是一个可选属性，只有在使用Git作为后端存储时才重要。它设置了配置的Git分支名称，默认为`master`。
- en: Native profile support
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地配置文件支持
- en: 'Let’s begin with the simplest example, based on a filesystem backend. By default,
    Spring Cloud Config Server tries to fetch configuration data from a Git repository.
    To enable the native profile, we should launch the server with the `spring.profiles.active` option set
    to `native`. It searches for files stored in the following locations, `classpath:/`,
    `classpath:/config`, `file:./`, `file:./config`. It means that properties or YAML
    files may be also placed inside a JAR file. For test purposes, I created a config
    folder inside `src/main/resources`. Our configuration files will be stored in
    that location. Now, we need to go back for a moment to the example from the previous
    chapter. As you probably remember, I introduced the configuration for a clustered
    discovery environment, where each client service instance was launched in a different
    zone. There were three available zones and three client instances, each of them
    has its own profile in the `application.yml` file. The source code for that example
    is available in the `config` branch. Here''s the link:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的基于文件系统后端的示例开始。默认情况下，Spring Cloud Config Server尝试从Git存储库中获取配置数据。要启用本机配置文件，我们应该使用`spring.profiles.active`选项将服务器启动为`native`。它搜索存储在以下位置的文件，`classpath:/`，`classpath:/config`，`file:./`，`file:./config`。这意味着属性或YAML文件也可以放在JAR文件中。为了测试目的，我在`src/main/resources`中创建了一个config文件夹。我们的配置文件将存储在该位置。现在，我们需要回到上一章的示例。您可能还记得，我介绍了一个集群发现环境的配置，其中每个客户端服务实例在不同的区域中启动。有三个可用区域和三个客户端实例，每个实例在`application.yml`文件中都有自己的配置文件。该示例的源代码位于`config`分支中。以下是链接：
- en: '[https://github.com/piomin/sample-spring-cloud-netflix/tree/config](https://github.com/piomin/sample-spring-cloud-netflix/tree/config)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/piomin/sample-spring-cloud-netflix/tree/config](https://github.com/piomin/sample-spring-cloud-netflix/tree/config)'
- en: 'Our current task is to migrate that configuration to the Spring Cloud Config
    Server. Let''s remind ourselves the properties set for that example. Here are
    the profile settings used for the first instance of the client application. According
    to the selected profile, there are a changing instance running port, a default
    discovery server URL and a zone name:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的任务是将该配置迁移到Spring Cloud Config Server。让我们回顾一下为该示例设置的属性。以下是用于客户端应用程序的第一个实例的配置设置。根据所选的配置文件，有一个运行端口，一个默认的发现服务器URL和一个区域名称：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the described example I placed all of the profiles settings in a single
    `application.yml` file for simplicity. That file might as well be divided into
    three different files with the names including the profiles, `application-zone1.yml`,
    `application-zone2.yml`, and `application-zone3.yml`. Of course, such names are
    unique to a single application, so if we decided to move the files into a remote
    configuration server, we should take care of their names. The client application
    name is injected from `spring.application.name` and in this case, it is `client-service`.
    So, to conclude, I created three configuration files with the name `client-service-zone[n].yml`
    in the `src/main/resources/config` catalog, where [`n`] is an instance''s number.
    Now, when you call the `http://localhost:8888/client-service/zone1` endpoint, you
    will receive the following response in JSON format:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述的示例中，我将所有配置文件的配置设置放在一个名为`application.yml`的文件中，以简化操作。该文件也可以分成三个不同的文件，文件名包括配置文件，`application-zone1.yml`，`application-zone2.yml`和`application-zone3.yml`。当然，这些名称对于单个应用程序是唯一的，因此，如果我们决定将文件移动到远程配置服务器，我们应该注意它们的名称。客户端应用程序名称是从`spring.application.name`注入的，在这种情况下，它是`client-service`。因此，总之，我创建了三个名为`client-service-zone[n].yml`的配置文件，它们位于`src/main/resources/config`目录中，其中[`n`]是实例的编号。现在，当您调用`http://localhost:8888/client-service/zone1`端点时，您将以JSON格式收到以下响应：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also call `http://localhost:8888/client-service-zone2.properties` for
    the second instance, which returns the following response as a list of properties:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以调用`http://localhost:8888/client-service-zone2.properties`来获取第二个实例的响应，该响应是一组属性的列表：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last available version of the HTTP API endpoint, `http://localhost:8889/client-service-zone3.yml`,
    returns data identical to the input file. Here''s the result for the third instance:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个可用版本的HTTP API端点，`http://localhost:8889/client-service-zone3.yml`，返回与输入文件相同的数据。以下是第三个实例的结果：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Building a server-side application
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建服务器端应用程序
- en: 'We have started by discussing HTTP, a resource-based API provided by the Spring
    Cloud Config Server, and the way of creating and storing properties there. But
    now let''s move back to the basics. The same as a discovery server, a Config Server
    may be run as a Spring Boot application. To enable it on the server side, we should
    include `spring-cloud-config-server` in our dependencies in the `pom.xml` file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论了HTTP，这是由Spring Cloud Config Server提供的基于资源的API，以及在那里创建和存储属性的方法。但现在让我们回到基础知识。与发现服务器一样，配置服务器可以作为Spring
    Boot应用程序运行。要在服务器端启用它，我们应该在`pom.xml`文件中的依赖项中包含`spring-cloud-config-server`：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In addition to this, we should enable the Config Server on the main application
    class. It would be a good idea to change the server port to `8888`, because it
    is the default value of the `spring.cloud.config.uri` property on the client side.
    For example, it is auto configured on the client side. To switch the server to
    a different port, you should set the `server.port` property on `8888` or launch
    it with the `spring.config.name=configserver` property. There is a `configserver.yml`
    embedded in the `spring-cloud-config-server` library:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们应该在主应用程序类上启用配置服务器。将服务器端口更改为`8888`是个好主意，因为这是客户端侧`spring.cloud.config.uri`属性的默认值。例如，它在客户端侧是自动配置的。要将服务器切换到不同的端口，您应该将`server.port`属性设置为`8888`，或者使用`spring.config.name=configserver`属性启动它。`spring-cloud-config-server`库中嵌入了一个`configserver.yml`：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Building a client-side application
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建客户端应用程序
- en: 'If you set port `8888` as the default for the server, the configuration on
    the client side is really simple. All you need to do is to provide the `bootstrap.yml`
    file with the application name and include the following dependency in your `pom.xml`.
    Of course, that rule is applicable only on localhost, because the auto-configured
    Config Server address for a client is `http://localhost:8888`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将`port` `8888`设置为服务器的默认端口，则客户端端的配置非常简单。 您只需要提供`bootstrap.yml`文件和在`pom.xml`中包含以下依赖项。
    当然，该规则仅适用于本地主机，因为客户端的自动配置的配置服务器地址为`http://localhost:8888`：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you set a port different than `8888` for the server, or it is running on
    a different machine than the client application, you should also set its current
    address in `bootstrap.yml`. Here are the bootstrap context settings, which allow
    you to fetch properties for `client-service` from the server available on port 
    `8889`. When running the application with the `--spring.profiles.active=zone1` argument, it
    automatically fetches the properties set for the `zone1` profile in the configuration
    server:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为服务器设置的端口与`8888`不同，或者它在与客户端应用程序不同的计算机上运行，则还应在`bootstrap.yml`中设置其当前地址。 以下是引导上下文设置，允许您从在`port`
    `8889`上可用的服务器中获取`client-service`的属性。 使用`--spring.profiles.active=zone1`参数运行应用程序时，它会自动获取为配置服务器中的`zone1`配置文件设置的属性：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding a Eureka Server
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Eureka服务器
- en: As you have probably noticed, there is the discovery service network location
    address in the client's properties. So, before launching the client service we
    should have a Eureka Server running. Of course, Eureka also has its own configuration,
    which has been stored in the `application.yml` file for the example from the previous
    chapter. That configuration, similar to `client-service`, has been divided into
    three profiles, where each of them differ from the others in such properties as
    the number of the server's HTTP port and the list of discovery peers to communicate
    with.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，客户端属性中有发现服务网络位置地址。 因此，在启动客户端服务之前，我们应该运行Eureka服务器。 当然，Eureka也有自己的配置，该配置已存储在上一章节示例的`application.yml`文件中。
    该配置与`client-service`类似，已分为三个配置文件，其中每个配置文件在服务器的HTTP端口号和要与之通信的发现对等体列表等属性方面与其他配置文件不同。
- en: 'Now, we place those `property` files on the configuration server. Eureka fetches
    all of the settings assigned to the selected profile on startup. File naming is
    consistent with the already described standard, which means `discovery-service-zone[n].yml`.
    Before running the Eureka Server, we should include `spring-cloud-starter-config`
    in the dependencies to enable Spring Cloud Config Client, and replace `application.yml`
    with `bootstrap.yml`, which is shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将这些`property`文件放在配置服务器上。 Eureka在启动时获取分配给所选配置文件的所有设置。 文件命名与已描述的标准一致，这意味着`discovery-service-zone[n].yml`。
    在运行Eureka服务器之前，我们应该在依赖项中包含`spring-cloud-starter-config`以启用Spring Cloud Config
    Client，并将`application.yml`替换为`bootstrap.yml`，如下所示：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we may run three instances of the Eureka Server in peer-to-peer communication
    mode by setting a different profile name in the `--spring.profiles.active` property.
    After launching three instances of `client-service`, our architecture looks like
    the following diagram. In comparison to the example from the previous chapter,
    both client and discovery services fetch the configuration from the Spring Cloud
    Config Server, instead of keeping it as a YML file inside a fat JAR:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在`--spring.profiles.active`属性中设置不同的配置文件名来以对等通信模式运行三个Eureka服务器实例。 在启动三个`client-service`实例后，我们的架构如下图所示。
    与上一章的示例相比，客户端和发现服务都从Spring Cloud Config服务器获取配置，而不是将其作为YML文件保存在fat JAR中：
- en: '![](img/9423cf78-f43e-4e95-89a7-fe1beeae4cff.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9423cf78-f43e-4e95-89a7-fe1beeae4cff.png)'
- en: Client-side bootstrap approaches
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端引导方法
- en: In the example solution described previously, all of the applications must hold
    the network location of the configuration server. The network location of service
    discovery is stored there as a property. At this point, we are confronted with
    an interesting problem to discuss. We could ask whether our microservices should
    be aware of the Config Server's network address. In previous discussions, we have
    agreed that the main place all the service’s network locations should be kept
    is the service discovery server. The configuration server is also a Spring Boot
    application like other microservices, so logically it should register itself with
    Eureka to enable the automated discovery mechanism for other services that have
    to fetch data from the Spring Cloud Config Server. This in turn requires placing
    the service discovery connection settings in `bootstrap.yml` instead of the `spring.cloud.config.uri`
    property.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前描述的示例解决方案中，所有应用程序都必须保存配置服务器的网络位置。 服务发现的网络位置存储在那里作为属性。 在这一点上，我们面临一个有趣的问题需要讨论。
    我们可以问我们的微服务是否应该知道配置服务器的网络地址。 在先前的讨论中，我们已经同意所有服务的网络位置应该保存在服务发现服务器中。 配置服务器也是像其他微服务一样的Spring
    Boot应用程序，因此从逻辑上讲，它应该向Eureka注册，以启用其他服务的自动发现机制，这些服务必须从Spring Cloud Config服务器获取数据。
    这反过来要求将服务发现连接设置放在`bootstrap.yml`中，而不是`spring.cloud.config.uri`属性。
- en: Choosing between these two different approaches is one of the decisions you
    need to make while designing your system architecture. It's not that one solution
    is better than the other. The default behavior for any application that uses the `spring-cloud-config-client`
    artifact is called **Config First Bootstrap** in Spring Cloud nomenclature. When
    a config client starts up, it binds to the server and initializes the context
    with remote property sources. That approach has been presented in the first example
    in this chapter. In the second solution, the Config Server registers with the
    service discovery and all of the applications may use `DiscoveryClient` to locate
    it. That approach is called **Discovery First Bootstrap**. Let's implement an
    example that illustrates that concept.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计系统架构时，选择这两种不同方法之一是您需要做出的决定之一。并不是一个解决方案比另一个更好。任何使用`spring-cloud-config-client`工件的应用程序的默认行为在Spring
    Cloud命名法中称为**Config First Bootstrap**。当配置客户端启动时，它会绑定到服务器并使用远程属性源初始化上下文。这种方法已经在本章的第一个示例中介绍过。在第二种解决方案中，配置服务器向服务发现注册，并且所有应用程序都可以使用`DiscoveryClient`来定位它。这种方法称为**Discovery
    First Bootstrap**。让我们实施一个说明该概念的示例。
- en: Config Server discovery
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务器发现
- en: 'To access that example on GitHub, you need to switch to the `config_with_discovery` branch.
    Here''s the link:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要在GitHub上访问该示例，您需要切换到`config_with_discovery`分支。这是链接：
- en: '[https://github.com/piomin/sample-spring-cloud-netflix/tree/config_with_discovery](https://github.com/piomin/sample-spring-cloud-netflix/tree/config_with_discovery).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/piomin/sample-spring-cloud-netflix/tree/config_with_discovery](https://github.com/piomin/sample-spring-cloud-netflix/tree/config_with_discovery).'
- en: 'The first change is related to the `sample-service-discovery` module. We don’t
    need the `spring-cloud-starter-config` dependency there. The simple configuration
    is not fetched from remote property sources, but set in `bootstrap.yml`. In contrast
    to the previous example, we launch a single standalone Eureka instance in order
    to simplify the exercise:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变化与`sample-service-discovery`模块有关。我们不需要在那里使用`spring-cloud-starter-config`依赖项。简单的配置不是从远程属性源中获取的，而是在`bootstrap.yml`中设置的。与上一个示例相反，我们启动了一个独立的Eureka实例，以简化练习：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By contrast, we should include the `spring-cloud-starter-eureka` dependency
    for the Config Server. Now, the full list of dependencies is shown in the following
    code. Moreover, a discovery client has to be enabled by declaring the `@EnableDiscoveryClient`
    annotation on the main class, and the Eureka Server address should be provided
    by setting the `eureka.client.serviceUrl.defaultZone` property to `http://localhost:8761/eureka/`
    in the `application.yml` file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们应该为配置服务器包含`spring-cloud-starter-eureka`依赖项。现在，完整的依赖项列表显示在以下代码中。此外，必须通过在主类上声明`@EnableDiscoveryClient`注解来启用发现客户端，并且应该通过在`application.yml`文件中将Eureka服务器地址设置为`http://localhost:8761/eureka/`来提供Eureka服务器地址：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On the client application side, it is no longer needed to hold the address
    of the configuration server. The only thing that has to be set is the service
    ID, in case it is different than the Config Server. In accordance with the naming
    convention used for the services in the presented examples, that ID is `config-server`.
    It should be overridden with the `spring.cloud.config.discovery.serviceId` property.
    In order to allow discovery mechanism enable the discovery mechanism to fetch
    remote property sources from the configuration server, we should set `spring.cloud.config.discovery.enabled=true`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端应用程序方面，不再需要保存配置服务器的地址。唯一需要设置的是服务ID，如果与配置服务器不同的话。根据所呈现示例中服务的命名约定，该ID为`config-server`。它应该被`spring.cloud.config.discovery.serviceId`属性覆盖。为了允许发现机制从配置服务器获取远程属性源，我们应该设置`spring.cloud.config.discovery.enabled=true`：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s the screen with the Eureka dashboard, with one instance of the Config
    Server and three instances of `client-service` registered. Every instance of the
    client''s Spring Boot application is the same as for the previous example and
    was launched with the `--spring.profiles.active=zone[n]` parameter, where `n`
    is the number of the zone. The only difference is that all of the client''s service
    configuration files served by the Spring Cloud Config Server have the same connection
    address as the Eureka Server:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有尤里卡仪表板的屏幕，其中一个配置服务器的实例和三个“client-service”注册。客户端的每个Spring Boot应用程序实例与上一个示例相同，并且是使用`--spring.profiles.active=zone[n]`参数启动的，其中`n`是区域的编号。唯一的区别是，由Spring
    Cloud配置服务器提供的所有客户端服务配置文件都具有与Eureka服务器相同的连接地址：
- en: '![](img/11dbf317-7acc-465c-8714-af1143dd5297.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11dbf317-7acc-465c-8714-af1143dd5297.png)'
- en: Repository backend types
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库后端类型
- en: All of the previous examples in this chapter have used the filesystem backend,
    which means that the config files were loaded from the local filesystem or classpath.
    This type of backend is very good for tutorial purposes or for testing. If you
    would like to use Spring Cloud Config in production, it is worth considering the
    other options. The first of them is a repository backend based on Git, which is
    also enabled by default. It is not the only one **version control system** (**VCS**)
    that can be used as a repository for configuration sources. The other option is
    SVN, or we can even decide to create a composite environment, which may consist of
    both Git and SVN repositories. The next supported backend type is based on a tool
    provided by HashiCorp, Vault. It is especially useful when managing security properties
    such as passwords or certificates. Let's take a closer look at each of the solutions
    listed here.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有先前示例都使用了文件系统后端，这意味着配置文件是从本地文件系统或类路径加载的。这种后端类型非常适合教程目的或测试。如果您想在生产中使用Spring
    Cloud Config，值得考虑其他选项。其中之一是基于Git的存储库后端，它也是默认启用的。它不是唯一可以用作配置源存储库的版本控制系统。另一个选项是SVN，或者我们甚至可以决定创建一个由Git和SVN存储库组成的复合环境。下一个支持的后端类型是基于HashiCorp提供的工具Vault。在管理诸如密码或证书之类的安全属性时特别有用。让我们更仔细地看看这里列出的每个解决方案。
- en: Filesystem backend
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统后端
- en: I won't write a lot about this topic, because it has already been discussed
    in the previous examples. All of them have shown how to store property sources
    in the classpath. There is also the ability to load them from disk. By default,
    the Spring Cloud Config Server tries to locate files inside an application's working
    directory or the config subdirectory at this location. We can override the default
    location with the `spring.cloud.config.server.native.searchLocations` property.
    The search location path may contain placeholders for `application`, `profile`,
    and `label`. If you don't use any placeholders in the location path, the repository
    automatically appends the label parameter as a suffix.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这个话题上写很多，因为它已经在之前的例子中讨论过了。所有这些例子都展示了如何在类路径中存储属性源。还有能力从磁盘加载它们。默认情况下，Spring
    Cloud Config服务器尝试定位应用程序工作目录内的文件，或者在此位置的config子目录内的文件。我们可以使用`spring.cloud.config.server.native.searchLocations`属性覆盖默认位置。搜索位置路径可以包含`application`、`profile`和`label`的占位符。如果您在位置路径中不使用任何占位符，存储库会自动将标签参数附加为后缀。
- en: As a consequence, the configuration files are loaded from each search location
    and a subdirectory with the same name as the label. For example, `file:/home/example/config`
    is the same as `file:/home/example/config,file:/home/example/config/{label}`.
    This behavior may be disabled by setting `spring.cloud.config.server.native.addLabelLocations`
    to `false`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，配置文件从每个搜索位置和与标签同名的子目录中加载。例如，`file:/home/example/config`等同于`file:/home/example/config,file:/home/example/config/{label}`。通过将`spring.cloud.config.server.native.addLabelLocations`设置为`false`，可以禁用此行为。
- en: As I have already mentioned, a filesystem backend is not a good choice for a
    production deployment. If you place property sources in a classpath inside a JAR
    file, every change requires a recompilation of the application. On the other hand,
    using a filesystem outside of a JAR does not need recompilation, but this approach
    may be troublesome if you have more than one instance of a config service working
    in a high availability mode. In that case, share the filesystem across all of
    the instances or hold a copy of all of the property sources per running instance.
    The Git backend is free from such disadvantages, and that's why it is recommended
    for production use.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我已经提到的，文件系统后端不适合生产部署。如果您将属性源放在JAR文件中的类路径中，每次更改都需要重新编译应用程序。另一方面，使用JAR之外的文件系统不需要重新编译，但如果您有多个配置服务实例以高可用模式运行，这种方法可能会很麻烦。在这种情况下，将文件系统跨所有实例共享，或者在每个运行实例中保存所有属性源的副本。Git后端不受这些缺点的影响，这就是为什么它推荐用于生产的原因。
- en: Git backend
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git后端
- en: The Git version control system has some features that make it very useful as
    a repository for property sources. It allows you to easily manage and audit changes.
    By using well-known VCS mechanisms such as commit, revert, and branching, we can
    perform important operations a lot easier than in a filesystem approach. This
    type of backend also has another two key advantages. It forces a separation between
    the Config Server source code and the `property` files repository. If you take
    a look one more time at the previous examples, you will see that the `property`
    files were stored together with the application source code. Probably some of
    you would say that even if we used a filesystem backend, we can store the whole
    configuration as a separate project on Git and upload it to a remote server on
    demand. Of course, you would be right. But when using a Git backend with the Spring
    Cloud Config, you have those mechanisms available out of the box. In addition,
    it resolves the problems related to running multiple instances of the server.
    If you use a remote Git server, the changes may be easily shared across all of
    the running instances.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Git版本控制系统具有一些功能，使其作为属性源的存储库非常有用。它允许您轻松管理和审计更改。通过使用众所周知的版本控制系统机制，如提交、回滚和分支，我们可以执行比文件系统方法更容易的重要操作。这种后端还有另外两个关键优势。它强制在配置服务器源代码和“属性”文件存储库之间进行分离。如果您再看一下之前的例子，您会发现“属性”文件与应用程序源代码一起存储。也许你们中的一些人会说，即使我们使用文件系统后端，我们也可以将整个配置作为Git上的单独项目存储，并根据需要上传到远程服务器。当然，你是对的。但是，使用Spring
    Cloud Config的Git后端，您可以直接使用这些机制。此外，它解决了与运行多个服务器实例相关的问题。如果您使用远程Git服务器，更改可以轻松地在所有运行的实例之间共享。
- en: Different protocols
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的协议
- en: To set the location of the Git repository for the application, we should use
    the `spring.cloud.config.server.git.uri` property in `application.yml`. If you
    are familiar with Git, you well know that cloning may be realized using file,
    http/https, and ssh protocols. The local repository access allows you to get started
    quickly without a remote server. It is configured with file, prefix, for example,
    `spring.cloud.config.server.git.uri=file:/home/git/config-repo`. For more advanced
    usage when running Config Server in the high availability mode, you should use
    the remote protocols SSH or HTTPS. In this case, Spring Cloud Config clones a
    remote repository and then bases it on the local working copy as a cache.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置应用程序的Git存储库位置，我们应该在`application.yml`中使用`spring.cloud.config.server.git.uri`属性。如果您熟悉Git，您会知道克隆可以使用文件、http/https和ssh协议来实现。本地存储库访问允许您快速开始，而无需远程服务器。它配置了文件前缀，例如，`spring.cloud.config.server.git.uri=file:/home/git/config-repo`。在以高可用模式运行Config
    Server时，对于更高级的用法，您应该使用远程协议SSH或HTTPS。在这种情况下，Spring Cloud Config会克隆远程存储库，然后将其基于本地工作副本作为缓存。
- en: Using placeholders in URIs
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在URI中使用占位符
- en: All the recently listed placeholders, `application`, `profile`, and `label`,
    are also supported here. We can create a single repository per application using
    a placeholder as in `https://github.com/piomin/{application}`, or even per profile, `https://github.com/piomin/{profile}`.
    This type of backend implementation maps the label parameter of the HTTP resource
    to a Git label, which may refer to commit ID, branch, or tag name. The most appropriate
    way to discover interesting features for us is obviously through an example. Let's
    begin by creating a Git repository dedicated to storing the application's property
    sources.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最近列出的所有占位符，`application`，`profile`和`label`，在这里也都支持。我们可以使用占位符为每个应用程序创建单个存储库，如`https://github.com/piomin/{application}`，甚至为每个配置文件创建，`https://github.com/piomin/{profile}`。这种后端实现将HTTP资源的标签参数映射到Git标签，该标签可以引用提交ID、分支或标签名称。发现我们最感兴趣的功能的最合适方式显然是通过示例。让我们开始创建一个专门用于存储应用程序属性源的Git存储库。
- en: Building a server application
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建服务器应用程序
- en: 'I created an example configuration repository, which is available on GitHub
    here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个示例配置存储库，可以在GitHub上找到：
- en: '[https://github.com/piomin/sample-spring-cloud-config-repo.git](https://github.com/piomin/sample-spring-cloud-config-repo.git).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/piomin/sample-spring-cloud-config-repo.git](https://github.com/piomin/sample-spring-cloud-config-repo.git)。'
- en: 'I placed all of the property sources used in the first example in this chapter,
    which illustrated native profile support for client applications running in different
    discovery zones. Now, our repository holds the files visible in this list:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章的第一个示例中使用的所有属性源都放在了这里，该示例说明了在不同发现区域运行的客户端应用程序的本机配置文件支持。现在，我们的存储库包含了此列表中可见的文件：
- en: '![](img/d2b06957-1a0d-4f84-ade1-8637cdc7d591.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2b06957-1a0d-4f84-ade1-8637cdc7d591.png)'
- en: 'The Spring Cloud Config Server by default tries to clone a repository after
    the first HTTP resource call. If you would like to force cloning it after startup,
    you should set the `cloneOnStart` property to `true`. Beyond this, it is required
    to set the repository connection settings and the account authentication credentials:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config Server默认在第一次HTTP资源调用后尝试克隆存储库。如果您希望在启动后强制克隆它，应将`cloneOnStart`属性设置为`true`。除此之外，还需要设置存储库连接设置和帐户身份验证凭据：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After running the server, we can call the endpoints known from the previous
    exercises, for example, `http://localhost:8889/client-service/zone1` or `http://localhost:8889/client-service-zone2.yml`.
    The result would be the same as for the earlier tests; the only difference is
    in the data source. Now, let's perform another exercise. As you probably remember,
    we had to change the client's properties a little when we created the example
    with discovery first bootstrap with the `native` profile enabled. Because right
    now we are using a Git backend, we can develop a smarter solution for that case.
    In the current approach, we would create `discovery` branch ([https://github.com/piomin/sample-spring-cloud-config-repo/tree/discovery](https://github.com/piomin/sample-spring-cloud-config-repo/tree/discovery))
    at our configuration repository on GitHub, and we would place the files dedicated
    to the application illustrating the discovery first bootstrap mechanism. If you
    call the Config Server endpoints with the `label` parameter set to `discovery`,
    you will fetch data from our new branch. Try to call `http://localhost:8889/client-service/zone1/discovery`
    and/or `http://localhost:8889/discovery/client-service-zone2.yml` and check the
    result*. *
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行服务器后，我们可以调用之前练习中已知的端点，例如`http://localhost:8889/client-service/zone1`或`http://localhost:8889/client-service-zone2.yml`。结果与先前的测试相同；唯一的区别在于数据源。现在，让我们进行另一个练习。您可能还记得，当我们首次启用`native`配置文件时，我们必须稍微更改客户端的属性。因为现在我们正在使用Git后端，我们可以为该情况开发一个更智能的解决方案。在当前方法中，我们将在GitHub上的配置存储库中创建`discovery`分支（[https://github.com/piomin/sample-spring-cloud-config-repo/tree/discovery](https://github.com/piomin/sample-spring-cloud-config-repo/tree/discovery)），并放置专用于说明首先发现引导机制的应用程序的文件。如果您将Config
    Server端点的`label`参数设置为`discovery`，则将从我们的新分支获取数据。尝试调用`http://localhost:8889/client-service/zone1/discovery`和/或`http://localhost:8889/discovery/client-service-zone2.yml`并检查结果*。
- en: 'Let''s consider another situation. I changed the server port for the third
    instance of `client-service`, but for some reason I would like to move back to
    the previous value. Do I have to change and commit `client-service-zone3.yml`
    with the previous port value? No, all I have to do is to pass the commit ID as
    a `label` parameter while calling the HTTP API resource. The change performed is
    illustrated in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一种情况。我更改了`client-service`的第三个实例的服务器端口，但出于某种原因，我想要恢复到先前的值。我是否需要更改和提交`client-service-zone3.yml`以使用先前的端口值？不，我所需要做的就是在调用HTTP
    API资源时将提交ID作为`label`参数传递。所做的更改如下截图所示：
- en: '![](img/b6069696-66ed-4ace-bfda-741529faf834.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6069696-66ed-4ace-bfda-741529faf834.png)'
- en: 'If I invoke the API endpoint with the parent commit ID instead of branch name,
    the older port number would be returned as a response. Here''s the result of calling `http://localhost:8889/e546dd6/client-service-zone3.yml`,
    where `e546dd6` is the previous commit ID:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我调用API端点时使用父提交ID而不是分支名称，旧的端口号将作为响应返回。这是调用`http://localhost:8889/e546dd6/client-service-zone3.yml`的结果，其中`e546dd6`是先前的提交ID：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Client-side configuration
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端配置
- en: 'While building the server side with a Git backend, I have only shown you examples
    of HTTP resource calls.  Here''s the example configuration for the client''s application.
    Instead of setting the `profile` property inside `bootstrap.yml`, we may also
    pass it in the `spring.profiles.active` running parameter. This configuration
    makes the client fetch properties from the `discovery` branch. We may also decide
    to switch to a certain commit ID by setting it in the `label` property, as I have
    already mentioned:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Git后端构建服务器端时，我只向您展示了HTTP资源调用的示例。这是客户端应用程序的示例配置。我们可以在运行参数中传递`spring.profiles.active`，而不是在`bootstrap.yml`中设置`profile`属性。这个配置使客户端从`discovery`分支获取属性。我们也可以通过在`label`属性中设置特定的提交ID来决定切换到某个提交ID，正如我之前提到的那样：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Multiple repositories
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个存储库
- en: 'Sometimes, you may need to configure multiple repositories for a single Config
    Server. I can imagine the situation that you would have to separate the business
    configuration from a typical technical configuration. This is absolutely possible:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要为单个配置服务器配置多个存储库。我可以想象到您需要将业务配置与典型的技术配置分开的情况。这是完全可能的：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Vault backend
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vault后端
- en: 'I have already mentioned Vault as a tool for securely accessing secrets through
    a unified interface. In order to enable the Config Server to use that type of
    backend, you must run it with the Vault profile `--spring.profiles.active=vault`.
    Of course, before running the Config Server you need to install and launch the
    Vault instance. I suggest you use Docker for this. I know that this is our first
    contact with Docker in this book, and not everyone has knowledge of that tool.
    I have provided a short introduction to Docker, its basic commands, and use cases
    in [Chapter 14](0756243e-39c9-4696-8d79-4175e7cf4c48.xhtml)*, Docker Support*.
    So, if this is your first contact with that technology, please first take a look
    at that introduction. For those of you who are familiar with Docker, here''s the
    command for running a Vault container in development mode. We may override the
    default listen address with the `VAULT_DEV_LISTEN_ADDRESS` parameter or the ID
    of the initial generated root token with the `VAULT_DEV_ROOT_TOKEN_ID` parameter:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到Vault作为一个工具，通过统一接口安全地访问秘密。为了使配置服务器能够使用这种类型的后端，您必须使用Vault配置文件`--spring.profiles.active=vault`来运行它。当然，在运行配置服务器之前，您需要安装和启动Vault实例。我建议您使用Docker来实现这一点。我知道这是本书中我们第一次接触Docker，并不是每个人都了解这个工具。我在第14章《Docker支持》中提供了Docker的简短介绍、基本命令和用例。所以，如果这是您第一次接触这项技术，请先看一下那个介绍。对于那些熟悉Docker的人，这是在开发模式下运行Vault容器的命令。我们可以使用`VAULT_DEV_LISTEN_ADDRESS`参数或初始生成的根令牌的ID来覆盖默认的监听地址`VAULT_DEV_ROOT_TOKEN_ID`参数：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Getting started with Vault
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Vault
- en: 'Vault provides a command line interface, which may be used for adding new values
    to the server and reading them from the server. Examples of calling those commands
    are shown here. However, we have run Vault as a Docker container, so the most
    convenient way to manage the secrets is through the HTTP API:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Vault提供了一个命令行界面，可以用于向服务器添加新值并从服务器读取它们。这里展示了调用这些命令的示例。然而，我们已经将Vault作为一个Docker容器运行，所以管理秘密的最方便的方式是通过HTTP
    API：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The HTTP API is available for our instance of Vault under the `http://192.168.99.100:8200/v1/secret` address.
    When calling every method of that API, you need to pass a token as the request
    header `X-Vault-Token`. Because we set that value in the `VAULT_DEV_ROOT_TOKEN_ID`
    environment parameter while launching a Docker container, it is equal to `client`.
    Otherwise, it would be automatically generated during startup and may be read
    from logs by invoking the command `docker logs vault`. To start working with Vault,
    we in fact need to be aware of two HTTP methods—`POST` and `GET`. When calling
    the `POST` method, we may define the list of secrets that should be added to the
    server. The parameters passed in the `curl` command shown here are created using
    the kv backend, which acts like a key/value store:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Vault实例的HTTP API可以在`http://192.168.99.100:8200/v1/secret`地址下访问。在调用该API的每个方法时，您需要将令牌作为请求头`X-Vault-Token`传递。因为我们在启动Docker容器时设置了`VAULT_DEV_ROOT_TOKEN_ID`环境参数的值，它等于`client`。否则，它将在启动期间自动生成，并且可以通过调用`docker
    logs vault`命令从日志中读取。实际上，要开始使用Vault，我们需要了解两种HTTP方法——`POST`和`GET`。在调用`POST`方法时，我们可以定义应该添加到服务器的秘密列表。在这里显示的`curl`命令中传递的参数是使用kv后端创建的，它的作用类似于键/值存储：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The newly added values may be read from the server by using the `GET` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 新添加的值可以通过`GET`方法从服务器中读取：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Integration with Spring Cloud Config
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Spring Cloud配置集成
- en: 'As I have mentioned before, we have to run the Spring Cloud Config Server with
    the `--spring.profiles.active=vault` parameter to enable Vault as a backend store.
    To override the default auto configured settings, we should define the properties
    under the `spring.cloud.config.server.vault.*` key. The current configuration
    for our example application is shown here. An example application is available
    on GitHub; you need to switch to the `config_vault` branch ([https://github.com/piomin/sample-spring-cloud-netflix/tree/config_vault](https://github.com/piomin/sample-spring-cloud-netflix/tree/config_vault))
    to access it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，我们必须使用`--spring.profiles.active=vault`参数来运行Spring Cloud配置服务器，以启用Vault作为后端存储。为了覆盖默认的自动配置设置，我们应该在`spring.cloud.config.server.vault.*`键下定义属性。我们示例应用的当前配置如下所示。示例应用程序可在GitHub上找到；您需要切换到`config_vault`分支（[https://github.com/piomin/sample-spring-cloud-netflix/tree/config_vault](https://github.com/piomin/sample-spring-cloud-netflix/tree/config_vault)）才能访问它：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, you may call the endpoint exposed by the Config Server. You have to pass
    the token in the request header, but this time its name is `X-Config-Token`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以调用Config Server公开的端点。您必须在请求头中传递令牌，但这次它的名称是`X-Config-Token`：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The response should be the same as what is shown next. These properties are
    the default for all of the profiles of the client application. You may also add
    specific settings for the selected profile by calling the Vault HTTP `API` method
    with the profile name after a comma character, like this, `http://192.168.99.100:8200/v1/secret/client-service,zone1`. If
    such a profile name is included in the calling path, the properties for both the
    `default` and `zone1` profiles are returned in the response:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 响应应该与下面显示的内容相同。这些属性是客户端应用程序所有配置文件的默认值。您还可以通过在逗号字符后调用Vault HTTP `API`方法并使用所选配置文件的名称来为所选配置文件添加特定设置，如此`http://192.168.99.100:8200/v1/secret/client-service,zone1`。如果在调用路径中包含这样的配置文件名，响应中将返回`default`和`zone1`配置文件的属性：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Client-side configuration
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端配置
- en: 'When using Vault as a backend to your Config Server, the client will need to
    pass a token for the server to be able to retrieve values from Vault. This token
    should be provided in the client configuration settings with the `spring.cloud.config.token`
    property in the `bootstrap.yml` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Vault作为Config Server的后端时，客户端将需要传递一个令牌给服务器，以便能够从Vault中检索值。这个令牌应该在客户端配置设置中使用`bootstrap.yml`文件中的`spring.cloud.config.token`属性提供：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Additional features
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他功能
- en: Let's take a look at some other useful features of the Spring Cloud Config.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Spring Cloud Config的一些其他有用的功能。
- en: Fail on start and retry
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动失败和重试
- en: Sometimes it doesn't make any sense to launch the application if the Config
    Server is unavailable. In this case, we would like to halt a client with an exception.
    To achieve this, we have to set the bootstrap configuration property `spring.cloud.config.failFast`
    to `true`. Such a radical solution is not always the desired behavior. If a Config
    Server is unreachable only occasionally, the better approach would be to keep
    trying to reconnect until it succeeds. The `spring.cloud.config.failFast` property still
    has to be equal to `true`, but we would also need to add the `spring-retry` library
    and `spring-boot-starter-aop` to the application classpath. The default behavior
    assumes to retry six times with an initial backoff interval of 1000 milliseconds. You
    may override these settings by using the `spring.cloud.config.retry.*` configuration
    properties.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果配置服务器不可用，启动应用程序就没有任何意义。在这种情况下，我们希望用异常来中止客户端。为了实现这一点，我们必须将引导配置属性`spring.cloud.config.failFast`设置为`true`。这样的激进解决方案并不总是期望的行为。如果配置服务器偶尔不可达，更好的方法是不断尝试重新连接，直到成功。`spring.cloud.config.failFast`属性仍然必须等于`true`，但我们还需要将`spring-retry`库和`spring-boot-starter-aop`添加到应用程序类路径中。默认行为假定重试六次，初始退避间隔为1000毫秒。您可以使用`spring.cloud.config.retry.*`配置属性来覆盖这些设置。
- en: Secure client
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全客户端
- en: 'The same as for the service discovery, we may secure the Config Server with
    basic authentication. It can be easily enabled on the server side with Spring
    Security. In that case, all the client needs to set is the username and password
    in the `bootstrap.yml` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务发现一样，我们可以使用基本身份验证来保护Config Server。可以在服务器端轻松启用Spring Security。在这种情况下，客户端只需要在`bootstrap.yml`文件中设置用户名和密码：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Reload configuration automatically
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动重新加载配置
- en: We have already discussed the most important features of Spring Cloud Config.
    At that point, we implemented examples illustrating how to use different backend
    storage as a repository. But no matter whether we decided to choose filesystem,
    Git, or Vault, our client-side application needed to restart to be able to fetch
    the newest configuration from the server. However, sometimes this is not an optimal
    solution, especially if we have many microservices running and some of them use
    the same generic configuration.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Spring Cloud Config的最重要功能。在那时，我们实现了示例，说明了如何将不同的后端存储用作存储库。但无论我们决定选择文件系统、Git还是Vault，我们的客户端应用程序都需要重新启动才能从服务器获取最新的配置。然而，有时这并不是最佳解决方案，特别是如果我们有许多微服务在运行，其中一些使用相同的通用配置。
- en: Solution architecture
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案架构
- en: Even if we created a dedicated `property` file per single application, an opportunity
    to dynamically reload it without restart could be very helpful. As you may have
    deduced, such a solution is available for Spring Boot and therefore for Spring
    Cloud. In [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*
    while describing deregistration from the service discovery server, I introduced
    an endpoint, `/shutdown`, which may be used for gracefully shutting down. There
    is also an endpoint available for Spring context restart, which works in a similar
    way to that for shutdown.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们为每个单独的应用程序创建了一个专用的“property”文件，但在不重新启动的情况下动态重新加载它可能非常有帮助。正如你可能已经推断出的那样，这样的解决方案适用于Spring
    Boot，因此也适用于Spring Cloud。在[第4章](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml)中，*服务发现*中描述了从服务发现服务器注销时，我介绍了一个端点`/shutdown`，它可以用于优雅地关闭。还有一个可用于Spring上下文重启的端点，其工作方式类似于关闭的方式。
- en: 'An endpoint on the client side is just one component of the much larger system
    that needs to be included to enable push notifications for the Spring Cloud Config. The
    most popular source code repository providers, such as GitHub, GitLab, and Bitbucket,
    are able to send notifications about changes in a repository by providing a WebHook
    mechanism. We may configure the WebHook using the provider''s web dashboard as
    a URL and a list of selected event types. Such a provider will call the `POST`
    method defined in the WebHook with a body containing a list of commits. It is
    required to include a Spring Cloud Bus dependency in the project to enable the
    monitor endpoint on the Config Server side. When this endpoint is invoked as a
    result of the WebHook activation, a Config Server prepares and sends an event
    with a list of property sources that has been modified by the last commit. That
    event is sent to a message broker. The Spring Cloud Bus provides implementations
    for RabbitMQ and Apache Kafka. The first may be enabled for the project by including
    the `spring-cloud-starter-bus-amqp` dependency, and the second by including the `spring-cloud-starter-bus-kafka`
    dependency. Those dependencies should also be declared for a client application
    to enable receiving messages from a message broker. We should also enable the
    dynamic refresh mechanism on the client side by annotating the selected configuration
    class with `@RefreshScope`. An architecture of this solution is shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端端点只是需要包含在其中的一个组件，以启用Spring Cloud Config的推送通知的更大系统。最流行的源代码存储库提供商，如GitHub、GitLab和Bitbucket，能够通过提供WebHook机制来发送有关存储库更改的通知。我们可以使用提供商的Web仪表板配置WebHook，作为URL和一组选定的事件类型。这样的提供商将调用WebHook中定义的`POST`方法，并包含一个包含提交列表的主体。在项目中需要包含Spring
    Cloud Bus依赖项，以在配置服务器端启用监视端点。当WebHook激活时，此端点被调用，配置服务器准备并发送一个包含最后一次提交修改的属性源列表的事件。该事件被发送到消息代理。Spring
    Cloud Bus提供了RabbitMQ和Apache Kafka的实现。第一个可以通过包含`spring-cloud-starter-bus-amqp`依赖项来为项目启用，第二个可以通过包含`spring-cloud-starter-bus-kafka`依赖项来启用。这些依赖项也应该声明在客户端应用程序中，以启用从消息代理接收消息。我们还应该通过使用`@RefreshScope`注释所选配置类来在客户端端启用动态刷新机制。此解决方案的架构如下所示：
- en: '![](img/f0318c08-6af4-40fc-a44a-e1b8885e6a01.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0318c08-6af4-40fc-a44a-e1b8885e6a01.png)'
- en: Reload configuration with @RefreshScope
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@RefreshScope重新加载配置
- en: 'This time we will start unusually from the client side. The example application
    is available on GitHub ([https://github.com/piomin/sample-spring-cloud-config-bus.git](https://github.com/piomin/sample-spring-cloud-config-bus.git)).
    The same as the previous examples, it uses a Git repository as backend storage,
    which is also created on GitHub ([https://github.com/piomin/sample-spring-cloud-config-repo](https://github.com/piomin/sample-spring-cloud-config-repo)).
    I added some new properties to the client''s configuration file and committed
    changes to the repository. Here''s the current version of the client''s configuration:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将不同寻常地从客户端开始。示例应用程序可在GitHub上找到（[https://github.com/piomin/sample-spring-cloud-config-bus.git](https://github.com/piomin/sample-spring-cloud-config-bus.git)）。与之前的示例一样，它使用Git存储库作为后端存储，该存储库也在GitHub上创建（[https://github.com/piomin/sample-spring-cloud-config-repo](https://github.com/piomin/sample-spring-cloud-config-repo)）。我向客户端的配置文件添加了一些新属性，并提交了更改到存储库。以下是客户端配置的当前版本：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I disabled security for Spring Boot Actuator endpoints by setting `management.security.enabled`
    to `false`. It is required to be able to call those endpoints without passing
    security credentials. I also added two test parameters, `sample.string.property`
    and `sample.int.property`, to demonstrate bean refresh mechanisms based on their
    values in the example. Spring Cloud provides some additional HTTP management endpoints
    for the Spring Boot Actuator. One of them is `/refresh`, which is responsible
    for reloading the bootstrap context and refreshing beans annotated with `@RefreshScope`.
    This is an HTTP `POST` method, which may be called on our client''s instance at `http://localhost:8081/refresh`.
    Before testing that functionality, we need to have the discovery and Config Servers
    running. The client application should be launched with the `--spring.profiles.active=zone1 `parameter.
    Here''s the class where the test properties `sample.string.property` and `sample.int.property`
    are injected into the fields:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过将`management.security.enabled`设置为`false`来禁用了Spring Boot Actuator端点的安全性。这是为了能够在不传递安全凭据的情况下调用这些端点。我还添加了两个测试参数，`sample.string.property`和`sample.int.property`，以演示基于其值的bean刷新机制。Spring
    Cloud为Spring Boot Actuator提供了一些额外的HTTP管理端点。其中之一是`/refresh`，负责重新加载引导上下文并刷新使用`@RefreshScope`注释的bean。这是一个HTTP
    `POST`方法，可以在我们客户端实例的`http://localhost:8081/refresh`上调用。在测试该功能之前，我们需要运行发现和配置服务器。客户端应用程序应该使用`--spring.profiles.active=zone1`参数启动。以下是测试属性`sample.string.property`和`sample.int.property`被注入到字段的类：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That bean is injected into the `ClientController` class and invoked inside
    the `ping` method, which is exposed at `http://localhost:8081/ping`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该bean被注入到`ClientController`类中，并在`ping`方法中调用，该方法在`http://localhost:8081/ping`上公开：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s change the values for test properties in `client-service-zone1.yml`
    and commit them. If you call the Config Server HTTP endpoint `/client-service/zone1`,
    you''ll see the newest values returned as a response. But when you call the `/ping`
    method exposed on the client application, you will still see older values visible
    on the left side of the following screen. Why? Although the Config Server automatically
    detects repository changes, the client application is not able to automatically
    refresh without any trigger. It requires a restart to read the newest settings,
    or we may force a configuration reload by invoking the previously described `/refresh`
    method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更改`client-service-zone1.yml`中的测试属性值并提交它们。如果您调用配置服务器的HTTP端点`/client-service/zone1`，您将看到最新的值作为响应返回。但是，当您调用客户端应用程序上公开的`/ping`方法时，您仍然会看到屏幕左侧显示的旧值。为什么？尽管配置服务器自动检测存储库更改，但客户端应用程序无法在没有任何触发器的情况下自动刷新。它需要重新启动以读取最新的设置，或者我们可以通过调用先前描述的`/refresh`方法来强制重新加载配置：
- en: '![](img/49a8d206-7a6b-4477-8b85-40b5427c13f9.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49a8d206-7a6b-4477-8b85-40b5427c13f9.png)'
- en: 'After calling the `/refresh` endpoint on the client application, you will see
    in the log files that the configuration has been reloaded. Now, if you invoke
    `/ping` one more time, the newest property values are returned in the response.
    That example illustrates how a hot reload works for a Spring Cloud application,
    but it is obviously not our target solution. The next step is to enable communication
    with the message broker:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 调用客户端应用程序上的`/refresh`端点后，您将在日志文件中看到配置已重新加载。现在，如果您再次调用`/ping`，最新的属性值将在响应中返回。该示例说明了热重载是如何为Spring
    Cloud应用程序工作的，但显然这不是我们的目标解决方案。下一步是启用与消息代理的通信：
- en: '![](img/7c79dd98-0c3d-45ae-a736-678d2cec1cb1.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c79dd98-0c3d-45ae-a736-678d2cec1cb1.png)'
- en: Consuming events from a message broker
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从消息代理中消费事件
- en: I have already mentioned that we may choose between two message brokers that
    are integrated with the Spring Cloud Bus. In this example, I'm going to show you
    how to run and use RabbitMQ. Let me just say a few words about that solution,
    because we are dealing with it for the first time in the book. RabbitMQ has grown
    into the most popular message broker software. It is written in Erlang and implements
    **Advanced Message Queueing Protocol** (**AMQP**). It is easy to use and configure,
    even if we are talking about such mechanisms as clustering or high availability.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到我们可以选择与Spring Cloud Bus集成的两个消息代理之间。在这个例子中，我将向您展示如何运行和使用RabbitMQ。让我简单介绍一下这个解决方案，因为这是我们在本书中第一次接触到它。RabbitMQ已经发展成为最流行的消息代理软件。它是用Erlang编写的，并实现了**高级消息队列协议**（**AMQP**）。即使涉及到诸如集群或高可用性等机制，它也很容易使用和配置。
- en: 'The most convenient way to run RabbitMQ on your machine is through a Docker
    container. Two ports have been exposed outside the container. The first of them
    is used for client connections (`5672`) and the second is dedicated to the management
    dashboard (`15672`). I also ran the image with the management tag to enable the
    UI dashboard, which is not available in the default version:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的计算机上运行RabbitMQ的最便捷方式是通过Docker容器。两个端口已经暴露在容器外。其中一个用于客户端连接（`5672`），另一个专用于管理仪表板（`15672`）。我还使用了管理标签来运行带有UI仪表板的镜像，这在默认版本中是不可用的：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To enable support for the RabbitMQ broker for our example client application,
    we should include the following dependency in `pom.xml`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的示例客户端应用程序启用对RabbitMQ代理的支持，我们应该在`pom.xml`中包含以下依赖项：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That library contains auto-configuration settings. Because I run Docker on
    Windows, I need to override some default properties. The full service configuration
    is stored inside a Git repository, so the changes affect only remote files. We
    should add the following parameters to the previously used version of the client''s
    property source:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该库包含自动配置设置。因为我在Windows上运行Docker，所以我需要覆盖一些默认属性。完整的服务配置存储在Git存储库中，因此更改仅影响远程文件。我们应该向先前使用的客户端属性源版本添加以下参数：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you run the client application, an exchange and a queue would be automatically
    created in RabbitMQ. You can easily check this out by logging in to the management
    dashboard available at `http://192.168.99.100:15672`. The default username and
    password are `guest/guest`. Here''s the screen from my RabbitMQ instance. There
    is one exchange with the name `SpringCloudBus` created, with two bindings to the
    client queue and Config Server queue (I have already run it with the changes described
    in the next section). At this stage, I wouldn''t like to go into the detail about
    RabbitMQ and its architecture. A good place for such a discussion would be in
    the [Chapter 11](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml), *Message-Driven
    Microservices* on the Spring Cloud Stream project:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行客户端应用程序，RabbitMQ中将自动创建一个交换和一个队列。您可以通过登录到`http://192.168.99.100:15672`上的管理仪表板轻松检查这一点。默认用户名和密码为`guest/guest`。这是我RabbitMQ实例的屏幕。已创建一个名为`SpringCloudBus`的交换，与客户端队列和配置服务器队列绑定了两次（我已经运行了下一节中描述的更改）。在这个阶段，我不想深入讨论RabbitMQ及其架构的细节。这样的讨论的好地方将在[第11章](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml)中，*基于消息的微服务*，Spring
    Cloud Stream项目中：
- en: '![](img/c29e1292-6fa9-412f-812f-c60bb2ab2033.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c29e1292-6fa9-412f-812f-c60bb2ab2033.png)'
- en: Monitoring repository changes on a Config Server
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视配置服务器上的存储库更改
- en: 'Spring Cloud Config Server has to perform two tasks in the previously described
    process. First of all, it has to detect changes in a `property` file stored in
    a Git repository. This may be achieved by exposing a special endpoint, which would
    be called through a WebHook by the repository provider. The second step is to
    prepare and send a `RefreshRemoteApplicationEvent` targeted at the applications
    that might have been changed.  This in turn requires us to establish connection
    with a message broker. The `spring-cloud-config-monitor` library is responsible
    for enabling the `/monitor` endpoint. To enable support for the RabbitMQ broker,
    we should include the same starter artifact as for the client application:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config Server在先前描述的过程中必须执行两项任务。首先，它必须检测存储在Git存储库中的`property`文件的更改。这可以通过公开一个特殊的端点来实现，该端点将通过存储库提供程序的WebHook调用。第二步是准备并发送针对可能已更改的应用程序的`RefreshRemoteApplicationEvent`。这反过来要求我们与消息代理建立连接。`spring-cloud-config-monitor`库负责启用`/monitor`端点。要启用对RabbitMQ代理的支持，我们应该包含与客户端应用程序相同的启动器工件：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'That''s not all. The configuration monitor should also be activated in `application.yml`.
    Because each repository provider has a dedicated implementation in Spring Cloud,
    it is necessary to select which of them should be enabled:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是全部。配置监视器还应在`application.yml`中激活。由于每个存储库提供程序在Spring Cloud中都有专用的实现，因此有必要选择其中哪些应该启用：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The change detection mechanism may be customized. By default, it detects changes
    in files that match the application name. To override that behavior, you need
    to provide a custom implementation of `PropertyPathNotificationExtractor`. It
    accepts the request headers and body parameters, and returns a list of file paths
    that have been changed. To support notifications from GitHub, we may use `GithubPropertyPathNotificationExtractor`
    provided by `spring-cloud-config-monitor`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 变更检测机制可以进行定制。默认情况下，它会检测与应用程序名称匹配的文件的更改。要覆盖该行为，您需要提供`PropertyPathNotificationExtractor`的自定义实现。它接受请求标头和主体参数，并返回已更改的文件路径列表。为了支持来自GitHub的通知，我们可以使用`spring-cloud-config-monitor`提供的`GithubPropertyPathNotificationExtractor`：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Simulating change events manually
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动模拟更改事件
- en: 'A monitor endpoint can be invoked by a WebHook configured on a Git repository
    provider such as GitHub, Bitbucket, or GitLab. Testing such a feature with the
    application running on localhost is troublesome. It turns out that we may easily
    simulate such a WebHook activation by calling `POST /monitor` manually. For example,
    the `Github` command should have the header `X-Github-Event` included in the request.
    The JSON body with changes in the `property` files should look as shown in this
    cURL request:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 监视端点可以由配置在GitHub、Bitbucket或GitLab等Git存储库提供程序上的WebHook调用。在本地主机上运行应用程序测试此功能是麻烦的。事实证明，我们可以通过手动调用`POST
    /monitor`轻松模拟此类WebHook激活。例如，`Github`命令应在请求中包含`X-Github-Event`标头。具有`property`文件更改的JSON主体应如此cURL请求所示：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, let's change and commit a value of one property in the `client-service-zone1.yml`
    file, for example, `sample.int.property`. Then, we may call the `POST /monitor`
    method with the parameters shown in the previous example command. If you configured
    everything according to my descriptions, you should  see the following log line
    on your client application side, `Received remote refresh request. Keys refreshed
    [sample.int.property]`. If you call the `/ping` endpoint exposed by the client
    microservice, it should return the newest value of the changed property.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更改并提交`client-service-zone1.yml`文件中一个属性的值，例如`sample.int.property`。然后，我们可以使用前面示例命令中显示的参数调用`POST
    /monitor`方法。如果您根据我的描述进行了配置，您应该在客户端应用程序端看到以下日志行，`Received remote refresh request.
    Keys refreshed [sample.int.property]`。如果您调用客户端微服务公开的`/ping`端点，它应该返回更改属性的最新值。
- en: Testing locally with a GitLab instance
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地使用GitLab实例进行测试
- en: 'For those who do not prefer simulating events, I''m proposing a more practical
    exercise. However, I would point out that it requires not only development skills
    from you, but also a basic knowledge of Continuous Integration tools. We will
    start by running a GitLab instance locally using its Docker image. GitLab is an
    open sourced web-based Git repository manager with wiki and issue tracking features.
    It is very similar to such tools as GitHub or Bitbucket, but may be easily deployed
    on your local machine:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不喜欢模拟事件的人，我提出了一个更实际的练习。但是，我要指出，这不仅需要您的开发技能，还需要对持续集成工具有基本的了解。我们将从使用其Docker镜像在本地运行GitLab实例开始。GitLab是一个开源的基于Web的Git存储库管理器，具有维基和问题跟踪功能。它与GitHub或Bitbucket等工具非常相似，但可以轻松部署在您的本地机器上：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A web dashboard is available at `http://192.168.99.100:10080`. The first step
    is to create an admin user and then log in using the credentials provided. I won''t
    go into the details of GitLab. It has a user-friendly and intuitive GUI interface,
    so I''m pretty sure you will able to handle it without too much effort. Anyway,
    going forward, I created a project in GitLab with the name `sample-spring-cloud-config-repo`.
    It may be cloned from `http://192.168.99.100:10080/root/sample-spring-cloud-config-repo.git`.
    I committed there the same set of configuration files, which is available in our
    example repository on GitHub.  The next step is to define a WebHook that invokes
    the Config Server''s `/monitor` endpoint with a push notification. To add a new
    WebHook for the project, you need to go to the Settings | Integration section
    and then fill in the URL field with the server address (use your hostname instead
    of localhost). Leave the Push events checkbox selected:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网络仪表板可在`http://192.168.99.100:10080`找到。第一步是创建一个管理员用户，然后使用提供的凭据登录。我不会详细介绍GitLab。它有一个用户友好和直观的GUI界面，所以我相信你能够轻松处理它。无论如何，接下来，我在GitLab中创建了一个名为`sample-spring-cloud-config-repo`的项目。它可以从`http://192.168.99.100:10080/root/sample-spring-cloud-config-repo.git`克隆。我在那里提交了与我们在GitHub示例存储库中可用的相同一组配置文件。下一步是定义一个WebHook，用于通过推送通知调用Config
    Server的`/monitor`端点。要为项目添加新的WebHook，您需要转到设置|集成部分，然后在URL字段中填写服务器地址（使用您的主机名而不是localhost）。保留Push
    events复选框选中：
- en: '![](img/d7c24aea-9d7a-45ed-b69f-b6aa818239d7.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7c24aea-9d7a-45ed-b69f-b6aa818239d7.png)'
- en: 'In comparison with the Config Server implementation with GitHub as a backend
    repository provider, we need to change the enabled monitor type in `application.yml`
    and of course provide a different address:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与以GitHub作为后端存储库提供程序的Config Server实现相比，我们需要在`application.yml`中更改启用的监视器类型，并且当然提供不同的地址：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We should also register another bean implementing `PropertyPathNotificationExtractor`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注册另一个实现`PropertyPathNotificationExtractor`的bean：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, you may make and push some changes in the configuration files. The
    WebHook should be activated and the client application's configuration should
    be refreshed. That is the last example in this chapter; we may proceed to the
    conclusion.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以对配置文件进行一些更改并推送。WebHook应该被激活，并且客户端应用程序的配置应该被刷新。这是本章的最后一个示例；我们可以继续进行结论。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I have described the most important features of a Spring Cloud
    Config project. The same as for service discovery, we started from the basics,
    a simple use case on the client and server sides. We discussed the different backend
    repository types for a Config Server. I implemented the examples illustrating
    how to use filesystem, Git, and even third-party tools such as Vault as a repository
    for your `property` files. I put particular focus on interoperability with other
    components, such as service discovery or multiple instances of microservices within
    a larger system. Finally, I showed you how to reload an application's configuration
    without restart, based on WebHooks and a message broker. To conclude, after reading
    this chapter you should be able to use Spring Cloud Config as one element of your
    microservice-based architecture and take an advantage of its main features.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了Spring Cloud Config项目的最重要特性。与服务发现一样，我们从基础知识开始，从客户端和服务器端的简单用例开始。我们讨论了Config
    Server的不同后端存储库类型。我实现了一些示例，说明如何使用文件系统、Git，甚至第三方工具（如Vault）作为`property`文件的存储库。我特别关注与其他组件的互操作性，例如服务发现或在更大系统中的多个微服务实例。最后，我向您展示了如何基于WebHooks和消息代理重新加载应用程序的配置而无需重新启动。总之，在阅读完本章后，您应该能够将Spring
    Cloud Config作为微服务架构的一个元素，并利用其主要特性。
- en: After we have discussed an implemetation of service discovery and configuration
    server with Spring Cloud, we may proceed to an inter-service communication. In
    the next two chapters we will analyze basic and some more advanced samples that
    illustrate synchronous communication between a few microservices.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论了使用Spring Cloud实现服务发现和配置服务器之后，我们可以继续进行服务间通信。在接下来的两章中，我们将分析一些基本和一些更高级的示例，这些示例说明了几个微服务之间的同步通信。
