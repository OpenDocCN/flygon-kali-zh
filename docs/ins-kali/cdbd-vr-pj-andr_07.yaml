- en: Chapter 7. 360-Degree Gallery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。360度画廊
- en: 360-degree photos and videos are a different approach to virtual reality. Rather
    than rendering 3D geometry in real time with OpenGL, you're letting users look
    around a prerendered or photographed scene. 360-degree viewers are a great way
    to introduce consumers to VR because they give a very natural experience and are
    easy to produce. It is much easier to take a photo than to render a photorealistic
    scene of objects in real time. Images are easy to record with a new generation
    of 360-degree cameras, or the photosphere feature in the Google Camera app. Viewing
    prerecorded images requires much less computer power than rendering full 3D scenes,
    and this works well on mobile Cardboard viewers. Battery power should also be
    less of an issue.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 360度全景照片和视频是虚拟现实的一种不同方法。与使用OpenGL实时渲染3D几何图形不同，您让用户四处查看一个预先渲染或拍摄的场景。360度查看器是向消费者介绍VR的绝佳方式，因为它们提供了非常自然的体验，并且易于制作。拍摄照片比实时渲染物体的逼真场景要容易得多。使用新一代360度摄像机或Google相机应用程序中的全景图像功能很容易记录图像。查看预先录制的图像需要比渲染完整的3D场景需要更少的计算机功率，并且在移动Cardboard查看器上运行良好。电池电量也不应该是一个问题。
- en: Non-VR 360-degree media has become fairly common. For example, for many years
    real-estate listing sites have provided panoramic walkthroughs with a web-based
    player that lets you interactively view the space. Similarly, YouTube supports
    the uploading and playback of 360-degree videos and provides a player with interactive
    controls to look around during playback. Google Maps lets you upload 360-degree
    still photosphere images, much like their Street View tool, that you can create
    with an Android or iOS app (for more information, visit [https://www.google.com/maps/about/contribute/photosphere/](https://www.google.com/maps/about/contribute/photosphere/))
    or a consumer 360 camera. The Internet is teeming with 360-degree media!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 非VR 360度媒体已经相当普遍。例如，多年来，房地产列表网站提供了带有基于网络的播放器的全景漫游，让您可以交互地查看空间。同样，YouTube支持上传和播放360度视频，并提供一个带有交互式控件的播放器，可以在播放期间四处查看。Google地图允许您上传360度静态全景图像，就像他们的街景工具一样，您可以使用Android或iOS应用程序（有关更多信息，请访问[https://www.google.com/maps/about/contribute/photosphere/](https://www.google.com/maps/about/contribute/photosphere/)）或消费者360摄像机创建。互联网上充斥着360度媒体！
- en: Viewing 360-degree media in VR is surprisingly immersive, even for still photos
    (and even without a pair of stereoscopic images). You're standing at the center
    of a sphere with an image projected onto the inside surface, but you feel like
    you're really there in the captured scene. Simply turn your head to look around.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中查看360度媒体令人惊讶地沉浸，即使是静态照片（甚至没有成对的立体图像）。你站在一个球体的中心，图像投影在内表面上，但你感觉自己真的在被捕捉的场景中。只需转动头部来四处看。
- en: 'In this project, we''ll build a photo gallery that lets you browse photos on
    your phone. Regular flat pictures and panoramas will appear projected on a large
    screen to your left. But 360-degree photospheres will fully immerse you inside
    the spherical projection. We will accomplish this project by performing the following
    steps:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将构建一个照片库，让您可以在手机上浏览照片。常规的平面图片和全景照片将显示在您左侧的大屏幕上。但是360度全景照片将完全沉浸您在球形投影中。我们将通过以下步骤完成这个项目：
- en: Setting up the new project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置新项目
- en: Viewing a 360-degree photosphere
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看360度全景照片
- en: Viewing a regular photo on a large virtual projection screen
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大型虚拟投影屏幕上查看常规照片
- en: Adding a frame border to the photos
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为照片添加边框
- en: Loading and displaying a photo image from your device's camera folder
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从设备的相机文件夹加载和显示照片图像
- en: Adjusting a photo's orientation and aspect ratio
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整照片的方向和长宽比
- en: Creating a user interface with a grid of thumbnail images for selecting the
    photo to be viewed with scrolling
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个用户界面，其中包含一个缩略图图像网格，用于选择要滚动查看的照片
- en: Ensuring a good, responsive VR experience with thread-safe operations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保良好的、响应迅速的VR体验，具有线程安全的操作
- en: Launching an Android image view intent app
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动Android图像查看意图应用程序
- en: The source code for this project can be found on the Packt Publishing website,
    and on GitHub at [https://github.com/cardbookvr/gallery360](https://github.com/cardbookvr/gallery360)
    (with each topic a separate commit).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的源代码可以在Packt Publishing网站上找到，并且在GitHub上也可以找到[https://github.com/cardbookvr/gallery360](https://github.com/cardbookvr/gallery360)（每个主题都是单独的提交）。
- en: Setting up the new project
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新项目
- en: 'To build this project, we''re going to use our `RenderBox` library created
    in [Chapter 5](ch05.html "Chapter 5. RenderBox Engine"), *RenderBox Engine*. You
    can use yours, or grab a copy from the download files provided with this book
    or our GitHub repo (use the commit tagged `after-ch6`—[https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch6](https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch6)).
    For a more detailed description of how to import the `RenderBox` library, refer
    to the final section, *Using RenderBox in future projects*, in [Chapter 5](ch05.html
    "Chapter 5. RenderBox Engine"), *RenderBox Engine*. To do this, perform the following
    steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这个项目，我们将使用我们在[第5章](ch05.html "第5章。RenderBox Engine")中创建的`RenderBox`库，*RenderBox
    Engine*。您可以使用您自己的库，或者从本书提供的下载文件或我们的GitHub存储库中获取一份副本（使用标记为`after-ch6`的提交——[https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch6](https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch6)）。有关如何导入`RenderBox`库的更详细描述，请参阅[第5章](ch05.html
    "第5章。RenderBox Engine")中的最后一节，*在未来项目中使用RenderBox*。要做到这一点，请执行以下步骤：
- en: With Android Studio opened, create a new project. Let's name it `Gallery360`
    and target **Android 4.4 KitKat (API 19)** with an **Empty Activity**.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Android Studio，创建一个新项目。让我们将其命名为`Gallery360`，并针对**Android 4.4 KitKat（API 19）**使用**空活动**。
- en: Create new modules for the `renderbox`, `common`, and `core` packages, using
    **File** | **New Module** | **Import .JAR/.AAR Package**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`renderbox`，`common`和`core`包创建新模块，使用**文件** | **新模块** | **导入.JAR/.AAR包**。
- en: Set the modules as dependencies for the app, using **File** | **Project Structure**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模块设置为应用程序的依赖项，使用**文件** | **项目结构**。
- en: Edit the `build.gradle` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, to compile against
    SDK 22.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据[第2章](ch02.html "第2章。骨架Cardboard项目")中的说明编辑`build.gradle`文件，*骨架Cardboard项目*，以便编译SDK
    22。
- en: Update `/res/layout/activity_main.xml` and `AndroidManifest.xml`, as explained
    in the previous chapters.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`/res/layout/activity_main.xml`和`AndroidManifest.xml`，如前几章所述。
- en: Edit `MainActivity` as `class MainActivity extends CardboardActivity implements
    IRenderBox`, and implement the interface method stubs (*Ctrl* + *I*).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MainActivity`编辑为`class MainActivity extends CardboardActivity implements IRenderBox`，并实现接口方法存根（*Ctrl*
    + *I*）。
- en: 'We can go ahead and define the `onCreate` method in `MainActivity`. The class
    now has the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续在`MainActivity`中定义`onCreate`方法。该类现在有以下代码：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'While we implement this project, we will be creating new classes that could
    be good extensions to `RenderBoxLib`. We''ll make them regular classes in this
    project at first. Then, at the end of the chapter, we''ll help you move them into
    the `RenderBoxLib` project and rebuild the library. Perform the following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实施这个项目的过程中，我们将创建一些可能成为`RenderBoxLib`的好扩展的新类。起初，我们将把它们作为这个项目中的常规类。然后，在本章末，我们将帮助您将它们移动到`RenderBoxLib`项目中，并重新构建库。执行以下步骤：
- en: Right-click on the `gallery360` folder (`com.cardbookvr.gallery360`) and go
    to **New** | **Package**, and name the package `RenderBoxExt`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`gallery360`文件夹（`com.cardbookvr.gallery360`），然后转到**新建** | **包**，并命名包为`RenderBoxExt`。
- en: Within `RenderBoxExt`, create package subfolders named `components` and `materials`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RenderBoxExt`中，创建名为`components`和`materials`的包子文件夹。
- en: There's no real technical need to make it a separate package but this helps
    organize our files, because the ones in `RenderBoxExt` will be moved into our
    reusable library at the end of this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 没有真正的技术需要将其作为一个单独的包，但这有助于组织我们的文件，因为`RenderBoxExt`中的文件将在本章末被移动到我们的可重用库中。
- en: 'You can add a cube to the scene, temporarily, to help ensure that everything
    is set up properly. Add it to the `setup` method as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将一个立方体临时添加到场景中，以确保一切设置正确。将其添加到`setup`方法中，如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you remember, a cube is a component that's added to a transform. The cube
    defines its geometry (for example, vertices). The transform defines its position,
    rotation, and scale in 3D space.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得的话，立方体是添加到变换中的一个组件。立方体定义了它的几何形状（例如，顶点）。变换定义了它在3D空间中的位置、旋转和缩放。
- en: You should be able to click on **Run 'app'** with no compile errors, and see
    the cube and Cardboard split screen view on your Android device.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在Android设备上点击**运行'app'**，没有编译错误，并看到立方体和Cardboard分屏视图。
- en: Viewing a 360-degree photo
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看360度照片
- en: Ever since it was discovered that the Earth is round, cartographers and mariners
    have struggled with how to project the spherical globe onto a two-dimensional
    chart. The result is an inevitable distortion of some areas of the globe.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 自从发现地球是圆的以来，制图师和水手们一直在努力将球形地球投影到二维图表上。结果是对地球某些区域的不可避免的失真。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about map projections and spherical distortions, visit [http://en.wikipedia.org/wiki/Map_projection](http://en.wikipedia.org/wiki/Map_projection).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于地图投影和球体失真的信息，请访问[http://en.wikipedia.org/wiki/Map_projection](http://en.wikipedia.org/wiki/Map_projection)。
- en: 'For 360-degree media, we typically use an equirectangular (or a meridian) projection
    where the sphere is unraveled into a cylindrical projection, stretching the texture
    as you progress toward the North and South poles while keeping the meridians as
    equidistant vertical straight lines. To illustrate this, consider Tissot''s Indicatrix
    (visit [http://en.wikipedia.org/wiki/Tissot%27s_indicatrix](http://en.wikipedia.org/wiki/Tissot%27s_indicatrix)
    for more information) that shows a globe with strategically arranged identical
    circles (an illustration by Stefan Kühn):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于360度媒体，我们通常使用等经纬（或子午线）投影，其中球体被展开成柱状投影，随着你向北极和南极推进，纹理会被拉伸，而经线则保持等距垂直直线。为了说明这一点，考虑提索特指示圈（访问[http://en.wikipedia.org/wiki/Tissot%27s_indicatrix](http://en.wikipedia.org/wiki/Tissot%27s_indicatrix)了解更多信息），它显示了一个球体，上面有战略性排列的相同圆圈（Stefan
    Kühn的插图）：
- en: '![Viewing a 360-degree photo](img/B05144_07_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![查看360度照片](img/B05144_07_01.jpg)'
- en: 'The following image shows the globe unwrapped with an equirectangular projection
    ([https://en.wikipedia.org/wiki/Equirectangular_projection](https://en.wikipedia.org/wiki/Equirectangular_projection)):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了使用等经纬投影（[https://en.wikipedia.org/wiki/Equirectangular_projection](https://en.wikipedia.org/wiki/Equirectangular_projection)）展开的地球：
- en: '![Viewing a 360-degree photo](img/B05144_07_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![查看360度照片](img/B05144_07_02.jpg)'
- en: We will use an equirectangular mesh for our photospheres and an appropriately
    projected (warped) image for its texture map. To view, we place the camera viewpoint
    at the center of the sphere and render the image onto the inside surface.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的全景照片使用等经纬网格和适当投影（扭曲）的图像作为纹理贴图。为了查看，我们将相机视点放在球体的中心，并将图像渲染到内表面。
- en: You may have noticed that our Earth and other planet textures had the same sort
    of distortion on them. It's a pretty common way to map spherical images to flat
    ones, and in fact, we've been "doing the math" on this problem ever since we created
    the UVs for our sphere in [Chapter 6](ch06.html "Chapter 6. Solar System"), *Solar
    System*! You'll have to get clever with UV offsets to keep them from appearing
    stretched, but you should also be able to display panoramic photos on a sphere
    in the same way.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们的地球和其他行星纹理上有相同类型的失真。这是将球形图像映射到平面图像的一种常见方式，事实上，自从我们在[第6章](ch06.html
    "第6章。太阳系")中为我们的球体创建UV以来，我们一直在“计算”这个问题！您将不得不在UV偏移上下些功夫，以防止它们出现拉伸，但您也应该能够以同样的方式在球体上显示全景照片。
- en: Viewing a sample photosphere
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看一个样本全景照片
- en: 'You may choose any 360-degree equirectangular image for this topic. We''ve
    included the following beach photo with this book, named `sample360.jpg`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为这个主题选择任何360度等经纬图像。我们在本书中包含了以下海滩照片，名为`sample360.jpg`：
- en: '![Viewing a sample photosphere](img/B05144_07_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![查看示例全景照片](img/B05144_07_03.jpg)'
- en: Add it to your project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将其添加到您的项目中。
- en: 'Copy the image you want to view into the project''s `res/drawable/` folder.
    Now add the following code to the `MainActivity.java` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将要查看的图像复制到项目的`res/drawable/`文件夹中。现在将以下代码添加到`MainActivity.java`文件中：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that multiplying the scale by 0.99 avoids unwanted clipping of the background
    image due to floating point precision errors on some phones. Using a negative
    scale *y* axis compensates for inverted rendering by the texture shader (alternatively
    you could modify the shader code).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将比例乘以0.99可以避免由于某些手机上的浮点精度错误而导致背景图像的不必要剪裁。使用负比例*y*轴可以补偿纹理着色器的反向渲染（或者您可以修改着色器代码）。
- en: You can replace the drawable filename, `R.drawable.sample360`, with yours, as
    defined in the `DEFAULT_BACKGROUND` variable. This variable must be final, as
    required by the Android resource system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用您的文件名替换可绘制的文件名`R.drawable.sample360`，如`DEFAULT_BACKGROUND`变量中所定义的那样。这个变量必须是final的，根据Android资源系统的要求。
- en: In the `setup` method, we create a `Sphere` component as we have been doing
    all along. Start with a new transform, scale it, then add a new `Sphere` component
    with our resource ID to the transform. We're naming the object `background` because
    later on, this object will be the default background for the app.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup`方法中，我们像一直以来一样创建一个`Sphere`组件。从一个新的变换开始，缩放它，然后向变换添加一个新的`Sphere`组件，带有我们的资源ID。我们将对象命名为`background`，因为以后，这个对象将成为应用程序的默认背景。
- en: Run the app, and insert your phone into a Cardboard viewer. Voila! You're in
    Margaritaville!! If that seemed really easy, you're right; it was! Really, the
    hard work was done for us by the photosphere app or whatever transformed the image
    into an equirectangular projection. The rest of it is the standard UV projection
    math we've been doing all along!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，并将手机插入Cardboard查看器中。哇！你来到了Margaritaville！如果这看起来很容易，那么你是对的；它确实很容易！实际上，艰苦的工作是由全景应用程序或其他将图像转换为等距投影的应用程序完成的。其余的工作就是我们一直在做的标准UV投影数学！
- en: '![Viewing a sample photosphere](img/B05144_07_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![查看示例全景照片](img/B05144_07_04.jpg)'
- en: Using the background image
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用背景图像
- en: We're going to make a gallery that lets the user pick from a number of images.
    It would be nice if the user saw something more neutral when they first started
    the app. A more appropriate background image is included with the downloadable
    files for this book. It is named `bg.png` and contains a regular grid. Copy it
    to your `res/drawable/` folder. Then, change `DEFAULT_BACKGROUND` to `R.drawable.bg`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个画廊，让用户从多张图片中选择。当用户第一次启动应用程序时，如果用户看到一些更中性的东西会很好。这本书的可下载文件中包含了一个更合适的背景图像。它的名称是`bg.png`，包含一个常规的网格。将其复制到您的`res/drawable/`文件夹中。然后，将`DEFAULT_BACKGROUND`更改为`R.drawable.bg`。
- en: '![Using the background image](img/B05144_07_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![使用背景图像](img/B05144_07_05.jpg)'
- en: 'Rerun the app, and it should look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行应用程序，应该看起来像这样：
- en: '![Using the background image](img/B05144_07_06.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![使用背景图像](img/B05144_07_06.jpg)'
- en: Viewing a regular photo
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看常规照片
- en: Now that we got that done, let's prepare our app to also be able to view regular
    flat photos. We'll do this by rendering them onto a plane. So first we need to
    define a `Plane` component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个，让我们准备我们的应用程序也能够查看常规的平面照片。我们将通过将它们渲染到一个平面上来实现这一点。所以首先我们需要定义一个`Plane`组件。
- en: Defining the Plane component and allocating buffers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义Plane组件并分配缓冲区
- en: The `Plane` component rightfully belongs to the `RenderBox` library, but for
    the time being, we'll add it directly to the app.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plane`组件理所当然地属于`RenderBox`库，但目前，我们将直接将其添加到应用程序中。'
- en: 'Create a new Java class file in the `RenderBoxExt/components/` folder, and
    name it `Plane`. Define it as `extends RenderObject`, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RenderBoxExt/components/`文件夹中创建一个新的Java类文件，并将其命名为`Plane`。将其定义为`extends RenderObject`，如下所示：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As with other geometry in the `RenderBox` library, we''ll define the plane
    with triangles. Simply two adjacent triangles are required, a total of six indices.
    The following data arrays define our default plane''s 3D coordinates, UV texture
    coordinates, vertex colors (middle gray), normal vectors, and corresponding indices.
    Add the following code at the top of the class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与`RenderBox`库中的其他几何图形一样，我们将用三角形定义平面。只需要两个相邻的三角形，总共六个索引。以下数据数组定义了我们默认平面的3D坐标、UV纹理坐标、顶点颜色（中灰色）、法线向量和相应的索引。在类的顶部添加以下代码：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can define the `Plane` constructor that calls an `allocateBuffers`
    helper method that allocates buffers for vertices, normals, textures, and indexes.
    Let''s declare variables for these at the top of the class, and write the methods:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义`Plane`构造函数，调用`allocateBuffers`辅助方法为顶点、法线、纹理和索引分配缓冲区。让我们在类的顶部声明这些变量，并编写方法：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, we ensure that `allocateBuffers` is run only once by checking whether
    `vertexBuffer` is null. (Note that we've decided to declare the buffers `public`
    to afford future flexibility to create arbitrary texture materials for objects.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们通过检查`vertexBuffer`是否为空来确保`allocateBuffers`只运行一次。（请注意，我们决定将缓冲区声明为`public`，以便将来可以为对象创建任意纹理材料。）
- en: Adding materials to the Plane component
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向Plane组件添加材质
- en: 'Next, we can add an appropriate material to the `Plane`, one that uses a texture
    image. Using a constructor API pattern that is consistent with the built-in `Sphere`
    component in [Chapter 6](ch06.html "Chapter 6. Solar System"), *Solar System*,
    we''ll add the ability to call a new `Plane` with an image texture ID and an optional
    lighting Boolean flag. Then, we''ll add helper methods to allocate the corresponding
    `Material` objects and set their buffers:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以向`Plane`添加一个适当的材质，使用纹理图像。使用与内置`Sphere`组件在[第6章](ch06.html "第6章 太阳系")*太阳系*中一致的构造函数API模式，我们将添加调用一个新的`Plane`的能力，带有图像纹理ID和可选的光照布尔标志。然后，我们将添加帮助方法来分配相应的`Material`对象并设置它们的缓冲区：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Adding an image screen to the scene
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向场景添加图像屏幕
- en: We can now add an image to the scene in `MainActivity`. Soon we will take a
    look at the phone's photos folder for pictures, but at this point, you can just
    use the same (photosphere) one that we used earlier (or drop another in your `res/drawable`
    folder). Note that you might have issues displaying an image that is too large
    for a phone's GPU. We will take a look at this issue later, so try to keep it
    less than 4,096 pixels in either dimension.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`MainActivity`中向场景添加图像了。很快我们将在手机的照片文件夹中查看照片，但在这一点上，你可以使用我们之前使用过的相同（全景）照片（或者将另一张放在你的`res/drawable`文件夹中）。请注意，如果图像对于手机的GPU来说太大，可能会出现显示问题。我们稍后会解决这个问题，所以尽量保持在任何维度上小于4096像素。
- en: Name the object `screen` because later on, we'll use it to project whichever
    photo the user selects from a gallery.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象命名为`screen`，因为稍后我们将用它来投影用户从画廊中选择的照片。
- en: 'In `MainActivity.java`, update the `setup` function to add the image to the
    scene, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity.java`中，更新`setup`函数以添加图像到场景中，如下所示：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The screen is scaled to 4 units (in X and Y) and placed 5 units in front of
    the camera. That's like sitting 5 meters (15 feet) from an 8 meter wide movie
    screen!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕按4个单位（在X和Y方向）缩放，并放置在相机前方5个单位。这就像坐在离8米宽的电影屏幕5米（15英尺）远的地方！
- en: 'Also, note that we rotate the plane 180 degrees on the *z* axis; otherwise,
    the image will appear upside down. Our world coordinate system has the up-direction
    along the positive *y* axis. However, UV space (for rendering textures) typically
    has the origin in the upper-left corner and positive is downward. (If you remember,
    in the previous chapter, this is why we also had to flip the Earth). Later in
    this chapter, when we implement an `Image` class, we''ll read the actual orientation
    from the image file and set the rotation accordingly. Here''s our screen plane
    with the image (viewed from an angle):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意我们在*z*轴上将平面旋转了180度；否则，图像将会颠倒。我们的世界坐标系的上方向沿着正*y*轴。然而，UV空间（用于渲染纹理）通常将原点放在左上角，并且正向是向下的。（如果你记得，在上一章中，这就是为什么我们还必须翻转地球的原因）。在本章后面，当我们实现一个`Image`类时，我们将从图像文件中读取实际的方向并相应地设置旋转。这是我们的带有图像的屏幕平面（从一个角度看）：
- en: '![Adding an image screen to the scene](img/B05144_07_07.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![向场景添加图像屏幕](img/B05144_07_07.jpg)'
- en: 'It will be convenient to separate the screen plane (with its image texture)
    from the placement and size of the screen. We will see why this is important later,
    but it has to do with scaling and rotating based on image parameters. Let''s refactor
    the code so that the screen is parented by a `screenRoot` transform as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将屏幕平面（及其图像纹理）与屏幕的放置和大小分开将是方便的。我们稍后会看到这为什么很重要，但这与根据图像参数进行缩放和旋转有关。让我们重构代码，使屏幕由`screenRoot`变换作为父级，如下所示：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Putting a border frame on the image
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图像上放置边框
- en: Pictures look best in a frame. Let's add one now. There are a number of ways
    to accomplish this, but we are going to use shaders. The frame will also be used
    for the thumbnail images and will enable us to change colors to highlight when
    the user selects an image. Furthermore, it helps define a region of contrast,
    which ensures that you can see the edge of any image on any background.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图像在框架中看起来最好。让我们现在添加一个。有许多方法可以实现这一点，但我们将使用着色器。这个框架也将用于缩略图图像，并且将使我们能够更改颜色以突出显示用户选择图像时的区域。此外，它有助于定义对比区域，确保您可以在任何背景上看到任何图像的边缘。
- en: Border shaders
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边框着色器
- en: We can start by writing the shader programs which, among other things, define
    the variables they will need from the `Material` object that uses it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先编写着色器程序，其中包括从使用它的`Material`对象中定义它们需要的变量。
- en: If necessary, create a resource directory for the shaders, `res/raw/`. Then,
    create the `border_vertex.shader` and `border_fragment.shader` files. Define them
    as follows.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，为着色器创建一个资源目录`res/raw/`。然后，创建`border_vertex.shader`和`border_fragment.shader`文件。定义如下。
- en: The `border_vertex` shader is identical to the `unlit_tex_vertex` shader that
    we were using.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`border_vertex`着色器与我们之前使用的`unlit_tex_vertex`着色器是相同的。'
- en: 'File: `res/raw/border_vertex.shader`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`res/raw/border_vertex.shader`
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For the `border_fragement` shader, we add variables for a border color (`u_Color`)
    and width (`u_Width`). Then, add a bit of logic to decide whether the current
    coordinate being rendered is on the border or in the texture image:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`border_fragement`着色器，我们添加了边框颜色（`u_Color`）和宽度（`u_Width`）的变量。然后，添加一些逻辑来决定当前渲染的坐标是在边框上还是在纹理图像中：
- en: 'File: `res/raw/border_fragment.shader`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`res/raw/border_fragment.shader`
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that this technique cuts off the edges of the image. We found this to
    be acceptable, but if you really want to see the entire image, you can offset
    the UV coordinates within the `texture2D` sampler call. It would look something
    like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种技术会切掉图像的边缘。我们发现这是可以接受的，但如果你真的想看到整个图像，你可以在`texture2D`采样调用中偏移UV坐标。它会看起来像这样：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, observant readers might notice that when the plane is scaled non-uniformly
    (to make it a rectangle), the border will be scaled so that the vertical borders
    might be thicker or thinner than the horizontal borders. There are a number of
    ways to fix this, but this is left as an exercise for the (over-achieving) reader.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，细心的读者可能会注意到，当平面被非均匀缩放（使其成为矩形）时，边框将被缩放，使得垂直边框可能比水平边框更厚或更薄。有许多方法可以解决这个问题，但这留给（过度努力的）读者作为练习。
- en: The border material
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边框材质
- en: 'Next, we define the material for the border shader. Create a new Java class
    in `RenderBoxExt/materials/` named `BorderMaterial` and define it as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为边框着色器定义材质。在`RenderBoxExt/materials/`中创建一个名为`BorderMaterial`的新Java类，并定义如下：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add material variables for the texture ID, border width, and color. Then, add
    variables for the shader program references and buffers, as shown in the following
    code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为纹理ID、边框宽度和颜色添加材质变量。然后，添加着色器程序引用和缓冲区的变量，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can add a constructor. As we''ve seen earlier, it calls a `setupProgram`
    helper method that creates the shader program and obtains references to its parameters:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加一个构造函数。正如我们之前所见，它调用一个`setupProgram`辅助方法，该方法创建着色器程序并获取对其参数的引用：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Likewise, we add a `setBuffers` method to be called by the `RenderObject` component
    (`Plane`):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们添加一个`setBuffers`方法，该方法将由`RenderObject`组件（`Plane`）调用：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Provide a setter method for the texture ID:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为纹理ID提供一个setter方法：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the draw code, which will be called from the `Camera` component, to render
    the geometry prepared in the buffers (via `setBuffer`). The draw method looks
    like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 添加绘制代码，该代码将从`Camera`组件调用，以渲染通过`setBuffer`准备的几何图形。绘制方法如下：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One more thing; let''s provide a method to destroy an existing material:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事；让我们提供一个销毁现有材质的方法：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using the border material
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用边框材质
- en: 'To use the `BorderMaterial` class instead of the default `UnlitTexMaterial`
    class, we wrote in the `Plane` class previously, we can add it to the `Plane`
    Java class, as follows. We plan to create the material outside the `Plane` class
    (in `MainActivity`), so we just need to set it up. In `Plane.java`, add the following
    code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`BorderMaterial`类而不是先前在`Plane`类中编写的默认`UnlitTexMaterial`类，我们可以将其添加到`Plane`Java类中，如下所示。我们计划在`Plane`类之外（在`MainActivity`中）创建材质，因此我们只需要设置它。在`Plane.java`中，添加以下代码：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In `MainActivity`, modify the `setupScreen` method to use this material instead
    of the default one, as follows. We first create the material and set the texture
    to our sample image. We don’t need to set the color, which will default to black.
    Then we create the screen plane and set its material. And then create the transform
    and add the screen component:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`中，修改`setupScreen`方法以使用此材质而不是默认材质，如下所示。我们首先创建材质并将纹理设置为我们的示例图像。我们不需要设置颜色，默认为黑色。然后我们创建屏幕平面并设置其材质。然后创建变换并添加屏幕组件：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you run it now, it should look something like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行它，它应该看起来像这样：
- en: '![Using the border material](img/B05144_07_08.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![使用边框材质](img/B05144_07_08.jpg)'
- en: Loading and displaying a photo image
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和显示照片图像
- en: So far, we've used images in the project's `drawable` resource folder. The next
    step is to read photo images from the phone and display one on our virtual screen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在项目的`drawable`资源文件夹中使用图像。下一步是从手机中读取照片图像并在虚拟屏幕上显示其中一个。
- en: Defining the image class
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义图像类
- en: 'Let''s make a placeholder `Image` class. Later on, we''ll build the attributes
    and methods. Define it as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制作一个占位符`Image`类。稍后，我们将构建属性和方法。定义如下：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We define a constructor that takes the image's full path. We also provide a
    validation method that checks whether the path is actually for an image, based
    on the filename extension. We don't want to load and bind the image data on construction
    because we don't want to load all the images at once; as you'll see, we will manage
    these intelligently using a worker thread.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个构造函数，该构造函数接受图像的完整路径。我们还提供一个验证方法，该方法检查路径是否实际上是图像，基于文件名扩展名。我们不想在构造时加载和绑定图像数据，因为我们不想一次加载所有图像；正如您将看到的，我们将使用工作线程来智能地管理这些。
- en: Reading images into the app
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将图像读入应用程序
- en: 'Now in `MainActivity`, access the photos folder on the phone and build a list
    of images in our app. The following `getImageList` helper method looks in the
    given folder path and instantiates a new `Image` object for each file found:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`MainActivity`中，访问手机上的照片文件夹，并在我们的应用程序中构建图像列表。以下`getImageList`辅助方法查找给定文件夹路径，并为找到的每个文件实例化一个新的`Image`对象：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use this method in the `setup` method, passing in the name of the camera images
    folder path, as follows (your path may vary):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup`方法中使用此方法，传入相机图像文件夹路径的名称，如下所示（您的路径可能有所不同）：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Also, ensure that the following line is included in your `AndroidManifest.xml`
    file, giving the app the permission to read the device''s external storage. Technically,
    you should already have this permission when using the Cardboard SDK:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保在您的`AndroidManifest.xml`文件中包含以下行，以赋予应用程序读取设备外部存储的权限。从技术上讲，使用Cardboard SDK时，您应该已经拥有此权限：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can add a log message to the `getImageList` loop and run it to verify that
    it is finding files. If not, you may need to discover the actual path to your
    photos folder.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向`getImageList`循环添加日志消息并运行它以验证它是否正在找到文件。如果没有，您可能需要发现您的照片文件夹的实际路径。
- en: This is the first project where we need to be really careful about permissions.
    Up until this point, the Cardboard SDK itself was the only thing which needed
    access to the filesystem, but now we need it for the app itself to function. If
    you are using a device with Andriod 6.0, and you don't make sure to compile the
    app against SDK 22, you will not be able to load the image files, and the app
    will either do nothing, or crash.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要非常小心权限的第一个项目。直到这一点，Cardboard SDK本身是唯一需要访问文件系统的东西，但现在我们需要它来使应用程序本身正常运行。如果您使用的是Andriod
    6.0的设备，并且您没有确保将应用程序编译为SDK 22，您将无法加载图像文件，应用程序要么无所作为，要么崩溃。
- en: If you are compiling against SDK 22 and you have the permission set up correctly
    in the manifest but you still get an empty file list, try looking for the correct
    path on your device with a file browser. It could very well be that the path we
    provided doesn't exist or is empty. And, of course, make sure that you have actually
    taken a picture with that device!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在针对SDK 22进行编译，并且在清单中正确设置了权限，但仍然获得空文件列表，请尝试使用文件浏览器在设备上查找正确的路径。很可能是我们提供的路径不存在或为空。当然，确保您确实使用该设备拍摄了照片！
- en: Image load texture
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像加载纹理
- en: If you remember, in [Chapter 6](ch06.html "Chapter 6. Solar System"), *Solar
    System,* we wrote a `loadTexture` method that reads a static image from the project's
    `res/drawable` folder into a memory bitmap and binds it to the texture in OpenGL.
    Here, we're going to do something similar but source the images from the phone's
    camera path and provide methods for additional processing, such as resizing and
    rotating its orientation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，在[第6章](ch06.html "第6章。太阳系")*太阳系*中，我们编写了一个`loadTexture`方法，该方法从项目的`res/drawable`文件夹中读取静态图像到内存位图，并将其绑定到OpenGL中的纹理。在这里，我们将做类似的事情，但是从手机的相机路径中获取图像，并提供额外处理的方法，例如调整大小和旋转方向。
- en: 'At the top of the `Image` class, add a variable to hold the current texture
    handle:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Image`类的顶部，添加一个变量来保存当前的纹理句柄：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The image''s `loadTexture` method, given a path to an image file, will load
    an image file into a bitmap and then convert it to a texture. (This method will
    be called from `MainActivity` with the app''s `CardboardView` class.) Write it
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的`loadTexture`方法，给定图像文件的路径，将图像文件加载到位图中，然后将其转换为纹理。（此方法将从`MainActivity`中的应用程序的`CardboardView`类中调用。）编写如下：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We added a small (but important) optimization, checking whether the texture
    has already been loaded; don't do it again if not needed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个小的（但重要的）优化，检查纹理是否已经加载；如果不需要，就不要再次加载。
- en: 'Our implementation of `bitmapToTexture` is shown in the following code. Given
    a bitmap, it binds the bitmap to an OpenGL ES texture (with some error checking).
    Add the following code to `Image`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`bitmapToTexture`的实现如下所示。给定一个位图，它将位图绑定到OpenGL ES纹理（带有一些错误检查）。将以下代码添加到`Image`中：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Showing an image on the screen
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在屏幕上显示图像
- en: Let's show one of our camera images in the app, say, the first one.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序中显示我们的相机图像之一，比如第一个。
- en: 'To show an image on the virtual screen, we can write a `show` method that takes
    the current `CardboardView` object and the `Plane` screen. It''ll load and bind
    the image texture and pass its handle to the material. In the `Image` class, implement
    the `show` method as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟屏幕上显示图像，我们可以编写一个`show`方法，该方法接受当前的`CardboardView`对象和`Plane`屏幕。它将加载和绑定图像纹理，并将其句柄传递给材质。在`Image`类中，实现`show`方法如下：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s use this stuff! Go to `MainActivity` and write a separate `showImage`
    method to load the image texture. And, temporarily, call it from `setup` with
    the first image that we find (you will need at least one image in your camera
    folder):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用这些东西！转到`MainActivity`并编写一个单独的`showImage`方法来加载图像纹理。然后，暂时从`setup`中调用它，使用我们找到的第一个图像（您的相机文件夹中至少需要一个图像）：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It now also makes sense to modify `setupScreen,` so it creates the screen but
    doesn't load an image texture onto it. Remove the call to `screenMaterial.setTexture`
    in there.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在修改`setupScreen`也是有意义的，因此它创建屏幕但不在其上加载图像纹理。删除其中的`screenMaterial.setTexture`调用。
- en: 'Now run the app, and you will see your own image on the screen. Here''s mine:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，您将在屏幕上看到自己的图像。这是我的：
- en: '![Showing an image on the screen](img/B05144_07_09.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![在屏幕上显示图像](img/B05144_07_09.jpg)'
- en: Rotating to the correct orientation
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转到正确的方向
- en: Some image file types keep track of their image orientation, particularly JPG
    files (`.jpg` or `.jpeg`). We can get the orientation value from the EXIF metadata
    included with the file written by the camera app. (For example, refer to [http://sylvana.net/jpegcrop/exif_orientation.html](http://sylvana.net/jpegcrop/exif_orientation.html).
    Note that some devices may not be compliant or contain different results.)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一些图像文件类型会跟踪它们的图像方向，特别是JPG文件（`.jpg`或`.jpeg`）。我们可以从文件中包含的EXIF元数据中获取方向值，该元数据由相机应用程序编写。（例如，请参阅[http://sylvana.net/jpegcrop/exif_orientation.html](http://sylvana.net/jpegcrop/exif_orientation.html)。请注意，某些设备可能不符合规定或包含不同的结果。）
- en: If the image is not JPG, we'll skip this step.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像不是JPG，我们将跳过此步骤。
- en: 'At the top of the `Image` class, declare a variable to hold the current image
    rotation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Image`类的顶部，声明一个变量来保存当前图像的旋转：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `rotation` value is stored as a `Quaternion` instance, as defined in our
    RenderBox math library. If you remember [Chapter 5](ch05.html "Chapter 5. RenderBox
    Engine"), *RenderBox Engine*, a quaternion represents a rotational orientation
    in three-dimensional space in a way that is more precise and less ambiguous than
    Euler angles. But Euler angles are more human-friendly, specifying an angle for
    each *x*, *y*, and *z* axes. So, we''ll set the quaternion using Euler angles
    based on the image orientation. Ultimately, we use a `Quaternion` here because
    it is the underlying type of `Transform.rotation`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotation`值存储为`Quaternion`实例，如我们的RenderBox数学库中定义的那样。如果您还记得[第5章](ch05.html "第5章。RenderBox引擎")*RenderBox引擎*，四元数表示三维空间中的旋转方向，比欧拉角更精确和更不含糊。但是欧拉角更符合人类的习惯，指定每个*x*、*y*和*z*轴的角度。因此，我们将根据图像的方向使用欧拉角设置四元数。最终，我们在这里使用`Quaternion`，因为它是`Transform.rotation`的基础类型：'
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we set the screen''s rotation in the `show` method of the `Image` class,
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`Image`类的`show`方法中设置屏幕的旋转，如下所示：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Run your project again. The image should be correctly oriented. Note that it
    is possible that your original image was fine all along. It will become easier
    to check whether your rotation code works once we get the thumbnail grid going.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行您的项目。图像应该被正确定向。请注意，您的原始图像可能一直都很好。一旦我们开始使用缩略图网格，检查旋转代码是否有效将变得更容易。
- en: '![Rotating to the correct orientation](img/B05144_07_10.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![旋转到正确的方向](img/B05144_07_10.jpg)'
- en: Dimensions to correct the width and height
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纠正宽度和高度的尺寸
- en: Square images are easy. But usually, photos are rectangular. We can get the
    actual width and height of the image and scale the screen accordingly, so the
    display won't show up distorted.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 方形图像很容易。但通常，照片是矩形的。我们可以获取图像的实际宽度和高度，并相应地缩放屏幕，以便显示不会出现扭曲。
- en: 'At the top of the `Image` class, declare variables to hold the current image
    width and height:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Image`类的顶部，声明变量来保存当前图像的宽度和高度：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, set them in `loadTexture` using bitmap options in the `decodeFile` method,
    as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`decodeFile`方法中使用位图选项设置它们，如下所示：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `decodeFile` call returns the image's width and height (among other information)
    in the options (refer to [http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html](http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`decodeFile`调用将返回选项中的图像宽度和高度（以及其他信息）（参考[http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html](http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html)）。'
- en: 'Now we can set the screen size in the `show` method of the `Image` class. We''ll
    normalize the scale so that the longer side is of size 1.0 and the shorter one
    is calculated as the image aspect ratio:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`Image`类的`show`方法中设置屏幕大小。我们将规范化比例，使得较长的一侧为1.0，较短的一侧根据图像纵横比计算：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you run it now, the screen will have the correct aspect ratio for the image:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行它，屏幕将具有图像的正确纵横比：
- en: '![Dimensions to correct the width and height](img/B05144_07_11.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![纠正宽度和高度的尺寸](img/B05144_07_11.jpg)'
- en: Sample image down to size
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将图像缩小到指定大小
- en: The camera in your phone is probably awesome! It's probably really mega awesome!
    Many-megapixel images are important when printing or doing lots of cropping. But
    for viewing in our app, we don't need the full resolution image. In fact, you
    might already be having trouble running this project if the image size generates
    a texture that's too big for your device's hardware.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您手机上的相机可能非常棒！它可能真的非常棒！当打印或进行大量裁剪时，百万像素图像非常重要。但是在我们的应用程序中查看时，我们不需要全分辨率图像。实际上，如果图像大小生成了对设备硬件来说太大的纹理，您可能已经在运行此项目时遇到了问题。
- en: 'We can accommodate this issue by constraining the maximum size and scaling
    our bitmaps to fit within these constraints when loading the texture. We will
    ask OpenGL ES to give us its current maximum texture size. We''ll do this in `MainActivity,`
    so it''s generally available (and/or move this into the `RenderBox` class in your
    `RenderBox` library project). Add the following to `MainActivity`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载纹理时，我们可以通过限制最大尺寸并将位图缩放到这些约束范围内来解决此问题。我们将要求OpenGL ES告诉我们当前的最大纹理尺寸。我们将在`MainActivity`中执行此操作，因此它通常是可用的（和/或将其移动到`RenderBox`库项目中的`RenderBox`类中）。将以下内容添加到`MainActivity`：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We call it as the first line of the `setup` method of the `MainActivity` class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其称为`MainActivity`类的`setup`方法的第一行。
- en: As for scaling the image, unfortunately, Android's `BitmapFactory` does not
    let you directly request a new size of a sampled image. Instead, given an arbitrary
    image, you can specify the sampling rate, such as every other pixel (2), every
    fourth pixel (4), and so on. It must be a power of two.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 至于缩放图像，不幸的是，Android的`BitmapFactory`不允许您直接请求采样图像的新大小。相反，对于任意图像，您可以指定采样率，例如每隔一个像素（2），每隔四个像素（4）等。它必须是2的幂。
- en: 'Back to the `Image` class. First, we will add a `sampleSize` argument to `loadTexture`,
    which can be used as an argument to `decodeFile`, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`Image`类。首先，我们将在`loadTexture`中添加一个`sampleSize`参数，该参数可以用作`decodeFile`的参数，如下所示：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To determine an appropriate sample size for images, we need to first find out
    its full dimensions and then figure out what sample size will get it closest but
    less than the maximum texture size we're going to use. The math isn't too difficult,
    but instead of going through that, we'll use a procedural method to search for
    the best size value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定图像的适当采样大小，我们首先需要找出其完整尺寸，然后找出哪个采样大小最接近但小于我们将使用的最大纹理尺寸。数学并不太困难，但我们将使用程序方法来搜索最佳大小值，而不是进行这样的搜索。
- en: 'Fortunately, one of the input options of `decodeFile` is to only retrieve the
    image bounds, and not actually load the image. Write a new load texture method
    named `loadFullTexture`, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`decodeFile`的一个输入选项是仅检索图像边界，而不是实际加载图像。编写一个名为`loadFullTexture`的新加载纹理方法，如下所示：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We keep bumping up the sample size until we find one that produces a bitmap
    within the `MAX_TEXTURE_SIZE` bounds, and then call `loadTexture`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不断增加采样大小，直到找到一个在`MAX_TEXTURE_SIZE`范围内生成位图的大小，并然后调用`loadTexture`。
- en: 'Use `loadFullTexture` in the `show` method instead of the other `loadTexture`
    one:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`show`方法中使用`loadFullTexture`而不是其他的`loadTexture`：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Run the project. It should look the same as the earlier one. But if your camera
    is too good, maybe it's not crashing like it was before.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。它应该看起来与之前的一样。但是如果您的相机太好，也许它不会像以前那样崩溃。
- en: This sampling will also be useful to display thumbnail versions of the images
    in the user interface. There's no point in loading the full-sized bitmap for a
    thumbnail view.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种采样还将有助于在用户界面中显示图像的缩略图版本。对于缩略图视图，加载全尺寸的位图没有意义。
- en: Loading and displaying a photosphere image
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和显示全景图像
- en: So far, we've been handling all the images in the same manner. But some of them
    may be 360-degree images. These should be displayed on the photosphere and not
    on the virtual screen.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直以相同的方式处理所有图像。但其中一些可能是360度图像。这些应该显示在全景照片上，而不是虚拟屏幕上。
- en: If you do not have any 360-degree photos in your device's camera folder yet,
    you can create them using the Google Camera app.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的设备相机文件夹中还没有360度照片，可以使用Google相机应用程序创建它们。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the default camera app on your phone does not include a **Photosphere** mode,
    you may need to download the Google Camera app from the Play Store. Third-party
    cameras might use a different name. For example, Samsung calls their photosphere
    feature **Surround Shot**.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您手机上的默认相机应用程序不包括**全景**模式，则可能需要从Play商店下载Google相机应用程序。第三方相机可能使用不同的名称。例如，三星将其全景功能称为**环绕拍摄**。
- en: Some images include the XMP metadata that will include information of whether
    the image is distorted for an equirectangular projection. This can be useful to
    distinguish spherical images from flat ones. However, the Android API doesn't
    include an XMP interface, so integrating XMP header parsing is beyond the scope
    of this book.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一些图像包括XMP元数据，其中将包括有关图像是否为等距投影而畸变的信息。这对于区分球形图像和平面图像可能很有用。但是，Android API不包括XMP接口，因此集成XMP头解析超出了本书的范围。
- en: 'For now, we''ll just check whether the filename is prefixed with `PANO_`. Add
    the following variable to the `Image` class and set it in the constructor method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需检查文件名是否以`PANO_`为前缀。将以下变量添加到`Image`类中，并在构造方法中设置它：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can now build the `MainActivity` show method to handle regular photos (displayed
    on the virtual screen) versus photospheres (displayed on the background sphere).
    Furthermore, it should handle switching between a flat image displayed on the
    virtual screen and rendering the photosphere and vice versa.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建`MainActivity`显示方法来处理普通照片（显示在虚拟屏幕上）与照片球（显示在背景球上）。此外，它应该处理在虚拟屏幕上显示的平面图像与渲染照片球之间的切换，反之亦然。
- en: 'We want to remember the texture handle ID of the background photosphere texture.
    Add a `bgTextureHandle` handle at the top of the `MainActivity` class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望记住背景照片球纹理的纹理句柄ID。在`MainActivity`类的顶部添加一个`bgTextureHandle`句柄：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, set it in `setupBackground` by calling `getTexture`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`setupBackground`中调用`getTexture`设置它：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we can update the `showImage` method, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新`showImage`方法，如下所示：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When the image is a photosphere, we set the background photosphere texture to
    the image and hide the screen plane. When the image is a regular photo, we set
    the background texture back to the default one and show the image on the virtual
    screen.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像是照片球时，我们将将背景照片球纹理设置为图像，并隐藏屏幕平面。当图像是普通照片时，我们将将背景纹理恢复为默认值，并在虚拟屏幕上显示图像。
- en: 'Until we implement the user interface (next) to test this, you will need to
    know which image in the images list is a photosphere. If you make a new photosphere
    now, it''ll be the last one in the list, and you can change the `setup` method
    to call `showImage` on it. For example, run the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现用户界面（下一步）进行测试之前，您需要知道图像列表中哪个图像是照片球。如果现在制作一个新的照片球，它将成为列表中的最后一个，并且您可以更改`setup`方法以调用`showImage`。例如，运行以下代码：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Run the project again and be happy!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目并感到高兴！
- en: The image gallery user interface
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像库用户界面
- en: Before we go ahead and implement a user interface for this project, let's talk
    about how we want it to work.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续为该项目实现用户界面之前，让我们谈谈我们希望它如何工作。
- en: The purpose of this project is to allow the user to select a photo from their
    phone's storage and view it in VR. The phone's photo collection will be presented
    in a scrollable grid of thumbnail images. If a photo is a normal 2D one, it'll
    be displayed on the virtual screen plane we just made. If it's a photosphere,
    we'll view it as a fully immersive 360-degree spherical projection.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的目的是允许用户从其手机存储中选择照片并在VR中查看它。手机的照片集将以可滚动的缩略图图像网格的形式呈现。如果照片是普通的2D照片，它将显示在我们刚刚制作的虚拟屏幕平面上。如果是照片球，我们将将其视为完全沉浸式的360度球形投影。
- en: A sketch of our proposed scene layout is shown in the following diagram. The
    user camera is centered at the origin, and the photosphere is represented by the
    gray circle, which surrounds the user. In front of the user (determined by the
    calibration at launch), there will be a 5 x 3 grid of thumbnail images from the
    phone's photo gallery. This will be a scrollable list. To the left of the user,
    there is the image projection screen.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提议的场景布局草图如下图所示。用户摄像头位于原点，照片球由灰色圆圈表示，围绕用户周围。在用户面前（由启动时的校准确定），将有一个来自手机相册的5 x
    3网格的缩略图图像。这将是一个可滚动的列表。在用户的左侧，有图像投影屏幕。
- en: '![The image gallery user interface](img/B05144_07_12.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图像库用户界面](img/B05144_07_12.jpg)'
- en: 'Specifically, the UI will implement the following features:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，UI将实现以下功能：
- en: Displays up to 15 thumbnail images in a 5 x 3 grid.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在5 x 3网格中显示最多15个缩略图图像。
- en: Allows the user to select one of the thumbnail images by looking at it and then
    clicking on the Cardboard trigger. Thumbnails will be highlighted when in the
    sightline.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户通过观看缩略图图像并单击Cardboard触发器来选择其中之一。当处于视线中时，缩略图将被突出显示。
- en: Selecting a regular photo will display it on the virtual projection screen in
    the scene (and clear the photosphere to the background image).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择普通照片将在场景中的虚拟投影屏幕上显示它（并将照片球清除为背景图像）。
- en: Selecting a photosphere will hide the virtual projection screen and load the
    image into the photosphere projection.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择照片球将隐藏虚拟投影屏幕并将图像加载到照片球投影中。
- en: Allows the user to scroll through thumbnail images by selecting the up/down
    arrows.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户通过选择上/下箭头滚动缩略图图像。
- en: Some of our UI considerations are unique to virtual reality. Most importantly,
    all of the user interface elements and controls are in world coordinate space,
    That is, they're integrated into the scene as geometric objects with a position,
    rotation, and scale like any other component. This is in contrast with most mobile
    games where the UI is implemented as a screen space overlay.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一些UI考虑是虚拟现实独特的。最重要的是，所有用户界面元素和控件都在世界坐标空间中，也就是说，它们被集成到场景中作为具有位置、旋转和比例的几何对象，就像任何其他组件一样。这与大多数移动游戏中UI作为屏幕空间叠加的方式实现的情况形成对比。
- en: Why? Because in VR, in order to create the stereoscopic effect, each eye has
    a separate viewpoint, offset by the interpupillary distance. This can be simulated
    in screen space by horizontally offsetting the position of screen space objects,
    so they appear to have a parallax (a technique we used in [Chapter 4](ch04.html
    "Chapter 4. Launcher Lobby"), *Launcher Lobby*). But when mixed with 3D geometry,
    camera, lighting, and rendering, that technique proves inadequate. A world space
    UI is required for an effective user experience and immersion.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为在VR中，为了创建立体效果，每只眼睛都有一个单独的视点，通过瞳孔间距进行偏移。这可以通过在屏幕空间中水平偏移屏幕空间对象的位置来模拟，使它们看起来具有视差（这是我们在[第4章](ch04.html
    "第4章。启动器大厅")中使用的技术，*启动器大厅*）。但是当与3D几何、摄像机、照明和渲染混合时，该技术证明是不够的。需要一个世界空间UI来实现有效的用户体验和沉浸感。
- en: Another feature that's unique to VR is gaze-based selection. In this case, where
    you look will highlight an image thumbnail, and then you click on the Cardboard
    trigger to open the image.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在VR中独有的功能是凝视选择。在这种情况下，您的凝视会突出显示一个图像缩略图，然后您点击Cardboard触发器打开图像。
- en: Lastly, as mentioned earlier, since we're working in world space and making
    selections based on where we're looking, the layout of our 3D space is an important
    consideration. Remember that we're in VR and not constrained by rectangular edges
    of a phone screen. Objects in the scene can be placed all around you. On the other
    hand, you don't want users twisting and turning all the time (unless that's an
    intended part of the experience). We'll pay attention to comfort zones to place
    our UI controls and image screen.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如前面提到的，由于我们是在世界空间中工作，并且根据我们的凝视进行选择，我们的3D空间的布局是一个重要考虑因素。请记住，我们处于VR环境中，不受手机屏幕矩形边缘的限制。场景中的对象可以放置在您周围的任何位置。另一方面，您不希望用户一直扭来扭去（除非这是体验的一个意图部分）。我们将注意舒适区域来放置我们的UI控件和图像屏幕。
- en: Furthermore, Google and researchers elsewhere have begun to develop best practices
    for the user interface design, including the optimal distance for menus and UI
    controls from the camera, approximately 5 to 15 feet (1.5 to 5 meters). This distance
    is close enough to enjoy a 3D parallax effect but not so close to make you look
    cross-eyed to focus on the objects.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，谷歌和其他地方的研究人员已经开始制定用户界面设计的最佳实践，包括菜单和UI控件与摄像头的最佳距离，大约为5到15英尺（1.5到5米）。这个距离足够近，可以享受3D视差效果，但不会让你看起来眯着眼睛专注于物体。
- en: Okay, let's begin with the UI implementation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始UI实现。
- en: Positioning the photo screen on the left
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将照片屏幕定位在左侧
- en: 'Firstly, let''s move the screen from in front to the side, that is, rotate
    it 90 degrees to the left. Our transform math does the position after the rotation,
    so we now offset it along the *x* axis. Modify the `setupScreen` method of the
    `MainActivity` class, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将屏幕从前方移动到侧面，即将其向左旋转90度。我们的变换数学在旋转后进行位置，所以现在我们沿*x*轴偏移它。修改`MainActivity`类的`setupScreen`方法，如下所示：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Displaying thumbnails in a grid
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网格中显示缩略图
- en: A thumbnail is a mini version of the full image. Therefore, we don't need to
    load a full-sized texture bitmap. For the sake of simplicity, let's just always
    sample it down by 4 (to 1/16th the original size).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 缩略图是完整图像的迷你版本。因此，我们不需要加载全尺寸的纹理位图。为了简单起见，让我们总是将其缩小4倍（原始尺寸的1/16）。
- en: The thumbnail image
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩略图图像
- en: 'In the `Image` class, the `show` method loads the full texture. Let''s write
    a similar `showThumbnail` method that uses a smaller sampling. In the `Image`
    class, add the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Image`类中，`show`方法加载完整的纹理。让我们编写一个类似的`showThumbnail`方法，使用较小的采样。在`Image`类中，添加以下代码：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The Thumbnail class
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩略图类
- en: 'Create a new `Thumbnail` class for the project that will contain a small `Plane`
    object and an `Image` object to show on it. It also gets the current `cardboardView`
    instance, which `Image` will require:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为项目创建一个新的`Thumbnail`类，其中包含一个小的`Plane`对象和一个`Image`对象来显示。它还获取当前的`cardboardView`实例，`Image`将需要它：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Define a `setImage` method that loads the image texture and shows it as a thumbnail:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个`setImage`方法，加载图像纹理并显示为缩略图：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Lastly, make a quick toggle for the thumbnail visibility:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为缩略图可见性添加一个快速切换：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The thumbnail grid
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩略图网格
- en: 'The plan is to display the phone photos in a 5 x 3 grid of thumbnail images.
    At the top of the `MainActivity` class, declare a `thumbnails` variable to hold
    the list of thumbnails:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 计划在`MainActivity`类的顶部显示5x3缩略图图像网格。声明一个`thumbnails`变量来保存缩略图列表：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Build the list in a new method named `setupThumbnailGrid`. The first thumbnail
    is positioned in the upper-left corner of the page (-4, 3, -5) and each thumb
    spaced 2.1 units in *x* and 3 units in *y*, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为`setupThumbnailGrid`的新方法中构建列表。第一个缩略图位于页面的左上角（-4，3，-5），每个缩略图在*x*轴上间隔2.1个单位，在*y*轴上间隔3个单位，如下所示：
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we need to add image textures to the planes. We''ll write another method,
    `updateThumbnails`, as follows. It will show the first 15 images in the grid (or
    less if you don''t have that many):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将图像纹理添加到平面上。我们将编写另一个方法`updateThumbnails`，如下所示。它将在网格中显示前15张图像（如果没有那么多，就显示更少）：
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add these new methods to `setup`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些新方法添加到`setup`中：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When you run the project, it should look something like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行项目时，它应该看起来像这样：
- en: '![The thumbnail grid](img/B05144_07_13.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![缩略图网格](img/B05144_07_13.jpg)'
- en: Note that the thumbnails' sizes are adjusted to match the image aspect ratio,
    and are properly oriented, because we implemented those features in the `Image`
    class earlier.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，缩略图的大小已调整以匹配图像的宽高比，并且已正确定向，因为我们之前在`Image`类中实现了这些功能。
- en: Tip
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you don''t have more than 15 photos already in your phone, add a loop to
    `loadImageList` to load duplicates. For example, run the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的手机上已经没有超过15张照片，请在`loadImageList`中添加一个循环来加载重复的照片。例如，运行以下代码：
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Gaze to load
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 凝视加载
- en: We want to detect when the user looks at a thumbnail and highlight the image
    by changing its border color. If users move their gaze away from the thumbnail,
    it will unhighlight. When the user clicks on the Cardboard trigger, that image
    is loaded.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望检测用户何时看着缩略图，并通过更改其边框颜色来突出显示图像。如果用户将目光从缩略图移开，它将取消突出显示。当用户点击Cardboard触发器时，该图像将被加载。
- en: Gaze-based highlights
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凝视突出显示
- en: Fortunately, we implemented the `isLooking` detection in the `RenderBox` library
    at the end of [Chapter 5](ch05.html "Chapter 5. RenderBox Engine"), *RenderBox
    Engine*. If you remember, the technique determines whether the user is looking
    at the plane by checking whether the vector between the camera and the plane position
    is the same as the camera's view direction, within a threshold of tolerance.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们在[第5章](ch05.html "第5章。RenderBox Engine")的末尾在`RenderBox`库中实现了`isLooking`检测，*RenderBox
    Engine*。如果您还记得，该技术通过检查相机和平面位置之间的矢量是否与相机的视图方向相同来确定用户是否正在查看平面，容忍度为阈值。
- en: 'We can use this in `MainActivity`. We''ll write a `selectObject` helper method
    that checks whether any of the objects in the scene are selected and highlights
    them. First, let''s declare some variables at the top of the `MainActivity` class.
    The `selectedThumbnail` object holds the currently selected thumbnail index. We
    define border colors for normal and selected states:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`MainActivity`中使用这个。我们将编写一个`selectObject`辅助方法，检查场景中是否有任何对象被选中并突出显示它们。首先，让我们在`MainActivity`类的顶部声明一些变量。`selectedThumbnail`对象保存当前选定的缩略图索引。我们为正常和选定状态定义边框颜色：
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now the `selectObject` method goes through each thumbnail, checks whether it''s
    `isLooking`, and highlights (or unhighlights) it accordingly:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`selectObject`方法会遍历每个缩略图，检查它是否`isLooking`，并相应地突出显示（或取消突出显示）它：
- en: '[PRE56]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`RenderBox` provides hooks, including `postDraw` where we''ll check for selected
    objects. We want to use `postDraw` because we need to wait until `draw` is called
    on all of `RenderObjects` before we know which one the user is looking at. In
    `MainActivity`, add a call to the `selectObject` method as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderBox`提供了一些挂钩，包括`postDraw`，我们将在其中检查选定的对象。我们希望使用`postDraw`，因为我们需要等到在所有`RenderObjects`上调用`draw`之后才知道用户正在查看哪一个。在`MainActivity`中，添加对`selectObject`方法的调用，如下所示：'
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Run the project. As you gaze at a thumbnail image, it should get highlighted!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。当您盯着缩略图图像时，它应该会被突出显示！
- en: Selecting and showing photos
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择和显示照片
- en: Well, now that we can pick an image from the thumbnail grid, we need a way to
    click on it and show that image. That'll happen in `MainActivity` using the Cardboard
    SDK hook, `onCardboardTrigger`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从缩略图网格中选择图像，我们需要一种点击它并显示该图像的方法。这将在`MainActivity`中使用Cardboard SDK挂钩`onCardboardTrigger`来实现。
- en: 'With all the work we''ve done so far, it''s not going to take much more to
    implement this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的工作不需要太多就可以实现这一点：
- en: '[PRE58]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Try and run it. Now highlight an image and pull the trigger. If you're lucky,
    it'll work…mine crashes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行它。现在突出显示一个图像并扳动扳机。如果你幸运的话，它会工作……我的崩溃了。
- en: Queue events
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排队事件
- en: What's going on? We're running into thread-safe issues. So far, we've been executing
    all of our code from the render thread, which is started by the `GLSurfaceView`/`CardboardView`
    class via the Cardboard SDK. This thread owns the access to the GPU and to the
    particular surface we're rendering on. The call to `onCardboardTrigger` originates
    from a thread that is not the render thread. This means that we can't make any
    OpenGL calls from here. Luckily, `GLSurfaceView` provides a nifty way to execute
    arbitrary code on the render thread through a method called `queueEvent`. The
    `queueEvent` method takes a single `Runnable` argument, which is a Java class
    meant to create one-off procedures such as these (refer to [http://developer.android.com/reference/android/opengl/GLSurfaceView.html#queueEvent(java.lang.Runnable](http://developer.android.com/reference/android/opengl/GLSurfaceView.html#queueEvent(java.lang.Runnable)).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？我们遇到了线程安全问题。到目前为止，我们一直在渲染线程中执行所有代码，该线程由`GLSurfaceView`/`CardboardView`类通过Cardboard
    SDK启动。该线程拥有对GPU和我们正在渲染的特定表面的访问权限。对`onCardboardTrigger`的调用来自不是渲染线程的线程。这意味着我们不能从这里进行任何OpenGL调用。幸运的是，`GLSurfaceView`提供了一种通过名为`queueEvent`的方法在渲染线程上执行任意代码的巧妙方法。`queueEvent`方法接受一个`Runnable`参数，这是一个用于创建这类一次性过程的Java类（参见[http://developer.android.com/reference/android/opengl/GLSurfaceView.html#queueEvent(java.lang.Runnable](http://developer.android.com/reference/android/opengl/GLSurfaceView.html#queueEvent(java.lang.Runnable)））。
- en: 'Modify `showImage` to wrap it inside a `Runnable` argument, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`showImage`，将其包装在`Runnable`参数中，如下所示：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that any data passed to the anonymous class, such as our image, must be
    declared `final` to be accessible from the new procedure.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，传递给匿名类的任何数据，例如我们的图像，必须声明为`final`，才能从新过程中访问。
- en: Try to run the project again. It should work. You can gaze at a thumbnail, click
    on the trigger, and that image will be shown, either on the virtual screen or
    in the background photosphere.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试再次运行项目。它应该可以工作。您可以盯着缩略图，点击触发器，该图像将被显示，无论是在虚拟屏幕上还是在背景光球中。
- en: Using a vibrator
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用振动器
- en: No worries, we're keeping it clean. We want to provide some haptic feedback
    to the user when an image has been selected, using the phone's vibrator. And fortunately,
    in Android, that's straightforward.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，我们会保持干净。我们希望在用户选择图像时为用户提供一些触觉反馈，使用手机的振动器。而在Android中，这是直截了当的。
- en: 'First, make sure that your `AndroidManifest.xml` file includes the following
    line of code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保您的`AndroidManifest.xml`文件包含以下代码行：
- en: '[PRE60]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'At the top of the `MainActivity` class, declare a `vibrator` variable:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`类的顶部，声明一个`vibrator`变量：
- en: '[PRE61]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, in `onCreate`, add the following code to initialize it:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`onCreate`中，添加以下代码进行初始化：
- en: '[PRE62]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, use it in `onCardboardTrigger`, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`onCardboardTrigger`中使用它，如下所示：
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Run it again. Click on it and you'll feel it. *Ahhh!* But don't get carried
    away, it's not that kind of vibrator.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行。点击它，你会感觉到它。*啊！*但不要得意忘形，它不是那种振动器。
- en: Enable scrolling
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用滚动
- en: Our thumbnail grid has 15 images. If your phone has more than 15 photos, you'll
    need to scroll through the list. For this project, we'll implement a simple mechanic
    to scroll the list up and down, using triangular scroll buttons.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的缩略图网格有15张图像。如果您的手机有超过15张照片，您需要滚动列表。对于这个项目，我们将实现一个简单的机制来上下滚动列表，使用三角形滚动按钮。
- en: Creating the Triangle component
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建三角形组件
- en: Like other `RenderObjects` in our `RenderBox`, the `Triangle` component defines
    coordinates, normals, indices, and other data that describes a triangle. We create
    a constructor method that allocates buffers. Like the `Plane` component, we want
    to use the `BorderMaterial` class so that it can be highlighted when selected.
    And like the `Plane` component, it will determine when the user is looking at
    it. Without further ado, here's the code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的`RenderBox`中的其他`RenderObjects`一样，`Triangle`组件定义了描述三角形的坐标、法线、索引和其他数据。我们创建一个分配缓冲区的构造方法。与`Plane`组件一样，我们希望使用`BorderMaterial`类，以便在选择时可以突出显示。与`Plane`组件一样，它将确定用户何时在查看它。话不多说，这是代码。
- en: 'Create a new Java class file, `Triangle.java`, in the `RenderBoxExt/components`
    folder. We begin by declaring it `extends RenderObject` and by declaring the following
    variables:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RenderBoxExt/components`文件夹中创建一个新的Java类文件`Triangle.java`。我们首先声明它`extends RenderObject`，并声明以下变量：
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In case it's not clear as to why we need this 2-triangle triangle, it has to
    do with how the UVs work. You can't get a full border with just one triangle,
    at least not the way we've written the border shader.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不清楚为什么我们需要这个由2个三角形组成的三角形，那是因为UV的工作方式。您无法仅使用一个三角形获得完整的边框，至少不是我们编写边框着色器的方式。
- en: 'Add a constructor, along with an `allocateBuffers` helper:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个构造函数，以及一个`allocateBuffers`辅助程序：
- en: '[PRE65]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can create various materials, but we really only plan to use `BorderMaterial`,
    so let''s support this like we did with `Plane`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建各种材料，但我们实际上只计划使用`BorderMaterial`，因此让我们像我们在`Plane`中那样支持它：
- en: '[PRE66]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Adding triangles to the UI
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向UI添加三角形
- en: 'In `MainActivity`, we can add the `up` and `down` triangle buttons to scroll
    the thumbnails. At the top of the `MainActivity` class, declare variables for
    the triangles and their materials:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`中，我们可以添加`up`和`down`三角形按钮来滚动缩略图。在`MainActivity`类的顶部，声明三角形及其材料的变量：
- en: '[PRE67]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Define a `setupScrollButtons` helper as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个`setupScrollButtons`辅助程序如下：
- en: '[PRE68]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, call it from the `setup` method:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从`setup`方法中调用它：
- en: '[PRE69]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'When you run the project, you will see the arrows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目时，您将看到箭头：
- en: '![Adding triangles to the UI](img/B05144_07_14.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![向UI添加三角形](img/B05144_07_14.jpg)'
- en: Interacting with the scroll buttons
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与滚动按钮交互
- en: 'Now we will detect when the user is looking at a triangle, by using `isLooking`
    in `selectObject` (which is called from the `postDraw` hook):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检测用户何时在查看三角形，使用`selectObject`中的`isLooking`（从`postDraw`挂钩调用）：
- en: '[PRE70]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Implementing the scrolling method
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现滚动方法
- en: 'To implement scrolling the thumbnail images, we''ll keep the grid planes in
    place and just scroll the textures. Use an offset variable to hold the index of
    the first image in the grid:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现滚动缩略图图像，我们将保持网格平面不变，只滚动纹理。使用偏移变量来保存网格中第一个图像的索引：
- en: '[PRE71]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, modify the `updateThumbnails` method to populate the plane textures using
    the thumb offset as the starting index of the image textures:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改`updateThumbnails`方法，使用缩略图偏移作为图像纹理的起始索引来填充平面纹理：
- en: '[PRE72]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can perform scrolling when the up or down arrows are pressed in `onCardboardTrigger`
    by shifting the `thumbOffset` variable one row at a time (`GRID_X`):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下上下箭头时，我们可以在`onCardboardTrigger`中执行滚动，通过将`thumbOffset`变量一次移动一行（`GRID_X`）：
- en: '[PRE73]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'As with `showImage`, the `updateThumbnails` method needs to run on the render
    thread:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 与`showImage`一样，`updateThumbnails`方法需要在渲染线程上运行：
- en: '[PRE74]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Run the project. You can now click on the up and down arrows to scroll through
    your photos.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。现在，您可以单击上下箭头来滚动浏览照片。
- en: Stay responsive and use threads
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持响应并使用线程
- en: There are a few problems with our loading and scrolling code, all related to
    the fact that loading images and converting bitmaps is compute-intensive. Attempting
    to do this for 15 images all at once causes the app to appear frozen. You may
    have also noticed that the app takes significantly longer to start up since we
    added the thumbnail grid.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的加载和滚动代码存在一些问题，都与加载图像和转换位图是计算密集型的事实有关。尝试一次为15张图像执行此操作会导致应用程序似乎冻结。您可能还注意到，自从我们添加了缩略图网格以来，应用程序启动时间显着延长。
- en: In conventional apps, it might be annoying but somewhat acceptable for the app
    to lock up while waiting for data to load. But in VR, the app needs to stay alive.
    The app needs to continue responding to the head movement and update the display
    for each frame with a view corresponding to the current view direction. If the
    app is locked while loading files, it will feel stuck, that is, stuck to your
    face! In a fully immersive experience, and on a desktop HMD that is strapped on,
    visual lockup is the most severe cause of nausea, or *sim sickness*.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的应用程序中，应用程序在等待数据加载时锁定可能会很烦人，但在VR中，应用程序需要保持活动状态。应用程序需要继续响应头部运动，并为每个帧更新显示，以显示与当前视图方向相对应的视图。如果应用程序在加载文件时被锁定，它会感觉卡住，即卡在您的脸上！在完全沉浸式体验中，并且在桌面HMD上，视觉锁定是引起恶心或*模拟疾病*的最严重原因。
- en: 'The solution is a worker thread. The key to successful multithreaded support
    is providing the ability for the procedures to signal each other with semaphores
    (Boolean flags). We''ll use the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是一个工作线程。成功支持多线程的关键是提供过程之间使用信号量（布尔标志）相互通信的能力。我们将使用以下内容：
- en: '`Image.loadLock`: This is true when waiting for the GPU to generate a texture'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image.loadLock`：当等待GPU生成纹理时为真'
- en: '`MainActivity.cancelUpdate`: This is true when the thread should stop due to
    a user event'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainActivity.cancelUpdate`：当线程由于用户事件而停止时为真'
- en: '`MainActivity gridUpdateLock`: This is true when the grid is updating; ignore
    other user events'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainActivity gridUpdateLock`：当网格正在更新时为真；忽略其他用户事件'
- en: 'Let''s declare these. At the top of the `Image` class, add the following code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明这些。在`Image`类的顶部，添加以下代码：
- en: '[PRE75]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'At the top of the `MainActivity` class, add the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`类的顶部，添加以下内容：
- en: '[PRE76]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: First, let's identify the compute-intensive part of our code. Feel free to do
    your own investigation, but let's assume that `BitmapFactory.decodeFile` is the
    culprit. Ideally, any code that wasn't directly related to rendering should be
    done on a worker thread, but beware of pre-optimization. We're doing this work
    because we've noticed an issue, so we should be able to identify the new code
    which is causing it. An educated guess points to this business of loading arbitrary
    images into textures.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确定我们代码中计算密集的部分。随意进行自己的调查，但让我们假设`BitmapFactory.decodeFile`是罪魁祸首。理想情况下，任何与渲染无关的代码都应该在工作线程上完成，但要注意预优化。我们正在做这项工作是因为我们注意到了一个问题，所以我们应该能够确定导致问题的新代码。一个合理的猜测指向了将任意图像加载到纹理中的这个业务。
- en: Where do we do this operation? Well, the actual call to `BitmapFactory.decodeFile`
    comes from `Image.loadTexture`, but more generally, all of this is kicked off
    in `MainActivity.updateGridTextures` and `MainActivity.showImage`. Let's update
    these last two functions now.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在哪里进行这个操作？嗯，对`BitmapFactory.decodeFile`的实际调用来自`Image.loadTexture`，但更一般地说，所有这些都是从`MainActivity.updateGridTextures`和`MainActivity.showImage`中启动的。现在让我们更新这最后两个函数。
- en: 'Lucky for us, `showImage` has already been wrapped in `Runnable` for the purpose
    of redirecting its execution to the render thread. Now we want to actually ensure
    that it always happens off the render thread. We''ll be using `queueEvent` in
    a different place to avoid the error that we encountered earlier. We replace the
    previous `Runnable` code with `Thread`. For example, `showImage` now looks like
    this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`showImage`已经被包装在`Runnable`中，以便将其执行重定向到渲染线程。现在我们想确保它总是发生在渲染线程之外。我们将在不同的地方使用`queueEvent`来避免我们之前遇到的错误。我们用`Thread`替换了以前的`Runnable`代码。例如，`showImage`现在看起来是这样的：
- en: '[PRE77]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Do the same to `updateThumbnails`. While we''re here, add the `gridUpdateLock`
    flag that remains set while it''s running, and handle the `cancelUpdate` flag,
    so the loops can be interrupted:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对`updateThumbnails`做同样的操作。当我们在这里时，添加`gridUpdateLock`标志，它在运行时保持设置，并处理`cancelUpdate`标志，以便可以中断循环：
- en: '[PRE78]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Focusing on the `Image` class''s `loadTexture` method, we need to redirect
    the GPU calls back to the render thread with `queueEvent`. If you try to run the
    app now, it will crash right out of the gate. This is because `showImage` is now
    always run in its own thread, and when we eventually make the OpenGL calls to
    generate the texture, we''ll get the invalid operation error that we got earlier
    when we added the trigger input. To fix this, modify `loadTexture` as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于`Image`类的`loadTexture`方法，我们需要使用`queueEvent`将GPU调用重定向回渲染线程。如果你现在尝试运行应用程序，它将立即崩溃。这是因为`showImage`现在总是在自己的线程中运行，当我们最终进行OpenGL调用生成纹理时，我们将得到无效操作错误，就像我们之前添加触发输入时那样。为了解决这个问题，修改`loadTexture`如下：
- en: '[PRE79]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We changed it so that `bitmapToTexture` is now called on the GPU thread. We
    use the `loadLock` flag to indicate that the loading is busy. When it's done,
    the flag is reset. Meanwhile, `loadTexture` waits for it to finish before returning
    because we need this `textureHandle` value for later. But since we're always calling
    this from a worker thread, the app isn't hung waiting. This change will also improve
    the start-up time.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变了`bitmapToTexture`，现在它在GPU线程上调用。我们使用`loadLock`标志来指示加载正在忙碌。当它完成时，标志被重置。与此同时，`loadTexture`在返回之前等待它完成，因为我们需要这个`textureHandle`值以供以后使用。但由于我们总是从工作线程调用这个，应用程序不会因等待而挂起。这个改变也将改善启动时间。
- en: 'Similarly, we do the same thing in the `Thumbnail` class; its `setImage` method
    also loads the image texture. Modify it so that it looks like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们在`Thumbnail`类中也做同样的事情；它的`setImage`方法也加载图像纹理。修改它，使它看起来像这样：
- en: '[PRE80]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You might have noticed a subtler issue in all of this. If we try to close the
    app in the middle of one of these worker thread operations, it will crash. The
    underlying issue is that the thread persists, but the graphics context has been
    destroyed, even if you are just switching apps. Trying to generate textures with
    an invalid graphics context results in a crash, and the user gets little notification.
    Bad news. What we want to do is stop the worker thread when the app closes. This
    is where `cancelUpdate` comes into play. In `MainActivity`, we''ll set its value
    in the `onCreate` method, and add the methods to the `onStart`, `onResume`, and
    `onPause` hook methods, as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了所有这些中更微妙的问题。如果我们试图在这些工作线程操作的中间关闭应用程序，它将崩溃。潜在的问题是线程持续存在，但图形上下文已被销毁，即使你只是切换应用程序。尝试使用无效的图形上下文生成纹理会导致崩溃，并且用户几乎得不到通知。坏消息。我们想要做的是在应用程序关闭时停止工作线程。这就是`cancelUpdate`发挥作用的地方。在`MainActivity`中，我们将在`onCreate`方法中设置它的值，并在`onStart`、`onResume`和`onPause`挂钩方法中添加方法，如下所示：
- en: '[PRE81]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If you try to click on something while the grid is updating, it shouldn''t
    let you to do so. Add the following code to the top of `onCardboardTrigger`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在网格更新时尝试点击某物，它不应该让你这样做。在`onCardboardTrigger`的顶部添加以下代码：
- en: '[PRE82]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This new `long[]{0,50,30,50}` business is a way of programming a sequence into
    the vibrator. In this case, two short (50 milliseconds) pulses in a row are used
    to indicate the nuh-uh reaction.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`long[]{0,50,30,50}`业务是将一个序列编程到振动器中的一种方式。在这种情况下，连续使用两个短（50毫秒）的脉冲来指示nuh-uh反应。
- en: 'We can even go one beautiful step further and highlight selectable objects
    in `selectObject` with a disabled color during `gridUpdateLock` like this:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以再进一步，就像这样在`gridUpdateLock`期间用禁用的颜色突出显示可选择的对象：
- en: '[PRE83]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Your project should run as before. But now it's more responsive, better behaved,
    and doesn't get stuck waiting for images to load.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目应该像以前一样运行。但现在它更具响应性，行为更好，并且不会因等待图像加载而卡住。
- en: An explanation of threading and virtual reality
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程和虚拟现实的解释
- en: OpenGL is not thread-safe. This sounds like a design flaw. In reality, it's
    more like a design requirement. You want your graphics API to draw frames as quickly
    and frequently as possible. As you may know, or will soon learn, waiting is something
    that threads end up doing a lot of the time. If you introduce multithreaded access
    to your graphics hardware, you introduce periods where the hardware might be waiting
    on the CPU simply to figure out its thread scheduling and who needs access at
    the time. It's much simpler and faster to say "only one thread may access the
    GPU." Technically speaking, as graphics APIs become more advanced (DirectX 12
    and Vulkan), this is not strictly true, but we will not be getting into multithreaded
    rendering in this book.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL不是线程安全的。这听起来像是一个设计缺陷。实际上，更像是一个设计要求。您希望您的图形API尽可能快地频繁绘制帧。正如您可能知道的，或者很快就会了解到，等待是线程经常做的事情。如果您引入多线程访问图形硬件，您就会引入硬件可能在CPU上等待的时期，仅仅是为了弄清楚它的线程调度和谁需要在那个时候访问。说“只有一个线程可以访问GPU”更简单更快。从技术上讲，随着图形API变得更加先进（DirectX
    12和Vulkan），这并不严格正确，但我们不会在本书中涉及多线程渲染。
- en: Let's first take a step back and ask the question, "Why do we need to use threads?"
    To some of you who are more experienced application developers, the answer should
    be obvious. But not all programmers need to use threads, and, even worse, many
    programmers use threads inappropriately, or when they aren't needed in the first
    place. For those of you still in the dark, a thread is a fancy term for "a way
    to run two procedures at the same time." On a practical level, the operating system
    takes control of scheduling threads to run one after another, or on different
    CPU cores, but as programmers, we assume that all threads are running "simultaneously."
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先退一步，问一个问题，“为什么我们需要使用线程？”对于一些经验丰富的应用程序开发人员来说，答案应该是显而易见的。但并非所有程序员都需要使用线程，更糟糕的是，许多程序员在不适当的时候或者根本不需要的时候使用线程。对于那些仍然不清楚的人来说，线程是一个“同时运行两个程序的方法”的花哨术语。在实际层面上，操作系统控制着调度线程一个接一个地运行，或者在不同的CPU核心上运行，但作为程序员，我们假设所有线程都在“同时”运行。
- en: Incidentally, while we are only allowed one CPU thread to control the GPU, the
    whole point of a GPU is that it is massively multithreaded. Mobile GPUs are still
    getting there, but high-end Tegra chips have hundreds of cores (currently, the
    X1 is at 256 cores), lagging behind their desktop equivalents with thousands of
    cores (Titan Black @ 2880 cores). A GPU is set up to process each pixel (or other
    similar small datum) on a separate thread, and there is some hardware magic going
    on that schedules all of them automatically with zero overhead. Think of your
    render thread as a slow taskmaster instructing a tiny army of CPUs to do your
    bidding and report back with the results, or in most cases, just draw them right
    to the screen. This means that the CPU is already doing a fair amount of waiting
    on behalf of the GPU, freeing your other worker threads to do their tasks and
    then wait when there is more CPU render work to be done.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，虽然我们只允许一个CPU线程控制GPU，但GPU的整个意义在于它是大规模多线程的。移动GPU仍在发展中，但高端的Tegra芯片拥有数百个核心（目前，X1拥有256个核心），落后于拥有数千个核心的台式机等效芯片（Titan
    Black @ 2880个核心）。GPU被设置为在单独的线程上处理每个像素（或其他类似的小数据），并且有一些硬件魔术自动调度所有这些线程而零开销。把您的渲染线程想象成一个缓慢的工头，指挥着一支小型的CPU军队来执行您的命令并报告结果，或者在大多数情况下，直接将它们绘制到屏幕上。这意味着CPU已经在代表GPU做了相当多的等待，从而使您的其他工作线程可以在需要更多CPU渲染工作时进行任务并等待。
- en: Threads are generally useful when you want to run a process which will take
    a while, and you want to avoid blocking the program's execution, or main, thread.
    The most common place where this comes up is starting a background process and
    allowing the UI to continue to update. If you're creating a media encoder program,
    you don't want it to be unresponsive for 30 minutes while it decodes a video.
    Instead, you'd like the program to run as normal, allowing the user to click on
    buttons and see progress updates from the background work. In this scenario, you
    have to let the UI and background threads take a break now and then to send and
    check messages passed between the two. Adjusting the length of the break, or sleep
    time, and thread priority values allows you to avoid one thread hogging too much
    CPU time.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要运行一个需要一段时间的进程，并且希望避免阻塞程序的执行或主线程时，线程通常是有用的。这种情况最常见的地方是启动一个后台进程并允许UI继续更新。如果您正在创建一个媒体编码器程序，您不希望在解码视频时程序在30分钟内无响应。相反，您希望程序正常运行，允许用户点击按钮并从后台工作中看到进度更新。在这种情况下，您必须让UI和后台线程偶尔休息一下，以便发送和检查两者之间传递的消息。调整休息时间或睡眠时间以及线程优先级值可以避免一个线程占用太多CPU时间。
- en: Back to OpenGL and graphics programming. It is common in a game engine to split
    the work into a few, distinct threads (render, physics, audio, input, and so on).
    However, the render thread is always a kind of *orchestrator* because rendering
    still tends to be the most time-sensitive job and must happen at least 30 times
    per second. In VR, this constraint is even more important. We're not worried about
    physics and audio, perhaps, but we still need to make sure that our renderer can
    draw things as quickly as possible, or the feeling of presence is lost. Furthermore,
    we can never stop rendering, as long as the person is looking at the screen. We
    need threads to avoid "hiccups" or unacceptably long periods between render frames.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 回到OpenGL和图形编程。在游戏引擎中，将工作分成几个不同的线程（渲染、物理、音频、输入等）是很常见的。然而，渲染线程总是一种“指挥者”，因为渲染仍然倾向于是最时间敏感的工作，必须至少每秒发生30次。在虚拟现实中，这种约束更加重要。也许我们不担心物理和音频，但我们仍然需要确保我们的渲染器能够尽快地绘制东西，否则就会失去存在感。此外，只要人在看屏幕，我们就永远不能停止渲染。我们需要线程来避免渲染帧之间出现“抽搐”或不可接受的长时间间隔。
- en: Head tracking is essential to a VR experience. A person who is moving their
    head, looking only at a fixed image, will start to experience nausea, or *simsickness*.
    Even some text on a black background, if it is not compensated by some sort of
    fixed horizon, will eventually cause discomfort. Sometimes, we do have to block
    the render thread for significant periods of time, and the best option is to first
    fade the image to a solid color, or void. This can be comfortable for a short
    period of time. The worst thing that can happen in VR is periodic hiccups or frame
    rate drops due to extensive work being done on the render thread. If you don't
    maintain a constant, smooth, frame rate, your VR experience is worthless.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 头部跟踪对于VR体验至关重要。一个人移动头部，只看着一个固定的图像，会开始感到恶心，或者*模拟病*。即使是黑色背景上的一些文本，如果没有通过某种固定的地平线进行补偿，最终也会引起不适。有时，我们确实需要阻塞渲染线程相当长的时间，最好的选择是首先将图像淡化为纯色或空白。这样可以在短时间内感到舒适。在VR中最糟糕的事情是由于渲染线程上的大量工作而导致周期性的抽搐或帧速率下降。如果您不能保持恒定、平稳的帧速率，您的VR体验就毫无价值。
- en: In our case, we need to decode a series of rather large bitmaps and load them
    into GPU textures. Unfortunately, the decode step takes a few hundred milliseconds
    and causes those hiccups we were just talking about. However, since this isn't
    GPU work, it doesn't have to happen on the render thread! If we want to avoid
    any heavy lifting in our `setup()`, `preDraw()`, and `postDraw()` functions, we
    should create a thread any time that we want to decode a bitmap. In the case of
    updating our grid of previews, we should probably just create a single thread,
    which can run the whole update process, waiting in between each bitmap. In the
    CPU land, the OS needs to use some resources to schedule threads and allocate
    their resources. It's much more efficient to just create a single thread to run
    through the entire job, rather than spinning up and taking down a thread for each
    bitmap.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们需要解码一系列相当大的位图并将它们加载到GPU纹理中。不幸的是，解码步骤需要几百毫秒，并导致我们刚刚谈到的这些抽搐。然而，由于这不是GPU工作，它不必发生在渲染线程上！如果我们想要避免在我们的`setup()`，`preDraw()`和`postDraw()`函数中进行任何繁重的工作，我们应该在任何想要解码位图的时候创建一个线程。在更新我们的预览网格的情况下，我们可能只需要创建一个单独的线程，它可以运行整个更新过程，在每个位图之间等待。在CPU领域，操作系统需要使用一些资源来调度线程并分配它们的资源。与为每个位图启动和关闭线程相比，只创建一个线程来完成整个作业要高效得多。
- en: Of course, we're going to need to make use of our old friend `queueEvent` in
    order to do any graphics work, in this case generating and loading the texture.
    As it turns out, updating the display of the image is not graphics work, since
    it just involves changing a value on our material. We do, however, need to wait
    on the graphics work in order to get this new value. As a result of these optimizations
    and constraints, we need a locking system in order to allow one thread to wait
    on the others to finish its work, and to prevent the user from interrupting or
    restarting this procedure before it has completed. This is what we just implemented
    in the previous topic.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要利用我们的老朋友`queueEvent`来进行任何图形工作，这样才能生成和加载纹理。事实证明，更新图像的显示并不是图形工作，因为它只涉及更改我们材质上的一个值。然而，我们确实需要等待图形工作，以获取这个新值。由于这些优化和约束，我们需要一个锁定系统，以允许一个线程等待其他线程完成其工作，并防止用户在完成之前中断或重新启动此过程。这就是我们在上一个主题中刚刚实现的。
- en: Launch with an intent
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用意图启动
- en: Wouldn't it be cool if you could launch this app any time you go to view an
    image on your phone, especially 360-degree photospheres?
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以在手机上查看图像时随时启动此应用程序，这不是很酷吗，尤其是360度全景照片？
- en: One of the more powerful features of the Android operating system is the ability
    to communicate between apps with intents. An **intent** is a message that any
    app can send to the Android system, which declares its intent to use another app
    for a certain purpose. The intent object contains a number of members to describe
    what type of action needs to be done, and, if any, the data on which it needs
    to be done. As a user, you may be familiar with the default action picker, which
    displays a number of app icons, and the choices, **Just Once**, or **Always**.
    What you're seeing is the result of the app you were just using broadcasting a
    new intent to the system. When you choose an app, and Android launches a new activity
    from that app, which has been registered to respond to intents of that type.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Android操作系统的一个更强大的功能是使用意图在应用程序之间进行通信。**意图**是任何应用程序可以发送到Android系统的消息，它声明了使用另一个应用程序进行某种目的的意图。意图对象包含许多成员，用于描述需要执行的操作类型，以及（如果有的话）需要执行操作的数据。作为用户，您可能熟悉默认操作选择器，它显示了许多应用程序图标以及**仅此一次**或**始终**的选择。您看到的是您刚刚使用的应用程序向系统广播新意图的结果。当您选择一个应用程序时，Android会从该应用程序启动一个新的活动，该活动已注册以响应该类型的意图。
- en: 'In your `AndroidManifest.xml` file, add an intent filter to the activity block.
    Let Android know that the app can be used as an image viewer. Add the following
    XML code:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`AndroidManifest.xml`文件中，向活动块添加一个意图过滤器。让Android知道该应用程序可以用作图像查看器。添加以下XML代码：
- en: '[PRE84]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We just need to handle the situation so an intent image is the default image
    loaded when the app starts. In `MainActivity`, we''ll write a new function that
    shows an image given its URI, as follows. The method gets the URI path and translates
    it into a file pathname, calls the new `Image` object on that path, and then the
    `showImage` method. (For reference, visit [http://developer.android.com/guide/topics/providers/content-provider-basics.html](http://developer.android.com/guide/topics/providers/content-provider-basics.html)):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要处理这样一种情况，即当应用程序启动时，意图图像是默认加载的图像。在`MainActivity`中，我们将编写一个显示图像的新函数，如下所示。该方法获取URI路径并将其转换为文件路径名，调用该路径上的新`Image`对象，然后调用`showImage`方法。（有关参考，请访问[http://developer.android.com/guide/topics/providers/content-provider-basics.html](http://developer.android.com/guide/topics/providers/content-provider-basics.html)）：
- en: '[PRE85]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then, add a call to `showUriImage` from `setup`, as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`setup`中添加对`showUriImage`的调用，如下所示：
- en: '[PRE86]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We've also added a call to `BorderMaterial.destroy()` since the intent launches
    a second instance of the activity. If we don't destroy the materials, the new
    activity instance, which has its own graphics context, will throw errors when
    it tries to use shaders compiled on the first activity's graphics context.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了对`BorderMaterial.destroy()`的调用，因为意图会启动活动的第二个实例。如果我们不销毁材料，新的活动实例，它有自己的图形上下文，将在尝试使用在第一个活动的图形上下文上编译的着色器时抛出错误。
- en: Now with the project built and installed on the phone, when you choose an image
    file, for example, from a file folder browser app such as **My Files** (Samsung),
    you're given a choice of apps with an intent to view images. Your Gallery360 app
    (or whatever you have actually named it) will be one of the choices, as shown
    in the following screenshot. Pick it and it will launch with that image file view
    as the default.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，项目已经构建并安装到手机上，当您选择一个图像文件时，例如，从文件夹浏览器应用程序（例如**我的文件**（三星））中，您将得到一个选择使用意图查看图像的应用程序的选项。您的Gallery360应用程序（或者您实际上命名的任何应用程序）将是其中的一个选择，如下面的屏幕截图所示。选择它，它将以该图像文件视图作为默认视图启动。
- en: '![Launch with an intent](img/B05144_07_15.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![使用意图启动](img/B05144_07_15.jpg)'
- en: Showing/hiding the grid with tilt-up gestures
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用倾斜向上手势显示/隐藏网格
- en: Back in the early days of Cardboard, you had one button. That was all. The one
    button and head tracking were the only ways for the user to interact with the
    app. And because the button was a nifty magnet thing, you couldn't even press
    and hold the one button. With Cardboard 2.0, the screen turned into the button,
    and we also realized that we could briefly take the box off of our face, tilt
    the phone up, put it back on, and interpret that as a gesture. Thus, a second
    input was born! At the time of writing, the sample Cardboard apps use this as
    a back gesture.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cardboard的早期，您只有一个按钮。就是这样。按钮和头部跟踪是用户与应用程序交互的唯一方式。而且因为按钮是一个巧妙的磁铁东西，你甚至不能按住这个按钮。有了Cardboard
    2.0，屏幕变成了按钮，我们还意识到我们可以短暂地把盒子从脸上拿下来，把手机向上倾斜，然后把它放回去，并将其解释为手势。因此，第二个输入诞生了！在撰写本文时，示例Cardboard应用程序将其用作返回手势。
- en: We will be using tilt-up to show and hide the grid and arrows so that you can
    fully immerse yourself in the selected photosphere. Since it's less work, we'll
    also let the user do this anytime, and not just while looking at photospheres.
    As with the vibration feedback, this is actually a pretty painless feature to
    add. Most of the hard work is done by an `OrientationEventListener` class.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用倾斜向上来显示和隐藏网格和箭头，以便您可以完全沉浸在所选的全景照片中。由于这样做的工作量较小，我们还允许用户随时执行此操作，而不仅仅是在查看全景照片时。与振动反馈一样，这实际上是一个相当轻松的功能。大部分的工作都是由`OrientationEventListener`类完成的。
- en: 'At the top of the `MainActivity` class, add a variable for the state of the
    grid, the orientation event listener, and ones for a tilt detection timer, as
    follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`类的顶部，添加一个变量来表示网格的状态，方向事件监听器，以及倾斜检测计时器，如下所示：
- en: '[PRE87]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'First, we can write a method that toggles the thumbnail grid menu on/off. Check
    whether there are less images than planes since empty ones are already disabled
    in `updateThumbnails`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以编写一个方法来切换缩略图网格菜单的开/关。检查是否有比平面更少的图像，因为空的图像已经在`updateThumbnails`中被禁用：
- en: '[PRE88]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, write a `setupOrientationListener` helper method, which provides a callback
    function when the device orientation changes. If the orientation gets close to
    vertical after being in landscape mode, we can call our toggle function, and once
    the device returns to landscape and goes vertical again, we toggle again:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编写一个`setupOrientationListener`辅助方法，当设备方向发生变化时提供回调函数。如果方向接近垂直，我们可以调用我们的切换函数，一旦设备返回横向并再次垂直，我们再次切换：
- en: '[PRE89]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then, add it to `onCreate`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其添加到`onCreate`中：
- en: '[PRE90]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `setupComplete` flag prevents the grid from being toggled while it is still
    being created. Let''s reset the complete flag after `updateThumbnails`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupComplete`标志防止在网格仍在创建时切换网格。让我们在`updateThumbnails`之后重置完成标志：'
- en: '[PRE91]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'It''s prudent to destroy it in `onDestroy`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onDestroy`中销毁它是明智的：
- en: '[PRE92]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `onOrientationChanged` callback will fire whenever the phone changes orientation.
    We'll only be interested in the times when it changes from landscape to portrait,
    and we also want to make sure that it doesn't happen too often, hence the **tilt
    damper** feature. You might want to tweak the value (currently 250 milliseconds)
    to your liking. Too short, and you might falsely register two changes in a row.
    Too long, and the user might try to tiltup twice within the cutoff time.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`onOrientationChanged`回调将在手机改变方向时触发。我们只对从横向到纵向的变化感兴趣，并且我们也希望确保它不会发生太频繁，因此有了**倾斜阻尼器**功能。您可能希望调整值（目前为250毫秒）以满足您的喜好。时间太短，可能会错误地注册两次变化。时间太长，用户可能会在截止时间内尝试两次倾斜。'
- en: Spherical thumbnails
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 球形缩略图
- en: Spherical 360-degree images deserve better than a plain ol' paint-chip thumbnail
    images, don't you think? I suggest that we display them as small balls. Maybe
    we should call them thumb-tips or thumb-marbles. Anyway, let's do a little hacking
    to make this happen.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 球形360度图像应该比普通的缩略图图像更好，不是吗？我建议我们将它们显示为小球。也许我们应该称它们为拇指尖或拇指弹珠。无论如何，让我们做一些小小的修改来实现这一点。
- en: Add a sphere to the Thumbnail class
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`Thumbnail`类中添加一个球体
- en: 'In the `Thumbnail` class, add a `sphere` variable:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Thumbnail`类中，添加一个`sphere`变量：
- en: '[PRE93]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Modify `setImage` to recognize a photosphere image:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`setImage`以识别全景图像：
- en: '[PRE94]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We must also change `setVisible` to handle both the `plane` and `sphere` variables,
    as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须更改`setVisible`以处理`plane`和`sphere`变量，如下所示：
- en: '[PRE95]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, in the `MainActivity` class''s `setupThumbnailGrid`, initialize a `Sphere`
    object in addition to a `Plane` object (inside the `GRID_Y` and `GRID_X` loops):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`MainActivity`类的`setupThumbnailGrid`中，除了`Plane`对象之外，还初始化一个`Sphere`对象（在`GRID_Y`和`GRID_X`循环内）：
- en: '[PRE96]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Now the thumbnails have both a plane and a sphere that we can populate depending
    on the image type.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，缩略图既有一个平面又有一个球体，我们可以根据图像类型进行填充。
- en: Lastly, we just need to modify the `selectObject` method to see how we highlight
    a sphere thumbnail. We highlight the rectangular ones by changing the border color.
    Our spheres don't have a border; in lieu of that we'll change their size.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要修改`selectObject`方法，看看我们如何突出显示一个球体缩略图。我们通过改变边框颜色来突出显示矩形的缩略图。我们的球体没有边框；因此我们将改变它们的大小。
- en: 'At the top of `MainActivity`, add variables to the normal and selected scales:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`的顶部，添加变量到正常和选定的比例：
- en: '[PRE97]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now, change `selectObject` to behave differently when the image is a photosphere:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当图像是全景照片时，将`selectObject`更改为以不同的方式行事：
- en: '[PRE98]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Whoo hoo! We even have the sphere spinning, so you can see its 360-ness in all
    its glory! This is so much fun, it should be illegal.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！我们甚至让球体旋转，这样你就可以看到它360度的全部荣耀！这太有趣了，简直应该是非法的。
- en: '![Add a sphere to the Thumbnail class](img/B05144_07_16.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![在缩略图类中添加一个球体](img/B05144_07_16.jpg)'
- en: There you have it! A beautiful photo viewer app that supports both regular camera
    images as well as 360-degree photospheres.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！一个美丽的照片查看器应用程序，支持常规相机图像和360度全景照片。
- en: Updating the RenderBox library
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新RenderBox库
- en: With the Gallery360 project implemented and our code stabilized, you might realize
    that we've built some code that is not necessarily specific to this application
    that can be reused in other projects, and ought to make its way back to the `RenderBox`
    library.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: Gallery360项目已经实施并且我们的代码已经稳定，你可能会意识到我们构建了一些不一定特定于这个应用程序的代码，可以在其他项目中重复使用，并且应该回到`RenderBox`库中。
- en: 'We did this at the end of the previous project in [Chapter 6](ch06.html "Chapter 6. Solar
    System"), *Solar System*. You can refer to that topic for details. Follow these
    steps to update the `RenderBoxLib` project:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个项目的最后在[第6章](ch06.html "第6章. Solar System")中完成了这个。你可以参考那个主题了解详情。按照以下步骤更新`RenderBoxLib`项目：
- en: Move the `Plane` and `Triangle` components from `RenderBoxExt/components`.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`RenderBoxExt/components`移动`Plane`和`Triangle`组件。
- en: Move the `BorderMaterial` component from `RenderBoxExt/materials`.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`RenderBoxExt/materials`移动`BorderMaterial`组件。
- en: Move the border shader files from `res/raw`.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`res/raw`移动边框着色器文件。
- en: Refactor any invalid references to correct the package names.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复任何无效引用以正确的包名称。
- en: Rebuild the library by clicking **Build** | **Make Project**.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**Build** | **Make Project**来重建库。
- en: Further possible enhancements
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步的可能增强
- en: 'Whew, that was a lot of work! This thing is certainly done, isn''t it? *Never!*
    Here are a few improvements just begging to be implemented:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这是很多工作！这个东西肯定完成了，不是吗？*永远不是！*这里有一些改进，迫切需要实施：
- en: 'Better detection of phone images:'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好地检测手机图片：
- en: Not everyone keeps all of their images in a specific path. In fact, some camera
    software uses completely different paths! Introduce a proper file browser.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并不是每个人都把他们的所有图像保存在特定的路径中。事实上，一些相机软件使用完全不同的路径！引入一个合适的文件浏览器。
- en: 'Better detection of photosphere images:'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好地检测全景图像：
- en: 'There is a `Projection Type` attribute in the XMP header, another piece of
    metadata in some JPG files. Unfortunately, the Android API doesn''t have a specific
    class to read this data, and integrating a third-party library is beyond the scope
    of this project. Feel free to try the following links:'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在XMP头文件中有一个`Projection Type`属性，这是一些JPG文件中的另一个元数据。不幸的是，Android API没有一个特定的类来读取这些数据，集成第三方库超出了这个项目的范围。可以尝试以下链接：
- en: '[https://github.com/dragon66/pixymeta-android](https://github.com/dragon66/pixymeta-android)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/dragon66/pixymeta-android](https://github.com/dragon66/pixymeta-android)'
- en: '[https://github.com/drewnoakes/metadata-extractor](https://github.com/drewnoakes/metadata-extractor)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/drewnoakes/metadata-extractor](https://github.com/drewnoakes/metadata-extractor)'
- en: Don't use the pano technique because it picks up regular panoramas. Allow users
    to flag or fix photosphere or rotation metadata on images that are displayed incorrectly.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用全景技术，因为它会捕捉到常规全景照片。允许用户标记或修复显示不正确的全景照片或旋转元数据的图像。
- en: Animate UI actions—scale/translate on select, smooth grid scrolling.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画UI操作-选择时的缩放/平移，平滑网格滚动。
- en: A nifty technique to keep grid tiles from showing up behind the up/down arrows
    is known as **depth masking**. You can also just introduce a maximum and minimum
    Y value in the world space beyond which tiles would not be able to draw. But depth
    masks are cooler.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个很棒的技术，可以防止网格瓦片出现在上/下箭头的后面，称为**深度遮罩**。你也可以在世界空间中引入最大和最小的Y值，超出这些值的瓦片将无法绘制。但深度遮罩更酷。
- en: Respond to the `GALLERY` intent to override the grid with a selection of images
    from another app.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应`GALLERY`意图，用来覆盖网格并从另一个应用程序中选择图像。
- en: Accept image URLs from the web in `VIEW` intents.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`VIEW`意图中接受来自网络的图像URL。
- en: You need to first download the image, and then load it from the download path.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要首先下载图像，然后从下载路径加载它。
- en: Summary
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I hope you're as excited as I am with what we accomplished here! We built a
    truly practical Cardboard VR app to view a gallery of regular photos and 360-degree
    photospheres. The project uses the `RenderBox` library, as discussed in [Chapter
    5](ch05.html "Chapter 5. RenderBox Engine"), *RenderBox Engine*.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你和我一样对我们在这里取得的成就感到兴奋！我们构建了一个真正实用的Cardboard VR应用程序，用于查看常规照片和360度全景照片的画廊。该项目使用了`RenderBox`库，如[第5章](ch05.html
    "第5章. RenderBox Engine")中所讨论的，*RenderBox Engine*。
- en: To begin with, we illustrated how photospheres work and viewed one on Cardboard
    using the `RenderBox` library without any custom changes. Then, to view a regular
    photo, we created a `Plane` component to be used as a virtual projection screen.
    We wrote new materials and shaders to render images with a frame border.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们演示了全景照片的工作原理，并使用`RenderBox`库在Cardboard上查看了一个，而没有进行任何自定义更改。然后，为了查看常规照片，我们创建了一个`Plane`组件，用作虚拟投影屏幕。我们编写了新的材料和着色器来渲染带有边框的图像。
- en: Next, we defined a new `Image` class and loaded images from the phone's camera
    folder into a list, and wrote a method to show the image on the screen `Plane`,
    correcting its orientation and aspect ratio. Then, we built a user interface that
    shows a grid of thumbnail images and lets you select one by gazing at it and clicking
    on the Cardboard trigger to display the image. The grid is scrollable, which required
    us to add threading, so the app would not appear to lock up when files are loading.
    Lastly, we added a couple of bells and whistles to launch the app with the image
    view intent, toggle the menu grid by tilting the phone vertically, and spherical
    thumbanils for photospheres.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个新的“Image”类，并从手机的相机文件夹中加载图像到列表中，并编写了一个方法来在屏幕上显示图像“Plane”，纠正其方向和纵横比。然后，我们构建了一个用户界面，显示了缩略图图像的网格，并允许您通过凝视并点击Cardboard触发器来选择其中一个图像进行显示。该网格是可滚动的，这要求我们添加线程，以便在加载文件时应用程序不会出现锁定。最后，我们添加了一些功能来启动带有图像查看意图的应用程序，通过将手机垂直倾斜来切换菜单网格，并为全景照片添加了球形缩略图。
- en: In the next chapter, we'll build another kind of viewer; this time to view full
    3D models in OBJ files.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建另一种类型的查看器；这次是为了查看OBJ文件中的完整3D模型。
