- en: '*Chapter 6*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: The JavaScript Ecosystem
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript生态系统
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够做到以下事情：
- en: Compare the different JavaScript ecosystems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较不同的JavaScript生态系统
- en: Explain the basic concepts of server-side JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释服务器端JavaScript的基本概念
- en: Build a Node.js and Express server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个Node.js和Express服务器
- en: Build a React frontend website
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个React前端网站
- en: Combine a frontend framework with a backend server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将前端框架与后端服务器结合起来
- en: The final chapter covers the JavaScript Ecosystem in detail, and teaches the
    students how to work with different features and sections of Node.js, as well
    as the Node Package Manager (NPM).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一章详细介绍了JavaScript生态系统，并教导学生如何使用Node.js的不同功能和部分，以及Node包管理器（NPM）。
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: '**In** *Chapter 5, Functional Programming*, we covered the **Functional Programming
    paradigm**. We covered **Object Oriented Programming** and Functional Programming,
    discussed the differences between the two, and outlined the reasons why we should
    use functional programming. In the second section, we discussed the key concepts
    of functional programming and demonstrated how they are applied to JavaScript
    code.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章“函数式编程”中，我们介绍了“函数式编程范式”。我们讨论了面向对象编程和函数式编程，讨论了两者之间的区别，并概述了为什么我们应该使用函数式编程。在第二部分中，我们讨论了函数式编程的关键概念，并演示了它们如何应用于JavaScript代码。
- en: The JavaScript ecosystem has grown immensely over the past 10+ years. JavaScript
    is no longer a programming language to be used for adding flair, such as animations,
    on top of a basic HTML web page. JavaScript can now be used to build full backend
    web servers and services, command-line interfaces, mobile apps, and frontend sites.
    In this chapter, we will introduce the JavaScript ecosystem, discuss building
    web servers in JavaScript with Node.js, and discuss building websites with JavaScript
    using the React framework.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的10多年里，JavaScript生态系统已经大幅增长。JavaScript不再只是用于在基本的HTML网页上添加动画等效果的编程语言。现在JavaScript可以用于构建完整的后端Web服务器和服务、命令行界面、移动应用程序和前端网站。在本章中，我们将介绍JavaScript生态系统，讨论使用Node.js在JavaScript中构建Web服务器，并讨论使用React框架在JavaScript中构建网站。
- en: JavaScript Ecosystem
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript生态系统
- en: 'There are four main categories of the JavaScript ecosystem that we will discuss:
    **frontend**, **command-line** **interface**, **mobile**, and **backend**.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论JavaScript生态系统的四个主要类别：前端、命令行界面、移动和后端。
- en: Front-end JavaScript is used for user-facing websites.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端JavaScript用于用户界面网站。
- en: Command-line interface (CLI) JavaScript is used for building command-line tasks
    to assist developers.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行界面（CLI）JavaScript用于构建命令行任务，以帮助开发人员。
- en: Mobile development JavaScript is used to build mobile phone apps.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动开发JavaScript用于构建手机应用程序。
- en: Backend JavaScript is used to build web servers and services.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端JavaScript用于构建Web服务器和服务。
- en: For a language that was created originally to embed simple applications in browsers,
    JavaScript has come a long way.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最初是为了在浏览器中嵌入简单应用程序而创建的语言来说，JavaScript已经走了很长的路。
- en: Frontend JavaScript
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端JavaScript
- en: '**Frontend JavaScript** is used for creating complicated and dynamic user-facing
    websites. Websites such as Facebook, Google Maps, Spotify, and YouTube rely heavily
    on JavaScript. In frontend development, JavaScript is used to manipulate the DOM
    and handle events. Many JavaScript libraries, such as jQuery, have been created
    to increase the efficiency and ease of JavaScript DOM manipulation by wrapping
    the DOM manipulation APIs of each browser into a standardized API. The most prevalent
    DOM manipulation library is jQuery, which was discussed in *Chapter 3, DOM Manipulation
    and Event Handling*. JavaScript frameworks have also been created to more seamlessly
    integrate DOM manipulation and events with the HTML design aspect. Two of the
    most common JavaScript frameworks for frontend development are **AngularJS** and
    **React**. AngularJS was built by and is maintained by Google, and React was built
    by and is maintained by Facebook.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前端JavaScript用于创建复杂和动态的用户界面网站。Facebook、Google Maps、Spotify和YouTube等网站都严重依赖JavaScript。在前端开发中，JavaScript用于操作DOM和处理事件。许多JavaScript库，如jQuery，已被创建以通过将每个浏览器的DOM操作API封装成标准化API来增加JavaScript
    DOM操作的效率和便利性。最常见的DOM操作库是jQuery，在第3章“DOM操作和事件处理”中进行了讨论。还创建了JavaScript框架，以更无缝地将DOM操作和事件与HTML设计方面整合在一起。前端开发中最常见的两个JavaScript框架是AngularJS和React。AngularJS由Google创建和维护，React由Facebook创建和维护。
- en: Facebook and Google manage bug fixes and version releases for their respective
    frameworks. React will be discussed in more detail in a later section of this
    chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook和Google管理其各自框架的错误修复和版本发布。React将在本章的后面部分进行更详细的讨论。
- en: Command-Line Interface
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行界面
- en: '**Command-line integration (CLI)** JavaScript is generally used to create utilities
    to assist developers with repetitive or time-intensive tasks. CLI programs in
    JavaScript are generally used for tasks such as linting code, starting a server,
    building releases, transpiling code, minifying files, and installing development
    dependencies and packages. JavaScript CLI programs are generally written in Node.js.
    Node.js is a cross-platform environment that allows developers to execute JavaScript
    code outside a browser. Node.js will be discussed in more detail in a later section
    of this chapter. Many developers rely on CLI utilities in their day-to-day development.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行集成（CLI）JavaScript通常用于创建实用程序，以帮助开发人员处理重复或耗时的任务。JavaScript的CLI程序通常用于诸如代码检查、启动服务器、构建发布、转译代码、文件最小化以及安装开发依赖和包等任务。JavaScript的CLI程序通常是用Node.js编写的。Node.js是一个跨平台环境，允许开发人员在浏览器之外执行JavaScript代码。Node.js将在本章的后面部分进行更详细的讨论。许多开发人员在日常开发中依赖CLI实用程序。
- en: Mobile Development
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动开发
- en: '**Mobile development** with JavaScript is quickly becoming mainstream. Since
    the rise of smartphones, mobile developers have become a hot commodity. While
    JavaScript cannot be run natively on most mobile operating systems, frameworks
    exist that allow JavaScript and HTML to be built into Android and IOS phone apps.
    The most common frameworks for JavaScript mobile development are Ionic, React
    Native, and Cordova/PhoneGap. These frameworks all allow you to write JavaScript
    to build the framework and logic of an application and then compile the JavaScript
    down to the native mobile operating system code. Mobile development frameworks
    are very powerful because they allow us to build full mobile applications in our
    preferred JavaScript.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用JavaScript进行移动开发**正在迅速成为主流。自智能手机兴起以来，移动开发人员已成为炙手可热的商品。尽管JavaScript不能在大多数移动操作系统上本地运行，但存在允许将JavaScript和HTML构建到Android和IOS手机应用程序中的框架。JavaScript移动开发最常见的框架是Ionic、React
    Native和Cordova/PhoneGap。这些框架都允许您编写JavaScript来构建应用程序的框架和逻辑，然后将JavaScript编译为本机移动操作系统代码。移动开发框架非常强大，因为它们允许我们使用首选的JavaScript构建完整的移动应用程序。'
- en: Backend Development
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端开发
- en: '**Backend development** with JavaScript is generally done with Node.js. Node.js
    can be used to build powerful web servers and services. As stated earlier in this
    topic, Node.js and its application to backend server development will be discussed
    in more detail in a later section of this chapter.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用JavaScript进行后端开发**通常使用Node.js。Node.js可用于构建强大的Web服务器和服务。正如前面所述，Node.js及其在后端服务器开发中的应用将在本章的后续部分中进行更详细的讨论。'
- en: The JavaScript ecosystem is very extensive. It is possible to write nearly any
    sort of program in JavaScript. Despite the number of frameworks and the capabilities
    of modern JavaScript, it is important to remember that a framework does not replace
    a good understanding of core JavaScript. Frameworks nicely wrap core JavaScript
    to allow us to perform powerful tasks like building mobile and desktop applications
    from it, but if the core principles of JavaScript and asynchronous programming
    are not well understood, flaws may begin to appear in our applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript生态系统非常广泛。几乎可以用JavaScript编写任何类型的程序。尽管现代JavaScript具有许多框架和功能，但重要的是要记住，框架不能取代对核心JavaScript的深入理解。框架很好地封装了核心JavaScript，使我们能够执行强大的任务，如构建移动和桌面应用程序，但如果不深刻理解JavaScript和异步编程的核心原则，应用程序可能会出现缺陷。
- en: Node.js
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js
- en: '**Node.js** (Node for short), which was developed in 2009 by Ryan Dahl, is
    the most popular out-of-browser JavaScript engine. Node is an open source, cross-platform
    JavaScript runtime environment that was based on Chrome''s V8 JavaScript engine.
    It is used to run JavaScript code outside of the browser for non-client, side applications.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node.js**（简称Node），由Ryan Dahl于2009年开发，是最流行的非浏览器JavaScript引擎。Node是一个基于Chrome的V8
    JavaScript引擎的开源、跨平台JavaScript运行时环境。它用于在浏览器之外运行JavaScript代码，用于非客户端的应用程序。'
- en: Like Google's V8 JavaScript engine in Chrome, Node.js uses a singly-threaded,
    event-driven, asynchronous architecture. It allows developers to use JavaScript's
    event-driven programming style to build web servers, services, and CLI tools.
    As discussed in *Chapter 2, Asynchronous JavaScript*, JavaScript is a non-blocking
    and event-driven programming language. JavaScript's asynchronous nature (a single-threaded
    event loop), along with Node's lightweight design, allows us to build very scalable
    network applications without worrying about threading.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与Chrome中的Google V8 JavaScript引擎一样，Node.js使用单线程、事件驱动、异步架构。它允许开发人员使用JavaScript的事件驱动编程风格来构建Web服务器、服务和CLI工具。如*第2章，异步JavaScript*中所讨论的，JavaScript是一种非阻塞和事件驱动的编程语言。JavaScript的异步特性（单线程事件循环），加上Node的轻量设计，使我们能够构建非常可扩展的网络应用程序，而无需担心线程。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: As discussed in *Chapter 2, Asynchronous JavaScript*, JavaScript is single-threaded.
    Synchronous code running on a single thread is blocking. CPU-intensive operations
    will block events as I/O file system operations and network operations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如*第2章，异步JavaScript*中所讨论的，JavaScript是单线程的。在单线程上运行的同步代码是阻塞的。CPU密集型操作将阻塞事件，如I/O文件系统操作和网络操作。
- en: Setting Up Node.js
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置Node.js
- en: 'Node.js can be downloaded from the Node.js website, which can be found at [https://nodejs.org/en/](https://nodejs.org/en/).
    There are two versions available for download: the **Long Term Support (LTS)**
    version and the current version. We recommend that you download the LTS version.
    The current version has the latest features available, which may not be completely
    bug-free. Be sure to follow your operating system''s specific instructions for
    installing Node. An installer file can be downloaded for all three of the major
    operating systems, and Node.js can be installed with many package managers. Node.js
    installation debugging is outside of the scope of this book. However, installation
    tips and debugging tips can be found easily with a Google search.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js可以从Node.js网站下载，网址为[https://nodejs.org/en/](https://nodejs.org/en/)。有两个可供下载的版本：**长期支持（LTS）**版本和当前版本。我们建议您下载LTS版本。当前版本具有最新的功能，但可能不完全没有错误。请务必遂行您操作系统的特定安装说明。可以为所有三种主要操作系统下载安装程序文件，并且可以使用许多软件包管理器安装Node.js。Node.js安装调试不在本书的范围之内。但是，可以通过谷歌搜索轻松找到安装提示和调试提示。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'Node.js''s download link is as follows: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的下载链接如下：[https://nodejs.org/en/download/](https://nodejs.org/en/download/)。
- en: 'Once Node.js has been downloaded and installed, it can be run from the terminal
    with the `node` command. Executing this command with no arguments following it
    will run the Node.js terminal. JavaScript code can be typed directly into the
    terminal, just like a browser''s debug console. It is important to note that there
    is no state carry over between terminal instances. When the terminal instance
    running the Node.js command-line closes, all computation will stop, and all memory
    being used by the Node.js command line process will be released back to the OS.
    To run a JavaScript code file with Node.js, simply add the file path directly
    after the `node` command. For example, the following command will run the file
    at the`./path/to/file` location with the filename `my_file.js`: `node ./path/to/file/my_file.js`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Node.js被下载并安装，就可以使用`node`命令从终端运行它。在执行此命令后不跟任何参数，将运行Node.js终端。JavaScript代码可以直接在终端中输入，就像浏览器的调试控制台一样。重要的是要注意，在终端实例之间没有状态传递。当运行Node.js命令行的终端实例关闭时，所有计算将停止，并且Node.js命令行进程使用的所有内存将释放回操作系统。要使用Node.js运行JavaScript代码文件，只需在`node`命令后直接添加文件路径。例如，以下命令将在`./path/to/file`位置以文件名`my_file.js`运行文件：`node
    ./path/to/file/my_file.js`。
- en: Node Package Manager
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Node包管理器
- en: Node.js is an open source platform. One of Node's largest assets is the availability
    of open source third-party libraries, called modules. Node uses the **Node Package
    Manager (NPM)** to handle the installation and management of the third-party modules
    that are used by an application. NPM is usually installed with Node.js. To test
    whether NPM was installed correctly with your installation of Node, open a terminal
    window and run the `npm -v` command. If NPM is correctly installed, the current
    version of NPM will be printed in the terminal. If NPM did not install with Node,
    you may have to rerun the Node.js installer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个开源平台。Node的最大优势之一是可用的开源第三方库，称为模块。Node使用**Node包管理器（NPM）**来处理应用程序使用的第三方模块的安装和管理。NPM通常与Node.js一起安装。要测试NPM是否已正确安装到Node，请打开终端窗口并运行`npm
    -v`命令。如果NPM已正确安装，终端将打印出当前NPM的版本。如果NPM未随Node一起安装，可能需要重新运行Node.js安装程序。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The NPM documentation for all the functionality not covered in this section
    can be found at [https://docs.npmjs.com/](https://docs.npmjs.com/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本节未涵盖的所有功能的NPM文档可以在[https://docs.npmjs.com/](https://docs.npmjs.com/)找到。
- en: In *Chapter 1, Introducing ECMAScript 6*, we learned about ES6 modules. It is
    very important that we make a distinction between ES6 modules and Node.js modules.
    Node.js modules were created well before ES6 and vanilla JavaScript's support
    for modules. While Node.js modules and ES6 modules are used for the same purpose,
    they do not follow the same technology specification. Node.js modules and ES6
    modules are loaded, parsed, and built differently. Node.js modules are loaded
    from the disk synchronously, parsed synchronously, and built synchronously. No
    other code can run before the modules have been loaded. Unfortunately, ES6 modules
    are not loaded in the same way. They are loaded asynchronously from disk. The
    two different module loading methods are not compatible. At the time of writing
    this book, Node.js support for ES6 modules is in beta and is not enabled by default.
    Support for ES6 modules can be enabled, but we recommend that you use standard
    node modules until full support for ES6 modules is released.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章，介绍ECMAScript 6*中，我们学习了关于ES6模块。非常重要的是，我们要区分ES6模块和Node.js模块。Node.js模块是在ES6和原始JavaScript对模块的支持之前创建的。虽然Node.js模块和ES6模块用于相同的目的，但它们不遵循相同的技术规范。Node.js模块和ES6模块的加载、解析和构建方式不同。Node.js模块是同步从磁盘加载、同步解析和同步构建的。在模块加载完成之前，没有其他代码可以运行。不幸的是，ES6模块的加载方式不同。它们是异步从磁盘加载的。这两种不同的模块加载方法不兼容。在撰写本书时，Node.js对ES6模块的支持处于测试阶段，并且默认情况下未启用。可以启用对ES6模块的支持，但我们建议您在ES6模块的完全支持发布之前使用标准的Node模块。
- en: 'NPM packages are installed via the command line with the `npm install` command.
    You can use this command to either add a specific package to the project or install
    all missing dependencies. If no arguments are given to the install command, `npm`
    will look in the current directory for a `package.json` file. Inside the `package.json`
    file, there is a `dependencies` field that contains all of the dependencies that
    have been installed for the Node.js project. NPM will run through the dependency
    list and verify that each package specified in this list is installed. The dependency
    list in `packages.json` will look similar to the code that''s shown in the following
    snippet:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: NPM包是通过命令行使用`npm install`命令安装的。您可以使用此命令将特定包添加到项目中，或安装所有缺少的依赖项。如果没有向安装命令提供参数，`npm`将在当前目录中查找`package.json`文件。在`package.json`文件中，有一个`dependencies`字段，其中包含为Node.js项目安装的所有依赖项。NPM将遍历依赖项列表，并验证该列表中指定的每个包是否已安装。`packages.json`中的依赖项列表将类似于以下代码片段中显示的代码：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Snippet 6.1: Dependency list in package.json'
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码片段6.1：package.json中的依赖项列表
- en: The dependencies field in `package.json` lists the NPM modules that have been
    installed for the project, along with the version number. In this snippet, we
    have the `amqplib` module installed at version `0.5.2` or higher, the `body-parser`
    module installed at `1.18.3` or higher, and several others. NPM modules follow
    semantic versioning. The version number is expressed by three numbers, separated
    by periods. The first number is the major version. Increases in the major version
    number indicate major changes that break backwards compatibility. The second number
    is the minor version. Changes to the minor version number indicate a release of
    new features that do not break backward compatibility. The final number is the
    patch number. Increases to the patch number indicate a bug fix or small updates
    to a feature. Increases in patch number do not include new functionality and do
    not break backwards compatibility.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`中的依赖项字段列出了为项目安装的NPM模块，以及版本号。在这个片段中，我们安装了`amqplib`模块的版本为`0.5.2`或更高版本，安装了`body-parser`模块的版本为`1.18.3`或更高版本，以及其他几个模块。NPM模块遵循语义化版本。版本号由三个数字组成，用句点分隔。第一个数字是主要版本。主要版本号的增加表示破坏向后兼容的重大更改。第二个数字是次要版本。次要版本号的更改表示发布了不会破坏向后兼容性的新功能。最后一个数字是补丁号。补丁号的增加表示修复错误或对功能进行小更新。补丁号的增加不包括新功能，也不会破坏向后兼容性。'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: More information about semantic versioning can be found at [https://www.npmjs.com/](https://www.npmjs.com/).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有关语义化版本的更多信息，请访问[https://www.npmjs.com/](https://www.npmjs.com/)。
- en: To install a module, you can add an argument to the `npm install` command after
    the word *install* (for example, `npm install express`). The argument can be either
    the package name, a Git repository, a **tarball**, or a folder. If the argument
    is a package, NPM will search through its list of registered packages and install
    the package that matches the name. If the argument is a Git repository, NPM will
    attempt to download and install the files from the Git repository. If the proper
    access credentials are not provided, the installation may fail.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 安装模块时，可以在`npm install`命令的*install*后添加参数（例如，`npm install express`）。参数可以是包名称、Git存储库、**tarball**或文件夹。如果参数是一个包，NPM将在其注册的包列表中搜索并安装与名称匹配的包。如果参数是Git存储库，NPM将尝试从Git存储库下载并安装文件。如果没有提供适当的访问凭据，安装可能会失败。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: See the NPM documentation for how to install packages from private git repositories.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅NPM文档，了解如何从私有git存储库安装包。
- en: If the argument is a tarball, NPM will unpack the tarball and install the files.
    A tarball can be installed through a URL that points to the tarball or through
    a local file. Finally, if the argument that's specified is a folder on the local
    machine, NPM will attempt to install an NPM package from the specified folder.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是一个tarball，NPM将解压tarball并安装文件。tarball可以通过指向tarball的URL或本地文件进行安装。最后，如果指定的参数是本地机器上的文件夹，NPM将尝试从指定的文件夹安装NPM包。
- en: When installing packages with NPM, it is important to consider how the package
    will be installed. By default, packages are installed in the local project scope
    and not saved as project dependencies. If you are installing an NPM package that
    you want saved in `package.json` as a project dependency, you must include the
    `--save` or `-s` argument after the package name in the install command (for example,
    `npm install express -s`). This argument tells NPM to save the dependency in `package.json`
    so that an `npm install` command at a later time will install it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用NPM安装包时，重要考虑包的安装方式。默认情况下，包是在本地项目范围内安装的，并且不会保存为项目依赖项。如果要安装一个NPM包，并希望将其保存在`package.json`中作为项目依赖项，必须在安装命令的包名称后包含`--save`或`-s`参数（例如，`npm
    install express -s`）。此参数告诉NPM将依赖项保存在`package.json`中，以便以后的`npm install`命令会安装它。
- en: 'NPM packages can be installed in two scopes: the **global scope** and the **local
    scope**. Packages installed in the local scope, or local packages, can only be
    used inside the Node.js project where they are installed. Packages installed in
    the global scope, or global packages, can be used by any Node.js project. Packages
    are installed locally by default. To force a module to be installed globally,
    you can add the `-g` or `--global` flag to the `npm install` command after the
    package name (for example, `npm install express -g`).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: NPM包可以安装在两个范围内：**全局范围**和**本地范围**。在本地范围内安装的包，或本地包，只能在安装它们的Node.js项目中使用。在全局范围内安装的包，或全局包，可以被任何Node.js项目使用。默认情况下，包是本地安装的。要强制安装模块为全局安装，可以在包名称后添加`-g`或`--global`标志到`npm
    install`命令（例如，`npm install express -g`）。
- en: It is not always apparent where you should install a package, but you can follow
    the following general rule of thumb if you are unsure. If you are going to use
    the package in a project with the `require()` function, install the package locally.
    If you plan on using the package on the command line, install the package globally.
    If you still cannot decide and need to use the package in a project and on the
    command line, you can simply install it in both places.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 并不总是明显应该在哪里安装包，但如果不确定，可以遵循以下一般规则。如果要在具有`require()`函数的项目中使用包，请在本地安装包。如果计划在命令行上使用包，请全局安装包。如果仍然无法决定并且需要在项目和命令行中使用包，可以在两个地方都安装它。
- en: Loading and Creating Modules
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载和创建模块
- en: Node.js uses the **CommonJS** style module specification as the standard for
    loading and working with modules. CommonJS is a project that's designed to specify
    a JavaScript ecosystem for JavaScript outside the browser. CommonJS defined a
    specification for modules that was adopted by Node.js. Modules allow the developer
    to encapsulate functionality and expose only the desired parts of the encapsulated
    functionality to other JavaScript files.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js使用**CommonJS**风格的模块规范作为加载和处理模块的标准。CommonJS是一个旨在为浏览器外的JavaScript指定JavaScript生态系统的项目。CommonJS定义了一个模块规范，被Node.js采纳。模块允许开发人员封装功能，并仅向其他JavaScript文件公开所需部分的封装功能。
- en: 'In Node.js, we use the require function to import modules into our code (`require(''module'')`).
    The `require` function can load any valid JavaScript file, NPM module, or JSON
    file. We will use the `require` function to load any NPM packages that have been
    installed for our project. To load a module, simply pass the name of the module
    as a parameter into the `require` function and save the returned object into a
    variable. For example, we could load the NPM module `body-parser` with the following
    code: `const bodyParser = require( ''body-parser'' )`;. This loads the exported
    functions and variables into the `bodyParser` object. The require function can
    also be used to load JavaScript files and JSON files. To load one of these files,
    you simply need to pass the file path into the `require` function instead of a
    module name. If no file extension is provided, Node.js will look for a JavaScript
    file by default.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，我们使用require函数将模块导入到我们的代码中（`require('module')`）。`require`函数可以加载任何有效的JavaScript文件、NPM模块或JSON文件。我们将使用`require`函数加载为我们的项目安装的任何NPM包。要加载一个模块，只需将模块的名称作为参数传递给`require`函数，并将返回的对象保存到一个变量中。例如，我们可以使用以下代码加载NPM模块`body-parser`：`const
    bodyParser = require( 'body-parser' )`。这将导入导出的函数和变量到`bodyParser`对象中。require函数还可以用于加载JavaScript文件和JSON文件。要加载其中一个文件，只需将文件路径传递给`require`函数，而不是模块名称。如果未提供文件扩展名，Node.js将默认查找JavaScript文件。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A directory can also be loaded through the require function. If a directory
    is provided instead of a JS file, the require function will look for a file named
    `index.js` in the specified directory and load that file. If that file cannot
    be found, an error will be thrown.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过require函数加载目录。如果提供的是目录而不是JS文件，则require函数将在指定目录中查找名为`index.js`的文件并加载该文件。如果找不到该文件，将抛出错误。
- en: 'To create a module, that is, a Node.js module, we use the `module.exports`
    property. In Node.js, every JavaScript file has a global variable object called
    `module`. The `exports` field in the `module` object defines what items will be
    exported from the module. When a module is imported with the `require()` function,
    the return value of `require()` is the value that''s set in the module''s `module.exports`
    field. Modules usually export a function or an object with properties for each
    function or variable that''s exported. An example of exporting modules is shown
    in the following snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个模块，即Node.js模块，我们使用`module.exports`属性。在Node.js中，每个JavaScript文件都有一个名为`module`的全局变量对象。`module`对象中的`exports`字段定义了将从模块中导出的项目。当使用`require()`函数导入模块时，`require()`的返回值是模块的`module.exports`字段中设置的值。模块通常导出一个函数或具有每个导出的函数或变量的属性的对象。以下是导出模块的示例：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Snippet 6.2: Exporting a Node.js module'
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Snippet 6.2：导出Node.js模块
- en: 'Exercise 32: Exporting and Importing NPM Modules'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习32：导出和导入NPM模块
- en: 'To build, export, and import NPM modules, perform the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建、导出和导入NPM模块，请执行以下步骤：
- en: Create a JavaScript for our module called `module.js`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的模块创建一个名为`module.js`的JavaScript文件。
- en: Set the `module.exports` property to an object.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`module.exports`属性设置为一个对象。
- en: Add the `exportedConstant` field to the object with the value `An exported constant!`
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`exportedConstant`字段添加到对象中，并将其值设置为`An exported constant!`
- en: Add the `exportedFunction` field to the object and set its value to a function
    that logs to the console with the text `An exported function!`
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`exportedFunction`字段添加到对象中，并将其值设置为记录到控制台的函数，文本为`An exported function!`
- en: Create an `index.js` file for our main code.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的主要代码创建一个`index.js`文件。
- en: Import the module from `module.js` with a `require` function and save it into
    the `ourModule` variable.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`require`函数从`module.js`导入模块，并将其保存到`ourModule`变量中。
- en: Log the value of `exportedString` from `ourModule`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从ourModule中记录`exportedString`的值。
- en: Call the `exportedFunction` function from `ourModule`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ourModule`调用`exportedFunction`函数。
- en: '**Code**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: module.js
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: module.js
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Snippet 6.3: Exporting code as a module'
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Snippet 6.3：将代码导出为模块
- en: https://bit.ly/2M3SIsT
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2M3SIsT
- en: index.js
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: index.js
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Snippet 6.4: Exporting code as a module'
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Snippet 6.4：将代码导出为模块
- en: https://bit.ly/2RwOIXP
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2RwOIXP
- en: '**Outcome**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '![Figure 6.1: Test values output](image/Figure_6.1.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：测试值输出](image/Figure_6.1.jpg)'
- en: 'Figure 6.1: Test values output'
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.1：测试值输出
- en: You have successfully built, exported, and imported NPM modules.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功构建、导出和导入NPM模块。
- en: Basic Node.js Server
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本Node.js服务器
- en: The most common application for Node.js is web servers. Node.js makes it very
    easy to build very efficient and scalable web servers because developers don't
    need to worry about threading. In this section, we will demonstrate the code that's
    required to make a basic web server in Node.js.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js最常见的应用是Web服务器。Node.js使构建高效和可扩展的Web服务器变得非常容易，因为开发人员不需要担心线程。在本节中，我们将演示在Node.js中创建基本Web服务器所需的代码。
- en: 'A Node.js server can be set up as either an HTTP, HTTPS, or HTTP2 server. For
    this example, we will create a basic HTTP server. Node.js has basic functionality
    for an HTTP server available through the HTTP module. Import the HTTP module with
    a require statement. This is shown in the following snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js服务器可以设置为HTTP、HTTPS或HTTP2服务器。在本例中，我们将创建一个基本的HTTP服务器。Node.js通过HTTP模块提供了HTTP服务器的基本功能。使用require语句导入HTTP模块。如下所示：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Snippet 6.5: Loading the HTTP module'
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Snippet 6.5：加载HTTP模块
- en: This line of code will import the functionality contained in the module 'HTTP'
    and save it in the variable `http` for use later. Now that we have loaded the
    HTTP module, we need to choose a hostname and a port to run our server on. Since
    this server will only be running locally to our computer, we can use the IP address
    for the machine's internal local network, localhost ('`127.0.0.1`'), for our hostname
    address. We can run our local server on any network port which isn't already in
    use by another application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将导入模块'HTTP'中包含的功能，并将其保存在变量`http`中以供以后使用。现在我们已经加载了HTTP模块，我们需要选择一个主机名和一个端口来运行我们的服务器。由于这个服务器只会在我们的计算机本地运行，我们可以使用机器内部本地网络的IP地址，即localhost（'127.0.0.1'）作为我们的主机名地址。我们可以在任何尚未被其他应用程序使用的网络端口上运行我们的本地服务器。
- en: 'You can choose any valid port number, but it is rare that programs use port
    `8000` by default, so that is what is used in this demo. Add a variable to contain
    the port number and hostname to your code. The full code to this point is shown
    in the following snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择任何有效的端口号，但通常情况下程序不会默认使用端口`8000`，所以在这个演示中使用了这个端口号。在您的代码中添加一个变量来包含端口号和主机名。到目前为止的完整代码如下所示：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Snippet 6.6: Constants for simple server'
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码段6.6：简单服务器的常量
- en: 'Now that we have set up all of the basic parameters for our server, we can
    write the code to create and start the server. The HTTP module contains a function
    called `createServer()` that returns a server object. This function can take in
    an optional callback function that acts as am HTTP request listener. When any
    HTTP request comes into the server, the provided callback method gets called.
    We need to call the `createServer` function with the request listener callback
    so that our server can properly respond to inbound HTTP requests. This is done
    with the lines of code that are shown in the following snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的服务器设置了所有基本参数，我们可以编写代码来创建和启动服务器。HTTP模块包含一个名为`createServer()`的函数，它返回一个服务器对象。这个函数可以接受一个可选的回调函数，作为HTTP请求监听器。当任何HTTP请求进入服务器时，提供的回调方法会被调用。我们需要使用带有请求监听器回调的`createServer`函数，这样我们的服务器才能正确地响应传入的HTTP请求。这是在以下代码段中显示的代码行：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Snippet 6.7: Creating a simple server'
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码段6.7：创建一个简单的服务器
- en: 'In the preceding snippet, we call the create `server` function and save the
    returned server into the `server` variable. We pass a callback into `createServer()`.
    This callback takes in two arguments: `req` and `res`. The `req` argument represents
    the incoming HTTP request and the `res` argument represents the server HTTP response.
    In the first line of code in the callback, we set the response status code to
    `200`. A `200` status code in the response indicates that the HTTP request to
    the server was successful. In the line after the status code, we set the `Content-Type`
    header in the response to `text/plain`. This step tells the response that the
    data passed into it will be plain text. In the final line of the callback, we
    call the `res.end()` function. This function appends the data passed into it to
    the response, then closes the response and sends it back to the requester. In
    this snippet, we pass in the `Welcome to my server!` string to the `end()` function.
    The response has the string appended to it and the text is sent back to the requester.
    Our server now handles all HTTP calls to it with this handler.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，我们调用`create server`函数并将返回的服务器保存到`server`变量中。我们将一个回调传递给`createServer()`。这个回调接受两个参数：`req`和`res`。`req`参数表示传入的HTTP请求，`res`参数表示服务器的HTTP响应。在回调的第一行代码中，我们将响应状态码设置为`200`。响应中的`200`状态码表示服务器对HTTP请求成功。在状态码之后的一行中，我们在响应中设置了`Content-Type`头为`text/plain`。这一步告诉响应传入的数据将是纯文本。在回调的最后一行中，我们调用了`res.end()`函数。这个函数将传入的数据附加到响应中，然后关闭响应并将其发送回请求者。在这个代码段中，我们将`Welcome
    to my server!`字符串传递给`end()`函数。响应中附加了这个字符串，并将文本发送回请求者。我们的服务器现在使用这个处理程序处理所有对它的HTTP调用。
- en: 'The final step to get our mini server up and running is to call the `.listen()`
    function on the server object. The `listen` function starts the HTTP server on
    the specified `port` and `hostname`. Once the server has begun listening, it can
    accept HTTP requests. The code in the following snippet shows how to make the
    server listen to the specified `port` at the specified `hostname`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的迷你服务器启动并运行的最后一步是在服务器对象上调用`.listen()`函数。`listen`函数在指定的`port`和`hostname`上启动HTTP服务器。一旦服务器开始监听，它就可以接受HTTP请求。以下代码段显示了如何使服务器在指定的`port`和指定的`hostname`上监听：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Snippet 6.8: Server begins listening on hostname and port'
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码段6.8：服务器开始在主机名和端口上监听
- en: The preceding snippet shows how to call the `server.listen()` function. The
    first argument passed into the function is the port number that our server will
    be exposed on. The second argument is the hostname that our server will be accessed
    from. In this example, the port evaluates to `8000` and the hostname evaluates
    to `127.0.0.1` (the local network for your computer). In this example, our server
    will be listening on `127.0.0.1:8000`. The final argument passed in to `.listen()`
    is a callback function. Once the server begins listening for HTTP requests at
    the specified port and hostname, the provided callback function is called. In
    the preceding snippet, the callback function simply prints the URL that our server
    can be accessed from locally. You can enter this URL into your browser and a web
    page will load.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码段显示了如何调用`server.listen()`函数。传递给函数的第一个参数是我们的服务器将暴露在的端口号。第二个参数是我们的服务器将从中访问的主机名。在这个例子中，端口评估为`8000`，主机名评估为`127.0.0.1`（您的计算机的本地网络）。在这个例子中，我们的服务器将在`127.0.0.1:8000`上监听。传递给`.listen()`的最后一个参数是一个回调函数。一旦服务器开始在指定的端口和主机名上监听HTTP请求，提供的回调函数就会被调用。在前面的代码段中，回调函数只是打印出我们的服务器可以在本地访问的URL。您可以将此URL输入到浏览器中，然后一个网页将加载。
- en: 'Exercise 33: Creating a Basic HTTP Server'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习33：创建基本的HTTP服务器
- en: 'To build a basic HTTP server, perform the following steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个基本的HTTP服务器，请执行以下步骤：
- en: Import the `http` module.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`http`模块。
- en: Set up variables for the hostname and port and give them the values `127.0.0.1`
    and `8000,` respectively.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为主机名和端口设置变量，并分别给它们赋值`127.0.0.1`和`8000`。
- en: Create the server with `http.createServer`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`http.createServer`创建服务器。
- en: Provide a callback to the `createServer` function that takes in the arguments
    `req` and `res`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`createServer`函数提供一个回调，该回调接受参数`req`和`res`。
- en: Set the response status code to `200`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将响应状态码设置为`200`。
- en: Set the response content type to `text/plain`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将响应内容类型设置为`text/plain`。
- en: Respond to the request with `My first server!`
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`My first server!`响应请求
- en: Make the server listen on the specified port and host with the `server.listen`
    function.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`server.listen`函数使服务器监听指定的端口和主机。
- en: Provide a callback to the `listen` function that logs `Server running at ${server uri}`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`listen`函数提供一个回调，记录`Server running at ${server uri}`。
- en: Start the server and load the logged web page.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器并加载已记录的网页。
- en: '**Code**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: index.js
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: index.js
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Snippet 6.9: Simple HTTP server'
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码片段6.9：简单的HTTP服务器
- en: https://bit.ly/2sihcFw
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2sihcFw
- en: '**Outcome**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '![Figure 6.2: Returning the new cart array'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2：返回新的购物车数组'
- en: '](image/Figure_6.2.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.2.jpg)'
- en: 'Figure 6.2: Returning the new cart array'
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.2：返回新的购物车数组
- en: '![Figure 6.3: Returning the new cart array'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3：返回新的购物车数组'
- en: '](image/Figure_6.3.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.3.jpg)'
- en: 'Figure 6.3: Returning the new cart array'
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.3：返回新的购物车数组
- en: You have successfully built a basic HTTP server.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功构建了一个基本的HTTP服务器。
- en: Streams and Pipes
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流和管道
- en: Streaming data can be one of the most complicated and misunderstood aspects
    of Node.js. Streams are also arguably one of the most powerful features Node.js
    has to offer. Streams are simply collections of data, just like the standard array
    or string. The main difference is that, with streams, all of the data may not
    be available at one time. You can think of it like streaming a video off YouTube
    or Netflix. You do not need to download the entire video before you can begin
    to watch it. The video provider (YouTube or Netflix) sends, or "streams", the
    video to your computer in small pieces. You can begin watching a part of the video
    without waiting for any other parts to be loaded first. Streams are very powerful
    because they allow the server and the client to not need to load an entire large
    collection of data into memory at one time. In JavaScript servers, streams are
    crucial to memory management.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 流数据可能是Node.js中最复杂和最被误解的方面之一。流也可以说是Node.js提供的最强大的功能之一。流只是数据的集合，就像标准数组或字符串一样。主要区别在于，使用流时，所有数据可能不会同时可用。你可以把它想象成从YouTube或Netflix上流视频。你不需要在开始观看视频之前下载整个视频。视频提供者（YouTube或Netflix）以小块的方式向你的计算机发送视频。你可以开始观看视频的一部分，而不需要等待其他部分被加载。流非常强大，因为它们允许服务器和客户端不需要一次性将整个大量数据集加载到内存中。在JavaScript服务器中，流对于内存管理至关重要。
- en: Many of the built-in modules in Node.js rely on streams. These modules include
    the request and response objects in the HTTP module (`http`), the file system
    module `(fs)` file the cryptography module (crypto), and the child process module
    (`child_process`). In Node.js, streams come in four types— **readable**, **writeable**,
    **duplex**, and **transform**. Understanding what they do is pretty straightforward.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中的许多内置模块依赖于流。这些模块包括HTTP模块（`http`）中的请求和响应对象，文件系统模块（`fs`）中的文件，加密模块（crypto）和子进程模块（`child_process`）。在Node.js中，流有四种类型——**可读**，**可写**，**双工**和**转换**。理解它们的作用非常简单。
- en: Types of Streams
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流的类型
- en: Data is consumed from **Readable Streams**. They abstract the loading and chunking
    of a source. Data is presented for consumption (use) by the readable stream, one
    chunk at a time. After the data chunk has been consumed, it is let go by the stream
    and the next chunk is presented. A readable stream cannot have data pushed into
    it by the consumer. An example of a readable stream is an HTTP request body.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 数据从**可读流**中消耗。它们抽象了源的加载和分块。数据以一次一个数据块的方式呈现给可读流进行消耗（使用）。在数据块被消耗后，它被流释放，并呈现下一个数据块。可读流不能由消费者推送数据进入其中。可读流的一个例子是HTTP请求体。
- en: A **readable stream** comes in two modes— **flowing** and **paused**. These
    modes determine the data flow of the stream. When the stream is in flowing mode,
    data is automatically read from the underlying stream system and is being provided
    to consumers. When the stream is in paused mode, data is not automatically read
    from the underlying system. The consumer must explicitly request data from the
    stream with the `stream.read()` function. All readable streams start in paused
    mode and can be switched to flowing by either attaching a `data` event handler,
    calling `stream.resume()`, or `calling stream.pipe()`. Event handlers and stream
    piping are covered later in this section. A readable stream can be switched from
    flowing to paused with the `stream.pause()` method or the `stream.unpipe()` method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**可读流**有两种模式——**流动**和**暂停**。这些模式决定了流的数据流动。当流处于流动模式时，数据会自动从底层流系统中读取，并提供给消费者。当流处于暂停模式时，数据不会自动从底层系统中读取。消费者必须使用`stream.read()`函数显式请求流中的数据。所有可读流都以暂停模式开始，并可以通过附加`data`事件处理程序、调用`stream.resume()`或`调用stream.pipe()`来切换到流动模式。事件处理程序和流管道将在本节后面介绍。可读流可以使用`stream.pause()`方法或`stream.unpipe()`方法从流动切换到暂停。'
- en: A **writeable stream** is a stream to which data can be written or pushed. **Writeable
    streams** abstract away the combining and handling of the source. Data is presented
    to the stream for consumption by the provider. The stream will consume data one
    chunk at a time until it is told to stop. After the stream has consumed a chunk
    of data and handled it appropriately, it will consume or request the next chunk
    of data that's available. An example of a writeable stream is the filesystem module
    function `createWriteStream`, which allows us to stream data to a file on the
    disk.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**可写流**是可以写入或推送数据的流。**可写流**将源的组合和处理抽象化。数据被呈现给流以供提供者消耗。流将一次消耗一个数据块，直到被告知停止。在流消耗了一个数据块并适当处理后，它将消耗或请求下一个可用的数据块。一个可写流的例子是文件系统模块的`createWriteStream`函数，它允许我们将数据流到磁盘上的文件中。'
- en: A **duplex stream** is a stream that is both readable and writeable. Data can
    be pushed in chunks by a provider to the stream or consumed in chunks by a consumer
    from the stream. An example of a duplex stream is a network socket such as a TCP
    socket.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**双工流**是既可读又可写的流。数据可以由提供者以块的形式推送到流中，也可以由消费者以块的形式从流中消耗。双工流的一个例子是网络套接字，比如TCP套接字。'
- en: A **transform stream** is a duplex stream that allows the data chunks to be
    mutated as they move through the stream. An example of a transform stream is the
    `gzip` method in Node.js's `ZLib` module, which compresses data with the `gzip`
    compression method.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换流**是允许数据块在流中移动时进行变异的双工流。一个转换流的例子是Node.js的`ZLib`模块中的`gzip`方法，它使用`gzip`压缩方法压缩数据。'
- en: Streams load data in chunks instead of all at once, so to effectively use streams,
    we need some way to determine if data has been loaded by the stream. In Node.js,
    streams are instances of the `EventEmitter` prototype. Streams emit events when
    key events happen, such as errors or data availability. Events listeners can be
    attached to streams with the `.on()` and `.once()` methods. Readable streams and
    writeable streams have events for data handling, error handling, and steam management.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 流以块的形式加载数据，而不是一次性加载，因此为了有效地使用流，我们需要一种方法来确定流是否已加载数据。在Node.js中，流是`EventEmitter`原型的实例。当关键事件发生时，流会发出事件，比如错误或数据可用性。事件监听器可以使用`.on()`和`.once()`方法附加到流上。可读流和可写流都有用于数据处理、错误处理和流管理的事件。
- en: 'The following tables show the available events and their purpose:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了可用的事件及其目的：
- en: 'Writeable Stream Events:'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可写流事件：
- en: '![Figure 6.4: Writeable Stream Events'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4：可写流事件'
- en: '](image/Figure_6.4.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.4.jpg)'
- en: 'Figure 6.4: Writeable Stream Events'
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.4：可写流事件
- en: 'Readable Stream Events:'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可读流事件：
- en: '![Figure 6.5: Readable Stream Events'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5：可读流事件'
- en: '](image/Figure_6.5.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.5.jpg)'
- en: 'Figure 6.5: Readable Stream Events'
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.5：可读流事件
- en: Note
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: These event listeners can be attached to the stream to handle data flow and
    manage the state of the stream. Complete documentation can be found on the Node.js
    site under the Stream API.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件监听器可以附加到流上，以处理数据流和管理流的状态。完整的文档可以在Node.js网站的流API下找到。
- en: 'Now that you understand the basics of streams, we must implement them. Readable
    streams follow a basic workflow. Generally, a method that returns a readable stream
    is called. An example of this is the filesystem API function `createReadStream(),`
    which creates a readable stream that streams a file off the disk. After the readable
    stream is returned, we can begin to pull data from the stream by attaching a `data`
    event handler. An example of this is shown in the following snippet:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了流的基础知识，我们必须实现它们。可读流遵循一个基本的工作流程。通常会调用一个返回可读流的方法。一个例子是文件系统API的`createReadStream()`函数，它创建一个从磁盘上流出文件的可读流。在返回可读流之后，我们可以通过附加`data`事件处理程序来开始从流中拉取数据。以下片段展示了一个例子：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Snippet 6.10: Using a readable stream'
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.10：使用可读流
- en: In the preceding example, we imported the `fs` module and call the `createReadStream`
    function. This function returns a readable stream. We then attach an event listener
    to the `data` event. This puts the stream in flowing mode, and every time a data
    chunk is ready, the callback provided will be called. In this example, our callback
    simply logs the data that the readable stream relinquishes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们导入了`fs`模块并调用了`createReadStream`函数。这个函数返回一个可读流。然后我们给`data`事件附加了一个事件监听器。这将把流放入流动模式，每当数据块准备就绪时，提供的回调函数将被调用。在这个例子中，我们的回调函数简单地记录了可读流放弃的数据。
- en: 'Just like readable streams, writable streams also follow a pretty standard
    workflow as well. The most basic workflow for a writable stream is to first call
    a method that returns a writable stream. An example of this is the `fs` module
    function `createWriteStream`. After the writeable stream has been created, we
    can write to it with the `stream.write()` function. This function will write the
    data that''s passed into it to the stream. An example of this is shown in the
    following snippet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 就像可读流一样，可写流也遵循一个相当标准的工作流程。可写流的最基本工作流程是首先调用一个返回可写流的方法。一个例子是`fs`模块的`createWriteStream`函数。创建了可写流之后，我们可以使用`stream.write()`函数向其写入数据。这个函数将传入的数据写入流中。以下片段展示了一个例子：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Snippet 6.11: Using a writeable stream'
  id: totrans-158
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.11：使用可写流
- en: In the preceding snippet, we loaded the `fs` module and called the `createWriteStream`
    function. This returns a writeable stream that writes data to the filesystem.
    We then call the `stream.write()` function several times. Each time we call the
    `write` function, the data we pass into the function is pushed into the writeable
    stream and written to the disk.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，我们加载了`fs`模块并调用了`createWriteStream`函数。这返回一个将数据写入文件系统的可写流。然后我们多次调用`stream.write()`函数。每次调用`write`函数时，我们传入的数据都被推送到可写流并写入磁盘。
- en: One of the most powerful features in Node.js is the ability to pipe streams.
    Piping a stream simply takes the source and "pipe" it to a destination. You take
    the data output from one stream and pipes it to the input of another stream. This
    is extremely powerful because it allows us to simplify the process of connecting
    streams.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中最强大的功能之一是流的管道功能。管道流简单地将源流“管道”到目标流。您将一个流的数据输出管道到另一个流的输入。这非常强大，因为它允许我们简化连接流的过程。
- en: 'Consider the problem where we must load a file from the disk and send it in
    an HTTP response to a client. We can do this in two ways. The first implementation
    we can build is to load the entire file into memory, then push it all at once
    to the client. This is hugely inefficient for our server. The second is to make
    use of streams. We stream the file from the disk and push the data chunks to the
    request stream. To do this without pipes, we must attach listeners to the read
    stream and catch each data chunk, then push the data chunk to the HTTP response.
    The pseudocode for this is shown in the following snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个问题，我们必须从磁盘加载文件并将其作为HTTP响应发送给客户端。我们可以用两种方式来做这件事。我们可以构建的第一种实现是将整个文件加载到内存中，然后一次性将其推送给客户端。这对我们的服务器来说非常低效。第二种方法是利用流。我们从磁盘流式传输文件，并将数据块推送到请求流中。要做到这一点，我们必须在读取流上附加监听器，并捕获每个数据块，然后将数据块推送到HTTP响应。此伪代码如下所示：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Snippet 6.12: Sending data to HTTP response with a stream'
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.12：使用流将数据发送到HTTP响应
- en: In the pseudocode in the preceding snippet, we created a stream that loads from
    the specified file path. We then add an event handler for the `data` event and
    the `end` event. Every time the data event has data for us, we push that data
    to the `HTTP_Response` stream. Once there is no more data and the end event is
    fired, we close the `HTTP_Response` stream the data is sent to the client. This
    requires several lines of code and requires the developer to manage the data and
    data flow. We can build the exact same functionality with stream piping on a single
    line of code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面片段的伪代码中，我们创建了一个从指定文件路径加载的流。然后为`data`事件和`end`事件添加了事件处理程序。每当数据事件有数据时，我们将该数据推送到`HTTP_Response`流。一旦没有更多数据并且触发了end事件，我们关闭`HTTP_Response`流，数据被发送到客户端。这需要几行代码，并要求开发人员管理数据和数据流。我们可以使用单行代码构建完全相同的功能，使用流管道。
- en: 'Piping streams is done with the `Stream.pipe()` function. Pipe is called on
    the source stream and is passed the destination stream as an argument (for example,
    `readableStream.pipe( writeableStream )`). Pipe returns the destination stream,
    which allows it to be used for chaining pipe commands. Using the same scenario
    as in the preceding example, we can simplify the pseudocode down to one line with
    the pipe command. This is shown in the following snippet:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Stream.pipe()`函数进行流的管道传输。管道是在源流上调用的，并将目标流作为参数传递（例如，`readableStream.pipe(
    writeableStream )`）。管道返回目标流，允许它用于链接管道命令。使用与前面示例相同的场景，我们可以使用管道命令将伪代码简化为一行。如下所示：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Snippet 6.13: Piping data pseudo code'
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.13：管道数据伪代码
- en: In the preceding snippet, we loaded the file data and piped it to the `HTTP_response`.
    Each chunk of data loaded by the readable stream is automatically passed to the
    writeable stream `HTTP_Response`. When the readable stream finishes loading the
    data, it automatically closes and tells the write stream to also close.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们加载了文件数据并将其传输到`HTTP_response`。可读流加载的每个数据块都会自动传递给可写流`HTTP_Response`。当可读流完成加载数据时，它会自动关闭并告诉写流也关闭。
- en: Filesystem Operations
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统操作
- en: 'Node''s filesystem module, named ''`fs`,'' provides an API with which we can
    interact with the filesystem. The filesystem APIs are modeled around the POSIX
    standard. The **POSIX (Portable Operating System Interface)** standard is a standard
    specified by the IEEE Computer Society to help keep general compatibility between
    different operating system filesystems. You do not need to learn the details of
    the standard but understand that the fs modules follow it to maintain cross-platform
    compatibility. To import the filesystem module, we can use the following command:
    `const fs = require( ''fs'' );`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Node的文件系统模块，名为'`fs`'，提供了一个API，我们可以与文件系统交互。文件系统API是围绕POSIX标准建模的。**POSIX（可移植操作系统接口）**标准是由IEEE计算机学会指定的标准，旨在帮助不同操作系统文件系统之间保持一般兼容性。您不需要学习标准的细节，但要了解fs模块遵循它以保持跨平台兼容性。要导入文件系统模块，我们可以使用以下命令：`const
    fs = require( 'fs' );`。
- en: 'Most filesystem functions in Node.js require that you specify a path to the
    file that will be used. When specifying a file path for the fs module, the path
    can be specified in one of three ways: as a **string**, as a **buffer**, or as
    a **URL** object using the `file:` protocol. When the path is a string, the filesystem
    module will attempt to parse the string for a valid file path. If the file path
    is a buffer, the filesystem module will attempt to parse the contents of the buffer
    into a valid file path. If the path is a URL object, the filesystem will convert
    the object into a valid URL string and then attempt to parse the string for a
    valid file path. An example of the three ways to show file paths is shown in the
    following snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中的大多数文件系统函数都要求您指定要使用的文件路径。在为fs模块指定文件路径时，路径可以以三种方式之一指定：作为**字符串**，作为**缓冲区**，或者使用`file:`协议的**URL**对象。当路径是字符串时，文件系统模块将尝试解析字符串以获得有效的文件路径。如果文件路径是缓冲区，文件系统模块将尝试解析缓冲区的内容以获得有效的文件路径。如果路径是URL对象，则文件系统将将对象转换为有效的URL字符串，然后尝试解析字符串以获得有效的文件路径。三种显示文件路径的示例如下所示：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Snippet 6.14: Filesystem path formats'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.14：文件系统路径格式
- en: As you saw in the preceding example, we used the `existsSync` function from
    the `fs` module. In the first line, we pass in a file path as a string. In the
    second line, we create a buffer from the file path string and pass the buffer
    into the `existsSync` function. In the final example, we create a URL object from
    the `file:` protocol URL of the file path and pass the URL object into the `existsSync`
    function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的示例中看到的，我们使用了`fs`模块的`existsSync`函数。在第一行中，我们将文件路径作为字符串传递。在第二行中，我们从文件路径字符串创建了一个缓冲区，并将缓冲区传递给`existsSync`函数。在最后一个示例中，我们从文件路径的`file:`协议URL创建了一个URL对象，并将URL对象传递给`existsSync`函数。
- en: File paths can be parsed as either **relative** or **absolute paths**. An absolute
    path is resolved from the root folder of the operating system. A relative path
    is resolved from the current working directory. The current working directory
    can be obtained with the `process.cwd()` function. Paths specified via a string
    or a buffer can be either relative or absolute. Any path specified with a URL
    object must be the absolute path to the object.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 文件路径可以解析为**相对路径**或**绝对路径**。绝对路径是从操作系统的根文件夹解析的。相对路径是从当前工作目录解析的。当前工作目录可以通过`process.cwd()`函数获得。通过字符串或缓冲区指定的路径可以是相对的或绝对的。使用URL对象指定的路径必须是对象的绝对路径。
- en: The filesystem module brings in many functions that allow us to interact with
    the hard disk. For a large portion of these functions, there are both synchronous
    and asynchronous implementations. The synchronous fs functions are blocking! It
    is very important to remember this when you are writing any code that uses the
    fs module.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统模块引入了许多函数，允许我们与硬盘交互。对于这些函数的大部分，都有同步和异步实现。同步的fs函数是阻塞的！当您编写使用fs模块的任何代码时，记住这一点非常重要。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Remember the definition of blocking operations from *Chapter 2, Asynchronous
    JavaScript*? Blocking operations will prevent any events from being handled by
    the event loop.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得*第2章，异步JavaScript*中对阻塞操作的定义吗？阻塞操作将阻止事件循环处理任何事件。
- en: If you use a synchronous `fs` function to load a large file, it will block the
    event loop. No events will be handled until the synchronous `fs` function has
    finished its work. Nothing else will be done by the Node.js thread, including
    responding to HTTP requests, handling events, or any other asynchronous work.
    You should almost always use the asynchronous versions of the `fs` functions.
    The only instances where you may need to use the synchronous version is when you
    must perform a file system action that must occur before ANY other operation.
    An example of this may be loading files that an entire system or server depends
    on.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用同步的`fs`函数加载大文件，它将阻塞事件循环。在同步的`fs`函数完成工作之前，不会处理任何事件。Node.js线程不会执行任何其他操作，包括响应HTTP请求，处理事件或任何其他异步工作。您几乎总是应该使用`fs`函数的异步版本。唯一需要使用同步版本的情况是在必须在任何其他操作之前执行文件系统操作时。这可能是加载整个系统或服务器依赖的文件的一个例子。
- en: Express Server
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Express服务器
- en: We discussed the basic Node.js HTTP server in an earlier section of this topic.
    The server we created was very basic and lacked a lot of functionality that we
    come to expect from true web servers. In Node.js, one of the most common modules
    for creating minimal and flexible web servers is **Express**. Express takes a
    Node.js server object and wraps it in an API that simplifies functionality. Express
    can be installed through NPM (`npm install express --save`).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本主题的早期部分讨论了基本的Node.js HTTP服务器。我们创建的服务器非常基本，缺乏我们从真正的Web服务器中期望的许多功能。在Node.js中，用于创建最小和灵活的Web服务器的最常见模块之一是**Express**。Express将Node.js服务器对象包装在一个简化功能的API中。Express可以通过NPM（`npm
    install express --save`）安装。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The full documentation for Express can be found at [https://expressjs.com](https://expressjs.com).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Express的完整文档可以在[https://expressjs.com](https://expressjs.com)找到。
- en: 'The basic Express server is very easy to create. Let''s look back at the basic
    Node.js HTTP server that we created earlier in this chapter. In the basic HTTP
    server example, we first created a server with the `HTTP.createServer()` function
    and passed a basic request handler. We then started the server with the `server.listen()`
    function. An Express server is created in a similar manner. Just like with the
    HTTP server, we must first require our modules. Add a `require` statement for
    the `Express` module and create variables to hold our hostname and port number.
    Next, we must create our Express server. This is done simply by calling the function
    that is imported by default from the `require(''express'')` statement. Call the
    imported function and save the result in a variable. This is shown in the following
    snippet:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的Express服务器非常容易创建。让我们回顾一下本章前面创建的基本Node.js HTTP服务器。在基本的HTTP服务器示例中，我们首先使用`HTTP.createServer()`函数创建了一个服务器，并传递了一个基本的请求处理程序。然后使用`server.listen()`函数启动了服务器。Express服务器的创建方式类似。就像HTTP服务器一样，我们首先需要引入我们的模块。为`Express`模块添加一个`require`语句，并创建变量来保存我们的主机名和端口号。接下来，我们必须创建我们的Express服务器。这只需调用默认从`require('express')`语句导入的函数。调用导入的函数并将结果保存在一个变量中。如下面的片段所示：
- en: Note
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code for the simple HTTP server can be found under the code for Exercise 33.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 简单HTTP服务器的代码可以在练习33的代码下找到。
- en: '[PRE14]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Snippet 6.15: Setting up Express server'
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.15：设置Express服务器
- en: In the preceding snippet, we imported the `Express` module and save it to the
    variable `Express`. We then created two constant variables — one to hold the hostname
    and one to hold the port number. In the final line of code, we called the function
    that was imported by the require statement. This creates a basic `Express` server
    with all the default parameters.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们导入了`Express`模块并将其保存到变量`Express`中。然后创建了两个常量变量——一个用于保存主机名，一个用于保存端口号。在代码的最后一行，我们调用了通过require语句导入的函数。这将创建一个带有所有默认参数的基本`Express`服务器。
- en: 'The next step we must do to replicate our basic HTTP server is to add a basic
    HTTP request handler. This can be done with the `app.get()` function. `App.get`
    sets up an HTTP GET request handler for the path provided to it. It takes in two
    parameters— a path and a callback. The path specifies the URL path that the handler
    will catch requests to. `callback` is the function that gets called when the HTTP
    request is handled. We should add a route handler for the root path of the server
    (''`/`''). This is shown in the following snippet:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的下一步是复制我们的基本HTTP服务器，添加一个基本的HTTP请求处理程序。这可以通过`app.get()`函数完成。`App.get`为其提供的路径设置一个HTTP
    GET请求处理程序。它接受两个参数——路径和回调。路径指定处理程序将捕获请求的URL路径。`callback`是处理HTTP请求时调用的函数。我们应该为服务器的根路径（'`/`'）添加一个路由处理程序。如下片段所示：
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Snippet 6.16: Setting up the route handler'
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.16：设置路由处理程序
- en: 'In the preceding snippet of code, we added a route handler with `app.get()`.
    We pass in the root path (''`/`'') so that when the base (''`localhost/`'') path
    is hit with an HTTP request, the specified callback will be called. In our callback,
    we pass in a function that has two parameters: `req` and `res`. Just like with
    the simple HTTP server, `req` represents the incoming HTTP request and `res` represents
    the outgoing HTTP response. In the body of the function, we close the HTTP response
    with the string `Working express server!`. This tells `Express` to use the base
    200 HTTP response code and to send the text as the body of the response.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`app.get()`添加了一个路由处理程序。我们传入根路径（'`/`'），这样当基本路径（'`localhost/`'）被HTTP请求命中时，指定的回调将被调用。在我们的回调中，我们传入一个具有两个参数的函数：`req`和`res`。就像简单的HTTP服务器一样，`req`代表传入的HTTP请求，`res`代表传出的HTTP响应。在函数的主体中，我们使用字符串`Working
    express server!`关闭HTTP响应。这告诉`Express`使用基本的200 HTTP响应代码，并将文本作为响应的主体发送。
- en: 'In the final step, we must take to get our basic `Express` server working is
    to make it listen for HTTP requests. To do this, we can use the `app.listen()`
    function. This function tells the server to begin listening for HTTP requests
    at the specified port. We will pass three parameters into `app.listen()`. The
    first parameter is the **port number**. The second parameter is the **hostname**.
    The third parameter is a **callback function**, which gets called once the server
    begins listening. Call the `listen` function with the correct port, hostname,
    and a callback that prints the URL we can access the server from. An example of
    this is shown in the following snippet:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步，我们必须采取的步骤来使我们的基本`Express`服务器工作是让它监听HTTP请求。为此，我们可以使用`app.listen()`函数。此函数告诉服务器开始在指定端口监听HTTP请求。我们将三个参数传递给`app.listen()`。第一个参数是**端口号**。第二个参数是**主机名**。第三个参数是一个**回调函数**，一旦服务器开始监听，就会被调用。使用正确的端口、主机名和一个打印我们可以访问服务器的URL的回调来调用`listen`函数。以下是一个示例：
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Snippet 6.17: Making the Express server listen for incoming requests'
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.17：使Express服务器监听传入请求
- en: In the preceding snippet, we called the `listen` function. We pass in the port
    number, which resolves to `8000`; the hostname, which resolves to '`127.0.0.1`';
    and a `callback` function that logs the server URL. Once the server begins listening
    to HTTP requests at port `8000` on the local network, the `callback` function
    is called. Go to the URL logged to the console to see your basic server in action!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们调用了`listen`函数。我们传入端口号，解析为`8000`；主机名，解析为`127.0.0.1`；和一个`callback`函数，记录服务器URL。一旦服务器开始在本地网络上的端口`8000`监听HTTP请求，就会调用`callback`函数。转到控制台上记录的URL，看看你的基本服务器是如何工作的！
- en: 'Exercise 34: Creating a Basic Express Server'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习34：创建一个基本的Express服务器
- en: 'To build a basic Express server, perform the following steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个基本的Express服务器，请执行以下步骤：
- en: Import the `express` module.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`express`模块。
- en: Set up the variables for the hostname and port and give them the values `127.0.0.1`
    and `8000,` respectively.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置主机名和端口的变量，并分别给它们赋值`127.0.0.1`和`8000`。
- en: Create the server app by calling `express()` and save it to the `app` variable.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`express()`创建服务器应用程序，并将其保存到`app`变量中。
- en: Add a get request handler to the base route `/`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基本路由`/`上添加一个get请求处理程序。
- en: Provide the `callback` function that takes in `req` and `res`, and closes the
    response with the text `Working express server!.`
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个接受`req`和`res`的`callback`函数，并使用文本`Working express server!`关闭响应。
- en: Make the server listen on the specified port and host with `app.listen()`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使服务器在指定的端口和主机上侦听`app.listen()`。
- en: Provide a callback to `app.listen()` that logs `Server running at ${server uri}`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个回调函数给`app.listen()`，记录`Server running at ${server uri}`。
- en: Start the server and load the specified URL in your browser.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器并在浏览器中加载指定的URL。
- en: '**Code**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: index.js
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: index.js
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Snippet 6.18: Simple Express server'
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.18：简单的Express服务器
- en: https://bit.ly/2Qz4Z93
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2Qz4Z93
- en: '**Outcome**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '![Figure 6.6: Returning the new cart array'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6：返回新的购物车数组'
- en: '](image/Figure_6.6.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.6.jpg)'
- en: 'Figure 6.6: Returning the new cart array'
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.6：返回新的购物车数组
- en: '![Figure 6.7: Returning the new cart array'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7：返回新的购物车数组'
- en: '](image/Figure_6.7.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.7.jpg)'
- en: 'Figure 6.7: Returning the new cart array'
  id: totrans-219
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.7：返回新的购物车数组
- en: You have successfully built a basic Express server.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功构建了一个基本的Express服务器。
- en: Routing
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由
- en: 'One of Express'' most powerful features is its flexible routing. **Routing**
    refers to how a web server''s endpoint URIs respond to client requests. When a
    client makes a request to a web server, it requests a specified endpoint (URI
    or path) with a specified HTTP method (`GET`, `POST`, and so on). A web server
    must explicitly handle the paths and methods that it will accept, along with callback
    functions that state how to handle the request. In Express, this can be done with
    the following line of code: `app.METHOD( PATH, HANDLER );`. The `app` variable
    is the instance of the Express server. Method is the HTTP method that the handler
    is being set up for. The method should be in lowercase. The path is the URI path
    on the server that the handler will respond to. The handler is the callback function
    that will be executed if the path and method match the request. An example of
    this functionality is shown in the following snippet:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Express最强大的功能之一是其灵活的路由。**路由**指的是Web服务器的端点URI如何响应客户端请求。当客户端向Web服务器发出请求时，它请求指定的端点（URI或路径）以及指定的HTTP方法（`GET`，`POST`等）。Web服务器必须明确处理它将接受的路径和方法，以及说明如何处理请求的回调函数。在Express中，可以使用以下代码行来实现：`app.METHOD(
    PATH, HANDLER );`。`app`变量是Express服务器的实例。Method是要为其设置处理程序的HTTP方法。方法应为小写。路径是服务器上的URI路径，处理程序将对其进行响应。处理程序是如果路径和方法匹配请求将执行的回调函数。以下是此功能的示例：
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Snippet 6.19: Examples of Express routing'
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.19：Express路由示例
- en: In the preceding snippet, we set up three route handlers for our Express server.
    The first is set up with the `.get()` function. This means that the server will
    look for `GET` requests to the specified route. We pass in the base route for
    our server (`/`). When the base route is hit with a `GET` request, the provided
    callback function will be called. In our callback function, we respond with the
    string `GET request at /`. In the second line of code, we set up our server to
    respond to `POST` requests at the path `/user`. When a `POST` request hits our
    Express server, we call the provided callback which closes the response with the
    string `POST request at /user.` In the final line of code, we set up a handler
    for `DELETE` requests. When a `DELETE` request comes into the URI `/cart/item,`
    we respond with the provided callback.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述片段中，我们为Express服务器设置了三个路由处理程序。第一个是使用`.get()`函数设置的。这意味着服务器将寻找对指定路由的`GET`请求。我们传入了服务器的基本路由（`/`）。当基本路由收到`GET`请求时，将调用提供的回调函数。在我们的回调函数中，我们用字符串`GET
    request at /`进行响应。在第二行代码中，我们设置服务器响应路径`/user`的`POST`请求。当`POST`请求到达Express服务器时，我们调用提供的回调函数，关闭响应并返回字符串`POST
    request at /user.`在最后一行代码中，我们为`DELETE`请求设置了处理程序。当`DELETE`请求进入URI`/cart/item`时，我们用提供的回调进行响应。
- en: Express also supports the special function `app.all()`. If you have worked with
    HTTP requests a lot, you will recognize that ALL is not a valid HTTP method. `app.all()`
    is a special handler function that tells Express to respond to all valid HTTP
    request methods to the specified URI with the specified callback. It was added
    to Express to help reduce duplicated code if a route was intended to accept any
    request method.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Express还支持特殊函数`app.all()`。如果您经常使用HTTP请求，您会意识到`ALL`不是有效的HTTP方法。`app.all()`是一个特殊的处理程序函数，告诉Express响应指定URI的所有有效HTTP请求方法，并使用指定的回调。它被添加到Express中，以帮助减少重复的代码，如果一个路由打算接受任何请求方法。
- en: 'Express supports having more than one callback function for a request URI and
    HTTP method. To do this, we must add a third parameter to the callback function:
    `next`. `next` is a function, and when `next` is called, Express will move to
    the next callback handler that matches the method and URI. An example of this
    is shown in the following snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Express支持为请求URI和HTTP方法设置多个回调函数。为了实现这一点，我们必须向回调函数添加第三个参数：`next`。`next`是一个函数，当调用`next`时，Express将移动到匹配方法和URI的下一个回调处理程序。以下是一个示例：
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Snippet 6.20: Multiple request handlers for the same route'
  id: totrans-229
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.20：相同路由的多个请求处理程序
- en: In the preceding snippet, we set up two different route handlers and `GET` requests
    to the base URI. When a `GET` request to the base route is caught, the first handler
    will be called. This handler only calls the `next()` function, which tells Express
    to look for the next matching handler. Express sees that there is a second matching
    handler and calls the second handler function, which closes the HTTP response.
    It is important to note that HTTP responses can only be closed and set back to
    the client one time. If you set up multiple handlers for a URI server and HTTP
    method, you must ensure that only one of the handlers closes the HTTP request,
    otherwise an error will occur. The functionality provided with multiple handlers
    is critical for middleware and error handling in Express. These applications will
    be discussed in more detail later in this section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述片段中，我们为基本URI设置了两个不同的路由处理程序和`GET`请求。当捕获到对基本路由的`GET`请求时，将调用第一个处理程序。此处理程序仅调用`next()`函数，告诉Express寻找下一个匹配的处理程序。Express看到有第二个匹配的处理程序，并调用第二个处理程序函数，关闭HTTP响应。重要的是要注意，HTTP响应只能关闭并一次返回给客户端。如果为URI服务器和HTTP方法设置了多个处理程序，必须确保只有一个处理程序关闭HTTP请求，否则将会出现错误。多个处理程序提供的功能对于Express中的中间件和错误处理非常重要。这些应用程序将在本节后面更详细地讨论。
- en: Advanced Routing
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级路由
- en: As explained earlier, in Express, route paths are the path URIs that it matches,
    along with an HTTP method, when checking which handler callbacks to call. Route
    paths are passed into functions, such as `app.get()`, as the first parameter.
    Express's power comes from the ability to create extremely dynamic route paths
    that match multiple URIs. In Express, a route path can be a string, string pattern,
    or regular expression. Express will parse string-based routes for the special
    characters `?`, `+`, `*`, `()`, `$`, `[`, and `]`. When used in string paths,
    the special characters `?`, `+`, `*`, and `()` are subsets of the regular expression
    counterparts. The `[` and `]` characters are used to escape parts of a URL. They
    are not interpreted literally in the string. The `$` character is a reserved character
    in the Express path parsing module. If you must use the `$` character in a path
    string, you must escape it with the `[ and ]`. For example, `/user/$22515` should
    be written in the Express route handler as `/data/[\$]22515`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在Express中，路由路径是它匹配的路径URI，以及HTTP方法，在检查要调用哪个处理程序回调时。路由路径作为第一个参数传递给函数，例如`app.get()`。Express的强大之处在于能够创建极其动态的路由路径，以匹配多个URI。在Express中，路由路径可以是字符串、字符串模式或正则表达式。Express将解析基于字符串的路由，以查找特殊字符`?`，`+`，`*`，`()`，`$`，`[`和`]`。在字符串路径中使用时，特殊字符`?`，`+`，`*`和`()`是正则表达式对应字符的子集。`[`和`]`字符用于转义URL的部分，在字符串中不会被字面解释。`$`字符是Express路径解析模块中的保留字符。如果必须在路径字符串中使用`$`字符，则必须使用`[`和`]`进行转义。例如，`/user/$22515`应该在Express路由处理程序中写成`/data/[\$]22515`。
- en: 'If we wish to incorporate special characters in our routes to add flexibility
    we can use the characters `?`, `+`, `*`, and `()`. These characters operate the
    same way as their regular expression counterparts. This means that the `?` character
    is used to symbolize optional characters. Any character or character group followed
    by the `?` symbol will be considered optional and Express will match URIs that
    either match the full string literally with the optional character(s) or match
    the full string literally without the optional character(s). This is shown in
    the following snippet:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`字符的功能类似于`+`字符，但匹配零个或多个字符的重复。Express将匹配与字符串完全匹配但不包含额外字符的路由。一个或多个连续字符可以用来代替星号。示例如下：'
- en: '[PRE20]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Snippet 6.21: Optional characters in the route path'
  id: totrans-235
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.23：使用零个或多个字符进行路由
- en: In the preceding snippet, we set up a `GET` handler for the URL path '`/abc?de`.'
    When this URL is hit, the callback is called, which logs the two possible URI
    match options. Since the `?` character follows the `c` character, the `c` character
    is considered optional. Express will match both `GET` requests to the URI that
    contains or does not contain the optional character. Requests to both `/abde`
    and `/abcde` will match.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们为URL路径`/abc?de`设置了一个`GET`处理程序。当命中此URL时，将调用回调函数，该函数记录两个可能的URI匹配选项。由于`?`字符跟在`c`字符后面，因此`c`字符被视为可选的。Express将匹配包含或不包含可选字符的URI的`GET`请求。对`/abde`和`/abcde`的请求都将匹配。
- en: 'The `+` symbol is used to indicate zero or more repetitions of the character
    or character group it follows. Express will match a route that matches literally
    with the string with zero of the repeated character, and any string that contains
    one or more sequential repetitions of the marked character. An example of this
    is shown in the following snippet:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`符号用于指示字符或字符组的零个或多个重复。Express将匹配与重复字符的字符串完全匹配的路由，以及包含一个或多个标记字符的连续重复的任何字符串。示例如下：'
- en: '[PRE21]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Snippet 6.22: Routing with zero or more repeated characters'
  id: totrans-239
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.22：路由路径中零个或多个重复字符
- en: In the preceding snippet, we set up a `GET` handler for the URL path `fo+d`.
    When this URI is hit, the callback is called, which logs some of the matching
    options. Since the o character is followed by the `+` character, Express will
    parse any route with zero or more `o`'s in it. Express will match `fd`, `fod`,
    `food`, `foooooooooooood`, and any other string URI with consecutive `o`'s.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们为URL路径`fo+d`设置了一个`GET`处理程序。当命中此URI时，将调用回调函数，该函数记录一些匹配选项。由于o字符后面跟着`+`字符，Express将解析任何包含零个或多个`o`的路由。Express将匹配`fd`，`fod`，`food`，`foooooooooooood`和任何其他具有连续`o`的字符串URI。
- en: 'The `*` character functions similar to the `+` character, but matches zero
    or more repetitions of any character. Express will match routes that match literally
    with the string without the extra characters. One or more consecutive characters
    of any type are used in place of the asterisk. An example of this is shown in
    the following snippet:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 片段6.21：路由路径中的可选字符
- en: '[PRE22]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Snippet 6.23: Routing with zero or more characters'
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 如果我们希望在路由中使用特殊字符以增加灵活性，我们可以使用字符`?`，`+`，`*`和`()`。这些字符的操作方式与它们的正则表达式对应字符相同。这意味着`?`字符用于表示可选字符。跟在`?`符号后面的任何字符或字符组都将被视为可选的，Express将匹配要么与可选字符的完整字符串匹配，要么与不包含可选字符的完整字符串匹配。示例如下：
- en: In the preceding snippet, we set up a `GET` handler for the URL path `'fo*d`.'
    When this URI is hit, the callback is called, which logs some of the matching
    options. Since the `o` character is followed by the `*` character, Express will
    parse any route with zero or more additional characters in it. Express will match
    `fd`, `fod`, `fad`, `foood`, `faeioud`, and any other string URI with consecutive
    characters in place of the `*`. Notice the difference between the matching strings
    when comparing the `+` and `*` characters. The `*` character will match all of
    the strings that the `+` character matches, with the addition of strings with
    any valid character in place of the asterisk.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们为URL路径`fo*d`设置了一个`GET`处理程序。当命中此URI时，将调用回调函数，该函数记录一些匹配选项。由于`o`字符后面跟着`*`字符，Express将解析任何包含零个或多个额外字符的路由。Express将匹配`fd`，`fod`，`fad`，`foood`，`faeioud`和任何其他具有连续字符的字符串URI。在比较`+`和`*`字符的匹配字符串时，请注意匹配字符串之间的差异。`*`字符将匹配`+`字符匹配的所有字符串，还会匹配任何有效字符代替星号的字符串。
- en: 'The final set of characters is the `()`. The parentheses groups a set of characters
    together. Grouped characters are treated as single units when used in conjunction
    with the other special characters `(?, +, or *)`. For example, the URI `/ab(cd)?ef`
    will match the URIs `/abef` and `/abcdef`. The characters `cd` are grouped together,
    and the entire group is subject to the `?` character. An example of this interaction
    with each of the special characters is shown in the following snippet:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一组字符是`()`。括号将一组字符分组在一起。当与其他特殊字符（`?`，`+`或`*`）一起使用时，分组字符将被视为单个单位。例如，URI`/ab(cd)?ef`将匹配URI`/abef`和`/abcdef`。字符`cd`被分组在一起，并且整个组受到`?`字符的影响。示例显示了这种与每个特殊字符的交互在以下片段中：
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Snippet 6.24: Routing with character groups'
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.24：使用字符组进行路由
- en: In the preceding snippet, we set up `GET` request handlers for the paths `b(es)?t`,
    `b(es)+t`, `b(es)*t`. Each handler calls a callback that logs some of the match
    options. In the all of the handlers, the characters `es` are grouped together.
    In the first handler, the grouped characters are subject to the `?` character
    and are considered optional. The handler will match URIs that contain the full
    string and do only contain the non-optional characters. The two options are `bt`
    and `best`. In the second handler, the character group is subject to the `+` character.
    URIs with zero or more consecutive repetitions of the character group will match.
    The match options are `bt`, `best,` `besest`, `besesest`, and any other string
    with more consecutive repetitions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们为路径`b(es)?t`，`b(es)+t`，`b(es)*t`设置了`GET`请求处理程序。每个处理程序调用一个回调函数，记录一些匹配选项。在所有处理程序中，字符`es`被分组在一起。在第一个处理程序中，分组字符受到`?`字符的影响，并被视为可选的。处理程序将匹配包含完整字符串并且只包含非可选字符的URI。两个选项是`bt`和`best`。在第二个处理程序中，字符组受到`+`字符的影响。具有零个或多个连续重复字符组的URI将匹配。匹配选项是`bt`，`best`，`besest`，`besesest`，以及任何其他具有更多连续重复的字符串。
- en: 'Express also allows us to set up route parameters in the route strings. Route
    parameters are named route sections, and allow us to specify sections of the route
    URL to capture and save into variables. The captured sections of the URL are saved
    into the `req.params` object under the key name that matches the name of the capture.
    URL params are specified with the : character, followed by the capture name. Whatever
    string falls in that part of the route is captured and saved. An example of this
    is shown in the following snippet:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Express还允许我们在路由字符串中设置路由参数。路由参数是命名路由部分，允许我们指定要捕获并保存到变量中的路由URL的部分。URL的捕获部分保存在`req.params`对象中，对象的键名与捕获的名称匹配。URL参数使用`:`字符指定，后跟捕获名称。任何落在路由的那部分字符串都将被捕获并保存。示例显示在以下片段中：
- en: '[PRE24]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Snippet 6.25: Routing with URL params'
  id: totrans-251
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.25：使用URL参数进行路由
- en: 'In the preceding snippet, we set up a get parameter for the route `/amazon/audible/:userId/books/:bookId`.
    This route has two named parameter captures: one for `userId` and one for `bookId`.
    The two named captures can contain any set of valid URL characters. Whatever characters
    are contained between `audible/` and `/books` will be saved into the `req.params.userId`
    variable and whatever characters are after `books/` will be saved into `req.params.bookId`.
    It is important to note that the `/` character is what is used to split sections
    of the URL. The capture groups saved will not contain the `/` character because
    Express parses it as a URL separator.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们为路由`/amazon/audible/:userId/books/:bookId`设置了一个get参数。这个路由有两个命名参数捕获：一个是`userId`，另一个是`bookId`。这两个命名捕获可以包含任何一组有效的URL字符。在`audible/`和`/books`之间包含的任何字符都将保存在`req.params.userId`变量中，而在`books/`之后的任何字符都将保存在`req.params.bookId`中。重要的是要注意，`/`字符是用来分割URL的。保存的捕获组将不包含`/`字符，因为Express将其解析为URL分隔符。
- en: 'Express routes can also use regular expressions in place of a path strings.
    If a regular expression is passed into the first argument of a request handler
    instead of a string, Express will parse the regular expression and any string
    that matches the regular expression will fire the provided callback handler. If
    you are unfamiliar with regular expressions, you can find many tutorials online
    that teach the basics. An example of regular expression paths is shown in the
    following snippet:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Express路由还可以在路径字符串的位置使用正则表达式。如果将正则表达式传递给请求处理程序的第一个参数而不是字符串，Express将解析正则表达式，并且与正则表达式匹配的任何字符串都将触发提供的回调处理程序。如果您对正则表达式不熟悉，可以在网上找到许多教授基础知识的教程。正则表达式路径的示例显示在以下片段中：
- en: '[PRE25]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Snippet 6.26: Routing with regular expressions'
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.26：使用正则表达式进行路由
- en: In the preceding snippet, we set up a `GET` handler for the regular expression
    route `/^web.*/`. If this handler is matched, the server will log two examples
    of strings that match. The regular expression that we provided to the `GET` handler
    specifies that the URI must start with the string `web` and may be followed by
    any number of characters. This will match URIs such as `/web`, `/website`, and
    `/webmail`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们为正则表达式路由`/^web.*/`设置了一个`GET`处理程序。如果匹配此处理程序，服务器将记录两个匹配的字符串示例。我们提供给`GET`处理程序的正则表达式指定了URI必须以字符串`web`开头，可以跟随任意数量的字符。这将匹配诸如`/web`，`/website`和`/webmail`等URI。
- en: Middleware
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间件
- en: 'Express also expands on server flexibility with a feature called middleware.
    Express is a routing and middleware framework that has little functionality on
    its own. **Middleware** are functions that have access to the HTTP requests request
    and response objects and run somewhere in the middle of the handling sequence.
    Middleware can perform one of four tasks: execute code, make changes to request
    and response objects, end the HTTP request-response sequence, and call the next
    middleware that applies to the request.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Express还通过一个名为中间件的功能扩展了服务器的灵活性。Express是一个路由和中间件框架，本身功能有限。**中间件**是具有对HTTP请求请求和响应对象的访问权限并在处理序列的中间某处运行的函数。中间件可以执行四项任务中的一项：执行代码，对请求和响应对象进行更改，结束HTTP请求-响应序列，并调用适用于请求的下一个中间件。
- en: Note
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Middleware functions can be manually written, or they can be downloaded through
    third-party NPM modules. Before writing a middleware, check that the middleware
    does not already exist. Official middleware modules and some select popular modules
    can be found at [https://expressjs.com/en/resources/middleware.html](https://expressjs.com/en/resources/middleware.html).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件函数可以手动编写，也可以通过第三方NPM模块下载。在编写中间件之前，请检查中间件是否已经存在。官方中间件模块和一些热门模块可以在[https://expressjs.com/en/resources/middleware.html](https://expressjs.com/en/resources/middleware.html)找到。
- en: 'Middleware functions have three input variables: `req`, `res`, and `next`.
    `Req` represents the request object, `res` represents the response object, and
    `next` is a function that tells Express to continue to the next middleware handler.
    We saw the `next` function earlier in this section when registering multiple route
    handlers to one URI. The `next` function tells the middleware handlers to pass
    control to the next middleware in the handler stack. In simpler terms, it tells
    the `nex`t middleware to run. If a middleware does not end the request-response
    sequence, it must call the `next` function. If it does not, the request will hang
    and eventually time out. Middleware can be attached with the functions `app.use()`
    and `app.METHOD()`, where method is the lowercase HTTP method the middleware is
    being attached to. A middleware set up with `app.use()` will fire for all HTTP
    methods that match the specified optional path. Middleware attached with an HTTP
    method function will fire for all requests that match the method and specified
    path. An example of middleware is shown in the following snippet:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件函数有三个输入变量：`req`，`res`和`next`。`Req`表示请求对象，`res`表示响应对象，`next`是一个告诉Express继续到下一个中间件处理程序的函数。我们在本节的前面看到了`next`函数，当将多个路由处理程序注册到一个URI时。`next`函数告诉中间件处理程序将控制权传递给处理程序堆栈中的下一个中间件。简单来说，它告诉`next`中间件运行。如果中间件没有结束请求-响应序列，它必须调用`next`函数。如果不这样做，请求将挂起并最终超时。中间件可以使用`app.use()`和`app.METHOD()`函数附加。使用`app.use()`设置的中间件将对匹配指定可选路径的所有HTTP方法触发。使用HTTP方法函数附加的中间件将对匹配方法和指定路径的所有请求触发。下面的片段显示了中间件的示例：
- en: '[PRE26]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Snippet 6.27: Setting up middleware'
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.27：设置中间件
- en: In the preceding snippet, we set up a middleware function using `app.use()`.
    We do not provide a path to `app.use(),` so all requests will trigger the middleware.
    The middleware updates the request object by setting the `currentTime` field in
    the request to a new date object. The middleware then calls the next function,
    which passes control to the next middleware or route handler. Assuming a request
    to the base URI, the next handler that gets hit is the registered handler, which
    prints the value held in `req.currentTime`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们使用`app.use()`设置了一个中间件函数。我们没有为`app.use()`提供路径，因此所有请求都将触发中间件。中间件通过在请求中设置`currentTime`字段为一个新的日期对象来更新请求对象。然后中间件调用下一个函数，该函数将控制权传递给下一个中间件或路由处理程序。假设请求到基本URI，下一个被触发的处理程序是注册的处理程序，它打印`req.currentTime`中保存的值。
- en: Error Handling
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误处理
- en: The final important aspect of Express is error handling. **Error handling**
    is the process through which Express handles and manages errors. Express can handle
    synchronous errors and asynchronous errors. Express has built-in error handling,
    so you do not need to write your own. Express's built-in error handler will return
    the error to the client in the response body. This may include error details such
    as the stack trace. If you want the user to see a custom error message or page,
    then you must attach your own error handler.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Express的最后一个重要方面是错误处理。**错误处理**是Express处理和管理错误的过程。Express可以处理同步错误和异步错误。Express具有内置的错误处理，因此您不需要编写自己的错误处理程序。Express的内置错误处理程序将在响应正文中将错误返回给客户端。这可能包括错误详细信息，如堆栈跟踪。如果您希望用户看到自定义错误消息或页面，则必须附加自己的错误处理程序。
- en: 'The built-in Express error handler will catch any error thrown in synchronous
    code in a route handler or middleware function. This includes runtime errors and
    errors thrown with the throw keyword. Express will not, however, catch errors
    thrown in asynchronous functions. To invoke errors in asynchronous functions,
    you must add the `next` function to the callback handler. If an error occurs,
    you must call next with the error you want to handle. An examples of synchronous
    and asynchronous error handling with the default error handler are shown in the
    following snippet:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的Express错误处理程序将捕获路由处理程序或中间件函数中同步代码中抛出的任何错误。这包括运行时错误和使用throw关键字抛出的错误。但是，Express不会捕获在异步函数中抛出的错误。要在异步函数中调用错误，必须将`next`函数添加到回调处理程序中。如果发生错误，必须使用要处理的错误调用next。下面的片段显示了使用默认错误处理程序进行同步和异步错误处理的示例：
- en: '[PRE27]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Snippet 6.28: Synchronous and asynchronous error handling'
  id: totrans-269
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.28：同步和异步错误处理
- en: In the preceding snippet, we first created a `GET` request handler to the path
    `/synchronousError`. If this handler is hit, we call the callback function, which
    throws an error in a block of synchronous code. Since the error is thrown in a
    synchronous code block of code, Express automatically catches the error and passes
    it to the client. In the second example, we create a `GET` request handler for
    the path `/asynchronousError`. When this handler is hit, we call a callback function
    that begins a timeout and calls the `next` function with an error. The error occurs
    in an asynchronous block of code, so it must be passed to Express through the
    next function. When Express catches an error, either synchronously through thrown
    events or asynchronously through the next function, it immediately skips all applicable
    middleware and route handlers in the stack and jumps to the first applicable error
    handler.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们首先创建了一个`GET`请求处理程序，路径为`/synchronousError`。如果触发了这个处理程序，我们调用回调函数，在同步代码块中抛出一个错误。由于错误是在同步代码块中抛出的，Express会自动捕获错误并将其传递给客户端。在第二个示例中，我们为路径`/asynchronousError`创建了一个`GET`请求处理程序。当触发了这个处理程序时，我们调用一个回调函数，开始一个超时，并使用错误调用`next`函数。错误发生在一个异步代码块中，因此必须通过next函数传递给Express。当Express捕获到错误时，无论是通过抛出事件同步地还是通过next函数异步地，它会立即跳过所有适用的中间件和路由处理程序，并跳转到第一个适用的错误处理程序。
- en: 'To define our own error handler middleware function, we add it in the same
    way as other middleware functions, except with one key difference. Error handler
    middleware callback functions have four arguments in the callback instead of three.
    The arguments, in order, are `err`, `req`, `res`, and `next`. They are explained
    as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 定义我们自己的错误处理中间件函数，我们以与其他中间件函数相同的方式添加它，只是有一个关键的区别。错误处理中间件回调函数在回调中有四个参数，而不是三个。参数依次是`err`、`req`、`res`和`next`。它们的解释如下：
- en: '`err` represents the error that is being handled.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`err`代表正在处理的错误。'
- en: '`req` represents the request object.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req`代表请求对象。'
- en: '`res` represents the response object.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res`代表响应对象。'
- en: '`next` is a function that tells Express to move on to the next error handler.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`是一个告诉Express继续下一个错误处理程序的函数。'
- en: 'Custom error handlers should be the last defined middleware. An example of
    custom error handling is shown in the following snippet:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义错误处理程序应该是最后定义的中间件。下面是自定义错误处理的示例：
- en: '[PRE28]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Snippet 6.29: Adding a custom error handler'
  id: totrans-278
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.29：添加自定义错误处理程序
- en: In the preceding snippet, we added a `GET` request handler for the base route.
    When the handler is hit, it calls a callback function, which throws an error.
    This error is automatically caught by Express and passed to the next error handler.
    The next error handler is the one we defined with the `app.use()` function. This
    error handler catches the error and then responds to the client with an error
    message.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们为基本路由添加了一个`GET`请求处理程序。当处理程序被触发时，它调用一个回调函数，该函数抛出一个错误。这个错误会被Express自动捕获并传递给下一个错误处理程序。下一个错误处理程序是我们用`app.use()`函数定义的。这个错误处理程序捕获错误，然后用错误消息响应客户端。
- en: 'Exercise 35: Building a Backend with Node.js'
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习35：使用Node.js构建后端
- en: You have been tasked with building a Node.js Express server for a note taking
    application. The server should serve a basic HTML page (provided in the activity
    folder under `index.html`) to the base route (`/`). The server will need to have
    an API route to load a saved note from a text file in the server's local filesystem
    and an API route to save changes to the note to the text file on the server's
    local filesystem. The server should accept a `GET` request to the URI `/load`
    when loading the note and accept a `POST` request to the URI `/save` when saving
    the note. The provided HTML file will assume that these are the API paths used
    on the server. When building the server, you may want to use the body-parser middleware
    with the strict option set to false to simplify the handling of requests.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求为一个笔记应用构建一个Node.js Express服务器。服务器应该为基本路由（`/`）提供一个基本的HTML页面（在活动文件夹下的`index.html`中提供）。服务器将需要一个API路由，从服务器的本地文件系统中的文本文件加载保存的笔记，并且一个API路由，将对笔记的更改保存到服务器的本地文件系统中的文本文件。服务器应该在加载笔记时接受一个`GET`请求到URI`/load`，在保存笔记时接受一个`POST`请求到URI`/save`。提供的HTML文件将假定这些是服务器上使用的API路径。在构建服务器时，您可能希望使用`body-parser`中间件，并将strict选项设置为false，以简化请求的处理。
- en: 'To build a working Node.js server that serves an HTML file and accepts API
    calls, perform the following steps:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个工作的Node.js服务器，提供一个HTML文件并接受API调用，执行以下步骤：
- en: Set up the project with `npm init`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm init`设置项目。
- en: Install `express` and `body-parser` with npm.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用npm安装`express`和`body-parser`。
- en: Import the modules `express`, `http`, and `body-parser` saved as `bodyParser`,
    and `fs`, and save them in variables.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入模块`express`、`http`和`body-parser`保存为`bodyParser`，以及`fs`，并将它们保存在变量中。
- en: Create a variable called `notePath` that contains the path to the text file
    (`./note.txt`).
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`notePath`的变量，其中包含文本文件的路径（`./note.txt`）。
- en: Log that we are creating a server.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录我们正在创建一个服务器。
- en: Create the server app with `express()` and save it in the `app` variable.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`express()`创建服务器应用，并将其保存在`app`变量中。
- en: Create an HTTP server from the Express app with `http.createServer(app)` and
    save it in the server variable.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`http.createServer(app)`从Express应用创建一个HTTP服务器，并将其保存在server变量中。
- en: Log that we are configuring the server.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录我们正在配置服务器。
- en: Use the `body-parser` middleware to parse JSON request bodies.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`body-parser`中间件来解析JSON请求体。
- en: Tell the Express app to use the middleware with `app.use()`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉Express应用使用中间件`app.use()`。
- en: Pass in `bodyParser.json()` to the use function.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 将`bodyParser.json()`传递给use函数。
- en: Pass an options object into `bodyParser.json()` with the `key/value pair. strict:false`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个选项对象传递给`bodyParser.json()`，使用`key/value`对。strict:false。
- en: Create a router to handle the routing with `express.Router()` and save it to
    the variable router.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`express.Router()`创建一个路由来处理路由，并将其保存在变量router中。
- en: Add a get route handler for the base route with `router.route('/').get`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为基本路由添加一个`GET`路由处理程序，使用`router.route('/').get`。
- en: Add a callback function that takes in `req` and `res`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个接受`req`和`res`的回调函数。
- en: In the callback`,` send the `index.html` file with `res.sendFile()`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调中，使用`res.sendFile()`发送`index.html`文件。
- en: 'Pass in `index.html` for the first parameter and the options object {`root:
    __dirname` } for the second parameter.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '将`index.html`作为第一个参数传递，并将选项对象`{`root: __dirname`}`作为第二个参数传递。'
- en: Add a route for the `/save` route that accepts a `POST` request with `router.route(
    '/save' ).post`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`/save`路由添加一个路由，接受`POST`请求`router.route( '/save' ).post`。
- en: The route handler callback should take in the parameters `req` and `res`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 路由处理程序回调应该接受参数`req`和`res`。
- en: In the callback, call the `fs` function `writeFile()` with the `notePath` and
    `req.body` parameters and a `callback` function.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调中，使用`fs`函数`writeFile()`和`notePath`以及`req.body`参数和回调函数。
- en: In the callback function, take in the arguments `err` and `data`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数中，接受参数`err`和`data`。
- en: If an `err` is provided, close the response with the status code `500` and the
    error in JSON form.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了`err`，则使用状态码`500`和JSON形式的错误关闭响应。
- en: If no error is provided, close the response with the `200` status code and the
    JSON of the data object.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供错误，则使用数据对象的JSON关闭响应，并使用`200`状态码。
- en: Add a route for the `/load` route that accepts a get request with `router.route(
    '/load ).get`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`/load`路由添加一个路由，接受`GET`请求`router.route( '/load ).get`。
- en: The route handler callback should take in the parameters `req` and `res`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 路由处理程序回调应该接受参数`req`和`res`。
- en: In the callback, call the `fs` function `readFile` with the `notePath` and `utf8`
    parameters, and a callback function.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调中，使用`fs`函数`readFile`和`notePath`以及`utf8`参数和回调函数。
- en: In the callback function, take in the arguments `err` and `data`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数中，接受参数`err`和`data`。
- en: If an `err` is provided, close the response with the status code `500` and the
    error in JSON form.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了`err`，则使用状态码`500`和JSON形式的错误关闭响应。
- en: If no error is provided, close the response with the `200` status code and the
    JSON of the data object.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供错误，则使用数据对象的JSON关闭响应，并使用`200`状态码。
- en: Make the `express` app use the router to handle requests at the base route with
    `app.use('/', router)`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使`express`应用程序使用路由器处理基本路由的请求`app.use('/', router)`。
- en: Set the server up to listen on the correct port and hostname and pass in a callback
    using `server.listen( port, hostname, callback )`.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置服务器以侦听正确的端口和主机名，并使用`server.listen( port, hostname, callback )`传入回调。
- en: The callback should take in an error parameter. If an error is found, throw
    that error.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数应该接受一个错误参数。如果找到错误，抛出该错误。
- en: Otherwise, log the port that the server is listening on.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，记录服务器正在侦听的端口。
- en: Start the server and load the URL that is running at `(localhost:PORT)`.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器并加载运行在`(localhost:PORT)`的URL。
- en: Test the server's routing and functionality by saving a note, refreshing the
    web page, loading the saved note (should match what was saved before), then updating
    the note.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过保存一个笔记，刷新网页，加载保存的笔记（应该与之前保存的内容匹配），然后更新笔记来测试服务器的路由和功能。
- en: '**Code**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: index.js
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: index.js
- en: '[PRE29]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Snippet 6.30: Express server routing for complicated application'
  id: totrans-321
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.30：复杂应用的Express服务器路由
- en: https://bit.ly/2C4FR64
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2C4FR64
- en: '**Outcome**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '![Figure 6.8: Listening on port 8000'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8：监听端口8000'
- en: '](image/Figure_6.8.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.8.jpg)'
- en: 'Figure 6.8: Listening on port 8000'
  id: totrans-326
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.8：监听端口8000
- en: '![Figure 6.9: Loading the test note'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9：加载测试笔记'
- en: '](image/Figure_6.9.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.9.jpg)'
- en: 'Figure 6.9: Loading the test note'
  id: totrans-329
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.9：加载测试笔记
- en: You have successfully built a working Node.js server that serves an HTML file
    and accepts API calls.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功构建了一个工作的Node.js服务器，可以提供HTML文件并接受API调用。
- en: React
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React
- en: '**React** is a JavaScript library for building user interfaces. React is maintained
    primarily by FaceBook. React was first created by Jordal Walke, a Facebook software
    engineer, and open sourced in 2013\. React is designed to simplify web development
    and allow developers to build single-page web sites and mobile applications with ease.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**React**是一个用于构建用户界面的JavaScript库。React主要由FaceBook维护。React最初是由Facebook软件工程师Jordal
    Walke创建的，并于2013年开源。React旨在简化Web开发，使开发人员能够轻松构建单页网站和移动应用程序。'
- en: Note
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'React''s full documentation, along with extended tutorials, can be found at
    their home page: [https://reactjs.org/](https://reactjs.org/).'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: React的完整文档以及扩展教程可以在它们的主页找到：[https://reactjs.org/](https://reactjs.org/)。
- en: React uses a declarative approach for designing a view to improve the predictability
    and debugging of pages. The developer can declare and design simple views for
    each state in the application. React will handle the updating and rendering of
    the views as states change. React relies on a component-based model. The developer
    builds encapsulated components that track and handle their own internal states.
    We can combine our components to make complex user interfaces, similar to how
    we use function composition to build complex functions from simple functions.
    With components, we can pass rich data types from component to component, through
    our application. This is allowed because component logic is written purely in
    JavaScript. Finally, React allows us to be very flexible in our transition into
    the framework. No assumptions are made about the technology stack behind the application.
    React can be compiled on load in the browser, on a Node.js server, or into a mobile
    app with React Native. This allows React to be slowly incorporated into new features
    without requiring existing code to be refactored. You can begin to incorporate
    React at any point in the technology stack.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: React使用声明性方法来设计视图，以提高页面的可预测性和调试性。开发人员可以为应用程序中的每个状态声明和设计简单的视图。React将处理视图的更新和渲染，随着状态的改变。React依赖于基于组件的模型。开发人员构建封装的组件，跟踪和处理它们自己的内部状态。我们可以组合我们的组件以创建复杂的用户界面，类似于我们如何使用函数组合从简单函数构建复杂函数。通过组件，我们可以通过应用程序在组件之间传递丰富的数据类型。这是允许的，因为组件逻辑纯粹是用JavaScript编写的。最后，React允许我们在框架中非常灵活。不会对应用程序背后的技术栈做出任何假设。React可以在浏览器中加载时编译，在Node.js服务器上编译，或者使用React
    Native编译成移动应用程序。这使得可以在不需要重构现有代码的情况下逐步将React纳入新功能。您可以在技术栈的任何点开始纳入React。
- en: Installing React
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装React
- en: React can be installed through NPM and compiled on the server or integrated
    into an application through script tags. There are several ways to install React
    and add it to a project.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: React可以通过NPM安装，并在服务器上编译，或通过脚本标签集成到应用程序中。有几种安装React并将其添加到项目中的方法。
- en: 'The quickest way to add React to your application is to include the built-in
    libraries through a `<script>` tag. This method is generally the easiest if you
    have an existing project and you want to slowly start incorporating React into
    it. Adding React in this way takes less than a minute and can prepare you to begin
    adding components immediately. First, we need to add a DOM container to our HTML
    page where we want our React components to attach. This is generally a div with
    a unique ID. We then add the **React** and `ReactDOM` modules with script tags.
    Once the script tags have been added, we can load our React components with a
    script tag. An example of this is shown in the following snippet:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 将React添加到应用程序的最快方法是通过`<script>`标签包含内置库。如果您有现有项目并希望逐步开始将React纳入其中，这种方法通常是最简单的。以这种方式添加React不到一分钟，可以让您立即开始添加组件。首先，我们需要在HTML页面中添加一个DOM容器，我们希望我们的React组件附加到其中。通常这是一个带有唯一ID的div。然后使用脚本标签添加**React**和`ReactDOM`模块。添加了脚本标签后，可以使用脚本标签加载React组件。以下是一个示例。
- en: '[PRE30]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Snippet 6.31: Adding React to a web page'
  id: totrans-340
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码段6.31：将React添加到网页
- en: The next simplest way to set up a React app and install React into a new project
    is with the React app creator. This module is a Node.js command-line interface
    that automatically sets up a React project with a simple predefined folder structure
    and the basic dependencies installed. The CLI tool can be installed with the command-line
    command `npm install create-react-app -g`. This command tells NPM to install the
    CLI module in the global scope so that it can be run from the command line. Once
    the CLI has been installed, you can create a new React project by running the
    `create-react-app my-app-name` command. The CLI tool will create a folder in the
    working directory with the name provided (`my-app-name` from the example command),
    install the React dependencies, and create two folders for your application's
    resources. The CLI tool will populate the source code folder, named `src`, with
    an example app. You can start the app with the `npm start` command. From this
    point, you can begin hacking and modifying the files to see how React works, or
    you can delete all the files in `src` and begin writing your own application.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 设置React应用程序并将React安装到新项目中的下一个最简单的方法是使用React应用程序创建者。这个模块是一个Node.js命令行界面，可以自动设置一个具有简单预定义文件夹结构和基本依赖项安装的React项目。可以使用命令行命令`npm
    install create-react-app -g`安装CLI工具。这个命令告诉NPM在全局范围内安装CLI模块，以便可以从命令行运行它。安装了CLI后，可以通过运行`create-react-app
    my-app-name`命令创建一个新的React项目。CLI工具将在工作目录中创建一个文件夹，名称为提供的名称（例如命令中的`my-app-name`），安装React依赖项，并为应用程序资源创建两个文件夹。CLI工具将使用示例应用程序填充源代码文件夹，命名为`src`。可以使用`npm
    start`命令启动应用程序。从这一点开始，可以开始修改文件，看看React是如何工作的，或者可以删除`src`中的所有文件，开始编写自己的应用程序。
- en: The most difficult way to install React is to install the individual dependencies
    one at a time. This method provides the most flexibility and allows you to integrate
    React into your existing toolchain. To install React, you must install the modules
    `react` and `react-dom` with NPM. Both modules can be installed in the local project
    scope and should be saved to the `package.json` dependency list with the `--save`
    or `-s` flag. Once the modules are installed, React components can be created
    and built with your existing toolchain.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 安装React最困难的方法是逐个安装各个依赖项。这种方法提供了最大的灵活性，允许您将React集成到现有的工具链中。要安装React，必须使用NPM安装`react`和`react-dom`模块。这两个模块可以在本地项目范围内安装，并应该使用`--save`或`-s`标志保存到`package.json`依赖项列表中。安装了模块后，可以使用现有的工具链创建和构建React组件。
- en: In this topic, we will use React with JSX. **JSX** is a JavaScript syntactic
    sugar and is not supported by default in browsers. JSX must be transpiled into
    valid JavaScript code with Babel. To finalize the setup of React, you will need
    to set up Babel to transpile your React and JSX code into JavaScript. If Babel
    has not been installed for your project, you can install it with the `npm install
    babel -s` command.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本主题中，我们将使用带有JSX的React。**JSX**是JavaScript的一种语法糖，默认情况下不受浏览器支持。JSX必须通过Babel转译为有效的JavaScript代码。要完成React的设置，您需要设置Babel来将您的React和JSX代码转译为JavaScript。如果您的项目尚未安装Babel，可以使用`npm
    install babel -s`命令进行安装。
- en: 'This will save Babel as a dependency for your project. To add the React JSX
    plugin to Babel, run the `npm install babel-preset-react-app -s` command. This
    command adds the JSX transpiling libraries for Babel. After babel has been set
    up, we must create a build script that we can run to transpile all of our code.
    In package.json, add the following line: `build": "npx babel src -d lib --presets
    react-app/prod`. Note that `npx` is not a typo. It is a package runner tool that
    comes with NPM. This line tells Babel to compile code from the `src` directory
    to the `lib` directory with the `react-app/prod` preset. This command should be
    run each time we make changes to our React code and want to reflect this in the
    front-end. You are now ready to start building a React application.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '这将保存Babel作为项目的依赖项。要将React JSX插件添加到Babel中，请运行`npm install babel-preset-react-app
    -s`命令。此命令添加了Babel的JSX转换库。设置好Babel后，我们必须创建一个构建脚本，可以运行以转换我们所有的代码。在package.json中，添加以下行：`build":
    "npx babel src -d lib --presets react-app/prod`。请注意，`npx`不是拼写错误。它是一个随NPM一起提供的包运行工具。这行告诉Babel将代码从`src`目录编译到`lib`目录，并使用`react-app/prod`预设。每次我们对React代码进行更改并希望在前端反映这些更改时，都应该运行此命令。现在，您已经准备好开始构建React应用程序了。'
- en: Note
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You can provide the Babel setup commands stated in the previous paragraph to
    demonstrate how to set the project up for transpilation.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提供上一段中所述的Babel设置命令，以演示如何为转译设置项目。
- en: React Basics
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React基础
- en: 'React is built around small encapsulated pieces of code called components.
    Components in React are defined by subclassing `React.Component` or `React.PureComponent`.
    The most common method is to use `React.Component`. In the simplest form, a React
    component takes in properties (commonly called `props`) and returns the view to
    display via a call to `render()`. Properties are defined when the components are
    initialized. Each component that''s created must have a method called `render()`
    defined in the subclass. The render function returns a description of what will
    be rendered on the screen in JSX form. An example component declaration is shown
    in the following snippet:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: React是围绕称为组件的小型封装代码构建的。在React中，组件是通过对`React.Component`或`React.PureComponent`进行子类化来定义的。最常见的方法是使用`React.Component`。在最简单的形式中，React组件接受属性（通常称为`props`）并通过调用`render()`返回要显示的视图。在初始化组件时定义属性。每个创建的组件必须在子类中定义一个名为`render()`的方法。render函数以JSX形式返回屏幕上将呈现的内容的描述。以下是一个示例组件声明：
- en: '[PRE31]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Snippet 6.32: Basic React element'
  id: totrans-350
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.32：基本的React元素
- en: In the preceding snippet, we have defined a new React component `class` called
    `HelloWorld`. This new class extend the basic `React.Component`. Inside the declaration,
    we define the `render()` function. The `render()` function returns a block of
    JSX that defines what will be rendered on the screen. In this block of JSX, we
    create a `div` with the text `Hello World!!! Made by *!!!`, where the `*` character
    is replaced with the value passed in through the by property. In the final few
    lines, we call the `ReactDom.render()` function. This tells the `ReactDom` module
    to render all of the components and views we have passed into the `render()` function.
    In the preceding snippet, we passed our `HelloWorld` component with the property
    `by` set to `Zach`, and we tell the render function to attach the rendered DOM
    to the root element. The data that's passed into the property is passed into `this.props`
    inside our component and filled into the `Hello World!!! div`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们定义了一个名为`HelloWorld`的新的React组件`class`。这个新类扩展了基本的`React.Component`。在声明内部，我们定义了`render()`函数。`render()`函数返回一个JSX块，定义了将在屏幕上呈现的内容。在这个JSX块中，我们创建了一个带有文本`Hello
    World!!! Made by *!!!`的`div`，其中`*`字符被通过属性传递的值替换。在最后几行中，我们调用了`ReactDom.render()`函数。这告诉`ReactDom`模块呈现我们传递给`render()`函数的所有组件和视图。在前面的片段中，我们将我们的`HelloWorld`组件与属性`by`设置为`Zach`，并告诉渲染函数将呈现的DOM附加到根元素上。传递到属性中的数据被传递到我们的组件内部的`this.props`中，并填充到`Hello
    World!!! div`中。
- en: Note
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If your code base does not use ES6 or ES6 classes, you can use the create-react-class
    module, however, the specifics of this module are outside the scope of this book.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码库不使用ES6或ES6类，您可以使用create-react-class模块，但是，此模块的具体细节超出了本书的范围。
- en: Congratulations! You have learned about the most basic form of React. By expanding
    on this one example, you can now build basic static web pages. This may not seem
    very useful, but it is the most basic building block of all web development.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经了解了React的最基本形式。通过扩展这个例子，您现在可以构建基本的静态网页。这可能看起来并不是很有用，但它是所有网页开发的最基本构建块。
- en: React Specifics
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React特定
- en: 'From our very basic example in the preceding snippet, we can see that React
    uses an odd syntactic sugar called JSX. JSX is neither HTML nor JavaScript. It
    is a syntax extension for JavaScript that incorporates some concepts from HTML
    and XML to help describe what a user interface should look like. JSX is not necessary
    for a React app, however it is recommended that you use it when building a React
    UI. It looks like a template language but comes with the full power of JavaScript.
    It can be compiled into standard JavaScript with the Babel React plugin. An example
    of JSX and the equivalent JavaScript is shown in the following snippet:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的片段中的基本示例中，我们可以看到React使用了一种奇怪的语法糖叫做JSX。JSX既不是HTML也不是JavaScript。它是JavaScript的语法扩展，结合了HTML和XML的一些概念，帮助描述用户界面应该是什么样子。JSX对于React应用并非必需，但建议在构建React
    UI时使用它。它看起来像一个模板语言，但具有JavaScript的全部功能。它可以通过Babel React插件编译成标准的JavaScript。以下片段显示了JSX和等效的JavaScript示例：
- en: '[PRE32]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Snippet 6.33: JSX vs JS'
  id: totrans-358
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.33：JSX vs JS
- en: In the preceding snippet, we defined a variable called `elementJSX` and saved
    a JSX element into it. In the second line, we created a variable called `elementJS`
    and saved the equivalent element into it with pure JavaScript. In this example,
    you can clearly see how the markdown style of JSX simplifies the approach to defining
    an element in JavaScript.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们定义了一个名为`elementJSX`的变量，并将一个JSX元素保存到其中。在第二行，我们创建了一个名为`elementJS`的变量，并用纯JavaScript保存了等效的元素。在这个示例中，你可以清楚地看到JSX的标记风格如何简化了在JavaScript中定义元素的方法。
- en: JSX
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSX
- en: '**JSX** can have expressions embedded into it much like template literals in
    standard JavaScript. The main difference, however, is that JSX uses just curly
    braces (`{}`) to define an expression. Much like template literals, the expressions
    used in JSX can be variables, object references, or function calls. This allows
    us to use JSX to create dynamic elements in React. An example of JSX expressions
    is shown in the following snippet:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSX**可以像标准JavaScript中的模板文字一样嵌入表达式。然而，主要区别在于JSX只使用花括号（`{}`）来定义表达式。与模板文字一样，在JSX中使用的表达式可以是变量、对象引用或函数调用。这使我们能够在React中使用JSX创建动态元素。以下片段显示了JSX表达式的示例：'
- en: '[PRE33]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Snippet 6.34: JSX expressions'
  id: totrans-363
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.34：JSX表达式
- en: In the preceding snippet, we first created a variable called name that contains
    the string `David` and a function called `multiplyBy2` that takes in a number
    and returns the number multiplied by `2`. We then create a variable called `element1`
    and save a JSX element into it. This JSX element contains a `div` that contains
    an expression that references the `name` variable. When this JSX element is built,
    the expression evaluates the `name` variable to the string `David` and inserts
    that into the final markup. In the final line of code, we create a variable called
    `element2` and save another JSX element into it. This JSX element contains a div
    with an expression that references the `multiplyBy2` function. When the JSX element
    is created, the expression evaluates the code inside it and calls the function.
    The function return value is put into the final markup. As you can see, expressions
    in JSX work much like expressions in template literals.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们首先创建了一个名为name的变量，其中包含字符串`David`，以及一个名为`multiplyBy2`的函数，该函数接受一个数字并返回乘以`2`的数字。然后我们创建了一个名为`element1`的变量，并将一个JSX元素保存到其中。这个JSX元素包含一个包含对`name`变量的引用的表达式的`div`。当构建这个JSX元素时，表达式将`name`变量评估为字符串`David`并将其插入到最终的标记中。在代码的最后一行，我们创建了一个名为`element2`的变量，并将另一个JSX元素保存到其中。这个JSX元素包含一个包含对`multiplyBy2`函数的表达式的div。当创建JSX元素时，表达式将评估其中的代码并调用函数。函数的返回值被放入最终的标记中。正如你所看到的，JSX中的表达式与模板文字中的表达式非常相似。
- en: ReactDOM
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ReactDOM
- en: When we create React elements, we must have some way to render them into the
    DOM. This was touched on very briefly in the React introduction example. In that
    example, we used the `ReactDOM` library to render the component we created. The
    `ReactDOM` object, which was imported from the `react-dom` module, provides DOM
    specific methods that can be used through your app; however, most components do
    need these methods. The function you will use most is the `render()` function.
    This function takes in three parameters.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建React元素时，我们必须有一种方法将它们渲染到DOM中。这在React介绍示例中被非常简要地提及了。在那个示例中，我们使用了`ReactDOM`库来渲染我们创建的组件。从`react-dom`模块导入的`ReactDOM`对象提供了可以在整个应用程序中使用的特定于DOM的方法；然而，大多数组件并不需要这些方法。你将最常使用的函数是`render()`函数。这个函数接受三个参数。
- en: 'The first parameter is the React element that we will rendering, or attaching,
    to the DOM. The second parameter is the container or DOM node that the React component
    will be rendered into. The final parameter is an optional callback method. The
    callback function will be executed after the component is rendered. For full React
    apps, `ReactDOM.render()` is usually only needed at the top level of the application,
    and is used to render the entire app in the view. In applications where React
    is being slowly incorporated into an existing code base, `ReactDOM.render()` may
    be used at each new point where a React component is being incorporated into non-React
    code. An example of `ReactDOM.render()` is shown in the following snippet:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们将要渲染或附加到DOM的React元素。第二个参数是React组件将被渲染到的容器或DOM节点。最后一个参数是一个可选的回调方法。回调函数将在组件渲染后执行。对于完整的React应用程序，`ReactDOM.render()`通常只需要在应用程序的顶层使用，并用于在视图中渲染整个应用程序。在将React逐渐纳入现有代码库的应用程序中，`ReactDOM.render()`可能在每个新的React组件被纳入非React代码的地方使用。以下片段显示了`ReactDOM.render()`的示例：
- en: '[PRE34]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Snippet 6.35: Rendering elements into the DOM'
  id: totrans-369
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.35：将元素渲染到DOM中
- en: In the preceding example, we first imported the `ReactDOM` module. We then created
    a new React element with JSX. This simple element contains only a `div` with the
    text `HELLO WORLD!!!` inside it. We then called the `ReactDOM.render()` function
    with all three arguments. This function call is telling the browser to select
    the root DOM node and attach the markup rendered by our React element. When the
    rendering completes, the provided callback is called and the `Done rendering`
    string is logged to the console.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们首先导入了`ReactDOM`模块。然后我们使用JSX创建了一个新的React元素。这个简单的元素只包含一个带有文本`HELLO WORLD!!!`的`div`。然后我们调用了`ReactDOM.render()`函数并传入了所有三个参数。这个函数调用告诉浏览器选择根DOM节点并附加我们的React元素渲染的标记。当渲染完成时，将调用提供的回调，并将`Done
    rendering`字符串记录到控制台中。
- en: React.Component
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React.Component
- en: 'React revolves around components. As we learned earlier, the simplest way to
    create a new component is by creating a new subclass that extends the `React.Component`
    class. The `React.Component` class can be accessed through the React object that''s
    imported from the React NPM module. When we define a React component we must,
    at the very least, define a `render()` function. The `render` function returns
    the JSX description of what the component will contain. If we wish to make more
    complex components, such as components with states, we can add a constructor to
    our component. The constructor must take in the `props` variable and it must call
    the `super()` function with the `props` variable. The `props` variable will contain
    an object with the properties assigned when creating the React component. An example
    of a React component with a constructor is shown in the following snippet:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: React围绕组件展开。正如我们之前学到的，创建新组件的最简单方法是创建一个扩展`React.Component`类的新子类。`React.Component`类可以通过从React
    NPM模块导入的React对象访问。当我们定义一个React组件时，我们必须至少定义一个`render()`函数。`render`函数返回组件将包含的JSX描述。如果我们希望创建更复杂的组件，例如具有状态的组件，我们可以向组件添加构造函数。构造函数必须接受`props`变量，并且必须使用`props`变量调用`super()`函数。`props`变量将包含在创建React组件时分配的属性的对象。以下是一个具有构造函数的React组件的示例：
- en: '[PRE35]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Snippet 6.36: React class constructor'
  id: totrans-374
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.36：React类构造函数
- en: In the preceding snippet, we created a new component called `ConstructorExample`.
    In the same snippet, we call the `constructor` function. The `constructor` function
    takes in one parameter, which is the object that contains the properties. In the
    constructor, we call the `super()` function and pass in the `props` variable.
    We then create a `class` variable called `variable` and assign the value `test`.
    At the end of the class, as required for all React components, we add a `render()`
    function that returns the JSX markup for the component.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，我们创建了一个名为`ConstructorExample`的新组件。在同一个片段中，我们调用了`constructor`函数。`constructor`函数接受一个参数，即包含属性的对象。在构造函数中，我们调用了`super()`函数并传入`props`变量。然后我们创建了一个名为`variable`的`class`变量，并赋予了值`test`。在类的末尾，作为所有React组件所需的，我们添加了一个返回组件的JSX标记的`render()`函数。
- en: State
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态
- en: To add a local state to a React component, we simply initialize the variable
    state, in the this scope, inside the constructor (`this.state = {}`;). The state
    variable is a special variable keyword name in React. Any changes to `this.state`
    will cause the `render()` function be called. This allows us to have the view
    dynamically change, depending on the current state of the component.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 要向React组件添加本地状态，我们只需在构造函数内部（`this.state = {}`）初始化状态变量。状态变量是React中的一个特殊变量关键字名称。对`this.state`的任何更改都将导致调用`render()`函数。这使我们能够根据组件的当前状态动态更改视图。
- en: 'It is important to know three key things about the state variable. First, you
    should never modify the state directly with a statement such as `this.state.value
    = ''value''`. Modifying the state in this way will not result in a call to `render()`
    and a view update. Instead, you must use the `setState()` function. This will
    update the state with the data passed into the function. For example, we must
    set the state like so: `this.setState( { name: ''Zach'' } )`. The second key detail
    is that state updates may be asynchronous. React may batch multiple `setState`
    calls into a single update to boost performance. Because of this fact, and because
    `this.props` and `this.state` can be changed asynchronously, we cannot rely on
    their values for calculating a state. If we must use the current state or current
    value of a property to calculate the next state, we can use a second form of `setState`
    that accepts a function instead of an object. The function will receive the previous
    state as the first argument and the properties object at the time the state update
    was applied as the second argument. This reliably allows us to use the previous
    state and property information for calculating the next state. Finally, state
    updates are merged instead of overwritten. Much like the `Object.assign` function,
    `setState` does a shallow merge of the state object and the new state. When setting
    a state, the new object will be merged with into old state object. Only the properties
    specified in the new state object will change. All of the properties in the old
    state object that are not in the new state object will be left untouched.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '关于状态变量，有三个关键要知道的事情。首先，您不应该直接修改状态，比如`this.state.value = ''value''`。以这种方式修改状态不会导致调用`render()`和视图更新。相反，您必须使用`setState()`函数。这将使用传递给函数的数据更新状态。例如，我们必须这样设置状态：`this.setState(
    { name: ''Zach'' } )`。第二个关键细节是状态更新可能是异步的。React可能会将多个`setState`调用合并为单个更新以提高性能。因此，我们不能依赖它们的值来计算状态。如果我们必须使用当前状态或属性的当前值来计算下一个状态，我们可以使用`setState`的第二种形式，它接受一个函数而不是一个对象。该函数将接收前一个状态作为第一个参数，并在应用状态更新时接收属性对象。这可靠地允许我们使用先前的状态和属性信息来计算下一个状态。最后，状态更新是合并而不是覆盖。与`Object.assign`函数类似，`setState`对状态对象和新状态进行浅合并。在设置状态时，新对象将与旧状态对象合并。只有新状态对象中指定的属性将更改。旧状态对象中的所有属性，如果不在新状态对象中，将保持不变。'
- en: 'In React components, the property object is read-only from inside the component.
    This means that changes to the properties object from inside component will not
    be reflected to any variable inside the parent component or DOM structure. Data
    only flows downward. Consequently, any change to the parent component''s JSX markup
    for the child component''s properties will cause the child to re-render with the
    new property values. To get data to flow in an upward direction, we must pass
    in functions from the parent component to the child component in the form of properties.
    An example of this is shown in the following snippet:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在React组件中，属性对象从组件内部是只读的。这意味着从组件内部对属性对象的更改不会反映到父组件或DOM结构中的任何变量。数据只能向下流动。因此，对子组件属性的父组件JSX标记的任何更改都将导致子组件使用新的属性值重新渲染。要使数据向上流动，我们必须以属性的形式将函数从父组件传递到子组件。以下片段显示了一个示例。
- en: '[PRE36]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Snippet 6.37: Rendering a child component'
  id: totrans-381
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.37：渲染子组件
- en: In this snippet, we created two components. The first one is called `ChildElement`
    and the second is called `ParentElement`. `ChildElement` simply contains JSX for
    a button that, when clicked, calls the function that's passed in through the `onClick`
    property. `ParentElement` contains a function called clicked that logs to the
    console and, when rendered, returns JSX with a `ChildElement` instance. The `ChildElement`
    that's created in the JSX of `ParentElement` has the property `onClick` set to
    the `clicked()` function of `ParentElement`. When the button in `ChildElement`
    is clicked, the `clicked()` function gets called. In this example, bind the parent
    scope to this.clicked when we pass it into the child element (`this.clicked.bind(this)`).
    If `this.clicked` needs to access anything in the parent component, we must bind
    it's scope to the scope of the parent component. In your React applications, you
    can use this functionality to create upward data flow.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们创建了两个组件。第一个称为`ChildElement`，第二个称为`ParentElement`。`ChildElement`简单地包含了一个按钮的JSX，当点击时，通过`onClick`属性传递的函数被调用。`ParentElement`包含一个名为`clicked`的函数，用于记录到控制台，并在渲染时返回带有`ChildElement`实例的JSX。在`ParentElement`的JSX中创建的`ChildElement`将`onClick`属性设置为`ParentElement`的`clicked()`函数。当点击`ChildElement`中的按钮时，将调用`clicked()`函数。在这个例子中，当我们将它传递给子元素时，将父级范围绑定到`this.clicked`（`this.clicked.bind(this)`）。如果`this.clicked`需要访问父组件中的任何内容，我们必须将其范围绑定到父组件的范围。在您的React应用程序中，您可以使用此功能创建向上的数据流。
- en: 'Handling DOM events in React is very similar to HTML DOM element event handling,
    with a few main differences. First, in React, event names are using `camelcase`
    instead of lowercase. This means that at each "new word" in the name, the first
    letter of that word is upper case. For example, the DOM event `onclick` becomes
    `onClick` in React. Second, in JSX, function event handlers are passed into the
    handler definition directly as the function, instead of as a string containing
    the handler function name. An example of the differences between standard HTML
    and React are shown in the following code:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中处理DOM事件与HTML DOM元素事件处理非常相似，但有一些主要区别。首先，在React中，事件名称使用`驼峰命名法`而不是小写。这意味着在名称的每个“新单词”中，该单词的第一个字母是大写的。例如，在React中，DOM事件`onclick`变成了`onClick`。其次，在JSX中，函数事件处理程序直接作为函数传递到处理程序定义中，而不是作为包含处理程序函数名称的字符串。以下代码显示了标准HTML和React之间的差异：
- en: '[PRE37]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Snippet 6.38: JSX versus HTML events'
  id: totrans-385
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.38：JSX与HTML事件
- en: In the preceding snippet, we created two buttons. The first is in HTML and has
    an `onclick` listener attached to it that calls the `doSomething` function. The
    second button is in JSX format and also has an `onclick` listener that calls the
    `doSomething` function. Note the difference in how the listeners are defined.
    The JSX event name is in `camelcase` and the HTML event name is in lower case.
    In JSX, we set the handler function via an expression, which evaluates to the
    function. In HTML, we set the event handler to a string that calls the function.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们创建了两个按钮。第一个是HTML格式的，它附加了一个`onclick`侦听器，调用`doSomething`函数。第二个按钮是JSX格式的，也有一个`onclick`侦听器，调用`doSomething`函数。请注意侦听器定义的不同之处。JSX事件名称是`camelcase`，HTML事件名称是小写。在JSX中，我们通过表达式设置处理程序函数，该表达式求值为函数。在HTML中，我们将事件处理程序设置为调用函数的字符串。
- en: Note
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We learned in *Chapter 3, DOM Manipulation and Event Handling*, that it is a
    bad practice to attach events directly in the DOM. JSX is not HTML and this practice
    is acceptable because JSX prevents injection attacks by escaping any values embedded
    in JSX.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第3章，DOM操作和事件处理*中学到，直接在DOM中附加事件是一种不好的做法。JSX不是HTML，这种做法是可以接受的，因为JSX通过转义JSX中嵌入的任何值来防止注入攻击。
- en: Another significant difference between React event handling and standard DOM
    event handling is that, in React, the event handler function cannot return false
    to prevent the default behavior. You must explicitly call the `preventDefault()`
    function on the event object.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: React事件处理和标准DOM事件处理之间的另一个重要区别是，在React中，事件处理程序函数不能返回false以阻止默认行为。您必须在事件对象上明确调用`preventDefault()`函数。
- en: When attaching event listeners in React, we must be careful with the `this`
    scope. In JavaScript, class methods are not bound to the `this` scope by default.
    If the functions are passed somewhere else and called from somewhere else, the
    `this` scope may not be properly set. You should be sure to bind the `this` scope
    correctly when attaching them to listeners or passing methods around as properties.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中附加事件侦听器时，我们必须小心处理`this`作用域。在JavaScript中，类方法默认情况下不绑定到`this`作用域。如果函数被传递到其他地方并从其他地方调用，则`this`作用域可能无法正确设置。在将它们附加到侦听器或作为属性传递方法时，应确保正确绑定`this`作用域。
- en: Conditional Rendering
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件渲染
- en: In React, we create distinct components to encapsulate the views or behaviors
    we need. We need a way to only render some of the components we have created,
    based on the state of the application. In React, this is referred to as **Conditional
    Rendering**. In React, conditional rendering works the same way as JavaScript
    conditional statements. We can use JavaScript's if or the conditional operator
    to decide what elements to render. This can be done in several ways.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，我们创建不同的组件来封装我们需要的视图或行为。我们需要一种方式，根据应用程序的状态，只渲染我们创建的一些组件。在React中，这称为**条件渲染**。在React中，条件渲染的工作方式与JavaScript条件语句相同。我们可以使用JavaScript的if或条件运算符来决定渲染哪些元素。这可以通过几种方式来实现。
- en: 'Out of two simple ways, one is to have a function that returns a React element
    (JSX) based on the current state, while the second is have a conditional statement
    in JSX that returns a React element based on the current state. An example of
    these forms of conditional rendering are shown in the following snippet:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种简单的方式中，一种是根据当前状态返回一个React元素（JSX）的函数，而另一种是在JSX中有一个条件语句，根据当前状态返回一个React元素。这些条件渲染形式的示例显示在以下片段中：
- en: '[PRE38]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Snippet 6.39: Conditional rendering'
  id: totrans-395
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.39：条件渲染
- en: In the preceding snippet, we created an element called `AccountControl`. In
    the constructor, we set the local state to an object that contains account information
    that's passed in from the property variable. The render function simply returns
    a `div` with two expressions. Both expressions take advantage of conditional rendering
    to display information based off of the current state. The first expression calls
    the `isLoggedIn` function, which checks `this.state.account` and returns either
    a `LogoutButton` or a `LoginButton,` depending on the current state. The second
    expression uses the conditional operator to check `this.state.account` inline
    and returns either a `LogoutButton` or a `LoginButton` depending on the local
    state.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们创建了一个名为`AccountControl`的元素。在构造函数中，我们将本地状态设置为包含从属性变量传入的帐户信息的对象。渲染函数简单地返回一个带有两个表达式的`div`。这两个表达式都利用条件渲染来根据当前状态显示信息。第一个表达式调用`isLoggedIn`函数，该函数检查`this.state.account`并根据当前状态返回`LogoutButton`或`LoginButton`。第二个表达式使用条件运算符来内联检查`this.state.account`，并根据本地状态返回`LogoutButton`或`LoginButton`。
- en: List of Items
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目列表
- en: 'Rendering lists of items in React is extremely simple. It is based on the concepts
    of JSX and expressions. As we learned earlier, JSX uses expressions to create
    dynamic code. If an expression evaluates to an array of components, all the components
    will be rendered as if they were added inline in JSX. We can build a collection,
    or array, of components, save the collection in a variable, and include the variable
    in a JSX expression. An example of this is shown in the following snippet:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中渲染项目列表非常简单。它基于JSX和表达式的概念。正如我们之前学到的，JSX使用表达式来创建动态代码。如果表达式求值为组件数组，则所有组件将被呈现为如果它们被内联添加到JSX中。我们可以构建一个组件的集合或数组，将集合保存在一个变量中，并将变量包含在JSX表达式中。这种示例显示在以下片段中：
- en: '[PRE39]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Snippet 6.40: Rendering lists'
  id: totrans-400
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.40：渲染列表
- en: In the preceding snippet, we created an element called `ListElement`. This element
    simply takes in an array of items and maps the array to an array of JSX elements
    that contains the array item value in a `<li>` tag. The resulting array of list
    items is then returned into a `<ul>` tag. When JSX compiles this into HTML each
    item in the array is inserted, in order, into the `<ul>` element.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们创建了一个名为`ListElement`的元素。这个元素简单地接受一个项目数组，并将数组映射到包含`<li>`标签中的数组项值的JSX元素数组中。然后将结果列表项数组返回到`<ul>`标签中。当JSX将其编译成HTML时，数组中的每个项目按顺序插入到`<ul>`元素中。
- en: HTML Forms
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML表单
- en: The final key concept of React that we must discuss is HTML forms. HTML forms
    work differently in React than other DOM elements because HTML forms track their
    own internal state. If we only need to handle the default behavior of a form,
    then we can use them off the shelf with React and have no issues. However, we
    run into a complication when we want to have a JavaScript handle the form submission
    and have access to all of the data in the form. This issue arises because both
    the element and React component try to track the state of the form at the same
    time.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: React的最后一个关键概念是HTML表单。HTML表单在React中的工作方式与其他DOM元素不同，因为HTML表单跟踪其自己的内部状态。如果我们只需要处理表单的默认行为，那么我们可以在React中直接使用它们，并且不会出现任何问题。然而，当我们希望让JavaScript处理表单提交并访问表单中的所有数据时，我们会遇到一个复杂的问题。这个问题是因为元素和React组件同时尝试跟踪表单的状态。
- en: 'The way to achieve this is with controlled components. The goal of controlled
    components is to remove state control from the form element and make React the
    controlling component. This is done by adding a React event listener for a field''s
    value change event (`onChange`) and having React set its internal `state` variable
    value equal to the form''s value. Then, React sets the value of the field equal
    to the value that''s saved in the `state` variable. React reads any changes from
    the `input` field and forces the `input` field to adopt any changes that happen
    to the data stored in the React component. An example of this is shown in the
    following snippet:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的方法是使用受控组件。受控组件的目标是从表单元素中删除状态控制，并使React成为控制组件。这是通过为字段的值更改事件（`onChange`）添加一个React事件监听器，并让React将其内部`state`变量值设置为表单的值来实现的。然后，React将字段的值设置为保存在`state`变量中的值。React读取`input`字段中的任何更改，并强制`input`字段采用发生在React组件中存储的数据的任何更改。以下片段中显示了这一点的示例：
- en: '[PRE40]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Snippet 6.41: React component states'
  id: totrans-406
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段6.41：React组件状态
- en: In the preceding snippet, we created a component called `ControlledInput`. This
    component has a state variable called value that will store the value of the text
    input. We create a function called `handleChange` that simply updates the components
    state by setting a value equal to the value of the read from the event. In the
    render function, we create a div that contains an `input` field and another `div`.
    This input field has its value mapped to `this.state.value` and an event listener
    that calls the `handleChange` function. The second `div` simply mirrors the value
    of `this.state.value`. When we make a change inside of the text input, the `onChange`
    listener gets called and the components `state.value` gets set to the current
    value of the input field. Whenever `this.state.value` gets changed, that changes
    gets reflected back to the `input` field. The component's value for `this.state.value`
    is absolute and the `input` field is forced to mirror it.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们创建了一个名为`ControlledInput`的组件。该组件有一个名为value的状态变量，用于存储文本输入的值。我们创建了一个名为`handleChange`的函数，简单地通过将值设置为从事件中读取的值来更新组件的状态。在渲染函数中，我们创建一个包含一个`input`字段和另一个`div`的div。这个输入字段的值映射到`this.state.value`，并且有一个调用`handleChange`函数的事件监听器。第二个`div`简单地镜像了`this.state.value`的值。当我们在文本输入框内进行更改时，`onChange`监听器被调用，组件的`state.value`被设置为输入字段的当前值。每当`this.state.value`被更改时，这种变化都会反映到`input`字段上。组件的`this.state.value`的值是绝对的，`input`字段被强制镜像它。
- en: 'Activity 6: Building a Frontend with React'
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动6：使用React构建前端
- en: The front-end team working on your note taking app from *Exercise 32* has unexpectedly
    quit. You must build the frontend for this application using React. Your frontend
    should have two views, a Home view and an Edit view. Create a `R``eact` component
    for each view. The `home` view should have a button that changes the view to the
    `edit` view. The `edit` view should have a button that switches back to the `home`
    view, a text input that contains the `Note Text`, a **Load** button that calls
    the API load route, and a **Save** button that calls the API save route. A Node.js
    server has been provided to you. Write your React code in `activities/activity6/activity/src/index.js`.
    When you are ready to test your code, run the build script (defined in `package.json`)
    before starting the server. You can reference the `index.html` file from *Exercise
    35* for hints on how to call the API routes.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习32*中负责笔记应用的前端团队意外辞职了。您必须使用React构建此应用的前端。您的前端应该有两个视图，一个是主页视图，一个是编辑视图。为每个视图创建一个`React`组件。`主页`视图应该有一个按钮，可以切换到`编辑`视图。`编辑`视图应该有一个按钮，可以切换回`主页`视图，一个包含`笔记文本`的文本输入，一个调用API加载路由的**加载**按钮，以及一个调用API保存路由的**保存**按钮。已经为您提供了一个Node.js服务器。在`activities/activity6/activity/src/index.js`中编写您的React代码。当您准备测试您的代码时，在启动服务器之前运行构建脚本（在`package.json`中定义）。您可以参考*练习35*中的`index.html`文件，了解如何调用API路由的提示。
- en: 'To build a working React front-end and integrate it with a Node.js Express
    server, perform the following steps:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个可工作的React前端并将其与Node.js Express服务器集成，执行以下步骤：
- en: Open the starter activity at `activity/activity6/activity`. Run `npm install`
    to install the required dependencies.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity/activity6/activity`中的起始活动。运行`npm install`以安装所需的依赖项。
- en: Create a `Home` and `Editor` component in the `src/index.js` file.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/index.js`文件中创建`Home`和`Editor`组件。
- en: The `home` view should display the app name and have a button that changes the
    app state to the `edit` view.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`主页`视图应该显示应用程序名称，并有一个按钮，可以将应用状态更改为`编辑`视图。'
- en: The `edit` view should have a return home button that changes the app state
    to the `edit` view, a text input that is controlled by the `edit view` state,
    a **Load** button that makes a request to the server for the saved `Note Text`,
    and a **Save** button that makes a request to the server to save the note text.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`编辑`视图应该有一个返回主页的按钮，可以将应用状态更改为`编辑`视图，一个由`编辑视图`状态控制的文本输入，一个向服务器请求保存的`笔记文本`的**加载**按钮，以及一个向服务器请求保存笔记文本的**保存**按钮。'
- en: In the `App` component, use the `app` state to decide which view (`home` or
    `editor`) to show.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App`组件中，使用`app`状态来决定显示哪个视图（`主页`或`编辑`）。
- en: '**Code**'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: '**Outcome**'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**'
- en: '![Figure 6.10: Home view'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.10：主页视图'
- en: '](image/Figure_6.10.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.10.jpg)'
- en: 'Figure 6.10: Home view'
  id: totrans-420
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.10：主页视图
- en: '![Figure 6.11: Edit View'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11：编辑视图'
- en: '](image/Figure_6.11.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.11.jpg)'
- en: 'Figure 6.11: Edit View'
  id: totrans-423
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.11：编辑视图
- en: '![Figure 6.12: Server View](image/Figure_6.12.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12：服务器视图](image/Figure_6.12.jpg)'
- en: 'Figure 6.12: Server view'
  id: totrans-425
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.12：服务器视图
- en: You have successfully built a working React front-end and integrate it with
    a Node.js Express server.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功构建了一个可工作的React前端，并将其与Node.js Express服务器集成。
- en: Note
  id: totrans-427
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 293.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第293页找到。
- en: Summary
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The JavaScript ecosystem has grown immensely over the past 10+ years. In this
    chapter, we first discussed the JavaScript Ecosystem first. JavaScript can be
    used to build full backend web servers and services, command-line interfaces,
    mobile apps, and front-end sites. In the second section, we introduced Node.js.
    We discussed how to set up Node.js for out of browser JavaScript development,
    the Node Package Manager, loading and creating modules, basic HTTP servers, streams
    and piping, filesystem operations, and the Express server. In the final topic,
    we introduced the React framework for frontend web development. We discussed installing
    React and the basics and specifics of React.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去10多年中，JavaScript生态系统已经大幅增长。在本章中，我们首先讨论了JavaScript生态系统。JavaScript可用于构建完整的后端Web服务器和服务、命令行界面、移动应用程序和前端网站。在第二部分中，我们介绍了Node.js。我们讨论了如何为浏览器外的JavaScript开发设置Node.js，Node包管理器，加载和创建模块，基本的HTTP服务器，流和管道，文件系统操作以及Express服务器。在最后一个主题中，我们介绍了用于前端Web开发的React框架。我们讨论了安装React以及React的基础知识和特定内容。
- en: This rounds up the book. In this book, you examined major features in ES6 and
    implemented these features to build applications. Then, you handled JavaScript
    browser events and created programs that follow the TDD pattern. Lastly, you constructed
    the backend framework Node.js and the frontend framework React. Now, you should
    be equipped with the tools to put what you have learned into practice in the real
    world. Thank you for choosing this advanced JavaScript book.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书到此结束。在本书中，您学习了ES6中的主要特性，并实现了这些特性来构建应用程序。然后，您处理了JavaScript浏览器事件，并创建了遵循TDD模式的程序。最后，您构建了后端框架Node.js和前端框架React。现在，您应该具备将所学知识应用于实际工作中的工具。感谢您选择本高级JavaScript书籍。
