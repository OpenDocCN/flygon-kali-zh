- en: MicroProfile Health Check and JWT Propagation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile Health Check和JWT传播
- en: In this chapter, we will introduce the MicroProfile Health Check and **JSON
    Web Token** (**JWT**) Propagation projects. The Health Check project is concerned
    with exposing the application-defined health to the outside world, and JWT Propagation
    is concerned with defining an interoperable security token and use of that token
    in an application. In this chapter, you will learn the concerns that these specifications
    address, their constructs, and how to use them in your application. The code snippets
    throughout this chapter are for reference only. If you would like a working code
    version of this specification, please refer to [Chapter 8](5535a9c6-c887-40a5-95cd-c8b51ef75bf1.xhtml),
    *A Working Eclipse MicroProfile Code Sample*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍MicroProfile Health Check和JSON Web Token（JWT）传播项目。健康检查项目涉及将应用程序定义的健康状态暴露给外部世界，而JWT传播涉及定义可互操作的安全令牌以及在应用程序中使用该令牌。在本章中，您将了解这些规范解决的问题、它们的构造以及如何在应用程序中使用它们。本章中的代码片段仅供参考。如果您想要这些规范的工作代码版本，请参阅[第8章](5535a9c6-c887-40a5-95cd-c8b51ef75bf1.xhtml)，*一个可工作的Eclipse
    MicroProfile代码示例*。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: What a health check is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康检查是什么
- en: How MicroProfile Health Check exposes the health check endpoint and the format
    of a query to that endpoint
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile Health Check如何公开健康检查端点以及查询该端点的格式
- en: How to write a MicroProfile Health Check for your application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为您的应用程序编写MicroProfile Health Check
- en: The required format for the tokens in MicroProfile JWT Propagation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile JWT传播中令牌的所需格式
- en: How we can leverage MicroProfile JWT Propagation for security decisions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何利用MicroProfile JWT传播进行安全决策
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To build and run the samples in this chapter, you need Maven 3.5+ and a Java
    8 JDK. The code for this chapter can be found at [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-healthcheck](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-healthcheck) and
    [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation)
    for the MicroProfile Health Check and MicroProfile Propagation JWT sections, respectively.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行本章中的示例，您需要Maven 3.5+和Java 8 JDK。本章的代码可以在[https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-healthcheck](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-healthcheck)和[https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation)找到，分别用于MicroProfile
    Health Check和MicroProfile Propagation JWT部分。
- en: Understanding health checks and how MicroProfile handles them
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解健康检查以及MicroProfile如何处理它们
- en: In cloud-native architectures, health checks are used to determine whether a
    computing node is alive and ready to perform work. The concept of readiness describes
    the state when containers start up or roll over (that is, redeployment). During
    this time, the cloud platform needs to ensure that no network traffic is routed
    to that instance before it is ready to perform work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在云原生架构中，健康检查用于确定计算节点是否存活并准备好执行工作。就绪性的概念描述了容器启动或滚动（即重新部署）时的状态。在此期间，云平台需要确保在实例准备好执行工作之前不会将任何网络流量路由到该实例。
- en: Liveness, on the other hand, describes the state of a running container; that
    is, can it still respond to requests? If either the liveness or readiness states
    are seen as invalid, the computing node will be discarded (terminated or shut
    down) and eventually replaced by another, healthy, instance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，存活性描述了运行容器的状态；也就是说，它是否仍然可以响应请求？如果存活性或就绪性状态被视为无效，计算节点将被丢弃（终止或关闭），并最终由另一个健康的实例替换。
- en: Health checks are an essential contract with the orchestration framework and
    scheduler of the cloud platform. The check procedures are provided by the application
    developer and the platform uses these to continuously ensure the availability
    of your application or service.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查是与云平台的编排框架和调度器的基本合同。检查程序由应用程序开发人员提供，平台使用这些程序来持续确保应用程序或服务的可用性。
- en: MicroProfile Health Check 1.0 (MP-HC) supports a single health check endpoint
    that can be utilized for either a liveness or readiness check. MicroProfile Health
    Check 2.0 plans to add support for multiple endpoints to allow an application
    to define both liveness and readiness probes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Health Check 1.0（MP-HC）支持单个健康检查端点，可用于存活性或就绪性检查。MicroProfile Health
    Check 2.0计划添加对多个端点的支持，以允许应用程序定义存活性和就绪性探针。
- en: 'The MP-HC specification details two elements: a protocol along with a response
    wire format part and a Java API for defining the response content.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MP-HC规范详细说明了两个元素：协议以及响应线格式部分和用于定义响应内容的Java API。
- en: The architecture of the MP-HC feature is modeled as an application that consists
    of zero or more health check procedures that are logically linked together with
    `AND` to derive the overall health check status. A procedure represents an application-defined
    check of a required condition that has a name, state, and, optionally, data about
    the check.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: MP-HC功能的架构被建模为一个应用程序，该应用程序由零个或多个健康检查程序组成，这些程序在逻辑上与`AND`连接在一起，以推导出整体健康检查状态。一个程序代表了一个应用程序定义的检查必要条件的状态，并且可能包含有关检查的名称、状态和可选数据。
- en: The Health Check protocol and wire format
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查协议和线格式
- en: 'The MP-HC specification defines the requirement to support the HTTP GET requests
    against a logical `/health` REST endpoint that may return any one of the following
    codes to represent the endpoint''s status:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: MP-HC规范定义了支持针对逻辑`/health` REST端点的HTTP GET请求的要求，该请求可能返回以下任一代码来表示端点的状态：
- en: '`200`: It is up and healthy.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200`：它已经上线并且健康。'
- en: '`500`: It is unhealthy due to an unknown error.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500`：由于未知错误而不健康。'
- en: '`503`: It is down and not ready to respond to requests.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`503`：它已经关闭，无法响应请求。'
- en: Note that many cloud environments simply look at the request return code as
    either success or failure, so the differentiation between a `500` and `503` code
    may not be distinguishable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，许多云环境只将请求返回代码视为成功或失败，因此`500`和`503`代码之间的区别可能无法区分。
- en: The payload of a `/health` request must be a JSON object that matches the schema
    given in the following (for more information on the JSON schema syntax see [http://jsonschema.net/#/](http://jsonschema.net/#/)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对`/health`请求的负载必须是一个符合以下给定模式的JSON对象（有关JSON模式语法的更多信息，请参见[http://jsonschema.net/#/](http://jsonschema.net/#/)）。
- en: Following is ...
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是...
- en: The Health Check Java API
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查Java API
- en: Most of the plumbing is performed by the application framework that implements
    the MP-HC specification. Your part is to decide how liveness or readiness are
    determined through the health check procedures that your microservice defines
    using the MP-HC API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分的管道工作是由实现MP-HC规范的应用框架执行的。你的任务是通过使用MP-HC API定义你的微服务的健康检查过程来决定存活或就绪是如何确定的。
- en: To do this, you need to implement a health check procedure by implementing one
    or more instances of the `HealthCheck` interface using beans that are marked with
    a `Health` annotation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你需要通过实现一个或多个带有`Health`注解的bean来实现健康检查过程，实现`HealthCheck`接口的一个或多个实例。
- en: 'The `HealthCheck` interface is provided in the following code block:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`HealthCheck`接口的代码如下所示：'
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code for the `Health` annotation is provided in the following code block:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Health`注解的代码如下所示：'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An example `HealthCheck` implementation that represents the status of a hypothetical
    disk space check is shown in the following example. Note that the check includes
    the current free space as part of the response data. The `HealthCheckResponse` class
    supports a builder interface to populate the response object.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了一个代表假设磁盘空间检查状态的`HealthCheck`实现示例。注意，检查包括响应数据的当前可用空间。`HealthCheckResponse`类支持构建接口来填充响应对象。
- en: 'Following is a hypothetical disk space `HealthCheck` procedure implementation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个假设的磁盘空间`HealthCheck`过程实现：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we created a health response that is named `diskspace` with
    a status of `up` and custom data named `free` with a string value of `780mb`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`diskspace`的健康响应，状态为`up`，并且自定义数据名为`free`，字符串值为`780mb`。
- en: Another health check example representing some service endpoint is shown in
    the following.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个健康检查示例，代表某个服务端点，如下所示。
- en: 'A hypothetical service `HealthCheck` procedure implementation is shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个假设的服务`HealthCheck`过程实现：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, we created a health response named `service-check` with a
    status of `up` that includes the following additional data:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`service-check`的健康响应，状态为`up`，包括以下附加数据：
- en: A `port` item with an integer value of `12345`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`port`项，整数值为`12345`
- en: An `isSecure` item with a Boolean value of `true`
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`isSecure`项，布尔值为`true`
- en: A `hostname` item with a string value of `service.jboss.com`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`hostname`项，字符串值为`service.jboss.com`
- en: 'The CDI-managed health checks are discovered and registered automatically by
    the application runtime. The runtime automatically exposes an HTTP endpoint, `/health`,
    used by the cloud platform to poke into your application to determine its state.
    You can test this by building the `Chapter04-healthcheck` application and running
    it. You will see the following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: CDI管理的健康检查会被应用运行时自动发现和注册。运行时会自动暴露一个HTTP端点`/health`，云平台用它来检查你的应用状态。你可以通过构建`Chapter04-healthcheck`应用并运行它来测试。你会看到以下输出：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the server has started, test the health checks by querying the health
    endpoint:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器启动后，通过查询健康端点来测试健康检查：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This shows the overall health to be `UP`. The overall status is the logical
    `OR` of all of the health check procedures found in the application. In this case,
    it is `AND` of the two health check procedures we have seen: `diskspace` and `service-check`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了整体健康状态为`UP`。整体状态是应用中所有健康检查过程的逻辑`OR`。在这种情况下，它是我们看到的两个健康检查过程的`AND`：`diskspace`和`service-check`。
- en: Integration with the cloud platform
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与云平台集成
- en: Most cloud platforms support both TCP- and HTTP-based checks. To integrate health
    checks with your selected cloud platform, you need to configure your cloud deployment
    to point to the HTTP entry point, `/health`, on the node that hosts your application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数云平台都支持基于TCP和HTTP的检查。要将健康检查集成到所选的云平台中，你需要配置云部署，指向托管应用的节点上的HTTP入口点`/health`。
- en: The cloud platform will invoke a `GET` query on the HTTP entry point; all checks
    that are registered will be performed and the sum of individual checks determines
    the overall outcome.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 云平台将在HTTP入口点上调用`GET`查询；所有注册的检查将被执行，各个检查的总和决定了整体结果。
- en: Usually, the response payload is ignored by the cloud platform and it only looks
    at the HTTP status code to determine the liveness or readiness of your application.
    A successful outcome, `UP`, will be mapped to `200` and `DOWN` to `503`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，云平台会忽略响应负载，并只查看HTTP状态码来确定应用的存活或就绪状态。成功的结果`UP`将映射为`200`，`DOWN`将映射为`503`。
- en: Human operators
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工操作员
- en: 'The primary use case for the JSON response payload is to provide a way for
    operators to investigate the application state. To support this, health checks
    allow for additional data to be attached to a health check response as we have
    seen in the `CheckDiskspace` and `ServiceCheck` examples. Consider the following
    fragment:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JSON响应负载的主要用例是为操作员提供一种调查应用状态的方式。为了支持这一点，健康检查允许附加额外的数据到健康检查响应中，就像我们在`CheckDiskspace`和`ServiceCheck`示例中看到的那样。考虑以下片段：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, the additional information about `free-heap` is provided and will become
    part of the response payload, as shown in this response fragment. The JSON response
    fragment showing `memory-check` procedure content is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了关于`free-heap`的附加信息，并将成为响应有效负载的一部分，如此响应片段所示。显示`memory-check`程序内容的JSON响应片段如下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we see the `memory-check` procedure with its `UP` state and additional
    `free-heap` data item of the string type with the value of `64mb`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`memory-check`程序及其`UP`状态和字符串类型的附加`free-heap`数据项，值为`64mb`。
- en: '**Eclipse resources/GitHub coordinates for MP-Health**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**Eclipse资源/MP-Health的GitHub坐标**：'
- en: The MP-Health project source code can be found at [https://github.com/eclipse/microprofile-health](https://github.com/eclipse/microprofile-health).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: MP-Health项目源代码可以在[https://github.com/eclipse/microprofile-health](https://github.com/eclipse/microprofile-health)找到。
- en: Changes in Health Check response messages
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查响应消息的更改
- en: MicroProfile Health Check 3.0 introduced changes to the message format of health
    check JSON responses. Specifically, the field's outcome and state have been replaced
    by the field status.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Health Check 3.0对健康检查JSON响应的消息格式进行了更改。具体而言，字段的结果和状态已被字段状态所取代。
- en: In addition, the `@Health` qualifier was deprecated in the Health Check 3.0
    release, while the `@Liveness` and `@Readiness` qualifiers were introduced. For
    the two qualifiers, the `/health/live` and `/health/ready` endpoints were also
    introduced to call all the liveliness and readiness procedures, respectively.
    Lastly, for backward compatibility, `/health` endpoint now calls all the procedures
    that have `@Health`, `@Liveness`, or `@Readiness` qualifiers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在Health Check 3.0版本中，`@Health`限定符已被弃用，而引入了`@Liveness`和`@Readiness`限定符。对于这两个限定符，还引入了`/health/live`和`/health/ready`端点，分别调用所有的活动和准备就绪程序。最后，为了向后兼容，`/health`端点现在调用所有具有`@Health`、`@Liveness`或`@Readiness`限定符的程序。
- en: It's time to discuss JWT Propagation now.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是讨论JWT传播的时候了。
- en: Using JSON Web Token Propagation in MicroProfile
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在MicroProfile中使用JSON Web Token传播
- en: A **JSON Web Token** (**JWT**) is a common format for carrying security information
    that is used by many different web-based security protocols. However, there is
    a lack of standardization around exactly what the contents of the JWT are and
    what security algorithms are used with signed JWTs. The **MicroProfile JWT** (**MP-JWT**) Propagation
    project specification looked at the **OpenID Connect** (**OIDC**)-based ([http://openid.net/connect/](http://openid.net/connect/)) JWT
    ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)) specifications
    and built upon those to define a set of requirements to promote interoperability
    of JWTs for use in MicroProfile-based microservices, along with APIs to access
    information from the JWTs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON Web Token**（**JWT**）是一种常见的格式，用于携带许多不同基于Web的安全协议使用的安全信息。然而，关于JWT的内容以及使用带有签名JWT的安全算法的标准化存在缺乏。**MicroProfile
    JWT**（**MP-JWT**）传播项目规范查看了基于**OpenID Connect**（**OIDC**）的（[http://openid.net/connect/](http://openid.net/connect/)）JWT（[https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)）规范，并在此基础上定义了一组要求，以促进在MicroProfile基础的微服务中使用JWT的互操作性，并提供了访问JWT信息的API。'
- en: For a description of how OIDC and JWT work, including how an application/microservice
    intercepts bearer tokens, please refer to the *Basic Client Implementer's Guide*
    at [http://openid.net/connect/](http://openid.net/connect/).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有关OIDC和JWT的工作原理的描述，包括应用程序/微服务如何拦截承载令牌，请参阅[http://openid.net/connect/](http://openid.net/connect/)上的*基本客户端实施指南*。
- en: 'In this section, you will learn about the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解以下内容：
- en: The claims and signature algorithms from OIDC and JWT specifications that were
    required for interoperability
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OIDC和JWT规范中所需的声明和签名算法，用于实现互操作性
- en: Using JWTs for **Role-Based Access Control** (**RBAC**) of microservice endpoints
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务端点的**基于角色的访问控制**（**RBAC**）中使用JWT
- en: How to use the MP-JWT APIs to access a JWT and its claim values
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用MP-JWT API访问JWT及其声明值
- en: Recommendations for interoperability
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互操作性的建议
- en: 'The maximum utility of MP-JWT as a token format depends on the agreement between
    both identity providers and service providers. This means identity providers—responsible
    for issuing tokens—should be able to issue tokens using the MP-JWT format in a
    way that service providers can understand to inspect the token and gather information
    about a subject. The primary goals for MP-JWT are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: MP-JWT作为令牌格式的最大效用取决于身份提供者和服务提供者之间的协议。这意味着负责发行令牌的身份提供者应该能够以服务提供者能够理解的方式使用MP-JWT格式发行令牌，以检查令牌并收集有关主题的信息。MP-JWT的主要目标如下：
- en: It should be usable as an authentication token.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该可用作身份验证令牌。
- en: It should be usable as an authorization token that contains application-level
    roles indirectly granted via a group's claim.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该可用作包含通过组声明间接授予的应用级角色的授权令牌。
- en: It can support additional standard claims described in IANA JWT Assignments
    ([https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml)),
    as well as non-standard ...
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以支持IANA JWT分配（[https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml)）中描述的附加标准声明，以及非标准...
- en: Required MP-JWT claims
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所需的MP-JWT声明
- en: 'The required set of MP-JWT claims for which an implementation needs to provide
    support contains the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实现需要支持的MP-JWT声明集包括以下内容：
- en: '`typ`: This header parameter identifies the token type and is required to be
    `JWT`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typ`：此标头参数标识令牌类型，必须为`JWT`。'
- en: '`alg`: This header algorithm was used to sign the JWT and must be specified
    as `RS256`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alg`：此标头算法用于签署JWT，必须指定为`RS256`。'
- en: '`kid`: This header parameter provides a hint about which public key was used
    to sign the JWT.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kid`：此标头参数提供了有关用于签署JWT的公钥的提示。'
- en: '`iss`: This is the issuer and signer of the token.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iss`：这是令牌的发行者和签署者。'
- en: '`sub`: This identifies the subject of the JWT.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub`：这标识了JWT的主题。'
- en: '`exp`: This identifies the expiration time on, or after, which the JWT MUST
    NOT be accepted for processing.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exp`：这标识了JWT在指定的UTC日期/时间之后或之后的到期时间，JWT在此之后不得被接受进行处理。'
- en: '`iat`: This identifies the time at which the JWT was issued and can be used
    to determine the age of the JWT.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iat`：这标识了JWT发出的时间，可以用来确定JWT的年龄。'
- en: '`jti`: This provides a unique identifier for the JWT.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jti`：这为JWT提供了一个唯一标识符。'
- en: '`upn`: This MP-JWT custom claim is the preferred way to specify a user principal
    name.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upn`：这个MP-JWT自定义声明是指定用户主体名称的首选方式。'
- en: '`groups`: This MP-JWT custom claim is the list of group or role names assigned
    to the JWT principal.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groups`：这个MP-JWT自定义声明是分配给JWT主体的组或角色名称的列表。'
- en: '`NumericDate` used by `exp`, `iat`, and other date-related claims is a JSON
    numeric value representing the number of seconds from `1970-01-01T00:00:00Z` UTC
    until the specified UTC date/time, ignoring leap seconds. Additionally, more details
    about the standard claims may be found in the MP-JWT specification ([https://github.com/eclipse/microprofile-jwt-auth/releases/tag/1.1.1](https://github.com/eclipse/microprofile-jwt-auth/releases/tag/1.1.1))
    and the JSON Web Token RFC ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`exp`，`iat`和其他与日期相关的声明使用`NumericDate`，它是一个JSON数值，表示从`1970-01-01T00:00:00Z`
    UTC到指定UTC日期/时间的秒数，忽略闰秒。此外，有关标准声明的更多详细信息可以在MP-JWT规范（[https://github.com/eclipse/microprofile-jwt-auth/releases/tag/1.1.1](https://github.com/eclipse/microprofile-jwt-auth/releases/tag/1.1.1)）和JSON
    Web Token RFC（[https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)）中找到。'
- en: 'An example basic MP-JWT in JSON would be a sample header and payload of an
    MP-JWT compatible JWT, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JSON中MP-JWT的基本示例将是一个MP-JWT兼容JWT的示例标头和有效负载，如下所示：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This example shows the header with `typ=JWT`, `alg=RS256`, and `kid=abc-1234567890`.
    The body includes the `iss`, `jti`, `exp`, `iat`, `sub`, `upn`, and `groups` claims.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示了标头，其中`typ=JWT`，`alg=RS256`和`kid=abc-1234567890`。正文包括`iss`，`jti`，`exp`，`iat`，`sub`，`upn`和`groups`声明。
- en: The high-level description of the MP-JWT API
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MP-JWT API的高级描述
- en: 'The MP-JWT project introduces the following API interfaces and classes under
    the `org.eclipse.microprofile.jwt` package namespace:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: MP-JWT项目在`org.eclipse.microprofile.jwt`包命名空间下引入了以下API接口和类：
- en: '`JsonWebToken`: This is a `java.security.Principal` interface extension that
    makes the set of required claims available via get-style accessors, along with
    general access to any claim in the JWT.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JsonWebToken`：这是一个`java.security.Principal`接口扩展，通过get-style访问器提供了一组必需的声明，以及对JWT中的任何声明的一般访问。'
- en: '`Claims`: This is an enumeration utility class that encapsulates all of the
    standard JWT-related claims along with a description and the required Java type
    for the claim as returned from the `JsonWebToken#getClaim(String)` method.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Claims`：这是一个枚举实用程序类，封装了所有标准的JWT相关声明，以及从`JsonWebToken#getClaim(String)`方法返回的声明的描述和所需的Java类型。'
- en: '`Claim`: This is a qualifier annotation used to signify an injection point
    for `ClaimValue`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Claim`：这是一个限定符注释，用于表示`ClaimValue`的注入点。'
- en: '`ClaimValue<T>`: This is a `java.security.Principal` interface extension ...'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClaimValue<T>`：这是一个`java.security.Principal`接口扩展...'
- en: Sample code that uses MP-JWT
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MP-JWT的示例代码
- en: The basic usage of the MP-JWT API is to inject `JsonWebToken`, its `ClaimValue`,
    or both. In this section, we present snippets of typical usage. This book's code
    for this section is available at [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: MP-JWT API的基本用法是注入`JsonWebToken`、它的`ClaimValue`或两者。在本节中，我们提供了典型用法的代码片段。本节的代码可在[https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation)中找到。
- en: Injection of JsonWebToken information
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入JsonWebToken信息
- en: 'The following code sample illustrates access of the incoming MP-JWT token as `JsonWebToken`,
    the raw JWT token string, the `upn` claim, and integration with JAX-RS `SecurityContext`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了作为`JsonWebToken`、原始JWT令牌字符串、`upn`声明以及与JAX-RS`SecurityContext`集成的传入MP-JWT令牌的访问：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Injection of JWT claim values
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入JWT声明值
- en: The code snippet in this section illustrates the injection of individual JWT
    claim values. There are several different formats we can use for the injected
    value. Standard claims support the object subtypes defined in the `Claim#getType`
    field and `JsonValue` subtypes. Custom claim types only support the injection
    of the `JsonValue` subtypes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码片段说明了单个JWT声明值的注入。我们可以使用几种不同的格式来注入值。标准声明支持`Claim#getType`字段和`JsonValue`子类型中定义的对象子类型。自定义声明类型只支持`JsonValue`子类型的注入。
- en: 'The following code example illustrates injection of the standard `groups` and
    `iss` claims, along with `customString`, `customInteger`, `customDouble`, and
    `customObject` custom claims:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了标准`groups`和`iss`声明的注入，以及`customString`、`customInteger`、`customDouble`和`customObject`自定义声明的注入：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The eight commented injections are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 八个注入的注释如下：
- en: Injection of the standard `groups` claim as its default `Set<String>` type
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标准`groups`声明注入为其默认的`Set<String>`类型
- en: Injection of the standard `iss` claim as its default String type
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标准的`iss`声明注入为其默认的字符串类型
- en: Injection of the standard `groups` claim as its default `JsonArray` type
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标准的`groups`声明注入为其默认的`JsonArray`类型
- en: Injection of the standard `iss` claim as its default `JsonString` type
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标准`iss`声明注入为其默认的`JsonString`类型
- en: Injection of a non-standard `customString` claim as a `JsonString` type
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将非标准的`customString`声明注入为`JsonString`类型
- en: Injection of a non-standard `customInteger` claim as a `JsonNumber` type
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将非标准的`customInteger`声明注入为`JsonNumber`类型
- en: Injection of a non-standard `customDouble` claim as a `JsonNumber` type
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将非标准的`customDouble`声明注入为`JsonNumber`类型
- en: Injection of a non-standard `customObject` claim as a `JsonString` type
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将非标准的`customObject`声明注入为`JsonString`类型
- en: Configuring authentication of JWTs
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置JWT的身份验证
- en: 'To accept a JWT as representing an identity that should be authenticated and
    therefore trusted, we need to configure the MP-JWT feature with the information
    to verify who signed and who issued the JWT. This is done via MP-Config properties:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要接受JWT表示应该经过身份验证并因此受信任的身份，我们需要使用信息配置MP-JWT功能，以验证谁签署了JWT以及谁发布了JWT。这是通过MP-Config属性完成的：
- en: '`mp.jwt.verify.publickey`: This provides the embedded key material of the public
    key for the MP-JWT signer, typically in PKCS8 PEM format.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mp.jwt.verify.publickey`：这提供了MP-JWT签名者的公钥的嵌入式密钥材料，通常以PKCS8 PEM格式提供。'
- en: '`mp.jwt.verify.issuer`: This specifies the expected value of the `iss` claim
    found in the JWT.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mp.jwt.verify.issuer`：这指定了JWT中`iss`声明的预期值。'
- en: 'An example `microprofile-configuration.properties` file for this book is as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个示例`microprofile-configuration.properties`文件如下：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Running the samples
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行示例
- en: The samples we looked at can be deployed to Thorntail and accessed via command-line
    queries against the endpoints to validate the expected behaviors. Since authentication
    against the endpoints marked with security constraints requires a valid JWT, we
    need a way to generate a JWT that will be accepted by the Thorntail server.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看的示例可以部署到Thorntail，并通过命令行查询访问端点，以验证预期的行为。由于对标记有安全约束的端点进行身份验证需要有效的JWT，因此我们需要一种方法来生成一个Thorntail服务器将接受的JWT。
- en: 'This chapter''s code provides an `io.packt.jwt.test.GenerateToken` utility
    that will create a JWT signed by a key that has been configured with the Thorntail
    server. The claims included in the JWT are defined by the `src/test/resources/JwtClaims.json`
    document of this chapter''s project. You run the utility using the `mvn exec:java`
    command, as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码提供了一个`io.packt.jwt.test.GenerateToken`实用程序，它将创建一个由已配置了Thorntail服务器的密钥签名的JWT。JWT中包含的声明由本章项目的`src/test/resources/JwtClaims.json`文档定义。您可以使用`mvn
    exec:java`命令运行该实用程序，如下所示：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The utility outputs the claims that were added and then prints out the base64-encoded
    JWT. You would use this JWT as the value in the `Authorization: Bearer …` header
    of the `curl` command line you used to access the server endpoints.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '该实用程序输出添加的声明，然后打印出base64编码的JWT。您将使用此JWT作为`curl`命令行中`Authorization: Bearer …`标头的值，以访问服务器端点。'
- en: 'To start up the Thorntail server with the example endpoints, `cd` into the `Chapter04-jwtpropagation` project
    directory and then run `mvn` to build the executable JAR:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动带有示例端点的Thorntail服务器，请`cd`进入`Chapter04-jwtpropagation`项目目录，然后运行`mvn`来构建可执行的JAR文件：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The resulting executable JAR is located at `target/jwt-propagation-thorntail.jar`.
    You start up the Thorntail server with this chapter''s sample deployment using
    `java -jar …`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的可执行JAR文件位于`target/jwt-propagation-thorntail.jar`。您可以使用`java -jar …`命令启动本章的示例部署Thorntail服务器：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point, we can query the server endpoints. There is one endpoint that
    we defined that does not require any authentication. This is the `jwt/openHello`
    endpoint of the `io.pckt.jwt.rest.SecureEndpoint` class. Run the following command
    to validate that your Thorntail server is running as expected:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以查询服务器端点。我们定义了一个不需要任何身份验证的端点。这是`io.pckt.jwt.rest.SecureEndpoint`类的`jwt/openHello`端点。运行以下命令验证您的Thorntail服务器是否按预期运行：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, try the secured endpoint. It should fail with a 401 Not authorized error
    because we are not providing any authorization information:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试访问受保护的端点。由于我们没有提供任何授权信息，它应该失败并显示401未经授权的错误：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we need to generate a fresh JWT and pass that along with the curl command
    in the `Authorization` header, so let''s try that. We will save the JWT generated
    by the mvn command in a JWT environment variable to simplify the curl command
    line:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要生成一个新的JWT，并将其与curl命令一起传递到`Authorization`标头中，所以让我们试试。我们将通过mvn命令生成的JWT保存在JWT环境变量中，以简化curl命令行：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the previous code snippet, for Windows users, please install a bash-compatible
    shell for Windows; otherwise, you will get an error due to the `echo` command.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，对于Windows用户，请安装一个适用于Windows的bash兼容shell；否则，您将由于`echo`命令而出现错误。
- en: This time, the query succeeds and we see that the username, `upn` claim value,
    scheme, and `isUserInRole("User")` check are as expected.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，查询成功了，我们看到用户名、`upn`声明值、方案和`isUserInRole("User")`检查都如预期那样。
- en: 'Now, try accessing the `/jwt/printClaims` endpoint that illustrated the injection
    of standard and non-standard claims as different types:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试访问`/jwt/printClaims`端点，该端点说明了将标准和非标准声明注入为不同类型的过程：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that, if you begin to experience `Not authorized errors` after a while,
    the problem is that the JWT has expired. You either need to generate a new token
    or generate a token with a longer expiration. You can do this by passing in the
    expiration in seconds to the `GenerateToken` utility. For example, to generate
    a token that is valid for a full hour''s use, perform the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您在一段时间后开始遇到`未经授权的错误`，问题可能是JWT已过期。您需要生成一个新的令牌，或者生成一个具有更长有效期的令牌。您可以通过将到期时间以秒为单位传递给`GenerateToken`实用程序来实现这一点。例如，要生成一个有效期为一小时的令牌，执行以下操作：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These samples should give you a feel for the interaction between the microservice
    client and how the use of JWTs to secure microservice endpoints allows for stateless
    authentication and RBAC, as well as custom authorization based on claims in the
    JWT.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例应该让您了解微服务客户端与使用JWT来保护微服务端点之间的交互，从而实现无状态身份验证和RBAC，以及基于JWT中声明的自定义授权的感觉。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the MicroProfile Health Check and JWT Propagation
    projects. You should now understand what a health check is and how to add application-specific
    checks, known as procedures. These allow your microservice to describe its non-trivial
    health requirements in a cloud environment. You should also understand how JWTs
    can be used to provide an authentication and authorization capability on top of
    your microservices to control access to your endpoints. You should also understand
    how content from the JWT can be used to augment your microservice in user-specific
    ways.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了MicroProfile Health Check和JWT传播项目。您现在应该了解什么是健康检查，以及如何添加应用程序特定的检查，即过程。这些允许您的微服务在云环境中描述其非平凡的健康需求。您还应该了解JWT如何用于在微服务顶部提供身份验证和授权功能，以控制对端点的访问。您还应该了解JWT中的内容如何用于以用户特定的方式增强您的微服务。
- en: The next chapter will introduce the MicroProfile Metrics and OpenTracing features.
    These allow your microservices to provide additional information ...
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍MicroProfile Metrics和OpenTracing功能。这些功能允许您的微服务提供额外的信息...
- en: Questions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is the MP-HC wire format useful in all environments?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MP-HC线格式在所有环境中都有用吗？
- en: Can an MP-HC response contain arbitrary properties?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MP-HC响应是否可以包含任意属性？
- en: What if my application has different types of services that need to report health
    status?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我的应用程序有不同类型的服务需要报告健康状态怎么办？
- en: What is a JWT?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是JWT？
- en: What is a claim?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是声明？
- en: Are there restrictions on what can be in a JWT?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT中可以包含什么限制？
- en: What is/are the main step(s) in authenticating a JWT?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证JWT的主要步骤是什么？
- en: Beyond the security annotations, how might we perform an authorization check
    using JWTs?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了安全注释之外，我们如何使用JWT执行授权检查？
