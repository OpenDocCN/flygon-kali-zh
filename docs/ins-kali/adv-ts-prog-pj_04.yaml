- en: The MEAN Stack - Building a Photo Gallery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MEAN堆栈 - 构建照片库
- en: Nowadays, it's almost impossible to write Node.js applications and not hear
    about the MEAN stack. MEAN is the acronym used to describe a set of common technologies
    used on both the client and server side to build web applications with persistent
    server-side storage. The technologies that make up the **MEAN** stack are **MongoDB**,
    **Express** (sometimes known as **Express.js**), **Angular**, and **Node.js**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，几乎不可能编写Node.js应用程序而不听说MEAN堆栈。MEAN是用来描述一组常用技术的缩写，这些技术用于客户端和服务器端构建具有持久服务器端存储的Web应用程序。构成**MEAN**堆栈的技术有**MongoDB**、**Express**（有时被称为**Express.js**）、**Angular**和**Node.js**。
- en: We are ready to build on the knowledge we developed in the previous chapters
    to write a photo gallery application using the MEAN stack. Unlike previous chapters,
    we will not be using Bootstrap in this chapter, preferring to use Angular Material
    instead.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备在前几章中学到的知识的基础上构建一个使用MEAN堆栈的照片库应用程序。与以前的章节不同的是，在本章中我们不会使用Bootstrap，而是更喜欢使用Angular
    Material。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The components of the MEAN stack
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MEAN堆栈的组件
- en: Creating our application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的应用程序
- en: Using Angular Material to create the UI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular Material创建UI
- en: Using Material to add our navigation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Material添加我们的导航
- en: Creating a file upload component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文件上传组件
- en: Using services to read the file in
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务来读取文件
- en: Introducing Express support into our application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Express支持引入我们的应用程序
- en: Providing Express routing support
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供Express路由支持
- en: Introducing MongoDB
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入MongoDB
- en: Displaying images
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示图片
- en: Using RxJS to watch for images
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxJS来观察图片
- en: Transferring data using `HttpClient`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`HttpClient`传输数据
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter04](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter04).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的项目可以从[https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter04](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter04)下载。
- en: After downloading the project, you will have to install the package requirements
    using `npm install`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下载项目后，您将需要使用`npm install`安装软件包要求。
- en: The MEAN stack
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MEAN堆栈
- en: 'When we use the term the MEAN stack, we are talking about a set of separate
    JavaScript technologies that go together to create web applications that span
    both the client and server side. MEAN is an acronym of the core technologies used:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用MEAN堆栈这个术语时，我们指的是一组单独的JavaScript技术，它们一起创建跨客户端和服务器端的Web应用程序。MEAN是核心技术的缩写：
- en: '**MongoDB**: This is something called a document database, which is used to
    store data in JSON form. Document databases are different from relational databases,
    so if you have come from a technology such as SQL Server or Oracle, it can take
    a little bit of time to adjust to the way that document databases work.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB**：这是一种称为文档数据库的东西，用于以JSON形式存储数据。文档数据库与关系数据库不同，因此如果您来自诸如SQL Server或Oracle之类的技术，可能需要一点时间来适应文档数据库的工作方式。'
- en: '**Express**: This is a backend web application framework that sits on top of
    Node.js. The idea behind having Express in the stack is that it simplifies things
    that Node.js provides on the server side. While Node.js can do everything that
    Express does, the complexity of writing code to do things such as adding cookies
    or routing web requests means that Express''s simplification aids us by cutting
    development time.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Express**：这是一个在Node.js之上的后端Web应用程序框架。在堆栈中使用Express的想法是简化Node.js在服务器端提供的功能。虽然Node.js可以做Express所做的一切，但编写代码来执行诸如添加cookie或路由Web请求等操作的复杂性意味着Express的简化可以通过减少开发时间来帮助我们。'
- en: '**Angular**: Angular is a client-side framework that runs the client side of
    an application. Typically, Angular is used to create **Single-Page Applications**
    (**SPAs**), whereby small sections of the client are updated rather than having
    to reload the whole page when a navigation event happens.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular**：Angular是一个客户端框架，用于运行应用程序的客户端部分。通常，Angular用于创建**单页应用程序**（**SPA**），在这种应用程序中，客户端的小部分会被更新，而不必在导航事件发生时重新加载整个页面。'
- en: '**Node.js**: Node.js is the server-side runtime environment for an application.
    We can think of this as the web server.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js**：Node.js是应用程序的服务器端运行环境。我们可以将其视为Web服务器。'
- en: 'The following diagram shows where the components of the MEAN stack exist in
    terms of our application architecture. The part of the application that our user
    sees, sometimes known as the frontend, is the client in this diagram. The rest
    of our application is commonly referred to as the backend and is the web server
    and database in the diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了MEAN堆栈的组件在我们的应用程序架构中的位置。用户看到的应用程序部分，有时被称为前端，在这个图表中是客户端。我们应用程序的其余部分通常被称为后端，在图表中是Web服务器和数据库：
- en: '![](assets/28a2cdaf-cd75-4d1f-a0c0-c1c55894b3e0.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/28a2cdaf-cd75-4d1f-a0c0-c1c55894b3e0.png)'
- en: There is an equivalent for using React in place of Angular. It's known as the
    MERN stack.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用React替代Angular时有一个等效的。它被称为MERN堆栈。
- en: Project overview
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: The project we are going to build in this chapter will introduce us to writing
    server-side applications as well as introduce us to the popular Angular framework.
    We will build a picture gallery application where our users can upload pictures
    and save them in a server-side database that allows them to view them again later.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将要构建的项目将使我们了解如何编写服务器端应用程序，并向我们介绍流行的Angular框架。我们将构建一个图片库应用程序，用户可以上传图片并将它们保存在服务器端数据库中，以便以后再次查看。
- en: 'As long as you work alongside the code in the GitHub repository, this chapter
    should take about three hours to complete. The finished application will look
    like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你在GitHub存储库中与代码一起工作，这一章应该需要大约三个小时才能完成。完成的应用程序将如下所示：
- en: '![](assets/a569134c-b4b1-4a88-bc95-111d96c87fda.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a569134c-b4b1-4a88-bc95-111d96c87fda.png)'
- en: This chapter is not intended to be a comprehensive tutorial on all aspects of
    the MEAN stack. By the end of the chapter, we will only have begun to scratch
    the surface of what the different parts provide. As we are introducing many topics
    here, we will focus more on those topics than on advanced features of TypeScript
    because this could lead to information overload, but we will still be covering
    features such as generic constraints and fluent code, even though we aren't going
    to refer to them explicitly. At this point, we should be familiar enough with
    them to recognize them when we encounter them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不打算成为 MEAN 栈所有方面的全面教程。到本章结束时，我们只会开始涉及这些不同部分提供的一小部分内容。由于我们在这里介绍了许多主题，我们将更多地关注这些主题，而不是
    TypeScript 的高级特性，因为这可能导致信息过载，但我们仍将涵盖通用约束和流畅代码等特性，尽管我们不会明确提到它们。在这一点上，我们应该足够熟悉它们，以便在遇到它们时能够识别它们。
- en: Getting started
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'Just as in the previous chapter, this chapter will use Node.js, which is available
    at [https://nodejs.org](https://nodejs.org). We will also be using the following
    components:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一章一样，本章将使用可在 [https://nodejs.org](https://nodejs.org) 上获得的 Node.js。我们还将使用以下组件：
- en: The Angular **Command-Line Interface** (**CLI**) (I'm using version 7.2.2)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular **命令行界面**（**CLI**）（我使用的版本是 7.2.2）
- en: '`cors` (version 2.8.5 or greater)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cors`（版本 2.8.5 或更高）'
- en: '`body-parser` (version 1.18.3 or greater)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body-parser`（版本 1.18.3 或更高）'
- en: '`express` (version 4.16.4 or greater)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`express`（版本 4.16.4 或更高）'
- en: '`mongoose` (version 5.4.8 or greater)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongoose`（版本 5.4.8 或更高）'
- en: '`@types/cors` (version 2.8.4 or greater)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/cors`（版本 2.8.4 或更高）'
- en: '`@types/body-parser` (version 1.17.0 or greater)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/body-parser`（版本 1.17.0 或更高）'
- en: '`@types/express` (version 4.16.0 or greater)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/express`（版本 4.16.0 或更高）'
- en: '`@types/mongodb` (version 3.1.19 or greater)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/mongodb`（版本 3.1.19 或更高）'
- en: '`@types/mongoose` (version 5.3.11 or greater)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/mongoose`（版本 5.3.11 或更高）'
- en: We will also be using MongoDB. The Community Edition is available at [https://www.mongodb.com/download-center/community](https://www.mongodb.com/download-center/community).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 MongoDB。Community Edition 可以在 [https://www.mongodb.com/download-center/community](https://www.mongodb.com/download-center/community)
    下载。
- en: MongoDB also comes with a GUI that makes it easier to view, query, and edit
    your MongoDB databases. MongoDB Community Edition can be downloaded from [https://www.mongodb.com/download-center/compass](https://www.mongodb.com/download-center/compass).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 还配备了一个 GUI，使查看、查询和编辑 MongoDB 数据库变得更加容易。MongoDB Community Edition 可以从
    [https://www.mongodb.com/download-center/compass](https://www.mongodb.com/download-center/compass)
    下载。
- en: Creating an Angular photo gallery with the MEAN stack
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MEAN 栈创建 Angular 照片库
- en: 'As we did in previous chapters, we are going to start out by defining the requirements
    of our application:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在之前的章节中一样，我们将从定义我们应用程序的需求开始：
- en: The user must be able to select a picture to transfer to the server
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须能够选择要传输到服务器的图片
- en: The user will be able to supply additional metadata for the pictures, such as
    descriptions
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够为图片提供额外的元数据，如描述
- en: Uploaded pictures will be saved in a database with the metadata
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传的图片将与元数据一起保存在数据库中
- en: The user will be able to automatically view the uploaded pictures
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够自动查看上传的图片
- en: Understanding Angular
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Angular
- en: Angular was created as a platform for creating client-side applications using
    a combination of HTML and TypeScript. Originally, Angular was written in JavaScript
    (it was known as Angular.js back then), but it underwent a complete rewrite using
    TypeScript and was rebranded to just Angular. The architecture of Angular itself
    revolves around a series of modules that we can bring into our application or
    write ourselves, which can contain services and components that we can use to
    build up our client-side code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是作为一个平台创建客户端应用程序的，使用 HTML 和 TypeScript 的组合。最初，Angular 是用 JavaScript
    编写的（当时被称为 Angular.js），但它经历了完全的重写，使用 TypeScript，并重新命名为 Angular。Angular 本身的架构围绕着一系列模块，我们可以将其引入我们的应用程序或自己编写，其中可以包含我们可以用来构建客户端代码的服务和组件。
- en: Originally, one of the key drivers behind Angular was the idea that fully reloading
    web pages is a wasteful practice. So many websites were serving the same navigation,
    headers, footers, sidebars, and more that it was a waste of time reloading those
    items every time the user navigated to a new page because they hadn't actually
    changed. Angular helped to popularize an architecture known as the SPAs, where
    only small parts of the page that need to change actually do so. This reduces
    the amount of traffic that a web page has to deal with so that, when done properly,
    the responsiveness of a client application is increased.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Angular 的一个关键驱动因素是完全重新加载网页是一种浪费的做法。因此，许多网站都在提供相同的导航、标题、页脚、侧边栏等，每次用户导航到新页面时重新加载这些项目都是一种浪费，因为它们实际上并没有改变。Angular
    帮助推广了一种被称为 SPAs 的架构，其中只有需要更改的页面的小部分才会实际更改。这减少了网页处理的流量量，因此，当正确完成时，客户端应用的响应性会增加。
- en: 'The following screenshot shows a typical SPA format. The vast majority of the
    page is static in nature so it doesn''t have to be re-sent, but the Junk Email
    section in the center will be dynamic—only that part needs to be updated. This
    is the beauty of SPAs:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了典型的 SPA 格式。页面的绝大部分是静态的，因此不需要重新发送，但中间的垃圾邮件部分将是动态的——只有那部分需要更新。这就是 SPAs
    的美妙之处：
- en: '![](assets/fb8ad46b-5832-4607-91a8-f52441cf10cb.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fb8ad46b-5832-4607-91a8-f52441cf10cb.png)'
- en: This does not mean that we can't create multi-page applications in Angular.
    It just means that unless we have a real need to create a multi-page application,
    then Angular SPA applications are the way we should write our Angular applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们不能在 Angular 中创建多页面应用程序。这只是意味着，除非我们真正需要创建多页面应用程序，否则 Angular SPA 应用程序是我们应该编写
    Angular 应用程序的方式。
- en: Now that we have an idea of what Angular is about, we can move on to using Angular
    to write our client.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Angular 的内容，我们可以继续使用 Angular 来编写我们的客户端。
- en: Creating our application
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的应用程序
- en: 'Unless you have recently installed Angular, you need to install it using `npm`.
    The part that we are going to install is the Angular CLI. This gives us everything
    we need to run from Command Prompt to generate our application, add components,
    scaffold the application, and more:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您最近安装了Angular，否则需要使用`npm`进行安装。我们要安装的部分是Angular CLI。这为我们提供了从命令提示符中运行所需的一切，包括生成应用程序、添加组件、脚手架应用程序等等：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we are going to develop both client and server code, it will be helpful to
    keep our code together to do this; therefore, we are going to create `Client`
    and `Server` folders under a common directory. Any Angular commands will be run
    in the `Client` folder. It is relatively common to share code between the client
    and server side, so this arrangement is a simple way to keep the application together
    and simplify sharing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将开发客户端和服务器端代码，将代码放在一起会很有帮助；因此，我们将在一个共同的目录下创建`Client`和`Server`文件夹。任何Angular命令都将在`Client`文件夹中运行。在客户端和服务器端之间共享代码是相当常见的，因此这种安排是保持应用程序在一起并简化共享的简单方法。
- en: 'Creating an application with Angular is easily accomplished using the `ng new`
    command, which was added to our system when we added the Angular CLI. We are going
    to specify command-line arguments to choose SCSS to generate our CSS, as well
    as choosing the prefix we want to give to any components that we create:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ng new`命令轻松创建一个带有Angular的应用程序，该命令在添加Angular CLI时已经添加到我们的系统中。我们将指定命令行参数来选择SCSS生成我们的CSS，以及选择我们要为创建的任何组件指定的前缀：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The naming convention I have chosen to follow reflects the name of the book,
    so we use `atp` to reflect *Advanced TypeScript Projects*. While we aren't going
    to make heavy use of CSS in this chapter, I tend to use SCSS as my CSS pre-processor
    more than I use raw CSS because it has a rich syntax for using things such as
    style mixins, which means that this is the style engine I tend to go to by default. The
    reason that we are choosing to use the `atp` prefix is to make our component selectors
    unique. Suppose that we had a component that we wanted to call label; obviously,
    this would clash with the built-in HTML label. To avoid the clash, our component
    selector would be the `atp` label. As HTML controls never use hyphens, we guarantee
    that we aren't going to *collide* with existing control selectors.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择遵循的命名约定反映了书名，因此我们使用`atp`来反映*Advanced TypeScript Projects*。虽然在本章中我们不会大量使用CSS，但我更倾向于使用SCSS作为我的CSS预处理器，而不是使用原始CSS，因为它具有丰富的语法，可以使用诸如样式混合等内容，这意味着这是我默认使用的样式引擎。我们选择使用`atp`前缀的原因是为了使我们的组件选择器唯一。假设我们有一个组件想要称为label；显然，这将与内置的HTML
    label冲突。为了避免冲突，我们的组件选择器将是`atp` label。由于HTML控件从不使用连字符，我们保证不会与现有的控件选择器发生*冲突*。
- en: 'We are going to accept the installation defaults, so just press *Enter* when
    prompted about whether or not to add Angular routing support. When the installation
    completes, we are going to start our Angular server, which also watches to see
    whether files change and rebuilds the application on the fly. Normally, I would
    install all of the required components before I did this part, but it is useful
    to see exactly what Angular gives us as a starting point and the ability to view
    live changes is highly useful:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将接受安装默认值，因此在提示是否添加Angular路由支持时，只需按*Enter*。安装完成后，我们将启动我们的Angular服务器，它还会监视文件是否更改并实时重建应用程序。通常，在执行此部分之前，我会安装所有所需的组件，但是看到Angular给我们提供的起点以及查看实时更改的能力是非常有用的：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unlike React, the default web address for opening our application is `http://localhost:4200`.
    When the browser opens, it displays the default Angular sample page. Obviously,
    we are going to remove lots from this, but in the short term, we are going to
    keep this page as it is while we start adding some of the infrastructure we need.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与React不同，打开我们的应用程序的默认网址是`http://localhost:4200`。当浏览器打开时，它会显示默认的Angular示例页面。显然，我们将从中删除很多内容，但在短期内，我们将保持此页面不变，同时开始添加一些我们需要的基础设施。
- en: Angular creates a lot of files for us, so it's worth identifying which ones
    are the ones that we are going to work with the most and what purpose they serve.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Angular为我们创建了许多文件，因此值得确定我们将与之最多一起使用的文件以及它们的作用。
- en: App.Module.ts
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: App.Module.ts
- en: During the process of developing large Angular applications, especially if we
    are just one of a number of teams developing different parts of the same overall
    application, it's common to break them down into modules. We can view this file
    as our entry point into saying how a module is grouped together. For our purposes,
    we are interested in two sections in the module definition covered by `@NgModule`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发大型Angular应用程序的过程中，特别是如果我们只是众多团队中开发同一整体应用程序的一部分，将它们分解为模块是很常见的。我们可以将此文件视为我们进入组合模块的入口点。对于我们的目的，我们对`@NgModule`覆盖的模块定义中的两个部分感兴趣。
- en: The first section is the `declarations` section, which tells Angular what components
    we have developed. For our application, we will develop three components that
    belong in here—`AppComponent` (which is added by default), `FileuploadComponent`,
    and `PageBodyComponent`. Fortunately for us, when we use the Angular CLI to generate
    components, their declarations are automatically added into this section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是`declarations`部分，告诉Angular我们开发了哪些组件。对于我们的应用程序，我们将开发三个组件，它们属于这里——`AppComponent`（默认添加），`FileuploadComponent`和`PageBodyComponent`。幸运的是，当我们使用Angular
    CLI生成组件时，它们的声明会自动添加到此部分中。
- en: The other section we are interested in is the `imports` section. This tells
    us what external modules need to be imported into our application. We cannot just
    reference a feature from an external module in our application; we actually have
    to tell Angular that we are going to use the module that the feature comes from.
    This means that Angular is very good at minifying the dependencies that we have
    when we deploy the application because it will only deploy modules that we have
    said that we are using.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的另一部分是`imports`部分。这告诉我们需要导入到我们的应用程序中的外部模块。我们不能只是在我们的应用程序中引用外部模块的功能；我们实际上必须告诉Angular我们将使用该功能所来自的模块。这意味着当我们部署应用程序时，Angular非常擅长最小化我们的依赖关系，因为它只会部署我们已经说过我们在使用的模块。
- en: As we go through this chapter, we will add items into this section in order
    to enable features such as Angular Material support.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们阅读本章时，我们将在这一部分添加项目，以启用诸如Angular Material支持之类的功能。
- en: Using Angular Material for our UI
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular Material来构建我们的UI
- en: The frontend of our application is going to use something called Angular Material
    instead of relying on Bootstrap. We are going to look at Material because it's
    widely used with Angular applications; therefore, if you are going to develop
    with Angular commercially, there's a good chance that you will use it in your
    career at some point.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序的前端将使用一个叫做Angular Material的东西，而不是依赖于Bootstrap。我们将研究Material，因为它在Angular应用程序中被广泛使用；因此，如果你要商业化地开发Angular，有很大的机会你会在职业生涯中的某个时候使用它。
- en: Angular Material was built by the Angular team to bring Material Design components
    to Angular. The idea behind them is that they integrate seamlessly into the Angular
    development process so that they feel no different to using standard HTML components.
    These design components go well beyond what we can do with single standard controls,
    so we can easily build complex navigation layouts with them, for instance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material是由Angular团队构建的，旨在将Material Design组件带到Angular。它们的理念是，它们能够无缝地融入到Angular开发过程中，以至于使用它们感觉和使用标准HTML组件没有什么不同。这些设计组件远远超出了我们可以用单个标准控件做的事情，因此我们可以轻松地使用它们来构建复杂的导航布局，等等。
- en: Material components bring behaviors and visual appearance together so that,
    out of the box, we can use them to create professional-looking applications with
    minimal effort on our part. To a certain extent, Material can be thought of as
    a similar experience to using Bootstrap. In this chapter, we are going to concentrate
    on using Material instead of Bootstrap.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Material组件将行为和视觉外观结合在一起，这样，我们可以直接使用它们来轻松创建专业外观的应用程序，而我们自己的工作量很小。在某种程度上，Material可以被认为是一种类似于使用Bootstrap的体验。在本章中，我们将集中使用Material而不是Bootstrap。
- en: A couple of paragraphs ago, we rather glibly mentioned that Angular Material
    brings Material Design components to Angular. This is a largely circular statement
    until we understand what Material Design is. If we search Google for the term,
    we get lots of articles telling us that Material Design is Google's design language.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 几段文字前，我们轻率地提到Angular Material将Material Design组件带到了Angular。在我们了解Material Design是什么之前，这是一个很大程度上的循环陈述。如果我们在谷歌上搜索这个词，我们会得到很多文章告诉我们Material
    Design是谷歌的设计语言。
- en: Certainly, if we do Android development, the term comes up frequently because
    Android and Material are fundamentally linked. The idea behind Material is that
    it is in the best interests of our users if we can present interface elements
    in a way that is consistent. So, if we adopt Material, our applications will look
    familiar to users who are used to applications such as Gmail.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们进行Android开发，这个术语会经常出现，因为Android和Material基本上是相互关联的。Material的理念是，如果我们能以一致的方式呈现界面元素，那么对我们的用户来说是最有利的。因此，如果我们采用Material，我们的应用程序将对于习惯于诸如Gmail之类的应用程序的用户来说是熟悉的。
- en: The term *design language* is too vague, though. What does it actually mean
    to us? Why does it have its own fancy term? In the same way that our own language
    is broken down and structured into words and punctuation, we can break visual
    elements down into structures such as color and depth. As an example, the language
    tells us what colors mean, so if we see a button with one color on one screen
    in our application, it should have the same underlying usage across other screens
    in our application; we wouldn't use a green button to signify OK on one dialog
    and then Cancel on another.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，“设计语言”这个术语太模糊了。对我们来说它实际上意味着什么？为什么它有自己的花哨术语？就像我们自己的语言被分解和结构化成单词和标点符号一样，我们可以将视觉元素分解成结构，比如颜色和深度。举个例子，语言告诉我们颜色的含义，所以如果我们在应用程序的一个屏幕上看到一个按钮是一个颜色，那么在应用程序的其他屏幕上它应该有相同的基本用法；我们不会在一个对话框上用绿色按钮表示“确定”，然后在另一个对话框上表示“取消”。
- en: 'Installing Angular Material is a simple process. We run the following command
    to add support for Angular Material, the **Component Design Toolkit** (**CDK**),
    flexible layout support, and animation support:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Angular Material是一个简单的过程。我们运行以下命令来添加对Angular Material、**组件设计工具包**（**CDK**）、灵活的布局支持和动画支持的支持：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: During the installation of the libraries, we will be prompted to choose what
    theme we want to use. The most visible aspect of the theme is the color scheme
    that is applied.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装库的过程中，我们将被提示选择要使用的主题。主题最显著的方面是应用的颜色方案。
- en: 'We can choose from the following themes (examples of the themes are also supplied):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从以下主题中进行选择（主题的示例也已提供）：
- en: Indigo/Pink ([https://material.angular.io?theme=indigo-pink](https://material.angular.io?theme=indigo-pink))
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 靛蓝/粉色 ([https://material.angular.io?theme=indigo-pink](https://material.angular.io?theme=indigo-pink))
- en: Deep Purple/Amber ([https://material.angular.io?theme=deeppurple-amber](https://material.angular.io?theme=deeppurple-amber))
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深紫色/琥珀色 ([https://material.angular.io?theme=deeppurple-amber](https://material.angular.io?theme=deeppurple-amber))
- en: Pink/Blue Grey ([https://material.angular.io?theme=pink-bluegrey](https://material.angular.io?theme=pink-bluegrey))
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粉色/蓝灰色 ([https://material.angular.io?theme=pink-bluegrey](https://material.angular.io?theme=pink-bluegrey))
- en: Purple/Green ([https://material.angular.io?theme=purple-green](https://material.angular.io?theme=purple-green))
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紫色/绿色 ([https://material.angular.io?theme=purple-green](https://material.angular.io?theme=purple-green))
- en: Custom
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义
- en: For our application, we are going to use the Indigo/Pink theme.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将使用Indigo/Pink主题。
- en: We are also prompted about whether or not we want to add HammerJS support. This
    library provides gesture recognition so our applications can respond to things
    such as panning or rotating using touch or the mouse. Finally, we have to choose
    whether or not we want to set up browser animations for Angular Material.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还被提示是否要添加HammerJS支持。这个库提供了手势识别，这样我们的应用程序就可以响应诸如触摸或鼠标旋转等操作。最后，我们必须选择是否要为Angular
    Material设置浏览器动画。
- en: The CDK is an abstraction that says how common Material features work, but it
    does not say what they will look like. Without installing the CDK, many features
    of the Material library just won't work, so it's important to ensure that it is
    installed alongside `@angular/material`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: CDK是一个抽象，它说明了常见Material功能的工作原理，但并不说明它们的外观。如果没有安装CDK，Material库的许多功能就无法正常工作，因此确保它与`@angular/material`一起安装非常重要。
- en: Using Material to add navigation
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Material添加导航
- en: 'We will see, over and over again, that so much of what we need to do to add
    features to our application requires us to start with changes in `app.module.ts`.
    Material is no different, so we start by adding the following `import` lines:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会一遍又一遍地看到，我们需要做的许多事情来为我们的应用程序添加功能，都需要从`app.module.ts`中开始。Material也不例外，所以我们首先添加以下`import`行：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that the modules are available to us, we need to reference them in the
    `import` section of `NgModule`. Any module listed in this section will have its
    capabilities available in the templates that are in our application. When we add
    side-navigation support, for instance, we are relying on the fact that we have
    made `MatSidenavModule` available in this section:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些模块对我们可用，我们需要在`NgModule`的`import`部分中引用它们。在这一部分列出的任何模块都将在我们应用程序的模板中可用。例如，当我们添加侧边导航支持时，我们依赖于我们已经在这一部分中使`MatSidenavModule`可用：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are going to set our application to use side navigation (the navigation
    strip that appears down the side of the screen). Structurally, we need to add
    three elements to enable side navigation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置我们的应用程序使用侧边导航（出现在屏幕侧边的导航条）。在结构上，我们需要添加三个元素来启用侧边导航：
- en: '`mat-sidenav-container` to host side navigation'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mat-sidenav-container` 用于承载侧边导航'
- en: '`mat-sidenav` to display side navigation'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mat-sidenav` 用于显示侧边导航'
- en: '`mat-sidenav-content` to add the content that we are going to display'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mat-sidenav-content` 以添加我们要显示的内容'
- en: 'To start, we are going to add the following content to our `app.component.html`
    page:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`app.component.html`页面中添加以下内容：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `mat-sidenav` line sets up a couple of the behaviors that we will exploit.
    We want the navigation to be fixed in the viewport and we give it the ID of drawer
    through the use of `#drawer`. We will use this ID shortly, when we trigger toggling
    whether the drawer is open or not.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`mat-sidenav` 行设置了我们将利用的一些行为。我们希望导航固定在视口中，并通过`#drawer`的使用给它设置了drawer的ID。我们将很快使用这个ID，当我们触发抽屉是打开还是关闭的切换时。'
- en: Possibly the most interesting part of this line is `[opened]="false"`. This
    is the first point at which we encounter binding in our application. The use of
    `[]` here tells us that we want to bind to a particular property, `opened` in
    this case, and set it to `false`. As we will see as we go through this chapter,
    Angular has a rich binding syntax.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行可能最有趣的部分是`[opened]="false"`。这是我们在应用程序中遇到绑定的第一个点。这里的`[]`告诉我们，我们要绑定到一个特定的属性，这种情况下是`opened`，并将其设置为`false`。当我们在本章中逐步学习时，会发现Angular有丰富的绑定语法。
- en: 'Now that we have the container to hold our navigation, we are going to add
    side-navigation content. We are going to add a toolbar to hold the `Menu` text
    and a navigation list that allows the user to import an image:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了容器来容纳我们的导航，我们将添加侧边导航内容。我们将添加一个工具栏来容纳`Menu`文本和一个导航列表，允许用户导入图像。
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using `mat-list-item` in a standard anchor tag simply tells the Material engine
    that we want to lay the anchors in a list. Effectively, this section is an unordered
    list of anchors that are styled using Material styles.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准锚标签中使用`mat-list-item`只是告诉Material引擎，我们要在列表中放置锚点。实际上，这一部分是一个使用Material样式进行样式化的锚点无序列表。
- en: 'Now, we want to add the ability to toggle our navigation. The way that we do
    this is by adding a toolbar to our navigation content area. This toolbar will
    host a button that triggers the opening of the side-navigation drawer. In the
    `mat-sidenav-content` section, add the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要添加切换导航的功能。我们这样做的方式是在导航内容区域添加一个工具栏。这个工具栏将承载一个按钮，触发侧边导航抽屉的打开。在`mat-sidenav-content`部分，添加以下内容：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The button uses another example of binding here—in this case, reacting to the
    `click` event—to trigger the `toggle` operation on the `mat-sidenav` item with
    the `drawer` ID. Rather than using `[eventName]` to bind to commands, we use `(eventName)`
    instead. Inside the button, we host `mat-icon` to represent the image used to
    toggle the navigation. In keeping with the philosophy that Material design represents
    a common way to show applications, Angular Material provides us with a number
    of standard icons, such as `menu`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮在这里使用了另一个绑定的例子——在这种情况下，对`click`事件做出反应——以触发具有`drawer`ID的`mat-sidenav`项目上的`toggle`操作。我们不再使用`[eventName]`来绑定命令，而是使用`(eventName)`。在按钮内部，我们使用`mat-icon`来表示用于切换导航的图像。与Material设计代表一种常见的应用程序显示方式的理念一致，Angular
    Material为我们提供了许多标准图标，如`menu`。
- en: The Material fonts that we are using represent certain words, such as home and
    menu, as particular images via something called **ligatures**. This is a standard
    typography term that just means that there are well-known combinations of letters,
    numbers, and symbols that can be represented as an image. For instance, if we
    had `mat-icon` with the text `home`, this would be represented as a home icon.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的Material字体代表了某些单词，比如home和menu，通过一种叫做**连字**的东西来表示特定的图像。这是一个标准的排版术语，意思是有一些众所周知的字母、数字和符号的组合可以被表示为图像。例如，如果我们有一个带有文本`home`的`mat-icon`，这将被表示为一个home图标。
- en: Creating our first component – the FileUpload component
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个组件 - FileUpload组件
- en: 'The `Import Image` link on our navigation has to actually do something, so
    we are going to write a component that will be displayed inside a dialog. As we
    are going to upload a file, we are going to call this `FileUpload`, and creating
    it is as simple as running the following Angular CLI command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导航栏上的`导入图像`链接实际上必须做一些事情，所以我们将编写一个将显示在对话框中的组件。由于我们将要上传一个文件，我们将称其为`FileUpload`，创建它就像运行以下Angular
    CLI命令一样简单：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can shorten these standard Angular commands if we want, so we can use `ng
    g c` instead of `ng generate component`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以缩短这些标准的Angular命令，所以我们可以使用`ng g c`代替`ng generate component`。
- en: 'This command creates four files for us:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令为我们创建了四个文件：
- en: '`fileupload.component.html`: The HTML template for our component.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileupload.component.html`：我们组件的HTML模板。'
- en: '`fileupload.component.scss`: Anything that we need to convert into CSS for
    our component.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileupload.component.scss`：我们需要将其转换为组件的CSS的任何内容。'
- en: '`fileupload.component.spec.ts`: Now, `spec.ts` files are used when we want
    to run unit tests against our Angular applications. Properly testing web applications
    is outside the scope of this book as it''s a book in its own right.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileupload.component.spec.ts`：现在，当我们想要对我们的Angular应用运行单元测试时，会使用`spec.ts`文件。适当地测试Web应用程序超出了本书的范围，因为这本书本身就是一本书。'
- en: '`fileupload.component.ts`: The logic for the component.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileupload.component.ts`：组件的逻辑。'
- en: Running the `ng` command to generate the component also results in it being
    added into the `declarations` section in `app.module.ts`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`ng`命令生成组件还会导致它被添加到`app.module.ts`中的`declarations`部分。
- en: 'When we open up `fileupload.component.ts`, the structure roughly looks like
    this (ignoring the imports at the top):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开`fileupload.component.ts`时，结构大致如下（忽略顶部的导入）：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we can see that Angular is making full use of TypeScript features that
    we have already looked at. In this case, `FileuploadComponent` has a `Component`
    decorator that tells Angular that we use `atp-fileupload` when we want to use
    a `FileuploadComponent` instance in our HTML. As we are using a separate HTML
    template and style, the other parts of the `@Component` decorator identify where
    those elements are. We could define styles and templates directly in this class,
    but in general, it's better to separate them out into their own files.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到Angular充分利用了我们已经了解的TypeScript特性。在这种情况下，`FileuploadComponent`有一个`Component`装饰器，告诉Angular当我们想在HTML中使用`FileuploadComponent`实例时，我们使用`atp-fileupload`。由于我们使用了单独的HTML模板和样式，`@Component`装饰器的其他部分标识了这些元素的位置。我们可以直接在这个类中定义样式和模板，但一般来说，最好将它们分开到它们自己的文件中。
- en: We can see our naming convention here, having specified `atp` when we created
    our application. It's a good idea to use something meaningful. When working in
    a team, you should find out what the standard is that your team follows and, if
    there is no standard, you should take the time to agree on how you want this to
    be named up front.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里看到我们的命名约定，在创建应用程序时指定了`atp`。使用有意义的东西是个好主意。在团队中工作时，您应该了解您的团队遵循的标准是什么，如果没有标准，您应该花时间商定如何在前期命名。
- en: One of the features of the dialog is that it will show us a preview of the image
    that the user selects. We are going to separate the logic for reading the image
    from the component to keep a nice and clean separation of concerns going on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框的一个特性是它会向我们显示用户选择的图像的预览。我们将把读取图像的逻辑从组件中分离出来，以保持关注点的清晰分离。
- en: Previewing files using a service
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务预览文件
- en: One of the challenges of developing UI applications is that there is a tendency
    for logic to creep into views that does not belong there. It becomes convenient
    to put a piece of logic in our `ts` views file because we know that the view is
    going to call out to it, but it does something that does not have any visible
    impact on the client.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 开发UI应用程序的一个挑战是，逻辑往往会渗入视图中，这是不应该出现的。我们知道视图将调用它，所以把一部分逻辑放在我们的`ts`视图文件中变得很方便，但它做的事情对客户端没有任何可见的影响。
- en: We might, for instance, want to write some values from the UI back to the server.
    The only part of this that is relevant to the view is the data part; the actual
    writing to the server is a completely different responsibility. It would be useful
    to us if we had a simple way to create external classes that we could inject wherever
    we needed so that we would not need to worry about how to instantiate them. They
    would just be available to us to use whenever we needed them. Fortunately for
    us, the authors of Angular saw that there would be a need for this and provided
    us with services.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能想要将一些UI中的值写回服务器。与视图相关的部分只有数据部分；实际写入服务器是完全不同的责任。如果我们有一个简单的方法来创建外部类，我们可以在需要的地方注入它们，这对我们是有用的，这样我们就不需要担心如何实例化它们。它们只是在我们需要它们时可用。幸运的是，Angular的作者们看到了这一点，并为我们提供了服务。
- en: 'A service is simply a class that uses the `@Injectable` decorator and has an
    entry in the `declarations` section of the module. Apart from those requirements,
    there''s nothing else that is needed, so we could easily handcraft the class if
    we needed to. While we could do this, there''s no real reason to, because Angular
    helps us to generate the service using the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`service`只是一个使用`@Injectable`装饰器的类，并在模块的`declarations`部分中有一个条目。除了这些要求，没有其他需要的东西，所以如果需要的话，我们可以轻松手工制作这个类。虽然我们可以这样做，但实际上没有真正的理由，因为Angular帮助我们使用以下命令生成`service`：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we create the `service`, we don''t actually have to add `service` at the
    end of the name as this command automatically does that for us. To see how this
    works, we are going to create a `service` that takes a file that has been chosen
    using the file selector and then reads it in so that it can be displayed back
    in the image upload dialog and on the main screen, or transferred over to be saved
    in the database. We start with the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`service`时，实际上我们不必在名称后面添加`service`，因为这个命令会自动为我们添加。为了看到这是如何工作的，我们将创建一个`service`，它接受使用文件选择器选择的文件，然后读取它，以便可以在图像上传对话框和主屏幕上显示，或者传输到数据库中保存。我们从以下命令开始：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I like to generate my services in a `Services` sub-folder. Putting this in the
    filename creates it in the `Services` folder.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在`Services`子文件夹中生成我的`services`。将其放在文件名中会在`Services`文件夹中创建它。
- en: 'The `ng generate service` command gives us the following basic outline:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng generate service`命令给我们提供了以下基本概述：'
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Reading a file can be a time-consuming process, so we know that we want this
    operation to happen asynchronously. As we discussed in earlier chapters, we could
    do this with a callback, but a much better method is to use a promise. We add
    the following method call to the service:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件可能是一个耗时的过程，所以我们知道我们希望这个操作是异步发生的。正如我们在前面的章节中讨论的，我们可以使用回调来做到这一点，但更好的方法是使用`Promise`。我们将以下方法调用添加到`service`中：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As this is the point at which we are going to read the file in, this is when
    we are going to create the model that we are going to use to pass the data around
    our application. The model that we are going to use looks like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是我们要读取文件的时候，这是我们要创建模型的时候，我们将使用它来传递数据到我们的应用程序。我们将要使用的模型看起来像这样：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Image` holds the actual image that we are going to read in, and `Name` is
    the name of the file. This is why we populate this model at this point; we are
    working with the file itself so this is the point at which we have the filename
    available to us. The `Description` and `Tags` strings will be added by the image
    upload component. While we could create an intersection type at that point, for
    a simple model like this, it is enough to have a single model hold them.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image`保存我们要读取的实际图像，`Name`是文件的名称。这就是为什么我们在这一点上填充这个模型；我们正在处理文件本身，所以这是我们拥有文件名的时候。`Description`和`Tags`字符串将由图像上传组件添加。虽然我们可以在那时创建一个交集类型，但对于一个简单的模型来说，有一个单一的模型来保存它们就足够了。'
- en: 'The fact that we have said that we are using `Promise` means that we need to
    `retu``rn` an appropriate `Promise` from our `Preview` method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过我们使用`Promise`，这意味着我们需要从我们的`Preview`方法中`retu`rn一个适当的`Promise`：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Inside the `Promise`, we are going to create an instance of our model. As it
    is good practice, we are going to add some defensive code to ensure that we have
    an image file. If the file is not an image file, we are going to reject it, which
    can be handled gracefully by the calling code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Promise`内部，我们将创建我们模型的一个实例。作为良好的实践，我们将添加一些防御性代码，以确保我们有一个图像文件。如果文件不是图像文件，我们将拒绝它，这可以由调用代码优雅地处理：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we reach this point, we know that we have a valid file, so we are going
    to set the name in the model using the filename, as well as using `FileReader`
    to read the image using `readAsDataURL`. When the read finishes, the `onload`
    event is raised, allowing us to add the image data to our model. At this point,
    we can resolve our promise:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达这一点时，我们知道我们有一个有效的文件，所以我们将使用文件名在模型中设置名称，并使用`FileReader`使用`readAsDataURL`读取图像。当读取完成时，将触发`onload`事件，允许我们将图像数据添加到我们的模型中。此时，我们可以解决我们的承诺：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using the service in the dialog
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在对话框中使用服务
- en: 'Now that we have a working `preview` service, we can use it in our dialog.
    In order to use it, we are going to pass it into our constructor. As the service
    is injectable, we can let Angular take care of injecting it for us as long as
    we add an appropriate reference in our constructor. At the same time, we are going
    to add in a reference to the dialog itself, as well as a set of declarations that
    will be used in the corresponding HTML template:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的`preview`服务，我们可以在我们的对话框中使用它。为了使用它，我们将把它传递到我们的构造函数中。由于服务是可注入的，我们可以让Angular负责为我们注入它，只要我们在构造函数中添加一个适当的引用。同时，我们还将在对话框本身中添加一个引用，以及一组将在相应HTML模板中使用的声明：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The technique that allows Angular to automatically build up constructors with
    dependencies, without us having to explicitly instantiate them with `new`, is
    known as dependency injection. This fancy term simply means that we tell Angular
    what our class needs and leave the building of the objects for that class to Angular.
    In effect, we tell Angular *what* we need without worrying about *how* it will
    be built. The act of building the classes can lead to very complex internal hierarchies,
    as the dependency injection engine may have to build up classes that our code
    relies on as well.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 允许Angular自动构建具有依赖关系的构造函数，而无需我们明确使用`new`实例化它们的技术称为依赖注入。这个花哨的术语简单地意味着我们告诉Angular我们的类需要什么，然后让Angular来构建那个类的对象。实际上，我们告诉Angular我们需要什么，而不用担心它将如何构建。构建类的行为可能导致非常复杂的内部层次结构，因为依赖注入引擎可能不得不构建我们的代码依赖的类。
- en: 'With this reference in place, we are going to create a method to accept the
    file selection from the file upload component and call our `Preview` method. `catch`
    is in place to cater for our defensive coding in the service, as well as to cater
    for situations where the user tries to upload a non-image file. If the file is
    invalid, the dialog will show a message informing the user of this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个参考，我们将创建一个方法来接受文件上传组件的文件选择并调用我们的`Preview`方法。`catch`用于适应我们在服务中的防御性编码，以及适应用户尝试上传非图像文件的情况。如果文件无效，对话框将显示一条消息通知用户：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The last thing we need to do with the code side of the dialog is to allow the
    user to close the dialog and pass the selected values back to the calling code.
    We update the image source description and tags with the relevant local values.
    The `close` method closes the current dialog and returns `imageSource` back to
    the calling code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框的代码部分的最后一件事是允许用户关闭对话框并将选定的值传回到调用代码。我们使用相关的本地值更新图像源描述和标签。`close`方法关闭当前对话框并将`imageSource`返回给调用代码：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The file upload component template
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件上传组件模板
- en: 'The final bit of work on our component is the actual HTML template in `fileupload.component.html`.
    As this is going to be a Material dialog, we are going to use a number of Material
    tags here. The simplest of these tags is used to add the dialog title, which is
    a standard header tag with the `mat-dialog-title` attribute. The reason that this
    attribute is used is to anchor the title to the top of the dialog so that if there
    was any scrolling, the title would stay fixed in place:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件的最后一部分工作是`fileupload.component.html`中的实际HTML模板。由于这将是一个Material对话框，我们将在这里使用许多Material标签。其中最简单的标签用于添加对话框标题，这是一个带有`mat-dialog-title`属性的标准标题标签。使用此属性的原因是将标题锚定在对话框顶部，以便如果有任何滚动，标题将保持固定在原位：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the title anchored to the top, we are ready to add our content and action
    buttons. First, we are going to add our content using the `mat-dialog-content`
    tag:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将标题锚定在顶部后，我们准备添加内容和操作按钮。首先，我们将使用`mat-dialog-content`标签添加内容：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first element inside our content is the message that will be displayed
    if the message in the code for the component is set. The test to show whether
    or not the message is displayed uses another Angular binding, `*ngIf`. Here, the
    Angular binding engine evaluates the expression and renders out the value if the
    expression is true. In this case, it''s checking to see whether a message is present.
    It''s probably not going to come as a surprise to learn that the funny-looking `{{}}`
    code is also a binding. This one is used to write out the text of the item being
    bound to, in this case the message:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们内容中的第一个元素是如果组件代码中设置了消息，则将显示的消息。用于显示消息是否显示的测试使用另一个Angular绑定`*ngIf`。在这里，Angular绑定引擎评估表达式，并在表达式为真时呈现出值。在这种情况下，它正在检查消息是否存在。也许不会让人惊讶的是，看起来有趣的`{{}}`代码也是一个绑定。这个用于写出被绑定的项目的文本，这种情况下是消息：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next part of the change is one of my favorite parts of the application.
    There is no Material version of the standard HTML file component, so if we want
    to display a modern-looking equivalent, we have to show the file input as a hidden
    component and trick it into thinking it has been activated when the user presses
    a Material button. The file upload input is given the `fileUpload` ID and triggered
    when the button is clicked using `(click)="fileUpload.click()"`. When the user
    chooses something, the change event triggers the `OnImageSelected` code we wrote
    a couple of minutes ago:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 变化的下一部分是我最喜欢的应用程序的一部分。标准HTML文件组件没有Material版本，因此如果我们想显示一个现代外观的等效组件，我们必须将文件输入显示为隐藏组件，并欺骗它认为在用户按下Material按钮时已被激活。文件上传输入被赋予`fileUpload`ID，并在按钮被点击时使用`(click)="fileUpload.click()"`触发。当用户选择某物时，更改事件触发我们几分钟前编写的`OnImageSelected`代码：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Adding an image preview is as simple as adding an `img` tag that is bound to
    the preview image created when we successfully read in the image:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 添加图像预览就像添加一个绑定到成功读取图像时创建的预览图像的`img`标签一样简单：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we need to add in fields for reading in the tags and description.
    We lay these out inside the `mat-form-field` sections. `matInput` tells the template
    engine what styling should be put in place for text input. The most interesting
    part is the use of the `[(ngModel)]="..."` part. This applies model binding for
    us, telling the binding engine what field to use from our underlying TypeScript
    component code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加用于读取标签和描述的字段。我们将这些放在`mat-form-field`部分内。`matInput`告诉模板引擎应该放置什么样式以用于文本输入。最有趣的部分是使用`[(ngModel)]="..."`部分。这为我们应用了模型绑定，告诉绑定引擎从我们的底层TypeScript组件代码中使用哪个字段：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you have previously used an earlier version of Angular (prior to version
    6), you have probably come across `formControlName` as a means of binding to values.
    In Angular 6+, trying to combine `formControlName` and `ngModel` no longer works.
    See [https://next.angular.io/api/forms/FormControlName#use-with-ngmodel](https://next.angular.io/api/forms/FormControlName#use-with-ngmodel)
    for more information.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前使用过早期版本的Angular（6版之前），您可能已经遇到`formControlName`作为绑定值的一种方式。在Angular 6+中，尝试结合`formControlName`和`ngModel`不再起作用。有关更多信息，请参见[https://next.angular.io/api/forms/FormControlName#use-with-ngmodel](https://next.angular.io/api/forms/FormControlName#use-with-ngmodel)。
- en: 'There is a touch of styling that needs to be associated with `mat-form-field`.
    In the `fileupload.component.scss` file, we add `.mat-form-field { display: block;
    }` to style the field so that it appears on a new line. If we miss this out, the
    input fields appear side by side.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`mat-form-field`需要关联一些样式。在`fileupload.component.scss`文件中，我们添加`.mat-form-field
    { display: block; }`来对字段进行样式设置，使其显示在新行上。如果我们忽略这一点，输入字段将并排显示。'
- en: 'It''s no good having a dialog that we cannot close, or that cannot return values
    back to the calling code. The convention that we should follow for such operations
    is to put our Save and Cancel buttons inside a `mat-dialog-actions` section. The
    Cancel button is marked with `mat-dialog-close` so that it closes the dialog for
    us without us having to take any actions. The Save button follows the pattern
    that we should be familiar with by now, and calls the `Save` method in our component
    code when the button click is detected:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个对话框我们无法关闭，或者无法将值返回给调用代码是没有意义的。我们应该遵循这样的操作约定，将我们的保存和取消按钮放在`mat-dialog-actions`部分。取消按钮标记为`mat-dialog-close`，这样它就会为我们关闭对话框，而无需我们采取任何操作。保存按钮遵循我们现在应该熟悉的模式，当检测到按钮点击时，在我们的组件代码中调用`Save`方法：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have reached the point where we need to consider where we are going to store
    the images when they have been selected by the user, and where they are going
    to be retrieved from. In the previous chapter, we used a client-side database
    to store our data. From now on, we are going to work with server-side code as
    well. Our data is going to be stored in a MongoDB database, so we now need to
    look at how to use Node.js and Express to connect to the MongoDB database.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到了需要考虑用户选择的图像将存储在何处以及将从何处检索的地步。在上一章中，我们使用了客户端数据库来存储我们的数据。从现在开始，我们将开始处理服务器端代码。我们的数据将存储在一个MongoDB数据库中，所以现在我们需要看看如何使用Node.js和Express来连接MongoDB数据库。
- en: Introducing Express support into our application
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入Express支持到我们的应用程序
- en: When we develop client/server applications with Node.js, it makes our lives
    a lot easier if we can use a framework that allows us to develop the server-side
    part, especially if it comes with a rich ecosystem of *add-in* functionality to
    cover features such as connecting to databases and working with the local filesystem.
    This is where Express comes into play; it's a middleware framework that fits neatly
    alongside Node.js.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Node.js开发客户端/服务器应用程序时，如果我们能够使用一个允许我们开发服务器端部分的框架，尤其是如果它带有丰富的*插件*功能生态系统，覆盖诸如连接到数据库和处理本地文件系统等功能，那将会让我们的生活变得更加轻松。这就是Express发挥作用的地方；它是一个中间件框架，与Node.js完美地配合在一起。
- en: 'As we are going to create our server-side code completely from scratch, we
    should start off by creating the base `tsconfig.json` and `package.json` files.
    To do this, run the following commands in the `Server` folder, which will also
    add Express support by importing the Express and TypeScript Express definitions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将完全从头开始创建我们的服务器端代码，我们应该从创建基本的`tsconfig.json`和`package.json`文件开始。为此，在`Server`文件夹中运行以下命令，这也将通过导入Express和TypeScript
    Express定义来添加Express支持：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There are a number of unnecessary options in our `tsconfig.json` file. We only
    need the bare minimum of options, so we set our configuration to look like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`tsconfig.json`文件中有许多不必要的选项。我们只需要最基本的选项，所以我们将我们的配置设置为如下所示：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our server-side code is going to start with a class called `Server`. This class
    is going to `import express`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器端代码将以一个名为`Server`的类开始。这个类将`import express`：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In order to create an instance of the Express application, we are going to create
    a private instance called `app` and set it to `express()` in the constructor.
    This has the effect of initializing the Express framework for us.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个Express应用程序的实例，我们将在构造函数中创建一个名为`app`的私有实例，并将其设置为`express()`。这样做的效果是为我们初始化Express框架。
- en: 'The constructor also accepts a port number, which we will use when we tell
    our application to listen in our `Start` method. Obviously, we need to respond
    to web requests, so when our app receives a `get` request from `/`, we are going
    to respond by using `send` to send a message back to the web page. In our example,
    if we navigate to `http://localhost:3000/`, the web page URL that this method
    receives is the root and the function that is called returns `Hello from the server`
    back to the client. If we browse to anything other than `/`, our server will respond
    with `404`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数还接受一个端口号，我们将在`Start`方法中告诉我们的应用程序监听这个端口。显然，我们需要响应web请求，所以当我们的应用程序从`/`接收到一个`get`请求时，我们将使用`send`来向网页发送一条消息作为响应。在我们的例子中，如果我们导航到`http://localhost:3000/`，这个方法接收到的网页URL是根目录，调用的函数返回`Hello
    from the server`给客户端。如果我们浏览的不是`/`，我们的服务器将会响应`404`：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To start our server, we must give it the port that we want to serve the content
    from and call `Start`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的服务器，我们必须给它要提供内容的端口，并调用`Start`：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The reason that we have started off with a `Server` class, rather than following
    the approach of most Node.js/Express tutorials we see on the internet, is that
    we are looking to build the foundations of something that we will be able to re-use
    in future chapters. This chapter represents a starting point for this class, as
    future chapters will take what we have done here and grow the capabilities of
    the server.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以从`Server`类开始，而不是遵循大多数Node.js/Express教程在互联网上看到的方法，是因为我们希望构建一些基础，以便在未来的章节中能够重复使用。这一章代表了这个类的起点，未来的章节将会在我们这里所做的基础上增强服务器的功能。
- en: In its current state, the server will not be able to handle any incoming requests
    from Angular. It's time to start enhancing the server so that it can cope with
    requests that come across from the client. When the client sends its data, it
    will come across as a JSON-formatted request. This means that we need to tell
    the server to take the request and expose it in the body of any request we see.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，服务器将无法处理来自Angular的任何传入请求。现在是时候开始增强服务器，以便它能够处理来自客户端的请求。当客户端发送其数据时，它将以JSON格式的请求传递过来。这意味着我们需要告诉服务器接收请求，并在我们看到的任何请求的主体中公开它。
- en: 'When we cover routing, shortly, we will see an example of us taking in the
    `request.Body` in its entirety. Something that we have to be aware of is that
    we will receive large requests from Angular; photographs can take up a lot of
    space. By default, the body parser has a limit of 100 KB, which won''t be large
    enough. We are going to raise the limit for the size of requests to 100 MB, which
    should be more than enough for any image we care to throw at our picture gallery:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们很快涵盖路由时，我们将看到一个例子，我们将完整地接收`request.Body`。我们必须意识到的一件事是，我们将从Angular接收大量请求；照片可能占用大量空间。默认情况下，body解析器的限制为100
    KB，这不够大。我们将提高请求大小的限制为100 MB，这应该足够处理我们想要放在图片库中的任何图像：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that we are talking about the data that is going to come across from Angular,
    we need to think about whether or not our application will accept the requests.
    Before we get into the topic of how our server will know which operation to perform
    based on which request, we need to address the issue of something called **Cross-Origin
    Request Sharing** (**CORS**).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在讨论从Angular传递过来的数据，我们需要考虑我们的应用程序是否接受这些请求。在我们讨论服务器如何根据请求执行哪些操作之前，我们需要解决一个叫做**跨域请求共享**（**CORS**）的问题。
- en: 'With CORS, we let known outside locations have access to restricted operations
    on our site. As Angular is running from a different site to our web server (`localhost:4200`
    as opposed to `localhost:3000`), we need to enable CORS support to post; otherwise,
    we will not return anything when we make requests from Angular. The first thing
    we have to do is add the `cors` middleware to our Node.js server:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CORS，我们允许已知的外部位置访问我们站点上的受限操作。由于Angular是从与我们的Web服务器不同的站点运行的（`localhost:4200`而不是`localhost:3000`），我们需要启用CORS支持以进行post；否则，当我们从Angular发出请求时，我们将不返回任何内容。我们必须做的第一件事是将`cors`中间件添加到我们的Node.js服务器中：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Adding CORS support is as simple as telling the application to use CORS:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 添加CORS支持就像告诉应用程序使用CORS一样简单：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: CORS support provides a lot of fine-tuning that we don't need to take advantage
    of. For instance, it allows us to set the types of request methods that we are
    allowing, using `Access-Control-Allow-Methods`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: CORS支持提供了许多我们不需要利用的微调。例如，它允许我们设置允许的请求方法类型，使用`Access-Control-Allow-Methods`。
- en: Now that we can accept requests from Angular, we need to put the mechanism in
    place to route requests to appropriate request handlers.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以接受来自Angular的请求，我们需要建立机制将请求路由到适当的请求处理程序。
- en: Providing routing support
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供路由支持
- en: 'Whenever a request comes into our web server, we have to determine what response
    we want to send back. What we are building is going to respond to post and receive
    requests, which is similar to the way we build REST APIs. The ability to route
    incoming requests to responses is known as routing. Our application is going to
    handle three types of request:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每当请求进入我们的Web服务器时，我们都必须确定要发送的响应。我们正在构建的东西将响应post和接收请求，这类似于我们构建REST API的方式。将传入请求路由到响应的能力称为路由。我们的应用程序将处理三种类型的请求：
- en: A `POST` request with `add` as the URL (in other words, when we see `http://localhost:3000/add/`).
    This will add an image and the associated details to the database.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在URL中带有“add”作为URL的`POST`请求（换句话说，当我们看到`http://localhost:3000/add/`时）。这将向数据库添加图像和相关详细信息。
- en: A `GET` request with `get` in the URL (as in `http://localhost:3000/get/`).
    This gets the IDs of all the saved pictures and returns an array of these IDs
    back to the caller.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在URL中带有“get”的`GET`请求（如`http://localhost:3000/get/`）。这获取所有保存的图片的ID，并将这些ID的数组返回给调用者。
- en: A `GET` request with `/id/` in the URL. This uses an additional parameter in
    the URL to get the ID of the individual picture to send back to the client.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在URL中带有“/id/”的`GET`请求。这在URL中使用了一个额外的参数来获取要发送回客户端的单个图片的ID。
- en: The reason that we are returning an array of IDs is that an individual image
    can be large. If we were to attempt to return all the images in one go, we would
    slow down the displaying of the images at the client side as they can be displayed
    as each one is being loaded. We could also breach the limits of how big the response
    we are passing back can be. In the case of large chunks of data, it's always worth
    looking to see how we can minimize what we are transmitting with each request.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回ID数组的原因是单个图像可能很大。如果我们尝试一次返回所有图像，我们将减慢客户端显示图像的速度，因为它们可以在加载时显示。我们还可能违反我们传回的响应的大小限制。在处理大块数据时，值得看看如何最小化每个请求传输的内容。
- en: 'The destination of each request corresponds to a unique action that we want
    to take. This gives us a hint that we should be able to split each route into
    a single class that does nothing but service that action. To enforce the single
    action, we define the interface that we want our routing classes to use:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求的目的对应于我们要执行的唯一操作。这给了我们一个提示，我们应该能够将每个路由拆分为一个什么都不做的单个类。为了强制执行单个操作，我们定义了我们希望我们的路由类使用的接口：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We are going to add a helper class that will be responsible for instantiating
    each router instance. The class starts off simply enough, creating an `IRouter`
    array that the route instances will be added into:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个辅助类，负责实例化每个路由器实例。该类开始得足够简单，创建一个`IRouter`数组，将路由实例添加到其中：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Things get interesting with the method that we use to add the instances in.
    What we are going to do is accept a generic type as a parameter and instantiate
    the type. To do this, we must take advantage of a TypeScript feature that allows
    us to accept a generic type and specify that when `new` is called on it, it returns
    an instance of the type.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的方法让实例添加变得有趣。我们要做的是接受一个通用类型作为参数，并实例化该类型。为此，我们必须利用TypeScript的一个特性，允许我们接受一个通用类型，并指定当对其调用`new`时，它返回该类型的实例。
- en: 'As we have specified a generic constraint on our type, we will only accept
    `IRouter` implementations:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在类型上指定了通用约束，我们只接受`IRouter`实现：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The route that is passed into the method comes from Express. It's the router
    instance that we tell our application to use.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给该方法的路由来自Express。 这是我们告诉我们的应用程序使用的路由器实例。
- en: 'Now that we have our routing support in place, we need to write the classes
    that correspond with the route requests we identified previously. The first one
    that we are going to look at is the class that accepts the `add` post:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在路由支持中就位，我们需要编写与我们之前确定的路由请求对应的类。 我们要查看的第一个是接受`add` post的类：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method works by stating that when we receive an `/add/` post, we will take
    the request, process it, and send a response back. What we do with the request
    is up to us, but whenever the routing determines that we have a match here, we
    will execute this method. In this method, we are going to create a server-side
    representation of the picture and save it to the database.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过声明当我们收到一个`/add/` post时，我们将接受请求，处理它，并发送响应回来来工作。 我们如何处理请求取决于我们，但无论路由何时确定我们在这里有匹配项，我们将执行此方法。
    在此方法中，我们将创建图片的服务器端表示并将其保存到数据库中。
- en: For the purposes of this application, we have only introduced Express routing.
    Angular has its own routing engine, but for the purposes of what we wanted to
    put in place in our code, we have no need for it. In [Chapter 5](05f23d63-20d8-4d72-97af-042e8a5a3864.xhtml),
    *Angular ToDo App with GraphQL and Apollo*, we introduce Angular routing.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们只引入了Express路由。 Angular有自己的路由引擎，但就我们想要在我们的代码中放置的内容而言，我们不需要它。 在[第5章](05f23d63-20d8-4d72-97af-042e8a5a3864.xhtml)中，*使用GraphQL和Apollo的Angular
    ToDo应用程序*，我们介绍了Angular路由。
- en: Introducing MongoDB
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍MongoDB
- en: 'Working with MongoDB requires us to use something such as the popular Mongoose
    package. Installing Mongoose requires us to add both the `mongoose` and `@types/mongoose`
    packages:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB需要我们使用诸如流行的Mongoose包之类的东西。 安装Mongoose需要我们添加`mongoose`和`@types/mongoose`包：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Before we do anything with our database, we need to create a schema to represent
    the object that we want to save to the database. Unfortunately, this is where
    things can become a little bit tedious when we are developing applications using
    MEAN. While the schema superficially represents the model that we created on the
    Angular side, it is not the same model, so we have to type it in again.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对数据库进行任何操作之前，我们需要创建一个模式来表示我们要保存到数据库中的对象。 不幸的是，这就是当我们使用MEAN开发应用程序时事情可能变得有点乏味的地方。
    虽然模式表面上代表了我们在Angular端创建的模型，但它不是相同的模型，因此我们必须再次输入它。
- en: 'More importantly, this means that if we change our Angular model, we have to
    regenerate our MongoDB schema to go hand in hand with the changes:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，这意味着如果我们更改我们的Angular模型，我们必须重新生成我们的MongoDB模式以与更改相适应。
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For the purposes of our application, we are going to keep the image in the database—in
    the `Image` field—because this simplifies the infrastructure we have to put in
    place. In commercial-grade applications, we would choose to store the actual image
    separate to the database and the `Image` field would point to the physical location
    of the image. The location of the image would have to be accessible to our web
    application, and there would be policies in place to ensure that the images were
    safely backed up and could be easily restored.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将保留数据库中的图像—在`Image`字段中—因为这简化了我们必须放置的基础设施。 在商业级应用程序中，我们将选择将实际图像存储到数据库之外，并且`Image`字段将指向图像的物理位置。
    图像的位置必须对我们的Web应用程序可访问，并且必须有政策确保图像得到安全备份并且可以轻松恢复。
- en: 'With the schema in place, we want to create a model that represents it. A good
    way to think about the interaction between the model and the schema is that the
    schema tells us *what* we want our data to look like. The model tells us *how*
    we want to manipulate it with the database:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有了模式，我们想创建一个代表它的模型。 想象一下模型和模式之间的交互的一个好方法是，模式告诉我们我们的数据应该是什么样子。 模型告诉我们我们想要如何使用数据库来操作它：
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now that we have the model ready, we need something to establish a connection
    to the database. The connection string for the MongoDB database has its own protocol,
    so it starts with the `mongodb://` pattern. For the purposes of our application,
    we are going to have MongoDB running on the same server as our server-side code;
    for larger applications, we really would want to separate these out, but for now,
    we are going to use `localhost:27017` in the connection string as MongoDB is listening
    on port `27017`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好模型，我们需要建立与数据库的连接。 MongoDB数据库的连接字符串有自己的协议，因此它以`mongodb://`模式开头。 对于我们的应用程序，我们将使MongoDB在与我们的服务器端代码相同的服务器上运行；
    对于更大的应用程序，我们确实希望将它们分开，但现在，我们将在连接字符串中使用`localhost:27017`，因为MongoDB正在侦听端口`27017`。
- en: 'As we want to be able to host many databases in MongoDB, the mechanism to tell
    the engine what database to use will supply a database name as part of the connection
    string. If the database doesn''t exist, it will be created. For our application,
    our database is going to be called `packt_atp_chapter_04`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望能够在MongoDB中托管许多数据库，因此告诉引擎要使用哪个数据库的机制将作为连接字符串的一部分提供数据库名称。 如果数据库不存在，它将被创建。
    对于我们的应用程序，我们的数据库将被称为`packt_atp_chapter_04`：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As long as `Connect` is called before we attempt to do anything inside the database,
    our database should be available for us to use. Internally, `Connect` calls `mongoose.connect`
    using our connection string.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 只要在我们尝试在数据库内部执行任何操作之前调用`Connect`，我们的数据库应该可供我们使用。 在内部，`Connect`使用我们的连接字符串调用`mongoose.connect`。
- en: Back to our routing
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到我们的路由
- en: 'With the `Picture` model available to us, we can populate it directly from
    inside our `add` route. The request body contains the same parameters as our schema,
    so the mapping is invisible to us. When it has been populated, we call the `save`
    method. If there''s an error, we will send this back to the client; otherwise,
    we are going to send the picture back to the client:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有了可用的`Picture`模型，我们可以直接从我们的`add`路由内部填充它。请求体包含与我们的模式相同的参数，因此对我们来说映射是不可见的。当它被填充后，我们调用`save`方法。如果有错误，我们将把错误发送回客户端；否则，我们将把图片发送回客户端：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In production applications, we wouldn't really want to send the error back to
    the client as that exposes the inner workings of our application. With a small
    application, intended for our own use only, it is less of an issue and it is a
    useful way to determine what has gone wrong with our application because we can
    simply view the error in the browser console window. Professionally, I would recommend
    sanitizing the error and sending one of the standard HTTP responses back instead.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产应用程序中，我们实际上不希望将错误发送回客户端，因为这会暴露我们应用程序的内部工作。对于一个小型应用程序，仅用于我们自己使用，这不是一个问题，这是一种确定我们应用程序出了什么问题的有用方式，因为我们可以简单地在浏览器控制台窗口中查看错误。从专业角度来看，我建议对错误进行消毒，并发送一个标准的HTTP响应之一。
- en: 'The handler for `get` requests is no more complicated. It starts off in a similar
    fashion to the `add` router:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`请求的处理程序并不复杂。它以与`add`路由类似的方式开始：'
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `Request` and `Response` types in our routes come from Express, so they
    should be added as `imports` in the class.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Request`和`Response`类型在我们的路由中来自Express，因此它们应该作为类中的`imports`添加。'
- en: 'What we are trying to do with this call is get the unique list of pictures
    the user has uploaded. Internally, each schema adds an `_id` field, so we are
    going to use the `Picture.distinct` method to get the full list of these IDs,
    which we are then going to send back to the client code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图做的是获取用户上传的图片的唯一列表。在内部，每个模式都添加了一个`_id`字段，因此我们将使用`Picture.distinct`方法来获取这些ID的完整列表，然后将其发送回客户端代码：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The last router that we need to put in place takes an individual ID request
    and retrieves the related item from the database. What makes this class slightly
    more complicated than the preceding ones is that we need to manipulate the schema
    slightly to exclude the `_id` field before we transmit the data back to the client.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要放置的最后一个路由是获取单个ID请求并从数据库中检索相关项目。使这个类比前面的类稍微复杂的是，我们需要稍微操纵模式以在将数据传输回客户端之前排除`_id`字段。
- en: 'If we didn''t remove this field, the data our client would receive wouldn''t
    match the type that it was expecting, so it wouldn''t be able to automatically
    populate an instance. This would result in our client not displaying this data
    even though it received it back unless we manually populated it at the client
    side:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有删除这个字段，我们的客户端将收到的数据将无法匹配它所期望的类型，因此它将无法自动填充一个实例。这将导致我们的客户端即使收到了数据，也不会显示这些数据，除非我们在客户端手动填充它：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The syntax with `:id` tells us that we are going to receive a parameter called
    `id` here. The request exposes a `params` object, which will expose this parameter
    as `id`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`:id`的语法告诉我们，我们将在这里接收一个名为`id`的参数。请求公开了一个`params`对象，该对象将把此参数公开为`id`。
- en: 'We know that the `id` parameter we have received is unique so we can use the
    `Picture.findOne` method to retrieve the matching entry from the database. In
    order to exclude the `_id` field from the result we are going to send back to
    the client, we must use `-_id` in the parameters to remove this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们收到的`id`参数是唯一的，因此我们可以使用`Picture.findOne`方法从数据库中检索匹配的条目。为了在发送回客户端的结果中排除`_id`字段，我们必须在参数中使用`-_id`来删除它：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `Server` class needs a little bit of extra attention at this point. We have
    created the `RoutingEngine` and `Mongo` classes, but there is nothing in the `Server` class
    to hook them up. This is easily sorted by extending the constructor to add instances
    of them. We also need to add a call to `Start` to `connect` to the database. If
    we changed our `Server` class to an abstract class and added an `AddRouting` method,
    we would stop anyone from directly instantiating the server.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`Server`类需要额外的关注。我们已经创建了`RoutingEngine`和`Mongo`类，但在`Server`类中没有任何东西来连接它们。通过扩展构造函数来添加它们的实例，这很容易解决。我们还需要添加一个调用`Start`来`connect`到数据库。如果我们将我们的`Server`类更改为抽象类，并添加一个`AddRouting`方法，我们将阻止任何人直接实例化服务器。
- en: 'Our applications will need to derive from this class and add their own routing
    implementations using the `RoutingEngine` class. This is the first step to breaking
    the server into smaller discrete units that separate out the responsibilities.
    One of the big changes in the `Start` method is that, once we have added our routing,
    we tell the application to use the same `express.Router()` that our routing engine
    is using, so any requests are then automatically hooked up:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将需要从这个类派生，并使用`RoutingEngine`类添加他们自己的路由实现。这是将服务器分解为更小的离散单元并分离责任的第一步。`Start`方法中的一个重大变化是，一旦我们添加了我们的路由，我们告诉应用程序使用与我们的路由引擎相同的`express.Router()`，因此任何请求都会自动连接起来：
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With this in place, we can now create a concrete class that extends our `Server`
    class and adds the routers that we have created. This is the class that we will
    start when we run our application:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在可以创建一个具体的类，该类扩展了我们的`Server`类，并添加了我们创建的路由。这是我们运行应用程序时将启动的类：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Don't forget to remove the original call to start the `new Server(3000).Start();` server.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记删除原始调用以启动`new Server(3000).Start();`服务器。
- en: Our server-side code is finished. We aren't going to add any more features to
    it, so we can get back to the client-side code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器端代码已经完成。我们不打算为其添加更多功能，因此我们可以回到客户端代码。
- en: Displaying images
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示图片
- en: 'After all our hard work writing the server-side code and letting the user choose
    what image they want to upload, we need something to actually show the images.
    We are going to create a `PageBody` component, which we will display and add as
    an element inside our main navigation. Again, we''re going to let Angular do the
    hard work and create the infrastructure for us:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们辛苦编写了服务器端代码并让用户选择要上传的图片之后，我们需要一些东西来实际显示这些图片。我们将创建一个`PageBody`组件，将其显示并添加为主导航中的一个元素。同样，我们将让Angular来完成这项艰苦的工作，并为我们创建基础设施。
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With this component created, we''re going to update `app.component.html` with
    the `PageBody` component as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了这个组件后，我们将按以下方式更新`app.component.html`，添加`PageBody`组件：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When we installed Material support, one of the features we added was Flex Layout,
    which provides flexible layout support for Angular. We are going to take advantage
    of this in our application by setting the cards to lay out, initially in rows
    of three, wrapping to the next line when we need to. Internally, the layout engine
    uses **Flexbox** (a **flexible box**) to perform the layout.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们安装Material支持时，我们添加的一个功能是Flex布局，它为Angular提供了灵活的布局支持。我们将通过在我们的应用程序中设置卡片的布局，最初以每行三个的方式布置，并在需要时换行，来利用这一点。在内部，布局引擎使用Flexbox（一种灵活的盒子）来执行布局。
- en: 'The idea is that the engine can adjust widths and heights as it sees fit, in
    order to take advantage of screen real estate. This behavior should be familiar
    to you, from the way we set up Bootstrap, which adopted Flexbox. As Flexbox defaults
    to trying to lay items out on one line, we''re going to start by creating a `div` tag
    that alters the behavior to wrap along rows with a 1% space gap:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎可以根据需要调整宽度和高度，以充分利用屏幕空间。这种行为应该对您来说很熟悉，因为我们设置了Bootstrap，它采用了Flexbox。由于Flexbox默认尝试在一行上布置项目，因此我们将首先创建一个`div`标签，以改变其行为，使其在行之间包裹1%的空间间隙：
- en: '[PRE54]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With the layout container in place, we now need to set up the cards to hold
    the images and relevant details. As we could have a dynamic number of cards, we
    really hope that Angular has a means that allows us to define a card effectively
    as a template and add the individual elements inside. A card is added using `mat-card`,
    and with a little bit of Angular magic (okay, another bit of Angular binding),
    we can iterate over the pictures:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 布局容器就位后，我们现在需要设置卡片来容纳图片和相关细节。由于我们可能有动态数量的卡片，我们真的希望Angular有一种方法，允许我们有效地定义卡片作为模板，并在内部添加各个元素。使用`mat-card`添加卡片，并通过一点点的Angular魔法（好吧，又一点点的Angular绑定），我们可以对图片进行迭代：
- en: '[PRE55]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'What this section is doing is setting up our card using `ngFor`, which is an
    Angular directive that iterates over an underlying array, `Pictures` in this case,
    and is effective for creating a variable that we can use in the body of our card.
    With this, we are going to add a card title that binds to `picture.Name`, and
    an image that binds the source to `picture.Image`. Finally, we are going to display `picture.Description`
    below the image inside a paragraph:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的作用是使用`ngFor`设置我们的卡片，`ngFor`是一个Angular指令，它可以迭代底层数组，本例中是`Pictures`，并且对于创建我们卡片的主体中可以使用的变量非常有效。通过这个，我们将添加一个绑定到`picture.Name`的卡片标题，以及一个将源绑定到`picture.Image`的图像。最后，我们将在段落中显示`picture.Description`。
- en: '[PRE56]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For completeness, we have added a bit of styling to our `picture-card-layout`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们已经为我们的`picture-card-layout`添加了一些样式：
- en: '[PRE57]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It would be good to see what our card styling looks like in action:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们的卡片样式在实际中是什么样子：
- en: '![](assets/02d7a720-b84f-41a6-973c-6fdd95d4b614.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/02d7a720-b84f-41a6-973c-6fdd95d4b614.png)'
- en: 'That''s the HTML in place for our page body, but we need to put the code in
    the TypeScript behind this to actually start serving some of the data that our
    cards are going to bind to. In particular, we have to provide the `Pictures` array
    that we are going to populate:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们页面主体的HTML，但是我们需要在其背后的TypeScript中放置代码，以实际开始提供我们的卡片将绑定到的一些数据。特别是，我们必须提供我们将要填充的`Pictures`数组：
- en: '[PRE58]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We have a number of services here that we haven't encountered yet. We are going
    to start by looking at how our application knows when instances of `IPictureModel`
    have become available.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有许多我们尚未遇到的服务。我们将首先看一下我们的应用程序如何知道`IPictureModel`的实例何时可用。
- en: Using RxJS to watch for images
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RxJS来观察图片
- en: It's no good having our application be capable of choosing images through the
    dialog, or fetching them from the server during the load process, if we can't
    display them in the page body. As our application has features that are loosely
    related to each other, we don't want to introduce events as the mechanism for
    controlling when these happen, since this introduces tight coupling between things
    such as our page body component and the loading service.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法在页面主体中显示这些图片，那么通过对话框选择图片或在加载过程中从服务器获取图片的应用程序就没有意义。由于我们的应用程序具有彼此松散相关的功能，我们不希望引入事件作为控制这些功能发生的机制，因为这会在诸如页面主体组件和加载服务之间引入紧密耦合。
- en: What we need are services that sit between the code that handles the interaction
    (such as loading the data) and the page body, and passes notifications from one
    side to the other when something interesting has happened. The mechanism that
    Angular provides to do this is called **Reactive Extensions for JavaScript** (**RxJS**).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是位于处理交互代码（例如加载数据）和页面主体之间的服务，并在有趣的事情发生时从一侧传递通知到另一侧。Angular提供的执行此操作的机制称为**JavaScript的响应式扩展**（**RxJS**）。
- en: Reactive extensions are an implementation of something called the observer pattern
    (there's that word pattern again). This is a simple pattern to understand and
    you will have been using it for a while now, possibly without even recognizing
    it. The idea with the observer pattern is that we have a class that has something
    called a `Subject` type. Internally, this `Subject` type maintains a list of dependencies
    and, when it needs to do so, notifies those dependencies that they need to react,
    potentially passing the state over that they need to react to.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式扩展是观察者模式的一种实现（又是那个模式词）。这是一个简单的模式，你会很容易理解，并且你可能已经使用它一段时间了，可能甚至没有意识到。观察者模式的想法是，我们有一个类，其中有一个叫做`Subject`的类型。在内部，这个`Subject`类型维护一个依赖项列表，当需要时，通知这些依赖项需要做出反应，可能传递它们需要做出反应的状态。
- en: This might ring a vague bell that this is precisely what events do, so why should
    we concern ourselves with this pattern? You would be correct in your understanding—events
    are just a very specialist form of the observer pattern, but they have some weaknesses
    that things such as RxJS are designed to overcome. Suppose we had a real-time
    stock trading application where we had tens of thousands of stock ticks coming
    to our client every second. Obviously, we wouldn't want our client to handle all
    of those ticks, so we would have to write code inside our event handlers to start
    filtering out notifications. That's a lot of code that we would have to write,
    which would potentially be duplicated across different events. There also has
    to be a tight relationship between classes when we use events, so one class has
    to know about another in order to hook up to an event.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让你模糊地想起这正是事件所做的事情，那么为什么我们要关注这个模式呢？你的理解是正确的——事件只是观察者模式的一个非常专业的形式，但它们有一些弱点，而RxJS等东西是设计来克服这些弱点的。假设我们有一个实时股票交易应用程序，每秒都有成千上万的股票行情到达我们的客户端。显然，我们不希望我们的客户端处理所有这些股票行情，因此我们必须编写代码在我们的事件处理程序内部开始过滤通知。这是我们必须编写的大量代码，可能会在不同的事件中重复。当我们使用事件时，类之间还必须有紧密的关系，因此一个类必须了解另一个类，以便连接到一个事件。
- en: As our applications get bigger and more complex, there could be a lot of *distance*
    between the class that brings in the stock tick and the one that displays it.
    Therefore, we would end up building a complex hierarchy of events, where `class
    A` listens to an event on `class B` and when `class B` raises that event, it has
    to re-raise it so that `class C` can react to it. The more distributed our code
    becomes internally, the less we want to encourage this tight coupling.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序变得越来越庞大和复杂，可能会有很多*距离*在带入股票行情的类和显示它的类之间。因此，我们最终会构建一个复杂的事件层次结构，其中`A类`监听`B类`上的事件，当`B类`引发该事件时，它必须重新引发它，以便`C类`可以对其做出反应。我们的代码内部分布得越多，我们就越不希望鼓励这种紧密耦合。
- en: With libraries such as RxJS, we solve these issues (and many more) by decoupling
    away from events. With RxJS, we can make sophisticated subscription mechanisms,
    where we can do things such as throttling the number of notifications we react
    to or choosing only to subscribe to data and changes where certain conditions
    are met. As new components are added at runtime, they can query the observable
    class to see what values are already available, in order to prepopulate the screen
    with data that has already been received. These features are more than we need
    in this application, but as we will use them in future chapters, it makes sense
    for us to be aware that they are available to us.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RxJS等库，我们通过远离事件来解决这些问题（以及更多）。使用RxJS，我们可以制定复杂的订阅机制，例如限制我们做出反应的通知数量或仅选择订阅满足特定条件的数据和更改。随着新组件在运行时添加，它们可以查询可观察类以查看已经可用的值，以便使用已经接收到的数据预填充屏幕。这些功能超出了我们在这个应用程序中所需的，但是由于我们将在未来的章节中使用它们，因此我们需要意识到它们对我们是可用的。
- en: 'Our application has two things we need to react to:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序有两件事需要做出反应：
- en: When the page is loaded, the images will be loaded from the server, so we need
    to react to each image being loaded in
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当页面加载时，图像将从服务器加载，因此我们需要对加载的每个图像做出反应。
- en: When the user chooses an image from the dialog, after the dialog has closed
    because the user chose Save, we need to trigger a save to the database, and also
    display the image on the page
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户从对话框中选择图像后，在用户选择保存后对话框关闭，我们需要触发对数据库的保存，并在页面上显示图像
- en: 'It''s probably not going to come as a surprise to learn that we are going to
    create services to satisfy these two requirements. As they both internally do
    the same thing, the only difference is what the subscriber needs to do once it
    reacts. We start off by creating a simple base class that these services will
    derive from:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 也许不会让人惊讶的是，我们将创建服务来满足这两个要求。因为它们在内部做的事情是一样的，唯一的区别是订阅者需要在做出反应后做什么。我们首先创建一个简单的基类，这些服务将从中派生：
- en: '[PRE59]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Our starting point in this class is to define the `Subject` that our observable
    will use. As we noted, there are different `Subject` specializations in RxJS.
    As we only want our `Subject` to notify other classes of the latest value, we
    are going to use `BehaviorSubject` and set the current value to `null`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个类中的起点是定义我们的可观察对象将使用的`Subject`。正如我们所指出的，RxJS中有不同的`Subject`专业化。由于我们只希望我们的`Subject`通知其他类最新的值，我们将使用`BehaviorSubject`并将当前值设置为`null`：
- en: '[PRE60]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We aren''t going to expose the `Subject` to external classes; instead, we are
    going to create a new observable with this subject as the source. We do this so
    that, if we wanted to, we could customize the subscription logic—the throttling
    issue being an example of why we might want to do this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会将`Subject`暴露给外部类；相反，我们将使用此主题创建一个新的可观察对象。我们这样做是为了，如果我们愿意，我们可以自定义订阅逻辑——限制问题就是我们可能想这样做的一个例子：
- en: '[PRE61]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We call this property the `context` property because it will carry the context
    of the change.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这种属性为`上下文`属性，因为它将携带变化的上下文。
- en: 'With this in place, external classes now have access to the observable source,
    so whenever we notify them that they need to react, they can. As the operation
    that we want to perform is based either on the user adding `IPictureModel`, or
    the data loading adding one, we are going to call the method that triggers the
    observable `add` chain. Our `add` method will receive the instance of the model
    that we want to send to our subscribing code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，外部类现在可以访问可观察源，因此每当我们通知它们需要做出反应时，它们可以。由于我们要执行的操作基于用户添加`IPictureModel`或数据加载添加一个，我们将调用触发可观察`add`链的方法。我们的`add`方法将接收我们要发送到订阅代码的模型实例：
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We identified that we needed two services to handle the different ways `IPictureModel`
    was received. The first service is called `AddImageService` and, as we would expect,
    can be generated for us by using Angular:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确定需要两个服务来处理接收`IPictureModel`的不同方式。第一个服务称为`AddImageService`，正如我们所期望的那样，可以通过使用Angular为我们生成：
- en: '[PRE63]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As we have already written the logic for our observable, our service simply
    looks like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经编写了我们的可观察逻辑，因此我们的服务看起来就像这样：
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Our second service is called `LoadImageService`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个服务称为`LoadImageService`：
- en: '[PRE65]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Again, this class is going to extend `ContextServiceBase`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个类将扩展`ContextServiceBase`：
- en: '[PRE66]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: At this point, you might be wondering why we have two services that appear to
    do the same thing. Theoretically, we could have had both do exactly the same thing.
    The reason that I chose to implement two versions comes back to understanding
    that one of the things that we want to do is display the image and trigger a save
    whenever we raise a notification through `AddImageService`. Suppose we also used `AddImageService`
    when the page was loaded. If we did this, then whenever the page was loaded, it
    would also trigger the save so we would end up duplicating images. Now, we could
    introduce filtering to prevent duplicates from happening, but I chose to keep
    things simple by using two separate classes for this first visit to RxJS. In the
    coming chapters, we will see how to make more complex subscriptions.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会想知道为什么我们有两个看起来做同样事情的服务。理论上，我们可以让它们都做完全相同的事情。我选择实现两个版本的原因是因为我们想要做的一件事是在通过`AddImageService`触发通知时显示图像并触发保存。假设我们在页面加载时也使用`AddImageService`。如果我们这样做，那么每当页面加载时，它也会触发保存，这样我们最终会复制图像。现在，我们可以引入过滤器来防止重复发生，但我选择使用两个单独的类来保持事情简单，因为这是我们第一次接触RxJS。在接下来的章节中，我们将看到如何进行更复杂的订阅。
- en: Transferring the data
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据传输
- en: 'We have covered one side of the client/server interaction. It''s now time for
    us to address the other side—the code that actually calls the routes that our
    server exposes. Not surprisingly, we add a service that takes care of this communication.
    We start with the code to create the service:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了客户端/服务器交互的一侧。现在是时候处理另一侧了——实际调用我们服务器暴露的路由的代码。毫不奇怪，我们添加了一个负责这种通信的服务。我们从创建服务的代码开始：
- en: '[PRE67]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Our service is going to make use of three things. The first thing that it will
    rely on is an `HttpClient` instance to manage the `get` and `post` operations.
    We also bring in the `AddImageService` and `LoadImageService` classes that we
    have just created:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务将利用三样东西。它将依赖于的第一件事是一个`HttpClient`实例来管理`get`和`post`操作。我们还引入了我们刚刚创建的`AddImageService`和`LoadImageService`类：
- en: '[PRE68]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The first point of contact between our server and client is the piece of code
    we are going to use when the user has chosen the image from the dialog. Once they
    have clicked Save, we are going to set off a chain of actions that results in
    the data being saved in the server. We are going to set up our HTTP header to
    set the content type to JSON:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器和客户端之间的第一个接触点是当用户从对话框中选择图像时我们将要使用的代码。一旦他们点击保存，我们将引发一系列操作，导致数据保存在服务器中。我们将设置我们的HTTP头部以将内容类型设置为JSON：
- en: '[PRE69]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Thinking back to our RxJS classes, we know that we have two separate subscriptions
    available to us. The one that we want to use here reacts when `AddImageService`
    is pushed out, so we are going to add this subscription to `SubscribeToAddImageContextChanges`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们的RxJS类，我们知道我们有两个可用的单独订阅。我们想在这里使用的是当`AddImageService`被推送出时做出反应的那个，因此我们将把这个订阅添加到`SubscribeToAddImageContextChanges`中：
- en: '[PRE70]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When we receive a message in this subscription, we are going to post it to
    the server, which will end up saving the data to the database:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这个订阅中收到消息时，我们将把它发送到服务器，这将最终保存数据到数据库中：
- en: '[PRE71]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The format of the post is to pass the endpoint address, which ties nicely back
    to the server-side code that we wrote earlier, along with the message and any
    HTTP options. Because our message content is semantically the same as the model
    that is received at the server side, it will automatically be decoded at that
    side. As we can receive content back from the server, we have a subscription that
    we can use to decode the messages coming back from our Express code base. When
    we put this code together, we end up with this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 发布的格式是传递端点地址，这与我们之前编写的服务器端代码很好地联系在一起，以及消息和任何HTTP选项。因为我们的消息内容在语义上与在服务器端接收的模型相同，所以它将自动在那一侧被解码。由于我们可以从服务器接收内容，我们有一个订阅可以用来解码从我们的Express代码库返回的消息。当我们将这些代码放在一起时，我们得到了这样的结果：
- en: '[PRE72]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The other side of our transfer service is responsible for getting the images
    back from the server. As you may remember from our Express code, we are going
    to receive the data in two stages. The first stage is that we will receive an
    array of IDs that match all the pictures available to us. To fetch this array,
    we call `get` on `HttpClient`, telling it that we are going to get an array of
    strings, by pointing to the `/get/` endpoint:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传输服务的另一侧负责从服务器获取图像。正如你可能还记得的，我们将在两个阶段接收数据。第一阶段是我们将接收一个与我们可用的所有图片匹配的ID数组。为了获取这个数组，我们在`HttpClient`上调用`get`，告诉它我们将获取一个字符串数组，指向`/get/`端点：
- en: '[PRE73]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now that we have the array of strings, we need to iterate over each element
    and call `get` again, this time adding `/id/...` to tell the server which one
    we are interested in. When the data comes back, we call the `add` method on `LoadImageService`,
    passing in `IPictureModel`. This ties back to our page body, as we will see shortly:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了字符串数组，我们需要遍历每个元素并再次调用`get`，这次添加`/id/...`来告诉服务器我们感兴趣的是哪一个。当数据返回时，我们调用`LoadImageService`上的`add`方法，传入`IPictureModel`。这与我们的页面主体有关，我们很快就会看到：
- en: '[PRE74]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, we are going to add an `Initialize` method, which we will use to initialize
    the service:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个`Initialize`方法，我们将用它来初始化服务：
- en: '[PRE75]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Back to the page body component
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到页面主体组件
- en: 'Now that we have `LoadImageService`, `AddImageService`, and `TransferDataService`
    written, we can use them in the `PageBodyComponent` initialization code in `ngOnInit`,
    which is called when the component is initializing. The first thing we need to
    do is affect is to call the `Initialize` function in `TransferDataService`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了`LoadImageService`，`AddImageService`和`TransferDataService`，我们可以在`PageBodyComponent`的初始化代码中使用它们，在`ngOnInit`中调用，这是在组件初始化时调用的。我们需要做的第一件事是调用`TransferDataService`中的`Initialize`函数：
- en: '[PRE76]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To finish off this component, and to actually populate the `Pictures` array,
    we need to hook up to the context for both of our RxJS services:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个组件，并实际填充`Pictures`数组，我们需要连接到我们的两个RxJS服务的上下文：
- en: '[PRE77]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Wrapping up by displaying the dialog
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过显示对话框来结束
- en: By now, you have probably noticed that we haven't actually put any code in place
    to display the dialog or trigger `AddImageService` when the user closes the dialog.
    To do this, we are going to add the code in `app.component.ts` and make a minor
    adjustment to the related HTML.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经注意到，我们实际上还没有放置任何代码来显示对话框或在用户关闭对话框时触发`AddImageService`。为了做到这一点，我们将在`app.component.ts`中添加代码，并对相关的HTML进行微小调整。
- en: 'Add a constructor that accepts a Material dialog and `AddImageService`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个接受Material对话框和`AddImageService`的构造函数：
- en: '[PRE78]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We need to add a public method that our HTML template will bind to. We are
    going to call this `ImportImage`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个公共方法，我们的HTML模板将绑定到它。我们将称之为`ImportImage`：
- en: '[PRE79]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The related change to our HTML template is to add the call to `ImportImage` to
    respond to the `click` event, via the `(click)` event binding, on our menu list
    item in `app.component.html`. Once again, we see Angular binding coming into play:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的HTML模板相关的更改是在`app.component.html`中的菜单列表项上添加对`ImportImage`的调用，通过`(click)`事件绑定对`click`事件做出响应。再次看到Angular绑定发挥作用：
- en: '[PRE80]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We are going to configure our dialog to behave in a certain way. We don''t
    want the user to be able to automatically close it by pressing the *Esc* key.
    We want it to be automatically focused and to be 500 pixels wide:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置我们的对话框以特定的方式行为。我们不希望用户能够通过按下*Esc*键来自动关闭它。我们希望它自动聚焦并且宽度为500像素：
- en: '[PRE81]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, we can show our dialog using this configuration:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个配置来显示我们的对话框：
- en: '[PRE82]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We want to be able to identify when the dialog is closed and automatically
    call our add image service—our `add` method—which will notify the transfer data
    service that the data must be sent to the client, and will also notify the page
    body that there is a new image to display:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够识别对话框何时关闭，并自动调用我们的添加图像服务——我们的`add`方法——这将通知传输数据服务必须将数据发送到客户端，并且还将通知页面主体有一个新图像要显示：
- en: '[PRE83]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'That''s the last piece of code that we put in place. Our client code now has
    neatly segregated services and components that work in co-operation with our Material
    dialog. Our dialog looks like this when in use:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们放置的最后一段代码。我们的客户端代码现在已经整齐地分离了服务和组件，这些服务和组件与我们的Material对话框协作。我们的对话框在使用时看起来像这样：
- en: '![](assets/1edd640e-c713-4728-ab76-200216af5a09.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1edd640e-c713-4728-ab76-200216af5a09.png)'
- en: We have finished wiring our dialog into our Angular code. We have a fully working
    application that we can use to save images into our database.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将我们的对话框连接到我们的Angular代码中。我们有一个完全可用的应用程序，可以用来将图像保存到我们的数据库中。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, using the MEAN stack, we have developed an application that
    allows the user to load images from their disk, add information about the images,
    and transfer data from the client to the server. We wrote code that created a
    server that could respond to incoming requests, as well as being able to save
    data to and retrieve data from a database. We discovered how to use Material Design
    and laid out our screen using Angular Material, along with navigation elements.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，使用MEAN堆栈，我们开发了一个应用程序，允许用户从其磁盘加载图像，添加有关图像的信息，并将数据从客户端传输到服务器。我们编写了创建一个服务器的代码，该服务器可以响应传入的请求，还可以将数据保存到数据库并从数据库中检索数据。我们发现了如何使用Material
    Design，并使用Angular Material布局我们的屏幕，以及导航元素。
- en: In the next chapter, we are going to expand our Angular knowledge and create
    a ToDo application that uses GraphQL to visualize its data.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展我们的Angular知识，并创建一个使用GraphQL来可视化其数据的ToDo应用程序。
- en: Questions
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: When we say that we are developing an application using the MEAN stack, what
    are the major components of the stack?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们说我们正在使用MEAN堆栈开发应用程序时，堆栈的主要组件是什么？
- en: Why did we supply a prefix when we created our Angular client?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在创建Angular客户端时我们提供了前缀？
- en: How do we start an Angular application?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何启动Angular应用程序？
- en: When we state that Material is a design language, what do we mean?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们说Material是一种设计语言时，我们是什么意思？
- en: How do we tell Angular to create a service?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何告诉Angular创建一个服务？
- en: What is Express routing?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Express路由？
- en: Which pattern does RxJS implement?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RxJS实现了哪种模式？
- en: What is CORS and why do we need it?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CORS是什么，为什么我们需要它？
- en: Further reading
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about the full MEAN stack, Packt has the following book available: *MongoDB,
    Express, Angular, and Node.js Fundamentals* by Paul Oluyege ([https://www.packtpub.com/web-development/mongodb-express-angular-and-nodejs-fundamentals](https://www.packtpub.com/web-development/mongodb-express-angular-and-nodejs-fundamentals))
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于完整的MEAN技术栈，Packt有以下图书可供参考：*MongoDB, Express, Angular, and Node.js Fundamentals*
    作者是Paul Oluyege ([https://www.packtpub.com/web-development/mongodb-express-angular-and-nodejs-fundamentals](https://www.packtpub.com/web-development/mongodb-express-angular-and-nodejs-fundamentals))
- en: For more information about learning reactive coding with JavaScript, Packt also
    has the following book available: *Mastering Reactive JavaScript* by Erich de
    Souza Oliveira ([https://www.packtpub.com/in/web-development/mastering-reactive-javascript](https://www.packtpub.com/in/web-development/mastering-reactive-javascript))
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于学习使用JavaScript进行响应式编程的更多信息，Packt还有以下图书可供参考：*Mastering Reactive JavaScript*
    作者是Erich de Souza Oliveira ([https://www.packtpub.com/in/web-development/mastering-reactive-javascript](https://www.packtpub.com/in/web-development/mastering-reactive-javascript))
