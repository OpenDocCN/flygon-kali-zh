["```kt\npublic class MainActivity extends CardboardActivity implements IRenderBox {\n    private static final String TAG = \"SolarSystem\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        CardboardView cardboardView = (CardboardView) findViewById(R.id.cardboard_view);\n        cardboardView.setRenderer(new RenderBox(this, this));\n        setCardboardView(cardboardView);\n    }\n    @Override\n    public void setup() {\n\n    }\n    @Override\n    public void preDraw() {\n    }\n    @Override\n    public void postDraw() {\n    }\n}\n```", "```kt\n    public void setup() {\n        new Transform()\n            .setLocalPosition(0,0,-7)\n            .setLocalRotation(45,60,0)\n            .addComponent(new Cube(true));\n    }\n```", "```kt\npublic class Sphere extends RenderObject{\n    private static final String TAG = \"RenderBox.Sphere\";\n    public Sphere() {\n        super();\n        allocateBuffers();\n    }\n}\n```", "```kt\n    public static FloatBuffer vertexBuffer;\n    public static FloatBuffer normalBuffer;\n    public static FloatBuffer texCoordBuffer;\n    public static ShortBuffer indexBuffer;\n    public static int numIndices;\n```", "```kt\n    public static void allocateBuffers(){\n        //Already allocated?\n        if (vertexBuffer != null) return;\n        //Generate a sphere model\n        float radius = 1f;\n        // Longitude |||\n        int nbLong = 24;\n        // Latitude ---\n        int nbLat = 16;\n\n        Vector3[] vertices = new Vector3[(nbLong+1) * nbLat + nbLong * 2];\n        float _pi = MathUtils.PI;\n        float _2pi = MathUtils.PI2;\n```", "```kt\n        //Top and bottom vertices are duplicated\n        for(int i = 0; i < nbLong; i++){\n            vertices[i] = new Vector3(Vector3.up).multiply(radius);\n            vertices[vertices.length - i - 1] = new Vector3(Vector3.up).multiply(-radius);\n        }\n        for( int lat = 0; lat < nbLat; lat++ )\n        {\n            float a1 = _pi * (float)(lat+1) / (nbLat+1);\n            float sin1 = (float)Math.sin(a1);\n            float cos1 = (float)Math.cos(a1);\n\n            for( int lon = 0; lon <= nbLong; lon++ )\n            {\n                float a2 = _2pi * (float)(lon == nbLong ? 0 : lon) / nbLong;\n                float sin2 = (float)Math.sin(a2);\n                float cos2 = (float)Math.cos(a2);\n\n                vertices[lon + lat * (nbLong + 1) + nbLong] = \n                    new Vector3( sin1 * cos2, cos1, sin1 * sin2 ).multiply(radius);\n            }\n        }\n```", "```kt\n        Vector3[] normals = new Vector3[vertices.length];\n        for( int n = 0; n < vertices.length; n++ )\n            normals[n] = new Vector3(vertices[n]).normalize();\n\n        Vector2[] uvs = new Vector2[vertices.length];\n        float uvStart = 1.0f / (nbLong * 2);\n        float uvStride = 1.0f / nbLong;\n        for(int i = 0; i < nbLong; i++) {\n            uvs[i] = new Vector2(uvStart + i * uvStride, 1f);\n            uvs[uvs.length - i - 1] = new Vector2(1 - (uvStart + i * uvStride), 0f);\n        }\n        for( int lat = 0; lat < nbLat; lat++ )\n            for( int lon = 0; lon <= nbLong; lon++ )\n                uvs[lon + lat * (nbLong + 1) + nbLong] = new Vector2( (float)lon / nbLong, 1f - (float)(lat+1) / (nbLat+1) );\n```", "```kt\n        int nbFaces = (nbLong+1) * nbLat + 2;\n        int nbTriangles = nbFaces * 2;\n        int nbIndexes = nbTriangles * 3;\n        numIndices = nbIndexes;\n        short[] triangles = new short[ nbIndexes ];\n\n        //Top Cap\n        int i = 0;\n        for( short lon = 0; lon < nbLong; lon++ )\n        {\n            triangles[i++] = lon;\n            triangles[i++] = (short)(nbLong + lon+1);\n            triangles[i++] = (short)(nbLong + lon);\n        }\n\n        //Middle\n        for( short lat = 0; lat < nbLat - 1; lat++ )\n        {\n            for( short lon = 0; lon < nbLong; lon++ )\n            {\n                short current = (short)(lon + lat * (nbLong + 1) + nbLong);\n                short next = (short)(current + nbLong + 1);\n\n                triangles[i++] = current;\n                triangles[i++] = (short)(current + 1);\n                triangles[i++] = (short)(next + 1);\n\n                triangles[i++] = current;\n                triangles[i++] = (short)(next + 1);\n                triangles[i++] = next;\n            }\n        }\n\n        //Bottom Cap\n        for( short lon = 0; lon < nbLong; lon++ )\n        {\n            triangles[i++] = (short)(vertices.length - lon - 1);\n            triangles[i++] = (short)(vertices.length - nbLong - (lon+1) - 1);\n            triangles[i++] = (short)(vertices.length - nbLong - (lon) - 1);\n        }\n```", "```kt\n        //convert Vector3[] to float[]\n        float[] vertexArray = new float[vertices.length * 3];\n        for(i = 0; i < vertices.length; i++){\n            int step = i * 3;\n            vertexArray[step] = vertices[i].x;\n            vertexArray[step + 1] = vertices[i].y;\n            vertexArray[step + 2] = vertices[i].z;\n        }\n        float[] normalArray = new float[normals.length * 3];\n        for(i = 0; i < normals.length; i++){\n            int step = i * 3;\n            normalArray[step] = normals[i].x;\n            normalArray[step + 1] = normals[i].y;\n            normalArray[step + 2] = normals[i].z;\n        }\n        float[] texCoordArray = new float[uvs.length * 2];\n        for(i = 0; i < uvs.length; i++){\n            int step = i * 2;\n            texCoordArray[step] = uvs[i].x;\n            texCoordArray[step + 1] = uvs[i].y;\n        }\n\n        vertexBuffer = allocateFloatBuffer(vertexArray);\n        normalBuffer = allocateFloatBuffer(normalArray);\n        texCoordBuffer = allocateFloatBuffer(texCoordArray);\n        indexBuffer = allocateShortBuffer(triangles);\n    }\n```", "```kt\nuniform mat4 u_MVP;\nuniform mat4 u_MV;\n\nattribute vec4 a_Position;\nattribute vec3 a_Normal;\n\nvarying vec3 v_Position;\nvarying vec3 v_Normal;\n\nvoid main() {\n    // vertex in eye space\n    v_Position = vec3(u_MV * a_Position);\n\n    // normal's orientation in eye space\n    v_Normal = vec3(u_MV * vec4(a_Normal, 0.0));\n\n    // point in normalized screen coordinates\n    gl_Position = u_MVP * a_Position;\n}\n```", "```kt\nprecision mediump float; // default medium precision in the fragment shader\nuniform vec3 u_LightPos; // light position in eye space\nuniform vec4 u_LightCol;\nuniform vec4 u_Color;\n\nvarying vec3 v_Position;        \nvarying vec3 v_Normal;\nvarying vec2 v_TexCoordinate;   \n\nvoid main() {\n    // distance for attenuation.\n    float distance = length(u_LightPos - v_Position);\n\n    // lighting direction vector from the light to the vertex\n    vec3 lightVector = normalize(u_LightPos - v_Position);\n\n    // dot product of the light vector and vertex normal. // If the normal and light vector are\n    // pointing in the same direction then it will get max // illumination.\n    float diffuse = max(dot(v_Normal, lightVector), 0.01);\n\n    // Add a tiny bit of ambient lighting (this is outerspace)\n    diffuse = diffuse + 0.025;  \n\n    // Multiply color by the diffuse illumination level and // texture value to get final output color\n    gl_FragColor = u_Color * u_LightCol * diffuse;\n}\n```", "```kt\npublic class SolidColorLightingMaterial extends Material {\n    private static final String TAG = \"solidcolorlighting\";\n\n}\n```", "```kt\n    float[] color = new float[4];\n    static int program = -1;\n    static int positionParam;\n    static int colorParam;\n    static int normalParam;\n    static int modelParam;\n    static int MVParam;\n    static int MVPParam;\n    static int lightPosParam;\n    static int lightColParam;\n\n    FloatBuffer vertexBuffer;\n    FloatBuffer normalBuffer;\n    ShortBuffer indexBuffer;\n    int numIndices;\n```", "```kt\n    public SolidColorLightingMaterial(float[] c){\n        super();\n        setColor(c);\n        setupProgram();\n    }\n\n    public void setColor(float[] c){\n        color = c;\n    }\n```", "```kt\n    public static void setupProgram(){\n        //Already setup?\n        if (program != -1) return;\n\n        //Create shader program\n        program = createProgram(R.raw.solid_color_lighting_vertex, R.raw.solid_color_lighting_fragment);\n\n        //Get vertex attribute parameters\n        positionParam = GLES20.glGetAttribLocation(program, \"a_Position\");\n        normalParam = GLES20.glGetAttribLocation(program, \"a_Normal\");\n\n        //Enable them (turns out this is kind of a big deal ;)\n        GLES20.glEnableVertexAttribArray(positionParam);\n        GLES20.glEnableVertexAttribArray(normalParam);\n\n        //Shader-specific parameters\n        colorParam = GLES20.glGetUniformLocation(program, \"u_Color\");\n        MVParam = GLES20.glGetUniformLocation(program, \"u_MV\");\n        MVPParam = GLES20.glGetUniformLocation(program, \"u_MVP\");\n        lightPosParam = GLES20.glGetUniformLocation(program, \"u_LightPos\");\n        lightColParam = GLES20.glGetUniformLocation(program, \"u_LightCol\");\n\n        RenderBox.checkGLError(\"Solid Color Lighting params\");\n    }\n```", "```kt\n    public void setBuffers(FloatBuffer vertexBuffer, FloatBuffer normalBuffer, ShortBuffer indexBuffer, int numIndices){\n        this.vertexBuffer = vertexBuffer;\n        this.normalBuffer = normalBuffer;\n        this.indexBuffer = indexBuffer;\n        this.numIndices = numIndices;\n    }\n```", "```kt\n    @Override\n    public void draw(float[] view, float[] perspective) {\n        GLES20.glUseProgram(program);\n\n        GLES20.glUniform3fv(lightPosParam, 1, RenderBox.instance.mainLight.lightPosInEyeSpace, 0);\n        GLES20.glUniform4fv(lightColParam, 1, RenderBox.instance.mainLight.color, 0);\n\n        Matrix.multiplyMM(modelView, 0, view, 0, RenderObject.lightingModel, 0);\n        // Set the ModelView in the shader, // used to calculate lighting\n        GLES20.glUniformMatrix4fv(MVParam, 1, false, modelView, 0);\n        Matrix.multiplyMM(modelView, 0, view, 0, RenderObject.model, 0);\n        Matrix.multiplyMM(modelViewProjection, 0, perspective, 0, modelView, 0);\n        // Set the ModelViewProjection matrix for eye position.\n        GLES20.glUniformMatrix4fv(MVPParam, 1, false, modelViewProjection, 0);\n\n        GLES20.glUniform4fv(colorParam, 1, color, 0);\n\n        //Set vertex attributes\n        GLES20.glVertexAttribPointer(positionParam, 3, GLES20.GL_FLOAT, false, 0, vertexBuffer);\n        GLES20.glVertexAttribPointer(normalParam, 3, GLES20.GL_FLOAT, false, 0, normalBuffer);\n\n        GLES20.glDrawElements(GLES20.GL_TRIANGLES, numIndices, GLES20.GL_UNSIGNED_SHORT, indexBuffer);\n    }\n```", "```kt\n    public Sphere(float[] color) {\n        super();\n        allocateBuffers();\n        createSolidColorLightingMaterial(color);\n    }\n\n    public Sphere createSolidColorLightingMaterial(float[] color){\n        SolidColorLightingMaterial mat = new SolidColorLightingMaterial(color);\n        mat.setBuffers(vertexBuffer, normalBuffer, indexBuffer, numIndices);\n        material = mat;\n        return this;\n    }\n```", "```kt\n    private Transform sphere;\n\n    @Override\n    public void setup() {\n        sphere = new Transform();\n        float[] color = new float[]{1, 1, 0.5f, 1};\n        sphere.addComponent(new Sphere(color));\n        sphere.setLocalPosition(2.0f, -2.f, -5.0f);\n    }\n```", "```kt\n    public static int loadTexture(final int resourceId){\n        final int[] textureHandle = new int[1];\n\n        GLES20.glGenTextures(1, textureHandle, 0);\n\n        if (textureHandle[0] != 0)\n        {\n            final BitmapFactory.Options options = new BitmapFactory.Options();\n            options.inScaled = false;   // No pre-scaling\n\n            // Read in the resource\n            final Bitmap bitmap = BitmapFactory.decodeResource(RenderBox.instance.mainActivity.getResources(), resourceId, options);\n            // Bind to the texture in OpenGL\n            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureHandle[0]);\n\n            // Set filtering\n            GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);\n            GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);\n\n            // Load the bitmap into the bound texture.\n            GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0);\n\n            // Recycle the bitmap, since its data has been loaded // into OpenGL.\n            bitmap.recycle();\n        }\n\n        if (textureHandle[0] == 0)\n        {\n            throw new RuntimeException(\"Error loading texture.\");\n        }\n\n        return textureHandle[0];\n    }\n```", "```kt\nuniform mat4 u_MVP;\nuniform mat4 u_MV;\n\nattribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec2 a_TexCoordinate;\n\nvarying vec3 v_Position;\nvarying vec3 v_Normal;\nvarying vec2 v_TexCoordinate;\n\nvoid main() {\n    // vertex in eye space\n    v_Position = vec3(u_MV * a_Position);\n\n    // pass through the texture coordinate.\n    v_TexCoordinate = a_TexCoordinate;\n\n    // normal's orientation in eye space\n    v_Normal = vec3(u_MV * vec4(a_Normal, 0.0));\n\n    // final point in normalized screen coordinates\n    gl_Position = u_MVP * a_Position;\n}\n```", "```kt\nprecision highp float; // default high precision for floating point ranges of the planets\n\nuniform vec3 u_LightPos;        // light position in eye space\nuniform vec4 u_LightCol;\nuniform sampler2D u_Texture;    // the input texture\n\nvarying vec3 v_Position;\nvarying vec3 v_Normal;\nvarying vec2 v_TexCoordinate;\n\nvoid main() {\n    // distance for attenuation.\n    float distance = length(u_LightPos - v_Position);\n\n    // lighting direction vector from the light to the vertex\n    vec3 lightVector = normalize(u_LightPos - v_Position);\n\n    // dot product of the light vector and vertex normal. // If the normal and light vector are\n    // pointing in the same direction then it will get max // illumination.\n    float diffuse = max(dot(v_Normal, lightVector), 0.01);\n\n    // Add a tiny bit of ambient lighting (this is outerspace)\n    diffuse = diffuse + 0.025;\n\n    // Multiply the color by the diffuse illumination level and // texture value to get final output color\n    gl_FragColor = texture2D(u_Texture, v_TexCoordinate) * u_LightCol * diffuse;\n}\n```", "```kt\npublic class DiffuseLightingMaterial extends Material {\n    private static final String TAG = \"diffuselightingmaterial\";\n```", "```kt\n    int textureId;\n    static int program = -1; //Initialize to a totally invalid value for setup state\n    static int positionParam;\n    static int texCoordParam;\n    static int textureParam;\n    static int normalParam;\n    static int MVParam;    \n    static int MVPParam;\n    static int lightPosParam;\n    static int lightColParam;\n\n    FloatBuffer vertexBuffer;\n    FloatBuffer texCoordBuffer;\n    FloatBuffer normalBuffer;\n    ShortBuffer indexBuffer;\n    int numIndices;\n```", "```kt\n    public DiffuseLightingMaterial(int resourceId){\n        super();\n        setupProgram();\n        this.textureId = MainActivity.loadTexture(resourceId);\n    }\n```", "```kt\n    public static void setupProgram(){\n        //Already setup?\n        if (program != -1) return;\n\n        //Create shader program\n        program = createProgram(R.raw.diffuse_lighting_vertex, R.raw.diffuse_lighting_fragment);\n        RenderBox.checkGLError(\"Diffuse Texture Color Lighting shader compile\");\n\n        //Get vertex attribute parameters\n        positionParam = GLES20.glGetAttribLocation(program, \"a_Position\");\n        normalParam = GLES20.glGetAttribLocation(program, \"a_Normal\");\n        texCoordParam = GLES20.glGetAttribLocation(program, \"a_TexCoordinate\");\n\n        //Enable them (turns out this is kind of a big deal ;)\n        GLES20.glEnableVertexAttribArray(positionParam);\n        GLES20.glEnableVertexAttribArray(normalParam);\n        GLES20.glEnableVertexAttribArray(texCoordParam);\n\n        //Shader-specific parameters\n        textureParam = GLES20.glGetUniformLocation(program, \"u_Texture\");\n        MVParam = GLES20.glGetUniformLocation(program, \"u_MV\");\n        MVPParam = GLES20.glGetUniformLocation(program, \"u_MVP\");\n        lightPosParam = GLES20.glGetUniformLocation(program, \"u_LightPos\");\n        lightColParam = GLES20.glGetUniformLocation(program, \"u_LightCol\");\n\n        RenderBox.checkGLError(\"Diffuse Texture Color Lighting params\");\n    }\n```", "```kt\n    public void setBuffers(FloatBuffer vertexBuffer, FloatBuffer normalBuffer, FloatBuffer texCoordBuffer, ShortBuffer indexBuffer, int numIndices){\n        //Associate VBO data with this instance of the material\n        this.vertexBuffer = vertexBuffer;\n        this.normalBuffer = normalBuffer;\n        this.texCoordBuffer = texCoordBuffer;\n        this.indexBuffer = indexBuffer;\n        this.numIndices = numIndices;\n    }\n```", "```kt\n    @Override\n    public void draw(float[] view, float[] perspective) {\n        GLES20.glUseProgram(program);\n\n        // Set the active texture unit to texture unit 0.\n        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);\n\n        // Bind the texture to this unit.\n        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);\n\n        // Tell the texture uniform sampler to use this texture in // the shader by binding to texture unit 0.\n        GLES20.glUniform1i(textureParam, 0);\n\n        //Technically, we don't need to do this with every draw //call, but the light could move.\n        //We could also add a step for shader-global parameters //which don't vary per-object\n        GLES20.glUniform3fv(lightPosParam, 1, RenderBox.instance.mainLight.lightPosInEyeSpace, 0);\n        GLES20.glUniform4fv(lightColParam, 1, RenderBox.instance.mainLight.color, 0);\n\n        Matrix.multiplyMM(modelView, 0, view, 0, RenderObject.lightingModel, 0);\n        // Set the ModelView in the shader, used to calculate // lighting\n        GLES20.glUniformMatrix4fv(MVParam, 1, false, modelView, 0);\n        Matrix.multiplyMM(modelView, 0, view, 0, RenderObject.model, 0);\n        Matrix.multiplyMM(modelViewProjection, 0, perspective, 0, modelView, 0);\n        // Set the ModelViewProjection matrix for eye position.\n        GLES20.glUniformMatrix4fv(MVPParam, 1, false, modelViewProjection, 0);\n\n        //Set vertex attributes\n        GLES20.glVertexAttribPointer(positionParam, 3, GLES20.GL_FLOAT, false, 0, vertexBuffer);\n        GLES20.glVertexAttribPointer(normalParam, 3, GLES20.GL_FLOAT, false, 0, normalBuffer);\n        GLES20.glVertexAttribPointer(texCoordParam, 2, GLES20.GL_FLOAT, false, 0, texCoordBuffer);\n\n        GLES20.glDrawElements(GLES20.GL_TRIANGLES, numIndices, GLES20.GL_UNSIGNED_SHORT, indexBuffer);\n\n        RenderBox.checkGLError(\"Diffuse Texture Color Lighting draw\");\n    }\n}\n```", "```kt\n    public Sphere(int textureId){\n        super();\n        allocateBuffers();\n        createDiffuseMaterial(textureId);\n    }\n\n    public Sphere createDiffuseMaterial(int textureId){\n        DiffuseLightingMaterial mat = new DiffuseLightingMaterial(textureId);\n        mat.setBuffers(vertexBuffer, normalBuffer, texCoordBuffer, indexBuffer, numIndices);\n        material = mat;\n        return this;\n    }\n```", "```kt\n    @Override\n    public void setup() {\n        sphere = new Transform();\n        sphere.addComponent(new Sphere(R.drawable.earth_tex));\n        sphere.setLocalPosition(2.0f, -2.f, -2.0f);\n    }\n```", "```kt\n    public void setup() {\n        sphere = new Transform()\n            .setLocalPosition(2.0f, -2.f, -2.0f)\n            .rotate(0, 0, 180f)\n            .addComponent(new Sphere(R.drawable.earth_tex));\n    }\n```", "```kt\n    public void preDraw() {\n        float dt = Time.getDeltaTime();\n        sphere.rotate( 0, -10f * dt, 0);\n    }\n```", "```kt\n    public void setup() {\n        sphere = new Transform()\n            .setLocalPosition(147.1f, 0, 0)\n            .rotate(0, 0, 180f)\n            .addComponent(new Sphere(R.drawable.earth_tex));\n        RenderBox.mainCamera.getTransform().setLocalPosition(147.1f, 2f, 2f);\n    }\n```", "```kt\nuniform mat4 u_MVP;\nuniform mat4 u_MV;\n\nattribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec2 a_TexCoordinate;\n\nvarying vec3 v_Position;\nvarying vec3 v_Normal;\nvarying vec2 v_TexCoordinate;\n\nvoid main() {\n   // vertex to eye space\n   v_Position = vec3(u_MV * a_Position);\n\n   // pass through the texture coordinate\n   v_TexCoordinate = a_TexCoordinate;\n\n   // normal's orientation in eye space\n   v_Normal = vec3(u_MV * vec4(a_Normal, 0.0));\n\n   // final point in normalized screen coordinates\n   gl_Position = u_MVP * a_Position;\n}\n```", "```kt\nprecision highp float; //  default high precision for floating point ranges of the //  planets\nuniform vec3 u_LightPos;      // light position in eye space\nuniform vec4 u_LightCol;\nuniform sampler2D u_Texture;  // the day texture.\nuniform sampler2D u_NightTexture;    // the night texture.\n\nvarying vec3 v_Position;\nvarying vec3 v_Normal;\nvarying vec2 v_TexCoordinate;\n\nvoid main() {\n    // lighting direction vector from the light to the vertex\n    vec3 lightVector = normalize(u_LightPos - v_Position);\n\n    // dot product of the light vector and vertex normal. If the // normal and light vector are\n    // pointing in the same direction then it will get max // illumination.\n    float ambient = 0.3;\n    float dotProd = dot(v_Normal, lightVector);\n    float blend = min(1.0, dotProd * 2.0);\n    if(dotProd < 0.0){\n        //flat ambient level of 0.3\n        gl_FragColor = texture2D(u_NightTexture, v_TexCoordinate) * ambient;\n    } else {\n        gl_FragColor = (\n            texture2D(u_Texture, v_TexCoordinate) * blend\n            + texture2D(u_NightTexture, v_TexCoordinate) * (1.0 - blend)\n        ) * u_LightCol * min(max(dotProd * 2.0, ambient), 1.0);\n    }\n}\n```", "```kt\npublic class DayNightMaterial extends Material {\n    private static final String TAG = \"daynightmaterial\";\n```", "```kt\n    int textureId;\n    int nightTextureId;\n\n    static int program = -1; //Initialize to a totally invalid value for setup state\n    static int positionParam;\n    static int texCoordParam;\n    static int textureParam;\n    static int nightTextureParam;\n    static int normalParam;\n    static int MVParam;\n    static int MVPParam;\n    static int lightPosParam;\n    static int lightColParam;\n\n    FloatBuffer vertexBuffer;\n    FloatBuffer texCoordBuffer;\n    FloatBuffer normalBuffer;\n    ShortBuffer indexBuffer;\n    int numIndices;\n```", "```kt\n    public DayNightMaterial(int resourceId, int nightResourceId){\n        super();\n        setupProgram();\n        this.textureId = MainActivity.loadTexture(resourceId);\n\n        this.nightTextureId = MainActivity.loadTexture(nightResourceId);\n    }\n\n    public static void setupProgram(){\n        if(program != -1) return;\n        //Create shader program\n        program = createProgram(R.raw.day_night_vertex, R.raw.day_night_fragment);\n\n        //Get vertex attribute parameters\n        positionParam = GLES20.glGetAttribLocation(program, \"a_Position\");\n        normalParam = GLES20.glGetAttribLocation(program, \"a_Normal\");\n        texCoordParam = GLES20.glGetAttribLocation(program, \"a_TexCoordinate\");\n\n        //Enable them (turns out this is kind of a big deal ;)\n        GLES20.glEnableVertexAttribArray(positionParam);\n        GLES20.glEnableVertexAttribArray(normalParam);\n        GLES20.glEnableVertexAttribArray(texCoordParam);\n\n        //Shader-specific parameters\n        textureParam = GLES20.glGetUniformLocation(program, \"u_Texture\");\n        nightTextureParam = GLES20.glGetUniformLocation(program, \"u_NightTexture\");\n        MVParam = GLES20.glGetUniformLocation(program, \"u_MV\");\n        MVPParam = GLES20.glGetUniformLocation(program, \"u_MVP\");\n        lightPosParam = GLES20.glGetUniformLocation(program, \"u_LightPos\");\n        lightColParam = GLES20.glGetUniformLocation(program, \"u_LightCol\");\n\n        RenderBox.checkGLError(\"Day/Night params\");\n    }\n\n    public void setBuffers(FloatBuffer vertexBuffer, FloatBuffer normalBuffer, FloatBuffer texCoordBuffer, ShortBuffer indexBuffer, int numIndices){\n        //Associate VBO data with this instance of the material\n        this.vertexBuffer = vertexBuffer;\n        this.normalBuffer = normalBuffer;\n        this.texCoordBuffer = texCoordBuffer;\n        this.indexBuffer = indexBuffer;\n        this.numIndices = numIndices;\n    }\n```", "```kt\n    @Override\n    public void draw(float[] view, float[] perspective) {\n        GLES20.glUseProgram(program);\n\n        // Set the active texture unit to texture unit 0.\n        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);\n\n        // Bind the texture to this unit.\n        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);\n\n        GLES20.glActiveTexture(GLES20.GL_TEXTURE1);\n        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, nightTextureId);\n\n        // Tell the texture uniform sampler to use this texture in // the shader by binding to texture unit 0.\n        GLES20.glUniform1i(textureParam, 0);\n        GLES20.glUniform1i(nightTextureParam, 1);\n\n        //Technically, we don't need to do this with every draw //call, but the light could move.\n        //We could also add a step for shader-global parameters //which don't vary per-object\n        GLES20.glUniform3fv(lightPosParam, 1, RenderBox.instance.mainLight.lightPosInEyeSpace, 0);\n        GLES20.glUniform4fv(lightColParam, 1, RenderBox.instance.mainLight.color, 0);\n\n        Matrix.multiplyMM(modelView, 0, view, 0, RenderObject.lightingModel, 0);\n        // Set the ModelView in the shader, used to calculate // lighting\n        GLES20.glUniformMatrix4fv(MVParam, 1, false, modelView, 0);\n        Matrix.multiplyMM(modelView, 0, view, 0, RenderObject.model, 0);\n        Matrix.multiplyMM(modelViewProjection, 0, perspective, 0, modelView, 0);\n        // Set the ModelViewProjection matrix for eye position.\n        GLES20.glUniformMatrix4fv(MVPParam, 1, false, modelViewProjection, 0);\n\n        //Set vertex attributes\n        GLES20.glVertexAttribPointer(positionParam, 3, GLES20.GL_FLOAT, false, 0, vertexBuffer);\n        GLES20.glVertexAttribPointer(normalParam, 3, GLES20.GL_FLOAT, false, 0, normalBuffer);\n        GLES20.glVertexAttribPointer(texCoordParam, 2, GLES20.GL_FLOAT, false, 0, texCoordBuffer);\n\n        GLES20.glDrawElements(GLES20.GL_TRIANGLES, numIndices, GLES20.GL_UNSIGNED_SHORT, indexBuffer);\n\n        RenderBox.checkGLError(\"DayNight Texture Color Lighting draw\");\n    }\n}\n```", "```kt\n    public Sphere(int textureId, int nightTextureId){\n        super();\n        allocateBuffers();\n        createDayNightMaterial(textureId, nightTextureId);\n    }\n\n    public Sphere createDayNightMaterial(int textureId, int nightTextureId){\n        DayNightMaterial mat = new DayNightMaterial(textureId, nightTextureId);\n        mat.setBuffers(vertexBuffer, normalBuffer, texCoordBuffer, indexBuffer, numIndices);\n        material = mat;\n        return this;\n    }\n```", "```kt\n    .addComponent(new Sphere(R.drawable.earth_tex, R.drawable.earth_night_tex));\n```", "```kt\nuniform mat4 u_MVP;\n\nattribute vec4 a_Position;\nattribute vec2 a_TexCoordinate;\n\nvarying vec3 v_Position;\nvarying vec2 v_TexCoordinate;\n\nvoid main() {\n   // pass through the texture coordinate\n   v_TexCoordinate = a_TexCoordinate;\n\n   // final point in normalized screen coordinates\n   gl_Position = u_MVP * a_Position;\n}\n```", "```kt\nprecision mediump float;        // default medium precision\nuniform sampler2D u_Texture;    // the input texture\n\nvarying vec3 v_Position;\nvarying vec2 v_TexCoordinate;\n\nvoid main() {\n    // Send the color from the texture straight out\n    gl_FragColor = texture2D(u_Texture, v_TexCoordinate);\n}\n```", "```kt\npublic class UnlitTexMaterial extends Material {\n    private static final String TAG = \"unlittex\";\n\n    int textureId;\n\n    static int program = -1; //Initialize to a totally invalid value for setup state\n    static int positionParam;\n    static int texCoordParam;\n    static int textureParam;\n    static int MVPParam;\n\n    FloatBuffer vertexBuffer;\n    FloatBuffer texCoordBuffer;\n    ShortBuffer indexBuffer;\n    int numIndices;\n```", "```kt\n    public UnlitTexMaterial(int resourceId){\n        super();\n        setupProgram();\n        this.textureId = MainActivity.loadTexture(resourceId);\n    }\n\n    public static void setupProgram(){\n        if(program != -1) return;\n        //Create shader program\n        program = createProgram(R.raw.unlit_tex_vertex, R.raw.unlit_tex_fragment);\n\n        //Get vertex attribute parameters\n        positionParam = GLES20.glGetAttribLocation(program, \"a_Position\");\n        texCoordParam = GLES20.glGetAttribLocation(program, \"a_TexCoordinate\");\n\n        //Enable them (turns out this is kind of a big deal ;)\n        GLES20.glEnableVertexAttribArray(positionParam);\n        GLES20.glEnableVertexAttribArray(texCoordParam);\n\n        //Shader-specific parameters\n        textureParam = GLES20.glGetUniformLocation(program, \"u_Texture\");\n        MVPParam = GLES20.glGetUniformLocation(program, \"u_MVP\");\n\n        RenderBox.checkGLError(\"Unlit Texture params\");\n    }\n\n    public void setBuffers(FloatBuffer vertexBuffer, FloatBuffer texCoordBuffer, ShortBuffer indexBuffer, int numIndices){\n        //Associate VBO data with this instance of the material\n        this.vertexBuffer = vertexBuffer;\n        this.texCoordBuffer = texCoordBuffer;\n        this.indexBuffer = indexBuffer;\n        this.numIndices = numIndices;\n    }\n```", "```kt\n    public void setTexture(int textureHandle){\n        textureId = textureHandle;\n    }\n\n      public int getTexture(){\n          return textureId;\n      }\n```", "```kt\n    @Override\n    public void draw(float[] view, float[] perspective) {\n        GLES20.glUseProgram(program);\n\n        // Set the active texture unit to texture unit 0.\n        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);\n\n        // Bind the texture to this unit.\n        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);\n\n        // Tell the texture uniform sampler to use this texture in // the shader by binding to texture unit 0.\n        GLES20.glUniform1i(textureParam, 0);\n\n        Matrix.multiplyMM(modelView, 0, view, 0, RenderObject.model, 0);\n        Matrix.multiplyMM(modelViewProjection, 0, perspective, 0, modelView, 0);\n        // Set the ModelViewProjection matrix in the shader.\n        GLES20.glUniformMatrix4fv(MVPParam, 1, false, modelViewProjection, 0);\n\n        // Set the vertex attributes\n        GLES20.glVertexAttribPointer(positionParam, 3, GLES20.GL_FLOAT, false, 0, vertexBuffer);\n        GLES20.glVertexAttribPointer(texCoordParam, 2, GLES20.GL_FLOAT, false, 0, texCoordBuffer);\n\n        GLES20.glDrawElements(GLES20.GL_TRIANGLES, numIndices, GLES20.GL_UNSIGNED_SHORT, indexBuffer);\n\n        RenderBox.checkGLError(\"Unlit Texture draw\");\n    }\n}\n```", "```kt\n    public Sphere(int textureId, boolean lighting){\n        super();\n        allocateBuffers();\n        if (lighting) {\n            createDiffuseMaterial(textureId);\n        } else {\n            createUnlitTexMaterial(textureId);\n        }\n    }\n\n    public Sphere createUnlitTexMaterial(int textureId){\n        UnlitTexMaterial mat = new UnlitTexMaterial(textureId);\n        mat.setBuffers(vertexBuffer, texCoordBuffer, indexBuffer, numIndices);\n        material = mat;\n        return this;\n    }\n```", "```kt\n    public void setup() {\n        Transform origin = new Transform();\n\n        //Sun\n        Transform sun = new Transform()\n            .setParent(origin, false)\n            .setLocalScale(6.963f, 6.963f, 6.963f)\n            .addComponent(new Sphere(R.drawable.sun_tex, false));\n\n        //\"Sun\" light\n        RenderBox.instance.mainLight.transform.setPosition( origin.getPosition());\n        RenderBox.instance.mainLight.color = new float[]{1, 1, 0.8f, 1};\n\n            //Earth\u2026\n```", "```kt\npublic class Planet {\n    protected float rotation, orbit;\n    protected Transform orbitTransform, transform;\n\n    public float distance, radius;\n```", "```kt\n    public Planet(float distance, float radius, float rotation, float orbit, int texId, Transform origin){\n        setupPlanet(distance, radius, rotation, orbit, origin);\n        transform.addComponent(new Sphere(texId));\n    }\n\n    public void setupPlanet(float distance, float radius, float rotation, float orbit, Transform origin){\n        this.distance = distance;\n        this.radius = radius;\n        this.rotation = rotation;\n        this.orbit = orbit;\n        this.orbitTransform = new Transform();\n        this.orbitTransform.setParent(origin, false);\n\n        transform = new Transform()\n            .setParent(orbitTransform, false)\n            .setLocalPosition(distance, 0, 0)\n            .setLocalRotation(180, 0, 0)\n            .setLocalScale(radius, radius, radius);\n    }\n```", "```kt\n    public void preDraw(float dt){\n        orbitTransform.rotate(0, dt * orbit, 0);\n        transform.rotate(0, dt * -rotation, 0);\n    }\n```", "```kt\n    public Transform getTransform() { return transform; }\n    public Transform getOrbitransform() { return orbitTransform; }\n```", "```kt\n    Planet[] planets;\n```", "```kt\n    // tighten up the distances (millions km)\n    float DISTANCE_FACTOR = 0.5f; // this is 100x relative to interplanetary distances\n    float SCALE_FACTOR = 0.0001f; // animation rate for one earth rotation (seconds per rotation)\n    float EDAY_RATE = 10f; // rotation scale factor e.g. to animate earth: dt * 24 * // DEG_PER_EHOUR\n    float DEG_PER_EHOUR = (360f / 24f / EDAY_RATE); // animation rate for one earth rotation (seconds per orbit)//  (real is EDAY_RATE * 365.26)\n    float EYEAR_RATE = 1500f; // orbit scale factorfloat DEG_PER_EYEAR = (360f / EYEAR_RATE); \n```", "```kt\n    public void setupPlanets(Transform origin) {\n\n        float[] distances = new float[] { 57.9f, 108.2f, 149.6f, 227.9f, 778.3f, 1427f, 2871f, 4497f, 5913f };\n        float[] fudged_distances = new float[] { 57.9f, 108.2f, 149.6f, 227.9f, 400f, 500f, 600f, 700f, 800f };\n\n        float[] radii = new float[] { 2440f, 6052f, 6371f, 3390f, 69911f, 58232f, 25362f, 24622f, 1186f };\n\n        float[] rotations = new float[] { 1408.8f * 0.05f, 5832f * 0.01f, 24f, 24.6f, 9.84f, 10.2f, 17.9f, 19.1f, 6.39f };\n\n        float[] orbits = new float[] { 0.24f, 0.615f, 1.0f, 2.379f, 11.862f, 29.456f, 84.07f, 164.81f, 247.7f };\n```", "```kt\n        int[] texIds = new int[]{\n                R.drawable.mercury_tex,\n                R.drawable.venus_tex,\n                R.drawable.earth_tex,\n                R.drawable.mars_tex,\n                R.drawable.jupiter_tex,\n                R.drawable.saturn_tex,\n                R.drawable.uranus_tex,\n                R.drawable.neptune_tex,\n                R.drawable.pluto_tex\n        };\n```", "```kt\n        planets = new Planet[distances.length + 1];\n        for(int i = 0; i < distances.length; i++){\n            planets[i] = new Planet(\n                    fudged_distances[i] * DISTANCE_FACTOR,\n                    radii[i] * SCALE_FACTOR,\n                    rotations[i] * DEG_PER_EHOUR,\n                    orbits[i] * DEG_PER_EYEAR * fudged_distances[i]/distances[i],\n                    texIds[i],\n                    origin);\n        }\n```", "```kt\n        // Create the moon\n        planets[distances.length] = new Planet(7.5f, 0.5f, 0, - 0.516f, R.drawable.moon_tex, planets[2].getTransform());}\n```", "```kt\n    void goToPlanet(int index){\n        RenderBox.mainCamera.getTransform().setParent( planets[index].getOrbitransform(), false);\n        RenderBox.mainCamera.getTransform().setLocalPosition( planets[index].distance, planets[index].radius * 1.5f, planets[index].radius * 2f);\n    }\n```", "```kt\n    public void setup() { \n        //Sun ...\n\n        // Planets\n setupPlanets(origin);\n\n // Start looking at Earth \n goToPlanet(2);\n    }\n```", "```kt\n    @Override\n    public void preDraw() {\n        float dt = Time.getDeltaTime();\n        for(int i = 0; i < planets.length; i++){\n            planets[i].preDraw(dt);\n        }\n    }\n```", "```kt\n        //Stars in the sky\n        Transform stars = new Transform()\n                .setParent(RenderBox.mainCamera.transform, false)\n                .setLocalScale(Camera.Z_FAR * 0.99f, Camera.Z_FAR * 0.99f, Camera.Z_FAR * 0.99f)\n                .addComponent(new Sphere(R.drawable.milky_way_tex, false));\n```", "```kt\npublic class Earth extends Planet {\n\n    public Earth(float distance, float radius, float rotation, float orbit, int texId, int nightTexId, Transform origin) {\n        super(distance, radius, rotation, orbit, origin);\n        transform.addComponent(new Sphere(texId, nightTexId));\n    }\n}\n```", "```kt\n    public Planet(float distance, float radius, float rotation, float orbit, Transform origin){\n        setupPlanet(distance, radius, rotation, orbit, origin);\n    }\n```", "```kt\n        for(int i = 0; i < distances.length; i++){\n if (i == 2) {\n planets[i] = new Earth(\n fudged_distances[i] * DISTANCE_FACTOR,\n radii[i] * SCALE_FACTOR,\n rotations[i] * DEG_PER_EHOUR,\n orbits[i] * DEG_PER_EYEAR * fudged_distances[i] / distances[i],\n texIds[i],\n R.drawable.earth_night_tex,\n origin);\n } else {\n                planets[i] = new Planet(\n```", "```kt\n    Transform wobble;\n\n    public Earth(float distance, float radius, float rotation, float orbit, int texId, int nightTexId, Transform origin) {\n        super(distance, radius, rotation, orbit, origin);\n\n        wobble = new Transform()\n                .setLocalPosition(distance, 0, 0)\n                .setParent(orbitTransform, false);\n\n        Transform tilt = new Transform()\n                .setLocalRotation(-23.4f,0,0)\n                .setParent(wobble, false);\n\n        transform\n                .setParent(tilt, false)\n                .setLocalPosition(0,0,0)\n                .addComponent(new Sphere(texId, nightTexId));\n    }\n```", "```kt\n    public void preDraw(float dt){\n        orbitTransform.rotate(0, dt * orbit, 0);\n        wobble.rotate(0, dt * 5, 0);\n        transform.rotate(0, dt * -rotation, 0);\n    }\n```", "```kt\n    int currPlanet = 2;\n\n    public void onCardboardTrigger(){\n        if (++currPlanet >= planets.length)\n            currPlanet = 0;\n        goToPlanet(currPlanet);\n    }\n```"]