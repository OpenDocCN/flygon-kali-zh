["```kt\n<resources>\n     <string name=\"app_name\">LocationAlarm</string>\n     <string name=\"title_activity_maps\">Map</string>\n     <string name=\"Settings\">Settings</string>\n    <string name=\"PREFS_NAME\">LocationAlarmFile</string> </resources>\n```", "```kt\nval sharedPref = this?.getSharedPreferences(getString(R.string.PREFS_NAME),Context.MODE_PRIVATE) ?: return with(sharedPref.edit()){ putString(\"userLat\", Lat?.text.toString())\n     putString(\"userLang\",Lang?.text.toString())\n     commit()\n```", "```kt\n      val sharedPref = \n this?.getSharedPreferences(getString(R.string.PREFS_NAME), \n      Context.MODE_PRIVATE) ?: return AlarmLat = \n     java.lang.Double.parseDouble(sharedPref.getString(\"userLat\",   \n \"13.07975\"))\n         AlarmLong = \n     java.lang.Double.parseDouble(sharedPref.getString(\"userLang\", \n \"80.1798347\"))\n```", "```kt\ndependencies {\n    compile 'com.google.android.gms:play-services-location:11.8.0'\n}\n```", "```kt\n <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n```", "```kt\nprivate fun checkLocation(): Boolean {\n         if(!isLocationEnabled())\n             Toast.makeText(this,\"Please enable Location and grant permission for this app for Location\",Toast.LENGTH_LONG).show()\n         return isLocationEnabled();\n     }\n\nprivate fun isLocationEnabled(): Boolean {\n     locationManager = getSystemService(Context.LOCATION_SERVICE) as \n     LocationManager\n     return locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER) || locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER)\n }\n```", "```kt\nclass MapsActivity : AppCompatActivity(), OnMapReadyCallback ,GoogleApiClient.ConnectionCallbacks, GoogleApiClient.OnConnectionFailedListener, com.google.android.gms.location.LocationListener {\n```", "```kt\n    private lateinit var mMap: GoogleMap\n    private var newLat: Double? = null\n    private var newLang: Double? = null\n    private var chennai: LatLng? = null\n\n    private var AlarmLat: Double? = null\n    private var AlarmLong: Double? = null\n    private var UserLat: Double? = null\n    private var UserLong: Double? = null\n\n     //location variablesprivate val TAG = \"MapsActivity\" private lateinit var mGoogleApiClient: GoogleApiClient\n    private var mLocationManager: LocationManager? = null\n    lateinit var mLocation: Location\n    private var mLocationRequest: LocationRequest? = null\n```", "```kt\n private val UPDATE_INTERVAL = 10000.toLong() // 10 seconds rate at \n     //  which we would like to receive the updates\n     private val FASTEST_INTERVAL: Long = 5000 // 5 seconds - rate at  \n     //  which app can handle the update lateinit var locationManager: LocationManager\n```", "```kt\n   override fun onCreate(savedInstanceState: Bundle?) {\n         super.onCreate(savedInstanceState)\n         setContentView(R.layout.*activity_maps*)\n         // Obtain the SupportMapFragment and get notified when the map    \n         is ready to be used. val mapFragment = *supportFragmentManager\n                * .findFragmentById(R.id.*map*) as SupportMapFragment\n         mapFragment.getMapAsync(this)\n\n         mGoogleApiClient = GoogleApiClient.Builder(this)\n                 .addConnectionCallbacks(this)\n                 .addOnConnectionFailedListener(this)\n                 .addApi(LocationServices.API)\n                 .build()\n\n         mLocationManager =   \n this.getSystemService(Context.LOCATION_SERVICE) as  \n         LocationManager\n         checkLocation()\n }\n```", "```kt\n   override fun onStart() {\n         super.onStart();\n         if (mGoogleApiClient != null) {\n             mGoogleApiClient.connect();\n         }\n     }\n```", "```kt\n    override fun onStop() {\n         super.onStop();\n         if (mGoogleApiClient.isConnected()) {\n             mGoogleApiClient.disconnect();\n         }\n     }\n```", "```kt\n     override fun onConnectionSuspended(p0: Int) {\n\n         Log.i(TAG, \"Connection Suspended\");\n         mGoogleApiClient.connect();\n     }\n```", "```kt\n     override fun onConnectionFailed(connectionResult: \n        ConnectionResult) {\n     Log.i(TAG, \"Connection failed. Error: \" + \n        connectionResult.getErrorCode());\n     }\n```", "```kt\noverride fun onConnected(p0: Bundle?) {\n\n         if (ActivityCompat.checkSelfPermission(this,   \n            Manifest.permission.ACCESS_FINE_LOCATION) != \n            PackageManager.PERMISSION_GRANTED && \n            ActivityCompat.checkSelfPermission(this, \n            Manifest.permission.ACCESS_COARSE_LOCATION) != \n            PackageManager.PERMISSION_GRANTED) {\n\n             return;\n         }\n         startLocationUpdates();\n```", "```kt\nvar fusedLocationProviderClient :\n         FusedLocationProviderClient =   \n         LocationServices.getFusedLocationProviderClient(this);\n         fusedLocationProviderClient .getLastLocation()\n         .addOnSuccessListener(this, OnSuccessListener<Location> {   \n         location ->\n                     if (location != null) {\n                         mLocation = location;\n } }) }\n```", "```kt\n\n protected fun startLocationUpdates() {\n          // Create the location request mLocationRequest = LocationRequest.create()\n                 .setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY)\n                 .setInterval(UPDATE_INTERVAL)\n                 .setFastestInterval(FASTEST_INTERVAL);\n         // Request location updates if (ActivityCompat.checkSelfPermission(this, \n          Manifest.permission.ACCESS_FINE_LOCATION) !=   \n          PackageManager.PERMISSION_GRANTED && \n          ActivityCompat.checkSelfPermission(this, \n          Manifest.permission.ACCESS_COARSE_LOCATION) != \n          PackageManager.PERMISSION_GRANTED) {\n             return;\n         }\n\n      LocationServices.FusedLocationApi.requestLocationUpdates(\n mGoogleApiClient, mLocationRequest, this);\n     }\n\n```", "```kt\noverride fun onLocationChanged(location: Location) { \n        val sharedPref =  \n this?.getSharedPreferences(getString(R.string.*PREFS_NAME*), \n      Context.*MODE_PRIVATE*)\n           ?: return\n        AlarmLat = \n      java.lang.Double.parseDouble(sharedPref.getString(\"userLat\", \n \"13.07975\"))\n        AlarmLong = \n      java.lang.Double.parseDouble(sharedPref.getString(\"userLang\", \n \"80.1798347\"))\n\n         UserLat = location.latitude\n UserLong = location.longitude\n val AlarmLat1 = AlarmLat val AlarmLong1 = AlarmLong\n         val UserLat1 = UserLat\n         val UserLong1 = UserLong\n\n         if(AlarmLat1 != null && AlarmLong1 != null && UserLat1 != null \n         && UserLong1 != null){\n\n      checkAlarmLocation(AlarmLat1,AlarmLong1,UserLat1,UserLong1)\n         }\n     }\n```", "```kt\nfun checkAlarmLocation(AlarmLat : Double, AlarmLong : Double, UserLat : Double,UserLong : Double) {\n\n    Toast.makeText(this,\"Check Alarm Called\" + AlarmLat + \",\" + AlarmLong + \",\" + UserLat + \",\" + UserLong,Toast.*LENGTH_LONG* ).show()\n\n         var LatAlarm: Double\n         var LongAlarm: Double\n         var LatUser: Double\n         var LongUser: Double\n\n         LatAlarm = Math.round(AlarmLat * 100.0) / 100.0;\n         LongAlarm = Math.round(AlarmLong * 100.0) / 100.0;\n\n         LatUser = Math.round(UserLat * 100.0) / 100.0;\n         LongUser = Math.round(UserLong * 100.0) / 100.0;\n\nToast.makeText(this,\"Check Alarm Called\" + LatAlarm + \",\" + LongAlarm + \",\" + LatUser + \",\" + LongUser,Toast.*LENGTH_LONG* ).show()\n\n         if (LatAlarm == LatUser && LongAlarm == LongUser) {\n             Toast.makeText(this, \"User has reached the area for which \n             alarm has been set\", Toast.LENGTH_LONG).show();\n         }\n     }\n```"]