- en: Powering a Continuous Deployment Pipeline with Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker推动持续部署管道
- en: Docker supports building and running software in components that can be easily
    distributed and managed. The platform also lends itself to development environments,
    where source control, build servers, build agents, and test agents can all be
    run in Docker containers from standard images.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持构建和运行可以轻松分发和管理的组件。该平台还适用于开发环境，其中源代码控制、构建服务器、构建代理和测试代理都可以从标准镜像中运行在Docker容器中。
- en: Using Docker for development lets you consolidate many projects in a single
    set of hardware while maintaining isolation. You could have services running a
    Git server and an image registry with high availability in Docker Swarm, shared
    by many projects. Each project could have a dedicated build server configured
    with their own pipeline and their own build setup, running in a lightweight Docker
    container.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发中使用Docker可以让您在单一硬件集中 consoli 许多项目，同时保持隔离。您可以在Docker Swarm中运行具有高可用性的Git服务器和镜像注册表的服务，这些服务由许多项目共享。每个项目可以配置有自己的管道和自己的构建设置的专用构建服务器，在轻量级Docker容器中运行。
- en: Setting up a new project in this environment is simply a case of creating a
    new repository in the source control repository and a new namespace in the registry,
    and running new containers for the build process. These steps can all be automated,
    so project onboarding becomes a simple process that takes minutes and uses existing
    hardware.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种环境中设置新项目只是在源代码控制存储库中创建新存储库和新命名空间，并运行新容器进行构建过程。所有这些步骤都可以自动化，因此项目入职变成了一个只需几分钟并使用现有硬件的简单过程。
- en: 'In this chapter, I''ll walk you through the setup of a **continuous integration
    and continuous delivery** (**CI/CD**) pipeline using Docker. I''ll cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将带您完成使用Docker设置**持续集成和持续交付**（**CI/CD**）管道。我将涵盖：
- en: Designing CI/CD with Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker设计CI/CD
- en: Running shared development services in Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中运行共享开发服务
- en: Configuring CI/CD using Jenkins in Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中使用Jenkins配置CI/CD
- en: Deploying to a remote Docker Swarm using Jenkins
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jenkins部署到远程Docker Swarm
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need Docker running on Windows 10 update 18.09, or Windows Server 2019,
    to follow along with the examples. The code for this chapter is available at [https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch10](https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch10).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在Windows 10更新18.09或Windows Server 2019上运行Docker，以便按照示例进行操作。本章的代码可在[https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch10](https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch10)上找到。
- en: Designing CI/CD with Docker
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker设计CI/CD
- en: The pipeline will support full continuous integration. When developers push
    code to the shared source repository, that will trigger a build that produces
    a release candidate. The release candidates will be tagged Docker images that
    are stored in a local registry. The CI workflow deploys the solution from the
    built images as containers and runs an end-to-end test pack.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该管道将支持完整的持续集成。当开发人员将代码推送到共享源代码存储库时，将触发生成发布候选版本的构建。发布候选版本将被标记为存储在本地注册表中的Docker镜像。CI工作流从构建的图像中部署解决方案作为容器，并运行端到端测试包。
- en: My sample pipeline has a manual quality gate. If the tests pass, the image versions
    are made publicly available on Docker Hub, and the pipeline can start a rolling
    upgrade in a public environment running on a remote Docker Swarm. In a full CI/CD
    environment, you can automate the deployment to production in your pipeline, too.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我的示例管道具有手动质量门。如果测试通过，图像版本将在Docker Hub上公开可用，并且管道可以在远程Docker Swarm上运行的公共环境中启动滚动升级。在完整的CI/CD环境中，您还可以在管道中自动部署到生产环境。
- en: 'The stages of the pipeline will all be powered by software running in Docker
    containers:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线的各个阶段都将由运行在Docker容器中的软件驱动：
- en: '**Source control**: Gogs, a simple open source Git server written in Go'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码控制：Gogs，一个用Go编写的简单的开源Git服务器
- en: '**Build server**: Jenkins, a Java-based automation tool that uses plugins to
    support many workflows'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建服务器：Jenkins，一个基于Java的自动化工具，使用插件支持许多工作流
- en: '**Build agent**: The .NET SDK packaged into a Docker image to compile code
    in a container'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建代理：将.NET SDK打包成一个Docker镜像，以在容器中编译代码
- en: '**Test agent**: NUnit packaged into a Docker image to run end-to-end tests
    against deployed code'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代理：NUnit打包成一个Docker镜像，用于对部署的代码进行端到端测试
- en: Gogs and Jenkins can run in long-running containers on a Docker Swarm or on
    an individual Docker Engine. The build and test agents are task containers that
    will be run by Jenkins to perform the pipeline steps—then, they will exit. The
    release candidate will be deployed as a set of containers that are removed when
    the tests are completed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Gogs和Jenkins可以在Docker Swarm上或在单独的Docker Engine上运行长时间运行的容器。构建和测试代理是由Jenkins运行的任务容器，用于执行流水线步骤，然后它们将退出。发布候选将部署为一组容器，在测试完成时将被删除。
- en: The only requirement to set this up is to give containers access to the Docker
    API—both in the local and remote environments. On the local server, I'll use named
    pipes from Windows. For the remote Docker Swarm, I'll use a secured TCP connection.
    I covered securing the Docker API in [Chapter 1](59b504fb-1012-4118-aa49-c5e0efce06d3.xhtml),
    *Getting Started with Docker on Windows*, using the `dockeronwindows/ch01-dockertls`
    image to generate TLS certificates. You need to have local access configured so
    that the Jenkins container can create containers in development, and remote access
    so that Jenkins can start the rolling upgrade in the public environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这个的唯一要求是让容器访问Docker API——在本地和远程环境中都是如此。在本地服务器上，我将使用来自Windows的命名管道。对于远程Docker
    Swarm，我将使用一个安全的TCP连接。我在[第1章](59b504fb-1012-4118-aa49-c5e0efce06d3.xhtml)中介绍了如何保护Docker
    API，*在Windows上使用Docker入门*，使用`dockeronwindows/ch01-dockertls`镜像生成TLS证书。您需要配置本地访问权限，以便Jenkins容器可以在开发中创建容器，并配置远程访问权限，以便Jenkins可以在公共环境中启动滚动升级。
- en: The workflow for this pipeline starts when a developer pushes code to the Git
    server, which is running Gogs in a Docker container. Jenkins is configured to
    poll the Gogs repository, and it will start a build if there are any changes.
    All the custom components in the solution use multi-stage Dockerfiles, which are
    stored in the Git repository for the project. Jenkins runs `docker image build`
    commands for each Dockerfile, building the image on the same Docker host where
    Jenkins itself is running in a container.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流水线的工作流是当开发人员将代码推送到运行Gogs的Git服务器时开始的，Gogs运行在一个Docker容器中。Jenkins被配置为轮询Gogs存储库，如果有任何更改，它将开始构建。解决方案中的所有自定义组件都使用多阶段的Dockerfile，这些文件存储在项目的Git存储库中。Jenkins对每个Dockerfile运行`docker
    image build`命令，在同一Docker主机上构建镜像，Jenkins本身也在一个容器中运行。
- en: When the builds complete, Jenkins deploys the solution locally as containers
    on the same Docker host. Then, it runs end-to-end tests, which are packaged in
    a Docker image and run as a container in the same Docker network as the application
    being tested. If all the tests pass, then the final pipeline step pushes these
    images as release candidates to the local registry, and the registry is also running
    in a Docker container.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，Jenkins将解决方案部署到本地，作为同一Docker主机上的容器。然后，它运行端到端测试，这些测试打包在一个Docker镜像中，并作为一个容器在与被测试的应用程序相同的Docker网络中运行。如果所有测试都通过了，那么最终的流水线步骤将把这些图像作为发布候选推送到本地注册表中，而注册表也在一个Docker容器中运行。
- en: When you run your development tools in Docker, you get the same benefits that
    you have when you run production workloads in Docker. The whole toolchain becomes
    portable, and you can run it wherever you like with minimal compute requirements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Docker中运行开发工具时，您将获得与在Docker中运行生产工作负载时相同的好处。整个工具链变得可移植，您可以在任何地方以最小的计算要求运行它。
- en: Running shared development services in Docker
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中运行共享开发服务
- en: Services such as source control and the image registry are good candidates to
    be shared between many projects. They have similar requirements for high availability
    and reliable storage, so they can be deployed across a cluster that has enough
    capacity for many projects. The CI server can be run as a shared service or as
    a separate instance for each team or project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如源代码控制和镜像注册表之类的服务是很适合在多个项目之间共享的候选项。它们对于高可用性和可靠存储有类似的要求，因此可以部署在具有足够容量的集群上，以满足许多项目的需求。CI服务器可以作为共享服务运行，也可以作为每个团队或项目的单独实例运行。
- en: I covered running a private registry in a Docker container in [Chapter 4](cba48cea-1666-4d9a-a268-ee2a104f5565.xhtml),
    *Sharing Images with Docker Registries*. Here, we'll look at running a Git server
    and a CI server in Docker.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第4章](cba48cea-1666-4d9a-a268-ee2a104f5565.xhtml)中介绍了在Docker容器中运行私有注册表，*使用Docker注册表共享镜像*。在这里，我们将看看如何在Docker中运行Git服务器和CI服务器。
- en: Packaging a Git server into a Windows Docker image
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Git服务器打包到Windows Docker镜像中
- en: Gogs is a popular open source Git server. It's written in Go, which is cross
    platform, and you can package it as a Docker image based on a minimal Nano Server
    installation or on Windows Server Core. Gogs is a simple Git server; it provides
    remote repository access over HTTP and HTTPS, and it has a web UI. The Gogs team
    provides images on Docker Hub for Linux, but you need to build your own to run
    in Windows containers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Gogs是一个流行的开源Git服务器。它是用Go语言编写的，跨平台，可以将其打包为基于最小Nano Server安装或Windows Server Core的Docker镜像。Gogs是一个简单的Git服务器；它通过HTTP和HTTPS提供远程存储库访问，并且具有Web
    UI。Gogs团队在Docker Hub上提供了Linux的镜像，但您需要构建自己的镜像以在Windows容器中运行。
- en: 'Packaging Gogs in a Docker image is straightforward. It''s a case of scripting
    the installation instructions in a Dockerfile, which I''ve done for the `dockeronwindows/ch10-gogs:2e`
    image. That image uses a multi-stage build, starting with Windows Server Core,
    to download the Gogs release and expand the ZIP file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将Gogs打包到Docker镜像中非常简单。这是在Dockerfile中编写安装说明的情况，我已经为`dockeronwindows/ch10-gogs:2e`镜像完成了这个过程。该镜像使用多阶段构建，从Windows
    Server Core开始，下载Gogs发布并展开ZIP文件。
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There's nothing new here, but there are a couple of points worth looking at.
    The Gogs team provides a CDN with their releases, and the URLs use the same format,
    so I have parameterized the version number to download. The `ARG` instruction
    uses a default Gogs version of `0.11.86`, but I can install a different version
    without changing the Dockerfile by specifying a build argument.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新东西，但有几点值得关注。Gogs团队提供了一个CDN来发布他们的版本，并且URL使用相同的格式，所以我已经将版本号参数化为可下载。`ARG`指令使用默认的Gogs版本`0.11.86`，但我可以通过指定构建参数来安装不同的版本，而无需更改Dockerfile。
- en: To make it clear which version is being installed, I write that out before downloading
    the ZIP file. The download is in a separate `RUN` instruction, so the downloaded
    file gets stored in its own layer in the Docker cache. If I need to edit the later
    steps in the Dockerfile, I can build the image again and get the downloaded file
    from the cache, so it doesn't need to be downloaded repeatedly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地表明正在安装的版本，我在下载ZIP文件之前写出了版本号。下载在单独的`RUN`指令中进行，因此下载的文件被存储在Docker缓存中的自己的层中。如果我需要编辑Dockerfile中的后续步骤，我可以再次构建镜像，并从缓存中获取已下载的文件，因此不需要重复下载。
- en: 'The final image could be based on Nano Server, as Gogs is a cross-platform
    technology, but it has dependencies on Git tooling that are difficult to set up
    in Nano Server. It''s straightforward to install the dependencies with Chocolatey,
    but that doesn''t work in Nano Server. I''m using `sixeyed/chocolatey` for the
    base application image, which is a public image on Docker Hub with Chocolatey
    installed on top of Windows Server Core, and then I set up the environment for
    Gogs:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最终镜像可以基于Nano Server，因为Gogs是一个跨平台技术，但它依赖于难以在Nano Server中设置的Git工具。使用Chocolatey很容易安装依赖项，但在Nano
    Server中无法使用。我正在使用`sixeyed/chocolatey`作为基础应用程序镜像，这是Docker Hub上的一个公共镜像，在Windows
    Server Core上安装了Chocolatey，然后我为Gogs设置了环境：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I'm capturing the Gogs version and the installation path as `ARG` instructions,
    so that they can be specified at build time. Build arguments aren't stored in
    the final image, so I copy them into environment variables in the `ENV` instructions.
    Gogs uses port `3000` by default, and I create volumes for all the data, logs,
    and repository directories.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在捕获Gogs版本和安装路径作为`ARG`指令，以便它们可以在构建时指定。构建参数不会存储在最终镜像中，所以我将它们复制到`ENV`指令中的环境变量中。Gogs默认使用端口`3000`，我为所有数据、日志和存储库目录创建卷。
- en: 'Gogs is a Git server, but it doesn''t include Git in the release, which is
    why I''m using an image with Chocolatey installed. I use the `choco` command line
    to install `git`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Gogs是一个Git服务器，但它的发布版本中不包括Git，这就是为什么我使用了安装了Chocolatey的镜像。我使用`choco`命令行来安装`git`：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, I copy in the expanded `Gogs` directory from the installer stage,
    and bundle a default set of configurations from the local `app.ini` file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我从安装程序阶段复制了扩展的`Gogs`目录，并从本地的`app.ini`文件中捆绑了一组默认配置：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Building this image gives me a Git server that I can run in a Windows container.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 构建这个镜像给我一个可以在Windows容器中运行的Git服务器。
- en: It's not a best practice to have an application image that uses a larger base
    image than it needs, and includes installation tools such as Chocolatey. If my
    Gogs container was compromised, the attacker would have access to the `choco`
    command as well as all the features of PowerShell. In this case, the container
    won't be on a public network, so the risks are mitigated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用比所需更大的基础镜像以及包括Chocolatey等安装工具的应用程序镜像并不是最佳实践。如果我的Gogs容器受到攻击，攻击者将可以访问`choco`命令以及PowerShell的所有功能。在这种情况下，容器不会在公共网络上，因此风险得到了缓解。
- en: Running the Gogs Git server in Docker
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中运行Gogs Git服务器
- en: 'You run Gogs just like any other container: setting it to be detached, publishing
    the HTTP port, and using a host mount to store the volumes in known locations
    outside of the container:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像运行任何其他容器一样运行Gogs：将其设置为分离状态，发布HTTP端口，并使用主机挂载将卷存储在容器之外已知位置：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The Gogs image has default configuration settings bundled inside it, but when
    you first run the application, you need to complete an installation wizard. I
    can browse to `http://localhost:3000`, leave the default values, and click the
    Install Gogs button:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Gogs镜像内置了默认配置设置，但当您第一次运行应用程序时，您需要完成安装向导。我可以浏览到`http://localhost:3000`，保留默认值，并点击安装Gogs按钮：
- en: '![](Images/25fa9119-bc6b-4f11-9fe2-edabd0b2d520.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/25fa9119-bc6b-4f11-9fe2-edabd0b2d520.png)'
- en: 'Now, I can register a user and sign in, which takes me to the Gogs dashboard:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以注册用户并登录，这将带我到Gogs仪表板：
- en: '![](Images/729ae508-9bc9-46ae-9fdb-1e3c84e7b997.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/729ae508-9bc9-46ae-9fdb-1e3c84e7b997.png)'
- en: Gogs supports issue tracking and pull requests in addition to the usual Git
    features, so it's very much like a slimmed-down local version of GitHub. I've
    gone on to create a repository called `docker-on-windows` to store the source
    code for this book. To use it, I need to add the Gogs server as a remote in my
    local Git repository.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Gogs支持问题跟踪和拉取请求，除了通常的Git功能，因此它非常类似于GitHub的精简本地版本。我继续创建了一个名为`docker-on-windows`的存储本书源代码的存储库。为了使用它，我需要将Gogs服务器添加为我的本地Git存储库的远程。
- en: 'I''ve used `gogs` as the container name, so other containers can reach the
    Git server by that name. I''ve also added an entry into my hosts file with the
    same name that points to the local machine, so I can use the same `gogs` name
    on my machine and inside containers (this is in `C:\Windows\System32\drivers\etc\hosts`):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`gogs`作为容器名称，所以其他容器可以通过该名称访问Git服务器。我还在我的主机文件中添加了一个与本地机器指向相同名称的条目，这样我就可以在我的机器和容器内使用相同的`gogs`名称（这在`C:\Windows\System32\drivers\etc\hosts`中）：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I tend to do this quite a lot, adding the local machine or container IP addresses
    to my hosts file. I have a PowerShell alias set up to make it easier, which gets
    the container IP address and adds the line to the hosts file. I've blogged about
    this and other aliases I use at [https://blog.sixeyed.com/your-must-have-powershell-aliases-for-docker](https://blog.sixeyed.com/your-must-have-powershell-aliases-for-docker).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于经常这样做，将本地机器或容器IP地址添加到我的主机文件中。我设置了一个PowerShell别名，使这一过程更加简单，它可以获取容器IP地址并将该行添加到主机文件中。我在[https://blog.sixeyed.com/your-must-have-powershell-aliases-for-docker](https://blog.sixeyed.com/your-must-have-powershell-aliases-for-docker)上发表了这一点以及我使用的其他别名。
- en: 'Now, I can push source code from my local machine to Gogs just like any other
    remote Git server, such as GitHub or GitLab. It''s running in a local container,
    but that''s transparent to the Git client on my laptop:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以像将源代码推送到GitHub或GitLab等其他远程Git服务器一样，从我的本地机器推送源代码到Gogs。它在本地容器中运行，但对于我笔记本上的Git客户端来说是透明的。
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Gogs is stable and lightweight in a Docker container. My instance typically
    uses 50 MB of memory and less than 1% CPU when idle.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Gogs在Docker容器中是稳定且轻量的。我的实例在空闲时通常使用50MB的内存和少于1%的CPU。
- en: Running a local Git server is a good idea, even if you use a hosted service
    such as GitHub or GitLab. Hosted services have outages, and, although rare, they
    can have a significant impact on productivity. Having a local secondary running
    with very little cost can protect you from being impacted when the next outage
    occurs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 运行本地Git服务器是一个好主意，即使你使用托管服务如GitHub或GitLab。托管服务会出现故障，尽管很少，但可能会对生产力产生重大影响。拥有一个本地次要运行成本很低的服务器可以保护你免受下一次故障发生时的影响。
- en: The next step is to run a CI server in Docker that can fetch code from Gogs
    and build the application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在Docker中运行一个CI服务器，该服务器可以从Gogs获取代码并构建应用程序。
- en: Packaging a CI server into a Windows Docker image
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将CI服务器打包成Windows Docker镜像
- en: Jenkins is a popular automation server that is used for CI/CD. It supports custom
    job workflows with multiple trigger types, including schedules, SCM polling, and
    manual starts. It's a Java application that is straightforward to package in Docker,
    although it's not so simple to fully automate the Jenkins setup.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是一个流行的自动化服务器，用于CI/CD。它支持具有多种触发类型的自定义作业工作流程，包括计划、SCM轮询和手动启动。它是一个Java应用程序，可以很容易地在Docker中打包，尽管完全自动化Jenkins设置并不那么简单。
- en: 'In the source code for this chapter, I have a Dockerfile for the `dockersamples/ch10-jenkins-base:2e` image.
    This Dockerfile packages a clean installation of Jenkins, using Windows Server
    Core in the installation stage to download the Jenkins web archive. I use an argument
    to capture the Jenkins version, and the installer also downloads the SHA256 hash
    for the download and checks that the downloaded file hasn''t been corrupted:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的源代码中，我有一个用于`dockersamples/ch10-jenkins-base:2e`映像的Dockerfile。这个Dockerfile使用Windows
    Server Core在安装阶段下载Jenkins web存档文件，打包了一个干净的Jenkins安装。我使用一个参数来捕获Jenkins版本，安装程序还会下载下载的SHA256哈希并检查下载的文件是否已损坏：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Checking the file hash for a download is an important security task to make
    sure that the file you download is the same as the one the publisher made available.
    It's a step that people typically leave out when they manually install software,
    but it's easy to automate in your Dockerfile and it gives you a more secure deployment.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 检查下载文件的哈希值是一个重要的安全任务，以确保您下载的文件与发布者提供的文件相同。这是人们通常在手动安装软件时忽略的一步，但在Dockerfile中很容易自动化，并且可以为您提供更安全的部署。
- en: 'The final stage of the Dockerfile uses the official OpenJDK image as the base,
    sets up the environment, and copies in the download from the installer stage:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile的最后阶段使用官方的OpenJDK映像作为基础，设置环境，并从安装程序阶段复制下载的文件：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A clean Jenkins installation doesn't have many useful features; almost all functionality
    is provided by plugins that you install after Jenkins is set up. Some of these
    plugins also install the dependencies they need, but others don't. For my CI/CD
    pipeline, I need a Git client in Jenkins so that it can connect to the Git server
    running in Docker, and I also want the Docker CLI so that I can use Docker commands
    in my builds.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 干净的Jenkins安装没有太多有用的功能；几乎所有功能都是在设置Jenkins之后安装的插件提供的。其中一些插件还会安装它们所需的依赖项，但其他一些则不会。对于我的CI/CD流水线，我需要在Jenkins中安装Git客户端，以便它可以连接到在Docker中运行的Git服务器，并且我还希望安装Docker
    CLI，以便我可以在构建中使用Docker命令。
- en: I can install these dependencies in the Jenkins Dockerfile, but that would make
    it large and difficult to manage. Instead, I'm going to fetch these tools from
    other Docker images. I'm using `sixeyed/git` and `sixeyed/docker-cli`, which are
    public images on Docker Hub. I use these along with the Jenkins base image to
    build my final Jenkins image.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在Jenkins的Dockerfile中安装这些依赖项，但这将使其变得庞大且难以管理。相反，我将从其他Docker映像中获取这些工具。我使用的是`sixeyed/git`和`sixeyed/docker-cli`，这些都是Docker
    Hub上的公共映像。我将这些与Jenkins基础映像一起使用，构建我的最终Jenkins映像。
- en: 'The Dockerfile for `dockeronwindows/ch10-jenkins:2e` starts from the base and
    copies in the binaries from the Git and Docker CLI images:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`dockeronwindows/ch10-jenkins:2e`的Dockerfile从基础开始，并从Git和Docker CLI映像中复制二进制文件：'
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final line just adds all the new tool locations to the system path so that
    Jenkins can find them:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行只是将所有新的工具位置添加到系统路径中，以便Jenkins可以找到它们：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using public Docker images for the dependencies gives me a final Jenkins image
    with all the components I need, but with a manageable Dockerfile using a set of
    reusable source images. Now, I can run Jenkins in a container and finish the setup
    by installing plugins.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公共Docker映像来获取依赖项，可以让我得到一个包含所有所需组件的最终Jenkins映像，但使用一组可重用的源映像编写一个可管理的Dockerfile。现在，我可以在容器中运行Jenkins，并通过安装插件完成设置。
- en: Running the Jenkins automation server in Docker
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中运行Jenkins自动化服务器
- en: 'Jenkins uses port `8080` for the Web UI, so you can run it from the image in
    this chapter using this command, which maps the port and mounts a local folder
    for the Jenkins root directory:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins使用端口`8080`用于Web UI，因此您可以使用以下命令从本章的映像中运行它，该命令映射端口并挂载本地文件夹到Jenkins根目录：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Jenkins generates a random administrator password for each new deployment.
    I can fetch that password from the container logs before I browse to the site:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins为每个新部署生成一个随机的管理员密码。我可以在浏览网站之前从容器日志中获取该密码：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, I will browse to port `8080` on localhost, enter the generated password,
    and add the Jenkins plugins I need. As a bare minimum example, I''ve chosen to
    customize the plugin installation and chosen the Folders, Credentials Binding,
    and Git plugins, which gives me most of the functionality I require:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将浏览本地主机上的端口`8080`，输入生成的密码，并添加我需要的Jenkins插件。作为最简单的示例，我选择了自定义插件安装，并选择了文件夹、凭据绑定和Git插件，这样我就可以获得大部分所需的功能：
- en: '![](Images/70485e78-a4b8-4455-bde2-bb6d97d03c8a.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/70485e78-a4b8-4455-bde2-bb6d97d03c8a.png)'
- en: 'I need one more plugin to run PowerShell scripts in build jobs. This isn''t
    a recommended plugin so it doesn''t show in the initial setup list. Once Jenkins
    starts, I go to Manage Jenkins | Manage Plugins, and, from the Available list,
    I choose PowerShell and click on Install without restart:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要一个插件来在构建作业中运行PowerShell脚本。这不是一个推荐的插件，因此它不会显示在初始设置列表中。一旦Jenkins启动，我转到“管理Jenkins
    | 管理插件”，然后从“可用”列表中选择PowerShell并单击“无需重启安装”：
- en: '![](Images/fb15f9c8-c31c-4d2b-a3b7-3c6d8d03dfaa.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fb15f9c8-c31c-4d2b-a3b7-3c6d8d03dfaa.png)'
- en: When this is complete, I have all the infrastructure services I need to run
    my CI/CD pipeline. However, they're running in containers that have been customized.
    The apps in the Gogs and Jenkins containers have been through a manual setup stage
    and are not in the same state as the image they run from. If I replace the containers,
    I'll lose the additional setup that I did. I can get around that by creating images
    from the containers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我拥有了运行CI/CD流水线所需的所有基础设施服务。但是，它们运行在已经定制过的容器中。Gogs和Jenkins容器中的应用程序经历了手动设置阶段，并且与它们运行的镜像不处于相同的状态。如果我替换容器，我将丢失我所做的额外设置。我可以通过从容器创建镜像来解决这个问题。
- en: Committing images from running containers
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从运行的容器中提交镜像
- en: You should build your images from a Dockerfile. That's a repeatable process
    in a script that can be stored in source control for versioning, comparison, and
    authorization. But there are some applications that need additional setup steps
    after the application is deployed, and those steps need to be executed manually.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从Dockerfile构建您的镜像。这是一个可重复的过程，可以存储在源代码控制中进行版本控制、比较和授权。但是有一些应用程序在部署后需要额外的设置步骤，并且这些步骤需要手动执行。
- en: Jenkins is a good example of this. You can automate the plugin installation
    with Jenkins, but it requires an additional download and some scripting of the
    Jenkins API. Plugin dependencies are not always resolved when you install that
    way, so it can be safer to manually set up the plugins and verify the deployment.
    Once you've done that, you can persist the final setup by committing the container,
    which generates a new Docker image from the container's current state.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是一个很好的例子。您可以使用Jenkins自动安装插件，但这需要额外的下载和一些Jenkins API的脚本编写。插件依赖关系并不总是在安装时解决，因此手动设置插件并验证部署可能更安全。完成后，您可以通过提交容器来保持最终设置，从容器的当前状态生成新的Docker镜像。
- en: 'On Windows, you need to stop containers to commit them, and then run `docker
    container commit`, giving the name of the container and the new image tag to create:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，您需要停止容器才能提交它们，然后运行`docker container commit`，并提供容器的名称和要创建的新镜像标签：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For my setup, I've committed Jenkins and Gogs and I have a Docker Compose file
    to configure them, together with the registry container. These are infrastructure
    components, but this is still a distributed solution. The Jenkins container will
    access the Gogs and registry containers. The services all have the same SLA, so
    defining them in a Compose file lets me capture that and start all the services
    together.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的设置，我已经提交了Jenkins和Gogs，并且有一个Docker Compose文件来配置它们，以及注册表容器。这些是基础设施组件，但这仍然是一个分布式解决方案。Jenkins容器将访问Gogs和注册表容器。所有服务都具有相同的SLA，因此在Compose文件中定义它们可以让我捕获并一起启动所有服务。
- en: Configuring CI/CD using Jenkins in Docker
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中使用Jenkins配置CI/CD
- en: I'll configure my Jenkins build job to poll the Git repository and use Git pushes
    as the trigger for a new build.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我将配置我的Jenkins构建作业来轮询Git存储库，并使用Git推送作为新构建的触发器。
- en: Jenkins will connect to Git through the repository URL for Gogs, and all the
    actions to build, test, and deploy the solution will run as Docker containers.
    The Gogs server and the Docker Engine have different authentication models, but
    Jenkins supports many credential types. I can configure the build job to securely
    access the source repository and Docker on the host.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins将通过Gogs的存储库URL连接到Git，并且构建、测试和部署解决方案的所有操作都将作为Docker容器运行。Gogs服务器和Docker引擎具有不同的身份验证模型，但Jenkins支持许多凭据类型。我可以配置构建作业以安全地访问源存储库和主机上的Docker。
- en: Setting up Jenkins credentials
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Jenkins凭据
- en: Gogs integrates with external identity providers and also features its own basic
    username/password authentication, which I'm using in my setup. This is not secure
    over HTTP, so, in a real environment, I would use SSH or HTTPS for Git, either
    by packaging a **Secure Sockets Layer** (**SSL**) certificate in the image, or
    by using a proxy server in front of Gogs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Gogs与外部身份提供者集成，还具有自己的基本用户名/密码身份验证功能，我在我的设置中使用了它。这在HTTP上不安全，因此在真实环境中，我将使用SSH或HTTPS进行Git，可以通过在镜像中打包SSL证书，或者在Gogs前面使用代理服务器来实现。
- en: 'In the `Users` section of the Gogs admin interface, I''ve created a `jenkins`
    user and given it read access to the `docker-on-windows` Git repository, which
    I''ll use for my sample CI/CD job:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gogs管理界面的“用户”部分，我创建了一个“jenkins”用户，并为其赋予了对“docker-on-windows”Git存储库的读取权限，这将用于我的示例CI/CD作业：
- en: '![](Images/2f498d84-eb8f-4736-98db-af02df316ae2.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2f498d84-eb8f-4736-98db-af02df316ae2.png)'
- en: 'Jenkins will pull the source code repository from Gogs, authenticating as the
    `jenkins` user. I''ve added the username and password to Jenkins as global credentials
    so that they can be used by any job:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins将作为`jenkins`用户进行身份验证，从Gogs拉取源代码存储库。我已将用户名和密码添加到Jenkins作为全局凭据，以便任何作业都可以使用：
- en: '![](Images/7340759f-72e0-4e85-813e-65ba10c4dee1.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7340759f-72e0-4e85-813e-65ba10c4dee1.png)'
- en: Jenkins doesn't display the password once entered, and it records an audit trail
    for all the jobs that use the credential, so this is a secure way of authenticating.
    My Jenkins container is running with a volume that mounts the Docker named pipe
    from the Windows host so that it can work with the Docker Engine without authenticating.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins在输入密码后不显示密码，并记录使用凭据的所有作业的审计跟踪，因此这是一种安全的身份验证方式。我的Jenkins容器正在运行，它使用一个卷将Windows主机的Docker命名管道挂载，以便它可以在不进行身份验证的情况下与Docker引擎一起工作。
- en: As an alternative, I could connect to a remote Docker API over TCP. To authenticate
    with Docker, I would use the **Transport Layer Security** (**TLS**) certificates
    I generated when securing the Docker engine. There are three certificates—the
    **Certificate Authority** (**CA**), the client certificate, and the client key.
    They need to be passed to the Docker CLI as file paths, and Jenkins supports this
    with credentials that can be saved as secret files, thus storing the certificate
    PEM files in Jenkins.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，我可以通过TCP连接到远程Docker API。要使用Docker进行身份验证，我将使用在保护Docker引擎时生成的**传输层安全性**（**TLS**）证书。有三个证书——**证书颁发机构**（**CA**），客户端证书和客户端密钥。它们需要作为文件路径传递给Docker
    CLI，并且Jenkins支持使用可以保存为秘密文件的凭据来存储证书PEM文件。
- en: Configuring the Jenkins CI job
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Jenkins CI作业
- en: In this chapter, the sample solution is in the `ch10-nerd-dinner` folder. It's
    the modernized NerdDinner application that has evolved over the previous chapters.
    There's a Dockerfile for every component. This uses a multi-stage build, and a
    set of Docker Compose files for building and running the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，示例解决方案位于`ch10-nerd-dinner`文件夹中。这是现代化的NerdDinner应用程序，在前几章中已经发展过了。每个组件都有一个Dockerfile。这使用了多阶段构建，并且有一组Docker
    Compose文件用于构建和运行应用程序。
- en: The folder structure here is worth looking at to see how distributed applications
    are usually arranged—the `src` folder contains all the application and database
    source code, the `docker` folder contains all the Dockerfiles, and the `compose`
    folder contains all the Compose files.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的文件夹结构值得一看，以了解分布式应用程序通常是如何排列的——`src`文件夹包含所有应用程序和数据库源代码，`docker`文件夹包含所有Dockerfile，`compose`文件夹包含所有Compose文件。
- en: 'I''ve created a freestyle job in Jenkins to run the build, and configured Git
    for source code management. It''s simple to configure Git—I''m using the same
    repository URL that I use for the Git repository on my laptop, and I''ve selected
    the Gogs credentials so that Jenkins can access them:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Jenkins中创建了一个自由风格的作业来运行构建，并配置了Git进行源代码管理。配置Git很简单，我使用的是在笔记本电脑上Git存储库中使用的相同存储库URL，并且我已经选择了Gogs凭据，以便Jenkins可以访问它们：
- en: '![](Images/3830a303-627f-4ede-bf31-101c321f60ff.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3830a303-627f-4ede-bf31-101c321f60ff.png)'
- en: Jenkins is running in a Docker container, and Gogs is running in a container
    on the same Docker network. I'm using the hostname `gogs`, which is the container
    name, so that Jenkins can reach the Git server. On my laptop, I've add `gogs`
    as an entry in my hosts file, so I can use the same repository URL in development
    and on the CI server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins正在Docker容器中运行，Gogs也在同一Docker网络的容器中运行。我正在使用主机名`gogs`，这是容器名称，以便Jenkins可以访问Git服务器。在我的笔记本电脑上，我已经在hosts文件中添加了`gogs`作为条目，这样我就可以在开发和CI服务器上使用相同的存储库URL。
- en: Jenkins supports multiple types of build triggers. In this case, I'm going to
    poll the Git server on a set schedule. I'm using `H/5 * * * *` as the schedule
    frequency, which means Jenkins will check the repository every five minutes. If
    there are any new commits since the last build, Jenkins will run the job.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins支持多种类型的构建触发器。在这种情况下，我将定期轮询Git服务器。我使用`H/5 * * * *`作为调度频率，这意味着Jenkins将每五分钟检查存储库。如果自上次构建以来有任何新的提交，Jenkins将运行作业。
- en: That's all the job configuration I need, and all the build steps will now run
    using Docker containers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我需要的所有作业配置，所有构建步骤现在将使用Docker容器运行。
- en: Building the solution using Docker in Jenkins
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jenkins中使用Docker构建解决方案
- en: 'The build steps use PowerShell, running simple scripts so that there''s no
    dependency on more complex Jenkins plugins. There are plugins specific to Docker
    that wrap up several tasks, such as building images and pushing them to a registry,
    but I can do everything I need with basic PowerShell steps and the Docker CLI.
    The first step builds all the images:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构建步骤使用PowerShell运行简单的脚本，因此不依赖于更复杂的Jenkins插件。有一些特定于Docker的插件，可以包装多个任务，比如构建镜像并将其推送到注册表，但我可以使用基本的PowerShell步骤和Docker
    CLI来完成我需要的一切。第一步构建所有的镜像：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It would be much nicer to use `docker-compose build` with override files, but
    there's an outstanding issue with the Docker Compose CLI, which means it doesn't
    work correctly with named pipes inside a container. When this is resolved in a
    future release of Compose, the build steps will be simpler.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker-compose build`和覆盖文件会更好，但是Docker Compose CLI存在一个未解决的问题，这意味着它在容器内部无法正确使用命名管道。当这个问题在未来的Compose版本中得到解决时，构建步骤将更简单。
- en: 'Docker Compose is open source, and you can check on the status of this issue
    on GitHub here: [https://github.com/docker/compose/issues/5934](https://github.com/docker/compose/issues/5934).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose是开源的，您可以在GitHub上查看此问题的状态：[https://github.com/docker/compose/issues/5934](https://github.com/docker/compose/issues/5934)。
- en: Docker builds the images using multi-stage Dockerfiles, and each step of the
    build executes in a temporary Docker container. Jenkins itself is running in a
    container, and it has the Docker CLI available in the image. I haven't had to
    install Visual Studio on a build server, or even install the .NET Framework or
    the .NET Core SDKs. All the prerequisites are in Docker images, so the Jenkins
    build just needs the source code and Docker.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用多阶段Dockerfile构建镜像，构建的每个步骤在临时Docker容器中执行。Jenkins本身运行在一个容器中，并且它的镜像中有Docker
    CLI。我不需要在构建服务器上安装Visual Studio，甚至不需要安装.NET Framework或.NET Core SDK。所有的先决条件都在Docker镜像中，所以Jenkins构建只需要源代码和Docker。
- en: Running and verifying the solution
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行和验证解决方案
- en: 'The next build step in Jenkins will deploy the solution locally, running in
    Docker containers, and verify that the build is working correctly. This step is
    another PowerShell script, which starts by deploying the application with `docker
    container run` commands:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins中的下一个构建步骤将在本地部署解决方案，运行在Docker容器中，并验证构建是否正常工作。这一步是另一个PowerShell脚本，它首先通过`docker
    container run`命令部署应用程序：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One advantage of using the Docker CLI over Compose in the build is that I can
    create containers in a specific order, which gives more time for slow-starting
    applications such as the NerdDinner website to be ready before testing them. I'm
    also adding a label, `ci`, to all the containers, which I can use later to clean
    up all the test containers, without removing any other containers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建中使用Docker CLI而不是Compose的一个优势是，我可以按特定顺序创建容器，这样可以给慢启动的应用程序（如NerdDinner网站）更多的时间准备好，然后再进行测试。我还给所有的容器添加了一个标签`ci`，以便稍后清理所有的测试容器，而不会删除其他容器。
- en: 'After this step is completed, all the containers should be running. Before
    I run the end-to-end test suite, which could be a lengthy operation, I have another
    PowerShell step in the build that runs a simple verification test to make sure
    that the application responds:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，所有的容器应该都在运行。在运行可能需要很长时间的端到端测试套件之前，我在构建中有另一个PowerShell步骤，运行一个简单的验证测试，以确保应用程序有响应。
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Remember that these commands are running inside the Jenkins container, which
    means it can access other containers by name. I don't need to publish specific
    ports or inspect containers to get their IP addresses. The script starts the Traefik
    container with the name `nerd-dinner-test`, and all the frontend containers use
    that same hostname in their Traefik rules. The Jenkins job can access that URL
    and the app will respond if the build has been successful.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些命令是在Jenkins容器内运行的，这意味着它可以通过名称访问其他容器。我不需要发布特定的端口或检查容器以获取它们的IP地址。脚本使用名称`nerd-dinner-test`启动Traefik容器，并且所有前端容器在其Traefik规则中使用相同的主机名。Jenkins作业可以访问该URL，如果构建成功，应用程序将做出响应。
- en: 'At this point, the application has been built from the latest source code,
    and it''s all up and running in containers. I''ve verified that the home page
    is accessible, which proves that the site is working. The build steps are all
    console commands, so the output will be written to the job log in Jenkins. For
    every build, you will see all the output, including the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，应用程序已经从最新的源代码构建，并且在容器中全部运行。我已经验证了主页是可访问的，这证明了网站正在运行。构建步骤都是控制台命令，因此输出将被写入Jenkins作业日志中。对于每个构建，您将看到所有输出，包括以下内容：
- en: Docker executing the Dockerfile commands
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker执行Dockerfile命令
- en: NuGet and MSBuild steps compiling the application
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NuGet和MSBuild步骤编译应用程序
- en: Docker starting application containers
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker启动应用程序容器
- en: PowerShell making the web request to the application
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell向应用程序发出Web请求
- en: The `Invoke-WebRequest` cmdlet is a simple build verification test. It gives
    an error if the build or deployment has failed, but, if it succeeds, that still
    does not mean the application is working correctly. For greater confidence in
    the build, I run end-to-end integration tests in the next build step.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoke-WebRequest`命令是一个简单的构建验证测试。如果构建或部署失败，它会产生错误，但是，如果成功，这仍不意味着应用程序正常工作。为了增强对构建的信心，我在下一个构建步骤中运行端到端集成测试。'
- en: Running end-to-end tests in Docker
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中运行端到端测试
- en: There's one more component I've added to the NerdDinner solution in this chapter,
    which is a test project that uses a simulated browser to interact with the web
    application. The browser sends HTTP requests to an endpoint, which will actually
    be a container, and asserts that the responses contain the correct content.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我还添加了NerdDinner解决方案的另一个组件，即使用模拟浏览器与Web应用程序进行交互的测试项目。浏览器向端点发送HTTP请求，实际上将是一个容器，并断言响应包含正确的内容。
- en: The `NerdDinner.EndToEndTests` project uses SpecFlow to define feature tests,
    stating the expected behavior of the solution. The SpecFlow tests are executed
    using Selenium, which automates browser testing, and SimpleBrowser, which presents
    a headless browser. These are web tests that can be run from the console, so no
    UI components are needed and the tests can be executed in a Docker container.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`NerdDinner.EndToEndTests`项目使用SpecFlow来定义功能测试，说明解决方案的预期行为。使用Selenium执行SpecFlow测试，Selenium自动化浏览器测试，以及SimpleBrowser，提供无头浏览器。这些都是可以从控制台运行的Web测试，因此不需要UI组件，并且可以在Docker容器中执行。'
- en: 'If that sounds like a lot of technology to add to your test infrastructure,
    it''s actually a very neat way to perform a full integration test of the application,
    which has been specified in simple scenarios that use human language:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来像是要添加到您的测试基础设施中的大量技术，实际上这是一种非常巧妙的方式，可以对应用程序进行完整的集成测试，这些测试已经在使用人类语言的简单场景中指定了：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I have a Dockerfile to build the test project into the `dockeronwindows/ch10-nerd-dinner-e2e-tests:2e`
    image. It uses a multi-stage build to compile the test project and then package
    the test assembly. The final stage of the build uses an image on Docker Hub that
    has the NUnit Console Runner installed, so it is able to run the end-to-end tests
    through the console. The Dockerfile sets up a `CMD` instruction to run all the
    tests when the container starts:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个Dockerfile来将测试项目构建成`dockeronwindows/ch10-nerd-dinner-e2e-tests:2e`镜像。它使用多阶段构建来编译测试项目，然后打包测试程序集。构建的最后阶段使用了Docker
    Hub上安装了NUnit控制台运行器的镜像，因此它能够通过控制台运行端到端测试。Dockerfile设置了一个`CMD`指令，在容器启动时运行所有测试：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I can run a container from this image and it will start the test suite, connecting
    to `http://nerd-dinner-test` and asserting that the content in the response contains
    the expected header text. This one simple test actually verifies that my new home
    page container and the reverse proxy container are both running, that they can
    access each other on the Docker network, and that the proxy rules have been set
    up correctly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以从这个镜像中运行一个容器，它将启动测试套件，连接到`http://nerd-dinner-test`，并断言响应中包含预期的标题文本。这个简单的测试实际上验证了我的新主页容器和反向代理容器都在运行，它们可以在Docker网络上相互访问，并且代理规则已经正确设置。
- en: I only have one scenario in my tests, but because the whole stack is running
    in containers, it's very easy to write a suite of high-value tests that execute
    the key features of the app. I could build a custom database image with known
    test data and write simple scenarios to verify the user-login, list-dinner, and
    create-dinner workflows. I could even query the SQL Server container in the test
    assertions to make sure that new data is inserted.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我的测试中只有一个场景，但因为整个堆栈都在容器中运行，所以很容易编写一套执行应用程序关键功能的高价值测试。我可以构建一个包含已知测试数据的自定义数据库镜像，并编写简单的场景来验证用户登录、列出晚餐和创建晚餐的工作流。我甚至可以在测试断言中查询SQL
    Server容器，以确保新数据已插入。
- en: 'The next step of the Jenkins build runs these end-to-end tests. Again, it''s
    a simple PowerShell script that does this, building the end-to-end Docker image,
    and then running a container. The test container will execute in the same Docker
    network as the application, so the headless browser can reach the web application
    using the container name in the URL:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins构建的下一步是运行这些端到端测试。同样，这是一个简单的PowerShell脚本，它构建端到端Docker镜像，然后运行一个容器。测试容器将在与应用程序相同的Docker网络中执行，因此无头浏览器可以使用URL中的容器名称访问Web应用程序：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'NUnit generates an XML file with the test results, and it would be useful to
    add that to the Jenkins workspace so that it''s available to view in the Jenkins
    UI after all the containers have been removed. The PowerShell step uses `docker
    container cp` to copy that file out of the container into the current directory
    of the Jenkins workspace, using the container ID stored from the run command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: NUnit生成一个包含测试结果的XML文件，将其添加到Jenkins工作空间中会很有用，这样在所有容器被移除后可以在Jenkins UI中查看。PowerShell步骤使用`docker
    container cp`将该文件从容器复制到Jenkins工作空间的当前目录中，使用从运行命令中存储的容器ID：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There''s some additional PowerShell in this step to read the XML from that
    file and determine whether the tests have passed (you can find the full script
    in the source folder for this chapter, in the `ci\04_test.ps1` file). When it
    completes, the output from NUnit is echoed to the Jenkins log:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中还有一些额外的PowerShell来从该文件中读取XML并确定测试是否通过（您可以在本章的源文件夹中的`ci\04_test.ps1`文件中找到完整的脚本）。当完成时，NUnit的输出将被回显到Jenkins日志中：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the tests complete, the database container and all the other application
    containers are removed in the final part of the test step. This uses the `docker
    container ls` command to list the IDs of all containers with the `ci` label – those
    are the ones that were created by this job—and then forcibly removes them:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试完成时，数据库容器和所有其他应用程序容器将在测试步骤的最后部分被移除。这使用`docker container ls`命令列出所有具有`ci`标签的容器的ID
    - 这些是由此作业创建的容器 - 然后强制性地将它们删除：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, I have a set of application images that are tested and known to be good.
    The images exist only on the build server, so the next step is to push them to
    the local registry.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我有一组经过测试并已知良好的应用程序图像。这些图像仅存在于构建服务器上，因此下一步是将它们推送到本地注册表。
- en: Tagging and pushing Docker images in Jenkins
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jenkins中标记和推送Docker图像
- en: How you push images to your registry during the build process is your choice.
    You might start by tagging every image with the build number and pushing all image
    versions to the registry as part of the CI build. Projects using efficient Dockerfiles
    will have minimal differences between builds, so you benefit from cached layers,
    and the amount of storage you use in your registry shouldn't be excessive.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中如何将图像推送到您的注册表是您的选择。您可以从为每个图像打上构建编号的标签并将所有图像版本推送到注册表作为CI构建的一部分开始。使用高效的Dockerfile的项目在构建之间将具有最小的差异，因此您可以从缓存层中受益，并且您在注册表中使用的存储量不应过多。
- en: If you have larger projects with a lot of development churn and a shorter release
    cadence, the storage requirements could grow out of hand. You might move to a
    scheduled push, tagging images daily and pushing the latest build to the registry.
    Or, if you have a pipeline with a manual quality gate, the final release stage
    could push to the registry, so the only images you store are valid release candidates.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有大型项目，开发变动很多，发布周期较短，存储需求可能会失控。您可以转向定期推送，每天为图像打上标签并将最新构建推送到注册表。或者，如果您有一个具有手动质量门的流水线，最终发布阶段可以推送到注册表，因此您存储的唯一图像是有效的发布候选者。
- en: 'For my sample CI job, I''ll push to the local registry with every successful
    build once the tests have passed, using the Jenkins build number as the image
    tag. The build step to tag and push images is another PowerShell script that uses
    the `BUILD_TAG` environment variable from Jenkins for tagging:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的示例CI作业，一旦测试通过，我将在每次成功构建后将其推送到本地注册表，使用Jenkins构建编号作为图像标签。标记和推送图像的构建步骤是另一个使用Jenkins的`BUILD_TAG`环境变量进行标记的PowerShell脚本。
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This script uses  a simple loop to apply a new tag to all the built images.
    The new tag includes my local registry domain, `registry:5000`, and adds the Jenkins
    build tag as a suffix so that I can easily identify which build the image came
    from. Then, it pushes all the images to the local registry—again, this is running
    in a container in the same Docker network as the Jenkins container, so it's accessible
    by the container name `registry`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本使用一个简单的循环来为所有构建的图像应用一个新的标签。新标签包括我的本地注册表域，`registry:5000`，并将Jenkins构建标签作为后缀，以便我可以轻松地识别图像来自哪个构建。然后，它将所有图像推送到本地注册表
    - 再次强调，这是在与Jenkins容器相同的Docker网络中运行的容器中，因此可以通过容器名称`registry`访问。
- en: My registry is only configured to use HTTP, not HTTPS, so it needs to be explicitly
    added as an insecure registry in the Docker Engine configuration. I covered this
    in [Chapter 4](cba48cea-1666-4d9a-a268-ee2a104f5565.xhtml), *Sharing Images with
    Docker Registries*. The Jenkins container is using the Docker Engine on the host,
    so it uses the same configuration and can push to the registry that is running
    in another container.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我的注册表只配置为使用HTTP，而不是HTTPS，因此需要在Docker Engine配置中显式添加为不安全的注册表。我在[第4章](cba48cea-1666-4d9a-a268-ee2a104f5565.xhtml)中介绍了这一点，*与Docker注册表共享镜像*。Jenkins容器正在使用主机上的Docker
    Engine，因此它使用相同的配置，并且可以将镜像推送到在另一个容器中运行的注册表。
- en: 'After a few builds have completed, I can make a REST call to the registry API
    from my development laptop to query the tags for the `dockeronwindows/nerd-dinner-index-handler`
    repository. The API will give me a list of all the tags for my message handler
    application image so that I can verify that they''ve been pushed by Jenkins with
    the correct tags:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成了几次构建之后，我可以从开发笔记本上对注册表API进行REST调用，查询`dockeronwindows/nerd-dinner-index-handler`存储库的标签。API将为我提供我的消息处理程序应用程序镜像的所有标签列表，以便我可以验证它们是否已由Jenkins使用正确的标签推送：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The Jenkins build tag gives me the complete path to the job that created the
    images. I could also use the `GIT_COMMIT` environment variable that Jenkins provides
    to tag images with the commit ID. This makes for a much shorter tag, but the Jenkins
    build tags include the incrementing build number, so I can always find the latest
    version by ordering the tags. The Jenkins web UI shows the Git commit ID for each
    build, so it's easy to track back from the job number to the exact source revision.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins构建标签为我提供了创建镜像的作业的完整路径。我也可以使用Jenkins提供的`GIT_COMMIT`环境变量来为镜像打标签，标签中包含提交ID。这样标签会更短，但Jenkins构建标签包括递增的构建编号，因此我可以通过对标签进行排序来找到最新版本。Jenkins
    web UI显示每个构建的Git提交ID，因此很容易从作业编号追溯到确切的源代码修订版。
- en: The CI part of the build is now done. For every new push to the Git server,
    Jenkins will compile, deploy, and test the application, and then push good images
    to the local registry. The next part is deploying the solution to the public environment.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的CI部分现在已经完成。对于每次对Git服务器的新推送，Jenkins将编译、部署和测试应用程序，然后将良好的镜像推送到本地注册表。接下来是将解决方案部署到公共环境。
- en: Deploying to a remote Docker Swarm using Jenkins
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jenkins部署到远程Docker Swarm
- en: The workflow for my sample application uses a manual quality gate and separates
    the concerns for local and external artifacts. On every source code push, the
    solution is deployed locally and tests are run. If they pass, images are saved
    to the local registry. The final deployment stage is to push these images to an
    external registry and deploy the application to the public environment. This simulates
    a project approach where builds happen internally, and approved releases are then
    pushed externally.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我的示例应用程序的工作流程使用手动质量门和分离本地和外部工件的关注点。在每次源代码推送时，解决方案会在本地部署并运行测试。如果测试通过，镜像将保存到本地注册表。最终部署阶段是将这些镜像推送到外部注册表，并将应用程序部署到公共环境。这模拟了一个项目方法，其中构建在内部进行，然后批准的发布被推送到外部。
- en: In this example, I'll use public repositories on Docker Hub and deploy to a
    multi-node Docker Enterprise cluster running in Azure. I'll continue to use PowerShell
    scripts and run basic `docker` commands. The principles are exactly the same to
    push images to other registries such as DTR, and deploy to on-premises Docker
    Swarm clusters.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我将使用Docker Hub上的公共存储库，并部署到在Azure中运行的多节点Docker Enterprise集群。我将继续使用PowerShell脚本并运行基本的`docker`命令。原则上，将镜像推送到其他注册表（如DTR）并部署到本地Docker
    Swarm集群的操作是完全相同的。
- en: I've created a new Jenkins job for the deployment step, which is parameterized
    to take the version number to deploy. The version number is the job number from
    the CI build, so I can deploy a known version at any time. In the new job, I need
    some additional credentials. I've added secret files for the Docker Swarm manager's
    TLS certificates that will allow me to connect to the manager node of the Docker
    Swarm running in Azure.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我为部署步骤创建了一个新的Jenkins作业，该作业被参数化为接受要部署的版本号。版本号是CI构建的作业编号，因此我可以随时部署已知版本。在新作业中，我需要一些额外的凭据。我已经添加了用于Docker
    Swarm管理器的TLS证书的秘密文件，这将允许我连接到在Azure中运行的Docker Swarm的管理节点。
- en: 'I''m also going to push images to Docker Hub as part of the release step, so
    I''ve added a username and password credential in Jenkins that I can use to log
    in to Docker Hub. To authenticate in the job step, I''ve added a binding for the
    credentials in the deployment job, and this exposes the username and password
    as environment variables:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为发布步骤的一部分，我还将推送图像到Docker Hub，因此我在Jenkins中添加了一个用户名和密码凭据，我可以使用它来登录到Docker Hub。为了在作业步骤中进行身份验证，我在部署作业中添加了凭据的绑定，这将用户名和密码暴露为环境变量：
- en: '![](Images/ccdcae51-bcc9-4a2b-af46-a54243d3c2b6.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ccdcae51-bcc9-4a2b-af46-a54243d3c2b6.png)'
- en: 'Then, I set up the command configuration and used `docker login` in the PowerShell
    build step, specifying the credentials from the environment variables:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我设置了命令配置，并在PowerShell构建步骤中使用`docker login`，指定了环境变量中的凭据：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Registry logins are executed with the Docker CLI, but the logged-in context
    is actually stored in the Docker Engine. When I run this step in the Jenkins container,
    the host where that container is running is logged in to Docker Hub using the
    Jenkins credentials. If you follow a similar process, you need to ensure that
    the job logs out after each run, or that the engine where the build server runs
    is secure, otherwise users could access that machine and push images as the Jenkins
    account.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表登录是使用Docker CLI执行的，但登录的上下文实际上存储在Docker Engine中。当我在Jenkins容器中运行此步骤时，运行该容器的主机使用Jenkins凭据登录到Docker
    Hub。如果您遵循类似的流程，您需要确保作业在每次运行后注销，或者构建服务器运行的引擎是安全的，否则用户可能会访问该机器并以Jenkins帐户身份推送图像。
- en: Now, for each of the built images, I pull them from the local registry, tag
    them for Docker Hub, and then push them to the Hub. The initial pull is there
    in case I want to deploy a previous build. The local server cache may have been
    cleaned since the build, so this ensures that the correct image is present from
    the local registry. For Docker Hub, I use a simpler tagging format, just applying
    the version number.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于构建的每个图像，我从本地注册表中拉取它们，为Docker Hub打标签，然后将它们推送到Hub。初始拉取是为了以防我想部署以前的构建。自从构建以来，本地服务器缓存可能已被清除，因此这可以确保来自本地注册表的正确图像存在。对于Docker
    Hub，我使用更简单的标记格式，只需应用版本号。
- en: 'This script uses a PowerShell loop for pulling and pushing all the images:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用PowerShell循环来拉取和推送所有图像：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When this step completes, the images are publicly available on Docker Hub.
    Now, the last step in the deployment job runs the latest application version on
    the remote Docker Swarm using these public images. I need to generate a Compose
    file that contains the latest version numbers in the image tag, and I can use
    `docker-compose config` with override files to do that:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当此步骤完成时，图像将在Docker Hub上公开可用。现在，部署作业中的最后一步是使用这些公共图像在远程Docker Swarm上运行最新的应用程序版本。我需要生成一个包含图像标记中最新版本号的Compose文件，并且我可以使用`docker-compose
    config`与覆盖文件来实现：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `docker-compose.latest.yml` file is the last one that''s added in the command,
    and it uses the `VERSION_NUMBER` environment variable, which is populated by Jenkins
    to create the image tags:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.latest.yml`文件是添加的最后一个文件，并且使用`VERSION_NUMBER`环境变量，该变量由Jenkins填充以创建图像标签：'
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `config` command isn't affected by the issue that stops you from using Docker
    Compose to deploy containers when you're running inside a container using named
    pipes. `docker-compose config` just joins and parses the files—it doesn't communicate
    with the Docker Engine.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`config`命令不受影响，无法使用Docker Compose在使用命名管道的容器内部署容器的问题。`docker-compose config`只是连接和解析文件，它不与Docker
    Engine通信。'
- en: 'Now, I have a Docker Compose file with all the setup for my hybrid Linux and
    Windows Docker Swarm, using the latest versioned application images from Docker
    Hub. The final step uses `docker stack deploy` to actually run the stack on the
    remote swarm:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我有一个Docker Compose文件，其中包含我混合使用最新版本的应用程序镜像从Docker Hub的Linux和Windows Docker
    Swarm的所有设置。最后一步使用`docker stack deploy`来实际在远程swarm上运行堆栈：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This last command uses a secured TCP connection to the Docker API on the remote
    swarm manager. The `$config` object is set up with all the parameters that the
    Docker CLI needs in order to make that connection:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的命令使用安全的TCP连接到远程swarm管理器上的Docker API。`$config`对象设置了Docker CLI需要的所有参数，以便建立连接：
- en: '`host` is the public, fully-qualified domain name of the manager node'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`是管理节点的公共完全限定域名'
- en: '`tlsverify` specifies that this is a secure connection and that the CLI should
    present client certificates'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tlsverify`指定这是一个安全连接，并且CLI应该提供客户端证书'
- en: '`tlscacert` is the certificate authority for the swarm'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tlscacert`是swarm的证书颁发机构'
- en: '`tlscert` is the client certificate for the user'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tlscert`是用户的客户端证书'
- en: '`tlskey` is the key for the user''s client certificate'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tlskey`是用户客户端证书的密钥'
- en: All the certificates are surfaced as files from Jenkins secrets when the job
    runs. The files are available in the workspace, when the Docker CLI needs them;
    hence, this is a seamless secure connection.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当作业运行时，所有证书都作为Jenkins秘密文件呈现。当Docker CLI需要时，这些文件在工作空间中可用；因此，这是一个无缝的安全连接。
- en: 'When the job completes, the updated services will have been deployed. Docker
    compares stack definitions against running services in the same way that Docker
    Compose does for containers, so services are only updated if the definition has
    changed. After the deployment job is complete, I can browse to the public DNS
    entry (which is a CNAME for my Docker Swarm cluster) and see the application:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作完成时，更新后的服务将已部署。Docker会将堆栈定义与正在运行的服务进行比较，就像Docker Compose对容器进行比较一样，因此只有在定义发生更改时才会更新服务。部署工作完成后，我可以浏览到公共DNS条目（这是我的Docker
    Swarm集群的CNAME），并查看应用程序：
- en: '![](Images/10d36d30-f70c-4886-8c31-c846ed9233b5.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10d36d30-f70c-4886-8c31-c846ed9233b5.png)'
- en: My workflow uses two jobs, so I can manually control the release to the remote
    environment, which could be a QA site, or it could be production. This can be
    automated for a full CD setup, and you can easily build on your Jenkins jobs to
    add more functionality—displaying the test output and coverage, joining the builds
    into a pipeline, and breaking jobs up into reusable parts.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我的工作流程使用了两个作业，因此我可以手动控制对远程环境的发布，这可能是一个QA站点，也可能是生产环境。这可以自动化为完整的CD设置，并且您可以轻松地在Jenkins作业上构建更多功能-显示测试输出和覆盖率，将构建加入管道，并将作业分解为可重用的部分。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter covered CI/CD in Docker with a sample deployment workflow configured
    in Jenkins. Every part of the process I demonstrated ran in Docker containers:
    the Git server, Jenkins itself, the build agents, the test agents, and the local
    registry.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在Jenkins中配置的Docker中的CI/CD，以及一个示例部署工作流程。我演示的过程的每个部分都在Docker容器中运行：Git服务器、Jenkins本身、构建代理、测试代理和本地注册表。
- en: You saw that it is straightforward to run your own development infrastructure
    with Docker, giving you an alternative to hosted services. It's also straightforward
    to use these services for your own deployment workflow, whether it's full CI/CD
    or separate workflows with a gated manual step.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了使用Docker运行自己的开发基础设施是很简单的，这为你提供了一个托管服务的替代方案。对于你自己的部署工作流程来说，使用这些服务也是很简单的，无论是完整的CI/CD还是带有门控手动步骤的单独工作流程。
- en: You saw how to configure and run the Gogs Git server and the Jenkins automation
    server in Docker to power the workflow. I used multi-stage builds for all the
    images in my latest cut of the NerdDinner code, which means that I can have a
    very simple Jenkins setup with no need to deploy any toolchains or SDKs.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了如何在Docker中配置和运行Gogs Git服务器和Jenkins自动化服务器来支持工作流程。我在NerdDinner代码的最新版本中为所有镜像使用了多阶段构建，这意味着我可以拥有一个非常简单的Jenkins设置，而无需部署任何工具链或SDK。
- en: My CI pipeline was triggered from a developer pushing changes to Git. The build
    job pulled the source, compiled the application components, built them into Docker
    images, and ran a local deployment of the app in Docker. It then ran end-to-end
    tests in another container, and if they passed, it tagged and pushed all the images
    to the local registry.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我的CI流水线是由开发人员推送Git更改触发的。构建作业拉取源代码，编译应用程序组件，将它们构建成Docker镜像，并在Docker中运行应用程序的本地部署。然后在另一个容器中运行端到端测试，如果测试通过，就会给所有镜像打标签并推送到本地注册表。
- en: I demonstrated a manual deployment step with a job that the user initiates,
    specifying the built version to be deployed. This job pushes the built images
    to the public Docker Hub and deploys an update to the public environment by deploying
    the stack on a Docker Swarm running in Azure.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我演示了一个用户启动的作业，指定要部署的构建版本的手动部署步骤。这个作业将构建的镜像推送到公共Docker Hub，并通过在Azure上运行的Docker
    Swarm上部署堆栈来更新公共环境。
- en: There are no hard dependencies on any of the technologies I used in this chapter.
    The process I implemented with Gogs, Jenkins, and the open source registry can
    just as easily be implemented with hosted services like GitHub, AppVeyor, and
    Docker Hub. All the steps of this process use simple PowerShell scripts and can
    be run on any stack that supports Docker.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我使用的技术没有任何硬性依赖。我用Gogs、Jenkins和开源注册表实现的流程可以很容易地使用托管服务（如GitHub、AppVeyor和Docker
    Hub）来实现。这个流程的所有步骤都使用简单的PowerShell脚本，并且可以在支持Docker的任何堆栈上运行。
- en: In the next chapter I'll step back to the developer experience and look at the
    practicalities of running, debugging, and troubleshooting applications in containers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将回到开发人员的体验，看看在容器中运行、调试和故障排除应用程序的实际操作。
