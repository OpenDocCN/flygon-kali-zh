- en: Backend and API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后端和API
- en: In this chapter, we will connect our application to the remote backend instance.
    All data we create will be synchronized to and from the backend. For the API calls,
    we will use Retrofit. Retrofit is the most frequently used HTTP client for the
    Android platform. We will guide you step by step through the common practices
    so you can easily connect and implement connection to backend in any application
    you develop in the future.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把我们的应用程序连接到远程后端实例。我们创建的所有数据都将与后端同步。对于API调用，我们将使用Retrofit。Retrofit是Android平台上最常用的HTTP客户端。我们将逐步指导您通过常见的实践，以便您可以轻松地连接和实现将来在任何应用程序中连接到后端。
- en: 'This chapter is, by far, the longest chapter in this book, and here, we will
    cover many important things such as the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是本书中迄今为止最长的一章，在这里，我们将涵盖许多重要的内容，如以下主题：
- en: Working with data classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用data类
- en: Retrofit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Retrofit
- en: Gson with Kotson library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gson与Kotson库
- en: Content providers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容提供程序
- en: Content loaders
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容加载器
- en: Android adapters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android适配器
- en: Data binding
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Using lists and grids
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表和网格
- en: Read this chapter carefully and enjoy playing with your application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读本章，并享受玩耍您的应用程序。
- en: Identifying entities used
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别使用的实体
- en: 'Before we synchronize anything, we must identify exactly what we will synchronize.
    The answer to this question is obvious, but we will recapitulate the list of our
    entities anyway. We have two main entities we are planning to synchronize:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们同步任何内容之前，我们必须确定我们将要同步的内容。这个问题的答案是显而易见的，但我们无论如何都会回顾一下我们的实体列表。我们计划同步的主要实体有两个：
- en: '`Note` entity'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Note`实体'
- en: '`Todo` entity'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Todo`实体'
- en: 'They have the following attributes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它们具有以下属性：
- en: 'Common attributes:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共同属性：
- en: '`title`: `String`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：`String`'
- en: '`message`: `String`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`：`String`'
- en: '`location`: `Location` (will be serialized)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`：`Location`（将被序列化）'
- en: Note that, currently, we represent the location with latitude and longitude
    in our database. We will change this to `Text` type since we will introduce Gson
    and Kotson for serialization/deserialization purposes!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目前我们在数据库中用纬度和经度表示位置。我们将把这个改为`Text`类型，因为我们将引入Gson和Kotson进行序列化/反序列化！
- en: 'Todo specific attributes are as follows:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Todo特定属性如下：
- en: '`scheduledFor`: `Long`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scheduledFor`：`Long`'
- en: Once again, open your classes and take a look at them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开您的类并查看它们。
- en: Working with data classes
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用data类
- en: In Kotlin, it's recommended to use `data` classes as the representation for
    your entities. In our case, we did not use `data` classes since we extended a
    common class containing the attributes shared between the `Note` and `Todo` classes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，建议使用`data`类作为实体的表示。在我们的情况下，我们没有使用`data`类，因为我们扩展了一个包含`Note`和`Todo`类之间共享属性的通用类。
- en: We recommend the use of `data` classes since it can significantly simplify your
    work routine, especially if you are using these entities in backend communication.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用`data`类，因为它可以显著简化您的工作流程，特别是如果您在后端通信中使用这些实体。
- en: 'It''s not rare that we have a need for classes that have only one purpose--holding
    the data. The benefit of using `data` classes is that some functionality that
    is often used along with its purpose is automatically provided. As you probably
    already know how to define a `data` class, you have to do something like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要只有一个目的的类--保存数据。使用`data`类的好处是，通常与其目的一起使用的一些功能会自动提供。您可能已经知道如何定义`data`类，您必须这样做：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For the `data` class, the compiler automatically provides you with the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`data`类，编译器会自动为您提供以下内容：
- en: The `equals()` and `hashCode()` methods
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals()`和`hashCode()`方法'
- en: The `toString()` method in human readable form,
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString()`方法以人类可读的形式，'
- en: '`Entity(param1=Something, param2=Something)`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entity(param1=Something, param2=Something)`'
- en: The `copy()` method for the cloning
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于克隆的`copy()`方法
- en: 'All `data` classes must satisfy the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`data`类必须满足以下要求：
- en: The primary constructor needs to have at least one parameter
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主构造函数需要至少有一个参数
- en: All primary constructor parameters need to be marked as `val` or `var`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有主构造函数参数都需要标记为`val`或`var`
- en: Data classes cannot be `abstract`, `open`, `sealed`, or `inner`
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`类不能是`abstract`，`open`，`sealed`或`inner`'
- en: 'Let''s introduce some `data` classes! Since we plan to use a remote backend
    instance, it will require some authentication. We will create new entities (`data`
    classes) for the data we pass during the authentication process, and for the result
    of the authentication. Create a new package called `api`. Then, create a new `data`
    class called `UserLoginRequest` as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一些`data`类！由于我们计划使用远程后端实例，这将需要一些身份验证。我们将为身份验证过程中传递的数据创建新的实体（`data`类），以及身份验证结果。创建一个名为`api`的新包。然后，创建一个名为`UserLoginRequest`的新的`data`类，如下所示：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`UserLoginRequest` class will contain our authentication credentials. The API
    call will return a JSON that will be deserialized into the `JournalerApiToken` data
    class as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserLoginRequest`类将包含我们的身份验证凭据。API调用将返回一个JSON，该JSON将被反序列化为`JournalerApiToken`的`data`类，如下所示：'
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pay attention that we used the annotation to tell Gson that the token field
    will be obtained from the `id_token` field in JSON.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用注解告诉Gson，token字段将从JSON中的`id_token`字段获取。
- en: To summarize--Always consider the use of `data` classes! Especially if the data
    they represent will be used for holding database and backend information.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 总之--始终考虑使用`data`类！特别是如果它们所代表的数据将用于保存数据库和后端信息。
- en: Connect data models to a database
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据模型连接到数据库
- en: If you have a scenario like we have with the Journaler application to hold the
    data in the database, and you plan to synchronize it with the remote backend instance,
    it can be a good idea to first create a persistence layer that will store your
    data. Keeping data persisted into a local filesystem database prevents data from
    loss, especially if you have a bigger amount of it!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您像Journaler应用程序一样拥有一个在数据库中保存数据并计划将其与远程后端实例同步的场景，首先创建一个将存储数据的持久层可能是一个好主意。将数据持久化到本地文件系统数据库可以防止数据丢失，特别是如果数据量较大！
- en: So, once again, what did we do? We created a persistence mechanism that will
    store all our data into the SQLite database. Then, in this chapter, we will introduce
    the backend communication mechanism. Because we don't know if our API calls will
    fail or whether the backend instance will be available at all, we have the data
    persisted. If we keep our data in the device memory only, and if the API call
    for synchronization fails and our application crashes, we can lose this data.
    Let's say if the API call failed and the application crashed, but we have our
    data persisted, we can retry the synchronization. The data is still there!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们做了什么？我们创建了一个持久化机制，将所有数据存储到SQLite数据库中。然后，在本章中，我们将介绍后端通信机制。因为我们不知道我们的API调用是否会失败，或者后端实例是否可用，所以我们将数据持久化。如果我们只将数据保存在设备内存中，如果同步的API调用失败并且我们的应用程序崩溃，我们可能会丢失这些数据。假设API调用失败并且应用程序崩溃，但我们的数据已持久化，我们可以重试同步。数据仍然存在！
- en: Introduction to Retrofit
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Retrofit介绍
- en: As we already mentioned, Retrofit is an open source library. It is the most
    popular HTTP client for Android used today. Because of that, we will introduce
    you to Retrofit basics and demonstrate how to use it. The version we will cover
    is 2.3.0\. We will give you step-by-step guidance on how to use it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，Retrofit是一个开源库。它是当今最流行的Android HTTP客户端。因此，我们将向您介绍Retrofit的基础知识，并演示如何使用它。我们将涵盖的版本是2.3.0。我们将为您提供如何使用它的逐步指导。
- en: 'First of all, Retrofit depends on some libraries too. We will use it with Okhttp.
    Okhttp is an HTTP/HTTP2 client developed by the same guys who developed Retrofit.
    Before we start, we will put dependencies into our `build.gradle` configuration
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Retrofit也依赖于一些库。我们将与Okhttp一起使用。Okhttp是由开发Retrofit的同一团队开发的HTTP/HTTP2客户端。在开始之前，我们将把依赖项放入我们的`build.gradle`配置中，如下所示：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We updated our Retrofit and Okhttp to the latest version. We added dependencies
    for the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的Retrofit和Okhttp更新到最新版本。我们为以下内容添加了依赖项：
- en: Retrofit library
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Retrofit库
- en: Gson converter that will be used to deserialize the API responses
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gson转换器，用于反序列化API响应
- en: Okhttp library
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Okhttp库
- en: Logging interceptor for Okhttp so we can log what is going on with our API calls
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Okhttp的日志拦截器，以便我们可以记录API调用的情况
- en: After we synchronize our Gradle configuration, we are ready to start!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步我们的Gradle配置之后，我们准备好开始了！
- en: Defining Retrofit service
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义Retrofit服务
- en: 'Retrofit turns your HTTP API into a Kotlin interface. Create an interface called
    `JournalerBackendService` inside the API package. Let''s put some code in it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit将您的HTTP API转换为Kotlin接口。在API包中创建一个名为`JournalerBackendService`的接口。让我们在其中放入一些代码：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What do we have in this interface? We defined a list of calls that will be
    able to execute the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个接口中我们有什么？我们定义了一系列调用，可以执行以下操作：
- en: 'Authentication for the user: This accepts request headers and instances of
    the `UserLoginRequest` class containing user credentials. It will be used as a
    payload for our call. Executing the call will return a wrapped `JournalerApiToken`
    instance. We will need a token for all other calls, and we will put its content
    into the header of each call.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户身份验证：这将接受请求标头和包含用户凭据的`UserLoginRequest`类的实例。它将用作我们调用的有效负载。执行调用将返回一个包装的`JournalerApiToken`实例。我们将需要一个令牌用于所有其他调用，并将其内容放入每个调用的标头中。
- en: '`Notes` and `TODOs` obtain: This accepts request headers containing the authentication
    token as well. As a result of the call, we get a wrapped list of the `Note` or
    `Todo` class instances.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取`Notes`和`TODOs`：这将接受包含身份验证令牌的请求标头。作为调用的结果，我们会得到一个包装的`Note`或`Todo`类实例的列表。
- en: '`Notes` and `TODOs` putting (when we send new stuff to the server): This accepts
    request headers containing the authentication token as well. Payload for the call
    will be a list of the `Note` or `Todo` class instances. We will not return any
    important data for these calls. It is important that the response code is positive.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notes`和`TODOs`放置（当我们向服务器发送新内容时）：这将接受包含身份验证令牌的请求标头。调用的有效负载将是`Note`或`Todo`类实例的列表。对于这些调用，我们不会返回任何重要数据。重要的是响应代码是正数。'
- en: '`Notes` and `TODOs` removal--This accepts request headers containing the authentication
    token as well. Payload for the call will be a list of `Note` or `Todo` class instances
    to be removed from our remote backend server instance. We will not return any
    important data for these calls. It is important that the response code is positive.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`Notes`和`TODOs`--这也将接受包含身份验证令牌的请求标头。调用的有效负载将是要从我们的远程后端服务器实例中删除的`Note`或`Todo`类实例的列表。对于这些调用，我们不会返回任何重要数据。重要的是响应代码是正数。
- en: Each has a proper annotation representing the HTTP method with the path. We
    also use annotations to mark the payload body and headers map.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都有一个表示HTTP方法和路径的适当注释。我们还使用注释来标记有效负载主体和标头映射。
- en: Building a Retrofit service instance
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个Retrofit服务实例
- en: 'Now, after we have described our service, we need a real Retrofit instance
    that we will use to trigger API calls. First, we will introduce some additional
    classes. We will hold the latest token instance inside the `TokenManager` object:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们描述了我们的服务之后，我们需要一个真正的Retrofit实例，我们将用它来触发API调用。首先，我们将介绍一些额外的类。我们将在`TokenManager`对象中保存最新的令牌实例：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will also have an object to obtain the API call headers map called `BackendServiceHeaderMap`,
    as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将有一个用于获取API调用标头映射的对象，名为`BackendServiceHeaderMap`，如下所示：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can show you how to build a `Retrofit` instance. Create a new object
    called `BackendServiceRetrofit` and make sure it looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以向您展示如何构建`Retrofit`实例。创建一个名为`BackendServiceRetrofit`的新对象，并确保它看起来像这样：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Calling the `obtain()` method will return us a `Retrofit` instance ready to
    fire API calls. We made a `Retrofit` instance with a backend base URL set to local
    host. We also passed the Gson converter factory to be used as a mechanism for
    JSON deserialization. Most importantly, we passed an instance of the client that
    we will use, and we created a new OkHttp client.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`obtain()`方法将返回一个准备好发出API调用的`Retrofit`实例。我们创建了一个`Retrofit`实例，其后端基本URL设置为本地主机。我们还传递了Gson转换器工厂，用作JSON反序列化的机制。最重要的是，我们传递了我们将使用的客户端实例，并创建了一个新的OkHttp客户端。
- en: Introduction to Gson with Kotson library
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kotson库介绍Gson
- en: JSON serialization and deserialization are very important for every Android
    application and are frequently used. For that purpose, we will be using the Gson
    library developed by Google. Also, we will use Kotson and Kotlin bindings for
    Gson. So, let's start!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: JSON序列化和反序列化对于每个Android应用程序都非常重要，并且经常被使用。为此，我们将使用由Google开发的Gson库。此外，我们将使用Kotson和Kotlin绑定来使用Gson。所以，让我们开始吧！
- en: 'First of all, we need to provide dependencies for our `build.gradle` configuration
    as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要根据以下内容为我们的`build.gradle`配置提供依赖项：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will update our code to use Gson with Kotson bindings for location serialization/deserialization
    in database management. First, we need to apply a small change to the `Db` class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新我们的代码，使用Gson与Kotson绑定进行位置序列化/反序列化在数据库管理中。首先，我们需要对`Db`类进行一些小改动：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we changed the location information handling. Instead of having
    location latitude and longitude columns, we now have only one database column--`location`.
    The type is `Text`. We will hold the serialized `Location` class values that will
    be generated by the Gson library. Also, when we retrieve the serialized values,
    we will deserialize them using Gson into `Location` class instances.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们改变了位置信息处理。现在，我们不再有位置纬度和经度列，而是只有一个数据库列--`location`。类型为`Text`。我们将保存由Gson库生成的序列化的`Location`类值。此外，当我们检索序列化的值时，我们将使用Gson将它们反序列化为`Location`类实例。
- en: 'Now, we have to actually use Gson. Open `Db.kt` and update it to serialize,
    and deserialize `Location` class instances using Gson, as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须实际使用Gson。打开`Db.kt`并更新它以使用Gson序列化和反序列化`Location`类实例，如下所示：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, in the preceding code, to update using Gson is very simple.
    We rely on the following two Gson library methods accessed from the Gson class
    instance:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，在上述代码中，使用Gson进行更新非常简单。我们依赖于从Gson类实例访问的以下两个Gson库方法：
- en: '`fromJson<T>()`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromJson<T>()`'
- en: '`toJson()`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toJson()`'
- en: Thanks to Kotson and Kotlin bindings, we can use a parameterize type for the
    data we serialize using the `fromJson<T>()` method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kotson和Kotlin绑定，我们可以使用`fromJson<T>()`方法对我们序列化的数据使用参数化类型。
- en: What else is available?
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有什么其他的？
- en: Now, we will list some alternatives for Retrofit and Gson. Outside, there is
    a big open source community that makes great things every day. You are not obligated
    to use any libraries we present. You can choose any of the alternatives, or even
    create your own implementation!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将列出一些Retrofit和Gson的替代方案。在外部，有一个庞大的开源社区，每天都在做出伟大的事情。您不必使用我们提供的任何库。您可以选择任何替代方案，甚至创建自己的实现！
- en: Retrofit alternative
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Retrofit替代方案
- en: 'As its homepage says, Volley is an HTTP library that makes networking for Android
    apps easier and, most importantly, faster. Some of the key features Volley offers
    are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其主页所说，Volley是一个使Android应用程序的网络工作更加简单和更快的HTTP库。Volley提供的一些关键功能包括：
- en: Automatic scheduling of network requests
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动调度网络请求
- en: Multiple concurrent network connections
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个并发网络连接
- en: Transparent disk and memory response caching with standard HTTP cache coherence
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明的磁盘和内存响应缓存与标准HTTP缓存一致性
- en: Support for request prioritization.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持请求优先级。
- en: Cancellation request API
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消请求API
- en: Ease of customization
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于定制
- en: Strong ordering
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强有力的排序
- en: Debugging and tracing tools
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试和跟踪工具
- en: Homepage--[https://github.com/google/volley](https://github.com/google/volley).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 主页--[https://github.com/google/volley](https://github.com/google/volley)。
- en: Gson alternative
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gson替代方案
- en: 'Jackson is a low-level JSON parser. It''s very similar to the Java StAX parser
    for XML. Some of the key features Jackson offers are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Jackson是一个低级别的JSON解析器。它与Java StAX解析器非常相似，用于XML。Jackson提供的一些关键功能包括：
- en: Very fast and convenient
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常快速和方便
- en: Extensive annotation support
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广泛的注释支持
- en: Streaming reading and writing
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式读取和写入
- en: Tree model
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树模型
- en: Out-of-box JAX-RS support
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开箱即用的JAX-RS支持
- en: Integrated support for binary content
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成对二进制内容的支持
- en: Homepage--[https://github.com/FasterXML/jackson](https://github.com/FasterXML/jackson).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 主页--[https://github.com/FasterXML/jackson](https://github.com/FasterXML/jackson)。
- en: Executing our first API call
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行我们的第一个API调用
- en: We defined a Retrofit service with all API calls, but we haven't connected anything
    to it yet. It is time to use it. We will extend our code to use Retrofit. Each
    API call can be executed synchronously or asynchronously. We will show you both
    ways. Do you remember that we set our Retrofit service base URL to the localhost?
    This means that we will need a local backend instance that will respond to our
    HTTP requests. Since backend implementation is not the subject of this book, we
    will leave it up to you to create a simple service responding to this request.
    You can implement it from any programming language you like, such as Kotlin, Java,
    Python, and PHP.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个带有所有API调用的Retrofit服务，但我们还没有将任何东西连接到它。现在是使用它的时候了。我们将扩展我们的代码以使用Retrofit。每个API调用都可以同步或异步执行。我们将向您展示两种方式。您还记得我们将Retrofit服务的基本URL设置为本地主机吗？这意味着我们将需要一个本地后端实例来响应我们的HTTP请求。由于后端实现不是本书的主题，我们将把它留给您来创建一个简单的服务来响应此请求。您可以使用任何您喜欢的编程语言来实现它，比如Kotlin、Java、Python和PHP。
- en: 'If you are impatient and don''t want to implement your own application for
    dealing with HTTP requests, you can override the base URL, Notes, and TODOs paths
    as shown in the following example and use the backend instance ready for tryout:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不耐烦，不想为处理HTTP请求实现自己的应用程序，您可以覆盖基本URL，Notes和TODOs路径，如下例所示，并使用后端实例进行尝试：
- en: Base URL--[http://static.milosvasic.net/json/journaler](http://static.milosvasic.net/json/journaler)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本URL--[http://static.milosvasic.net/json/journaler](http://static.milosvasic.net/json/journaler)
- en: 'Login POST to target:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录POST到目标：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Notes` `GET` to target:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notes` `GET`到目标：'
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`TODOs` `GET` to target:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TODOs` `GET`到目标：'
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Like this, we will target the remote backend instance returning us stub `Notes`
    and `TODOs`. Now open your `JournalerBackendService` interface and extend it as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将针对远程后端实例返回我们的存根`Notes`和`TODOs`。现在打开您的`JournalerBackendService`接口，并将其扩展如下：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The method we just added will give us an instance of `JournalerBackendService`
    using Retrofit. Through this, we will trigger all our calls. Open the `MainService`
    class. Find the `synchronize()` method. Remember that we put sleep there to simulate
    communication with the backend. Now, we will replace it with real backend calls:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的方法将为我们提供一个使用Retrofit的`JournalerBackendService`实例。通过这个，我们将触发所有我们的调用。打开`MainService`类。找到`synchronize()`方法。记住我们在那里放了一个睡眠来模拟与后端的通信。现在，我们将用真实的后端调用替换它：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Analyze the code slowly and take your time! There are a lot of things going
    on! First, we will create instances of headers and the Journaler backend service.
    Then, we performed the authentication synchronously by triggering the `execute()`
    method. We received `Response<JournalerApiToken>`. The `JournalerApiToken` instance
    is wrapped in the `Response` class instance. After we check if the response is
    successful, and that we actually received and deserialized `JournalerApiToken`,
    we set it to `TokenManager`. Finally, we trigger asynchronous calls for `Notes`
    and `TODOs` retrieval.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 慢慢分析代码，花点时间！有很多事情要做！首先，我们将创建标题和Journaler后端服务的实例。然后，我们通过触发`execute()`方法同步执行身份验证。我们收到了`Response<JournalerApiToken>`。`JournalerApiToken`实例包装在`Response`类实例中。在我们检查响应是否成功，并且我们实际上收到并反序列化了`JournalerApiToken`之后，我们将其设置为`TokenManager`。最后，我们触发`Notes`和`TODOs`检索的异步调用。
- en: The `enqueue()` method triggers the async operation, and, as a parameter, accepts
    the Retrofit Callback concretization. We will do the same that we did with the
    sync call. We will check if it is successful and if there is data. If everything
    is ok, we will pass all instances to our database manager for saving.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue()`方法触发异步操作，并且作为参数接受Retrofit回调具体化。我们将与同步调用做同样的事情。我们将检查它是否成功，以及是否有数据。如果一切正常，我们将把所有实例传递给我们的数据库管理器进行保存。'
- en: We only implemented the `Notes` and `TODOs` retrieval. For the rest of the API
    calls, we leave it up to you to do the implementation. It is a great way to learn
    Retrofit!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只实现了`Notes`和`TODOs`的检索。对于其余的API调用，我们将把它留给您来实现。这是学习Retrofit的一个很好的方法！
- en: Let's build you an application and run it. As an application and its main service
    starts, the API calls are executed. Filter the Logcat output by OkHttp. Observe
    the following.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个应用程序并运行它。当应用程序及其主服务启动时，API调用将被执行。通过OkHttp过滤Logcat输出。观察以下内容。
- en: 'Authentication log lines:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证日志行：
- en: 'Request:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Response:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Notes` log lines:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notes`日志行：'
- en: 'Request:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Response:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`TODOs` log lines:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`TODOs`日志行：'
- en: 'Request: This is an example of the request part we do:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求：这是我们做的请求部分的一个例子：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Response: This is an example of the response we receive:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应：这是我们收到的响应的一个例子：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Congratulations! You have implemented your first Retrofit service! Now it is
    time to implement the rest of the calls. Also, do some code refactoring! This
    is a small homework task for you. Update your service so it can accept login credentials.
    In our current code, we hardcoded the username and password. Your mission will
    be to refactor the code and pass the parameterized credential.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经实现了您的第一个Retrofit服务！现在是时候实现其余的调用。还要进行一些代码重构！这是一个小作业任务给你。更新您的服务，使其可以接受登录凭据。在我们当前的代码中，我们硬编码了用户名和密码。您的任务将是重构代码并传递参数化的凭据。
- en: Optionally, improve the code so it's no longer possible to execute the same
    call multiple times at the same moment. We left this as the legacy from our previous
    work.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，改进代码，使其不再可能在同一时刻多次执行相同的调用。我们将这留作我们以前工作的遗留问题。
- en: Content providers
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容提供程序
- en: It's time to further improve our application and introduce you to Android content
    providers. Content providers are one of the top power features Android Framework
    has to offer. What is the purpose of content providers? As its name suggests,
    content providers have the purpose of managing access to data stored by our application
    or stored by other applications. They provide a mechanism for sharing the data
    with other applications and provide a security mechanism for data access, that
    may or may not be from the same process.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进一步改进我们的应用程序并向您介绍Android内容提供程序。内容提供程序是Android框架提供的顶级强大功能之一。内容提供程序的目的是什么？顾名思义，内容提供程序的目的是管理我们的应用程序存储的数据或其他应用程序存储的数据的访问。它们提供了一种机制来与其他应用程序共享数据，并为数据访问提供了安全机制，这些数据可能来自同一进程，也可能不来自同一进程。
- en: 'Take a look at the following illustration displaying how content provider can
    manage access to shared storage:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的插图，显示内容提供程序如何管理对共享存储的访问：
- en: '![](img/ad7d8f5f-eed6-4480-988f-3d2429c76339.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad7d8f5f-eed6-4480-988f-3d2429c76339.png)'
- en: 'We have a plan to share `Notes` and the `TODOs` data with other applications.
    Thanks to the abstraction layer content providers offers, it''s easy to make the
    changes in the storage implementation layer without affecting the upper layers.
    Because of this, you can use content providers even if you do not plan to share
    any data with other applications. We can, for example, completely replace the
    persistence mechanism from SQLite to something completely different. Take a look
    at the following illustration showing this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划与其他应用程序共享`Notes`和`TODOs`数据。由于抽象层内容提供者提供的抽象层，很容易在不影响上层的情况下对存储实现层进行更改。因此，即使你不打算与其他应用程序共享任何数据，你也可以使用内容提供者。例如，我们可以完全替换持久性机制，从SQLite到完全不同的东西。看一下下面的插图：
- en: '![](img/0109ab05-42bf-40e3-87d1-d34dd8ee5ebd.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0109ab05-42bf-40e3-87d1-d34dd8ee5ebd.png)'
- en: 'If you are not sure whether you need content provider or not, here is when
    you should implement it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定是否需要内容提供者，这就是你应该实现它的时候：
- en: If you are planning to share your application's data with other applications
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你计划与其他应用程序共享你的应用程序数据
- en: If you are planning to copy and paste complex data or files from your application
    to other applications
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你计划从你的应用程序复制和粘贴复杂数据或文件到其他应用程序
- en: If you are planning to support custom search suggestions
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你计划支持自定义搜索建议
- en: The Android Framework comes with an already defined content provider that you
    can use; for example, to manage contacts, audio, video, or other files. Content
    providers are not limited to SQLite access only, but you can use it for other
    structured data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Android框架已经定义了一个内容提供者，你可以使用它来管理联系人、音频、视频或其他文件。内容提供者不仅限于SQLite访问，你也可以用它来处理其他结构化数据。
- en: 'Let''s once again highlight the main benefits:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次强调主要的好处：
- en: Permissions over accessing the data
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问数据的权限
- en: Abstracting the data layer
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象数据层
- en: So, as we already said, we are planning to support data exposure from the Journaler
    application. Before we create our content provider, we must note that this will
    require refactoring of the current code. Don't worry, we will present content
    provider, explain it to you and all the refactoring we do. After we do this--finish
    our implementation and refactoring--we will create an example client application
    that will use our content provider and trigger all the CRUD operations.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如我们已经说过的，我们计划支持从Journaler应用程序暴露数据。在创建内容提供者之前，我们必须注意，这将需要重构当前的代码。不要担心，我们将向你介绍内容提供者，并解释给你所有我们所做的重构。在我们完成实现和重构之后，我们将创建一个示例客户端应用程序，该应用程序将使用我们的内容提供者并触发所有CRUD操作。
- en: Let's create a `ContentProvider` class. Create a new package called `provider`
    with the `JournalerProvider` class extending the `ContentProvider` class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`ContentProvider`类。创建一个名为`provider`的新包，并创建一个`JournalerProvider`类，继承`ContentProvider`类。
- en: 'Class beginning:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 类开始：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Defining a `companion` object:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个`companion`对象：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Class initialization:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 类初始化：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Overriding the `onCreate()` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`onCreate()`方法：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Insert the operation as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 插入操作如下：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Update the operation as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 更新操作如下：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Delete the operation as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作如下：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Performing query:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 执行查询：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Class ending:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 类结束：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Going from top to bottom, we did the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从上到下，我们做了以下工作：
- en: Defined the database name and version
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义数据库名称和版本
- en: Defined the database instance lazy initialization
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义数据库实例的延迟初始化
- en: Defined the URI(s) we will use to access the data
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义我们将用于访问数据的URI(s)
- en: Implemented all the CRUD operations
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了所有的CRUD操作
- en: Defined the MIME type for the data
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为数据定义MIME类型
- en: 'Now, when you have a content provider implementation, it is required to register
    it in your `manifest` as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你有一个内容提供者实现时，需要在你的`manifest`中注册它，如下所示：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Observe. We set the exported attribute to `True`. What does this mean? It means
    that, if `True`, the Journaler provider is available to other applications. Any
    application can use the provider's content URI to access the data. One more important
    attribute is `multiprocess`. If the app runs in multiple processes, this attribute
    determines whether multiple instances of the Journaler provider are created. If
    `True`, each of the applications' processes has its own content provider instance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 观察。我们将`exported`属性设置为`True`。这是什么意思？这意味着，如果为`True`，Journaler提供者可供其他应用程序使用。任何应用程序都可以使用提供者的内容URI来访问数据。另一个重要的属性是`multiprocess`。如果应用程序在多个进程中运行，此属性确定是否创建Journaler提供者的多个实例。如果为`True`，每个应用程序的进程都有自己的内容提供者实例。
- en: 'Let''s continue. In the `Crud` interface, add this to the `companion` object
    if you do not have it already:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续。在`Crud`接口中，如果你还没有，将这个添加到`companion`对象中：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will rename our `Db` class into Content. Update the `Content` implementation,
    as follows, to use `JournalerProvider`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的`Db`类重命名为Content。更新`Content`实现，如下所示，以使用`JournalerProvider`：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`Note` insert operation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意插入操作：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`Note` update operation:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Note`更新操作：'
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`Note` delete operation:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意删除操作：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`Note` select operation:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Note`选择操作：'
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`Todo` object definition and its insert operation:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Todo`对象定义及其插入操作：'
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`Todo` update operation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Todo`更新操作：'
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`Todo` delete operation:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`Todo`删除操作：'
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`Todo` select operation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`Todo`选择操作：'
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Read the code carefully. We replaced the direct database access with content
    provider. Update your UI classes to use the new refactored code. If you have trouble
    doing this, you can take a look at the GitHub branch containing these changes:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读代码。我们用内容提供者替换了直接的数据库访问。更新你的UI类以使用新的重构代码。如果你在做这个过程中遇到困难，你可以看一下包含这些更改的GitHub分支：
- en: '[https://github.com/PacktPublishing/-Mastering-Android-Development-with-Kotlin/tree/examples/chapter_12](https://github.com/PacktPublishing/-Mastering-Android-Development-with-Kotlin/tree/examples/chapter_12).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/-Mastering-Android-Development-with-Kotlin/tree/examples/chapter_12](https://github.com/PacktPublishing/-Mastering-Android-Development-with-Kotlin/tree/examples/chapter_12)。'
- en: 'The branch also contains an example of the Journaler content provider client
    application. We will highlight an example of use on the client application''s
    main screen containing four buttons. Each button triggers an example of the CRUD
    operation, as shown here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 该分支还包含了Journaler内容提供程序客户端应用程序的示例。我们将突出显示客户端应用程序主屏幕上包含四个按钮的使用示例。每个按钮触发一个CRUD操作的示例，如下所示：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This example demonstrates how to trigger CRUD operations from other applications
    using content provider.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了如何使用内容提供程序从其他应用程序触发CRUD操作。
- en: Android adapters
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android适配器
- en: 'To present content on our main screen, we will use the Android Adapter class.
    The Android Framework offers adapters as a mechanism to provide items to view
    groups as lists or grids. To show an example of Adapter usage, we will define
    our own adapter implementation. Create a new package called `adapter` and an `EntryAdapter`
    member class extending the `BaseAdapter` class:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的主屏幕上呈现内容，我们将使用Android Adapter类。Android框架提供了适配器作为一种机制，以将项目提供给视图组，如列表或网格。为了展示适配器的使用示例，我们将定义我们自己的适配器实现。创建一个名为`adapter`的新包和一个扩展`BaseAdapter`类的`EntryAdapter`成员类：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We overrode the following methods:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写了以下方法：
- en: '`getView()`: This returns the instance of the populated view based on the current
    position in the container'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getView()`: 根据容器中的当前位置返回填充视图的实例'
- en: '`getItem()`: This returns the instance of the item we use to create the view;
    in our case, this is the `Entry` class instance (`Note` or `Todo`)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getItem()`: 这将返回我们用来创建视图的项目实例；在我们的情况下，这是`Entry`类实例（`Note`或`Todo`）'
- en: '`getItemId()`: This returns the ID for the current item instance'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getItemId()`: 这将返回当前项目实例的ID'
- en: '`getCount()`: This returns the total number of items'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCount()`: 返回项目的总数'
- en: 'We will connect the adapter and our UI. Open `ItemsFragment` and updated its
    `onResume()` method to instantiate the adapter and assign it to a `ListView`,
    as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将连接适配器和我们的UI。打开`ItemsFragment`并更新其`onResume()`方法，以实例化适配器并将其分配给`ListView`，如下所示：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When you build and run your application, you should see every page of `ViewPager`
    populated with the loaded items, as shown in the following screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建和运行应用程序时，您应该看到`ViewPager`的每个页面都填充了加载的项目，如下截图所示：
- en: '![](img/1fdfdd42-d4ba-4f48-b569-5da14b86d4f2.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fdfdd42-d4ba-4f48-b569-5da14b86d4f2.png)'
- en: Content loaders
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容加载器
- en: 'Content loaders provide you with a mechanism to load data from a content provider
    or other data source for display in a UI component, such as Activity or Fragment.
    These are the benefits that loaders provide:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 内容加载器为您提供了一种机制，用于从内容提供程序或其他数据源加载数据，以在UI组件（如Activity或Fragment）中显示。这些是加载程序提供的好处：
- en: Running on a separate thread
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单独的线程上运行
- en: Simplifying thread management by providing callback methods
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供回调方法简化线程管理
- en: Loaders persist and cache results across configuration changes, which prevents
    duplicated queries
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载程序在配置更改期间保持和缓存结果，从而防止重复查询
- en: We can implement and be observers to monitor changes in the data
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以实现并成为监视数据更改的观察者
- en: 'We will create our content loader implementation. First, we need to update
    the `Adapter` class. Since we will deal with cursors, we will use a `CursorAdapte`r
    instead of `BaseAdapter`. `CursorAdapter` accepts a `Cursor` instance as a parameter
    in the primary constructor. The `CursorAdapter` implementation is much simpler
    than the one we have right now. Open `EntryAdapter` and update it as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建我们的内容加载器实现。首先，我们需要更新`Adapter`类。由于我们将处理游标，我们将使用`CursorAdapter`而不是`BaseAdapter`。`CursorAdapter`在主构造函数中接受`Cursor`实例作为参数。`CursorAdapter`的实现比我们现在拥有的要简单得多。打开`EntryAdapter`并更新如下：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We have the following two methods to override:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下两种要重写的方法：
- en: '`newView()`: This returns the instance of the view to populate with data'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newView()`: 这将返回要填充数据的视图的实例'
- en: '`bindView()`: This populates data from the `Cursor` instance'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bindView()`: 这将填充来自`Cursor`实例的数据'
- en: 'Finally, let''s update our `ItemsFragment` class, so it uses the content loader
    implementation:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更新我们的`ItemsFragment`类，以便使用内容加载器实现：
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We initialize `LoaderManager` by calling the `LoaderManager` member of our
    Fragment. The two crucial methods we execute are as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用Fragment的`LoaderManager`成员来初始化`LoaderManager`。我们执行的两个关键方法如下：
- en: '`initLoader()`: This ensures a loader is initialized and active'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initLoader()`: 这确保加载程序已初始化并处于活动状态'
- en: '`restartLoader()`: This starts a new or restarts an existing `loader` instance'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restartLoader()`: 这将启动新的或重新启动现有的`loader`实例'
- en: 'Both methods accept the loader ID and bundle data as arguments and the `LoaderCallbacks<Cursor>`
    implementation, which provides the following three methods to override:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都接受loader ID和bundle数据作为参数，并提供了要重写的`LoaderCallbacks<Cursor>`实现，其中包括以下三种方法：
- en: '`onCreateLoader()`: This instantiates and returns a new loader instance for
    the ID we provided'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateLoader()`: 为我们提供的ID实例化并返回一个新的加载程序实例'
- en: '`onLoadFinished()`: This is called when a previously created loader has finished
    loading'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLoadFinished()`: 当先前创建的loader完成加载时调用'
- en: '`onLoaderReset()`: This is called when a previously created loader is being
    reset, and, because of that, making its data unavailable'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLoaderReset()`: 当先前创建的loader正在被重置时调用，因此使其数据不可用'
- en: Data binding
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定
- en: 'Android supports a mechanism for data binding so that data is bound with views
    and the glue code is minimized. Enable data binding by updating your build Gradle
    configuration as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持一种数据绑定机制，以便将数据与视图绑定，并最小化粘合代码。通过更新您的构建Gradle配置来启用数据绑定，如下所示：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, you can define your binding expressions. Take a look at the following
    example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以定义绑定表达式。看一下以下示例：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s bind the data as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式绑定数据：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That's it! See how simple it is to bind data to layout views! We strongly recommend
    that you play with data binding as much as you can. Create your own examples!
    Feel free to experiment!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！看看将数据绑定到布局视图是多么简单！我们强烈建议您尽可能多地使用数据绑定。创建您自己的示例！随意尝试！
- en: Using lists
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用列表
- en: We showed you how to work with data. As you noticed, in the main view data container,
    we used `ListView`. Why did we choose it? First of all, it's the most commonly
    used container to hold your data. In most cases, you will use `ListView` to hold
    the data from your adapters. Never put a large number of views in a scrollable
    container like `LinearLayout`! Whenever possible, use `ListView`. It will recycle
    views when they are not needed anymore and reinstantiate them when needed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向您展示了如何处理数据。正如您注意到的，在主视图数据容器中，我们使用了`ListView`。为什么我们选择它？首先，它是最常用的容器来保存您的数据。在大多数情况下，您将使用`ListView`来保存来自适配器的数据。永远不要在可滚动容器（如`LinearLayout`）中放置大量视图！尽可能使用`ListView`。当不再需要视图时，它会回收视图，并在需要时重新实例化它们。
- en: Using lists can affect your application performance since it's a well-optimized
    container for displaying your data. Displaying a list is an essential functionality
    of almost any application! Any application that produces a set of data as a result
    of some operation needs a list. It's almost impossible that you will not use it
    in your application.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表可能会影响您的应用程序性能，因为它是一个用于显示数据的优化良好的容器。显示列表是几乎任何应用程序的基本功能！任何生成一组数据作为某些操作结果的应用程序都需要一个列表。在您的应用程序中几乎不可能不使用它。
- en: Using grids
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格
- en: 'We noted how lists are important. However, what if we plan to present our data
    as a grid? Lucky for us!! The Android Framework provides us with a `GridView`
    that works very similar to `ListView`. You define your `GridView` in layout and
    assign the adapter instance to `GridView`''s adapter property. `GridView` will
    recycle all views for you and perform instantiation when needed. The main difference
    between the list and the grid is that you have to define the number of columns
    for your `GridView`. The following example will present you with an example of
    `GridView`''s use:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到列表的重要性。但是，如果我们计划将数据呈现为网格呢？对我们来说太幸运了！Android框架为我们提供了一个与`ListView`非常相似的`GridView`。您在布局中定义您的`GridView`，并将适配器实例分配给`GridView`的适配器属性。`GridView`将为您回收所有视图，并在需要时执行实例化。列表和网格之间的主要区别在于您必须为您的`GridView`定义列数。以下示例将向您展示`GridView`的使用示例：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We will highlight the important attributes we used in this example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将突出显示我们在此示例中使用的重要属性：
- en: '`columnWidth`: This specifies the width for each column'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`columnWidth`：指定每列的宽度'
- en: '`numColumns`: This specifies the number of columns'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numColumns`：指定列数'
- en: '`verticalSpacing`: This specifies the vertical spacing between the rows'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verticalSpacing`：指定行之间的垂直间距'
- en: '`horizontalSpacing`: This specifies the horizontal spacing between the items
    in the grid'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`horizontalSpacing`：指定网格中项目之间的水平间距'
- en: Try updating the current application's main `ListView` to present the data as
    `GridView`. Adjust it so it looks pleasant for the end user. Once again, feel
    free to experiment!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将当前应用程序的主`ListView`更新为以`GridView`形式呈现数据。调整它，使其对最终用户看起来愉悦。再次，随意尝试实验！
- en: Implementing drag and drop
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现拖放
- en: Here, in the last section of this chapter, we will show you how to implement
    the drag and drop feature. It's a feature that you will probably need in most
    applications containing data in lists. Using lists is not mandatory for performing
    drag and drop, because you can drag anything (view) and release it anywhere where
    a proper listener is defined. For a better understanding of what we are talking
    about, we will show you an example of how to implement it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节，我们将向您展示如何实现拖放功能。这是您在大多数包含列表数据的应用程序中可能需要的功能。使用列表并不是执行拖放的必要条件，因为您可以拖动任何（视图）并将其释放到定义了适当监听器的任何位置。为了更好地理解我们所讨论的内容，我们将向您展示一个实现的例子。
- en: 'Let''s define a view. On that view, we will set a long press listener that
    will trigger the drag and drop operation:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个视图。在该视图上，我们将设置一个长按监听器，触发拖放操作：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We used the `ClipData` class to pass the data to drop a target. We defined
    `dragListener` like this and assigned it to a view where we expect it to drop:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ClipData`类来传递数据以放置目标。我们定义了`dragListener`，并将其分配给我们期望它放置的视图：
- en: '[PRE52]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Drag listener will fire up the code when we start dragging a view and finally
    release it on the `target` view that has the listener assigned.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放监听器将在我们开始拖动视图并最终释放到具有分配的监听器的`target`视图上时触发代码。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a lot of topics. We learned about backend communication,
    how to establish communication with the backend remote instance using Retrofit,
    and how to handle the data we obtain. The aim of this chapter was to work with
    content providers and content loaders. We hope you realized their importance and
    what their benefits are. Finally, we demonstrated data binding; noted the importance
    of our data view containers, such as `ListView` and `GridView`; and showed you
    how to carry out the drag and drop operation. In the next chapter, we will start
    testing our code. Be ready for the performance optimization since that is what
    we will do in the next chapter!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多主题。我们学习了关于后端通信，如何使用Retrofit与后端远程实例建立通信，以及如何处理我们获取的数据。本章的目的是使用内容提供程序和内容加载器。我们希望您意识到它们的重要性以及它们的好处。最后，我们演示了数据绑定；注意到我们的数据视图容器的重要性，比如`ListView`和`GridView`；并向您展示了如何执行拖放操作。在下一章中，我们将开始测试我们的代码。准备好进行性能优化，因为这是我们下一章要做的事情！
