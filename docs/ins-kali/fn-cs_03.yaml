- en: Chapter 3. Expressing Anonymous Methods with Lambda Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用Lambda表达式表达匿名方法
- en: 'We covered delegates in the previous chapter, as it was a pre-requisite for
    understanding anonymous methods and lambda expressions, the subject of the current
    chapter. By using an anonymous method, we can create a delegate instance with
    no need to have a separate method. By using the lambda expression, we can create
    a shorthand syntax for the anonymous method. In this chapter, we are going to
    dig up the anonymous methods as well as Lambda expressions. The topics in this
    chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经讨论了委托，因为它是理解匿名方法和lambda表达式的先决条件，而这也是本章的主题。通过使用匿名方法，我们可以创建一个不需要单独方法的委托实例。通过使用lambda表达式，我们可以为匿名方法创建一种简写语法。在本章中，我们将深入研究匿名方法以及Lambda表达式。本章的主题如下：
- en: Applying delegate to create and use anonymous methods
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用委托来创建和使用匿名方法
- en: Transformation of anonymous methods to lambda expressions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将匿名方法转换为lambda表达式
- en: Understanding expression trees and its relation to lambda
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解表达式树及其与lambda的关系
- en: Subscribing for events using lambda expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lambda表达式订阅事件
- en: Elaborating the benefit of lambda expressions in the use of functional programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用函数式编程中阐述lambda表达式的好处
- en: Getting to know anonymous methods
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解匿名方法
- en: 'In the previous chapter, we already discussed how to declare a delegate using
    named methods. When using named methods, we''ve have to create a method first,
    give it a name, and then associate it with the delegate. To refresh our memory,
    a simple delegate declaration associated with a named method is provided as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经讨论了如何使用命名方法声明委托。当使用命名方法时，我们必须首先创建一个方法，给它一个名称，然后将其与委托关联起来。为了提醒我们，与命名方法关联的简单委托声明如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'From the preceding code, we simply create a delegate data type named `DelDelegate`
    , and we also create a method named `DoSomething` . After we have a named method,
    we can associate the delegate with the method. Fortunately, anonymous methods
    were announced in C# 2.0 to ease the use of delegates. They provide us with a
    shortcut to create a simple and short method that will be used once. The syntax
    to declare an anonymous method is as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中，我们简单地创建了一个名为`DelDelegate`的委托数据类型，并且创建了一个名为`DoSomething`的方法。当我们有了一个命名方法后，我们可以将委托与该方法关联起来。幸运的是，C#
    2.0中宣布了匿名方法，以简化委托的使用。它们为我们提供了一种快捷方式来创建一个简单且短小的方法，该方法将被使用一次。声明匿名方法的语法如下：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The explanation for each element of the anonymous method syntax is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法语法的每个元素的解释如下：
- en: '**Delegate** : The keyword we need in order to initialize a delegate.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托**：我们需要的关键字，以便初始化委托。'
- en: '**Parameters** : The list of parameters that the method we assign to this delegate
    takes.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：我们分配给该委托的方法所需的参数列表。'
- en: '**Implementation** : The code that will be executed by the method. It can apply
    a return statement if the method needs to return a value.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现**：方法将执行的代码。如果方法需要返回一个值，可以应用返回语句。'
- en: From the preceding syntax, we can see that an anonymous method is a method that
    doesn't have a name. We just need to define the arguments and the implementation
    of the method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述语法中，我们可以看到匿名方法是一种没有名称的方法。我们只需要定义方法的参数和实现。
- en: Creating anonymous methods
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建匿名方法
- en: 'For further discussion, let''s create a simple anonymous method, which we can
    find in the `SimpleAnonymousMethods.csproj` project, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步讨论，让我们创建一个简单的匿名方法，可以在`SimpleAnonymousMethods.csproj`项目中找到，如下所示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We now have an anonymous method we assign to the delegate `displayMessageDelegate`
     delegate. We create the `displayMessageDelegate` delegate using the `Func` built-in
    delegate, which takes only one string argument and a return string value as well.
    If we need to run the anonymous method, we can invoke the delegate as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个匿名方法，我们将其分配给`displayMessageDelegate`委托。我们使用`Func`内置委托创建`displayMessageDelegate`委托，该委托只接受一个字符串参数，并且也返回一个字符串值。如果我们需要运行匿名方法，可以按照以下方式调用委托：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After running the preceding code, we will get the following output on the console:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码后，我们将在控制台上获得以下输出：
- en: '![Creating anonymous methods](img/Image00021.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![创建匿名方法](img/Image00021.jpg)'
- en: 'As we can see in the output console window, we have successfully invoked the
    anonymous method by calling the delegate name. Now, let''s go back to the previous
    chapter to use some code from there and refactor it to an anonymous method. We
    are going to refactor the code of `SimpleDelegates.csproj` , which we''ve discussed
    in the previous chapter. The following is the declaration of anonymous methods,
    and it can be found in the `SimpleDelegatesRefactor.csproj` project:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在输出控制台窗口中所看到的，我们成功地通过调用委托名称调用了匿名方法。现在，让我们回到上一章，从中使用一些代码并将其重构为匿名方法。我们将重构`SimpleDelegates.csproj`的代码，这是我们在上一章中讨论过的。以下是匿名方法的声明，可以在`SimpleDelegatesRefactor.csproj`项目中找到：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have two anonymous methods in our preceding code. We also use the `Func`
    delegate, the built-in delegate we discussed in the previous chapter. To invoke
    the methods, we can invoke the delegate name as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的代码中有两个匿名方法。我们还使用了`Func`委托，这是我们在上一章中讨论过的内置委托。要调用这些方法，我们可以按照以下方式调用委托名称：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we run the project, we will get an output like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行该项目，将会得到以下输出：
- en: '![Creating anonymous methods](img/Image00022.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![创建匿名方法](img/Image00022.jpg)'
- en: 'Compared to the code in the `SimpleDelegates.csproj` project, our code in the
    preceding `SimpleDelegatesRefactor.csproj` project becomes simpler and shorter
    since we don''t need to declare the delegate. The delegate is declared simultaneously
    with the creation of an anonymous method, such as the following code snippet:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与`SimpleDelegates.csproj`项目中的代码相比，我们在上述`SimpleDelegatesRefactor.csproj`项目中的代码变得更简单更短，因为我们不需要声明委托。委托与匿名方法的创建同时进行，例如以下代码片段：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the code we used in our previous chapter, named `SimpleDelegates.csproj`
    :'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在上一章中使用的代码，名为`SimpleDelegates.csproj`：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using anonymous delegation , we have simplified our code compared to the code
    produced in the previous chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用匿名委托，我们简化了我们的代码，与上一章中生成的代码相比。
- en: Using an anonymous method as an argument
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将匿名方法用作参数
- en: 'We have now executed an anonymous method. However, the anonymous method can
    also be passed to a method as a parameter. Let''s look at the following code,
    which we can find in the `AnonymousMethodAsArgument.csproj` project:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经执行了一个匿名方法。但是，匿名方法也可以作为参数传递给方法。让我们看一下以下代码，可以在`AnonymousMethodAsArgument.csproj`项目中找到：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First, we have a method named `FindMultipleOfSeven` in this project. The method
    will be passed to the argument of the following method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在这个项目中有一个名为`FindMultipleOfSeven`的方法。该方法将被传递给以下方法的参数：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we call the `FindMultipleOfSeven()` method from the following method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从以下方法调用`FindMultipleOfSeven()`方法：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also define the following `List` variable to be passed to the `FindMultipleOfSeven()`
    method argument:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义以下`List`变量，以便传递给`FindMultipleOfSeven()`方法的参数：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we invoke the `PrintResult()` method, we will get the following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`PrintResult()`方法，我们将得到以下输出：
- en: '![Using an anonymous method as an argument](img/Image00023.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![将匿名方法用作参数](img/Image00023.jpg)'
- en: The goal of the preceding program is to find a number that is multiplied by
    seven from the number list. And since `91` is the first number that meet this
    criteria, the `FindMultipleOfSeven()` method returns that number.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序的目标是从数字列表中找到一个乘以七的数字。由于`91`是满足此条件的第一个数字，因此`FindMultipleOfSeven()`方法返回该数字。
- en: 'Inside the `FindMultipleOfSeven()` method, we can find the `Find()` method
    passing the `IsMultipleOfSeven()` method as an argument, as shown in the following
    code snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FindMultipleOfSeven()`方法内部，我们可以找到将`IsMultipleOfSeven()`方法作为参数传递给`Find()`方法，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can, if we want, replace this method with the anonymous method, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以用匿名方法替换这个方法，如下所示：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We now have the `FindMultipleOfSevenLambda()` method, which invokes the `Find()`
    method and passes the anonymous method to the method argument. Since we have passed
    the anonymous method, we don''t need the `FindMultipleOfSeven()` method any longer.
    We can invoke the `FindMultipleOfSevenLambda()` method using the `PrintResultLambda()`
    method, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`FindMultipleOfSevenLambda()`方法，它调用`Find()`方法并将匿名方法传递给方法参数。由于我们传递了匿名方法，我们不再需要`FindMultipleOfSeven()`方法。我们可以使用`PrintResultLambda()`方法调用`FindMultipleOfSevenLambda()`方法，如下所示：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will get the following output we after we have executed the `PrintResultLambda()`
    method:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行了`PrintResultLambda()`方法后，我们将得到以下输出：
- en: '![Using an anonymous method as an argument](img/Image00024.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![将匿名方法用作参数](img/Image00024.jpg)'
- en: As we can see from the output window, we still retrieve `91` as a result of
    a number multiplication of `7` . However, we have successfully passed the anonymous
    method as the method argument.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出窗口中可以看到，我们仍然得到`91`作为`7`的乘积的结果。但是，我们已成功将匿名方法作为方法参数传递。
- en: Writing anonymous methods - some guidelines
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写匿名方法-一些指导方针
- en: 'When writing anonymous methods, here are some things that we should keep in
    mind:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写匿名方法时，以下是一些我们应该牢记的事情：
- en: 'An anonymous method has no return type in its declaration. Consider the following
    code snippet:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名方法在其声明中没有返回类型。考虑以下代码片段：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding delegate declaration, we don't find the return type, although
    we find the `return` keyword in the method implementation. This is because the
    compiler infers the return type based on the delegate signature.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的委托声明中，我们找不到返回类型，尽管在方法实现中找到了`return`关键字。这是因为编译器根据委托签名推断返回类型。
- en: 'We have to match the declaration of the delegate''s signature with the method''s
    argument. This will be similar to assigning a named method to a delegate. Let''s
    take a look at the following code snippet:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须将委托签名的声明与方法的参数匹配。这将类似于将命名方法分配给委托。让我们看一下以下代码片段：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding code snippet, we declare a delegate that takes two int arguments
    and returns an int value. Refer to the delegate signature; we use the same signature
    when declaring the anonymous method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们声明了一个接受两个int参数并返回int值的委托。参考委托签名；我们在声明匿名方法时使用相同的签名。
- en: 'We are not allowed to declare variables whose names conflict with the variables
    of the anonymous method that is declared. Take a look at the following code snippet:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不允许声明变量的名称与已声明的匿名方法的变量冲突。看一下以下代码片段：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will never be able to compile the preceding code since we declare the variable
    `i` twice both in `Conflict()` method and in `actDelegate` delegate.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们永远无法编译上述代码，因为我们在`Conflict()`方法和`actDelegate`委托中都声明了变量`i`。
- en: Advantages of the anonymous methods
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名方法的优势
- en: 'Here are some advantages of using anonymous methods:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用匿名方法的一些优点：
- en: Since we do not attach a name to a method, they are a good solution if we want
    to invoke the method only once.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们不给方法附加名称，如果我们只想调用该方法一次，它们是一个很好的解决方案。
- en: We can write the code in place rather than writing the logic in other parts
    of a code.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在原地编写代码，而不是在代码的其他部分编写逻辑。
- en: We don't need to declare the return type of the anonymous method since it will
    be inferred from the signature of the delegate that is assigned to the anonymous
    method.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要声明匿名方法的返回类型，因为它将根据分配给匿名方法的委托的签名推断出来。
- en: We can access local variables of the outer method from the anonymous method.
    Outer variables are captured inside the anonymous method.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从匿名方法中访问外部方法的局部变量。外部变量被捕获在匿名方法内部。
- en: We do not need to create a named method for snippets of logic that are invoked
    once.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于只调用一次的逻辑片段，我们不需要创建一个命名方法。
- en: Lambda expressions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: We now have an idea that anonymous methods can help us create a simple and short
    method. However, in C# 3.0, lambda expressions were announced in order to complement
    anonymous methods in providing a shorthand notation to create anonymous methods.
    In fact, lambda expressions become the preferred way when writing new code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，匿名方法可以帮助我们创建简单而简短的方法。然而，在C# 3.0中，lambda表达式被宣布为补充匿名方法的方式，提供了一种简写的方法来创建匿名方法。事实上，当编写新代码时，lambda表达式成为首选方式。
- en: 'Now, let''s examine the simplest lambda expression syntax, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下最简单的lambda表达式语法，如下所示：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the lambda expression syntax, we only find two elements, which are `parameters`
    and `expression` . Like any method, a lambda expression has an argument symbolized
    by parameters. The implementation of the lambda expression is symbolized by the
    expression. We can also omit the parenthesis of parameters if only one parameter
    is required.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda表达式语法中，我们只找到两个元素，即`parameters`和`expression`。像任何方法一样，lambda表达式具有由参数表示的参数。lambda表达式的实现由表达式表示。如果只需要一个参数，我们还可以省略参数的括号。
- en: 'Let''s create a simple lambda expression, which we can find in the `SimpleLambdaExpression.csproj`
    project, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的lambda表达式，我们可以在`SimpleLambdaExpression.csproj`项目中找到，如下所示：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we declare the `displayMessageDelegate` delegate and
    assign it to the `Func` delegate using a lambda expression. Similar to the method
    in the `SimpleDelegates.csproj` project, in order to invoke the delegate, we use
    the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了`displayMessageDelegate`委托，并使用lambda表达式将其分配给`Func`委托。与`SimpleDelegates.csproj`项目中的方法类似，为了调用委托，我们使用以下代码：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We call the `displayMessageDelegate` delegate like a method name. The output
    will be sent to the console, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像调用方法名一样调用`displayMessageDelegate`委托。输出将被发送到控制台，如下所示：
- en: '![Lambda expressions](img/Image00025.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Lambda表达式](img/Image00025.jpg)'
- en: 'Now, let''s compare the method declaration between an anonymous method in `SimpleAnonymousMethods.csproj`
    and a lambda expression in the `SimpleLambdaExpression.csproj` project:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们比较`SimpleAnonymousMethods.csproj`中的匿名方法和`SimpleLambdaExpression.csproj`项目中的lambda表达式的方法声明：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code snippet is an anonymous method declaration that is shorter
    and simpler than a named method declaration.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是一个匿名方法声明，比命名方法声明更短、更简单。
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code snippet is a lambda expression declaration that is shorter
    and simpler than an anonymous method. The lambda expressions are brief compared
    to anonymous methods.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是一个lambda表达式声明，比匿名方法更短、更简单。与匿名方法相比，lambda表达式更为简洁。
- en: Transforming an anonymous method to a lambda expression
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将匿名方法转换为lambda表达式
- en: 'Now, let''s discuss the transformation of an anonymous method to a lambda expression.
    We have the following anonymous method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论将匿名方法转换为lambda表达式。我们有以下匿名方法：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And we want to transform it to a lambda expression, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想将其转换为lambda表达式，如下所示：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'First, we take out the `delegate` keyword since we don''t need it anymore;
    so, the code will be as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们去掉了`delegate`关键字，因为我们不再需要它；所以，代码将如下所示：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we supersede the curly braces with a `=>` lambda operator in order to
    make it the inline lambda expression:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们用`=>`lambda运算符取代大括号，使其成为内联lambda表达式：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can also remove the `return` keyword since it is only a single line code
    that returns a value. The code will be as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以去掉`return`关键字，因为它只是返回一个值的单行代码。代码将如下所示：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since the preceding syntax is now an expression instead of a complete statement,
    the semicolon can be removed from the preceding code and the code will be as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的语法现在是一个表达式而不是一个完整的语句，所以可以从前面的代码中删除分号，代码将如下所示：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding expression is a valid lambda expression. However, we can simplify
    the code more in order to take advantage of the lambda expression. The code will
    be as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式是一个有效的lambda表达式。然而，为了充分利用lambda表达式，我们可以进一步简化代码。代码将如下所示：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since we have taken out `string` data type, we can now take out the parenthesis
    as well:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经去掉了`string`数据类型，我们现在也可以去掉括号：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding syntax is our final lambda expression. As we can see, now, our
    code becomes more readable because of its simplicity.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语法是我们最终的lambda表达式。正如我们所看到的，现在我们的代码变得更易读了，因为它更简单了。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The parenthesis in the parameters list of lambda expressions can be omitted
    if it contains only one argument.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数列表中只包含一个参数，则可以省略lambda表达式的括号。
- en: Using lambda expressions, we can actually create delegates and expression tree
    types in anonymous methods. Now, let's find out the difference between these two
    types in the upcoming topics.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lambda表达式，我们实际上可以在匿名方法中创建委托和表达式树类型。现在，让我们找出这两种类型之间的区别。
- en: Creating a delegate type using lambda expresions
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用lambda表达式创建委托类型
- en: 'We discussed lambda expressions in a delegate type when we created code in
    the `SimpleLambdaExpression.csproj` project. Now, let''s create another project
    name in order to discuss this by referring to the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`SimpleLambdaExpression.csproj`项目中创建代码时讨论了委托类型中的lambda表达式。现在，让我们创建另一个项目名称，以便通过以下代码进行讨论：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Again, we refactor the `SimpleDelegatesRefactor.csproj` project and replace
    the anonymous method with a lambda expression. As we can see, the lambda expression
    is assigned to a variable typed delegate. Here, we create a lambda expression
    in a delegate type. We can use the `Main()` method we had used in the `SimpleDelegatesRefactor.csproj`
    project to invoke `AreaRectangleDelegate` and `AreaSquareDelegate` . The result
    of the two projects will be completely the same.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们重构`SimpleDelegatesRefactor.csproj`项目，并用lambda表达式替换匿名方法。正如我们所看到的，lambda表达式被分配给了一个类型为委托的变量。在这里，我们在委托类型中创建了一个lambda表达式。我们可以使用在`SimpleDelegatesRefactor.csproj`项目中使用的`Main()`方法来调用`AreaRectangleDelegate`和`AreaSquareDelegate`。这两个项目的结果将完全相同。
- en: Expression trees and lambda expressions
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式树和lambda表达式
- en: Besides creating a delegate, we can create expression trees, which are data
    structures which represents the expression elements (expr, term, factor) as a
    tree. By traversing the tree, one can interpret the expression trees or we can
    mutate a node in the tree for transforming the code. In compiler parlance, expressions
    trees are called **abstract syntax trees** ( **AST** ).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建委托，我们还可以创建表达式树，这是一种代表表达式元素（表达式、项、因子）的数据结构。通过遍历树，我们可以解释表达式树，或者我们可以改变树中的节点来转换代码。在编译器术语中，表达式树被称为**抽象语法树**（**AST**）。
- en: 'Now, let''s take a look at the following code snippet in order to assign a
    lambda expression to the delegate that we discussed earlier:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下以下代码片段，以便将lambda表达式分配给我们之前讨论过的委托：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we can see, there are three sections in the preceding statement. They are
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，前面的陈述中有三个部分。它们如下：
- en: '**A variable typed delegate declaration** : `Func<int, int, int> AreaRectangleDelegate`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个变量类型的委托声明**：`Func<int, int, int> AreaRectangleDelegate`'
- en: '**An equal operator** : `=`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个等号操作符**：`=`'
- en: '**A lambda expression** : `(a, b) => a * b`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个lambda表达式**：`(a, b) => a * b`'
- en: 'We are going to translate the preceding code statement into data. To achieve
    this goal, we need to create an instance of the `Expression<T>` type, and `T`
    is delegate type. The `Expression<T>` type is defined in the `System.Linq.Expressions`
    namespace. After using this namespace in the project, we can translate our preceding
    code into an expression tree, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把前面的代码陈述翻译成数据。为了实现这个目标，我们需要创建`Expression<T>`类型的实例，其中`T`是委托类型。`Expression<T>`类型在`System.Linq.Expressions`命名空间中定义。在项目中使用这个命名空间后，我们可以将我们前面的代码转换成表达式树，如下所示：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We have converted our preceding delegate lambda expression into the expression
    tree declared to be of type `Expression<T>` . The variable expression in the preceding
    code is not executable code but a data structure called an expression tree. There
    are four essentials properties in the `Expression<T>` class that we will discuss
    in detail. They are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将前面的委托lambda表达式转换成了声明为`Expression<T>`类型的表达式树。前面代码中的变量表达式不是可执行代码，而是一个叫做表达式树的数据结构。`Expression<T>`类中有四个基本属性，我们将详细讨论它们。它们如下：
- en: '**Body** : This contains the body of the expression'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主体**：这包含了表达式的主体'
- en: '**Parameters** : This contain the parameters of the lambda expression'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：这包含了lambda表达式的参数'
- en: '**NodeType** : This contains the `ExpressionType` type of node in the tree'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NodeType**：这包含了树中节点的`ExpressionType`类型'
- en: '**Type** : This contains the static type of the expression'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：这包含了表达式的静态类型'
- en: 'Now, let''s add a breakpoint in the expression variable and run the debugging
    process by pressing **F5** in the `LambdaExpressionInExpressionTree.csproj` project.
    After executing the expression declaration line, we can take a peek at the variable
    window in the Visual Studio IDE, and we will get the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在表达式变量中添加一个断点，并通过在`LambdaExpressionInExpressionTree.csproj`项目中按下**F5**来运行调试过程。在执行表达式声明行之后，我们可以在Visual
    Studio IDE的变量窗口中窥视，并得到以下截图：
- en: '![Expression trees and lambda expressions](img/Image00026.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![表达式树和lambda表达式](img/Image00026.jpg)'
- en: 'From the preceding screenshot, we have a `Body` property containing `{(a *
    b)}` , `NodeType` containing Lambda, `Type` containing the `Func` delegate with
    three templates, and are two parameters. If we expand the `Body` information in
    the variable window, we will get a result similar to what is shown in the following
    screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们有一个包含`{(a * b)}`的`Body`属性，`NodeType`包含Lambda，`Type`包含具有三个模板的`Func`委托，并且有两个参数。如果我们在变量窗口中展开`Body`信息，我们将得到类似以下截图所示的结果：
- en: '![Expression trees and lambda expressions](img/Image00027.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![表达式树和lambda表达式](img/Image00027.jpg)'
- en: 'From the preceding screenshot, we can see that we have the `Left` property
    containing `{a}` and the `Right` property containing `{b}` . Using these properties,
    we can also explore the body of expression tree programmatically. The following
    code is the `exploreBody()` method, which will explore the properties of `Body`
    :'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们可以看到`Left`属性包含`{a}`，`Right`属性包含`{b}`。使用这些属性，我们也可以以编程方式探索表达式树的主体。以下代码是`exploreBody()`方法，它将探索`Body`的属性：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we run the preceding `exploreBody()` method, we will get the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`exploreBody()`方法，我们将得到以下输出：
- en: '![Expression trees and lambda expressions](img/Image00028.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![表达式树和lambda表达式](img/Image00028.jpg)'
- en: 'In the preceding  code, we access the Body properties of `Expression<T>` programmatically.
    We need to create a `BinaryExpression`  data type in order to get the `Body` content,
    and `ParameterExpression` in order to get the `Left` and `Right` properties content.
    The code snippet for the `BinaryExpression` and `ParameterExpression` data is
    as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们以编程方式访问了`Expression<T>`的`Body`属性。为了获取`Body`内容，我们需要创建一个`BinaryExpression`数据类型，并且为了获取`Left`和`Right`属性的内容，我们需要创建一个`ParameterExpression`。`BinaryExpression`和`ParameterExpression`数据的代码片段如下：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have successfully created a data structure from the code in the expression
    tree. We can, if we want, convert this data back into code by compiling the expression.
    The expression we have is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地从表达式树中的代码创建了一个数据结构。如果我们愿意，我们可以通过编译表达式将这些数据转换回代码。我们现在有的表达式如下：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, we can compile the expression and run the code in the expression using
    the following `compilingExpr()` method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以编译表达式，并使用以下`compilingExpr()`方法运行表达式中的代码：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we run the `compilingExpr()` method, the following output will be displayed
    on the console window:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`compilingExpr()`方法，将在控制台窗口上显示以下输出：
- en: '![Expression trees and lambda expressions](img/Image00029.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![表达式树和lambda表达式](img/Image00029.jpg)'
- en: 'As we can see, we have compiled the expression using the `Compile()` method
    in the expression class, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们使用表达式类中的`Compile()`方法编译了表达式：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `expr.Compile()` method produces a delegate of type `Func<int, int, int>`
    in accordance with the type of the expression. We give the `Compile()` method
    the arguments `a` and `b` based on its signature, then it returns the `int` value.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`expr.Compile()`方法根据表达式的类型生成`Func<int, int, int>`类型的委托。我们根据其签名给`Compile()`方法传递参数`a`和`b`，然后它返回`int`值。'
- en: Subscribing for events using lambda expressions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lambda表达式订阅事件
- en: 'In C#, an object or a class can be used to inform other objects or classes
    when something happens, which is known as an event. There are two kinds of classes
    in the event, they are publishers and subscribers. The publisher is a class or
    object that sends (or raises) the event, while the subscriber is a class or object
    that receives (or handles) the event. Fortunately, lambda expressions can also
    be used to handle events. Let''s take a look at the following code to discuss
    events further:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，对象或类可以用来在发生某事时通知其他对象或类，这就是事件。事件中有两种类，它们是发布者和订阅者。发布者是发送（或引发）事件的类或对象，而订阅者是接收（或处理）事件的类或对象。幸运的是，lambda表达式也可以用来处理事件。让我们看一下以下代码来进一步讨论事件：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding code can be found in the `EventsInLambda.csproj` project. As
    we can see, a class named `EventClassWithoutEvent` has been created in the project.
    The class has a property named `OnChange` . This property''s role is to store
    the action that subscribes the class and will be run when the `Raise()` method
    is invoked. Now, let''s consume the `Raise()` method using the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以在`EventsInLambda.csproj`项目中找到。正如我们所看到的，项目中创建了一个名为`EventClassWithoutEvent`的类。该类有一个名为`OnChange`的属性。该属性的作用是存储订阅类并在调用`Raise()`方法时运行。现在，让我们使用以下代码调用`Raise()`方法：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we run the preceding `CreateAndRaiseEvent()` method, we will retrieve the
    following output on the console:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`CreateAndRaiseEvent()`方法，将在控制台上获得以下输出：
- en: '![Subscribing for events using lambda expressions](img/Image00030.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![使用lambda表达式订阅事件](img/Image00030.jpg)'
- en: 'From the code, we can see that when we invoke the `CreateAndRaiseEvent()` method,
    the code instances an `EventClassWithoutEvent` class. It then subscribes to the
    event with five different methods inside the lambda expression and then raises
    the event by invoking the `Raise()` method. The following code snippet will explain
    this further:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中，我们可以看到当调用`CreateAndRaiseEvent()`方法时，代码实例化了一个`EventClassWithoutEvent`类。然后它在lambda表达式中订阅了五种不同的方法，然后通过调用`Raise()`方法引发了事件。以下代码片段将进一步解释这一点：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'From the preceding code snippet, we can see that the lambda expression can
    be used to subscribe to the event since it uses a delegate to store the subscribed
    method. However, there is still a weakness in the preceding code. Take a look
    at the last `OnChange` assignment from this code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们可以看到lambda表达式可以用来订阅事件，因为它使用委托来存储订阅的方法。然而，前面的代码仍然存在一个弱点。看一下这段代码中的最后一个`OnChange`赋值：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, suppose that we change it to this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们将其更改为这样：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Then, we will remove all four previous subscribers. Another weakness is that
    `EventClassWithoutEvent` raises the event but nothing can stop the users of the
    class from raising this event. By invoking `OnChange()` , all users of the class
    can raise the event to all subscribers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将删除所有四个先前的订阅者。另一个弱点是`EventClassWithoutEvent`引发了事件，但没有任何东西可以阻止类的用户引发此事件。通过调用`OnChange()`，类的所有用户都可以向所有订阅者引发事件。
- en: Using the event keyword
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事件关键字
- en: 'The use of the `event` keyword can solve our preceding problem since it will
    enforce the users of the class to subscribe something only using either the `+=`
    or `-=` operator. Let''s take a look at the following code to explain this further:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`event`关键字可以解决我们之前的问题，因为它将强制类的用户只能使用`+=`或`-=`运算符订阅某些内容。让我们看一下以下代码来进一步解释这一点：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'From the preceding code, we can see that we are no longer using a public property
    but a public field in the `EventClassWithEvent` class. Using the `event` keyword,
    the compiler will secure our field from unwanted access. The event keyword will
    also protect the subscription list since it cannot be assigned to any lambda expression
    using the `=` operator but has to be used with the `+=` or `-=` operator. Now,
    let''s take a look at the following code to prove this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到我们不再使用公共属性，而是使用`EventClassWithEvent`类中的公共字段。使用`event`关键字，编译器将保护我们的字段免受未经授权的访问。事件关键字还将保护订阅列表，因为它不能使用`=`运算符分配给任何lambda表达式，而必须与`+=`或`-=`运算符一起使用。现在，让我们看一下以下代码来证明这一点：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We now have a method named `CreateAndRaiseEvent2()` , which is exactly same
    as the `CreateAndRaiseEvent()` method except that the last `OnChange` assignment
    used the `=` operator instead of the `+=` operator. However, since we have applied
    the event keyword to the `OnChange` field, the code cannot be compiled and the
    `CS0070` error code will occur, as shown in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个名为`CreateAndRaiseEvent2()`的方法，它与`CreateAndRaiseEvent()`方法完全相同，只是最后的`OnChange`赋值使用了`=`运算符而不是`+=`运算符。然而，由于我们已经将事件关键字应用于`OnChange`字段，代码无法编译，将出现`CS0070`错误代码，如下面的屏幕截图所示：
- en: '![Using the event keyword](img/Image00031.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![使用事件关键字](img/Image00031.jpg)'
- en: 'There is no risk anymore since the event keyword has restricted the use of
    the `=` operator. The `event` keyword also prevents the outside user of the class
    from raising the event. Only the part of the class that defines the event can
    raise the event. Let''s take a look at the difference between the `EventClassWithoutEvent`
    and `EventClassWithEvent` class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件关键字限制了`=`运算符的使用，不再存在风险。`event`关键字还阻止了类的外部用户引发事件。只有定义事件的类的部分才能引发事件。让我们来看一下`EventClassWithoutEvent`和`EventClassWithEvent`类之间的区别：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The reference of the preceding `CreateAndRaiseEvent3()` method is `CreateAndRaiseEvent()`
    , but we insert `ev.OnChange()` ; in between the third event and fourth event.
    If we run the method, it will run successfully, and we will see the following
    output on the console:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`CreateAndRaiseEvent3()`方法的引用是`CreateAndRaiseEvent()`，但我们在第三个事件和第四个事件之间插入了`ev.OnChange()`。如果我们运行该方法，它将成功运行，并且我们将在控制台上看到以下输出：
- en: '![Using the event keyword](img/Image00032.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![使用事件关键字](img/Image00032.jpg)'
- en: 'As we can see from the output, `OnChange()` in the `EventClassWithoutEvent`
    class can raise the event. Compared to the `EventClassWithEvent` class, if we
    insert `OnChange()` between any subscribing event, the compiler will create a
    compile error, as shown in the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，`EventClassWithoutEvent`类中的`OnChange()`可以引发事件。与`EventClassWithEvent`类相比，如果我们在任何订阅事件之间插入`OnChange()`，编译器将创建编译错误，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If we compile the preceding code, we will get the `CS0070` error code again,
    since we insert `ev.OnChange()` ; in between the third event and the fourth event.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译前面的代码，将再次得到`CS0070`错误代码，因为我们在第三个事件和第四个事件之间插入了`ev.OnChange()`。
- en: Using EventHandler or EventHandler<T>
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用EventHandler或EventHandler<T>
- en: 'Actually, C# has a class named `EventHandler` or `EventHandler<T>` that we
    can use to initialize an event instead of using an `Action` class. An `EventHandler`
    class takes a sender object and event arguments. The sender is the object that
    raises the event. Using `EventHandler<T>` , we can define the type of event arguments.
    Let''s take a look at the following code, which we can find in the `EventWithEventHandler.csproj`
    project:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，C#有一个名为`EventHandler`或`EventHandler<T>`的类，我们可以使用它来初始化事件，而不是使用`Action`类。`EventHandler`类接受一个发送者对象和事件参数。发送者是引发事件的对象。使用`EventHandler<T>`，我们可以定义事件参数的类型。让我们看一下在`EventWithEventHandler.csproj`项目中找到的以下代码：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We have two classes, named `MyArgs` and `EventClassWithEventHandler` . The
    `EventClassWithEventHandler` class uses `EventHandler<MyArgs>` , which defines
    the event argument''s type. We need to pass an instance of `MyArgs` when raising
    the event. Subscribers of the event can access the arguments and use them. Now,
    let''s take a look at the following `CreateAndRaiseEvent()` method code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个类，名为`MyArgs`和`EventClassWithEventHandler`。`EventClassWithEventHandler`类使用`EventHandler<MyArgs>`，它定义了事件参数的类型。在引发事件时，我们需要传递`MyArgs`的一个实例。事件的订阅者可以访问并使用参数。现在，让我们看一下以下`CreateAndRaiseEvent()`方法的代码：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we run the preceding code, we will get the following output on the console:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，将在控制台上看到以下输出：
- en: '![Using EventHandler or EventHandler<T>](img/Image00033.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![使用EventHandler或EventHandler<T>](img/Image00033.jpg)'
- en: 'From the preceding code, we can see that the lambda expression plays its role
    to subscribe to an event, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到lambda表达式发挥了订阅事件的作用，如下所示：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The advantages of using lambda expression in functional programming
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数式编程中使用lambda表达式的优势
- en: Lambda expressions are not only a powerful way to provide a shorthand notation
    for anonymous methods, but they are also used in functional programming. In this
    section, we will go through the advantages of using the lambda expression in the
    context of functional programming.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式不仅是提供匿名方法的简写符号的强大方式，而且还在函数式编程中使用。在本节中，我们将讨论在函数式编程的上下文中使用lambda表达式的优势。
- en: First-class functions
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一流函数
- en: 'In [Chapter 1](text00016.html#ch01 "Chapter 1. Tasting Functional Style in
    C#") , *Tasting Functional Style in C#* , we discussed the idea of first-class
    functions when we were discussing functional programming. If functions are fire
    class Functions, functions obey value semantics. They can be passed as a parameter,
    returned from a function, and so on. If we go back to the earlier topic about
    lambda expressions, we have a project named `SimpleLambdaExpression.csproj` ,
    which has the following simple lambda expression:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](text00016.html#ch01 "第1章。在C#中品尝函数式风格")中，*在C#中品尝函数式风格*，我们在讨论函数式编程时讨论了一流函数的概念。如果函数是一流函数，函数遵循值语义。它们可以作为参数传递，从函数返回，等等。如果我们回到关于lambda表达式的早期话题，我们有一个名为`SimpleLambdaExpression.csproj`的项目，其中包含以下简单的lambda表达式：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we can add the following `firstClassConcept()` method to the project
    in order to demonstrate the first-class function using a lambda expression:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将以下`firstClassConcept()`方法添加到项目中，以演示使用lambda表达式的一流函数：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As we can see, we have successfully assigned the `displayMessageDelegate()`
    method to the variable named `str` , as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们已成功将`displayMessageDelegate()`方法分配给名为`str`的变量，如下所示：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we run the code, we will get the following output on the console:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行代码，将在控制台上看到以下输出：
- en: '![First-class functions](img/Image00034.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![一流函数](img/Image00034.jpg)'
- en: 'We can also pass the lambda expression as the argument of the other function.
    Using `displayMessageDelegate` , let''s take a look at the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将lambda表达式作为其他函数的参数传递。使用`displayMessageDelegate`，让我们看一下以下代码：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We have a method named `firstClassConcept2` , which takes `Func` and string
    parameters. We can run the method as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`firstClassConcept2`的方法，它接受`Func`和字符串参数。我们可以按以下方式运行该方法：
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As we can see, we pass `displayMessageDelegate` , which is a lambda expression,
    to the `firstClassConcept2()` method. If we run the project, we will have the
    following output on the console window:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们将lambda表达式`displayMessageDelegate`传递给`firstClassConcept2()`方法。如果我们运行该项目，将在控制台窗口上看到以下输出：
- en: '![First-class functions](img/Image00035.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![一流函数](img/Image00035.jpg)'
- en: Since we have successfully assigned a function to a variable and passed a function
    to another function parameter, we can say that the lambda expression is a power
    tool to create first-class functions in functional programming.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经成功地将一个函数分配给一个变量，并将一个函数传递给另一个函数参数，我们可以说lambda表达式是在函数式编程中创建一流函数的强大工具。
- en: Closure
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Closure is a function that is able to be assigned to a variable (a first-class
    function) with free variables, which are bound in the lexical environment. A free
    variable is a variable that is not a parameter; or it is a local variable. In
    a closure, any variable that is not bound will be captured from the lexical environment
    where the closure is defined. To avoid getting confused about this term, let''s
    take a look at the following code, which we can find in the `Closure.csproj` project:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是一个能够被分配给一个变量（第一类函数）的函数，它具有自由变量，这些变量在词法环境中被绑定。自由变量是一个不是参数的变量；或者是一个局部变量。在闭包中，任何未绑定的变量都将从定义闭包的词法环境中捕获。为了避免对这个术语感到困惑，让我们看一下以下代码，在`Closure.csproj`项目中可以找到：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'From the preceding code, we can see that we''ve got a local variable named
    `localVar` , and it will be multiplied by 2 when the `GetFunction()` method is
    invoked. The `localVar` variable is bound inside the lambda expression when `returnValue`
    is returned. By analyzing the preceding code without running it, we might guess
    that `GetFunction()` will return `returnFunc` , which will always return the same
    value every time it''s passed to the same argument. This is because `localVar`
    will always be *1* every time `GetFunction()` is invoked, since it''s a local
    variable. As we learned in programming, the local variables are created on the
    stack and they will go away when the method has finished execution. Now, let''s
    invoke the `GetFunction()` method to prove our guess using the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码中，我们可以看到我们有一个名为`localVar`的局部变量，当调用`GetFunction()`方法时，它将乘以2。`localVar`变量在`returnValue`返回时绑定在lambda表达式中。通过分析前面的代码而不运行它，我们可能会猜测`GetFunction()`将返回`returnFunc`，每次传递给相同的参数时都将返回相同的值。这是因为`localVar`每次调用`GetFunction()`时都将始终为*1*，因为它是一个局部变量。正如我们在编程中学到的，局部变量是在堆栈上创建的，当方法执行完毕时它们将消失。现在，让我们调用`GetFunction()`方法来证明我们的猜测，使用以下代码：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We are going to invoke the `incrementFunc()` method, which is the return value
    of the `GetFunction()` method ten times, but we always pass 1 as the argument.
    From our previous guessing, we can say that the `incrementFunc(1)` method will
    always return `3` for all ten invocations. Now, let''s run the project, and we
    will see the following output on the console:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`incrementFunc()`方法，这是`GetFunction()`方法的返回值，调用十次，但我们总是传递1作为参数。根据我们之前的猜测，我们可以说`incrementFunc(1)`方法在所有十次调用中都将返回`3`。现在，让我们运行项目，我们将在控制台上看到以下输出：
- en: '![Closure](img/Image00036.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![Closure](img/Image00036.jpg)'
- en: According to the preceding output, we made a wrong guess. The `localVar` variable
    lives along with the `GetFunction()` method. It stores its value after being multiplied
    by 2 each time the method is called. We have successfully bound a free variable
    in the lexical environment and this is what we call closure.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的输出，我们猜错了。`localVar`变量与`GetFunction()`方法一起存在。它在每次调用方法时都会存储其值乘以2。我们已经成功地在词法环境中绑定了一个自由变量，这就是我们所说的闭包。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discovered that an anonymous method is a method that doesn't
    have a name. We just need to define the arguments and the implementation of the
    method. It's a shorthand notation from delegates. Then, we looked at lambda expressions,
    the powerful tool in functional programming, which can provide a shorthand notation
    from an anonymous method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现匿名方法是一种没有名称的方法。我们只需要定义方法的参数和实现。这是从委托中的简写表示。然后，我们看了lambda表达式，这是函数式编程中的强大工具，可以提供匿名方法的简写表示。
- en: The lambda expression can also be used to form an expression tree that will
    be useful when we need to express our code in regular C#, deconstruct it, inspect
    it, and interpret it. The expression tree is like an explanation of the code.
    If we have a `<Func<int, int, int>>`  expression, it explains how it will provide
    an `int` return if we give the code two integers.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式也可以用来形成表达式树，当我们需要用常规C#表达我们的代码，解构它，检查它和解释它时，这将非常有用。表达式树就像是代码的解释。如果我们有一个`<Func<int,
    int, int>>`表达式，它解释了如果我们给代码两个整数，它将提供一个`int`返回。
- en: Subscribing an event is also done by a lambda expression. There are two kinds
    of classes in the event, they are publisher and subscribers, and we can subscribe
    to the event using a lambda expression. It doesn't matter whether we use the `event`
    keyword or the `EventHandler` keyword, the lambda is always used to subscribe
    to the event.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过lambda表达式也可以订阅事件。事件中有两种类，发布者和订阅者，我们可以使用lambda表达式订阅事件。无论我们使用`event`关键字还是`EventHandler`关键字，lambda表达式都可以用来订阅事件。
- en: The first-class function concept is also fulfilled by lambda expressions since
    by using it, we can assign the function into a variable or pass the function as
    an argument of other functions. Using lambda expressions, we can also apply a
    closure concept, which makes a local variable live along within the function.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类函数概念也可以通过lambda表达式来实现，因为通过使用它，我们可以将函数分配给变量或将函数作为其他函数的参数传递。使用lambda表达式，我们还可以应用闭包概念，使局部变量在函数内部保持活动状态。
- en: For now, it's enough to discuss lambda expressions. However, we will discuss
    lambda expressions again in more more detail when we talk about LINQ in [Chapter
    5](text00039.html#page "Chapter 5. Querying Any Collection Easily with LINQ")
    , *Querying Any Collections Easily with LINQ* . And, in the next chapter, we are
    going to talk about the extension method that can be used to extend method abilities.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，讨论lambda表达式就足够了。但是，当我们在[第5章](text00039.html#page "第5章。使用LINQ轻松查询任何集合")中讨论LINQ时，我们将再次更详细地讨论lambda表达式，*使用LINQ轻松查询任何集合*。而在下一章中，我们将讨论可以用来扩展方法能力的扩展方法。
