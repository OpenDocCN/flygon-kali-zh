- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Testing Your Code with Unit Test Cases and TDD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单元测试用例和TDD测试您的代码
- en: When developing software, it is essential to ensure that an application is bug-free
    and that it satisfies all requirements. This can be done by testing all the modules
    while they are being developed, or when the overall application has been either
    completely or partially implemented.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，确保应用程序没有错误并且满足所有要求是至关重要的。这可以通过在开发过程中测试所有模块，或者在整个应用程序已经完全或部分实现时进行测试来完成。
- en: Performing all the tests manually is not a feasible option since most of the
    tests must be executed each time the application is modified and, as explained
    throughout this book, modern software is being continuously modified to adapt
    the applications to the needs of a fast-changing market. This chapter discusses
    all the types of tests needed to deliver reliable software, and how to organize
    and automate them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 手动执行所有测试并不可行，因为大多数测试必须在应用程序修改时每次执行，并且正如本书中所解释的那样，现代软件正在不断修改以适应快速变化的市场需求。本章讨论了交付可靠软件所需的所有类型的测试，以及如何组织和自动化它们。
- en: 'More specifically, this chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，本章涵盖以下主题：
- en: Understanding unit and integration tests and their usage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解单元测试和集成测试及其用法
- en: Understanding the basics of **Test-Driven Development** (**TDD**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解**测试驱动开发**（**TDD**）的基础知识
- en: Defining C# test projects in Visual Studio
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio中定义C#测试项目
- en: Use case – Automating unit tests in DevOps Azure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例 - 在DevOps Azure中自动化单元测试
- en: In this chapter, we'll see which types of tests are worth implementing, and
    what unit tests are. We'll see the different types of projects available and how
    to write unit tests in them. By the end of the chapter, the book use case will
    help us to execute our tests in Azure DevOps during the **Continuous Integration/Continuous
    Delivery** (**CI/CD**) cycle of our applications automatically.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到哪些类型的测试值得实施，以及什么是单元测试。我们将看到可用的不同类型的项目以及如何在其中编写单元测试。在本章结束时，本书的用例将帮助我们在Azure
    DevOps中执行我们的测试，自动执行我们应用程序的**持续集成/持续交付**（**CI/CD**）周期中的测试。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the Visual Studio 2019 free Community Edition or better
    with all database tools installed. It also requires a free Azure account. If you
    have not already created one, refer to the *Creating an Azure account* section
    in *Chapter 1*, *Understanding the Importance of Software Architecture*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装Visual Studio 2019免费社区版或更高版本，并安装所有数据库工具。还需要一个免费的Azure帐户。如果您还没有创建，请参阅*第1章*中的*创建Azure帐户*部分。
- en: All concepts in this chapter are clarified with practical examples based on
    the WWTravelClub book use case. The code for this chapter is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有概念都以基于WWTravelClub书用例的实际示例进行了澄清。本章的代码可在[https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-C-9-and-.NET-5)上找到。
- en: Understanding unit and integration tests
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解单元测试和集成测试
- en: 'Delaying the application testing until immediately after most of its functionalities
    have been completely implemented must be avoided for the following reasons:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟应用程序测试直到大部分功能已完全实现必须避免以下原因：
- en: If a class or module has been incorrectly designed or implemented, it might
    have already influenced the way other modules were implemented. Therefore, at
    this point, fixing the problem might have a very high cost.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类或模块设计或实现不正确，它可能已经影响了其他模块的实现方式。因此，在这一点上，修复问题可能会有很高的成本。
- en: The possible combination of input that is needed to test all possible paths
    that execution can take grows exponentially with the number of modules or classes
    that are tested together. Thus, for instance, if the execution of a class method
    `A` can take three different paths, while the execution of another method `B`
    can take four paths, then testing `A` and `B` together would require 3 x 4 different
    inputs. In general, if we test several modules together, the total number of paths
    to test is the product of the number of paths to test in each module. If modules
    are tested separately, instead, the number of inputs required is just the sum
    of the paths needed to test each module.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试所有可能执行路径所需的输入组合随着一起测试的模块或类的数量呈指数增长。因此，例如，如果类方法`A`的执行可以有三条不同的路径，而另一个方法`B`的执行可以有四条路径，那么测试`A`和`B`将需要3
    x 4个不同的输入。一般来说，如果我们一起测试几个模块，要测试的路径总数是每个模块中要测试的路径数的乘积。相反，如果模块分开测试，所需的输入数量只是测试每个模块所需的路径的总和。
- en: If a test of an aggregate made of *N* modules fails, then locating the origin
    of the bug among the *N* modules is usually a very time-consuming activity.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果由*N*个模块组成的聚合的测试失败，那么在*N*个模块中定位错误的来源通常是一项非常耗时的活动。
- en: When *N* modules are tested together, we have to redefine all tests involving
    the *N* modules, even if just one of the *N* modules changes during the application's
    CI/CD cycle.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一起测试*N*个模块时，我们必须重新定义涉及*N*个模块的所有测试，即使*N*个模块中的一个发生了变化。
- en: These considerations show that it is more convenient to test each module method
    separately. Unluckily, a battery of tests that verifies all methods independently
    from their context is incomplete because some bugs may be caused by incorrect
    interactions between modules.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些考虑表明，更方便的是分别测试每个模块方法。不幸的是，验证所有方法而不考虑它们的上下文的一系列测试是不完整的，因为一些错误可能是由模块之间的不正确交互引起的。
- en: 'Therefore, tests are organized into two stages:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试分为两个阶段：
- en: '**Unit tests**: These verify that all execution paths of each module behave
    properly. They are quite complete and usually cover all possible paths. This is
    feasible because there are not many possible execution paths of each method or
    module compared to the possible execution paths of the whole application.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这些测试验证每个模块的所有执行路径是否正常。它们非常完整，通常覆盖所有可能的路径。这是因为与整个应用程序的可能执行路径相比，每个方法或模块的可能执行路径并不多。'
- en: '**Integration tests**: These are executed once the software passes all its
    unit tests. Integration tests verify that all modules interact properly to get
    the expected results. Integration tests do not need to be complete since unit
    tests will have already verified that all execution paths of each module work
    properly. They need to verify all patterns of interaction, that is, all the possible
    ways in which the various modules may cooperate.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这些测试在软件通过所有单元测试后执行。集成测试验证所有模块是否正确交互以获得预期结果。集成测试不需要完整，因为单元测试已经验证了每个模块的所有执行路径是否正常工作。它们需要验证所有交互模式，也就是各种模块可能合作的所有可能方式。'
- en: 'Usually, each interaction pattern has more than one test associated with it:
    a typical activation of a pattern, and some extreme cases of activation. For instance,
    if a whole pattern of interaction receives an array as input, we will write a
    test for the typical size of the array, a test with a `null` array, a test with
    an empty array, and a test with a very big array. This way, we verify that the
    way the single module was designed is compatible with the needs of the whole interaction
    pattern.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每种交互模式都有多个与之关联的测试：一种是典型的模式激活，另一种是一些极端情况下的激活。例如，如果整个交互模式接收一个数组作为输入，我们将编写一个测试来测试数组的典型大小，一个测试用`null`数组，一个测试用空数组，以及一个测试用非常大的数组。这样，我们可以验证单个模块的设计是否与整个交互模式的需求相匹配。
- en: With the preceding strategy in place, if we modify a single module without changing
    its public interface, we need to change the unit tests for that module.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有了前面的策略，如果我们修改一个单个模块而不改变其公共接口，我们需要修改该模块的单元测试。
- en: If, instead, the change involves the way some modules interact, then we also
    have to add new integration tests or to modify existing ones. However, usually,
    this is not a big problem since most of the tests are unit tests, so rewriting
    a large percentage of all integration tests does not require too big an effort.
    Moreover, if the application was designed according to the **Single Responsibility**,
    **Open/Closed**, **Liskov Substitution**, **Interface Segregation**, or **Dependency
    Inversion** (**SOLID**) principles, then the number of integration tests that
    must be changed after a single code modification should be small since the modification
    should affect just a few classes that interact directly with the modified method
    or class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果改变涉及到一些模块的交互方式，那么我们还需要添加新的集成测试或修改现有的集成测试。然而，通常情况下，这并不是一个大问题，因为大多数测试都是单元测试，因此重写所有集成测试的大部分并不需要太大的努力。此外，如果应用程序是根据**单一职责**、**开闭原则**、**里氏替换原则**、**接口隔离原则**或**依赖倒置原则**（**SOLID**）原则设计的，那么在单个代码修改后必须更改的集成测试数量应该很小，因为修改应该只影响直接与修改的方法或类交互的几个类。
- en: Automating unit and integration tests
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化单元和集成测试
- en: At this point, it should be clear that both unit tests and integration tests
    must be reused during the entire lifetime of the software. That is why it is worth
    automating them. Automation of unit and integration tests avoids possible errors
    of manual test execution and saves time. A whole battery of several thousand automated
    tests can verify software integrity after each small modification in a few minutes,
    thereby enabling the frequent changes needed in the CI/CD cycles of modern software.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，应该清楚地知道单元测试和集成测试都必须在软件的整个生命周期中得到重复使用。这就是为什么值得自动化它们。自动化单元和集成测试可以避免手动测试执行可能出现的错误，并节省时间。几千个自动化测试可以在每次对现代软件的CI/CD周期中所需的频繁更改中，在几分钟内验证软件的完整性，从而使得频繁更改成为可能。
- en: As new bugs are found, new tests are added to discover them so that they cannot
    reappear in future versions of the software. This way, automated tests always
    become more reliable and protect the software more from bugs added as a result
    of new changes. Thus, the probability of adding new bugs (that are not immediately
    discovered) is greatly reduced.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着发现新的错误，会添加新的测试来发现它们，以便它们不会在软件的未来版本中重新出现。这样，自动化测试总是变得更加可靠，并更好地保护软件免受由于新更改而引入的错误。因此，添加新错误的概率（不会立即被发现的错误）大大降低了。
- en: The next section will give us the basics for organizing and designing automated
    unit and integration tests, as well as practical details on how to write a test
    in C# in the *Defining* *C# Test Projects* section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将为我们提供组织和设计自动化单元和集成测试的基础，以及如何在*C#测试项目定义*部分中编写测试的实际细节。
- en: Writing automated (unit and integration) tests
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自动化（单元和集成）测试
- en: Tests are not written from scratch; all software development platforms have
    tools that help us to both write tests and launch them (or some of them). Once
    the selected tests have been executed, all tools show a report and give the possibility
    to debug the code of all failed tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不是从头开始编写的；所有软件开发平台都有工具，可以帮助我们编写测试并运行它们（或其中一些）。一旦选择的测试被执行，所有工具都会显示报告，并提供调试所有失败测试代码的可能性。
- en: 'More specifically, all unit and integration test frameworks are made of three
    important parts:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，所有单元和集成测试框架都由三个重要部分组成：
- en: '**Facilities for defining all tests**: They verify whether the actual results
    correspond to expected results. Usually, a test is organized into test classes,
    where each test call tests either a single application class or a single class
    method. Each test is split into three stages:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义所有测试的设施**：它们验证实际结果是否与预期结果相符。通常，测试被组织成测试类，每个测试调用要么测试单个应用程序类，要么测试单个类方法。每个测试分为三个阶段：'
- en: '**Test preparation**: The general environment needed by the test is prepared.
    This stage only prepares the global environment for tests, such as objects to
    inject in class constructors or simulations of database tables; it doesn''t prepare
    the individual inputs for each of the methods we''re going to test. Usually, the
    same preparation procedure is used in several tests, so test preparations are
    factored out into dedicated modules.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试准备：准备测试所需的一般环境。这个阶段只是为测试准备全局环境，比如要注入到类构造函数中的对象或数据库表的模拟；它不准备我们要测试的每个方法的单独输入。通常，相同的准备过程用于多个测试，因此测试准备被分解成专门的模块。
- en: '**Test execution**: The methods to test are invoked with adequate input and
    all results of their executions are compared with expected results with constructs
    such as `Assert.Equal(x, y)` and `Assert.NotNull(x)`.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试执行：使用适当的输入调用要测试的方法，并将其执行的所有结果与预期结果进行比较，使用诸如`Assert.Equal(x, y)`和`Assert.NotNull(x)`之类的结构。
- en: '**Tear-down**: The whole environment is cleaned up to avoid the execution of
    a test influencing other tests. This step is the converse of *step 1*.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拆卸：清理整个环境，以避免一个测试的执行影响其他测试。这一步是*步骤1*的相反。
- en: '**Mock facilities**: While integration tests use all (or almost all) classes
    involved in a pattern of object cooperation, in unit tests, the use of other application
    classes is forbidden. Thus, if a class under test, say, `A`, uses a method of
    another application class, `B`, that is injected in its constructor in one of
    its methods, `M`, then in order to test `M`, we must inject a fake implementation
    of `B`. It is worth pointing out that only classes that do some processing are
    not allowed to use another class during unit tests, while pure data classes can.
    Mock frameworks contain facilities to define implementations of interfaces and
    interface methods that return data that can be defined in tests. Typically, mock
    implementations are also able to report information on all mock method calls.
    Such mock implementations do not require the definition of actual class files,
    but are done online in the test code by calling methods such as `new Mock<IMyInterface>()`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟设施：集成测试使用涉及对象协作模式的所有（或几乎所有）类，而单元测试则禁止使用其他应用程序类。因此，如果被测试的类A使用另一个应用程序类B的方法，该方法在其构造函数或方法M中被注入，那么为了测试M，我们必须注入B的一个虚假实现。值得指出的是，只有在单元测试期间，才不允许执行一些处理的类使用另一个类，而纯数据类可以。模拟框架包含定义接口和接口方法实现的设施，这些实现返回可以在测试中定义的数据。通常，模拟实现还能够报告所有模拟方法调用的信息。这样的模拟实现不需要定义实际的类文件，而是通过调用诸如`new
    Mock<IMyInterface>()`之类的方法在线上测试代码中完成。
- en: '**Execution and reporting tool**: This is a visual configuration-based tool
    that the developer may use to decide which tests to launch and when to launch
    them. Moreover, it also shows the final outcome of the tests as a report containing
    all successful tests, all failed tests, each test''s execution time, and other
    information that depends on the specific tool and on how it was configured. Usually,
    execution and reporting tools that are executed in development IDEs such as Visual
    Studio also give you the possibility of launching a debug session on each failed
    test.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行和报告工具：这是一个基于可视化配置的工具，开发人员可以用来决定何时启动哪些测试以及何时启动它们。此外，它还显示了测试的最终结果，包括所有成功的测试、所有失败的测试、每个测试的执行时间以及依赖于特定工具和配置方式的其他信息的报告。通常，在开发IDE（如Visual
    Studio）中执行的执行和报告工具还可以让您在每个失败的测试上启动调试会话。
- en: Since only interfaces allow a complete mock definition of all their methods,
    we should inject interfaces or pure data classes (that don't need to be mocked)
    in class constructors and methods; otherwise, classes could not be unit tested.
    Therefore, for each cooperating class that we want to inject into another class,
    we must define a corresponding interface.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有接口允许完全模拟定义其所有方法，我们应该在类的构造函数和方法中注入接口或纯数据类（不需要模拟）；否则，类将无法进行单元测试。因此，对于我们想要注入到另一个类中的每个协作类，我们必须定义一个相应的接口。
- en: Moreover, classes should use instances that are injected in their constructors
    or methods, and not class instances available in the public static fields of other
    classes; otherwise, the hidden interactions might be forgotten while writing tests,
    and this might complicate the *preparation* step of tests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，类应该使用在它们的构造函数或方法中注入的实例，而不是其他类的公共静态字段中可用的类实例；否则，在编写测试时可能会忘记隐藏的交互，这可能会使测试的准备步骤变得复杂。
- en: The following section describes other types of tests used in software development.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分描述了软件开发中使用的其他类型的测试。
- en: Writing acceptance and performance tests
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写验收和性能测试
- en: Acceptance tests define the contract between the project stakeholders and the
    development team. They are used to verify that the software developed actually
    behaves as agreed with them. Acceptance tests verify not only functional specifications,
    but also constraints on the software usability and user interface. Since they
    also have the purpose of showing how the software appears and behaves on actual
    computer monitors and displays, they are never completely automatic, but consist
    mainly of lists of recipes and verifications that must be followed by an operator.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试定义了项目利益相关者和开发团队之间的合同。它们用于验证开发的软件实际上是否与他们达成的协议一致。验收测试不仅验证功能规范，还验证了软件可用性和用户界面的约束。由于它们还有展示软件在实际计算机监视器和显示器上的外观和行为的目的，它们永远不是完全自动的，而主要由操作员遵循的食谱和验证列表组成。
- en: Sometimes, automatic tests are developed to verify just the functional specifications,
    but such tests usually bypass the user interface and inject the test input directly
    in the logic that is immediately behind the user interface. For instance, in the
    case of an ASP.NET Core MVC application, the whole website is run in a complete
    environment that includes all the necessary storage filled with test data. Input
    is not provided to HTML pages, but is injected directly in the ASP.NET Core controllers.
    Tests that bypass the user interface are called subcutaneous tests. ASP.NET Core
    supplies various tools to perform subcutaneous tests and also tools that automate
    interaction with HTML pages.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，自动测试是为了验证功能规范而开发的，但这些测试通常绕过用户界面，并直接将测试输入注入到用户界面后面的逻辑中。例如，在ASP.NET Core MVC应用程序的情况下，整个网站在包含填充了测试数据的所有必要存储的完整环境中运行。输入不是提供给HTML页面，而是直接注入到ASP.NET
    Core控制器中。绕过用户界面的测试称为皮下测试。ASP.NET Core提供了各种工具来执行皮下测试，以及自动化与HTML页面交互的工具。
- en: 'Subcutaneous tests are usually preferred in the case of automated tests, while
    full tests are executed manually for the following reasons:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化测试的情况下，通常首选皮下测试，而全面测试是手动执行的原因如下：
- en: No automatic test can verify how the user interface appears and how usable it
    is.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有自动测试可以验证用户界面的外观和可用性。
- en: Automating the actual interaction with the user interface is a very time-consuming
    task.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化实际与用户界面的交互是一项非常耗时的任务。
- en: User interfaces are changed frequently to improve their usability and to add
    new features, and small changes in a single application screen may force a complete
    rewrite of all tests that operate on that screen.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面经常更改以改善其可用性并添加新功能，对单个应用程序屏幕的小改动可能会迫使对该屏幕上的所有测试进行完全重写。
- en: In a few words, user interface tests are very expansive and have low reusability,
    so it's rarely worth automating them. However, ASP.NET Core supplies the `Microsoft.AspNetCore.Mvc.Testing`
    NuGet package to run the whole website in a testing environment. Using it together
    with the `AngleSharp` NuGet package, which parses HTML pages into DOM trees, you
    can write automated full tests with an acceptable programming effort. The automated
    ASP.NET Core acceptance tests will be described in detail in *Chapter 22*, *Automation
    for Functional Tests*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，用户界面测试非常昂贵，可重用性低，因此很少值得自动化。但是，ASP.NET Core提供了`Microsoft.AspNetCore.Mvc.Testing`
    NuGet包，以在测试环境中运行整个网站。与`AngleSharp` NuGet包一起使用，可以编写具有可接受的编程工作的自动化全面测试。自动化的ASP.NET
    Core验收测试将在*第22章* *功能测试自动化*中详细描述。
- en: Performance tests apply a fake load to an application to see whether it is able
    to handle the typical production load, to discover its load limits, and to locate
    bottlenecks. The application is deployed in a staging environment that is a copy
    of the actual production environment in terms of hardware resources.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试对应用程序施加虚拟负载，以查看其是否能够处理典型的生产负载，发现其负载限制，并定位瓶颈。该应用程序部署在一个与硬件资源相同的实际生产环境的分期环境中。
- en: Then, fake requests are created and applied to the system, and response times
    and other metrics are collected. Fake request batches should have the same composition
    as the actual production batches. They can be generated from the actual production
    request logs if they are available.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，虚拟请求被创建并应用于系统，并收集响应时间和其他指标。虚拟请求批次应该与实际生产批次具有相同的组成。如果可用，它们可以从实际生产请求日志中生成。
- en: If response times are not satisfactory, other metrics are collected to discover
    possible bottlenecks (low memory, slow storage, or slow software modules). Once
    located, a software component that is responsible for the problem can be analyzed
    in the debugger to measure the execution time of the various method calls involved
    in a typical request.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应时间不令人满意，将收集其他指标以发现可能的瓶颈（低内存、慢存储或慢软件模块）。一旦找到，就可以在调试器中分析负责问题的软件组件，以测量典型请求中涉及的各种方法调用的执行时间。
- en: Failures in the performance tests may lead either to a redefinition of the hardware
    needed by the application or to the optimization of some software modules, classes,
    or methods.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试中的失败可能导致重新定义应用程序所需的硬件，或者优化一些软件模块、类或方法。
- en: Both Azure and Visual Studio offer tools to create fake loads and to report
    execution metrics. However, they have been declared obsolete and will be discontinued,
    and so we will not describe them. As an alternative, there are both open source
    and third-party tools that can be used. Some of them are listed in the *Further
    reading* section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Azure和Visual Studio都提供了创建虚拟负载和报告执行指标的工具。但是，它们已被宣布过时，并将被停用，因此我们不会对其进行描述。作为替代方案，有开源和第三方工具可供使用。其中一些列在*进一步阅读*部分。
- en: The next section describes a software development methodology that gives a central
    role to tests.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节描述了一种给测试赋予中心作用的软件开发方法论。
- en: Understanding test-driven development (TDD)
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试驱动开发（TDD）
- en: '**Test-driven development** (**TDD**) is a software development methodology
    that gives a central role to unit tests. According to this methodology, unit tests
    are a formalization of the specifications of each class, so they must be written
    before the code of the class. Actually, a full test that covers all code paths
    univocally defines the code behavior, so it can be considered a specification
    for the code. It is not a formal specification that defines the code behavior
    through some formal language, but a specification based on examples of behavior.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是一种软件开发方法论，它赋予单元测试中心作用。根据这种方法论，单元测试是对每个类的规范的正式化，因此必须在编写类的代码之前编写。实际上，覆盖所有代码路径的完整测试唯一地定义了代码行为，因此可以被视为代码的规范。它不是通过某种正式语言定义代码行为的正式规范，而是基于行为示例的规范。'
- en: The ideal way to test software would be to write formal specifications of the
    whole software behavior and to verify with some wholly automatic tools whether
    the software that was actually produced conforms to them. In the past, some research
    effort was spent defining formal languages for describing code specifications,
    but expressing the behavior the developer has in mind with similar languages was
    a very difficult and error-prone task. Therefore, these attempts were quickly
    abandoned in favor of approaches based on examples. At that time, the main purpose
    was the automatic generation of code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 测试软件的理想方式是编写整个软件行为的正式规范，并使用一些完全自动化的工具验证实际生成的软件是否符合这些规范。过去，一些研究工作花费在定义描述代码规范的正式语言上，但用类似语言表达开发人员心中的行为是一项非常困难且容易出错的任务。因此，这些尝试很快被放弃，转而采用基于示例的方法。当时，主要目的是自动生成代码。
- en: Nowadays, automatic code generation has been substantially abandoned and survives
    in small application areas, such as the creation of device drivers. In these areas,
    the effort of formalizing the behavior in a formal language is worth the time
    saved in trying to test difficult-to-reproduce behaviors of parallel threads.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，自动生成代码已经大幅被放弃，并在小型应用领域中得以存留，例如创建设备驱动程序。在这些领域，将行为形式化为正式语言的工作量值得花费时间，因为这样做可以节省测试难以重现的并行线程行为的时间。
- en: Unit tests were initially conceived as a way to encode example-based specifications
    in a completely independent way, as part of a specific agile development methodology
    called **Extreme Programming**. However, nowadays, TDD is used independently of
    Extreme Programming and is included as an obligatory prescription in other agile
    methodologies.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试最初被构想为一种完全独立的编码示例规范的方式，作为一种名为**极限编程**的特定敏捷开发方法的一部分。然而，如今，TDD独立于极限编程使用，并作为其他敏捷方法的强制规定。
- en: While it is undoubtedly true that unit tests refined after finding hundreds
    of bugs act as reliable code specifications, it is not obvious that developers
    can easily design unit tests that can be immediately used as reliable specifications
    for the code to be written. In fact, generally, you need an infinite or at least
    an immense number of examples to univocally define a code's behavior if examples
    are chosen at random.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管毫无疑问，经过发现数百个错误后细化的单元测试可以作为可靠的代码规范，但开发人员很难设计可以立即用作代码可靠规范的单元测试。事实上，通常情况下，如果随机选择示例，你需要无限或至少大量的示例来明确定义代码的行为。
- en: 'The behavior can be defined with an acceptable number of examples only after
    you have understood all possible execution paths. In fact, at this point, it is
    enough to select a typical example for each execution path. Therefore, writing
    a unit test for a method after that method has been completely coded is easy:
    it simply requires selecting a typical instance for each execution path of the
    already existing code. However, writing unit tests this way does not protect from
    errors in the design of the execution paths themselves. Arguably, writing the
    tests beforehand doesn''t prevent someone from forgetting to test a value, or
    combination of values – no one is perfect! It does, however, force you to think
    about them explicitly prior to implementation, which is why you''re less likely
    to accidentally omit a test case.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在理解了所有可能的执行路径之后，才能用可接受的数量的示例来定义行为。事实上，在这一点上，只需为每个执行路径选择一个典型示例即可。因此，在完全编写了方法之后为该方法编写单元测试很容易：只需为已存在的代码的每个执行路径选择一个典型实例。然而，以这种方式编写单元测试并不能防止执行路径设计中的错误。可以说，事先编写测试并不能防止某人忘记测试一个值或值的组合-没有人是完美的！然而，它确实迫使您在实施之前明确考虑它们，这就是为什么您不太可能意外地忽略测试用例。
- en: We may conclude that, while writing unit tests, the developer must somehow forecast
    all execution paths by looking for extreme cases and by possibly adding more examples
    than strictly needed. However, the developer can make mistakes while writing the
    application code, and he or she can also make mistakes in forecasting all possible
    execution paths while designing the unit tests.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，编写单元测试时，开发人员必须以某种方式预测所有执行路径，寻找极端情况，并可能添加比严格需要的更多的示例。然而，开发人员在编写应用程序代码时可能会犯错误，而在设计单元测试时也可能会犯错误，无法预测所有可能的执行路径。
- en: 'We have identified the main drawback of TDD: unit tests themselves may be wrong.
    That is, not only application code, but also its associated TDD unit tests, may
    be incoherent with the behavior the developer has in mind. Therefore, in the beginning,
    unit tests can''t be considered software specifications, but rather a possibly
    wrong and incomplete description of the software behavior. Therefore, we have
    two descriptions of the behavior we have in mind: the application code itself
    and its TDD unit tests that were written before the application code.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了TDD的主要缺点：单元测试本身可能是错误的。也就是说，不仅应用程序代码，而且其相关的TDD单元测试可能与开发人员心中的行为不一致。因此，在开始阶段，单元测试不能被视为软件规范，而是软件行为可能错误和不完整的描述。因此，我们对心中的行为有两种描述：应用程序代码本身以及在应用程序代码之前编写的TDD单元测试。
- en: What makes TDD work is that the probability of making exactly the same error
    while writing the tests and while writing the code is very low. Therefore, whenever
    a test fails, there is an error either in the tests or in the application code,
    and, conversely, if there is an error either in the application code or in the
    test, there is a very high probability that a test will fail. That is, the usage
    of TDD ensures that most of the bugs are immediately found!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: TDD起作用的原因在于在编写测试和编写代码时犯同样错误的概率非常低。因此，每当测试失败时，测试或应用程序代码中都存在错误，反之亦然，如果应用程序代码或测试中存在错误，测试将失败的概率非常高。也就是说，使用TDD可以确保大多数错误立即被发现！
- en: 'Writing a class method or a chunk of code with TDD is a loop composed of three
    stages:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD编写类方法或一段代码是由三个阶段组成的循环：
- en: '**Red stage**: In this stage, the developer writes empty methods that either
    throw `NotImplementedException` or have empty bodies and designs new unit tests
    for them that must necessarily fail because, at this time, there is no code that
    implements the behavior they describe.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色阶段：在这个阶段，开发人员编写空方法，要么抛出`NotImplementedException`，要么有空的方法体，并为它们设计新的单元测试，这些测试必须失败，因为此时还没有实现它们描述的行为的代码。
- en: '**Green stage**: In this stage, the developer writes the minimum code or makes
    the minimum modifications to existing code that are necessary to pass all unit
    tests.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色阶段：在这个阶段，开发人员编写最少的代码或对现有代码进行最少的修改，以通过所有单元测试。
- en: '**Refactoring stage**: Once the test is passed, code is refactored to ensure
    good code quality and the application of best practices and patterns. In particular,
    in this stage, some code can be factored out in other methods or in other classes.
    During this stage, we may also discover the need for other unit tests because
    new execution paths or new extreme cases are discovered or created.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构阶段**：一旦测试通过，代码将被重构以确保良好的代码质量和最佳实践和模式的应用。特别是在这个阶段，一些代码可以被提取到其他方法或其他类中。在这个阶段，我们可能还会发现需要其他单元测试，因为发现或创建了新的执行路径或新的极端情况。'
- en: The loop stops as soon as all tests pass without writing new code or modifying
    the existing code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有测试通过而没有编写新代码或修改现有代码，循环就会停止。
- en: Sometimes, it is very difficult to design the initial unit tests because it
    is quite difficult to imagine how the code might work and the execution paths
    it might take. In this case, you can get a better understanding of the specific
    algorithm to use by writing an initial sketch of the application code. In this
    initial stage, we need to focus just on the main execution path, completely ignoring
    extreme cases and input verifications. Once we get a clear picture of the main
    ideas behind an algorithm that should work, we can enter the standard three-stage
    TDD loop.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，设计初始单元测试非常困难，因为很难想象代码可能如何工作以及可能采取的执行路径。在这种情况下，您可以通过编写应用程序代码的初始草图来更好地理解要使用的特定算法。在这个初始阶段，我们只需要专注于主要的执行路径，完全忽略极端情况和输入验证。一旦我们清楚了应该工作的算法背后的主要思想，我们就可以进入标准的三阶段TDD循环。
- en: In the next section, we will list all test projects available in Visual Studio
    and describe xUnit in detail.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将列出Visual Studio中提供的所有测试项目，并详细描述xUnit。
- en: Defining C# test projects
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义C#测试项目
- en: Visual Studio contains project templates for three types of unit testing frameworks,
    namely, MSTest, xUnit, and NUnit. Once you start the new project wizard, in order
    to visualize the version of all of them that is adequate for .NET Core C# applications,
    set **Project type** as **Test**, **Language** as **C#**, and **Platform** as
    **Linux**, since .NET Core projects are the only ones that can be deployed on
    Linux.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio包含三种类型的单元测试框架的项目模板，即MSTest、xUnit和NUnit。一旦启动新项目向导，为了可视化它们中的适用于.NET
    Core C#应用程序的版本，将**项目类型**设置为**测试**，**语言**设置为**C#**，**平台**设置为**Linux**，因为.NET Core项目是唯一可以部署在Linux上的项目。
- en: 'The following screenshot shows the selection that should appear:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了应该出现的选择：
- en: '![](img/B16756_18_01.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_18_01.png)'
- en: 'Figure 18.1: Adding a test project'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1：添加测试项目
- en: All the preceding projects automatically include the NuGet package for running
    all the tests in the Visual Studio test user interface (Visual Studio test runner).
    However, they do not include any facility for mocking interfaces, so you need
    to add the `Moq` NuGet package, which contains a popular mocking framework.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述项目都自动包含用于在Visual Studio测试用户界面（Visual Studio测试运行器）中运行所有测试的NuGet包。但它们不包含任何用于模拟接口的设施，因此您需要添加`Moq`NuGet包，其中包含一个流行的模拟框架。
- en: All test projects must contain a reference to the project to be tested.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试项目必须包含对要测试的项目的引用。
- en: In the next section, we will describe xUnit, since it is probably the most popular
    of the three frameworks. However, all three frameworks are quite similar and differ
    mainly in the names of the assert methods and in the names of the attributes used
    to decorate various testing classes and methods.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将描述xUnit，因为它可能是这三个框架中最受欢迎的。然而，这三个框架都非常相似，主要区别在于用于装饰各种测试类和方法的属性的名称以及断言方法的名称。
- en: Using the xUnit test framework
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用xUnit测试框架
- en: In xUnit, tests are methods decorated with either the `[Fact]` or `[Theory]`
    attributes. Tests are automatically discovered by the test runner that lists all
    of them in the user interface so the user can run either all of them or just a
    selection of them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在xUnit中，测试是用`[Fact]`或`[Theory]`属性装饰的方法。测试会被测试运行器自动发现，并在用户界面中列出所有测试，因此用户可以运行所有测试或只运行其中的一部分。
- en: A new instance of the test class is created before running each test, so the
    *test preparation* code contained in the class constructor is executed before
    each test of the class. If you also require *tear-down* code, the test class must
    implement the `IDisposable` interface so that the tear-down code can be included
    in the `IDisposable.Dispose` method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行每个测试之前，会创建测试类的一个新实例，因此在类构造函数中包含的*测试准备*代码会在类的每个测试之前执行。如果您还需要*拆卸*代码，测试类必须实现`IDisposable`接口，以便将拆卸代码包含在`IDisposable.Dispose`方法中。
- en: 'The test code invokes the methods to be tested and then tests the results with
    methods from the `Assert` static class, such as `Assert.NotNull(x)`, `Assert.Equal(x,
    y)`, and `Assert.NotEmpty(IEnumerable x)`. There are also methods that verify
    whether a call throws an exception of a specific type, for instance:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码调用要测试的方法，然后使用`Assert`静态类的方法测试结果，例如`Assert.NotNull(x)`、`Assert.Equal(x, y)`和`Assert.NotEmpty(IEnumerable
    x)`。还有一些方法可以验证调用是否引发了特定类型的异常，例如：
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When an assertion fails, an exception is thrown. A test fails if a not-intercepted
    exception is thrown either by the test code or by an assertion.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当断言失败时，会抛出异常。如果测试代码或断言抛出未拦截的异常，则测试失败。
- en: 'The following is an example of a method that defines a single test:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是定义单个测试的方法示例：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `[Fact]` attribute is used when a method defines just one test, while the
    `[Theory]` attribute is used when the same method defines several tests, each
    on a different tuple of data. Tuples of data can be specified in several ways
    and are injected in the test as method parameters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法只定义一个测试时，使用 `[Fact]` 属性，而当同一个方法定义多个测试时，每个测试都在不同的数据元组上使用时，使用 `[Theory]`
    属性。数据元组可以以多种方式指定，并作为方法参数注入到测试中。
- en: 'The previous code can be modified to test `MethodToTest` on several inputs,
    as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可以修改上述代码以在多个输入上测试 `MethodToTest`，如下所示：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Each `InlineData` attribute specifies a tuple to be injected in the method
    parameters. Since just simple constant data can be included as attribute arguments,
    xUnit also gives you the possibility to take all data tuples from a class that
    implements `IEnumerable`, as shown in the following example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `InlineData` 属性指定要注入到方法参数中的元组。由于属性参数只能包含简单的常量数据，xUnit 还允许您从实现 `IEnumerable`
    的类中获取所有数据元组，如下例所示：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The type of the class that provides the test data is specified with the `ClassData`
    attribute.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 提供测试数据的类的类型由 `ClassData` 属性指定。
- en: 'It is also possible to take data from a static method of a class that returns
    an `IEnumerable` with the `MemberData` attribute, as shown in the following example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用 `MemberData` 属性从返回 `IEnumerable` 的类的静态方法中获取数据，如下例所示：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `MemberData` attribute is passed the method name as the first parameter,
    and the class type in the `MemberType` named parameter. If the static method is
    part of the same test class, the `MemberType` parameter can be omitted.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`MemberData` 属性将方法名作为第一个参数传递，并在 `MemberType` 命名参数中指定类类型。如果静态方法是同一个测试类的一部分，则可以省略
    `MemberType` 参数。'
- en: The next section shows how to deal with some advanced preparation and tear-down
    scenarios.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将展示如何处理一些高级的准备和清理场景。
- en: Advanced test preparation and tear-down scenarios
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级测试准备和清理场景
- en: Sometimes, the preparation code contains very time-consuming operations, such
    as opening a connection with a database, that don't need to be repeated before
    each test, but that can be executed once before all the tests contained in the
    same class. In xUnit, this kind of test preparation code can't be included in
    the test class constructor; since a different instance of the test class is created
    before every single test, it must be factored out in a separate class called a
    fixture class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，准备代码包含非常耗时的操作，例如打开与数据库的连接，这些操作不需要在每个测试之前重复执行，但可以在同一个类中的所有测试之前执行一次。在 xUnit
    中，这种类型的测试准备代码不能包含在测试类构造函数中；因为在每个单独的测试之前都会创建测试类的不同实例，所以必须将其分解到一个称为 fixture 类的单独类中。
- en: If we also need a corresponding tear-down code, the fixture class must implement
    `IDisposable`. In other test frameworks, such as NUnit, the test class instances
    are created just once instead, so they don't need the fixture code to be factored
    out in other classes. However, test frameworks, such as NUnit, that do not create
    a new instance before each test may suffer from bugs because of unwanted interactions
    between test methods.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还需要相应的清理代码，fixture 类必须实现 `IDisposable`。在其他测试框架（如 NUnit）中，测试类实例只会创建一次，因此不需要将
    fixture 代码分解到其他类中。然而，不会在每个测试之前创建新实例的测试框架（如 NUnit）可能会因为测试方法之间的不必要交互而出现 bug。
- en: 'The following is an example of an xUnit fixture class that opens and closes
    a database connection:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个打开和关闭数据库连接的 xUnit fixture 类示例：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since a fixture class instance is created just once before all tests associated
    with the fixture are executed and the same instance is disposed of immediately
    after the tests, then the database connection is created just once when the fixture
    class is created and is disposed of immediately after the tests when the fixture
    object is disposed of.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 fixture 类的实例在执行与 fixture 相关的所有测试之前只创建一次，并且在测试后立即被销毁，因此当 fixture 类被创建时数据库连接也只会创建一次，并且在
    fixture 对象被销毁后立即被销毁。
- en: 'The fixture class is associated with each test class by letting the test class
    implement the empty `IClassFixture<T>` interface, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过让测试类实现空的 `IClassFixture<T>` 接口，fixture 类与每个测试类相关联，如下所示：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A fixture class instance is automatically injected in the test class constructor
    in order to make all data computed in the fixture test preparation available for
    the tests. This way, for instance, in our previous example, we can get the database
    connection instance so that all test methods of the class can use it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 fixture 测试准备中计算的所有数据对测试可用，fixture 类的实例会自动注入到测试类的构造函数中。例如，在我们之前的例子中，我们可以获取数据库连接实例，以便类的所有测试方法都可以使用它。
- en: 'If we want to execute some test preparation code on all tests contained in
    a collection of test classes instead of a single test class, we must associate
    the fixture class with an empty class that represents the collection of test classes,
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在测试类的集合中执行一些测试准备代码，而不是单个测试类，我们必须将 fixture 类与表示测试类集合的空类关联起来，如下所示：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `CollectionDefinition` attribute declares the name of the collection, and
    the `IClassFixture<T>` interface has been replaced with `ICollectionFixture<T>`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionDefinition` 属性声明了集合的名称，`IClassFixture<T>` 接口已被 `ICollectionFixture<T>`
    取代。'
- en: 'Then we declare that a test class belongs to the previously defined collection
    by applying it to the `Collection` attribute with the name of the collection,
    as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过将 `Collection` 属性应用到测试类，声明测试类属于先前定义的集合，如下所示：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Collection` attribute declares which collection to use, while the `DataBaseFixture`
    argument in the test class constructor provides an actual fixture class instance,
    so it can be used in all class tests.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection` 属性声明要使用的集合，而测试类构造函数中的 `DataBaseFixture` 参数提供了一个实际的 fixture 类实例，因此它可以在所有类测试中使用。'
- en: The next section shows how to mock interfaces with the `Moq` framework.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将展示如何使用`Moq`框架模拟接口。
- en: Mocking interfaces with Moq
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Moq模拟接口
- en: Mocking capabilities are not included in any of the test frameworks we listed
    in this section as they are not included in xUnit. Therefore, they must be provided
    by installing a specific NuGet package. The `Moq` framework available in the `Moq`
    NuGet package is the most popular mock framework available for .NET. It is quite
    easy to use and will be briefly described in this section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟能力不包括在我们在本节中列出的任何测试框架中，因为它们不包括在xUnit中。因此，它们必须通过安装特定的NuGet包来提供。`Moq`框架可在`Moq`
    NuGet包中获得，是.NET中最流行的模拟框架。它非常容易使用，并将在本节中简要描述。
- en: 'Once we''ve installed the NuGet package, we need to add a `using Moq` statement
    in our test files. A mock implementation is easily defined, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了NuGet包，我们需要在测试文件中添加`using Moq`语句。模拟实现很容易定义，如下所示：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The behavior of the mock dependency on specific inputs of the specific method
    can be defined with the `Setup/Return` method pair as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Setup/Return`方法对特定输入的特定方法的模拟依赖行为进行定义，如下所示：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can add several `Setup/Return` instructions for the same method. This way,
    we can specify an indefinite number of input/output behaviors.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为同一个方法添加多个`Setup/Return`指令。这样，我们可以指定无限数量的输入/输出行为。
- en: 'Instead of specific input values, we may also use wildcards that match a specific
    type as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用通配符来匹配特定类型，而不是特定的输入值，如下所示：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once we have configured the mock dependency, we may extract the mocked instance
    from its `Object` property and use it as if it were an actual implementation,
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了模拟依赖之后，我们可以从其`Object`属性中提取模拟的实例，并将其用作实际实现，如下所示：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, mocked methods are usually called by the code under test, so we just
    need to extract the mocked instance and use it as an input in our tests.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，模拟的方法通常由测试中的代码调用，所以我们只需要提取模拟的实例并在测试中使用它作为输入。
- en: 'We may also mock properties and async methods as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以模拟属性和异步方法，如下所示：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With async methods, `Returns` must be replaced by `ReturnsAsync`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步方法，`Returns`必须替换为`ReturnsAsync`。
- en: 'Each mocked instance records all calls to its methods and properties, so we
    may use this information in our tests. The following code shows an example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模拟的实例都记录其方法和属性的所有调用，因此我们可以在测试中使用这些信息。以下代码显示了一个例子：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding statement asserts that `MyMethod` has been invoked with the given
    arguments at least twice. There are also `Times.Never`, and `Times.Once` (which
    asserts that the method was called just once), and more.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句断言`MyMethod`至少被给定参数调用了两次。还有`Times.Never`和`Times.Once`（断言方法只被调用了一次），以及更多。
- en: The Moq documentation summarized up to now should cover 99% of the needs that
    may arise in your tests, but Moq also offers more complex options. The *Further
    reading* section contains the link to the complete documentation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Moq文档总结应该涵盖了你在测试中可能遇到的99%的需求，但Moq还提供了更复杂的选项。*进一步阅读*部分包含了完整文档的链接。
- en: The next section shows how to define unit tests in practice and how to run them
    both in Visual Studio and in Azure DevOps with the help of the book use case.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将展示如何实践定义单元测试以及如何在Visual Studio和Azure DevOps中运行它们，以书中用例的帮助。
- en: Use case – Automating unit tests in DevOps Azure
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 在DevOps Azure中自动化单元测试
- en: In this section, we add some unit test projects to the example application we
    built in *Chapter 15*, *Presenting ASP.NET Core MVC*. If you don't have it, you
    can download it from the *Chapter 15*, *Presenting ASP.NET Core MVC*, section
    of the GitHub repository associated with the book.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向我们在*第15章* *介绍ASP.NET Core MVC*中构建的示例应用程序添加一些单元测试项目。如果你没有它，你可以从与本书相关的GitHub存储库的*第15章*
    *介绍ASP.NET Core MVC*部分下载它。
- en: As a first step, let's make a new copy of the solution folder and name it `PackagesManagementWithTests`.
    Then, open the solution and add it to an xUnit .NET Core C# test project named
    `PackagesManagementTest`. Finally, add a reference to the ASP.NET Core project
    (`PackagesManagement`), since we will test it, and a reference to the latest version
    of the `Moq` NuGet package, since we require mocking capabilities. At this point,
    we are ready to write our tests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们复制解决方案文件夹并将其命名为`PackagesManagementWithTests`。然后，打开解决方案并将其添加到一个名为`PackagesManagementTest`的xUnit
    .NET Core C#测试项目中。最后，添加对ASP.NET Core项目（`PackagesManagement`）的引用，因为我们将对其进行测试，并添加对`Moq`
    NuGet包的最新版本的引用，因为我们需要模拟能力。在这一点上，我们已经准备好编写我们的测试了。
- en: 'As an example, we will write unit tests for the `Edit` method decorated with
    `[HttpPost]` of the `ManagePackagesController` controller, which is shown as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将为`ManagePackagesController`控制器的带有`[HttpPost]`装饰的`Edit`方法编写单元测试，如下所示：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Before writing our test methods, let's rename the test class that was automatically
    included in the test project as `ManagePackagesControllerTests`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的测试方法之前，让我们将自动包含在测试项目中的测试类重命名为`ManagePackagesControllerTests`。
- en: 'The first test verifies that in case there are errors in `ModelState`, the
    action method renders a view with the same model it received as an argument so
    that the user can correct all errors. Let''s delete the existing test method and
    write an empty `DeletePostValidationFailedTest` method, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试验证了如果`ModelState`中存在错误，那么操作方法将使用相同的模型呈现一个视图，以便用户可以纠正所有错误。让我们删除现有的测试方法，并编写一个空的`DeletePostValidationFailedTest`方法，如下所示：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The method must be `async` and the return type must be `Task` since the `Edit`
    method that we have to test is `async`. In this test, we don''t need mocked objects
    since no injected object will be used. Thus, as a preparation for the test, we
    just need to create a controller instance, and we must add an error to `ModelState`
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们要测试的`Edit`方法是`async`的，方法必须是`async`，返回类型必须是`Task`。在这个测试中，我们不需要模拟对象，因为不会使用任何注入的对象。因此，作为测试的准备，我们只需要创建一个控制器实例，并且必须向`ModelState`添加一个错误，如下所示：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then we invoke the method, injecting `ViewModel` and a `null` command handler
    as its arguments, since the command handler will not be used:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用该方法，注入`ViewModel`和一个`null`命令处理程序作为它的参数，因为命令处理程序将不会被使用：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the verification stage, we verify that the result is `ViewResult` and that
    it contains the same model that was injected in the controller:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证阶段，我们验证结果是`ViewResult`，并且它包含在控制器中注入的相同模型：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we also need a test to verify that in case there are no errors, the command
    handler is called, and then the browser is redirected to the `Index` controller
    action method. We call the `DeletePostSuccessTest` method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要一个测试来验证，如果没有错误，命令处理程序被调用，然后浏览器被重定向到`Index`控制器的操作方法。我们调用`DeletePostSuccessTest`方法：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This time the preparation code must include the preparation of a command handler
    mock, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这次准备代码必须包括命令处理程序模拟的准备工作，如下所示：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since the handler `HandleAsync` method returns no `async` value, we can''t
    use `ReturnsAsync`, but we have to return just a completed `Task` (`Task.Complete`)
    with the `Returns` method. The method to test is called with both `ViewModel`
    and the mocked handler:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理程序`HandleAsync`方法没有返回`async`值，我们不能使用`ReturnsAsync`，而是必须使用`Returns`方法返回一个完成的`Task`(`Task.Complete`)。要测试的方法被调用时，传入了`ViewModel`和模拟的处理程序：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this case, the verification code is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，验证代码如下：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As the first step, we verify that the command handler has actually been invoked
    once. A better verification should also include a check that it was invoked with
    a command that includes `ViewModel` passed to the action method. We will take
    it up as an exercise.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们验证命令处理程序是否实际被调用了一次。更好的验证还应包括检查它是否被调用，并且传递给操作方法的命令包括`ViewModel`。我们将把它作为一个练习来进行。
- en: Then we verify that the action method returns `RedirectToActionResult` with
    the right action method name and with no controller name specified.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们验证操作方法返回`RedirectToActionResult`，并且具有正确的操作方法名称，没有指定控制器名称。
- en: Once all the tests are ready, if the test window does not appear on the left
    bar of Visual Studio, we may simply select the **Run all tests** item from the
    Visual Studio **Test** menu. Once the test window appears, further invocations
    can be launched from within this window.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有测试准备就绪，如果测试窗口没有出现在Visual Studio的左侧栏中，我们可以简单地从Visual Studio的**测试**菜单中选择**运行所有测试**项目。一旦测试窗口出现，进一步的调用可以从这个窗口内启动。
- en: If a test fails, we can add a breakpoint to its code, so we can launch a debug
    session on it by right-clicking on it in the test window and then selecting **Debug
    selected tests**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试失败，我们可以在其代码中添加断点，这样我们就可以通过在测试窗口中右键单击它，然后选择**调试选定的测试**来启动调试会话。
- en: Connecting to an Azure DevOps repository
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到Azure DevOps存储库
- en: Tests play a fundamental role in the application CI/CD cycle, and specifically
    in continuous integration. They must be executed at least each time the master
    branch of the application repository is modified in order to verify that changes
    don't introduce bugs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在应用程序的CI/CD周期中发挥着基础作用，特别是在持续集成中。它们必须至少在每次应用程序存储库的主分支被修改时执行，以验证更改不会引入错误。
- en: 'The following steps show how to connect our solution to an Azure DevOps repository,
    and we will define an Azure DevOps pipeline that builds the project and launches
    its tests. In this way, every day after all developers have pushed their changes,
    we can launch the pipeline to verify that the repository code compiles and passes
    all the tests:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤显示了如何将我们的解决方案连接到Azure DevOps存储库，并且我们将定义一个Azure DevOps流水线来构建项目并启动其测试。这样，每天在所有开发人员推送他们的更改之后，我们可以启动流水线来验证存储库代码是否编译并通过了所有测试：
- en: 'As a first step, we need a free DevOps subscription. If you don''t already
    have one, please create one by clicking the **Start free** button on this page:
    [https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/).
    Here, let''s define an organization but stop before creating a project, since
    we will create the project from within Visual Studio.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，我们需要一个免费的DevOps订阅。如果你还没有，请点击此页面上的**开始免费**按钮创建一个：[https://azure.microsoft.com/en-us/services/devops/](https://azure.microsoft.com/en-us/services/devops/)。在这里，让我们定义一个组织，但在创建项目之前停下来，因为我们将从Visual
    Studio内部创建项目。
- en: Ensure you are logged in to Visual Studio with your Azure account (the same
    used in the creation of the DevOps account). At this point, you may create a DevOps
    repository for your solution by right-clicking on the solution and by selecting
    **Configure continuous delivery to Azure...**. In the window that appears, an
    error message will inform you that you have no repository configured for your
    code:![](img/B16756_18_02.png)
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经用Azure账户登录到Visual Studio（与创建DevOps账户时使用的相同）。在这一点上，你可以通过右键单击解决方案并选择**配置到Azure的持续交付...**来为你的解决方案创建一个DevOps存储库。在出现的窗口中，一个错误消息会告诉你你的代码没有配置存储库：![](img/B16756_18_02.png)
- en: 'Figure 18.2: No repository error message'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.2：没有存储库错误消息
- en: Click the **Add to source control now** link. After that, the DevOps screen
    will appear in the Visual Studio **Team Explorer** tab:![](img/B16756_18_03.png)
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**立即添加到源代码控制**链接。之后，DevOps屏幕将出现在Visual Studio的**Team Explorer**选项卡中：![](img/B16756_18_03.png)
- en: 'Figure 18.3: Publish repository to DevOps panel'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.3：发布存储库到DevOps面板
- en: As shown in *Chapter 3*, *Documenting Requirements with Azure DevOps*, Team
    Explorer is being replaced by Git Changes, but if this automatic wizard takes
    you to Team Explorer, use it to create your repository. Then you can use the Git
    Changes window.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如*第3章*所示，*使用Azure DevOps记录需求*，Team Explorer正在被Git Changes取代，但如果这个自动向导带你到Team
    Explorer，就用它来创建你的存储库。然后你可以使用Git Changes窗口。
- en: Once you click the **Publish Git Repo** button, you will be prompted to select
    your DevOps organization and a name for the repository. After you successfully
    publish your code to a DevOps repository, the DevOps screen should change as follows:![](img/B16756_18_04.png)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“发布Git存储库”按钮后，将提示您选择DevOps组织和存储库的名称。成功将代码发布到DevOps存储库后，DevOps屏幕应该会发生以下变化：![](img/B16756_18_04.png)
- en: 'Figure 18.4: DevOps button after publication'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4：发布后的DevOps按钮
- en: The DevOps screen shows a link to your online DevOps project. In future, when
    you open your solution, if the link does not appear, please click the DevOps screen
    **Connect** button or the **Manage connections** link (whichever appears) to select
    and connect your project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps屏幕显示了您在线DevOps项目的链接。将来，当您打开解决方案时，如果链接没有出现，请单击DevOps屏幕的“连接”按钮或“管理连接”链接（以后出现的那个）来选择并连接您的项目。
- en: Click this link to go to the online project. Once there, if you click the **Repos**
    item, on the left-hand menu, you will see the repository you just published.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击此链接转到在线项目。一旦进入那里，如果单击左侧菜单上的“存储库”项目，您将看到刚刚发布的存储库。
- en: Now, click the **Pipelines** menu item to create a DevOps pipeline to build
    and test your project. In the window that appears, click the button to create
    a new pipeline:![](img/B16756_18_05.png)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，单击“管道”菜单项来创建一个用于构建和测试项目的DevOps管道。在出现的窗口中，单击按钮创建新的管道：![](img/B16756_18_05.png)
- en: 'Figure 18.5: Pipeline page'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.5：管道页面
- en: You will be prompted to select where your repository is located:![](img/B16756_18_06.png)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被提示选择存储库的位置：![](img/B16756_18_06.png)
- en: 'Figure 18.6: Repository selection'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.6：存储库选择
- en: Select **Azure Repos Git** and then your repository. Then you will be prompted
    about the nature of the project:![](img/B16756_18_07.png)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“Azure Repos Git”，然后选择您的存储库。然后会提示您关于项目性质的信息：![](img/B16756_18_07.png)
- en: 'Figure 18.7: Pipeline configuration'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.7：管道配置
- en: Select **ASP.NET Core**. A pipeline for building and testing your project will
    be automatically created for you. Save it by committing the newly created `.yaml`
    file to your repository:![](img/B16756_18_08.png)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“ASP.NET Core”。将为您自动创建一个用于构建和测试项目的管道。通过将新创建的“.yaml”文件提交到存储库来保存它：![](img/B16756_18_08.png)
- en: 'Figure 18.8: Pipeline properties'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.8：管道属性
- en: The pipeline can be run by selecting the **Queue** button, but since the standard
    pipeline scaffolded by DevOps has a trigger on the master branch of the repository,
    it is automatically launched each time changes to this branch are committed and
    each time the pipeline is modified. The pipeline can be modified by clicking the
    **Edit** button:![](img/B16756_18_09.png)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过选择“排队”按钮来运行管道，但由于DevOps标准管道在存储库的主分支上有一个触发器，每次提交更改或修改管道时都会自动启动。可以通过单击“编辑”按钮来修改管道：![](img/B16756_18_09.png)
- en: 'Figure 18.9: Pipeline code'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.9：管道代码
- en: 'Once in edit mode, all pipeline steps can be edited by clicking the **Settings**
    link that appears above each of them. New pipeline steps can be added as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入编辑模式，所有管道步骤都可以通过单击每个步骤上方出现的“设置”链接进行编辑。可以按以下方式添加新的管道步骤：
- en: Write `- task:` where the new step must be added and then accept one of the
    suggestions that appear while you are typing the task name.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新步骤必须添加的地方写“- 任务：”，然后在输入任务名称时接受出现的建议之一。
- en: Once you have written a valid task name, a **Settings** link appears above the
    new step. Click it.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦编写了有效的任务名称，新步骤上方将出现“设置”链接。单击它。
- en: Insert the desired task parameters in the window that appears and then save.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的窗口中插入所需的任务参数，然后保存。
- en: 'In order to have our test working, we need to specify the criteria to locate
    all assemblies that contain tests. In our case, since we have a unique `.dll`
    file containing the tests, it is enough to specify its name. Click the **Settings**
    link of the `VSTest@2` test task, and replace the content that is automatically
    suggested for the **Test files** field with the following:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的测试工作，我们需要指定定位包含测试的所有程序集的条件。在我们的情况下，由于我们有一个包含测试的唯一的“.dll”文件，只需指定其名称即可。单击“VSTest@2”测试任务的“设置”链接，并用以下内容替换自动建议的“测试文件”字段的内容：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then click **Add** to modify the actual pipeline content. As soon as you confirm
    your changes in the **Save and run** dialog, the pipeline is launched, and if
    there are no errors, test results are computed. The results of tests launched
    during a specific build can be analyzed by selecting the specific build in the
    pipeline **History** tab and by clicking the **Tests** tab on the page that appears.
    In our case, we should see something like the following screenshot:![](img/B16756_18_10.png)
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后单击“添加”以修改实际的管道内容。一旦在“保存并运行”对话框中确认了更改，管道就会启动，如果没有错误，测试结果就会被计算出来。可以通过在管道“历史”选项卡中选择特定构建，并单击出现的页面上的“测试”选项卡来分析特定构建期间启动的测试结果。在我们的情况下，应该看到类似以下截图的内容：![](img/B16756_18_10.png)
- en: 'Figure 18.10: Test results'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.10：测试结果
- en: If you click the **Analytics** tab of the pipeline page, you will see analytics
    relating to all builds, including analytics about the test results:![](img/B16756_18_11.png)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果单击管道页面的“分析”选项卡，您将看到与所有构建相关的分析，包括有关测试结果的分析：![](img/B16756_18_11.png)
- en: 'Figure 18.11: Build analytics'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.11：构建分析
- en: Clicking the test area of the **Analytics** page gets us a detailed report about
    all pipeline test results.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“分析”页面的测试区域会得到有关所有管道测试结果的详细报告。
- en: Summing up, we created a new Azure DevOps repository, published the solution
    to the new repository, and then created a build pipeline that executes our tests
    after each build. The build pipeline is executed as soon as we save it and will
    be executed each time someone commits to the master branch.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们创建了一个新的Azure DevOps存储库，将解决方案发布到新存储库，然后创建了一个构建管道，在每次构建后执行我们的测试。构建管道一旦保存就会执行，并且每当有人提交到主分支时都会执行。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explained why it is worth automating software tests, and
    then we focused on the importance of unit tests. We also listed all types of tests
    and their main features, focusing mainly on unit tests. We analyzed the advantages
    of TDD, and how to use it in practice. With this knowledge, you should be able
    to produce software that is both reliable and easy to modify.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了为什么值得自动化软件测试，然后我们专注于单元测试的重要性。我们还列出了所有类型的测试及其主要特点，主要关注单元测试。我们分析了TDD的优势，以及如何在实践中使用它。有了这些知识，您应该能够编写既可靠又易于修改的软件。
- en: Finally, we analyzed all test tools available for .NET Core projects, focusing
    on the description of xUnit and Moq, and showed how to use them in practice, both
    in Visual Studio and in Azure DevOps, with the help of the book's use case.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们分析了.NET Core项目可用的所有测试工具，重点介绍了xUnit和Moq的描述，并展示了如何在实践中使用它们，无论是在Visual Studio还是在Azure
    DevOps中，都是通过本书的用例。
- en: The next chapter looks at how to test and measure the quality of the code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论如何测试和衡量代码的质量。
- en: Questions
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is it worth automating unit tests?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么值得自动化单元测试？
- en: What is the main reason why TDD is able to discover most bugs immediately?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TDD能够立即发现大多数错误的主要原因是什么？
- en: What is the difference between the `[Theory]` and `[Fact]` attributes of xUnit?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[Theory]`和`[Fact]`属性在xUnit中有什么区别？'
- en: Which xUnit static class is used in test assertions?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试断言中使用了哪个xUnit静态类？
- en: Which methods allow the definition of the Moq mocked dependencies?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些方法允许定义Moq模拟的依赖项？
- en: Is it possible to mock async methods with Moq? If yes, how?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以使用Moq模拟异步方法？如果可以，如何？
- en: Further reading
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: While the documentation on xUnit included in this chapter is quite complete,
    it doesn't include the few configuration options offered by xUnit. The full xUnit
    documentation is available at [https://xunit.net/](https://xunit.net/). Documentation
    for MSTest and NUnit can be found at [https://github.com/microsoft/testfx](https://github.com/microsoft/testfx)
    and [https://github.com/nunit/docs/wiki/NUnit-Documentation](https://github.com/nunit/docs/wiki/NUnit-Documentation),
    respectively.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章中包含的xUnit文档非常完整，但它并未包括xUnit提供的少量配置选项。完整的xUnit文档可在[https://xunit.net/](https://xunit.net/)找到。MSTest和NUnit的文档分别可在[https://github.com/microsoft/testfx](https://github.com/microsoft/testfx)和[https://github.com/nunit/docs/wiki/NUnit-Documentation](https://github.com/nunit/docs/wiki/NUnit-Documentation)找到。
- en: Full Moq documentation is available at [https://github.com/moq/moq4/wiki/Quickstart](https://github.com/moq/moq4/wiki/Quickstart).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Moq的完整文档可在[https://github.com/moq/moq4/wiki/Quickstart](https://github.com/moq/moq4/wiki/Quickstart)找到。
- en: 'Here are some links to performance test frameworks for web applications:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些用于Web应用程序的性能测试框架的链接：
- en: '[https://jmeter.apache.org/](https://jmeter.apache.org/) (free and open source)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://jmeter.apache.org/](https://jmeter.apache.org/)（免费且开源）'
- en: '[https://www.neotys.com/neoload/overview](https://www.neotys.com/neoload/overview)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.neotys.com/neoload/overview](https://www.neotys.com/neoload/overview)'
- en: '[https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview](https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview](https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview)'
- en: '[https://www.microfocus.com/en-us/products/silk-performer/overview](https://www.microfocus.com/en-us/products/silk-performer/overview)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.microfocus.com/en-us/products/silk-performer/overview](https://www.microfocus.com/en-us/products/silk-performer/overview)'
