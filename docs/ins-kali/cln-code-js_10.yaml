- en: Operators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: In the previous chapter on *dynamic typing*, we explored topics such as type-coercion
    and detection; we also covered several operators. In this chapter, we'll continue
    this exploration by delving into every single operator that the JavaScript language
    makes available. Having a rich understanding of JavaScript's operators will make
    us feel utterly empowered in a language that can, at times, appear confusing.
    There is, unfortunately, no shortcut to understanding JavaScript, but as you begin
    to explore its operators, you will see patterns emerge. For example, many of the
    multiplicative operators work in a similar manner, as do the logical operators.
    Once you are comfortable with the main operators, you will begin to see that there
    is a grace underlying the complexity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章关于*动态类型*的章节中，我们探讨了类型强制转换和检测等主题；我们还涵盖了几个运算符。在本章中，我们将继续探讨JavaScript语言提供的每个运算符。对JavaScript运算符的深入理解将使我们在这种有时看起来令人困惑的语言中感到非常有力。遗憾的是，理解JavaScript没有捷径，但当您开始探索它的运算符时，您会看到模式出现。例如，许多乘法运算符的工作方式相似，逻辑运算符也是如此。一旦您熟悉了主要运算符，您将开始看到其中有一种优雅的复杂性。
- en: It may be useful to treat this chapter as more of a reference if you're pressed
    for time. Do not feel like you need to exhaustively retain every detail of every
    operator's behavior.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你时间紧迫，将这一章视为参考可能会有所帮助。不要觉得你需要详尽地记住每个运算符行为的每个细节。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is an operator?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是运算符？
- en: Arithmetic and numeric operators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术和数值运算符
- en: Logical operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Comparative operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Assignment operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: Property access operators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性访问运算符
- en: Other operators and syntax
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他运算符和语法
- en: Bitwise operators
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位运算符
- en: 'Now that we''re ready to dive in, the very first question we need to ask ourselves
    is: what even *is* an operator?'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好深入研究了，我们需要问自己的第一个问题是：什么是运算符？
- en: What is an operator?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是运算符？
- en: An operator in JavaScript is a standalone piece of syntax that forms an *expression*
    and is typically used to derive something or compute a logical or mathematical
    output from a set of inputs (called **operands**).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，运算符是一个独立的语法部分，形成一个*表达式*，通常用于从一组输入（称为**操作数**）中推导出某些东西或计算逻辑或数学输出。
- en: 'Here, we can see an expression containing an operator (`+`) with two operands
    (`3` and `5`):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个包含一个运算符（`+`）和两个操作数（`3`和`5`）的表达式：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Any operator can be said to have four characteristics:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何运算符都可以说有四个特征：
- en: '**Its arity**: how many operands the operator accepts'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它的arity**：运算符接受多少个操作数'
- en: '**Its function**: what the operator does with its operands and what it evaluates
    to'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它的功能**：运算符如何处理它的操作数以及它的计算结果'
- en: '**Its precedence**: how the operator will be grouped when used in combination
    with other operators'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它的优先级**：当与其他运算符组合使用时，运算符将如何分组'
- en: '**Its associativity**: how the operator will behave when neighbored with operators
    of the same precedence'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它的结合性**：当与相同优先级的运算符相邻时，运算符将如何行为'
- en: It's important to understand these foundational characteristics as it will vastly
    aid your usage of operators in JavaScript.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些基本特征非常重要，因为它将极大地帮助您在JavaScript中使用运算符。
- en: Operator arity
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符的arity
- en: Arity refers to how many operands (or inputs) an operator can receive. An *operand* is
    a formal term for the value(s) that you can give or pass to an operator.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Arity指的是一个运算符可以接收多少个操作数（或输入）。*操作数*是一个正式术语，用于指代您可以给予或传递给运算符的值。
- en: 'If we consider the greater-than operator (`>`), it receives two operands:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑大于运算符（`>`），它接收两个操作数：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, `a` is its first operand (or left-side operand). And `b` is
    its second (or right-side operand). Since it receives two operands, the greater-than
    operator is considered a binary operator. In JavaScript, we have unary, binary, and ternary operators:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`a`是它的第一个操作数（或左侧操作数）。而`b`是它的第二个（或右侧操作数）。由于它接收两个操作数，所以大于运算符被认为是一个二元运算符。在JavaScript中，我们有一元、二元和三元运算符：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is only one ternary operator in JavaScript, the conditional operator (`a
    ? b : c`). Since it is the only ternary operator, it is sometimes simply referred
    to as the ternary operator instead of its formal name.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '在JavaScript中只有一个三元运算符，即条件运算符（`a ? b : c`）。由于它是唯一的三元运算符，有时它被简单地称为三元运算符，而不是它的正式名称。'
- en: 'Knowing about the arity of a given operator is vital—just as it would be vital
    to know how many arguments to pass a function. It''s also important to consider
    how we are communicating our intent when we compose operations. Since operations
    can appear in series, it can sometimes be unclear which operator refers to which
    operand. Consider this confusing expression:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 了解给定运算符的arity是至关重要的——就像知道要传递给函数多少个参数一样重要。在组合操作时，考虑我们如何传达我们的意图也很重要。由于操作可以连续出现，有时可能不清楚哪个运算符指的是哪个操作数。考虑这个令人困惑的表达式：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To avoid confusion in understanding operations like this, it is conventional
    to move unary operators closer to their operands and even to employ parentheses
    to make it absolutely crystal clear what the intent is:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免对这样的操作产生困惑，通常将一元运算符靠近它们的操作数，并且甚至使用括号来使意图绝对清晰：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As with all of the parts of code, operators must be wielded with care and concern
    for the individual or individuals (including your future self) who'll have to
    encounter, understand, and maintain the code going forward.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与代码的所有部分一样，运算符必须小心使用，并关心将来将不得不遇到、理解和维护代码的个人或个人（包括您未来的自己）。
- en: Operator function
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符功能
- en: An operator's function is simply what it does and what it evaluates to. We'll
    be going over each operator individually, so there's not a lot to say here beyond
    a few basic assumptions you can carry with you when working with operators.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符的功能就是它做什么以及它的计算结果。我们将逐个讨论每个运算符，因此在这里除了一些基本的假设之外，没有太多要说的。
- en: In JavaScript, every operator is its own entity and is not tied to the type
    of operands it is operated on. This is in contrast to some other languages where
    operators are mapped to overridable functions or are somehow attached to the operands
    themselves. In JavaScript, operators are their own syntactic entity and have non-overridable
    functionality. Their functionality is, however, extensible in certain situations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，每个运算符都是独立的实体，不与其操作的操作数类型绑定。这与其他一些语言相反，在其他语言中，运算符被映射到可重写的函数，或者以某种方式附加到操作数本身。在JavaScript中，运算符是它们自己的语法实体，并具有不可重写的功能。但是，在某些情况下，它们的功能是可扩展的。
- en: 'When using any of the following types of operators, the language will internally
    attempt coercion:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用以下类型的运算符时，语言将在内部尝试强制转换：
- en: Arithmetic operators (namely, `+`, `*`, `/`, `-`, and so on)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符（即`+`、`*`、`/`、`-`等）
- en: Increment operators (namely, `++` and `--`)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递增运算符（即`++`和`--`）
- en: Bitwise operators (namely,`~`, `<<`, `|`, and so on)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位运算符（即`~`、`<<`、`|`等）
- en: Computed member access operator (that is, `...[...]`)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算成员访问运算符（即`...[...]`）
- en: Non-strict comparative operators (namely, `>`, `<`, `>=`, `<=`, and `==`)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非严格比较运算符（即`>`、`<`、`>=`、`<=`和`==`）
- en: 'And to specifically override these mechanisms of coercion, you can supply `valueOf()`, `toString()`,
    or  `[Symbol.toPrimitive]()` methods to any objects you intend to use as operands:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确地覆盖这些强制转换机制，您可以为您打算用作操作数的任何对象提供`valueOf()`、`toString()`或`[Symbol.toPrimitive]()`方法：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we covered in the previous chapter's *Conversion to a primitive* section,
    these methods will be called in a specific order depending on the exact operator
    or language construct used. In the case of all arithmetic operators, for example, `valueOf` will
    be attempted before `toString`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章的*转换为原始值*部分中所介绍的，这些方法将根据使用的确切运算符或语言构造以特定顺序调用。例如，在所有算术运算符的情况下，`valueOf`将在`toString`之前尝试。
- en: Operator precedence and associativity
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符优先级和结合性
- en: The order of operation when multiple operators are used in combination is defined
    by two mechanisms: *precedence* and *associativity*. An operator's precedence
    is a number from `1` to `20`, and defines the order in which a series of operators
    will run. Some operators share the same precedence. Associativity defines the
    order in which operators of the same precedence will be operated on (either left-to-right
    or right-to-left).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合使用多个运算符时，操作的顺序由两种机制定义：*优先级*和*结合性*。运算符的优先级是从`1`到`20`的数字，并定义了一系列运算符的运行顺序。一些运算符共享相同的优先级。结合性定义了具有相同优先级的运算符将被操作的顺序（从左到右或从右到左）。
- en: 'Consider the following operation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下操作：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In JavaScript, these specific mathematic operators have the following precedences:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，这些特定的数学运算符具有以下优先级：
- en: The addition operator (`+`) has a precedence of `13`
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法运算符（`+`）的优先级为`13`
- en: The multiplication operator (`*`) has a precedence of `14`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法运算符（`*`）的优先级为`14`
- en: The division operator (`/`) has a precedence of `14`
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除法运算符（`/`）的优先级为`14`
- en: The subtraction operator (`-`) has a precedence of `13`
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减法运算符（`-`）的优先级为`13`
- en: 'And all of them have *left-to-right* associativity. Since operators of higher
    precedence occur first and operators of the same precedence will occur according
    to their associativity, we can say that our example operation occurs in the following
    order:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都具有*从左到右*的结合性。由于优先级更高的运算符首先出现，并且具有相同优先级的运算符将根据它们的结合性出现，我们可以说我们的示例操作按以下顺序进行：
- en: Multiplication (left most amongst operators with a precedence of `14`)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 乘法（具有优先级`14`中最左边的）
- en: Division (next on the left amongst operators with a precedence of `14`)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除法（具有优先级`14`中最左边的）
- en: Addition (left most amongst operators with a precedence of `13`)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加法（具有优先级`13`中最左边的）
- en: Subtraction (next on the left amongst operators with a precedence of `13`)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减法（具有优先级`13`中下一个最左边的）
- en: 'If we were to group our operation explicitly using parentheses, it would, therefore,
    look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用括号明确地对我们的操作进行分组，那么它看起来会像这样：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Every operator, even non-mathematical ones, have specific precedences and associativities.
    The `typeof` operator, for example, has a precedence of `16`. This can cause a
    headache if you use it in combination with a lower-precedence operator:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运算符，甚至非数学运算符，都有特定的优先级和结合性。例如，`typeof`运算符的优先级为`16`。如果您将它与优先级较低的运算符结合使用，这可能会引起头痛：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Due to the `+` operator having a lower precedence than `typeof`, JavaScript
    would internally run this operation like so:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`+`运算符的优先级低于`typeof`，JavaScript将在内部按以下方式运行此操作：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This, therefore, results in `typeof 1` (that is, `"number"`) being concatenated
    with `2` (producing `"number2"`). To avoid this, we must force the order using
    our own parentheses:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，结果是`typeof 1`（即`"number"`）与`2`连接（产生`"number2"`）。为了避免这种情况，我们必须使用自己的括号来强制顺序：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Incidentally, this is why you may often see `typeof` with parentheses (`typeof(...)`),
    which can make it look like a function being invoked. It is, however, an operator,
    and the parentheses are only there to force a specific order of operation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这就是为什么您经常会看到带括号的`typeof`（`typeof(...)`），这样看起来就像是在调用函数。然而，它实际上是一个运算符，括号只是为了强制特定的操作顺序。
- en: You can discover the exact precedences of every operator by reading the ECMAScript
    specification or searching online for `JavaScript operator precedences`. Note
    that the numbers used to indicate precedence between `1` and `20` are not from
    the ECMAScript specification itself but are rather just a useful way of understanding
    precedence.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读ECMAScript规范或在网上搜索“JavaScript运算符优先级”来发现每个运算符的确切优先级。请注意，用于指示优先级的数字在1和20之间，并不是来自ECMAScript规范本身，而只是一种理解优先级的有用方式。
- en: 'Knowing the precedences and associativities of every operator is not something
    we should expect of our colleagues. It may be reasonable to assume that they know
    the precedences of some basic mathematical operators, but knowledge beyond that
    should not be considered guaranteed. Therefore, it is often necessary to provide
    clarity by employing parentheses even in situations where they may not be strictly
    necessary. This is especially crucial in complex operations where there are a
    large number of consecutive operators, as in this example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 知道每个运算符的优先级和结合性并不是我们应该期望我们的同事知道的事情。假设他们知道一些基本数学运算符的优先级可能是合理的，但不应该认为他们知道更多。因此，通常需要通过使用括号来提供清晰度，即使在可能不严格需要的情况下。这在复杂的操作中尤为重要，其中有大量连续的运算符，就像这个例子中一样：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, the parentheses wrapping `(2 * horizontalPadding)` is technically unnecessary
    as the multiplication operator naturally has a higher precedence than the addition
    operator. However, it is useful to provide extra clarity. Programmers reading
    this code will be grateful to spend less cognitive energy discerning the exact
    order of operations. As with many well-intended things, however, this can be taken
    too far. Parentheses that provide neither clarity nor a different forced order
    of operation should not be included. An example of such redundancy might be wrapping
    the entire `return` expression in additional parentheses:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，包裹`(2 * horizontalPadding)`的括号在技术上是不必要的，因为乘法运算符自然比加法运算符具有更高的优先级。然而，提供额外的清晰度是有用的。阅读这段代码的程序员会感激地花费更少的认知能量来辨别操作的确切顺序。然而，像许多本意良好的事情一样，这可能会走得太远。不应该包括既不提供清晰度也不强制不同操作顺序的括号。这种多余的例子可能是在额外的括号中包裹整个`return`表达式：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This should ideally be avoided, as if it''s taken too far, it can introduce
    additional cognitive load for the reader of the code. A good guide for such situations
    is if you''re inclined to add additional parentheses for clarity, you should probably
    split the operation into multiple lines:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最好避免这样做，因为如果走得太远，它可能会给代码的读者增加额外的认知负担。对于这种情况的一个很好的指导是，如果你倾向于添加额外的括号以提高清晰度，你可能应该将操作拆分成多行：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These added lines provide not only clarity around the order of operations but
    also the purpose of each individual operation by usefully assigning each operation
    to a descriptive variable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的行不仅提供了关于操作顺序的清晰度，还通过有用地将每个操作分配给一个描述性变量，提供了每个单独操作的目的。
- en: Knowing every single operator's precedence and associativity is not necessarily
    vital, but knowing how these mechanisms underly every operation is very useful.
    Most of the time, as you've seen, it's preferable to split operations into self-contained
    lines or groups for clarity, even when the internal precedence or associativity
    of our operators does not demand it. Above all, we must always consider whether
    we are clearly communicating our intent to the readers of our code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 知道每个运算符的优先级和结合性并不一定是至关重要的，但知道这些机制如何支持每个操作是非常有用的。大多数情况下，正如你所看到的，最好将操作分成自包含的行或组，以便清晰，即使我们的运算符的内部优先级或结合性并不要求这样做。最重要的是，我们必须始终考虑我们是否清楚地传达了我们代码的意图给读者。
- en: The average JavaScript programmer will not have an encyclopedic knowledge of
    the ECMAScript specification, and as such, we should not demand such knowledge
    to comprehend the code we have written.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 普通的JavaScript程序员不会对ECMAScript规范有百科全书式的了解，因此，我们不应该要求这样的知识来理解我们编写的代码。
- en: Knowledge of the mechanisms underlying operators paves the way for us to now
    explore individual operators within JavaScript. We'll begin by exploring arithmetic
    and numeric operators.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 了解运算符背后的机制为我们探索JavaScript中的各个运算符铺平了道路。我们将从探索算术和数字运算符开始。
- en: Arithmetic and numeric operators
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术和数字运算符
- en: 'There are eight arithmetic or numeric operators in JavaScript:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中有八个算术或数字运算符：
- en: '**Addition**: `a + b`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加法**：`a + b`'
- en: '**Subtraction**: `a - b`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减法**：`a - b`'
- en: '**Division**: `a / b`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**除法**：`a / b`'
- en: '**Multiplication**: `a * b`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乘法**：`a * b`'
- en: '**Remainder**: `a % b`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取余**：`a % b`'
- en: '**Exponentiation**: `a ** b`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指数运算**：`a ** b`'
- en: '**Unary plus**: `+a`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一元加**：`+a`'
- en: '**Unary minus**: `-a`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一元减**：`-a`'
- en: Arithmetic and numeric operators will typically coerce their operands to numbers.
    The only exception is the `+` addition operator, which will, if passed a non-numerical
    operand, assume the function of string concatenation instead of addition.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 算术和数字运算符通常会将它们的操作数强制转换为数字。唯一的例外是`+`加法运算符，如果传递了一个非数字的操作数，它将假定字符串连接的功能而不是加法。
- en: 'There is one guaranteed outcome of all of these operations that is worth knowing
    about beforehand. An input of `NaN` guarantees an output of `NaN`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作的一个保证的结果是值得事先了解的。`NaN`的输入保证了`NaN`的输出：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Beyond that basic assumption, each of these operators behaves in a slightly
    different way, so it's worth going over each of them individually.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个基本假设之外，每个运算符的行为都略有不同，因此值得逐个讨论。
- en: The addition operator
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加法运算符
- en: 'The addition operator is a dual-purpose operator:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 加法运算符是一个双重用途运算符：
- en: If either operand is `String`, then it'll concatenate both operands together
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任一操作数是`String`，那么它将连接两个操作数。
- en: If neither operand is `String`, then it'll add both operands as numbers
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有操作数是`String`，那么它将把两个操作数都作为数字相加
- en: To accomplish its dual purpose, the `+` operator first needs to discern whether
    the operands you've passed can be considered strings. Obviously, a primitive `String`
    value is clearly a string, but for non-primitives, the `+` operator will attempt
    to convert your operands into their primitive representations by relying on the
    internal `ToPrimitive` procedure that we detailed in the last chapter, in the *Conversion
    to a primitive* section. If the output of `ToPrimitive` for either of our `+` operands
    is a string, then it will concatenate both operands as strings. Otherwise, it'll
    add them as numbers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现它的双重目的，`+`运算符首先需要确定你传递的操作数是否可以被视为字符串。显然，原始的`String`值显然是一个字符串，但对于非原始值，`+`运算符将尝试通过依赖我们在上一章中详细介绍的内部`ToPrimitive`过程将你的操作数转换为它们的原始表示。如果`+`操作数的`ToPrimitive`的输出是一个字符串，那么它将把两个操作数连接为字符串。否则，它将把它们作为数字相加。
- en: The fact that the `+` operator caters to both numeric addition and concatenation
    can make it quite complicated to understand, so it's helpful for us to walk through
    a few examples.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`运算符既可以进行数字相加，也可以进行连接，这使得它相当复杂，因此我们通过几个例子来帮助我们理解。'
- en: Both operands are numbers
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两个操作数都是数字
- en: '**Explanation**: When both operands are primitive numbers, the `+` operator
    very simply adds them together:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**解释**：当两个操作数都是原始数字时，`+`运算符非常简单地将它们相加：'
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Both operands are strings
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两个操作数都是字符串
- en: '**Explanation**: When both operands are primitive strings, the `+` operator
    very simply concatenates them together:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**解释**：当两个操作数都是原始字符串时，`+`运算符非常简单地将它们连接在一起：'
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: One operand is a string
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个操作数是字符串
- en: '**Explanation**: When only one operand is a primitive string, the `+` operator
    will coerce the other into `String` and will then concatenate both resulting strings
    together:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**解释**：当只有一个操作数是原始字符串时，`+`运算符将强制转换另一个为`String`，然后将两个结果字符串连接在一起：'
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: One operand is a non-primitive
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个操作数是非原始值
- en: '**Explanation**: When either operand is a non-primitive, the `+` operator will
    convert it into a primitive, and then act as it usually would with that new primitive
    representation. Here''s an example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**解释**：当任一操作数是非原始时，`+`运算符将把它转换为原始值，然后按照新的原始表示进行操作。这里有一个例子：'
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, JavaScript will convert `[123]` into its primitive value by using
    the return value of `[123].toString()` (that is, `"123"`). Since the primitive
    representation of an array is its `String` representation, the `+` operator will
    operate as if we were simply doing `"123" + 123`, which, as we know, evaluates
    to `"123123"`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，JavaScript将通过使用`[123].toString()`的返回值（即`"123"）将`[123]`转换为它的原始值。由于数组的原始表示是它的`String`表示，`+`运算符将操作，就好像我们只是在做`"123"
    + 123`一样，我们知道结果是`"123123"`。
- en: Conclusion – know your operands!
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论-了解你的操作数！
- en: When using the `+` operator, it's especially vital to know what operands you're
    dealing with. If you don't, then the outcome of your operation may be unexpected.
    The `+` operator is probably one of the more complex operators since it has a
    dual purpose. Most operators aren't as complex. The subtraction operator, which
    we'll explore next, is thankfully far simpler.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`+`运算符时，特别重要的是要知道你正在处理的操作数是什么。如果不知道，那么你的操作结果可能会出乎意料。`+`运算符可能是最复杂的运算符之一，因为它具有双重目的。大多数运算符都不那么复杂。接下来我们将探讨的减法运算符则幸运地简单得多。
- en: The subtraction operator
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减法运算符
- en: 'The subtraction operator (`-`) does what it says on the tin. It takes two operands,
    subtracting the right-side operand from the left-side operand:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 减法运算符（`-`）就像它的名字一样。它接受两个操作数，从左操作数中减去右操作数：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If either operand is not a number, it will be coerced into one:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任一操作数不是数字，它将被强制转换为数字：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This includes non-primitive types too:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这也包括非原始类型：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we''re seeing two arrays, each with a single element, being subtracted
    from each other. This seemingly makes no sense until we recall that the primitive
    representation of an array is its joined elements as a string, that is, `"5"` and `"3"` respectively:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到两个数组，每个数组都有一个元素，相互相减。这似乎毫无意义，直到我们想起数组的原始表示是其连接元素作为字符串，即分别是`"5"`和`"3"`：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These will then be converted into their numerical representations, `5` and `3`,
    via an operation that is equivalent to the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它们将通过等同于以下操作的方式转换为它们的数字表示，即`5`和`3`：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Therefore, we are left with the intuitive operation of `5` minus `3`, which
    we know is `2`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到了直观的操作`5`减去`3`，我们知道结果是`2`。
- en: The division operator
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 除法运算符
- en: 'The division operator, much like the subtraction operator, accepts two operands
    that it will coerce to numbers. It will divide its left-side operand by its right-side
    operand:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除法运算符，就像减法运算符一样，接受两个它将强制转换为数字的操作数。它将用左操作数除以右操作数：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The two operands are formally called the dividend and the divisor (`DIVIDEND
    / DIVISOR`) and will always evaluate according to floating-point math. Integer
    division does not exist in JavaScript, which means, effectively, that the results
    of your divisions may always include decimal points, and may hence be liable to
    the error margin of `Number.EPSILON`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作数正式称为被除数和除数（`被除数/除数`），并且将始终根据浮点数运算进行评估。在JavaScript中不存在整数除法，这意味着你的除法结果可能总是包含小数点，并且可能会受到`Number.EPSILON`的误差范围的影响。
- en: 'Watch out when dividing by zero, as you may end up with either `NaN` (when
    dividing zero by zero) or `Infinity` (when dividing a non-zero number by zero):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当除以零时要小心，因为你可能会得到`NaN`（当零除以零时）或`Infinity`（当非零数除以零时）：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If your divisor is `Infinity`, your division will always evaluate to zero (`0` or `-0`),
    unless your dividend is also `Infinity`, in which case, you''ll receive `NaN`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的除数是`Infinity`，你的除法结果将始终评估为零（`0`或`-0`），除非你的被除数也是`Infinity`，在这种情况下，你将收到`NaN`：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In circumstances where you expect a divisor or dividend of zero, `NaN` or `Infinity`,
    it is best to be defensive and either check for those values explicitly beforehand
    or following the operation, like so:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在预期除数或被除数为零、`NaN`或`Infinity`的情况下，最好是谨慎处理，并在操作之前或之后明确检查这些值，如下所示：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The edge cases of division may seem scary but they're not frequently encountered
    in everyday applications. If we were, however, authoring a medical or financial
    program, then it'd be absolutely vital to carefully consider our operations' potential
    error states.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除法的边缘情况可能看起来吓人，但在日常应用中并不经常遇到。然而，如果我们编写医疗或金融程序，那么仔细考虑我们操作的潜在错误状态就是绝对必要的。
- en: The multiplication operator
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 乘法运算符
- en: 'The multiplication operator behaves similarly to the division operator, apart
    from the obvious fact that it performs multiplication:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法运算符的行为与除法运算符类似，除了它执行乘法的明显事实之外：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It is necessary to watch out for effects of coercion and situations where either
    operand is `NaN` or `Infinity`. Rather intuitively, multiplying any non-zero finite
    value by `Infinity` will always result in `Infinity` (with the appropriate sign):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意强制转换的影响以及其中一个操作数是`NaN`或`Infinity`的情况。相当直观地，任何非零有限值乘以`Infinity`将始终导致`Infinity`（带有适当的符号）：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, multiplying zero by `Infinity` will always result in `NaN`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将零乘以`Infinity`将始终导致`NaN`：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Outside of these cases, most usages of the multiplication operator are fairly
    intuitive.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些情况外，大多数乘法运算符的用法都是相当直观的。
- en: The remainder operator
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 余数运算符
- en: 'The remainder operator (`%`), also known as the **modulo operator**, is similar
    to the division operator. It accepts two operands: a dividend, on the left side,
    and a divisor on the right side. It will return the remainder following an implied
    division operation:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 余数运算符（`%`），也称为**模运算符**，类似于除法运算符。它接受两个操作数：左侧的被除数和右侧的除数。它将返回隐含除法操作后的余数：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the divisor is zero, the dividend is `Infinity`, or either operand is `NaN`,
    then the operation will evaluate to `NaN`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果除数为零，被除数为`Infinity`，或者任一操作数为`NaN`，则操作将评估为`NaN`：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And if the divisor is `Infinity`, then the result will be equal to the dividend:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果除数为`Infinity`，则结果将等于被除数：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The modulo operator is useful in situations where you wish to know whether
    a number *goes into* another number squarely, such as when wishing to establish
    the *evenness* or *oddness* of an integer:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 模运算符在希望知道一个数是否可以被另一个数整除的情况下非常有用，比如在希望确定整数的*偶数性*或*奇数性*时：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As with all other arithmetic operators, it's useful to be aware of how your
    operands will be coerced. Most usages of the remainder operator are straightforward,
    so outside of its coercive behaviors and its treatment of `NaN` and `Infinity`,
    you should find its behavior intuitive.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他算术运算符一样，了解操作数的强制转换方式是有用的。大多数情况下，余数运算符的用法很直观，因此除了其强制转换行为和对`NaN`和`Infinity`的处理之外，你应该会发现它的行为是直观的。
- en: The exponentiation operator
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指数运算符
- en: 'The exponentiation operator (`**`) takes two operands, a base on the left side
    and an exponent on the right side. It will evaluate to the base raised to the
    power of the exponent:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 指数运算符（`**`）接受两个操作数，左侧是基数，右侧是指数。它将评估为基数的指数幂：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It is functionally identical to using the `Math.pow(a, b)` operation, although
    is more succinct. As with other arithmetic operations, it will internally coerce
    its operands to the `Number` type, and passing in any operands of `NaN`, `Infinity`, or
    zero will result in possibly unexpected outcomes, so you should try to avoid such
    cases.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它在功能上与使用`Math.pow(a, b)`操作相同，尽管更简洁。与其他算术运算一样，它将内部强制转换其操作数为`Number`类型，并传入任何`NaN`、`Infinity`或零的操作数将导致可能意外的结果，因此你应该尽量避免这种情况。
- en: 'One curious case worth mentioning is that, if the exponent is zero, then the
    result will always be `1`, regardless of what the base is. So, the base could
    even be `Infinity`, `NaN`, or anything else, and the result would still be `1`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的一个奇怪情况是，如果指数为零，那么结果将始终为`1`，无论基数是什么。因此，基数甚至可以是`Infinity`、`NaN`或其他任何值，结果仍然是`1`：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'All other arithmetic operators will evaluate to `NaN` if one of their operands
    is `NaN`, so the behavior of `**` here is quite unique. Another unique behavior
    is that it will throw `SyntaxError` if your first operand is itself a unary operation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数中有一个是`NaN`，则所有其他算术运算符的行为将评估为`NaN`，因此这里的`**`的行为是非常独特的。另一个独特的行为是，如果你的第一个操作数本身是一个一元操作，它将抛出`SyntaxError`：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is to prevent ambiguity for the programmer. Depending on their previous
    exposure to other languages (or strict mathematical notation), they may expect
    cases such as `-2 ** 2` to be either `4` or `-4`. As such, JavaScript will throw
    in such cases, hence forcing you to be more explicit with either `(-2) ** 2` or `-(2
    ** 2)`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了防止程序员的歧义。根据他们之前接触的其他语言（或严格的数学符号），他们可能期望诸如`-2 ** 2`的情况要么是`4`要么是`-4`。因此，在这些情况下，JavaScript会抛出异常，因此迫使你更加明确地使用`(-2)
    ** 2`或`-(2 ** 2)`。
- en: 'Apart from these unique characteristics, the exponentiation operator can be
    considered similar to other binary (two-operand) arithmetic operators. As always:
    be aware of your operands'' types and how they may be coerced!'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些独特的特点外，指数运算符可以被认为与其他二元（双操作数）算术运算符类似。一如既往：要注意你的操作数类型以及它们可能被强制转换的方式！
- en: The unary plus operator
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一元加运算符
- en: 'The unary plus operator (`+...`) will convert its operand into `Number` as
    if it were passed to `Number(...)`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一元加运算符（`+...`）将其操作数转换为`Number`，就好像它被传递给`Number(...)`一样：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To do this, our cherished internal `ToPrimitive` procedure will be utilized,
    as discussed in the last chapter, in the *Conversion to a primitive* section.
    Its result will then be re-coerced into `Number` if it is not already `Number`.
    So, if `ToPrimitive` were to return `String`, that `String` would be converted
    into `Number`, meaning that non-numeric strings will result in `NaN`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们珍爱的内部`ToPrimitive`过程将被使用，如上一章节中讨论的*转换为原始值*部分。其结果将被重新强制转换为`Number`，如果它不已经是`Number`。因此，如果`ToPrimitive`返回`String`，那么该`String`将被转换为`Number`，这意味着非数字字符串将导致`NaN`：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And naturally, if `String` from `ToPrimitive` can be converted into `Number`, then
    that is what the unary `+` operator will evaluate to:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，如果`ToPrimitive`中的`String`可以转换为`Number`，那么一元`+`运算符将评估为：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is more realistically observed when coercing an array via `+`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过`+`强制转换数组时，更容易观察到这一点：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The unary `+` operator is usually used in places where a programmer wishes to
    cast a number-like object to `Number` so that they can then use it with other
    numeric operations. Usually, however, it is preferable to explicitly use `Number(...)` as
    it is much clearer what the intention is.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一元`+`运算符通常用于程序员希望将类似数字的对象转换为`Number`以便随后与其他数字操作一起使用的地方。然而，通常最好明确使用`Number(...)`，因为这样更清楚意图是什么。
- en: 'The unary `+` operator can sometimes be confused with other operations. Consider
    this scenario:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一元`+`运算符有时可能会与其他操作混淆。考虑以下情况：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To someone unfamiliar with the unary plus or someone not attuned to seeing
    it regularly, this code may look like it contains a typo. We could potentially
    wrap the entire unary operation in its own parentheses to make it clearer:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉一元加号或不经常看到它的人来说，这段代码可能看起来像是包含了一个错别字。我们可以潜在地将整个一元操作包装在自己的括号中，以使其更清晰：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Or we could instead use the much clearer `Number(...)` function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用更清晰的`Number(...)`函数：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In summary, the unary `+` operator is a convenient shortcut to `Number(...)`.
    It's useful and quick, though in most cases, we should prefer to communicate our
    intent more clearly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，一元`+`运算符是`Number(...)`的便捷快捷方式。它很有用，尽管在大多数情况下，我们应该更清楚地表达我们的意图。
- en: The unary minus operator
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一元减号运算符
- en: 'The unary minus operator (`-...`) will first convert its operand into `Number`
    in the same way as the unary `+` operator, detailed in the last section, and will
    then negate it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一元减号运算符（`-...`）将首先将其操作数转换为`Number`，方式与上一节中详细介绍的一元`+`运算符相同，然后对其取反：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Its usage is fairly straightforward and intuitive, although, as with unary `+`,
    it''s useful to disambiguate cases where you have a unary operator next to its
    binary operator counterpart. Cases like these can be confusing:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用非常简单直观，尽管与一元`+`一样，有用的是消除一元运算符与其二元运算符对应物相邻的情况。这些情况可能会令人困惑：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It is best, in these situations, to lend clarity with parentheses:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，最好用括号明确表达清晰：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The unary minus operator is usually only used directly with a literal number
    operand to specify a negative value. As with all other arithmetic operators, we
    should ensure that our intent is clear and that we are not confusing people with
    long or confusing expressions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一元减号运算符通常只与文字数字操作数一起直接使用，以指定负值。与所有其他算术运算符一样，我们应确保我们的意图清晰，并且不要用长或令人困惑的表达式使人困惑。
- en: Now that we've explored arithmetic operators, we can begin to look into logical
    operators.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了算术运算符，我们可以开始研究逻辑运算符了。
- en: Logical operators
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'Logical operators are typically used to build logical expressions where the
    result of the expression informs some action or inaction. There are three logical
    operators in JavaScript:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符通常用于构建逻辑表达式，其中表达式的结果通知某些动作或不动作。JavaScript中有三个逻辑运算符：
- en: The NOT operator (`!a`)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NOT运算符（`!a`）
- en: The AND operator (`a && b`)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AND运算符（`a && b`）
- en: The OR operator (`a || b`)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OR运算符（`a || b`）
- en: As with most other operators, they can accept a variety of types and will coerce
    as necessary. The AND and OR operators, unusually, do not always evaluate to a `Boolean` value,
    and both utilize a mechanism called **short-circuit evaluation** to only execute
    both operands if some condition is met. We'll learn more about this as we explore
    each individual logical operator.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他运算符一样，它们可以接受各种类型并根据需要进行强制转换。AND和OR运算符不同寻常地并不总是评估为`Boolean`值，并且都利用一种称为**短路评估**的机制，只有在满足某些条件时才执行两个操作数。当我们探索每个单独的逻辑运算符时，我们将更多地了解这一点。
- en: The logical NOT operator
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑NOT运算符
- en: 'The NOT operator is a unary operator. It accepts only a single operand and
    converts that operand into its Boolean representation, then inverts it, so that
    truthy items become `false` and falsy items become `true`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: NOT运算符是一元运算符。它只接受一个操作数并将该操作数转换为其布尔表示形式，然后取反，因此真值项目变为`false`，假值项目变为`true`：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Internally, the NOT operator will perform the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，NOT运算符将执行以下操作：
- en: Cast the operand to a Boolean (`Boolean(operand)`)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将操作数转换为布尔值（`Boolean(operand)`）
- en: If the resulting value is `true`, then return `false`; otherwise, return `true`
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果结果值为`true`，则返回`false`；否则返回`true`
- en: As discussed in the *Conversion to a Boolean* section in the last chapter, a
    typical idiom for converting a value to its Boolean representation is the double
    NOT (that is, `!!value`) as this effectively reverses the truthiness or falsiness
    of the value twice and evaluates to a Boolean. The more explicit and slightly
    more preferred idiom is to use `Boolean(value)`, as the intention is far clearer
    than with `!!`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如上一章节中*转换为布尔值*部分所讨论的，将值转换为其布尔表示形式的典型习语是双重NOT（即`!!value`），因为这实际上两次颠倒了值的真实性或虚假性，并评估为`Boolean`。更明确且稍微更受欢迎的习语是使用`Boolean(value)`，因为意图比`!!`更清晰。
- en: 'As a result of there being only seven falsy values in JavaScript, the NOT operator
    can only evaluate to `true` in these seven scenarios:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript中只有七个假值，因此NOT运算符只能在以下七种情况下评估为`true`：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: JavaScript's rigid definition of falsiness and truthiness is reassuring. It
    means that even if someone constructs an object with all manner of primitive representations
    (imagine an object with `valueOf()` that returns a falsy value), all internal
    Boolean coercions will still only ever return `false` for the seven falsy values
    and nothing else. That means we only need to worry about those seven (*it could
    be much worse...*).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对假值和真值的严格定义是令人放心的。这意味着即使有人构造了一个具有各种原始表示的对象（想象一个具有返回假值的`valueOf()`的对象），所有内部布尔强制转换仍然只会对七个假值返回`false`，而不会返回其他任何值。这意味着我们只需要担心这七个值（*情况可能会更糟……*）。
- en: 'On the whole, usage of the logical NOT operator is very straightforward. It''s
    a well-understood syntax across programming languages with clear semantics. As
    such, there is not a lot in the way of *best practices* concerning it. At the
    very least, it''s best to avoid too many double negatives in your code. A double
    negative is when an already negatively-named variable is applied to the NOT operator,
    like so:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，逻辑非运算符的使用非常简单。它是跨编程语言具有清晰语义的众所周知的语法。因此，在*最佳实践*方面并没有太多需要考虑的。至少，最好避免在代码中使用太多双重否定。双重否定是指将已经带有否定意义的变量应用于非运算符，如下所示：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is cognitively expensive for those who read your code and is therefore
    liable to misunderstanding. It''s best to use positively-named Boolean variable
    names so that any logical operations using them are straightforward to comprehend.
    In this situation, we would simply rename our variable and reverse the operation,
    like so:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于阅读您的代码的人来说，这在认知上是昂贵的，因此容易产生误解。最好使用名称明确的布尔变量名称，以便使用它们的任何逻辑操作都容易理解。在这种情况下，我们只需重新命名变量并反转操作，如下所示：
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The logical NOT operator, in summary, is most useful in Boolean contexts such
    as `if()` and `while()`, though is also idiomatically found in the double-NOT `!!`
    operation. And it is technically the only operator in JavaScript that is guaranteed
    to return a `Boolean` value regardless of its operand's type. Next, we'll explore
    the AND operator.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑非运算符总的来说，在布尔上下文中最有用，比如`if()`和`while()`，尽管在双非`!!`操作中也有习惯用法。从技术上讲，它是 JavaScript
    中唯一保证返回`Boolean`值的运算符，无论其操作数的类型如何。接下来，我们将探讨与运算符。
- en: The logical AND operator
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑与运算符
- en: 'The logical AND operator (`&&`) in JavaScript accepts two operands. If its
    *left-side* operand is truthy, then it will evaluate and return the *right-side*
    operand; otherwise, it will return the *left-side* operand:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的逻辑与运算符(`&&`)接受两个操作数。如果其*左侧*操作数为真值，则它将评估并返回*右侧*操作数；否则，它将返回*左侧*操作数：
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It can be a confusing operator for many people because they wrongfully assume
    that it is equivalent to the question *Are both A and B true?* when, in fact,
    it is more akin to *If A is truthy then give me B; otherwise, I''ll settle for
    A*. People may have an assumption that JavaScript will evaluate both operands,
    but it in fact will only evaluate the right-side operand if the left-side operand
    is truthy. This is known as **short-circuit evaluation**. And JavaScript will
    not cast the resulting value of the operation to `Boolean`: instead, it''ll just
    give us that value back, unchanged. If we were to implement the operation ourselves,
    it might look something like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对许多人来说，它可能是一个令人困惑的运算符，因为他们错误地认为它等同于问题“A和B都是真的吗？”实际上，它更类似于“如果A是真的，那么给我B；否则，我会接受A”。人们可能会假设
    JavaScript 会评估两个操作数，但实际上，如果左侧操作数为真，它只会评估右侧操作数。这被称为**短路评估**。JavaScript 不会将操作的结果值转换为`Boolean`：相反，它只会将该值返回，不变。如果我们要自己实现该操作，它可能看起来像这样：
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Given a simple operation, such as making an `if(...)` statement conditional
    upon two values being truthy, the `&&` operator will behave in an entirely unsurprising
    and expected way:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的操作，比如使一个`if(...)`语句依赖于两个值都为真，`&&`运算符将以一种完全令人满意和预期的方式行事：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'However, the `&&` operator can be used in more interesting ways too, such as
    when needing to return a value but only if some prior condition is met:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`&&`运算符也可以以更有趣的方式使用，比如当需要返回一个值，但只有在满足某些先决条件时：
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here, the `&&` operator is being used in a non-Boolean context, where there
    is no coercion of its result occurring. In this case, if its left-side operand
    is falsy (that is, if `user` is falsy), then it will return that; otherwise, it
    will return the right-side operand (that is, `user.favoriteDrink`):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`&&`运算符被用在一个非布尔上下文中，其结果不会发生强制转换。在这种情况下，如果其左侧操作数为假值（即，如果`user`为假），那么它将返回该值；否则，它将返回右侧操作数（即，`user.favoriteDrink`）：
- en: '[PRE56]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `getFavoriteDrink` function behaves in a way that fulfills a basic contract,
    returning `favoriteDrink` if the `user` object is available and if the `favoriteDrink` property
    appears on that object, although its actual functionality is a little more chaotic:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFavoriteDrink`函数的行为方式符合基本约定，如果`user`对象可用并且该对象上出现了`favoriteDrink`属性，则返回`favoriteDrink`，尽管其实际功能有点混乱：'
- en: '[PRE57]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Our `getFavoriteDrink` function is not making any deliberations about the specific
    nature of the user or `favoriteDrink` values; it is just blindly yielding to the `&&` operator,
    returning either its left-side or its right-side operand. If we are confident
    in the potential values of our operands, then this approach may be fine.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`getFavoriteDrink`函数并不对用户或`favoriteDrink`的特定性质进行任何考虑；它只是盲目地屈从于`&&`运算符，返回其左侧或右侧的操作数。如果我们对操作数的潜在值有信心，那么这种方法可能是可以的。
- en: It's important to take the time to consider the possible ways that `&&` will
    evaluate the operands you provide it with. Take into consideration the fact that
    it is not guaranteed to return `Boolean` and is not guaranteed to even evaluate
    the right-side operand.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要花时间考虑`&&`将如何评估您提供的操作数的可能方式。要考虑的是，它不能保证返回`Boolean`，甚至不能保证评估右侧操作数。
- en: 'The `&&` operator, thanks to its short-circuiting nature, can also be used
    to express control flow. Let''s consider a scenario in which we wish to call `renderFeature()`
    if the `isFeatureEnabled` Boolean is truthy. Conventionally, we may employ an
    `if` statement to do this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`运算符，由于其短路特性，也可以用于表达控制流。假设我们希望在`isFeatureEnabled`布尔值为真时调用`renderFeature()`。传统上，我们可能会使用`if`语句来实现：'
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'But we could also employ `&&`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以使用`&&`：
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This and other unconventional usages of `&&` are typically frowned upon because
    they can obscure the intention of the programmer and create confusion for readers
    of your code who may not have such a thorough understanding of how `&&` operates
    in JavaScript. Nonetheless, the `&&` operator is truly powerful and should be
    used when well-suited to the task at hand. You should feel empowered to use it
    as you wish but always be aware of how the typical reader of your code may see
    the operation and always consider the prospective values that the operation may
    produce.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种以及其他不寻常的`&&`用法通常不被赞同，因为它们可能会掩盖程序员的意图，并对代码的读者造成困惑，这些读者可能对JavaScript中`&&`的操作方式了解不够透彻。尽管如此，`&&`运算符确实非常强大，应该在适当的情况下使用。你应该自由地使用它，但始终要意识到代码的典型读者可能如何看待这个操作，并始终考虑操作可能产生的潜在值。
- en: The logical OR operator
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑或运算符
- en: 'The logical OR operator (`||`) in JavaScript accepts two operands. If its left-side
    operand is truthy, then it will return that immediately; otherwise, it will evaluate
    and return the right-side operand:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的逻辑或运算符（`||`）接受两个操作数。如果其左侧操作数为真值，则它将立即返回该值；否则，它将评估并返回右侧操作数：
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Much like the `&&` operator, the `||` operator is flexible in that it does
    not cast what it returns to `Boolean`, and it evaluates in a short-circuited manner,
    meaning that it only evaluates the right-hand side operand if the left-side operand
    meets a condition—in this case, if the right-side operand is falsy:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与`&&`运算符类似，`||`运算符也具有灵活性，它不会将返回值转换为布尔值，并且以短路方式进行评估，这意味着只有在左侧操作数满足条件时才会评估右侧操作数，即在这种情况下，如果右侧操作数为假：
- en: '[PRE61]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Conventionally, a programmer may assume that the logical OR operator is akin
    to the question *Are either A or B true?* but in JavaScript, it is more akin to: *If
    A is falsy, then give me B; otherwise, I''ll settle for A*. If we were to implement
    this operation ourselves, it might look something like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，程序员可能会假设逻辑或运算符类似于问题“A或B是否为真？”，但在JavaScript中，它更类似于：“如果A为假，则给我B；否则，我会接受A”。如果我们自己实现这个操作，它可能看起来像这样：
- en: '[PRE62]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Just as with `&&`, this means that `||` can be used flexibly to provide control
    flow or to evaluate specific expressions conditionally:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与`&&`一样，这意味着`||`可以灵活使用以提供控制流或有条件地评估特定表达式：
- en: '[PRE63]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As such, it should be used cautiously in a way that considers what readers of
    the code are familiar with, and in a way that considers all prospective operands
    and the resulting values from the operation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应该谨慎使用它，考虑代码读者熟悉的内容，以及考虑所有潜在的操作数和操作结果值。
- en: Comparative operators
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'Comparative operators are a collection of binary operators that always return `Boolean` derived
    from a comparison between the two operands:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符是一组二元运算符，始终返回从两个操作数之间的比较派生的布尔值：
- en: Abstract equality (`a == b`)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象相等（`a == b`）
- en: Abstract inequality (`a != b`)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象不相等（`a != b`）
- en: Strict equality (`a === b`)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格相等（`a === b`）
- en: Strict inequality (`a !== b`)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格不相等（`a !== b`）
- en: Greater than (`a > b`)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于（`a > b`）
- en: Greater than or equal to (`a >= b`)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于或等于（`a >= b`）
- en: Less than (`a < b`)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于（`a < b`）
- en: Less than or equal to (`a <= b`)
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于或等于（`a <= b`）
- en: Instance of (`a instanceof b`)
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例（`a instanceof b`）
- en: In (`a in b`)
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在（`a in b`）
- en: Each of these operators has slightly different functions and coercive behavior
    so it's useful to go through each of them individually.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符每个都有稍微不同的功能和强制行为，因此逐个地了解它们是很有用的。
- en: Abstract equality and inequality
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象相等和不相等
- en: The abstract equality (`==`) and inequality (`!=`) operators rely on the same
    algorithm internally, which is responsible for determining whether two values
    can be considered equal. In this section, our examples will only explore `==`,
    but rest assured that `!=` will always simply be the opposite of whatever `==` is.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象相等（`==`）和不相等（`!=`）运算符在内部依赖于相同的算法，该算法负责确定两个值是否可以被视为相等。在本节中，我们的示例只会探讨`==`，但请放心，`!=`总是`==`的相反。
- en: In the vast majority of cases, it is not advisable to rely on abstract equality
    because its mechanism can create unexpected results. Most of the time, you'll
    want to opt for strict equality (that is, `===` or `!==`).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在绝大多数情况下，不建议依赖抽象相等，因为它的机制可能会产生意想不到的结果。大多数情况下，你会选择严格相等（即`===`或`!==`）。
- en: 'Where both operands, the left-side and the right-side, are of the same type,
    then the mechanism is quite simple—the operator will check whether the two operands
    are identical values:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当左侧和右侧操作数都是相同类型时，机制非常简单——运算符将检查这两个操作数是否是相同的值：
- en: '[PRE64]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: When both operands are of the same type, abstract equality (`==`) is exactly
    identical to strict equality (`===`).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个操作数都是相同类型时，抽象相等（`==`）与严格相等（`===`）完全相同。
- en: 'Since all non-primitives in JavaScript are of the same type (`Object`), abstract
    equality ( `==`) will always return `false` if you try to compare two non-primitives
    (two objects) that don''t refer to the exact same object:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript中所有非原始值都是相同类型（`Object`），抽象相等（`==`）如果你尝试比较两个非原始值（两个对象）并且它们不引用完全相同的对象，将始终返回`false`：
- en: '[PRE65]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: However, where both operands are of different types, for example, where you
    are comparing a `Number` type to a `String` type or an `Object` type to a `Boolean` type,
    the exact behavior of abstract equality will depend on the operands themselves.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当两个操作数的类型不同时，例如当你比较一个`Number`类型和一个`String`类型，或者一个`Object`类型和一个`Boolean`类型时，抽象相等的确切行为将取决于操作数本身。
- en: 'If either operand is `Number`, and the other is `String`, then the `a == b` operation is
    equivalent to the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个操作数是`Number`，另一个是`String`，那么`a == b`操作等同于以下操作：
- en: '[PRE66]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here are some examples of this in action:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE67]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note how, as discussed in the *Conversion to a number* section in the last chapter,
    the `"1e3"` string will be internally converted to the number `1000`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正如上一章中*转换为数字*部分所讨论的，字符串`"1e3"`将被内部转换为数字`1000`。
- en: 'Continuing down the rabbit hole—if only one operand to the `==` operator is `Boolean`,
    then the operation is, once again, equivalent to `Number(a) === Number(b)`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 继续深入研究——如果`==`运算符的操作数之一是`Boolean`，那么该操作再次等同于`Number(a) === Number(b)`：
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, if previous conditions are not met, and if either operand is `Object` (not
    a primitive), then it will compare the primitive representation of that object
    to the other operand. As discussed in the last chapter, in the *Conversion to
    a primitive* section, this will attempt to call the `[Symbol.toPrimitive]()`, `valueOf()`, and
    then `toString()` methods to establish the primitive. We can see this in action
    here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果不满足前面的条件，并且其中一个操作数是`Object`（而不是原始值），那么它将比较该对象的原始表示与另一个操作数。正如上一章中讨论的那样，在*转换为原始值*部分，这将尝试调用`[Symbol.toPrimitive]()`、`valueOf()`，然后是`toString()`方法来建立原始值。我们可以在这里看到它的运作方式：
- en: '[PRE69]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Due to their complicated coercive behaviors, the *abstract equality* and *inequality*
    operators are best avoided. Anyone reading code littered with these operators
    won't be able to have a good level of confidence in the conditions and control
    flow of the program because there are simply too many odd edge cases where abstract
    equality can bite.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们复杂的强制行为，最好避免使用*抽象相等*和*不相等*运算符。任何阅读到充斥着这些运算符的代码的人都无法对程序的条件和控制流程有很高的信心，因为抽象相等可能会有太多奇怪的边缘情况。
- en: If you find yourself wanting to use abstract equality, for example, when one
    operand is a number and another is a string, consider whether it might be clearer
    and less error-prone to use a combination of stricter checks or to explicitly
    cast your values for clarity; for example, instead of `aNumber == aNumericString`, you
    could do `aNumber === Number(aNumericString)`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己想要使用抽象相等，例如，当一个操作数是数字，另一个是字符串时，考虑是否使用更严格的检查的组合或明确地转换您的值以获得更清晰和更少出错的结果；例如，不要使用`aNumber
    == aNumericString`，而是使用`aNumber === Number(aNumericString)`。
- en: Strict equality and inequality
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格相等和不相等
- en: The *strict equality* (`===`) and *strict inequality* (`!==`) operators in JavaScript
    are a staple of clean code. Unlike their abstract equality cousins, they provide
    certainty and simplicity in how they treat their operands.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的*严格相等*（`===`）和*严格不相等*（`!==`）运算符是清晰代码的重要组成部分。与其抽象相等的表亲不同，它们在处理操作数的方式上提供了确定性和简单性。
- en: 'The `===` operator will only ever return `true` if both of its operands are
    identical:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`===`运算符只有在其两个操作数完全相同时才会返回`true`：'
- en: '[PRE70]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The only exception to this rule is when either operand is `NaN`, in which case,
    it''ll return `false`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外是当其中一个操作数是`NaN`时，此时它将返回`false`：
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'No internal coercion will ever occur with strict equality, so even if you have
    two primitives that could be coerced to the same number, for example, they will
    still be considered inequal:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 严格相等不会进行任何内部强制转换，因此即使您有两个可以强制转换为相同数字的原始值，它们仍将被视为不相等：
- en: '[PRE72]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the case of non-primitives, both operands must refer to the exact same object:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非原始值，两个操作数必须引用完全相同的对象：
- en: '[PRE73]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Even if the object is of the equivalent structure or shares other characteristics,
    if it is not a reference to the same exact object, it''ll return `false`. We can
    illustrate this by attempting to compare a wrapped `Number` instance with a value
    of `3` to the numeric literal, `3`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对象具有相同的结构或共享其他特征，如果它不是对同一对象的引用，它将返回`false`。我们可以通过尝试将包装的`Number`实例与值为`3`的数值文字`3`进行比较来说明这一点：
- en: '[PRE74]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The abstract equality operator (`==`) would evaluate to true in such a case.
    You may consider the coercion of `new Number(3)` to `3` to be preferable, but
    it''s far better to explicitly set up your operands so that they are of the desired
    types before comparison. So, in the example of `String` that contains a numerical
    value that we wish to compare to `Number`, it would be best to first explicitly
    cast it via `Number()`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，抽象相等运算符（`==`）将评估为true。您可能认为将`new Number(3)`强制转换为`3`更可取，但最好在比较之前明确设置操作数，使它们具有所需的类型。因此，在包含我们希望与`Number`进行比较的数值的`String`的示例中，最好首先通过`Number()`明确转换它：
- en: '[PRE75]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: It is always advisable to use strict equality instead of abstract equality.
    It provides far more certainty and reliability in the outcome of every operation
    and allows you to free your mind from the myriad coercive behaviors that abstract
    equality entails.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 建议始终使用严格相等而不是抽象相等。它在每次操作的结果中提供了更多的确定性和可靠性，并且可以让您从抽象相等所涉及的多种强制行为中解脱出来。
- en: Greater than and less than
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大于和小于
- en: The *greater-than* (`>`), *less-than* (`<`), *greater-than-or-equal-to* (`>=`),
    and *less-than-or-equal-to* (`<=`) operators all operate in a similar manner.
    They follow an algorithm similar to abstract equality, although how values are
    coerced is slightly different.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*大于*（`>`）、*小于*（`<`）、*大于或等于*（`>=`）和*小于或等于*（`<=`）运算符都以类似的方式运行。它们遵循类似于抽象相等的算法，尽管值的强制转换方式略有不同。'
- en: The first thing to note is that all operands to these operators will first be
    coerced to their primitive representation. Following that, if their primitive
    representations are both strings, then they'll be compared lexicographically.
    If their primitive representations are not both strings, then they'll be coerced
    from whatever they are to numbers and then compared. This means that even if only
    one of your operands is a string, they'll both be compared numerically.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，这些运算符的所有操作数都将首先被强制转换为它们的原始表示。接下来，如果它们的原始表示都是字符串，那么它们将被词典顺序比较。如果它们的原始表示不都是字符串，那么它们将被从它们当前的类型转换为数字，然后再进行比较。这意味着即使你的操作数中只有一个是字符串，它们都将被数值比较。
- en: Lexicographic comparison
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词典比较
- en: Lexicographic comparison occurs when both operands are strings, and involves
    the character-by-character comparison of each string. Broadly, strings that are
    *greater* are those that would appear later in a dictionary. Therefore, *banana*
    would be lexicographically greater than *apple*.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 词典比较发生在两个操作数都是字符串时，并涉及每个字符串的逐个字符比较。广义上，*更大*的字符串是那些在字典中出现在后面的字符串。因此，*banana*在词典排序中将大于*apple*。
- en: 'As we discovered in [Chapter 6](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml),
    *Primitive and Built-In Types*, JavaScript uses UTF-16 to encode strings and therefore
    each codeunit is a 16-bit integer. The UTF-16 codeunits from `65` (`U+0041`) to `122` (`U+007A`) are
    as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第6章](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml)中发现的那样，*原始和内置类型*，JavaScript使用UTF-16来编码字符串，因此每个代码单元都是一个16位整数。UTF-16代码单元从`65`（`U+0041`）到`122`（`U+007A`）如下：
- en: '[PRE76]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Those characters appearing later are represented by larger UTF-16 integers.
    To compare any two given codeunits, JavaScript will simply compare their integer
    values. For the case of comparing `B` to `A`, this might look something like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 后面出现的字符由更大的UTF-16整数表示。要比较任意两个给定的代码单元，JavaScript将简单地比较它们的整数值。比如比较`B`和`A`，可能会像这样：
- en: '[PRE77]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Every character in each operand string must be compared. To do this, JavaScript
    will go codeunit-by-codeunit. At each index of each string, if codeunits differ,
    the larger codeunit will be considered greater, and that string will, therefore,
    be considered greater than the other:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作数字符串中的每个字符都必须进行比较。为了做到这一点，JavaScript将逐个代码单元地进行比较。在每个字符串的每个索引处，如果代码单元不同，较大的代码单元将被认为是更大的，因此该字符串将被认为比另一个字符串更大。
- en: '[PRE78]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And if one operand is equal to the prefix of the other, then it will always
    be considered *less than*, as shown here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个操作数等于另一个操作数的前缀，那么它将始终被认为是*小于*，如下所示：
- en: '[PRE79]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As you may have spotted, the lowercase English letters occupy higher UTF-16
    integers than uppercase letters. This has the effect of meaning that uppercase
    is considered less than lowercase and would, therefore, appear before it in a
    lexicographic ordering:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的那样，小写的英文字母占据了比大写字母更高的UTF-16整数。这意味着大写字母被认为比小写字母小，因此在词典排序中会出现在它的前面。
- en: '[PRE80]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You''ll also notice that the codeunits from `91` to `96` include the punctuation
    characters, `[\]^_``. This will also affect our lexicographic comparisons:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到从`91`到`96`的代码单元包括标点符号，`[\]^_``。这也会影响我们的词典比较。
- en: '[PRE81]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Unicode tends to be arranged in a way that any given language''s characters
    will be naturally sorted lexicographically so that the first symbols in a language''s
    alphabet are expressed by lower 16-bit integers than the later symbols. Here,
    we see, for example, the word for chicken (`"ไก่"`) in Thai is lexicographically
    less than the word for egg (`"ไข่"`) since the `ก` character appears before `ข` in
    the Thai alphabet:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode往往以一种方式排列，使得任何给定语言的字符在词典排序中自然排序，以便语言字母表中的第一个符号由比后面符号更低的16位整数表示。例如，在这里，我们看到泰语中“鸡”的单词（"ไก่"）在词典排序中小于“蛋”的单词（"ไข่"），因为`ก`字符在泰语字母表中出现在`ข`之前。
- en: '[PRE82]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The natural order of Unicode may not always yield a sensible lexicographic
    order. As we learned in the previous chapter, complex symbols can be expressed
    by combining together multiple codeunits into combining character pairs, surrogate
    pairs (creating *code points*), or even grapheme clusters. This can create various
    difficulties. One example would be the following case where a given symbol, in
    this case, *LATIN CAPITAL LETTER A WITH CIRCUMFLEX*, can be expressed either via
    the lone Unicode code-point `U+00C2` or via combining the capital letter `"A"` (`U+0041`)
    with the *COMBINING CHARACTER ACCEN**T* (`U+0302`). Symbolically and semantically,
    these are identical:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode的自然顺序可能并不总是产生合理的词典顺序。正如我们在上一章中学到的，复杂的符号可以通过将多个代码单元组合成组合字符对、代理对（创建*代码点*）或甚至是图形簇来表达。这可能会产生各种困难。一个例子是下面的情况，其中给定的符号，即*带抑扬符的拉丁大写字母A*，可以通过单一的Unicode代码点`U+00C2`或通过将大写字母`"A"`（`U+0041`）与*组合字符ACCEN**T*（`U+0302`）组合来表达。在符号上和语义上，它们是相同的：
- en: '[PRE83]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'However, since `U+00C2` (decimal: `194`) is technically larger than `U+0041` (decimal: `65`),
    it will be considered *greater than* in a lexicographic comparison, even though
    they are symbolically and semantically identical:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于`U+00C2`（十进制：`194`）在技术上大于`U+0041`（十进制：`65`），在词典比较中它将被认为是*大于*，即使它们在符号上和语义上是相同的。
- en: '[PRE84]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: There are thousands of these potential discrepancies to watch out for, so if
    you ever find yourself needing to compare lexicographically, be mindful that JavaScript's *greater-than* and *less-than* operators
    will be limited by Unicode's inherent ordering.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 有成千上万这样的潜在差异需要注意，因此如果你发现自己需要进行词典排序，要注意JavaScript的*大于*和*小于*运算符将受到Unicode固有排序的限制。
- en: Numeric comparison
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值比较
- en: 'Numeric comparison using JavaScript''s greater-than and less-than operators
    is fairly intuitive. As mentioned, your operands will be coerced first to their
    primitive representations, and then coerced a second time, explicitly, to a number.
    For cases where both operands are numbers, the result is entirely intuitive:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript的大于和小于运算符进行数字比较是相当直观的。如前所述，你的操作数首先会被强制转换为它们的原始表示形式，然后再次被显式地强制转换为数字。对于两个操作数都是数字的情况，结果是完全直观的：
- en: '[PRE85]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'And for `NaN` and `Infinity`, the following assertions can be made:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`NaN`和`Infinity`，可以做出以下断言：
- en: '[PRE86]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If one operand has a primitive representation that is not `Number`, then it
    will be coerced to `Number` before comparison. If you were to accidentally pass `Array` as
    an operand to `>`, then it would first coerce it to its primitive representation,
    which for arrays, is `String` with all individual coerced elements joined with
    a comma, and then attempt to coerce that to `Number`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个操作数具有不是`Number`的原始表示形式，则在比较之前将其强制转换为`Number`。如果你意外地将`Array`作为`>`的操作数传递，那么它首先会将其强制转换为其原始表示形式，对于数组来说，它是用逗号连接的所有单个强制转换元素的`String`，然后尝试将其强制转换为`Number`：
- en: '[PRE87]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Due to the potentially complicated coercions that may occur, it is always best
    to pass operands of the same type to `>`, `<`, `>=`, and `<=`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能发生的复杂强制转换，最好始终将相同类型的操作数传递给`>`、`<`、`>=`和`<=`。
- en: The instanceof operator
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: instanceof运算符
- en: 'The `instanceof` operator in JavaScript allows you to detect whether an object
    is an instance of a constructor:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的`instanceof`运算符允许你检测一个对象是否是构造函数的实例：
- en: '[PRE88]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This operation will climb the `[[Prototype]]` chain of its left-side operand
    looking for a specific `constructor` function. It will then check whether this
    constructor is equal to the right-side operand.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作将遍历其左侧操作数的`[[Prototype]]`链，寻找特定的`constructor`函数。然后它将检查这个构造函数是否等于右侧操作数。
- en: 'Since it climbs the `[[Prototype]]` chain, it can work safely with multiple
    inheritances:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它会遍历`[[Prototype]]`链，因此它可以安全地处理多重继承：
- en: '[PRE89]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If the *right-side* operand is not a function (that is, is not callable as
    a constructor), then `TypeError` will be thrown:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*右侧*操作数不是函数（即不可调用为构造函数），那么将抛出TypeError：
- en: '[PRE90]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `instanceof` operator is sometimes useful in discerning native types such
    as whether an object is an array:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`运算符有时在区分原生类型方面很有用，比如判断一个对象是否是数组：'
- en: '[PRE91]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This usage, however, has been largely replaced by `Array.isArray()`, which is
    generally more trustworthy as it will work correctly in rare cases where `Array` has
    been passed to you from another native context such as a frame (within the browser).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种用法已经在很大程度上被`Array.isArray()`取代，后者通常更可靠，因为它在`Array`被从另一个原生上下文（例如浏览器中的帧）传递给你的罕见情况下会正确工作。
- en: The in operator
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: in运算符
- en: 'The `in` operator will return `true` if a property can be found in an object:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在对象中找到属性，则`in`运算符将返回`true`：
- en: '[PRE92]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The *left-side* operand will be coerced to its primitive representation, which,
    if not `Symbol`, will be coerced to `String`. Here, we can see how a left-side
    operand that is `Array` will be coerced into a comma-separated serialization of
    its contents (the native and default way that arrays are coerced to primitives,
    thanks to `Array.prototype.toString`):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*左侧*操作数将被强制转换为其原始表示形式，如果不是`Symbol`，它将被强制转换为`String`。在这里，我们可以看到`Array`作为左侧操作数将被强制转换为其内容的逗号分隔序列（这是数组被强制转换为原始值的本机和默认方式，感谢`Array.prototype.toString`）：'
- en: '[PRE93]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'All seemingly numeric property names in JavaScript are stored as strings, so
    accessing `someArray[0]` is equal to `someArray["0"]`, and therefore enquiring
    as to whether an object has a numeric property with `in` will also consider both `0` and `"0"` equally:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，所有看似是数字的属性名称都以字符串形式存储，因此访问`someArray[0]`等同于`someArray["0"]`，因此询问对象是否具有数字属性时，`in`也将同样考虑`0`和`"0"`：
- en: '[PRE94]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'When establishing whether a property is in a given object, the `in` operator
    will traverse the entire `[[Prototype]]` chain, hence returning `true` for all
    accessible methods and properties at all levels of the chain:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定给定对象中是否存在属性时，`in`运算符将遍历整个`[[Prototype]]`链，因此对链中所有级别的可访问方法和属性都返回`true`：
- en: '[PRE95]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This means that if you''re looking to distinguish between the concepts of *having
    a property* and *having a property on itself*, you should instead use `hasOwnProperty`,
    a method inherited from `Object.prototype` that will only check the object itself:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你想区分*具有属性*和*具有自身属性*的概念，你应该使用`hasOwnProperty`，这是从`Object.prototype`继承的方法，它只会检查对象本身：
- en: '[PRE96]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: On the whole, it is best to only use `in` if you're confident that there are no
    collisions with the property names you expect to use and properties provided by
    the object's `[[Prototype]]` chain. Even if you're just using plain objects, you
    still need to worry about the native prototype. If it's been modified in any way
    (by a utility library, for example), then you can no longer have a high level
    of trust in the results of your `in` operations and should hence use `hasOwnProperty`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，最好只在你确信不会与你期望使用的属性名称和对象的[[Prototype]]链提供的属性发生冲突时才使用`in`。即使你只是使用普通对象，你仍然需要担心原生原型。如果它以任何方式被修改（例如通过实用程序库），那么你就不能再对你的`in`操作的结果有很高的信任度，因此应该使用`hasOwnProperty`。
- en: 'In older library code, you may even find code that chooses not to rely on `hasOwnProperty` on
    the object of inquiry, fearing that it may have been overridden. Instead, it''ll
    opt for using the `Object.prototype.hasOwnProperty` method directly and calls
    it with that object as its execution context:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的库代码中，甚至可能会发现选择不依赖于被查询对象的`hasOwnProperty`的代码，因为害怕它可能已被覆盖。相反，它将选择直接使用`Object.prototype.hasOwnProperty`方法，并以该对象作为其执行上下文调用它：
- en: '[PRE97]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This is likely overly-cautious though. It's safe enough in most code bases and
    environments to trust and use the inherited `hasOwnProperty`. The `in` operator
    as well, if you've considered the risks, is usually safe enough to use.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这可能过于谨慎了。在大多数代码库和环境中，使用继承的`hasOwnProperty`是足够安全的。同样，如果你考虑了风险，`in`运算符通常也是足够安全的。
- en: Assignment operators
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: 'An assignment operator will assign the value of its right-side operand to its
    left-side operand and will return the newly assigned value. The left-side operand
    of an assignment operation must always be an assignable and valid identifier or
    property. Examples of this would include the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符将其右侧操作数的值赋给其左侧操作数，并返回新赋的值。赋值操作的左侧操作数必须始终是可分配的有效标识符或属性。例如：
- en: '[PRE98]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You can additionally use *destructuring assignment,* which enables you to declare
    your *left-side* operand as either an object-literal-like or array-like structure
    that designates the identifiers you wish to assign and the values you wish to
    be assigned:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用*解构赋值*，它使您能够将*左侧*操作数声明为类似对象文字或数组的结构，指定您希望分配的标识符和您希望分配的值：
- en: '[PRE99]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We will explore *destructuring assignment* further in a little bit. For now,
    it's only important to know that it, along with regular identifiers (`foo=...`)
    and property accessors (`foo.baz = ...`, `foo[baz] = ...`), can be used as the
    left-side operand to an assignment operator.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍后进一步探讨*解构赋值*。现在，重要的是要知道它，以及常规标识符（`foo=...`）和属性访问器（`foo.baz = ...`，`foo[baz]
    = ...`），都可以用作赋值运算符的左侧操作数。
- en: 'There are technically a large number of assignment operators because JavaScript
    combines regular operators with the basic assignment operator to create more succinct
    assignment operations in the common case of needing to mutate the value referred
    to by an existing variable or property. The assignment operators in JavaScript
    are as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，JavaScript 中有大量的赋值运算符，因为它将常规运算符与基本赋值运算符结合起来，以在常见情况下需要改变现有变量或属性所引用的值时创建更简洁的赋值操作。JavaScript
    中的赋值运算符如下：
- en: '**Direct assignment**: `=`'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接赋值：`=`
- en: '**Additive assignment**: ``+=``'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法赋值：`+=`
- en: '**Subtractive assignment**: `-=`'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减法赋值：`-=`
- en: '**Multiplicative assignment**: `*=`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法赋值：`*=`
- en: '**Divisive assignment**: `/=`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除法赋值：`/=`
- en: '**Remainder assignment**: `%=`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 余数赋值：`%=`
- en: '**Bitwise left-shift assignment**: `<<=`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位左移赋值：`<<=`
- en: '**Bitwise right-shift assignment**: `>>=`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位右移赋值：`>>=`
- en: '**Bitwise unsigned right-shift assignment**: `>>>=`'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位无符号右移赋值：`>>>=`
- en: '**Bitwise AND assignment**: `&=`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位与赋值：`&=`
- en: '**Bitwise XOR assignment**: `^=`'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位异或赋值：`^=`
- en: '**Bitwise OR assignment**: `|=`'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位或赋值：`|=`
- en: 'All assignment operators, apart from the direct assignment `=` operator, will
    conduct the operation that is indicated by the operator preceding `=`. So, in
    the case of `+=`, the `+` operator will be applied to the left-and right-side operands,
    the result of which will then be assigned to the left-side operand. So, consider
    the following statement:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接赋值`=`运算符外，所有赋值运算符都会执行`=`之前指示的操作。因此，在`+=`的情况下，`+`运算符将应用于左右操作数，然后将结果分配给左侧操作数。因此，考虑以下语句：
- en: '[PRE100]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'It would be equivalent to:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 它将等同于：
- en: '[PRE101]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The same follows for all other assignment operators that are of the combined
    type. The addition operator, as we know, will concatenate its operands if either
    is a string. And the exponentiation operator (`**`) will always evaluate to `1` if
    the exponent operand is zero (`2 ** 0 === 1`). We can rely on this and other existing
    knowledge to know how such operators will work when combined with assignment.
    We, therefore, don't need to individually explore all of these assignment operator
    variants.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他组合类型的赋值运算符也是一样的。我们可以依靠这一点和其他已有的知识来了解这些运算符与赋值结合时的工作方式。因此，我们不需要单独探索所有这些赋值运算符的变体。
- en: 'Assignment conventionally occurs in the context of a singular line. It''s typical
    to see an assignment statement on its own terminated by a semicolon:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值通常发生在单行的上下文中。通常会看到一个赋值语句单独出现，并以分号结束：
- en: '[PRE102]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'But there''s nothing implicit in the assignment operator that requires this.
    In fact, you can embed an assignment anywhere where you would be able to embed
    any expression within the language. The following syntax would be entirely legal,
    for example:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 但赋值运算符并没有隐含要求这样做。事实上，你可以在语言中任何可以嵌入任何表达式的地方嵌入赋值。例如，以下语法是完全合法的：
- en: '[PRE103]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This is carrying out an addition combined with an assignment, and then passing
    the resulting value to the `processStep` function. It is exactly equivalent to
    the following code:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这是进行加法和赋值，然后将结果值传递给`processStep`函数。这与以下代码完全等效：
- en: '[PRE104]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Note here how it is `nextValue` that is passed to `processStep`. The result
    of an assignment operation expression is always the value being assigned:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这里传递给`processStep`的是`nextValue`。赋值操作表达式的结果始终是被赋的值：
- en: '[PRE105]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'It is common to see assignment in contexts of `for` and `while` loops:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`和`while`循环的上下文中经常看到赋值的情况：
- en: '[PRE106]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This and other patterns of assignment are totally fine as they are so widely
    used they have become idiomatic of JavaScript. But in most other situations, it
    is preferable not to embed assignment within other language constructs. Code such
    as `fn(a += b)` is potentially unintuitive to some, as it may not be clear what
    value is actually passed to `fn()`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这和其他赋值模式都是完全可以接受的，因为它们被广泛使用，已经成为 JavaScript 的习惯用法。但在大多数其他情况下，最好不要在其他语言结构中嵌入赋值。例如`fn(a
    += b)`这样的代码对一些人来说可能不直观，因为可能不清楚实际传递给`fn()`的值是什么。
- en: In regard to clean code, the only question we need to ask ourselves when assigning
    values is whether the reader of our code (*including us!*) will find it obvious
    that assignment is occurring and whether they'll understand *what* is being assigned.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写干净的代码方面，我们在分配值时唯一需要问自己的问题是，我们的代码的读者（包括我们自己！）是否会发现分配正在发生，以及他们是否会理解正在分配的*是什么*。
- en: Increment and decrement (prefix and postfix) operators
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增量和减量（前缀和后缀）运算符
- en: 'These four operators technically fall under the umbrella of assignment but
    they are unique enough to warrant their own section:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个运算符在技术上属于赋值的范畴，但它们足够独特，值得有自己的部分：
- en: The postfix increment operator (`value++`)
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后缀增量运算符（`value++`）
- en: The postfix decrement operator (`value--`)
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后缀减量运算符（`value--`）
- en: The prefix increment operator (`++value`)
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀增量运算符（`++value`）
- en: The prefix decrement operator (`--value`)
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀减量运算符（`--value`）
- en: These will simply increment or decrement the value by `1`. They're usually found
    in iteration contexts such as `for` or `while` loops. They are best thought of
    as succinct alternatives to additive and subtractive assignment (that is, `value
    += 1` or `value -= 1`). However, they have a couple of unique characteristics
    that are worth covering.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将简单地增加或减少`1`的值。它们通常出现在迭代上下文中，例如`for`或`while`循环中。最好将它们视为对加法和减法赋值的简洁替代方法（即`value
    += 1`或`value -= 1`）。然而，它们有一些独特的特点值得探讨。
- en: Prefix increment/decrement
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前缀增量/减量
- en: 'The prefix increment and decrement operators allow you to increment or decrement
    any given value and will evaluate to the newly incremented value:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀增量和减量运算符允许您增加或减少任何给定的值，并将评估为新增的值：
- en: '[PRE107]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`++n` would technically be equivalent to the following additive assignment:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`++n`在技术上等同于以下的加法赋值：'
- en: '[PRE108]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Note how the current value of `n` is first converted into `Number`. This is
    the nature of both the increment and decrement operators: they operate strictly
    on numbers. So, if `n` were `String`, that could not be coerced successfully,
    then the new incremented or decremented value of `n` would be `NaN`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当前的`n`值首先被转换为`Number`。这就是增量和减量运算符的性质：它们严格作用于数字。因此，如果`n`是`String`，那么无法成功强制转换，那么`n`的新增值或减量值将是`NaN`：
- en: '[PRE109]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Here, we can observe how, since the coercion of `foo` to a `Number` fails, the
    attempted incrementation of it also fails, returning `NaN`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以观察到，由于将`foo`强制转换为`Number`失败，因此对其尝试增加也失败，返回`NaN`。
- en: Postfix increment/decrement
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后缀增量/减量
- en: 'The postfix variants of the increment and decrement operators are identical
    to the prefix variants, except for one fact: the postfix variants will evaluate
    to the old value, not the newly incremented/decremented value:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 增量和减量运算符的后缀变体与前缀变体相同，只有一个区别：后缀变体将评估为*旧*值，而不是新增/减量后的值：
- en: '[PRE110]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This is crucial and can, if not used intentionally, lead to undesirable bugs.
    Increment and decrement operators are usually used in contexts where this difference
    is irrelevant. For example, when used in the last expression of a `for (_;_;_)` statement,
    the return value is not used anywhere, so we''d see no difference between the
    two following approaches:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这是至关重要的，如果不是有意使用，可能会导致不希望的错误。增量和减量运算符通常用于在这种差异无关紧要的情况下。例如，在`for (_;_;_)`语句的最后一个表达式中使用时，返回值在任何地方都没有使用，因此我们在以下两种方法之间看不到任何区别：
- en: '[PRE111]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'However, in other circumstances, the evaluated value is absolutely key. In
    the following `while` loop, for example, the `++i < array.length` expression is
    evaluated on every iteration, meaning that the newly incremented value is compared
    to `array.length`. If we swapped this for `i++ < array.length`, then you''d be
    comparing the value before incrementing, meaning that it''d be one less and hence
    we''d get an additional (unwanted!) iteration. You can observe the difference
    here:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在其他情况下，评估的值是非常关键的。例如，在下面的`while`循环中，`++i < array.length`表达式在每次迭代时都会被评估，这意味着新增的值将与`array.length`进行比较。如果我们将其替换为`i++
    < array.length`，那么你将比较增量之前的值，这意味着它会少一个，因此我们会得到额外的（不需要的！）迭代。你可以在这里观察到区别：
- en: '[PRE112]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This is quite a rare occurrence, especially with more modern iteration techniques
    available in the language. But the increment and decrement operators are still
    very popular in other contexts, so it's useful to appreciate the difference between
    their prefix and postfix variants.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当罕见的情况，特别是在语言中提供了更现代的迭代技术。但是增量和减量运算符在其他情境中仍然非常受欢迎，因此了解它们的前缀和后缀变体之间的区别是很有用的。
- en: Destructuring assignment
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构赋值
- en: 'As briefly mentioned, the left-side operand of an assignment operator (`...
    =`) can be specified as a destructuring object or array pattern, like so:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，赋值运算符（`... =`）的左操作数可以指定为解构对象或数组模式，如下所示：
- en: '[PRE113]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: These patterns typically look like `Object` or `Array` literals as they start
    and end with `{}` and `[]` respectively. They are, however, slightly different.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式通常看起来像`Object`或`Array`字面量，因为它们分别以`{}`和`[]`开头和结尾。但它们有些微的不同。
- en: 'With the destructuring object pattern, where you want to declare the identifier
    or property you wish to assign to, you must place it as if it were a value in
    an object literal. That is, where `{ foo: bar }` usually means assign `bar` *to*
    `foo`, in a *destructuring pattern*, it means *assign the value of* `foo` *to
    the identifier, *`bar`. It is reversed. Where the name of the property of the
    value you wish to access matches the name that you wish to be assigned in the
    local scope, you can use a shorter syntax of simply `{ foo }`, as shown here:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '在解构对象模式中，当你想要声明要分配的标识符或属性时，你必须将它放置在对象字面量中的值的位置。也就是说，`{ foo: bar }`通常意味着将`bar`分配给`foo`，在*解构模式*中，它意味着*将`foo`的值分配给标识符`bar`。它是相反的。当你希望访问的值的属性名称与你希望在本地范围内分配的名称匹配时，你可以使用更短的语法，如`{
    foo }`，如下所示：'
- en: '[PRE114]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'For arrays, the slots of syntax where you would usually designate the values
    (that is, `[here, here, and here]`) are used to designate the identifiers to which
    you wish to assign your values, so each identifier in a sequence relates to the
    same index elements in the array:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组，通常用于指定值的语法槽（即`[这里，这里和这里]`）用于指定要分配值的标识符，因此序列中的每个标识符与数组中的相同索引元素相关联：
- en: '[PRE115]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'You can also use the rest operator (`...foo`) to instruct JavaScript to assign
    the *rest* of the properties to a given identifier. Here''s an example of using
    it within the *destructuring array pattern*:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用剩余运算符（`...foo`）指示JavaScript将*剩余*的属性分配给给定的标识符。以下是在*解构数组模式*中使用它的示例：
- en: '[PRE116]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'And here''s an example of using it within the* destructuring object pattern*:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在*解构对象模式*中使用它的示例：
- en: '[PRE117]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Only destructure your assignments when it provides *genuine* increased readability
    and simplicity.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在提供*真正*增加可读性和简单性时才解构你的赋值。
- en: 'Destructuring can also occur for object structures that involve multiple levels
    of hierarchy:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 解构也可以发生在涉及多层次层次结构的对象结构中：
- en: '[PRE118]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'If we wish to extract the `inhabitants` array and assign it to a variable of
    the same name, then we can do the following:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望提取`inhabitants`数组并将其赋值给同名变量，那么可以这样做：
- en: '[PRE119]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'And a *destructuring array pattern* can be embedded in a *destructuring object
    pattern* and vice versa:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '*解构数组模式*可以嵌套在*解构对象模式*中，反之亦然：'
- en: '[PRE120]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '*Destructuring assignment* is very useful in avoiding otherwise length, assignments
    like this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 解构赋值非常有用，可以避免像这样的冗长赋值：
- en: '[PRE121]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'However, it should be used with reservation as it can sometimes overcomplicate
    things for those who have to read your code. While it may appear intuitive when
    writing it for the first time, *destructuring assignments* are notoriously difficult
    to untangle. Consider the following statement:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，应该谨慎使用它，因为它有时会使阅读您的代码的人感到困惑。虽然在第一次编写时可能看起来直观，但*解构赋值*通常很难理清。考虑以下声明：
- en: '[PRE122]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This is cognitively expensive to untangle. It would, perhaps, be more intuitive
    to express this logic traditionally:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这在认知上是昂贵的。也许，用传统方式表达这个逻辑会更直观：
- en: '[PRE123]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: On the whole, *destructuring assignment* is an exciting and useful feature of
    the JavaScript language, but it should be used in a guarded way with consideration
    of the possibility of the confusion it can cause.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，*解构赋值*是JavaScript语言中一个令人兴奋和有用的特性，但应该以谨慎的方式使用，考虑到它可能引起混淆的可能性。
- en: Property access operators
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性访问运算符
- en: 'Accessing properties in JavaScript is achieved by using one of two operators:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用两种运算符之一来实现JavaScript中的属性访问：
- en: '**Direct property access**: `obj.property`'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接属性访问：`obj.property`
- en: '**Computed property access**: `obj[property]`'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算属性访问**：`obj[property]`'
- en: Direct  property access
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接属性访问
- en: 'The syntax for directly accessing a property is a single period character,
    with a *left-side* operand that is the object you wish to access, and with a *right-side*
    operand that is the property name you wish to access:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 直接访问属性的语法是一个单独的句点字符，左侧操作数是你希望访问的对象，右侧操作数是你希望访问的属性名称：
- en: '[PRE124]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The *right-side* operand must be a valid JavaScript identifier, and as such,
    cannot start with a number, cannot contain whitespace, and in general, cannot
    contain any punctuation characters that exist elsewhere within the JavaScript
    specification. You can, however, have properties that are named with so-termed
    exotic Unicode characters such as π (`PI`):'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '*右侧*操作数必须是有效的JavaScript标识符，因此不能以数字开头，不能包含空格，并且一般情况下不能包含JavaScript规范中其他地方存在的任何标点符号字符。但是，你可以拥有以所谓的外来Unicode字符命名的属性，例如π（`PI`）：'
- en: '[PRE125]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This is an unconventional practice and is usually only used in novelty settings.
    It may, however, be genuinely useful in code that is embedded in problem domains
    where there are legitimate exotic symbols with existing meanings (*mathematics*,
    *physics*, and so on).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种不寻常的做法，通常只在新颖的设置中使用。然而，在嵌入了存在现有含义的合法外来符号（*数学*、*物理*等）的问题域中，它可能确实有用。
- en: Computed property access
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性访问
- en: 'In cases where you cannot directly access a property via *direct property access*,
    it is possible to compute the property name you wish to access, delimiting it
    with square brackets:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法通过*直接属性访问*直接访问属性的情况下，可以计算要访问的属性名称，并用方括号括起来：
- en: '[PRE126]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'It''s a *right-si**de* operand of any expression, meaning that you can freely
    compute some value that''ll then be coerced to a string (if it is not already
    a string) and used as the property name to access the object:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 它是任何表达式的*右侧*操作数，这意味着你可以自由计算一些值，然后将其强制转换为字符串（如果它还不是字符串），并用作要访问的对象的属性名称：
- en: '[PRE127]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Typically this is used to access property names that contain characters that
    make them invalid identifiers, and hence illegal to use with the *direct property
    access* operator. This would include numeric property names (such as those found
    in an array), names with whitespace, or names with punctuation or keywords that
    exist elsewhere in the language:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 通常用于访问包含使它们无效的字符的属性名称，因此无法与*直接属性访问*运算符一起使用。这包括数字属性名称（例如在数组中找到的属性名称）、带有空格的名称或在语言中其他地方存在标点符号或关键字的名称：
- en: '[PRE128]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: It is best to only rely on computed property access in scenarios when you have
    no other choice. If there is the possibility of just accessing the property directly
    (that is, `object.property`), then you should prefer that. Likewise, if you're
    deciding what properties an object might contain, it's best to use names that
    are valid identifiers within the language so they can be directly accessed with
    ease.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 最好只在没有其他选择的情况下依赖计算属性访问。如果可能直接访问属性（即`object.property`），那么应该优先考虑这种方式。同样，如果你正在决定对象可能包含的属性，最好使用语言内有效的标识符名称，这样可以方便直接访问。
- en: Other operators and syntax
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他运算符和语法
- en: 'There are a few remaining operators and pieces of syntax that we have yet to
    explore and that don''t fall into any other operator category:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些剩下的运算符和语法要探讨，它们不属于任何其他运算符类别：
- en: '**The delete operator**: `delete VALUE`'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除操作符**：`delete VALUE`'
- en: '**The void operator**: `void VALUE`'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**void操作符**：`void VALUE`'
- en: '**The new operator**: `new VALUE`'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**new操作符**：`new VALUE`'
- en: '**Spread syntax**: `... VALUE`'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**展开语法**：`... VALUE`'
- en: '**Grouping**: `(VALUE)`'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分组**：`(VALUE)`'
- en: '**The comma operator**: `VALUE, VALUE, ...`'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逗号操作符**：`VALUE, VALUE, ...`'
- en: The delete operator
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除操作符
- en: 'The `delete` operator can be used to remove properties from objects, as such
    its only operand usually takes the form of a property accessor, like so:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`操作符可以用来从对象中删除属性，因此它的唯一操作数通常采用属性访问器的形式，如下所示：'
- en: '[PRE129]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Only properties that are deemed configurable can be deleted in this manner.
    All properties added conventionally are, by default, configurable and can, therefore,
    be deleted:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 只有被视为可配置的属性才能以这种方式被删除。所有传统添加的属性默认都是可配置的，因此可以被删除：
- en: '[PRE130]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'However, if the property has been added via `defineProperty` with `configurable` set
    to `false`, then it''ll not be deletable:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果属性是通过`defineProperty`添加的，并且`configurable`设置为`false`，那么它将无法被删除：
- en: '[PRE131]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: As you can see, the `delete` operator evaluates to `true` or `false` depending
    on whether the property has been successfully deleted. Following successful deletion,
    the property is not merely set to `undefined` or `null` but is entirely removed
    from the object so that checking its existence via `in` will return `false`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`delete`操作符根据属性是否成功删除而评估为`true`或`false`。在成功删除后，属性不仅仅被设置为`undefined`或`null`，而是完全从对象中删除，因此通过`in`检查其存在性将返回`false`。
- en: 'The `delete` operator can technically be used to delete any variable (or so-termed
    *environment record binding* internally), but attempting to do so is considered
    a deprecated behavior and will produce `SyntaxError` in strict mode:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`操作符在技术上可以用来删除任何变量（或者内部所谓的*环境记录绑定*），但尝试这样做被认为是不推荐的行为，并且在严格模式下会产生`SyntaxError`：'
- en: '[PRE132]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The `delete` operator has historically been the subject of many inconsistencies
    between JavaScript implementations, most especially between different browsers.
    Because of this, only its conventional usage of deleting properties on objects
    is advisable.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`操作符在JavaScript实现之间历史上存在许多不一致，尤其是在不同的浏览器之间。因此，只有在对象上删除属性的常规用法是可取的。'
- en: The void operator
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: void操作符
- en: 'The `void` operator will evaluate to `undefined` regardless of its operand.
    Its operand can be any valid reference or expression:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`操作符将评估为`undefined`，无论其操作数是什么。它的操作数可以是任何有效的引用或表达式：'
- en: '[PRE133]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: It doesn't have many uses nowadays, although `void 0` is sometimes used as an
    idiom for `undefined` either for succinctness or to avoid issues in legacy environments
    where `undefined` was an untrusted mutable value.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 它现在用途不多，尽管`void 0`有时被用作`undefined`的习语，要么是为了简洁，要么是为了避免在旧环境中`undefined`是一个不受信任的可变值的问题。
- en: The new operator
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新操作符
- en: 'The `new` operator is used to form an instance from a constructor. Its *right-side*
    operand must be a valid constructor, either provided by the language (for example, `new
    String()`) or by ourselves:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`操作符用于从构造函数形成一个实例。它的*右侧*操作数必须是一个有效的构造函数，可以是语言提供的（例如`new String()`）或者自己提供的：'
- en: '[PRE134]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'By *instance,* what we truly mean is an object that has a `[[Prototype]]` equal
    to the constructor''s `prototype` property, and that has been passed to the constructor
    as its `this` binding so that the constructor can fully prepare it for its purpose.
    Observe here how, whether we define our constructor via a class definition or
    conventional syntax, we can make the same assertions about the produced instances:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*实例*，我们真正的意思是一个对象，它的`[[Prototype]]`等于构造函数的`prototype`属性，并且已经作为它的`this`绑定传递给构造函数，以便构造函数可以完全准备好它的目的。请注意，无论我们是通过类定义还是传统语法定义构造函数，我们都可以对产生的实例做出相同的断言：
- en: '[PRE135]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The `new` operator only cares that its *right-side* operand is constructible.
    This means it cannot be a function formed by an arrow function, as in this example:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`操作符只关心它的*右侧*操作数是否可构造。这意味着它不能是由箭头函数形成的函数，就像这个例子：'
- en: '[PRE136]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'As long as you''ve defined your constructor using a function expression or
    declaration, it''ll work fine. You can even instantiate an anonymous inline constructor
    if you want:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你使用函数表达式或声明定义了构造函数，它就可以正常工作。如果你愿意，甚至可以实例化一个匿名内联构造函数：
- en: '[PRE137]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The `new` operator does not formally require the calling parentheses. They
    only need to be included if you are passing arguments to the constructor:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`操作符不正式需要调用括号。只有在你传递参数给构造函数时才需要包括它们：'
- en: '[PRE138]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'When you wish to instantiate something and then immediately access a property
    or method, however, you''d need to disambiguate by providing the calling parentheses
    and *then* accessing the property following that; otherwise, you''d receive `TypeError`:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你希望实例化某些东西然后立即访问属性或方法时，你需要通过提供调用括号来消除歧义，*然后*在其后访问属性；否则，你会收到`TypeError`：
- en: '[PRE139]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The usage of the `new` operator is usually very straightforward. Semantically,
    it is understood to relate to the construction of an instance and should therefore
    ideally only be used to do that. It''s also, therefore, assumed that anything
    being referenced by the *right-side* operand of `new` is identified with a name
    beginning with a capital letter and is a noun. These naming conventions indicate
    that it is a constructor, providing a useful hint to any programmers who may wish
    to use it. Here are some examples of both good and bad constructor names:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`操作符的使用通常非常简单。从语义上讲，它被理解为与实例的构造有关，因此理想情况下只应该用于这个目的。因此，假定`new`的*右侧*操作数引用的任何东西都以大写字母开头并且是一个名词。这些命名约定表明它是一个构造函数，为希望使用它的任何程序员提供了有用的提示。以下是一些好的和坏的构造函数名称的示例：'
- en: '[PRE140]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The correct naming of a constructor is crucial. It makes our fellow programmers
    immediately aware of what *contract* a specific abstraction fulfills. If we name
    a constructor so that it appears like a regular function, then our colleagues
    may try to invoke it incorrectly and suffer possible errors as a result. It, therefore,
    makes perfect sense to take advantage of a name's ability to communicate *contract*,
    as discussed in the earlier chapter on naming ([Chapter 5](cf2c2cfc-6b5e-48a3-a7ef-99169bd9067d.xhtml), *Naming
    Things is Hard*).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 正确命名构造函数至关重要。它使我们的同行程序员立即意识到特定抽象满足的*合同*是什么。如果我们命名一个构造函数，使其看起来像一个常规函数，那么我们的同事可能会尝试不正确地调用它，并因此遭受可能的错误。因此，利用名称传达*合同*的能力是完全有道理的，正如在前一章关于命名的讨论中所述（[第5章](cf2c2cfc-6b5e-48a3-a7ef-99169bd9067d.xhtml)，*命名很难*）。
- en: The spread syntax
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展开语法
- en: 'The *spread syntax* (also known as *rest syntax*) is composed of three dots
    followed by an operand expression (`...expression`). It allows the expression
    to be expanded in places where either multiple arguments or multiple array elements
    are expected. It technically exists in five distinct areas of the language:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '*展开语法*（也称为*rest语法*）由三个点组成，后面跟着一个操作数表达式（`...expression`）。它允许在需要多个参数或多个数组元素的地方展开表达式。它在语言的五个不同领域中存在：'
- en: In *array literals*, of the form `array = [a, b, c, ...otherArray]`
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*数组文字*中，形式为`array = [a, b, c, ...otherArray]`
- en: In *object literals*, of the form `object = {a, b, c, ...otherObject}`
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*对象文字*中，形式为`object = {a, b, c, ...otherObject}`
- en: In *function parameter lists*, in the form `function(a, b,  c, ...otherArguments)
    {}`
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*函数参数列表*中，形式为`function(a, b,  c, ...otherArguments) {}`
- en: In *destructuring array patterns*, in the form `[a,  b, c, ...others] = array`
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*解构数组模式*中，形式为`[a, b, c, ...others] = array`
- en: In *destructuring object patterns*, in the form `{a, b, c, ,,,otherProps} =
    object`
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*解构对象模式*中，形式为`{a, b, c, ,,,otherProps} = object`
- en: 'In the context of a *function parameter list*, the *spread syntax* must be
    the very last parameter and would indicate that you wish for all arguments passed
    to the function from that point onward to be collected into a singular array by
    the name indicated:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在*函数参数列表*的上下文中，*展开语法*必须是最后一个参数，并且表示您希望从那时起传递给函数的所有参数都被收集到一个由指定名称的单一数组中。
- en: '[PRE141]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'If you attempt to use it amid other parameters, then you will receive `SyntaxError`:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在其他参数中使用它，那么您将收到“SyntaxError”：
- en: '[PRE142]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'In the context of an *array literal* or a *destructuring array pattern*, the
    *spread syntax* is similarly used to indicate that the values referred to should
    be spread out. It''s best to see these as two opposites, *deconstruction* and *reconstruction*:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在*数组文字*或*解构数组模式*的上下文中，*展开语法*同样用于指示所引用的值应该展开。最好将这两者看作是两种相反的操作，*解构*和*重构：
- en: '[PRE143]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'When used in the context of an *array literal* or a *destructuring array pattern*, the
    *spread syntax* must refer to an iterable value. This doesn''t necessarily have
    to be an array. Strings, as an example, are iterable, so the following also works:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 当在*数组文字*或*解构数组模式*的上下文中使用时，*展开语法*必须指向可迭代的值。这不一定是一个数组。例如，字符串是可迭代的，所以下面的也可以工作：
- en: '[PRE144]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'In the context of an *object literal* or a *d**estructuring object pattern*,
    the *spread syntax* is similarly used to spread out all properties of any given
    object into the receiving object. Once again, we can see this as processes of *deconstruction* and *reconstruction*:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在*对象文字*或*d**estructuring对象模式*的上下文中，*展开语法*同样用于将任何给定对象的所有属性展开到接收对象中。再次，我们可以将这看作是*解构*和*重构*的过程：
- en: '[PRE145]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'When used in this context, the value of the right side of the *spread syntax*
    must be either an object or a primitive that can be wrapped as an object (for
    example, `Number` or `String`). This means that all values in JavaScript are permissible
    except `null` and `undefined`, both of which, as we know, cannot be wrapped as
    objects:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下使用*展开语法*的右侧值必须是一个对象或可以包装为对象的原始值（例如，`Number`或`String`）。这意味着JavaScript中的所有值都是允许的，除了`null`和`undefined`，我们知道这两者都不能被包装为对象：
- en: '[PRE146]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: It's, therefore, best to only use the *spread syntax* in an object context when
    you're confident that the value is an object.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好只在对象上下文中使用*展开语法*，当您确信该值是一个对象时。
- en: In conclusion, the *spread syntax*, as we've seen, is remarkably useful in a
    variety of different situations. Its main advantage is that it reduces the amount
    of syntax required to extract and designate values.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，正如我们所看到的，*展开语法*在各种不同的情况下都非常有用。它的主要优势在于它减少了提取和指定值所需的语法量。
- en: The comma operator
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逗号运算符
- en: The comma operator (`a, b`) accepts a left-side and right-side operand and will
    always evaluate to its right-side operand. It is sometimes not considered an operator
    since it does not technically operate on its operands. It's also quite rare.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号运算符（`a, b`）接受左侧和右侧操作数，并始终计算为其右侧操作数。有时它不被认为是一个运算符，因为它在技术上不对其操作数进行操作。它也非常罕见。
- en: The comma operator should not be confused with the comma we use to separate
    arguments when declaring or invoking a function (for example `fn(a,b,c)`), the
    comma used when creating array literals and object literals (for example `[a,
    b, c]`), or the comma used when declaring variables (for example `let a, b, c;`).
    The comma operator is distinct from all of these.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号运算符不应与我们在声明或调用函数时用来分隔参数的逗号（例如`fn(a,b,c)`），在创建数组文字和对象文字时使用的逗号（例如`[a, b, c]`），或者在声明变量时使用的逗号（例如`let
    a, b, c;`）混淆。逗号运算符与所有这些都不同。
- en: 'It''s most commonly seen in the iteration statement portion of a `for(;;)` loop:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 它最常见于`for(;;)`循环的迭代语句部分：
- en: '[PRE147]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Note how three increment operations are occurring in the third statement (which
    occurs at the end of each iteration in a conventional `for(;;)` statement), and
    that they are each separated by a comma. In this context, the comma is used merely
    to ensure that all of these individual operations will occur, regardless of each
    other, within the context of a singular statement. In regular code outside a `for(;;)` statement,
    you would likely just have these each dedicated to their own line and statement,
    like so:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意第三个语句中发生的三次递增操作（在传统的`for(;;)`语句的每次迭代结束时发生），它们之间都用逗号分隔。在这种情况下，逗号仅用于确保所有这些单独的操作将在一个单一语句的上下文中发生，而不受彼此的影响。在`for(;;)`语句之外的常规代码中，你可能只会将它们分别放在自己的行和语句中，如下所示：
- en: '[PRE148]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: However, due to the constraints of the `for(;;)` syntax, they must all exist
    within a singular statement and so the comma operator becomes necessary.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于`for(;;)`语法的限制，它们必须存在于一个单一的语句中，因此逗号操作符变得必要。
- en: 'The fact that the comma operator evaluates to its *right-side* operand is not
    important in this context, but in other contexts, it may be important:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号操作符评估其*右侧*操作数在这种情况下并不重要，但在其他情境中可能很重要：
- en: '[PRE149]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Here, `processThings`, when invoked, will first call `firstThing` and then `secondThing` and
    will return whatever `secondThing` returns. It is therefore equivalent to the
    following:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当调用`processThings`时，将首先调用`firstThing`，然后调用`secondThing`，并返回`secondThing`返回的任何内容。因此，它等同于以下内容：
- en: '[PRE150]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: It is rare to see the comma operator used, even in scenarios like this, as it
    tends to unnecessarily obscure code that could be more clearly expressed. It's
    useful to know that it exists and how it behaves, but we shouldn't expect it to
    be an everyday operator.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中很少见到逗号操作符的使用，即使在这样的情况下，它也往往会使本来可以更清晰表达的代码变得不必要地复杂。了解它的存在和行为是有用的，但我们不应该期望它成为一个日常操作符。
- en: Grouping
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组
- en: '*Grouping*, or parenthesizing, is achieved by using regular brackets ( `(...)` ).
    This should not be mistaken for other pieces of syntax that use parentheses, such
    as function invocation (`fn(...)`).'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '*分组*，或者用括号括起来，是通过使用常规括号（`(...)`）来实现的。这不应该被误解为其他使用括号的语法，比如函数调用（`fn(...)`）。'
- en: 'The grouping parentheses can be considered an operator just like all of the
    others we''ve learned about. They accept one operand—an expression of any form—and
    will evaluate to whatever resides within them:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 分组括号可以被视为一个操作符，就像我们学过的所有其他操作符一样。它们接受一个操作数——任何形式的表达式，并且将评估其中的内容：
- en: '[PRE151]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'As it simply evaluates its contents, you may wonder what the purpose of a group
    is. Earlier, we covered the concepts of operator precedence and associativity.
    Sometimes, if you''re using a series of operators and wish to force a specific
    order of operations, then the only way to do that is by wrapping them in a group,
    which, when used in combination with other operators, has the highest precedence
    of all:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它只是评估其内容，你可能会想知道分组的目的是什么。早些时候，我们讨论了操作符优先级和结合性的概念。有时，如果你正在使用一系列操作符，并希望强制特定的操作顺序，那么唯一的方法就是将它们包裹在一个分组中，这样在与其他操作符一起使用时，它具有最高的优先级：
- en: '[PRE152]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'It''s wise to use a group when the order of operations is either not what you
    desire or has the potential to be unclear to readers of the code. For example,
    it is sometimes common to wrap items being returned from a function in a group
    to provide aesthetic containment and clarity:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作顺序不是你所期望的，或者可能对代码的读者不清晰时，使用分组是明智的。例如，有时常见的做法是将从函数返回的项目包装在一个分组中，以提供美观的容纳和清晰度：
- en: '[PRE153]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Another obvious solution to this may be to merely indent the items you wish
    to contain, but the issue with this is that the JavaScript `return` statement
    will not know to look beyond its own line for the start of the expression or value
    it must return:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个明显的解决方案可能只是缩进你希望包含的项目，但这样做的问题是JavaScript的`return`语句将不知道在其自己的行之外寻找表达式或值的开始：
- en: '[PRE154]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The `return` statement in the preceding code effectively terminates itself
    with a semicolon when the parser observes that there is no value or expression
    on the same line. This is known as **Automatic Semicolon Insertion** (**ASI**)
    and its existence means we often have to use groups to make it obvious to the
    parser what our intentions are:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`return`语句在解析器观察到同一行上没有值或表达式时，会有效地用分号终止自身。这被称为**自动分号插入**（**ASI**），它的存在意味着我们经常需要使用分组来明确告诉解析器我们的意图是什么：
- en: '[PRE155]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: In summary, *grouping* is a useful tool for containment and re-ordering operations,
    and it is a cheap and easy way to increase the clarity and readability of an expression.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，*分组*是一个用于容纳和重新排序操作的有用工具，它是一种增加表达式的清晰度和可读性的廉价且简单的方法。
- en: Bitwise operators
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按位操作符
- en: 'JavaScript has seven bitwise operators. The term *bitwise* here means *to operate
    on binary numbers*. These operators are rarely utilized but are useful to know
    about nonetheless:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有七个按位操作符。这里的*按位*意味着*对二进制数进行操作*。这些操作符很少被使用，但了解它们仍然是有用的：
- en: '**Bitwise unsigned right-shift operator**: `>>>`'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按位无符号右移操作符**：`>>>`'
- en: '**Bitwise left-shift operator**: `<<`'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按位左移操作符**：`<<`'
- en: '**Bitwise right-shift operator**: `>>`'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按位右移操作符**：`>>`'
- en: '**Bitwise OR**: `|`'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按位或**：`|`'
- en: '**Bitwise AND**: `&`'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按位与**：`&`'
- en: '**Bitwise XOR**: `^`'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按位异或**：`^`'
- en: '**Bitwise NOT**: `~` (a unary operator)'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按位非**：`~`（一元操作符）'
- en: Bitwise operations are incredibly rare in JavaScript since you're usually dealing
    with higher-level sequences of bits like strings or numbers. However, it's worth
    having at least a cursory understanding of bitwise operations so that if you encounter
    the need, you can cope.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，按位操作非常罕见，因为通常处理的是高级位序列，如字符串或数字。然而，值得至少对按位操作有一定的了解，这样如果遇到需要，你就能应对。
- en: 'All bitwise operators in JavaScript will first coerce their operands (or a
    singular operand, in the case of bitwise NOT `~`) to a 32-bit integer representation.
    This means that, internally, a number such as `250` would be manifested as follows:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的所有位运算符都将首先将它们的操作数（或者在位运算NOT `~`的情况下是单个操作数）强制转换为32位整数表示。这意味着，内部上，数字如`250`将被表现为如下：
- en: '[PRE156]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The last eight bits, in this case of `250`, contain all of the information
    regarding the number:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即`250`的最后八位包含有关数字的所有信息：
- en: '[PRE157]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Adding together all of the bits will get us a decimal integer value of `250`.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有位相加将得到一个十进制整数值为`250`。
- en: 'Every bitwise operator available will operate on these bits and derive a new
    value. A bitwise AND operation, for example, will yield a bit value of `1` for
    every pair of bits that are both *on*:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可用的位运算符都将对这些位进行操作并得出一个新值。例如，位AND操作将为每对同时处于*on*状态的位产生一个位值为`1`。
- en: '[PRE158]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: We can see that only the fifth bit from the right (that is, `16`) is *on* in
    both `250` and `20`, therefore the AND operation will result in only that bit
    being left on.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，从右边数起的第五位（即`16`）在`250`和`20`中都是*on*，因此AND操作将导致只有这一位保持on状态。
- en: Bitwise operators should only be utilized when you are carrying out binary mathematics.
    Outside of that, any usage of bitwise operators (for example, for side-effects)
    should be avoided because it drastically limits the clarity and comprehensibility
    of our code.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在进行二进制数学运算时，才应该使用位运算符。除此之外，任何位运算符的使用（例如，用于副作用）都应该避免，因为它会极大地限制我们代码的清晰度和可理解性。
- en: It was not uncommon, for a time, to see bitwise operators such as `~` and `|` being
    used in JavaScript because they were popular for succinctly deriving the integer
    floor of a number (for example, `~34.6789 === 34`). It goes without saying that
    this approach, while clever and ego-boosting, created unreadable and unfamiliar
    code. It remains preferable to use more explicit techniques. In the case of flooring,
    using `Math.floor()` is ideal.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经在JavaScript中经常看到位运算符如`~`和`|`的使用，因为它们在简洁地得出一个数字的整数部分方面很受欢迎（例如，`~34.6789 ===
    34`）。毫无疑问，这种方法虽然聪明且令人自豪，但却创建了难以阅读和陌生的代码。使用更明确的技术仍然更可取。在取整的情况下，使用`Math.floor()`是理想的。
- en: Summary
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have exhaustively covered the operators available in JavaScript.
    Collectively, the last past three chapters have given us an incredibly strong
    foundational understanding of JavaScript syntax, enabling us to feel utterly comfortable
    when constructing expressions.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详尽地介绍了JavaScript中可用的运算符。总的来说，过去的三章使我们对JavaScript语法有了非常坚实的基础理解，使我们在构建表达式时感到非常舒适。
- en: In the next chapter, we'll continue to explore the language by applying our
    existing knowledge of types and operators to the landscapes of declaration and
    control flow. We'll be exploring how to use larger language constructs to craft
    clean code and will be discussing many of the traps and idiosyncrasies present
    in those constructs.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续通过应用我们对类型和运算符的现有知识来探索语言的声明和控制流。我们将探讨如何使用更大的语言结构来编写清晰的代码，并将讨论这些结构中存在的许多陷阱和特殊之处。
