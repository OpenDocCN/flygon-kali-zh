["```java\npublic class LevenshteinDistance {\n\n    public static int calculate (String string1, String string2) {\n        int[][] distances=new int[string1.length()+1][string2.length()+1];\n\n        for (int i=1; i<=string1.length();i++) {\n            distances[i][0]=i;\n        }\n\n        for (int j=1; j<=string2.length(); j++) {\n            distances[0][j]=j;\n        }\n\n        for(int i=1; i<=string1.length(); i++) {\n            for (int j=1; j<=string2.length(); j++) {\n                if (string1.charAt(i-1)==string2.charAt(j-1)) {\n                    distances[i][j]=distances[i-1][j-1];\n                } else {\n                    distances[i][j]=minimum(distances[i-1][j], distances[i][j-1],distances[i-1][j-1])+1;\n                }\n            }\n        }\n\n        return distances[string1.length()][string2.length()];\n    }\n\n    private static int minimum(int i, int j, int k) {\n        return Math.min(i,Math.min(j, k));\n    }\n}\n```", "```java\npublic class BestMatchingSerialCalculation {\n\n    public static BestMatchingData getBestMatchingWords(String word, List<String> dictionary) {\n        List<String> results=new ArrayList<String>();\n        int minDistance=Integer.MAX_VALUE;\n        int distance;\n```", "```java\n        for (String str: dictionary) {\n            distance=LevenshteinDistance.calculate(word,str);\n            if (distance<minDistance) {\n                results.clear();\n                minDistance=distance;\n                results.add(str);\n            } else if (distance==minDistance) {\n                results.add(str);\n            }\n        }\n```", "```java\n        BestMatchingData result=new BestMatchingData();\n        result.setWords(results);\n        result.setDistance(minDistance);\n        return result;\n    }\n\n}\n```", "```java\npublic class BestMatchingSerialMain {\n\n    public static void main(String[] args) {\n\n        Date startTime, endTime;\n        List<String> dictionary=WordsLoader.load(\"data/UK Advanced Cryptics Dictionary.txt\");\n\n        System.out.println(\"Dictionary Size: \"+dictionary.size());\n\n        startTime=new Date();\n        BestMatchingData result= BestMatchingSerialCalculation.getBestMatchingWords (args[0], dictionary);\n        List<String> results=result.getWords();\n        endTime=new Date();\n        System.out.println(\"Word: \"+args[0]);\n        System.out.println(\"Minimum distance: \" +result.getDistance());\n        System.out.println(\"List of best matching words: \" +results.size());\n        results.forEach(System.out::println);\n        System.out.println(\"Execution Time: \"+(endTime.getTime()- startTime.getTime()));\n    }\n\n}\n```", "```java\npublic class BestMatchingBasicTask implements Callable <BestMatchingData > {\n\n    private int startIndex;\n\n    private int endIndex;\n\n    private List < String > dictionary;\n\n    private String word;\n\n    public BestMatchingBasicTask(int startIndex, int endIndex, List < String > dictionary, String word) {\n        this.startIndex = startIndex;\n        this.endIndex = endIndex;\n        this.dictionary = dictionary;\n        this.word = word;\n    }\n```", "```java\n    @Override\n    public BestMatchingData call() throws Exception {\n        List<String> results=new ArrayList<String>();\n        int minDistance=Integer.MAX_VALUE;\n        int distance;\n        for (int i=startIndex; i<endIndex; i++) {\n            distance = LevenshteinDistance.calculate (word,dictionary.get(i));\n            if (distance<minDistance) {\n                results.clear();\n                minDistance=distance;\n                results.add(dictionary.get(i));\n            } else if (distance==minDistance) {\n                results.add(dictionary.get(i));\n            }\n        }\n```", "```java\n        BestMatchingData result=new BestMatchingData();\n        result.setWords(results);\n        result.setDistance(minDistance);\n        return result;\n    }\n}\n```", "```java\npublic class BestMatchingBasicConcurrentCalculation {\n\n    public static BestMatchingData getBestMatchingWords(String word, List<String> dictionary) throws InterruptedException, ExecutionException {\n\n        int numCores = Runtime.getRuntime().availableProcessors();\n        ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(numCores);\n```", "```java\n        int size = dictionary.size();\n        int step = size / numCores;\n        int startIndex, endIndex;\n        List<Future<BestMatchingData>> results = new ArrayList<>();\n```", "```java\n        for (int i = 0; i < numCores; i++) {\n            startIndex = i * step;\n            if (i == numCores - 1) {\n                endIndex = dictionary.size();\n            } else {\n                endIndex = (i + 1) * step;\n            }\n            BestMatchingBasicTask task = new BestMatchingBasicTask(startIndex, endIndex, dictionary, word);\n            Future<BestMatchingData> future = executor.submit(task);\n            results.add(future);\n        }\n```", "```java\n        executor.shutdown();\n        List<String> words=new ArrayList<String>();\n        int minDistance=Integer.MAX_VALUE;\n        for (Future<BestMatchingData> future: results) {\n            BestMatchingData data=future.get();\n            if (data.getDistance()<minDistance) {\n                words.clear();\n                minDistance=data.getDistance();\n                words.addAll(data.getWords());\n            } else if (data.getDistance()==minDistance) {\n                words.addAll(data.getWords());\n            }\n\n        }\n```", "```java\n        BestMatchingData result=new BestMatchingData();\n        result.setDistance(minDistance);\n        result.setWords(words);\n        return result;\n    }\n}\n```", "```java\n        for (int i = 0; i < numCores; i++) {\n            startIndex = i * step;\n            if (i == numCores - 1) {\n                endIndex = dictionary.size();\n            } else {\n                endIndex = (i + 1) * step;\n            }\n            BestMatchingBasicTask task = new BestMatchingBasicTask(startIndex, endIndex, dictionary, word);\n            tasks.add(task);\n        }\n```", "```java\n        results = executor.invokeAll(tasks);\n        executor.shutdown();\n        List<String> words = new ArrayList<String>();\n        int minDistance = Integer.MAX_VALUE;\n        for (Future<BestMatchingData> future : results) {\n            BestMatchingData data = future.get();\n            if (data.getDistance() < minDistance) {\n                words.clear();\n                minDistance = data.getDistance();\n                words.addAll(data.getWords());\n            } else if (data.getDistance()== minDistance) {\n                words.addAll(data.getWords());\n            }\n        }\n        BestMatchingData result = new BestMatchingData();\n        result.setDistance(minDistance);\n        result.setWords(words);\n        return result;\n    }\n```", "```java\npublic class ExistSerialCalculation {\n\n    public static boolean existWord(String word, List<String> dictionary) {\n        for (String str: dictionary) {\n            if (LevenshteinDistance.calculate(word, str) == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```", "```java\npublic class ExistSerialMain {\n\n    public static void main(String[] args) {\n\n        Date startTime, endTime;\n        List<String> dictionary=WordsLoader.load(\"data/UK Advanced Cryptics Dictionary.txt\");\n\n        System.out.println(\"Dictionary Size: \"+dictionary.size());\n\n        startTime=new Date();\n        boolean result=ExistSerialCalculation.existWord(args[0], dictionary);\n        endTime=new Date();\u2029\n        System.out.println(\"Word: \"+args[0]);\n        System.out.println(\"Exists: \"+result);\n        System.out.println(\"Execution Time: \"+(endTime.getTime()- startTime.getTime()));\n    }\n}\n```", "```java\npublic class ExistBasicTask implements Callable<Boolean> {\n\n    private int startIndex;\n\n    private int endIndex;\n\n    private List<String> dictionary;\n\n    private String word;\n\n    public ExistBasicTask(int startIndex, int endIndex, List<String> dictionary, String word) {\n        this.startIndex=startIndex;\n        this.endIndex=endIndex;\n        this.dictionary=dictionary;\n        this.word=word;\n    }\n```", "```java\n    @Override\n    public Boolean call() throws Exception {\n        for (int i=startIndex; i<endIndex; i++) {\n            if (LevenshteinDistance.calculate(word, dictionary.get(i))==0) {\n                return true;\n            }\n        }\n            if (Thread.interrupted()) {\n                return false;\n            }\n        throw new NoSuchElementException(\"The word \"+word+\" doesn't exists.\");\n    }\n```", "```java\npublic class ExistBasicConcurrentCalculation {\n\n    public static boolean existWord(String word, List<String> dictionary) throws InterruptedException, ExecutionException{\n        int numCores = Runtime.getRuntime().availableProcessors();\n        ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(numCores);\n```", "```java\n        int size = dictionary.size();\n        int step = size / numCores;\n        int startIndex, endIndex;\n        List<ExistBasicTask> tasks = new ArrayList<>();\n\n        for (int i = 0; i < numCores; i++) {\n            startIndex = i * step;\n            if (i == numCores - 1) {\n                endIndex = dictionary.size();\n            } else {\n                endIndex = (i + 1) * step;\n            }\n            ExistBasicTask task = new ExistBasicTask(startIndex, endIndex, dictionary,\n                    word);\n            tasks.add(task);\n        }\n```", "```java\n        try {\n            Boolean result=executor.invokeAny(tasks);\n            return result;\n        } catch (ExecutionException e) {\n            if (e.getCause() instanceof NoSuchElementException)\n                return false;\n            throw e;\n        } finally {\n            executor.shutdown();\n        }\n    }\n}\n```", "```java\npublic class DocumentParser {\n\n    public Map<String, Integer>  parse(String route) {\n        Map<String, Integer> ret=new HashMap<String,Integer>();\n        Path file=Paths.get(route);\n        try ( BufferedReader reader = Files.newBufferedReader(file)) {\n                String line = null;\n                while ((line = reader.readLine()) != null) {\n                    parseLine(line,ret);\n                }\n            } catch (IOException x) {\n              x.printStackTrace();\n            } catch (Exception e) {\n              e.printStackTrace();\n            }\n        return ret;\n\n    }\n```", "```java\nprivate static final Pattern PATTERN = Pattern.compile(\"\\\\P{IsAlphabetic}+\");\n\nprivate void parseLine(String line, Map<String, Integer> ret) {\n  for(String word: PATTERN.split(line)) {\n    if(!word.isEmpty())\n      ret.merge(Normalizer.normalize(word, Normalizer.Form.NFKD).toLowerCase(), 1, (a, b) -> a+b);\n  }\n}\n```", "```java\npublic class SerialIndexing {\n\n    public static void main(String[] args) {\n\n        Date start, end;\n\n        File source = new File(\"data\");\n        File[] files = source.listFiles();\n        Map<String, List<String>> invertedIndex=new HashMap<String,List<String>> ();\n```", "```java\n        start=new Date();\n        for (File file : files) {\n\n            DocumentParser parser = new DocumentParser();\n\n            if (file.getName().endsWith(\".txt\")) {\n                Map<String, Integer> voc = parser.parse (file.getAbsolutePath());\n                updateInvertedIndex(voc,invertedIndex, file.getName());\n            }\n        }\n        end=new Date();\n```", "```java\n        System.out.println(\"Execution Time: \"+(end.getTime()- start.getTime()));\n        System.out.println(\"invertedIndex: \"+invertedIndex.size());\n    }\n```", "```java\nprivate static void updateInvertedIndex(Map<String, Integer> voc, Map<String, List<String>> invertedIndex, String fileName) {\n  for (String word : voc.keySet()) {\n    if (word.length() >= 3) {\n      invertedIndex.computeIfAbsent(word, k -> new ArrayList<>()).add(fileName);\n    }\n  }\n}\n```", "```java\npublic class IndexingTask implements Callable<Document> {\n    private File file;\n    public IndexingTask(File file) {\n        this.file=file;\n    }\n```", "```java\n    @Override\n    public Document call() throws Exception {\n        DocumentParser parser = new DocumentParser();\n\n        Map<String, Integer> voc = parser.parse(file.getAbsolutePath());\n\n        Document document=new Document();\n        document.setFileName(file.getName());\n        document.setVoc(voc);\n        return document;\n    }\n}\n```", "```java\npublic class InvertedIndexTask implements Runnable {\n\n    private CompletionService<Document> completionService;\n    private ConcurrentHashMap<String, ConcurrentLinkedDeque<String>> invertedIndex;\n\n    public InvertedIndexTask(CompletionService<Document> completionService,\n            ConcurrentHashMap<String, ConcurrentLinkedDeque<String>> invertedIndex) {\n        this.completionService = completionService;\n        this.invertedIndex = invertedIndex;\n\n    }\n```", "```java\npublic void run() {\n        try {\n            while (!Thread.interrupted()) {\n                try {\n                    Document document = completionService.take().get();\n                    updateInvertedIndex(document.getVoc(), invertedIndex, document.getFileName());\n                } catch (InterruptedException e) {\n                    break;\n                }\n            }\n            while (true) {\n                Future<Document> future = completionService.poll();\n                if (future == null)\n                    break;\n                Document document = future.get();\n                updateInvertedIndex(document.getVoc(), invertedIndex, document.getFileName());\n            }\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n```", "```java\n     private void updateInvertedIndex(Map<String, Integer> voc, ConcurrentHashMap<String, ConcurrentLinkedDeque<String>> invertedIndex, String fileName) {\n        for (String word : voc.keySet()) {\n            if (word.length() >= 3) {\n                invertedIndex.computeIfAbsent(word, k -> new ConcurrentLinkedDeque<>()).add(fileName);\n            }\n        }\n    }\n```", "```java\npublic class ConcurrentIndexing {\n\n    public static void main(String[] args) {\n\n        int numCores=Runtime.getRuntime().availableProcessors();\n        ThreadPoolExecutor executor=(ThreadPoolExecutor) Executors.newFixedThreadPool(Math.max(numCores-1, 1));\n        ExecutorCompletionService<Document> completionService=new ExecutorCompletionService<>(executor);\n        ConcurrentHashMap<String, ConcurrentLinkedDeque<String>> invertedIndex=new ConcurrentHashMap <String,ConcurrentLinkedDeque<String>> ();\n\n        Date start, end;\n\n        File source = new File(\"data\");\n        File[] files = source.listFiles();\n```", "```java\n        start=new Date();\n        for (File file : files) {\n            IndexingTask task=new IndexingTask(file);\n            completionService.submit(task);\n        }\n```", "```java\n        InvertedIndexTask invertedIndexTask=new InvertedIndexTask(completionService,invertedIndex);\n        Thread thread1=new Thread(invertedIndexTask);\n        thread1.start();\n        InvertedIndexTask invertedIndexTask2=new InvertedIndexTask(completionService,invertedIndex);\n        Thread thread2=new Thread(invertedIndexTask2);\n        thread2.start();\n```", "```java\n        executor.shutdown();\n        try {\n            executor.awaitTermination(1, TimeUnit.DAYS);\n            thread1.interrupt();\n            thread2.interrupt();\n            thread1.join();\n            thread2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n```", "```java\n        end=new Date();\n        System.out.println(\"Execution Time: \"+(end.getTime()- start.getTime()));\n        System.out.println(\"invertedIndex: \"+invertedIndex.size());\n    }\n\n}\n```", "```java\npublic class MultipleIndexingTask implements Callable<List<Document>> {\n\n    private List<File> files;\n\n    public MultipleIndexingTask(List<File> files) {\n        this.files = files;\n    }\n```", "```java\n    @Override\n    public List<Document> call() throws Exception {\n        List<Document> documents = new ArrayList<Document>();\n        for (File file : files) {\n            DocumentParser parser = new DocumentParser();\n\n            Hashtable<String, Integer> voc = parser.parse (file.getAbsolutePath());\n\n            Document document = new Document();\n            document.setFileName(file.getName());\n            document.setVoc(voc);\n\n            documents.add(document);\n        }\n\n        return documents;\n    }\n}\n```", "```java\n    @Override\n    public void run() {\n        try {\n            while (!Thread.interrupted()) {\n                try {\n                    List<Document> documents = completionService.take().get();\n                    for (Document document : documents) {\n                        updateInvertedIndex(document.getVoc(), invertedIndex, document.getFileName());\n                    }\n                } catch (InterruptedException e) {\n                    break;\n                }\n            }\n            while (true) {\n                Future<List<Document>> future = completionService.poll();\n                if (future == null)\n                    break;\n                List<Document> documents = future.get();\n                for (Document document : documents) {\n                    updateInvertedIndex(document.getVoc(), invertedIndex, document.getFileName());\n                }\n            }\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n```", "```java\n        start=new Date();\n        List<File> taskFiles=new ArrayList<>();\n        for (File file : files) {\n            taskFiles.add(file);\n            if (taskFiles.size()==NUMBER_OF_TASKS) {\n                MultipleIndexingTask task=new MultipleIndexingTask(taskFiles);\n                completionService.submit(task);\n                taskFiles=new ArrayList<>();\n            }\n        }\n        if (taskFiles.size()>0) {\n            MultipleIndexingTask task=new MultipleIndexingTask(taskFiles);\n            completionService.submit(task);\n        }\n\n        MultipleInvertedIndexTask invertedIndexTask=new MultipleInvertedIndexTask (completionService,invertedIndex);\n        Thread thread1=new Thread(invertedIndexTask);\n        thread1.start();\n        MultipleInvertedIndexTask invertedIndexTask2=new MultipleInvertedIndexTask (completionService,invertedIndex);\n        Thread thread2=new Thread(invertedIndexTask2);\n        thread2.start();\n```"]