- en: Addressing Cross-Cutting Concerns
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 解决横切关注点
- en: 'There are two types of concerns that you need to have when writing clean code—core
    concerns and cross-cutting concerns. **Core concerns** are the reasons for the
    software and why it is being developed. **Cross-cutting concerns** are the concerns
    that are not part of the business requirements and that form the core concerns,
    but must be addressed in all areas of the code, as illustrated in the following
    diagram:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写清晰代码时，您需要考虑两种类型的关注点-核心关注点和横切关注点。**核心关注点**是软件的原因以及为什么开发它。**横切关注点**是不属于业务需求的关注点，但必须在代码的所有区域中进行处理，如下图所示：
- en: '![](img/5a4fd4a9-d664-4351-985d-fc1b37687b68.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a4fd4a9-d664-4351-985d-fc1b37687b68.png)'
- en: It is the cross-cutting concerns that we will be covering in this chapter by
    building a reusable class library that you can modify or extend to your liking.
    Cross-cutting concerns include configuration management, logging, auditing, security,
    validation, exception-handling, instrumentation, transactions, resource pooling,
    caching, and threading and concurrency. We will use the decorator pattern and
    the PostSharp Aspect Framework to help us build our reusable library, which is
    injected at compile time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正是横切关注点，我们将在本章中通过构建一个可重用的类库来进行覆盖，您可以修改或扩展它以满足您的需求。横切关注点包括配置管理、日志记录、审计、安全、验证、异常处理、仪表、事务、资源池、缓存以及线程和并发。我们将使用装饰者模式和PostSharp
    Aspect Framework来帮助我们构建我们的可重用库，该库在编译时注入。
- en: As you read through this chapter, you will see how **attribute programming** can
    result in using a lot less boilerplate code, as well as code that is smaller,
    more readable, and easier to maintain and extend. This leaves only the required
    business code in your methods with the boilerplate code
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当您阅读本章时，您将看到**属性编程**如何导致使用更少的样板代码，以及更小、更可读、更易于维护和扩展的代码。这样，您的方法中只留下了所需的业务代码和样板代码。
- en: We have discussed many of these ideas already. However, they are mentioned here
    again as they are cross-cutting concerns.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了许多这些想法。然而，它们在这里再次提到，因为它们是横切关注点。
- en: 'In this chapter, we''ll be covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The decorator pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: The proxy pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式
- en: '**Aspect-Oriented Programming** (**AOP**) with PostSharp'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PostSharp应用AOP。
- en: Project – cross-cutting concerns reusable library
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目-横切关注点可重用库
- en: 'By the end of this chapter, you will have the skills to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将具备以下技能：
- en: Implement the decorator pattern.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现装饰者模式。
- en: Implement the proxy pattern.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现代理模式。
- en: Apply AOP using PostSharp.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PostSharp应用AOP。
- en: Build your own reusable AOP library that addresses your cross-cutting concerns.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建您自己的可重用AOP库，以解决您的横切关注点。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get the most out of this chapter, you will need Visual Studio 2019 and PostSharp
    installed. For the code files for this chapter, refer to [https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH11](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH11).
    Let's start by looking at the decorator pattern.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用本章，您需要安装Visual Studio 2019和PostSharp。有关本章的代码文件，请参阅[https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH11](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH11)。让我们从装饰者模式开始。
- en: The decorator pattern
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: 'The decorator design pattern is a structural pattern that is used to add new
    functionality to an existing object without changing its structure. The original
    class is wrapped in decorator class wraps and new behaviors and operations are
    added to an object at runtime:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者设计模式是一种结构模式，用于在不改变其结构的情况下向现有对象添加新功能。原始类被包装在装饰类中，并在运行时向对象添加新的行为和操作：
- en: '![](img/adc0e574-a40d-4c5f-b12b-397bf35ff3b9.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adc0e574-a40d-4c5f-b12b-397bf35ff3b9.png)'
- en: The `Component` interface and the members it contains are implemented by the
    `ConcreteComponent` class and the `Decorator` class. `ConcreteComponent` implements
    the `Component` interface. The `Decorator` class is an abstract class that implements
    the `Component` interface and contains the reference to a `Component` instance.
    The `Decorator` class is the base class for components. The `ConcreteDecorator`
    class inherits from the `Decorator` class and provides a decorator for components.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Component`接口及其包含的成员由`ConcreteComponent`类和`Decorator`类实现。`ConcreteComponent`实现了`Component`接口。`Decorator`类是一个实现`Component`接口并包含对`Component`实例的引用的抽象类。`Decorator`类是组件的基类。`ConcreteDecorator`类继承自`Decorator`类，并为组件提供装饰器。'
- en: 'We are going to write an example that wraps an operation in a `try`/`catch`
    block. Both `try` and `catch` will output a string to the console. Create a new
    .NET 4.8 console application named `CH10_AddressingCrossCuttingConcerns`. Then,
    add a folder called `DecoratorPattern`. Add a new interface called `IComponent`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个示例，将一个操作包装在`try`/`catch`块中。`try`和`catch`都将向控制台输出一个字符串。创建一个名为`CH10_AddressingCrossCuttingConcerns`的新.NET
    4.8控制台应用程序。然后，添加一个名为`DecoratorPattern`的文件夹。添加一个名为`IComponent`的新接口：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To keep things simple, our interface only has a single operation of the `void` type.
    Now that we have our interface in place, we need to add an abstract class that
    implements the interface. Add a new abstract class called `Decorator` that implements
    the `IComponent` interface. Add a member variable to store our `IComponent` object:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们的接口只有一个`void`类型的操作。现在我们已经有了接口，我们需要添加一个实现接口的抽象类。添加一个名为`Decorator`的新抽象类，它实现了`IComponent`接口。添加一个成员变量来存储我们的`IComponent`对象：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `_component` member variable, which stores the `IComponent` object, is
    set via the constructor, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 存储`IComponent`对象的`_component`成员变量是通过构造函数设置的，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, the constructor sets the component we will be decorating.
    Next, we add our interface method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，构造函数设置了我们将要装饰的组件。接下来，我们添加我们的接口方法：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We''ve declared the `Operation()` method as `virtual` so that it can be overridden
    in the derived classes. We''ll now create our `ConcreteComponent` class, which
    implements `IComponent`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Operation()`方法声明为`virtual`，以便可以在派生类中重写它。现在，我们将创建我们的`ConcreteComponent`类，它实现`IComponent`：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, our class consists of one operation, which throws `NotImplementedException`.
    Now, we can write about the `ConcreteDecorator` class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的类包括一个操作，它抛出`NotImplementedException`。现在，我们可以写关于`ConcreteDecorator`类：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `ConcreteDecorator` class inherits the `Decorator` class. The constructor
    takes an `IComponent` parameter and passes it to the base constructor, where the
    member variable is then set. Next, we''ll override the `Operation()` method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcreteDecorator`类继承自`Decorator`类。构造函数接受一个`IComponent`参数，并将其传递给基类构造函数，然后设置成员变量。接下来，我们将重写`Operation()`方法：'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our overridden method, we have a `try`/`catch` block. In the `try` block,
    we write a message to the console and execute the base class'' `Operation()` method.
    In the `catch` block, when an exception is encountered, a message is written,
    followed by the error message. Before we can use our code, we need to update the `Program` class.
    Add the `DecoratorPatternExample()` method to the `Program` class:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们重写的方法中，我们有一个`try`/`catch`块。在`try`块中，我们向控制台写入一条消息，并执行基类的`Operation()`方法。在`catch`块中，当遇到异常时，会写入一条消息，然后是错误消息。在我们可以使用我们的代码之前，我们需要更新`Program`类。将`DecoratorPatternExample()`方法添加到`Program`类中：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In our `DecoratorPatternExample()` method, we create a new concrete component.
    We then pass it into the constructor of a new concrete decorator. Then, we call
    the `Operation()` method on the concrete decorator. Add the following two lines
    to the `Main()` method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`DecoratorPatternExample()`方法中，我们创建一个新的具体组件。然后，我们将其传递给一个新的具体装饰器的构造函数。然后，我们在具体装饰器上调用`Operation()`方法。将以下两行添加到`Main()`方法中：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Those two lines execute our example and then wait for the user to press a key
    before exiting. Run the code and you should see the same output as in the following
    screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行执行我们的示例，然后等待用户按键退出。运行代码，您应该看到与以下截图相同的输出：
- en: '![](img/664bec75-738c-4c02-b795-f06f6e2d0a52.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/664bec75-738c-4c02-b795-f06f6e2d0a52.png)'
- en: That concludes our look at the decorator pattern. Now, it's time to look at
    the proxy pattern.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对装饰器模式的讨论。现在，是时候来看看代理模式了。
- en: The proxy pattern
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理模式
- en: 'The proxy pattern is a structural design pattern providing objects that act
    as substitutes for real service objects used by clients. Proxies receive client
    requests, perform the required work, and then pass the request to service objects.
    Proxy objects are interchangeable with services as they share the same interfaces:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式是一种结构设计模式，提供作为客户端使用的真实服务对象的替代对象。代理接收客户端请求，执行所需的工作，然后将请求传递给服务对象。代理对象可以与服务对象互换，因为它们共享相同的接口：
- en: '![](img/7a2acc31-3b52-44c5-8ddf-421e7e7aba54.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a2acc31-3b52-44c5-8ddf-421e7e7aba54.png)'
- en: An example of when you would want to use the proxy pattern is when you have
    a class that you do not want to change, but where you do need additional behaviors
    to be added. Proxies delegate work to other objects. Unless a proxy is a derivative
    of a service, proxy methods should finally refer to a `Service` object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用代理模式的一个例子是当您有一个您不想更改的类，但您需要添加额外的行为时。代理将工作委托给其他对象。除非代理是服务的派生类，否则代理方法应最终引用`Service`对象。
- en: 'We will look at a very simple implementation of the proxy pattern. Add a folder
    to the root of your `Chapter 11` project called `ProxyPattern`. Add an interface
    called `IService` with a single method to handle a request:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个非常简单的代理模式实现。在您的`Chapter 11`项目的根目录下添加一个名为`ProxyPattern`的文件夹。添加一个名为`IService`的接口，其中包含一个处理请求的方法：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Request()` method performs the work that carries out the request. Both
    the proxy and the service will implement this interface to use the `Request()` method.
    Now, add the `Service` class and implement the `IService` interface:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Request()`方法执行执行请求的工作。代理和服务都将实现这个接口来使用`Request()`方法。现在，添加`Service`类并实现`IService`接口：'
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our `Service` class implements the `IService` interface and handles the actual
    service `Request()` method. This `Request()` method will be called by the `Proxy` class.
    The final step to implementing the proxy pattern is to write the `Proxy` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Service`类实现了`IService`接口，并处理实际的服务`Request()`方法。这个`Request()`方法将被`Proxy`类调用。实现代理模式的最后一步是编写`Proxy`类：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our `Proxy` class implements `IService` and has a constructor that accepts
    a single `IService` parameter. The `Request()` method of the `Proxy` class is
    called by the client. The `Proxy.Request()` method will do what it needs to do
    and will be responsible for calling `_service.Request()`. So that we can see this
    in action, let''s update our `Program` class. Add the `ProxyPatternExample()` call to
    the `Main()` method. Then, add the `ProxyPatternExample()` method:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Proxy`类实现了`IService`，并具有一个接受单个`IService`参数的构造函数。客户端调用`Proxy`类的`Request()`方法。`Proxy.Request()`方法将执行所需的操作，并负责调用`_service.Request()`。为了看到这一点，让我们更新我们的`Program`类。在`Main()`方法中添加`ProxyPatternExample()`调用。然后，添加`ProxyPatternExample()`方法：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our test method runs the `Request()` method of the `Service` class direction.
    Then, it runs the same method via the `Request()` method of the `Proxy` class.
    Run the project and you should see the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试方法运行`Service`类的`Request()`方法。然后，通过`Proxy`类的`Request()`方法运行相同的方法。运行项目，您应该看到以下内容：
- en: '![](img/ff58bd4b-08a3-41b8-bdba-bef5e252a020.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff58bd4b-08a3-41b8-bdba-bef5e252a020.png)'
- en: Now that you have a working understanding of the decorator and proxy patterns,
    let's take a look at AOP with PostSharp.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对装饰器和代理模式有了工作理解，让我们来看看使用PostSharp的AOP。
- en: AOP with PostSharp
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PostSharp的AOP
- en: AOP can be used with OOP. An **aspect** is an attribute applied to classes,
    methods, parameters, and properties that, at compile-time, weaves code into the
    class, method, parameter, or property to which it is applied. This approach allows
    the cross-cutting concerns of a program to be moved from the business source code
    to a class library. The concerns are added where needed as attributes. The compiler
    then weaves the required code in at runtime. This keeps your business code small
    and readable. In this chapter, we will be using PostSharp. You can download it
    from [https://www.postsharp.net/download](https://www.postsharp.net/download).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: AOP可以与OOP一起使用。**方面**是应用于类、方法、参数和属性的属性，在编译时，将代码编织到应用的类、方法、参数或属性中。这种方法允许程序的横切关注从业务源代码移动到类库中。关注点在需要时作为属性添加。然后编译器在运行时编织所需的代码。这使得您的业务代码保持简洁和可读。在本章中，我们将使用PostSharp。您可以从[https://www.postsharp.net/download](https://www.postsharp.net/download)下载它。
- en: So, how does AOP work with PostSharp?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，AOP如何与PostSharp一起工作呢？
- en: You add the PostSharp package to your project. Then, you annotate your code
    with attributes. The C# compiler builds your code into binary, and then PostSharp
    analyzes the binary and injects the implementation of the aspects. Although the
    binaries are modified with injected code at compile-time, your project's source
    code remains unaltered. This means you can keep your code nice, clean, and simple,
    which in turn makes maintenance, reuse, and extending existing code bases much
    easier in the long term.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将PostSharp包添加到项目中。然后，您可以使用属性对代码进行注释。C#编译器将您的代码构建成二进制代码，然后PostSharp分析二进制代码并注入方面的实现。尽管二进制代码在编译时被修改并注入了代码，但您的项目源代码保持不变。这意味着您可以保持代码的整洁、简洁，从而使长期内维护、重用和扩展现有代码库变得更加容易。
- en: PostSharp has some really good ready-made patterns for you to utilize. These
    cover **Model-View-ViewModel** (**MVVM**), caching, multi-threading, longing and
    architecture validation, and more. But the good news is that if there is nothing
    that meets your requirements, then you can automate your own patterns by extending
    the aspect framework and/or the architecture framework.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: PostSharp有一些非常好的现成模式供您利用。这些模式涵盖了**Model-View-ViewModel**（**MVVM**）、缓存、多线程、日志和架构验证等。但好消息是，如果没有符合您要求的内容，那么您可以通过扩展方面框架和/或架构框架来自动化自己的模式。
- en: With the aspect framework, you develop your simple or composite aspect, apply
    it to the code, and validate its usage. As for the architectural framework, you
    develop your custom architectural constraints. Before we delve into the cross-cutting
    concerns, let's briefly take a look at extending the aspect and architectural
    frameworks.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方面框架，您可以开发简单或复合方面，将其应用于代码，并验证其使用。至于架构框架，您可以开发自定义的架构约束。在我们深入研究横切关注之前，让我们简要地看一下如何扩展方面和架构框架。
- en: You need to add the `PostSharp.Redist` NuGet package when writing aspects and
    attributes. Once done, if you find that your attributes and aspects are not working,
    then right-click on the project and select Add PostSharp to Project. After you've
    done this, your aspects should work.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写方面和属性时，您需要添加`PostSharp.Redist` NuGet包。完成后，如果发现您的属性和方面不起作用，那么右键单击项目并选择添加PostSharp到项目。完成此操作后，您的方面应该可以工作。
- en: Extending the aspect framework
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展方面框架
- en: In this section, we are going to develop a simple aspect and apply it to some
    code. Then, we will validate the usage of our aspect.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个简单的方面并将其应用于一些代码。然后，我们将验证我们方面的使用。
- en: Developing our aspect
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发我们的方面
- en: Our aspect will be a simple one that is composed of a single transformation.
    We will derive our aspect from a primitive aspect class. Then, we will override
    some methods known as **advice**. If you would like to know how to create a composite
    aspect, you can read how to do so at [https://doc.postsharp.net/complex-aspects](https://doc.postsharp.net/complex-aspects).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方面将是一个由单个转换组成的简单方面。我们将从原始方面类派生我们的方面。然后，我们将重写一些称为**建议**的方法。如果您想知道如何创建复合方面，可以在[https://doc.postsharp.net/complex-aspects](https://doc.postsharp.net/complex-aspects)上阅读如何做到这一点。
- en: Injecting behaviors before and after the method execution
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在方法执行前后注入行为
- en: 'The `OnMethodBoundaryAspect` aspect implements the decorator pattern. You have
    already seen how to implement the decorator pattern earlier in this chapter. With
    this aspect, you can execute logic before and after the execution of a target
    method. The following table provides a list of the advice methods that are available
    in the `OnMethodBoundaryAspect` class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnMethodBoundaryAspect`方面实现了装饰器模式。您已经在本章前面看到了如何实现装饰器模式。通过这个方面，您可以在目标方法执行前后执行逻辑。以下表格提供了`OnMethodBoundaryAspect`类中可用的建议方法列表：'
- en: '| **Advice** | **Description** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **建议** | **描述** |'
- en: '| `OnEntry(MethodExecutionArgs)` | Used when the method''s execution starts,
    before any user code. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `OnEntry(MethodExecutionArgs)` | 在方法执行开始时使用，用户代码之前。 |'
- en: '| `OnSuccess(MethodExecutionArgs)` | Used when the method''s execution succeeds
    (that is, returns without an exception), after any user code. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `OnSuccess(MethodExecutionArgs)` | 在方法执行成功（即没有异常返回）后使用，用户代码之后。 |'
- en: '| `OnException(MethodExecutionArgs)` | Used when the method execution fails
    with an exception, after any user code. It is equivalent to a `catch` block. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `OnException(MethodExecutionArgs)` | 在方法执行失败并出现异常后使用，用户代码之后。相当于`catch`块。
    |'
- en: '| `OnExit(MethodExecutionArgs)` | Used when the method execution exits, whether
    successfully or with an exception. This advice runs after any user code and after
    the `OnSuccess(MethodExecutionArgs)` or `OnException(MethodExecutionArgs)` method
    of the current aspect. It is equivalent to a `finally` block. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `OnExit(MethodExecutionArgs)` | 在方法执行退出时使用，无论成功与否或出现异常。此建议在用户代码之后以及当前方面的`OnSuccess(MethodExecutionArgs)`或`OnException(MethodExecutionArgs)`方法之后运行。相当于`finally`块。|'
- en: 'For our simple aspect, we are going to look at all the methods in use. Before
    we begin, add PostSharp to your project. If you have already downloaded PostSharp,
    you can right-click on your project and then select Add PostSharp to Project.
    After that, add a new folder to your project called `Aspects`, and then add a
    new class called `LoggingAspect`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们简单的方面，我们将查看所有正在使用的方法。在开始之前，将PostSharp添加到您的项目中。如果您已经下载了PostSharp，可以右键单击您的项目，然后选择添加PostSharp到项目。之后，添加一个名为`Aspects`的新文件夹到您的项目中，然后添加一个名为`LoggingAspect`的新类：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `[PSerializeable]` attribute is a custom attribute that, when applied to
    a type, causes PostSharp to generate a serializer for use by `PortableFormatter`.
    Now, override the `OnEntry()` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`[PSerializeable]`属性是一个自定义属性，当应用于类型时，会导致PostSharp生成一个供`PortableFormatter`使用的序列化器。现在，重写`OnEntry()`方法：'
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `OnEntry()` method is executed before any user code. Now, override the
    `OnSuccess()` method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnEntry()`方法在任何用户代码之前执行。现在，重写`OnSuccess()`方法：'
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `OnSuccess()` method runs after the user code has completed without exception.
    Override the `OnExit()` method:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnSuccess()`方法在用户代码完成时执行。重写`OnExit()`方法：'
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `OnExit()` method executes when the user method completes successfully
    or unsuccessfully and exits. It is equivalent to a `finally` block. Finally, override
    the `OnException()` method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnExit()`方法在用户方法成功或失败完成并退出时执行。它相当于一个`finally`块。最后，重写`OnException()`方法：'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `OnException()` method executes when method execution fails with an exception,
    after any user code. It is equivalent to a `catch` block.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnException()`方法在方法执行失败并出现异常时执行，执行在任何用户代码之后。它相当于一个`catch`块。'
- en: 'The next step is to write two methods that we can apply `LoggingAspect` to.
    We''ll add `SuccessfulMethod()`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编写两个可以应用`LoggingAspect`的方法。我们将添加`SuccessfulMethod()`：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`SuccessfulMethod()` uses `LoggingAspect` and prints a message to the console.
    Now, let''s add `FailedMethod()`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`SuccessfulMethod()`使用`LoggingAspect`并在控制台上打印一条消息。现在，让我们添加`FailedMethod()`：'
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`FailedMethod()` uses `LoggingAspect` and prints a message to the console.
    Then, it performs a division by zero operations, which results in `DivideByZeroException`.
    Call both of these methods from your `Main()` method, and then run through your
    project. You should see the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`FailedMethod()`使用`LoggingAspect`并在控制台上打印一条消息。然后，它执行了一个除零操作，导致`DivideByZeroException`。从您的`Main()`方法中调用这两种方法，然后运行您的项目。您应该看到以下输出：'
- en: '![](img/2169d706-6075-45f7-a0c7-668e69855318.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2169d706-6075-45f7-a0c7-668e69855318.png)'
- en: At this point, the debugger will cause the program to exit. That's it. As you
    can see, creating your own PostSharp aspects to meet your needs is a simple process.
    Now, we will look at adding our own architectural constraint.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，调试器将导致程序退出。就是这样。正如您所看到的，创建自己的PostSharp方面以满足您的需求是一个简单的过程。现在，我们将看看如何添加我们自己的架构约束。
- en: Extending the architectural framework
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展架构框架
- en: An architectural constraint is the adoption of custom design patterns that must
    be respected across all modules. We will implement a scalar constraint that validates
    an element of code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 架构约束是采用必须在所有模块中遵守的自定义设计模式。我们将实现一个标量约束，用于验证代码的元素。
- en: 'Our scalar constraint, called `BusinessRulePatternValidation`, will validate
    that any class deriving from the `BusinessRule` class must have a nested class
    named `Factory`. Start by adding the `BusinessRulePatternValidation` class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的标量约束，称为`BusinessRulePatternValidation`，将验证从`BusinessRule`类派生的任何类必须具有名为`Factory`的嵌套类。首先添加`BusinessRulePatternValidation`类：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`MulticastAttributeUsage` designates that this validation aspect will only
    work with classes and inheritance allowed. Let''s override the `ValidateCode()`
    method:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`MulticastAttributeUsage`指定此验证方面只能与允许类和继承的类一起使用。让我们重写`ValidateCode()`方法：'
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our `ValidateCode()` method checks whether the target object has a nested `Factory`
    type. If the `Factory` type is not present, then an exception message is written
    to the output window. Add the `BusinessRule` class:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ValidateCode()`方法检查目标对象是否具有嵌套的`Factory`类型。如果`Factory`类型不存在，则会向输出窗口写入异常消息。添加`BusinessRule`类：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `BusinessRule` class is empty and devoid of `Factory`. It has our `BusinessRulePatternValidation`
    attribute assigned to it, which is an architectural constraint. Build your project
    and you will see the message in the output window. We will now start to build
    a reusable class library that you can extend and use in your own projects to address
    cross-cutting concerns using AOP and the decorator pattern.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`BusinessRule`类是空的，没有`Factory`。它有我们分配给它的`BusinessRulePatternValidation`属性，这是一个架构约束。构建您的项目，您将在输出窗口中看到消息。我们现在将开始构建一个可重用的类库，您可以在自己的项目中扩展和使用它来解决横切关注点，使用AOP和装饰器模式。'
- en: Project – cross-cutting concerns reusable library
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目-横切关注点可重用库
- en: In this section, we will be working through writing a reusable library for addressing
    various cross-cutting concerns. It will have limited functionality, but it will
    give you the knowledge you need to further expand the project for your own needs.
    The class library you will be creating will be a .NET standard library so that
    it can be used for apps that target both .NET Framework and .NET Core. You will
    also create a .NET Framework console application to see the library in action.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过编写一个可重用库来解决各种横切关注点的问题。它的功能有限，但它将为您提供进一步扩展项目所需的知识。您将创建的类库将是一个.NET标准库，以便可以用于同时针对.NET
    Framework和.NET Core的应用程序。您还将创建一个.NET Framework控制台应用程序，以查看库的运行情况。
- en: Start by creating a new .NET standard class library called `CrossCuttingConcerns`.
    Then, add a .NET Framework console application to the solution called `TestHarness`.
    We will be adding reusable functionality to address various concerns, starting
    with caching.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个名为`CrossCuttingConcerns`的新.NET标准类库。然后，在解决方案中添加一个名为`TestHarness`的.NET Framework控制台应用程序。我们将添加可重用的功能来解决各种问题，从缓存开始。
- en: Adding the caching concern
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加缓存关注点
- en: '**Caching** is a storage technique for improving performance when accessing
    various kinds of resources. The cache used can be memory, a filesystem, or a database.
    The type of cache you use will be dependent on the needs of the project. For our
    demonstration, we will be using memory caching to keep things simple.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存**是一种用于提高访问各种资源时性能的存储技术。使用的缓存可以是内存、文件系统或数据库。您使用的缓存类型将取决于项目的需求。为了演示，我们将使用内存缓存来保持简单。'
- en: 'Add a folder called `Caching` to the `CrossCuttingConcerns` project. Then,
    add a class called `MemoryCache`. Add the following NuGet packages to the project:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在“CrossCuttingConcerns”项目中添加一个名为“Caching”的文件夹。然后，添加一个名为“MemoryCache”的类。向项目添加以下NuGet包：
- en: '`PostSharp`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostSharp`'
- en: '`PostSharp.Patterns.Common`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostSharp.Patterns.Common`'
- en: '`PostSharp.Patterns.Diagnostics`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostSharp.Patterns.Diagnostics`'
- en: '`System.Runtime.Caching`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Runtime.Caching`'
- en: 'Update the `MemoryCache` class with the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新“MemoryCache”类：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `GetItem()` method takes the name of the cached item, `itemName`, the length
    of time the item is to remain in the cache, `timeInCache`, and the function to
    call to place the item in the cache if it is not already there, `itemCacheFunction`.
    Add a new class to the `TestHarness` project and call it `TestClass`. Then, add
    the `GetCachedItem()` and `GetMessage()` methods, as shown:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: “GetItem（）”方法接受缓存项的名称“itemName”，缓存项保留在缓存中的时间长度“timeInCache”，以及在将项目放入缓存时调用的函数“itemCacheFunction”。在“TestHarness”项目中添加一个新类，命名为“TestClass”。然后，添加“GetCachedItem（）”和“GetMessage（）”方法，如下所示：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `GetCachedItem()` method gets a string called `"Message"` from the cache.
    If it is not in the cache, then it will be stored in the cache by the `GetMessage()` method for
    30 seconds.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: “GetCachedItem（）”方法从缓存中获取名为“Message”的字符串。如果它不在缓存中，那么它将由“GetMessage（）”方法存储在缓存中30秒。
- en: 'Update your `Main()` method in the `Program` class to call the `GetCachedItem()`
    method, as shown:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Program”类中更新您的“Main（）”方法，调用“GetCachedItem（）”方法，如下所示：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first call to `GetCachedItem()` stores the item in the cache and then returns
    it. The second call obtains the item from the cache and returns it. The sleeping
    thread invalidates the cache, and so the last call stores the item in the cache
    before returning it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用“GetCachedItem（）”将项目存储在缓存中，然后返回它。第二次调用从缓存中获取项目并返回它。睡眠线程使缓存无效，因此最后一次调用在返回项目之前将项目存储在缓存中。
- en: Adding file logging capabilities
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加文件日志功能
- en: 'In our project, the logging, auditing, and instrumentation processes will send
    their output to a text file. So, we will need a class to manage adding the files
    if they don''t exist, and then adding the output to those files and saving them.
    Add a folder to the class library called `FileSystem`. Then, add a class called
    `LogFile`. Set the class as `public static` and add the following member variables:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，日志记录、审计和仪表化过程将它们的输出发送到文本文件。因此，我们需要一个类来管理如果文件不存在则添加文件，然后将输出添加到这些文件并保存它们。在类库中添加一个名为“FileSystem”的文件夹。然后，添加一个名为“LogFile”的类。将该类设置为“public
    static”，并添加以下成员变量：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `_location` variable is assigned the folder for the entry assembly. The
    `_filename` variable is assigned the name of the file with the file extension.
    We need to add the `Logs` folder at runtime (if it does not exist). So, we will
    add the `AddDirectory()` method to the `FileSystem` class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: _location变量被分配为条目程序集的文件夹。_filename变量被分配为带有文件扩展名的文件名。我们需要在运行时添加“Logs”文件夹（如果不存在）。因此，我们将在“FileSystem”类中添加“AddDirectory（）”方法：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `AddDirectory()` method checks whether the location exists. If it does
    not exist, then the directory is created. Next, we need to deal with adding the
    file if it does not exist. So, add the `AddFile()` method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: “AddDirectory（）”方法检查位置是否存在。如果不存在，则创建该目录。接下来，我们需要处理如果文件不存在则添加文件的情况。因此，添加“AddFile（）”方法：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `AddFile()` method, we combine the location and filename. If the filename
    already exists, then we exit the method; otherwise, we create the file. If we
    don''t use the `using` statement, we will encounter `IOException` when we create
    our first record, but subsequent saves will be fine. So, by using the `using`
    statement, we avoid the exception and log the data. We can now write a method
    that actually saves the data to a file. Add the `AppendTextToFile()` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在“AddFile（）”方法中，我们将位置和文件名组合在一起。如果文件名已经存在，那么我们退出方法；否则，我们创建文件。如果我们不使用“using”语句，当我们创建我们的第一条记录时，我们将遇到“IOException”，但随后的保存将会很好。因此，通过使用“using”语句，我们避免了异常并记录了数据。现在我们可以编写一个实际将数据保存到文件的方法。添加“AppendTextToFile（）”方法：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `AppendTextToFile()` method takes a filename and text and sets the location
    to that of the entry assembly. It then ensures that the file and directory exist.
    Then, it saves the text to the specified file. Our file logging capabilities are
    now taken care of, so now, we can move on to look at our logging concern.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: “AppendTextToFile（）”方法接受文件名和文本，并将位置设置为条目程序集的位置。然后，它确保文件和目录存在。然后，它将文本保存到指定的文件中。现在我们已经处理了文件日志功能，现在我们可以继续查看我们的日志关注。
- en: Adding the logging concern
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加日志关注
- en: 'Most applications need some form of logging. The usual methods of logging are
    to the console, filesystem, event logs, and database. In our project, we will
    only focus on console and text file logging. Add a folder called `Logging` to
    the class library. Then, add a file called `ConsoleLoggingAspect` and update it
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都需要某种形式的日志记录。通常的日志记录方法是控制台、文件系统、事件日志和数据库。在我们的项目中，我们只关注控制台和文本文件日志记录。在类库中添加一个名为“Logging”的文件夹。然后，添加一个名为“ConsoleLoggingAspect”的文件，并更新如下：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `[PSerializable]` attribute informs PostSharp to generate a serializer
    for use by `PortableFormatter`. `ConsoleLoggingAspect` inherits from `OnMethodBoundaryAspect`.
    The `OnMethodBoundaryAspect` class has methods that we can override to add code
    before a method body executes, after a method body executes, when a method body
    executes successfully, and when an exception is encountered. We will override
    these methods to output a message to the console. This can be a very useful tool
    when it comes to debugging to see whether code actually gets called and whether
    it successfully completes or encounters an exception. We will start by overriding
    the `OnEntry()` method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`[PSerializable]` 属性通知 PostSharp 生成一个供 `PortableFormatter` 使用的序列化器。`ConsoleLoggingAspect`
    继承自 `OnMethodBoundaryAspect`。`OnMethodBoundaryAspect` 类有我们可以重写的方法，以在方法主体执行之前、之后、成功执行时以及遇到异常时添加代码。我们将重写这些方法以向控制台输出消息。当涉及调试时，这可能是一个非常有用的工具，以查看代码是否实际被调用，以及它是否成功完成或遇到异常。我们将从重写
    `OnEntry()` 方法开始：'
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `OnEntry()` method executes before the body of our methods do, and our
    override prints out the name of the method been executed and its own name. Next,
    we''ll override the `OnExit()` method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnEntry()` 方法在我们的方法体执行之前执行，并且我们的重写打印出已执行的方法的名称和它自己的名称。接下来，我们将重写 `OnExit()`
    方法：'
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `OnExit()` method executes after the body of our methods have finished
    executing, and our override prints out the name of the method that has been executed
    and its own name. Now, we''ll add the `OnSuccess()` method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnExit()` 方法在我们的方法体执行完成后执行，并且我们的重写打印出已执行的方法的名称和它自己的名称。现在，我们将添加 `OnSuccess()`
    方法：'
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `OnSuccess()` method executes after the body of the method it is applied
    to has finished and returns without exception. When our override executes, it
    prints out the name of the executed method and its own name. The last method we
    will override is the `OnException()` method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnSuccess()` 方法在应用于方法的主体完成并且没有异常返回后执行。当我们的重写执行时，它打印出已执行的方法的名称和它自己的名称。我们将要重写的最后一个方法是
    `OnException()` 方法：'
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `OnException()` method executes when an exception is encountered, and in
    our override, we print out the name of the method and the argument''s object.
    To apply the attribute, use `[ConsoleLoggingAspect]`. To add a text file logging
    aspect, add a class called `TextFileLoggingAspect`. `TextFileLoggingAspect` is
    identical to `ConsoleLoggingAspect`, apart from the contents of the overridden
    methods. The `OnEntry()`, `OnExit()`, and `OnSuccess()` methods call the `LogFile.AppendTextToFile()`
    method and append the contents to the `Log.txt` file. The `OnException()` method
    does the same, except it appends the contents to the `Exception.log` file. Here
    is the `OnEntry()` example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnException()` 方法在遇到异常时执行，在我们的重写中，我们打印出方法的名称和参数对象的名称。要应用属性，请使用 `[ConsoleLoggingAspect]`。要添加文本文件日志记录方面，添加一个名为
    `TextFileLoggingAspect` 的类。`TextFileLoggingAspect` 与 `ConsoleLoggingAspect` 相同，除了重写方法的内容。`OnEntry()`、`OnExit()`
    和 `OnSuccess()` 方法调用 `LogFile.AppendTextToFile()` 方法，并将内容附加到 `Log.txt` 文件中。`OnException()`
    方法也是一样，只是它将内容附加到 `Exception.log` 文件中。这是 `OnEntry()` 的示例：'
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That is our logging taken care of. Now, we'll move on to adding our exceptions
    concern.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的日志记录处理完毕。现在，我们将继续添加我们的异常处理关注。
- en: Adding the exception-handling concern
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加异常处理关注
- en: 'It is inevitable with software that exceptions will be experienced by users
    of the software. So, there needs to be some way to log them. The normal way of
    logging exceptions is to store the error in a file on the user''s system, such
    as with `Exception.log`. That''s what we''ll do in this section. We will inherit
    from the `OnExceptionAspect` class and write our exception data to the `Exception.log` file,
    which will be located in the `Logs` folder of our application. `OnExceptionAspect`
    wraps the tagged method in a `try`/`catch` block. Add a new folder to the class
    library called `Exceptions`, and then add a file called `ExceptionAspect` with
    the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，用户将不可避免地遇到异常。因此，需要一些方法来记录它们。记录异常的常规方式是将错误存储在用户系统上的文件中，例如 `Exception.log`。这就是我们将在本节中做的。我们将继承自
    `OnExceptionAspect` 类，并将我们的异常数据写入 `Exception.log` 文件中，该文件将位于我们应用程序的 `Logs` 文件夹中。`OnExceptionAspect`
    将标记的方法包装在 `try`/`catch` 块中。在类库中添加一个名为 `Exceptions` 的新文件夹，然后添加一个名为 `ExceptionAspect`
    的文件，其中包含以下代码：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `ExceptionAspect` class is assigned the `[PSerializable]` aspect and inherits
    from `OnExceptionAspect`. We have three properties: `message`, `ExceptionType`,
    and `FlowBehavior`. `message` contains the exception message, `ExceptionType`
    contains the type of exception encountered, and `FlowBehavior` determines whether
    execution continues once the exception is handled or whether the process terminates.
    The `GetExceptionType()` method returns the type of exception that was thrown.
    The `OnException()` method starts by constructing the error message. It then logs
    the exception to file by calling `LogFile.AppendTextToFile()`. Finally, the flow
    of the exception''s behavior is set to continue.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceptionAspect` 类被分配了 `[PSerializable]` 方面，并继承自 `OnExceptionAspect`。我们有三个属性：`message`、`ExceptionType`
    和 `FlowBehavior`。`message` 包含异常消息，`ExceptionType` 包含遇到的异常类型，`FlowBehavior` 决定异常处理后是否继续执行或者进程是否终止。`GetExceptionType()`
    方法返回抛出的异常类型。`OnException()` 方法首先构造错误消息。然后通过调用 `LogFile.AppendTextToFile()` 将异常记录到文件中。最后，异常行为的流程被设置为继续。'
- en: All you have to do to use the `[ExceptionAspect]` aspect is add it as an attribute
    to your method. We have now covered exception-handling. So, we'll move on to adding
    our security concern.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `[ExceptionAspect]` 方面的唯一要做的就是将其作为属性添加到您的方法中。我们现在已经涵盖了异常处理。所以，我们将继续添加我们的安全性关注。
- en: Adding the security concern
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加安全性关注
- en: The security needs will be specific to the project being worked on. The most
    common concerns are that users are authenticated and authorized to access and
    use various parts of the system. In this section, we will use the decorator pattern
    to implement a secure component with role-based methods.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 安全需求将针对正在开发的项目而具体。最常见的问题是用户是否经过身份验证并获得授权访问和使用系统的各个部分。在本节中，我们将使用装饰器模式实现具有基于角色的方法的安全组件。
- en: Security is a very large subject in itself and beyond the scope of this book.
    There are many good APIs out there, such as the various Microsoft APIs. Refer
    to [https://docs.microsoft.com/en-us/dotnet/standard/security/](https://docs.microsoft.com/en-us/dotnet/standard/security/) for
    more information, and for OAuth 2.0, refer to [https://oauth.net/code/dotnet/](https://oauth.net/code/dotnet/).
    We will leave you to select and implement your own method of security. In this
    chapter, we simply add our own custom-defined security using the decorator pattern.
    You can use this as a base for implementing any of the aforementioned security
    methods.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 安全本身是一个非常庞大的主题，超出了本书的范围。有许多优秀的API，例如各种Microsoft API。有关更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/standard/security/](https://docs.microsoft.com/en-us/dotnet/standard/security/)，有关OAuth
    2.0，请参阅[https://oauth.net/code/dotnet/](https://oauth.net/code/dotnet/)。我们将让您选择并实现自己的安全方法。在本章中，我们只是使用装饰器模式添加了我们自己定义的安全性。您可以将其用作实现任何前述安全方法的基础。
- en: 'Add a new folder called `Security` and add an interface to it called `ISecureComponent`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 新增一个名为`Security`的文件夹，并为其添加一个名为`ISecureComponent`的接口：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our secure component interface contains the preceding four methods, which are
    self-explanatory. The `dynamic` keyword means that any type of data can be passed
    in as a parameter and that any type of data can be returned from the `GetData()`
    method. Next, we need an abstract class that implements the interface. Add a class
    called `DecoratorBase`, as shown:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的安全组件接口包含前面的四种方法，这些方法都是不言自明的。`dynamic`关键字意味着可以将任何类型的数据作为参数传递，并且可以从`GetData()`方法返回任何类型的数据。接下来，我们需要一个实现接口的抽象类。添加一个名为`DecoratorBase`的类，如下所示：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `DecoratorBase` class implements `ISecureComponent`. We declare a member
    variable of the `ISecureComponent` type and set it in the default constructor.
    We need to add the missing methods of `ISecureComponent`. Add the `AddData()`
    method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`DecoratorBase`类实现了`ISecureComponent`。我们声明了一个`ISecureComponent`类型的成员变量，并在默认构造函数中设置它。我们需要添加`ISecureComponent`的缺失方法。添加`AddData()`方法：'
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This method will take any type of data and then pass it into the call to the
    `AddData()` method of `_secureComponent`. Add the missing methods for `EditData()`,
    `DeleteData()`, and `GetData()`. Now, add a class called `ConcreteSecureComponent`,
    which implements `ISecureComponent`. For each method, write a message to the console.
    For the `DeleteData()` and `EditData()` methods, also return a value of `1`. Return
    `"Hi!"` for `GetData()`. The `ConcreteSecureComponent` class is the class that
    executes the secure work that we are interested in.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将接受任何类型的数据，然后将其传递给`_secureComponent`的`AddData()`方法。为`EditData()`、`DeleteData()`和`GetData()`添加缺失的方法。现在，添加一个名为`ConcreteSecureComponent`的类，该类实现了`ISecureComponent`。对于每个方法，向控制台写入一条消息。对于`DeleteData()`和`EditData()`方法，还返回一个值`1`。对于`GetData()`，返回`"Hi!"`。`ConcreteSecureComponent`类是执行我们感兴趣的安全工作的类。
- en: 'We need a way to validate the user and obtain their role. The role will be
    checked before executing any methods. So, add the following struct:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种验证用户并获取其角色的方法。在执行任何方法之前，将检查角色。因此，添加以下结构：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To keep things simple, the struct takes a username and password and sets the
    appropriate role. Restricted users have fewer privileges than administrators.
    The final class for our security concern is the `ConcreteDecorator` class. Add
    the class, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，该结构接受用户名和密码，并设置适当的角色。受限用户的权限比管理员少。我们安全问题的最终类是`ConcreteDecorator`类。添加如下类：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `ConcreteDecorator` class inherits the `DecoratorBase` class. Our constructor
    takes a type of `ISecureComponent` and passes it to the base class. Add the `AddData()`
    method:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcreteDecorator`类继承自`DecoratorBase`类。我们的构造函数接受`ISecureComponent`类型，并将其传递给基类。添加`AddData()`方法：'
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`AddMethod()` checks the user''s role against the allowed `Administrator` and
    `Restricted` roles. If the user is in one of these roles, then the `AddData()`
    method is executed in the base class; otherwise, `UnauthorizedAccessException`
    is thrown. The rest of the methods follow this same pattern. Override the rest
    of the methods, but make sure the `DeleteData()` method can only be executed by
    administrators.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddMethod()`检查用户的角色是否与允许的`Administrator`和`Restricted`角色匹配。如果用户属于这些角色之一，则在基类中执行`AddData()`方法；否则，抛出`UnauthorizedAccessException`。其他方法遵循相同的模式。重写其他方法，但确保`DeleteData()`方法只能由管理员执行。'
- en: 'We will now put our security concerns to work. Add the following line to the
    top of the `Program` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始处理安全问题。在`Program`类的顶部添加以下行：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We are declaring and instantiating a concrete decorator object and passing
    in the concrete secure object. This object will be referenced in our data methods.
    Update the `Main()` method, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明并实例化一个具体的装饰器对象，并传入具体的安全对象。此对象将在我们的数据方法中引用。更新`Main()`方法，如下所示：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We assign the username and password to the `Credentials` struct. This causes
    `Role` to be set. We then call the `DoWork()` method. The `DoWork()` method will
    be responsible for calling the data methods. We then pause for the user to press
    any key and exit. Add the `DoWork()` method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用户名和密码分配给`Credentials`结构。这将导致设置`Role`。然后调用`DoWork()`方法。`DoWork()`方法将负责调用数据方法。然后暂停等待用户按任意键并退出。添加`DoWork()`方法：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `DoSecureWork()` method calls each of the data methods that call the data
    methods on the concrete decorator. Add the `AddData()` method:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoSecureWork()`方法调用每个调用具体装饰器上的数据方法的数据方法。添加`AddData()`方法：'
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`[ExceptionAspect]` is applied to the `AddData()` method. This will ensure
    any errors are logged to the `Exceptions.log` file. The parameter is set to `true`,
    and so the error message will also be printed in the console window. The method
    itself calls the `AddData()` method on the `ConcreteDecorator` class. Add the
    rest of the methods by following the same procedure. Then, run your code. You
    should see the following output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ExceptionAspect]`应用于`AddData()`方法。这将确保任何错误都被记录到`Exceptions.log`文件中。参数设置为`true`，因此错误消息也将打印在控制台窗口中。方法本身调用`ConcreteDecorator`类的`AddData()`方法。按照相同的步骤添加其余的方法。然后运行你的代码。你应该看到以下输出：'
- en: '![](img/847bde47-fa68-4381-aba1-0c89cd4987ae.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/847bde47-fa68-4381-aba1-0c89cd4987ae.png)'
- en: We now have a working role-based object, complete with exception handling. Our
    next step is to implement our validation concern.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以工作的基于角色的对象，包括异常处理。我们的下一步是实现验证关注点。
- en: Adding the validation concern
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加验证关注点
- en: 'All user-entered data should be validated as it could be malicious, incomplete,
    or in the wrong format. You need to ensure that your data is clean and cannot
    cause harm. For our demonstration concern, we will implement null validation.
    Start by adding a folder called `Validation` to the class library. Then, add a
    new class called `AllowNullAttribute`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用户输入的数据都应该经过验证，因为它可能是恶意的、不完整的或格式错误的。您需要确保您的数据是干净的，不会造成伤害。对于我们的演示关注点，我们将实现空值验证。首先，在类库中添加一个名为`Validation`的文件夹。然后，添加一个名为`AllowNullAttribute`的新类：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This attribute allows nulls on parameters, return values, and properties. Now,
    add the `ValidationFlags` enum to a new file of the same name:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性允许参数、返回值和属性上的空值。现在，将`ValidationFlags`枚举添加到同名的新文件中：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'These flags are used to determine what items an aspect can be applied to. Next,
    we''ll add a class called `ReflectionExtensions`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志用于确定方面可以应用于哪些项。接下来，我们将添加一个名为`ReflectionExtensions`的类：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `IsCustomAttributeDefined()` method returns `true` if the attribute type
    is defined on this member, and `false` otherwise. The `AllowsNull()` method returns
    `true` if the `[AllowNull]` attribute is already applied, and `false` if not.
    The `MayNotBeNull()` method checks to see whether nulls are allowed, whether the
    parameter is optional, and what type of value the parameter is. A Boolean value
    is then returned by performing logical `AND` operations on these values. It''s
    time to add `DisallowNonNullAspect`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsCustomAttributeDefined()`方法在该成员上定义了该属性类型时返回`true`，否则返回`false`。`AllowsNull()`方法在已应用`[AllowNull]`属性时返回`true`，否则返回`false`。`MayNotBeNull()`方法检查是否允许空值，参数是否可选，以及参数的值类型。然后通过对这些值进行逻辑`AND`操作来返回一个布尔值。现在是时候添加`DisallowNonNullAspect`了：'
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This class has the `[PSerializable]` attribute applied to inform PostSharp
    to generate a serializer for `PortableFormatter`. It also inherits the `OnMethodBoundaryAspect`
    class. We then declare variables to hold the input and output arguments as validated
    parameter names, return value validation and the member name, and check whether
    the item being validated is a property. The default constructor is configured
    to allow the validator to be applied to all public members. We also have a constructor
    that takes a `ValidationFlags` value and a `ValidationFlags` property. Now, we''ll
    override the `CompileTimeValidate()` method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该类应用了`[PSerializable]`属性，以通知PostSharp为`PortableFormatter`生成序列化程序。它还继承了`OnMethodBoundaryAspect`类。然后，我们声明变量来保存经过验证的参数名称、返回值验证和成员名称，并检查被验证的项是否是属性。默认构造函数配置为允许验证器应用于所有公共成员。我们还有一个构造函数，它接受一个`ValidationFlags`值和一个`ValidationFlags`属性。现在，我们将重写`CompileTimeValidate()`方法：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This method ensures that the aspect is correctly applied at compile-time. If
    the aspect is applied to a wrong type of member, then `false` is returned. Otherwise,
    it returns `true`. We now override the `OnEntry()` method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法确保在编译时正确应用了该方面。如果该方面应用于错误类型的成员，则返回`false`。否则，返回`true`。现在我们将重写`OnEntry()`方法：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This method checks the *input arguments* to validate. If any arguments are
    `null`, then `ArgumentNullException` is thrown; otherwise, the method exits without
    throwing an exception. Let''s override the `OnSuccess()` method now:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法检查*输入参数*进行验证。如果任何参数为`null`，则会抛出`ArgumentNullException`；否则，该方法将在不抛出异常的情况下退出。现在让我们重写`OnSuccess()`方法：
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `OnSuccess()` method validates the *output parameters* to validate. If
    any arguments are null, then `InvalidOperationException` will be thrown. The next
    thing we need to do is add `private class` for extracting method information.
    Add the following class to the bottom of the `DisallowNonNullAspect` class before
    the closing brace:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnSuccess()`方法验证*输出参数*。如果任何参数为null，则会抛出`InvalidOperationException`。接下来我们需要做的是添加一个用于提取方法信息的`private
    class`。在`DisallowNonNullAspect`类的结束大括号之前，添加以下类：'
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add the following three constructors to the `MethodInformation` class:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下三个构造函数添加到`MethodInformation`类中：
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'These constructors differentiate between constructors and methods and perform
    the necessary initialization of the method. Add the following method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构造函数区分构造函数和方法，并对方法进行必要的初始化。添加以下方法：
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `CreateInstance()` method creates a new instance of the `MethodInformation`
    class based on the `MethodInfo` data of the method passed in and returns that
    instance. Add the `GetMethodInformation()` method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateInstance()`方法根据传入的方法的`MethodInfo`数据创建`MethodInformation`类的新实例，并返回该实例。添加`GetMethodInformation()`方法：'
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This method casts `methodBase` to `ConstructorInfo` and checks for `null`. If
    `ctor` is not `null`, then a new `MethodInformation` class is generated based
    on the constructor. However, if `ctor` is `null`, then `methodBase` is cast to
    `MethodInfo`. If the method is not `null`, then the `CreateInstance()` method
    is called, passing in the method. Otherwise, `null` is returned. Finally, add
    the following properties to the class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将`methodBase`转换为`ConstructorInfo`并检查是否为`null`。如果`ctor`不为`null`，则基于构造函数生成一个新的`MethodInformation`类。但是，如果`ctor`为`null`，则将`methodBase`转换为`MethodInfo`。如果方法不为`null`，则调用`CreateInstance()`方法，传入该方法。否则，返回`null`。最后，将以下属性添加到类中：
- en: '[PRE58]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: These properties are properties of the method that has the aspect applied. We
    have now finished writing our validation aspect. You can now use the validator
    to allow nulls by attaching the `[AllowNull]` attribute. You can disallow nulls
    by attaching `[DisallowNonNullAspect]`. Now, we'll add our transaction concern.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性是应用了该方面的方法的属性。我们现在已经完成了编写验证方面。您现在可以使用验证器通过附加`[AllowNull]`属性来允许空值。您可以通过附加`[DisallowNonNullAspect]`来禁止空值。现在，我们将添加事务关注点。
- en: Adding the transaction concern
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加事务关注点
- en: 'Transactions are processes that must run to completion or rollback. Add a new
    folder to the class library called `Transactions`*, *and then add the `RequiresTransactionAspect`
    class:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 事务是必须要完成或回滚的过程。在类库中添加一个名为`Transactions`的新文件夹，然后添加`RequiresTransactionAspect`类：
- en: '[PRE59]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `OnEntry()` method starts the transaction, the `OnSuccess()` method completes
    the exception, and the `OnExit()` method disposes of the transaction. To use the
    aspect, add `[RequiresTransactionAspect]` to your method. To log any exceptions
    that prevent the completion of the transaction, you can also assign the `[ExceptionAspect(consoleOutput:
    false)]` aspect. Next, we''ll add our resource pool concern.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnEntry()`方法启动事务，`OnSuccess()`方法完成异常，`OnExit()`方法处理事务。要使用该方面，请在您的方法中添加`[RequiresTransactionAspect]`。要记录任何阻止事务完成的异常，还可以分配`[ExceptionAspect(consoleOutput:
    false)]`方面。接下来，我们将添加资源池关注点。'
- en: Adding the resource pool concern
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加资源池关注点
- en: 'Resource pools are a good way to improve performance when multiple instances
    of an object are expensive to create and destroy. We will create a very simple
    resource pool for our needs. Add a folder called `ResourcePooling`, and then add
    the `ResourcePool` class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 资源池是在创建和销毁对象的多个实例昂贵时提高性能的好方法。我们将为我们的需求创建一个非常简单的资源池。添加一个名为`ResourcePooling`的文件夹，然后添加`ResourcePool`类：
- en: '[PRE60]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This class creates a new resource generator and stores resources in `ConcurrentBag`.
    When an item is requested, it issues a resource from the pool. If one does not
    exist, then it is created, added to the pool, and issued to the caller:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 该类创建一个新的资源生成器，并将资源存储在`ConcurrentBag`中。当请求项目时，它会从池中发出一个资源。如果不存在，则会创建一个并将其添加到池中，并发放给调用者：
- en: '[PRE61]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The code you've just seen shows you how to use the `ResourcePool` class to create
    a pool, obtain a resource, and return it to the pool.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚看到的代码向您展示了如何使用`ResourcePool`类来创建资源池，获取资源并将其返回到资源池中。
- en: Adding the configuration settings concern
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加配置设置关注点
- en: 'Configuration settings should always be centralized. Since desktop applications
    store their settings in the `app.config` file and web applications store their
    settings in `Web.config`, we can use `ConfigurationManager` to access the application
    settings. Add the `System.Configuration.Configuration` NuGet library to your class
    library and test the harness. Then, add a folder called `Configuration` and the
    following `Settings` class:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 配置设置应始终集中。由于桌面应用程序将其设置存储在`app.config`文件中，而Web应用程序将其设置存储在`Web.config`文件中，因此我们可以使用`ConfigurationManager`来访问应用程序设置。将`System.Configuration.Configuration`
    NuGet库添加到您的类库中并测试测试工具。然后，添加一个名为`Configuration`的文件夹和以下`Settings`类：
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This class will get and set app settings in the `Web.config` file and the `App.config`
    file. To include the class in your files, add the following `using` statement:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 该类将在`Web.config`文件和`App.config`文件中获取和设置应用程序设置。要在您的文件中包含该类，请添加以下`using`语句：
- en: '[PRE63]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following code shows you how to use the methods:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码向您展示了如何使用这些方法：
- en: '[PRE64]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Using the static import, you don't have to include the `class` prefix. You can
    extend the `Settings` class to get connection strings or to do whatever configuration
    you need in your apps.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态导入，您无需包含`class`前缀。您可以扩展`Settings`类以获取连接字符串或在应用程序中执行所需的任何配置。
- en: Adding the instrumentation concern
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加仪器化关注点
- en: 'Our final cross-cutting concern is that of instrumentation. We use instrumentation
    to profile our application and see how long it takes for methods to execute. Add
    a folder to the class library called `Instrumentation`, and then add the `InstrumentationAspect`
    class, as shown:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终横切关注点是仪器化。我们使用仪器化来分析我们的应用程序，并查看方法执行所需的时间。在类库中添加一个名为`Instrumentation`的文件夹，然后添加`InstrumentationAspect`类，如下所示：
- en: '[PRE65]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As you can see, the instrumentation aspect only applies to methods, times the
    start and stop times of the method, and logs the profile information to the `Profile.log`
    file. If an exception is encountered, then the exception is logged to the `Exception.log`
    file.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，仪器化方面仅适用于方法，记录方法的开始和结束时间，并将配置文件信息记录到`Profile.log`文件中。如果遇到异常，则将异常记录到`Exception.log`文件中。
- en: We now have a functional and reusable cross-cutting concerns library. Let's
    summarize what we have learned in this chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有一个功能齐全且可重用的横切关注点库。让我们总结一下本章学到的内容。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've learned some valuable information. We started off by looking at the decorator
    pattern and then the proxy pattern. The proxy pattern provides objects that act
    as substitutes for real service objects used by clients. A proxy receives a client
    request, performs the necessary work, and then passes the request to the service
    object. Since proxies share the same interfaces as the services they substitute,
    they are interchangeable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了一些宝贵的信息。我们首先看了装饰器模式，然后是代理模式。代理模式提供了作为客户端使用的真实服务对象的替代品。代理接收客户端请求，执行必要的工作，然后将请求传递给服务对象。由于代理与它们替代的服务共享相同的接口，它们是可互换的。
- en: After covering the proxy pattern, we then moved onto AOP with PostSharp. We
    saw how we can use aspects and attributes together to decorate code so that at
    compile-time, it injects code to perform the required operations, such as exception
    handling, logging, auditing, and security. We extended the aspect framework by
    developing our own aspect and looked at how to use PostSharp and the decorator
    pattern to address the cross-cutting concerns of configuration management, logging,
    auditing, security, validation, exception handling, instrumentation, transactions,
    resource pooling, caching, threading, and concurrency.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了代理模式之后，我们转向了使用PostSharp进行AOP。我们看到了如何将切面和属性一起使用来装饰代码，以便在编译时注入代码来执行所需的操作，例如异常处理、日志记录、审计和安全性。我们通过开发自己的切面来扩展了切面框架，并研究了如何使用PostSharp和装饰器模式来解决配置管理、日志记录、审计、安全性、验证、异常处理、仪器化、事务、资源池、缓存、线程和并发的横切关注点。
- en: In the next chapter, we will look at using tools to help you improve your code
    quality. But before then, test your knowledge and then further your reading.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看使用工具来帮助您提高代码质量。但在那之前，测试一下您的知识，然后继续阅读。
- en: Questions
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a cross-cutting concern and what does AOP stand for?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是横切关注点，AOP代表什么？
- en: What is an aspect and how do you apply one?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是切面，如何应用切面？
- en: What is an attribute and how do you apply one?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是属性，如何应用属性？
- en: How do the aspects and attributes work together?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切面和属性如何一起工作？
- en: How does the build process work with aspects?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切面如何与构建过程一起工作？
- en: Further reading
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The PostSharp home page: [https://www.postsharp.net/](https://www.postsharp.net/download)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostSharp主页：[https://www.postsharp.net/](https://www.postsharp.net/download)
