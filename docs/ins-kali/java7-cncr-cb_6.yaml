- en: Chapter 6. Concurrent Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。并发集合
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Using non-blocking thread-safe lists
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非阻塞线程安全列表
- en: Using blocking thread-safe lists
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阻塞线程安全列表
- en: Using blocking thread-safe lists ordered by priority
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用按优先级排序的阻塞线程安全列表
- en: Using thread-safe lists with delayed elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带延迟元素的线程安全列表
- en: Using thread-safe navigable maps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程安全的可导航映射
- en: Generating concurrent random numbers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成并发随机数
- en: Using atomic variables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子变量
- en: Using atomic arrays
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子数组
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: '**Data structures** are a basic element in programming. Almost every program
    uses one or more types of data structures to store and manage their data. Java
    API provides the **Java Collections framework** that contains interfaces, classes,
    and algorithms, which implement a lot of different data structures that you can
    use in your programs.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据结构**是编程中的基本元素。几乎每个程序都使用一种或多种类型的数据结构来存储和管理它们的数据。Java API提供了**Java集合框架**，其中包含接口、类和算法，实现了许多不同的数据结构，您可以在程序中使用。'
- en: When you need to work with data collections in a concurrent program, you must
    be very careful with the implementation you choose. Most collection classes are
    not ready to work with concurrent applications because they don't control the
    concurrent access to its data. If some concurrent tasks share a data structure
    that is not ready to work with concurrent tasks, you can have data inconsistency
    errors that will affect the correct operation of the program. One example of this
    kind of data structures is the `ArrayList` class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在并发程序中处理数据集合时，必须非常小心地选择实现。大多数集合类都不准备与并发应用程序一起工作，因为它们无法控制对其数据的并发访问。如果一些并发任务共享一个不准备与并发任务一起工作的数据结构，您可能会遇到数据不一致的错误，这将影响程序的正确运行。这种数据结构的一个例子是`ArrayList`类。
- en: 'Java provides data collections that you can use in your concurrent programs
    without any problems or inconsistency. Basically, Java provides two kinds of collections
    to use in concurrent applications:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了可以在并发程序中使用的数据集合，而不会出现任何问题或不一致。基本上，Java提供了两种在并发应用程序中使用的集合：
- en: '**Blocking collections**: This kind of collection includes operations to add
    and remove data. If the operation can''t be made immediately, because the collection
    is full or empty, the thread that makes the call will be blocked until the operation
    can be made.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻塞集合**：这种类型的集合包括添加和删除数据的操作。如果操作无法立即完成，因为集合已满或为空，进行调用的线程将被阻塞，直到操作可以完成。'
- en: '**Non-blocking collections**: This kind of collection also includes operations
    to add and remove data. If the operation can''t be made immediately, the operation
    returns a `null` value or throws an exception, but the thread that makes the call
    won''t be blocked.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非阻塞集合**：这种类型的集合还包括添加和删除数据的操作。如果操作无法立即完成，操作将返回`null`值或抛出异常，但进行调用的线程不会被阻塞。'
- en: 'Through the recipes of this chapter, you will learn how to use some Java collections
    that you can use in your concurrent applications. This includes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的示例，您将学习如何在并发应用程序中使用一些Java集合。这包括：
- en: Non-blocking lists, using the `ConcurrentLinkedDeque` class
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非阻塞列表，使用`ConcurrentLinkedDeque`类
- en: Blocking lists, using the `LinkedBlockingDeque` class
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`LinkedBlockingDeque`类的阻塞列表
- en: Blocking lists to be used with producers and consumers of data, using the `LinkedTransferQueue`
    class
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`LinkedTransferQueue`类的阻塞列表与数据的生产者和消费者一起使用
- en: Blocking lists that order their elements by priority, with the `PriorityBlockingQueue`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`PriorityBlockingQueue`对其元素按优先级排序的阻塞列表
- en: Blocking lists with delayed elements, using the `DelayQueue` class
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`DelayQueue`类的带延迟元素的阻塞列表
- en: Non-blocking navigable maps, using the `ConcurrentSkipListMap` class
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ConcurrentSkipListMap`类的非阻塞可导航映射
- en: Random numbers, using the `ThreadLocalRandom` class
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机数，使用`ThreadLocalRandom`类
- en: Atomic variables, using the `AtomicLong` and `AtomicIntegerArray` classes
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子变量，使用`AtomicLong`和`AtomicIntegerArray`类
- en: Using non-blocking thread-safe lists
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用非阻塞线程安全列表
- en: The most basic collection is the **list**. A list has an undetermined number
    of elements and you can add, read, or remove the element of any position. Concurrent
    lists allow the various threads to add or remove elements in the list at a time
    without producing any data inconsistency.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的集合是**列表**。列表具有不确定数量的元素，您可以在任何位置添加、读取或删除元素。并发列表允许各个线程同时在列表中添加或删除元素，而不会产生任何数据不一致。
- en: In this recipe, you will learn how to use non-blocking lists in your concurrent
    programs. Non-blocking lists provide operations that, if the operation can't be
    done immediately (for example, you want to get an element of the list and the
    list is empty), they throw an exception or return a `null` value, depending on
    the operation. Java 7 has introduced the `ConcurrentLinkedDeque` class that implements
    a non-blocking concurrent list.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您将学习如何在并发程序中使用非阻塞列表。非阻塞列表提供操作，如果操作无法立即完成（例如，您想获取列表的元素，而列表为空），它们会抛出异常或返回`null`值，具体取决于操作。Java
    7引入了实现非阻塞并发列表的`ConcurrentLinkedDeque`类。
- en: 'We are going to implement an example with the following two different tasks:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个示例，其中包括以下两个不同的任务：
- en: One that adds data to a list massively
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大量向列表中添加数据的任务
- en: One that removes data from the same list massively
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大量从同一列表中删除数据的任务
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `AddTask` and specify that it implements the `Runnable`
    interface.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AddTask`的类，并指定它实现`Runnable`接口。
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Declare a private `ConcurrentLinkedDeque` attribute parameterized with the `String`
    class named `list`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个参数为`String`类的私有`ConcurrentLinkedDeque`属性，命名为`list`。
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Implement the constructor of the class to initialize its attribute.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Implement the `run()` method of the class. It will store 10,000 strings in the
    list with the name of the thread that is executing the task and a number.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的`run()`方法。它将在列表中存储10,000个带有执行任务的线程名称和数字的字符串。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Create a class named `PollTask` and specify that it implements the `Runnable`
    interface.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PollTask`的类，并指定它实现`Runnable`接口。
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Declare a private `ConcurrentLinkedDeque` attribute parameterized with the `String`
    class named `list`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个参数为`String`类的私有`ConcurrentLinkedDeque`属性，命名为`list`。
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Implement the constructor of the class to initialize its attribute.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Implement the `run()` method of the class. It takes out 10,000 elements of the
    list in a loop with 5,000 steps, taking off two elements in each step.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的`run()`方法。它以5,000步的循环方式从列表中取出10,000个元素，每步取出两个元素。
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类。
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create a `ConcurrentLinkedDeque` object parameterized with the `String` class
    named `list`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个参数为`String`类的`ConcurrentLinkedDeque`对象，命名为`list`。
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create an array for 100 `Thread` objects named `threads`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含100个`Thread`对象的数组，命名为`threads`。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create 100 `AddTask` objects and a thread to run each of them. Store every thread
    in the array created earlier and start the threads.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建100个`AddTask`对象和一个线程来运行每个对象。将每个线程存储在之前创建的数组中，并启动这些线程。
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Wait for the completion of the threads using the `join()` method.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待线程的完成。
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Write in the console the size of the list.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中写入列表的大小。
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create 100 `PollTask` objectsand a thread to run each of them. Store every thread
    in the array created earlier and start the threads.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建100个`PollTask`对象和一个线程来运行每个对象。将每个线程存储在之前创建的数组中，并启动这些线程。
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Wait for the finalization of the threads using the `join()` method.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待线程的完成。
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Write in the console the size of the list.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中写入列表的大小。
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we have used the `ConcurrentLinkedDeque` object parameterized
    with the `String` class to work with a non-blocking concurrent list of data. The
    following screenshot shows the output of an execution of this example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们使用了参数为`String`类的`ConcurrentLinkedDeque`对象来处理非阻塞并发数据列表。以下屏幕截图显示了此示例执行的输出：
- en: '![How it works...](img/7881_06_01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![How it works...](img/7881_06_01.jpg)'
- en: First, you have executed 100 `AddTask` tasks to add elements to the list. Each
    one of those tasks inserts 10,000 elements to the list using the `add()` method.
    This method adds the new elements at the end of the list. When all those tasks
    have finished, you have written in the console the number of elements of the list.
    At this moment, the list has 1,000,000 elements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您已经执行了100个`AddTask`任务，向列表中添加元素。这些任务中的每一个都使用`add()`方法向列表中插入10,000个元素。此方法将新元素添加到列表的末尾。当所有这些任务都完成时，您已经在控制台中写入了列表的元素数量。此时，列表中有1,000,000个元素。
- en: Then, you have executed 100 `PollTask` tasks to remove elements from the list.
    Each one of those tasks removes 10,000 elements of the list using the `pollFirst()`
    and `pollLast()` methods. The `pollFirst()` method returns and removes the first
    element of the list and the `pollLast()` method returns and removes the last element
    of the list. If the list is empty, these methods return a `null` value. When all
    those tasks have finished, you have written in the console the number of elements
    of the list. At this moment, the list has zero elements.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您已经执行了100个`PollTask`任务来从列表中移除元素。这些任务中的每一个都使用`pollFirst()`和`pollLast()`方法从列表中移除10,000个元素。`pollFirst()`方法返回并移除列表的第一个元素，`pollLast()`方法返回并移除列表的最后一个元素。如果列表为空，这些方法返回一个`null`值。当所有这些任务都完成时，您已经在控制台中写入了列表的元素数量。此时，列表中没有元素。
- en: To write the number of elements of the list, you have used the `size()` method.
    You have to take into account that this method can return a value that is not
    real, especially if you use it when there are threads adding or deleting data
    in the list. The method has to traverse the entire list to count the elements
    and the contents of the list can change for this operation. Only if you use them
    when there aren't any threads modifying the list, you will have the guarantee
    that the returned result is correct.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入列表的元素数量，您已经使用了`size()`方法。您必须考虑到，这个方法可能会返回一个不真实的值，特别是在有线程向列表中添加或删除数据时。该方法必须遍历整个列表来计算元素的数量，列表的内容可能会因此操作而发生变化。只有在没有任何线程修改列表时使用它们，您才能保证返回的结果是正确的。
- en: There's more...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `ConcurrentLinkedDeque` class provides more methods to get elements form
    the list:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentLinkedDeque`类提供了更多的方法来从列表中获取元素：'
- en: '`getFirst()` and `getLast()`: These methods return the first and last element
    from the list respectively. They don''t remove the returned element from the list.
    If the list is empty, these methods throw a `NoSuchElementExcpetion` exception.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFirst()`和`getLast()`：这些方法分别返回列表的第一个和最后一个元素。它们不会从列表中移除返回的元素。如果列表为空，这些方法会抛出一个`NoSuchElementExcpetion`异常。'
- en: '`peek()`, `peekFirst()`, and `peekLast()`: These methods return the first and
    the last element of the list respectively. They don''t remove the returned element
    from the list. If the list is empty, these methods return a `null` value.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`，`peekFirst()`和`peekLast()`：这些方法分别返回列表的第一个和最后一个元素。它们不会从列表中移除返回的元素。如果列表为空，这些方法返回一个`null`值。'
- en: '`remove()`, `removeFirst()`, `removeLast()`: These methods return the first
    and the last element of the list respectively. They remove the returned element
    from the list. If the list is empty, these methods throw a `NoSuchElementException`
    exception.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`, `removeFirst()`, `removeLast()`: 这些方法分别返回列表的第一个和最后一个元素。它们会从列表中删除返回的元素。如果列表为空，这些方法会抛出`NoSuchElementException`异常。'
- en: Using blocking thread-safe lists
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用阻塞线程安全列表
- en: The most basic collection is the list. A list has an undetermined number of
    elements and you can add, read, or remove the element from any position. A concurrent
    list allows various threads to add or remove elements in the list at a time without
    producing any data inconsistency.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的集合是列表。列表有不确定数量的元素，您可以从任何位置添加、读取或删除元素。并发列表允许多个线程同时添加或删除列表中的元素，而不会产生任何数据不一致性。
- en: In this recipe, you will learn how to use blocking lists in your concurrent
    programs. The main difference between blocking lists and non-blocking lists is
    that blocking lists has methods to insert and delete elements on it that, if they
    can't do the operation immediately, because the list is full or empty, they block
    the thread that make the call until the operation can be made. Java includes the
    `LinkedBlockingDeque` class that implements a blocking list.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您将学习如何在并发程序中使用阻塞列表。阻塞列表和非阻塞列表之间的主要区别在于，阻塞列表具有用于插入和删除元素的方法，如果无法立即执行操作，因为列表已满或为空，它们将阻塞进行调用的线程，直到可以执行操作。Java包括实现阻塞列表的`LinkedBlockingDeque`类。
- en: 'You are going to implement an example with the following two tasks:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您将实现一个示例，其中包括以下两个任务：
- en: One that adds data to a list massively
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大规模地向列表中添加数据
- en: One that removes data from the same list massively
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大规模地从同一列表中删除数据
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用Eclipse IDE实现。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow the steps described next to implement the example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 按照下面描述的步骤来实现示例：
- en: Create a class named `Client` and specify that it implements the `Runnable`
    interface.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Client`的类，并指定它实现`Runnable`接口。
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Declare a private `LinkedBlockingDeque` attribute parameterized with the `String`
    class named `requestList`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`LinkedBlockingDeque`属性，命名为`requestList`，参数化为`String`类。
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Implement the `run()` method. Insert five `String` objects in the list per second
    using the `put()` method of `requestList object`. Repeat that cycle three times.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。使用`requestList`对象的`put()`方法每秒向列表中插入五个`String`对象。重复该循环三次。
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Create the main class of the example by creating a class named `Main` and add
    the `main()` method to it.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并向其中添加`main()`方法，创建示例的主类。
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Declare and create `LinkedBlockingDeque` parameterized with the `String` class
    named `list`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并创建`String`类命名为`list`的`LinkedBlockingDeque`。
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Create and start a `Thread` object to execute a client task.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动一个`Thread`对象来执行客户端任务。
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Get three `String` objects of the list every 300 milliseconds using the `take()`
    method of the list object. Repeat that cycle five times. Write the strings in
    the console.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用列表对象的`take()`方法每300毫秒获取列表的三个`String`对象。重复该循环五次。在控制台中写入字符串。
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Write a message to indicate the end of the program.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一条消息以指示程序的结束。
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, you have used `LinkedBlockingDeque` parameterized with the `String`
    class to work with a non-blocking concurrent list of data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您已经使用了参数化为`String`类的`LinkedBlockingDeque`来处理非阻塞并发数据列表。
- en: The `Client` class uses the `put()` method to insert strings in the list. If
    the list is full (because you have created it with a fixed capacity), the method
    blocks the execution of its thread until there is an empty space in the list.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client`类使用`put()`方法向列表中插入字符串。如果列表已满（因为您使用固定容量创建了它），该方法将阻塞其线程的执行，直到列表中有空间。'
- en: The `Main` class uses the `take()` method to get strings from the list. If the
    list is empty, the method blocks the execution of its thread until there are elements
    in the list.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`类使用`take()`方法从列表中获取字符串。如果列表为空，该方法将阻塞其线程的执行，直到列表中有元素为止。'
- en: Both the methods of the `LinkedBlockingDeque` class used in this example, can
    throw an `InterruptedException` exception if they are interrupted while they are
    blocked, so you have to include the necessary code to catch that exception.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中使用的`LinkedBlockingDeque`类的两种方法，如果它们在被阻塞时被中断，可以抛出`InterruptedException`异常，因此您必须包含必要的代码来捕获该异常。
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `LinkedBlockingDeque` class also provides the methods to put and get elements
    from the list that, instead of being block, throw an exception or return the `null`
    value. These methods are:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedBlockingDeque`类还提供了用于向列表中放置和获取元素的方法，而不是阻塞，它们会抛出异常或返回`null`值。这些方法包括：'
- en: '`takeFirst()` and `takeLast()`: These methods return the first and the last
    element of the list respectively. They remove the returned element from the list.
    If the list is empty, these methods block the thread until there are elements
    in the list.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeFirst()`和`takeLast()`: 这些方法分别返回列表的第一个和最后一个元素。它们会从列表中删除返回的元素。如果列表为空，这些方法会阻塞线程，直到列表中有元素。'
- en: '`getFirst()` and `getLast()`: These methods return the first and last element
    from the list respectively. They don''t remove the returned element from the list.
    If the list is empty, these methods throw a `NoSuchElementExcpetion` exception.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFirst()`和`getLast()`: 这些方法分别返回列表中的第一个和最后一个元素。它们不会从列表中删除返回的元素。如果列表为空，这些方法会抛出`NoSuchElementExcpetion`异常。'
- en: '`peek()`, `peekFirst()`, and `peekLast()`: These methods return the first and
    the last element of the list respectively. They don''t remove the returned element
    from the list. If the list is empty, these methods return a `null` value.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`、`peekFirst()`和`peekLast()`：这些方法分别返回列表的第一个和最后一个元素。它们不会从列表中删除返回的元素。如果列表为空，这些方法返回一个`null`值。'
- en: '`poll()`, `pollFirst()`, and `pollLast()`: These methods return the first and
    the last element of the list respectively. They remove the returned element form
    the list. If the list is empty, these methods return a `null` value.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll()`、`pollFirst()`和`pollLast()`：这些方法分别返回列表的第一个和最后一个元素。它们从列表中删除返回的元素。如果列表为空，这些方法返回一个`null`值。'
- en: '`add()`, `addFirst()`, `addLast()`: These methods add an element in the first
    and the last position respectively. If the list is full (you have created it with
    a fixed capacity), these methods throw an `IllegalStateException` exception.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add()`、`addFirst()`、`addLast()`：这些方法分别在第一个和最后一个位置添加一个元素。如果列表已满（你使用固定容量创建了它），这些方法会抛出`IllegalStateException`异常。'
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using non-blocking thread-safe lists* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章.并发集合")中的*使用非阻塞线程安全列表*配方，*并发集合*'
- en: Using blocking thread-safe lists ordered by priority
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用按优先级排序的阻塞线程安全列表
- en: A typical need when you work with data structures is to have an ordered list.
    Java provides `PriorityBlockingQueue` that has this functionality.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用数据结构时，通常需要有一个有序列表。Java提供了具有这种功能的`PriorityBlockingQueue`。
- en: 'All the elements you want to add to `PriorityBlockingQueue` have to implement
    the `Comparable` interface. This interface has a method, `compareTo()` that receives
    an object of the same type, so you have two objects to compare: the one that is
    executing the method and the one that is received as a parameter. The method must
    return a number less than zero if the local object is less than the parameter,
    a number bigger that zero if the local object is greater than the parameter, and
    the number zero if both objects are equal.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要添加到`PriorityBlockingQueue`中的所有元素都必须实现`Comparable`接口。这个接口有一个方法`compareTo()`，它接收一个相同类型的对象，所以你有两个对象可以比较：执行该方法的对象和作为参数接收的对象。如果本地对象小于参数，则该方法必须返回小于零的数字，如果本地对象大于参数，则返回大于零的数字，如果两个对象相等，则返回零。
- en: '`PriorityBlockingQueue` uses the `compareTo()` method when you insert an element
    in it to determine the position of the element inserted. The greater elements
    will be the tail of the queue.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向`PriorityBlockingQueue`中插入一个元素时，它会使用`compareTo()`方法来确定插入元素的位置。较大的元素将成为队列的尾部。
- en: Another important characteristic of `PriorityBlockingQueue` is that it's a **blocking
    data structure** . It has methods that, if they can't do their operation immediately,
    block the thread until they can do it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`PriorityBlockingQueue`的另一个重要特性是它是一个**阻塞数据结构**。它有一些方法，如果它们不能立即执行操作，就会阻塞线程，直到它们可以执行为止。'
- en: In this recipe, you will learn how to use the `PriorityBlockingQueue` class
    implementing an example, where you are going to store a lot of events with different
    priorities in the same list, to check that the queue will be ordered as you want.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将学习如何使用`PriorityBlockingQueue`类来实现一个示例，其中你将在同一个列表中存储许多具有不同优先级的事件，以检查队列是否按照你的要求排序。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用Eclipse IDE实现。如果你使用Eclipse或其他IDE，比如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Event` and specify that it implements the `Comparable`
    interface parameterized with the `Event` class.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Event`的类，并指定它实现了参数化为`Event`类的`Comparable`接口。
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Declare a private `int` attribute named `thread` to store the number of the
    thread that has created the event.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`int`属性，命名为`thread`，用于存储创建事件的线程号。
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Declare a private `int` attribute named `priority` to store the priority of
    the event.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`int`属性，命名为`priority`，用于存储事件的优先级。
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Implement the `getThread()` method to return the value of the thread attribute.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getThread()`方法以返回线程属性的值。
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Implement the `getPriority()` method to return the value of the priority attribute.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getPriority()`方法以返回优先级属性的值。
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Implement the `compareTo()` method. It receives `Event` as a parameter and compares
    the priority of the current event and the one received as parameter. It returns
    `-1` if the priority of the current event is bigger, `0` if both priorities are
    equal, and `1` if the priority of the current event is smaller. Note that this
    is opposite of most `Comparator.compareTo()` implementations.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`compareTo()`方法。它接收`Event`作为参数，并比较当前事件和接收的参数的优先级。如果当前事件的优先级较大，则返回`-1`，如果两个优先级相等，则返回`0`，如果当前事件的优先级较小，则返回`1`。请注意，这与大多数`Comparator.compareTo()`实现相反。
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Create a class named `Task` and specify that it implements the `Runnable` interface.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，并指定它实现了`Runnable`接口。
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Declare a private `int` attribute named `id` to store the number that identifies
    the task.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`int`属性，命名为`id`，用于存储标识任务的编号。
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Declare a private `PriorityBlockingQueue` attribute parameterized with the `Event`
    class named `queue` to store the events generated by the task.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的参数化为`Event`类的`PriorityBlockingQueue`属性，命名为`queue`，用于存储任务生成的事件。
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Implement the `run()` method. It stores 1000 events in the queue, using its
    ID to identify the task that creates the event and giving to them as priority
    an increasing number. Use the `add()` method to store the events in the queue.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。它使用其ID将1000个事件存储在队列中，以标识创建事件的任务，并为它们分配一个递增的优先级数字。使用`add()`方法将事件存储在队列中。
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Create a `PriorityBlockingQueue` object parameterized with the `Event` class
    named `queue`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用`Event`类参数化的`PriorityBlockingQueue`对象，命名为`queue`。
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Create an array of five `Thread` objects to store the threads that is going
    to execute five tasks.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含五个`Thread`对象的数组，用于存储将执行五个任务的线程。
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Create five `Task` objects. Store the threads in the array created earlier.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建五个`Task`对象。将线程存储在先前创建的数组中。
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Start the five threads created earlier.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动先前创建的五个线程。
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Wait for the finalization of the five threads using the `join()` method.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待五个线程的完成。
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Write to the console the actual size of the queue and the events stored in it.
    Use the `poll()` method to take off the events from the queue.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台写入队列的实际大小和其中存储的事件。使用`poll()`方法从队列中取出事件。
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Write a message to the console with the final size of the queue.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台写入队列的最终大小的消息。
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, you have implemented a priority queue of `Event` objects using
    `PriorityBlockingQueue`. As we mentioned in the introduction, all the elements
    stored in `PriorityBlockingQueue` have to implement the `Comparable` interface,
    so you have implemented the `compareTo()` method in the Event class.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您已经使用`PriorityBlockingQueue`实现了一个`Event`对象的优先级队列。正如我们在介绍中提到的，存储在`PriorityBlockingQueue`中的所有元素都必须实现`Comparable`接口，因此您已经在Event类中实现了`compareTo()`方法。
- en: All the events have a priority attribute. The elements that have a higher value
    of priority will be the first elements in the queue. When you have implemented
    the `compareTo()` method, if the event executing the method has a priority higher
    than the priority of the event passed as parameter, it returns `-1` as the result.
    In the other case, if the event executing the method has a priority lower than
    the priority of the event passed as parameter, it returns `1` as the result. If
    both objects have the same priority, the `compareTo()` method returns the `0`
    value. In that case, the `PriorityBlockingQueue` class doesn't guarantee the order
    of the elements.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有事件都有一个优先级属性。具有更高优先级值的元素将成为队列中的第一个元素。当您实现了`compareTo()`方法时，如果执行该方法的事件具有比作为参数传递的事件的优先级更高的优先级，则返回`-1`作为结果。在另一种情况下，如果执行该方法的事件具有比作为参数传递的事件的优先级更低的优先级，则返回`1`作为结果。如果两个对象具有相同的优先级，则`compareTo()`方法返回`0`值。在这种情况下，`PriorityBlockingQueue`类不能保证元素的顺序。
- en: We have implemented the `Task` class to add the `Event` objects to the priority
    queue. Each task object adds to the queue 1,000 events, with priorities between
    0 and 999, using the `add()` method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了`Task`类，以将`Event`对象添加到优先级队列中。每个任务对象向队列中添加1000个事件，优先级在0到999之间，使用`add()`方法。
- en: The `main()` method of the `Main` class creates five `Task` objects and executes
    them in the corresponding threads. When all the threads have finished their execution,
    you have written all the elements to the console. To get the elements from the
    queue, we have used the `poll()` method. That method returns and removes the first
    element from the queue.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`类的`main()`方法创建了五个`Task`对象，并在相应的线程中执行它们。当所有线程都完成执行时，您已经将所有元素写入控制台。为了从队列中获取元素，我们使用了`poll()`方法。该方法返回并删除队列中的第一个元素。'
- en: 'The following screenshot shows part of the output of an execution of the program:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了程序执行的部分输出：
- en: '![How it works...](img/7881_06_02.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_06_02.jpg)'
- en: You can see how the queue has a size of 5,000 elements and how the first elements
    have the biggest priority values.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到队列有5000个元素，并且前几个元素具有最大的优先级值。
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `PriorityBlockingQueue` class has other interesting methods. Following
    is the description of some of them:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`PriorityBlockingQueue`类还有其他有趣的方法。以下是其中一些的描述：'
- en: '`clear()`: This method removes all the elements of the queue.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 此方法删除队列的所有元素。'
- en: '`take()`: This method returns and removes the first element of the queue. If
    the queue is empty, the method blocks its thread until the queue has elements.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take()`: 此方法返回并删除队列的第一个元素。如果队列为空，该方法将阻塞其线程，直到队列有元素。'
- en: '`put(E``e)`: `E` is the class used to parameterize the `PriorityBlockingQueue`
    class. This method inserts the element passed as a parameter into the queue.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put(E``e)`: `E`是用于参数化`PriorityBlockingQueue`类的类。此方法将传递的元素插入队列。'
- en: '`peek()`:This method returns the first element of the queue, but doesn''t remove
    it.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`: 此方法返回队列的第一个元素，但不删除它。'
- en: See also
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using blocking thread-safe lists* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章.并发集合")中的*使用阻塞线程安全列表*配方，*并发集合*'
- en: Using thread-safe lists with delayed elements
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用具有延迟元素的线程安全列表
- en: An interesting data structure provided by the Java API, and that you can use
    in concurrent applications, is implemented in the `DelayedQueue` class. In this
    class, you can store elements with an activation date. The methods that return
    or extract elements of the queue will ignore those elements whose data is in the
    future. They are invisible to those methods.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Java API提供的一个有趣的数据结构，您可以在并发应用程序中使用，是在`DelayedQueue`类中实现的。在这个类中，您可以存储具有激活日期的元素。返回或提取队列元素的方法将忽略那些数据在未来的元素。它们对这些方法是不可见的。
- en: 'To obtain this behavior, the elements you want to store in the `DelayedQueue`
    class have to implement the `Delayed` interface. This interface allows you to
    work with delayed objects, so you will implement the activation date of the objects
    stored in the `DelayedQueue` class as the time remaining until the activation
    date. This interface forces to implement the following two methods:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这种行为，您想要存储在`DelayedQueue`类中的元素必须实现`Delayed`接口。此接口允许您处理延迟对象，因此您将实现存储在`DelayedQueue`类中的对象的激活日期作为激活日期之间的剩余时间。此接口强制实现以下两种方法：
- en: '`compareTo(Delayed``o)`: The `Delayed` interface extends the `Comparable` interface.
    This method will return a value less than zero if the object that is executing
    the method has a delay smaller than the object passed as a parameter, a value
    greater than zero if the object that is executing the method has a delay bigger
    than the object passed as a parameter, and the zero value if both objects have
    the same delay.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compareTo(Delayed o)`：`Delayed`接口扩展了`Comparable`接口。如果执行该方法的对象的延迟小于作为参数传递的对象，则此方法将返回小于零的值；如果执行该方法的对象的延迟大于作为参数传递的对象，则返回大于零的值；如果两个对象的延迟相同，则返回零值。'
- en: '`getDelay(TimeUnit``unit)`: This method has to return the time remaining until
    the activation date in the units is specified by the unit parameter. The `TimeUnit`
    class is an enumeration with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`,
    `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDelay(TimeUnit unit)`：此方法必须返回直到指定单位的激活日期剩余的时间。`TimeUnit`类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`和`SECONDS`。'
- en: In this example, you will learn how to use the `DelayedQueue` class storing
    in it some events with different activation dates.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您将学习如何使用`DelayedQueue`类，其中存储了具有不同激活日期的一些事件。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to implement the example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Event` and specify that it implements the `Delayed` interface.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Event`的类，并指定它实现`Delayed`接口。
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Declare a private `Date` attribute named `startDate`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`startDate`的私有`Date`属性。
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Implement the constructor of the class to initialize its attribute.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Implement the `compareTo()` method. It receives a `Delayed` object as its parameter.
    Return the difference between the delay of the current object and the one passed
    as parameter.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`compareTo()`方法。它接收一个`Delayed`对象作为参数。返回当前对象的延迟与传递的参数之间的差异。
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Implement the `getDelay()` method. Return the difference between `startDate`
    of the object and the actual `Date` in `TimeUnit` received as parameter.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getDelay()`方法。以作为参数接收的`TimeUnit`返回对象的`startDate`和实际`Date`之间的差异。
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Create a class named `Task` and specify that it implements the `Runnable` interface.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，并指定它实现`Runnable`接口。
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Declare a private `int` attribute named `id` to store a number that identifies
    this task.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`id`的私有`int`属性，用于存储标识此任务的数字。
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Declare a private `DelayQueue` attribute parameterized with the `Event` class
    named `queue`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`queue`的私有参数化为`Event`类的`DelayQueue`属性。
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Implement the `run()` method. First, calculate the activation date of the events
    that this task is going to create. Add to the actual date a number of seconds
    equal to the ID of the object.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。首先，计算此任务将创建的事件的激活日期。将实际日期增加等于对象ID的秒数。
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Store 100 events in the queue using the `add()` method.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`add()`方法将100个事件存储在队列中。
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建名为`Main`的类并向其添加`main()`方法来实现示例的主类。
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Create a `DelayedQueue` object parameterized with the `Event` class.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个参数化为`Event`类的`DelayedQueue`对象。
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Create an array of five `Thread` objects to store the tasks you're going to
    execute.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含五个`Thread`对象的数组，用于存储要执行的任务。
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Create five `Task` objects, with different IDs.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建五个具有不同ID的`Task`对象。
- en: '[PRE60]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Launch all the five tasks created earlier.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动先前创建的所有五个任务。
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Wait for the finalization of the threads using the `join()` method.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待线程的完成。
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Write to the console the events stored in the queue. While the size of the queue
    is bigger than zero, use the `poll()` method to obtain an `Event` class. If it
    returns `null`, put the main thread for 500 milliseconds to wait for the activation
    of more events.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存储在队列中的事件写入控制台。当队列的大小大于零时，使用`poll()`方法获取一个`Event`类。如果返回`null`，则将主线程等待500毫秒以等待更多事件的激活。
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we have implemented the `Event` class. That class has a unique
    attribute, the activation date of the events, and implements the `Delayed` interface,
    so you can store `Event` objects in the `DelayedQueue` class.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们已经实现了`Event`类。该类具有一个唯一的属性，即事件的激活日期，并实现了`Delayed`接口，因此您可以将`Event`对象存储在`DelayedQueue`类中。
- en: The `getDelay()` method returns the number of nanoseconds between the activation
    date and the actual date. Both dates are objects of the `Date` class. You have
    used the `getTime()` method that returns a date converted to milliseconds and
    then, you have converted that value to `TimeUnit` received as a parameter. The
    `DelayedQueue` class works in nanoseconds, but at this point, it's transparent
    to you.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDelay()`方法返回激活日期和实际日期之间的纳秒数。这两个日期都是`Date`类的对象。您已经使用了`getTime()`方法，该方法返回转换为毫秒的日期，然后将该值转换为作为参数接收的`TimeUnit`。`DelayedQueue`类以纳秒为单位工作，但在这一点上，对您来说是透明的。'
- en: The `compareTo()` method returns a value less than zero if the delay of the
    object executing the method is smaller than the delay of the object passed as
    a parameter, a value greater than zero if the delay of the object executing the
    method is bigger than the delay of the object passes as a parameter, and the value
    `0` if both delays are equal.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行方法的对象的延迟小于作为参数传递的对象的延迟，则`compareTo()`方法返回小于零的值，如果执行方法的对象的延迟大于作为参数传递的对象的延迟，则返回大于零的值，并且如果两个延迟相等，则返回`0`值。
- en: You also have implemented the `Task` class. This class has an `integer` attribute
    named `id`. When a `Task` object is executed, it adds a number of seconds equal
    to the ID of the task to the actual date and that is the activation date of the
    events stored by this task in the `DelayedQueue` class. Each `Task` object stores
    100 events in the queue using the `add()` method.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您还实现了`Task`类。此类具有名为`id`的`integer`属性。执行`Task`对象时，它将与任务的ID相等的秒数添加到实际日期，并且这是由此任务在`DelayedQueue`类中存储的事件的激活日期。每个`Task`对象使用`add()`方法在队列中存储100个事件。
- en: Finally, in the `main()` method of the `Main` class, you have created five `Task`
    objects and executed them in the corresponding threads. When those threads finish
    their execution, you have written to the console all the events using the `poll()`
    method. That method retrieves and removes the first element of the queue. If the
    queue does not have any active element, the method returns the `null` value. You
    called the `poll()` method and if it returns an `Event` class, you increment a
    counter. When the `poll()` method returns the `null` value, you write the value
    of the counter in the console and put the thread to sleep during half a second
    to wait for more active events. When you have obtained the 500 events stored in
    the queue, the execution of the program finishes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Main`类的`main()`方法中，您创建了五个`Task`对象并在相应的线程中执行它们。当这些线程完成执行时，您使用`poll()`方法将所有事件写入控制台。该方法检索并删除队列的第一个元素。如果队列没有任何活动元素，则该方法返回`null`值。您调用`poll()`方法，如果它返回一个`Event`类，则增加一个计数器。当`poll()`方法返回`null`值时，您将计数器的值写入控制台，并使线程休眠半秒钟以等待更多活动事件。当您获得队列中存储的500个事件时，程序的执行结束。
- en: 'The following screenshot shows part of the output of an execution of the program:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了程序执行的部分输出：
- en: '![How it works...](img/7881_06_03.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/7881_06_03.jpg)'
- en: You can see how the program only gets 100 events when it is activated.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到程序在激活时仅获取100个事件。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You must be very careful with the `size()` method. It returns the total number
    of elements in the list that includes the active and non-active elements.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须非常小心使用`size()`方法。它返回包括活动和非活动元素的列表中的元素总数。
- en: There's more...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `DelayQueue` class has other interesting methods, which are as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`DelayQueue`类还有其他有趣的方法，如下所示：'
- en: '`clear()`: This method removes all the elements of the queue.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 此方法删除队列的所有元素。'
- en: '`offer(E``e)`: `E` represents the class used to parameterize the `DelayQueue`
    class. This method inserts the element passed as a parameter in the queue.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offer(E``e)`: `E`表示用于参数化`DelayQueue`类的类。此方法将作为参数传递的元素插入队列。'
- en: '`peek()`: This method retrieves, but doesn''t remove the first element of the
    queue.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`: 此方法检索但不删除队列的第一个元素。'
- en: '`take()`: This method retrieves and removes the first element of the queue.
    If there aren''t any active elements in the queue, the thread that is executing
    the method will be blocked until the thread has some active elements.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take()`: 此方法检索并删除队列的第一个元素。如果队列中没有任何活动元素，则执行该方法的线程将被阻塞，直到线程有一些活动元素为止。'
- en: See also
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using blocking thread-safe lists* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章.并发集合")中的*使用阻塞线程安全列表*食谱，*并发集合*'
- en: Using thread-safe navigable maps
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程安全的可导航映射
- en: 'An interesting data structure provided by the Java API that you can use in
    your concurrent programs is defined by the `ConcurrentNavigableMap` interface.
    The classes that implement the `ConcurrentNavigableMap` interface stores elements
    within two parts:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Java API提供的一个有趣的数据结构，您可以在并发程序中使用，由`ConcurrentNavigableMap`接口定义。实现`ConcurrentNavigableMap`接口的类在两个部分中存储元素：
- en: A **key** that uniquely identifies an element
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**唯一标识元素的**键'
- en: The rest of the data that defines the element
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义元素的其余数据
- en: Each part has to be implemented in different classes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分必须在不同的类中实现。
- en: Java API also provides a class that implements that interface, which is the
    `ConcurrentSkipListMap` interface that implements a non-blocking list with the
    behavior of the `ConcurrentNavigableMap` interface. Internally, it uses a **Skip
    List** to store the data. A Skip List is a data structure based on parallel lists
    that allows us to get efficiency similar to a binary tree. With it, you can get
    a sorted data structure with a better access time to insert, search, or delete
    elements than a sorted list.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Java API还提供了一个实现该接口的类，即实现具有`ConcurrentNavigableMap`接口行为的非阻塞列表的`ConcurrentSkipListMap`接口。在内部，它使用**Skip
    List**来存储数据。跳表是一种基于并行列表的数据结构，允许我们获得类似于二叉树的效率。使用它，您可以获得一个排序的数据结构，其插入、搜索或删除元素的访问时间比排序列表更好。
- en: Note
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Skip List was introduced by William Pugh in 1990.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Skip List由William Pugh于1990年引入。
- en: When you insert an element in the map, it uses the key to order them, so all
    the elements will be ordered. The class also provides methods to obtain a submap
    of the map, in addition to the ones that return a concrete element.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在映射中插入元素时，它使用键对它们进行排序，因此所有元素都将被排序。该类还提供了一些方法来获取映射的子映射，以及返回具体元素的方法。
- en: In this recipe, you will learn how to use the `ConcurrentSkipListMap` class
    to implement a map of contacts.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何使用`ConcurrentSkipListMap`类来实现联系人映射。
- en: Getting ready
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例已经使用Eclipse IDE实现。如果你使用Eclipse或其他IDE如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Contact`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Contact`的类。
- en: '[PRE64]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Declare two private `String` attributes named `name` and `phone`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个私有的`String`属性，命名为`name`和`phone`。
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Implement the constructor of the class to initialize its attributes.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE66]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Implement the methods to return the values of the `name` and `phone` attributes.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现方法来返回`name`和`phone`属性的值。
- en: '[PRE67]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Create a class named `Task` and specify that it implements the `Runnable` interface.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，并指定它实现`Runnable`接口。
- en: '[PRE68]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Declare a private `ConcurrentSkipListMap` attribute parameterized with the `String`
    and `Contact` classes named `map`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`ConcurrentSkipListMap`属性，参数化为`String`和`Contact`类，命名为`map`。
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Declare a private `String` attribute named `id` to store the ID of the current
    task.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`String`属性，命名为`id`，用于存储当前任务的ID。
- en: '[PRE70]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Implement the constructor of the class to store its attributes.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以存储其属性。
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Implement the `run()` method. It stores in the map 1,000 different contacts
    using the ID of the task and an incremental number to create the `Contact` objects.
    Use the `put()` method to store the contacts in the map.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。它使用任务的ID和递增数字来创建1,000个不同的联系人，并使用`put()`方法将联系人存储在地图中。
- en: '[PRE72]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE73]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Create a `ConcurrentSkipListMap` object parameterized with the `String` and
    `Conctact` classes named `map`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个参数为`String`和`Conctact`类的`ConcurrentSkipListMap`对象，命名为`map`。
- en: '[PRE74]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Create an array for 25 `Thread` objects to store all the `Task` objects that
    you're going to execute.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含25个`Thread`对象的数组，用于存储所有要执行的`Task`对象。
- en: '[PRE75]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Create and launch 25 task objects assigning a capital letter as the ID of each
    task.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动25个任务对象，为每个任务分配一个大写字母作为ID。
- en: '[PRE76]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Wait for the finalization of the threads using the `join()` method.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待线程的完成。
- en: '[PRE77]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Get the first entry of the map using the `firstEntry()` method. Write its data
    to the console.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`firstEntry()`方法获取地图的第一个条目。将其数据写入控制台。
- en: '[PRE78]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Get the last entry of the map using the `lastEntry()` method. Write its data
    to the console.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lastEntry()`方法获取地图的最后一个条目。将其数据写入控制台。
- en: '[PRE79]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Obtain a submap of the map using the `subMap()` method. Write their data to
    the console.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`subMap()`方法获取地图的子地图。将它们的数据写入控制台。
- en: '[PRE80]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we have implemented a `Task` class to store `Contact` objects
    in the navigable map. Each contact has a name that is the ID of the task that
    creates it, and a phone number, that is a number between 1,000 and 2,000\. We
    have used a concatenation of those values as the key for the contacts. Each `Task`
    object creates 1,000 contacts that are stored in the navigable map using the `put()`
    method.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们实现了一个`Task`类来存储可导航地图中的`Contact`对象。每个联系人都有一个名称，即创建它的任务的ID，以及一个电话号码，即1,000到2,000之间的数字。我们使用这些值的连接作为联系人的键。每个`Task`对象创建1,000个联系人，这些联系人使用`put()`方法存储在可导航地图中。
- en: Note
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you insert an element with a key that exists in the map, the element associated
    with that key will be replaced by the new element.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你插入一个具有在地图中存在的键的元素，那么与该键关联的元素将被新元素替换。
- en: The `main()` method of the `Main` class creates 25 `Task` objects, using IDs
    as the letters between A and Z. Then, you have used some methods to obtain data
    from the map. The `firstEntry()` method returns a `Map.Entry` object with the
    first element of the map. This method doesn't remove the element from the map.
    That object contains the key and the element. To obtain the element, you have
    called the `getValue()` method. You can use the `getKey()` method to obtain the
    key of that element.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`类的`main()`方法创建了25个`Task`对象，使用字母A到Z作为ID。然后，你使用了一些方法来从地图中获取数据。`firstEntry()`方法返回一个带有地图第一个元素的`Map.Entry`对象。这个方法不会从地图中移除元素。该对象包含键和元素。要获取元素，你调用了`getValue()`方法。你可以使用`getKey()`方法来获取该元素的键。'
- en: The `lastEntry()` method returns a `Map.Entry` object with the last element
    of the map and the `subMap()` method returns the `ConcurrentNavigableMap` object
    with part of the elements of the map, in this case, the elements which have the
    keys between `A1996` and `B1002`. In this case, you have used the `pollFirst()`
    method to process the elements of the `subMap()` method. That method returns and
    removes the first `Map.Entry` object of the submap.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastEntry()`方法返回一个带有地图最后一个元素的`Map.Entry`对象，而`subMap()`方法返回一个`ConcurrentNavigableMap`对象，其中包含地图部分元素，即具有键在`A1996`和`B1002`之间的元素。在这种情况下，你使用了`pollFirst()`方法来处理`subMap()`方法的元素。该方法返回并移除子地图的第一个`Map.Entry`对象。'
- en: 'The following screenshot shows the output of an execution of the program:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了程序执行的输出：
- en: '![How it works...](img/7881_06_04.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_06_04.jpg)'
- en: There's more...
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `ConcurrentSkipListMap` class has other interesting methods. Following
    are some of them:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentSkipListMap`类还有其他有趣的方法。以下是其中一些：'
- en: '`headMap(K``toKey)`: `K` is the class of the key values used in the parameterization
    of the `ConcurrentSkipListMap` object. This method returns a submap of the first
    elements of the map with the elements that have a key smaller than the one passed
    as parameter.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headMap(K``toKey)`: `K`是在`ConcurrentSkipListMap`对象的参数化中使用的键值的类。这个方法返回地图的第一个元素的子地图，其中包含具有小于传递的键的元素。'
- en: '`tailMap(K``fromKey)`: `K` is the class of the key values used in the parameterization
    of the `ConcurrentSkipListMap` object. This method returns a submap of the last
    elements of the map with the elements that have a key greater than the one passed
    as parameter.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tailMap(K``fromKey)`: `K`是用于`ConcurrentSkipListMap`对象参数化的键值的类。此方法返回具有大于传递的键的元素的子映射。'
- en: '`putIfAbsent(K``key,``V``Value)`: This method inserts the value specified as
    a parameter with the key specified as parameter if the key doesn''t exist in the
    map.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`putIfAbsent(K``key,``V``Value)`: 如果键在映射中不存在，则此方法将使用指定的键作为参数插入指定的值作为参数。'
- en: '`pollLastEntry()`: This method returns and removes a `Map.Entry` object with
    the last element of the map.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pollLastEntry()`: 此方法返回并删除映射的最后一个元素的`Map.Entry`对象。'
- en: '`replace(K``key,``V``Value)`: This method replaces the value associated with
    the key specified as parameter if this key exists in the map.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace(K``key,``V``Value)`: 如果指定的键存在于映射中，此方法将替换与参数指定的键关联的值。'
- en: See also
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using non-blocking thread-safe lists* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章. 并发集合")中的*使用非阻塞线程安全列表*食谱，*并发集合*'
- en: Generating concurrent random numbers
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成并发随机数
- en: The Java concurrency API provides a specific class to generate pseudo-random
    numbers in concurrent applications. It's the `ThreadLocalRandom` class and it's
    new in the Java 7 Version. It works as the thread local variables. Every thread
    that wants to generate random numbers has a different generator, but all of them
    are managed from the same class, in a transparent way to the programmer. With
    this mechanism, you will get a better performance than using a shared `Random`
    object to generate the random numbers of all the threads.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供了一个特定的类来在并发应用程序中生成伪随机数。它是`ThreadLocalRandom`类，它是Java 7版本中的新功能。它的工作方式类似于线程本地变量。想要生成随机数的每个线程都有一个不同的生成器，但所有这些生成器都是从同一个类中管理的，对程序员来说是透明的。通过这种机制，您将获得比使用共享的`Random`对象来生成所有线程的随机数更好的性能。
- en: In this recipe, you will learn how to use the `ThreadLocalRandom` class to generate
    random numbers in a concurrent application.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用`ThreadLocalRandom`类在并发应用程序中生成随机数。
- en: Getting ready
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `TaskLocalRandom` and specify that it implements the `Runnable`
    interface.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`TaskLocalRandom`的类，并指定它实现`Runnable`接口。
- en: '[PRE81]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Implement the constructor of the class. Use it to initialize the random-number
    generator to the actual thread using the `current()` method.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '实现类的构造函数。使用它来使用`current()`方法将随机数生成器初始化为实际线程。 '
- en: '[PRE82]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Implement the `run()` method. Get the name of the thread that is executing this
    task and write 10 random integer numbers to the console using the `nextInt()`
    method.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。获取执行此任务的线程的名称，并使用`nextInt()`方法将10个随机整数写入控制台。
- en: '[PRE83]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建名为`Main`的类并向其添加`main()`方法来实现示例的主类。
- en: '[PRE84]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Create an array for three `Thread` objects.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为三个`Thread`对象创建一个数组。
- en: '[PRE85]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Create and launch three `TaskLocalRandom` tasks. Store the threads in the array
    created earlier.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动三个`TaskLocalRandom`任务。将线程存储在之前创建的数组中。
- en: '[PRE86]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: How it works...
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key of this example is in the `TaskLocalRandom` class. In the constructor
    of the class, we make a call to the `current()` method of the `ThreadLocalRandom`
    class. This is a static method that returns the `ThreadLocalRandom` object associated
    with the current thread, so you can generate random numbers using that object.
    If the thread that makes the call does not have any object associated yet, the
    class creates a new one. In this case, you use this method to initialize the random
    generator associated with this task, so it will be created in the next call to
    the method.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的关键在于`TaskLocalRandom`类。在类的构造函数中，我们调用了`ThreadLocalRandom`类的`current()`方法。这是一个返回与当前线程关联的`ThreadLocalRandom`对象的静态方法，因此您可以使用该对象生成随机数。如果调用该方法的线程尚未关联任何对象，则该类将创建一个新对象。在这种情况下，您可以使用此方法初始化与此任务关联的随机生成器，因此它将在下一次调用该方法时创建。
- en: In the `run()` method of the `TaskLocalRandom` class, make a call to the `current()`
    method to get the random generator associated with this thread, also you make
    a call to the `nextInt()` method passing number 10 as parameter. This method will
    return a pseudo random number between zero and 10\. Each task generates 10 random
    numbers.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TaskLocalRandom`类的`run()`方法中，调用`current()`方法以获取与此线程关联的随机生成器，还调用`nextInt()`方法并传递数字10作为参数。此方法将返回0到10之间的伪随机数。每个任务生成10个随机数。
- en: There's more...
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `ThreadLocalRandom` class also provides methods to generate `long`, `float`,
    and `double` numbers, and `Boolean` values. There are methods that allow you to
    provide a number as a parameter to generate random numbers between zero and that
    number. Other methods allow you to provide two parameters to generate random numbers
    between those numbers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadLocalRandom`类还提供了生成`long`、`float`和`double`数字以及`Boolean`值的方法。有一些方法允许您提供一个数字作为参数，以在零和该数字之间生成随机数。其他方法允许您提供两个参数，以在这些数字之间生成随机数。'
- en: See also
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using local thread variables* recipe in [Chapter 1](ch01.html "Chapter 1. Thread
    Management"), *Thread management*
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. 线程管理")中的*使用本地线程变量*食谱，*线程管理*'
- en: Using atomic variables
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原子变量
- en: '**Atomic variables** were introduced in Java Version 5 to provide atomic operations
    on single variables. When you work with a normal variable, each operation that
    you implement in Java is transformed in several instructions that is understandable
    by the machine when you compile the program. For example, when you assign a value
    to a variable, you only use one instruction in Java, but when you compile this
    program, this instruction is transformed in various instructions in the JVM language.
    This fact can provide data inconsistency errors when you work with multiple threads
    that share a variable.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**原子变量**是在Java版本5中引入的，用于对单个变量进行原子操作。当您使用普通变量时，您在Java中实现的每个操作都会被转换为多个指令，这些指令在编译程序时可以被机器理解。例如，当您给变量赋值时，在Java中只使用一条指令，但在编译此程序时，此指令会在JVM语言中转换为各种指令。当您使用多个共享变量的线程时，这个事实可能会导致数据不一致的错误。'
- en: To avoid these problems, Java introduced the atomic variables. When a thread
    is doing an operation with an atomic variable, if other threads want to do an
    operation with the same variable, the implementation of the class includes a mechanism
    to check that the operation is done in one step. Basically, the operation gets
    the value of the variable, changes the value in a local variable, and then tries
    to change the old value for the new one. If the old value is still the same, it
    does the change. If not, the method begins the operation again. This operation
    is called **Compare and Set** .
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些问题，Java引入了原子变量。当一个线程对原子变量进行操作时，如果其他线程想要对同一个变量进行操作，类的实现会包括一个机制来检查该操作是否一步完成。基本上，该操作获取变量的值，将值更改为本地变量，然后尝试将旧值更改为新值。如果旧值仍然相同，则进行更改。如果不是，则方法重新开始操作。这个操作被称为**比较和设置**。
- en: Atomic variables don't use locks or other synchronization mechanisms to protect
    the access to their values. All their operations are based on the Compare and
    Set operation. It's guaranteed that several threads can work with an atomic variable
    at a time without generating data inconsistency errors and its performance is
    better than using a normal variable protected by a synchronization mechanism.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 原子变量不使用锁或其他同步机制来保护对其值的访问。它们所有的操作都基于比较和设置操作。保证多个线程可以同时使用原子变量而不会产生数据不一致的错误，并且其性能比使用由同步机制保护的普通变量更好。
- en: In this recipe, you will learn how to use atomic variables implementing a bank
    account and two different tasks, one that adds money to the account and one that
    subtracts money from it. You will use the `AtomicLong` class in the implementation
    of the example.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用原子变量来实现一个银行账户和两个不同的任务，一个是向账户添加金额，另一个是从中减去金额。您将在示例的实现中使用“AtomicLong”类。
- en: Getting ready
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    are using Eclipse or other IDE such as NetBeans, open it and create a new Java
    project.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的实现已经使用了Eclipse IDE。如果您正在使用Eclipse或其他IDE，如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Account` to simulate a bank account.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“Account”的类来模拟银行账户。
- en: '[PRE87]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Declare a private `AtomicLong` attribute named `balance` to store the balance
    of the account.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的“AtomicLong”属性，名为“balance”，用于存储账户的余额。
- en: '[PRE88]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Implement the constructor of the class to initialize its attribute.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE89]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Implement a method named `getBalance()` to return the value of the balance attribute.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为“getBalance（）”的方法来返回余额属性的值。
- en: '[PRE90]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Implement a method named `setBalance(``)` to establish the value of the balance
    attribute.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为“setBalance（）”的方法来建立余额属性的值。
- en: '[PRE91]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Implement a method named `addAmount()` to increment the value of the `balance`
    attribute.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为“addAmount（）”的方法来增加“balance”属性的值。
- en: '[PRE92]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Implement a method named `substractAmount()` to decrement the value of the `balance`
    attribute.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为“substractAmount（）”的方法来减少“balance”属性的值。
- en: '[PRE93]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Create a class named `Company` and specify that it implements the `Runnable`
    interface. This class will simulate the payments made by a company.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“Company”的类，并指定它实现“Runnable”接口。这个类将模拟公司的付款。
- en: '[PRE94]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Declare a private `Account` attribute named `account`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的“Account”属性，名为“account”。
- en: '[PRE95]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Implement the constructor of the class to initialize its attribute.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE96]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Implement the `run()` method of the task. Use the `addAmount()` method of the
    account to make 10 increments of 1,000 in its balance.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现任务的“run（）”方法。使用账户的“addAmount（）”方法使其余额增加1,000的10次。
- en: '[PRE97]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Create a class named `Bank` and specify that it implements the `Runnable` interface.
    This class will simulate the withdrawal of money from the account.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“Bank”的类，并指定它实现“Runnable”接口。这个类将模拟从账户中取钱。
- en: '[PRE98]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Declare a private `Account` attribute named `account`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的“Account”属性，名为“account”。
- en: '[PRE99]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Implement the constructor of the class to initialize its attribute.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE100]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Implement the `run()` method of the task. Use the `subtractAmount()` method
    of the account to make 10 decrements of 1,000 in its balance.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现任务的“run（）”方法。使用账户的“subtractAmount（）”方法使其余额减少1,000的10次。
- en: '[PRE101]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为“Main”的类并向其添加“main（）”方法来实现示例的主类。
- en: '[PRE102]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Create an `Account` object and set its balance to `1000`.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个“Account”对象并将其余额设置为“1000”。
- en: '[PRE103]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Create a new `Company` task and a thread to execute it.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的“Company”任务和一个线程来执行它。
- en: '[PRE104]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Write in the console the initial balance of the account.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中写入账户的初始余额。
- en: '[PRE105]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Start the threads.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动线程。
- en: '[PRE106]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Wait for the finalization of the threads using the `join()` method and write
    in the console the final balance of the account.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“join（）”方法等待线程的完成，并在控制台中写入账户的最终余额。
- en: '[PRE107]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: How it works...
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key of this example is in the `Account` class. In that class, we declared
    an `AtomicLong` variable named `balance` to store the balance of the account and
    then we implemented the methods to work with that balance using the methods provided
    by the `AtomicLong` class. To implement the `getBalance()` method that returns
    the value of the `balance` attribute, you have used the `get()` method of the
    `AtomicLong` class. To implement the `setBalance()` method that establish the
    value of the balance attribute, you have used the `set()` method of the `AtomicLong`
    class. To implement the `addAmount()` method that adds an import to the balance
    of the account, you have used the `getAndAdd()` method of the `AtomicLong` class
    that returns the value and increments it by the value specified as a parameter.
    Finally, to implement the `subtractAmount()` method that decrements the value
    of the `balance` attribute, you have also used the `getAndAdd()` method.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的关键在于`Account`类。在这个类中，我们声明了一个`AtomicLong`变量，名为`balance`，用于存储账户的余额，然后我们使用`AtomicLong`类提供的方法来实现处理这个余额的方法。为了实现`getBalance()`方法，返回`balance`属性的值，你使用了`AtomicLong`类的`get()`方法。为了实现`setBalance()`方法，用于设定余额属性的值，你使用了`AtomicLong`类的`set()`方法。为了实现`addAmount()`方法，用于向账户余额添加金额，你使用了`AtomicLong`类的`getAndAdd()`方法，该方法返回指定参数的值并将其增加到余额中。最后，为了实现`subtractAmount()`方法，用于减少`balance`属性的值，你也使用了`getAndAdd()`方法。
- en: 'Then, you have implemented two different tasks:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你实现了两个不同的任务：
- en: The `Company` class simulates a company that increments the balance of the account.
    Each task of this class makes 10 increments of 1,000\.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Company`类模拟了一个增加账户余额的公司。该类的每个任务都会增加1,000的余额。'
- en: The `Bank` class simulates a bank where the proprietary of the bank account
    takes out its money. Each task of this class makes 10 decrements of 1,000.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bank`类模拟了一个银行，银行账户的所有者取出了他的钱。该类的每个任务都会减少1,000的余额。'
- en: In the `Main` class, you have created an `Account` object with a balance of
    1,000\. Then, you have executed a bank task and a company task, so the final balance
    of the account must be the same as the initial one.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`类中，你创建了一个余额为1,000的`Account`对象。然后，你执行了一个银行任务和一个公司任务，所以账户的最终余额必须与初始余额相同。
- en: 'When you execute the program, you will see how the final balance is the same
    as the initial one. The following screenshot shows the output of an execution
    of this example:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行程序时，你会看到最终余额与初始余额相同。以下截图显示了此示例的执行输出：
- en: '![How it works...](img/7881_06_05.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_06_05.jpg)'
- en: There's more...
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As we mentioned in the introduction, there are other atomic classes in Java.
    `AtomicBoolean`, `AtomicInteger`, and `AtomicReference` are other examples of
    atomic classes.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中提到的，Java中还有其他原子类。`AtomicBoolean`、`AtomicInteger`和`AtomicReference`是原子类的其他示例。
- en: See also
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Synchronizing a method* recipe in [Chapter 2](ch02.html "Chapter 2. Basic
    Thread Synchronization"), *Basic thread synchronization*
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。基本线程同步")的*Synchronizing a method*示例中，*Basic thread synchronization*
- en: Using atomic arrays
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原子数组
- en: When you implement a concurrent application that has one or more objects shared
    by several threads, you have to protect the access to their attributes using a
    synchronization mechanism as locks or the `synchronized` keyword to avoid data
    inconsistency errors.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实现一个并发应用程序，其中有一个或多个对象被多个线程共享时，你必须使用同步机制来保护对其属性的访问，如锁或`synchronized`关键字，以避免数据不一致错误。
- en: 'These mechanisms have the following problems:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这些机制存在以下问题：
- en: 'Deadlock: This situation occurs when a thread is blocked waiting for a lock
    that is locked by other threads and will never free it. This situation blocks
    the program, so it will never finish.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死锁：当一个线程被阻塞等待被其他线程锁定的锁，并且永远不会释放它时，就会发生这种情况。这种情况会阻塞程序，因此它永远不会结束。
- en: If only one thread is accessing the shared object, it has to execute the code
    necessary to get and release the lock.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只有一个线程访问共享对象，它必须执行必要的代码来获取和释放锁。
- en: 'To provide a better performance to this situation, the **compare-and-swap operation**
    was developed. This operation implements the modification of the value of a variable
    in the following three steps:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更好的性能，开发了**对比交换操作**。这个操作实现了对变量值的修改，分为以下三个步骤：
- en: You get the value of the variable, which is the old value of the variable.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你获取了变量的值，这是变量的旧值。
- en: You change the value of the variable in a temporal variable, which is the new
    value of the variable.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将变量的值更改为临时变量，这是变量的新值。
- en: You substitute the old value with the new value, if the old value is equal to
    the actual value of the variable. The old value may be different from the actual
    value if another thread has changed the value of the variable.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果旧值等于变量的实际值，你用新值替换旧值。如果另一个线程已更改了变量的值，那么旧值可能与实际值不同。
- en: With this mechanism, you don't need to use any synchronization mechanism, so
    you avoid deadlocks and you obtain a better performance.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种机制，你不需要使用任何同步机制，因此可以避免死锁，并获得更好的性能。
- en: Java implements this mechanism in the **atomic variables**. These variables
    provide the `compareAndSet()` method that is an implementation of the compare-and-swap
    operation and other methods based on it.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: Java在**原子变量**中实现了这种机制。这些变量提供了`compareAndSet()`方法，这是对比交换操作的实现以及基于它的其他方法。
- en: Java also introduced **atomic arrays** that provide atomic operations for arrays
    of `integer` or `long` numbers. In this recipe, you will learn how to use the
    `AtomicIntegerArray` class to work with atomic arrays.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Java还引入了**原子数组**，为`integer`或`long`数字的数组提供原子操作。在这个示例中，你将学习如何使用`AtomicIntegerArray`类来处理原子数组。
- en: Getting ready
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的示例是使用Eclipse IDE实现的。如果你使用Eclipse或其他IDE，比如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来实现示例：
- en: Create a class named `Incrementer` and specify that it implements the `Runnable`
    interface.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Incrementer`的类，并指定它实现`Runnable`接口。
- en: '[PRE108]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Declare a private `AtomicIntegerArray` attribute named `vector` to store an
    array of `integer` numbers.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`AtomicIntegerArray`属性，名为`vector`，用于存储一个整数数组。
- en: '[PRE109]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Implement the constructor of the class to initialize its attribute.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE110]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Implement the `run()` method. Increment all the elements of the array using
    the `getAndIncrement()` method.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。使用`getAndIncrement()`方法递增数组的所有元素。
- en: '[PRE111]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Create a class named `Decrementer` and specify that it implements the `Runnable`
    interface.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Decrementer`的类，并指定它实现`Runnable`接口。
- en: '[PRE112]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Declare a private `AtomicIntegerArray` attribute named `vector` to store an
    array of `integer` numbers.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个私有的`AtomicIntegerArray`属性，名为`vector`，用于存储一个整数数组。
- en: '[PRE113]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Implement the constructor of the class to initialize its attribute.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。
- en: '[PRE114]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Implement the `run()` method. Decrement all the elements of the array using
    the `getAndDecrement()` method.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。使用`getAndDecrement()`方法递减数组的所有元素。
- en: '[PRE115]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并向其中添加`main()`方法来实现示例的主类。
- en: '[PRE116]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Declare a constant named `THREADS` and assign to it the value `100`. Create
    an `AtomicIntegerArray` object with 1,000 elements.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`THREADS`的常量，并将其赋值为`100`。创建一个包含1,000个元素的`AtomicIntegerArray`对象。
- en: '[PRE117]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Create an `Incrementer` task to work with the atomic array created earlier.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Incrementer`任务来处理之前创建的原子数组。
- en: '[PRE118]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Create a `Decrementer` task to work with the atomic array created earlier.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Decrementer`任务来处理之前创建的原子数组。
- en: '[PRE119]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Create two arrays to store 100 Thread objects.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个数组来存储100个线程对象。
- en: '[PRE120]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Create and launch 100 threads to execute the `Incrementer` task and another
    100 threads to execute the `Decrementer` task. Store the threads in the arrays
    created earlier.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动100个线程来执行`Incrementer`任务，另外启动100个线程来执行`Decrementer`任务。将线程存储在之前创建的数组中。
- en: '[PRE121]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Wait for the finalization of the threads using the `join()` method.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待线程的完成，使用`join()`方法。
- en: '[PRE122]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Write in the console the elements of the atomic array distinct from zero. Use
    the `get()` method to obtain the elements of the atomic array.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中打印出原子数组中不为零的元素。使用`get()`方法来获取原子数组的元素。
- en: '[PRE123]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Write a message in the console to indicate the finalization of the example.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中写入一条消息，指示示例的完成。
- en: '[PRE124]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: How it works...
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this example, you have implemented two different tasks to work with an `AtomicIntegerArray`
    object:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你已经实现了两个不同的任务来处理`AtomicIntegerArray`对象：
- en: '`Incrementer` task: This class increments all the elements of the array using
    the `getAndIncrement()` method'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Incrementer`任务：这个类使用`getAndIncrement()`方法递增数组的所有元素'
- en: '`Decrementer` task: This class decrements all the elements of the array using
    the `getAndDecrement()` method'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Decrementer`任务：这个类使用`getAndDecrement()`方法递减数组的所有元素'
- en: In the `Main` class, you have created `AtomicIntegerArray` with 1,000 elements
    and then, you have executed 100 Incrementer and 100 decrementer tasks. At the
    end of those tasks, if there were no inconsistency errors, all the elements of
    the array must have the value `0`. If you execute the program, you will see how
    the program only writes to the console the final message because all the elements
    are zero.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`类中，你已经创建了一个包含1,000个元素的`AtomicIntegerArray`，然后执行了100个增量器和100个减量器任务。在这些任务结束时，如果没有不一致的错误，数组的所有元素必须具有值`0`。如果你执行程序，你会看到程序只会在控制台中写入最终消息，因为所有元素都是零。
- en: There's more...
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Nowadays, Java only provides another atomic array class. It's the `AtomicLongArray`
    class that provides the same methods as the `IntegerAtomicArray` class.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Java只提供了另一个原子数组类。它是`AtomicLongArray`类，提供了与`IntegerAtomicArray`类相同的方法。
- en: 'Other interesting methods provided by these classes are:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类提供的其他有趣的方法是：
- en: '`get(int``i)`: Returns the value of the array position specified by the parameter'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(int``i)`: 返回由参数指定的数组位置的值'
- en: '`set(int``I,``int``newValue)`: Establishes the value of the array position
    specified by the parameter.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set(int``I,``int``newValue)`: 建立由参数指定的数组位置的值。'
- en: See also
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using atomic variables* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用原子变量*配方在[第6章](ch06.html "第6章.并发集合"), *并发集合*'
