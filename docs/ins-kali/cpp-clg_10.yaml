- en: Archives, Images, and Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存档，图像和数据库
- en: Problems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 79\. Finding files in a ZIP archive
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 79. 在ZIP存档中查找文件
- en: Write a program that can search for and print all the files in a ZIP archive
    whose name matches a user-provided regular expression (for instance, use `^.*\.jpg$`
    to find all files with the extension `.jpg`).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，可以搜索并打印ZIP存档中所有文件的名称与用户提供的正则表达式匹配的文件（例如，使用`^.*\.jpg$`来查找所有扩展名为`.jpg`的文件）。
- en: 80\. Compressing and decompressing files to/from a ZIP archive
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 80. 将文件压缩和解压缩到/从ZIP存档
- en: 'Write a program that can do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，可以执行以下操作：
- en: Compress either a file or the contents of a user-specified directory, recursively,
    to a ZIP archive
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件或用户指定目录的内容递归地压缩到ZIP存档
- en: Decompress the contents of a ZIP archive to a user-specified destination directory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将ZIP存档的内容解压缩到用户指定的目标目录
- en: 81\. Compressing and decompressing files to/from a ZIP archive with a password
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 81. 将文件压缩和解压缩到/从受密码保护的ZIP存档
- en: 'Write a program that can do the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，可以执行以下操作：
- en: Compress either a file or the contents of a user-specified directory, recursively,
    to a password-protected ZIP archive
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件或用户指定目录的内容递归地压缩到受密码保护的ZIP存档
- en: Decompress the content of a password-protected ZIP archive to a user-specified
    destination directory
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将受密码保护的ZIP存档的内容解压缩到用户指定的目标目录
- en: 82\. Creating a PNG that represents a national flag
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 82. 创建代表国旗的PNG
- en: 'Write a program that generates a PNG file that represents the national flag
    of Romania, shown here. The size of the image in pixels, as well as the path to
    the destination file, should be provided by the user:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，生成代表罗马尼亚国旗的PNG文件，如下所示。用户应提供图像的像素大小和目标文件路径：
- en: '![](img/ef91c3bc-5e8e-4106-ad7a-77429c9d7572.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef91c3bc-5e8e-4106-ad7a-77429c9d7572.png)'
- en: 83\. Creating verification text PNG images
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 83. 创建验证文本PNG图像
- en: 'Write a program that can create Captcha-like PNG images for verifying human
    users to a system. Such an image should have:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，可以为验证人类用户到系统创建类似验证码的PNG图像。这样的图像应该具有：
- en: A gradient-colored background
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐变色背景
- en: A series of random letters displayed at different angles both to the right and
    left
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不同角度显示的一系列随机字母，向右和向左
- en: Several random lines of different colors across the image (on top of the text)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像上方的不同颜色的几条随机线（在文本之上）
- en: 'Here is an example of such an image:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这样一个图像的示例：
- en: '![](img/28add9ea-14fe-40eb-9fb9-dee3ae6e6407.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28add9ea-14fe-40eb-9fb9-dee3ae6e6407.png)'
- en: 84\. EAN-13 barcode generator
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 84. EAN-13条形码生成器
- en: 'Write a program that can generate a PNG image with an EAN-13 barcode for any
    international article number in version 13 of the standard. For simplicity, the
    image should only contain the barcode and can skip the EAN-13 number printed under
    the barcode. Here is an example of the expected output for the number `5901234123457`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，可以为标准13版的任何国际文章编号生成EAN-13条形码的PNG图像。为简单起见，图像应仅包含条形码，并且可以跳过在条形码下面打印的EAN-13号码。以下是数字`5901234123457`的预期输出示例：
- en: '![](img/c20e3077-983f-4cfe-b624-c8a09acd28c8.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c20e3077-983f-4cfe-b624-c8a09acd28c8.png)'
- en: 85\. Reading movies from an SQLite database
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 85. 从SQLite数据库中读取电影
- en: 'Write a program that reads movies from an SQLite database and displays them
    on the console. Each movie must have a numerical identifier, a title, release
    year, length in minutes, list of directors, list of writers, and a cast that includes
    both the actor and the character names. The following is a diagram of the database
    that should be used for this purpose:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，从SQLite数据库中读取电影并在控制台上显示它们。每部电影必须具有数字标识符，标题，发行年份，分钟长度，导演列表，编剧列表以及包括演员和角色名称的演员表。以下是应用于此目的的数据库的图表：
- en: '![](img/3033e8b2-df86-4975-9c79-73b0ddce1fbc.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3033e8b2-df86-4975-9c79-73b0ddce1fbc.png)'
- en: 86\. Inserting movies into an SQLite database transactionally
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 86. 以事务方式将电影插入SQLite数据库
- en: Extended the program written for the previous problem so that it can add new
    movies to the database. The movies could be read from the console, or alternatively
    from a text file. The insertion of movie data into several tables in the database
    must be performed transactionally.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展为前一个问题编写的程序，以便它可以将新电影添加到数据库。电影可以从控制台读取，或者从文本文件中读取。必须以事务方式执行将电影数据插入数据库中的多个表。
- en: 87\. Handling movie images in an SQLite database
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 87. 在SQLite数据库中处理电影图像
- en: 'Modify the program written for the previous problem to support adding media
    files (such as images, but also videos) to a movie. These files must be stored
    in a separate table in the database and have a unique numerical identifier, the
    movie identifier, a name (typically the filename), an optional description, and
    the actual media content, stored as a blob. The following is a diagram with the
    structure of the table that must be added to the existing database:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 修改为前一个问题编写的程序，以支持向电影添加媒体文件（如图像，还有视频）。这些文件必须存储在数据库中的单独表中，并具有唯一的数字标识符，电影标识符，名称（通常是文件名），可选描述以及作为blob存储的实际媒体内容。以下是必须添加到现有数据库的表结构图：
- en: '![](img/057eaf49-6131-4f69-bb61-cc9b04f3362f.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/057eaf49-6131-4f69-bb61-cc9b04f3362f.png)'
- en: 'The program written for this problem must support several commands:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为此问题编写的程序必须支持几个命令：
- en: Listing all movies that match a search criterion (notably the title) ...
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有符合搜索条件（尤其是标题）的电影...
- en: Solutions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 79\. Finding files in a ZIP archive
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 79. 在ZIP存档中查找文件
- en: There are a variety of libraries that provide support for working with ZIP archives.
    Among the ones available for free, the most used ones include *ZipLib*, *Info-Zip*,
    *MiniZip*, and *LZMA SDK* from 7z. And then, there are also commercial implementations. For
    the problems regarding ZIP archives in this book, I have chosen `ZipLib`. This
    is a lightweight, open source cross-platform C++11 library built around standard
    library streams, with no additional dependencies. The library, along with its
    documentation, is available at [https://bitbucket.org/wbenny/ziplib](https://bitbucket.org/wbenny/ziplib).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多库提供了对ZIP存档的支持。在免费可用的库中，最常用的包括*ZipLib*、*Info-Zip*、*MiniZip*和来自7z的*LZMA SDK*。此外，还有商业实现。对于本书中涉及ZIP存档的问题，我选择了`ZipLib`。这是一个轻量级的、开源的跨平台C++11库，构建在标准库流周围，没有额外的依赖。该库及其文档可在[https://bitbucket.org/wbenny/ziplib](https://bitbucket.org/wbenny/ziplib)上找到。
- en: 'To implement the required functionality, you have to:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现所需的功能，你必须：
- en: Open the ZIP archive using `ZipFile::Open()`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ZipFile::Open()`打开ZIP存档
- en: Enumerate all the entries in the archive using `ZipArchive::GetEntry() ...`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ZipArchive::GetEntry()...`枚举存档中的所有条目
- en: 80\. Compressing and decompressing files to/from a ZIP archive
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 80. 将文件压缩到ZIP存档中并从中解压缩
- en: To solve this two-part problem, we will use the same `ZipLib` library we saw
    for the solution of the previous problem. The solution to this problem consists
    of two functions, one that is able to perform the compression to a ZIP archive
    and one that is able to perform decompression from a ZIP archive.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个两部分的问题，我们将使用我们在解决前一个问题时看到的相同的`ZipLib`库。这个问题的解决方案包括两个函数，一个能够对ZIP存档进行压缩，另一个能够对ZIP存档进行解压缩。
- en: 'In order to perform the requested compression, we should do the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行所请求的压缩，我们应该做以下操作：
- en: If the source path represents a regular file, then add that file to the ZIP
    archive using `ZipFile::AddFile()`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果源路径表示一个常规文件，则使用`ZipFile::AddFile()`将该文件添加到ZIP存档中
- en: 'If the source path represents a recursive directory, then:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果源路径表示一个递归目录，则：
- en: Iterate recursively through all the entries in the directory
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归遍历目录中的所有条目
- en: If an entry is a directory, then create a directory entry in the ZIP archive
    with ...
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果条目是一个目录，则在ZIP存档中创建一个目录条目...
- en: 81\. Compressing and decompressing files to/from a ZIP archive with password
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 81. 将文件压缩到ZIP存档中并从中解压缩，带密码
- en: 'This problem is very similar to the previous one with the addition that the
    files must be encrypted. The `ZipLib` library supports PKWare encryption only.
    Should you need to use another method for encryption, then you have to use another
    library. The `compress()` and `decompress()` functions, shown in the following, are
    similar to the implementation from the previous problem, but have a few differences,
    apart from the extra parameter that represents the password for the encryption/decryption
    of files:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题与前一个问题非常相似，只是文件必须加密。`ZipLib`库仅支持PKWare加密。如果需要使用其他加密方法，那么你必须使用另一个库。下面显示的`compress()`和`decompress()`函数与前一个问题中的实现类似，但除了表示文件加密/解密密码的额外参数之外，还有一些区别：
- en: Adding encrypted files to the archive is done with `ZipFile::AddEncryptedFile()`
    instead of `ZipFile::AddFile()`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ZipFile::AddEncryptedFile()`而不是`ZipFile::AddFile()`来向存档中添加加密文件
- en: When decompressing, the password must be set with `ZipArchiveEntry::SetPassword()
    ...`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在解压缩时，必须使用`ZipArchiveEntry::SetPassword()...`设置密码
- en: 82\. Creating a PNG that represents a national flag
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 82. 创建代表国旗的PNG
- en: The most feature-rich library for working with PNG files is *libpng*, a platform-independent,
    open source library written in C. There are also C++ libraries, some of which
    are wrappers for *libpng*, such as *png++*, *lodepng*, or *PNGWriter*. For the
    problems in this book, we will use the last one, *PNGWriter*. It is an open source
    library that works on Linux, Unix, macOS, and Windows. Its supported features
    include opening existing PNG images; plotting and reading pixels in the RGB, HSV,
    and CMYK color spaces; basic shapes; scaling; bilinear interpolation; full TrueType
    antialiased and rotated text support; and Bezier curves. It is a wrapper for *libpng*
    and also requires the `FreeType2` library for text ...
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 用于处理PNG文件的最丰富的库是*libpng*，这是一个平台无关的开源库，用C语言编写。还有一些C++库，其中一些是*libpng*的包装器，比如*png++*、*lodepng*或*PNGWriter*。在本书中，我们将使用最后一个*PNGWriter*。它是一个开源库，可以在Linux、Unix、macOS和Windows上使用。它支持的功能包括打开现有的PNG图像；在RGB、HSV和CMYK颜色空间中绘制和读取像素；基本形状；缩放；双线性插值；完整的TrueType抗锯齿和旋转文本支持；以及贝塞尔曲线。它是*libpng*的包装器，还需要`FreeType2`库来处理文本...
- en: 83\. Creating verification text PNG images
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 83. 创建验证文本PNG图像
- en: This problem can be solved in a similar manner to the previous one with the
    national flag. If you haven’t done that one first, I recommend that you do so
    before continuing with this one.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以以类似的方式解决，就像之前处理国旗问题一样。如果你还没有先做过那个问题，我建议你在继续这个问题之前先做一下。
- en: 'There are basically three elements that the image must have:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图像必须具有基本的三个元素：
- en: A gradient-color background. This can be achieved by drawing lines (vertically
    or horizontally) of a different color from one side to the other of the image.
    Drawing lines can be done with the `pngwriter::line()` function. There are several
    overloads available; the one used in the following code takes the start and end
    position and three values for the red, green, and blue channels of the RGB color
    space.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐变色背景。这可以通过在图像的一侧从一边到另一边绘制不同颜色的线条（垂直或水平）来实现。可以使用`pngwriter::line()`函数来绘制线条。有几种可用的重载；以下代码中使用的函数接受起始位置和结束位置，以及RGB颜色空间的红色、绿色和蓝色通道的三个值。
- en: A random text with letters displayed at various random ...
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个随机文本，其中包含各种随机显示的字母...
- en: 84\. EAN-13 barcode generator
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 84. EAN-13条形码生成器
- en: 'The *International Article Number* (aka *European Article Number* or *EAN*),
    as described on Wikipedia, is a standard describing a barcode symbology and numbering
    system that is used in global trade to identify a specific retail product type,
    in a specific packaging configuration, from a specific manufacturer. The most
    commonly used EAN standard is the 13-digit EAN-13\. A description of the standard,
    including information on how the barcode should be generated, can be found on
    Wikipedia at [https://en.wikipedia.org/wiki/International_Article_Number](https://en.wikipedia.org/wiki/International_Article_Number)
    and will not be detailed in this book. The following is the EAN-13 barcode for
    the number 5901234123457, given as an example in the problem’s description (source:
    Wikipedia): ...'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*国际商品条码*（又称*欧洲商品编号*或*EAN*），如维基百科所述，是一种描述用于全球贸易中识别特定零售产品类型、特定包装配置和特定制造商的条形码符号和编号系统的标准。最常用的EAN标准是13位EAN-13。标准的描述，包括有关如何生成条形码的信息，可以在维基百科上找到[https://en.wikipedia.org/wiki/International_Article_Number](https://en.wikipedia.org/wiki/International_Article_Number)，本书中不会详细介绍。以下是问题描述中给出的示例中数字5901234123457的EAN-13条形码（来源：维基百科）：...'
- en: 85\. Reading movies from an SQLite database
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 85\. 从SQLite数据库中读取电影
- en: SQLite is an in-process relational database management library written in C
    (although a large number of programming languages provide bindings to it). SQLite
    is not a client-server database engine, but one embedded into the application.
    The entire database, including tables, indexes, triggers, and views, is contained
    within a single disk file. Because accessing the database means accessing a local
    disk file, without any inter-process communication, SQLite has a better performance
    compared to other relational database engines. SQLite, as the name implies, uses
    SQL, although it does not implement all the features (such as `RIGHT OUTER JOIN`).
    SQLite is used in not just web browsers (several major ones ...
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite是一个用C语言编写的进程内关系数据库管理库（尽管许多编程语言都提供了与它的绑定）。SQLite不是一个客户端-服务器数据库引擎，而是嵌入到应用程序中的数据库。整个数据库，包括表、索引、触发器和视图，都包含在一个单独的磁盘文件中。由于访问数据库意味着访问本地磁盘文件，没有任何进程间通信，SQLite与其他关系数据库引擎相比具有更好的性能。SQLite正如其名字所暗示的那样，使用SQL，尽管它并没有实现所有功能（比如`RIGHT
    OUTER JOIN`）。SQLite不仅用于Web浏览器（几个主要的...
- en: 86\. Inserting movies into an SQLite database
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 86\. 将电影插入SQLite数据库
- en: The solution to this problem builds upon the previous one. You must solve that
    one before continuing here. Also, the function `split()` that is used in the code
    here is the same from problem 27, *Splitting a string into tokens with a list
    of possible delimiters*, from [Chapter 3](e9df2028-62cc-41c0-9834-d2cff13346dd.xhtml),
    *Strings and Regular Expressions*. For this reason, it will not be listed here
    again. In the source code for this book, you will find a database file called
    `cppchallenger86.db` that is prepared with several records for this problem.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题建立在前一个问题的基础上。在继续之前，您必须解决那个问题。此外，此处使用的`split()`函数与第27个问题中的代码相同，即*使用可能的分隔符列表将字符串拆分为标记*，来自[第3章](e9df2028-62cc-41c0-9834-d2cff13346dd.xhtml)，*字符串和正则表达式*。因此，这里不会再列出。在本书的源代码中，您将找到一个名为`cppchallenger86.db`的数据库文件，其中准备了几条记录供此问题使用。
- en: The following function, `read_movie()`, reads information about a movie from
    the console (title, release year, length in minutes, directors, writers, and cast),
    creates a `movie` object, and returns it. ...
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数`read_movie()`从控制台读取有关电影的信息（标题、发行年份、长度（分钟）、导演、编剧和演员），创建一个`movie`对象并返回它。...
- en: 87\. Handling movie images in an SQLite database
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 87\. 在SQLite数据库中处理电影图像
- en: If you have not done so already, you must complete the previous two problems
    before continuing with this one. For this problem, we must extend the database
    model with an additional table to store images and possibly other media files,
    such as videos. The actual content of the media files must be stored in a blob
    field, but other attributes, such as description and filename, should also be
    stored.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，您必须在继续进行此问题之前完成前两个问题。对于这个问题，我们必须通过添加一个额外的表来扩展数据库模型，以存储图像和可能的其他媒体文件，如视频。媒体文件的实际内容必须存储在blob字段中，但其他属性，如描述和文件名，也应该存储。
- en: 'When you are using large objects you have two options: either store them directly
    in the database as blobs or keep them in separate files and store only the file
    paths in the database. According to the tests performed by the developers of SQLite,
    for objects smaller than 100KB, reads are faster when ...'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '当您使用大对象时，有两种选择：要么将它们直接存储在数据库中作为blob，要么将它们保留在单独的文件中，并仅在数据库中存储文件路径。根据SQLite开发人员进行的测试，对于小于100KB的对象，读取速度更快... '
