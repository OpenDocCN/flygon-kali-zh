- en: Chapter 8. The Snake Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。蛇游戏
- en: In this chapter, we will get straight down to designing and implementing a clone
    of the highly addictive *Snake* game. We will look at the design of the game and
    learn how to animate some bitmaps. Then we will look at a few aspects of the code
    that are new, such as our coordinate system. After that, we will whiz through
    the implementation of the game. Finally, we will look at how we could enhance
    our game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将直接着手设计和实现一个高度上瘾的*Snake*游戏的克隆。我们将研究游戏的设计，并学习如何为一些位图添加动画。然后我们将看一下一些新的代码方面，比如我们的坐标系统。之后，我们将快速实现游戏。最后，我们将看一下如何增强我们的游戏。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Examine the design of our game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们游戏的设计
- en: Look at the coordinate system of our *Snake* game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看我们的*Snake*游戏的坐标系统
- en: Examine the code structure so that when we come to implement the game, it will
    be more straightforward
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查代码结构，以便在实现游戏时更加简单
- en: Learn about animation with sprite sheets at the same time as implementing the
    home screen of our game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用精灵表实现游戏主屏幕时的动画
- en: Break the code for the *Snake* game into manageable chunks and run through its
    full implementation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*Snake*游戏的代码分解为可管理的块，并运行其完整实现
- en: Enhance the game a little
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稍微增强游戏
- en: Game design
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏设计
- en: 'If you haven''t played the excellent *Snake* game before, here is an explanation
    of how it works. You control a very small snake. In our version, there is just
    a head, one body segment, and a tail. Here is a screenshot of our snake, made
    out of three segments:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前没有玩过优秀的*Snake*游戏，这里是它的工作原理的解释。你控制一个非常小的蛇。在我们的版本中，只有一个头部，一个身体部分和一个尾巴。这是我们蛇的截图，由三个部分组成：
- en: '![Game design](img/8859OS_08_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![游戏设计](img/8859OS_08_01.jpg)'
- en: 'The following screenshot shows the three segments individually:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了三个部分：
- en: '![Game design](img/8859OS_08_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![游戏设计](img/8859OS_08_02.jpg)'
- en: 'Now, here is the thing; our snake is very hungry and also a very quick grower.
    Every time he eats an apple, he grows a body segment. This is a screenshot of
    the apple:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题来了；我们的蛇非常饥饿，而且成长得非常快。每次他吃一个苹果，他就会长出一个身体部分。这是一个苹果的截图：
- en: '![Game design](img/8859OS_08_03.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![游戏设计](img/8859OS_08_03.jpg)'
- en: Life is great! Our snake just eats and grows! The problem that the player of
    our game needs to solve is that the snake is a little hyperactive. It never stops
    moving! What exacerbates this problem is that if the snake touches the side of
    the screen, it dies.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 生活真是美好！我们的蛇只是吃东西并长大！我们游戏的玩家需要解决的问题是，蛇有点过于活跃。它永远不停止移动！加剧这个问题的是，如果蛇触碰屏幕的边缘，它就会死亡。
- en: 'At first, this doesn''t seem like too much of a problem, but as he grows longer
    and longer, he can''t just keep going around in circles because he will bump inevitably
    into himself. This would again result in his demise:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这似乎并不是太大的问题，但随着蛇变得越来越长，他不能一直绕圈子走，因为他最终会不可避免地撞到自己。这将再次导致他的死亡：
- en: '![Game design](img/8859OS_08_04.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![游戏设计](img/8859OS_08_04.jpg)'
- en: 'For each apple eaten, we add an increasingly large amount to the score. Here
    is a sneak peek at what the game will look like after the basic implementation
    and before the enhancements:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每吃一个苹果，我们都会将一定数量添加到分数上。这是游戏在基本实现之后和增强之前的样子：
- en: '![Game design](img/8859OS_08_08.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![游戏设计](img/8859OS_08_08.jpg)'
- en: The player controls the snake by tapping on the left or the right side of the
    screen. The snake will respond by turning left or right. The turn directions are
    relative to the direction the snake is traveling, which adds to the challenge
    because the player needs to think like a snake—kind of!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家通过点击屏幕的左侧或右侧来控制蛇。蛇将通过向左或向右转向做出响应。转向方向是相对于蛇行进方向的，这增加了挑战，因为玩家需要像蛇一样思考！
- en: At the end of the chapter, we will also take a brief look at enhancing the game,
    use that enhanced version in the next chapter to publish it to the Google Play
    Store, and add leaderboards and achievements.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们还将简要介绍如何增强游戏，使用增强版在下一章中将其发布到Google Play商店，并添加排行榜和成就。
- en: The coordinate system
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坐标系统
- en: In the previous chapter, we drew all our game objects directly to points on
    the screen, and we used real screen coordinates to detect collisions, bounces,
    and so on. This time, we will be doing things slightly differently. This is partly
    out of necessity, but as we will see, collision detection and keeping track of
    our game objects will also get simpler. This might be surprising when we think
    about the potential of our snake to be many blocks long.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们直接将所有游戏对象绘制到屏幕上的点，并使用真实的屏幕坐标来检测碰撞、反弹等。这一次，我们将做一些稍微不同的事情。这在一定程度上是出于必要，但正如我们将看到的，碰撞检测和跟踪游戏对象也会变得更简单。当我们考虑到我们的蛇可能会变得很长时，这可能会让人感到惊讶。
- en: Keeping track of the snake segments
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪蛇的部分
- en: 'To keep track of all the snake segments, we will first define a block size
    to define a portion of a grid for the entire game area. Every game object will
    reside at an (x,y) coordinate, based not on the pixel resolution of the screen
    but on a position within our virtual grid. In the game, we define a grid that
    is 40 blocks wide, like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪所有蛇的部分，我们首先定义一个块大小来定义整个游戏区域的网格部分。每个游戏对象将驻留在(x,y)坐标处，不是基于屏幕的像素分辨率，而是基于我们虚拟网格内的位置。在游戏中，我们定义了一个宽度为40个方块的网格，就像这样：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So we know that:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们知道：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The height of the game screen in blocks will then simply be calculated by dividing
    the height of the screen in pixels by the previously determined value of `blockSize`
    minus a bit of space at the top for the score:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏屏幕的高度以方块为单位，将通过将屏幕的高度以像素为单位除以先前确定的“blockSize”的值来简单计算，减去顶部一点空间用于分数：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This then allows us to keep track of our snake using two arrays for *x* and
    *y* coordinates, where element zero is the head and the last used element is the
    tail, a bit like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这使我们可以使用两个数组来跟踪我们的蛇的*x*和*y*坐标，其中元素零是头部，最后使用的元素是尾部，就像这样：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As long as we have a system for moving the head, perhaps something similar
    to the squash ball but based on our new game grid, we can do the following to
    make the body follow the head:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们有一个移动头部的系统，也许类似于挤压球但基于我们的新游戏网格，我们就可以做以下事情让身体跟随头部移动：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous code simply starts at the back section of the snake and creates
    its location in the grid irrespective of what the section in front of it was.
    It proceeds up the body doing the same until everything has been moved to the
    location of the section that used to be just ahead of it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码简单地从蛇的后部开始，并在网格中创建其位置，而不管前面的部分是什么。它沿着身体向上进行相同的操作，直到一切都被移动到曾经在其前面的部分的位置。
- en: This also makes collision detection (even for a very long snake) nice and easy.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使得碰撞检测（即使对于非常长的蛇）变得非常简单。
- en: Detecting collisions
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: 'Using our grid based on `blockSize`, we can detect a collision, for example,
    with the right side of the screen, like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于`blockSize`的网格，我们可以检测碰撞，例如与屏幕右侧的碰撞，就像这样：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The previous code simply checks whether the first element of our array, which
    holds the *x* coordinate of the snake, is equal to or greater than the width of
    our game grid in blocks. Try to work out the code for collision with the left,
    top, and bottom before we see it during the implementation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码只是检查我们的数组的第一个元素（保存蛇的*x*坐标）是否等于或大于游戏网格的宽度（以块为单位）。在我们实现时，试着先想出与左侧、顶部和底部碰撞的代码。
- en: 'Detecting the event of the snake bumping into itself is quick too. We just
    need to check whether the first element of our array (the head) is in exactly
    the same position as any of the other sections, like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 检测蛇撞到自己的事件也很快。我们只需要检查我们的数组的第一个元素（头部）是否与任何其他部分的位置完全相同，就像这样：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Drawing the snake
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制蛇
- en: 'We simply draw every section of the snake relative to its grid location multiplied
    by the size in pixels of a block. The `blockSize` variable handles the entire
    challenge of making the game work on different screen sizes, like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需根据蛇的每个部分相对于其网格位置乘以一个块的像素大小来绘制。`blockSize`变量处理了使游戏在不同屏幕尺寸上运行的整个挑战，就像这样：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Admittedly, there are probably more questions about how our implementation will
    work, but they are probably best answered by actually building the game.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，关于我们的实现将如何工作可能还有更多问题，但最好的答案可能是通过实际构建游戏来回答。
- en: Thus, we can easily follow along by either writing the code or just reading
    from the completed project. Let's take a look at the overall structure of our
    code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过编写代码或仅从已完成的项目中阅读来轻松跟进。让我们来看看我们代码的整体结构。
- en: The code structure
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码结构
- en: We will have two activities, one for the menu screen and one for the game screen.
    The menu screen activity will be called `MainActivity`, and the game screen activity
    will be called `GameActivity`. You can find all the completed code files as well
    as all the assets such as images, sprite sheets, and sound files in the `Chapter8/Snake`
    folder in the download bundle.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有两个活动，一个用于菜单屏幕，一个用于游戏屏幕。菜单屏幕活动将被称为`MainActivity`，游戏屏幕活动将被称为`GameActivity`。您可以在下载包的`Chapter8/Snake`文件夹中找到所有已完成的代码文件以及所有资产，如图像、精灵表和声音文件。
- en: MainActivity
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主活动
- en: 'In contrast to our other projects, the menu screen will not have a UI designed
    in the Android Studio UI designer. It will consist of an animated snake head,
    a title, and a high score. The player will proceed to `GameActivity` by tapping
    anywhere on the screen. As we need to accomplish animations and user interactions,
    even the home screen will have a thread, a view object, and methods normally associated
    with our game screens, like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的其他项目不同，菜单屏幕将不会在Android Studio UI设计器中设计UI。它将由一个动画蛇头、一个标题和一个高分组成。玩家将通过在屏幕上的任何位置轻击来进入`GameActivity`。由于我们需要完成动画和用户交互，即使主屏幕也将有一个线程、一个视图对象和通常与我们的游戏屏幕相关的方法，就像这样：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will not go deeper into the menu screen for now because at the end of this
    section, we will implement it line by line.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时不会深入研究菜单屏幕，因为在本节结束时，我们将逐行实现它。
- en: GameActivity
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏活动
- en: 'The game screen structure has many similarities to our Squash game and to the
    structure of the menu screen, although the internals of this structure vary a
    lot (as we have discussed and as we will see). There are some differences towards
    the end of the structure, most notably, a `loadSound` method and a `configureDisplay`
    method. Here is the structure (we will see afterwards why the two extra methods
    are there):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏屏幕结构与我们的Squash游戏和菜单屏幕的结构有许多相似之处，尽管这种结构的内部差异很大（正如我们已经讨论过的和将要看到的）。在结构的末尾有一些差异，尤其是`loadSound`方法和`configureDisplay`方法。这是结构（之后我们将看到为什么有这两个额外的方法）：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tidying up onCreate
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整理onCreate
- en: 'One of the first things you might notice when you examine the code from the
    `GameActivity` class we will soon implement is just how short the `onCreate` method
    is:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当您很快实现的`GameActivity`类的代码时，您可能会注意到的第一件事是`onCreate`方法有多么简短：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have written two methods, `loadSound` and `configureDisplay`. They do most
    of the initialization and setup present in our squash game. This makes our code
    less cluttered. All that is left in `onCreate` is the initialization of our `SnakeView`
    object and a call to `setContentView`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了两个方法，`loadSound`和`configureDisplay`。它们完成了我们挤压游戏中的大部分初始化和设置。这使得我们的代码更加整洁。在`onCreate`中只剩下初始化我们的`SnakeView`对象和调用`setContentView`。
- en: We will look in detail at our `loadSound` and `configureDisplay` methods when
    we implement them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现它们时，我们将详细查看我们的`loadSound`和`configureDisplay`方法。
- en: As we have had advanced sight of the structure as well as previous experience
    of this type of implementation, we will just go through all of the implementation
    of our game activity in one phase.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经提前了解了结构并且有了这种实现类型的先前经验，我们将在一个阶段内完成我们游戏活动的所有实现。
- en: Let's quickly implement the menu screen.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速实现菜单屏幕。
- en: Animation, sprite sheets, and the Snake home screen
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画、精灵表和蛇的主屏幕
- en: In the previous chapter, we used a bitmap to draw text, a circle, a line, and
    a single pixel on the blank bitmap we created in Java code. We then displayed
    the bitmap with all of its doodling using the `Canvas` class. Now we will look
    at a technique to draw two dimensional images, sometimes referred to as sprites.
    These are made from predrawn images. The images can be as simple as a plain pong
    ball or as complex as a glorious two-dimensional character with muscle definition,
    elaborate clothing, weapons, and hair.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用位图在我们用Java代码创建的空白位图上绘制文本、圆圈、线条和单个像素。然后，我们使用`Canvas`类显示了所有涂鸦的位图。现在我们将看一种绘制二维图像的技术，有时被称为精灵。这些是由预先绘制的图像制成的。这些图像可以是简单的乒乓球，也可以是拥有肌肉定义、精美服装、武器和头发的辉煌的二维角色。
- en: So far, we have animated with unchanging objects, that is, we have moved a static
    unchanging image around the screen. In this section, we will see how to not only
    display a predrawn bitmap image on the screen but also continually alter it to
    create the illusion of on-the-spot animation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经用不变的对象进行了动画，也就是说，我们已经将一个静态不变的图像在屏幕上移动了。在本节中，我们将看到如何不仅在屏幕上显示预先绘制的位图图像，而且不断地改变它以创建现场动画的幻觉。
- en: Of course, the ultimate combination would be to animate the bitmap both by changing
    its image and moving it around at the same time. We will see that briefly when
    we look at an enhanced version of this chapter's *Snake* game, but will not be
    analyzing the code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最终的组合将是通过同时改变图像和移动图像来实现位图动画。当我们查看本章节《Snake》游戏的增强版本时，我们将会简要看到这一点，但不会分析代码。
- en: 'To do this on-the-spot bitmap animation, we need some bitmaps, as you might
    expect. For example, to draw a snake''s tail swishing back and forth, we would
    need at least two frames of animation, showing the tail in different positions.
    In the following screenshot, the flower''s head is towards the left:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要在现场进行位图动画，我们需要一些位图，正如你所期望的那样。例如，要绘制蛇尾来回摆动，我们至少需要两帧动画，显示尾巴在不同位置的样子。在下面的截图中，花朵的头朝向左侧：
- en: '![Animation, sprite sheets, and the Snake home screen](img/8859OS_08_05.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: 使用精灵表进行动画
- en: 'In this screenshot, the flower has been flipped:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中，花朵已经被翻转：
- en: '![Animation, sprite sheets, and the Snake home screen](img/8859OS_08_06.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: 动画、精灵表和蛇的主屏幕
- en: If the two bitmaps were shown one after the other, repeatedly, they would create
    the basic effect of a flower blowing in the wind. Of course, two frames of animation
    aren't going to contest for any animation awards, and there is another problem
    with these images as well, as we will learn, so we should add in more frames to
    make the animation as life-like as is practical.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个位图连续显示，它们将创建花在风中摇摆的基本效果。当然，两帧动画不会争夺任何动画奖项，而且这些图像还有另一个问题，正如我们将要学到的，所以我们应该添加更多帧来使动画尽可能逼真。
- en: We have just one more thing to discuss before we make an animated snake head
    for our game's home screen. How do we get Android to switch between these bitmaps?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为游戏的主屏幕制作一个动画蛇头之前，我们还有一件事要讨论。我们如何让Android在这些位图之间切换？
- en: Animating with sprite sheets
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用精灵表进行动画
- en: 'Firstly, we need to present the frames in a manner that is easy to manipulate
    in code. This is where sprite sheets come in. The following image shows some frames
    from a basic snake head animation that we will use on our game home screen. This
    time, they are presented in a strip of frames. All of them are parts of the same
    image, a bit like a series of images in a film. Also, notice in the following
    image that the frames are centered relative to each other and are exactly equal
    in size:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要以一种易于在代码中操作的方式呈现帧。这就是精灵表的用武之地。下面的图像显示了我们将在游戏主屏幕上使用的基本蛇头动画的一些帧。这一次，它们呈现在一条帧条中。它们都是同一图像的部分，有点像电影中的一系列图像。另外，请注意在下面的图像中，帧相对于彼此居中并且大小完全相等：
- en: '![Animating with sprite sheets](img/8859OS_08_07.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: 使用精灵表进行动画
- en: If we were to actually show the two previous flower images consecutively, they
    would not only would they sway but also jump around from one side to another on
    their stems, which is probably not the effect we were looking for.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实际上连续显示两个前面的花朵图像，它们不仅会摇摆，而且还会在它们的茎上来回跳动，这可能不是我们想要的效果。
- en: Thus, with regard to the snake sprite sheet, as long as we show one frame after
    another, we will create a basic animation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就蛇精灵表而言，只要我们一个接一个地显示帧，我们就会创建一个基本的动画。
- en: So how do we make our code jump from one part of the sprite sheet to the next?
    Each frame is exactly the same size, 64 x 64 pixels in this case, so we just need
    a way to display pixels from 0 to 63, then 64 to 127, then 128 to 192, and so
    on. As each frame of the sprite sheet image is subtly different, it allows us
    to use one image file with multiple frames to create our animation. Fortunately,
    we have a class to handle this, which is nothing quite as luxurious as a specific
    sprite sheet class but almost.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何让我们的代码从精灵表的一个部分跳到另一个部分呢？每一帧的大小都完全相同，在这种情况下是64 x 64像素，所以我们只需要一种方法来显示从0到63的像素，然后是64到127，然后是128到192，依此类推。由于精灵表图像的每一帧都略有不同，它允许我们使用一个图像文件来创建我们的动画。幸运的是，我们有一个处理这个的类，虽然不像专门的精灵表类那样奢华，但几乎一样。
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Regarding sprite sheet classes, such a thing does exist, although not in the
    regular Android classes. An API specifically designed for two-dimensional games
    will usually contain classes for sprite sheets. We will look at examples of this
    in the next chapter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于精灵表类，这样的东西确实存在，尽管不在常规的Android类中。专门为二维游戏设计的API通常会包含精灵表的类。我们将在下一章中看到这方面的例子。
- en: 'The `Rect` class holds the coordinates of a rectangle. Here, we create a new
    object of the `Rect` type, and initialize it to start at 0, 0 and end at 63, 63:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rect`类保存矩形的坐标。在这里，我们创建了一个`Rect`类型的新对象，并将其初始化为从0,0开始到63,63结束：'
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Canvas` class can then actually use our `Rect` object to define a portion
    of a previously loaded bitmap:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Canvas`类实际上可以使用我们的`Rect`对象来定义先前加载的位图的一部分：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code is much simpler than it looks. First, we see `canvas.drawBitmap`.
    We are using the `drawBitmap` method of the `Canvas` class just as we have before.
    Then we pass `headAnimBitmap`, which is our sprite sheet containing all the frames
    we want to animate, as an argument. Rect `rectToBeDrawn` represents the coordinates
    of the currently relevant frame within `headAnimationBitmap`. `destRect` simply
    represents the screen coordinates at which we want to draw the current frame,
    and of course, `paint` is our object of the `Paint` class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码比看起来简单得多。首先，我们看到`canvas.drawBitmap`。我们使用`Canvas`类的`drawBitmap`方法，就像以前一样。然后我们将`headAnimBitmap`作为参数传递，它是包含我们要动画的所有帧的精灵表。`rectToBeDrawn`代表当前相关帧在`headAnimationBitmap`中的坐标。`destRect`简单地表示我们要绘制当前帧的屏幕坐标，当然，`paint`是`Paint`类的对象。
- en: All we have to do now is change the coordinates of `rectToBeDrawn` and control
    the frame rate with a thread and we are done! Let's do that and create an animated
    home screen for our *Snake* game.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所要做的就是改变`rectToBeDrawn`的坐标，并使用线程控制帧速率，我们就完成了！让我们这样做，为我们的*Snake*游戏创建一个动画主屏幕。
- en: Implementing the Snake home screen
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现蛇的主屏幕
- en: 'With the background information we just covered and our detailed look at the
    structure of the code we are about to write, there shouldn''t be any surprises
    in this code. We will break things up into chunks just to make sure we follow
    exactly what is going on:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们刚刚介绍的背景信息以及我们对即将编写的代码结构的详细了解，这段代码不应该有任何意外。我们将把事情分成几块，只是为了确保我们确切地知道发生了什么：
- en: Create a new project of API level 13\. Call it `Snake`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个API级别为13的新项目。将其命名为`Snake`。
- en: Make the activity full screen as we have done before, and put your graphics
    into the `drawable/mdpi` folder. Of course, you can use my graphics as usual.
    They are supplied in the code download in the `graphics` folder of the `Snake`
    project.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像以前一样将活动设置为全屏，并将图形放入`drawable/mdpi`文件夹中。当然，您可以像往常一样使用我的图形。它们在`Snake`项目的`graphics`文件夹中提供了代码下载。
- en: 'Here, you will find our `MainActivity` class declaration and member variables.
    Notice the variables for our `Canvas` and `Bitmap` class as well, we are declaring
    variables to hold frame size (width and height) as well as the number of frames.
    We also have a `Rect` object to hold the coordinates of the current frame of the
    sprite sheet. We will see these variables in action soon. Type the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，您将找到我们的`MainActivity`类声明和成员变量。注意我们的`Canvas`和`Bitmap`类的变量，我们声明变量来保存帧大小（宽度和高度）以及帧数。我们还有一个`Rect`对象来保存精灵表的当前帧的坐标。我们很快就会看到这些变量的作用。输入以下代码：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is the implementation of the overridden `onCreate` method. We
    get the screen dimensions in the usual way. We load our sprite sheet into the
    `headAnimBitmap` Bitmap. Finally, we create a new `SnakeAnimView` and set it as
    the content view. Type the following code after the code from the previous step:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是重写的`onCreate`方法的实现。我们以通常的方式获取屏幕尺寸。我们将我们的精灵表加载到`headAnimBitmap`位图中。最后，我们创建一个新的`SnakeAnimView`并将其设置为内容视图。在上一步的代码之后输入以下代码：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the declaration of our `SurfaceView` class, called `SnakeAnimView`,
    along with its member variables. Notice that it extends `SurfaceView` and implements
    `Runnable`. All its methods follow in the next steps. Type this code after the
    code from the preceding step:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们的`SurfaceView`类`SnakeAnimView`的声明，以及它的成员变量。注意它扩展了`SurfaceView`并实现了`Runnable`。它的所有方法都在接下来的步骤中。在上一步的代码之后输入以下代码：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the constructor that gets the `frameWidth` value by dividing the bitmap
    width by the number of frames, and the `frameHeight` value using the `getHeight`
    method. Type this code after the code from the previous step:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是构造函数，通过将位图宽度除以帧数得到`frameWidth`值，并使用`getHeight`方法得到`frameHeight`值。在上一步的代码之后输入以下代码：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we implement the short but crucial `run` method. It calls each of the key
    methods of this class one after the other. These three methods are implemented
    in the following three steps after this step. Type the following code after the
    code from the preceding step:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们实现了简短但至关重要的`run`方法。它依次调用这个类的每个关键方法。这三个方法在此步骤之后的三个步骤中实现。在上一步的代码之后输入以下代码：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the `update` method. It tracks and chooses the frame number that needs
    to be displayed. Each time through the `update` method, we calculate the coordinates
    of the sprite sheet to be drawn using `frameWidth`, `frameHeight`, and `frameNumber`.
    If you are wondering why we subtract `1` from each horizontal coordinate, it is
    because like the screen coordinates, bitmaps start their coordinates at 0, 0:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`update`方法。它跟踪并选择需要显示的帧编号。每次通过`update`方法，我们使用`frameWidth`，`frameHeight`和`frameNumber`计算要绘制的精灵表的坐标。如果您想知道为什么我们从每个水平坐标中减去`1`，那是因为像屏幕坐标一样，位图从0,0开始它们的坐标：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next is the `draw` method, which does nothing new until the end, when it calculates
    the place on the screen to draw the bitmap by dividing the `screenHeight` and
    `screenWidth` variables by 2\. These coordinates are then saved in `destRect`.
    Both `destRect` and `rectToDraw` are then passed to the `drawBitmap` method, which
    draws the frame required at the location required. Type this code after the code
    from the previous step:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`draw`方法，直到最后都没有什么新的，当它通过`screenHeight`和`screenWidth`变量除以2来计算在屏幕上绘制位图的位置时才有变化。然后将这些坐标保存在`destRect`中。`destRect`和`rectToDraw`都传递给`drawBitmap`方法，该方法在所需位置绘制所需的帧。在上一步的代码之后输入这段代码：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our trusty old `controlFPS` method ensures that our animation appears at a
    sensible rate. The only change in this code is that the initialization of `timeTosleep`
    is changed to create a 500-millisecond pause between each frame. Type the following
    code after the code from the preceding step:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可靠的`controlFPS`方法确保我们的动画以合理的速度显示。这段代码的唯一变化是将`timeTosleep`的初始化更改为在每帧之间创建500毫秒的暂停。在上一步的代码之后输入以下代码：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next are our `pause` and `resume` methods, which work with the Android lifecycle
    methods to start and stop our thread. Type this code after the code from the previous
    step:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是我们的`pause`和`resume`方法，它们与Android生命周期方法一起工作，以启动和停止我们的线程。在上一步的代码之后输入这段代码：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For our `SnakeAnimView` class and our `onTouchEvent` method, which simply starts
    the game when the screen is touched anywhere, we enter the following code. Obviously,
    we don''t have a `GameActivity` yet:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的`SnakeAnimView`类和`onTouchEvent`方法，当屏幕的任何位置被触摸时简单地启动游戏，我们输入以下代码。显然，我们还没有`GameActivity`：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, back in the `MainActivity` class, we handle some Android lifecycle
    methods. We also handle what happens when the player presses the back button:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`MainActivity`类中，我们处理了一些Android生命周期方法。我们还处理了当玩家按下返回按钮时会发生什么：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now you must temporarily comment out this line from step 4 to test the animation.
    The reason for this is that it causes an error until we implement the `GameActivity`
    class:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您必须暂时注释掉步骤4中的这行代码以测试动画。这样做的原因是在我们实现`GameActivity`类之前，它会导致错误：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Test the app.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试应用程序。
- en: Uncomment the line from step 14 when we have implemented the `GameActivity`
    class. Here is our completed home screen:![Implementing the Snake home screen](img/8859OS_08_10.jpg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们实现了`GameActivity`类时，取消步骤14中的注释。这是我们完成的主屏幕：![实现贪吃蛇主屏幕](img/8859OS_08_10.jpg)
- en: In this exercise, we set up a class that extended `SurfaceView`, just like we
    did for our squash game. We had a `run` method, which controlled the thread, as
    well as an `update` method, which calculated the coordinates of the current animation
    within our sprite sheet. The `draw` method simply drew to the screen using the
    coordinates calculated by the `update` method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们设置了一个扩展了`SurfaceView`的类，就像我们为壁球游戏做的那样。我们有一个控制线程的`run`方法，以及一个计算当前动画在精灵表中坐标的`update`方法。`draw`方法只是使用`update`方法计算的坐标在屏幕上绘制。
- en: As in the squash game, we had an `onTouchUpdate` method, but the code this time
    was very simple. As a touch of any type in any location was all we needed to detect,
    we added just one line of code to the method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就像壁球游戏一样，我们有一个`onTouchUpdate`方法，但这次的代码非常简单。因为我们只需要检测任何位置的任何类型的触摸，所以我们只需在方法中添加一行代码。
- en: Implementing the Snake game activity
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现贪吃蛇游戏活动
- en: Not all of this code is new. In fact, we have either used most of it before
    or discussed it earlier in the chapter. However, I wanted to present every line
    to you in order and in context with at least a brief explanation, even when we
    have seen it before. Having said that, I haven't included the long list of imports
    as we will either be prompted to add them automatically or we can just press *Alt*
    + *Enter* when needed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是所有的代码都是新的。事实上，我们要么以前大部分都用过，要么在本章中早些时候已经讨论过。然而，我想按顺序和至少简要解释的方式向您呈现每一行，即使我们以前已经看到过。话虽如此，我没有包括导入的长列表，因为我们要么会被提示自动添加它们，要么在需要时只需按*Alt*
    + *Enter*。
- en: 'This way, we can remind ourselves how the whole thing comes together without
    any blanks in our understanding. As usual, I will summarize as we proceed through
    the implementation, and go into a few bits of extra depth at the end:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以在没有任何理解上的空白的情况下回顾整个过程。像往常一样，随着实现的进行，我会进行总结，并在最后深入一些细节：
- en: Add an activity called `GameActivity`. Select a blank activity when asked.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`GameActivity`的活动。当询问时选择一个空活动。
- en: Make the activity full screen as we have done before.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像以前一样，将活动设置为全屏。
- en: As usual, create some sound effects or use mine. Create an `assets` directory
    in the `main` directory in the usual way. Copy and paste the sound files (`sample1.ogg`,
    `sample2.ogg`, `sample3.ogg`, and `sample4.ogg`) into it.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，创建一些音效或使用我的音效。按照通常的方式在`main`目录中创建一个`assets`目录。将声音文件（`sample1.ogg`，`sample2.ogg`，`sample3.ogg`和`sample4.ogg`）复制粘贴到其中。
- en: Create individual non-sprite-sheet versions of graphics or use mine. Copy and
    paste them in the `res/drawable-mdpi` folder.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建单独的非精灵表版本的图形，或者使用我的。将它们复制粘贴到`res/drawable-mdpi`文件夹中。
- en: 'Here is the `GameActivity` class declaration with the member variables. There
    is nothing new here until we declare our arrays for our snake (`snakeX` and `snakeY`).
    Also, notice our variables used to control our game grid (`blockSize`, `numBlocksHigh`,
    and `numBlocksWide`). Now type this code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`GameActivity`类声明和成员变量。在这里没有什么新的，直到我们声明了贪吃蛇的数组（`snakeX`和`snakeY`）。还要注意我们用来控制游戏网格的变量（`blockSize`，`numBlocksHigh`和`numBlocksWide`）。现在输入这段代码：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As explained previously, our new, small `onCreate` method has very little to
    do because much of the work is done in the `loadSound` and `configureDisplay`
    methods. Type this code after the code from the previous step:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们的新的小`onCreate`方法几乎没有什么要做的，因为大部分工作都是在`loadSound`和`configureDisplay`方法中完成的。在上一步的代码之后输入这段代码：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is the class declaration, member variables, and constructor for our `SnakeView`
    class. We allocate 200 `int` variables to the `snakeX` and `snakeY` arrays, and
    call the `getSnake` and `getApple` methods, which will place an apple and our
    snake on the screen. This is just what we want when the class is constructed:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们的`SnakeView`类的类声明，成员变量和构造函数。我们为`snakeX`和`snakeY`数组分配了200个`int`变量，并调用了`getSnake`和`getApple`方法，这将在屏幕上放置一个苹果和我们的蛇。这正是在类构造时我们想要的：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is how we spawn a snake and an apple in our coordinate system. In the
    `getSnake` method, we place the snake''s head in the approximate center of the
    screen by initializing `snakeX[0]` and `snakeY[0]` to the number of blocks high
    and wide divided by 2\. We then place a body segment and the tail segment immediately
    behind. Notice that we don''t need to make any special arrangement for the different
    types of segments. As long as the drawing code *knows* that the first segment
    is a head, the last segment is a tail, and everything in between is a body, then
    that will do. In the `getApple` method, the integer variables `appleX` and `appleY`
    are initialized to random locations within our game grid. This method is called
    from the constructor, as we saw in the previous step. It will also be called to
    place a new apple every time our snake manages to eat an apple, as we will see.
    Type this code after the code from the previous step:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们如何在我们的坐标系统中生成蛇和苹果。在`getSnake`方法中，我们通过将`snakeX[0]`和`snakeY[0]`初始化为高度和宽度均分之后的块数的中心位置，将蛇的头放在屏幕的大致中心。然后我们立即在后面放置一个身体段和尾部段。请注意，我们不需要为不同类型的段做任何特殊安排。只要绘图代码*知道*第一个段是头部，最后一个段是尾部，中间的一切都是身体，那就可以了。在`getApple`方法中，整数变量`appleX`和`appleY`被初始化为游戏网格内的随机位置。这个方法是从构造函数中调用的，就像我们在前一步中看到的那样。每当我们的蛇设法吃掉一个苹果时，它也将被调用以放置一个新的苹果，我们将会看到。在前一步的代码之后输入此代码：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next comes the `run` method, which controls the flow of the game. Type the
    following code after the code from the previous step:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`run`方法，它控制游戏的流程。在前一步的代码之后输入以下代码：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we will look at `updateGame`, the most complex method of the entire app.
    Having said that, it is probably slightly less complex than the same method in
    our squash game. This is because of our coordinate system, which leads to simpler
    collision detection. Here is the code for `updateGame`. Study it carefully, and
    we will dissect it line by line at the end:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将看一下`updateGame`，整个应用程序中最复杂的方法。话虽如此，它可能比我们挤压游戏中的同一方法稍微复杂一些。这是因为我们的坐标系统导致了更简单的碰撞检测。这是`updateGame`的代码。仔细研究它，我们将在最后一行一行地剖析它：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We have worked out where our game objects are on the screen, so now we can
    draw them. This code is easy to understand as we have seen most of it before:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经弄清楚了游戏对象在屏幕上的位置，现在我们可以绘制它们。这段代码很容易理解，因为我们之前大部分都见过：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here is the `controlFPS` method, unchanged from our squash game''s `controlFPS`
    method, except that we have a different target frame rate. Type this code after
    the code from the preceding step:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`controlFPS`方法，与我们的挤压游戏的`controlFPS`方法相同，只是我们有一个不同的目标帧率。在前一步的代码之后输入此代码：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here are our unchanged `pause` and `resume` methods. Type the following code
    after the code from the previous step:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是我们未更改的`pause`和`resume`方法。在前一步的代码之后输入以下代码：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then we have the `onTouchEvent` method, similar to that of our squash game.
    There are no new concepts here, but the way it works in this game is as follows.
    We switch on the `ACTION_UP` event. This is broadly the same as detecting a click.
    We then check whether the press was on the left or the right. If it was on the
    right, we increment `directionOfTravel`. If it was on the left, we decrement `directionOfTravel`.
    If you looked carefully at the `updateGame` method, you would have seen that `directionOfTravel`
    indicates the direction in which to move the snake. Remember, the snake never
    stops. This is why we did it differently from our squash game. Type this code
    after the code from the previous step:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是`onTouchEvent`方法，类似于我们挤压游戏的方法。这里没有新概念，但在这个游戏中它的工作方式如下。我们打开`ACTION_UP`事件。这与检测点击大致相同。然后我们检查按压是在左边还是右边。如果在右边，我们增加`directionOfTravel`。如果在左边，我们减少`directionOfTravel`。如果你仔细看`updateGame`方法，你会发现`directionOfTravel`表示移动蛇的方向。记住，蛇永远不会停止。这就是为什么我们与我们的挤压游戏做法不同的原因。在前一步的代码之后输入此代码：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Back in the `GameActivity` class, we now handle the Android lifecycle methods
    and the "back" button functionality. Type this code after the code from the preceding
    step:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameActivity`类中，我们现在处理Android生命周期方法和“返回”按钮功能。在前一步的代码之后输入以下代码：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here is our `loadSound` method, which simply tidies up the `onCreate` method
    by moving all of the sound initialization to here. Type this code after the code
    from the previous step:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们的`loadSound`方法，它通过将所有声音初始化移动到这里，简化了`onCreate`方法。在前一步的代码之后输入以下代码：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then we have the `configureDisplay` method, which is called from `onCreate`
    and does the entire setup of bitmaps and screen size calculations. We will look
    at this in more detail later. Type the following code after the code from the
    previous step:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是`configureDisplay`方法，它从`onCreate`中调用并完成了位图和屏幕大小计算的整个设置。我们稍后会更详细地看一下这个。在前一步的代码之后输入以下代码：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now run the app. The game is much more playable on an actual device than it
    is on the emulator.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序。在实际设备上，游戏比在模拟器上更容易玩。
- en: We covered the code as we progressed, but as usual, here is a piece-by-piece
    dissection of a few of the more complicated methods, starting with the `updateGame`
    method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在进行过程中逐步介绍了代码，但像往常一样，这里是一些更复杂方法的逐步剖析，从`updateGame`方法开始。
- en: 'First, we check whether the player has eaten an apple. More specifically, is
    the snake''s head in the same grid location as the apple? The `if` statement checks
    whether this has occurred, and then does the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查玩家是否吃了一个苹果。更具体地说，蛇的头部是否与苹果在同一个网格位置？`if`语句检查是否发生了这种情况，然后执行以下操作：
- en: Increases the length of the snake
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加蛇的长度
- en: Puts another apple on the screen by calling `getApple`
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`getApple`在屏幕上放置另一个苹果
- en: Adds a value to the player's score, relative to the length of the snake, making
    each apple worth more than the previous one
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据蛇的长度为玩家的分数增加一个值，使每个苹果的价值都比上一个更高
- en: Plays a beep
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发出蜂鸣声
- en: 'Here is the code for the actions that we have just described:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们刚刚描述的操作的代码：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we simply move each segment of the snake, starting from the back, to the
    position of the segment in front of it. We do this with a `for` loop:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只是简单地移动蛇的每个部分，从后面开始，到它前面的位置。我们使用`for`循环来做到这一点：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Of course, we better move the head too! We move the head last because the leading
    section of the body would move to the wrong place if we move the head earlier.
    As long as the entire move is made before any drawing is done, all will be well.
    Our `run` method ensures that this is always the case. Here is the code to move
    the head in the direction determined by `directionOfTravel`. As we saw, `directionOfTravel`
    is manipulated by the player in the `onTouchEvent` method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们最好也移动头部！我们之所以最后移动头部，是因为如果我们之前移动头部，身体的前部分会移动到错误的位置。只要在进行任何绘图之前完成整个移动，一切都会很好。我们的`run`方法确保这总是成立。以下是根据`directionOfTravel`确定的方向移动头部的代码。正如我们所看到的，`directionOfTravel`是由玩家在`onTouchEvent`方法中操作的：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we check for a collision with a wall. We saw this code when we looked
    at collision detection earlier. Here is the complete solution, starting with the
    left wall, then right, then top, and then bottom:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否与墙壁发生了碰撞。我们在之前查看碰撞检测时看到了这段代码。以下是完整的解决方案，从左墙开始，然后右墙，然后顶部，最后底部：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then we check whether the snake has collided with itself. Initially, this seemed
    awkward, but as we previously saw, we just loop through our snake array to check
    whether any of the segments are in the same place as the head, in both *x* and
    *y* coordinates:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查蛇是否与自身发生了碰撞。最初，这似乎很尴尬，但正如我们之前看到的，我们只需循环遍历我们的蛇数组，检查任何部分是否与头部在相同的位置，无论是在*x*坐标还是*y*坐标上：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If any part of our collision detection code sets `dead` to `true`, we simply
    play a sound, set the `score` to `0`, and get a new baby snake:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的任何碰撞检测代码将`dead`设置为`true`，我们只需播放一个声音，将`score`设置为`0`，然后得到一个新的小蛇：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we take a closer look at the `drawGame` method. First, we get ready to
    draw by clearing the screen:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更仔细地看一下`drawGame`方法。首先，我们准备通过清除屏幕来绘制：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we draw the text for the player''s score, just above `topGap` that we define
    in `configureDisplay`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为玩家的分数绘制文本，就在我们在`configureDisplay`中定义的`topGap`上方：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, using `drawLine`, we draw a visible border around our game grid:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`drawLine`，我们在游戏网格周围绘制一个可见的边框：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we draw the snake''s head:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们绘制蛇的头部：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The snake''s head will be followed by all the body segments. Look at the condition
    of the `for` loop. This starts at `1`, which means it is not redrawing the head
    position, and ends at `snakeLength - 1`, which means it is not drawing the tail
    segment. Here is the code used to draw the body section:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 蛇的头部将被所有的身体部分跟随。看一下`for`循环的条件。这从`1`开始，这意味着它不会重绘头部位置，结束于`snakeLength - 1`，这意味着它不会绘制尾部部分。以下是用于绘制身体部分的代码：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we draw the tail of the snake:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们绘制蛇的尾巴：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we draw the apple as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们按以下方式绘制苹果：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Next, we will go through the `configureDisplay` method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将详细介绍`configureDisplay`方法。
- en: 'First, we get the screen resolution and store the results in `screenWidth`
    and `screenHeight` as normal:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取屏幕分辨率，并像往常一样将结果存储在`screenWidth`和`screenHeight`中：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, we define a gap called `topGap`. It will be a space at the top of the
    screen and will not be a part of the game area. This gap is used for the score.
    We saw `topGap` used fairly extensively in the `drawGame` method. After this,
    we calculate the width and height of the remaining area in blocks:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个叫做`topGap`的间隙。它将是屏幕顶部的一个空间，不会成为游戏区域的一部分。这个间隙用于分数。我们在`drawGame`方法中相当广泛地看到了`topGap`的使用。之后，我们计算剩余区域的宽度和高度：
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the following part of the code, we load all our image files into `Bitmap`
    objects:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的下一部分中，我们将所有的图像文件加载到`Bitmap`对象中：
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we scale each bitmap to be the same width and height as `blockSize`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将每个位图缩放为与`blockSize`相同的宽度和高度：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now we can take a quick look at a few different ways we can improve the game.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以快速看一下我们可以改进游戏的几种不同方式。
- en: Enhancing the game
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强游戏
- en: Here is a series of questions and answers to lead us to an improved version
    of our *Snake* game. It doesn't matter if you can't answer some (or even all)
    of the questions. Just take a look at the questions and answers, after which you
    can take a look at the new game and the code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一系列问题和答案，引导我们改进*Snake*游戏的版本。如果你无法回答一些（甚至全部）问题，也没关系。只需看一下问题和答案，然后你可以看一下新游戏和代码。
- en: Self-test questions
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: Q1) What can be used to provide a visual improvement for our game screen? Can
    we use a nice light green, grassy background instead of just black?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Q1）有什么可以用来为我们的游戏屏幕提供视觉改进？我们可以使用漂亮的浅绿色草地背景，而不仅仅是黑色吗？
- en: Q2) How about some nice flowers?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Q2）怎么样一些漂亮的花？
- en: Q3) If you're feeling brave, make the flowers sway. Think about what we have
    learned about sprite sheets. The theory is exactly the same as that of the animated
    snake head. We just need a few lines of code to control the frame rate separately
    from the game frame rate.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Q3）如果你感到勇敢，让花朵摇曳。想想我们对精灵表学到的东西。理论上与动画蛇头的理论完全相同。我们只需要几行代码来控制帧速率，与游戏帧速率分开。
- en: Q4) We could set up another counter and use our snake head animation in `GameActivity`,
    but it wouldn't be that useful because the subtle tongue movements would be barely
    visible at the smaller size. But could we swish the tail segment?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Q4) 我们可以设置另一个计数器，并在 `GameActivity` 中使用我们的蛇头动画，但这并不是很有用，因为在较小的尺寸下，细微的舌头运动几乎不可见。但我们能摆动尾部吗？
- en: Q5) Here is a slightly trickier enhancement. You can't help notice that when
    the snake sprites are headed in three out of the four possible directions, they
    don't look right. Can you fix this?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Q5) 这是一个稍微棘手的增强。你会注意到，当蛇精灵朝着四个可能的方向中的三个时，它们看起来不对劲。你能修复这个问题吗？
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This is the end of yet another successful game project. You now know how to
    create and animate sprite sheets to add more realism to our games. Now we have
    an enhanced *Snake* game.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是又一个成功的游戏项目的结束。现在你知道如何创建和动画精灵表，以增加我们游戏的逼真感。现在我们有了一个增强版的 *Snake* 游戏。
- en: In the next chapter, we will see how simple it is to add leaderboards and achievements.
    This will make our game social and compelling by letting the player see the high
    scores and achievements of their friends and compare them with their own.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到添加排行榜和成就是多么简单。这将使我们的游戏变得社交化和引人入胜，让玩家看到他们朋友的高分和成就，并将其与自己的进行比较。
