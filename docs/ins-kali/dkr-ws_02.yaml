- en: 2\. Getting Started with Dockerfiles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 使用Dockerfile入门
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will study the form and function of a `Dockerfile` and
    its directives, including `FROM`, `LABEL`, and `CMD`, with which you will dockerize
    an application. The chapter will provide you with knowledge of the layered filesystem
    of Docker images and the use of caching during the Docker build process. By the
    end of this chapter, you will be able to write a `Dockerfile` using the common
    directives and build custom Docker images with the `Dockerfile`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习`Dockerfile`及其指令的形式和功能，包括`FROM`、`LABEL`和`CMD`，您将使用这些指令来dockerize一个应用程序。本章将为您提供关于Docker镜像的分层文件系统和在Docker构建过程中使用缓存的知识。在本章结束时，您将能够使用常见指令编写`Dockerfile`并使用`Dockerfile`构建自定义Docker镜像。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned how to run our first Docker container by
    pulling a pre-built Docker image from the Docker Hub. While it is useful to get
    pre-built Docker images from Docker Hub, we must know how to create custom Docker
    images. This is important for running our applications on Docker by installing
    new packages and customizing the settings of the pre-built Docker images. In this
    chapter, we are going to learn how to create our custom Docker image and run a
    Docker container based on it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何通过从Docker Hub拉取预构建的Docker镜像来运行我们的第一个Docker容器。虽然从Docker Hub获取预构建的Docker镜像很有用，但我们必须知道如何创建自定义Docker镜像。这对于通过安装新软件包和自定义预构建Docker镜像的设置来在Docker上运行我们的应用程序非常重要。在本章中，我们将学习如何创建自定义Docker镜像并基于它运行Docker容器。
- en: This will be done using a text file called a `Dockerfile`. This file consists
    of commands that can be executed by Docker to create a Docker image. Docker images
    are created from a `Dockerfile` using the `docker build` (or `docker image build`)
    command.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用一个名为`Dockerfile`的文本文件完成。该文件包含Docker可以执行以创建Docker镜像的命令。使用`docker build`（或`docker
    image build`）命令从`Dockerfile`创建Docker镜像。
- en: Note
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Beginning with Docker 1.13, the **Docker CLI** syntax has been restructured
    to the form of Docker **COMMAND SUBCOMMAND**. For example, the `docker build`
    command was replaced by the `docker image build` command. This restructuring was
    carried out to clean up the Docker CLI syntax and gain a more consistent grouping
    of commands. Currently, both syntaxes are supported, but the old syntax is expected
    to be deprecated in the future.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从Docker 1.13开始，Docker CLI的语法已重构为Docker COMMAND SUBCOMMAND的形式。例如，`docker build`命令被替换为`docker
    image build`命令。此重构是为了清理Docker CLI语法并获得更一致的命令分组。目前，两种语法都受支持，但预计将来会弃用旧语法。
- en: A Docker image consists of multiple layers, each layer representing the commands
    provided in the `Dockerfile`. These read-only layers are stacked on top of one
    another to create the final Docker image. Docker images can be stored in a Docker
    **registry**, such as **Docker Hub**, which is a place where you can store and
    distribute Docker images.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像由多个层组成，每个层代表`Dockerfile`中提供的命令。这些只读层叠加在一起，以创建最终的Docker镜像。Docker镜像可以存储在Docker注册表（如Docker
    Hub）中，这是一个可以存储和分发Docker镜像的地方。
- en: 'A Docker **container** is a running instance of the Docker image. One or more
    Docker containers can be created from a single Docker image using the `docker
    run` (or `docker container run`) command. Once a Docker container is created from
    the Docker image, a new writeable layer will be added on top of the read-only
    layers from the Docker image. Docker containers can then be listed with the docker
    ps (or docker container list) command:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Docker **容器**是Docker镜像的运行实例。可以使用`docker run`（或`docker container run`）命令从单个Docker镜像创建一个或多个Docker容器。一旦从Docker镜像创建了Docker容器，将在Docker镜像的只读层之上添加一个新的可写层。然后可以使用docker
    ps（或docker container list）命令列出Docker容器：
- en: '![Figure 2.1: Image layers and a container layer'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1：图像层和容器层'
- en: '](image/B15021_02_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_01.jpg)'
- en: 'Figure 2.1: Image layers and a container layer'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：图像层和容器层
- en: As illustrated in the preceding diagram, there can be one or more read-only
    layers that make up the Docker image. These read-only layers are generated for
    each command in the `Dockerfile` during the Docker image build process. Once a
    Docker container is created from the image, a new read-write layer (known as the
    **Container layer**) will be added on top of the image layers and will host all
    the changes made on the running container.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Docker镜像可以由一个或多个只读层组成。这些只读层是在`Dockerfile`中的每个命令在Docker镜像构建过程中生成的。一旦从镜像创建了Docker容器，新的可写层（称为**容器层**）将被添加到镜像层之上，并将承载在运行容器上所做的所有更改。
- en: In this chapter, we will write our first `Dockerfile`, build the Docker image
    from the `Dockerfile`, and run a Docker container from our custom Docker image.
    Before we can perform any of these tasks, however, we must first define a `Dockerfile`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写我们的第一个`Dockerfile`，从`Dockerfile`构建Docker镜像，并从我们的自定义Docker镜像运行Docker容器。然而，在执行任何这些任务之前，我们必须首先定义一个`Dockerfile`。
- en: What Is a Dockerfile?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Dockerfile？
- en: A `Dockerfile` is a text file that contains instructions on how to create a
    Docker image. These commands are known as **directives**. A `Dockerfile` is a
    mechanism that we use to create a custom Docker image as per our requirements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`是一个文本文件，包含了创建Docker镜像的指令。这些命令称为**指令**。`Dockerfile`是我们根据需求创建自定义Docker镜像的机制。'
- en: 'The format of a `Dockerfile` is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`的格式如下：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A `Dockerfile` can contain multiple lines of comments and directives. These
    lines will be executed in order by the **Docker Engine** while building the Docker
    image. Like programming languages, a `Dockerfile` can also contain comments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`可以包含多行注释和指令。这些行将由**Docker引擎**按顺序执行，同时构建Docker镜像。与编程语言一样，`Dockerfile`也可以包含注释。'
- en: 'All statements starting with the # symbol will be treated as a comment. Currently,
    `Dockerfiles` only support single-line comments. If you wish you write a multi-line
    comment, you need to add the # symbol at the beginning of each line.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以#符号开头的语句将被视为注释。目前，`Dockerfiles`只支持单行注释。如果您希望编写多行注释，您需要在每行开头添加#符号。
- en: However, unlike most programming languages, instructions within the `Dockerfile`
    are not case-sensitive. Even though the `DIRECTIVE` is case-insensitive, it is
    a best practice to write all directives in uppercase to distinguish them from
    arguments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与大多数编程语言不同，`Dockerfile`中的指令不区分大小写。即使`DIRECTIVE`不区分大小写，最好将所有指令都以大写形式编写，以便与参数区分开来。
- en: In the next section, we will discuss the common directives that we can use in
    `Dockerfiles` to create a custom Docker image.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论在`Dockerfiles`中可以使用的常见指令，以创建自定义Docker镜像。
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using ubuntu versions later than 18.04, there will be a prompt to
    enter time zone. Please suppress the prompt with `ARG DEBIAN_FRONTEND=non_interactive`
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是18.04之后的ubuntu版本，将会提示输入时区。请使用`ARG DEBIAN_FRONTEND=non_interactive`来抑制提示
- en: Common Directives in Dockerfiles
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile中的常见指令
- en: 'As discussed in the previous section, a directive is a command that is used
    to create a Docker image. In this section, we will be discussing the following
    five `Dockerfile` directives:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所讨论的，指令是用于创建Docker镜像的命令。在本节中，我们将讨论以下五个`Dockerfile`指令：
- en: The `FROM` directive
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FROM`指令'
- en: The `LABEL` directive
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LABEL`指令'
- en: The `RUN` directive
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RUN`指令'
- en: The `CMD` directive
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMD`指令'
- en: The `ENTRYPOINT` directive
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`指令'
- en: The FROM Directive
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`FROM`指令'
- en: A `Dockerfile` usually starts with the `FROM` directive. This is used to specify
    the parent image of our custom Docker image. The parent image is the starting
    point of our custom Docker image. All the customization that we do will be applied
    on top of the parent image. The parent image can be an image from Docker Hub,
    such as Ubuntu, CentOS, Nginx, and MySQL. The `FROM` directive takes a valid image
    name and a tag as arguments. If the tag is not specified, the `latest` tag will
    be used.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`通常以`FROM`指令开头。这用于指定我们自定义Docker镜像的父镜像。父镜像是我们自定义Docker镜像的起点。我们所做的所有自定义将应用在父镜像之上。父镜像可以是来自Docker
    Hub的镜像，如Ubuntu、CentOS、Nginx和MySQL。`FROM`指令接受有效的镜像名称和标签作为参数。如果未指定标签，将使用`latest`标签。'
- en: 'A FROM directive has the following format:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`指令的格式如下：'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the following `FROM` directive, we are using the `ubuntu` parent image with
    the `20.04` tag:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下`FROM`指令中，我们使用带有`20.04`标签的`ubuntu`父镜像：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Additionally, we can use the base image if we need to build a Docker image from
    scratch. The base image, known as the scratch image, is an empty image mostly
    used to build other parent images.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果需要从头开始构建Docker镜像，我们可以使用基础镜像。基础镜像，即scratch镜像，是一个空镜像，主要用于构建其他父镜像。
- en: 'In the following `FROM` directive, we are using the `scratch` image to build
    our custom Docker image from scratch:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下`FROM`指令中，我们使用`scratch`镜像从头开始构建我们的自定义Docker镜像：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let's understand what a `LABEL` directive is in the next section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一节中了解`LABEL`指令是什么。
- en: The LABEL Directive
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`LABEL`指令'
- en: A `LABEL` is a key-value pair that can be used to add metadata to a Docker image.
    These labels can be used to organize the Docker images properly. An example would
    be to add the name of the author of the `Dockerfile` or the version of the `Dockerfile`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`LABEL`是一个键值对，可用于向Docker镜像添加元数据。这些标签可用于适当地组织Docker镜像。例如，可以添加`Dockerfile`的作者姓名或`Dockerfile`的版本。'
- en: 'A `LABEL` directive has the following format:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`LABEL`指令的格式如下：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A `Dockerfile` can have multiple labels, adhering to the preceding key-value
    format:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`可以有多个标签，遵循前面的键值对格式：'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or these labels can be included on a single line separated by spaces:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这些标签可以在单行上用空格分隔包含：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Labels on an existing Docker image can be viewed with the `docker image inspect`
    command.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的Docker镜像标签可以使用`docker image inspect`命令查看。
- en: 'The output should be like the following on running the `docker image inspect
    <image>:<tag>` command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker image inspect <image>:<tag>`命令时，输出应该如下所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As shown here, the docker image inspect command will output the key-value pairs
    configured in the `Dockerfile` using the `LABEL` directive.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，docker image inspect命令将输出使用`LABEL`指令在`Dockerfile`中配置的键值对。
- en: In the next section, we will learn how to execute commands during the image
    build time using the `RUN` directive.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用`RUN`指令在构建镜像时执行命令。
- en: The RUN Directive
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`RUN`指令'
- en: The `RUN` directive is used to execute commands during the image build time.
    This will create a new layer on top of the existing layer, execute the specified
    command, and commit the results to the newly created layer. The `RUN` directive
    can be used to install the required packages, update the packages, create users
    and groups, and so on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令用于在图像构建时执行命令。这将在现有层的顶部创建一个新层，执行指定的命令，并将结果提交到新创建的层。`RUN`指令可用于安装所需的软件包，更新软件包，创建用户和组等。'
- en: 'The `RUN` directive takes the following format:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令的格式如下：'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`<command>` specifies the shell command you want to execute as part of the
    image build process. A `Dockerfile` can have multiple `RUN` directives adhering
    to the preceding format.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`<command>`指定您希望作为图像构建过程的一部分执行的shell命令。一个`Dockerfile`可以有多个`RUN`指令，遵循上述格式。'
- en: 'In the following example, we are running two commands on top of the parent
    image. The `apt-get update` is used to update the package repositories, and `apt-get
    install nginx -y` is used to install the Nginx package:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们在父镜像的基础上运行了两个命令。`apt-get update`用于更新软件包存储库，`apt-get install nginx -y`用于安装Nginx软件包：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, you can add multiple shell commands to a single `RUN` directive
    by separating them with the `&&` symbol. In the following example, we have used
    the same two commands, but this time in a single `RUN` directive, separated by
    an `&&` symbol:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过使用`&&`符号将多个shell命令添加到单个`RUN`指令中。在以下示例中，我们使用了相同的两个命令，但这次是在单个`RUN`指令中，用`&&`符号分隔：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let's move on to the next section where we will learn about the `CMD` directive.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一节，我们将学习`CMD`指令。
- en: The CMD Directive
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMD指令
- en: A Docker container is normally expected to run one process. A `CMD` directive
    is used to provide this default initialization command that will be executed when
    a container is created from the Docker image. A `Dockerfile` can execute only
    one `CMD` directive. If there is more than one `CMD` directive in the `Dockerfile`,
    Docker will execute only the last one.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器通常预期运行一个进程。`CMD`指令用于提供默认的初始化命令，当从Docker镜像创建容器时将执行该命令。`Dockerfile`只能执行一个`CMD`指令。如果`Dockerfile`中有多个`CMD`指令，Docker将只执行最后一个。
- en: 'The `CMD` directive has the following format:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`指令的格式如下：'
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For example, use the following command to echo "`Hello World`" as the output
    of a Docker container:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用以下命令将"`Hello World`"作为Docker容器的输出：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding `CMD` directive will produce the following output when we run
    the Docker container with the `docker container run <image>` command (replace
    `<image>` with the name of the Docker image):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`docker container run <image>`命令（用Docker镜像的名称替换`<image>`）运行Docker容器时，上述`CMD`指令将产生以下输出：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, if we send any command-line arguments with `docker container run <image>`,
    these arguments will take precedence over the `CMD` command that we defined. For
    example, if we execute the following command (replace `<image>` with the name
    of the Docker image), the default "`Hello World`" output defined with the `CMD`
    directive will be ignored. Instead, the container will output "`Hello Docker !!!`":'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用`docker container run <image>`命令行参数，这些参数将覆盖我们定义的`CMD`指令。例如，如果我们执行以下命令（用Docker镜像的名称替换`<image>`），则会忽略使用`CMD`指令定义的默认的"`Hello
    World`"输出。相反，容器将输出"`Hello Docker !!!`"：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we discussed, both the `RUN` and `CMD` directives can be used to execute
    a shell command. The main difference between these two directives is that the
    command provided with the `RUN` directive will be executed during the image build
    process, while the command provided with the `CMD` directive will be executed
    once a container is launched from the built image.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，`RUN`和`CMD`指令都可以用来执行shell命令。这两个指令之间的主要区别在于，`RUN`指令提供的命令将在镜像构建过程中执行，而`CMD`指令提供的命令将在从构建的镜像启动容器时执行。
- en: Another notable difference between the `RUN` and `CMD` directives is that there
    can be multiple `RUN` directives in a `Dockerfile`, but there can be only one
    `CMD` directive (if there are multiple `CMD` directives, all others except the
    last one will be ignored).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`和`CMD`指令之间的另一个显着区别是，在`Dockerfile`中可以有多个`RUN`指令，但只能有一个`CMD`指令（如果有多个`CMD`指令，则除最后一个之外的所有其他指令都将被忽略）。'
- en: As an example, we can use the `RUN` directive to install a software package
    during the Docker image build process and the `CMD` directive to start the software
    package once a container is launched from the built image.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`RUN`指令在Docker镜像构建过程中安装软件包，并使用`CMD`指令在从构建的镜像启动容器时启动软件包。
- en: In the next section, we will learn about the `ENTRYPOINT` directive, which provides
    the same functionality as the `CMD` directive, except for overriding.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习`ENTRYPOINT`指令，它提供了与`CMD`指令相同的功能，除了覆盖。
- en: The ENTRYPOINT Directive
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ENTRYPOINT指令
- en: Similar to the `CMD` directive, the `ENTRYPOINT` directive is also used to provide
    this default initialization command that will be executed when a container is
    created from the Docker image. The difference between the `CMD` directive and
    the `ENTRYPOINT` directive is that, unlike the `CMD` directive, we cannot override
    the `ENTRYPOINT` command using the command-line parameters sent with the `docker
    container run` command.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与`CMD`指令类似，`ENTRYPOINT`指令也用于提供默认的初始化命令，该命令将在从Docker镜像创建容器时执行。`CMD`指令和`ENTRYPOINT`指令之间的区别在于，与`CMD`指令不同，我们不能使用`docker
    container run`命令发送的命令行参数来覆盖`ENTRYPOINT`命令。
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `--entrypoint` flag can be sent with the `docker container run` command
    to override the default `ENTRYPOINT` of the image.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`--entrypoint`标志可以与`docker container run`命令一起发送，以覆盖镜像的默认`ENTRYPOINT`。'
- en: 'The `ENTRYPOINT` directive has the following format:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`指令的格式如下：'
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Similar to the `CMD` directive, the `ENTRYPOINT` directive also allows us to
    provide the default executable and the parameters. We can use the `CMD` directive
    with the `ENTRYPOINT` directive to provide additional arguments to the executable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与`CMD`指令类似，`ENTRYPOINT`指令也允许我们提供默认的可执行文件和参数。我们可以在`ENTRYPOINT`指令中使用`CMD`指令来为可执行文件提供额外的参数。
- en: 'In the following example, we have used `"echo"` as the default command and
    `"Hello"` as the default parameter using the `ENTRYPOINT` directive. We have also
    provided `"World"` as the additional parameter using the `CMD` directive:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用`ENTRYPOINT`指令将`"echo"`作为默认命令，将`"Hello"`作为默认参数。我们还使用`CMD`指令提供了`"World"`作为额外的参数：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The output of the `echo` command will differ based on how we execute the `docker
    container run` command.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`命令的输出将根据我们如何执行`docker container run`命令而有所不同。'
- en: 'If we launch the Docker image without any command-line parameters, it will
    output the message as `Hello World`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动Docker镜像而没有任何命令行参数，它将输出消息`Hello World`：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'But if we launch the Docker image with additional command-line parameters (for
    example, `Docker`), the output message will be `Hello Docker`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们使用额外的命令行参数（例如`Docker`）启动Docker镜像，输出消息将是`Hello Docker`：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Before discussing the `Dockerfile` directives any further, let's start by creating
    our first `Dockerfile` in the next exercise.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步讨论`Dockerfile`指令之前，让我们从下一个练习开始创建我们的第一个`Dockerfile`。
- en: 'Exercise 2.01: Creating Our First Dockerfile'
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.01：创建我们的第一个Dockerfile
- en: 'In this exercise, you will create a Docker image that can print the arguments
    you pass to the Docker image, preceded by the text `You are reading`. For example,
    if you pass `hello world`, it will output `You are reading hello world` as the
    output. If no argument is provided, `The Docker Workshop` will be used as the
    standard value:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个Docker镜像，可以打印您传递给Docker镜像的参数，前面加上文本`You are reading`。例如，如果您传递`hello
    world`，它将输出`You are reading hello world`。如果没有提供参数，则将使用`The Docker Workshop`作为标准值：
- en: 'Create a new directory named `custom-docker-image` using the `mkdir` command.
    This directory will be the **context** for your Docker image. `Context` is the
    directory that contains all the files needed to successfully build an image:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mkdir`命令创建一个名为`custom-docker-image`的新目录。该目录将是您的Docker镜像的**上下文**。`上下文`是包含成功构建镜像所需的所有文件的目录：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Navigate to the newly created `custom-docker-image` directory using the `cd`
    command as we will be creating all the files required during the build process
    (including the `Dockerfile`) within this directory:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd`命令导航到新创建的`custom-docker-image`目录，因为我们将在此目录中创建构建过程中所需的所有文件（包括`Dockerfile`）：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Within the `custom-docker-image` directory, create a file named `Dockerfile`
    using the `touch` command:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`custom-docker-image`目录中，使用`touch`命令创建一个名为`Dockerfile`的文件：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, open the `Dockerfile` using your favorite text editor:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`Dockerfile`：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following content to the `Dockerfile`, save it, and exit from the `Dockerfile`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`Dockerfile`中，保存并退出`Dockerfile`：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Docker image will be based on the Ubuntu parent image. You then use the
    `LABEL` directive to provide the email address of the author of the `Dockerfile`.
    The next line executes the `apt-get update` command to update the package list
    of Debian to the latest available version. Finally, you will use the `ENTRYPOINT`
    and `CMD` directives to define the default executable and parameters of the container.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像将基于Ubuntu父镜像。然后，您可以使用`LABEL`指令提供`Dockerfile`作者的电子邮件地址。接下来的一行执行`apt-get
    update`命令，将Debian的软件包列表更新到最新可用版本。最后，您将使用`ENTRYPOINT`和`CMD`指令来定义容器的默认可执行文件和参数。
- en: We have provided `echo` as the default executable and `You are reading` as the
    default parameter that cannot be overridden with command-line parameters. Also,
    we have provided `The Docker Workshop` as an additional parameter that can be
    overridden with command-line parameters with a `docker container run` command.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提供了`echo`作为默认可执行文件，`You are reading`作为默认参数，不能使用命令行参数进行覆盖。此外，我们还提供了`The Docker
    Workshop`作为一个额外的参数，可以使用`docker container run`命令的命令行参数进行覆盖。
- en: In this exercise, we created our first `Dockerfile` using the common directives
    that we learned in the previous sections. The next step of the process is to build
    the Docker image from the `Dockerfile`. You can only run a Docker container after
    building the Docker image from the `Dockerfile`. In the next section, we are going
    to look at how to build a Docker image from the `Dockerfile`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了在前几节中学到的常见指令创建了我们的第一个`Dockerfile`。该过程的下一步是从`Dockerfile`构建Docker镜像。只有在从`Dockerfile`构建Docker镜像之后，才能运行Docker容器。在下一节中，我们将看看如何从`Dockerfile`构建Docker镜像。
- en: Building Docker Images
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Docker镜像
- en: In the last section, we learned how to create a `Dockerfile`. The next step
    of the process is to build a **Docker image** using the `Dockerfile`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何创建`Dockerfile`。该过程的下一步是使用`Dockerfile`构建**Docker镜像**。
- en: A **Docker image** is the template used to build Docker containers. This is
    analogous to how a house plan can be used to create multiple houses from the same
    design. If you are familiar with **object-oriented programming** concepts, a Docker
    image and a Docker container have the same relationship as a **class** and an
    **object**. A class in object-oriented programming can be used to create multiple
    objects.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker镜像**是用于构建Docker容器的模板。这类似于如何可以使用房屋平面图从相同的设计中创建多个房屋。如果您熟悉**面向对象编程**的概念，Docker镜像和Docker容器的关系与**类**和**对象**的关系相同。面向对象编程中的类可用于创建多个对象。'
- en: 'A Docker image is a binary file consisting of multiple layers based on the
    instructions provided in the `Dockerfile`. These layers are stacked on top of
    one another, and each layer is dependent on the previous layer. Each of the layers
    is a result of the changes from the layer below it. All the layers of the Docker
    image are read-only. Once we create a Docker container from a Docker image, a
    new writable layer will be created on top of other read-only layers, which will
    contain all the modifications made to the container filesystem:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像是一个二进制文件，由`Dockerfile`中提供的多个层组成。这些层堆叠在彼此之上，每个层依赖于前一个层。每个层都是基于其下一层的更改而生成的。Docker镜像的所有层都是只读的。一旦我们从Docker镜像创建一个Docker容器，将在其他只读层之上创建一个新的可写层，其中包含对容器文件系统所做的所有修改：
- en: '![Figure 2.2: Docker image layers'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2：Docker镜像层'
- en: '](image/B15021_02_02.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_02.jpg)'
- en: 'Figure 2.2: Docker image layers'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：Docker镜像层
- en: As illustrated in the preceding image, the docker image build command will create
    a Docker image from the `Dockerfile`. The layers of the Docker image will be mapped
    to the directives provided in the `Dockerfile`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，docker image build命令将从`Dockerfile`创建一个Docker镜像。Docker镜像的层将映射到`Dockerfile`中提供的指令。
- en: This image build process is initiated by the Docker CLI and executed by the
    Docker daemon. To generate a Docker image, the Docker daemon needs access to the
    `Dockerfile`, source code (for example, `index.html`), and other files (for example,
    properties files) that are referenced in the `Dockerfile`. These files are typically
    stored in a directory that is known as the build context. This context will be
    specified while executing the docker image build command. The entire context will
    be sent to the Docker daemon during the image build process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图像构建过程是由Docker CLI发起并由Docker守护程序执行的。要生成Docker镜像，Docker守护程序需要访问`Dockerfile`，源代码（例如`index.html`）和其他文件（例如属性文件），这些文件在`Dockerfile`中被引用。这些文件通常存储在一个被称为构建上下文的目录中。在执行docker
    image build命令时将指定此上下文。整个上下文将在图像构建过程中发送到Docker守护程序。
- en: 'The `docker image build` command takes the following format:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image build`命令采用以下格式：'
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can execute the docker image build command from the folder that contains
    the `Dockerfile` and the other files, as shown in the following example. Note
    that the dot (`.`) at the end of the command is used to denote the current directory:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从包含`Dockerfile`和其他文件的文件夹中执行docker image build命令，如下例所示。请注意，命令末尾的点（`.`）用于表示当前目录：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s see the Docker image build process for the following sample `Dockerfile`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例`Dockerfile`的Docker镜像构建过程：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This `Dockerfile` uses the latest `ubuntu` images as the parent image. Then,
    the `LABEL` directive is used to specify `sathsara@mydomain.com` as the maintainer.
    Finally, the `CMD` directive is used to echo `"Hello World"` as the output of
    the image.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Dockerfile`使用最新的`ubuntu`镜像作为父镜像。然后，使用`LABEL`指令将`sathsara@mydomain.com`指定为维护者。最后，使用`CMD`指令将echo`"Hello
    World"`用作图像的输出。
- en: 'Once we execute the docker image build command for the preceding `Dockerfile`,
    we can see an output similar to the following on the console during the build
    process:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述`Dockerfile`的docker镜像构建命令后，我们可以在构建过程中的控制台上看到类似以下的输出：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first line of the output is `Sending build context to Docker daemon`, which
    indicates that the building starts by sending the build context to the Docker
    daemon. All the files available in the context will be sent recursively to the
    Docker daemon (unless specifically asked to ignore certain files).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行是`Sending build context to Docker daemon`，这表明构建开始时将构建上下文发送到Docker守护程序。上下文中的所有文件将被递归地发送到Docker守护程序（除非明确要求忽略某些文件）。
- en: Next, there are steps mentioned as `Step 1/3` and `Step 2/3`, which correspond
    to the instructions in the `Dockerfile`. As the first step, the Docker daemon
    will download the parent image. In the preceding output shown, Pulling from library/ubuntu
    indicates this. For each line of the `Dockerfile`, a new intermediate container
    will be created to execute the directive, and once this step is completed, this
    intermediate container will be removed. The lines `Running in a4a11e5e7c27` and
    `Removing intermediate container a4a11e5e7c27` are used to indicate this. Finally,
    the `Successfully built dc3d4fd77861` line is printed when the build is completed
    without any errors. This line prints the ID of the newly built Docker image.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有`Step 1/3`和`Step 2/3`的步骤，对应于`Dockerfile`中的指令。作为第一步，Docker守护程序将下载父镜像。在上述输出中，从library/ubuntu拉取表示这一点。对于`Dockerfile`的每一行，都会创建一个新的中间容器来执行指令，一旦这一步完成，这个中间容器将被移除。`Running
    in a4a11e5e7c27`和`Removing intermediate container a4a11e5e7c27`这两行用于表示这一点。最后，当构建完成且没有错误时，将打印出`Successfully
    built dc3d4fd77861`这一行。这行打印出了新构建的Docker镜像的ID。
- en: 'Now, we can list the available Docker images using the `docker image list` command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`docker image list`命令列出可用的Docker镜像：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This list contains the locally built Docker images and Docker images pulled
    from remote Docker repositories:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表包含了本地构建的Docker镜像和从远程Docker仓库拉取的Docker镜像：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As shown in the preceding output, we can see two Docker images. The first Docker
    image with the IMAGE ID of `dc3d4fd77861` is the locally built Docker image during
    the build process. We can see that this `IMAGE ID` is identical to the ID in the
    last line of the `docker image build` command. The next image is the ubuntu image
    that we used as the parent image of our custom image.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如上述输出所示，我们可以看到两个Docker镜像。第一个Docker镜像的IMAGE ID是`dc3d4fd77861`，是在构建过程中本地构建的Docker镜像。我们可以看到，这个`IMAGE
    ID`与`docker image build`命令的最后一行中的ID是相同的。下一个镜像是我们用作自定义镜像的父镜像的ubuntu镜像。
- en: 'Now, let''s build the Docker image again using the `docker image build` command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次使用`docker image build`命令构建Docker镜像：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This time, the image build process was instantaneous. The reason for this is
    the cache. Since we did not change any content of the `Dockerfile`, the Docker
    daemon took advantage of the cache and reused the existing layers from the local
    image cache to accelerate the build process. We can see that the cache was used
    this time with the `Using cache` lines available in the preceding output.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，镜像构建过程是瞬时的。这是因为缓存。由于我们没有改变`Dockerfile`的任何内容，Docker守护程序利用了缓存，并重用了本地镜像缓存中的现有层来加速构建过程。我们可以在上述输出中看到，这次使用了缓存，有`Using
    cache`行可用。
- en: 'The Docker daemon will perform a validation step before starting the build
    process to make sure that the `Dockerfile` provided is syntactically correct.
    In the case of an invalid syntax, the build process will fail with an error message
    from the Docker daemon:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Docker守护程序将在启动构建过程之前执行验证步骤，以确保提供的`Dockerfile`在语法上是正确的。在语法无效的情况下，构建过程将失败，并显示来自Docker守护程序的错误消息：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s revisit the locally available Docker images with the `docker image
    list` command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`docker image list`命令重新查看本地可用的Docker镜像：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The command should return the following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应返回以下输出：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that there was no name for our custom Docker image. This was because we
    did not specify any repository or tag during the build process. We can tag an
    existing image with the docker image tag command.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的自定义Docker镜像没有名称。这是因为我们在构建过程中没有指定任何存储库或标签。我们可以使用docker image tag命令为现有镜像打标签。
- en: 'Let''s tag our image with `IMAGE ID dc3d4fd77861` as `my-tagged-image:v1.0`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`IMAGE ID dc3d4fd77861`作为`my-tagged-image:v1.0`来为我们的镜像打标签：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, if we list our images again, we can see the Docker image name and the
    tag under the `REPOSITORY` and `TAG` columns:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次列出我们的镜像，我们可以看到`REPOSITORY`和`TAG`列下的Docker镜像名称和标签：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can also tag an image during the build process by specifying the `-t` flag:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过指定`-t`标志在构建过程中为镜像打标签：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding command will print the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将打印以下输出：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This time, in addition to the `Successfully built dc3d4fd77861` line, we can
    see a `Successfully tagged my-tagged-image:v2.0` line, which indicates the tagging
    on our Docker image.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，除了`成功构建dc3d4fd77861`行之外，我们还可以看到`成功标记my-tagged-image:v2.0`行，这表明我们的Docker镜像已经打了标签。
- en: In this section, we learned how to build a Docker image from a `Dockerfile`.
    We discussed the difference between a `Dockerfile` and a Docker image. Then, we
    discussed how a Docker image is made up of multiple layers. We also experienced
    how caching can accelerate the build process. Finally, we tagged the Docker images.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何从`Dockerfile`构建Docker镜像。我们讨论了`Dockerfile`和Docker镜像之间的区别。然后，我们讨论了Docker镜像由多个层组成。我们还体验了缓存如何加速构建过程。最后，我们为Docker镜像打了标签。
- en: 'In the next exercise, we are going to build a Docker image from the `Dockerfile`
    that we created in *Exercise 2.01: Creating Our First Dockerfile*.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将从*练习2.01：创建我们的第一个Dockerfile*中创建的`Dockerfile`构建Docker镜像。
- en: 'Exercise 2.02: Creating Our First Docker Image'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.02：创建我们的第一个Docker镜像
- en: 'In this exercise, you will build the Docker image from the `Dockerfile` that
    you created in *Exercise 2.01:* *Creating Our First Dockerfile* and run a Docker
    container from the newly built image. First, you will run the Docker image without
    passing any arguments, expecting You are reading The Docker Workshop as the output.
    Next, you will run the Docker image with `Docker Beginner''s Guide` as the argument
    and expect You are reading Docker Beginner''s Guide as the output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将从*练习2.01：创建我们的第一个Dockerfile*中创建的`Dockerfile`构建Docker镜像，并从新构建的镜像运行Docker容器。首先，您将在不传递任何参数的情况下运行Docker镜像，期望输出为“您正在阅读Docker
    Workshop”。接下来，您将以`Docker Beginner's Guide`作为参数运行Docker镜像，并期望输出为“您正在阅读Docker Beginner's
    Guide”：
- en: 'First, make sure you are in the `custom-docker-image` directory created in
    *Exercise 2.01:* *Creating Our First Dockerfile*. Confirm that the directory contains
    the following `Dockerfile` created in *Exercise 2.01:* *Creating Our First Dockerfile*:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，请确保您在*练习2.01：创建我们的第一个Dockerfile*中创建的`custom-docker-image`目录中。确认该目录包含在*练习2.01：创建我们的第一个Dockerfile*中创建的以下`Dockerfile`：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Build the Docker image with the `docker image build` command. This command
    has the optional `-t` flag to specify the tag of the image. Tag your image as
    `welcome:1.0`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker image build`命令构建Docker镜像。此命令具有可选的`-t`标志，用于指定镜像的标签。将您的镜像标记为`welcome:1.0`：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Do not forget the dot (`.`) at the end of the preceding command, which is used
    to denote the current directory as the build context.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在前述命令的末尾加上点(`.`)，用于将当前目录作为构建上下文。
- en: 'It can be seen from the following output that all five steps mentioned in the
    `Dockerfile` are executed during the build process. The last two lines of the
    output suggest that the image is successfully built and tagged:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从以下输出中看到，在构建过程中执行了`Dockerfile`中提到的所有五个步骤。输出的最后两行表明成功构建并打了标签的镜像：
- en: '![Figure 2.3: Building the welcome:1.0 Docker image'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3：构建welcome:1.0 Docker镜像'
- en: '](image/B15021_02_03.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_03.jpg)'
- en: 'Figure 2.3: Building the welcome:1.0 Docker image'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：构建welcome:1.0 Docker镜像
- en: 'Build this image again without changing the `Dockerfile` content:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次构建此镜像，而不更改`Dockerfile`内容：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that this build process completed much quicker than the previous process
    due to the cache being used:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于使用了缓存，此构建过程比以前的过程快得多：
- en: '![Figure 2.4: Building the welcome:1.0 Docker image using the cache'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4：使用缓存构建welcome:1.0 Docker镜像'
- en: '](image/B15021_02_04.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_04.jpg)'
- en: 'Figure 2.4: Building the welcome:1.0 Docker image using the cache'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：使用缓存构建welcome:1.0 Docker镜像
- en: 'Use the `docker image list` command to list all the Docker images available
    on your computer:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker image list`命令列出计算机上所有可用的Docker镜像：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'These images are available on your computer, either when you pull them from
    a Docker registry, or when you build on your computer:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些镜像可以在您的计算机上使用，无论是从Docker注册表中拉取还是在您的计算机上构建：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see from the preceding output, there are three Docker images available.
    The `ubuntu` image is pulled from the Docker Hub, and version (`tag`) `1.0` and
    `2.0` of the `welcome` images are built on your computer.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从前述输出中可以看出，有三个Docker镜像可用。`ubuntu`镜像是从Docker Hub拉取的，`welcome`镜像的`1.0`和`2.0`版本是在您的计算机上构建的。
- en: 'Execute the `docker container run` command to start a new container from the
    Docker image that you built in `step 1` (`welcome:1.0`):'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`docker container run`命令，从您在`步骤1`中构建的Docker镜像（`welcome:1.0`）启动一个新容器：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output should be as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You receive the expected output of `You are reading The Docker Workshop`. `You
    are reading` is due to the parameter provided with the `ENTRYPOINT` directive,
    and `The Docker Workshop` comes from the parameter provided with the `CMD` directive.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到预期的输出`You are reading The Docker Workshop`。`You are reading`是由`ENTRYPOINT`指令提供的参数引起的，`The
    Docker Workshop`来自`CMD`指令提供的参数。
- en: 'Finally, execute the `docker container run` command again, this time with command-line
    arguments:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，再次执行`docker container run`命令，这次使用命令行参数：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You will get the output `You are reading Docker Beginner''s Guide` because
    of the command-line argument, `Docker Beginner''s Guide`, and the `You are reading`
    argument provided in the `ENTRYPOINT` directive:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命令行参数`Docker初学者指南`和`ENTRYPOINT`指令中提供的`You are reading`参数，您将获得输出`You are reading
    Docker初学者指南`：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this exercise, we learned how to build a custom Docker image using the `Dockerfile`
    and run a Docker container from the image. In the next section, we are going to
    learn other Docker directives that we can use in the `Dockerfile`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用`Dockerfile`构建自定义Docker镜像，并从镜像运行Docker容器。在下一节中，我们将学习可以在`Dockerfile`中使用的其他Docker指令。
- en: Other Dockerfile Directives
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他Dockerfile指令
- en: In the section Common Directives in Dockerfile, we discussed the common directives
    available for a `Dockerfile`. In that section, we discussed `FROM`, `LABEL`, `RUN`,
    `CMD`, and `ENTRYPOINT` directives and how to use them to create a simple `Dockerfile`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dockerfile中的常见指令部分，我们讨论了可用于`Dockerfile`的常见指令。在该部分中，我们讨论了`FROM`、`LABEL`、`RUN`、`CMD`和`ENTRYPOINT`指令以及如何使用它们创建一个简单的`Dockerfile`。
- en: 'In this section, we will be discussing more advanced `Dockerfile` directives.
    These directives can be used to create more advanced Docker images. For example,
    we can use the `VOLUME` directive to bind the filesystem of the host machine to
    a Docker container. This will allow us to persist the data generated and used
    by the Docker container. Another example is the `HEALTHCHECK` directive, which
    allows us to define health checks to evaluate the health status of Docker containers.
    We will look into the following directives in this section:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论更高级的`Dockerfile`指令。这些指令可以用于创建更高级的Docker镜像。例如，我们可以使用`VOLUME`指令将主机机器的文件系统绑定到Docker容器。这将允许我们持久化Docker容器生成和使用的数据。另一个例子是`HEALTHCHECK`指令，它允许我们定义健康检查以评估Docker容器的健康状态。在本节中，我们将研究以下指令：
- en: The `ENV` directive
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ENV`指令'
- en: The `ARG` directive
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ARG`指令'
- en: The `WORKDIR` directive
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WORKDIR`指令'
- en: The `COPY` directive
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`COPY`指令'
- en: The `ADD` directive
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ADD`指令'
- en: The `USER` directive
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USER`指令'
- en: The `VOLUME` directive
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VOLUME`指令'
- en: The `EXPOSE` directive
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EXPOSE`指令'
- en: The `HEALTHCHECK` directive
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HEALTHCHECK`指令'
- en: The `ONBUILD` directive
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ONBUILD`指令'
- en: The ENV Directive
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ENV指令
- en: The ENV directive in `Dockerfile` is used to set environment variables. **Environment
    variables** are used by applications and processes to get information about the
    environment in which a process runs. One example would be the `PATH` environment
    variable, which lists the directories to search for executable files.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`中的ENV指令用于设置环境变量。**环境变量**被应用程序和进程用来获取有关进程运行环境的信息。一个例子是`PATH`环境变量，它列出了要搜索可执行文件的目录。'
- en: 'Environment variables are defined as key-value pairs as per the following format:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量按以下格式定义为键值对：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The PATH environment variable is set with the following value:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: PATH环境变量设置为以下值：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Hence, it can be set using the `ENV` directive as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以使用`ENV`指令设置如下：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can set multiple environment variables in the same line separated by spaces.
    However, in this form, the `key` and `value` should be separated by the equal
    to (`=`) symbol:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在同一行中用空格分隔设置多个环境变量。但是，在这种形式中，`key`和`value`应该由等号（`=`）分隔：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the following example, there are two environment variables configured. The
    `PATH` environment variable is configured with the value of `$PATH:/usr/local/myapp/bin/`,
    and the `VERSION` environment variable is configured with the value of `1.0.0`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，配置了两个环境变量。`PATH`环境变量配置为`$PATH:/usr/local/myapp/bin/`的值，`VERSION`环境变量配置为`1.0.0`的值：
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Once an environment variable is set with the `ENV` directive in the `Dockerfile`,
    this variable is available in all subsequent Docker image layers. This variable
    is even available in the Docker containers launched from this Docker image.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用`Dockerfile`中的`ENV`指令设置了环境变量，该变量就会在所有后续的Docker镜像层中可用。甚至在从此Docker镜像启动的Docker容器中也可用。
- en: In the next section, we will look into the `ARG` directive.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将研究`ARG`指令。
- en: The ARG Directive
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ARG指令
- en: The `ARG` directive is used to define variables that the user can pass at build
    time. `ARG` is the only directive that can precede the `FROM` directive in the
    `Dockerfile`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARG`指令用于定义用户可以在构建时传递的变量。`ARG`是唯一可以在`Dockerfile`中的`FROM`指令之前出现的指令。'
- en: 'Users can pass values using `--build-arg <varname>=<value>`, as shown here,
    while building the Docker image:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在构建Docker镜像时使用`--build-arg <varname>=<value>`传递值，如下所示：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `ARG` directive has the following format:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARG`指令的格式如下：'
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'There can be multiple `ARG` directives in a `Dockerfile`, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`中可以有多个`ARG`指令，如下所示：'
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `ARG` directive can also have an optional default value defined. This default
    value will be used if no value is passed at build time:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARG`指令也可以定义一个可选的默认值。如果在构建时没有传递值，将使用此默认值：'
- en: '[PRE55]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Unlike the `ENV` variables, `ARG` variables are not accessible from the running
    container. They are only available during the build process.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ENV`变量不同，`ARG`变量无法从正在运行的容器中访问。它们仅在构建过程中可用。
- en: In the next exercise, we will use the knowledge gained so far to use `ENV` and
    `ARG` directives in a `Dockerfile`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '在下一个练习中，我们将利用迄今为止所学到的知识，在`Dockerfile`中使用`ENV`和`ARG`指令。 '
- en: 'Exercise 2.03: Using ENV and ARG Directives in a Dockerfile'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.03：在Dockerfile中使用ENV和ARG指令
- en: 'Your manager has asked you to create a `Dockerfile` that will use ubuntu as
    the parent image, but you should be able to change the ubuntu version at build
    time. You will also need to specify the publisher''s name and application directory
    as the environment variables of the Docker image. You will use the `ENV` and `ARG`
    directives in the `Dockerfile` to perform this exercise:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您的经理要求您创建一个`Dockerfile`，该文件将使用ubuntu作为父镜像，但您应该能够在构建时更改ubuntu版本。您还需要指定发布者的名称和Docker镜像的应用程序目录作为环境变量。您将使用`Dockerfile`中的`ENV`和`ARG`指令来执行此练习：
- en: 'Create a new directory named `env-arg-exercise` using the `mkdir` command:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mkdir`命令创建一个名为`env-arg-exercise`的新目录：
- en: '[PRE56]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Navigate to the newly created `env-arg-exercise` directory using the `cd` command:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd`命令导航到新创建的`env-arg-exercise`目录：
- en: '[PRE57]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Within the `env-arg-exercise` directory, create a file named `Dockerfile`:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`env-arg-exercise`目录中，创建一个名为`Dockerfile`的文件：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, open the `Dockerfile` using your favorite text editor:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`Dockerfile`：
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add the following content to the `Dockerfile`. Then, save and exit from the `Dockerfile`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`Dockerfile`中。然后，保存并退出`Dockerfile`：
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This `Dockerfile` first defined an argument named `TAG` with the default value
    of the latest. The next line is the `FROM` directive, which will use the ubuntu
    parent image with the `TAG` variable value sent with the `build` command (or the
    default value if no value is sent with the build command). Then, the `LABEL` directive
    sets the value for the maintainer. Next is the `ENV` directive, which defines
    the environment variable of `PUBLISHER` with the value `packt`, and `APP_DIR`
    with the value of `/usr/local/app/bin`. Finally, use the `CMD` directive to execute
    the `env` command, which will print all the environment variables.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此`Dockerfile`首先定义了一个名为`TAG`的参数，其默认值为最新版本。接下来是`FROM`指令，它将使用带有`TAG`变量值的ubuntu父镜像与`build`命令一起发送（或者如果没有使用`build`命令发送值，则使用默认值）。然后，`LABEL`指令设置了维护者的值。接下来是`ENV`指令，它使用值`packt`定义了`PUBLISHER`的环境变量，并使用值`/usr/local/app/bin`定义了`APP_DIR`的环境变量。最后，使用`CMD`指令执行`env`命令，该命令将打印所有环境变量。
- en: 'Now, build the Docker image:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建Docker镜像：
- en: '[PRE61]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Note the `env-arg --build-arg TAG=19.04` flag used to send the `TAG` argument
    to the build process. The output should be as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`env-arg --build-arg TAG=19.04`标志将`TAG`参数发送到构建过程中。输出应如下所示：
- en: '![Figure 2.5: Building the env-arg Docker image'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5：构建env-arg Docker镜像'
- en: '](image/B15021_02_05.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_05.jpg)'
- en: 'Figure 2.5: Building the env-arg Docker image'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：构建env-arg Docker镜像
- en: Note that the `19.04` tag of the ubuntu image was used as the parent image.
    This is because you sent the `--build-arg flag` with the value of `TAG=19.04`
    during the build process.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在构建过程中使用了ubuntu镜像的`19.04`标签作为父镜像。这是因为您在构建过程中使用了`--build-arg`标志，并设置了值为`TAG=19.04`。
- en: 'Now, execute the `docker container run` command to start a new container from
    the Docker image that you built in the last step:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行`docker container run`命令，从您在上一步中构建的Docker镜像启动一个新的容器：
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As we can see from the output, the `PUBLISHER` environment variable is available
    with the value of `packt`, and the `APP_DIR` environment variable is available
    with the value of `/usr/local/app/bin`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，`PUBLISHER`环境变量的值为`packt`，`APP_DIR`环境变量的值为`/usr/local/app/bin`：
- en: '![Figure 2.6: Running the env-arg Docker container'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6：运行env-arg Docker容器'
- en: '](image/B15021_02_06.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_06.jpg)'
- en: 'Figure 2.6: Running the env-arg Docker container'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：运行env-arg Docker容器
- en: In this exercise, we defined environment variables for a Docker image using
    the `ENV` directive. We also experienced how to use `ARG` directives to pass values
    during the Docker image build time. In the next section, we will be covering the
    `WORKDIR` directive, which can be used to define the current working directory
    of the Docker container.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用`ENV`指令为Docker镜像定义了环境变量。我们还体验了如何在Docker镜像构建时使用`ARG`指令传递值。在下一节中，我们将介绍`WORKDIR`指令，它可以用来定义Docker容器的当前工作目录。
- en: The WORKDIR Directive
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作目录指令
- en: 'The `WORKDIR` directive is used to specify the current working directory of
    the Docker container. Any subsequent `ADD`, `CMD`, `COPY`, `ENTRYPOINT`, and `RUN`
    directives will be executed in this directory. The `WORKDIR` directive has the
    following format:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR`指令用于指定Docker容器的当前工作目录。任何后续的`ADD`、`CMD`、`COPY`、`ENTRYPOINT`和`RUN`指令都将在此目录中执行。`WORKDIR`指令的格式如下：'
- en: '[PRE63]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If the specified directory does not exist, Docker will create this directory
    and make it the current working directory, which means this directive executes
    both `mkdir` and `cd` commands implicitly.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的目录不存在，Docker将创建此目录并将其设置为当前工作目录，这意味着该指令隐式执行`mkdir`和`cd`命令。
- en: 'There can be multiple `WORKDIR` directives in the `Dockerfile`. If a relative
    path is provided in a subsequent `WORKDIR` directive, that will be relative to
    the working directory set by the previous `WORKDIR` directive:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`中可以有多个`WORKDIR`指令。如果在后续的`WORKDIR`指令中提供了相对路径，那么它将相对于前一个`WORKDIR`指令设置的工作目录。'
- en: '[PRE64]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the preceding example, we are using the `pwd` command at the end of the `Dockerfile`
    to print the current working directory. The output of the `pwd` command will be
    `/one/two/three`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在`Dockerfile`的末尾使用`pwd`命令来打印当前工作目录。`pwd`命令的输出将是`/one/two/three`。
- en: In the next section, we will discuss the `COPY` directive that is used to copy
    files from the local filesystem to the Docker image filesystem.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论`COPY`指令，该指令用于将文件从本地文件系统复制到Docker镜像文件系统。
- en: The COPY Directive
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制指令
- en: 'During the Docker image build process, we may need to copy files from our local
    filesystem to the Docker image filesystem. These files can be source code files
    (for example, JavaScript files), configuration files (for example, properties
    files), or artifacts (for example, JAR files). The `COPY` directive can be used
    to copy files and folders from the local filesystem to the Docker image during
    the build process. This directive takes two arguments. The first one is the source
    path from the local filesystem, and the second one is the destination path on
    the image filesystem:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker镜像构建过程中，我们可能需要将文件从本地文件系统复制到Docker镜像文件系统。这些文件可以是源代码文件（例如JavaScript文件）、配置文件（例如属性文件）或者构件（例如JAR文件）。在构建过程中，可以使用“COPY”指令将文件和文件夹从本地文件系统复制到Docker镜像。该指令有两个参数。第一个是本地文件系统的源路径，第二个是镜像文件系统上的目标路径：
- en: '[PRE65]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the following example, we are using the `COPY` directive to copy the `index.html`
    file from the local filesystem to the `/var/www/html/` directory of the Docker
    image:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们使用“COPY”指令将“index.html”文件从本地文件系统复制到Docker镜像的“/var/www/html/”目录中：
- en: '[PRE66]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Wildcards can also be specified to copy all files that match the given pattern.
    The following example will copy all files with the `.html` extension from the
    current directory to the `/var/www/html/` directory of the Docker image:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符也可以用来指定匹配给定模式的所有文件。以下示例将把当前目录中所有扩展名为“.html”的文件复制到Docker镜像的“/var/www/html/”目录中：
- en: '[PRE67]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In addition to copying files, the `--chown` flag can be used with the `COPY`
    directive to specify the user and group ownership of the files:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 除了复制文件外，“--chown”标志还可以与“COPY”指令一起使用，以指定文件的用户和组所有权：
- en: '[PRE68]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the preceding example, in addition to copying all the HTML files from the
    current directory to the `/var/www/html/` directory, the `--chown` flag is used
    to set file ownership, with the user as `myuser` and group as `mygroup`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，除了将所有HTML文件从当前目录复制到“/var/www/html/”目录外，“--chown”标志还用于设置文件所有权，用户为“myuser”，组为“mygroup”：
- en: Note
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `--chown` flag is only supported from Docker version 17.09 and above. For
    Docker versions below 17.09, you need to run the `chown` command after the `COPY`
    command to change file ownership.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: “--chown”标志仅在Docker版本17.09及以上版本中受支持。对于低于17.09版本的Docker，您需要在“COPY”命令之后运行“chown”命令来更改文件所有权。
- en: In the next section, we will look at the `ADD` directive.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下“ADD”指令。
- en: The ADD Directive
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADD指令
- en: 'The `ADD` directive is also similar to the `COPY` directive, and has the following
    format:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: “ADD”指令也类似于“COPY”指令，格式如下：
- en: '[PRE69]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'However, in addition to the functionality provided by the `COPY` directive,
    the `ADD` directive also allows us to use a URL as the `<source>` parameter:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，除了“COPY”指令提供的功能外，“ADD”指令还允许我们将URL用作“<source>”参数：
- en: '[PRE70]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the preceding example, the `ADD` directive will download the `test.txt` file
    from `http://sample.com` and copy the file to the `/tmp` directory of the Docker
    image filesystem.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，“ADD”指令将从“http://sample.com”下载“test.txt”文件，并将文件复制到Docker镜像文件系统的“/tmp”目录中。
- en: Another feature of the `ADD` directive is automatically extracting the compressed
    files. If we add a compressed file (gzip, bzip2, tar, and so on) to the `<source>`
    parameter, the `ADD` directive will extract the archive and copy the content to
    the image filesystem.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: “ADD”指令的另一个特性是自动提取压缩文件。如果我们将一个压缩文件（gzip、bzip2、tar等）添加到“<source>”参数中，“ADD”指令将会提取存档并将内容复制到镜像文件系统中。
- en: 'Imagine we have a compressed file named `html.tar.gz` that contains `index.html`
    and `contact.html` files. The following command will extract the `html.tar.gz`
    file and copy the `index.html` and `contact.html` files to the `/var/www/html`
    directory:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`html.tar.gz`的压缩文件，其中包含`index.html`和`contact.html`文件。以下命令将提取`html.tar.gz`文件，并将`index.html`和`contact.html`文件复制到`/var/www/html`目录：
- en: '[PRE71]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Since the `COPY` and `ADD` directives provide almost the same functionality,
    it is recommended to always use the `COPY` directive unless you need the additional
    functionality (add from a URL or extract a compressed file) provided by the `ADD`
    directive. This is because the `ADD` directive provides additional functionality
    that can behave unpredictably if used incorrectly (for example, copying files
    when you want to extract, or extracting files when you want to copy).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`COPY`和`ADD`指令提供几乎相同的功能，建议始终使用`COPY`指令，除非您需要`ADD`指令提供的附加功能（从URL添加或提取压缩文件）。这是因为`ADD`指令提供了额外的功能，如果使用不正确，可能会表现出不可预测的行为（例如，在想要提取文件时复制文件，或者在想要复制文件时提取文件）。
- en: In the next exercise, we are going to use the `WORKDIR`, `COPY`, and `ADD` directives
    to copy files into the Docker image.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用`WORKDIR`，`COPY`和`ADD`指令将文件复制到Docker镜像中。
- en: 'Exercise 2.04: Using the WORKDIR, COPY, and ADD Directives in the Dockerfile'
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.04：在Dockerfile中使用WORKDIR，COPY和ADD指令
- en: 'In this exercise, you will deploy your custom HTML file to the Apache web server.
    You will use Ubuntu as the base image and install Apache on top of it. Then, you
    will copy your custom index.html file to the Docker image and download the Docker
    logo (from the https://www.docker.com website) to be used with the custom index.html
    file:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将部署自定义的HTML文件到Apache Web服务器。您将使用Ubuntu作为基础镜像，并在其上安装Apache。然后，您将将自定义的index.html文件复制到Docker镜像，并从https://www.docker.com网站下载Docker标志，以与自定义的index.html文件一起使用：
- en: 'Create a new directory named `workdir-copy-add-exercise` using the `mkdir` command:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mkdir`命令创建一个名为`workdir-copy-add-exercise`的新目录：
- en: '[PRE72]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Navigate to the newly created `workdir-copy-add-exercise` directory:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的`workdir-copy-add-exercise`目录：
- en: '[PRE73]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Within the `workdir-copy-add-exercise` directory, create a file named `index.html`.
    This file will be copied to the Docker image during build time:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`workdir-copy-add-exercise`目录中，创建一个名为`index.html`的文件。此文件将在构建时复制到Docker镜像中：
- en: '[PRE74]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, open `index.html` using your favorite text editor:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`index.html`：
- en: '[PRE75]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Add the following content to the `index.html` file, save it, and exit from
    `index.html`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`index.html`文件中，保存并退出`index.html`：
- en: '[PRE76]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This HTML file will output `Welcome to The Docker Workshop` as the header of
    the page and `logo.png` (which we will download during the Docker image build
    process) as an image. You have defined the size of the `logo.png` image as a height
    of `350` and a width of `500`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此HTML文件将在页面的标题中输出“欢迎来到Docker工作坊”，并作为图像输出`logo.png`（我们将在Docker镜像构建过程中下载）。您已经定义了`logo.png`图像的高度为`350`，宽度为`500`。
- en: 'Within the `workdir-copy-add-exercise` directory, create a file named `Dockerfile`:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`workdir-copy-add-exercise`目录中，创建一个名为`Dockerfile`的文件：
- en: '[PRE77]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, open the `Dockerfile` using your favorite text editor:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`Dockerfile`：
- en: '[PRE78]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Add the following content to the `Dockerfile`, save it, and exit from the `Dockerfile`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`Dockerfile`中，保存并退出`Dockerfile`：
- en: '[PRE79]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This `Dockerfile` first defines the ubuntu image as the parent image. The next
    line is the `RUN` directive, which will execute `apt-get update` to update the
    package list, and `apt-get install apache2 -y` to install the Apache HTTP server.
    Then, you will set `/var/www/html/` as the working directory. Next, copy the `index.html`
    file that we created in *step 3* to the Docker image. Then, use the `ADD` directive
    to download the Docker logo from [https://www.docker.com/sites/default/files/d8/2019-07/Moby-logo.png](https://www.docker.com/sites/default/files/d8/2019-07/Moby-logo.png)
    to the Docker image. The final step is to use the `ls` command to print the content
    of the `/var/www/html/` directory.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Dockerfile`首先将ubuntu镜像定义为父镜像。下一行是`RUN`指令，它将执行`apt-get update`来更新软件包列表，以及`apt-get
    install apache2 -y`来安装Apache HTTP服务器。然后，您将设置`/var/www/html/`为工作目录。接下来，将我们在*步骤3*中创建的`index.html`文件复制到Docker镜像中。然后，使用`ADD`指令从[https://www.docker.com/sites/default/files/d8/2019-07/Moby-logo.png](https://www.docker.com/sites/default/files/d8/2019-07/Moby-logo.png)下载Docker标志到Docker镜像中。最后一步是使用`ls`命令打印`/var/www/html/`目录的内容。
- en: 'Now, build the Docker image with the tag of `workdir-copy-add`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用标签`workdir-copy-add`构建Docker镜像：
- en: '[PRE80]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You will observe that the image is successfully built and tagged as `latest`
    since we did not explicitly tag our image:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，由于我们没有明确为镜像打标签，因此该镜像已成功构建并标记为`latest`：
- en: '![Figure 2.7: Building the Docker image using WORKDIR, COPY, and ADD directives'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7：使用WORKDIR、COPY和ADD指令构建Docker镜像'
- en: '](image/B15021_02_07.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_07.jpg)'
- en: 'Figure 2.7: Building the Docker image using WORKDIR, COPY, and ADD directives'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：使用WORKDIR、COPY和ADD指令构建Docker镜像
- en: 'Execute the `docker container run` command to start a new container from the
    Docker image that you built in the previous step:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`docker container run`命令，从您在上一步中构建的Docker镜像启动一个新的容器：
- en: '[PRE81]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'As we can see from the output, both the `index.html` and `logo.png` files are
    available in the `/var/www/html/` directory:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看到，`index.html`和`logo.png`文件都在`/var/www/html/`目录中可用：
- en: '[PRE82]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In this exercise, we observed how the `WORKDIR`, `ADD`, and `COPY` directives
    work with Docker. In the next section, we are going to discuss the `USER` directive.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们观察了`WORKDIR`、`ADD`和`COPY`指令在Docker中的工作方式。在下一节中，我们将讨论`USER`指令。
- en: The USER Directive
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: USER指令
- en: Docker will use the root user as the default user of a Docker container. We
    can use the `USER` directive to change this default behavior and specify a non-root
    user as the default user of a Docker container. This is a great way to improve
    security by running the Docker container as a non-privileged user. The username
    specified with the `USER` directive will be used to run all subsequent `RUN`,
    `CMD`, and `ENTRYPOINT` directives in the `Dockerfile`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将使用root用户作为Docker容器的默认用户。我们可以使用`USER`指令来改变这种默认行为，并指定一个非root用户作为Docker容器的默认用户。这是通过以非特权用户身份运行Docker容器来提高安全性的好方法。在`Dockerfile`中使用`USER`指令指定的用户名将用于运行所有后续的`RUN`、`CMD`和`ENTRYPOINT`指令。
- en: 'The `USER` directive takes the following format:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER`指令采用以下格式：'
- en: '[PRE83]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In addition to the username, we can also specify the optional group name to
    run the Docker container:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户名之外，我们还可以指定可选的组名来运行Docker容器：
- en: '[PRE84]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We need to make sure that the `<user>` and `<group>` values are valid user
    and group names. Otherwise, the Docker daemon will throw an error while trying
    to run the container:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保`<user>`和`<group>`的值是有效的用户和组名。否则，Docker守护程序在尝试运行容器时会抛出错误：
- en: '[PRE85]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now, let's try our hands at using the `USER` directive in the next exercise.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一个练习中尝试使用`USER`指令。
- en: 'Exercise 2.05: Using USER Directive in the Dockerfile'
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.05：在Dockerfile中使用USER指令
- en: 'Your manager has asked you to create a Docker image to run the Apache web server.
    He has specifically requested that you use a non-root user while running the Docker
    container due to security reasons. In this exercise, you will use the `USER` directive
    in the `Dockerfile` to set the default user. You will be installing the Apache
    web server and changing the user to `www-data`. Finally, you will execute the
    `whoami` command to verify the current user by printing the username:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您的经理要求您创建一个Docker镜像来运行Apache Web服务器。由于安全原因，他特别要求您在运行Docker容器时使用非root用户。在这个练习中，您将使用`Dockerfile`中的`USER`指令来设置默认用户。您将安装Apache
    Web服务器并将用户更改为`www-data`。最后，您将执行`whoami`命令来验证当前用户的用户名：
- en: Note
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `www-data` user is the default user for the Apache web server on Ubuntu.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`www-data`用户是Ubuntu上Apache Web服务器的默认用户。'
- en: 'Create a new directory named `user-exercise` for this exercise:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个练习创建一个名为`user-exercise`的新目录：
- en: '[PRE86]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Navigate to the newly created `user-exercise` directory:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的`user-exercise`目录：
- en: '[PRE87]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Within the `user-exercise` directory, create a file named `Dockerfile`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`user-exercise`目录中，创建一个名为`Dockerfile`的文件：
- en: '[PRE88]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, open the `Dockerfile` using your favorite text editor:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用你喜欢的文本编辑器打开`Dockerfile`：
- en: '[PRE89]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Add the following content to the `Dockerfile`, save it, and exit from the `Dockerfile`:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`Dockerfile`中，保存并退出`Dockerfile`：
- en: '[PRE90]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This `Dockerfile` first defines the Ubuntu image as the parent image. The next
    line is the `RUN` directive, which will execute `apt-get update` to update the
    package list, and `apt-get install apache2 -y` to install the Apache HTTP server.
    Next, you use the `USER` directive to change the current user to the `www-data`
    user. Finally, you have the `CMD` directive, which executes the `whoami` command,
    which will print the username of the current user.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Dockerfile`首先将Ubuntu镜像定义为父镜像。下一行是`RUN`指令，它将执行`apt-get update`来更新软件包列表，以及`apt-get
    install apache2 -y`来安装Apache HTTP服务器。接下来，您使用`USER`指令将当前用户更改为`www-data`用户。最后，您有`CMD`指令，它执行`whoami`命令，将打印当前用户的用户名。
- en: 'Build the Docker image:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建Docker镜像：
- en: '[PRE91]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output should be as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 2.8: Building the user Docker image'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8：构建用户Docker镜像'
- en: '](image/B15021_02_08.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_08.jpg)'
- en: 'Figure 2.8: Building the user Docker image'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：构建用户Docker镜像
- en: 'Now, execute the `docker container` run command to start a new container from
    the Docker image that we built in the previous step:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行`docker container` run命令来从我们在上一步中构建的Docker镜像启动一个新的容器：
- en: '[PRE92]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'As you can see from the following output, `www-data` is the current user associated
    with the Docker container:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下输出中所见，`www-data`是与Docker容器关联的当前用户：
- en: '[PRE93]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In this exercise, we implemented the `USER` directive in the `Dockerfile` to
    set the `www-data` user as the default user of the Docker image.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们在`Dockerfile`中实现了`USER`指令，将`www-data`用户设置为Docker镜像的默认用户。
- en: In the next section, we will discuss the `VOLUME` directive.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论`VOLUME`指令。
- en: The VOLUME Directive
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VOLUME指令
- en: In Docker, the data (for example, files, executables) generated and used by
    Docker containers will be stored within the container filesystem. When we delete
    the container, all the data will be lost. To overcome this issue, Docker came
    up with the concept of volumes. Volumes are used to persist the data and share
    the data between containers. We can use the `VOLUME` directive within the `Dockerfile`
    to create Docker volumes. Once a `VOLUME` is created in the Docker container,
    a mapping directory will be created in the underlying host machine. All file changes
    to the volume mount of the Docker container will be copied to the mapped directory
    of the host machine.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中，Docker容器生成和使用的数据（例如文件、可执行文件）将存储在容器文件系统中。当我们删除容器时，所有数据都将丢失。为了解决这个问题，Docker提出了卷的概念。卷用于持久化数据并在容器之间共享数据。我们可以在`Dockerfile`中使用`VOLUME`指令来创建Docker卷。一旦在Docker容器中创建了`VOLUME`，底层主机将创建一个映射目录。Docker容器的卷挂载的所有文件更改将被复制到主机机器的映射目录中。
- en: 'The `VOLUME` directive generally takes a JSON array as the parameter:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLUME`指令通常以JSON数组作为参数：'
- en: '[PRE94]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Or, we can specify a plain string with multiple paths:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以指定一个包含多个路径的普通字符串：
- en: '[PRE95]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We can use the `docker container inspect <container>` command to view the volumes
    available in a container. The output JSON of the docker container inspect command
    will print the volume information similar to the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker container inspect <container>`命令查看容器中可用的卷。docker容器inspect命令的输出JSON将打印类似以下内容的卷信息：
- en: '[PRE96]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: As per the preceding output, there is a unique name given to the volume by Docker.
    Also, the source and destination paths of the volume are mentioned in the output.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的输出，Docker为卷指定了一个唯一的名称。此外，输出中还提到了卷的源路径和目标路径。
- en: 'Additionally, we can execute the `docker volume inspect <volume>` command to
    display detailed information pertaining to a volume:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以执行`docker volume inspect <volume>`命令来显示有关卷的详细信息：
- en: '[PRE97]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This is also similar to the previous output, with the same unique name and the
    mount path of the volume.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这也类似于先前的输出，具有相同的唯一名称和卷的挂载路径。
- en: In the next exercise, we will learn how to use the `VOLUME` directive in a `Dockerfile`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将学习如何在`Dockerfile`中使用`VOLUME`指令。
- en: 'Exercise 2.06: Using VOLUME Directive in the Dockerfile'
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.06：在Dockerfile中使用VOLUME指令
- en: 'In this exercise, you will be setting a Docker container to run the Apache
    web server. However, you do not want to lose the Apache log files in case of a
    Docker container failure. As a solution, you have decided to persist in the log
    files by mounting the Apache log path to the underlying Docker host:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将设置一个Docker容器来运行Apache Web服务器。但是，您不希望在Docker容器失败时丢失Apache日志文件。作为解决方案，您决定通过将Apache日志路径挂载到底层Docker主机来持久保存日志文件。
- en: 'Create a new directory named `volume-exercise`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`volume-exercise`的新目录：
- en: '[PRE98]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Navigate to the newly created `volume-exercise` directory:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到新创建的`volume-exercise`目录：
- en: '[PRE99]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Within the `volume-exercise` directory, create a file named `Dockerfile`:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`volume-exercise`目录中，创建一个名为`Dockerfile`的文件：
- en: '[PRE100]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, open the `Dockerfile` using your favorite text editor:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`Dockerfile`：
- en: '[PRE101]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Add the following content to the `Dockerfile`, save it, and exit from the `Dockerfile`:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`Dockerfile`中，保存并退出`Dockerfile`：
- en: '[PRE102]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This `Dockerfile` started by defining the Ubuntu image as the parent image.
    Next, you will execute the `apt-get update` command to update the package list,
    and the `apt-get install apache2 -y` command to install the Apache web server.
    Finally, use the `VOLUME` directive to set up a mount point to the `/var/log/apache2`
    directory.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Dockerfile`首先定义了Ubuntu镜像作为父镜像。接下来，您将执行`apt-get update`命令来更新软件包列表，以及`apt-get
    install apache2 -y`命令来安装Apache Web服务器。最后，使用`VOLUME`指令来设置一个挂载点到`/var/log/apache2`目录。
- en: 'Now, build the Docker image:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建Docker镜像：
- en: '[PRE103]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The output should be as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 2.9: Building the volume Docker image'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9：构建卷Docker镜像'
- en: '](image/B15021_02_09.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_09.jpg)'
- en: 'Figure 2.9: Building the volume Docker image'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：构建卷Docker镜像
- en: 'Execute the docker container run command to start a new container from the
    Docker image that you built in the previous step. Note that you are using the
    `--interactive` and `--tty` flags to open an interactive bash session so that
    you can execute commands from the bash shell of the Docker container. You have
    also used the `--name` flag to define the container name as `volume-container`:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行docker容器运行命令，从您在上一步构建的Docker镜像中启动一个新的容器。请注意，您正在使用`--interactive`和`--tty`标志来打开一个交互式的bash会话，以便您可以从Docker容器的bash
    shell中执行命令。您还使用了`--name`标志来将容器名称定义为`volume-container`：
- en: '[PRE104]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Your bash shell will be opened as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 您的bash shell将会被打开如下：
- en: '[PRE105]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'From the Docker container command line, change directory to the `/var/log/apache2/`
    directory:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Docker容器命令行，切换到`/var/log/apache2/`目录：
- en: '[PRE106]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'This will produce the following output:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE107]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now, list the available files in the directory:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，列出目录中可用的文件：
- en: '[PRE108]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The output should be as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 2.10: Listing files of the /var/log/apache2 directory'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10：列出/var/log/apache2目录的文件'
- en: '](image/B15021_02_10.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_10.jpg)'
- en: 'Figure 2.10: Listing files of the /var/log/apache2 directory'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：列出/var/log/apache2目录的文件
- en: These are the log files created by Apache while running the process. The same
    files should be available once you check the host mount of this volume.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Apache在运行过程中创建的日志文件。一旦您检查了该卷的主机挂载，相同的文件应该也是可用的。
- en: 'Now, exit the container to check the host filesystem:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，退出容器以检查主机文件系统：
- en: '[PRE109]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Inspect `volume-container` to view the mount information:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`volume-container`以查看挂载信息：
- en: '[PRE110]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Under the "`Mounts`" key, you can see the information relating to the mount:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在"`Mounts`"键下，您可以看到与挂载相关的信息：
- en: '![Figure 2.11: Inspecting the Docker container'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.11：检查Docker容器'
- en: '](image/B15021_02_11.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_11.jpg)'
- en: 'Figure 2.11: Inspecting the Docker container'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：检查Docker容器
- en: 'Inspect the volume with the `docker volume inspect <volume_name>` command.
    `<volume_name>` can be identified by the `Name` field of the preceding output:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker volume inspect <volume_name>`命令来检查卷。`<volume_name>`可以通过前面输出的`Name`字段来识别：
- en: '[PRE111]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'You should get the output similar to the following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似以下的输出：
- en: '![Figure 2.12: Inspecting the Docker volume'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.12：检查Docker卷'
- en: '](image/B15021_02_12.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_12.jpg)'
- en: 'Figure 2.12: Inspecting the Docker volume'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：检查Docker卷
- en: We can see that the container is mounted to the host path of `"/var/lib/docker/volumes/354d188e0761d82e1e7d9f3d5c6ee644782b
    7150f51cead8f140556e5d334bd5/_data"`, which is defined as the `Mountpoint` field
    in the preceding output.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到容器被挂载到`"/var/lib/docker/volumes/354d188e0761d82e1e7d9f3d5c6ee644782b 7150f51cead8f140556e5d334bd5/_data"`的主机路径上，这在前面的输出中被定义为`Mountpoint`字段。
- en: 'List the files available in the host file path. The host file path can be identified
    with the `"Mountpoint`" field of the preceding output:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出主机文件路径中可用的文件。主机文件路径可以通过前面输出的`"Mountpoint"`字段来识别：
- en: '[PRE112]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'In the following output, you can see that the log files in the `/var/log/apache2`
    directory of the container are mounted to the host:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的输出中，您可以看到容器中`/var/log/apache2`目录中的日志文件被挂载到主机上：
- en: '![Figure 2.13: Listing files in the mount point directory'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13：列出挂载点目录中的文件'
- en: '](image/B15021_02_13.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_13.jpg)'
- en: 'Figure 2.13: Listing files in the mount point directory'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：列出挂载点目录中的文件
- en: In this exercise, we observed how to mount the log path of the Apache web server
    to the host filesystem using the `VOLUME` directive. In the next section, we will
    learn about the `EXPOSE` directive.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们观察了如何使用`VOLUME`指令将Apache Web服务器的日志路径挂载到主机文件系统上。在下一节中，我们将学习`EXPOSE`指令。
- en: The EXPOSE Directive
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EXPOSE指令
- en: 'The `EXPOSE` directive is used to inform Docker that the container is listening
    on the specified ports at runtime. We can use the `EXPOSE` directive to expose
    ports through either TCP or UDP protocols. The `EXPOSE` directive has the following
    format:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE`指令用于通知Docker容器在运行时监听指定端口。我们可以使用`EXPOSE`指令通过TCP或UDP协议公开端口。`EXPOSE`指令的格式如下：'
- en: '[PRE113]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'However, the ports exposed with the `EXPOSE` directive will only be accessible
    from within the other Docker containers. To expose these ports outside the Docker
    container, we can publish the ports with the `-p` flag with the `docker container
    run` command:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`EXPOSE`指令公开的端口只能从其他Docker容器内部访问。要将这些端口公开到Docker容器外部，我们可以使用`docker container
    run`命令的`-p`标志来发布端口：
- en: '[PRE114]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: As an example, imagine that we have two containers. One is a NodeJS web app
    container that should be accessed from outside via port `80`. The second one is
    the MySQL container, which should be accessed from the node app container via
    port `3306`. In this scenario, we have to expose port `80` of the NodeJS app with
    the `EXPOSE` directive and use the `-p` flag with the `docker container run` command
    to expose it externally. However, for the MySQL container, we can only use the
    `EXPOSE` directive without the `-p` flag when running the container, as `3306`
    should only be accessible from the node app container.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们有两个容器。一个是NodeJS Web应用容器，应该通过端口`80`从外部访问。第二个是MySQL容器，应该通过端口`3306`从Node应用容器访问。在这种情况下，我们必须使用`EXPOSE`指令公开NodeJS应用的端口`80`，并在运行容器时使用`docker
    container run`命令和`-p`标志来将其公开到外部。然而，对于MySQL容器，我们在运行容器时只能使用`EXPOSE`指令，而不使用`-p`标志，因为`3306`端口只能从Node应用容器访问。
- en: 'So, in summary, the following statements define this directive:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结来说，以下陈述定义了这个指令：
- en: If we specify both the `EXPOSE` directive and `-p` flag, exposed ports will
    be accessible from other containers as well as externally.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们同时指定`EXPOSE`指令和`-p`标志，公开的端口将可以从其他容器以及外部访问。
- en: If we specify `EXPOSE` without the `-p` flag, exposed ports will only be accessible
    from other containers, but not externally.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们不使用`-p`标志来指定`EXPOSE`，那么公开的端口只能从其他容器访问，而无法从外部访问。
- en: You will learn about the `HEALTHCHECK` directive in the next section.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习`HEALTHCHECK`指令。
- en: The HEALTHCHECK Directive
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HEALTHCHECK指令
- en: 'Health checks are used in Docker to check whether the containers are running
    healthily. For example, we can use health checks to make sure the application
    is running within the Docker container. Unless there is a health check specified,
    there is no way for Docker to say whether a container is healthy. This is very
    important if you are running Docker containers in production environments. The
    `HEALTHCHECK` directive has the following format:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中使用健康检查来检查容器是否正常运行。例如，我们可以使用健康检查来确保应用程序在Docker容器内部运行。除非指定了健康检查，否则Docker无法判断容器是否健康。如果在生产环境中运行Docker容器，这一点非常重要。`HEALTHCHECK`指令的格式如下：
- en: '[PRE115]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: There can be only one `HEALTHCHECK` directive in a `Dockerfile`. If there is
    more than one `HEALTHCHECK` directive, only the last one will take effect.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`中只能有一个`HEALTHCHECK`指令。如果有多个`HEALTHCHECK`指令，只有最后一个会生效。'
- en: 'As an example, we can use the following directive to ensure that the container
    can receive traffic on the `http://localhost/` endpoint:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下指令来确保容器可以在`http://localhost/`端点接收流量：
- en: '[PRE116]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The exit code at the end of the preceding command is used to specify the health
    status of the container. `0` and `1` are valid values for this field. 0 is used
    to denote a healthy container, and `1` is used to denote an unhealthy container.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令的最后，退出代码用于指定容器的健康状态。`0`和`1`是此字段的有效值。0用于表示健康的容器，`1`用于表示不健康的容器。
- en: 'In addition to the command, we can specify a few other parameters with the
    `HEALTHCHECK` directive, as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命令，我们可以在`HEALTHCHECK`指令中指定一些其他参数，如下所示：
- en: '`--interval`: This specifies the period between each health check (the default
    is 30s).'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--interval`：指定每次健康检查之间的时间间隔（默认为30秒）。'
- en: '`--timeout`: If no success response is received within this period, the health
    check is considered failed (the default is 30s).'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--timeout`：如果在此期间未收到成功响应，则健康检查被视为失败（默认为30秒）。'
- en: '`--start-period`: The duration to wait before running the first health check.
    This is used to give a startup time for the container (the default is 0s).'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--start-period`：在运行第一次健康检查之前等待的持续时间。这用于为容器提供启动时间（默认为0秒）。'
- en: '`--retries`: The container will be considered unhealthy if the health check
    failed consecutively for the given number of retries (the default is 3).'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--retries`：如果健康检查连续失败给定次数的重试（默认为3次），则容器将被视为不健康。'
- en: 'In the following example, we have overridden the default values by providing
    our custom values with the `HEALTHCHECK` directive:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们通过使用`HEALTHCHECK`指令提供我们的自定义值来覆盖了默认值：
- en: '[PRE117]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We can check the health status of a container with the `docker container list`
    command. This will list the health status under the `STATUS` column:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker container list`命令来检查容器的健康状态。这将在`STATUS`列下列出健康状态：
- en: '[PRE118]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'As soon as we start the container, the health status will be health: starting.
    Following the successful execution of the `HEALTHCHECK` command, the status will
    change to `healthy`.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动容器，健康状态将是健康：启动中。成功执行`HEALTHCHECK`命令后，状态将变为`健康`。
- en: In the next exercise, we are going to use the `EXPOSE` and `HEALTHCHECK` directives
    to create a Docker container with the Apache web server and define health checks
    for it.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用`EXPOSE`和`HEALTHCHECK`指令来创建一个带有Apache web服务器的Docker容器，并为其定义健康检查。
- en: 'Exercise 2.07: Using EXPOSE and HEALTHCHECK Directives in the Dockerfile'
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.07：在Dockerfile中使用EXPOSE和HEALTHCHECK指令
- en: 'Your manager has asked you to dockerize the Apache web server to access the
    Apache home page from the web browser. Additionally, he has asked you to configure
    health checks to determine the health status of the Apache web server. In this
    exercise, you will use the `EXPOSE` and `HEALTHCHECK` directives to achieve this goal:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 你的经理要求你将Apache web服务器docker化，以便从Web浏览器访问Apache首页。此外，他要求你配置健康检查以确定Apache web服务器的健康状态。在这个练习中，你将使用`EXPOSE`和`HEALTHCHECK`指令来实现这个目标：
- en: 'Create a new directory named `expose-healthcheck`:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`expose-healthcheck`的新目录：
- en: '[PRE119]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Navigate to the newly created `expose-healthcheck` directory:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的`expose-healthcheck`目录：
- en: '[PRE120]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Within the `expose-healthcheck` directory, create a file named `Dockerfile`:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`expose-healthcheck`目录中，创建一个名为`Dockerfile`的文件：
- en: '[PRE121]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Now, open the `Dockerfile` using your favorite text editor:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用你喜欢的文本编辑器打开`Dockerfile`：
- en: '[PRE122]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Add the following content to the `Dockerfile`, save it, and exit from the `Dockerfile`:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`Dockerfile`中，保存并退出`Dockerfile`：
- en: '[PRE123]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This `Dockerfile` first defines the ubuntu image as the parent image. Next,
    we execute the `apt-get update` command to update the package list, and the `apt-get
    install apache2 curl -y` command to install the Apache web server and curl tool.
    `Curl` is required to execute the `HEALTHCHECK` command. Next, we define the `HEALTHCHECK`
    directive with curl to the `http://localhost/` endpoint. Then, we exposed port
    `80` of the Apache web server so that we can access the home page from our web
    browser. Finally, we start the Apache web server with the `ENTRYPOINT` directive.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Dockerfile`首先将ubuntu镜像定义为父镜像。接下来，我们执行`apt-get update`命令来更新软件包列表，以及`apt-get
    install apache2 curl -y`命令来安装Apache web服务器和curl工具。`Curl`是执行`HEALTHCHECK`命令所需的。接下来，我们使用curl将`HEALTHCHECK`指令定义为`http://localhost/`端点。然后，我们暴露了Apache
    web服务器的端口`80`，以便我们可以从网络浏览器访问首页。最后，我们使用`ENTRYPOINT`指令启动了Apache web服务器。
- en: 'Now, build the Docker image:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建Docker镜像：
- en: '[PRE124]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'You should get the following output:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下输出：
- en: '![Figure 2.14: Building the expose-healthcheck Docker image'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.14：构建expose-healthcheck Docker镜像'
- en: '](image/B15021_02_14.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_14.jpg)'
- en: 'Figure 2.14: Building the expose-healthcheck Docker image'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：构建expose-healthcheck Docker镜像
- en: 'Execute the docker container run command to start a new container from the
    Docker image that you built in the previous step. Note that you are using the
    `-p` flag to redirect port `80` of the host to port `80` of the container. Additionally,
    you have used the `--name` flag to specify the container name as `expose-healthcheck-container`,
    and the `-d` flag to run the container in detached mode (this runs the container
    in the background):'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`docker container run`命令，从前一步构建的Docker镜像启动一个新的容器。请注意，您使用了`-p`标志将主机的端口`80`重定向到容器的端口`80`。此外，您使用了`--name`标志将容器名称指定为`expose-healthcheck-container`，并使用了`-d`标志以分离模式运行容器（这将在后台运行容器）：
- en: '[PRE125]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'List the running containers with the `docker container list` command:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker container list`命令列出正在运行的容器：
- en: '[PRE126]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'In the following output, you can see that the `STATUS` of the `expose-healthcheck-container`
    is healthy:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的输出中，您可以看到`expose-healthcheck-container`的`STATUS`为健康：
- en: '![Figure 2.15: List of running containers'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.15：运行容器列表'
- en: '](image/B15021_02_15.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_15.jpg)'
- en: 'Figure 2.15: List of running containers'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：运行容器列表
- en: 'Now, you should be able to view the Apache home page. Go to the `http://127.0.0.1`
    endpoint from your favorite web browser:![Figure 2.16: Apache home page'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您应该能够查看Apache首页。从您喜欢的网络浏览器转到`http://127.0.0.1`端点：![图2.16：Apache首页
- en: '](image/B15021_02_16.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_16.jpg)'
- en: 'Figure 2.16: Apache home page'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：Apache首页
- en: 'Now, clean up the container. First, stop the Docker container by using the
    `docker container stop` command:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在清理容器。首先，使用`docker container stop`命令停止Docker容器：
- en: '[PRE127]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Finally, remove the Docker container with the `docker container rm` command:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`docker container rm`命令删除Docker容器：
- en: '[PRE128]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: In this exercise, you utilized the `EXPOSE` directive to expose an Apache web
    server as a Docker container and used the `HEALTHCHECK` directive to define a
    health check to verify the healthy status of the Docker container.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您利用了`EXPOSE`指令将Apache web服务器暴露为Docker容器，并使用了`HEALTHCHECK`指令来定义一个健康检查，以验证Docker容器的健康状态。
- en: In the next section, we will learn about the `ONBUILD` directive.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习`ONBUILD`指令。
- en: The ONBUILD Directive
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ONBUILD指令
- en: The `ONBUILD` directive is used in the `Dockerfile` to create a reusable Docker
    image that will be used as the base for another Docker image. As an example, we
    can create a Docker image that contains all the prerequisites, such as dependencies
    and configurations, in order to run an application. Then, we can use this 'prerequisite'
    image as the parent image to run the application.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`ONBUILD`指令用于在`Dockerfile`中创建可重用的Docker镜像，该镜像将用作另一个Docker镜像的基础。例如，我们可以创建一个包含所有先决条件的Docker镜像，如依赖和配置，以便运行一个应用程序。然后，我们可以使用这个“先决条件”镜像作为父镜像来运行应用程序。'
- en: While creating the prerequisite image, we can use the `ONBUILD` directive, which
    will include the instructions that should only be executed when this image is
    used as the parent image in another `Dockerfile`. `ONBUILD` instructions will
    not be executed while building the `Dockerfile` that contains the `ONBUILD` directive,
    but only when building the child image.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建先决条件镜像时，我们可以使用`ONBUILD`指令，该指令将包括应仅在此镜像作为另一个`Dockerfile`中的父镜像时执行的指令。`ONBUILD`指令在构建包含`ONBUILD`指令的`Dockerfile`时不会被执行，而只有在构建子镜像时才会执行。
- en: 'The `ONBUILD` directive takes the following format:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`ONBUILD`指令采用以下格式：'
- en: '[PRE129]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'As an example, consider that we have the following `ONBUILD` instruction in
    the `Dockerfile` of our custom base image:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们的自定义基础镜像的`Dockerfile`中有以下`ONBUILD`指令：
- en: '[PRE130]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The `"Running ONBUILD directive"` value will not be printed if we create a Docker
    container from our custom base image. However, the `"Running ONBUILD directive"`
    value will be printed if we use our custom base image as the base for our new
    child Docker image.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从自定义基础镜像创建一个Docker容器，那么`"Running ONBUILD directive"`值将不会被打印出来。然而，如果我们将我们的自定义基础镜像用作新的子Docker镜像的基础，那么`"Running
    ONBUILD directive"`值将被打印出来。
- en: 'We can use the `docker image inspect` command for the parent image to list
    the OnBuild triggers listed for the image:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker image inspect`命令来列出父镜像的OnBuild触发器：
- en: '[PRE131]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The command will return output similar to the following:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回类似以下的输出：
- en: '[PRE132]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: In the next exercise, we will be using the `ONBUILD` directive to define a Docker
    image to deploy the HTML files.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用`ONBUILD`指令来定义一个Docker镜像来部署HTML文件。
- en: 'Exercise 2.08: Using ONBUILD Directive in the Dockerfile'
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.08：在Dockerfile中使用ONBUILD指令
- en: 'You have been asked by your manager to create a Docker image that is capable
    of running any HTML files provided by the software development team. In this exercise,
    you will build a parent image with the Apache web server and use the `ONBUILD`
    directive to copy the HTML files. The software development team can use this Docker
    image as the parent image to deploy and test any HTML files created by them:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 你的经理要求你创建一个能够运行软件开发团队提供的任何HTML文件的Docker镜像。在这个练习中，你将构建一个带有Apache Web服务器的父镜像，并使用`ONBUILD`指令来复制HTML文件。软件开发团队可以使用这个Docker镜像作为父镜像来部署和测试他们创建的任何HTML文件。
- en: 'Create a new directory named `onbuild-parent`:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`onbuild-parent`的新目录：
- en: '[PRE133]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Navigate to the newly created `onbuild-parent` directory:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的`onbuild-parent`目录：
- en: '[PRE134]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Within the `onbuild-parent` directory, create a file named `Dockerfile`:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onbuild-parent`目录中，创建一个名为`Dockerfile`的文件：
- en: '[PRE135]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Now, open the `Dockerfile` using your favorite text editor:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用你喜欢的文本编辑器打开`Dockerfile`：
- en: '[PRE136]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Add the following content to the `Dockerfile`, save it, and exit from the `Dockerfile`:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`Dockerfile`中，保存并退出`Dockerfile`：
- en: '[PRE137]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: This `Dockerfile` first defines the ubuntu image as the parent image. It then
    executes the `apt-get update` command to update the package list, and the `apt-get
    install apache2 -y` command to install the Apache web server. The `ONBUILD` directive
    is used to provide a trigger to copy all HTML files to the `/var/www/html` directory.
    The `EXPOSE` directive is used to expose port `80` of the container and `ENTRYPOINT`
    to start the Apache web server using the `apache2ctl` command.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Dockerfile`首先将ubuntu镜像定义为父镜像。然后执行`apt-get update`命令来更新软件包列表，以及`apt-get install
    apache2 -y`命令来安装Apache Web服务器。`ONBUILD`指令用于提供一个触发器，将所有HTML文件复制到`/var/www/html`目录。`EXPOSE`指令用于暴露容器的端口`80`，`ENTRYPOINT`用于使用`apache2ctl`命令启动Apache
    Web服务器。
- en: 'Now, build the Docker image:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建Docker镜像：
- en: '[PRE138]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The output should be as follows:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 2.17: Building the onbuild-parent Docker image'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.17：构建onbuild-parent Docker镜像'
- en: '](image/B15021_02_17.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_17.jpg)'
- en: 'Figure 2.17: Building the onbuild-parent Docker image'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：构建onbuild-parent Docker镜像
- en: 'Execute the `docker container run` command to start a new container from the
    Docker image built in the previous step:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`docker container run`命令以从上一步构建的Docker镜像启动新容器：
- en: '[PRE139]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: In the preceding command, you have started the Docker container in detached
    mode while exposing port `80` of the container.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，您已经以分离模式启动了Docker容器，同时暴露了容器的端口`80`。
- en: 'Now, you should be able to view the Apache home page. Go to the `http://127.0.0.1`
    endpoint from your favorite web browser. Note that the default Apache home page
    is visible:![Figure 2.18: Apache home page'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您应该能够查看Apache首页。在您喜欢的网络浏览器中转到`http://127.0.0.1`端点。请注意，默认的Apache首页是可见的：![图2.18：Apache首页
- en: '](image/B15021_02_16.jpg)'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_16.jpg)'
- en: 'Figure 2.18: Apache home page'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18：Apache首页
- en: 'Now, clean up the container. Stop the Docker container by using the `docker
    container stop` command:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，清理容器。使用`docker container stop`命令停止Docker容器：
- en: '[PRE140]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Remove the Docker container with the `docker container rm` command:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker container rm`命令删除Docker容器：
- en: '[PRE141]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Now, create another Docker image using `onbuild-parent-container` as the parent
    image to deploy a custom HTML home page. First, change the directory back to the
    previous directory:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`onbuild-parent-container`作为父镜像创建另一个Docker镜像，以部署自定义HTML首页。首先，将目录更改回到上一个目录：
- en: '[PRE142]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Create a new directory named `onbuild-child` for this exercise:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个练习创建一个名为`onbuild-child`的新目录：
- en: '[PRE143]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Navigate to the newly created `onbuild-child` directory:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的`onbuild-child`目录：
- en: '[PRE144]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Within the `onbuild-child` directory, create a file named `index.html`. This
    file will be copied to the Docker image by the `ONBUILD` command during build
    time:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onbuild-child`目录中，创建一个名为`index.html`的文件。这个文件将在构建时由`ONBUILD`命令复制到Docker镜像中：
- en: '[PRE145]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Now, open the `index.html` file using your favorite text editor:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`index.html`文件：
- en: '[PRE146]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Add the following content to the `index.html` file, save it, and exit from
    the `index.html` file:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`index.html`文件中，保存并退出`index.html`文件：
- en: '[PRE147]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: This is a simple HTML file that will output the `Learning Docker ONBUILD` directive
    as the header of the page.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的HTML文件，将在页面的标题中输出`Learning Docker ONBUILD`指令。
- en: 'Within the `onbuild-child` directory, create a file named `Dockerfile`:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onbuild-child`目录中，创建一个名为`Dockerfile`的文件：
- en: '[PRE148]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Now, open the `Dockerfile` using your favorite text editor:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`Dockerfile`：
- en: '[PRE149]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Add the following content to the `Dockerfile`, save it, and exit from the `Dockerfile`:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`Dockerfile`中，保存并退出`Dockerfile`：
- en: '[PRE150]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: This `Dockerfile` has only one directive. This will use the `FROM` directive
    to utilize the `onbuild-parent` Docker image that you created previously as the
    parent image.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Dockerfile`只有一个指令。它将使用`FROM`指令来利用您之前创建的`onbuild-parent` Docker镜像作为父镜像。
- en: 'Now, build the Docker image:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建Docker镜像：
- en: '[PRE151]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '![Figure 2.19: Building the onbuild-child Docker image'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.19：构建onbuild-child Docker镜像'
- en: '](image/B15021_02_19.jpg)'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_19.jpg)'
- en: 'Figure 2.19: Building the onbuild-child Docker image'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：构建onbuild-child Docker镜像
- en: 'Execute the `docker container run` command to start a new container from the
    Docker image that you built in the previous step:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`docker container run`命令，从上一步构建的Docker镜像启动一个新的容器：
- en: '[PRE152]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: In this command, you have started the Docker container from the `onbuild-child`
    Docker image while exposing port `80` of the container.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，您已经从`onbuild-child` Docker镜像启动了Docker容器，同时暴露了容器的端口`80`。
- en: 'You should be able to view the Apache home page. Go to the `http://127.0.0.1`
    endpoint from your favorite web browser:![Figure 2.20: Customized home page of
    the Apache web server'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该能够查看Apache首页。在您喜欢的网络浏览器中转到`http://127.0.0.1`端点：![图2.20：Apache web服务器的自定义首页
- en: '](image/B15021_02_20.jpg)'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_20.jpg)'
- en: 'Figure 2.20: Customized home page of the Apache web server'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20：Apache web服务器的自定义首页
- en: 'Now, clean up the container. First, stop the Docker container by using the
    `docker container stop` command:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，清理容器。首先使用`docker container stop`命令停止Docker容器：
- en: '[PRE153]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Finally, remove the Docker container with the `docker container rm` command:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`docker container rm`命令删除Docker容器：
- en: '[PRE154]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: In this exercise, we observed how we can use the `ONBUILD` directive to create
    a reusable Docker image that is capable of running any HTML file provided to it.
    We created the reusable Docker image named `onbuild-parent` with the Apache web
    server, with port `80` exposed. This `Dockerfile` contains the `ONBUILD` directive
    to copy the HTML files in the context of the Docker image. Then, we created the
    second Docker image named `onbuild-child`, using `onbuild-parent` as the base
    image, that provided a simple HTML file to be deployed to the Apache web server.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们观察到如何使用`ONBUILD`指令创建一个可重用的Docker镜像，能够运行提供给它的任何HTML文件。我们创建了名为`onbuild-parent`的可重用Docker镜像，其中包含Apache
    web服务器，并暴露了端口`80`。这个`Dockerfile`包含`ONBUILD`指令，用于将HTML文件复制到Docker镜像的上下文中。然后，我们使用`onbuild-parent`作为基础镜像创建了第二个Docker镜像，名为`onbuild-child`，它提供了一个简单的HTML文件，用于部署到Apache
    web服务器。
- en: Now, let's test our knowledge that we have acquired in this chapter by dockerizing
    the given PHP application using the Apache web server in the following activity.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在下面的活动中使用Apache web服务器来测试我们在本章中学到的知识，将给定的PHP应用程序进行docker化。
- en: 'Activity 2.01: Running a PHP Application on a Docker Container'
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动2.01：在Docker容器上运行PHP应用程序
- en: 'Imagine that you want to deploy a PHP welcome page that will greet visitors
    based on the date and time using the following logic. Your task is to dockerize
    the PHP application given here, using the Apache web server installed on an Ubuntu
    base image:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要部署一个PHP欢迎页面，根据日期和时间来问候访客，使用以下逻辑。您的任务是使用安装在Ubuntu基础镜像上的Apache web服务器，对这里给出的PHP应用程序进行docker化。
- en: '[PRE155]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'This is a simple PHP file that will greet the user based on the following logic:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的PHP文件，根据以下逻辑来问候用户：
- en: '![Figure 2.21: Logic of PHP application'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.21：PHP应用程序的逻辑'
- en: '](image/B15021_02_21.jpg)'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_02_21.jpg)'
- en: 'Figure 2.21: Logic of PHP application'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：PHP应用程序的逻辑
- en: 'Execute the following steps to complete this activity:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成这个活动：
- en: Create a folder to store the activity files.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件夹来存储活动文件。
- en: Create a `welcome.php` file with the code provided previously.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`welcome.php`文件，其中包含之前提供的代码。
- en: Create a `Dockerfile` and set up the application with PHP and Apache2 on an
    Ubuntu base image.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Dockerfile`，并在Ubuntu基础镜像上使用PHP和Apache2设置应用程序。
- en: Build and run the Docker image.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行Docker镜像。
- en: Once completed, stop and remove the Docker container.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，停止并删除Docker容器。
- en: Note
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor321).
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这项活动的解决方案可以通过[此链接](B15021_Solution_Final_SMP.xhtml#_idTextAnchor321)找到。
- en: Summary
  id: totrans-580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how we can use a `Dockerfile` to create our own
    custom Docker images. First, we discussed what is a `Dockerfile` and the syntax
    of a `Dockerfile`. We then discussed some common Docker directives, including
    the `FROM`, `LABEL`, `RUN`, `CMD`, and `ENTRYPOINT` directives. Then, we created
    our first `Dockerfile` with the common directives that we learned.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用`Dockerfile`来创建我们自己的自定义Docker镜像。首先，我们讨论了什么是`Dockerfile`以及`Dockerfile`的语法。然后，我们讨论了一些常见的Docker指令，包括`FROM`、`LABEL`、`RUN`、`CMD`和`ENTRYPOINT`指令。然后，我们使用我们学到的常见指令创建了我们的第一个`Dockerfile`。
- en: In the next section, we focused on building Docker images. We discussed multiple
    areas in depth regarding Docker images, including the layered filesystem of Docker
    images, the context in Docker builds, and the use of the cache during the Docker
    build process. Then, we discussed more advanced `Dockerfile` directives, including
    the `ENV`, `ARG`, `WORKDIR`, `COPY`, `ADD`, `USER`, `VOLUME`, `EXPOSE`, `HEALTHCHECK`,
    and `ONBUILD` directives.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们专注于构建Docker镜像。我们深入讨论了关于Docker镜像的多个方面，包括Docker镜像的分层文件系统，Docker构建中的上下文，以及在Docker构建过程中缓存的使用。然后，我们讨论了更高级的`Dockerfile`指令，包括`ENV`、`ARG`、`WORKDIR`、`COPY`、`ADD`、`USER`、`VOLUME`、`EXPOSE`、`HEALTHCHECK`和`ONBUILD`指令。
- en: In the next chapter, we will discuss what a Docker registry is, look at private
    and public Docker registries, and learn how we can publish Docker images to Docker registries.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Docker注册表是什么，看看私有和公共Docker注册表，并学习如何将Docker镜像发布到Docker注册表。
