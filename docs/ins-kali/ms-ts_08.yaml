- en: Chapter 8. Object-oriented Programming with TypeScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用TypeScript进行面向对象编程
- en: 'In 1995, the **Gang of Four** (**GoF**), published a book named *Design Patterns:
    Elements of Reusable Object-Oriented Software*. In it, the authors, Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides, describe a number of classic
    software design patterns. These patterns present simple and elegant solutions
    to common software problems. If you have never heard of design patterns such as
    the Factory pattern, Composite pattern, Observer pattern, or Singleton pattern,
    then going through this GoF book is highly recommended.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 1995年，**四人帮**（**GoF**）出版了一本名为*设计模式：可复用面向对象软件的元素*的书。在这本书中，作者Erich Gamma、Richard
    Helm、Ralph Johnson和John Vlissides描述了许多经典的软件设计模式。这些模式提供了常见软件问题的简单而优雅的解决方案。如果你从未听说过工厂模式、组合模式、观察者模式或单例模式等设计模式，那么强烈建议阅读这本GoF书籍。
- en: The Design patterns presented by the GoF have been reproduced in many different
    programming languages, including Java and C#. Mark Torok has even ported these
    patterns to TypeScript, and his GitHub repository can be found at [https://github.com/torokmark/design_patterns_in_typescript](https://github.com/torokmark/design_patterns_in_typescript).
    We have already explored one of these patterns, the Factory Design Pattern, in
    [Chapter 3](ch03.html "Chapter 3. Interfaces, Classes and Generics"), *Interfaces,
    Classes and Generics*, and Mark's work provides a quick and simple reference implementation
    of all of the GoF patterns in TypeScript.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: GoF提出的设计模式已经在许多不同的编程语言中复制，包括Java和C#。Mark Torok甚至将这些模式移植到了TypeScript中，他的GitHub存储库可以在[https://github.com/torokmark/design_patterns_in_typescript](https://github.com/torokmark/design_patterns_in_typescript)找到。我们已经在[第3章](ch03.html
    "第3章。接口、类和泛型")*接口、类和泛型*中探讨了其中的一个模式，即工厂设计模式，Mark的工作为TypeScript中的所有GoF模式提供了快速简单的参考实现。
- en: Simon Timms has also published a book called *Mastering JavaScript Design Patterns*,
    *Packt Publishing* ([https://www.packtpub.com/application-development/mastering-javascript-design-patterns](https://www.packtpub.com/application-development/mastering-javascript-design-patterns)),
    which walks the reader through each of these patterns, when to use them, and how
    to use them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Simon Timms还出版了一本名为*精通JavaScript设计模式*的书，*Packt Publishing*（[https://www.packtpub.com/application-development/mastering-javascript-design-patterns](https://www.packtpub.com/application-development/mastering-javascript-design-patterns)），该书为读者逐一介绍了这些模式，何时使用它们以及如何使用它们。
- en: In this chapter, we will not cover the standard GoF design patterns, but instead
    take a look at two other popular design patterns and how they can be implemented
    in TypeScript. We will discuss Dependency Injection using a Service Locator Pattern,
    and then see how these techniques can be used to build a Domain Event Pattern
    implementation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会涵盖标准的GoF设计模式，而是看一看另外两种流行的设计模式以及它们如何在TypeScript中实现。我们将讨论使用服务定位器模式进行依赖注入，然后看看这些技术如何用于构建领域事件模式的实现。
- en: Program to an interface
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按接口编程
- en: One of the primary notions that the GoF adhere to, is the idea that programmers
    should "program to an interface, and not an implementation". This means that programs
    are built using interfaces as the defined interaction between objects. By programming
    to an interface, client objects are unaware of the internal logic of their dependent
    objects, and are much more resilient to change.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 四人帮坚持的主要观念之一是，程序员应该“按接口编程，而不是按实现编程”。这意味着程序是使用接口作为对象之间定义的交互来构建的。通过按接口编程，客户对象不知道其依赖对象的内部逻辑，并且更具有抵抗变化的能力。
- en: The TypeScript language brings with it the `interface` keyword, allowing us
    to write object-oriented code against interfaces in a much easier way than with
    standard JavaScript. Remember, though, that interfaces are a TypeScript concept
    only, and are compiled away in the generated JavaScript.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript语言带来了`interface`关键字，使我们能够以比标准JavaScript更简单的方式针对接口编写面向对象的代码。不过，请记住，接口只是TypeScript的概念，会在生成的JavaScript中被编译掉。
- en: Note that many other languages have the concept of being able to interrogate
    an object to see which interfaces they implement, a process called **reflection**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，许多其他语言都有能够询问对象以查看它们实现了哪些接口的概念，这个过程称为**反射**。
- en: SOLID principles
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则
- en: 'An extension of the "program to an interface" principle, is what has been coined
    as SOLID design principles, based on the ideas of Robert Martin. This is an acronym
    for five different programming principles, and deserves a mention whenever object-oriented
    programming is discussed. Each of the letters in the word SOLID relate to an object-oriented
    principle, as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: “按接口编程”原则的延伸是所谓的SOLID设计原则，基于Robert Martin的思想。这是五个不同编程原则的首字母缩写，无论何时讨论面向对象编程，都值得一提。单词SOLID中的每个字母都与一个面向对象原则相关，如下所示：
- en: 'S: Single Responsibility'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S：单一职责
- en: 'O: Open Closed'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O：开闭原则
- en: 'L: Liskov Substitution'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L：里氏替换
- en: 'I: Interface Segregation'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I：接口隔离
- en: 'D: Dependency Inversion'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D：依赖反转
- en: Single Responsibility
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责
- en: The idea behind the Single Responsibility principle is that an object should
    have just a single responsibility, or a single reason to exist. In other words,
    do one thing and do it well. We have seen examples of this principle in the previous
    chapter, in our work with Backbone. A Backbone model class is used to represent
    a single model. A Backbone collection class is used to represent a collection
    of these models, and a Backbone view class is used to render models or collections.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则的理念是，一个对象应该只有一个职责，或者说只有一个存在的理由。换句话说，做一件事，并且做好。我们在上一章中已经看到了这个原则的例子，在我们使用Backbone时。Backbone模型类用于表示单个模型。Backbone集合类用于表示这些模型的集合，Backbone视图类用于渲染模型或集合。
- en: Open Closed
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开闭原则
- en: The idea behind the Open Closed principle states that an object should be open
    to extension, but closed for modification. In other words, once an interface has
    been designed for a class, changes that occur over time to this interface, should
    be implemented through inheritance, and not by modifying the interface directly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开闭原则的理念是，一个对象应该对扩展开放，但对修改关闭。换句话说，一旦为一个类设计了接口，随着时间的推移对这个接口的更改应该通过继承来实现，而不是直接修改接口。
- en: Note that if you are writing libraries that are consumed by third-parties via
    an API, then this principle is essential. Changes to an API should only be made
    through a new, versioned release, and should not break the existing API or interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您正在编写通过API由第三方使用的库，则此原则至关重要。对API的更改应仅通过新的、有版本的发布进行，并且不应破坏现有的API或接口。
- en: Liskov Substitution
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 里斯科夫替换
- en: The Liskov Substitution principle states that if one object is derived from
    another, then these objects can be substituted for each other without breaking
    functionality. While this principle seems fairly easy to implement, it can get
    pretty hairy when dealing with subtyping rules that relate to more complex types,
    such as lists of objects or actions on objects—which are most often found in code
    that works with generics. In these instances, the concept of variance is introduced,
    and objects can be either covariant, contravariant, or invariant. We will not
    discuss the finer points of variance here, but keep this principle in mind when
    writing libraries or code using generics.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 里斯科夫替换原则规定，如果一个对象是从另一个对象派生的，那么这些对象可以相互替换而不会破坏功能。虽然这个原则似乎很容易实现，但在处理与更复杂类型相关的子类型规则时，比如对象列表或对象上的操作时，情况可能会变得非常复杂——这些通常出现在使用泛型的代码中。在这些情况下，引入了变异的概念，对象可以是协变的、逆变的或不变的。我们不会在这里讨论变异的细节，但在编写库或使用泛型的代码时，请记住这个原则。
- en: Interface Segregation
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口分离
- en: The idea behind the Interface Segregation principle is that many interfaces
    are better than one general-purpose interface. If we tie this principle in with
    the Single Responsibility principle, we will start to look at our interfaces as
    smaller pieces of the puzzle, which will be put together to create broader application
    functionality.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接口分离原则的理念是，许多接口比一个通用接口更好。如果我们将这个原则与单一责任原则联系起来，我们将开始将我们的接口视为谜题的小部分，这些小部分将被组合在一起，以创建更广泛的应用程序功能。
- en: Dependency Inversion
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖反转
- en: The Dependency Inversion principle states that we should depend on abstractions
    (or interfaces) rather than instances of concrete objects. Again, this is the
    same principle as "program to an interface, and not an implementation".
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖反转原则规定，我们应该依赖于抽象（或接口），而不是具体对象的实例。同样，这与“根据接口而不是实现编程”的原则相同。
- en: Building a Service Locator
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建服务定位器
- en: The idea of the Service Location Pattern is that some areas of an application
    can be broken down into services. Each service should adhere to our SOLID design
    principles, and provide a small external interface that acts as a service API.
    Each service used by an application is then registered with a service locator.
    When a specific piece of information or functionality is required by the application,
    it can query this service locator to find the correct service, based on the service
    interface.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定位器模式的理念是，应用程序的某些区域可以被分解为服务。每个服务都应遵循我们的SOLID设计原则，并提供一个作为服务API的小外部接口。应用程序使用的每个服务都会在服务定位器中注册。当应用程序需要特定的信息或功能时，它可以查询这个服务定位器，以找到基于服务接口的正确服务。
- en: The problem space
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题空间
- en: In the previous chapter, we explored Backbone, where our application was broken
    down into models, collections, and views. Outside of these elements, we also had
    an application class to coordinate the loading of data via a collection, and the
    rendering of this collection using a view. Once our application classes were built,
    the last piece of the puzzle was putting together the `require.config` object,
    in order to coordinate the loading of our AMD modules, any HTML that we needed
    in our application, and our jQuery plugins.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了Backbone，我们的应用程序被分解为模型、集合和视图。除了这些元素之外，我们还有一个应用程序类来协调通过集合加载数据，并使用视图呈现此集合。一旦我们构建了应用程序类，谜题的最后一块就是组合`require.config`对象，以协调加载我们的AMD模块、应用程序中需要的任何HTML和我们的jQuery插件。
- en: 'If we have a look at a visual representation of which aspect of the application
    loaded which files, we come up with something that looks as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下应用程序加载哪些文件的视觉表示，我们会得到以下内容：
- en: '![The problem space](img/9665OS_08_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![问题空间](img/9665OS_08_01.jpg)'
- en: Application object dependency tree
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 应用对象依赖树
- en: We start at the top with an HTML page named `ContactViewApp.html`, which is
    the main entry page for our application, and which will be served up to the web
    browser. This HTML page then loads the Require library, which in turn loads our
    `AppConfig.ts` file containing the `require.config` section. This `require.config`
    section then instructs Require to load various scripts from the `/Scripts/` directory,
    as well as a snippet of HTML via the Text plugin. Once all files have been loaded
    by Require, the last portion of the `AppConfig.ts` file then loads the `ContactViewApp.ts`,
    which in turn loads our `ContactCollection.ts` and `ContactCollectionView.ts`
    files. These last two files then instruct Require to load the module files named
    `ContactModel.ts` and `ContactItemView.ts` respectively.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个名为`ContactViewApp.html`的HTML页面开始，这是我们应用程序的主入口页面，将提供给Web浏览器。然后这个HTML页面加载Require库，Require库又加载包含`require.config`部分的`AppConfig.ts`文件。然后`require.config`部分指示Require从`/Scripts/`目录加载各种脚本，以及通过Text插件加载一小段HTML。一旦Require加载了所有文件，`AppConfig.ts`文件的最后一部分加载`ContactViewApp.ts`，然后加载我们的`ContactCollection.ts`和`ContactCollectionView.ts`文件。然后这两个文件指示Require分别加载名为`ContactModel.ts`和`ContactItemView.ts`的模块文件。
- en: If we take a closer look at this hierarchy, it is quite feasible to imagine
    that in a large application, we would have a large amount of collections, models,
    views, and item views. It may be that we are loading collections of collections,
    and views containing sub-views that contain further sub-views. Each of these views
    will require some HTML to be loaded via the Text plugin, in order to use our template
    mechanism.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更仔细地看一下这个层次结构，很容易想象在一个大型应用程序中，我们会有大量的集合、模型、视图和项目视图。可能我们正在加载集合的集合，以及包含子视图的视图，其中包含进一步的子视图。每个这些视图都需要通过文本插件加载一些HTML，以使用我们的模板机制。
- en: 'Let''s take a closer look at how we loaded and used an HTML snippet in our
    previous example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下在我们之前的例子中如何加载和使用HTML片段：
- en: '![The problem space](img/9665OS_08_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![问题空间](img/9665OS_08_02.jpg)'
- en: Dependency tree with usage of global variable
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局变量的依赖树
- en: In this diagram, we can see that we loaded an HTML snippet via the Text plugin,
    within the `AppConfig.ts` file, and then stored it into a global variable named
    `CONTACT_ITEM_SNIPPET`. The only code that used this global variable was the `ContactItemView`
    class itself.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们可以看到我们通过文本插件在`AppConfig.ts`文件中加载了一个HTML片段，然后将其存储到名为`CONTACT_ITEM_SNIPPET`的全局变量中。唯一使用这个全局变量的代码是`ContactItemView`类本身。
- en: Using a global variable breaks our Dependency Inversion principle, in that we
    are programming to a concrete instance of a global variable, instead of an interface.
    This global variable can also be inadvertently changed by any running code, which
    may cause our views to stop functioning. Another problem that we faced when running
    our test suite, was that changing the original HTML template broke some of our
    unit tests. While we were able to modify the tests slightly in order to pass,
    this broken test highlighted that we had broken the Open Closed principle somewhere
    along the line.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局变量违反了我们的依赖反转原则，因为我们在编程时针对一个全局变量的具体实例，而不是一个接口。这个全局变量也可能被任何正在运行的代码无意中改变，这可能导致我们的视图停止工作。当运行我们的测试套件时，我们遇到的另一个问题是，更改原始的HTML模板会破坏一些单元测试。虽然我们能够稍微修改测试以通过，但这个破损的测试突显出我们在某个地方违反了开闭原则。
- en: Creating a Service
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个服务
- en: We will solve the problem of using a global variable to store HTML snippets
    in two parts.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两部分解决使用全局变量存储HTML片段的问题。
- en: 'Firstly, let''s define a service to replace our global variables—a `SnippetService`.
    This service will have a very simple interface, and will be only responsible for
    two things: storing an HTML snippet and retrieving an HTML snippet.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个服务来替换我们的全局变量 - `SnippetService`。这个服务将有一个非常简单的接口，只负责两件事：存储HTML片段和检索HTML片段。
- en: Secondly, we need a mechanism to get hold of this `SnippetService`, both at
    the point in our code where we store the snippet (in `AppConfig.ts)`, and also
    at the point where we use the snippet (in `ContactItemView.ts)`. We will use a
    Service Locator at both of these touch-points a bit later, but for now, let's
    flesh out a design for our snippet service.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要一种机制来获取这个`SnippetService`，在我们存储片段的代码点（在`AppConfig.ts`中）和使用片段的代码点（在`ContactItemView.ts`中）。我们稍后将在这两个接触点使用服务定位器，但现在，让我们为我们的片段服务设计一个设计。
- en: 'Introducing a `SnippetService` changes our dependency diagram as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 引入`SnippetService`会改变我们的依赖图如下：
- en: '![Creating a Service](img/9665OS_08_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个服务](img/9665OS_08_03.jpg)'
- en: Dependency tree using a service to store HTML snippets
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务存储HTML片段的依赖树
- en: We can see that we have now abstracted away the use of our global variable.
    We still have a global area to store these HTML snippets, i.e. the Snippet Storage
    area, but we are now programming against an interface—that the `SnippetService`
    provides—and not against a concrete implementation. Our application is now guarded
    against any changes to the internal storage of these HTML snippets. As an example,
    we may decide to change our implementation from using HTML files, to storing HTML
    snippets in a database. In this case, only the internals of the `SnippetService`
    would need to be modified, and our code could carry on without needing to be changed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们现在已经抽象出了对全局变量的使用。我们仍然有一个全局区域来存储这些HTML片段，即片段存储区，但我们现在是针对一个接口编程 - `SnippetService`提供的接口，而不是针对一个具体的实现。我们的应用程序现在受到了对这些HTML片段的内部存储的任何更改的保护。例如，我们可能决定从使用HTML文件改为在数据库中存储HTML片段。在这种情况下，只需要修改`SnippetService`的内部，我们的代码就可以继续运行而无需更改。
- en: Obviously, we will need some sort of key to allow us to store more than one
    snippet, but should the `SnippetService` be responsible for defining this key
    or not? Think Single Responsibility. Is the `SnippetService` really responsible
    for managing the keys that relate to the snippets? In other words, does it need
    to add or remove these keys? Not really. A smaller enum class would prove quite
    useful here, and favors numerous smaller interfaces over one general-purpose interface
    – think Interface Segregation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要一种键来允许我们存储多个片段，但`SnippetService`是否应该负责定义这个键呢？考虑单一职责原则。`SnippetService`是否真的负责管理与片段相关的键？换句话说，它需要添加或删除这些键吗？并不是真的。一个更小的枚举类在这里会非常有用，并且更倾向于许多较小的接口而不是一个通用接口
    - 考虑接口隔离。
- en: 'With these things in mind, we can define the interface for our `SnippetService`
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些事情，我们可以定义`SnippetService`的接口如下：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Firstly, we define an `enum` named `SnippetKey` to store all the keys to be
    used by the `SnippetService`. Secondly, we define the interface for the actual
    `SnippetService`, named `ISnippetService`, which has two functions. The first
    function will be a method to store a snippet, and is named `storeSnippet`. This
    function has two arguments, the first being a `SnippetKey` enum value, and the
    second argument is, of course, the HTML snippet itself. Similarly, the second
    function, named `retrieveSnippet` uses a single `SnippetKey` argument to retrieve
    the HTML snippet.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个名为`SnippetKey`的`enum`，用于存储`SnippetService`要使用的所有键。其次，我们定义了实际`SnippetService`的接口，名为`ISnippetService`，它有两个函数。第一个函数将是一个存储片段的方法，名为`storeSnippet`。这个函数有两个参数，第一个是`SnippetKey`枚举值，第二个参数当然是HTML片段本身。类似地，第二个函数，名为`retrieveSnippet`，使用一个`SnippetKey`参数来检索HTML片段。
- en: 'Now that we have defined an interface, we can create the structure of our `SnippetService`
    class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个接口，我们可以创建`SnippetService`类的结构：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we have a class named `SnippetService` that implements our `ISnippetService`
    interface. We have created the two methods defined in the interface, but have
    not yet provided an implementation. We will use this opportunity to follow TDD
    principles and write a failing unit test before writing the code that makes the
    tests pass. Our unit test is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为`SnippetService`的类，它实现了我们的`ISnippetService`接口。我们已经创建了接口中定义的两个方法，但尚未提供实现。我们将利用这个机会遵循TDD原则，在编写使测试通过的代码之前编写一个失败的单元测试。我们的单元测试如下：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this test, we simply create an instance of the `SnippetService`, store a
    snippet with the key of `SnippetKey.CONTACT_ITEM_SNIPPET`, and then call `retrieveSnippet`
    with the same key, verifying the string value returned. Bear in mind that this
    is a simulated test, and in the real application, the `storeSnippet` call will
    occur during application initialization, and the `retrieveSnippet` call will occur
    at a later stage.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们只是创建了一个`SnippetService`的实例，使用`SnippetKey.CONTACT_ITEM_SNIPPET`作为键存储了一个片段，然后使用相同的键调用`retrieveSnippet`，验证返回的字符串值。请记住，这是一个模拟测试，在真实应用中，`storeSnippet`调用将在应用初始化期间发生，而`retrieveSnippet`调用将在稍后的阶段发生。
- en: 'Let''s now flesh out the `SnippetService` so that the tests pass:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们完善`SnippetService`，使测试通过：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our `SnippetService` class now has an internal array of strings named `snippetArray`,
    marked as `private`, which will hold our HTML snippet values. Our `storeSnippet`
    and `retrieveSnippet` functions are now simply storing or retrieving values from
    this array. With this code in place, our test will now pass and our simple `SnippetService`
    is complete.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SnippetService`类现在有一个名为`snippetArray`的内部字符串数组，标记为`private`，它将保存我们的HTML片段值。我们的`storeSnippet`和`retrieveSnippet`函数现在只是简单地从这个数组中存储或检索值。有了这段代码，我们的测试现在将通过，我们简单的`SnippetService`完成了。
- en: Dependency Resolution
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖解析
- en: 'Thus far, we have refactored our code to be dependent on an interface instead
    of a concrete object. This is all well and good, but begs the question: "how do
    we get hold of an interface?" – or more correctly – "how do we get hold of the
    concrete class that is currently implementing this interface?". This is the essential
    question that Dependency Injectors seek to answer.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经重构了我们的代码，使其依赖于接口而不是具体对象。这一切都很好，但引出了一个问题：“我们如何获得一个接口？”- 或者更正确地说 - “我们如何获得当前实现这个接口的具体类？”这是依赖注入器试图回答的基本问题。
- en: There are a number of different ways in which a class can get hold of another
    class that implements an interface.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以获得实现接口的另一个类的方式有很多种。
- en: Service Location
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务定位
- en: If the class itself requests a concrete object based on an interface, then this
    process is called "**Service Location**". In other words, the class is using a
    registry or helper to locate the service it requires. You could also describe
    this technique as "dependency requesting". A central registry holds a lookup table
    with all registered classes against their respective interfaces. When the interface
    is requested, the Service locator simply looks up what class instance is stored
    against the interface in its table, and returns the object from its registry.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类本身根据接口请求一个具体对象，那么这个过程称为“**服务定位**”。换句话说，类使用注册表或助手来定位它需要的服务。您还可以将这种技术描述为“依赖请求”。一个中央注册表保存了所有已注册类与它们各自接口的查找表。当接口被请求时，服务定位器简单地查找其表中存储的接口对应的类实例，并从其注册表返回对象。
- en: Dependency Injection
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: If the act of creating an instance of a class can be handed over to some sort
    of framework, then this framework can work out what interfaces a class needs,
    and "inject" these dependencies during class instantiation. This injection of
    dependencies is also called **assembly**. In this case, an assembler class or
    framework would need to be able to query an object to find out what interfaces
    it is dependent on. Unfortunately, we do not have this ability in JavaScript or
    TypeScript, as all interfaces are compiled away. So, we cannot use TypeScript
    interfaces by themselves to implement dependency injection. If we were to implement
    dependency injection in TypeScript or JavaScript, we would need some sort of naming
    convention to flag to the assembler framework that we need a concrete object to
    replace an interface.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建类的实例的行为可以交给某种框架处理，那么这个框架可以找出类需要什么接口，并在类实例化期间“注入”这些依赖关系。这种依赖注入也称为**装配**。在这种情况下，装配器类或框架需要能够查询对象以找出它依赖的接口。不幸的是，在JavaScript或TypeScript中我们没有这种能力，因为所有接口都被编译掉了。因此，我们不能单独使用TypeScript接口来实现依赖注入。如果我们要在TypeScript或JavaScript中实现依赖注入，我们需要一种命名约定来告诉装配器框架我们需要一个具体对象来替换接口。
- en: Dependency Injection is also referred to as Inversion of Control—as we are handing
    over control of creation of our classes, and the resolution of their dependencies—to
    a third party. By the time we receive an instance of our class, all of the services
    or dependencies have been "magically" filled in.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入也被称为控制反转，因为我们把类的创建和依赖项的解析控制权交给了第三方。当我们收到类的实例时，所有的服务或依赖项都已经被“神奇”地填充进去了。
- en: Service Location versus Dependency Injection
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务定位与依赖注入
- en: The ideas around the Service Location pattern were first introduced by Martin
    Fowler around 2004, in a blog titled *Inversion of Control Containers and the
    Dependency Injection pattern* ([http://martinfowler.com/articles/injection.html](http://martinfowler.com/articles/injection.html)).
    However, in his book, *Dependency Injection in .NET*, Mark Seeman argues that
    the Service Location pattern is in fact an anti-pattern.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定位模式的想法最早是由马丁·福勒在2004年左右提出的，在一篇名为《控制反转容器和依赖注入模式》的博客中（[http://martinfowler.com/articles/injection.html](http://martinfowler.com/articles/injection.html)）。然而，在他的书《.NET中的依赖注入》中，马克·西曼认为服务定位模式实际上是一种反模式。
- en: Mark's take on Martin's original ideas are that it is too easy to introduce
    runtime errors, or to misunderstand the usage of a particular class, when Service
    Location is used. This is because figuring out what services a class uses, means
    reading through the entire class. He argues that a better way of using Dependency
    Injection, is to list all dependencies in the constructor function of a class,
    and let the service locator resolve each dependency, during class constructon.
    Most of Mark's examples seem to revolve around building and using APIs, where
    internals of a particular class cannot simply be read from the code, and using
    a class without knowing what services it depends on, can easily cause runtime
    errors.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 马克对马丁最初的想法是，使用服务定位很容易引入运行时错误，或者误解特定类的使用。这是因为找出一个类使用了哪些服务意味着要阅读整个类。他认为更好的使用依赖注入的方法是，在类的构造函数中列出所有的依赖项，并让服务定位器在类构造过程中解析每个依赖项。马克的大部分例子似乎都围绕着构建和使用API，其中特定类的内部不能简单地从代码中读取，并且在不知道一个类依赖于哪些服务的情况下使用一个类很容易引起运行时错误。
- en: While his ideas do certainly hold true, the solutions to this problem are all
    relevant to the .NET language—which has a key language feature that is unavailable
    in JavaScript— called Reflection. Reflection is the ability of a program—at runtime—to
    interrogate an object for information about itself, such as what properties it
    has, and what interfaces it implements or expects. Even though TypeScript provides
    the interface keyword, and does compile-time checking on these interfaces, all
    interfaces are compiled away in the resultant JavaScript.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管他的想法确实是正确的，但是解决这个问题的方法都与.NET语言相关，而这在JavaScript中是不可用的，这就是反射。反射是程序在运行时询问对象自身信息的能力，比如它有哪些属性，它实现或期望实现哪些接口。尽管TypeScript提供了接口关键字，并对这些接口进行了编译时检查，但所有接口都在生成的JavaScript中被编译掉了。
- en: This provides us with a serious problem. If a class is dependent on an interface,
    we cannot use this interface at runtime to look up the concrete implementation
    for the interface—because at runtime, this interface simply does not exist.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了一个严重的问题。如果一个类依赖于一个接口，我们不能在运行时使用这个接口来查找接口的具体实现，因为在运行时，这个接口根本不存在。
- en: Angular uses a naming convention (a `$` prefix) to provide dependency injection
    capabilities. This has been rather successful, although there are caveats and
    some work-arounds when using minification routines. Angular 2.0 also solves this
    problem by providing a custom syntax to denote places where dependencies need
    to be injected. Other JavaScript frameworks—such as ExtJs—provide a mechanism
    to create objects by using a global creation routine, which then allows the framework
    to inject dependencies. This ExtJs technique, unfortunately, is not very compatible
    with the TypeScript language syntax (see [Chapter 5](ch05.html "Chapter 5. Third
    Party Libraries"), *Third Party Libraries* where we discuss ExtJs).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用命名约定（以`$`前缀）来提供依赖注入功能。这已经相当成功，尽管在使用缩小程序时会有一些注意事项和一些解决方法。Angular 2.0也通过提供自定义语法来解决这个问题，以表示需要注入依赖项的位置。其他JavaScript框架，如ExtJs，提供了使用全局创建例程来创建对象的机制，然后允许框架注入依赖项。不幸的是，这种ExtJs技术与TypeScript语法不太兼容（参见[第5章](ch05.html
    "第5章. 第三方库")，“第三方库”中我们讨论了ExtJs）。
- en: Also, if we are not using Angular, Angular 2.0, ExtJs, or any other framework,
    then Dependency Injection is just slightly out of reach in standard JavaScript.
    Service Location, on the other hand, can be accomplished, and combined with TypeScript
    interfaces, can bring us all of the benefits of dependency resolution and therefore,
    modular programming.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们不使用Angular、Angular 2.0、ExtJs或任何其他框架，那么在标准JavaScript中依赖注入就略微超出了我们的能力。另一方面，服务定位是可以实现的，并且结合TypeScript接口，可以为我们带来依赖项解析的所有好处，因此也可以实现模块化编程。
- en: We can also make a compromise in order to incorporate the ideas that Mark suggests—and
    limit our Service Location to object constructors. When writing libraries that
    use Service Location, we would need to clearly document what dependencies a particular
    class has—and how they need to be registered. Even popular .NET Dependency injection
    frameworks such as StructureMap still allow for Service Location techniques—although
    they are being deprecated.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以做出妥协，以纳入马克建议的想法，并将我们的服务定位限制在对象构造函数中。在编写使用服务定位的库时，我们需要清楚地记录特定类有哪些依赖项，以及它们需要如何注册。即使像StructureMap这样的流行.NET依赖注入框架仍然允许使用服务定位技术，尽管它们正在被弃用。
- en: For the purposes of this book, then, let's explore how to write a simple Service
    Locator and use it in our code to build a more modular application, and leave
    the argument about pattern versus anti-pattern to those languages that have the
    features to implement Dependency Injection naturally.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了本书的目的，让我们探讨如何编写一个简单的服务定位器，并在我们的代码中使用它来构建一个更模块化的应用程序，并将模式与反模式的论点留给那些具有自然实现依赖注入功能的语言。
- en: A Service Locator
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个服务定位器
- en: 'Let''s get back to the crux of our problem: given an interface, how do we obtain
    a concrete implementation of a class that is currently implementing it?'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们问题的核心：给定一个接口，我们如何获得当前实现它的类的具体实现？
- en: In [Chapter 3](ch03.html "Chapter 3. Interfaces, Classes and Generics"), *Interfaces,
    Classes and Generics*, we wrote a generic class named `InterfaceChecker` that
    did a runtime evaluation of a class, to check whether it implemented a specific
    set of methods and properties. The basic idea behind this `InterfaceChecker` was
    that if we provided a metadata class that listed the expected properties and methods
    of an interface, we could then interrogate a class at runtime against this metadata.
    If the class had all of the required properties and methods, then it was said
    to implement the interface.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html“第3章。接口，类和泛型”), *接口，类和泛型*，我们编写了一个名为`InterfaceChecker`的通用类，它对类进行了运行时评估，以检查它是否实现了一组特定的方法和属性。这个`InterfaceChecker`背后的基本思想是，如果我们提供了一个列出了接口的预期属性和方法的元数据类，我们就可以在运行时根据这些元数据来查询一个类。如果类具有所有必需的属性和方法，那么就说它实现了这个接口。
- en: 'So, we now have a mechanism—at runtime—to ensure that a class implements an
    interface: not a TypeScript interface, mind you, but a metadata-defined interface.
    If we extend this idea, and give each of our metadata interfaces a unique name,
    we have the concept of a "named interface". As long as these interface names are
    unique across our application, we now have a mechanism to query a class—at runtime—and
    see whether it implements a named interface.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有了一个机制——在运行时——来确保一个类实现了一个接口：注意，不是TypeScript接口，而是元数据定义的接口。如果我们扩展这个想法，并为我们的每个元数据接口提供一个唯一的名称，我们就有了“命名接口”的概念。只要这些接口名称在我们的应用程序中是唯一的，我们现在就有了一个在运行时查询一个类是否实现了命名接口的机制。
- en: If a class implements a named interface, we can then use a registry to store
    an instance of this class against its named interface. Any other code that needs
    an instance of a class that is implementing this named interface, simply has to
    query the registry, supply the interface name, and the registry will be able to
    return the class instance.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类实现了一个命名接口，我们可以使用注册表来存储该类的实例与其命名接口。任何需要实现这个命名接口的类实例的其他代码，只需查询注册表，提供接口名称，注册表就能返回类实例。
- en: As long as we ensure that our TypeScript interfaces match the named interface
    definitions, we are all good to go.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们确保我们的TypeScript接口与命名接口定义匹配，我们就可以开始了。
- en: Named interfaces
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名接口
- en: 'Back in [Chapter 3](ch03.html "Chapter 3. Interfaces, Classes and Generics"),
    *Interfaces, Classes and Generics*, we wrote an interface named `IInterfaceChecker`
    that we could use as a standard template for our metadata. Let''s update this
    interface and give it a required `className` property—so that we can use it as
    a named interface:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第3章](ch03.html“第3章。接口，类和泛型”), *接口，类和泛型*，我们编写了一个名为`IInterfaceChecker`的接口，我们可以将其用作元数据的标准模板。让我们更新这个接口，并给它一个必需的`className`属性，这样我们就可以将其用作命名接口：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We still have the optional arrays of `methodNames` and `propertyNames`, but
    now every class that implements this interface will also require a `className`
    property.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有可选的`methodNames`和`propertyNames`数组，但现在每个实现这个接口的类也将需要一个`className`属性。
- en: 'So, given the following TypeScript interface:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到以下TypeScript接口：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our named interface metadata class to match this TypeScript interface would
    look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的命名接口元数据类匹配这个TypeScript接口将如下所示：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This `IHasIdProperty` interface has a single property named `id`, which is of
    type `number`. We then create a class named `IIHasIdProperty` to act as a named
    interface definition. This class implements our updated `IInterfaceChecker` interface
    and must, therefore, provide a `className` property. The `propertyNames` property
    has a single array entry named `id`, and will be used by our `InterfaceChecker`
    class to match against the `id` property of our TypeScript interface.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`IHasIdProperty`接口有一个名为`id`的属性，类型为`number`。然后我们创建一个名为`IIHasIdProperty`的类，作为一个命名接口定义。这个类实现了我们更新的`IInterfaceChecker`接口，因此必须提供一个`className`属性。`propertyNames`属性有一个名为`id`的单个数组条目，并将被我们的`InterfaceChecker`类用来与我们的TypeScript接口的`id`属性进行匹配。
- en: Note the naming convention of this class—it is the same name as the interface
    but adds an extra `I`. This double `I` convention will help us to tie the TypeScript
    interface named `IHasIdProperty` with its `IIHasIdProperty` metadata named interface
    class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个类的命名约定——它与接口的名称相同，但添加了额外的`I`。这个双`I`约定将帮助我们将TypeScript接口命名为`IHasIdProperty`与其`IIHasIdProperty`元数据命名接口类联系起来。
- en: 'We can now create a normal TypeScript class that implements the `IHasIdProperty`
    TypeScript interface as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个正常的TypeScript类，实现`IHasIdProperty`TypeScript接口，如下所示：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We now have all of the pieces in place to start building a Service Locator:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了所有的要素来开始构建一个服务定位器：
- en: A TypeScript interface named `IHasIdProperty`. This will provide compile-time
    type checking against a class implementing this interface.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`IHasIdProperty`的TypeScript接口。这将提供对实现这个接口的类的编译时类型检查。
- en: A named interface or metadata class called `IIHasIdProperty`. This will provide
    runtime type checking against a class, and it also has a unique name.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`IIHasIdProperty`的命名接口或元数据类。这将提供对类的运行时类型检查，并且还有一个唯一的名称。
- en: A class that implements the TypeScript interface `IHasIdProperty`. This class
    will pass the runtime type checks, and an instance of this class can be registered
    with our Service Locator.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实现了TypeScript接口`IHasIdProperty`的类。这个类将通过运行时类型检查，并且这个类的实例可以被注册到我们的服务定位器中。
- en: Registering classes against named interfaces
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册类与命名接口对应
- en: 'With these metadata classes in place, we can now create a central repository
    to act as a Service Locator. This class has static functions for registering classes,
    as well as resolving interfaces:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些元数据类，我们现在可以创建一个中央存储库，作为服务定位器。这个类有用于注册类以及解析接口的静态函数：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This class, named `TypeScriptTinyIoC`, has a single static property named `registeredClasses`,
    which is an array of type `any`. This array is essentially our registry. As we
    do not know what type of class we are going to store in this array, the use of
    the `any` type in this instance is correct.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为`TypeScriptTinyIoC`的类有一个名为`registeredClasses`的静态属性，它是一个`any`类型的数组。这个数组本质上是我们的注册表。由于我们不知道要在这个数组中存储什么类型的类，所以在这种情况下使用`any`类型是正确的。
- en: This class then provides two primary static functions, named `register` and
    `resolve`. The `register` function takes a `targetObject` as its first parameter,
    and then a class definition of a named interface—i.e. a class derived from `IInterfaceChecker`.
    Note the syntax of the `targetInterface` argument—it is the same as the generic
    syntax that we used in [Chapter 3](ch03.html "Chapter 3. Interfaces, Classes and
    Generics"), *Interfaces, Classes and Generics,* to denote a class definition.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了两个主要的静态函数，名为`register`和`resolve`。`register`函数以`targetObject`作为第一个参数，然后是一个命名接口的类定义，即从`IInterfaceChecker`派生的类。注意`targetInterface`参数的语法，它与我们在[第3章](ch03.html
    "第3章.接口、类和泛型")中使用的泛型语法相同，用于表示类定义。
- en: 'It is actually easier to understand these function signatures if we take a
    look at an example of their usage, so let''s write a quick test:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下它们的使用示例，就更容易理解这些函数签名，所以让我们写一个快速测试：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This test first creates an instance of the `PropertyOne` class, which implements
    the `IHasIdProperty` interface. This class is the one that we would like to register.
    The test then calls the register function of `TypeScriptTinyIoC` with two parameters.
    The first parameter is the class instance itself, and the second parameter is
    the class definition for the associated named interface—`IIHasIdProperty`. We
    have seen this type of syntax before, when we discussed creating instances of
    classes using generics, but its signature is also available on nongeneric functions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试首先创建了一个`PropertyOne`类的实例，该类实现了`IHasIdProperty`接口。这个类是我们想要注册的类。然后测试调用`TypeScriptTinyIoC`的`register`函数，有两个参数。第一个参数是类实例本身，第二个参数是与命名接口`IIHasIdProperty`相关的类定义。我们之前已经见过这种语法，当我们讨论使用泛型创建类的实例时，但它的签名也适用于非泛型函数。
- en: 'Without using the `targetInterface: { new (): IInterfaceChecker; }` signature,
    we would have to call this function as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '如果不使用`targetInterface: { new (): IInterfaceChecker; }`的签名，我们将不得不如下调用这个函数：'
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But with this signature in place, we can defer the creation of the `IIHasIdProperty`
    named interface class to the register function—and drop the new syntax as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有了这个签名，我们可以将`IIHasIdProperty`命名接口类的创建推迟到`register`函数中，并且可以删除如下的新语法：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our test then calls the `resolve` function on `TypeScriptTinyIoC`, and again
    passes the class definition of our named interface as the lookup key. Finally,
    we check whether the class that is returned is in fact an instance of the `PropertyOne`
    class that we registered initially.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的测试调用`TypeScriptTinyIoC`的`resolve`函数，并再次传入我们命名接口的类定义作为查找键。最后，我们检查返回的类是否实际上是我们最初注册的`PropertyOne`类的实例。
- en: 'At this stage, our test will fail dramatically, so let''s flesh out the `TypeScriptTinyIoC`
    class, starting with the `register` function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的测试将会失败，所以让我们完善`TypeScriptTinyIoC`类，从`register`函数开始：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This `register` function firstly creates an instance of the `InterfaceChecker`
    class, and then creates an instance of the class definition passed in, through
    the `targetInterface` argument. This `targetInterface` is the named interface
    or metadata class. We then call the `implementsInterface` function of `interfaceChecker`
    to ensure that the `targetObject` implements the interface described by `targetInterface`.
    If it passes this check, we then add it to our internal array named `registeredClasses`,
    using the `className` property as a key.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`register`函数首先创建了一个`InterfaceChecker`类的实例，然后通过`targetInterface`参数创建了传入的类定义的实例。这个`targetInterface`是命名接口或元数据类。然后我们调用`interfaceChecker`的`implementsInterface`函数来确保`targetObject`实现了`targetInterface`描述的接口。如果通过了这个检查，我们就使用`className`属性作为键将其添加到我们的内部数组`registeredClasses`中。
- en: Again, using our `InterfaceChecker` gives us runtime type checking—so that we
    can be sure that any class we are registering does in fact implement the correct
    named interface.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用我们的`InterfaceChecker`给我们提供了运行时类型检查，这样我们就可以确保我们注册的任何类实际上都实现了正确的命名接口。
- en: 'Now we can flesh out the `resolve` function as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以如下完善`resolve`函数：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This `resolve` function only has one parameter—the definition of our named interface.
    Again, we are using the `new`–able syntax that we have seen previously. This function
    simply creates an instance of the `targetInterface` class, and then uses the `className`
    property as the key into the `registeredClasses` array. If an entry is found,
    we simply return it; otherwise, we throw an error.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`resolve`函数只有一个参数，即我们命名接口的定义。同样，我们使用了之前见过的可实例化的语法。这个函数简单地创建了`targetInterface`类的一个实例，然后使用`className`属性作为`registeredClasses`数组的键。如果找到了条目，我们就简单地返回它；否则，我们抛出一个错误。
- en: 'The final function on our `TypeScriptTinyIoC` class is the `clearAll` function,
    and it is used primarily in testing to clear out our registered classes array:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`TypeScriptTinyIoC`类上的最后一个函数是`clearAll`函数，它主要用于测试，用于清除我们的注册类数组：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our service locator is now complete.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务定位器现在已经完成。
- en: Using the Service Locator
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用服务定位器
- en: 'Let''s now update our dependency tree to see how the `TypeScriptTinyIoC` service
    locator would be used:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新我们的依赖树，看看`TypeScriptTinyIoC`服务定位器将如何被使用：
- en: '![Using the Service Locator](img/9665OS_08_04.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![使用服务定位器](img/9665OS_08_04.jpg)'
- en: Dependency diagram with a service locator pattern
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 带有服务定位器模式的依赖图
- en: Our `AppConfig.ts` code will now create an instance of the `SnippetService`,
    and register it with `TypeScriptTinyIoC` using a named interface—`IISnippetService`.
    Our `ContactItemView` constructor will then be updated to resolve an instance
    of the `IISnippetService` named interface from the registry. In this way, we are
    now programming to an interface—the `IISnippetService` interface. We use this
    named interface when we register our service with the service locator, and again
    when we resolve the service later on. Our `ContactItemView`, then, is asking the
    service locator to give us the current object that is implementing the `IISnippetService`
    interface.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`AppConfig.ts`代码现在将创建一个`SnippetService`的实例，并使用命名接口`IISnippetService`将其注册到`TypeScriptTinyIoC`中。然后我们将更新`ContactItemView`的构造函数，以从注册表中解析`IISnippetService`的实例。这样，我们现在是编程到一个接口——`IISnippetService`接口。我们在注册服务到服务定位器时使用这个命名接口，以及在以后解析服务时再次使用。然后，我们的`ContactItemView`要求服务定位器给我们实现`IISnippetService`接口的当前对象。
- en: 'To implement this change, we will firstly need a named interface to match the
    `ISnippetService` TypeScript interface. As a refresher, our `ISnippetService`
    was defined as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个改变，我们首先需要一个命名接口来匹配`ISnippetService` TypeScript接口。作为一个复习，我们的`ISnippetService`定义如下：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using our naming rules, our named interface definition would be called `IISnippetService`
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的命名规则，我们的命名接口定义将被称为`IISnippetService`，如下所示：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note how the `methodNames` array contains two entries that match our TypeScript
    interface. By convention, we have also specified a `className` property, so that
    we can use this class as a named interface. Using the name of the class (`IISnippetService`)
    as the `className` property will also ensure a unique name, as TypeScript will
    not allow multiple class definitions with the same name.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`methodNames`数组包含两个与我们的TypeScript接口匹配的条目。按照惯例，我们还指定了一个`className`属性，这样我们就可以将这个类用作命名接口。使用类的名称（`IISnippetService`）作为`className`属性也将确保一个唯一的名称，因为TypeScript不允许使用相同名称定义多个类。
- en: Let's now focus on our test suite. Remember that our `TestConfig.ts` file is
    almost identical to our `AppConfig.ts` file, but starts the Jasmine test suite
    instead of running our app. We will modify this `TestConfig.ts` file to include
    our `SnippetService` and `TypeScriptTinyIoC` as follows.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们专注于我们的测试套件。记住我们的`TestConfig.ts`文件几乎与我们的`AppConfig.ts`文件相同，但是它启动了Jasmine测试套件而不是运行我们的应用程序。我们将修改这个`TestConfig.ts`文件，包括我们的`SnippetService`和`TypeScriptTinyIoC`，如下所示。
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Firstly, we have included an entry for `tinyioc` and `snippetservice` in our
    paths property, to ensure that Require will load our files from the specified
    directory. We then update the call to the require function to include both the
    `tinyioc` and `snippetservice` in both of the arguments. Our anonymous function
    then creates a new instance of the `SnippetService` and stores the snippet that
    is loaded by Text, using the `CONTACT_ITEM_SNIPPET` key. We then register the
    instance of this `SnippetService` with `TypeScriptTinyIoC` using the named interface
    `IISnippetService`. If we run our test suite now, we should get a few failing
    tests:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在路径属性中包含了对`tinyioc`和`snippetservice`的条目，以确保Require会从指定目录加载我们的文件。然后我们更新对require函数的调用，将`tinyioc`和`snippetservice`都包含在两个参数中。我们的匿名函数然后创建了`SnippetService`的一个新实例，并使用`CONTACT_ITEM_SNIPPET`键存储由Text加载的片段。然后我们使用命名接口`IISnippetService`将这个`SnippetService`的实例注册到`TypeScriptTinyIoC`中。如果我们现在运行测试套件，应该会有一些失败的测试：
- en: '![Using the Service Locator](img/9665OS_08_05.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![使用服务定位器](img/9665OS_08_05.jpg)'
- en: Unit test failures
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试失败
- en: 'This failure is caused because the `ContactItemView` still references the `CONTACT_ITEM_SNIPPET`
    global variable. Let''s now modify this view''s constructor as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个失败是因为`ContactItemView`仍然引用`CONTACT_ITEM_SNIPPET`全局变量。现在让我们修改这个视图的构造函数如下：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first line of the constructor calls the `TypeScriptTinyIoC.resolve` function
    with the definition of the named interface, `IISnippetService`. The result of
    this call is stored in the `snippetService` variable, which is strongly typed
    to the `ISnippetService` interface. This is the essence of the service locator
    pattern: we are programming to an interface (`ISnippetService`) and also locating
    this interface via our service locator. Once we have an instance of the class
    providing the interface, we can simply call `retrieveSnippet` with the required
    key to load our template.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的第一行调用`TypeScriptTinyIoC.resolve`函数，使用命名接口`IISnippetService`的定义。这个调用的结果存储在`snippetService`变量中，它的类型与`ISnippetService`接口强类型绑定。这就是服务定位器模式的本质：我们编程到一个接口（`ISnippetService`），并且通过我们的服务定位器定位这个接口。一旦我们有了提供接口的类的实例，我们就可以简单地使用所需的键调用`retrieveSnippet`来加载我们的模板。
- en: Now that we have updated and fixed our tests, we will just need to modify our
    `AppConfig.ts` file in the same way that we modified the `TestConfig.ts` file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新并修复了我们的测试，我们只需要以与我们修改`TestConfig.ts`文件相同的方式修改我们的`AppConfig.ts`文件。
- en: Testability
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可测试性
- en: 'Now that we are programming against a defined interface, we can start to test
    our code in different ways. In a test, we can now substitute the actual `SnippetService`
    for another service that throws an error when we call `retrieveSnippet`. For this
    test, lets create a class named `SnippetServiceRetrieveThrows` as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在根据一个定义好的接口进行编程，我们可以开始以不同的方式测试我们的代码。在一个测试中，我们现在可以用另一个在调用`retrieveSnippet`时抛出错误的服务替换实际的`SnippetService`。对于这个测试，让我们创建一个名为`SnippetServiceRetrieveThrows`的类，如下所示：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This class can be registered against the `IISnippetService` named interface,
    as it correctly implements the TypeScript interface `ISnippetService`. The `retrieveSnippet`
    function, however, simply throws an error.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以注册到`IISnippetService`命名接口，因为它正确实现了TypeScript接口`ISnippetService`。然而，`retrieveSnippet`函数只是抛出一个错误。
- en: 'Our tests, then, can easily register this version of the service, and then
    create a `ContactItemView` class instance in order to see what happens, should
    the call to the `retrieveSnippet` function fail. Note that we have not modified
    our `ContactItemView` class in any way—we are simply registering a different class
    against the `IISnippetService` named interface. Our test, in this case, would
    be as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的测试可以轻松注册此服务的版本，然后创建一个`ContactItemView`类的实例，以查看如果调用`retrieveSnippet`函数失败会发生什么。请注意，我们并没有以任何方式修改我们的`ContactItemView`类
    - 我们只是针对`IISnippetService`命名接口注册了一个不同的类。在这种情况下，我们的测试将如下：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this test, we are registering our throwing version of the `SnippetService`
    in our `beforeAll` function, and then testing the rendering capability of the
    `ContactItemView`. Running this test will cause an error to be thrown when the
    `ContactItemView` calls `retrieveSnippet`. To enable this test to pass, we need
    to update the `ContactItemView` to handle an error gracefully:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们在`beforeAll`函数中注册了我们抛出版本的`SnippetService`，然后测试了`ContactItemView`的渲染能力。运行此测试将在`ContactItemView`调用`retrieveSnippet`时引发错误。为了使此测试通过，我们需要更新`ContactItemView`以优雅地处理错误：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we have simply surrounded the call to `retrieveSnippet` with a `try` `catch`
    block. If an error occurs, we are then modifying the snippet to be a standard
    error message. By putting a test like this in place, we are further solidifying
    our code to be able to handle various errors.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是用`try` `catch`块包围了对`retrieveSnippet`的调用。如果发生错误，我们将修改片段为标准错误消息。通过放置这样的测试，我们进一步巩固了我们的代码，以便处理各种错误。
- en: So what have we accomplished thus far? We have built a service to provide HTML
    snippets, and we have built a Service Locator that can register an instance of
    this service for use throughout our code. By registering different variations
    of this service during testing, we can also further bug-proof our code by simulating
    common errors, and testing our components under these circumstances.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们取得了什么成就呢？我们已经建立了一个服务来提供HTML片段，并且我们已经建立了一个服务定位器，可以注册此服务的实例，以便在整个代码中使用。通过在测试期间注册不同版本的此服务，我们还可以通过模拟常见错误来进一步防止错误，并在这些情况下测试我们的组件。
- en: The Domain Events Pattern
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 域事件模式
- en: Most JavaScript frameworks have the concept of an event bus. An event bus is
    simply a method of publishing events to a global bus, so that other parts of your
    application that are subscribed to these events will receive a message, and be
    able to react to them. The use of an event-based architecture helps to decouple
    our applications, making them resilient to change and easier to test.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数JavaScript框架都有事件总线的概念。事件总线只是一种将事件发布到全局总线的方法，以便订阅这些事件的应用程序的其他部分将接收到消息，并能够对其做出反应。使用基于事件的架构有助于解耦我们的应用程序，使其更具有适应变化的能力，并更易于测试。
- en: A Domain Event is an event that happens specific to our application domain.
    Something like "when an error occurs, log it to the console", or "when a menu
    button is clicked, change the sub-menu panel to reflect this option". A Domain
    Event can be raised anywhere in your code. Any class can register an event handler
    against this event, and will then be notified when this event is raised. There
    can be many event handlers for a single Domain Event.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 域事件是特定于我们应用程序域的事件。例如“当发生错误时，将其记录到控制台”，或者“当单击菜单按钮时，更改子菜单面板以反映此选项”。域事件可以在代码的任何位置引发。任何类都可以针对此事件注册事件处理程序，然后在引发此事件时将收到通知。对于单个域事件可以有多个事件处理程序。
- en: Martin Fowler first blogged about the concept of a Domain Event in 2005 in a
    blog found at [http://martinfowler.com/eaaDev/DomainEvent.html](http://martinfowler.com/eaaDev/DomainEvent.html).
    Udi Dahan then showed how to implement a simple domain event pattern in C# in
    another blog found at [http://www.udidahan.com/2009/06/14/domain-events-salvation/](http://www.udidahan.com/2009/06/14/domain-events-salvation/).
    Mike Hadlow also blogged about Separation of Concerns with Domain Events, and
    this blog can be found at [http://mikehadlow.blogspot.com.au/2010/09/separation-of-concerns-with-domain.html](http://mikehadlow.blogspot.com.au/2010/09/separation-of-concerns-with-domain.html).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Martin Fowler在2005年的一篇博客中首次提出了域事件的概念，该博客位于[http://martinfowler.com/eaaDev/DomainEvent.html](http://martinfowler.com/eaaDev/DomainEvent.html)。然后，Udi
    Dahan在另一篇博客中展示了如何在C#中实现简单的域事件模式，该博客位于[http://www.udidahan.com/2009/06/14/domain-events-salvation/](http://www.udidahan.com/2009/06/14/domain-events-salvation/)。Mike
    Hadlow还在博客中讨论了域事件的关注点分离，该博客位于[http://mikehadlow.blogspot.com.au/2010/09/separation-of-concerns-with-domain.html](http://mikehadlow.blogspot.com.au/2010/09/separation-of-concerns-with-domain.html)。
- en: Mike argues that a piece of code that raises an event should not be concerned
    with what happens after that—we should have separate handlers to handle these
    events—which are not coupled to anything actually raising the events.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Mike认为，引发事件的代码片段不应该关心之后会发生什么 - 我们应该有单独的处理程序来处理这些事件 - 这些处理程序与实际引发事件的任何内容都没有耦合。
- en: While there are a number of JavaScript libraries that handle events—Postal for
    example—most of these libraries send strings or simple JavaScript objects as the
    message packet. There is no way of ensuring that the sender of the message is
    filling in all of the properties that the handler of the message is expecting.
    In other words, these messages are not strongly typed—and could easily cause runtime
    errors—by trying to fit a "square peg" message into a "round hole" event handler.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多处理事件的JavaScript库 - 例如Postal - 但这些库中的大多数都将字符串或简单的JavaScript对象作为消息包发送。无法确保发送消息的对象填写了消息处理程序所期望的所有属性。换句话说，这些消息不是强类型的
    - 可能会很容易地导致运行时错误 - 试图将“方形销子”消息适配到“圆形孔”事件处理程序中。
- en: In this section, we will build a strongly typed Domain Event message bus, and
    show how both sides—the event raiser and the event handler—can ensure that the
    event that is raised has all of the properties that are expected in the event
    handler. We will also show how to ensure that the event handlers are written correctly—and
    registered correctly —so that events are delivered in a strongly typed manner.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个强类型的领域事件消息总线，并展示事件引发方和事件处理方如何确保引发的事件具有事件处理方期望的所有属性。我们还将展示如何确保事件处理程序被正确编写和正确注册，以便以强类型的方式传递事件。
- en: Problem space
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题空间
- en: 'Let''s assume that we have the following business requirement: "If an error
    occurs, show the user an error message in a notification pop up. This pop up should
    show for two seconds and then fade away, allowing the user to continue working."'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下业务需求：“如果发生错误，请向用户显示一个通知弹出窗口中的错误消息。这个弹出窗口应该显示两秒钟，然后消失，让用户继续工作。”
- en: 'In our current application, there are a number of places where errors could
    occur—when loading JSON through the `ContactCollection`, for instance—or when
    rendering a `ContactItemView`. These errors could occur quite deep down in our
    class hierarchy. In order to achieve our stated requirements, we will need to
    handle these errors at the `ContactViewApp` level. Consider the following diagram:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的应用程序中，有许多可能发生错误的地方——例如通过`ContactCollection`加载JSON时，或者渲染`ContactItemView`时。这些错误可能会发生在我们的类层次结构中的深层。为了实现我们的需求，我们需要在`ContactViewApp`级别处理这些错误。请考虑以下图表：
- en: '![Problem space](img/9665OS_08_06.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![问题空间](img/9665OS_08_06.jpg)'
- en: Dependency tree with domain event handlers and event raisers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 带有领域事件处理程序和事件引发方的依赖树。
- en: Our `ContactViewApp` will register an event handler with `TypeScriptTinyIoC`,
    specifying which event type it is interested in. When an event of this type is
    raised by any one of our modules, our message bus will direct the message to the
    correct handler, or group of handlers. In the preceding diagram, the `ContactCollection`
    and the `ContactItemView` classes are shown to be raising an `ErrorEvent` via
    `TypeScriptTinyIoC`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ContactViewApp`将使用`TypeScriptTinyIoC`注册一个事件处理程序，指定它感兴趣的事件类型。当我们的模块中的任何一个引发了这种类型的事件时，我们的消息总线将把消息传递给正确的处理程序或一组处理程序。在前面的图表中，`ContactCollection`和`ContactItemView`类被显示为通过`TypeScriptTinyIoC`引发`ErrorEvent`。
- en: Message and Handler Interfaces
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息和处理程序接口
- en: There are two key sets of information that we need in order to register and
    raise strongly typed messages. The first is an interface describing the message
    itself, which is paired with its named interface. The second is an interface describing
    the message handler function, again which is paired with its named interface.
    Our TypeScript interface gives us compile-time checking of messages and handlers,
    and our named interfaces (implementing `IInterfaceChecker`) give us runtime type
    checking of messages and handlers.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两组关键信息来注册和引发强类型消息。第一组是描述消息本身的接口，与其命名接口配对。第二组是描述消息处理程序函数的接口，同样与其命名接口配对。我们的TypeScript接口为我们提供了消息和处理程序的编译时检查，而我们的命名接口（实现`IInterfaceChecker`）为我们提供了消息和处理程序的运行时类型检查。
- en: 'First up, the interfaces for our message are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的消息接口如下：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We start with the TypeScript interface `IErrorEvent`. This interface has two
    properties, `Message` and `Description`, which are both strings. We then create
    our `IIErrorEvent` class, which is an instance of our named interface – again
    with the `propertyNames` array matching our TypeScript interface property names.
    The `className` property is also set to be the name of the class, `IIErrorEvent`,
    to ensure uniqueness.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从TypeScript接口`IErrorEvent`开始。这个接口有两个属性，`Message`和`Description`，都是字符串。然后我们创建我们的`IIErrorEvent`类，它是我们命名接口的一个实例——再次使用`propertyNames`数组匹配我们的TypeScript接口属性名。`className`属性也设置为类的名称`IIErrorEvent`，以确保唯一性。
- en: 'The interfaces for our event handlers are then as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的事件处理程序接口如下：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The TypeScript interface `IErrorEvent_Handler` contains a single method, named
    `handle_ErrorEvent`. This handler method has a single parameter, `event`, which
    is again strongly typed to be our event interface, `IErrorEvent`. We then construct
    a named interface called `IIErrorEvent_Handler`, and match the TypeScript interface
    through the `methodNames` array. Again, we provide a unique `className` property
    for this named interface.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript接口`IErrorEvent_Handler`包含一个名为`handle_ErrorEvent`的方法。这个处理程序方法有一个名为`event`的参数，再次强类型化为我们的事件接口`IErrorEvent`。然后我们构建一个名为`IIErrorEvent_Handler`的命名接口，并通过`methodNames`数组匹配TypeScript接口。同样，我们为这个命名接口提供一个独特的`className`属性。
- en: 'With these two interfaces and named interfaces in place, we can now create
    the actual `ErrorEvent` class as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个接口和命名接口，我们现在可以创建实际的`ErrorEvent`类如下：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The class definition for `ErrorEvent` implements the `IErrorEvent` interface,
    thereby making it compatible with our event handler. Note the `constructor` of
    this class. We are forcing users of this class to provide both a `message` and
    `description` parameter in the constructor – thereby using TypeScript compile-time
    checking to ensure that we construct this class correctly, no matter where it
    is used.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorEvent`的类定义实现了`IErrorEvent`接口，从而使其与我们的事件处理程序兼容。请注意这个类的`constructor`。我们强制这个类的用户在构造函数中提供`message`和`description`参数——从而使用TypeScript编译时检查来确保我们无论在何处都正确构造这个类。'
- en: 'We can then create a class that implements the `IErrorEvent_Handler` interface,
    which will receive the event itself. As a quick example, consider the following
    class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以创建一个实现`IErrorEvent_Handler`接口的类，该类将接收事件本身。举个快速的例子，考虑以下类：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This class implements the `IErrorEvent_Handler` TypeScript interface, and therefore
    the compiler will force the class to define a `handle_ErrorEvent` function with
    the correct signature, in order to receive messages.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了`IErrorEvent_Handler` TypeScript接口，因此编译器将强制这个类定义一个具有正确签名的`handle_ErrorEvent`函数，以接收消息。
- en: Multiple Event Handlers
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多事件处理程序
- en: 'To be able to register multiple events, and have multiple event handlers per
    event, we will need an array of events, each of which will, in turn, hold an array
    of handlers as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够注册多个事件，并且每个事件可以有多个事件处理程序，我们将需要一个事件数组，每个事件将依次保存一个处理程序数组，如下所示：
- en: '![Multiple Event Handlers](img/9665OS_08_07.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![多事件处理程序](img/9665OS_08_07.jpg)'
- en: Class structure for registering multiple event handlers per event.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 用于注册每个事件的多个事件处理程序的类结构。
- en: Our `TypeScriptTinyIoC` class will have an array called `events`, which uses
    the name of the event as its key. This name will be drawn from our named interface
    for the event – again because TypeScript interfaces are compiled away. To help
    with managing multiple event handlers per event, we will create a new class called
    `EventHandlerList` that will facilitate the registration of multiple event handlers.
    An instance of this `EventHandlerList` class will be stored in our `events` array
    for each named event that we have registered.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`TypeScriptTinyIoC`类将有一个名为`events`的数组，它使用事件的名称作为键。这个名称将来自我们的事件的命名接口 - 再次因为TypeScript接口被编译掉了。为了帮助管理每个事件的多个事件处理程序，我们将创建一个名为`EventHandlerList`的新类，它将便于注册多个事件处理程序。这个`EventHandlerList`类的实例将被存储在我们已注册的每个命名事件的`events`数组中。
- en: 'Let''s start with this list of event handlers, and implement our `EventHandlerList`
    class. At this stage, all we need is an internal array to store handlers, named
    `eventHandlers`, along with a `registerHandler` function as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从事件处理程序列表开始，并实现我们的`EventHandlerList`类。在这个阶段，我们只需要一个内部数组来存储处理程序，名为`eventHandlers`，以及一个`registerHandler`函数，如下所示：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `registerHandler` function is again using the `{ new(): IInterfaceChecker
    }` syntax for the `interfaceType` argument, thereby allowing us to use a type
    name for this function call. A quick unit test is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`registerHandler`函数再次使用`{ new(): IInterfaceChecker }`语法来为`interfaceType`参数，从而允许我们为这个函数调用使用类型名称。一个快速的单元测试如下：'
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We start this test with an `import` statement for our event classes, and then
    a class named `EventHandlerTests_ErrorHandler`. This class will be used as a registered
    event handler just for this test suite. The class implements the `iee.IErrorEvent_Handler`
    and, as such, will generate a compile error if we do not have a `handle_ErrorEvent`
    function that accepts an `IErrorEvent` as its only parameter. Just by using TypeScript
    interfaces, we have already ensured that this class has the correct function name
    and function signature to accept `ErrorEvent` messages.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从导入我们的事件类的`import`语句开始，然后是一个名为`EventHandlerTests_ErrorHandler`的类。这个类将被用作一个仅用于这个测试套件的注册事件处理程序。该类实现了`iee.IErrorEvent_Handler`，因此，如果我们没有一个接受`IErrorEvent`作为唯一参数的`handle_ErrorEvent`函数，它将生成一个编译错误。仅仅通过使用TypeScript接口，我们已经确保这个类具有正确的函数名称和函数签名来接受`ErrorEvent`消息。
- en: Our test then starts by declaring a variable named `testHandler` to store an
    instance of our `EventHandlerTests_ErrorHandler` class. The `beforeEach` function
    will create this instance, and assign it to our `testHandler` variable. The test
    itself then creates an instance of the `EventHandlerList` class, calls the `registerHandler`,
    and then expects the `length` of the internal `eventHandlers` property to be the
    value of one.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试首先声明一个名为`testHandler`的变量来存储我们的`EventHandlerTests_ErrorHandler`类的一个实例。`beforeEach`函数将创建这个实例，并将其赋给我们的`testHandler`变量。测试本身然后创建一个`EventHandlerList`类的实例，调用`registerHandler`，然后期望内部`eventHandlers`属性的`length`值为1。
- en: Note again the syntax of the call to `registerHandler`. We are passing in our
    `testHandler` instance as the first argument, and then specifying the named interface
    `IIErrorEvent_Handler` class type. As we saw with the service locator pattern,
    we are again using the same class name syntax for our named interface, instead
    of having to call `new()`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意`registerHandler`的调用语法。我们将我们的`testHandler`实例作为第一个参数传入，然后指定命名接口`IIErrorEvent_Handler`类类型。正如我们在服务定位器模式中看到的，我们再次使用相同的类名语法来表示我们的命名接口，而不是调用`new()`。
- en: 'Let''s now fill in the code to make the test pass:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们填写代码使测试通过：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our `registerHandler` function firstly creates an instance of the `InterfaceChecker`
    class, and then calls `implementsInterface` to make sure, at runtime, that the
    handler object that is passed in does indeed have all of the method names defined
    by our named interface. If the `implementsInterface` function returns `true`,
    we can simply push this handler onto our internal array.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`registerHandler`函数首先创建一个`InterfaceChecker`类的实例，然后调用`implementsInterface`来确保在运行时，传入的处理程序对象确实具有我们命名接口定义的所有方法名称。如果`implementsInterface`函数返回`true`，我们可以简单地将这个处理程序推入我们的内部数组。
- en: If the handler does not implement the named interface, we throw an error. For
    completeness, this error contains the `className` property of the named interface,
    so we first have to new up an instance of this named interface class, before we
    can extract the `className` property.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理程序没有实现命名接口，我们会抛出一个错误。为了完整起见，这个错误包含了命名接口的`className`属性，因此我们首先要实例化这个命名接口类的一个实例，然后才能提取`className`属性。
- en: 'Let''s now create a test that will deliberately fail our `implementsInterface`
    check and ensure that an error is in fact thrown:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个测试，故意使我们的`implementsInterface`检查失败，并确保实际上抛出了一个错误：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We start with the class definition of the `No_ErrorHandler` class that obviously
    does not implement our named interface. Our test then sets up the `EventHandlerList`
    class, and calls the `registerHandler` function, using a new instance of the `No_ErrorHandler`
    class, and our `IIErrorEvent_Handler` named interface. We are then expecting a
    specific error message— one that should include the name of our named interface,
    `IIErrorEvent_Handler`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`No_ErrorHandler`类的类定义开始，显然它没有实现我们的命名接口。然后我们设置`EventHandlerList`类，并调用`registerHandler`函数，使用`No_ErrorHandler`类的新实例和我们的`IIErrorEvent_Handler`命名接口。然后我们期望一个特定的错误消息
    - 这个消息应该包括我们命名接口`IIErrorEvent_Handler`的名称。
- en: Firing an event
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发事件
- en: 'We can now turn our attention to raising an event. To do this, we will need
    to know what the actual function name of the event handler is. We will make a
    slight change to our `EventHandlerList`, and pass in the event name to the constructor
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以把注意力转向触发事件。为了做到这一点，我们需要知道事件处理程序的实际函数名称。我们将对`EventHandlerList`进行轻微更改，并将事件名称传递给构造函数，如下所示：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our constructor is now expecting a `handleEventMethodName` as a required parameter,
    and we are storing this in a property named `handleEventMethod`. Remember that
    all of the handlers that are registered with an instance of this class are responding
    to the same event – and as such will all have the same method name – enforced
    by the TypeScript compiler. We have also defined a `raiseEvent` function, and
    since we do not know what event this class will be handling, the event is of type
    `any`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数现在期望一个`handleEventMethodName`作为必需的参数，并且我们将其存储在名为`handleEventMethod`的属性中。请记住，注册到此类实例的所有处理程序都在响应相同的事件
    - 因此都将具有相同的方法名称 - 这是由TypeScript编译器强制执行的。我们还定义了一个`raiseEvent`函数，由于我们不知道这个类将处理什么事件，所以事件的类型是`any`。
- en: 'Now, we can create a unit test that will fail, as the `raiseEvent` function
    is not actually doing anything as yet. Before we do this, lets update our test
    handler class, `EventHandlerTests_ErrorHandler,` to store the last event fired
    in a property that we can access later:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个单元测试，该测试将失败，因为`raiseEvent`函数实际上还没有做任何事情。在这之前，让我们更新我们的测试处理程序类`EventHandlerTests_ErrorHandler`，以便将最后触发的事件存储在一个我们以后可以访问的属性中：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We have updated this class definition with a property named `LastEventFired`,
    and set this property inside the `handle_ErrorEvent` function. With this change
    in place, when an event is fired, we can interrogate the `LastEventFired` property
    to see what event was fired last. Let''s now write a test that calls the `raiseEvent`
    method:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更新了这个类定义，增加了一个名为`LastEventFired`的属性，并在`handle_ErrorEvent`函数中设置了这个属性。有了这个改变，当一个事件被触发时，我们可以询问`LastEventFired`属性来查看最后触发的事件是什么。现在让我们编写一个调用`raiseEvent`方法的测试。
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We start with a variable named `eventHandlerList` that holds an instance of
    our `EventHandlerList` class, and pass in the name of the function to be called
    via the constructor. We then call `registerHandler` with this `testHandler` instance.
    Now, we can call the `raiseEvent` function, passing in a `new ErrorEvent`. As
    the constructor of our `ErrorEvent` class requires two parameters, we have just
    passed in `"test"` for each of these arguments. Finally, we are expecting that
    the `LastEventFired` property of our event handler to be set correctly. Running
    our test at this stage will fail, so let''s implement the `raiseEvent` method
    on our `EventHandlerList` class as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个名为`eventHandlerList`的变量开始，它保存了我们`EventHandlerList`类的一个实例，并通过构造函数传递了要调用的函数的名称。然后我们使用这个`testHandler`实例调用`registerHandler`。现在，我们可以调用`raiseEvent`函数，传入一个`new
    ErrorEvent`。由于我们`ErrorEvent`类的构造函数需要两个参数，我们刚刚为这些参数传入了`"test"`。最后，我们期望我们的事件处理程序的`LastEventFired`属性被正确设置。在这个阶段运行我们的测试将失败，所以让我们实现`EventHandlerList`类上的`raiseEvent`方法如下：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The implementation of this `raiseEvent` function is relatively simple. We just
    iterate through our `eventHandlers` array, and then get a reference to each of
    the event handlers using an index. The line to note here is how we execute the
    handler function: `handler[this.handleEventMethod](event)`. This takes advantage
    of JavaScript''s ability to calling a function using a string value that matches
    the function''s name. In our tests, this would be equivalent to `handler[''handle_ErrorEvent''](event)`,
    which in JavaScript is equivalent to `handler.handle_ErrorEvent(event)`—an actual
    call to the handler function. With this JavaScript magic in place, our events
    are being fired, and our unit tests run through correctly.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`raiseEvent`函数的实现相对简单。我们只需遍历我们的`eventHandlers`数组，然后使用索引引用每个事件处理程序。这里需要注意的一行是我们如何执行处理程序函数：`handler[this.handleEventMethod](event)`。这利用了JavaScript能够使用与函数名称匹配的字符串值来调用函数的能力。在我们的测试中，这相当于`handler['handle_ErrorEvent'](event)`，在JavaScript中相当于`handler.handle_ErrorEvent(event)`
    - 对处理程序函数的实际调用。有了这个JavaScript魔法，我们的事件被触发，我们的单元测试正确运行。
- en: Registering an Event handler for an Event
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为事件注册事件处理程序
- en: Now that we have a working, tested class to manage multiple event handlers responding
    to a specific event, we can turn our attention back to the `TypeScriptTinyIoC`
    class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可工作、经过测试的类来管理多个事件处理程序响应特定事件，我们可以把注意力转回到`TypeScriptTinyIoC`类上。
- en: 'As we did for our Service Locator pattern, we will need to register an instance
    of an object to handle a specific event. The method signature for registering
    our event handler will look like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为服务定位器模式所做的那样，我们需要注册一个对象的实例来处理特定的事件。我们的事件处理程序注册的方法签名将如下所示：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This `registerHandler` function takes three arguments. The first is the instance
    of the object implementing the handler. The second argument is the named interface
    class for our handler—so that we can check this class at runtime to ensure that
    it implements the handler interface. The third argument is the named interface
    for the event itself. This `register` function is also what binds an event to
    its handler.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`registerHandler`函数有三个参数。第一个是实现处理程序的对象的实例。第二个参数是处理程序的命名接口类，这样我们可以在运行时检查这个类，以确保它实现了处理程序接口。第三个参数是事件本身的命名接口。这个`register`函数也是将事件绑定到处理程序的方法。
- en: 'Before we put together a unit test, we will need another static function to
    raise an event:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们组合单元测试之前，我们需要另一个静态函数来触发事件：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This `raiseEvent` function on the `TypeScriptTinyIoC` class will call the `raiseEvent`
    function on the `EventHandlerList` class instance for this event. We will also
    do an `interfaceChecker` test here, in order to ensure that the event being raised
    matches our named interface class for the event—before we actually raise the event.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`TypeScriptTinyIoC`类上的`raiseEvent`函数将调用这个事件的`EventHandlerList`类实例上的`raiseEvent`函数。我们还将在这里进行一个`interfaceChecker`测试，以确保正在触发的事件与我们为事件提供的命名接口类匹配——在我们实际触发事件之前。
- en: 'Now for our unit test:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到我们的单元测试：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This test is very similar to the test that we wrote for our `EventHandlerList`
    class, except we are calling the `registerHandler` and `raiseEvent` methods on
    the `TypeScriptTinyIoC` class, instead of a specific `EventHandlerList`. With
    this failing test in place, we can now fill out the `registerHandler` and `raiseEvent`
    functions as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与我们为`EventHandlerList`类编写的测试非常相似，只是我们在`TypeScriptTinyIoC`类上调用`registerHandler`和`raiseEvent`方法，而不是特定的`EventHandlerList`。有了这个失败的测试，我们现在可以填写`registerHandler`和`raiseEvent`函数如下：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Firstly, we have added a static property called `events`, which is an array
    of `EventHandlerList` instances. We will add to this array using the `className`
    of our named event interface as a key. Our `registerHandler` function firstly
    creates instances of both named interface classes that are passed in via the `handlerInterface`
    and `eventInterface` arguments. We are then checking to see whether our internal
    array already has an `EventHandlerList` instance for this event, keyed via the
    `className` property of our named event interface. If we have an entry already,
    we can simply call the `registerHandler` function on the existing `EventHandlerList`
    instance. If this event has not been registered, we simply create a new instance
    of an `EventHandlerList` class, call `registerHandler`, and then add this entry
    to our internal array.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个名为`events`的静态属性，它是`EventHandlerList`实例的数组。我们将使用命名事件接口的`className`作为键来添加到这个数组中。我们的`registerHandler`函数首先创建通过`handlerInterface`和`eventInterface`参数传入的命名接口类的实例。然后我们检查我们的内部数组是否已经有了一个针对这个事件的`EventHandlerList`实例，通过命名事件接口的`className`属性作为键。如果已经有了条目，我们可以简单地在现有的`EventHandlerList`实例上调用`registerHandler`函数。如果这个事件尚未注册，我们只需创建一个`EventHandlerList`类的新实例，调用`registerHandler`，然后将这个条目添加到我们的内部数组中。
- en: 'Note how we figured out what the actual name of the event handler function
    call is. We are simply using the first method name found in our method names array:
    `handlerInterfaceInstance.methodNames[0]`, which will return a string. In our
    samples, this would return the `''handle_ErrorEvent''` string, which is the method
    name that we will need to invoke when invoking handler functions for an event.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何找出事件处理程序函数调用的实际名称的。我们只是使用在我们的方法名称数组中找到的第一个方法名称：`handlerInterfaceInstance.methodNames[0]`，这将返回一个字符串。在我们的示例中，这将返回`'handle_ErrorEvent'`字符串，这是我们在调用事件的处理程序函数时需要调用的方法名称。
- en: 'Next, we can focus on the `raiseEvent` function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以专注于`raiseEvent`函数：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This function first creates an instance of an `InterfaceChecker` class, and
    then ensures that the event being raised conforms to the named interface that
    we provide as the second parameter. Again, this is a runtime type check to ensure
    that the event we are attempting to raise is in fact of the correct type. If the
    event is valid, we fetch the instance of the `EventHandlerList` class that is
    registered for this event, and then call its `raiseEvent` function.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先创建一个`InterfaceChecker`类的实例，然后确保正在触发的事件符合我们作为第二个参数提供的命名接口。同样，这是一个运行时类型检查，以确保我们试图触发的事件实际上是正确类型的。如果事件是有效的，我们获取为这个事件注册的`EventHandlerList`类的实例，然后调用它的`raiseEvent`函数。
- en: Our strongly typed Domain Event mechanism is now complete. We are using both
    compile-time TypeScript interface checking, and runtime type checking in two ways.
    Firstly, when registering a handler, we do an interface check, and then when we
    fire an event, we do another interface check. This means that both sides—registering
    and firing—of events are strongly typed, both at compile time and also at runtime.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的强类型域事件机制现在已经完成。我们在两个方面使用了编译时TypeScript接口检查和运行时类型检查。首先，在注册处理程序时，我们进行了接口检查，然后在触发事件时，我们进行了另一个接口检查。这意味着事件的两个方面——注册和触发——在编译时和运行时都是强类型的。
- en: Displaying error notifications
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示错误通知
- en: Now that we have our `TypeScriptTinyIoC` event mechanism in place, we can focus
    on solving the business problem of showing error notifications when errors occur.
    Notify is a jQuery plugin that suits our needs perfectly ([http://notifyjs.com/](http://notifyjs.com/)).
    We could install the JavaScript library from NuGet (Install the `jQuery.notify`
    package), but the default version of this package relies on another package named
    Bootstrap for its styling. Notify, however, also provides an option on their website
    to download a custom notify.js script that has all of these styles built-in to
    the library. We will use this custom version, as our project is not using the
    Bootstrap package.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在`TypeScriptTinyIoC`中有了事件机制，我们可以专注于解决当错误发生时显示错误通知的业务问题。Notify是一个完全符合我们需求的jQuery插件（[http://notifyjs.com/](http://notifyjs.com/)）。我们可以从NuGet安装JavaScript库（安装`jQuery.notify`包），但是这个包的默认版本依赖于另一个名为Bootstrap的包来进行样式设置。然而，Notify还在他们的网站上提供了一个选项，可以下载一个包含所有这些样式的自定义notify.js脚本。我们将使用这个自定义版本，因为我们的项目没有使用Bootstrap包。
- en: The definition file for Notify can be downloaded from DefinitelyTyped ([https://github.com/borisyankov/DefinitelyTyped/tree/master/notify](https://github.com/borisyankov/DefinitelyTyped/tree/master/notify)).
    At the time of writing, however, there seems to be two versions of the Notify
    library, one named Notify and the other named Notify.js. Use the Notify version
    as it seems to be more up to date.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Notify的定义文件可以从DefinitelyTyped（[https://github.com/borisyankov/DefinitelyTyped/tree/master/notify](https://github.com/borisyankov/DefinitelyTyped/tree/master/notify)）下载。然而，在撰写本文时，似乎有两个版本的Notify库，一个名为Notify，另一个名为Notify.js。使用Notify版本，因为它似乎更加更新。
- en: 'To simulate an error, let''s tag onto the `ContactItemView onClicked` function,
    where we are currently executing a flip, and raise a dummy error whenever someone
    clicks on one of our contact links:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟一个错误，让我们附加到`ContactItemView onClicked`函数，我们当前正在执行flip，并在某人点击我们的联系链接时引发一个虚拟错误：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After our call to flip, we are simply creating an instance of the `ErrorEvent`
    class, with its two required parameters. We then call the `raiseEvent` function
    on `TypeScriptTinyIoC` with this `errorEvent` instance, and the named interface
    for the type of event that we are raising. It's as simple as that.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用flip之后，我们只是创建了一个`ErrorEvent`类的实例，带有它的两个必需参数。然后我们调用`TypeScriptTinyIoC`上的`raiseEvent`函数，使用这个`errorEvent`实例和我们正在引发的事件类型的命名接口。就是这么简单。
- en: 'Now, we can modify our `ContactViewApp` to register a handler for this event
    as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以修改我们的`ContactViewApp`来注册此事件的处理程序如下：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, have made a few changes to our `ContactViewApp` class. Firstly, we implement
    the `IErrorEvent_Handler` TypeScript interface, which will force us to include
    the `handle_ErrorEvent` function within our class. We have also defined a `constructor`,
    and within this, we are registering the class instance as a handler using our
    two named interfaces: `IIErrorEvent_Handler`, and `IIErrorEvent`.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对`ContactViewApp`类进行了一些更改。首先，我们实现了`IErrorEvent_Handler` TypeScript接口，这将强制我们在类中包含`handle_ErrorEvent`函数。我们还定义了一个`constructor`，在其中，我们使用我们的两个命名接口`IIErrorEvent_Handler`和`IIErrorEvent`注册了类实例作为处理程序。
- en: Within the `handle_ErrorEvent` function, we are calling `$.notify`—the Notify
    jQuery plugin. Note that the type of the `event` argument passed into the `handle_ErrorEvent`
    function, is of type `IErrorEvent`. This means that we can safely use any properties
    or methods of the `IErrorEvent` interface within our event handler function, as
    we have already ensured, during event raising, that this event implements the
    interface correctly.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handle_ErrorEvent`函数中，我们调用`$.notify`——Notify jQuery插件。请注意，传递给`handle_ErrorEvent`函数的`event`参数的类型是`IErrorEvent`。这意味着我们可以在事件处理程序函数中安全地使用`IErrorEvent`接口的任何属性或方法，因为在事件引发期间，我们已经确保此事件正确实现了接口。
- en: 'Our call to Notify is just using a message that is built up from our `ErrorEvent`.
    The following screenshot shows the results of this Notify call:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用Notify只是使用了从我们的`ErrorEvent`构建的消息。以下屏幕截图显示了此Notify调用的结果：
- en: '![Displaying error notifications](img/9665OS_08_08.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![显示错误通知](img/9665OS_08_08.jpg)'
- en: Screenshot of application showing an error notification
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序显示错误通知的屏幕截图
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The implementation of this Service Locator pattern and the strongly typed Domain
    Events pattern that we have worked through in this chapter are available on the
    GitHub project *typescript-tiny-ioc* ([https://github.com/blorkfish/typescript-tiny-ioc](https://github.com/blorkfish/typescript-tiny-ioc)).
    This project has further code samples as well as a full suite of unit tests for
    both AMD and normal JavaScript usage.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经通过GitHub项目*typescript-tiny-ioc*（[https://github.com/blorkfish/typescript-tiny-ioc](https://github.com/blorkfish/typescript-tiny-ioc)）实现了此服务定位器模式和强类型域事件模式。该项目还有更多的代码示例以及用于AMD和普通JavaScript使用的完整单元测试套件。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we had a look at object-oriented programming, beginning with
    the SOLID Design principles. We then reviewed the application that we had built
    in [Chapter 7](ch07.html "Chapter 7. Modularization"), *Modularization*, with
    regards to these principles. We discussed various methods of Dependency Injection,
    and then built a mechanism that is based on our `InterfaceChecker` from [Chapter
    3](ch03.html "Chapter 3. Interfaces, Classes and Generics"), *Interfaces, Classes
    and Generics*, to obtain an instance of a named interface. We used this principle
    to build a Service Locator and then extended this principle to build a strongly
    typed event bus for the Domain Event pattern. Finally, we incorporated Notify
    into our application for simple notifications in response to these error events.
    In our next and final chapter, we will put all of the principles we have learned
    so far into practice, and build an application from the ground up.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了面向对象编程，从SOLID设计原则开始。然后，我们针对这些原则回顾了我们在[第7章](ch07.html "第7章。模块化") *模块化*
    中构建的应用程序。我们讨论了各种依赖注入的方法，然后构建了一个基于我们在[第3章](ch03.html "第3章。接口、类和泛型") *接口、类和泛型* 中的`InterfaceChecker`的机制，以获得命名接口的实例。我们使用了这个原则来构建一个服务定位器，然后将这个原则扩展到为域事件模式构建一个强类型的事件总线。最后，我们将Notify整合到我们的应用程序中，用于对这些错误事件进行简单通知。在我们接下来的最后一章中，我们将把我们迄今学到的所有原则付诸实践，并从头开始构建一个应用程序。
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为Bentham Chang准备，Safari ID为bentham@gmail.com 用户编号：2843974 © 2015 Safari Books
    Online，LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他用途均需获得版权所有者的事先书面同意。未经授权的使用、复制和/或分发严格禁止并违反适用法律。保留所有权利。
