- en: Chapter 12. Object-Oriented, Functional Programming, and Lambda Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。面向对象，函数式编程和Lambda表达式
- en: 'In this chapter, we will discuss functional programming and how Java 9 implements
    many functional programming concepts. We will work with many examples on how to
    mix functional programming with object-oriented programming. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论函数式编程以及Java 9如何实现许多函数式编程概念。我们将使用许多示例来演示如何将函数式编程与面向对象编程相结合。我们将：
- en: Understand functions and methods as first-class citizens
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数和方法视为一等公民
- en: Work with functional interfaces and lambda expressions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数接口和Lambda表达式
- en: Create a functional version of array filtering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数组过滤的函数版本
- en: Create a data repository with generics and interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型和接口创建数据存储库
- en: Filter collections with complex conditions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复杂条件过滤集合
- en: Use a map operation to transform values
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用map操作转换值
- en: Combine a map operation with reduce
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将map操作与reduce结合
- en: Chain many operations with map and reduce
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用map和reduce链式操作
- en: Work with different collectors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的收集器
- en: Understanding functions and methods as first-class citizens
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数和方法视为一等公民
- en: Since its first release, Java has been an object-oriented programming language.
    Starting with Java 8, Java added support for the **functional programming** paradigm
    and continues to do so in Java 9\. Functional programming favors immutable data,
    and therefore, functional programming avoids state changes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java首次发布以来，Java一直是一种面向对象的编程语言。从Java 8开始，Java增加了对**函数式编程**范式的支持，并在Java 9中继续这样做。函数式编程偏爱不可变数据，因此，函数式编程避免状态更改。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code written with a functional programming style is as declarative as possible,
    and it is focused on what it does instead of how it must do it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数式编程风格编写的代码尽可能声明性，并且专注于它所做的事情，而不是它必须如何做。
- en: In most programming languages that provide support to the functional programming
    paradigm, functions are first-class citizens, that is, we can use functions as
    arguments for other functions or methods. Java 8 introduced many changes to reduce
    boilerplate code and make it easy for methods to become first-class citizens in
    Java and make it easy to write code that uses a functional programming approach.
    We can easily understand this concept with a simple example such as filtering
    a list. However, take into account that we will start by writing **imperative
    code** with methods as first-class citizens, and then, we will create a new version
    for this code that uses a complete functional approach in Java 9 through a filter
    operation. We will create many versions of this example because it will allow
    us to understand how functional programming is possible in Java 9.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数支持函数式编程范式的编程语言中，函数是一等公民，也就是说，我们可以将函数用作其他函数或方法的参数。Java 8引入了许多更改，以减少样板代码，并使方法成为Java中的一等公民变得容易，并且使得编写使用函数式编程方法的代码变得容易。我们可以通过一个简单的示例，例如过滤列表，轻松理解这个概念。但是，请注意，我们将首先编写具有方法作为一等公民的**命令式代码**，然后，我们将为此代码创建一个使用Java
    9中的过滤操作的完整函数式方法的新版本。我们将创建许多版本的此示例，因为这将使我们能够了解在Java 9中如何实现函数式编程。
- en: First, we will write some code considering that we still don't know about the
    features included in Java 9 to transform methods into first-class citizens. Then,
    we will use these features in many examples.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写一些代码，考虑到我们仍然不知道Java 9中包含的将方法转换为一等公民的功能。然后，我们将在许多示例中使用这些功能。
- en: The following lines declare the `Testable` interface that specifies a method
    requirement that receives a `number` argument of the `int` type and returns a
    `boolean` result. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_01.java` file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`Testable`接口，该接口指定了一个接收`int`类型的`number`参数并返回`boolean`结果的方法要求。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_01.java`文件中。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The following lines declare the `TestDivisibleBy5` concrete class that implements
    the previously declared `Testable` interface. The class implements the `test`
    method with code that returns a `boolean` value indicating whether the received
    number is divisible by `5` or not. If the result of the modulus, modulo, or remainder
    operator (`%`) between the number and `5` is equal to `0`, it means that the number
    is divisible by `5`. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_01.java` file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了实现先前声明的`Testable`接口的`TestDivisibleBy5`具体类。该类使用包含返回`boolean`值的代码实现`test`方法，指示接收到的数字是否可以被`5`整除。如果数字和`5`之间的模运算结果等于`0`，则表示该数字可以被`5`整除。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_01.java`文件中。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following lines declare the `TestGreaterThan10` concrete class that implements
    the previously declared `Testable` interface. The class implements the `test`
    method with code that returns a `boolean` value indicating whether the received
    number is greater than `10` or not. The code file for the sample is included in
    the `java_9_oop_chapter_12_01` folder, in the `example12_01.java` file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了实现先前声明的`Testable`接口的`TestGreaterThan10`具体类。该类使用包含返回`boolean`值的代码实现`test`方法，指示接收到的数字是否大于`10`。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_01.java`文件中。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The following lines declare the `filterNumbersWithTestable` method that receives
    a `List<Integer>` in the `numbers` argument and a `Testable` instance in the `tester`
    argument. The method uses an external `for` loop, that is, imperative code to
    call the `tester.test` method for each `Integer` element in the numbers `List<Integer>`.
    If the `test` method returns `true`, the code adds the `Integer` element to the
    `filteredNumbersList<Integer>`, specifically, an `ArrayList<Integer>`. Finally,
    the method returns the `filteredNumbersList<Integer>` as a result with all the
    `Integer` objects that satisfied the test. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_01.java` file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行声明了`filterNumbersWithTestable`方法，该方法接收`numbers`参数中的`List<Integer>`和`tester`参数中的`Testable`实例。该方法使用外部的`for`循环，即命令式代码，为`numbers`中的每个`Integer`元素调用`tester.test`方法。如果`test`方法返回`true`，则代码将`Integer`元素添加到`filteredNumbersList<Integer>`中，具体来说，是一个`ArrayList<Integer>`。最后，该方法将`filteredNumbersList<Integer>`作为结果返回，其中包含满足测试条件的所有`Integer`对象。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_01.java`文件中。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `filterNumbersWithTestable` method works with two `List<Integer>` objects,
    that is, two `List` of `Integer` objects. We are talking about `Integer` and not
    the `int` primitive type. `Integer` is a wrapper class for the `int` primitive
    type. However, the `test` method we declared in the `Testable` interface and then
    implemented in the two classes that implement this interface receive an argument
    of the `int` type, and not `Integer`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`filterNumbersWithTestable`方法使用两个`List<Integer>`对象，即两个`List`的`Integer`对象。我们讨论的是`Integer`而不是`int`原始类型。`Integer`是`int`原始类型的包装类。但是，我们在`Testable`接口中声明的`test`方法，然后在实现该接口的两个类中实现，接收的是`int`类型的参数，而不是`Integer`。'
- en: Java automatically converts a primitive value into an object of the corresponding
    wrapper class. Whenever we pass an object as a parameter to a method that expects
    the value of a primitive type, the Java compiler converts this object to the corresponding
    primitive type, in an operation known as **unboxing**. In the next line, the Java
    compiler converts or unboxes the `Integer` object to a value of the `int` type.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Java会自动将原始值转换为相应包装类的对象。每当我们将对象作为参数传递给期望原始类型值的方法时，Java编译器将该对象转换为相应的原始类型，这个操作称为**拆箱**。在下一行中，Java编译器将`Integer`对象转换或拆箱为`int`类型的值。
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The compiler will execute code that is equivalent to the following line that
    calls the `intValue()` method that unboxes the `Integer` to an `int`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将执行等效于调用`intValue()`方法的代码，该方法将`Integer`拆箱为`int`：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We won't write a `for` loop to populate a `List` of `Integer` objects. Instead,
    we will use the `IntStream` class that specializes `Stream<T>` to describe a stream
    of `int` primitives. These classes are defined in the `java.util.stream` package,
    and therefore, we must add an `import` statement to be able to use it in our code
    in JShell. The following line calls the `IntStream.rangeClosed` method with `1`
    and `20` as the arguments to generate an `IntStream` with `int` values from `1`
    to `20` (inclusive). The chained call to the `boxed` method converts the generated
    `IntStream` into a `Stream<Integer>`, that is, a stream of `Integer` objects boxed
    from the primitive `int` values. The chained call to the `collect` method with
    `Collectors.toList()` as an argument collects the stream of `Integer` objects
    into a `List<Integer>`, specifically, an `ArrayList<Integer>`. The `Collectors`
    class is also defined in the `java.util.stream` package. The code file for the
    sample is included in the `java_9_oop_chapter_12_01` folder, in the `example12_01.java`
    file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会编写`for`循环来填充`List`中的`Integer`对象。相反，我们将使用`IntStream`类，该类专门用于描述`int`原始类型的流。这些类定义在`java.util.stream`包中，因此，我们必须添加一个`import`语句才能在JShell中使用它。以下一行调用`IntStream.rangeClosed`方法，参数为`1`和`20`，以生成一个包含从`1`到`20`（包括）的`int`值的`IntStream`。链式调用`boxed`方法将生成的`IntStream`转换为`Stream<Integer>`，即从原始`int`值装箱成的`Integer`对象流。链式调用`collect`方法，参数为`Collectors.toList()`，将`Integer`对象流收集到`List<Integer>`中，具体来说，是一个`ArrayList<Integer>`。`Collectors`类也定义在`java.util.stream`包中。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_01.java`文件中。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Boxing and unboxing add overheads and have both performance and memory impacts.
    In some cases, we might need to rewrite our code to avoid unnecessary boxing and
    unboxing when we want to achieve the best performance.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 装箱和拆箱会增加开销，并且会对性能和内存产生影响。在某些情况下，我们可能需要重写我们的代码，以避免不必要的装箱和拆箱，从而实现最佳性能。
- en: It is very important to understand that the `collect` operation will start processing
    the pipeline to return the desired result, that is, the list generated from the
    intermediate streams. The intermediate operations aren't executed until we call
    the `collect` method. The following screenshot shows the results of executing
    the previous lines in JShell. We can see that `range1to20` is a list of `Integer`
    that includes the numbers from 1 to 20 (inclusive) boxed into `Integer` objects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要理解`collect`操作将开始处理管道以返回所需的结果，即从中间流生成的列表。在调用`collect`方法之前，中间操作不会被执行。以下屏幕截图显示了在JShell中执行前几行的结果。我们可以看到`range1to20`是一个包含从1到20（包括）的`Integer`列表，装箱成`Integer`对象。
- en: '![Understanding functions and methods as first-class citizens](img/00096.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![理解函数和方法作为一等公民](img/00096.jpeg)'
- en: 'The following lines create an instance of the `TestDivisibleBy5` class named
    `testDivisibleBy5`. Then, the code calls the `filterNumbersWithTestable` method
    with the `List<Integer> range1to20` as the `numbers` argument and the `TestDivisibleBy5`
    instance named `testDivisibleBy5` as the `tester` argument. The `List<Integer>
    divisibleBy5Numbers` will have the following values after the code runs: `[5,
    10, 15, 20]`. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_01.java` file.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个名为`testDivisibleBy5`的`TestDivisibleBy5`类的实例。然后，代码使用`List<Integer> range1to20`作为`numbers`参数，使用名为`testDivisibleBy5`的`TestDivisibleBy5`实例作为`tester`参数调用了`filterNumbersWithTestable`方法。代码运行后，`List<Integer>
    divisibleBy5Numbers`将具有以下值：`[5, 10, 15, 20]`。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_01.java`文件中。
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following lines create an instance of the `TestGreaterThan10` class named
    `testGreaterThan10`. Then, the code calls the `filterNumbersWithTestable` method
    with `range1to20` and `testGreaterThan10` as the arguments. The `List<Integer>
    greaterThan10Numbers` will have the following values after the code runs: `[11,
    12, 13, 14, 15, 16, 17, 18, 19, 20]`. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_01.java` file.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个名为`testGreaterThan10`的`TestGreaterThan10`类的实例。然后，代码使用`range1to20`和`testGreaterThan10`作为参数调用了`filterNumbersWithTestable`方法。代码运行后，`List<Integer>
    greaterThan10Numbers`将具有以下值：`[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]`。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_01.java`文件中。
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following screenshot shows the results of executing the previous lines
    in JShell:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中执行前面行的结果：
- en: '![Understanding functions and methods as first-class citizens](img/00097.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![理解函数和方法作为一等公民](img/00097.jpeg)'
- en: Working with functional interfaces and lambda expressions
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数接口和Lambda表达式
- en: We had to declare an interface and two classes to make it possible for a method
    to receive an instance of `Testable` and execute the `test` method implemented
    by each class. Luckily, Java 8 introduced **functional interfaces** and Java 9
    makes it easy for us to supply a compatible **lambda expression** whenever the
    code requires a functional interface. In a nutshell, we can write less code to
    achieve the same goal.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不声明一个接口和两个类，以使方法能够接收`Testable`的实例并执行每个类实现的`test`方法成为可能。幸运的是，Java 8引入了**函数接口**，Java
    9使我们能够在代码需要函数接口时提供兼容的**Lambda表达式**。简而言之，我们可以写更少的代码来实现相同的目标。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A functional interface is an interface that meets the following condition:
    it has a single abstract method or a single method requirement. We can create
    instances of functional interfaces with lambda expressions, method references,
    or constructor references. We will work with different examples that will allow
    us to understand lambda expressions, method references, and constructor references
    and we will see them in action.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接口是满足以下条件的接口：它具有单个抽象方法或单个方法要求。我们可以使用Lambda表达式、方法引用或构造函数引用创建函数接口的实例。我们将使用不同的示例来理解Lambda表达式、方法引用和构造函数引用，并看到它们的实际应用。
- en: The `IntPredicate` functional interface represents a function with one argument
    of the `int` type that returns a `boolean` result. Boolean-valued functions are
    known as predicates. This functional interface is defined in `java.util.function`,
    and therefore, we must include an `import` statement before we use it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntPredicate`函数接口表示具有一个`int`类型参数并返回一个`boolean`结果的函数。布尔值函数称为谓词。该函数接口在`java.util.function`中定义，因此在使用之前我们必须包含一个`import`语句。'
- en: The following lines declare the `filterNumbersWithPredicate` method that receives
    a `List<Integer>` in the `numbers` argument and an `IntPredicate` instance in
    the `predicate` argument. The code for this method is the same as the code declared
    for the `filterNumbersWithTestable` method, with the only difference being that
    instead of receiving an argument of the `Testable` type named `tester`, the new
    method receives an argument of the `IntPredicate` type named `predicate`. The
    code also calls the `test` method with each number retrieved from the list as
    an argument to evaluate. The `IntPredicate` functional interface defines an abstract
    method named `test` that receives an `int` and returns a `boolean` result. The
    code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_02.java` file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`filterNumbersWithPredicate`方法，该方法接收`List<Integer>`作为`numbers`参数，并接收`IntPredicate`实例作为`predicate`参数。该方法的代码与为`filterNumbersWithTestable`方法声明的代码相同，唯一的区别是，新方法接收的不是名为`tester`的`Testable`类型参数，而是名为`predicate`的`IntPredicate`类型参数。代码还调用了`test`方法，将从列表中检索的每个数字作为参数进行评估。`IntPredicate`函数接口定义了一个名为`test`的抽象方法，该方法接收一个`int`并返回一个`boolean`结果。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_02.java`文件中。
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The following line declares a variable named `divisibleBy5` with the `IntPredicate`
    type and assigns a lambda expression to it. Specifically, the code assigns a lambda
    expression that receives an `int` argument named `n` and returns a `boolean` value
    indicating whether the modulus, modulo, or remainder operator (`%`) between `n`
    and `5` is equal to `0`. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_02.java` file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了一个名为`divisibleBy5`的变量，类型为`IntPredicate`，并将一个Lambda表达式赋给它。具体来说，代码赋予了一个Lambda表达式，该表达式接收一个名为`n`的`int`参数，并返回一个`boolean`值，指示`n`和`5`之间的模运算（`%`）是否等于`0`。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_02.java`文件中。
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The lambda expression is composed of the following three components:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式由以下三个组件组成：
- en: '`n`: The argument list. In this case, there is just one argument, and therefore,
    we don''t need to enclose the argument list within parentheses. If we have more
    than one argument, it is necessary to enclose the list within parentheses. We
    don''t have to specify the types for the arguments.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`：参数列表。在这种情况下，只有一个参数，因此不需要用括号括起参数列表。如果有多个参数，需要用括号括起列表。我们不必为参数指定类型。'
- en: '`->`: The arrow token.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->`：箭头标记。'
- en: '`n % 5 == 0`: The body. In this case, the body is a single expression, and
    therefore, there is no need to enclose it in curly braces (`{}`). In addition,
    there is no need to write the `return` statement before the expression because
    it is a single expression.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n % 5 == 0`：主体。在这种情况下，主体是一个单一表达式，因此不需要用大括号(`{}`)括起来。此外，在表达式之前也不需要写`return`语句，因为它是一个单一表达式。'
- en: 'The previous code is equivalent to the following code. The previous code is
    the shortest version and the next line is the longest version:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码等同于以下代码。前面的代码是最短版本，下一行是最长版本：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Imagine that with any of the two versions of the previous code, we are performing
    the following tasks:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，使用前面两个版本的任何一个代码，我们正在执行以下任务：
- en: Create an anonymous class that implements the `IntPredicate` interface.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现`IntPredicate`接口的匿名类。
- en: Declare a test method in the anonymous class that receives an `int` argument
    and returns a `boolean` with the body specified after the arrow token (`->`).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在匿名类中声明一个接收`int`参数并返回`boolean`的测试方法，指定箭头标记(`->`)后的主体。
- en: Create an instance of this anonymous class.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个匿名类的实例。
- en: All these things happen under the hood whenever we enter a lambda expression
    when an `IntPredicate` is required. When we use lambda expressions for other functional
    interfaces, similar things will happen with the difference being that the method
    name, the arguments, and the return type for the method might be different.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们输入lambda表达式时，当需要`IntPredicate`时，所有这些事情都是在幕后发生的。当我们为其他函数接口使用lambda表达式时，类似的事情会发生，不同之处在于方法名称、参数和方法的返回类型可能会有所不同。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Java compiler infers the types for the arguments and the return type from
    the functional interface. Things remain strongly typed and if we make a mistake
    with types, the compiler will generate the appropriate errors and the code won't
    compile.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Java编译器从函数接口中推断出参数和返回类型的类型。事物保持强类型，如果我们在类型上犯了错误，编译器将生成适当的错误，代码将无法编译。
- en: 'The following lines call the `filterNumbersWithPredicate` method with the `List<Integer>
    range1to20` as the `numbers` argument and the `IntPredicate` instance named `divisibleBy5`
    as the `predicate` argument. The `List<Integer> divisibleBy5Numbers2` will have
    the following values after the code runs: `[5, 10, 15, 20]`. The code file for
    the sample is included in the `java_9_oop_chapter_12_01` folder, in the `example12_02.java`
    file.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行调用`filterNumbersWithPredicate`方法，使用`List<Integer> range1to20`作为`numbers`参数，名为`divisibleBy5`的`IntPredicate`实例作为`predicate`参数。代码运行后，`List<Integer>
    divisibleBy5Numbers2`将具有以下值：`[5, 10, 15, 20]`。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_02.java`文件中。
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following lines call the `filterNumbersWithPredicate` method with the `List<Integer>
    range1to20` as the `numbers` argument and a lambda expression as the `predicate`
    argument. The lambda expression receives an `int` argument named `n` and returns
    a `boolean` value indicating whether `n` is greater than `10`. The `List<Integer>
    greaterThan10Numbers2` will have the following values after the code runs: `[11,
    12, 13, 14, 15, 16, 17, 18, 19, 20]`. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_02.java` file.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行调用`filterNumbersWithPredicate`方法，使用`List<Integer> range1to20`作为`numbers`参数，使用lambda表达式作为`predicate`参数。lambda表达式接收一个名为`n`的`int`参数，并返回一个`boolean`值，指示`n`是否大于`10`。代码运行后，`List<Integer>
    greaterThan10Numbers2`将具有以下值：`[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]`。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_02.java`文件中。
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The following screenshot shows the results of executing the previous lines in
    JShell.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中执行前几行的结果。
- en: '![Working with functional interfaces and lambda expressions](img/00098.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![使用函数接口和lambda表达式](img/00098.jpeg)'
- en: The `Function<T, R>` functional interface represents a function where `T` is
    the type of the input to the function and `R` is the type of the result of the
    function. We cannot specify a primate type such as `int` for `T` because it is
    not a class, but we can use the boxed type, that is, `Integer`. We cannot use
    `boolean` for `R`, but we can use the boxed type, that is, `Boolean`. If we want
    a similar behavior than the `IntPredicate` functional interface, we can use `Function<Integer,
    Boolean>`, that is, a function with one argument of the `Integer` type that returns
    a `Boolean` result. This functional interface is defined in `java.util.function`,
    and therefore, we must include an `import` statement before we use it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function<T, R>`函数接口表示一个函数，其中`T`是函数的输入类型，`R`是函数的结果类型。我们不能为`T`指定原始类型，比如`int`，因为它不是一个类，但我们可以使用装箱类型，即`Integer`。我们不能为`R`使用`boolean`，但我们可以使用装箱类型，即`Boolean`。如果我们想要与`IntPredicate`函数接口类似的行为，我们可以使用`Function<Integer,
    Boolean>`，即一个具有`Integer`类型的参数的函数，返回一个`Boolean`结果。这个函数接口在`java.util.function`中定义，因此在使用之前，我们必须包含一个`import`语句。'
- en: The following lines declare the `filterNumbersWithFunction` method that receives
    a `List<Integer>` in the `numbers` argument and a `Function<Integer, Boolean>`
    instance in the `predicate` argument. The code for this method is the same as
    the code declared for the `filterNumbersWithCondition` method, with the difference
    being that instead of receiving an argument of the `IntPredicate` type named `predicate`,
    the new method receives an argument of the `Function<Integer, Boolean>` type named
    `function`. The code calls the `apply` method with each number retrieved from
    the list as an argument to evaluate, instead of calling the `test` method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`filterNumbersWithFunction`方法，该方法接收`numbers`参数中的`List<Integer>`和`predicate`参数中的`Function<Integer,
    Boolean>`实例。该方法的代码与`filterNumbersWithCondition`方法声明的代码相同，不同之处在于新方法接收了`Function<Integer,
    Boolean>`类型的参数`function`，而不是接收了名为`predicate`的`IntPredicate`类型的参数。代码调用`apply`方法，并将从列表中检索到的每个数字作为参数进行评估，而不是调用`test`方法。
- en: The `Function<T, R>` functional interface defines an abstract method named apply
    that receives a `T` and returns a result of type `R`. In this case, the apply
    method receives an `Integer` and returns a `Boolean` that the Java compiler will
    automatically unbox to `boolean`. The code file for the sample is included in
    the `java_9_oop_chapter_12_01` folder, in the `example12_03.java` file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function<T, R>`功能接口定义了一个名为apply的抽象方法，该方法接收一个`T`并返回类型为`R`的结果。在这种情况下，apply方法接收一个`Integer`并返回一个`Boolean`，Java编译器将自动拆箱为`boolean`。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_03.java`文件中。'
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following lines call the `filterNumbersWithFunction` method with the `List<Integer>
    range1to20` as the `numbers` argument and a lambda expression as the `function`
    argument. The lambda expression receives an `Integer` argument named `n` and returns
    a `Boolean` value indicating whether the modulus, modulo, or remainder operator
    (`%`) between `n` and `3` is equal to `0`. Java automatically boxes the `boolean`
    value generated by the expression into a `Boolean` object. The `List<Integer>
    divisibleBy3Numbers` will have the following values after the code runs: `[3,
    6, 9, 12, 15, 18]`. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_03.java` file.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行调用了`filterNumbersWithFunction`方法，将`List<Integer> range1to20`作为`numbers`参数，并将lambda表达式作为`function`参数。lambda表达式接收一个名为`n`的`Integer`参数，并返回一个`Boolean`值，指示`n`和`3`之间的模运算结果是否等于`0`。Java会自动将表达式生成的`boolean`值装箱为`Boolean`对象。代码运行后，`List<Integer>
    divisibleBy3Numbers`将具有以下值：`[3, 6, 9, 12, 15, 18]`。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_03.java`文件中。
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Java will run code that is equivalent to the following line. The `intValue()`
    function returns an `int` value for the received `Integer` instance in `n` and
    the lambda expression returns the `boolean` value generated by the expression
    evaluation in a new `Boolean` instance. However, remember that boxing and unboxing
    happens under the hood.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Java将运行等效于以下行的代码。`intValue()`函数为`n`中接收的`Integer`实例返回一个`int`值，lambda表达式返回表达式评估生成的`boolean`值的新`Boolean`实例。但是，请记住，装箱和拆箱是在幕后发生的。
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are more than 40 functional interfaces defined in `java.util.function`.
    We just worked with two of them that were capable of working with the same lambda
    expression. We could dedicate an entire book to analyze all the functional interfaces
    in detail. We will keep our focus on mixing object-oriented with functional programming.
    However, it is very important to know that we must check all the functional interfaces
    defined in `java.util.function` before declaring a customized one.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`java.util.function`中定义了40多个功能接口。我们只使用了其中两个能够处理相同lambda表达式的接口。我们可以专门撰写一本书来详细分析所有功能接口。我们将继续专注于将面向对象与函数式编程相结合。然而，非常重要的是要知道，在声明自定义功能接口之前，我们必须检查`java.util.function`中定义的所有功能接口。
- en: Creating a functional version of array filtering
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数组过滤的功能性版本
- en: The preceding code that declared the `filterNumbersWithFunction` method represents
    an imperative version of array filtering with an external `for` loop. We can use
    the `filter` method available for a `Stream<T>` object, in this case, a `Stream<Integer>`
    object, and achieve the same goal with a functional approach.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 先前声明的`filterNumbersWithFunction`方法代表了使用外部`for`循环进行数组过滤的命令式版本。我们可以使用`Stream<T>`对象的`filter`方法，在这种情况下是`Stream<Integer>`对象，并以函数式方法实现相同的目标。
- en: The next lines use a functional approach to generate a `List<Integer>` with
    the numbers included in the `List<Integer> range1to20` that are divisible by `3`.
    The code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_04.java` file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行使用了一种功能性方法来生成一个`List<Integer>`，其中包含在`List<Integer> range1to20`中的能被`3`整除的数字。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_04.java`文件中。
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we want the previous code to run in JShell, we must enter all the code in
    a single line, which wouldn't be necessary for the Java compiler to successfully
    compile the code. It is a specific problem with JShell, streams, and lambda expression.
    This makes the code a bit difficult to understand. Hence, the next lines show
    another version of the code that uses multiple lines, won't work in JShell, but
    will make it easier to understand the code. Just take into account that you must
    enter the code in a single line in the next examples. The code files use single
    lines. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_04.java` file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望先前的代码在JShell中运行，我们必须将所有代码输入到单行中，这对于Java编译器成功编译代码并不是必需的。这是JShell、流和lambda表达式的一个特定问题。这使得代码有点难以理解。因此，接下来的几行展示了另一个使用多行的代码版本，这在JShell中不起作用，但会使代码更容易理解。只需注意，在下面的示例中，您必须将代码输入到单行中。代码文件使用单行。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_04.java`文件中。
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `stream` method generates a `Stream<Integer>` from the `List<Integer>`.
    A **stream** is a sequence of elements of a specific type that allow us to perform
    computations or aggregate operations with sequential or parallel executions. In
    fact, we can chain many stream operations and compose a stream pipeline. These
    computations have a lazy execution, that is, they won't be computed until there
    is a terminal operation such as a request to collect the final data into a `List`
    of a specific type.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`stream`方法从`List<Integer>`生成一个`Stream<Integer>`。**流**是特定类型的元素序列，允许我们执行顺序或并行执行的计算或聚合操作。实际上，我们可以链接许多流操作并组成流管道。这些计算具有延迟执行，也就是说，直到有终端操作（例如请求将最终数据收集到特定类型的`List`中）之前，它们不会被计算。'
- en: The `filter` method receives a `Predicate<Integer>` as an argument and we apply
    it to the `Stream<Integer>`. The `filter` method returns the stream of the elements
    of the input stream that matches the specified predicate. The method returns a
    stream with all the elements for whom the `Predicate<Integer>` evaluates to `true`.
    We passed that previously explained lambda expression as an argument for the `filter`
    method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`方法接收一个`Predicate<Integer>`作为参数，并将其应用于`Stream<Integer>`。`filter`方法返回输入流的元素流，这些元素与指定的谓词匹配。该方法返回一个流，其中包含所有`Predicate<Integer>`评估为`true`的元素。我们将先前解释的lambda表达式作为`filter`方法的参数传递。'
- en: 'The `collect` method receives a `Stream<Integer>` returned by the `filter`
    method. We passed `Collectors.toList()` as an argument to the `collect` method
    to perform a mutable reduction operation on the elements of the `Stream<Integer>`
    and generate a `List<Integer>`, that is, a mutable result container. The `List<Integer>
    divisibleBy3Numbers2` will have the following values after the code runs: `[3,
    6, 9, 12, 15, 18]`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect`方法接收`filter`方法返回的`Stream<Integer>`。我们将`Collectors.toList()`作为`collect`方法的参数传递，以对`Stream<Integer>`的元素执行可变归约操作，并生成`List<Integer>`，即可变结果容器。代码运行后，`List<Integer>
    divisibleBy3Numbers2`将具有以下值：`[3, 6, 9, 12, 15, 18]`。'
- en: Now, we want to follow a functional approach to print each number in the resulting
    `List<Integer>`. `List<T>` implements the `Iterable<T>` interface that allows
    us to call the `forEach` method to perform the action specified as an argument
    for each element of the `Iterable` until all the elements have been processed
    or the action throws an exception. The action argument for the `forEach` method
    must be a `Consumer<T>`, and therefore, in our case, it must be a `Consumer<Integer>`
    because we will call the `forEach` method for the resulting `List<Integer>`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望采用功能方法来打印结果`List<Integer>`中的每个数字。`List<T>`实现了`Iterable<T>`接口，允许我们调用`forEach`方法对`Iterable`的每个元素执行指定为参数的操作，直到所有元素都被处理或操作引发异常。`forEach`方法的操作参数必须是`Consumer<T>`，因此在我们的情况下，它必须是`Consumer<Integer>`，因为我们将为结果`List<Integer>`调用`forEach`方法。
- en: A `Consumer<T>` is a functional interface that represents an operation that
    accesses a single input argument of type `T` and returns no result (`void`). The
    `Consumer<T>` functional interface defines an abstract method named `accept` that
    receives an argument of type `T` and returns no result. The following lines pass
    a lambda expression as an argument to the `forEach` method. The lambda expression
    generates a `Consumer<Integer>` that prints the number received in `n`. The code
    file for the sample is included in the `java_9_oop_chapter_12_01` folder, in the
    `example12_04.java` file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer<T>`是一个函数接口，表示访问类型为`T`的单个输入参数并返回无结果（`void`）的操作。`Consumer<T>`函数接口定义了一个名为`accept`的抽象方法，该方法接收类型为`T`的参数并返回无结果。以下行将lambda表达式作为`forEach`方法的参数传递。lambda表达式生成一个`Consumer<Integer>`，打印接收到的`n`。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_04.java`文件中。'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As a result of the previous line, we will see the following numbers printed
    in JShell:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上一行的结果，我们将在JShell中看到以下数字的打印：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The lambda expression that generates the `Consumer<Integer>` calls the `System.out.println`
    method with an `Integer` as an argument. We can use a method reference instead
    of a lambda expression to invoke an existing method. In this case, we can replace
    the previously shown lambda expression with `System.out::println`, that is, a
    method reference that invokes the `println` method for `System.out`. The Java
    runtime infers the method type arguments whenever we use a method reference; in
    this case, the method type argument is a single `Integer`. The code file for the
    sample is included in the `java_9_oop_chapter_12_01` folder, in the `example12_04.java`
    file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 生成`Consumer<Integer>`的lambda表达式调用`System.out.println`方法，并将`Integer`作为参数。我们可以使用方法引用来调用现有方法，而不是使用lambda表达式。在这种情况下，我们可以用`System.out::println`替换先前显示的lambda表达式，即调用`System.out`的`println`方法的方法引用。每当我们使用方法引用时，Java运行时都会推断方法类型参数；在这种情况下，方法类型参数是单个`Integer`。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_04.java`文件中。
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The code will produce the same results as the previous call to `forEach` with
    the lambda expression. The following screenshot shows the results of executing
    the previous lines in JShell:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将产生与先前对lambda表达式调用`forEach`相同的结果。以下屏幕截图显示了在JShell中执行先前行的结果：
- en: '![Creating a functional version of array filtering](img/00099.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![创建数组过滤的功能版本](img/00099.jpeg)'
- en: We can capture variables that aren't defined within the lambda expression. When
    a lambda captures variables from the outside world, we can also call them closures.
    For example, the following lines declare an `int` variable named `byNumber` and
    assigns `4` to this variable. Then, the next lines use a new version of the combination
    of stream, filter, and collect to generate a `List<Integer>` with the numbers
    that are divisible by the number specified in the `byNumber` variable. The lambda
    expression includes `byNumber` and Java captures this variable from the outside
    world under the hood. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_04.java` file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以捕获在lambda表达式中未定义的变量。当lambda从外部世界捕获变量时，我们也可以称之为闭包。例如，以下行声明了一个名为`byNumber`的`int`变量，并将`4`赋给该变量。然后，下一行使用流、过滤器和收集的新版本来生成一个`List<Integer>`，其中包含能被`byNumber`变量指定的数字整除的数字。lambda表达式包括`byNumber`，Java在幕后从外部世界捕获了这个变量。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_04.java`文件中。
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As a result of the previous line, we will see the following numbers printed
    in JShell:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前一行的结果，我们将在JShell中看到以下数字的打印：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we use a lambda expression that doesn't match a functional interface, the
    code won't compile and the Java compiler will generate the appropriate errors.
    For example, the following line tries to assign a lambda expression that returns
    an `int` instead of either a `Boolean` or a `boolean` to an `IntPredicate` variable.
    The code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_05.java` file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一个与函数式接口不匹配的lambda表达式，代码将无法编译，Java编译器将生成适当的错误。例如，以下行尝试将返回`int`而不是`Boolean`或`boolean`的lambda表达式分配给`IntPredicate`变量。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_05.java`文件中。
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'JShell will display the following errors, indicating to us that `int` cannot
    be converted to `boolean`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: JShell将显示以下错误，向我们指出`int`无法转换为`boolean`：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating a data repository with generics and interfaces
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型和接口创建数据仓库
- en: Now we want to create a repository that provides us with entities so that we
    can apply the functional programming features included in Java 9 to retrieve and
    process data from these entities. First, we will create an `Identifiable` interface
    that defines the requirements for an identifiable entity. We want any class that
    implements this interface to provide a `getId` method that returns an `int` with
    the value of a unique identifier for the entity. The code file for the sample
    is included in the `java_9_oop_chapter_12_01` folder, in the `example12_06.java`
    file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要创建一个仓库，为我们提供实体，以便我们可以应用Java 9中包含的函数式编程特性来检索和处理这些实体的数据。首先，我们将创建一个`Identifiable`接口，该接口定义了可识别实体的要求。我们希望实现此接口的任何类都提供一个`getId`方法，该方法返回一个`int`，其值为实体的唯一标识符。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_06.java`文件中。
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The next lines create a `Repository<E>` generic interface that specifies that
    `E` must implement the recently created `Identifiable` interface in the generic
    type constraint. The class declares a `getAll` method that returns a `List<E>`.
    Each class that implements the interface must provide its own implementation for
    this method. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_06.java` file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的行创建了一个`Repository<E>`通用接口，该接口指定`E`必须实现最近创建的`Identifiable`接口的通用类型约束。该类声明了一个`getAll`方法，该方法返回一个`List<E>`。实现该接口的每个类都必须为此方法提供自己的实现。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_06.java`文件中。
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The next lines create the `Entity` abstract class, which is the base class for
    all the entities. The class implements the `Identifiable` interface and defines
    an immutable `id` protected field of the `int` type. The constructor receives
    the desired value for the `id` immutable field and initializes the fields with
    the received value. The abstract class implements the `getId` method that returns
    the value for the `id` immutable field. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_06.java` file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的行创建了`Entity`抽象类，它是所有实体的基类。该类实现了`Identifiable`接口，并定义了一个`int`类型的不可变`id`受保护字段。构造函数接收`id`不可变字段的期望值，并使用接收到的值初始化字段。抽象类实现了`getId`方法，该方法返回`id`不可变字段的值。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_06.java`文件中。
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The next lines create the `MobileGame` class, specifically, a subclass of the
    previously created `Entity` abstract class. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_06.java` file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的行创建了`MobileGame`类，具体来说，是先前创建的`Entity`抽象类的子类。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_06.java`文件中。
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The class declares many public fields whose values are initialized with the
    constructor: `name`, `highestScore`, `lowestScore`, and `playersCount`. The field
    is immutable but the other three are mutable. We don''t use getters or setters
    in order to keep things simpler. However, it is important to take into account
    that some frameworks that allow us to work with entities require us to use getters
    for all the fields and setters when the fields aren''t read-only.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该类声明了许多公共字段，它们的值在构造函数中初始化：`name`，`highestScore`，`lowestScore`和`playersCount`。该字段是不可变的，但其他三个是可变的。我们不使用getter或setter来保持事情更简单。但是，重要的是要考虑到，一些允许我们使用实体的框架要求我们对所有字段使用getter，并且在字段不是只读时使用setter。
- en: In addition, the class overrides the `toString` method inherited from the `java.lang.Object`
    class and that must return a `String` representation for the entity. The code
    declared in this method uses an instance of the `java.lang.StringBuilder` class
    (`sb`) to append many strings in an efficient way and finally return the results
    of calling the `sb.toString` method to return the generated `String`. This method
    uses the protected separator immutable string that determines the separator we
    use between fields. Whenever we call `System.out.println` with an instance of
    `MobileGame` as an argument, the `println` method will call the overridden `toString`
    method to print the `String` representation for the instance.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该类重写了从`java.lang.Object`类继承的`toString`方法，必须为实体返回一个`String`表示。此方法中声明的代码使用`java.lang.StringBuilder`类的一个实例（`sb`）以一种高效的方式附加许多字符串，最后返回调用`sb.toString`方法的结果以返回生成的`String`。此方法使用受保护的分隔符不可变字符串，该字符串确定我们在字段之间使用的分隔符。每当我们使用`MobileGame`的实例调用`System.out.println`时，`println`方法将调用重写的`toString`方法来打印该实例的`String`表示。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We might also use `String` concatenation (`+`) or `String.format` to write the
    code for the `toString` method because we will work with just 15 instances of
    the `MobileGame` class. However, it is a good practice to work with `StringBuilder`
    whenever we have to concatenate many strings to produce a result and we want to
    make sure that we will have the best performance when executing the code. In our
    simple example, any implementation won't have any performance issues.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`String`连接（`+`）或`String.format`来编写`toString`方法的代码，因为我们将只使用`MobileGame`类的15个实例。然而，当我们必须连接许多字符串以生成结果并且希望确保在执行代码时具有最佳性能时，最好使用`StringBuilder`。在我们的简单示例中，任何实现都不会有任何性能问题。
- en: The following lines create the `MemoryMobileGameRepository` concrete class that
    implements the `Repository<MobileGame>` interface. Notice that we don't say `Repository<E>`
    but instead we indicate `Repository<MobileGame>`, because we already know the
    value for the `E` type parameter that we will implement in our class. We aren't
    creating a `MemoryMobileGameRepository<E extends Identifiable>`. Instead, we are
    creating a non-generic concrete class that implements a generic interface and
    sets the value for the parameter type `E` to `MobileGame`. The code file for the
    sample is included in the `java_9_oop_chapter_12_01` folder, in the `example12_06.java`
    file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了实现`Repository<MobileGame>`接口的`MemoryMobileGameRepository`具体类。请注意，我们不说`Repository<E>`，而是指出`Repository<MobileGame>`，因为我们已经知道我们将在我们的类中实现的`E`类型参数的值。我们不是创建一个`MemoryMobileGameRepository<E
    extends Identifiable>`。相反，我们正在创建一个非泛型的具体类，该类实现了一个泛型接口并将参数类型`E`的值设置为`MobileGame`。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_06.java`文件中。
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The class implements the `getAll` method required by the `Repository<E>` interface.
    In this case, the method returns a `List` of `MobileGame` (`List<MobileGame>`),
    specifically an `ArrayList<MobileGame>`. The method creates 15 `MobileGame` instances
    and appends them to an `ArrayList` of `MobileGame` that the method returns as
    a result.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该类实现了`Repository<E>`接口所需的`getAll`方法。在这种情况下，该方法返回一个`MobileGame`的`List`（`List<MobileGame>`），具体来说是一个`ArrayList<MobileGame>`。该方法创建了15个`MobileGame`实例，并将它们附加到一个`MobileGame`的`ArrayList`，该方法作为结果返回。
- en: The following lines create an instance of the `MemoryMobileGameRepository` class
    and call the `forEach` method for the `List<MobileGame>` returned by the `getAll`
    method. The `forEach` method calls a body on each element in the list, as is done
    in a `for` loop. The closure specified as an argument for the `forEach` method
    calls the `System.out.println` method with the `MobileGame` instance as an argument.
    This way, Java uses the `toString` method overridden in the `MobileGame` class
    to generate a `String` representation for each `MobileGame` instance. The code
    file for the sample is included in the `java_9_oop_chapter_12_01` folder, in the
    `example12_06.java` file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了`MemoryMobileGameRepository`类的一个实例，并为`getAll`方法返回的`List<MobileGame>`调用`forEach`方法。`forEach`方法在列表中的每个元素上调用一个体，就像在`for`循环中一样。作为`forEach`方法参数指定的闭包调用`System.out.println`方法，并将`MobileGame`实例作为参数。这样，Java使用`MobileGame`类中重写的`toString`方法为每个`MobileGame`实例生成一个`String`表示。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_06.java`文件中。
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following lines show the output generated after executing the previous
    code that prints the `String` returned by the `toString()` method for each `MobileGame`
    instance:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示在执行打印每个`MobileGame`实例的`toString()`方法返回的`String`后生成的输出：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Filtering collections with complex conditions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用复杂条件过滤集合
- en: We can use our new repository to restrict the results retrieved from complex
    data. We can combine a call to the `getAll` method with stream, filter, and collect
    to generate a `Stream<MobileGame>`, apply a filter with a lambda expression as
    an argument, and call the `collect` method with `Collectors.toList()` as an argument
    to generate a filtered `List<MobileGame>` from the filtered `Stream<MobileGame>`.
    The `filter` method receives a `Predicate<MobileGame>` as an argument that we
    generate with a lambda expression and we apply the filter to the `Stream<MobileGame>`.
    The `filter` method returns the stream of the elements of the input stream that
    matches the specified predicate. The method returns a stream with all the elements
    for whom the `Predicate<MobileGame>` evaluates to `true`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的新存储库来限制从复杂数据中检索的结果。我们可以将对`getAll`方法的调用与流、过滤器和收集结合起来，以生成一个`Stream<MobileGame>`，应用一个带有lambda表达式作为参数的过滤器，并调用`collect`方法，并将`Collectors.toList()`作为参数，从过滤后的`Stream<MobileGame>`生成一个过滤后的`List<MobileGame>`。`filter`方法接收一个`Predicate<MobileGame>`作为参数，我们使用lambda表达式生成该谓词，并将该过滤器应用于`Stream<MobileGame>`。`filter`方法返回输入流的元素流，这些元素流与指定的谓词匹配。该方法返回一个流，其中所有元素的`Predicate<MobileGame>`评估为`true`。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The next lines show code snippets that use multiple lines, won't work in JShell,
    but will make it easier to read and understand the code. If we want the code to
    run in JShell, we must enter all the code in a single line, which wouldn't be
    necessary for the Java compiler to successfully compile the code. It is a specific
    problem with JShell, streams, and lambda expression. The code files use single
    lines to be compatible with JShell.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的行显示了使用多行的代码片段，这在JShell中无法工作，但将使代码更易于阅读和理解。如果我们希望代码在JShell中运行，我们必须将所有代码输入到一行中，这对于Java编译器成功编译代码并不是必需的。这是JShell、流和lambda表达式的一个特定问题。代码文件使用单行以与JShell兼容。
- en: The following lines declare the new `getWithLowestScoreGreaterThan` method for
    the `MemoryMobileGameRepository` class. Notice that we don't include all the code
    for the new class in order to avoid repetition. The code file for the sample is
    included in the `java_9_oop_chapter_12_01` folder, in the `example12_07.java`
    file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`MemoryMobileGameRepository`类的新`getWithLowestScoreGreaterThan`方法。请注意，为了避免重复，我们没有包含新类的所有代码。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_07.java`文件中。
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following lines use the `MemoryMobileGameRepository` instance named `repository`
    to call the previously added method and then chain a call to `forEach` to print
    all the games whose `lowestScore` value is greater than `1000`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行使用名为`repository`的`MemoryMobileGameRepository`实例调用先前添加的方法，然后链式调用`forEach`以打印所有`lowestScore`值大于`1000`的游戏：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following lines show the output generated after executing the previous
    code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行前面代码后生成的输出：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The following lines declare the new `getStartingWith` method for the `MemoryMobileGameRepository`
    class. The lambda expression passed as an argument to the `filter` method returns
    the results of calling the `startsWith` method for the game's name with the prefix
    received as an argument. In this case, the lambda expression is a closure that
    captures the `prefix` argument and uses it within the lambda expression body.
    The code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_08.java` file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`MemoryMobileGameRepository`类的新`getStartingWith`方法。作为`filter`方法参数传递的lambda表达式返回调用游戏名称的`startsWith`方法的结果，该方法使用作为参数接收的前缀。在这种情况下，lambda表达式是一个闭包，它捕获了`prefix`参数，并在lambda表达式体内使用它。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_08.java`文件中。
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The following lines use the `MemoryMobileGameRepository` instance named `repository`
    to call the previously added method and then chain a call to `forEach` to print
    all the games whose names starts with `"Su"`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行使用名为`repository`的`MemoryMobileGameRepository`实例调用先前添加的方法，然后链式调用`forEach`以打印所有以`"Su"`开头的游戏的名称。
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following lines show the output generated after executing the previous
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行前面代码后生成的输出：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The following lines declare the new `getByPlayersCountAndHighestScore` method
    for the `MemoryMobileGameRepository` class. The method returns an `Optional<MobileGame>`,
    that is, a container object which may contain a `MobileGame` instance or it may
    be empty. If there is a value, the `isPresent` method will return `true` and we
    will be able to retrieve the `MobileGame` instance by calling the `get` method.
    In this case, the code calls the `findFirst` method chained to the call to the
    `filter` method. The `findFirst` method returns an `Optional<T>`, in this case,
    an `Optional<MobileGame>` with the first element in the `Stream<MobileGame>` generated
    by the `filter` method. Notice that we aren't sorting the results at any time.
    The code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_09.java` file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了`MemoryMobileGameRepository`类的新`getByPlayersCountAndHighestScore`方法。该方法返回一个`Optional<MobileGame>`，即一个可能包含`MobileGame`实例的容器对象，也可能为空。如果有值，`isPresent`方法将返回`true`，我们将能够通过调用`get`方法检索`MobileGame`实例。在这种情况下，代码调用了`findFirst`方法链接到`filter`方法的调用。`findFirst`方法返回一个`Optional<T>`，在这种情况下，是由`filter`方法生成的`Stream<MobileGame>`中的第一个元素的`Optional<MobileGame>`。请注意，我们在任何时候都没有对结果进行排序。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_09.java`文件中。
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The following lines use the `MemoryMobileGameRepository` instance named `repository`
    to call the previously added method. The code calls the `isPresent` method after
    each call to the `getByPlayersCountAndHighestScore` method to determine whether
    the `Optional<MobileGame>` has an instance. If the method returns `true`, the
    code calls the `get` method to retrieve the `MobileGame` instance from the `Optional<MobileGame>`.
    The code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_09.java` file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行使用名为`repository`的`MemoryMobileGameRepository`实例调用先前添加的方法。在每次调用`getByPlayersCountAndHighestScore`方法后，代码调用`isPresent`方法来确定`Optional<MobileGame>`是否有实例。如果方法返回`true`，代码将调用`get`方法从`Optional<MobileGame>`中检索`MobileGame`实例。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_09.java`文件中。
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following lines show the output generated with the previous code. In the
    first call, there was a mobile game that matched the search criteria. In the second
    call, there is no `MobileGame` instance that matches the search criteria:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行前面代码后生成的输出。在第一次调用中，有一个符合搜索条件的移动游戏。在第二次调用中，没有符合搜索条件的`MobileGame`实例：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following screenshot shows the results of executing the previous lines
    in JShell:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中执行前面行的结果：
- en: '![Filtering collections with complex conditions](img/00100.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![使用复杂条件过滤集合](img/00100.jpeg)'
- en: Using a map operation to transform values
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用map操作来转换值
- en: The following lines declare a new `getGameNamesTransformedToUpperCase` method
    for our previously coded `MemoryMobileGameRepository` class. The new method performs
    one of the simplest map operations. The call to the `map` method transforms a
    `Stream<MobileGame>` into a `Stream<String>`.The lambda expression passed as an
    argument to the `map` method generates a `Function<MobileGame, String>`, that
    is, it receives a `MobileGame` argument and returns a `String`. The call to the
    `collect` method generates a `List<String>` from the `Stream<String>` returned
    by the `map` method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行为我们先前编写的`MemoryMobileGameRepository`类声明了一个新的`getGameNamesTransformedToUpperCase`方法。新方法执行了最简单的map操作之一。对`map`方法的调用将`Stream<MobileGame>`转换为`Stream<String>`。作为`map`方法参数传递的lambda表达式生成了一个`Function<MobileGame,
    String>`，即它接收一个`MobileGame`参数并返回一个`String`。对`collect`方法的调用从`map`方法返回的`Stream<String>`生成了一个`List<String>`。
- en: The code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_10.java` file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_10.java`文件中。
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `getGameNamesTransformedToUpperCase` method returns a `List<String>`. The
    `map` method transforms each `MobileGame` instance in the `Stream<MobileGame>`into
    a `String` with the `name` field converted to uppercase. This way, the `map` method
    transforms a `Stream<MobileGame>` into a `List<String>`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`getGameNamesTransformedToUpperCase`方法返回一个`List<String>`。`map`方法将`Stream<MobileGame>`中的每个`MobileGame`实例转换为一个带有`name`字段转换为大写的`String`。这样，`map`方法将`Stream<MobileGame>`转换为`List<String>`。'
- en: The following lines use the `MemoryMobileGameRepository` instance named `repository`
    to call the previously added method and generate a list of the game names converted
    to uppercase strings. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_10.java` file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行使用名为`repository`的`MemoryMobileGameRepository`实例调用先前添加的方法，并生成一个转换为大写字符串的游戏名称列表。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_10.java`文件中。
- en: '[PRE47]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following lines show the output generated after executing the previous
    code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示执行先前代码后生成的输出：
- en: '[PRE48]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The following code creates a new `NamesForMobileGame` class with two constructors.
    The code file for the sample is included in the `java_9_oop_chapter_12_01` folder,
    in the `example12_11.java` file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个新的`NamesForMobileGame`类，其中包含两个构造函数。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_11.java`文件中。
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `NamesForMobileGame` class declares two immutable fields of the `String`
    type: `upperCaseName` and `lowerCaseName`. One of the constructors receives a
    `nameString` and saves it converted to uppercase in the `upperCaseName` field
    and saves it converted to lowercase in the `lowerCaseName` field. The other constructor
    receives a `MobileGame` instance and calls the previously explained constructor
    with the `name` field for the received `MobileGame` instance as an argument.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`NamesForMobileGame`类声明了两个`String`类型的不可变字段：`upperCaseName`和`lowerCaseName`。其中一个构造函数接收一个`nameString`，并将其转换为大写保存在`upperCaseName`字段中，并将其转换为小写保存在`lowerCaseName`字段中。另一个构造函数接收一个`MobileGame`实例，并使用接收到的`MobileGame`实例的`name`字段作为参数调用先前解释的构造函数。'
- en: The following code adds a new `getNamesForMobileGames` method to the `MemoryMobileGameRepository`
    class. The new method performs a map operation. The call to the `map` method transforms
    a `Stream<MobileGame>` into a `Stream<NamesForMobileGame>`. The lambda expression
    passed as an argument to the `map` method generates a `Function<MobileGame, NamesForMobileGame>`,
    that is, it receives a `MobileGame` argument and returns an instance of `NamesForMobileGame`
    by calling the constructor that receives a `name` as an argument. The call to
    the `collect` method generates a `List<NamesForMobileGame>` from the `Stream<NamesForMobileGame>`
    returned by the `map` method. The code file for the sample is included in the
    `java_9_oop_chapter_12_01` folder, in the `example12_11.java` file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码为我们先前编写的`MemoryMobileGameRepository`类添加了一个新的`getNamesForMobileGames`方法。新方法执行了一个map操作。对`map`方法的调用将`Stream<MobileGame>`转换为`Stream<NamesForMobileGame>`。作为`map`方法参数传递的lambda表达式生成了一个`Function<MobileGame,
    NamesForMobileGame>`，即它接收一个`MobileGame`参数，并通过调用接收一个`name`作为参数的构造函数返回一个`NamesForMobileGame`实例。对`collect`方法的调用从`map`方法返回的`Stream<NamesForMobileGame>`生成了一个`List<NamesForMobileGame>`。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_11.java`文件中。
- en: '[PRE50]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The following lines use the `MemoryMobileGameRepository` instance named `repository`
    to call the previously added method. The lambda expression passed as an argument
    to the `forEach` method declares a body enclosed in curly braces because it requires
    many lines. This body uses an instance of the `java.lang.StringBuilder` class
    (`sb`) to append many strings with the uppercase name, a separator, and a lower
    case name. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_11.java` file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行使用名为`repository`的`MemoryMobileGameRepository`实例调用先前添加的方法。作为`forEach`方法参数传递的lambda表达式声明了一个用大括号括起来的主体，因为它需要多行。此主体使用`java.lang.StringBuilder`类的一个实例(`sb`)来附加许多带有大写名称、分隔符和小写名称的字符串。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_11.java`文件中。
- en: '[PRE51]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following lines show the output generated after executing the previous
    code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示执行先前代码后生成的输出：
- en: '[PRE52]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The next code shows another version of the `getNamesForMobileGames` method
    named `getNamesForMobileGamesV2` that is equivalent and produces the same results.
    In this case, we replaced the lambda expression that generates a `Function<MobileGame,
    NamesForMobileGame>` with the constructor reference method: `NamesForMobileGame::new`.
    The constructor reference method is specified with the class name followed by
    `::new` and will create a new instance of the `NamesForMobileGame` by using the
    constructor that receives a `MobileGame` instance as an argument. The code file
    for the sample is included in the `java_9_oop_chapter_12_01` folder, in the `example12_12.java`
    file.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码显示了`getNamesForMobileGames`方法的另一个版本，名为`getNamesForMobileGamesV2`，它是等效的并产生相同的结果。在这种情况下，我们用构造函数引用方法替换了生成`Function<MobileGame,
    NamesForMobileGame>`的lambda表达式：`NamesForMobileGame::new`。构造函数引用方法是指定类名后跟`::new`，将使用接收`MobileGame`实例作为参数的构造函数创建`NamesForMobileGame`的新实例。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中，`example12_12.java`文件中。
- en: '[PRE53]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The following code uses the new version of the method and produces the same
    results shown for the first version. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_12.java` file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用方法的新版本，并产生了第一个版本显示的相同结果。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中，`example12_12.java`文件中。
- en: '[PRE54]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Combining a map operation with reduce
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合地图操作和减少
- en: The following lines show an imperative code version of a `for` loop that calculates
    the sum of all the `lowestScore` values for the mobile games. The code file for
    the sample is included in the `java_9_oop_chapter_12_01` folder, in the `example12_13.java`
    file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了一个`for`循环的命令式代码版本，用于计算移动游戏的所有`lowestScore`值的总和。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中，`example12_13.java`文件中。
- en: '[PRE55]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The code is very easy to understand. The `lowestScoreSum` variable has a starting
    value of `0`, and each iteration of the `for` loop retrieves a `MobileGame` instance
    from the `List<MobileGame>` returned by the `repository.getAll()` method and increases
    the value of the `lowestScoreSum` variable with the value of the `mobileGame.lowestScore`
    field.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常容易理解。`lowestScoreSum`变量的初始值为`0`，`for`循环的每次迭代从`repository.getAll()`方法返回的`List<MobileGame>`中检索一个`MobileGame`实例，并增加`lowestScoreSum`变量的值与`mobileGame.lowestScore`字段的值。
- en: We can combine the map and reduce operations to create a functional version
    of the previous imperative code to calculate the sum of all the `lowestScore`
    values for the mobile games. The next lines chain a call to `map` to a call to
    `reduce` to achieve this goal. Take a look at the following code. The code file
    for the sample is included in the `java_9_oop_chapter_12_01` folder, in the `example12_14.java`
    file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将地图和减少操作结合起来，以创建先前命令式代码的功能版本，以计算移动游戏的所有“lowestScore”值的总和。下一行将`map`的调用链接到`reduce`的调用，以实现这个目标。看一下以下代码。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中，`example12_14.java`文件中。
- en: '[PRE56]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'First, the code uses the call to `map` to transform a `Stream<MobileGame>`
    into a `Stream<Integer>` with the values specified in the `lowestScore` stored
    property boxed into `Integer` objects. Then, the code calls the `reduce` method
    that receives two arguments: the initial value for an accumulated value, `0`,
    and a combine closure that will be repeatedly called with the accumulated value.
    The method returns the results of the repeated calls to the combine closure.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码使用调用`map`将`Stream<MobileGame>`转换为`Stream<Integer>`，其中`lowestScore`存储属性中的值被装箱为`Integer`对象。然后，代码调用`reduce`方法，该方法接收两个参数：累积值的初始值`0`和一个组合闭包，该闭包将重复调用累积值。该方法返回对组合闭包的重复调用的结果。
- en: The closure specified in the second argument for the `reduce` method receives
    `sum` and `lowestScore` and returns the sum of both values. Hence, the closure
    returns the sum of the total accumulated so far plus the `lowestScore` value that
    is processed. We can add a `System.out.println` statement to display the values
    for both `sum` and `lowestScore` within the closure specified in the second argument
    for the `reduce` method. The following lines show a new version of the previous
    code that adds the line with the `System.out.println` statement that will allow
    us to dive deep into how the `reduce` operation works. The code file for the sample
    is included in the `java_9_oop_chapter_12_01` folder, in the `example12_15.java`
    file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`方法的第二个参数中指定的闭包接收`sum`和`lowestScore`，并返回这两个值的总和。因此，闭包返回到目前为止累积的总和加上处理的`lowestScore`值。我们可以添加一个`System.out.println`语句，以显示`reduce`方法的第二个参数中指定的闭包中的`sum`和`lowestScore`的值。以下行显示了先前代码的新版本，其中添加了包含`System.out.println`语句的行，这将允许我们深入了解`reduce`操作的工作原理。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中，`example12_15.java`文件中。'
- en: '[PRE57]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The following lines show the results for the previous lines, where we can see
    how the value for the `sum` argument starts with the initial value specified in
    the first argument for the `reduce` method (`0`) and accumulates the sum completed
    so far. Finally, the `lowestScoreSum2` variable holds the sum of all the `lowestScore`
    values. We can see that the last value printed for `sum` and `lowestScore` are
    `10910` and `5`. The last piece of code executed for the reduce operation computes
    `10910` plus `5` and returns `10915`, which is the result saved in the `lowestScoreSum2`
    variable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了先前行的结果，我们可以看到`sum`参数的值从`reduce`方法的第一个参数中指定的初始值（`0`）开始，并累积到目前为止的总和。最后，`lowestScoreSum2`变量保存了所有`lowestScore`值的总和。我们可以看到`sum`和`lowestScore`的最后一个值分别为`10910`和`5`。对于减少操作执行的最后一段代码计算`10910`加`5`并返回`10915`，这是保存在`lowestScoreSum2`变量中的结果。
- en: '[PRE58]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the previous example, we combined map and reduce to perform a sum. We can
    take advantage of the reduction methods provided by Java 9 to achieve the same
    goal with simplified code. In the following code, we take advantage of `mapToInt`
    to generate an `IntStream`; the sum works with `int` values and doesn't have to
    unbox `Integer` to `int`. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_16.java` file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们结合使用map和reduce来执行求和。我们可以利用Java 9提供的简化代码来实现相同的目标。在下面的代码中，我们利用`mapToInt`生成一个`IntStream`；sum使用`int`值工作，不需要将`Integer`转换为`int`。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中，名为`example12_16.java`。
- en: '[PRE59]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The next lines also produce the same results with a different pipeline that
    is not as efficient as the previously shown one. The `map` method has to box the
    returned `int` into an `Integer` and returns a `Stream<Integer>`. Then, the call
    to the `collect` method specifies a call to `Collectors.summingInt` as an argument.
    `Collectors.summingInt` requires `int` values to compute the sum, and therefore,
    we pass a method reference to call the `intValue` method for each `Integer` in
    the `Stream<Integer>`. The following lines use the `Collectors.summingInt` collector
    to perform the sum of the `int` values. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_17.java` file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的行也使用了不太高效的不同管道产生相同的结果。`map`方法必须将返回的`int`装箱为`Integer`并返回一个`Stream<Integer>`。然后，对`collect`方法的调用指定了对`Collectors.summingInt`的调用作为参数。`Collectors.summingInt`需要`int`值来计算总和，因此，我们传递了一个方法引用来调用`Stream<Integer>`中每个`Integer`的`intValue`方法。以下行使用`Collectors.summingInt`收集器来执行`int`值的求和。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中，名为`example12_17.java`。
- en: '[PRE60]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this case, we know that the `Integer.MAX_VALUE` will allow us to hold the
    accurate result for the sum. However, in some cases, we have to use the`long`
    type. The following code uses the `mapToLong` method to use a `long` to accumulate
    the values. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_18.java` file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们知道`Integer.MAX_VALUE`将允许我们保存准确的求和结果。然而，在某些情况下，我们必须使用`long`类型。下面的代码使用`mapToLong`方法来使用`long`来累积值。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中，名为`example12_18.java`。
- en: '[PRE61]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Java 9 provides many reduction methods, also known as aggregate operations.
    Make sure you consider them before writing your own code to perform operations
    such as count, average, and sum. We can use them to perform arithmetic operations
    on streams and get the number results.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9提供了许多归约方法，也称为聚合操作。在编写自己的代码执行诸如计数、平均值和求和等操作之前，请确保考虑它们。我们可以使用它们在流上执行算术操作并获得数字结果。
- en: Chaining many operations with map and reduce
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用map和reduce链接多个操作
- en: We can chain `filter`, `map`, and `reduce` operations. The following code adds
    a new `getHighestScoreSumForMinPlayersCount` method to the `MemoryMobileGameRepository`
    class. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_19.java` file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以链接`filter`、`map`和`reduce`操作。以下代码向`MemoryMobileGameRepository`类添加了一个新的`getHighestScoreSumForMinPlayersCount`方法。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中，名为`example12_19.java`。
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The new method performs a `filter` chained with a `mapToLong` and finally a
    `reduce` operation. The call to `filter` generates a `Stream<MobileGame>` with
    the instance of `MobileGame` whose `playersCount` value is equal or greater than
    the `minPlayersCount` value received as an argument. The `mapToLong` method returns
    a `LongStream`, that is, a specialized `Stream<T>` that describes a stream of
    `long` primitives. The call to `mapToLong` receives the `highestScore` value of
    the `int` type for each filtered `MobileGame` instance and returns this value
    converted to `long`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法执行了一个`filter`，链接了一个`mapToLong`，最后是一个`reduce`操作。对`filter`的调用生成了一个`Stream<MobileGame>`，其中包含`playersCount`值等于或大于作为参数接收的`minPlayersCount`值的`MobileGame`实例。`mapToLong`方法返回一个`LongStream`，即描述`long`原始类型流的专门化`Stream<T>`。对`mapToLong`的调用接收了每个经过筛选的`MobileGame`实例的`int`类型的`highestScore`值，并将此值转换为`long`返回。
- en: The `reduce` method receives a `LongStream` from the processing pipeline. The
    initial value for the accumulated value of the `reduce` operation is specified
    as the first argument, `0`, and the second argument is a lambda expression with
    the combine operation that will be repeatedly called with the accumulated value.
    The method returns the results of the repeated calls to the combine operation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`方法从处理管道中接收一个`LongStream`。`reduce`操作的累积值的初始值被指定为第一个参数`0`，第二个参数是一个带有组合操作的lambda表达式，该操作将重复调用累积值。该方法返回重复调用组合操作的结果。'
- en: The lambda expression specified in the second argument for the `reduce` method
    receives `sum` and `highestScore` and returns the sum of both values. Hence, the
    lambda expression returns the sum of the total accumulated so far, received in
    the `sum` argument, plus the `highestScore` value that is processed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`方法的第二个参数中指定的lambda表达式接收`sum`和`highestScore`，并返回这两个值的和。因此，lambda表达式返回到目前为止累积的总和，接收到`sum`参数，加上正在处理的`highestScore`值。'
- en: The next lines use the previously created method. The code file for the sample
    is included in the `java_9_oop_chapter_12_01` folder, in the `example12_19.java`
    file.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的行使用了先前创建的方法。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中，名为`example12_19.java`。
- en: '[PRE63]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'JShell will display the following value as a result:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: JShell将显示以下值作为结果：
- en: '[PRE64]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As we learned from the previous examples, we can use the `sum` method instead
    of writing the code for the `reduce` method. The next code shows another version
    of the `getHighestScoreSumForMinPlayersCount` method named `getHighestScoreSumForMinPlayersCountV2`
    that is equivalent and produces the same results. The code file for the sample
    is included in the `java_9_oop_chapter_12_01` folder, in the `example12_20.java`
    file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面的示例中学到的，我们可以使用`sum`方法而不是编写`reduce`方法的代码。下一行代码显示了`getHighestScoreSumForMinPlayersCount`方法的另一个版本，名为`getHighestScoreSumForMinPlayersCountV2`，它是等效的并产生相同的结果。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_20.java`文件中。
- en: '[PRE65]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The following code uses the new version of the method and produces the same
    results shown for the first version. The code file for the sample is included
    in the `java_9_oop_chapter_12_01` folder, in the `example12_20.java` file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用方法的新版本，并产生了与第一个版本显示的相同结果。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_20.java`文件中。
- en: '[PRE66]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Working with different collectors
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同的收集器
- en: We can follow a functional approach and solve different kinds of algorithms
    with stream processing pipelines and the help of the diverse collectors provided
    by Java 9, that is, the diverse static methods provided by the `java.util.stream.Collectors`
    class. In the next examples, we will use different arguments for the `collect`
    method.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遵循函数式方法，并使用Java 9提供的各种收集器来解决不同类型的算法，即`java.util.stream.Collectors`类提供的各种静态方法。在接下来的示例中，我们将为`collect`方法使用不同的参数。
- en: The following lines join all the names for the `MobileGame` instances to generate
    a single `String` with the names separated with a separator (`"; "`). The code
    file for the sample is included in the `java_9_oop_chapter_12_01` folder, in the
    `example12_21.java` file.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将所有`MobileGame`实例的名称连接起来，生成一个用分隔符(`"; "`)分隔的单个`String`。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_21.java`文件中。
- en: '[PRE67]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The code passes `Collectors.joining(";" )` as an argument to the `collect` method.
    The `joining` static method returns a `Collector` that concatenates the input
    elements into a `String` separated by the delimiter received as an argument. The
    following shows the results of executing the previous lines in JShell.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将`Collectors.joining(";" )`作为参数传递给`collect`方法。`joining`静态方法返回一个`Collector`，它将输入元素连接成一个由作为参数接收的分隔符分隔的`String`。以下显示了在JShell中执行前面行的结果。
- en: '[PRE68]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The code passes `Comparator.comparing(game -> game.name)` as an argument to
    the `sorted` method. The `comparing` static method receives a function that extracts
    the desired sort key from the `MobileGame` and returns a `Comparator<MobileGame>`
    that compares this sort key using the specified comparator. The code passes a
    lambda expression as an argument to the `comparing` static method to specify the
    name as the desired sort key for the `MobileGame` instances. The sorted method
    receives a `Stream<MobileGame>` and returns a `Stream<MobileGame>` with the `MobileGame`
    instances sorted according to the provided `Comparator<MobileGame>`. The following
    shows the results of executing the previous lines in JShell:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将`Comparator.comparing(game -> game.name)`作为参数传递给`sorted`方法。`comparing`静态方法接收一个函数，从`MobileGame`中提取所需的排序键，并返回一个`Comparator<MobileGame>`，使用指定的比较器比较此排序键。代码将一个lambda表达式作为参数传递给`comparing`静态方法，以指定名称为`MobileGame`实例的所需排序键。sorted方法接收一个`Stream<MobileGame>`，并返回一个根据提供的`Comparator<MobileGame>`对`MobileGame`实例进行排序的`Stream<MobileGame>`。以下显示了在JShell中执行前面行的结果：
- en: '[PRE71]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now we want to check the games that have a players' count equal or higher than
    a specified threshold. We want to check the games that passed and failed. The
    following lines generate a `Map<Boolean, List<MobileGame>>` whose key specifies
    whether the mobile games passed or not and the value includes the `List<MobileGame>`
    that passed or failed. Then, the code calls the `forEach` method to display the
    results. The code file for the sample is included in the `java_9_oop_chapter_12_01`
    folder, in the `example12_23.java` file.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要检查玩家数量等于或高于指定阈值的游戏。我们想要检查通过和未通过的游戏。以下行生成一个`Map<Boolean, List<MobileGame>`，其键指定移动游戏是否通过，值包括通过或未通过的`List<MobileGame>`。然后，代码调用`forEach`方法来显示结果。示例的代码文件包含在`java_9_oop_chapter_12_01`文件夹中的`example12_23.java`文件中。
- en: '[PRE72]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The code passes `Collectors.partitioningBy(g -> g.playersCount >= 100000)` as
    an argument to the `collect` method. The `partitioningBy` static method receives
    a `Predicate<MobileGame>`. The code passes a lambda expression as an argument
    to the `partitioningBy` static method to specify that the input elements must
    be partitioned based on whether the `playersCount` field is greater than or equal
    to `100000` or not. The returned `Collector<MobileGame>` partitions the `Stream<MobileGame>`
    and organizes it into a `Map<Boolean, List<MobileGame>>`, performing a downstream
    reduction.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将`Collectors.partitioningBy(g -> g.playersCount >= 100000)`作为参数传递给`collect`方法。`partitioningBy`静态方法接收一个`Predicate<MobileGame>`。代码将一个lambda表达式作为参数传递给`partitioningBy`静态方法，以指定输入元素必须基于`playersCount`字段是否大于或等于`100000`进行分区。返回的`Collector<MobileGame>`将`Stream<MobileGame>`分区并将其组织成`Map<Boolean,
    List<MobileGame>>`，执行下游归约。
- en: 'Then, the code calls the `forEach` method with a lambda expression as an argument
    that receives the key and value from the `Map<Boolean, List<MobileGame>>` in the
    `passed` and `mobileGames` arguments. The following shows the results of executing
    the previous lines in JShell:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码调用`forEach`方法，其中lambda表达式作为参数接收来自`Map<Boolean, List<MobileGame>`中的`passed`和`mobileGames`参数的键和值。以下显示了在JShell中执行前面行的结果：
- en: '[PRE73]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The following shows the results of executing the previous lines in JShell:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了在JShell中执行前面行的结果：
- en: '[PRE76]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Test your knowledge
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'A functional interface is an interface that meets the following condition:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数接口是满足以下条件的接口：
- en: It uses a lambda expression in one of its default methods.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在其默认方法中使用了一个lambda表达式。
- en: It has a single abstract method or a single method requirement.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它具有单个抽象方法或单个方法要求。
- en: It implements the `Lambda<T, U>` interface.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它实现了`Lambda<T, U>`接口。
- en: 'You can create an instance of a functional interface with:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下哪个代码片段创建函数式接口的实例：
- en: Lambda expressions, method references, or constructor references.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda表达式、方法引用或构造函数引用。
- en: Only lambda expressions. Method references and constructor references only work
    with `Predicate<T>`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有lambda表达式。方法引用和构造函数引用只能与`Predicate<T>`一起使用。
- en: Method references and constructor references. Lambda expressions only work with
    `Predicate<T>`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法引用和构造函数引用。Lambda表达式只能与`Predicate<T>`一起使用。
- en: 'The `IntPredicate` functional interface represents a function with:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IntPredicate`函数式接口表示一个带有：'
- en: One argument of the `int` type that returns no result (`void`).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int`类型的一个参数，返回`void`类型。'
- en: One argument of the `int` type that returns an `Integer` result.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int`类型的一个参数，返回`Integer`类型的结果。'
- en: One argument of the `int` type that returns a `boolean` result.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int`类型的一个参数，返回`boolean`类型的结果。'
- en: 'When we apply a `filter` method to a `Stream<T>`, the method returns:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们对`Stream<T>`应用`filter`方法时，该方法返回：
- en: A `Stream<T>`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stream<T>`。'
- en: A `List<T>`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`List<T>`。'
- en: A `Map<T, List<T>>`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Map<T, List<T>>`。'
- en: 'Which of the following code snippets is equivalent to `numbers.forEach(n ->
    System.out.println(n));`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个代码片段等同于`numbers.forEach(n -> System.out.println(n));`：
- en: '`numbers.forEach(n::System.out.println);`'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`numbers.forEach(n::System.out.println);`'
- en: '`numbers.forEach(System.out::println);`'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`numbers.forEach(System.out::println);`'
- en: '`numbers.forEach(n ->System.out.println);`'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`numbers.forEach(n ->System.out.println);`'
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we worked with many functional programming features included
    in Java 9 and combined them with everything we discussed so far about object-oriented
    programming. We analyzed the differences between imperative code and functional
    programming approaches for many algorithms.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了Java 9中包含的许多函数式编程特性，并将它们与我们之前讨论的面向对象编程的所有内容结合起来。我们分析了许多算法的命令式代码和函数式编程方法之间的差异。
- en: We worked with functional interfaces and lambda expressions. We understood method
    references and constructor references. We created a data repository with generics
    and interfaces and we used it to work with filters, map operations, reductions,
    aggregate functions, sorting and partitioning. We worked with different stream
    processing pipelines.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了函数式接口和lambda表达式。我们理解了方法引用和构造函数引用。我们使用泛型和接口创建了一个数据仓库，并用它来处理过滤、映射操作、归约、聚合函数、排序和分区。我们使用了不同的流处理管道。
- en: Now that you have learned about functional programming, we are ready to take
    advantage of modularity in Java 9, which is the topic we are going to discuss
    in the next chapter.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了函数式编程，我们准备利用Java 9中的模块化功能，这是我们将在下一章中讨论的主题。
