- en: Chapter 5. Gaming and Java Essentials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。游戏和Java基础知识
- en: In this chapter, we will cover a diverse and interesting range of topics. We
    will learn about Java arrays, which allow us to manipulate a potentially huge
    amount of data in an organized and efficient manner.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖各种有趣的主题。我们将学习Java数组，它允许我们以有组织和高效的方式操纵潜在的大量数据。
- en: Then, we will look at the role threads can play in games, in order to do more
    than one thing apparently simultaneously.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将研究线程在游戏中的作用，以便看起来可以同时做更多事情。
- en: If you thought that our math game was a bit on the quiet side, then we will
    look at adding sound effects to our games as well as introducing a cool open source
    app to generate authentic sound effects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为我们的数学游戏有点安静，那么我们将研究如何为我们的游戏添加声音效果，以及介绍一个很酷的开源应用程序来生成真实的声音效果。
- en: The last new thing we will learn will be persistence. This is what happens when
    the player quits our game or even turns off their Android device. What happens
    to the score then? How will we load the right level the next time they play?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习的最后一件新事情将是持久性。这是当玩家退出我们的游戏甚至关闭他们的Android设备时会发生的情况。那时分数会怎么样？下次他们玩时我们将如何加载正确的级别？
- en: Once we have done all this, we will use all the new techniques and knowledge
    along with what we already know to create a neat memory game.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了所有这些，我们将使用所有新的技术和知识以及我们已经知道的内容来创建一个整洁的记忆游戏。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Java arrays—an array of variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java数组-一组变量的数组
- en: Timing with threads
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程定时
- en: Creating and using beeps 'n' buzzes—Android sound
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用蜂鸣声和嗡嗡声-Android声音
- en: A look at life after destruction—persistence
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 毁灭后的生活展望-坚持
- en: Building the memory game
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建记忆游戏
- en: Java arrays – an array of variables
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java数组-一组变量的数组
- en: 'You might be wondering what happens when we have a game with lots of variables
    to keep track of. How about a table of high scores with the top 100 scores? We
    could declare and initialize 100 separate variables like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道当我们有很多要跟踪的变量的游戏时会发生什么。如何处理一个包含前100名得分的高分榜？我们可以声明并初始化100个单独的变量，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Straightaway, this can seem unwieldy, and what about the case when someone
    gets a new top score and we have to shift the scores in every variable down one
    place? A nightmare begins:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能立即显得笨拙，那么当有人获得新的最高分时，我们需要将每个变量中的分数向下移动一个位置，会发生什么？噩梦开始：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There must be a better way to update the scores. When we have a large set of
    variables, what we need is a Java **array**. An array is a reference variable
    that holds up to a fixed maximum number of elements. Each element is a variable
    with a consistent type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 更新分数必须有更好的方法。当我们有一大堆变量时，我们需要的是一个Java **数组**。数组是一个引用变量，最多可以容纳固定数量的元素。每个元素都是具有一致类型的变量。
- en: 'The following line of code declares an array that can hold `int` type variables,
    even a high score table perhaps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码行声明了一个可以容纳`int`类型变量的数组，甚至可能是一个高分表：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also declare arrays of other types, like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以声明其他类型的数组，如下所示：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Each of these arrays would need to have a fixed maximum amount of storage space
    allocated before it is used, like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数组中的每一个都需要在使用之前分配固定的最大存储空间，如下所示：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding line of code allocates up to a maximum of 100 integer-sized storage
    spaces. Think of a long aisle of 100 consecutive storage spaces in our variable
    warehouse. The spaces would probably be labeled `intArray[0]`, `intArray[1]`,
    `intArray[2]`, and so on, with each space holding a single `int` value. Perhaps
    the slightly surprising thing here is that the storage spaces start off at 0,
    not 1\. Therefore, in an array of size 100, the storage spaces would run from
    0 to 99.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码行分配了最多100个整数大小的存储空间。想象一下我们的变量仓库中有100个连续存储空间的长过道。空间可能标有`intArray[0]`，`intArray[1]`，`intArray[2]`等，每个空间都包含一个单个的`int`值。也许这里稍微令人惊讶的是，存储空间从0开始，而不是1。因此，在大小为100的数组中，存储空间将从0到99。
- en: 'We can actually initialize some of these storage spaces like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以像这样初始化一些存储空间：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that we can only put the declared type into an array and the type that
    an array holds can never change:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只能将声明的类型放入数组中，数组保存的类型永远不会改变：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So when we have an array of `int` types, what are each of the `int` variables
    called? The array notation syntax replaces the name. We can do anything with a
    variable in an array that we could do with a regular variable with a name:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当我们有一个`int`类型的数组时，每个`int`变量被称为什么？数组表示法语法替换了名称。我们可以对数组中的变量做任何我们可以用名称对常规变量做的事情：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is another example of array variables being used like normal variables:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数组变量被用作普通变量的另一个例子：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also assign a value from an array to a regular variable of the same
    type, like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将数组中的值分配给相同类型的常规变量，如下所示：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note, however, that `myNamedInt` is a separate and distinct primitive variable,
    so any changes made to it do not affect the value stored in the `intArray` reference.
    It has its own space in the warehouse and is not connected to the array.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，`myNamedInt`是一个单独且独立的基本变量，因此对它所做的任何更改都不会影响存储在`intArray`引用中的值。它在仓库中有自己的空间，并且与数组没有关联。
- en: Arrays are objects
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组是对象
- en: We said that arrays are reference variables. Think of an array variable as an
    address to a group of variables of a given type. Perhaps, using the warehouse
    analogy, `someArray` is an aisle number. So each of `someArray[0]`, `someArray[1]`,
    and so on is the aisle number followed by the position number in the aisle.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说数组是引用变量。将数组变量视为给定类型的一组变量的地址。也许，使用仓库类比，`someArray`是一个过道编号。因此，`someArray[0]`，`someArray[1]`等都是过道编号，后跟过道中的位置编号。
- en: 'Arrays are also objects. This means that they have methods and properties that
    we can use:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也是对象。这意味着它们有我们可以使用的方法和属性：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous line of code, we assigned the length of `someArray` to the `int`
    variable called `lengthOfSomeArray`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一行代码中，我们将`someArray`的长度分配给了名为`lengthOfSomeArray`的`int`变量。
- en: 'We can even declare an array of arrays. This is an array that, in each of its
    elements, stores another array, like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以声明一个数组的数组。这是一个数组，每个元素中存储另一个数组，就像这样：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding array, we could hold a list of cities within each country.
    Let''s not go array-crazy just yet. Just remember that an array holds up to a
    predetermined number of variables of any predetermined type and their values are
    accessed using this syntax:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数组中，我们可以保存每个国家内的城市列表。现在先不要太疯狂地使用数组。只需记住，数组最多可以保存预定数量的任何类型的变量，并且可以使用以下语法访问它们的值：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's actually use some arrays to try and get an understanding of how to use
    them in real code and what we might use them for.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际使用一些数组来尝试并了解如何在实际代码中使用它们以及我们可能用它们做什么。
- en: A simple example of an array
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个数组的简单示例
- en: 'Let''s write a really simple working example of an array by performing the
    following steps. You can get the complete code for this example in the downloadable
    code bundle. It''s at `Chapter5/SimpleArrayExample/MainActivity.java`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤编写一个真正简单的数组工作示例。您可以在可下载的代码包中找到此示例的完整代码。它在`Chapter5/SimpleArrayExample/MainActivity.java`中：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.xhtml "第2章。开始使用Android")中所做的那样，*开始使用Android*。同时，通过删除不必要的部分来清理代码，但这并非必要。
- en: 'First, we declare our array, allocate five spaces, and initialize some values
    to each of the elements:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们声明我们的数组，分配五个空间，并为每个元素初始化一些值：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We output each of the values to the **logcat** console. Notice that when we
    add the array elements together, we are doing so over multiple lines. This is
    fine because we have omitted a semicolon until the last operation, so the Java
    compiler treats the lines as one statement:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将每个值输出到**logcat**控制台。请注意，当我们将数组元素相加时，我们是在多行上这样做的。这没问题，因为我们在最后一个操作之前省略了分号，所以Java编译器将这些行视为一个语句：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the example on an emulator.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上运行示例。
- en: 'Remember that nothing will happen on the emulator display because the entire
    output will be sent to our **logcat** console window in Android Studio. Here is
    the output of the preceding code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在模拟器显示上不会发生任何事情，因为整个输出将被发送到我们在Android Studio中的**logcat**控制台窗口。以下是前面代码的输出：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In step 2, we declared an array called `ourArray` to hold `int` variables, and
    allocated space for up to five variables of that type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们声明了一个名为`ourArray`的数组，以保存`int`变量，并为该类型的最多五个变量分配了空间。
- en: Next, we assigned a value to each of the five spaces in our array. Remember
    that the first space is `ourArray[0]` and the last space is `ourArray[4]`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为数组中的五个空间中的每一个分配了一个值。请记住，第一个空间是`ourArray[0]`，最后一个空间是`ourArray[4]`。
- en: In step 3, we simply printed the value in each array location to the console.
    From the output, we can see that they hold the value we initialized in the previous
    step. Then we added each of the elements in `ourArray` and initialized their value
    to the `answer` variable. We then printed `answer` to the console and saw that
    all the values where added together, just as if they were plain old `int` types
    stored in a slightly different manner, which is exactly what they are.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步，我们简单地将每个数组位置的值打印到控制台。从输出中，我们可以看到它们保存了我们在上一步中初始化的值。然后我们将`ourArray`中的每个元素相加，并将它们的值初始化为`answer`变量。然后我们将`answer`打印到控制台，并看到所有的值都被加在一起，就像它们是存储在稍微不同方式的普通旧`int`类型中一样，这正是它们的本质。
- en: Getting dynamic with arrays
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与数组一起变得动态起来
- en: As we discussed at the beginning of all this array stuff, if we need to declare
    and initialize each element of an array individually, there isn't a huge amount
    of benefit in an array over regular variables. Let's look at an example of declaring
    and initializing arrays dynamically.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在所有这些数组内容的开头讨论的那样，如果我们需要单独声明和初始化数组的每个元素，那么数组与常规变量相比并没有太大的好处。让我们看一个动态声明和初始化数组的例子。
- en: Dynamic array example
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态数组示例
- en: 'Let''s make a really simple dynamic array by performing the following steps.
    You can find the working project for this example in the download bundle. It is
    at `Chapter5/DynamicArrayExample/MainActivity.java`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤创建一个真正简单的动态数组。您可以在下载包中找到此示例的工作项目。它在`Chapter5/DynamicArrayExample/MainActivity.java`中：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Android"),*Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.xhtml "第2章。开始使用Android")中所做的那样，*开始使用Android*。同时，通过删除不必要的部分来清理代码，但这并非必要。
- en: 'Type the following between the opening and closing curly braces of `onCreate`.
    See if you can work out what the output will be before we discuss it and analyze
    the code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`的大括号之间键入以下内容。在我们讨论并分析代码之前，看看您能否弄清楚输出将是什么：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the example on an emulator. Remember that nothing will happen on the emulator
    display because the entire output will be sent to our **logcat** console window
    in Android Studio. Here is the output of the preceding code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上运行示例。请记住，在模拟器显示上不会发生任何事情，因为整个输出将被发送到我们在Android Studio中的**logcat**控制台窗口。以下是前面代码的输出：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I have removed 994 iterations of the loop for brevity:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经删除了循环的994次迭代以简洁起见：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'All the action happened in step 2\. We declared and allocated an array called
    `ourArray` to hold up to 1,000 `int` values. This time, however, we did the two
    steps in one line of code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的操作都发生在第2步。我们声明并分配了一个名为`ourArray`的数组，以容纳最多1,000个`int`值。然而，这一次，我们在一行代码中完成了这两个步骤：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we used a `for` loop that was set to loop 1,000 times:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了一个`for`循环，设置为循环1,000次：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We initialized the spaces in the array from 0 to 999 with the value of `i`
    multiplied by `5`, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`i`乘以`5`的值初始化了数组中从0到999的空间，如下所示：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To demonstrate the value of `i` and the value held in each position of the
    array, we output the value of `i` followed by the value held in the corresponding
    position in the array as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`i`的值以及数组中每个位置上保存的值的价值，我们按如下方式输出`i`的值，然后是数组中相应位置上保存的值：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: All of this happened 1,000 times, producing the output we saw.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都发生了1,000次，产生了我们看到的输出。
- en: Entering the nth dimension with arrays
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入数组的第n维
- en: We very briefly mentioned that an array can even hold other arrays at each of
    its positions. Now, if an array holds lots of arrays that hold lots of some other
    type, how do we access the values in the contained arrays? And why would we ever
    need this anyway? Take a look at the next example of where multidimensional arrays
    can be useful.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常简要地提到数组甚至可以在每个位置上容纳其他数组。现在，如果一个数组包含许多包含其他类型的数组，我们如何访问包含的数组中的值？为什么我们需要这个？看看多维数组何时有用的下一个示例。
- en: An example of a multidimensional array
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多维数组的一个示例
- en: 'Let''s create a really simple multidimensional array by performing the following
    steps. You can find the working project for this example in the download bundle.
    It is at `Chapter5/MultidimensionalArrayExample/MainActivity.java`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤创建一个非常简单的多维数组。您可以在下载包中找到此示例的工作项目。它位于`Chapter5/MultidimensionalArrayExample/MainActivity.java`：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary methods, but this isn't essential.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.xhtml "第2章。开始Android")中所做的那样，*开始Android*。同时，通过删除不必要的方法来清理代码，但这并非必需。
- en: 'After the call to `setContentView`, declare and initialize a two-dimensional
    array, like this:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`setContentView`之后，声明并初始化一个二维数组，如下所示：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we output the contents of the array using a `for` loop and a `Random` class
    object. Note how we ensure that although the question is random, we can always
    pick the correct answer:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用`for`循环和`Random`类对象输出数组的内容。请注意，尽管问题是随机的，但我们始终可以选择正确的答案：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the example on an emulator. Once again, nothing will happen on the emulator
    display because the output will be sent to our **logcat** console window in Android
    Studio. Here is the output of the previous code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器上运行示例。再次强调，模拟器显示屏上不会发生任何事情，因为输出将发送到我们在Android Studio中的**logcat**控制台窗口。这是先前代码的输出：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What just happened? Let's go through this chunk by chunk so that we know exactly
    what is going on.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？让我们一块一块地过一遍，这样我们就知道到底发生了什么。
- en: 'We make a new object of the `Random` type, called `randInt`, ready to generate
    random numbers later in the program:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`Random`类型的新对象，称为`randInt`，准备在程序后面生成随机数：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We declare a simple `int` variable to hold a question number:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个简单的`int`变量来保存问题编号：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we declare `countriesAndCities`, our array of arrays. The outer array
    holds arrays:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们声明`countriesAndCities`，我们的数组数组。外部数组保存数组：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we allocate space within our arrays. The first outer array will be able
    to hold five arrays and each of the inner arrays will be able to hold two strings:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在数组中分配空间。第一个外部数组将能够容纳五个数组，每个内部数组将能够容纳两个字符串：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we initialize our arrays to hold countries and their corresponding capital
    cities. Notice that with each pair of initializations, the outer array number
    stays the same, indicating that each country/capital pair is within one inner
    array (a string array). Of course, each of these inner arrays is held in one element
    of the outer array (which holds arrays):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化数组以保存国家及其对应的首都。请注意，每对初始化中，外部数组编号保持不变，表示每个国家/首都对在一个内部数组（字符串数组）中。当然，这些内部数组中的每一个都保存在外部数组的一个元素中（保存数组）：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To make the upcoming `for` loop clearer, we declare and initialize `int` variables
    to represent the country and the capital from our arrays. If you glance back at
    the array initialization, all the countries are held in position `0` of the inner
    array and all the corresponding capital cities are held at position `1`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使即将到来的`for`循环更清晰，我们声明并初始化`int`变量来表示数组中的国家和首都。如果您回顾一下数组初始化，所有国家都保存在内部数组的位置`0`，所有对应的首都都保存在位置`1`：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we create a `for` loop that will run three times. Note that this number
    does not mean we access the first three elements of our array. It is rather the
    number of times we go through the loop. We could make it loop one time or a thousand
    times, but the example would still work:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个`for`循环，将运行三次。请注意，这个数字并不意味着我们访问数组的前三个元素。这只是循环的次数。我们可以让它循环一次或一千次，但示例仍然有效：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we actually determine which question to ask, or more specifically, which
    element of our outer array. Remember that `randInt.nextInt(5)` returns a number
    between 0 and 4\. This is just what we need as we have an outer array with five
    elements, from 0 to 4:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实际确定要问什么问题，或者更具体地说，我们外部数组的哪个元素。请记住，`randInt.nextInt(5)`返回0到4之间的数字。这正是我们需要的，因为我们有一个包含五个元素的外部数组，从0到4：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we can ask a question by outputting the strings held in the inner array,
    which in turn is held by the outer array that was chosen in the previous line
    by the randomly generated number:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过输出内部数组中保存的字符串来提问，而内部数组又由前一行中随机生成的数字选择的外部数组保存：
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For the record, we will not be using any multidimensional arrays in the rest
    of this book. So if there is still a little bit of murkiness around these arrays
    inside arrays, then that doesn't matter. You know they exist and what they can
    do, so you can revisit them if necessary.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，我们在本书的其余部分将不再使用任何多维数组。因此，如果对这些数组内部的数组还有一点模糊，那也没关系。您知道它们存在以及它们能做什么，所以如果有必要，您可以重新访问它们。
- en: Array-out-of-bounds exceptions
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组越界异常
- en: 'An array-out-of-bounds exception occurs when we attempt to access an element
    of an array that does not exist. Whenever we try this, we get an error. Sometimes,
    the compiler will catch it to prevent the error from going into a working game,
    like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试访问一个不存在的数组元素时，就会发生数组越界异常。每当我们尝试这样做，就会出现错误。有时，编译器会捕捉到它，以防止错误进入工作中的游戏，就像这样：
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Guess what happens if we write something like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜如果我们写出这样的东西会发生什么：
- en: '[PRE36]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The only way we can avoid this problem is to know the rule. The rule is that
    arrays start at zero and go up to the number obtained by subtracting one from
    the allocated number. We can also use clear, readable code where it is easy to
    evaluate what we have done and spot the problems.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免这个问题的唯一方法是了解规则。规则是数组从零开始，一直到从分配的数字中减去一得到的数字。我们还可以使用清晰、可读的代码，在这种代码中很容易评估我们所做的事情并发现问题。
- en: Timing with threads
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程的时间控制
- en: So what is a thread? You can think of threads in Java programming just like
    threads in a story. In one thread of a story, we have the primary character battling
    the enemy on the front line, and in another thread, the soldier's family are getting
    by, day to day. Of course, a story doesn't have to have just two threads. We could
    introduce a third thread. Perhaps the story also tells of the politicians and
    military commanders making decisions. These decisions subtly, or not so subtly,
    affect what happens in the other threads.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么是线程呢？你可以把Java编程中的线程想象成故事中的线程。在故事的一个线程中，我们有主要角色在前线与敌人作战，而在另一个线程中，士兵的家人们日复一日地生活。当然，一个故事不一定只有两个线程。我们可以引入第三个线程。也许故事还讲述了政客和军事指挥官做出决策。这些决策会微妙地或者不那么微妙地影响其他线程中发生的事情。
- en: 'Threads in programming are just like this. We create parts/threads in our program
    and they control different aspects for us. We introduce threads to represent these
    different aspects because of the following reasons:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的线程就是这样。我们在程序中创建部分/线程，它们为我们控制不同的方面。我们引入线程来代表这些不同的方面，是因为以下原因：
- en: They make sense from an organizational point of view
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从组织的角度来看，它们是有意义的
- en: They are a proven way of structuring a program that works
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是一种经过验证的程序结构方式
- en: The nature of the system we are working on forces us to use them
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在工作的系统的性质迫使我们使用它们
- en: In Android, we use threads for all of these reasons simultaneously. It makes
    sense, it works, and we have to use it because of the design of the system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，我们同时出于以上所有原因使用线程。这是有道理的，它有效，而且我们必须使用它，因为系统的设计需要。
- en: In gaming, think about a thread that receives the player's button taps for "left",
    "right", and "shoot", a thread that represents the alien thinking where to move
    next, and yet another thread that draws all the graphics on the screen.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，想象一下一个线程接收玩家的“左”、“右”和“射击”按钮点击，一个线程代表外星人思考下一步要移动到哪里，还有另一个线程在屏幕上绘制所有的图形。
- en: Programs with multiple threads can have problems. Like the threads of a story,
    if proper synchronization does not occur, then things go wrong. What if our soldier
    went into battle before the battle or even the war existed? Weird!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程程序可能会出现问题。就像故事的线程一样，如果适当的同步没有发生，事情就会出错。如果我们的士兵在战斗甚至战争存在之前就进入了战斗，会怎么样？奇怪！
- en: What if we have a variable, `int x`, that represents a key piece of data that
    say three threads of our program use? What happens if one thread gets slightly
    ahead of itself and makes the data "wrong" for the other two? This problem is
    the problem of **correctness**, caused by multiple threads racing to completion,
    oblivious of each other—because they are just dumb code after all.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个变量`int x`，代表着我们程序中三个线程使用的关键数据，会发生什么呢？如果一个线程稍微领先一些，使得数据对其他两个线程来说变得“错误”了，会发生什么？这个问题就是**正确性**的问题，由多个线程竞争完成而引起，它们互相不知道对方的存在，因为它们毕竟只是愚蠢的代码。
- en: The problem of correctness can be solved by close oversight of the threads and
    **locking**. Locking means temporarily preventing execution in one thread to ensure
    that things are working in a synchronized manner. It's like freezing the soldier
    from boarding a ship to war until the ship has actually docked and the plank has
    been lowered, avoiding an embarrassing splash.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正确性的问题可以通过密切监督线程和**锁定**来解决。锁定意味着暂时阻止一个线程的执行，以确保事情以同步的方式工作。这就像冻结士兵不让他登上战舰，直到战舰实际靠岸并放下了栈板，避免尴尬的溅水。
- en: The other problem with programs with multiple threads is the problem of **deadlock**,
    where one or more threads become locked, waiting for the right moment to access
    `x`, but that moment never comes and the entire program eventually grinds to a
    halt.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程程序的另一个问题是**死锁**的问题，其中一个或多个线程被锁住，等待合适的时机来访问`x`，但那个时机从未到来，整个程序最终停滞不前。
- en: You might have noticed that it was the solution to the first problem (correctness)
    that is the cause of the second problem (deadlock). Now consider all that we have
    just been discussing and mix it in with the Android Activity lifecycle. It's possible
    that you start to feel a little nauseous with the complexity.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，第一个问题（正确性）的解决方案是导致第二个问题（死锁）的原因。现在考虑我们刚刚讨论的所有内容，并将其与Android Activity生命周期混合在一起。你可能开始感到这种复杂性有点令人恶心。
- en: Fortunately, the problem has been solved for us. Just as we use the `Activity`
    class and override its methods to interact with the Android lifecycle, we can
    also use other classes to create and manage our threads. Just as with `Activity`,
    we only need to know how to use them, not how they work.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个问题已经为我们解决了。就像我们使用`Activity`类并重写其方法与Android生命周期进行交互一样，我们也可以使用其他类来创建和管理我们的线程。就像使用`Activity`一样，我们只需要知道如何使用它们，而不需要知道它们是如何工作的。
- en: 'So why tell me all this stuff about threads when I didn''t need to know, you
    would rightly ask. It''s simply because we will be writing code that looks different
    and is structured in an unfamiliar manner. We will have no sweat writing our Java
    code to create and work within our threads if we can do the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所以为什么要告诉我所有这些关于线程的东西，当我不需要知道的时候，你可能会问。这只是因为我们将编写看起来不同并且结构不熟悉的代码。如果我们能做到以下几点，我们将毫不费力地编写我们的Java代码来创建和在我们的线程中工作：
- en: Accept that the new concepts we will introduce are what we need to work with
    in order to create an Android-specific solution to the problems related to working
    with threads
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受我们将介绍的新概念是我们需要处理的，以便为处理与线程相关的问题创建一个特定于Android的解决方案
- en: Understand the general concept of a thread, which is mostly the same as a story
    thread that happens almost simultaneously
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解线程的一般概念，这与几乎同时发生的故事线程大致相同
- en: Learn the few rules of using some of the Android thread classes
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用一些Android线程类的几个规则
- en: Notice that I said classes, plural, in the third bullet. Different thread classes
    work best in different situations. You could write a whole book on just threads
    in Android. We will use two thread classes in this book. In this chapter, we will
    use `Handler`. In [Chapter 7](ch07.xhtml "Chapter 7. Retro Squash Game"), *Retro
    Squash Game*, and [Chapter 8](ch08.xhtml "Chapter 8. The Snake Game"), *The Snake
    Game*, we will use the `Runnable` class. All we need to remember is that we will
    be writing parts of our program that run at almost the same time as each other.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在第三个项目中说了类，复数。不同的线程类在不同的情况下效果最好。你可以写一整本关于Android线程的书。在本书中，我们将使用两个线程类。在本章中，我们将使用`Handler`。在[第7章](ch07.xhtml
    "第7章。复古乒乓球游戏")，*复古乒乓球游戏*，和[第8章](ch08.xhtml "第8章。贪吃蛇游戏")，*贪吃蛇游戏*中，我们将使用`Runnable`类。我们需要记住的是，我们将编写几乎同时运行的程序部分。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: What do I mean by "almost"? What is actually happening is that the CPU switches
    between threads in turn. However, this happens so fast that we will not be able
    to perceive anything but simultaneity.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的“几乎”是什么意思？实际上发生的是CPU轮流在线程之间切换。然而，这一切发生得如此之快，以至于我们除了同时性之外无法感知到任何东西。
- en: A simple thread timer example with the Handler class
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Handler类创建一个简单的线程计时器示例
- en: After this example, we can heave a sigh of relief when we realize that threads
    are not as complicated as first feared. When using threads in a real game, we
    will have to add a bit of extra code alongside the code in this simple example,
    but it's not much, and we will talk about it when we get to it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子之后，当我们意识到线程并不像最初害怕的那么复杂时，我们可以松一口气。在真正的游戏中使用线程时，我们将不得不在这个简单的例子中的代码旁边添加一些额外的代码，但这并不多，我们会在到达时讨论它。
- en: As usual, you can simply use the complete code from the download bundle. This
    project is located in `Chapter5`/`SimpleThreadTimer/MainActivity.java`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，你可以直接使用下载包中的完整代码。这个项目位于`Chapter5`/`SimpleThreadTimer/MainActivity.java`。
- en: 'As the name suggests, we will be creating a timer—quite a useful feature in
    a lot of games:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，我们将创建一个计时器 - 在许多游戏中非常有用的功能：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.xhtml "第2章。开始使用Android")中所做的那样，*开始使用Android*。同时，通过删除不必要的部分来清理代码，但这并不是必要的。
- en: 'Immediately after the class declaration, enter the three highlighted lines:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类声明之后，输入三行高亮显示的代码：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Enter this code inside the `onCreate` method. It will create a thread with
    something else going on in the `if(gameOn)` block:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此代码输入`onCreate`方法中。它将创建一个线程，同时在`if(gameOn)`块中进行其他操作：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Run the app. Quit with the home or back button on the emulator. Notice that
    it is still printing to the console. We will deal with this anomaly when we implement
    our memory game.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。在模拟器上使用主页或返回按钮退出。请注意，它仍然在控制台上打印。当我们实现我们的记忆游戏时，我们将处理这个异常。
- en: 'When you run the example on an emulator, remember that nothing will happen
    on the emulator display because all of the output will be sent to our **logcat**
    console window in Android Studio. Here is the output of the previous code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在模拟器上运行示例时，请记住模拟器显示屏上不会发生任何事情，因为所有的输出都将发送到我们在Android Studio中的**logcat**控制台窗口。这是先前代码的输出：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So what just happened? After 1-second intervals, the number of seconds elapsed
    was printed to the console. Let's learn how this happened.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 那刚刚发生了什么？每隔1秒，经过的秒数被打印到控制台上。让我们学习一下这是如何发生的。
- en: 'First, we declare a new object, called `myHandler`, of the `Handler` type.
    We then declare a Boolean variable called `gameOn`. We will use this to keep track
    of when our game is running. Finally, the last line of this block of code declares
    a variable of the `long` type. You might remember the `long` type from [Chapter
    3](ch03.xhtml "Chapter 3. Speaking Java – Your First Game"), *Speaking Java –
    Your First Game*. We can use `long` variables to store very large whole numbers,
    and this is what we do here with `startTime`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个名为`myHandler`的`Handler`类型的新对象。然后我们声明一个名为`gameOn`的布尔变量。我们将使用这个变量来跟踪我们的游戏何时运行。最后，这段代码块的最后一行声明了一个`long`类型的变量。你可能还记得`long`类型来自[第3章](ch03.xhtml
    "第3章。说Java - 你的第一个游戏")，*说Java - 你的第一个游戏*。我们可以使用`long`变量来存储非常大的整数，这就是我们在这里使用`startTime`的方式：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next, we initialized `startTime` using `currentTimeMillis`, a method of the
    `System` class. This method holds the number of milliseconds since January 1,
    1970\. We will see how we use this value in the next line of code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`System`类的`currentTimeMillis`方法初始化了`startTime`。这个方法保存了自1970年1月1日以来的毫秒数。我们将看到我们如何在下一行代码中使用这个值。
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Next is the important code. Everything up to `if(gameOn)` marks the code to
    define our thread. Certainly, the code is a bit of a mouthful, but it is not as
    bad as it looks at first glance. Also, remember that we only need to use the threads;
    we don't need to understand every aspect of how they do their work.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是重要的代码。直到`if(gameOn)`之前的所有内容都是用来定义我们的线程的代码。当然，这段代码有点复杂，但实际上并没有看起来那么糟糕。还要记住，我们只需要使用线程；我们不需要理解它们的所有工作原理。
- en: Let's dissect the preceding code to demystify it a bit. The `myHandler = new
    Handler()` line simply initializes our `myHandler` object. What is different from
    what we have seen before is that we go on to customize the object immediately
    afterwards. We override the `handleMessage` method (which is where we put our
    code that runs in the thread) and then we call `super.handleMessage`, which calls
    the default version of `handleMessage` before it runs our custom code. This is
    much like we do for the `onCreate` method every time we call `super.onCreate`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的代码，以便更好地理解。`myHandler = new Handler()`这一行只是初始化了我们的`myHandler`对象。与之前看到的不同的是，我们立即对对象进行了自定义。我们重写了`handleMessage`方法（这是我们在线程中运行代码的地方），然后调用了`super.handleMessage`，它在运行我们的自定义代码之前调用了`handleMessage`的默认版本。这很像我们每次调用`super.onCreate`时对`onCreate`方法所做的事情。
- en: 'Then we have the `if(gameOn)` block. Everything in that `if` block is the code
    that we want to run in the thread. The `if(gameOn)` block simply gives us a way
    to control whether we want to run our code at all. For example, we might want
    the thread up and running but only sometimes run our code. The `if` statement
    gives us the power to easily choose. Take a look at the code now. We will analyze
    what is happening in the `if` block later:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有`if(gameOn)`块。该`if`块中的所有内容都是我们想要在线程中运行的代码。`if(gameOn)`块只是给了我们一个控制是否要运行代码的方式。例如，我们可能希望线程一直运行，但只有在某些时候运行我们的代码。`if`语句让我们可以轻松选择。现在看一下代码。稍后我们将分析`if`块中发生了什么：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Inside the `if` block, we declare and initialize another `long` variable called
    `seconds`, and do a little bit of math with it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块内，我们声明并初始化了另一个名为`seconds`的`long`变量，并对其进行了一些简单的数学运算：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'First, we get the current number of milliseconds since January 1, 1970, and
    then subtract `startTime` from it. This gives us the number of milliseconds since
    we first initialized `startTime`. Then we divide the answer by 1000 and get a
    value in seconds. We print this value to the console with the following line:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取自1970年1月1日以来的当前毫秒数，然后从中减去`startTime`。这给了我们自初始化`startTime`以来的毫秒数。然后我们将答案除以1000，得到一个秒数。我们用以下行将这个值打印到控制台：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, just after our `if` block, we have this line:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的`if`块之后，我们有这样一行：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The previous line tells the Android system that we want to run the code in the
    `handleMessage` method once every 1000 milliseconds (once a second).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行告诉Android系统，我们希望每1000毫秒（一秒一次）运行一次`handleMessage`方法中的代码。
- en: 'Back in `onCreate`, after the closing curly braces of the `handleMessage` method
    and the `Handler` class, we finally set `gameOn` to `true` so that it is possible
    to run the code in the `if` block:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`中，在`handleMessage`方法和`Handler`类的结束大括号之后，我们最终将`gameOn`设置为`true`，以便可以运行`if`块中的代码：
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, this last line of the code starts the flow of messages between our thread
    and the Android system:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码的最后一行开始了我们的线程与Android系统之间的消息流：
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is worth pointing out that the code inside the `if` block can be as minimal
    or as extensive as we need. When we implement our memory game, we will see much
    more code in our `if` block.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，`if`块中的代码可以是我们需要的最少或最多。当我们实现我们的记忆游戏时，我们将在`if`块中看到更多的代码。
- en: All we really need to know is that the somewhat elaborate setup we have just
    seen allows us to run the contents of the `if` block in a new thread. That's it!
    Perhaps apart from brushing over that `System` class a bit quickly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要知道的是，我们刚刚看到的有些复杂的设置允许我们在一个新的线程中运行`if`块中的内容。就是这样！也许除了稍微快速地涉及`System`类之外。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `System` class has many uses. In this case, we use it to get the number
    of milliseconds since January 1, 1970\. This is a common system used to measure
    time in a computer. It is known as Unix time, and the first millisecond of January
    1, 1970, is known as the Unix Epoch. We will bump into this concept a few more
    times throughout the book.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`System`类有很多用途。在这种情况下，我们使用它来获取自1970年1月1日以来的毫秒数。这是计算机中用于测量时间的常见系统。它被称为Unix时间，1970年1月1日的第一毫秒被称为Unix纪元。在本书中我们将再次遇到这个概念。'
- en: Enough on threads, let's make some noise!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 关于线程就说这么多，让我们发出一些声音吧！
- en: Beeps n buzzes – Android sound
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蜂鸣声和嗡嗡声 - Android音效
- en: This section will be divided into two parts—creating and using sound FX. So
    let's get on with it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分将分为两部分——创建和使用音效。那么让我们开始吧。
- en: Creating sound FX
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建音效
- en: Years ago, whenever I made a game, I would spend many hours trawling websites
    offering royalty-free sound FX. Although there are many good ones out there, the
    really great ones are always costly, and no matter how much you pay, they are
    never exactly what you want. Then a friend pointed out a simple open source app
    called Bfxr, and I have never wasted another moment looking for sound effects
    since. We can make our own.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，每当我制作游戏时，我会花费很多时间在提供免版税音效的网站上搜寻。虽然有很多好的音效，但真正优秀的音效总是很昂贵，无论你付多少钱，它们永远不会完全符合你的要求。然后一个朋友指出了一个名为Bfxr的简单开源应用，自那以后我再也没有浪费时间寻找音效。我们可以自己制作。
- en: Here is a very fast guide to making your own sound effects using Bfxr. Grab
    a free copy of Bfxr from [www.bfxr.net](http://www.bfxr.net).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Bfxr制作自己的音效的快速指南。从[www.bfxr.net](http://www.bfxr.net)免费下载Bfxr。
- en: 'Follow the simple instructions on the website to set it up. Try out a few of
    these examples to make cool sound effects:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按照网站上的简单说明进行设置。尝试一些示例来制作酷炫的音效：
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This is a seriously condensed tutorial. You can do much more with Bfxr. To learn
    more, read the tips on the website at the previous URL.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个严重简化的教程。您可以使用Bfxr做更多事情。要了解更多，请阅读上一个URL网站上的提示。
- en: Run `bfxr.exe`:![Creating sound FX](img/8859OS_05_10.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`bfxr.exe`：![创建声音效果](img/8859OS_05_10.jpg)
- en: Try out all the preset types, which generate a random sound of that type. When
    you have a sound that is close to what you want, move to the next step:![Creating
    sound FX](img/8859OS_05_11.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试所有预设类型，这些类型会生成该类型的随机声音。当您有一个接近您想要的声音时，转到下一步:![创建声音效果](img/8859OS_05_11.jpg)
- en: Use the sliders to fine-tune the pitch, duration, and other aspects of your
    new sound:![Creating sound FX](img/8859OS_05_12.jpg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用滑块微调您的新声音的音调、持续时间和其他方面:![创建声音效果](img/8859OS_05_12.jpg)
- en: Save your sound by clicking on the **Export Wav** button. Despite the name of
    this button, as we will see, we can save in formats other than `.wav`.![Creating
    sound FX](img/8859OS_05_13.jpg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击**导出Wav**按钮保存您的声音。尽管这个按钮的名称是这样的，但正如我们将看到的那样，我们可以保存为`.wav`以外的格式。![创建声音效果](img/8859OS_05_13.jpg)
- en: Android likes to work with sounds in the OGG format, so when asked to name your
    file, use the `.ogg` extension on the end of whatever you decide to call it.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android喜欢使用OGG格式的声音，因此在要求命名文件时，请在您决定的文件名后面使用`.ogg`扩展名。
- en: Repeat steps 2 to 5 as often as required.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要重复2到5步。
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Every project in this book that requires sound samples comes with the sound
    samples provided, but as we have seen, it is much more fun to make our own samples.
    All you need to do is to save them with the same filename as the provided samples.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中需要声音样本的每个项目都提供了声音样本，但正如我们所见，制作自己的样本更有趣。您只需要将它们保存为与提供的样本相同的文件名。
- en: Playing sounds in Android
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Android中播放声音
- en: 'To complete this brief example, you will need three sound effects saved in
    the `.ogg` format. So if you don''t have them to hand, go back to the *Creating
    sound FX* section to make some. Alternatively, you can use the sounds provided
    in the `Chapter5/ PlayingSounds/assets` folder of the code bundle. As usual, you
    can view or use the already completed code at `Chapter5/PlayingSounds/java/MainActivity.java`
    and `Chapter5/PlayingSounds/layout/activity_main.xml`. Now perform the following
    steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个简短的示例，您需要三个以`.ogg`格式保存的声音效果。因此，如果您手头没有它们，请返回到*创建声音效果*部分进行制作。或者，您可以使用代码包的`Chapter5/PlayingSounds/assets`文件夹中提供的声音。像往常一样，您可以查看或使用`Chapter5/PlayingSounds/java/MainActivity.java`和`Chapter5/PlayingSounds/layout/activity_main.xml`中已经完成的代码。现在执行以下步骤：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, although this isn't essential.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空白活动的项目，就像我们在[第2章](ch02.xhtml "第2章。开始使用Android")中所做的那样，*开始使用Android*。此外，通过删除不必要的部分来清理代码，尽管这并非必要。
- en: Create three sound files and save them as `sample1.ogg`, `sample2.ogg`, and
    `sample3.ogg`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个声音文件并将它们保存为`sample1.ogg`，`sample2.ogg`和`sample3.ogg`。
- en: In the `main` folder in the Project Explorer window, we need to add a folder
    called `assets`. So in the Project Explorer window, right-click on the **main**
    folder and navigate to **New** | **Directory**. Type `assets` in the **New Directory**
    dialog box.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器窗口的`main`文件夹中，我们需要添加一个名为`assets`的文件夹。因此，在项目资源管理器窗口中，右键单击**main**文件夹，然后导航到**新建**
    | **目录**。在**新建目录**对话框中输入`assets`。
- en: Now copy and paste the three sound files to the newly created `assets` folder.
    Alternatively, select the three files, right-click on them, and click on **Copy**.
    Then click on the **assets** folder in the Android Studio Project Explorer. Now
    right-click on the **assets** folder and click on **Paste**.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将三个声音文件复制并粘贴到新创建的`assets`文件夹中。或者，选择这三个文件，右键单击它们，然后单击**复制**。然后单击Android Studio项目资源管理器中的**assets**文件夹。现在右键单击**assets**文件夹，然后单击**粘贴**。
- en: Open `activity_main.xml` in the editor window and drag three button widgets
    onto your UI. It doesn't matter where they are or how they are aligned. When you
    look at the **id** property in the **Properties** window for any of our three
    new buttons, you will notice that they have automatically been assigned **id**
    properties. They are `button`, `button2`, and `button3`. As we will see, this
    is just what we need.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中打开`activity_main.xml`，并将三个按钮小部件拖放到您的UI上。它们的位置或对齐方式并不重要。当您查看我们三个新按钮中的任何一个的**属性**窗口中的**id**属性时，您会注意到它们已经自动分配了**id**属性。它们是`button`，`button2`和`button3`。正如我们将看到的那样，这正是我们需要的。
- en: 'Let''s enable our activity to listen to the buttons being clicked by implementing
    `onClickListener` as we have done in all our other examples with buttons. Open
    **MainActivity.java** in the editor window. Replace the `public class MainActivity
    extends Activity {` line with the following line of code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过实现`onClickListener`使我们的活动能够监听按钮的点击，就像我们在所有其他示例中使用按钮一样。在编辑器窗口中打开**MainActivity.java**。将`public
    class MainActivity extends Activity {`行替换为以下代码行：
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As before, we get an unsightly red underline on our new line of code. The last
    time this happened, we typed in the empty body of the `onClick` method that we
    must implement and all was well. This time, because we already know what is going
    on here, we will learn a shortcut. Hover your mouse cursor over the error and
    right-click on it. Now click on **Generate...** and then select **Implement methods...**.
    In the **Select** **Methods To Implement** dialog box, **onClick(View):void**
    will already be selected:![Playing sounds in Android](img/8859OS_05_03.jpg)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与以前一样，我们的新代码行上出现了难看的红色下划线。上次发生这种情况时，我们在必须实现的`onClick`方法的空体中键入，一切都很好。这一次，因为我们已经知道这里发生了什么，我们将学习一个快捷方式。将鼠标悬停在错误上，右键单击它。现在单击**生成...**，然后选择**实现方法...**。在**选择要实现的方法**对话框中，**onClick(View):void**将被自动选择:![在Android中播放声音](img/8859OS_05_03.jpg)
- en: Select this option by clicking on **OK**. Now scroll to the bottom of your code
    and see that Android Studio has very kindly implemented the `onClick` method for
    you and the error is also gone.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击**确定**来选择此选项。现在滚动到代码底部，看到Android Studio已经很好地为您实现了`onClick`方法，错误也已经消失。
- en: 'Type this code after the `MainActivity` declaration to declare some variables
    for our sound effects:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`声明之后键入此代码，以声明一些用于我们的音效的变量：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Type this code in the `onCreate` method to load our sounds into memory:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中键入此代码，将我们的声音加载到内存中：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now add the code to grab a reference to the buttons in our UI and listen to
    clicks on them:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加代码来获取对UI中按钮的引用并监听点击事件：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, type this code in the `onClick` method that we autogenerated:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们自动生成的`onClick`方法中键入此代码：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Run the example on an emulator or on a real Android device. Notice that by clicking
    on a button, you can play any of your three sound samples at will. Of course,
    sounds can be played at almost any time, not just on button presses. Perhaps they
    can be played from a thread as well. We will see more sound samples when we implement
    the memory game later in the chapter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器或真实的Android设备上运行示例。注意，通过单击按钮，您可以随意播放三个声音样本中的任何一个。当然，几乎可以在任何时候播放声音，而不仅仅是在按下按钮时。也许它们也可以从一个线程中播放。在本章后面实现记忆游戏时，我们将看到更多的声音样本。
- en: This is how the code works. We started off by setting up a new project in the
    usual way. In steps 2 to 5, however, we created some sounds with Bfxr, created
    an `assets` folder, and placed the files within it. This is the folder where Android
    expects to find sound files. So when we write the code in the next steps that
    refers to the sound files, the Android system will be able to find them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的工作原理。我们首先按照通常的方式设置了一个新项目。然而，在步骤2到5中，我们使用Bfxr创建了一些声音，创建了一个`assets`文件夹，并将文件放在其中。这是Android期望找到声音文件的文件夹。因此，当我们在接下来的步骤中编写引用声音文件的代码时，Android系统将能够找到它们。
- en: In steps 6 to 8, we enabled our activity to listen to button clicks as we have
    done several times before. Only this time, we got Android Studio to autogenerate
    the `onClick` method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤6到8中，我们使我们的活动能够监听按钮点击，就像我们以前做过好几次一样。只是这一次，我们让Android Studio自动生成了`onClick`方法。
- en: 'Then we saw this code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们看到了这段代码：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'First, we create an object of the `SoundPool` type, called `soundPool`. This
    object will be the key to making noises with our Android device. Next, we have
    this code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为`soundPool`的`SoundPool`类型的对象。这个对象将是我们的Android设备发出声音的关键。接下来，我们有这段代码：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding code is very simple; we declared three `int` variables. However,
    they serve a slightly deeper purpose than a regular `int` variable. As we will
    see in the next block of code we analyze, they will be used to hold a reference
    to a sound file that is loaded into memory. In other words, the Android system
    will assign a number to each variable that will refer to a place in memory where
    our sound file will reside.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常简单；我们声明了三个`int`变量。然而，它们的作用略微超出了普通的`int`变量。正如我们将在下一段代码中看到的，它们将用于保存加载到内存中的声音文件的引用。换句话说，Android系统将为每个变量分配一个数字，该数字将指向内存中我们的声音文件所在的位置。
- en: We can think of this as a location in our variable warehouse. So we know the
    name of the `int` variable, and contained within it is what Android needs to find
    our sound. Here is how we load our sounds into memory and use the references we've
    just been discussing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把这看作是我们变量仓库中的一个位置。所以我们知道`int`变量的名称，它包含的是Android需要找到我们的声音的内容。这是我们如何将声音加载到内存中并使用我们刚刚讨论过的引用的方法。
- en: 'Let''s break the code in step 10 into a few parts. Take a close look and then
    we will examine what is going on:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将步骤10中的代码分解成几个部分。仔细观察一下，然后我们将分析其中的内容：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we initialize our `soundPool` object and request up to 10 simultaneous
    streams of sound. We should be able to really mash the app buttons and get a sound
    every time. `AudioManager.STREAM_MUSIC` describes the type of stream. This is
    typical for applications of this type. Finally, the `0` argument indicates we
    would like default quality sound.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化了我们的`soundPool`对象，并请求最多10个同时播放的声音流。我们应该能够真正地按下应用按钮，并在每次按下时听到声音。`AudioManager.STREAM_MUSIC`描述了流的类型。这对于这种类型的应用程序是典型的。最后，`0`参数表示我们希望获得默认质量的声音。
- en: Now we see something new. Notice that the next chunk of code is wrapped into
    two blocks, `try` and `catch`. This means that if the code in the `try` block
    fails, we want the code in the `catch` block to run. As you can see, there is
    nothing but a comment in the `catch` block.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到了一些新的东西。注意到下一段代码被包裹在两个块`try`和`catch`中。这意味着如果`try`块中的代码失败，我们希望运行`catch`块中的代码。正如你所看到的，`catch`块中除了一个注释之外什么也没有。
- en: We must do this because of the way the `SoundPool` class is designed. If you
    try to write the code without the `try` and `catch` blocks, it won't work. This
    is typical of Java classes involved in reading from files. It is a fail-safe process
    to check whether the file is readable or even whether it exists. You could put
    a line of code to output to the console that an error has occurred.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须这样做是因为`SoundPool`类的设计方式。如果你尝试在没有`try`和`catch`块的情况下编写代码，它是行不通的。这是Java类在读取文件时的典型情况。这是一个安全失败的过程，用来检查文件是否可读，甚至是否存在。你可以放置一行代码输出到控制台，表示发生了错误。
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to experiment with `try/catch`, then put a line of code to output
    a message in the `catch` block and remove one of the sound files from the assets
    folder. When you run the app, the loading will fail and the code in the `catch`
    block will be triggered.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试`try/catch`，那么在`catch`块中放置一行代码输出一条消息，并从`assets`文件夹中删除一个声音文件。当你运行应用程序时，加载将失败，并且`catch`块中的代码将被触发。
- en: 'We will throw caution to the wind because we are quite sure that the files
    will be there and will work . Let''s examine what is inside the `try` block. Take
    a close look at the following code and then we will dissect it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将放手一搏，因为我们非常确定文件会在那里并且会起作用。让我们仔细看看`try`块中的内容。仔细看一下下面的代码，然后我们将对其进行分析：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'First, we create an object called `assetManager` of the `AssetManager` type
    and an `AssetFileDescriptor` object called `descriptor`. We then use these two
    objects combined to load our first sound sample like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`assetManager`的`AssetManager`类型对象和一个名为`descriptor`的`AssetFileDescriptor`对象。然后，我们使用这两个对象组合来加载我们的第一个声音样本，就像这样：
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We now have a sound sample loaded in memory and its location saved in our `int`
    variable called `sample1`. The first sound file, `sample1.ogg`, is now ready to
    use. We perform the same procedure for `sample2` and `sample3` and we are ready
    to make some noise!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在内存中加载了一个声音样本，并且将其位置保存在我们的名为`sample1`的`int`变量中。第一个声音文件`sample1.ogg`现在已经准备好使用了。我们对`sample2`和`sample3`执行相同的过程，然后我们就可以开始制造一些噪音了！
- en: 'In step 11, we set up our buttons, which we have seen several times before.
    In step 12, we have our switch block ready to perform a different action depending
    upon which button is pressed. You can probably see that the single action each
    button takes is the playing of a sound. For example, **Button1** does this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11步，我们设置了按钮，这是我们之前见过好几次的。在第12步，我们准备好了一个开关块，根据按下的按钮执行不同的操作。你可能会看到每个按钮执行的单个操作都是播放声音。例如，**Button1**就是这样的：
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This line of code plays the sound that is loaded in memory at the location referred
    to by `int sample1`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码播放了内存中加载的声音，位置由`int sample1`引用。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The arguments of the method from left to right define the following: the sample
    to play, left volume, right volume, priority over other playing sounds, loop or
    not, rate of playback. You can have some fun with these if you like. Try setting
    the loop argument to `3` and the rate argument to perhaps `1.5`.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的参数从左到右依次定义如下：要播放的样本、左声音、右声音、优先级、循环与否、播放速率。如果愿意的话，你可以玩一下这些参数。尝试将循环参数设置为`3`，将速率参数设置为`1.5`。
- en: We handle each button in the same way. Now let's learn something serious.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以相同的方式处理每个按钮。现在让我们学点严肃的东西。
- en: Life after destruction – persistence
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 毁灭后的生活-持久性
- en: Okay, this is not as heavy as it sounds, but it is an important topic when making
    games. You have probably noticed that the slightest thing can reset our math game,
    such as an incoming phone call, a battery that ran flat, or even tilting the device
    to a different orientation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这并不像听起来那么沉重，但在制作游戏时这是一个重要的话题。你可能已经注意到，最微小的事情都可能重置我们的数学游戏，比如来电、电池耗尽，甚至将设备倾斜到不同的方向。
- en: When these events occur, we might like our game to remember the exact state
    it was in so that when the player comes back, it is in exactly the same place
    as they left off. If you were using a word-processing app, you would definitely
    expect this type of behavior.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些事件发生时，我们可能希望我们的游戏记住它的确切状态，这样当玩家回来时，它就会和离开时一样。如果你正在使用一个文字处理应用程序，你肯定会期望这种类型的行为。
- en: We are not going to go to that extent with our game, but as a bare minimum,
    shouldn't we at least remember the high score? This gives the player something
    to aim for, and most importantly, a reason to come back to our game.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算在游戏中做到这一点，但至少，作为最低限度，我们难道不应该记住最高分吗？这给玩家一个目标，最重要的是，给他们一个回到我们游戏的理由。
- en: An example of persistence
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久性的一个例子
- en: Android and Java have many different ways to achieve persistence of data, from
    reading and writing to files to setting up and using whole databases through our
    code. However, the neatest, simplest, and most suitable way for the examples in
    this book is by using the `SharedPreferences` class.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Android和Java有许多不同的方法来实现数据的持久性，从读写文件到设置和使用整个数据库。然而，在本书的示例中，最整洁、简单和合适的方法是使用`SharedPreferences`类。
- en: In this example, we will use the `SharedPreferences` class to save data. Actually,
    we will be reading and writing to files, but the class hides all of the complexity
    from us and allows us to focus on the game.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用`SharedPreferences`类来保存数据。实际上，我们将读写文件，但这个类会为我们隐藏所有的复杂性，让我们专注于游戏。
- en: 'We will see a somewhat abstract example of persistence so that we are familiar
    with the code before we use something similar to save the high score in our memory
    game. The complete code for this example can be found in the code bundle at `Chapter5/Persistence/java/MainActivity.java`
    and `Chapter5/Persistence/layout/activity_main.xml`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个相当抽象的持久性示例，以便在使用类似内容保存内存游戏的最高分之前，我们熟悉代码。这个示例的完整代码可以在代码包的`Chapter5/Persistence/java/MainActivity.java`和`Chapter5/Persistence/layout/activity_main.xml`中找到：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Also,
    clean up the code by deleting the unnecessary parts, but this isn't essential.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空白活动的项目，就像我们在[第2章](ch02.xhtml "第2章. 开始Android")中所做的那样，*开始Android*。同时，通过删除不必要的部分来清理代码，但这并非必需。
- en: Open `activity_main.xml` in the editor window and click and drag one button
    from the palette to the design. The default ID of the button that is assigned
    is perfect for our uses, so no further work is required on the UI.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑窗口中打开`activity_main.xml`，从工具栏中拖动一个按钮到设计中。按钮分配的默认ID非常适合我们的用途，因此UI上不需要进一步的工作。
- en: Open `MainActivity.java` in the editor window. Implement `View.onClickListener`
    and autogenerate the required `onClick` method, just as we did in steps 6 and
    7 of the *Playing sound in Android* example previously.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑窗口中打开`MainActivity.java`。实现`View.onClickListener`，并自动生成所需的`onClick`方法，就像我们之前在*在Android中播放声音*示例的第6步和第7步中所做的那样。
- en: 'Type the following code just after the `MainActivity` declaration. This declares
    our two objects that will do all the complex stuff behind the scenes: a bunch
    of strings that will be useful and a button:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`声明之后输入以下代码。这声明了我们的两个对象，它们将在幕后执行所有复杂的工作：一堆有用的字符串和一个按钮：
- en: '[PRE59]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add the next block of code to the `onCreate` method after the call to `setContentView`.
    We initialize our objects and set up our button. We will look closely at this
    code once the example is done:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setContentView`调用之后，将下一块代码添加到`onCreate`方法中。我们初始化我们的对象并设置我们的按钮。一旦示例完成，我们将仔细查看这段代码：
- en: '[PRE60]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now the action takes place in our `onClick` method. Add this code, which generates
    a random number and adds it to the end of `currentString`. Then it saves the string
    and sets the value of the string to the button as well:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，动作发生在我们的`onClick`方法中。添加这段代码，它生成一个随机数并将其添加到`currentString`的末尾。然后它保存字符串并将字符串的值设置为按钮的值：
- en: '[PRE61]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Run the example on an emulator or a device. Notice that each time you press
    the button, a random number is appended to the text of the button. Now quit the
    app, or even shut down the device if you like. When you restart the app, our cool
    `SharedPreferences` class simply loads the last saved string.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器或设备上运行示例。请注意，每次按按钮时，都会将随机数附加到按钮的文本上。现在退出应用程序，甚至关闭设备。当您重新启动应用程序时，我们很酷的`SharedPreferences`类将简单地加载上次保存的字符串。
- en: 'Here is how the code works. There is nothing we haven''t seen several times
    before until step 4:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的工作原理。直到第4步，我们之前已经见过几次了：
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, we declare two types of `SharedPreferences` objects called `prefs` and
    `editor`. We will see exactly how we use them in a minute.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了两种类型的名为`prefs`和`editor`的`SharedPreferences`对象。我们将在一分钟内看到我们如何使用它们。
- en: 'Next, we declare the `dataName` and `stringName` strings. We do this because
    to use the facilities of `SharedPreferences`, we need to refer to our collection
    of data, as well as any individual pieces of data within it, using a consistent
    name. By initializing `dataName` and `stringName`, we can use them as a name for
    our data store as well as a specific item within that data store, respectively.
    The sad face in `defaultString` gets used any time the `SharedPreferences` object
    needs a default because either nothing has been previously saved or the loading
    process fails for some reason. The `currentString` variable will hold the value
    of the string we will be saving and loading as well as displaying to the user
    of our app. Our buttonis `button1`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明`dataName`和`stringName`字符串。我们这样做是因为要使用`SharedPreferences`的功能，我们需要使用一致的名称引用我们的数据集合以及其中的任何个别数据。通过初始化`dataName`和`stringName`，我们可以将它们用作我们数据存储的名称以及数据存储中的特定项目的名称。`defaultString`中的悲伤表情在`SharedPreferences`对象需要默认值时使用，因为要么之前没有保存任何内容，要么加载过程由于某种原因失败。`currentString`变量将保存我们将保存和加载的字符串的值，并显示给我们应用程序的用户。我们的按钮是`button1`：
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In step 5, the real action starts with this code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，真正的动作从这段代码开始：
- en: '[PRE64]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The previous code does stuff that would take a lot more code if we didn't have
    the useful `SharedPreferences` class. The first two lines initialize the objects
    and the third loads the value from our data store item, whose name is contained
    in `stringName`, to our `currentString` variable. The first time this happens,
    it uses the `defaultString` value because nothing is stored there yet, but once
    there is a value stored, this single line of code that will load up our saved
    string.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码执行的操作，如果没有`SharedPreferences`类，将需要更多的代码。前两行初始化对象，第三行从我们的数据存储项中加载值，该项的名称包含在`stringName`中，到我们的`currentString`变量。第一次发生这种情况时，它使用`defaultString`值，因为那里还没有存储任何内容，但一旦有值存储，这一行代码将加载我们保存的字符串。
- en: 'At the end of step 5, we set up our button as we have done many times before.
    Moving on to step 6 in the `onClick` method, there is no `switch` block because
    there is only one button. So if a click is detected, it must be our button. Here
    are the first three lines from `onClick`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步结束时，我们设置了按钮，就像以前做过很多次一样。在`onClick`方法中继续进行第6步，没有`switch`块，因为只有一个按钮。因此，如果检测到点击，那么一定是我们的按钮。以下是`onClick`中的前三行：
- en: '[PRE65]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We generate a random number and append it to the `currentString` variable.
    Next, still in `onClick`, we do this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成一个随机数并将其附加到`currentString`变量。接下来，在`onClick`中，我们这样做：
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is like the opposite of the code that loaded our string in `onCreate`.
    The first of the previous two lines identifies the place in the data store to
    write the value to (`stringName`) and the value to be written there (`currentString`).
    The next line, `editor.commit();`, simply says, "go ahead and do it."
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像加载我们的字符串的代码的相反。前两行中的第一行标识要将值写入的数据存储中的位置（`stringName`），以及要在那里写入的值（`currentString`）。接下来的一行，`editor.commit();`，简单地表示“继续并执行”。
- en: 'The following line displays `currentString` as text on our button so that we
    can see what is going on:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一行将`currentString`显示为按钮上的文本，以便我们可以看到发生了什么：
- en: '[PRE67]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Tip
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more on persistence, take a look at the second question of the *Self-test
    questions* section at the end of this chapter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有关持久性的更多信息，请查看本章末尾的*自测问题*部分的第二个问题。
- en: The memory game
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆游戏
- en: The code in the memory game shouldn't challenge us too much because we have
    done the background research on threads, arrays, sound, and persistence. There
    will be some new-looking code and we will examine it in detail when it crops up.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在记忆游戏中的代码不应该让我们感到太困难，因为我们已经对线程、数组、声音和持久性进行了背景研究。会有一些看起来新的代码，我们将在出现时详细检查它。
- en: 'Here is a screenshot of our finished game:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们完成的游戏的屏幕截图：
- en: '![The memory game](img/8859OS_05_15.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![记忆游戏](img/8859OS_05_15.jpg)'
- en: 'This is the home screen. It shows the high score, which persists between play
    sessions and when the device is shut down. It also shows a **Play** button, which
    will take the player to the main game screen. Take a look at the following screenshot:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主屏幕。它显示高分，这些高分在游戏会话之间和设备关闭时保持不变。它还显示一个**Play**按钮，该按钮将带玩家到主游戏屏幕。看一下以下的屏幕截图：
- en: '![The memory game](img/8859OS_05_16.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![记忆游戏](img/8859OS_05_16.jpg)'
- en: The game screen itself will play a sequence of sounds and numbers. The corresponding
    button will *wobble* in time with the corresponding sound. Then the player will
    be able to interact with the buttons and attempt to copy the sequence. For every
    part of the sequence that the player gets right, they will be awarded points.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏屏幕本身将播放一系列声音和数字。相应的按钮将与相应的声音一起*摇摆*。然后玩家将能够与按钮交互，并尝试复制序列。对于玩家正确复制的每个部分，他们将获得积分。
- en: If the sequence is copied in its entirety, then a new and longer sequence will
    be played and again the player will attempt to repeat the sequence. This continues
    until the player gets a part of a sequence wrong.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果整个序列被复制，那么将播放一个新的更长的序列，然后玩家将再次尝试重复序列。这将持续到玩家出现错误的部分。
- en: As the score increases, it is displayed in the relevant TextView, and when a
    sequence is copied correctly, the level is increased and displayed below the score.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 随着分数的增加，它会显示在相关的TextView中，当一个序列被正确复制时，级别会增加并显示在分数下方。
- en: The player can start a new game by pressing the **Replay** button. If a high
    score is achieved, it will be saved to a file and displayed on the home screen.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以通过按下**重播**按钮开始新游戏。如果获得了最高分，它将被保存到文件并显示在主屏幕上。
- en: 'The implementation of the game is divided into five phases. The end of a phase
    would be a good place to take a break. Here are the different phases of the game:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的实现分为五个阶段。每个阶段的结束都是休息的好地方。以下是游戏的不同阶段：
- en: '**Phase 1**: This implements the UI and some basics.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段1**：实现UI和一些基础知识。'
- en: '**Phase 2**: This prepares our variables and presents the pattern (to be copied)
    to the player.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段2**：这将准备我们的变量并向玩家呈现（要复制的）模式。'
- en: '**Phase 3**: In this phase, we will handle the player''s response when they
    try to copy the pattern.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段3**：在这个阶段，我们将处理玩家尝试复制模式时的响应。'
- en: '**Phase 4**: Here, we will use what we just learned about persistence to maintain
    the player''s high score when they quit the game or turn off their device.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段4**：在这里，我们将使用刚刚学到的关于持久性的知识来在玩家退出游戏或关闭设备时保持玩家的最高分。'
- en: '**Phase 5**: At the end of phase 4, we will have a fully working memory game.
    However, to add to our repertoire of Android skills, after we have discussed Android
    UI animations near the end of this chapter, we will complete this phase, which
    will enhance our memory game.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段5**：在第4阶段结束时，我们将拥有一个完全可用的记忆游戏。然而，为了增加我们的Android技能，我们将在本章末讨论Android UI动画后完成这个阶段，这将增强我们的记忆游戏。'
- en: All the files containing the complete code and the sound files after all five
    stages can be found in the download bundle in the `Chapter5/MemoryGame` folder.
    In this project, however, there is a lot to be learned from going through each
    of the stages.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter5/MemoryGame`文件夹的下载包中可以找到所有五个阶段后包含完整代码和声音文件的文件。然而，在这个项目中，通过每个阶段都有很多东西可以学习。
- en: Phase 1 – the UI and the basics
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阶段1-UI和基础知识
- en: 'Here, we will lay out a home menu screen UI and a UI for the game itself. We
    will also configure some IDs for some of the UI elements so that we can control
    them in our Java code later:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将布置主菜单屏幕UI和游戏本身的UI。我们还将为一些UI元素配置一些ID，以便稍后在我们的Java代码中控制它们：
- en: Create a new application called `Memory Game` and clean up the code if you wish.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Memory Game`的新应用程序，并在需要时清理代码。
- en: Now we create a new activity and call it `GameActivity`. So right-click on the
    `java` folder in Project Explorer, navigate to **New** | **Activity**, then click
    on **Next**, name the activity as `GameActivity`, and click on **Finish**. For
    clarity, clean up this activity in the same way as we cleaned up all our others.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个新的活动并将其命名为`GameActivity`。因此，在Project Explorer中右键单击`java`文件夹，导航到**新建**
    | **活动**，然后单击**下一步**，将活动命名为`GameActivity`，然后单击**完成**。为了清晰起见，以与我们清理所有其他活动相同的方式清理此活动。
- en: Make the game fullscreen and lock the orientation as we did in the *Going fullscreen
    and locking orientation* tutorial at the end of [Chapter 4](ch04.xhtml "Chapter 4. Discovering
    Loops and Methods"), *Discovering Loops and Methods*.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使游戏全屏，并锁定方向，就像我们在[第4章](ch04.xhtml "第4章。发现循环和方法")的*全屏和锁定方向*教程中所做的那样，*发现循环和方法*。
- en: Open the `activity_main.xml` file from the `res/layout` folder.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`res/layout`文件夹中的`activity_main.xml`文件。
- en: 'Let''s quickly create our home screen UI by performing the following steps:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤快速创建我们的主屏幕UI：
- en: Open `activity_main.xml` in the editor and delete the **Hello World** TextView.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开`activity_main.xml`并删除**Hello World** TextView。
- en: 'Click and drag the following: **Large Text** to the top center (to create our
    title text), **Image** just below that, another **LargeText** below that (for
    our high score), and a **Button** (for our player to click to play). Your UI should
    look a bit like what is shown in the following screenshot:![Phase 1 – the UI and
    the basics](img/8859OS_05_04.jpg)'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动以下内容：**大文本**到顶部中心（创建我们的标题文本），**图像**就在其下方，另一个**大文本**在其下方（用于我们的最高分），以及一个**按钮**（供玩家点击以开始游戏）。您的UI应该看起来有点像下面截图中显示的样子：![阶段1-UI和基础知识](img/8859OS_05_04.jpg)
- en: Adjust the **text** properties of the two TextViews and the Button element to
    make it plain what each will be used for. As usual, you can replace the Android
    icon in the **ImageView** with any image you choose (as we did in [Chapter 4](ch04.xhtml
    "Chapter 4. Discovering Loops and Methods"), *Discovering Loops and Methods*,
    in the *Adding a custom image* tutorial).
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整两个TextView和Button元素的**文本**属性，以便清楚表明它们各自将用于什么。通常情况下，您可以用任何您选择的图像替换**ImageView**中的Android图标（就像我们在[第4章](ch04.xhtml
    "第4章。发现循环和方法")的*添加自定义图像*教程中所做的那样）。
- en: Tweak the sizes of the elements in the usual way to suit the emulator or device
    you will be running the game on.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以通常的方式调整元素的大小，以适应您将在其上运行游戏的模拟器或设备。
- en: Let's make the ID for our **Hi Score** TextView more relevant to its purpose.
    Left-click to select the **Hi Score** TextView, find its **id** property in the
    **Properties** window, and change it to `textHiScore`. The IDs of the image and
    the title are not required, and the existing ID of the play button is `button`,
    which seems appropriate already. So there is nothing else to change here.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使**Hi Score** TextView的ID更相关于其用途。左键单击选择**Hi Score** TextView，在**属性**窗口中找到其**id**属性，并将其更改为`textHiScore`。图像和标题的ID不是必需的，播放按钮的现有ID是`button`，似乎已经很合适了。所以这里没有其他需要更改的地方。
- en: 'Let''s wire up the **Play** button to create a link between the home and the
    game screens, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将**播放**按钮连接起来，以在主屏幕和游戏屏幕之间创建链接，如下所示：
- en: Open `MainActivity.java` in the editor.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开`MainActivity.java`。
- en: 'Add `implements View.onClickListener` to the end of the `MainActivity` declaration
    so that it now looks like this:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`声明的末尾添加`implements View.onClickListener`，使其看起来像这样：
- en: '[PRE68]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now hover your mouse over the line you just typed and right-click on it. Now
    click on **Generate**, then on **Implement methods...**, and then on **OK** to
    have Android Studio autogenerate the `onClick` method we must implement.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将鼠标悬停在刚刚键入的行上，并右键单击它。现在单击**生成**，然后单击**实现方法...**，然后单击**确定**，以便Android Studio自动生成我们必须实现的`onClick`方法。
- en: 'At the end of our `onCreate` method, before the closing curly brace, enter
    the following code to get a reference to our **Play** button and listen to clicks:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`onCreate`方法的结束处，在闭合大括号之前，输入以下代码以引用我们的**播放**按钮并监听点击：
- en: '[PRE69]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Scroll down to our `onClick` method and enter the following code in its body
    to have the **Play** button take the player to our `GameActivity`, which we will
    design soon:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到我们的`onClick`方法，并在其主体中输入以下代码，使**播放**按钮将玩家带到我们即将设计的`GameActivity`：
- en: '[PRE70]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'At this point, the app will run and the player can click on the **Play** button
    to take them to our game screen. So let''s quickly create our game screen UI:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，应用程序将运行，玩家可以单击**播放**按钮将他们带到我们的游戏屏幕。所以让我们快速创建我们的游戏屏幕UI：
- en: Open `activity_game.xml` in the editor and delete the **Hello World** TextView.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开`activity_game.xml`，并删除**Hello World** TextView。
- en: Drag three **Large Text** elements one below the other and center them horizontally.
    Below them, add four buttons stacked one on top of the other, and finally, add
    another button below that but offset it to the right-hand side so that it looks
    like what is shown in the next screenshot. I have also adjusted the text properties
    for the UI elements to make it clear what each will be used for, but this is optional
    because our Java code will do all of the work for us. You can also tweak the sizes
    of the elements in the usual way to suit the emulator or device you will be running
    the game on.![Phase 1 – the UI and the basics](img/8859OS_05_05.jpg)
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个**大文本**元素拖动到彼此下方，并水平居中。在它们下方，添加四个按钮，一个在另一个上方堆叠，最后，在下方添加另一个按钮，但将其偏移到右侧，使其看起来像下一个屏幕截图中显示的样子。我还调整了UI元素的文本属性，以清楚地说明每个元素将用于什么，但这是可选的，因为我们的Java代码将为我们完成所有工作。您还可以按照通常的方式调整元素的大小，以适应您将在其上运行游戏的模拟器或设备。![第1阶段
    - UI和基础知识](img/8859OS_05_05.jpg)
- en: 'Now let''s assign some useful IDs to our UI elements so that we can do some
    Java magic with them in the next tutorial. Here is a table that matches the UI
    elements shown in the last screenshot with the **id** property value that you
    need to assign. Assign the following **id** property values to the corresponding
    UI elements:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们为我们的UI元素分配一些有用的ID，以便我们可以在下一个教程中对它们进行一些Java魔术。以下是一个表，它将上一个屏幕截图中显示的UI元素与您需要分配的**id**属性值进行匹配。将以下**id**属性值分配给相应的UI元素：
- en: '| Purpose | Default id property | New id to assign |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 目的 | 默认id属性 | 要分配的新id |'
- en: '| --- | --- | --- |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Score indicator | textView | textScore |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 分数指示器 | textView | textScore |'
- en: '| Difficulty indicator | textView2 | textDifficulty |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 难度指示器 | textView2 | textDifficulty |'
- en: '| Watch/go indicator | textView3 | textWatchGo |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 观看/前进指示器 | textView3 | textWatchGo |'
- en: '| Button 1 | button | Leave at default |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 按钮1 | button | 保持默认 |'
- en: '| Button 2 | button2 | Leave at default |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 按钮2 | button2 | 保持默认 |'
- en: '| Button 3 | button3 | Leave at default |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 按钮3 | button3 | 保持默认 |'
- en: '| Button 4 | button4 | Leave at default |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 按钮4 | button4 | 保持默认 |'
- en: '| Replay button | button5 | buttonReplay |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 重播按钮 | button5 | buttonReplay |'
- en: Now that we have our game menu and actual game UI ready to go, we can start
    to make it work.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的游戏菜单和实际游戏UI已经准备就绪，我们可以开始让它运行。
- en: Phase 2 – preparing our variables and presenting the pattern
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2阶段 - 准备我们的变量并呈现模式
- en: 'Here, we will set up a whole load of variables and objects for us to use, both
    in this phase and in the later phases. We will also implement the parts of the
    code that present a pattern to the player. We will add code that enables the player
    to respond in a later phase:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将设置大量变量和对象供我们在这个阶段和以后的阶段使用。我们还将实现呈现给玩家模式的代码部分。我们将在以后的阶段添加使玩家能够做出反应的代码：
- en: Open `GameActivity.java` in the editor window.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器窗口中打开`GameActivity.java`。
- en: I made the sounds by finding a pleasing one then slowly increasing the **Frequency**
    slider for each subsequent sample. You can use my sound from the `assets` folder
    in the `MemoryGame` project or create your own sound using Bfxr.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我通过找到一个令人愉悦的声音，然后逐渐增加每个后续样本的**频率**滑块来制作声音。您可以使用`MemoryGame`项目中`assets`文件夹中的我的声音，也可以使用Bfxr创建自己的声音。
- en: In the `main` folder in the project explorer window, we need to add a folder
    called `assets`. So in the project explorer window, right-click on the `main`
    folder and navigate to **New** | **Directory**. Type `assets` in the **New Directory**
    dialog box.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器窗口中的`main`文件夹中，我们需要添加一个名为`assets`的文件夹。因此，在项目资源管理器窗口中，右键单击`main`文件夹，然后导航到**新建**
    | **目录**。在**新目录**对话框中键入`assets`。
- en: 'Now copy and paste the four sound files to the newly created `assets` folder.
    You can do so like this: select the files, right-click on them, and then click
    on **Copy**. Then click on the `assets` folder in the Android Studio project explorer.
    Now right-click on the `assets` folder and click on **Paste**.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将四个声音文件复制并粘贴到新创建的`assets`文件夹中。您可以这样做：选择文件，右键单击它们，然后单击**复制**。然后单击Android Studio项目资源管理器中的`assets`文件夹。现在右键单击`assets`文件夹，然后单击**粘贴**。
- en: 'Let''s prepare `GameActivity` to listen to button clicks just as we did for
    `MainActivity`, as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备`GameActivity`来监听按钮点击，就像我们为`MainActivity`所做的那样：
- en: 'Add `implementsView.onClickListener` to the end of the `GameActivity` declaration
    so that it now looks like this:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameActivity`声明的末尾添加`implementsView.onClickListener`，使其看起来像这样：
- en: '[PRE71]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now hover your mouse over the line you just typed and right-click on it. Now
    click on **Generate**, then on **Implement methods...**, and then on **OK** to
    have Android Studio autogenerate the `onClick` method that we will use shortly.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将鼠标悬停在您刚刚输入的行上，并右键单击它。现在单击**生成**，然后单击**实现方法...**，然后单击**确定**，以便让Android Studio自动生成我们即将使用的`onClick`方法。
- en: 'Let''s declare some objects that we need to reference our UI and our `int`
    references for the sound effects we will load soon. Write the code just after
    the declaration for `GameActivity`. By putting them here, they will be available
    to all parts of our code in `GameActivity.java`. Here is the code in context:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明一些我们需要引用我们的UI和我们将很快加载的声音效果的`int`引用的对象。在`GameActivity`的声明之后写下这些代码。通过将它们放在这里，它们将对`GameActivity.java`中的所有部分都可用。以下是上下文中的代码：
- en: '[PRE72]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, after the last line of code from the previous step, enter the following
    code snippet, which will declare and initialize some variables for use in our
    thread. Notice that at the end, we also declare `myHandler`, which will be our
    thread, and `gameOn` to control whether our code within the thread is executed:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在上一步的代码的最后一行之后，输入以下代码片段，它将声明和初始化一些变量，供我们的线程使用。请注意，在最后，我们还声明了`myHandler`，它将是我们的线程，以及`gameOn`来控制我们线程中的代码是否被执行：
- en: '[PRE73]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Just after our call to `setContentView` in the `onCreate` method, we make our
    sound effects ready to be played:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中调用`setContentView`后，我们准备好播放我们的音效：
- en: '[PRE74]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Just after the code in the last step and still within the `onCreate` method,
    we initialize our objects and set click listeners for the buttons:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步的代码之后，仍然在`onCreate`方法中，我们初始化我们的对象并为按钮设置点击监听器：
- en: '[PRE75]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, after the last line of the code from the previous step, enter the code
    that will create our thread. We will add the details in the next step within the
    `if(playSequence)` block. Notice that the thread is run every nine-tenths of a
    second (900 milliseconds). Notice that we start the thread but do not set `playSequence`
    to `true`. So it will not do anything yet:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在上一步的代码的最后一行之后，输入将创建我们的线程的代码。我们将在`if(playSequence)`块中的下一步中添加细节。请注意，线程每九分之一秒（900毫秒）运行一次。请注意，我们启动了线程，但没有将`playSequence`设置为`true`。所以它现在什么也不会做：
- en: '[PRE76]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Before we look at the code that will run in our thread, we need a way to generate
    a random sequence appropriate for the difficulty level. This situation sounds
    like a candidate for a method. Enter this method just before the closing curly
    brace of the `GameActivity` class:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查看将在我们的线程中运行的代码之前，我们需要一种方法来生成适合难度级别的随机序列。这种情况听起来像是一个方法的候选。在`GameActivity`类的右花括号之前输入此方法：
- en: '[PRE77]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We also need a method to prepare and start our thread. Type the following method
    after the closing curly brace of `createSequence`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个方法来准备和启动我们的线程。在`createSequence`的右花括号后输入以下方法：
- en: Tip
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Actually, the order of implementation of the methods is unimportant. However,
    following along in order will mean our code will look the same. Even if you are
    referring to the downloaded code, the order will be the same.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，方法的实现顺序并不重要。然而，按顺序进行将意味着我们的代码看起来是一样的。即使您在引用下载的代码，顺序也是一样的。
- en: '[PRE78]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Just before we look at the details of the thread code, we need a method to
    tidy up our variables after the sequence has been played. Enter this method after
    the closing curly brace of `playASequence`:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查看线程代码的细节之前，我们需要一个方法来在播放序列后整理我们的变量。在`playASequence`的右花括号之后输入此方法：
- en: '[PRE79]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Finally, we will implement our thread. There is some new code in this part,
    which we will go through in detail after we finish this phase of the project.
    Enter this code between the opening and closing curly braces of the `if(playSequence){
    }` block:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将实现我们的线程。这部分有一些新的代码，我们将在完成项目的这个阶段后详细介绍。在`if(playSequence){ }`块的左花括号和右花括号之间输入此代码：
- en: '[PRE80]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Tip
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Just before the closing curly brace of `onCreate`, we could initiate a sequence
    by calling our `playASequence` method, like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`的右花括号之前，我们可以通过调用我们的`playASequence`方法来启动一个序列，就像这样：
- en: '[PRE81]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We could then run our app, click on **Play** on the home screen, and watch as
    a sequence of four random buttons and their matching sounds begins, with the sounds
    being played. In the next phase, we will wire up the **Replay** button so that
    the player can start the sequence when they are ready.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以运行我们的应用程序，在主屏幕上点击**播放**，观看四个随机按钮及其匹配的声音序列开始播放。在下一阶段，我们将连接**重播**按钮，以便玩家可以在准备好时开始序列。
- en: Phew! That was a long one. Actually, there is not much new there, but we did
    cram in just about everything we ever learned about Java and Android into one
    place, and we used it in new ways too. So we will look at it step by step and
    give extra focus to the parts that might seem tricky.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这是一个很长的过程。实际上，那里并没有太多新东西，但我们确实将我们学到的关于Java和Android的一切都塞进了一个地方，并且还以新的方式使用了它。因此，我们将逐步查看它，并对可能看起来棘手的部分进行额外关注。
- en: Let's look at each new piece of code in turn.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次查看每个新的代码片段。
- en: From steps 1 to 7, we initialized our variables, set up our buttons, and loaded
    our sounds as we have done before. We also put in the outline of the code for
    our thread.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 从步骤1到7，我们初始化了变量，设置了按钮，并像以前一样加载了声音。我们还放入了我们线程代码的大纲。
- en: 'In step 8, we implemented the `createSequence` method. We used a `Random` object
    to generate a sequence of random numbers between 1 and 4\. We did this in a `for`
    loop, which loops until a sequence the length of `difficultyLevel` has been created.
    The sequence is stored in an array called `sequenceToCopy`, which we can later
    use to compare to the player''s response:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8步中，我们实现了`createSequence`方法。我们使用`Random`对象生成1到4之间的随机数序列。我们在`for`循环中执行此操作，该循环会一直循环，直到创建了长度为`difficultyLevel`的序列。该序列存储在名为`sequenceToCopy`的数组中，我们稍后可以用它来与玩家的响应进行比较：
- en: '[PRE82]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In step 9, we implemented `playASequence`. First, we call `createSequence`
    to load our `sequenceToCopy` array. Then we set `isResponding` to `false` because
    we don''t want the player to bash buttons while the sequence is still playing.
    We set `elementToPlay` to `0` as this is the first element of our array. We also
    set `playerResponses` to `0`, ready to count the player''s responses. Next, we
    set some text on the UI to `"WATCH!"` to make it clear to the player that the
    sequence is playing. Finally, we set `playSequence` to `true`, which allows the
    code in our thread to run once every 900 milliseconds. Here is the code we have
    just analyzed:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9步中，我们实现了`playASequence`。首先，我们调用`createSequence`来加载我们的`sequenceToCopy`数组。然后，我们将`isResponding`设置为`false`，因为我们不希望玩家在序列仍在播放时乱按按钮。我们将`elementToPlay`设置为`0`，因为这是我们数组的第一个元素。我们还将`playerResponses`设置为`0`，准备计算玩家的响应。接下来，我们在UI上设置一些文本为“WATCH!”，以便向玩家清楚地表明序列正在播放。最后，我们将`playSequence`设置为`true`，这允许我们的线程代码每900毫秒运行一次。以下是我们刚刚分析的代码：
- en: '[PRE83]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In step 10, we handle `sequenceFinished`. We set `playSequence` to `false`,
    which prevents the code in our thread from running. We set all the buttons back
    to visible because, as we will see in the thread code, we set them to invisible
    to emphasize which button comes next in the sequence. We set our UI text to **GO!**
    to make it clear. It is time for the player to try and copy the sequence. For
    the code in the `checkElement` method to run, we set `isResponding` to `true`.
    We will look at the code in the `checkElement` method in the next phase:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10步中，我们处理了`sequenceFinished`。我们将`playSequence`设置为`false`，这样可以阻止我们线程中的代码运行。我们将所有按钮都设置为可见，因为正如我们将在线程代码中看到的那样，我们将它们设置为不可见以强调序列中接下来的按钮。我们将我们的UI文本设置为**GO!**，以明确表示。现在是玩家尝试复制序列并得分的时候了。为了使`checkElement`方法中的代码运行，我们将`isResponding`设置为`true`。我们将在下一个阶段查看`checkElement`方法中的代码：
- en: '[PRE84]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In step 11, we implement our thread. It''s quite long but not too complicated.
    First, we set all the buttons to visible as this is quicker than checking which
    one of them is currently invisible and setting just that one:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11步中，我们实现了我们的线程。它相当长，但不太复杂。首先，我们将所有按钮都设置为可见，因为这比检查它们中的哪一个当前不可见并仅设置那一个要快得多：
- en: '[PRE85]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then we switch based on what number is next in our sequence, hide the appropriate
    button, and play the appropriate sound. Here is the first case in the `switch`
    block for reference. The other case elements perform the same function but on
    a different button and with a different sound:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们根据序列中的下一个数字进行切换，隐藏适当的按钮，并播放适当的声音。以下是`switch`块中的第一个情况供参考。其他情况元素执行相同的功能，但在不同的按钮上以及使用不同的声音：
- en: '[PRE86]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now we increment `elementToPlay`, ready to play the next part of the sequence
    when the thread runs again in approximately 900 milliseconds:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们增加`elementToPlay`，准备在线程大约900毫秒后再次运行时播放序列的下一部分：
- en: '[PRE87]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Next, we check whether we have played the last part of the sequence. If we
    have, we call our `sequenceFinished` method to set things up for the player to
    attempt their answer:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否已经播放了序列的最后一部分。如果是，我们调用我们的`sequenceFinished`方法来为玩家尝试他们的答案做好准备：
- en: '[PRE88]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, we tell the thread when we would like to run our code again:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们告诉线程我们何时再次运行我们的代码：
- en: '[PRE89]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: When you ran a sequence (see the previous tip), did you notice an imperfection/bug
    with our game operation? This has to do with the way the last element of the sequence
    is animated. It is because our `sequenceFinished` method makes all the buttons
    visible so soon after the button has just been made invisible that looks like
    the button is never made invisible at all. We will solve the problem of the button
    that doesn't stay invisible long enough when we learn about UI animation in phase
    5.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行序列（参见上一个提示）时，是否注意到我们游戏操作中的不完美/错误？这与序列的最后一个元素的动画方式有关。这是因为我们的`sequenceFinished`方法使所有按钮很快就可见，所以在按钮刚刚变得不可见后，看起来就像按钮根本没有变得不可见。当我们在第5阶段学习UI动画时，我们将解决按钮不保持足够长时间不可见的问题。
- en: Now let's handle the player's response.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们处理玩家的响应。
- en: Phase 3 – the player's response
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三阶段-玩家的响应
- en: We now have an app that plays a random sequence of button flashes and matching
    sounds. It also stores that sequence in an array. So what we have to do now is
    enable the player to attempt to replicate the sequence and score points if successful.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个应用程序，可以播放随机的按钮闪烁和匹配的声音序列。它还将该序列存储在一个数组中。所以现在我们要做的是让玩家尝试复制序列，并在成功时得分。
- en: We can do all of this in two phases. First, we need to handle the button presses,
    which can pass all the hard work to a method that will do everything else.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以分两个阶段完成所有这些。首先，我们需要处理按钮的按压，这可以将所有的工作都传递给一个方法，该方法将完成其他所有工作。
- en: 'Let''s write the code and look at it as we go. Afterwards, we will closely
    examine the less obvious parts:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码，并在进行时查看它。之后，我们将仔细检查不太明显的部分：
- en: 'Here is how we handle the button presses. We have the empty body of the `switch`
    statement with an extra `if` statement that checks whether there is a sequence
    currently being played. If there is a sequence, then no input is accepted. We
    will start to fill the code in the empty body in the next step:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们处理按钮按下的方法。我们有`switch`语句的空主体，还有一个额外的`if`语句，检查当前是否正在播放序列。如果有一个序列，那么不接受任何输入。我们将在下一步开始填写空主体中的代码：
- en: '[PRE90]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, here is the code that handles `button1`. Notice that it just plays the
    sound related to `button1` and then calls the `checkElement` method, passing a
    value of 1\. This is all we have to do for the buttons 1 through 4: play a sound
    and then tell our new method (`checkElement`) which numbered button was pressed,
    and `checkElement` will do the rest:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这是处理`button1`的代码。请注意，它只播放与`button1`相关的声音，然后调用`checkElement`方法，传递一个值为1。对于按钮1到4，我们只需要做这些：播放声音，然后告诉我们的新方法（`checkElement`）按下了哪个编号的按钮，`checkElement`将完成其余工作：
- en: '[PRE91]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Here is the near-identical code for buttons 2 through 4\. Notice that the value
    passed to `checkElement` and the sound sample that is played are the only differences
    from the previous step. Enter this code directly after the code in the previous
    step:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是按钮2到4的几乎相同的代码。请注意，传递给`checkElement`和播放的声音样本是与上一步的唯一区别。在上一步的代码之后直接输入此代码：
- en: '[PRE92]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here is the last part of the code in our `onClick` method. This handles the
    **Restart** button. The code just resets the score and the difficulty level and
    then calls our `playASequence` method, which does the rest of the work of starting
    the game again. Enter this code directly after the code in the previous step:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们`onClick`方法中的最后一部分代码。这处理**重新开始**按钮。该代码只是重置分数和难度级别，然后调用我们的`playASequence`方法，该方法完成了重新开始游戏的其余工作。在上一步的代码之后直接输入此代码：
- en: '[PRE93]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Finally, here is our do-everything method. This is quite a long method compared
    to most of our previous methods, but it helps to see its entire structure. We
    will break this down line by line in a minute. Enter the following code, after
    which you will actually be able to play the game and get a score:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这是我们的全能方法。与我们以前的大部分方法相比，这是一个相当长的方法，但看到它的整个结构会有所帮助。我们将在一分钟内逐行分解这个方法。在输入以下代码之后，您实际上将能够玩游戏并获得分数：
- en: '[PRE94]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We covered the methods fairly comprehensively as we went through the tutorial.
    The one elephant in the room, however, is the apparent sprawl of code in the `checkElement`
    method. So let's go through all of the code in step 6, line by line.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在教程中对方法进行了相当全面的介绍。然而，房间里的大象是`checkElement`方法中代码的明显蔓延。所以让我们逐行通过第6步中的所有代码。
- en: 'First, we have the method signature. Notice that it does not return a value
    but it receives an `int` value. Remember that it is the `onClick` method that
    calls this method and it passes a `1`, `2`, `3`, or `4`, depending upon which
    button was clicked:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有方法签名。请注意，它不返回值，但接收一个`int`值。请记住，调用这个方法的是`onClick`方法，它传递一个`1`、`2`、`3`或`4`，取决于点击了哪个按钮：
- en: '[PRE95]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, we wrap the rest of this code into an `if` statement. Here is the `if`
    statement. We enter the block when the `isResponding` Boolean is `true`, and `isResponding`
    is set to `true` when the `sequenceFinnished` method completes, which is just
    what we need so that the player can''t mash the buttons until it is time to do
    so and our game is ready to listen:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将剩下的代码包装到一个`if`语句中。这是`if`语句。当`isResponding`布尔值为`true`时，我们进入这个块，而`isResponding`在`sequenceFinnished`方法完成时被设置为`true`，这正是我们需要的，这样玩家就不能在时机未到时乱按按钮，我们的游戏已经准备好听取指令：
- en: '[PRE96]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Here is what happens inside the `if` block. We increment the number of the
    player''s responses received in the `playerResponses` variable:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`if`块内发生的事情。我们增加了`playerResponses`变量中接收到的玩家响应的数量：
- en: '[PRE97]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now we check whether the number passed to the `checkElement` method and stored
    in `thisElement` matches the appropriate part of the sequence the player is trying
    to copy. If it matches, we increase `playerScore` by an amount relative to the
    number of correctly matched parts of the sequence so far. Then we set the score
    on the screen. Notice that if the response does not match, there is an `else`
    block to go with this `if` block that we will explain soon:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们检查传递给`checkElement`方法并存储在`thisElement`中的数字是否与玩家试图复制的序列的适当部分匹配。如果匹配，我们将根据迄今为止正确匹配的序列部分数量增加`playerScore`。然后我们在屏幕上设置分数。请注意，如果响应不匹配，就会有一个`else`块与这个`if`块配对，我们很快会解释：
- en: '[PRE98]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Next, we have another `if` block. Note that this `if` block is nested inside
    the `if` block we just described. So it will only be tested and potentially run
    if the player''s response was correct. This `if` statement checks whether it is
    the last part of the sequence, like this:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有另一个`if`块。请注意，这个`if`块嵌套在我们刚刚描述的`if`块内部。因此，只有在玩家的响应正确时才会被测试和可能运行。这个`if`语句检查是否是序列的最后一部分，就像这样：
- en: '[PRE99]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If it is the last part of the sequence, it executes the following lines:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是序列的最后一部分，它执行以下行：
- en: '[PRE100]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'What is happening inside the nested `if` statement, which checks whether the
    whole sequence has been correctly copied, is the following: It sets `isResponding`
    to `false`, so the player gets no response from the buttons. It then raises the
    difficulty level by 1 so that the sequence is a bit tougher next time. Finally,
    it calls the `playSequence` method to play another sequence and the whole process
    starts again.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查嵌套的`if`语句内部发生的事情，检查整个序列是否已经正确复制，是这样的：它将`isResponding`设置为`false`，所以玩家不会从按钮得到任何响应。然后它将难度级别提高1，以便下次序列会更加困难。最后，它调用`playSequence`方法来播放另一个序列，整个过程重新开始。
- en: 'Here is the `else` block, which runs if the player gets part of the sequence
    wrong:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`else`块，如果玩家复制了序列的一部分错误，就会运行这个块：
- en: '[PRE101]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Here, we set some text on the screen and set `isResponding` to `false`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在屏幕上设置一些文本，并将`isResponding`设置为`false`。
- en: Now let's use what we learned about the `SharedPreferences` class to preserve
    the high scores.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们利用`SharedPreferences`类所学到的知识来保存高分。
- en: Phase 4 – preserving the high score
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4阶段 - 保留最高分
- en: 'This phase is nice and short. We will use what we learned earlier in the chapter
    to save the player''s score if it is a new high score, and then display the best
    score in the **hi-score** TextView in our `MainActivity`:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段很简短。我们将使用本章前面学到的知识来保存玩家的分数，如果是新的最高分，然后在我们的`MainActivity`中的**hi-score** TextView中显示最佳分数：
- en: Open `MainActivity.java` in the editor window.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑窗口中打开`MainActivity.java`。
- en: 'Then we declare our objects used to read from a file just after the class declaration,
    like this:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在类声明之后声明用于从文件中读取的对象，就像这样：
- en: '[PRE102]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, just after our call to `setContentView` in the `onCreate` method, we initialize
    our objects, read from our file, and set the result to our `hiScore` variable.
    We then display it to the player:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`onCreate`方法中的`setContentView`调用之后，我们初始化我们的对象，从文件中读取，并将结果设置为我们的`hiScore`变量。然后将其显示给玩家：
- en: '[PRE103]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Next, we need to go back to the `GameActivity.java` file.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要回到`GameActivity.java`文件。
- en: 'We declare our objects to edit our file, this time like this:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次我们声明用于编辑文件的对象，就像这样：
- en: '[PRE104]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Just after the call to `setContentView` in the `onCreate` method, we instantiate
    our objects and assign a value to `hiScore`:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中的`setContentView`调用之后，我们实例化我们的对象并为`hiScore`赋值：
- en: '[PRE105]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The only thing that is different to what we have already learned is that we
    need to consider where we put the code to test for a high score and where to write
    to our file if appropriate. Consider this: eventually, every player must fail.
    Furthermore, the point at which they fail is the point when their score is at
    its highest, yet before it is reset when they try again. Place the following code
    in the `else` block, which handles a wrong answer from the player. The highlighted
    code is the new code; the rest is there to help you with the context:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一与我们已经学到的不同的是，我们需要考虑在哪里放置代码来测试最高分，并在适当时写入我们的文件。考虑到：最终，每个玩家都必须失败。此外，当他们的分数最高但在再次尝试时重置之前，他们失败的时刻就是他们的分数最高的时刻。将以下代码放在`else`块中，处理玩家的错误答案。突出显示的代码是新代码；其余代码是为了帮助您理解上下文。
- en: '[PRE106]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Play the game and get a high score. Now quit the app or even restart the phone.
    When you come back to the app, your high score is still there.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏并获得高分。现在退出应用程序，甚至重新启动手机。当您回到应用程序时，您的最高分仍然存在。
- en: The code we added in this phase is nearly the same as the code we wrote in our
    previous example of persistence, the only difference being that we wrote to the
    data store when a new high score was achieved instead of when a button was pressed.
    In addition, we used the `editor.putInt` method because we were saving an integer
    instead of `editor.putString` when we were saving a string.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个阶段添加的代码几乎与我们在之前的持久性示例中编写的代码相同，唯一的区别是当达到新的最高分时，我们将数据存储到数据存储中，而不是当按下按钮时。此外，我们使用了`editor.putInt`方法，因为我们保存的是整数，而不是在保存字符串时使用`editor.putString`。
- en: Animating our game
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画我们的游戏
- en: Before we go ahead, let's just think about animation. What is it exactly? The
    word probably conjures up images of moving cartoon characters and in-game characters
    of a video game.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们思考一下动画。它到底是什么？这个词可能让人联想到移动的卡通角色和视频游戏中的游戏角色。
- en: We need to animate our buttons (make them move) to make it clear when they are
    part of the sequence. We saw that simply making one disappear and then reappear
    was inadequate.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的按钮添加动画效果（使它们移动），以便清楚地显示它们是序列的一部分。我们发现简单地使一个按钮消失然后重新出现是不够的。
- en: The thought of controlling the movement of UI elements might make us imagine
    complex `for` loops and per-pixel calculations.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 控制UI元素的移动可能让我们想象复杂的`for`循环和逐像素计算。
- en: Fortunately, Android provides us with the `Animation` class, which allows us
    to animate UI objects without any such per-pixel awkwardness. Here is how it works.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Android为我们提供了`Animation`类，允许我们在没有任何像素尴尬的情况下对UI对象进行动画处理。它是如何工作的。
- en: Note
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, to fully control the shape and size of in-game objects, we must eventually
    learn to manipulate individual pixels and lines. We will do so from [Chapter 7](ch07.xhtml
    "Chapter 7. Retro Squash Game"), *Retro Squash Game*, onwards, when we make a
    retro pong-style squash game.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要完全控制游戏对象的形状和大小，我们最终必须学会操作单个像素和线条。从[第7章](ch07.xhtml "第7章。复古乒乓球游戏")开始，当我们制作一个复古乒乓球风格的壁球游戏时，我们将这样做。
- en: UI animation in Android
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android中的UI动画
- en: 'Animations in the Android UI can be divided into three phases:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Android UI中的动画可以分为三个阶段：
- en: Describing the animation in a file using a special syntax we will see shortly
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们将很快看到的特殊语法在文件中描述动画
- en: Referencing that animation by creating an object of it in our Java code
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在我们的Java代码中创建一个对象来引用该动画
- en: Applying the animation to a UI element when the animation is required to run
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要运行动画时将动画应用于UI元素
- en: Let's take a look at some code that describes an animation. We will soon be
    reusing this same code in our memory game. The purpose of showing it is not so
    much that we understand each and every line of it. After all, learning Java should
    be enough of an accomplishment without mastering this too. Moreover, the purpose
    is to demonstrate that whatever animation you can describe can then be used in
    our games using the same Java.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些描述动画的代码。我们很快将在我们的记忆游戏中重用这段代码。展示它的目的并不是让我们理解其中的每一行。毕竟，学习Java应该足够成就感，而不必掌握这个。此外，目的是演示无论您能描述什么动画，都可以在我们的游戏中使用相同的Java。
- en: 'We can quickly search the Web to find the code to perform the following:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速搜索网络以找到执行以下操作的代码：
- en: Fading in and out
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 淡入淡出
- en: Sliding
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑动
- en: Rotating
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转
- en: Expanding or shrinking
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展或收缩
- en: Morphing color
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变色
- en: 'Here is some code that causes a wobble effect. We will use it on a button,
    but you can also use it on any UI element or even the whole screen:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些导致摇晃效果的代码。我们将在一个按钮上使用它，但您也可以在任何UI元素甚至整个屏幕上使用它：
- en: '[PRE107]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The first line simply states that this is a file written in XML format. The
    next states that we will be performing a rotation. Then we state that the duration
    will be 100 milliseconds, the rotation will be from -5 degrees, the pivot will
    be on the *x* and *y* axes by 50 percent, repeat eight times, and reverse to positive
    5 degrees.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行只是说明这是一个以XML格式编写的文件。接下来说明我们将执行一个旋转。然后我们说明持续时间将是100毫秒，旋转将从-5度开始，中心将在*x*和*y*轴上分别为50％，重复八次，并反向到正5度。
- en: This is quite a mouthful, but the point is that it is easy to grab a template
    that works and then customize it to fit our situation. We could save the preceding
    code with a filename like `wobble.xml`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的代码，但重点是很容易抓住一个有效的模板，然后自定义以适应我们的情况。我们可以将上述代码保存为类似`wobble.xml`的文件名。
- en: 'Then we could simply reference it as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以简单地引用它如下：
- en: '[PRE108]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Now we can play the animation like this on our chosen UI object, in this case
    our `button1` object:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以这样播放动画，如下所示，对我们选择的UI对象进行操作，本例中是我们的`button1`对象：
- en: '[PRE109]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Phase 5 – animating the UI
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5阶段-UI动画
- en: 'Let''s add an animation that causes a button to wobble when a button sound
    is played. At the same time, we can remove the code that makes the button invisible
    and the code that makes it reappear. That wasn''t the best way to do it, but it
    served a purpose while developing the game:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个动画，当播放按钮声音时使按钮摇摆。同时，我们可以删除使按钮不可见的代码以及使其重新出现的代码。这不是最好的方法，但在开发游戏时起到了作用：
- en: We need to add a new folder to our project, called `anim`. So right-click on
    the `res` folder in the Project Explorer window. Navigate to **New** | **Android
    resource directory** and click on **OK** to create the new `anim` folder.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要向我们的项目添加一个名为`anim`的新文件夹。因此，在Project Explorer窗口中右键单击`res`文件夹。导航到**新建** |
    **Android资源目录**，然后单击**确定**以创建新的`anim`文件夹。
- en: Now right-click on the `anim` folder and navigate to **New** | **Animation resource
    file**. Enter `wobble` in the **File name** field and click on **OK**. We now
    have a new file called **wobble.xml** open in the editor window.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在右键单击`anim`文件夹，然后导航到**新建** | **动画资源文件**。在**文件名**字段中输入`wobble`，然后单击**确定**。现在我们在编辑器窗口中打开了一个名为**wobble.xml**的新文件。
- en: 'Replace all but the first line of `wobble.xml` with this code:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用这段代码替换`wobble.xml`除第一行以外的所有内容：
- en: '[PRE110]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Now switch to `GameActivity.java`.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在切换到`GameActivity.java`。
- en: 'Add the following code just after the declaration of our `GameActivity` class:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`GameActivity`类的声明之后添加以下代码：
- en: '[PRE111]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Just after the call to `setContentView` in our `onCreate` method, add this
    piece of code:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`onCreate`方法中的`setContentView`调用后，添加以下代码：
- en: '[PRE112]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, near the start of our thread code, find the calls to make our buttons
    reappear. Comment them out like this:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的线程代码的开头附近，找到使我们的按钮重新出现的调用。像这样注释掉它们：
- en: '[PRE113]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next, directly after our code in the previous step, within each of the four
    `case` statements, we need to comment out the lines that call `setVisibility`
    and replace them with our wobble animation. The following code is slightly abbreviated
    but shows exactly where to comment and where to add the new lines:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在上一步中的代码之后，在每个四个`case`语句中，我们需要注释掉调用`setVisibility`的行，并用我们的摇摆动画替换它们。以下代码略有缩写，但清楚地显示了在哪里进行注释以及在哪里添加新行：
- en: '[PRE114]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Finally, in our `sequenceFinished` method, we can comment out all the `setVisibility`
    calls, just as we did in our thread, like this:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的`sequenceFinished`方法中，我们可以注释掉所有的`setVisibility`调用，就像我们在线程中所做的那样：
- en: '[PRE115]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: That was not too tough. We added the wobble animation to the `anim` folder,
    declared an animation object, and initialized it. Then we used it whenever it
    was required on the appropriate button.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太难。我们将摇晃动画添加到`anim`文件夹中，声明了一个动画对象，并对其进行了初始化。然后我们在适当的按钮上使用它。
- en: There are obviously loads of improvements we could make to this game, especially
    to its appearance. I'm sure you can think of more. And certainly, if this was
    to be your app, you were trying to make it big on the Play Store. That is exactly
    what you should do.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以对这个游戏进行大量改进，特别是在外观方面。我相信你可以想到更多。当然，如果这是您的应用程序，并且您试图在Play商店上大展拳脚，那么您应该这样做。
- en: Constantly improve all aspects and strive to be the best in your genre. If you
    feel the urge, then why not improve upon it?
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 不断改进所有方面，并努力成为您所在类型中的佼佼者。如果您有冲动，为什么不加以改进呢？
- en: Here are a few self-test questions that look at ways we could do more with some
    of the examples from this chapter.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些自测问题，看看我们可以如何在本章的一些示例中做更多。
- en: Self-test questions
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: Q1) Suppose that we want to have a quiz where the question could be to name
    the president as well as capital city. How can we do this with multidimensional
    arrays?
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: Q1）假设我们想要进行一项测验，其中问题可以是命名总统以及首都。我们如何使用多维数组来实现这一点？
- en: Q2) In our *Persistence example* section, we saved a continually updating string
    to a file so that it persisted after the app had been shut down and restarted.
    This is like asking the user to click on a Save button. Summoning all your knowledge
    of [Chapter 2](ch02.xhtml "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, can you think of a way to save the string without saving
    it in the button click but just when the user quits the app?
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: Q2）在我们的*持久性示例*部分，我们将一个不断更新的字符串保存到文件中，以便在应用程序关闭并重新启动后保留。这就像要求用户单击“保存”按钮一样。在您对[第2章](ch02.xhtml
    "第2章。开始使用Android")的所有知识中，您能想到一种在用户退出应用程序时保存字符串而不是在按钮单击时保存字符串的方法吗？
- en: Q3) Other than increasing the difficulty level, how could we increase the challenge
    of our memory game for our players?
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: Q3）除了增加难度级别，我们如何增加我们的记忆游戏对玩家的挑战？
- en: Q4) Using the plain Android UI with the dull grey buttons isn't very exciting.
    Take a look at the UI elements in the visual designer and try and work out how
    we could quickly improve the visual appearance of our UI.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: Q4）使用灰暗的按钮的普通Android UI并不令人兴奋。查看可视化设计师中的UI元素，并尝试找出我们如何可以快速改进UI外观的方法。
- en: Summary
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: That was a bit of a hefty chapter, but we learned lots of new techniques such
    as storing and manipulating with arrays, creating and using sound effects, and
    saving important data such as a high score, in our game. We also took a very brief
    look at the powerful but simple-to-use `Animation` class.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当庞大的章节，但我们学到了许多新的技术，比如存储和操作数组，创建和使用音效，以及保存重要数据，比如游戏中的高分。我们还简要地介绍了强大但简单易用的“Animation”类。
- en: In the next chapter, we will be taking a more theoretical approach, but we will
    have plenty of working samples too. We will finally be opening the black box of
    Java classes so that we can gain an understanding of what is going on when we
    declare and use objects of a class.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将采用更加理论化的方法，但也会有大量的工作样本。我们最终将打开Java类的黑匣子，以便我们能够理解当我们声明和使用类的对象时发生了什么。
