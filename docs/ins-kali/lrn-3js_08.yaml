- en: Chapter 8. Creating and Loading Advanced Meshes and Geometries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。创建和加载高级网格和几何
- en: 'In this chapter, we''ll look at a couple of different ways that you can create
    advanced and complex geometries and meshes. In [Chapter 5](ch05.html "Chapter 5. Learning
    to Work with Geometries"), *Learning to Work with Geometries*, and [Chapter 6](ch06.html
    "Chapter 6. Advanced Geometries and Binary Operations"), *Advanced Geometries
    and Binary Operations* ,we showed you how to create a few advanced geometries
    using the built-in objects from Three.js. In this chapter, we''ll use the following
    two approaches to create advanced geometries and meshes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将看一下创建高级和复杂几何和网格的几种不同方法。在[第5章](ch05.html "第5章。学习使用几何")，“学习使用几何”，和[第6章](ch06.html
    "第6章。高级几何和二进制操作")，“高级几何和二进制操作”中，我们向您展示了如何使用Three.js的内置对象创建一些高级几何。在这一章中，我们将使用以下两种方法来创建高级几何和网格：
- en: '**Grouping and merging**: The first approach we explain uses built-in functionality
    from Three.js to group and merge existing geometries. This creates new meshes
    and geometries from existing objects.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合和合并**：我们解释的第一种方法使用了Three.js的内置功能来组合和合并现有的几何。这样可以从现有对象创建新的网格和几何。'
- en: '**Loading from external**: In this section, we''ll explain how you can load
    meshes and geometries from external sources. For instance, we''ll show you how
    you can use Blender to export meshes in a format Three.js supports.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从外部加载**：在本节中，我们将解释如何从外部来源加载网格和几何。例如，我们将向您展示如何使用Blender以Three.js支持的格式导出网格。'
- en: We start with the *group and merge* approach. With this approach, we use the
    standard Three.js grouping and the `THREE.Geometry.merge()` function to create
    new objects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从*组合和合并*方法开始。使用这种方法，我们使用标准的Three.js分组和`THREE.Geometry.merge()`函数来创建新对象。
- en: Geometry grouping and merging
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何组合和合并
- en: 'In this section, we''ll look at two basic features of Three.js: grouping objects
    together and merging multiple meshes into a single mesh. We''ll start with grouping
    objects.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍Three.js的两个基本功能：将对象组合在一起和将多个网格合并成单个网格。我们将从将对象组合在一起开始。
- en: Grouping objects together
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将对象组合在一起
- en: In some of the previous chapters, you already saw this when working with multiple
    materials. When you create a mesh from a geometry using multiple materials, Three.js
    creates a group. Multiple copies of your geometry are added to this group, each
    with their own specific material. This group is returned, so it looks like a mesh
    that uses multiple materials. In truth, however, it is a group that contains a
    number of meshes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的一些章节中，当您使用多个材质时已经看到了这一点。当您使用多个材质从几何创建网格时，Three.js会创建一个组。您的几何的多个副本被添加到这个组中，每个副本都有自己特定的材质。这个组被返回，所以看起来像是使用多个材质的网格。然而，实际上，它是一个包含多个网格的组。
- en: 'Creating groups is very easy. Every mesh you create can contain child elements,
    which can be added using the add function. The effect of adding a child object
    to a group is that you can move, scale, rotate, and translate the parent object,
    and all the child objects will also be affected. Let''s look at an example (`01-grouping.html`).
    The following screenshot shows this example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建组非常容易。您创建的每个网格都可以包含子元素，可以使用add函数添加子元素。将子对象添加到组中的效果是，您可以移动、缩放、旋转和平移父对象，所有子对象也会受到影响。让我们看一个例子（`01-grouping.html`）。以下屏幕截图显示了这个例子：
- en: '![Grouping objects together](graphics/2215OS_08_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![将对象组合在一起](graphics/2215OS_08_01.jpg)'
- en: 'In this example, you can use the menu to move the sphere and the cube around.
    If you check the **rotate** option, you''ll see these two meshes rotating around
    their center. This isn''t anything new and is not very exciting. However, these
    two objects haven''t been added to the scene directly, but have been added as
    a group. The following code encapsulates this discussion:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可以使用菜单来移动球体和立方体。如果您勾选**旋转**选项，您会看到这两个网格围绕它们的中心旋转。这并不是什么新鲜事，也不是很令人兴奋。然而，这两个对象并没有直接添加到场景中，而是作为一个组添加的。以下代码概括了这个讨论：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code snippet, you can see that we create `THREE.Object3D`. This is the
    base class of `THREE.Mesh` and `THREE.Scene`, but by itself, it doesn't contain
    anything or cause anything to be rendered. Note that in the latest version of
    Three.js, a new object called `THREE.Group` was introduced to support grouping.
    This object is exactly the same as a `THREE.Object3D` object, and you can replace
    `new THREE.Object3D()` in the previous code with `new THREE.Group()` for the same
    effect. In this example, we use the `add` function to add the `sphere` and `cube`
    to this object, and then we add it to the `scene`. If you look at the example,
    you can still move the cube and sphere around and scale and rotate these two objects.
    You can also do these things on the group they are in. If you look at the group
    menu, you'll see position and scale options. You can use these to scale and move
    the entire group around. The scale and position of the objects inside this group
    are relative to the scale and position of the group itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，您可以看到我们创建了`THREE.Object3D`。这是`THREE.Mesh`和`THREE.Scene`的基类，但本身并不包含任何内容或导致任何内容被渲染。请注意，在最新版本的Three.js中，引入了一个名为`THREE.Group`的新对象来支持分组。这个对象与`THREE.Object3D`对象完全相同，您可以用`new
    THREE.Group()`替换前面代码中的`new THREE.Object3D()`以获得相同的效果。在这个例子中，我们使用`add`函数将`sphere`和`cube`添加到这个对象，然后将它添加到`scene`中。如果您查看这个例子，您仍然可以移动立方体和球体，以及缩放和旋转这两个对象。您也可以在它们所在的组上进行这些操作。如果您查看组菜单，您会看到位置和缩放选项。您可以使用这些选项来缩放和移动整个组。这个组内部对象的缩放和位置是相对于组本身的缩放和位置的。
- en: 'Scale and position are very straightforward. One thing to keep in mind, though,
    is that when you rotate a group, it doesn''t rotate the objects inside it separately;
    it rotates the entire group around its own center (in our example, you rotate
    the entire group around the center of the `group` object). In this example, we
    placed an arrow using the `THREE.ArrowHelper` object at the center of the group
    to indicate the rotation point:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放和定位非常简单。但需要记住的一点是，当您旋转一个组时，它不会单独旋转其中的对象；它会围绕自己的中心旋转（在我们的示例中，您会围绕`group`对象的中心旋转整个组）。在这个示例中，我们使用`THREE.ArrowHelper`对象在组的中心放置了一个箭头，以指示旋转点：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you check both the **grouping** and **rotate** checkboxes, the group will
    rotate. You''ll see the sphere and cube rotating around the center of the group
    (indicated by the arrow), as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您同时选中**分组**和**旋转**复选框，组将会旋转。您会看到球体和立方体围绕组的中心旋转（由箭头指示），如下所示：
- en: '![Grouping objects together](graphics/2215OS_08_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![将对象分组](graphics/2215OS_08_02.jpg)'
- en: When using a group, you can still refer to, modify, and position the individual
    geometries. The only thing you need to remember is that all positions, rotations,
    and translations are done relative to the parent object. In the next section,
    we'll look at merging, where you'll combine multiple separate geometries and end
    up with a single `THREE.Geometry` object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用组时，您仍然可以引用、修改和定位单个几何体。您需要记住的是，所有位置、旋转和平移都是相对于父对象进行的。在下一节中，我们将看看合并，您将合并多个单独的几何体，并最终得到一个单个的`THREE.Geometry`对象。
- en: Merging multiple meshes into a single mesh
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将多个网格合并成单个网格
- en: 'In most cases, using groups allows you to easily manipulate and manage a large
    number of meshes. When you''re dealing with a very large number of objects, however,
    performance will become an issue. With groups, you''re still working with individual
    objects that each need to be handled and rendered separately. With `THREE.Geometry.merge()`,
    you can merge geometries together and create a combined one. In the following
    example, you can see how this works and the effect it has on performance. If you
    open the `02-merging.html` example, you see a scene with a set of randomly distributed
    semitransparent cubes. With the slider in the menu, you can set the number of
    cubes you want in the scene and redraw the scene by clicking on the **redraw**
    button. Depending on the hardware you''re running on, you''ll see a performance
    degradation as the number of cubes increases. In our case, as you can see in the
    following screenshot, this happens at around 4,000 objects, where the refresh
    rate drops to around 40 fps instead of the normal 60 fps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，使用组可以让您轻松操作和管理大量网格。然而，当您处理大量对象时，性能将成为一个问题。使用组时，您仍然在处理需要单独处理和渲染的单个对象。使用`THREE.Geometry.merge()`，您可以合并几何体并创建一个组合的几何体。在下面的示例中，您可以看到这是如何工作的，以及它对性能的影响。如果您打开`02-merging.html`示例，您会看到一个场景，其中有一组随机分布的半透明立方体。在菜单中使用滑块，您可以设置场景中立方体的数量，并通过单击**重绘**按钮重新绘制场景。根据您运行的硬件，随着立方体数量的增加，您会看到性能下降。在我们的案例中，如下截图所示，在大约4,000个对象时，刷新率会从正常的60
    fps降至约40 fps：
- en: '![Merging multiple meshes into a single mesh](graphics/2215OS_08_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![将多个网格合并成单个网格](graphics/2215OS_08_03.jpg)'
- en: 'As you can see, there is a certain limit to the number of meshes you can add
    to the scene. Normally, though, you probably wouldn''t need that many meshes,
    but when creating specific games (for example, something like *Minecraft*) or
    advanced visualizations, you might need to manage a large number of individual
    meshes. With `THREE.Geometry.merge()`, you can solve this problem. Before we look
    at the code, let''s run this same example, but this time, with the **combine**
    box checked. With this option flagged, we merge all the cubes into a single `THREE.Geometry`
    and add that one instead, as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以向场景中添加的网格数量存在一定限制。不过，通常情况下，您可能不需要那么多网格，但是在创建特定游戏（例如像*Minecraft*这样的游戏）或高级可视化时，您可能需要管理大量单独的网格。使用`THREE.Geometry.merge()`，您可以解决这个问题。在查看代码之前，让我们运行相同的示例，但这次选中**合并**框。通过标记此选项，我们将所有立方体合并为单个`THREE.Geometry`，并添加该对象，如下截图所示：
- en: '![Merging multiple meshes into a single mesh](graphics/2215OS_08_04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![将多个网格合并成单个网格](graphics/2215OS_08_04.jpg)'
- en: 'As you can see, we can easily render 20,000 cubes without any drop in performance.
    To do this, we use the following couple of lines of code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以轻松渲染20,000个立方体而不会出现性能下降。为此，我们使用以下几行代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code snippet, the `addCube()` function returns `THREE.Mesh`. In older
    versions of Three.js, we could use the `THREE.GeometryUtils.merge` function to
    also merge `THREE.Mesh` objects into `THREE.Geometry` objects. With the latest
    version, this functionality has been deprecated in favor of the `THREE.Geometry.merge`
    function. To make sure the merged-in `THREE.Geometry` object is positioned and
    rotated correctly, we not only provide `THREE.Geometry` to the `merge` function,
    but also its transformation matrix. When we add this matrix to the `merge` function,
    the cube we merge in will be positioned correctly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，`addCube()`函数返回`THREE.Mesh`。在较早版本的Three.js中，我们可以使用`THREE.GeometryUtils.merge`函数将`THREE.Mesh`对象合并到`THREE.Geometry`对象中。但在最新版本中，这个功能已经被弃用，取而代之的是`THREE.Geometry.merge`函数。为了确保合并的`THREE.Geometry`对象被正确定位和旋转，我们不仅向`merge`函数提供`THREE.Geometry`，还提供其变换矩阵。当我们将这个矩阵添加到`merge`函数时，我们合并的立方体将被正确定位。
- en: We do this 20,000 times and are left with a single geometry that we add to the
    scene. If you look at the code, you can probably see a couple of drawbacks of
    this approach. Since you're left with a single geometry, you can't apply a material
    to each individual cube. This, however, can be somewhat solved using `THREE.MeshFaceMaterial`.
    The biggest drawback, however, is that you lose control over the individual cubes.
    If you want to move, rotate, or scale a single cube, you can't (unless you search
    for the correct faces and vertices and position them individually).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做了20,000次，最后得到一个单一的几何图形，我们将其添加到场景中。如果您查看代码，您可能会看到这种方法的一些缺点。由于您得到了一个单一的几何图形，您无法为每个单独的立方体应用材质。然而，这可以通过使用`THREE.MeshFaceMaterial`来解决。然而，最大的缺点是您失去了对单个立方体的控制。如果您想要移动、旋转或缩放单个立方体，您无法做到（除非您搜索正确的面和顶点并单独定位它们）。
- en: With the grouping and merging approach, you can create large and complex geometries
    using the basic geometries provided by Three.js. If you want to create more advanced
    geometries, then using the programmatic approach provided by Three.js isn't always
    the best and easiest option. Three.js, luckily, offers a couple of other options
    to create geometries. In the next section, we'll look at how you can load geometries
    and meshes from external resources.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分组和合并方法，您可以使用Three.js提供的基本几何图形创建大型和复杂的几何图形。如果您想创建更高级的几何图形，那么使用Three.js提供的编程方法并不总是最佳和最简单的选择。幸运的是，Three.js还提供了其他几种选项来创建几何图形。在下一节中，我们将看看如何从外部资源加载几何图形和网格。
- en: Loading geometries from external resources
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从外部资源加载几何图形
- en: 'Three.js can read a number of 3D file formats and import geometries and meshes
    defined in those files. The following table shows the file formats that are supported
    by Three.js:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js可以读取多种3D文件格式，并导入这些文件中定义的几何图形和网格。以下表格显示了Three.js支持的文件格式：
- en: '| Format | Description |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 格式 | 描述 |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| JSON | Three.js has its own JSON format you can use to declaratively define
    a geometry or a scene. Even though this isn''t an official format, it''s very
    easy to use and comes in very handy when you want to reuse complex geometries
    or scenes. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| JSON | Three.js有自己的JSON格式，您可以用它来声明性地定义几何图形或场景。尽管这不是官方格式，但在想要重用复杂几何图形或场景时，它非常易于使用并非常方便。
    |'
- en: '| OBJ or MTL | OBJ is a simple 3D format first developed by **Wavefront Technologies**.
    It''s one of the most widely adopted 3D file formats and is used to define the
    geometry of an object. MTL is a companion format to OBJ. In an MTL file, the material
    of the objects in an OBJ file is specified.Three.js also has a custom OBJ exporter,
    called OBJExporter.js, should you want to export your models to OBJ from Three.js.
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| OBJ或MTL | OBJ是由**Wavefront Technologies**首次开发的简单3D格式。它是最广泛采用的3D文件格式之一，用于定义对象的几何形状。MTL是OBJ的伴随格式。在MTL文件中，指定了OBJ文件中对象的材质。Three.js还有一个名为OBJExporter.js的自定义OBJ导出器，如果您想要从Three.js导出模型到OBJ，可以使用它。
    |'
- en: '| Collada | Collada is a format for defining *digital assets* in an XML-based
    format. This is also a widely used format that is supported by pretty much all
    3D applications and rendering engines. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| Collada | Collada是一种用于以基于XML的格式定义*数字资产*的格式。这也是一种被几乎所有3D应用程序和渲染引擎支持的广泛使用的格式。
    |'
- en: '| STL | **STL** stands for **STereoLithography** and is widely used for rapid
    prototyping. For instance, models for 3D printers are often defined as STL files.Three.js
    also has a custom STL exporter, called STLExporter.js, should you want to export
    your models to STL from Three.js. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| STL | **STL**代表**STereoLithography**，广泛用于快速原型制作。例如，3D打印机的模型通常定义为STL文件。Three.js还有一个名为STLExporter.js的自定义STL导出器，如果您想要从Three.js导出模型到STL，可以使用它。
    |'
- en: '| CTM | CTM is a file format created by **openCTM**. It''s used as a format
    for storing 3D triangle-based meshes in a compact format. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| CTM | CTM是由**openCTM**创建的文件格式。它用作以紧凑格式存储3D三角形网格的格式。'
- en: '| VTK | VTK is the file format defined by **Visualization Toolkit** and is
    used to specify vertices and faces. There are two formats available: a binary
    one and a text-based ASCII one. Three.js only supports the ASCII-based format.
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| VTK | VTK是由**可视化工具包**定义的文件格式，用于指定顶点和面。有两种可用格式：二进制格式和基于文本的ASCII格式。Three.js仅支持基于ASCII的格式。
    |'
- en: '| AWD | AWD is a binary format for 3D scenes and is most often used with the
    [http://away3d.com/](http://away3d.com/) engine. Note that this loader doesn''t
    support compressed AWD files. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| AWD | AWD是用于3D场景的二进制格式，最常与[http://away3d.com/](http://away3d.com/)引擎一起使用。请注意，此加载器不支持压缩的AWD文件。
    |'
- en: '| Assimp | Open asset import library (also called **Assimp**) is a standard
    way to import various 3D model formats. With this loader, you can import models
    from a large range of 3D formats that have been converted using **assimp2json**,
    details of which are available at [https://github.com/acgessler/assimp2json](https://github.com/acgessler/assimp2json).
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Assimp | 开放资产导入库（也称为**Assimp**）是导入各种3D模型格式的标准方式。使用此加载器，您可以导入使用**assimp2json**转换的大量3D格式的模型，有关详细信息，请访问[https://github.com/acgessler/assimp2json](https://github.com/acgessler/assimp2json)。
    |'
- en: '| VRML | **VRML** stands for **Virtual Reality Modeling Language**. This is
    a text-based format that allows you to specify 3D objects and worlds. It has been
    superseded by the X3D file format. Three.js doesn''t support loading X3D models,
    but these models can be easily converted to other formats. More information can
    be found at [http://www.x3dom.org/?page_id=532#](http://www.x3dom.org/?page_id=532#).
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| VRML | **VRML**代表**虚拟现实建模语言**。这是一种基于文本的格式，允许您指定3D对象和世界。它已被X3D文件格式取代。Three.js不支持加载X3D模型，但这些模型可以很容易地转换为其他格式。更多信息可以在[http://www.x3dom.org/?page_id=532#](http://www.x3dom.org/?page_id=532#)找到。
    |'
- en: '| Babylon | Babylon is a 3D JavaScript game library. It stores models in its
    own internal format. More information about this can be found at [http://www.babylonjs.com/](http://www.babylonjs.com/).
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| Babylon | Babylon是一个3D JavaScript游戏库。它以自己的内部格式存储模型。有关此内容的更多信息，请访问[http://www.babylonjs.com/](http://www.babylonjs.com/)。
    |'
- en: '| PDB | This is a very specialized format, created by **Protein Data Bank**,
    that is used to specify what proteins look like. Three.js can load and visualize
    proteins specified in this format. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| PDB | 这是一种非常专业的格式，由**蛋白质数据银行**创建，用于指定蛋白质的外观。Three.js可以加载和可视化以这种格式指定的蛋白质。'
- en: '| PLY | This format is called the **Polygon** file format. This is most often
    used to store information from 3D scanners. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| PLY | 这种格式被称为**多边形**文件格式。这通常用于存储来自3D扫描仪的信息。'
- en: In the next chapter, we'll revisit some of these formats (and look at two additional
    ones, MD2 and glTF) when we look at animations. For now, we start with the first
    one on the list, the internal format of Three.js.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，当我们讨论动画时，我们将重新访问其中一些格式（并查看另外两种格式，MD2和glTF）。现在，我们从Three.js的内部格式开始。
- en: Saving and loading in Three.js JSON format
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以Three.js JSON格式保存和加载
- en: You can use Three.js' JSON format for two different scenarios in Three.js. You
    can use it to save and load a single `THREE.Mesh`, or you can use it to save and
    load a complete scene.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Three.js中的两种不同场景中使用Three.js的JSON格式。你可以用它来保存和加载单个`THREE.Mesh`，或者你可以用它来保存和加载完整的场景。
- en: Saving and loading THREE.Mesh
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存和加载THREE.Mesh
- en: To demonstrate saving and loading, we created a simple example based on `THREE.TorusKnotGeometry`.
    With this example, you can create a torus knot, just like we did in [Chapter 5](ch05.html
    "Chapter 5. Learning to Work with Geometries"), *Learning to Work with Geometries*,
    and using the **save** button from the **Save & Load** menu, you can save the
    current geometry. For this example, we save using the HTML5 local storage API.
    This API allows us to easily store persistent information in the client's browser
    and retrieve it at a later time (even after the browser has been shut down and
    restarted).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示保存和加载，我们创建了一个基于`THREE.TorusKnotGeometry`的简单示例。通过这个示例，你可以创建一个环结，就像我们在[第5章](ch05.html
    "第5章。学习使用几何图形") *学习使用几何图形*中所做的那样，并使用**保存**按钮从**保存和加载**菜单中保存当前几何图形。对于这个例子，我们使用HTML5本地存储API进行保存。这个API允许我们在客户端的浏览器中轻松存储持久信息，并在以后的时间检索它（即使浏览器已关闭并重新启动）。
- en: 'We will look at the `03-load-save-json-object.html` example. The following
    screenshot shows this example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看`03-load-save-json-object.html`示例。以下截图显示了这个例子：
- en: '![Saving and loading THREE.Mesh](graphics/2215OS_08_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![保存和加载THREE.Mesh](graphics/2215OS_08_05.jpg)'
- en: 'Exporting in JSON from Three.js is very easy and doesn''t require you to include
    any additional libraries. The only thing you need to do to export `THREE.Mesh`
    as JSON is the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从Three.js中以JSON格式导出非常容易，不需要你包含任何额外的库。要将`THREE.Mesh`导出为JSON，你需要做的唯一的事情是：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before saving it, we first convert the result from the `toJSON` function, a
    JavaScript object, to a string using the `JSON.stringify` function. This results
    in a JSON string that looks like this (most of the vertices and faces are left
    out):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存之前，我们首先将`toJSON`函数的结果，一个JavaScript对象，使用`JSON.stringify`函数转换为字符串。这将产生一个看起来像这样的JSON字符串（大部分顶点和面都被省略了）：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, Three.js saves all the information about `THREE.Mesh`. To save
    this information using the HTML5 local storage API, all we have to do is call
    the `localStorage.setItem` function. The first argument is the key value (`json`)
    that we can later use to retrieve the information we passed in as the second argument.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Three.js保存了关于`THREE.Mesh`的所有信息。要使用HTML5本地存储API保存这些信息，我们只需要调用`localStorage.setItem`函数。第一个参数是键值（`json`），我们稍后可以使用它来检索我们作为第二个参数传递的信息。
- en: 'Loading `THREE.Mesh` back into Three.js also requires just a couple of lines
    of code, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从本地存储中加载`THREE.Mesh`回到Three.js也只需要几行代码，如下所示：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we first get the JSON from local storage using the name we saved it with
    (`json` in this case). For this, we use the `localStorage.getItem` function provided
    by the HTML5 local storage API. Next, we need to convert the string back to a
    JavaScript object (`JSON.parse`) and convert the JSON object back to `THREE.Mesh`.
    Three.js provides a helper object called `THREE.ObjectLoader`, which you can use
    to convert JSON to `THREE.Mesh`. In this example, we used the `parse` method on
    the loader to directly parse a JSON string. The loader also provides a `load`
    function, where you can pass in the URL to a file containing the JSON definition.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用我们保存的名称（在本例中为`json`）从本地存储中获取JSON。为此，我们使用HTML5本地存储API提供的`localStorage.getItem`函数。接下来，我们需要将字符串转换回JavaScript对象（`JSON.parse`），并将JSON对象转换回`THREE.Mesh`。Three.js提供了一个名为`THREE.ObjectLoader`的辅助对象，你可以使用它将JSON转换为`THREE.Mesh`。在这个例子中，我们使用加载器上的`parse`方法直接解析JSON字符串。加载器还提供了一个`load`函数，你可以传入包含JSON定义的文件的URL。
- en: As you can see here, we only saved `THREE.Mesh`. We lose everything else. If
    you want to save the complete scene, including the lights and the cameras, you
    can use `THREE.SceneExporter`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，我们只保存了`THREE.Mesh`。我们失去了其他一切。如果你想保存完整的场景，包括灯光和相机，你可以使用`THREE.SceneExporter`。
- en: Saving and loading a scene
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存和加载场景
- en: 'If you want to save a complete scene, you use the same approach as we saw in
    the previous section for the geometry. `04-load-save-json-scene.html` is a working
    example showing this. The following screenshot shows this example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想保存完整的场景，你可以使用与我们在前一节中看到的相同方法来保存几何图形。`04-load-save-json-scene.html`是一个展示这一点的工作示例。以下截图显示了这个例子：
- en: '![Saving and loading a scene](graphics/2215OS_08_06.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![保存和加载场景](graphics/2215OS_08_06.jpg)'
- en: 'In this example, you''ve got three options: **exportScene**, **clearScene**,
    and **importScene**. With **exportScene**, the current state of the scene will
    be saved in the browser''s local storage. To test the import functionality, you
    can remove the scene by clicking on the **clearScene** button and load it from
    local storage with the **importScene** button. The code to do all this is very
    simple, but before you can use it, you have to import the required exporter and
    loader from the Three.js distribution (look at the `examples/js/exporters` and
    `examples/js/loaders` directories):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您有三个选项：**exportScene**，**clearScene**和**importScene**。使用**exportScene**，场景的当前状态将保存在浏览器的本地存储中。要测试导入功能，您可以通过单击**clearScene**按钮来删除场景，并使用**importScene**按钮从本地存储加载它。执行所有这些操作的代码非常简单，但在使用之前，您必须从Three.js分发中导入所需的导出器和加载器（查看`examples/js/exporters`和`examples/js/loaders`目录）：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With these JavaScript imports included in the page, you can export a scene
    with the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面中包含这些JavaScript导入后，您可以使用以下代码导出一个场景：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This approach is exactly the same as we used in the previous section—only this
    time, we use `THREE.SceneExporter()` to export a complete scene. The resulting
    JSON looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与我们在上一节中使用的方法完全相同，只是这次我们使用`THREE.SceneExporter()`来导出完整的场景。生成的JSON如下：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you load this JSON again, Three.js just recreates the objects exactly
    as they were exported. Loading a scene is done like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当您再次加载此JSON时，Three.js会按原样重新创建对象。加载场景的方法如下：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The last argument passed into the loader (`'.'`) defines the relative URL. For
    instance, if you've got materials that use textures (for example, external images),
    those will be retrieved using this relative URL. In this example, where we don't
    use textures, we just pass in the current directory. Just as with `THREE.ObjectLoader`,
    you can also load a JSON file from a URL using the `load` function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给加载程序的最后一个参数（`'.'`）定义了相对URL。例如，如果您有使用纹理的材质（例如，外部图像），那么这些材质将使用此相对URL进行检索。在这个例子中，我们不使用纹理，所以只需传入当前目录。与`THREE.ObjectLoader`一样，您也可以使用`load`函数从URL加载JSON文件。
- en: There are many different 3D programs you can use to create complex meshes. A
    popular open source one is Blender ([www.blender.org](http://www.blender.org)).
    Three.js has an exporter for Blender (and for Maya and 3D Studio Max) that directly
    exports to the JSON format of Three.js. In the next section, we'll walk you through
    getting Blender configured to use this exporter and show you how you can export
    a complex model in Blender and show it in Three.js.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的3D程序可以用来创建复杂的网格。一个流行的开源程序是Blender（[www.blender.org](http://www.blender.org)）。Three.js有一个针对Blender（以及Maya和3D
    Studio Max）的导出器，直接导出到Three.js的JSON格式。在接下来的部分中，我们将指导您配置Blender以使用此导出器，并向您展示如何在Blender中导出复杂模型并在Three.js中显示它。
- en: Working with Blender
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Blender
- en: 'Before we get started with the configuration, we''ll show the result that we''ll
    be aiming for. In the following screenshot, you can see a simple Blender model
    that we exported with the Three.js plugin and imported in Three.js with `THREE.JSONLoader`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始配置之前，我们将展示我们将要实现的结果。在下面的截图中，您可以看到一个简单的Blender模型，我们使用Three.js插件导出，并在Three.js中使用`THREE.JSONLoader`导入：
- en: '![Working with Blender](graphics/2215OS_08_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用Blender](graphics/2215OS_08_07.jpg)'
- en: Installing the Three.js exporter in Blender
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Blender中安装Three.js导出器
- en: 'To get Blender to export Three.js models, we first need to add the Three.js
    exporter to Blender. The following steps are for Mac OS X but are pretty much
    the same on Windows and Linux. You can download Blender from [www.blender.org](http://www.blender.org)
    and follow the platform-specific installation instructions. After installation,
    you can add the Three.js plugin. First, locate the `addons` directory from your
    Blender installation using a terminal window:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要让Blender导出Three.js模型，我们首先需要将Three.js导出器添加到Blender中。以下步骤适用于Mac OS X，但在Windows和Linux上基本相同。您可以从[www.blender.org](http://www.blender.org)下载Blender，并按照特定于平台的安装说明进行操作。安装后，您可以添加Three.js插件。首先，使用终端窗口找到Blender安装的`addons`目录：
- en: '![Installing the Three.js exporter in Blender](graphics/2215OS_08_08.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![在Blender中安装Three.js导出器](graphics/2215OS_08_08.jpg)'
- en: 'On my Mac, it''s located here: `./blender.app/Contents/MacOS/2.70/scripts/addons`.
    For Windows, this directory can be found at the following location: `C:\Users\USERNAME\AppData\Roaming\Blender
    Foundation\Blender\2.7X\scripts\addons`. And for Linux, you can find this directory
    here: `/home/USERNAME/.config/blender/2.7X/scripts/addons`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的Mac上，它位于这里：`./blender.app/Contents/MacOS/2.70/scripts/addons`。对于Windows，该目录可以在以下位置找到：`C:\Users\USERNAME\AppData\Roaming\Blender
    Foundation\Blender\2.7X\scripts\addons`。对于Linux，您可以在此处找到此目录：`/home/USERNAME/.config/blender/2.7X/scripts/addons`。
- en: 'Next, you need to get the Three.js distribution and unpack it locally. In this
    distribution, you can find the following folder: `utils/exporters/blender/2.65/scripts/addons/`.
    In this directory, there is a single subdirectory with the name `io_mesh_threejs`.
    Copy this directory to the `addons` folder of your Blender installation.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要获取Three.js分发并在本地解压缩。在此分发中，您可以找到以下文件夹：`utils/exporters/blender/2.65/scripts/addons/`。在此目录中，有一个名为`io_mesh_threejs`的单个子目录。将此目录复制到您的Blender安装的`addons`文件夹中。
- en: 'Now, all we need to do is start Blender and enable the exporter. In Blender,
    open **Blender User Preferences** (**File** | **User Preferences**). In the window
    that opens, select the **Addons** tab, and in the search box, type `three`. This
    will show the following screen:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要启动Blender并启用导出器。在Blender中，打开**Blender用户首选项**（**文件** | **用户首选项**）。在打开的窗口中，选择**插件**选项卡，并在搜索框中输入`three`。这将显示以下屏幕：
- en: '![Installing the Three.js exporter in Blender](graphics/2215OS_08_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![在Blender中安装Three.js导出器](graphics/2215OS_08_09.jpg)'
- en: 'At this point, the Three.js plugin is found, but it is still disabled. Check
    the small checkbox to the right, and the Three.js exporter will be enabled. As
    a final check to see whether everything is working correctly, open the **File**
    | **Export** menu option, and you''ll see Three.js listed as an export option.
    This is shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，找到了Three.js插件，但它仍然被禁用。勾选右侧的小复选框，Three.js导出器将被启用。最后，为了检查一切是否正常工作，打开**文件**
    | **导出**菜单选项，您将看到Three.js列为导出选项。如下截图所示：
- en: '![Installing the Three.js exporter in Blender](graphics/2215OS_08_10.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![在Blender中安装Three.js导出器](graphics/2215OS_08_10.jpg)'
- en: With the plugin installed, we can load our first model.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了插件后，我们可以加载我们的第一个模型。
- en: Loading and exporting a model from Blender
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Blender加载和导出模型
- en: As an example, we've added a simple Blender model named `misc_chair01.blend`
    in the `assets/models` folder, which you can find in the sources for this book.
    In this section, we'll load this model and show the minimal steps it takes to
    export this model to Three.js.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们在`assets/models`文件夹中添加了一个名为`misc_chair01.blend`的简单Blender模型，您可以在本书的源文件中找到。在本节中，我们将加载此模型，并展示将此模型导出到Three.js所需的最小步骤。
- en: 'First, we need to load this model in Blender. Use **File** | **Open** and navigate
    to the folder containing the `misc_chair01.blend` file. Select this file and click
    on **Open**. This will show you a screen that looks somewhat like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在Blender中加载此模型。使用**文件** | **打开**并导航到包含`misc_chair01.blend`文件的文件夹。选择此文件，然后单击**打开**。这将显示一个看起来有点像这样的屏幕：
- en: '![Loading and exporting a model from Blender](graphics/2215OS_08_11.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![从Blender加载和导出模型](graphics/2215OS_08_11.jpg)'
- en: 'Exporting this model to the Three.js JSON format is pretty straightforward.
    From the **File** menu, open **Export** | **Three.js**, type in the name of the
    export file, and select **Export Three.js**. This will create a JSON file in a
    format Three.js understands. A part of the contents of this file is shown next:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将此模型导出到Three.js JSON格式非常简单。从**文件**菜单中，打开**导出** | **Three.js**，输入导出文件的名称，然后选择**导出Three.js**。这将创建一个Three.js理解的JSON文件。此文件的部分内容如下所示：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, we aren''t completely done. In the previous screenshot, you can see
    that the chair contains a wooden texture. If you look through the JSON export,
    you can see that the export for the chair also specifies a material, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有完全完成。在前面的截图中，您可以看到椅子包含木纹理。如果您查看JSON导出，您会看到椅子的导出也指定了一个材质，如下所示：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This material specifies a texture, `misc_chair01_col.jpg`, for the `mapDiffuse`
    property. So, besides exporting the model, we also need to make sure the texture
    file is also available to Three.js. Luckily, we can save this texture directly
    from Blender.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此材质为`mapDiffuse`属性指定了一个名为`misc_chair01_col.jpg`的纹理。因此，除了导出模型，我们还需要确保Three.js也可以使用纹理文件。幸运的是，我们可以直接从Blender保存这个纹理。
- en: 'In Blender, open the **UV/Image Editor** view. You can select this view from
    the drop-down menu on the left-hand side of the **File** menu option. This will
    replace the top menu with the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blender中，打开**UV/Image Editor**视图。您可以从**文件**菜单选项的左侧下拉菜单中选择此视图。这将用以下内容替换顶部菜单：
- en: '![Loading and exporting a model from Blender](graphics/2215OS_08_12.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![从Blender加载和导出模型](graphics/2215OS_08_12.jpg)'
- en: Make sure the texture you want to export is selected, `misc_chair_01_col.jpg`
    in our case (you can select a different one using the small image icon). Next,
    click on the **Image** menu and use the **Save as Image** menu option to save
    the image. Save it in the same folder where you saved the model using the name
    specified in the JSON export file. At this point, we're ready to load the model
    into Three.js.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 确保选择要导出的纹理，我们的情况下是`misc_chair_01_col.jpg`（您可以使用小图标选择不同的纹理）。接下来，单击**图像**菜单，使用**另存为图像**菜单选项保存图像。将其保存在与模型相同的文件夹中，使用JSON导出文件中指定的名称。此时，我们已经准备好将模型加载到Three.js中。
- en: 'The code to load this into Three.js at this point looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此时将加载到Three.js中的代码如下：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ve already seen `JSONLoader` before, but this time, we use the `load` function
    instead of the `parse` function. In this function, we specify the URL we want
    to load (points to the exported JSON file), a callback that is called when the
    object is loaded, and the location, `../assets/models/`, where the texture can
    be found (relative to the page). This callback takes two parameters: `geometry`
    and `mat`. The `geometry` parameter contains the model, and the `mat` parameter
    contains an array of material objects. We know that there is only one material,
    so when we create `THREE.Mesh`, we directly reference that material. If you open
    the `05-blender-from-json.html` example, you can see the chair we just exported
    from Blender.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经见过`JSONLoader`，但这次我们使用`load`函数而不是`parse`函数。在此函数中，我们指定要加载的URL（指向导出的JSON文件），一个在对象加载时调用的回调，以及纹理所在的位置`../assets/models/`（相对于页面）。此回调接受两个参数：`geometry`和`mat`。`geometry`参数包含模型，`mat`参数包含材质对象的数组。我们知道只有一个材质，因此当我们创建`THREE.Mesh`时，我们直接引用该材质。如果您打开`05-blender-from-json.html`示例，您可以看到我们刚刚从Blender导出的椅子。
- en: Using the Three.js exporter isn't the only way of loading models from Blender
    into Three.js. Three.js understands a number of 3D file formats, and Blender can
    export in a couple of those formats. Using the Three.js format, however, is very
    easy, and if things go wrong, they are often quickly found.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '使用Three.js导出器并不是从Blender加载模型到Three.js的唯一方法。Three.js理解许多3D文件格式，而Blender可以导出其中的一些格式。然而，使用Three.js格式非常简单，如果出现问题，通常可以很快找到。 '
- en: In the following section, we'll look at a couple of the formats Three.js supports
    and also show a Blender-based example for the OBJ and MTL file formats.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下Three.js支持的一些格式，并展示一个基于Blender的OBJ和MTL文件格式的示例。
- en: Importing from 3D file formats
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从3D文件格式导入
- en: At the beginning of this chapter, we listed a number of formats that are supported
    by Three.js. In this section, we'll quickly walk through a couple of examples
    for those formats. Note that for all these formats, an additional JavaScript file
    needs to be included. You can find all these files in the Three.js distribution
    in the `examples/js/loaders` directory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们列出了Three.js支持的一些格式。在本节中，我们将快速浏览一些这些格式的例子。请注意，对于所有这些格式，都需要包含一个额外的JavaScript文件。您可以在Three.js分发的`examples/js/loaders`目录中找到所有这些文件。
- en: The OBJ and MTL formats
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OBJ和MTL格式
- en: 'OBJ and MTL are companion formats and often used together. The OBJ file defines
    the geometry, and the MTL file defines the materials that are used. Both OBJ and
    MTL are text-based formats. A part of an OBJ file looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: OBJ和MTL是配套格式，经常一起使用。OBJ文件定义了几何图形，而MTL文件定义了所使用的材质。OBJ和MTL都是基于文本的格式。OBJ文件的一部分看起来像这样：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The MTL file defines materials like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: MTL文件定义了材质，如下所示：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The OBJ and MTL formats by Three.js are understood well and are also supported
    by Blender. So, as an alternative, you could choose to export models from Blender
    in the OBJ/MTL format instead of the Three.js JSON format. Three.js has two different
    loaders you can use. If you only want to load the geometry, you can use `OBJLoader`.
    We used this loader for our example (`06-load-obj.html`). The following screenshot
    shows this example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js对OBJ和MTL格式有很好的理解，并且也受到Blender的支持。因此，作为一种替代方案，您可以选择以OBJ/MTL格式而不是Three.js
    JSON格式从Blender中导出模型。Three.js有两种不同的加载器可供使用。如果您只想加载几何图形，可以使用`OBJLoader`。我们在我们的例子（`06-load-obj.html`）中使用了这个加载器。以下截图显示了这个例子：
- en: '![The OBJ and MTL formats](graphics/2215OS_08_13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![OBJ和MTL格式](graphics/2215OS_08_13.jpg)'
- en: 'To import this in Three.js, you have to add the OBJLoader JavaScript file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Three.js中导入这个模型，您必须添加OBJLoader JavaScript文件：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Import the model like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样导入模型：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this code, we use `OBJLoader` to load the model from a URL. Once the model
    is loaded, the callback we provide is called, and we add the model to the scene.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用`OBJLoader`从URL加载模型。一旦模型加载完成，我们提供的回调就会被调用，并且我们将模型添加到场景中。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Usually, a good first step is to print out the response from the callback to
    the console to understand how the loaded object is built up. Often with these
    loaders, the geometry or mesh is returned as a hierarchy of groups. Understanding
    this makes it much easier to place and apply the correct material and take any
    other additional steps. Also, look at the position of a couple of vertices to
    determine whether you need to scale the model up or down and where to position
    the camera. In this example, we've also made the calls to `computeFaceNormals`
    and `computeVertexNormals`. This is required to ensure that the material used
    (`THREE.MeshLambertMaterial`) is rendered correctly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个很好的第一步是将回调的响应打印到控制台上，以了解加载的对象是如何构建的。通常情况下，使用这些加载器，几何图形或网格会作为一组组的层次结构返回。了解这一点会使得更容易放置和应用正确的材质，并采取任何其他额外的步骤。此外，查看一些顶点的位置来确定是否需要缩放模型的大小以及摄像机的位置。在这个例子中，我们还调用了`computeFaceNormals`和`computeVertexNormals`。这是为了确保所使用的材质（`THREE.MeshLambertMaterial`）能够正确渲染。
- en: 'The next example (`07-load-obj-mtl.html`) uses `OBJMTLLoader` to load a model
    and directly assign a material. The following screenshot shows this example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子（`07-load-obj-mtl.html`）使用`OBJMTLLoader`加载模型并直接分配材质。以下截图显示了这个例子：
- en: '![The OBJ and MTL formats](graphics/2215OS_08_14.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![OBJ和MTL格式](graphics/2215OS_08_14.jpg)'
- en: 'First, we need to add the correct loaders to the page:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将正确的加载器添加到页面上：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can load the model from the OBJ and MTL files like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样从OBJ和MTL文件加载模型：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first thing to mention before we look at the code is that if you receive
    an OBJ file, an MTL file, and the required texture files, you''ll have to check
    how the MTL file references the textures. These should be referenced relative
    to the MTL file and not as an absolute path. The code itself isn''t that different
    from the one we saw for `THREE.ObjLoader`. We specify the location of the OBJ
    file, the location of the MTL file, and the function to call when the model is
    loaded. The model we''ve used as an example in this case is a complex model. So,
    we set some specific properties in the callback to fix some rendering issues,
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看代码之前，首先要提到的是，如果您收到了一个OBJ文件、一个MTL文件和所需的纹理文件，您需要检查MTL文件如何引用纹理。这些应该是相对于MTL文件的引用，而不是绝对路径。代码本身与我们为`THREE.ObjLoader`看到的代码并没有太大的不同。我们指定了OBJ文件的位置、MTL文件的位置以及在加载模型时要调用的函数。在这种情况下，我们使用的模型是一个复杂的模型。因此，我们在回调中设置了一些特定的属性来修复一些渲染问题，如下所示：
- en: The opacity in the source files was set incorrectly, which caused the wings
    to be invisible. So, to fix that, we set the `opacity` and `transparent` properties
    ourselves.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件中的不透明度设置不正确，导致翅膀不可见。因此，为了解决这个问题，我们自己设置了`opacity`和`transparent`属性。
- en: By default, Three.js only renders one side of an object. Since we look at the
    wings from two sides, we need to set the `side` property to the `THREE.DoubleSide`
    value.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Three.js只渲染对象的一面。由于我们从两个方向观察翅膀，我们需要将`side`属性设置为`THREE.DoubleSide`值。
- en: The wings caused some unwanted artifacts when they needed to be rendered on
    top of each other. We've fixed that by setting the `depthTest` property to `false`.
    This has a slight impact on performance but can often solve some strange rendering
    artifacts.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要将翅膀渲染在彼此之上时，会导致一些不必要的伪影。我们通过将`depthTest`属性设置为`false`来解决这个问题。这对性能有轻微影响，但通常可以解决一些奇怪的渲染伪影。
- en: But, as you can see, you can easily load complex models directly into Three.js
    and render them in real time in your browser. You might need to fine-tune some
    material properties though.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如您所看到的，您可以轻松地直接将复杂的模型加载到Three.js中，并在浏览器中实时渲染它们。不过，您可能需要微调一些材质属性。
- en: Loading a Collada model
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载Collada模型
- en: Collada models (extension is `.dae`) are another very common format for defining
    scenes and models (and animations, as we'll see in the following chapter). In
    a Collada model, it is not just the geometry that is defined, but also the materials.
    It's even possible to define light sources.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Collada模型（扩展名为`.dae`）是另一种非常常见的格式，用于定义场景和模型（以及我们将在下一章中看到的动画）。在Collada模型中，不仅定义了几何形状，还定义了材料。甚至可以定义光源。
- en: 'To load Collada models, you have to take pretty much the same steps as for
    the OBJ and MTL models. You start by including the correct loader:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载Collada模型，您必须采取与OBJ和MTL模型几乎相同的步骤。首先要包括正确的加载程序：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For this example, we''ll load the following model:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将加载以下模型：
- en: '![Loading a Collada model](graphics/2215OS_08_15.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![加载Collada模型](graphics/2215OS_08_15.jpg)'
- en: 'Loading a truck model is once again pretty simple:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 再次加载卡车模型非常简单：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The main difference here is the result of the object that is returned to the
    callback. The `result` object has the following structure:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别是返回给回调的对象的结果。`result`对象具有以下结构：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this chapter, we're interested in the objects that are in the `scene` parameter.
    I first printed out the scene to the console to look where the mesh was that I
    was interested in, which was `result.scene.children[0].children[0]`. All that
    was left to do was scale it to a reasonable size and add it to the scene. A final
    note on this specific example—when I loaded this model for the first time, the
    materials didn't render correctly. The reason was that the textures used the `.tga`
    format, which isn't supported in WebGL. To fix this, I had to convert the `.tga`
    files to `.png` and edit the XML of the `.dae` model to point to these `.png`
    files.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对`scene`参数中的对象感兴趣。我首先将场景打印到控制台上，看看我感兴趣的网格在哪里，即`result.scene.children[0].children[0]`。剩下的就是将其缩放到合理的大小并添加到场景中。对于这个特定的例子，最后需要注意的是，当我第一次加载这个模型时，材料没有正确渲染。原因是纹理使用了`.tga`格式，这在WebGL中不受支持。为了解决这个问题，我不得不将`.tga`文件转换为`.png`并编辑`.dae`模型的XML，指向这些`.png`文件。
- en: As you can see, for most complex models, including materials, you often have
    to take some additional steps to get the desired results. By looking closely at
    how the materials are configured (using `console.log()`) or replacing them with
    test materials, problems are often easy to spot.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，对于大多数复杂模型，包括材料，通常需要采取一些额外的步骤才能获得所需的结果。通过仔细观察材料的配置（使用`console.log()`）或用测试材料替换它们，问题通常很容易发现。
- en: Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型
- en: 'We''re going to quickly skim over these file formats as they all follow the
    same principles:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速浏览这些文件格式，因为它们都遵循相同的原则：
- en: Include `[NameOfFormat]Loader.js` in your web page.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页中包括`[NameOfFormat]Loader.js`。
- en: Use `[NameOfFormat]Loader.load()` to load a URL.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`[NameOfFormat]Loader.load()`加载URL。
- en: Check what the response format for the callback looks like and render the result.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查回调的响应格式是什么样的，并渲染结果。
- en: 'We have included an example for all these formats:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为所有这些格式包含了一个示例：
- en: '| Name | Example | Screenshot |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 示例 | 截图 |'
- en: '| --- | --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| STL | `08-load-STL.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](graphics/2215OS_08_16.jpg) |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| STL | `08-load-STL.html` | ![加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型](graphics/2215OS_08_16.jpg)
    |'
- en: '| CTM | `09-load-CTM.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](graphics/2215OS_08_17.jpg) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| CTM | `09-load-CTM.html` | ![加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型](graphics/2215OS_08_17.jpg)
    |'
- en: '| VTK | `10-load-vtk.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](graphics/2215OS_08_18.jpg) |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| VTK | `10-load-vtk.html` | ![加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型](graphics/2215OS_08_18.jpg)
    |'
- en: '| AWD | `11-load-awd.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](graphics/2215OS_08_19.jpg) |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| AWD | `11-load-awd.html` | ![加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型](graphics/2215OS_08_19.jpg)
    |'
- en: '| Assimp | `12-load-assimp.html` | ![Loading the STL, CTM, VTK, AWD, Assimp,
    VRML, and Babylon models](graphics/2215OS_08_20.jpg) |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| Assimp | `12-load-assimp.html` | ![加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型](graphics/2215OS_08_20.jpg)
    |'
- en: '| VRML | `13-load-vrml.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](graphics/2215OS_08_21.jpg) |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| VRML | `13-load-vrml.html` | ![加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型](graphics/2215OS_08_21.jpg)
    |'
- en: '| Babylon | The Babylon loader is slightly different from the other loaders
    in this table. With this loader, you don''t load a single `THREE.Mesh` or `THREE.Geometry`
    instance, but with this loader, you load a complete scene, including lights.`14-load-babylon.html`
    | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models](graphics/2215OS_08_22.jpg)
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| Babylon | 巴比伦加载程序与表中的其他加载程序略有不同。使用此加载程序，您不会加载单个`THREE.Mesh`或`THREE.Geometry`实例，而是加载一个完整的场景，包括灯光。`14-load-babylon.html`
    | ![加载STL、CTM、VTK、AWD、Assimp、VRML和Babylon模型](graphics/2215OS_08_22.jpg) |'
- en: If you look at the source code for these examples, you might see that for some
    of them, we need to change some material properties or do some scaling before
    the model is rendered correctly. The reason we need to do this is because of the
    way the model is created in its external application, giving it different dimensions
    and grouping than we normally use in Three.js.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看这些示例的源代码，您可能会发现，对于其中一些示例，我们需要在模型正确渲染之前更改一些材料属性或进行一些缩放。我们之所以需要这样做，是因为模型是在其外部应用程序中创建的方式不同，给它不同的尺寸和分组，而不是我们在Three.js中通常使用的。
- en: We've almost shown all the supported file formats. In the next two sections,
    we'll take a different approach. First, we'll look at how to render proteins from
    Protein Data Bank (PDB format), and finally we'll use a model defined in the PLY
    format to create a particle system.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎展示了所有支持的文件格式。在接下来的两个部分中，我们将采取不同的方法。首先，我们将看看如何从蛋白质数据银行（PDB格式）渲染蛋白质，最后我们将使用PLY格式中定义的模型创建一个粒子系统。
- en: Show proteins from Protein Data Bank
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示来自蛋白质数据银行的蛋白质
- en: Protein Data Bank ([www.rcsb.org](http://www.rcsb.org)) contains detailed information
    about many different molecules and proteins. Besides the explanation of these
    proteins, they also provide a way to download the structure of these molecules
    in the PDB format. Three.js provides a loader for files specified in the PDB format.
    In this section, we'll give an example of how you can parse PDB files and visualize
    them with Three.js.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 蛋白质数据银行（[www.rcsb.org](http://www.rcsb.org)）包含许多不同分子和蛋白质的详细信息。除了这些蛋白质的解释外，它们还提供了以PDB格式下载这些分子结构的方法。Three.js提供了一个用于PDB格式文件的加载器。在本节中，我们将举例说明如何解析PDB文件并使用Three.js进行可视化。
- en: 'The first thing we always need to do to load in a new file format is include
    the correct loader in Three.js, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 加载新文件格式时，我们总是需要在Three.js中包含正确的加载器，如下所示：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this loader included, we''re going to create the following 3D model of
    the molecule description provided (see the `15-load-ptb.html` example):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 包含此加载器后，我们将创建以下分子描述的3D模型（请参阅“15-load-ptb.html”示例）：
- en: '![Show proteins from Protein Data Bank](graphics/2215OS_08_23.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![显示来自蛋白质数据银行的蛋白质](graphics/2215OS_08_23.jpg)'
- en: 'Loading a PDB file is done in the same manner as the previous formats, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 加载PDB文件的方式与之前的格式相同，如下所示：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see from this example, we instantiate `THREE.PDBLoader`, pass in
    the model file we want to load, and provide a callback that is called when the
    model is loaded. For this specific loader, the callback function is called with
    two arguments: `geometry` and `geometryBonds`. The vertices from the `geometry`
    argument supplied contain the positions of the individual atoms, and `geometryBounds`
    is used for the connections between the atoms.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从此示例中所见，我们实例化`THREE.PDBLoader`，传入我们想要加载的模型文件，并提供一个在加载模型时调用的回调函数。对于这个特定的加载器，回调函数被调用时带有两个参数：`geometry`和`geometryBonds`。`geometry`参数提供的顶点包含了单个原子的位置，而`geometryBounds`用于原子之间的连接。
- en: 'For each vertex, we create a sphere with the color that is also supplied by
    the model:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个顶点，我们创建一个颜色也由模型提供的球体：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Each connection is defined like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每个连接都是这样定义的：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For the connection, we first create a 3D path using the `THREE.SplineCurve3`
    object. This path is used as input for `THREE.Tube` and used to create the connection
    between the atoms. All the connections and atoms are added to a group, and this
    group is added to the scene. There are many models you can download from Protein
    Data Bank.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连接，我们首先使用`THREE.SplineCurve3`对象创建一个3D路径。这个路径被用作`THREE.Tube`的输入，并用于创建原子之间的连接。所有连接和原子都被添加到一个组中，然后将该组添加到场景中。您可以从蛋白质数据银行下载许多模型。
- en: 'The following image shows the structure of a diamond:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了一颗钻石的结构：
- en: '![Show proteins from Protein Data Bank](graphics/2215OS_08_24.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![显示来自蛋白质数据银行的蛋白质](graphics/2215OS_08_24.jpg)'
- en: Creating a particle system from a PLY model
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从PLY模型创建粒子系统
- en: 'Working with the PLY format isn''t that much different from the other formats.
    You include the loader, provide a callback, and visualize the model. For this
    last example, however, we''re going to do something different. Instead of rendering
    the model as a mesh, we''ll use the information from this model to create a particle
    system (see the `15-load-ply.html` example). The following screenshot shows this
    example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他格式相比，使用PLY格式并没有太大的不同。您需要包含加载器，提供回调函数，并可视化模型。然而，在最后一个示例中，我们将做一些不同的事情。我们将使用此模型的信息创建一个粒子系统，而不是将模型呈现为网格（请参阅“15-load-ply.html”示例）。以下截图显示了这个示例：
- en: '![Creating a particle system from a PLY model](graphics/2215OS_08_25.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![从PLY模型创建粒子系统](graphics/2215OS_08_25.jpg)'
- en: 'The JavaScript code to render the preceding screenshot is actually very simple,
    as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染上述截图的JavaScript代码实际上非常简单，如下所示：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we use `THREE.PLYLoader` to load the model. The callback returns
    `geometry`, and we use this geometry as input for `THREE.PointCloud`. The material
    we use is the same as the one we used for the last example in the previous chapter.
    As you can see, with Three.js, it is very easy to combine models from various
    sources and render them in different ways, all with a few lines of code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用`THREE.PLYLoader`来加载模型。回调函数返回`geometry`，我们将这个几何体作为`THREE.PointCloud`的输入。我们使用的材质与上一章中最后一个示例中使用的材质相同。如您所见，使用Three.js，很容易将来自各种来源的模型组合在一起，并以不同的方式呈现它们，只需几行代码。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Using models from external sources isn't that hard to do in Three.js. Especially
    for simple models, you only have to take a few simple steps. When working with
    external models, or creating them using grouping and merging, it is good to keep
    a couple of things in mind. The first thing you need to remember is that when
    you group objects, they still remain available as individual objects. Transformations
    applied to the parent also affect the children, but you can still transform the
    children individually. Besides grouping, you can also merge geometries together.
    With this approach, you lose the individual geometries and get a single new geometry.
    This is especially useful when you're dealing with thousands of geometries you
    need to render and you're running into performance issues.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中使用外部来源的模型并不难。特别是对于简单的模型，您只需要采取几个简单的步骤。在处理外部模型或使用分组和合并创建模型时，有几件事情需要记住。首先，您需要记住的是，当您将对象分组时，它们仍然作为单独的对象可用。应用于父对象的变换也会影响子对象，但您仍然可以单独变换子对象。除了分组，您还可以将几何体合并在一起。通过这种方法，您会失去单独的几何体，并获得一个新的单一几何体。当您需要渲染成千上万个几何体并且遇到性能问题时，这种方法尤其有用。
- en: Three.js supports a large number of external formats. When using these format
    loaders, it's a good idea to look through the source code and log out the information
    received in the callback. This will help you to understand the steps you need
    to take to get the correct mesh and set it to the correct position and scale.
    Often, when the model doesn't show correctly, this is caused by its material settings.
    It could be that incompatible texture formats are used, opacity is incorrectly
    defined, or the format contains incorrect links to the texture images. It is usually
    a good idea to use a test material to determine whether the model itself is loaded
    correctly and log the loaded material to the JavaScript console to check for unexpected
    values. It is also possible to export meshes and scenes, but remember that `GeometryExporter`,
    `SceneExporter`, and `SceneLoader` of Three.js are still work in progress.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js支持大量外部格式。在使用这些格式加载器时，最好查看源代码并记录回调中收到的信息。这将帮助您了解您需要采取的步骤，以获得正确的网格并将其设置到正确的位置和比例。通常，当模型显示不正确时，这是由其材质设置引起的。可能是使用了不兼容的纹理格式，不正确地定义了不透明度，或者格式包含了不正确的链接到纹理图像。通常最好使用测试材质来确定模型本身是否被正确加载，并记录加载的材质到JavaScript控制台以检查意外的值。还可以导出网格和场景，但请记住，Three.js的`GeometryExporter`、`SceneExporter`和`SceneLoader`仍在进行中。
- en: The models you worked with in this chapter, and in the previous chapters, are
    mostly static models. They aren't animated, don't move around, and don't change
    shape. In the next chapter, you'll learn how you can animate your models to make
    them come to life. Besides animations, the following chapter will also explain
    the various camera controls provided by Three.js. With a camera control, you can
    move, pan, and rotate the camera around your scene.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和前几章中使用的模型大多是静态模型。它们不是动画的，不会四处移动，也不会改变形状。在下一章中，您将学习如何为模型添加动画，使其栩栩如生。除了动画，下一章还将解释Three.js提供的各种摄像机控制。通过摄像机控制，您可以在场景中移动、平移和旋转摄像机。
