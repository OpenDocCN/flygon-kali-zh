- en: Useful Java Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的Java类
- en: Once we've achieved a level of confidence with the basics of Java, both the
    Java syntax and the basic object-oriented concepts that Java was built around,
    we can then take a look at Java's API and the class libraries that are immediately
    and easily accessible to us for writing Java programs. We want to do this because
    we're going to be using these class libraries to speed up our programming and
    to make use of the work of programmers who have written really great stuff.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对Java的基础知识，包括Java语法和Java构建的基本面向对象概念，有了一定的信心，我们就可以看一下Java的API和类库，这些对我们来说是立即和轻松地可访问的，用于编写Java程序。我们要这样做是因为我们将使用这些类库来加快我们的编程速度，并利用那些编写了非常棒东西的程序员的工作。
- en: Also, taking a look at the Java class libraries, or the class libraries of any
    programming language really, is also a great way to see how the programming language
    is designed for use and what optimal coding in that language should look and feel
    like.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，查看Java类库，或者任何编程语言的类库，也是了解编程语言设计用途以及该语言中最佳编码应该是什么样子的好方法。
- en: So, in this chapter, we will look at the `Calendar` class and how it works.
    We will take an in-depth look at the `String` class and a couple of its interesting
    methods. Next, we will walk through how to detect exceptions, that is, exceptional
    cases in our program, and how to handle them. We'll look at the `Object` class,
    which is the superclass of all classes in Java. Lastly, we'll look at the primitive
    classes of Java in brief.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将看一下`Calendar`类及其工作原理。我们将深入研究`String`类及其一些有趣的方法。接下来，我们将介绍如何检测异常，即程序中的异常情况，以及如何处理它们。我们将看一下`Object`类，它是Java中所有类的超类。最后，我们将简要介绍Java的原始类。
- en: 'The following are the topics that this chapter will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The `Calendar` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Calendar类
- en: The `String` class and the difference between using `String` objects and literals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`类以及使用`String`对象和文字之间的区别'
- en: Exceptions and how to handle them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常及如何处理它们
- en: The `Object` class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object`类'
- en: Primitive classes of Java
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java的原始类
- en: The Calendar class
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Calendar类
- en: In this section, we're going to take a look at Java's `Calendar` class. When
    writing Java code, we generally use the `Calendar` class to refer to a specific
    moment in time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下Java的`Calendar`类。在编写Java代码时，我们通常使用`Calendar`类来指代特定的时间点。
- en: The `Calendar` class is actually a relatively new addition to the Java API.
    Previously, we used a class called `Date` to perform the similar functionality.
    If you end up working on older Java code or are writing Java code that deals with
    a SQL or MySQL database, you'll probably end up using the Java `Date` class at
    least occasionally. If this happens, don't panic; consult the Java documentation
    and you'll discover that there are some really great functions for swapping between
    `Calendar` and `Date` objects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calendar`类实际上是Java API的一个相对较新的添加。以前，我们使用一个叫做`Date`的类来执行类似的功能。如果你最终要处理旧的Java代码，或者编写涉及SQL或MySQL数据库的Java代码，你可能会偶尔使用Java的`Date`类。如果发生这种情况，不要惊慌；查阅Java文档，你会发现有一些非常棒的函数可以在`Calendar`和`Date`对象之间进行切换。'
- en: To see the power of Java's `Calendar` class, let's jump into a Java program
    and instantiate it. Let's create a new program; first, import all the classes
    from the `java.util` package because that's where the `Calendar` class lives.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到Java的`Calendar`类的强大之处，让我们跳入一个Java程序并实例化它。让我们创建一个新程序；首先，从`java.util`包中导入所有类，因为`Calendar`类就在那里。
- en: Next, we declare a new `Calendar` object; I'm going to call it `now` because
    our first goal is to set the value of this `Calendar` object as the current moment
    in time. Let's set the value of `now` as the default value of a `Calendar` object
    and see what it gives us. To do this, I suppose we're going to need to use the
    `new` keyword. While we haven't actually looked it up in the documentation, this
    seems like a reasonable starting or default date for a `Calendar` instance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个新的`Calendar`对象；我将其称为`now`，因为我们的第一个目标是将这个`Calendar`对象的值设置为当前时刻。让我们将`now`的值设置为`Calendar`对象的默认值，并看看它给我们带来了什么。为了做到这一点，我想我们需要使用`new`关键字。虽然我们实际上还没有在文档中查找过，但这似乎是一个合理的起始或默认日期，用于`Calendar`实例。
- en: 'Lastly, let''s set up our program so that we can print out the information
    contained in our `now` object:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们设置我们的程序，以便打印出我们的`now`对象中包含的信息：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Perhaps, surprisingly, this basic program actually fails when we attempt to
    compile it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 也许令人惊讶的是，当我们尝试编译这个基本程序时，它实际上失败了：
- en: '![](img/f158bddd-0d63-4a9d-a67e-61669fc54652.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f158bddd-0d63-4a9d-a67e-61669fc54652.png)'
- en: Our error is on `Calendar`, where we have instantiated the `Calendar` class,
    according to the error shown in the console. The error is `Calendar is abstract;
    cannot be instantiated`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的错误出现在`Calendar`上，我们已经实例化了`Calendar`类，根据控制台显示的错误。错误是`Calendar`是抽象的，不能被实例化。
- en: If you recall, abstract classes are those that are designed purely to be subclassed,
    and we can never declare an instance of an abstract class all by itself. So what
    good is Java's `Calendar` class if we can never instantiate one? Of course, that's
    not a fair question because we definitely can create `Calendar` objects; they
    just have to be a specific type of `Calendar` object. We're almost always going
    to make use of `GregorianCalendar`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，抽象类是那些纯粹设计为被子类化的类，我们永远不能单独声明抽象类的实例。那么如果我们永远不能实例化Java的`Calendar`类，那么它有什么好处呢？当然，这不是一个公平的问题，因为我们绝对可以创建`Calendar`对象；它们只是特定类型的`Calendar`对象。我们几乎总是会使用`GregorianCalendar`。
- en: Subclasses of Calendar
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Calendar的子类
- en: Let's take a step back and assume, perhaps rightfully so, that we didn't know
    what `Calendar` options were available to us. This is one of the times when working
    with an **IDE **(**Integrated Development Environment)**, such as NetBeans here,
    can be really amazing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，假设也许是正确的，我们不知道`Calendar`有哪些选项可用。这是使用**IDE（集成开发环境）**，比如NetBeans，真的很棒的时候之一。
- en: Normally, at this point in time, we'd have to take a trip to the Java documentation
    to see exactly what subclasses of `Calendar` are available for us to instantiate.
    But because our IDE knows some metadata about the packages that we've already
    imported, we can ask our IDE what it thinks might be a possible solution for our
    code. If you're working in NetBeans, you can get these kinds of suggestions very
    often by checking some of the Code Completion options from Tools | Options | Code
    Completion.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在这个时间点上，我们需要查看Java文档，以确定`Calendar`的子类有哪些可以实例化。但是因为我们的IDE知道我们已经导入的包的一些元数据，我们可以询问我们的IDE它认为可能是我们代码的一个可能解决方案。如果你在NetBeans中工作，你可以通过从工具|选项|代码完成中检查一些代码完成选项来经常获得这些类型的建议。
- en: 'However, to keep code completion from popping up all the time, I''m going to
    make use of a NetBeans shortcut on this occasion. This shortcut, by default, is
    the key combination *Ctrl* + space, which will prompt a code completion pop-up
    window for the current location of our cursor, as shown in the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了防止代码完成一直弹出，我将在这个场合使用NetBeans的快捷方式。默认情况下，这个快捷键组合是*Ctrl* + space，这将在我们光标当前位置弹出一个代码完成弹出窗口，如下面的屏幕截图所示：
- en: '![](img/a53f7a67-2fd6-445d-888f-2b011fd7336c.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a53f7a67-2fd6-445d-888f-2b011fd7336c.png)'
- en: 'The Code Completion option in NetBeans is excellent. NetBeans has given us
    three possible suggestions: the abstract `Calendar` class, `BuddhistCalendar`,
    and `GregorianCalendar`. We already know we don''t want to use the `Calendar`
    class because we can''t actually instantiate an abstract class. The `BuddhistCalendar`
    and `GregorianCalendar` certainly look like subclasses of `Calendar`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans中的代码完成选项非常出色。NetBeans给了我们三个可能的建议：抽象的`Calendar`类，`BuddhistCalendar`和`GregorianCalendar`。我们已经知道我们不想使用`Calendar`类，因为我们实际上不能实例化一个抽象类。`BuddhistCalendar`和`GregorianCalendar`看起来确实是`Calendar`的子类。
- en: 'If we select `GregorianCalendar`, we''ll see that it is a subclass of `Calendar`.
    So let''s go ahead and attempt to create a brand-new `GregorianCalendar` instance
    with default settings and values:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择`GregorianCalendar`，我们会看到它是`Calendar`的一个子类。所以让我们试着创建一个全新的`GregorianCalendar`实例，使用默认的设置和值：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we run this Java program, we do get some output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个Java程序，我们确实会得到一些输出：
- en: '![](img/09bc6484-e8c0-49ca-9386-2560c3833071.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09bc6484-e8c0-49ca-9386-2560c3833071.png)'
- en: 'This output means two things:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出意味着两件事：
- en: Our syntax is correct because we compiled successfully
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的语法是正确的，因为我们成功编译了
- en: We can see what values Java puts in a brand new `Calendar` object
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到Java在一个全新的`Calendar`对象中放入了什么值
- en: One of the great things about Java is how extensive and demanding it is that
    new objects implement the `toString()` method used by `println()`. This means
    that most Java standard library objects are capable of printing themselves out
    in some sort of human-readable format when we ask them to.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Java的一个很棒的地方是它要求新对象实现`toString()`方法，这个方法被`println()`使用。这意味着大多数Java标准库对象在我们要求它们打印自己时，能够以某种人类可读的格式打印出来。
- en: Our new `Calendar` class printed out here isn't exactly easy to read, but we
    can go through it and see that values have been assigned to many of its fields,
    and we can also see what the fields, which a `Calendar` class has, actually are
    (such as `areFieldsSet`, `areAllFieldsSet`, and so on).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里打印出的新的`Calendar`类并不容易阅读，但我们可以浏览一下，看到许多字段已经被赋值，我们还可以看到`Calendar`类实际上有哪些字段（比如`areFieldsSet`，`areAllFieldsSet`等）。
- en: Fetching the current day, month, and year
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取当前的日，月和年
- en: 'Let''s see how to get just one piece of information from `Calendar` class.
    Let''s see whether it is actually set to the value of today. Let''s print the
    day, month, and year on three separate `println` lines to keep things simple.
    To access the current day, month, and year, we''ll need to get those fields from
    the `Calendar` object `now`. If our `Calendar` object represents a specific moment
    in time, it should have fields for day, month, and year, right? Well, if we open
    up our autocomplete option, we can take a look at all the fields and methods available
    to us, exposed by our `Calendar` object as shown in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从`Calendar`类中获取一个信息。让我们看看它是否实际上被设置为今天的值。让我们将日，月和年分别打印在三行`println`上，以保持简单。要访问当前的日，月和年，我们需要从`now`的`Calendar`对象中获取这些字段。如果我们的`Calendar`对象表示特定的时间点，它应该有日，月和年的字段，对吧？如果我们打开自动完成选项，我们可以看到我们的`Calendar`对象公开给我们的所有字段和方法，如下面的屏幕截图所示：
- en: '![](img/c178d672-c27e-45e8-ae73-5e000845e338.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c178d672-c27e-45e8-ae73-5e000845e338.png)'
- en: We're not going to find an easily accessible day, month, and year field, and
    this might start to disenfranchise us from `Calendar`; however, we're just not
    going enough levels deep.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会找到一个容易访问的日，月和年字段，这可能开始让我们对`Calendar`感到失望；然而，我们只是没有深入到足够的层次。
- en: The `Calendar` class exposes the `get()` method that allows us to acquire the
    fields that describe the specific `Calendar` instance or moment in time. It's
    a function that takes an integer as a parameter. To some of us, this might look
    a little confusing at first. Why would we provide `get()` with an integer to tell
    it what `Calendar` field we're looking for?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calendar`类公开了`get()`方法，允许我们获取描述特定`Calendar`实例或时间点的字段。这是一个以整数作为参数的函数。对于我们中的一些人来说，这一开始可能看起来有点混乱。为什么我们要提供一个整数给`get()`，告诉它我们正在寻找哪个`Calendar`字段？'
- en: 'This integer is actually an enumerator, which we''ll think about for now as
    a static string exposed by the `Calendar` class itself. If, for the parameter
    of `get()`, we type in the `Calendar` class name like we wanted to get a static
    member variable and then go back to autocomplete, we see a list of options that
    we can utilize in this instance, as shown in the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个整数实际上是一个枚举器，我们暂时将其视为`Calendar`类本身公开的静态字符串。如果我们在`get()`的参数中输入`Calendar`类名，就像我们想要获取一个静态成员变量，然后返回自动完成，我们会看到我们可以在这个实例中使用的选项列表，如下面的屏幕截图所示：
- en: '![](img/e9d6c526-d232-4e65-baad-fbb4557bf1f1.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9d6c526-d232-4e65-baad-fbb4557bf1f1.png)'
- en: 'Some of these options don''t make a lot of sense. We have to remember that
    autocomplete is just telling us what `Calendar` exposes; it''s not giving us the
    solution because it has no idea what we''re trying to do. For example, we wouldn''t
    want to use our `Calendar` instance `now` to get its value of `May`; this wouldn''t
    make any sense. But, we can use our `Calendar` instance to get the current month
    (`MONTH`). Similarly, what we really want is the day of the month (`DAY_OF_MONTH`)
    and the current year (`YEAR`). Let''s run the following program:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些选项并不太合理。我们必须记住，自动完成只是告诉我们`Calendar`公开的内容；它并不给我们解决方案，因为它不知道我们想要做什么。例如，我们不希望使用我们的`Calendar`实例`now`来获取其`May`的值；这没有任何意义。但是，我们可以使用我们的`Calendar`实例来获取当前月份（`MONTH`）。同样，我们真正想要的是当月的日期（`DAY_OF_MONTH`）和当前年份（`YEAR`）。让我们运行以下程序：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we run the preceding program, we get the output `9`, `12`, `2017`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述程序，我们得到输出`9`，`12`，`2017`：
- en: '![](img/951c8817-a2e8-4342-8922-8ff33f63cf5a.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/951c8817-a2e8-4342-8922-8ff33f63cf5a.png)'
- en: I'm writing this book on October 12, 2017, so this is actually a little confusing
    because October is the tenth month of the year.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我写这本书是在2017年10月12日，所以这实际上有点令人困惑，因为十月是一年中的第十个月。
- en: 'Fortunately, there''s a reasonable explanation for this. Unlike the day of
    the year and year, which makes sense to store as integer variables, most implementations
    of `Calendar` and classes similar to `Calendar` in most programming languages,
    not just Java, choose to store months as an array. This is because in addition
    to a numeric value, each month also has a corresponding string: its name.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对此有一个合理的解释。与一年中的日期和年份不同，它们可以存储为整数变量，大多数编程语言中的`Calendar`和类似`Calendar`的类的大多数实现（不仅仅是Java）选择将月份存储为数组。这是因为除了数值之外，每个月还有一个相应的字符串：它的名称。
- en: 'Since arrays are zero-indexed, our month appears, in case you forget about
    this, one month lower than it should be. Our `println()` function should probably
    look like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组是从零开始的，如果你忘记了这一点，我们的月份看起来比它应该的要低一个月。我们的`println()`函数可能应该如下所示：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I got the following output. You''ll have to trust me on this; it is today''s
    date:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了以下输出。你得相信我；这是今天的日期：
- en: '![](img/9e391090-bdab-4c54-b429-2ecf1ff3da33.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e391090-bdab-4c54-b429-2ecf1ff3da33.png)'
- en: So `Calendar` has a whole lot of methods associated with it. In addition to
    just setting `Calendar` to the current point of time and reading from it with
    our `get()` function, we can set `Calendar` to points in time using the `set()`
    function. We can add or subtract using negative values to point in time, using
    the `add()` function. We can check whether points in time are before or after
    other points of time, using the `before()` and `after()` functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Calendar`有很多与之关联的方法。除了使用`get()`函数将`Calendar`设置为当前时间点并从中读取外，我们还可以使用`set()`函数将`Calendar`设置为时间点。我们可以使用`add()`函数添加或减去负值来指定时间点。我们可以使用`before()`和`after()`函数检查时间点是在其他时间点之前还是之后。
- en: How Calendar works
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日历的工作原理
- en: If you're like me though, you'd like to know a little bit about how this `Calendar`
    object is really operating. Is it storing the month, day, and seconds of time
    in separate fields, or is there one big number that contains all of this information?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果像我一样，你想知道这个`Calendar`对象是如何运作的。它是将月份、日期和时间秒存储在单独的字段中，还是有一个包含所有这些信息的大数字？
- en: 'If we spend some time and take a look at the methods available to us in the
    `Calendar` class implementation, we''ll find these two methods: `setTimeInMillis()`
    and its sister method `getTimeInMillis()` as shown in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们花一些时间查看`Calendar`类实现中可用的方法，我们会发现这两个方法：`setTimeInMillis()`及其姐妹方法`getTimeInMillis()`如下截图所示：
- en: '![](img/594e44de-9eec-4c93-b94f-063721fc8b8a.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/594e44de-9eec-4c93-b94f-063721fc8b8a.png)'
- en: The fact that these methods are specially set aside is a really great window
    of opportunity for us to see how the `Calendar` class really thinks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法被特别设置是一个很好的机会，让我们看看`Calendar`类的真正思维方式。
- en: 'Let''s begin our exploration by calling the `getTimeInMillis()` function and
    printing out its output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过调用`getTimeInMillis()`函数并打印其输出来开始我们的探索：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We get a really large integer number, which is presumably the time in milliseconds
    since some particular point in time:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个非常大的整数，这很可能是自某个特定时间以来的毫秒数：
- en: '![](img/8af89898-4b62-4305-b86f-5f5ddce7edbf.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8af89898-4b62-4305-b86f-5f5ddce7edbf.png)'
- en: If we were to do the math on this though, we would discover that this point
    in time is not actually the year 0; rather, it's a time much closer than that.
    This point in time is referred to by the `Calendar` class as the **epoch**, and
    it's the point in time when we start counting from when we store a time in Java
    in terms of how many milliseconds it's been since the epoch.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进行数学计算，我们会发现这个时间点实际上不是公元元年；相反，它的时间要比那更接近。`Calendar`类称这个时间点为**纪元**，这是我们开始计算的时间点，当我们在Java中存储时间时，我们计算了多少毫秒自纪元以来。
- en: 'We could whip out our calculator and through a pretty painstaking process figure
    out exactly what this point in time was, or we could do it in our native Java
    environment with a lot less pain. Let''s simply change the value of `now`, originally
    set to the default or current moment in time, to be the time when milliseconds
    is set to `0`. We''ll do this with `setTimeInMillis()` and provide `0` as an argument:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用计算器通过一个相当费力的过程来准确计算这个时间点，或者我们可以在我们的本地Java环境中以更少的痛苦来做。让我们简单地将`now`的值更改为`0`时的时间点，最初设置为默认或当前时间点。我们将使用`setTimeInMillis()`并提供`0`作为参数：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we run our program again, we get the same output fields:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次运行程序时，我们得到相同的输出字段：
- en: '![](img/6e43915a-b424-4e21-ac8f-4c085a6f509f.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e43915a-b424-4e21-ac8f-4c085a6f509f.png)'
- en: The first number in our output is our confirmation that milliseconds has been
    set to `0`. Now our `Calendar` moment in time is January 1, 1970\. So once we
    start adding days to our object, we'll be counting from January 2, 1970\. This
    point in time is referred to by the Java `Calendar` as the epoch.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输出的第一个数字是我们确认毫秒已设置为`0`。现在我们的`Calendar`时间是1970年1月1日。因此，一旦我们开始向我们的对象添加天数，我们将从1970年1月2日开始计算。这个时间点被Java
    `Calendar`称为时代。
- en: Why is this a really interesting thing for us to know? It means that we can
    convert our `Calendar` classes to these millisecond values and then add, subtract,
    and I guess multiply and divide them as integer values. This allows us to use
    all sorts of operations on them in the native format of mathematics.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这对我们来说是一个非常有趣的事情？这意味着我们可以将我们的`Calendar`类转换为这些毫秒值，然后将它们作为整数值相加、相减，我想还可以将它们作为整数值相乘和相除。这使我们能够在数学的本机格式上对它们进行各种操作。
- en: Lastly, I'd like to show you one more thing because it's a bit of syntax that
    you may not be familiar with and may not immediately recognize when you come across
    it. If you recall at the beginning of this section, we said `Calendar` is an abstract
    class; we can only instantiate specific types of `Calendar` classes. However,
    oftentimes, we won't specify exactly what type of calendar we're looking for;
    we'll ask the `Calendar` class to decide this.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想向您展示另一件事，因为这是一个语法上的细节，您可能不熟悉，也可能不会在第一时间认出。如果您回忆一下本节开头，我们说`Calendar`是一个抽象类；我们只能实例化特定类型的`Calendar`类。然而，通常情况下，我们不会指定我们要找的确切类型的日历；我们会要求`Calendar`类来决定这一点。
- en: 'As we saw with our enums, in addition to having object-level methods, the `Calendar`
    class does provide some static methods that we can use just by referencing the
    `Calendar` type name. One of these methods is `Calendar.getInstance()`, which
    will create for us the best fit `Calendar` class that Java can figure out:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在枚举中看到的，除了具有对象级方法之外，`Calendar`类还提供了一些静态方法，我们可以通过引用`Calendar`类型名称来使用。其中一个方法是`Calendar.getInstance()`，它将为我们创建Java可以找到的最佳匹配`Calendar`类：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, it's going to be that same `GregorianCalendar` class that we have
    created already.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将是我们已经创建的相同的`GregorianCalendar`类。
- en: String functionality
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串功能
- en: Working with strings in Java can be a little confusing at first because they
    really are a special case. Strings have associated with them this concept of a
    string literal, that is, a sequence of characters between double quotation marks.
    We can just put it right into our Java programs and Java will understand it, just
    like it would understand an integer number or a single character.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中处理字符串可能会有点令人困惑，因为它们确实是一个特殊情况。字符串与之相关联的是字符串字面值的概念，即双引号之间的字符序列。我们可以将它直接放入我们的Java程序中，Java会理解它，就像它理解整数或单个字符一样。
- en: 'Unlike integers, characters, and floats, Java doesn''t have a primitive keyword
    associated with this string literal. About the closest we could get if we wanted
    to is a character array; however, generally, Java likes us to associate string
    literals with the `String` class. To understand the `String` class better, look
    at the following program:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与整数、字符和浮点数不同，Java没有与这个字符串字面值相关联的原始关键字。如果我们想要的话，我们可能会得到的最接近的是字符数组；然而，通常情况下，Java喜欢我们将字符串字面值与`String`类相关联。要更好地理解`String`类，请查看以下程序：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `String` class in Java is special. In some ways, it's just like any other
    class. It has methods, and as we can see in the code lines, where we defined the
    variables `s1` and `s2`, it has a constructor. But, we can use operators on the
    `String` class that are normally only reserved for literals and primitives. For
    example, in the preceding program, we added `s1` to the string literal `string
    1:` to get a meaningful result. This is not normally an option when dealing with
    a Java object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的`String`类是特殊的。在某些方面，它就像任何其他类一样。它有方法，正如我们在代码行中看到的，我们定义了变量`s1`和`s2`，它有一个构造函数。但是，我们可以对`String`类使用通常仅保留给字面值和基本类型的运算符。例如，在前面的程序中，我们将`s1`添加到字符串字面值`string
    1:`中以获得有意义的结果。在处理Java对象时，这通常不是一个选项。
- en: String literals versus String objects
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串字面值与字符串对象
- en: Java's decision to use objects of the `String` class as either string literals
    or genuine objects interchangeably is really powerful. It gives us way more options
    to manipulate text than we would otherwise have, but it does come with some trade-offs.
    While dealing with a `String` object, it's very important that we understand whether
    we're dealing with its string value or with the object itself. This is because
    we can get radically different behaviors. The preceding program we saw is designed
    to illustrate one of these instances.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Java决定将`String`类的对象作为字符串字面值或真正的对象可以互换使用，这真的很强大。它给了我们比我们原本拥有的更多操作文本的选项，但它也有一些权衡。在处理`String`对象时，非常重要的是我们理解我们是在处理它的字符串值还是对象本身。这是因为我们可能会得到截然不同的行为。我们看到的前面的程序旨在说明其中一个实例。
- en: 'It''s a pretty simple program. Let''s step through it and attempt to anticipate
    its output. We start off by declaring and instantiating two `String` objects:
    `s1` and `s2`. We use the `String` constructor (we''ll talk about why that''s
    important here soon), and we simply pass in the same string literal value to each
    of these new objects. Then, we ask our program to print out these values just
    so we can compare them visually. But then, we also ask our program to carry out
    this interesting task: compare using the double equal sign comparison operators
    `s1` and `s2`. Before you run this program, take a second and ask yourself, "What
    do you think the result of this comparison is going to be?".'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的程序。让我们逐步进行并尝试预测其输出。我们首先声明并实例化两个`String`对象：`s1`和`s2`。我们使用`String`构造函数（我们很快会谈到为什么这很重要），并简单地将相同的字符串字面值传递给这些新对象中的每一个。然后，我们要求我们的程序打印出这些值，以便我们可以进行视觉比较。但是，我们还要求我们的程序执行这个有趣的任务：使用双等号比较运算符`
    s1`和`s2`进行比较。在运行此程序之前，花一秒钟时间问自己，“你认为这个比较的结果会是什么？”。
- en: 'When I run this program, I see that Java does not believe that the comparison
    of `s1` and `s2` returns `true`. I get the result `false`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这个程序时，我发现Java不相信`s1`和`s2`的比较结果是`true`。我得到的结果是`false`：
- en: '![](img/11c57936-eaa1-47bd-975b-4fb5ae8f3d01.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11c57936-eaa1-47bd-975b-4fb5ae8f3d01.png)'
- en: Depending on what we were thinking about `s1` and `s2` at the time, the output
    either makes sense or is confusing. If we were thinking of `s1` and `s2` as string
    literals being compared by the comparison operator, it would be very confusing
    to us. We'd wonder why we didn't get the result `true` since the string literals
    assigned to both `s1` and `s2` are the same.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们当时对`s1`和`s2`的想法，输出要么是合理的，要么是令人困惑的。如果我们认为`s1`和`s2`是由比较运算符比较的字符串文字，那么我们会感到非常困惑。我们会想知道为什么我们没有得到`true`的结果，因为分配给`s1`和`s2`的字符串文字是相同的。
- en: However, if we were thinking of `s1` and `s2` as the objects that they are,
    the `false` result makes a lot more sense because what we're asking Java is, "Are
    these two objects the same?" They're clearly not because they're both the result
    of creating two different new objects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们把`s1`和`s2`看作它们实际上是的对象，`false`的结果就更有意义了，因为我们询问Java的是，“这两个对象是相同的吗？”显然不是，因为它们都是创建两个不同新对象的结果。
- en: This is why we like to use the `equals()` method when we can in Java. Almost
    every object implements an `equals()` method, and the `equals()` method should
    be written for every object so that it could logically compare the value of these
    objects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们喜欢在Java中尽可能使用`equals()`方法。几乎每个对象都实现了`equals()`方法，而且应该为每个对象编写`equals()`方法，以便逻辑上比较这些对象的值。
- en: 'If we compare our strings using the `equals()` method, we also compare the string
    literal values they contain:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`equals()`方法比较我们的字符串，我们也比较它们包含的字符串文字值：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now if we execute our program, we get the result `true`, as opposed to the `false`
    we got when we were trying to see whether they were actually the same objects
    stored in the same location of memory:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们执行我们的程序，我们得到的结果是`true`，而不是当我们试图看它们是否实际上是存储在内存的相同位置的相同对象时得到的`false`：
- en: '![](img/786b8fe7-9ac7-4202-a59d-a06e6ce02ea9.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/786b8fe7-9ac7-4202-a59d-a06e6ce02ea9.png)'
- en: String functions
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串函数
- en: 'So what powers does this `String` implementation give us? Well, we know that
    we can add or concatenate strings together because we can manipulate them as literals.
    In addition to this literal manipulation, we can also make use of all the functionality
    provided by the `String` class itself. We can go to the Java documentation to
    see what functionality is available for us, or we can always check using the code
    completion feature of NetBeans. I should probably point out here that we can even
    use the `String` class functionalities on string literals, as shown in the following
    screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`String`实现给了我们什么能力？嗯，我们知道我们可以添加或连接字符串，因为我们可以将它们作为文字进行操作。除了文字操作，我们还可以利用`String`类本身提供的所有功能。我们可以查看Java文档，了解可用的功能，或者我们可以始终使用NetBeans的代码完成功能进行检查。我应该在这里指出，我们甚至可以在字符串文字上使用`String`类的功能，如下面的屏幕截图所示：
- en: '![](img/877c76fc-5a48-413e-8982-dab2908cd52e.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/877c76fc-5a48-413e-8982-dab2908cd52e.png)'
- en: The replace() function
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: replace()函数
- en: 'A lot of the methods you''ll see in the methods list are pretty self-explanatory
    (`toLowerCase()`, `toUpperCase()`, and so on). But just to make sure we''re all
    on the same page, let''s make use of one of them. Let''s use `replace()`. The
    `replace()` function takes two arguments, and these arguments can either be single
    characters or a character sequence of which a string qualifies. This method simply
    replaces all the instances of the first string or character with the second string
    or character. Let''s look at the following `replace()` example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在方法列表中看到的大多数方法都是相当不言自明的（`toLowerCase()`，`toUpperCase()`等）。但为了确保我们都明白，让我们使用其中一个。让我们使用`replace()`。`replace()`函数接受两个参数，这些参数可以是单个字符，也可以是字符串符合条件的字符序列。该方法简单地用第二个字符串或字符替换第一个字符串或字符的所有实例。让我们看下面的`replace()`示例：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we run our program, we see that we''ve modified its output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的程序时，我们看到我们修改了它的输出：
- en: '![](img/b644940e-7847-4b30-bb78-e2083f63036d.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b644940e-7847-4b30-bb78-e2083f63036d.png)'
- en: Most of these methods simply modify the value being returned. We can see that
    our program still finds that `s1` equals `s2` at this last line of code, showing
    us that the value of `s1` hasn't been modified by our call to the `replace()`
    method. The `replace()` method has simply returned the modified value for our
    `println()` function to utilize.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些方法只是修改返回的值。我们可以看到我们的程序仍然发现在代码的最后一行`s1`等于`s2`，这表明我们对`replace()`方法的调用没有修改`s1`的值。`replace()`方法只是返回修改后的值供我们的`println()`函数使用。
- en: The format() function
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: format()函数
- en: 'Perhaps, the most interesting of the `String` class''s methods is actually
    one of its static methods: `String.format()`. To show you the power of `String.format()`,
    I''d like to create a brand new functional class for our project. So right-click
    on the Project name in the filesystem, shown on the left-hand side of the screen,
    create a new class, and call it `CustomPrinter.java`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，`String`类中最有趣的方法之一实际上是它的静态方法之一：`String.format()`。为了向您展示`String.format()`的强大功能，我想为我们的项目创建一个全新的功能类。因此，在屏幕左侧显示的文件系统中右键单击项目名称，在新建类中输入`CustomPrinter.java`：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So that you can see what we're doing when we set the `CustomPrinter` class up,
    let's look at the prewritten code we're going to use in our `main()` method. The
    idea behind the `CustomPrinter` class is that it will have a constructor that
    takes a string as input. This input string will format, or wrap around, any strings
    that we print out to our console using the `CustomPrinter` instance. We will implement
    `System.out.println()` within `CustomPrinter`, so we can just call `printer.println()`
    when we want to utilize it for formatting our text.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你看到我们在设置`CustomPrinter`类时在做什么，让我们看一下我们将在`main()`方法中使用的预写代码。`CustomPrinter`类的想法是它将有一个以字符串作为输入的构造函数。这个输入字符串将格式化或包装我们使用`CustomPrinter`实例打印到控制台的任何字符串。我们将在`CustomPrinter`中实现`System.out.println()`，所以当我们想要利用它来格式化我们的文本时，我们可以直接调用`printer.println()`。
- en: When we format a string in Java, we use some special syntax. Within our format
    string, we can preface the characters `f` or `d` or `s` most commonly with a percentage
    symbol (like we used `%s` in our code). In terms of the `String.format()` function,
    Java understands these as areas in our format string where we're going to insert
    other information.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中格式化字符串时，我们使用一些特殊的语法。在我们的格式字符串中，我们可以用百分号（就像我们在代码中使用的`%s`）来预先标识字符`f`或`d`或`s`。在`String.format()`函数方面，Java将这些理解为我们的格式字符串中要插入其他信息的区域。
- en: The format string that we've used in our code will wrap any string output we
    create with caret brackets. This is more complicated than simply appending and
    prepending to a string, and we could certainly create an implementation that would
    allow us to add multiple pieces to our formatted strings.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中使用的格式字符串将用尖括号包装我们创建的任何字符串输出。这比简单地将字符串附加和前置更复杂，我们当然可以创建一个实现，允许我们向我们的格式化字符串添加多个部分。
- en: 'Let''s edit our `CustomPrinter.java` file next. We know that we''re going to
    need a `CustomPrinter` constructor, which takes a format string as input. Then,
    we''re probably going to need to store this `format` string. So let''s just have
    our constructor take the provided format string and store it for later use in
    the `formatString` variable:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们编辑`CustomPrinter.java`文件。我们知道我们需要一个`CustomPrinter`构造函数，它接受一个格式字符串作为输入。然后，我们可能需要存储这个`format`字符串。所以让我们的构造函数接受提供的格式字符串，并将其存储以备后用在`formatString`变量中：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We also declare a `println()` function, which presumably is going to be a `void`
    function; it's just going to utilize `system.out.println()` to print something
    to the screen. What that *something* is, is going to be a little complicated.
    We need to take our given format string and replace `%s` with the input provided
    to our `println()` function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了一个`println()`函数，据推测它将是一个`void`函数；它只会利用`system.out.println()`将某些东西打印到屏幕上。那个*某些东西*会有点复杂。我们需要拿到我们给定的格式字符串，并用`println()`函数提供的输入替换`%s`。
- en: 'We do this with the awesome `String.format()` static function that takes two
    parameters: a format string and the data to be formatted. If our format string
    had multiple strings to format, we could provide multiple fields in `String.format()`.
    It''s a function that can take any amount of input. But, to keep everything simple
    and moving along, we''re simply going to assume that our format string only has
    one input instance.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了强大的`String.format()`静态函数，它接受两个参数：一个格式字符串和要格式化的数据。如果我们的格式字符串有多个要格式化的字符串，我们可以在`String.format()`中提供多个字段。这是一个可以接受任意数量输入的函数。但是，为了保持一切简单和顺利，我们只会假设我们的格式字符串只有一个输入实例。
- en: 'Once we''ve successfully formatted this string using the `String.format()`
    function, we''ll simply print it out to the screen, as we did earlier:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们成功使用`String.format()`函数格式化了这个字符串，我们就会简单地将它打印到屏幕上，就像我们之前做的那样：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we run this program (we need to run the class where we have our `main()`
    method), we see that all of our output gets properly wrapped in caret brackets:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序（我们需要运行我们有`main()`方法的类），我们会看到我们所有的输出都被正确地包裹在尖括号中：
- en: '![](img/824bfc07-9fa2-4ba3-b869-26bd7e5abf07.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/824bfc07-9fa2-4ba3-b869-26bd7e5abf07.png)'
- en: Extending a custom printer like this, of course, to take a higher amount of
    varied input and to be much more dynamic than the quick thing we created, is the
    basis for anything, such as a logging system, or a terminal system, where you
    will be able to see the same pieces of information wrapped around messages. We
    could use a custom printer like this, for example, to place dates and times after
    any message we send to the user. However, details would need to be properly formatted
    so that they're not just tacked on at the end but have proper spacing between
    them and stuff like that.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像这样扩展自定义打印机，以接受更多的各种输入，并且比我们创建的快速东西更加动态，是任何东西的基础，比如日志系统，或者终端系统，你将能够看到相同的信息片段包裹在消息周围。例如，我们可以使用这样的自定义打印机，在向用户发送任何消息后放置日期和时间。然而，细节需要被正确格式化，这样它们不仅仅是被添加在末尾，而是在它们之间有适当的间距等。
- en: I hope you have learned something about strings. The way Java handles them is
    really powerful, but as with most powerful things in programming, you will need
    to understand them at a basic level before you can be sure that they're not going
    to come back and bite you.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你已经学到了一些关于字符串的知识。Java处理它们的方式真的很强大，但和大多数强大的编程工具一样，你需要在基本水平上理解它们，才能确保它们不会回来咬你。
- en: Exceptions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: Sometimes, there is a possibility that our code might fail. It might be our
    fault for making a programming error, or it might be an end user using our system
    in a way we didn't anticipate. Sometimes, it might even be a hardware failure;
    a lot of errors can't really be attributed to any one single source, but they
    are going to happen. The way that our program handles the error case is often
    just as, if not more, important as how it handles ideal use cases.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的代码可能会失败。这可能是我们犯了编程错误，也可能是最终用户以我们没有预料到的方式使用我们的系统。有时，甚至可能是硬件故障；很多错误实际上不能真正归因于任何一个单一的来源，但它们会发生。我们的程序处理错误情况的方式通常和它处理理想使用情况的方式一样重要，甚至更重要。
- en: In this section, we're going to take a look at Java exceptions. Using Java exceptions,
    we can detect and catch, and in some cases recover from, errors that occur within
    our program. As we go through exceptions, there's something really important to
    keep in mind. Exceptions are called exceptions because they exist to handle exceptional
    cases, things that we either couldn't handle or couldn't anticipate when originally
    writing our code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一下Java异常。使用Java异常，我们可以检测、捕获，并在某些情况下从我们的程序中发生的错误中恢复。当我们处理异常时，有一件非常重要的事情要记住。异常之所以被称为异常，是因为它们存在于处理特殊情况，即我们在最初编写代码时无法处理或无法预料到的情况。
- en: Exceptions modify the control flow of our program, but we should never use them
    for anything other than catching and handling or passing exceptions. If we attempt
    to use them to implement logic, we'll make a program that will quickly become
    very confusing for us and will be immediately very confusing for any other programmer
    who attempts to understand it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 异常修改了我们程序的控制流，但我们绝不应该将它们用于除了捕获和处理或传递异常之外的任何其他用途。如果我们试图使用它们来实现逻辑，我们将制作一个对我们来说很快就会变得非常令人困惑，并且对于任何其他试图理解它的程序员来说立即变得非常令人困惑的程序。
- en: 'To help us explore Java exceptions, I''ve set up a basic program for us to
    play with; it is something that can fail. It''s an eternal loop that does two
    real things. First, it takes input from the user using the `nextFloat()` function
    of `Scanner`, then it prints that input back to the user:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们探索Java异常，我已经为我们设置了一个基本程序来玩耍；这是一个可能失败的东西。它是一个永恒的循环，做了两件真正的事情。首先，它使用`Scanner`的`nextFloat()`函数从用户那里获取输入，然后将该输入打印回用户：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we accurately assign floating-point values as input to this program, then
    the program will theoretically run forever, as shown in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将浮点值准确地分配为该程序的输入，那么该程序理论上将永远运行，如下面的屏幕截图所示：
- en: '![](img/b1fb966b-d867-438c-8a1d-211c5d62e9ba.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1fb966b-d867-438c-8a1d-211c5d62e9ba.png)'
- en: 'However, if we make a mistake and give this program a string as input, the
    `nextFloat()` function will not know what to do with it and an exception will
    occur:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们犯了一个错误，并给这个程序一个字符串作为输入，`nextFloat()`函数将不知道该怎么处理它，就会发生异常：
- en: '![](img/c39c4dd4-5866-4c87-bc24-27f820fca166.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c39c4dd4-5866-4c87-bc24-27f820fca166.png)'
- en: When this happens, we get red text in our console. This red text is actually
    going to the `System.err` stream.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，我们在控制台中会看到红色的文本。这些红色文本实际上是发送到`System.err`流中的。
- en: Analyzing the console exception messages
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析控制台异常消息
- en: Let's walk through the output text and understand what it means. There are two
    important sections in it. The first part of the output text, the bit that's not
    tabbed in, is the identifier of this exception. It lets us know that an exception
    has been thrown and where it has occurred. Then it tells us what type of exception
    has occurred. You'll notice that this exception is found in the `java.util` path
    (this part of the output looks very similar to whether we were importing something
    into our code or directly pathing to an external library). That's because this
    exception is actually a Java object, and our output text is letting us know exactly
    what type of object it is.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们浏览输出文本并理解它的含义。它有两个重要的部分。输出文本的第一部分，即没有缩进的部分，是这个异常的标识符。它让我们知道异常已经被抛出并且发生在哪里。然后它告诉我们发生了什么类型的异常。您会注意到这个异常在`java.util`路径中被发现（输出的这部分看起来非常类似于我们是否将某些东西导入到我们的代码中或直接将其路径到外部库）。这是因为这个异常实际上是一个Java对象，我们的输出文本让我们确切地知道它是什么类型的对象。
- en: The second bit of this exception test (the part that is tabbed) is what we call
    a stack trace. It's basically the pieces of our program that Java has jumped through.
    The very bottom of our stack trace is the location where the exception was originally
    thrown; in this case, it is `Scanner.java` and it is on line `909`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常测试的第二部分（缩进的部分）是我们称之为堆栈跟踪。基本上它是我们的程序中Java跳过的部分。堆栈跟踪的最底部是异常最初抛出的位置；在这种情况下，它是`Scanner.java`，位于第`909`行。
- en: That's not our code; that's the code written for `Scanner.java`, presumably
    where the `nextFloat()` method lives or code that the `nextFloat()` method calls.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 那不是我们的代码；那是为`Scanner.java`编写的代码，可能是`nextFloat()`方法所在的地方或`nextFloat()`方法调用的代码。
- en: Stack traces are layers of code, so once `InputMismatchException` occurs, Java
    begins to jump through these layers of code or bracketed areas until it eventually
    reaches the top layer where the code resides, that's `Exceptions.java` in our
    case. It's the file we've created, and it's at the top of the stack trace. Line
    11 of our `Exception.java` code file is the last place where Java was able to
    handle or throw this exception.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪是代码的层次，所以一旦发生`InputMismatchException`，Java就开始跳过这些代码层次或括号区域，直到最终达到代码所在的顶层，这在我们的情况下是`Exceptions.java`。这是我们创建的文件，它在堆栈跟踪的顶部。我们的`Exception.java`代码文件的第11行是Java能够处理或抛出这个异常的最后位置。
- en: Once line 11 was reached and the exception was still propagating upwards, there
    was nothing else to handle because it had reached the top of our program. So the
    exception ended by getting printed to our `System.err` stream and our program
    terminated with result `1`, which is a failure case.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦达到第11行并且异常仍在向上传播，就没有其他处理了，因为它已经达到了我们程序的顶部。因此，异常最终通过打印到我们的`System.err`流并且我们的程序以结果`1`终止，这是一个失败的情况。
- en: This is great for debugging purposes; we knew where we had to go to figure out
    what went wrong in our program, line 11 of `Exceptions.java`. But, if we were
    creating a program that we were looking to release for some reasonable purpose,
    we generally don't want our program to crash whenever a minor error were to occur,
    especially an input error such as this, which is perfectly reasonable for a user
    to make from time to time. So let's explore how we can handle exceptions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于调试目的来说非常好；我们知道我们必须去哪里找出程序出了什么问题，即`Exceptions.java`的第11行。但是，如果我们正在创建一个我们希望出于某种合理目的发布的程序，我们通常不希望我们的程序在发生次要错误时崩溃，特别是像这样的输入错误，这是用户偶尔会犯的错误。因此，让我们探讨一下如何处理异常。
- en: Handling exceptions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: When Java is told to throw an exception, it stops executing the current code
    block and begins jumping up levels until the exception is handled. That's how
    we moved from deep within the `Scanner.java` class' 909 line to line 11 of `Exceptions.java`,
    the piece in our code where, as far as we're concerned, the exception occurred.
    If our code were executed by another block of code, because we haven't handled
    this exception, instead of printing out to `System.err`, we'd simply throw the
    exception up another level. Due to this, they'd see line 11 of `Exception.java`
    in their stack trace.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java被告知抛出异常时，它会停止执行当前的代码块，并开始跳级，直到异常被处理。这就是我们从`Scanner.java`类的第909行深处跳转到`Exceptions.java`的第11行的方式，这是我们的代码中发生异常的地方。如果我们的代码被另一个代码块执行，因为我们没有处理这个异常，所以不会打印到`System.err`，我们只会将异常抛到另一个级别。因此，他们会在堆栈跟踪中看到`Exception.java`的第11行。
- en: However, sometimes it doesn't make sense to keep throwing an exception. Sometimes,
    we want to handle the exception case because we know what to do with it or because,
    as in the case we're dealing with right now, there are nicer ways to inform the
    user of what went wrong than just providing the stack trace and exception name.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时不断抛出异常是没有意义的。有时，我们希望处理异常情况，因为我们知道该如何处理它，或者因为，就像我们现在处理的情况一样，有比提供堆栈跟踪和异常名称更好的方式来告知用户出了什么问题。
- en: Additionally, if we handle this exception here, there's no reason that we can't
    resume our `while` loop as though nothing had happened. One failed case of this
    `while` loop isn't necessarily a reason to terminate our program. If we're going
    to handle exception cases, we're going to make use of the `try...catch` code blocks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们在这里处理异常，那么我们没有理由不能像什么都没有发生一样恢复我们的`while`循环。这个`while`循环的一个失败案例并不一定是终止我们的程序的理由。如果我们要处理异常情况，我们将使用`try...catch`代码块。
- en: The try and catch blocks
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: try和catch块
- en: In any block of code where we think an exception might be thrown and we'd like
    to handle the exception, we're going to wrap that line of code in a `try` block.
    For the most part, this doesn't affect how this code is executed unless an exception
    occurs within the `try` block. If an exception is thrown within the `try` block,
    instead of propagating that exception upward to the next level, the code within
    the following `catch` block will immediately get executed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们认为可能会抛出异常并且我们想处理异常的任何代码块中，我们将把该行代码包装在`try`块中。在大多数情况下，这不会影响代码的执行方式，除非在`try`块内发生异常。如果在`try`块内抛出异常，代码不会将异常传播到下一个级别，而是立即执行以下`catch`块中的代码。
- en: Note that `catch` blocks require a little more information before they can execute;
    they need to know what exactly they're going to catch. We can catch all exceptions
    by simply catching anything of the `Exception` class, but this may not be a fair
    thing to do. There's a lot of different schools of thought on exception handling,
    but generally, people will agree that you should only catch and handle exceptions
    that you, to some degree, expected might occur.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`catch`块在执行之前需要更多的信息；它们需要知道它们要捕获的确切内容。我们可以通过简单地捕获`Exception`类的任何内容来捕获所有异常，但这可能不是一个公平的做法。关于异常处理有很多不同的思路，但一般来说，人们会同意你应该只捕获和处理你在某种程度上预期可能发生的异常。
- en: 'In the example we saw, we know that `InputMismatchException` is thrown if we
    give invalid information through user input. Because we''re going to be printing
    out a message when this exception occurs, which specifically tells the user `Please
    enter a float number.`, we certainly don''t want to be catching any exceptions
    that are not `InputMismatchException`. So, we use the following code to catch
    `InputMismatchException`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到的例子中，我们知道如果我们通过用户输入提供无效信息，就会抛出`InputMismatchException`。因为当这种异常发生时，我们将打印一条消息，明确告诉用户`请输入一个浮点数。`，我们当然不希望捕获任何不是`InputMismatchException`的异常。因此，我们使用以下代码来捕获`InputMismatchException`：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we run this program, first we must quickly test that it works in a good
    use case, as it did before. Then, if we cause `InputMismatchException` to be thrown
    by providing the string input, we should see our catch block execute, and we should
    get the `Please enter a float number.` response:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，首先我们必须快速测试它在一个良好的用例中是否正常工作，就像以前一样。然后，如果我们通过提供字符串输入导致`InputMismatchException`被抛出，我们应该看到我们的catch块执行，并且我们应该得到`请输入一个浮点数。`的响应：
- en: '![](img/8c550cd6-7f09-4b4b-bf7b-fda46a559b08.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c550cd6-7f09-4b4b-bf7b-fda46a559b08.png)'
- en: Now, as you can see, we do get that response, but unfortunately, we're getting
    that response over and over again. We've inadvertently introduced an even worse
    bug. Now, instead of throwing an exception and crashing, our program just enters
    an infinite loop.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你所看到的，我们确实得到了那个响应，但不幸的是，我们一遍又一遍地得到了那个响应。我们无意中引入了一个更糟糕的错误。现在，我们的程序不是抛出异常并崩溃，而是进入了一个无限循环。
- en: 'Here''s why this happens: our `Scanner` object `reader` is a stream reader,
    which means there''s a buffer of input that it picks to read from. In a normal
    use case, when our infinite `while` loop executes, our user adds floating-point
    numbers to that buffer of input. We pick these out, print them, and go back to
    the start of the loop and wait for another. However, when a string is found in
    that buffer, the line of code where we call the `nextFloat()` function throws
    an exception, which is fine because we catch it with our catch block.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为什么会发生这种情况：我们的`Scanner`对象`reader`是一个流读取器，这意味着它有一个输入缓冲区供它读取。在正常的使用情况下，当我们的无限`while`循环执行时，我们的用户将浮点数添加到该输入缓冲区。我们提取这些内容，打印它们，然后返回循环的开始并等待另一个。然而，当该缓冲区中发现一个字符串时，我们调用`nextFloat()`函数的代码行会抛出一个异常，这没问题，因为我们用catch块捕获了它。
- en: Our catch block prints out the line of text telling the user that he/she gave
    invalid input and we go back to the beginning of the while loop. But, the bad
    string in our `reader` objects buffer is still there, so when we catch our exception,
    we will need to clear out that stream.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的catch块打印出一行文本，告诉用户他/她提供了无效的输入，然后我们回到while循环的开头。但是，我们`reader`对象缓冲区中的坏字符串仍然存在，因此当我们捕获异常时，我们需要清除该流。
- en: 'Fortunately, this is something we can handle. Once we''ve caught and handled
    our exception, we need to clear out the stream reader by simply grabbing its next
    line and doing nothing with its information. This will flush the `Please enter
    a float number.` line from the reader:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这是我们可以处理的事情。一旦我们捕获并处理了异常，我们需要清除流读取器，只需获取其下一行并不使用其信息。这将从读取器中刷新`Please enter
    a float number.`行：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we run our program now, we''ll see that it handles and recovers from a failed
    input where we give it a string, which is pretty cool:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行程序，我们会看到它处理并从失败的输入中恢复，我们给它一个字符串，这很酷：
- en: '![](img/dc6c1a2a-4cf6-4427-b9eb-0731597e7a41.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc6c1a2a-4cf6-4427-b9eb-0731597e7a41.png)'
- en: Let's go over a couple of more things we can do with exceptions. For one, clearing
    out our reader at the end of an exception case makes a lot of sense, but it might
    make even more sense to clear out our reader at the end of any attempted case.
    After all, we're entering this `while` loop with the assumption that there's no
    new line in the reader. So, to implement this, we have the `finally` block.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再讨论一些我们可以处理异常的事情。首先，在异常情况结束时清除我们的读取器是有很多意义的，但在任何尝试的情况结束时清除我们的读取器可能更有意义。毕竟，我们进入这个`while`循环的假设是读取器中没有新行。因此，为了实现这一点，我们有`finally`块。
- en: The finally block
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的块
- en: If we'd like to execute a case always, no matter whether we did or did not succeed
    in our `try` block, we can follow our `catch` block with the `finally` block.
    The `finally` block executes no matter what, whether an exception was or was not
    caught. This exists so that you can put cleanup code in your system. An example
    of cleanup code is clearing out our `reader` objects buffer so that there's nothing
    there to confuse ourselves later or other programmers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要无论我们在`try`块中是否成功，都要执行一个案例，我们可以在`catch`块后面跟着`finally`块。`finally`块无论如何都会执行，无论是否捕获了异常。这是为了让您可以在系统中放置清理代码。清理代码的一个例子是清除我们的`reader`对象缓冲区，以便以后或其他程序员不会困惑。
- en: Exceptions are more than a simple object that gets thrown; they can contain
    a lot of really important information. As we saw earlier, exceptions can contain
    a stack trace. Let's quickly modify our program so that while it still gives user-friendly
    `Please enter a float number.` information, it also prints out the stack trace
    so that a programmer can debug our program.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 异常不仅仅是一个简单的被抛出的对象；它们可能包含很多非常重要的信息。正如我们之前看到的，异常可能包含堆栈跟踪。让我们快速修改我们的程序，以便在它仍然提供用户友好的`Please
    enter a float number.`信息的同时，也打印出堆栈跟踪，以便程序员可以调试我们的程序。
- en: Generally, when we're writing finished code that a user is going to utilize,
    we never want a case where they would be able to see something as deep as a stack
    trace. It's confusing for most computer users and can be a security risk in some
    instances, but as a feature in a debug mode or for developers, detailed exceptions
    such as these can be very useful.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们编写用户将要使用的完成代码时，我们永远不希望出现他们能够看到像堆栈跟踪这样深的东西。对大多数计算机用户来说这很困惑，并且在某些情况下可能构成安全风险，但作为调试模式或开发人员的功能，这些详细的异常可能非常有用。
- en: 'The `Exception` class exposes a method called `printStackTrace()`, which requires
    a stream as input. We''ve been using `System.out` for all of our output so far,
    so we''ll provide the `printStackTrace()` method with `System.out` as its stream:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exception`类公开了一个名为`printStackTrace()`的方法，它需要一个流作为输入。到目前为止，我们一直在使用`System.out`作为所有输出，所以我们将为`printStackTrace()`方法提供`System.out`作为其流：'
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now when we run our program and give it a bad string, we get our initial friendly
    exception text code. However, we still have the stack trace, so we can exactly
    see where the errors are coming from:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行程序并给出一个错误的字符串时，我们会得到我们最初友好的异常文本代码。但是，我们仍然有堆栈跟踪，因此我们可以准确地看到错误的来源：
- en: '![](img/2d5302f8-3d50-45d1-b9af-75e200a5bb84.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d5302f8-3d50-45d1-b9af-75e200a5bb84.png)'
- en: As I mentioned earlier, exception handling is an extremely deep topic in modern
    software development, but at the end of this section, you should have a firm hand
    on the basics. When you come across exceptions in code or when you're writing
    your own code and feel that you need exception handling, you should be well prepared.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，异常处理是现代软件开发中一个非常深入的主题，但在本节结束时，您应该对基础知识有所了解。当您在代码中遇到异常或者在编写自己的代码时感到需要异常处理时，您应该做好充分的准备。
- en: The Object class
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象类
- en: 'In this section, we''re going to learn some very important things about how
    Java has chosen to implement object-oriented programming. We''re going to be exploring
    the `Object` class itself. To get us started, I''ve written a really basic program:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习关于Java如何选择实现面向对象编程的一些非常重要的内容。我们将探索`Object`类本身。为了开始，我写了一个非常基本的程序：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This program utilizes a custom class called `MyClass` and creates two instances
    of this class: `object1` and `object2`. We then call a void `MyMethod` method
    on each of these objects, which simply prints out the value that we''ve given
    them to contain. Then, the program compares these objects.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序利用了一个名为`MyClass`的自定义类，并创建了这个类的两个实例：`object1`和`object2`。然后，我们在这些对象上调用了一个名为`MyMethod`的void方法，该方法简单地打印出我们给它们的值。然后，程序比较了这些对象。
- en: We first compare using the comparison operator (`==`) that checks whether these
    two objects are actually the same object. We know that this will not be true because
    we can see that the objects were instantiated completely independent of each other.
    They share a class, but they are two different instances of the `MyClass` class.
    We then compared these objects using the `equals()` method, which we'll be talking
    about a lot in this section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用比较运算符（`==`）进行比较，检查这两个对象是否实际上是同一个对象。我们知道这不会是真的，因为我们可以看到这些对象是完全独立实例化的。它们共享一个类，但它们是`MyClass`类的两个不同实例。然后，我们使用`equals()`方法比较这些对象，在本节中我们将经常讨论这个方法。
- en: 'When we run this program, we see that the objects are found not to be the same
    when compared by the comparison operator, which is what we would expect. But,
    we also see that when they''re compared using the `equals()` method, the objects
    are found not to be equal, even though the objects were both created under the
    same parameters and had the exact same things done to them from their creation
    to this point in time. Following is the output of the preceding code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，我们看到当使用比较运算符进行比较时，对象被发现不相同，这是我们所期望的。但是，我们还看到当它们使用`equals()`方法进行比较时，尽管这两个对象是在相同的参数下创建的，并且从它们的创建到现在做了完全相同的事情，但这两个对象被发现不相等。以下是上述代码的输出：
- en: '![](img/ccc58e6f-859d-494a-b94a-94f4cd1be784.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccc58e6f-859d-494a-b94a-94f4cd1be784.png)'
- en: So, what does it mean when objects are not found to be equal by the `equals()`
    method? The first question we should ask ourselves is, where does this `equals()`
    method come from or where is it implemented?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当`equals()`方法发现对象不相等时，这意味着什么？我们应该问自己的第一个问题是，`equals()`方法来自哪里或者它是在哪里实现的？
- en: If we go by the definition of the `MyClass` class, we don't actually find an
    `equals()` method, which is pretty weird because `MyClass` is not declared to
    be inheriting from any superclass, but `equals()` is called directly on the `MyClass`
    instance. In reality, `MyClass`, as with all Java classes, does inherit from a
    superclass. At the very top of every class inheritance tree, there is the `Object`
    class, even though it's not explicitly declared in our code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照`MyClass`类的定义，实际上找不到`equals()`方法，这是非常奇怪的，因为`MyClass`并没有声明从任何超类继承，但`equals()`直接在`MyClass`实例上调用。实际上，`MyClass`，就像所有的Java类一样，都继承自一个超类。在每个类继承树的顶部，都有`Object`类，即使它在我们的代码中没有明确声明。
- en: 'If we head to the Java documentation ([docs.oracle.com/javase/7/docs/api/java/lang/Object.html](http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html))
    and look up the `Object` class, we will find this definition: "Class `Object`
    is the root of the class hierarchy. Every class has `Object` as a superclass.
    All objects, including arrays, implement the methods of this class." Then, if
    we scroll down the page, we get a short but very important list of methods:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们前往Java文档（[docs.oracle.com/javase/7/docs/api/java/lang/Object.html](http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)）并查找`Object`类，我们会找到这样的定义：“`Object`类是类层次结构的根。每个类都有`Object`作为超类。所有对象，包括数组，都实现了这个类的方法。”然后，如果我们滚动页面，我们会得到一个简短但非常重要的方法列表：
- en: '![](img/47b9097e-61a6-4de3-999d-9e2524a7dd8a.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47b9097e-61a6-4de3-999d-9e2524a7dd8a.png)'
- en: Because all Java objects inherit from the `Object` class, we can safely assume
    that any Java object we're dealing with implements each of the methods here. Among
    these methods is the `equals()` method that we were just talking about and trying
    to figure out where it came from. This makes it very clear to us that `MyClass`
    is inheriting the `equals()` method from its `Object` superclass.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有的Java对象都继承自`Object`类，我们可以安全地假设我们正在处理的任何Java对象都实现了这里的每个方法。在这些方法中，就包括我们刚刚讨论并试图找出其来源的`equals()`方法。这让我们非常清楚，`MyClass`正在从它的`Object`超类中继承`equals()`方法。
- en: The definition of the `equals()` method at the object level is very vague. It
    says, "Indicates whether some other object is **equal** to this one." To some
    degree, this vagueness leaves it up to us, as programmers, to determine what equality
    really means on a class-by-class basis.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象级别上，`equals()`方法的定义非常模糊。它说：“指示某个其他对象是否**等于**这个对象。”在某种程度上，这种模糊性让我们作为程序员来决定在逐个类的基础上真正意味着什么是相等的。
- en: Let's say we come to the decision, the reasonable decision, that `object1` and
    `object2` should be determined to be equal to each other if the values they contain
    are identical. If we make this decision, then the current implementation of our
    program is not quite correct because it's currently telling us that `object1`
    and `object2` are not equal. In order to change this, we're going to need to override
    the `equals()` method in `MyClass`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们做出决定，合理的决定，即如果它们包含的值相同，那么`object1`和`object2`应该被确定为相等。如果我们做出这个决定，那么我们当前程序的实现就不太正确，因为它目前告诉我们`object1`和`object2`不相等。为了改变这一点，我们需要重写`MyClass`中的`equals()`方法。
- en: Overriding the equals() method
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写equals()方法
- en: Overriding an `Object` class method is no more difficult than overriding the
    method for any other superclass. We simply declare an identical method, and this
    specific method will be used when appropriate, when we're dealing with a `MyClass`
    object. It's important for us to notice that the `equals()` method does not take
    a `MyClass` object as input; it takes any object as input. So, before we can go
    ahead and compare this object's value with the value of our current `MyClass`
    objects, we need to protect ourselves and make sure that the object given as input
    is actually a `MyClass` object.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖`Object`类方法并不比覆盖任何其他超类的方法更困难。我们只需声明一个相同的方法，当我们处理`MyClass`对象时，这个特定的方法将在适当的时候被使用。重要的是要注意，`equals()`方法不以`MyClass`对象作为输入；它以任何对象作为输入。因此，在我们继续比较这个对象的值与我们当前`MyClass`对象的值之前，我们需要保护自己，并确保作为输入的对象实际上是一个`MyClass`对象。
- en: 'To do this, let''s check some bad cases where we would want our program to
    simply go ahead and return `false` without even comparing the inner values of
    these objects:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们检查一些坏的情况，我们希望我们的程序只需返回`false`，甚至不比较这些对象的内部值：
- en: If we've been given an object that hasn't actually been instantiated, a pointer,
    or a null pointer, we'd simply want to return `false` because our instantiated
    `MyClass` object is not equivalent to nothing at all.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们得到的对象实际上没有被实例化，是一个指针，或者是一个空指针，我们只需返回`false`，因为我们实例化的`MyClass`对象与什么都不等价。
- en: 'The more difficult question is this: Is the object that we''ve been given to
    compare, an instance of `MyClass`? Let''s check the opposite of this; let''s confirm
    that this object is not an instance of `MyClass`. The `instanceof` keyword lets
    us see what classes an object has within its repertoire. If our `instanceof` statement
    does not evaluate to `true`, we simply want to return `false` because we''d be
    comparing a `MyClass` object with an object that is not a `MyClass` object.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更困难的问题是：我们得到的用于比较的对象是`MyClass`的一个实例吗？让我们检查相反的情况；让我们确认这个对象不是`MyClass`的一个实例。`instanceof`关键字让我们看到一个对象在其库存中有哪些类。如果我们的`instanceof`语句不评估为`true`，我们只需返回`false`，因为我们将比较一个`MyClass`对象和一个不是`MyClass`对象的对象。
- en: 'Once we''ve made it through these hoops successfully, it''s safe for us to
    assume that we can cast a given object to a `MyClass` object. Now we can simply
    compare the value fields they contain and return the appropriate value. Let''s
    write the following code to our `MyClass.java` file and jump back to our `main()`
    method to run it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们成功地通过了这些障碍，我们就可以安全地假设我们可以将给定的对象转换为`MyClass`对象。现在我们只需比较它们包含的值字段并返回适当的值。让我们将以下代码写入我们的`MyClass.java`文件，并返回到我们的`main()`方法来运行它：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we run this program, we will see that `object1` and `object2` are found
    to be equal to each other:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，我们会看到`object1`和`object2`被发现相互等价：
- en: '![](img/8404f7a6-5e88-4f4b-aa20-e57d5c784790.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8404f7a6-5e88-4f4b-aa20-e57d5c784790.png)'
- en: Other Object methods
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他Object方法
- en: The `Object` class declares a number of methods. In addition to `equals()`,
    some important methods are `hashCode()` and `toString()`. We're not going to implement
    `hashCode()` in this section because it requires us to do a little more math than
    is really wieldy, but I would very much recommend that you check out how `hashCode()`
    works by going to the documentation and exploring it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object`类声明了许多方法。除了`equals()`之外，一些重要的方法是`hashCode()`和`toString()`。在本节中，我们不会实现`hashCode()`，因为它需要我们做比较复杂的数学运算，但我强烈建议你查看`hashCode()`的工作原理，方法是查看文档并探索它。'
- en: For now, let's just know that an object's `hashCode()` method should return
    an integer value that describes that particular object. In all instances, if two
    objects are found to be equal through the `equals()` method, their `hashCode()`
    functions should also return the same integer value. If two objects are not equal,
    as far as the `equals()` method is concerned, their `hashCode()` functions should
    return different values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们只知道一个对象的`hashCode()`方法应该返回一个描述该特定对象的整数值。在所有情况下，如果两个对象通过`equals()`方法被发现相等，它们的`hashCode()`函数也应该返回相同的整数值。如果两个对象不相等，就`equals()`方法而言，它们的`hashCode()`函数应该返回不同的值。
- en: At this point in time, we should be familiar with the `toString()` method. This
    is also a method in the `Object` class, meaning that we can call the `toString()`
    method on any single object. But, in our custom objects, until we've overridden
    `toString()`, it's probably not going to return meaningful, human-readable information.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该熟悉`toString()`方法。这也是`Object`类中的一个方法，这意味着我们可以在任何单个对象上调用`toString()`方法。但是，在我们的自定义对象中，直到我们覆盖`toString()`，它可能不会返回有意义的、可读的信息。
- en: As you learn Java, I highly recommend that you implement `equals()` and `toString()`,
    even on the small little test classes you write while learning. It's a great habit
    to get into, and it keeps you thinking about object-oriented programming in the
    same way that Java does. When we create finalized software projects where we have
    public classes that other programmers may someday be using, we should be very
    careful that all our classes properly implement these methods in an understandable
    manner. This is because Java programmers will expect to be able to utilize these
    methods to manipulate and understand our classes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你学习Java时，我强烈建议你实现`equals()`和`toString()`，即使是在你学习时编写的小测试类上也是如此。这是一个很好的习惯，并且它让你以Java相同的方式思考面向对象编程。当我们创建最终的软件项目，其中有其他程序员可能会使用的公共类时，我们应该非常小心，确保所有我们的类以可理解的方式正确实现这些方法。这是因为Java程序员希望能够利用这些方法来操作和理解我们的类。
- en: Primitive classes
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类
- en: In this section, I'd like to take a very quick look at the primitive classes
    available to us in Java. In Java, we often say that strings are special because
    they have a literal interpretation identified by these double quotation marks;
    however, we still interact with them primarily through the `String` class, rather
    than a `string` primitive type that is not actually available to us.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我想快速看一下Java中可用的原始类。在Java中，我们经常说字符串很特殊，因为它们有一个由双引号标识的文字解释；然而，我们主要通过`String`类与它们交互，而不是通过我们实际上无法使用的`string`原始类型。
- en: 'In the case of a standard Java primitive, however, we generally interact with
    it through its primitive typing method. For every primitive type, we do have a
    corresponding primitive class. These are the `Integer`, `Character`, and `Float`
    classes and so on. For the most part, the explicit uses of these classes where
    we create an instance of them and then call methods on that instance are not very
    useful unless we''re overriding them to create a class of our own. Let''s look
    at the following program:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在标准的Java原始类型中，我们通常通过其原始类型方法与其交互。对于每种原始类型，我们都有一个相应的原始类。这些是`Integer`、`Character`和`Float`类等。在大多数情况下，我们创建一个实例然后在该实例上调用方法的显式使用并不是很有用，除非我们重写它们以创建自己的类。让我们看一下以下程序：
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The methods given to us by the instance `c` of the `Character` class are primarily
    conversion methods as shown in the following screenshot that would happen automatically
    or that we could simply cast to:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Character`类的实例`c`给我们的方法主要是转换方法，如下面的屏幕截图所示，这些方法将自动发生，或者我们可以简单地进行转换： '
- en: '![](img/68d33633-94fb-4a1a-a536-5e5695e2bfcc.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68d33633-94fb-4a1a-a536-5e5695e2bfcc.png)'
- en: Note that `compareTo()` is sometimes useful, though. It returns an integer value
    `0` if the other character given is equivalent and less than `0` or greater than
    `0`, depending on which side of the integer conversion scale the two characters
    fall in relation to each other.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`compareTo()`有时也很有用。如果给定的其他字符等于并且小于`0`或大于`0`，则返回整数值`0`，具体取决于两个字符在整数转换比例中相对于彼此的位置。
- en: 'However, often we may find ourselves using the static methods of these primitive
    classes to manipulate or get information from instances of the primitive types.
    For example, if I want to know whether our character `C` is lowercase, I can certainly
    convert it into an integer value, check an ASCII table, and then see whether that
    integer value falls between the range of lowercase characters. But, that''s a
    whole lot of work:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常我们可能会发现自己使用这些原始类的静态方法来操作或从原始类型的实例中获取信息。例如，如果我想知道我们的字符`C`是否是小写，我当然可以将它转换为整数值，查看ASCII表，然后看看该整数值是否落在小写字符的范围内。但是，这是一项繁重的工作：
- en: '![](img/05e99a92-cd67-499e-bd6c-4af194773208.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05e99a92-cd67-499e-bd6c-4af194773208.png)'
- en: 'The `Character` primitive class provides a static function for me, `isLowercase()`,
    as shown in the preceding screenshot, which will tell me whether a character is
    lowercase or not. Let''s run the following program:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Character`原始类为我提供了一个静态函数`isLowercase()`，如前面的屏幕截图所示，它将告诉我一个字符是否是小写。让我们运行以下程序：'
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Following is the output of the preceding code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/83f738f6-0dc7-4675-85cb-e0c051b8add4.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83f738f6-0dc7-4675-85cb-e0c051b8add4.png)'
- en: 'That''s really the gist of primitive functions. We can interact with the other
    literal types and their primitive types in the same manner: interact with strings
    using a class if we so choose.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是原始函数的要点。我们可以以相同的方式与其他文字类型及其原始类型进行交互：如果愿意，可以使用类与字符串交互。
- en: When we don't need the functionality of a primitive class, we should continue
    using primitive types (for example, use `char` instead of `Character`). The presence
    of the syntax highlighting feature and universal look of these primitive types
    across languages makes them much more friendly for programmers to work with.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不需要原始类的功能时，应继续使用原始类型（例如，使用`char`而不是`Character`）。语法高亮功能的存在以及这些原始类型在各种语言中的统一外观使它们更加友好，便于程序员使用。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the `Calendar` class of Java to work with dates
    and times. We saw the `String` class in detail. We also saw what exceptions are
    and how to handle them to make our programs more robust. Then, we walked through
    the `Object` class and some of its methods. Finally, we looked at the primitive
    classes of Java.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了Java的`Calendar`类来处理日期和时间。我们详细了解了`String`类。我们还了解了异常是什么，以及如何处理它们使我们的程序更加健壮。然后，我们走过了`Object`类及其一些方法。最后，我们看了Java的原始类。
- en: In the next chapter, we'll look at how to process files using Java.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用Java处理文件。
