- en: Chapter 9. Testing Code and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。测试代码和调试
- en: '"A bug free product is a myth" is a common phrase in the development industry.
    A problem-free and issue-free application or any other product is rationally not
    possible. However, the developer can always minimize the number of bugs and issues
    so that the game can run with the fewest possible problems and support the most
    platforms with the maximum possible efficiency.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “无bug的产品是一个神话”是开发行业中常见的短语。一个无问题和无故障的应用程序或任何其他产品在理性上是不可能的。然而，开发人员总是可以尽量减少bug和问题的数量，以便游戏可以尽可能少地出现问题，并以最大可能的效率支持最多的平台。
- en: 'We will discuss the scope of various debugging aspects in Android game development
    through the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下主题讨论Android游戏开发中各种调试方面的范围：
- en: Android AVDs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android AVD
- en: Android DDMS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android DDMS
- en: Android device debugging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android设备调试
- en: Monitoring the memory footprint
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控内存占用
- en: Strategic placement of different debug statements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同调试语句的战略放置
- en: Exception handling in Android games
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android游戏中的异常处理
- en: Debugging for Android while working with cross-platform engines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在跨平台引擎中工作时调试Android
- en: Best testing practices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳测试实践
- en: Android AVDs
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android AVD
- en: AVDs are the most significant and important part of debugging Android games.
    In the initial stages, the concept started with an emulator. There are a few predefined
    emulators that can be used to run the build on a development PC. An Android emulator
    provides an interface of a real-time-like device.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: AVD是调试Android游戏最重要和重要的部分。在最初阶段，该概念始于模拟器。有一些预定义的模拟器可以用于在开发PC上运行构建。Android模拟器提供了类似实时设备的界面。
- en: AVDs have a few features that virtually provide the device RAM, Android version,
    screen size, display dpi, keyboard, and different visual skins. Older AVDs mostly
    looked the same.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: AVD具有一些功能，可以提供设备RAM、Android版本、屏幕大小、显示dpi、键盘和不同的视觉皮肤。旧版AVD大多看起来都一样。
- en: '![Android AVDs](img/B05069_09_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Android AVDs](img/B05069_09_01.jpg)'
- en: In the current version of Android Studio, most of the Android device categories
    are provided. Developers can create AVDs as per the target development platform.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前版本的Android Studio中，提供了大多数Android设备类别。开发人员可以根据目标开发平台创建AVD。
- en: 'The categories are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类别如下：
- en: Android mobile phones
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android手机
- en: Android tablets
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android平板电脑
- en: Android TVs
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android电视
- en: Android wearables
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android可穿戴设备
- en: AVDs can be created or manipulated by the AVD manager tool provided within the
    Android SDK. Each and every attribute of AVD can be managed by the AVD manager.
    This tool can also help the developer to create a custom AVD.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: AVD可以通过Android SDK中提供的AVD管理器工具来创建或操作。AVD管理器可以管理AVD的每个属性。该工具还可以帮助开发人员创建自定义AVD。
- en: 'Let''s have a look at the attribute factors for each different AVD:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看每个不同AVD的属性因素：
- en: Name
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: Resolution
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分辨率
- en: Display size
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示尺寸
- en: Android version API level
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android版本API级别
- en: Android target version
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android目标版本
- en: CPU architecture
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU架构
- en: RAM amount
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM数量
- en: Hardware input options
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件输入选项
- en: Other options
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他选项
- en: Extended AVD settings and creation
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展AVD设置和创建
- en: Name of the AVD
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AVD的名称
- en: The name is only to identify the AVD. Anything can assigned to it, and it can
    be changed later. Predefined AVD names can also be changed at the time of creation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 名称仅用于识别AVD。可以分配任何内容，并且以后可以更改。在创建时也可以更改预定义的AVD名称。
- en: AVD resolution
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AVD分辨率
- en: AVD resolution is one of the most important factors for visibility. There are
    some predefined resolution standards, but they can also be changed. Nowadays,
    mostly, developers pick resolutions that are widely used on an actual hardware
    platform.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: AVD分辨率是可见性的最重要因素之一。有一些预定义的分辨率标准，但它们也可以更改。如今，大多数开发人员选择在实际硬件平台上广泛使用的分辨率。
- en: One more use of resolution is to check and verify the display portability of
    games. Mostly, games are made in a target base resolution. Then, the game can
    be tested on various resolutions to check the compatibility.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 分辨率的另一个用途是检查和验证游戏的显示可移植性。大多数游戏都是以目标分辨率制作的。然后，可以在各种分辨率上测试游戏以检查兼容性。
- en: Normally, multiple resolutions would create any issues if the aspect ratio is
    the same. However, in the case of Android, we can find multiple aspect ratios
    for different devices. The resolution factor of AVD helps fit the game and check
    its compatibility for multiple aspect ratios as well.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果纵横比相同，多个分辨率不会产生任何问题。然而，在Android的情况下，我们可以找到不同设备的多个纵横比。AVD的分辨率因子有助于适应游戏并检查其在多个纵横比下的兼容性。
- en: AVD display size
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AVD显示尺寸
- en: This is the visible space or visible display area on an AVD. One high-resolution
    AVD can have a small display area. It directly implies that the AVD has a high
    dpi value, which means a higher display quality.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是AVD上的可见空间或可见显示区域。一个高分辨率的AVD可以有一个小的显示区域。这直接意味着AVD具有高dpi值，这意味着更高的显示质量。
- en: This section of AVD helps ensure the visual quality of the game. However, it
    is not always possible to set the actual display region in the development system
    as the development system has its own display limit.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: AVD的这一部分有助于确保游戏的视觉质量。然而，在开发系统中设置实际显示区域并不总是可能的，因为开发系统有自己的显示限制。
- en: Android version API level
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android版本API级别
- en: While developing an Android game, the developer needs to limit the API usage
    to a certain version. The API version can be deprecated in future versions of
    Android or even discontinued. To check this factor, the developer can set an API
    version for AVD.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Android游戏时，开发人员需要将API使用限制在某个版本上。API版本可能会在将来的Android版本中被弃用，甚至停止使用。为了检查这一因素，开发人员可以为AVD设置API版本。
- en: Android target version
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android目标版本
- en: This is the Android version that will be used to run the AVD. This can verify
    the manifest target Android version and minimum version range.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将用于运行AVD的Android版本。这可以验证清单目标Android版本和最低版本范围。
- en: CPU architecture
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU架构
- en: 'Android devices mainly use three types of CPU architecture: armeabi, armeabi-v7,
    and x86\. This does not have a direct impact on games. However, the processing
    speed and quality varies with CPU architecture.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备主要使用三种CPU架构：armeabi、armeabi-v7和x86。这对游戏没有直接影响。然而，处理速度和质量会随着CPU架构的不同而有所变化。
- en: The developer should keep in mind that actual game performance on a real device
    with a different CPU architecture will always perform differently than an AVD.
    So, it may give the developer an idea of performance, but it needs to be tested
    on a real device.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员应该记住，实际设备上具有不同CPU架构的游戏性能总是会与AVD上的表现不同。因此，它可能给开发人员一个性能的想法，但需要在实际设备上进行测试。
- en: RAM amount
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RAM数量
- en: RAM amount specifies the total amount of memory that the AVD has, which can
    be used to check the memory consumption of the game at various levels.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: RAM数量指定了AVD可用的总内存量，可用于检查游戏在各个级别的内存消耗。
- en: It is best to predict the memory overflow issue for various devices. By running
    multiple apps at a time, a real-time clone can be created with the AVD. The default
    value is set to 66 MB. The developer can set any value according to the requirement.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最好预测各种设备的内存溢出问题。通过在AVD上同时运行多个应用程序，可以创建一个实时克隆。默认值设置为66MB。开发人员可以根据需求设置任何值。
- en: External storage can be also defined as an SD card for a virtual device.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 外部存储也可以定义为虚拟设备的SD卡。
- en: Hardware input options
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件输入选项
- en: 'In Android devices, there can be many types of hardware input distributed within
    a wide range of hardwires. The most common variations are as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android设备上，可以有许多类型的硬件输入分布在各种硬件中。最常见的变体如下：
- en: Touch screen
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸屏
- en: Touch pad
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸板
- en: Key pad
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘
- en: Custom controller
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义控制器
- en: Hardware buttons
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件按钮
- en: Many hardware platforms have opted for a combination of these variants. An AVD
    creates a virtual system for all of these input systems.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 许多硬件平台选择了这些变体的组合。AVD为所有这些输入系统创建了一个虚拟系统。
- en: Other options
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他选项
- en: There are a few other options that are readily available for manipulation. If
    the development system has a camera attached to it, then the AVD can also use
    a camera, both front and back.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他选项可供操作。如果开发系统连接了摄像头，那么AVD也可以使用前置和后置摄像头。
- en: Additionally, virtual accelerometers, sensors, and so on can be associated with
    an AVD.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，虚拟加速计、传感器等可以与AVD关联。
- en: Extended AVD settings
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展AVD设置
- en: A custom AVD can be made through a modern AVD manager tool. A developer can
    design a virtual device with a custom look and feel, and with complete custom
    hardware configuration.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过现代AVD管理工具可以制作自定义AVD。开发人员可以设计具有自定义外观和完全自定义硬件配置的虚拟设备。
- en: Android DDMS
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android DDMS
- en: DDMS can be used to analyze a running application for all run-time details such
    as memory consumption, process calls, and so on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: DDMS可用于分析运行中应用程序的所有运行时详细信息，如内存消耗、进程调用等。
- en: The main functions of Android DDMS are port providing, screen capture on a device,
    thread details, heap details, and Logcat processing. This service can be used
    for spoofing calls and messaging.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Android DDMS的主要功能是提供端口、在设备上进行屏幕截图、线程详细信息、堆详细信息和Logcat处理。此服务可用于欺骗呼叫和短信。
- en: 'Android DDMS is widely used for device debugging. Particularly in the game
    development procedure, it is often used as a line-by-line debugging system. This
    is very useful to identify unwanted loaded objects and assets, and to track runtime
    exceptions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Android DDMS广泛用于设备调试。特别是在游戏开发过程中，它经常被用作逐行调试系统。这对于识别不需要的加载对象和资产，以及跟踪运行时异常非常有用：
- en: '![Android DDMS](img/B05069_09_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Android DDMS](img/B05069_09_02.jpg)'
- en: Android DDMS can be used to carry out the following activities.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Android DDMS可用于执行以下活动。
- en: Connecting an Android device filesystem
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接Android设备文件系统
- en: DDMS can connect to a device filesystem and provide a file browser-based operation
    to copy, modify, or delete any file on the device through a PC. This method or
    feature, however, is not very important for Android game development.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: DDMS可以连接到设备文件系统，并提供基于文件浏览器的操作，通过PC在设备上复制、修改或删除任何文件。然而，这种方法或功能对Android游戏开发并不是非常重要。
- en: Profiling methods
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析方法
- en: 'Another interesting DDMS feature is profiling or tracing matrices of certain
    methods. It gives information on the following topics:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的DDMS功能是对某些方法的分析或跟踪矩阵。它提供以下主题的信息：
- en: Execution time
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行时间
- en: Number of operations
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作次数
- en: Number of cells
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格数量
- en: Memory use during execution
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行期间的内存使用
- en: Extending this feature, the developer can even gain control over profiling the
    data of a method by calling `startMethodTracing()` and `stopMethodTracing()`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展此功能，开发人员甚至可以通过调用`startMethodTracing()`和`stopMethodTracing()`来控制方法的数据分析。
- en: 'The developer needs to keep an eye on two things:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员需要关注两件事：
- en: Up to Android 2.1, it is mandatory to have an SD card installed on the device
    with the application's permission to read/write on it
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android 2.1之前，设备上必须安装有SD卡，并且应用程序需要有读写权限
- en: From Android 2.2 onward, the device can stream profiling data directly to the
    development PC
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Android 2.2开始，设备可以直接将分析数据流式传输到开发PC
- en: Thread information monitoring
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程信息监控
- en: DDMS provides details on each thread running for each process on a selected
    device. However, games mostly run on a single thread. As devices are getting better
    each day, games are also using the multithreading feature to support various operations
    such as rendering, processing, file I/O, and networking.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: DDMS提供了所选设备上每个进程运行的每个线程的详细信息。然而，游戏大多在单个线程上运行。随着设备的不断改进，游戏也在使用多线程功能来支持渲染、处理、文件I/O和网络等各种操作。
- en: Heap information monitoring
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆信息监控
- en: DDMS provides heap usage at runtime for a running process. It is very useful
    for game developers to track the game process heap during execution.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: DDMS为运行中的进程提供了堆使用情况。对于游戏开发人员来说，跟踪执行期间的游戏进程堆非常有用。
- en: Tracking memory allocation
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪内存分配
- en: This is very useful for tracking each and every memory allocation of runtime
    objects. This gives every detail on each specific object of each class. This means
    the developer can find out which class is taking exactly how much memory. This
    helps achieve memory optimization in a much more efficient way.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于跟踪运行时对象的每个内存分配非常有用。这可以给出每个类的每个特定对象的每个细节。这意味着开发人员可以找出每个类占用多少内存。这有助于以更有效的方式实现内存优化。
- en: Monitoring and managing network traffic
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控和管理网络流量
- en: From Android 4.0 onwards, DDMS features a **Detailed Network Usage** tab to
    track when a game makes network requests. Using this feature, the developer can
    monitor network data transfer. This option can be very useful to optimize network
    development. It can distinguish between different traffic types by applying a
    "tag" to network sockets before use.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android 4.0开始，DDMS具有**详细网络使用**选项卡，用于跟踪游戏何时发出网络请求。使用此功能，开发人员可以监视网络数据传输。这个选项对于优化网络开发非常有用。它可以通过在使用网络套接字之前对其应用“标签”来区分不同的流量类型。
- en: Tracking log information using Logcat
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Logcat跟踪日志信息
- en: Logs are the most useful debugging technique for tracking almost anything. It
    is a good practice to use logs properly to check the data or value of certain
    objects during runtime. It is very useful for logic development for games.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是跟踪几乎任何东西的最有用的调试技术。在运行时正确使用日志来检查某些对象的数据或值是一个很好的实践。对于游戏的逻辑开发非常有用。
- en: In game development, logical requirements will be different for different games.
    So, there must be a good amount of code that is written for the first time. Predefined
    test cases are not available. This deficiency can be overcome using Logcat from
    DDMS.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，不同游戏的逻辑需求将不同。因此，必须有大量的代码是第一次编写的。预定义的测试用例是不可用的。可以使用DDMS中的Logcat来克服这种不足。
- en: 'Logcat provides log information in the following types:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Logcat提供以下类型的日志信息：
- en: Verbose
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冗长的
- en: Debug
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: Error
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Warning
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告
- en: Information
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息
- en: Emulating device operations
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟设备操作
- en: As we discussed Android virtual devices earlier, DDMS can work upon AVDs as
    well. So, it becomes much easier to emulate a real-time scenario to debug the
    game being developed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的Android虚拟设备一样，DDMS也可以在AVD上工作。因此，模拟实时场景以调试正在开发的游戏变得更加容易。
- en: 'The most commonly used emulations are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的仿真如下：
- en: Emulating an incoming phone call
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟来电
- en: Emulating an incoming message
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟收到消息
- en: Emulating network state change during runtime
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟运行时网络状态更改
- en: These three are the most common scenarios at runtime. So, these situations can
    be checked without a physical device. Interruption handling has been difficult
    for Android devices since the beginning. As a matter of fact, this can be a nightmare
    for a programmer if interrupts are not handled properly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种情况是运行时最常见的情况。因此，这些情况可以在没有物理设备的情况下进行检查。自Android设备开始以来，中断处理一直是困难的。事实上，如果中断没有得到正确处理，这对程序员来说可能是一场噩梦。
- en: There are some common problems of crashing/freezing/restarting the game after
    an interrupt. Many times, some unnecessary services or processes can be interrupts,
    and they may change the game state during the interruption period. Emulating every
    possible interrupt on an AVD is always an added advantage to speed up the debugging
    or interrupt handling procedure.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在中断后，游戏崩溃/冻结/重新启动的常见问题。很多时候，一些不必要的服务或进程可能会中断，并且它们可能会在中断期间改变游戏状态。在AVD上模拟每种可能的中断总是加快调试或中断处理过程的一个额外优势。
- en: Android device testing and debugging
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android设备测试和调试
- en: 'Android device debugging is the most important part for any Android game development
    process. Let''s divide this topic into two sections:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备调试是任何Android游戏开发过程中最重要的部分。让我们将这个主题分成两个部分：
- en: Device testing
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备测试
- en: Device debugging
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备调试
- en: Device testing
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备测试
- en: The main challenge for a game developer is to run the game on a large number
    of different devices. These different devices include different displays, different
    resolutions, different Android operating system versions, different processors,
    and different memory capacities. Due to these reasons, Android device testing
    is important and has to be carried out with great effort and planning.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发者面临的主要挑战是在大量不同的设备上运行游戏。这些不同的设备包括不同的显示器、不同的分辨率、不同的Android操作系统版本、不同的处理器和不同的内存容量。由于这些原因，Android设备测试很重要，必须付出很大的努力和计划。
- en: Normally, in a game development cycle, first-point testing is carried out by
    the developer. This process makes sure that the game is running on devices.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在游戏开发周期中，第一点测试由开发人员进行。这个过程确保游戏在设备上运行。
- en: Then, the tester or a group of testers test the game on different devices from
    various aspects. This is the main part of device testing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试人员或一组测试人员从各个方面在不同的设备上测试游戏。这是设备测试的主要部分。
- en: 'Generally, the main testing phases are divided into four parts according to
    game development stages:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，主要的测试阶段根据游戏开发阶段分为四个部分：
- en: Prototype test
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型测试
- en: Full or complete test
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整测试
- en: Regression test
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归测试
- en: Release test or run test
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布测试或运行测试
- en: 'In other words, a similar kind of distribution in each category is termed as
    follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在每个类别中有类似的分布，如下所示：
- en: Pre-alpha test
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pre-alpha测试
- en: Alpha test
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alpha测试
- en: Beta test
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Beta测试
- en: Release candidate test
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布候选测试
- en: There are many other testing procedures that may follow typical software testing.
    However, in game development, usually, these approaches are followed. Let's describe
    these stages in brief.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他可能遵循典型软件测试的测试程序。然而，在游戏开发中，通常会遵循这些方法。让我们简要描述这些阶段。
- en: Prototype testing
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原型测试
- en: The developer and designer together develop a playable stage of the basic game
    idea with an initial set of game rules. These rules and gameplay are tested during
    the phase of prototype testing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员和设计师一起开发基本游戏想法的可玩阶段，具有初始的游戏规则。这些规则和游戏玩法在原型测试阶段进行测试。
- en: Ideally, core gameplay is tested in this phase to analyze the feasibility, potential,
    and scope for the game concept.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，核心游戏玩法在这个阶段进行测试，以分析游戏概念的可行性、潜力和范围。
- en: Prototype testing is probably the most important part of the game development
    process. This phase determines the future of the game concept and also helps in
    developing a meta game and monetization model for the concept.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 原型测试可能是游戏开发过程中最重要的部分。这个阶段决定了游戏概念的未来，并有助于为概念开发元游戏和货币化模型。
- en: Full or complete testing
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全面测试
- en: Usually, whenever the first few builds are submitted to testing in each phase,
    full testing is conducted. This reveals each and every possible issue with the
    game, including crashing, freezing, visual issues, playability, game rules, and
    design faults.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在每个阶段提交的前几个构建被提交进行全面测试。这会揭示游戏的每一个可能的问题，包括崩溃、冻结、视觉问题、可玩性、游戏规则和设计缺陷。
- en: Most of the issues are usually reported during this phase, which eventually
    implies the possible completion time and effort for that game build.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数问题通常在这个阶段报告，这最终意味着该游戏构建的可能完成时间和工作量。
- en: Regression testing
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回归测试
- en: Regression testing comes after full testing. Developers, designers, and producers
    take a call on each and every issue reported during full test. They select issues
    for resolving, and after the issues are resolved, they are submitted back to the
    testing team for regression test.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试是在全面测试之后进行的。开发人员、设计师和制作人在全面测试期间对每个问题进行评估。他们选择要解决的问题，问题解决后，提交给测试团队进行回归测试。
- en: In regression testing, a tester usually picks the issue and specifically checks
    whether it is actually solved or not. If the issue occurs in a fixed build, then
    the testers reopen the issue for the next regression cycle. This cycle continues
    until all the reported issues are addressed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在回归测试中，测试人员通常选择问题并专门检查它是否真的解决了。如果问题在修复的构建中发生，则测试人员会重新打开问题进行下一个回归周期。这个周期会持续，直到所有报告的问题都得到解决。
- en: Release testing or run testing
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布测试或运行测试
- en: This is probably the most mechanical testing phase of game testing. In this
    phase, the tester runs the regression test passed builds on various target devices,
    just to check whether the game is running on that hardware or not. This is the
    reason this phase is often called a "run test".
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是游戏测试中最机械化的测试阶段。在这个阶段，测试人员在各种目标设备上运行通过的回归测试构建，只是为了检查游戏是否在该硬件上运行。这就是为什么这个阶段经常被称为“运行测试”的原因。
- en: As many physical devices as possible are used for this segment of testing for
    a compatibility check. The final device support list is created after this testing
    phase. It is almost impossible to arrange all the available devices and perform
    a run test on them. So, the developer groups the devices according to their configuration
    and performance. Devices that behave in a similar manner are put in the same category,
    and only one or two devices are actually arranged for run testing for the whole
    group.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能多地使用物理设备进行此段测试以进行兼容性检查。在这个测试阶段之后，创建最终设备支持列表。几乎不可能安排所有可用的设备并对它们进行运行测试。因此，开发人员根据其配置和性能对设备进行分组。行为相似的设备被放在同一类别中，实际上只有一两个设备被安排用于整个组的运行测试。
- en: Device debugging
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备调试
- en: We have already seen that device testing is mainly the job of a tester. Now,
    we will see that device debugging is basically the job of a developer. However,
    commonly, it is done by both developers and testers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到设备测试主要是测试人员的工作。现在，我们将看到设备调试基本上是开发人员的工作。然而，通常情况下，开发人员和测试人员都会进行调试。
- en: 'In the game industry, device debugging is mainly used to find out runtime crashes,
    freezes, memory issues, networking issues, and performance issues. Through device
    debugging, the developer gathers the following information:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏行业中，设备调试主要用于查找运行时崩溃、冻结、内存问题、网络问题和性能问题。通过设备调试，开发人员收集以下信息：
- en: Runtime maximum heap consumption
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时最大堆消耗
- en: Average FPS on various devices or multiple set of devices
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种设备的平均FPS或多套设备
- en: Unnecessary loaded objects
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不必要的加载对象
- en: Hardware button behavior
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件按钮行为
- en: Network request and response
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络请求和响应
- en: Use of breakpoints
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用断点
- en: Breakpoints are very useful and handy in the case of device debugging. The game
    thread is paused at breakpoint, and the state info can be achieved through DDMS.
    Game programming is mostly about customized algorithms, which might produce some
    unusual behavior during runtime. Breakpoints come handy in this situation. The
    developer can debug the logic line by line after a breakpoint so that the root
    cause of the behavior is found and fixed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备调试的情况下，断点非常有用。游戏线程在断点处暂停，可以通过DDMS获得状态信息。游戏编程主要涉及定制算法，可能在运行时产生一些异常行为。在这种情况下，断点非常有用。开发人员可以在断点后逐行调试逻辑，以找到并修复行为的根本原因。
- en: Monitoring the memory footprint
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视内存占用
- en: 'Memory footprints are the signs and ways of using memory during runtime. From
    the point of game memory usage optimization, monitoring the memory footprint is
    very important:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 内存占用是在运行时使用内存的迹象和方式。从游戏内存使用优化的角度来看，监视内存占用非常重要：
- en: Checking log messages
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查日志消息
- en: Checking heap updates
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查堆更新
- en: Tracking memory allocation
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪内存分配
- en: Checking overall memory usage
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查整体内存使用
- en: Tracking memory leaks
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪内存泄漏
- en: Checking log messages
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查日志消息
- en: Using log messages has been the most effective and immediate debugging technique.
    Message logs are very useful for tracking the program control flow and runtime
    object tracking.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志消息一直是最有效和最直接的调试技术。消息日志对于跟踪程序控制流和运行时对象跟踪非常有用。
- en: Dalvik message log
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Dalvik消息日志
- en: 'The Dalvik message log is useful for tracking memory. Whenever garbage collection
    happens, the garbage collector can print the following information through Dalvik
    log messaging:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Dalvik消息日志对于跟踪内存很有用。每当发生垃圾收集时，垃圾收集器可以通过Dalvik日志消息打印以下信息：
- en: '**Garbage collection reason**: This info reveals the reason for triggering
    garbage collection. The reasons can be `GC_CONCURRENT`, `GC_FOR_MALLOC`, `GC_HPROF_DUMP_HEAP`,
    `GC_EXPLICIT`, or `GC_EXTERNAL_ALLOC`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾收集原因**：此信息显示了触发垃圾收集的原因。原因可以是`GC_CONCURRENT`、`GC_FOR_MALLOC`、`GC_HPROF_DUMP_HEAP`、`GC_EXPLICIT`或`GC_EXTERNAL_ALLOC`。'
- en: '**Amount of memory freed**: This section states the amount of memory freed
    by the garbage collector in KB.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**释放的内存量**：此部分说明了垃圾收集器释放的内存量（以KB为单位）。'
- en: '**Current heap memory status**: This shows the percentage of heap memory used
    and live objects memory/total heap.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前堆内存状态**：这显示了堆内存使用的百分比和活动对象内存/总堆内存。'
- en: '**External memory status**: There may be some operations that allocate memory
    externally. This section shows the allocated memory/garbage collection limit.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部内存状态**：可能会有一些分配外部内存的操作。这部分显示了分配的内存/垃圾收集限制。'
- en: '**Garbage collector pause time**: Pause time is triggered twice, at the beginning
    of garbage collection and at its end. Normally, the pause time is higher in the
    case of a large heap.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾收集器暂停时间**：暂停时间在垃圾收集开始时和结束时触发。通常，在堆较大的情况下，暂停时间会更长。'
- en: ART message log
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ART消息日志
- en: The ART message log is also capable of showing or tracking memory footprints.
    However, it is not triggered unless explicitly requested.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ART消息日志还能够显示或跟踪内存印记。但是，除非明确请求，否则不会触发。
- en: 'If the garbage collector pause time exceeds 5 ms or the garbage collector takes
    more than 100 ms to execute, then garbage collector logs are printed. In the case
    of ART, the following information can be shown as logs:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果垃圾收集器暂停时间超过5毫秒，或者垃圾收集器执行时间超过100毫秒，则会打印垃圾收集器日志。在ART的情况下，以下信息可以显示为日志：
- en: '**Garbage collection reason**: In ART log messages, the developer can have
    `Concurrent`, `Alloc`, `Explicit`, `NativeAlloc`, `CollectorTransition`, `HomogeneousSpaceCompact`,
    `DisableMovingGc`, or `HeapTrim` as the reason for collection.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾收集原因**：在ART日志消息中，开发人员可以将`Concurrent`、`Alloc`、`Explicit`、`NativeAlloc`、`CollectorTransition`、`HomogeneousSpaceCompact`、`DisableMovingGc`或`HeapTrim`作为收集原因。'
- en: '**Name of garbage collector**: ART has few different garbage collectors that
    can be involved in a collection process. The name can be known by the field of
    the collection log. ART has these collectors: **Concurrent** **Mark Sweep** (**CMS**),
    **Concurrent** **Partial Mark Sweep** (**CPMS**), **Concurrent Sticky Mark Sweep**
    (**CSMS**), and Marksweep plus Semispace.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾收集器的名称**：ART有几种不同的垃圾收集器可以参与收集过程。可以通过收集日志的字段了解名称。ART有这些收集器：**Concurrent**
    **Mark Sweep**（**CMS**）、**Concurrent** **Partial Mark Sweep**（**CPMS**）、**Concurrent
    Sticky Mark Sweep**（**CSMS**）和Marksweep plus Semispace。'
- en: '**Count of objects freed**: This shows the total number of objects freed from
    memory by the garbage collector.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**释放的对象计数**：这显示了垃圾收集器从内存中释放的对象总数。'
- en: '**Amount of memory freed**: This shows the total amount of memory freed by
    the garbage collector.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**释放的内存量**：这显示了垃圾收集器释放的总内存量。'
- en: '**Count of large objects freed**: This shows the number of objects freed from
    the large object scope. These objects are freed by the collector.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**释放的大对象计数**：这显示了从大对象范围中由收集器释放的对象数量。'
- en: '**Memory amount freed from large objects**: This shows the amount of memory
    freed from the large object scope. This memory is freed by the collector.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从大对象中释放的内存量**：这显示了从大对象范围中由收集器释放的内存量。'
- en: '**Current heap memory status**: This is the same as the one for Dalvik logs—live
    objects count/total heap memory.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前堆内存状态**：这与Dalvik日志中的相同——活动对象计数/总堆内存。'
- en: '**GC pause time**: In the ART pause time section, this is directly proportional
    to the number of object references modified by the running garbage collector.
    Unlike Dalvik, the ART CMS garbage collector has only one pause time during the
    end of the collection process.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GC暂停时间**：在ART暂停时间部分，这与运行垃圾收集器修改的对象引用数量成正比。与Dalvik不同，ART CMS垃圾收集器在收集过程结束时只有一个暂停时间。'
- en: Checking heap updates
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查堆更新
- en: The developer can check the heap usage per update. It gives a clear picture
    of the memory footprint. Heaps can be monitored with the help of several tools.
    There are plenty of device memory monitors available in the market. DDMS device
    monitor is one of them. It is a powerful tool that observes heap usage during
    the game's runtime.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以每次更新时检查堆使用情况。这可以清楚地显示内存印记。可以使用多种工具来监视堆。市场上有很多设备内存监视器可用。DDMS设备监视器就是其中之一。它是一个强大的工具，在游戏运行时观察堆使用情况。
- en: The Android SDK comes with an inbuilt device monitor at `<sdk>/tools/monitor`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK自带了一个内置的设备监视器，位于`<sdk>/tools/monitor`。
- en: The memory monitor in Android Studio is useful for Android Studio users. Monitors
    can interact with the Android application to watch heap update with each garbage
    collection. Through this, the Android developer can know about exact memory usage
    for each segment of an application.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio中的内存监视器对于Android Studio用户非常有用。监视器可以与Android应用程序交互，以观察每次垃圾收集时的堆更新。通过这种方式，Android开发人员可以了解应用程序各个部分的确切内存使用情况。
- en: Sometimes, developers switch on/off methods to check exact heap usage. Thus,
    it becomes easier to optimize it further.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，开发人员会打开/关闭方法来检查确切的堆使用情况。因此，进一步优化变得更容易。
- en: Tracking memory allocation
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪内存分配
- en: This is helpful for memory optimization. Memory allocation can be monitored
    through an **allocation tracker**.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于内存优化很有帮助。内存分配可以通过**分配跟踪器**进行监视。
- en: Memory allocation tracking is required after a certain stage of memory optimization.
    This helps identify each and every object's memory allocation. Often, many useless
    objects stay back in memory. The developer can identify these objects and remove
    them for greater memory optimization.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在一定阶段的内存优化之后，需要进行内存分配跟踪。这有助于识别每个对象的内存分配。通常，许多无用的对象会留在内存中。开发人员可以识别这些对象并将它们移除，以实现更大的内存优化。
- en: Memory allocation tracker is available with both Device Monitor in Android SDK
    and Allocation Tracker in Android Studio.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配跟踪器在Android SDK的设备监视器和Android Studio的分配跟踪器中都可用。
- en: 'However, it''s not necessary to remove all allocations from performance-critical
    code paths; yet, the allocation tracker can help developers identify important
    issues in code. For instance, some apps might create a new `Paint` object on every
    draw. Moving this object into a global member is a simple fix that helps improve
    performance:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并不需要从性能关键的代码路径中删除所有分配；然而，分配跟踪器可以帮助开发人员识别代码中的重要问题。例如，一些应用程序可能在每次绘制时创建一个新的`Paint`对象。将此对象移入全局成员是一个简单的修复方法，有助于提高性能：
- en: '![Tracking memory allocation](img/B05069_09_03.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![跟踪内存分配](img/B05069_09_03.jpg)'
- en: 'Let''s have a quick look at the allocation information obtained:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看所获得的分配信息：
- en: '**s1**: This is the object package currently being tracked'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s1**：这是当前正在跟踪的对象包'
- en: '**s2**: This shows the **Allocation** tab is selected'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s2**：这显示已选择**分配**选项卡'
- en: '**s3**: This is used to start/stop tracking of the object'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s3**：这用于启动/停止跟踪对象'
- en: '**s4**: This updates the package allocation'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s4**：这更新包分配'
- en: '**s5**: This shows the allocation details'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**s5**：这显示分配详情'
- en: In game development, the number of objects in memory is immense, so it is very
    difficult to keep track of allocation and deallocation of objects manually. This
    monitoring tool helps find out the hidden spots that could have been easily ignored
    during the optimization process.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，内存中的对象数量是巨大的，因此手动跟踪对象的分配和释放非常困难。这个监控工具有助于发现在优化过程中可能被忽视的隐藏点。
- en: Checking overall memory usage
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查整体内存使用
- en: Overall memory usage of an Android game is distributed in different segments
    in RAM. This creates a general idea about application performance and memory security.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Android游戏的整体内存使用分布在RAM的不同段中。这为应用程序的性能和内存安全性提供了一个大致的概念。
- en: Basically, there are two types of allocation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有两种类型的分配。
- en: Private RAM
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私有RAM
- en: 'This is the dedicated memory portion used by the game during runtime. The Android
    operating system allocates this memory to the application. Private RAM is distributed
    in two segments:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是游戏在运行时使用的专用内存部分。Android操作系统将此内存分配给应用程序。私有RAM分为两个部分：
- en: Clean RAM
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理RAM
- en: Dirty RAM
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脏RAM
- en: Private dirty RAM is the most expensive one as it can only be used by specific
    applications (in our case, it is an Android game).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 私有脏RAM是最昂贵的，因为它只能被特定应用程序使用（在我们的情况下，是一个Android游戏）。
- en: Proportional set size (PSS)
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比例设置大小（PSS）
- en: This segment of RAM is used by multiple processes. It is basically shared memory.
    Any RAM pages that are unique to the application process directly contribute to
    its PSS, while pages that are shared with other processes contribute to the PSS
    value only in proportion to the amount of sharing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分RAM被多个进程使用。基本上是共享内存。任何应用程序进程独有的RAM页面直接影响其PSS，而与其他进程共享的页面仅按比例影响PSS值。
- en: Tracking memory leaks
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪内存泄漏
- en: Memory leakage is a serious threat to software development. So, it is absolute
    necessary to track memory leakage and resolve it. When a process allocates memory
    and loses the reference pointer, then it is impossible to free the memory within
    the process.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏对软件开发构成严重威胁。因此，追踪内存泄漏并解决它是绝对必要的。当一个进程分配内存并丢失引用指针时，就不可能在进程内释放内存。
- en: There are few debug tools that can do this job to track down memory leakage.
    However, there is another free and more effective solution. The developer can
    always monitor memory consumption at any given point of time. A game runs within
    an update loop. So, it is possible to track the memory peaks of different game
    cycles. If the peak keeps increasing, it means there are leaks in the allocation/deallocation
    of memory. Now, the developer can check the size of each object and hunt down
    the leakage. Another benefit of this process is finding unnecessary objects in
    memory alongside memory leakage.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些调试工具可以追踪内存泄漏。然而，还有另一个免费且更有效的解决方案。开发人员可以随时监视内存消耗。游戏在更新循环中运行。因此，可以跟踪不同游戏周期的内存峰值。如果峰值不断增加，意味着内存的分配/释放存在泄漏。现在，开发人员可以检查每个对象的大小并追踪泄漏。这个过程的另一个好处是在内存中找到不必要的对象以及内存泄漏。
- en: Strategic placement of different debug statements
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同调试语句的战略放置
- en: A debug statement is the most important part of any development process. Anything
    and everything can be tracked and traced through debug statements. However, being
    a system printing call, each debug statement comes with a cost on performance,
    which has a direct effect on runtime FPS. This is why a strategy on the placement
    of debug statements is absolutely necessary.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 调试语句是任何开发过程中最重要的部分。通过调试语句可以跟踪和追踪任何事物。然而，作为系统打印调用，每个调试语句都会对性能产生影响，这直接影响运行时的FPS。这就是为什么调试语句的放置策略是绝对必要的。
- en: 'Let''s have a look at the strategies related to following categories:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看与以下类别相关的策略：
- en: Memory allocation
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存分配
- en: Tracking the object state
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪对象状态
- en: Checking the program flow
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查程序流程
- en: Tracking object values
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪对象值
- en: Memory allocation
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存分配
- en: In a game development object cycle, an object should be allocated once per initialization
    and deallocated on destruction. However, due to manual programming mistakes, developers
    forget to free the memory. In this case, the garbage collector cleans the memory
    when it is invoked by the system automatically. This way, a lag in performance
    is observed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发对象周期中，对象应该在初始化时分配一次，并在销毁时释放。然而，由于手动编程错误，开发人员忘记释放内存。在这种情况下，当系统自动调用垃圾收集器时，内存将被清理。这样就观察到了性能上的延迟。
- en: Now, as a strategic placement to trace such mistakes, two debug messages should
    be placed at the constructor and destructor.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为追踪这种错误的战略放置，应该在构造函数和析构函数中放置两个调试消息。
- en: Also, a debug statement after initializing each object ensures a successful
    initialization of the object. This can reveal the amount of memory it consumes.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，初始化每个对象后放置一个调试语句可以确保对象成功初始化。这可以显示它消耗的内存量。
- en: Tracking the object state at runtime
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在运行时跟踪对象状态
- en: An object can be initialized at any time during gameplay. Now, any external
    dependency in the initialization process can cause failure of allocation. So,
    the object goes into null state and might cause an exception if not handled properly.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以在游戏过程中的任何时候初始化。现在，初始化过程中的任何外部依赖都可能导致分配失败。因此，对象进入空状态，如果不正确处理，可能会导致异常。
- en: A successful debug statement and a failed debug statement (with reason) helps
    the developer rectify the issue.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成功的调试语句和一个失败的调试语句（带有原因）可以帮助开发人员纠正问题。
- en: Many times, a wrong deallocation also changes the state of the object. So, the
    debug statement identifies the spot. The developer can solve the issue with the
    help of debug statements both for objects and program flow.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，错误的释放也会改变对象的状态。因此，调试语句可以确定这个地方。开发人员可以借助调试语句来解决对象和程序流的问题。
- en: Checking the program flow
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查程序流程
- en: A debug statement in every method clearly shows the call hierarchy and program
    flow. A modular program can be tested with this system. Then, the module set can
    be tested with one debug statement in each module start.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法中的调试语句清楚地显示了调用层次结构和程序流程。一个模块化的程序可以通过这个系统进行测试。然后，每个模块的开始都可以用一个调试语句进行测试。
- en: Any wrong or unnecessary calls can be removed or rectified through this process.
    Proper program flow ensures a certain frame rate during runtime. So, this approach
    can be used to optimize performance.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 任何错误或不必要的调用都可以通过这个过程来移除或纠正。正确的程序流程可以确保运行时的一定帧率。因此，这种方法可以用来优化性能。
- en: Tracking object values
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪对象值
- en: Even after a successful initialization of the object, the content may not be
    correct. So, putting a debug statement to check the loaded/initialized content
    is necessary to avoid future conflicts.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对象成功初始化，内容可能也不正确。因此，放置一个调试语句来检查加载/初始化的内容是必要的，以避免未来的冲突。
- en: This is very useful when loading data from an external source. Debug statements
    are used to verify the loaded data after initialization. Any program module can
    be designed using an object-tracking method, resulting in a better programming
    structure.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当从外部来源加载数据时，这是非常有用的。调试语句用于验证初始化后加载的数据。任何程序模块都可以使用对象跟踪方法进行设计，从而得到更好的编程结构。
- en: Exception handling in Android games
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android游戏中的异常处理
- en: Exception handling may not be a part of debugging, but it helps reduce the number
    of exceptions and unnecessary application crashes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理可能不是调试的一部分，但它有助于减少异常和不必要的应用程序崩溃。
- en: Exception handling in Android is the same as Java exception handling.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的异常处理与Java异常处理相同。
- en: Syntax
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法
- en: 'Standard Java syntax for exception handling is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理的标准Java语法如下：
- en: '[PRE0]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The suspicious code should be put inside a `try` block, and the exception should
    be handled in a `catch` block. If the module requires some default task to execute,
    then put it in the `finally` block. The `catch` and `finally` blocks might not
    be defined always in exception handling. However, it is recommended that you process
    the exception in each `try` block failure, which is a good programming practice.
    This process requires you to analyze the module to find out any vulnerable chunk
    of code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 可疑的代码应该放在`try`块中，并且异常应该在`catch`块中处理。如果模块需要执行一些默认任务，那么将其放在`finally`块中。`catch`和`finally`块可能并不总是在异常处理中定义。然而，建议在每个`try`块失败时处理异常，这是一个良好的编程实践。这个过程需要分析模块，找出任何脆弱的代码块。
- en: Here is a simple example of handling exception along with other vulnerable default
    tasks.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个处理异常的简单例子，还包括其他易受攻击的默认任务。
- en: 'This is the initial program design:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最初的程序设计：
- en: '[PRE1]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The program should be written in this way:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 程序应该这样写：
- en: '[PRE2]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The developer should remember the following points:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员应该记住以下几点：
- en: A `try` block can be used only with a `catch` block
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`块只能与`catch`块一起使用'
- en: A `try` block can be used only with a `finally` block
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`块只能与`finally`块一起使用'
- en: A `try` block can be used with both `catch` and `finally` blocks in sequence
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`块可以与`catch`和`finally`块一起使用'
- en: A `try` block cannot be used alone anywhere
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`块不能单独使用'
- en: Nested `try…catch` is possible but not recommended as a good programming practice
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套的`try...catch`是可能的，但不建议作为良好的编程实践
- en: Scope
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围
- en: 'There are plenty of predefined exception scopes depending on the exception
    type and cause. However, the major exceptions handled in a game development process
    are as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 根据异常类型和原因，有很多预定义的异常范围。然而，在游戏开发过程中处理的主要异常如下：
- en: Null pointer exceptions
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空指针异常
- en: Index out of bound exceptions
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引越界异常
- en: Arithmetic exceptions
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术异常
- en: Input/output exceptions
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入/输出异常
- en: Network exceptions
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络异常
- en: Custom exceptions
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义异常
- en: Null pointer exceptions
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空指针异常
- en: This is one of the most encountered exceptions in the case of game development.
    `NullPointerException` is thrown when any null object is referred to in the code.
    The developer should track the initialization and use of the object to rectify
    this issue.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是游戏开发中最常见的异常之一。当代码中引用任何空对象时，会抛出`NullPointerException`。开发人员应该跟踪对象的初始化和使用来纠正这个问题。
- en: 'Here is an example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE3]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will throw an exception as `objA` has been initialized with null. Hence,
    this object is nowhere located in the memory, and a reference pointer does not
    exist. A modern smart compiler can detect this obvious exception during compile
    time, but the code might be like this, where we defined another class containing
    the `testFunc()` method:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这将抛出一个异常，因为`objA`被初始化为null。因此，这个对象在内存中找不到，引用指针也不存在。现代智能编译器可以在编译时检测到这个明显的异常，但代码可能是这样的，我们定义了另一个包含`testFunc()`方法的类：
- en: '[PRE4]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, most of the smart compilers cannot detect the upcoming exception.
    To handle this, the developer should add few more lines of code to the `testFunc()`
    method:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，大多数智能编译器无法检测到即将发生的异常。为了处理这个问题，开发人员应该在`testFunc()`方法中添加几行代码：
- en: '[PRE5]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Index out of bound exceptions
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引超出范围异常
- en: This exception is thrown when accessing an indexed address, which is supposed
    be a part of contiguous memory allocation, but is not. The most common one is
    `ArrayIndexOutOfBoundsException` in the case of game development.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问一个索引地址时抛出此异常，该地址应该是连续内存分配的一部分，但实际上并不是。在游戏开发中，最常见的是`ArrayIndexOutOfBoundsException`。
- en: 'For example, if an array contains five fields and the program tries to access
    more than five fields, this exception will be thrown. Let''s consider this piece
    of code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个数组包含五个字段，程序尝试访问超过五个字段，那么就会抛出此异常。让我们看一下这段代码：
- en: '[PRE6]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the exception will occur in the log statement, as `arrayNum[5]` means
    the sixth element in the array, which does not exist.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，异常将出现在日志语句中，因为`arrayNum[5]`表示数组中的第六个元素，而该元素不存在。
- en: Arithmetic exceptions
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术异常
- en: A mathematical expression can signify an undefined value, but in the programming
    aspect, "undefined" cannot be defined. Hence, `ArithmeticException` is thrown.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 数学表达式可以表示一个未定义的值，但在编程方面，“未定义”无法定义。因此，会抛出`ArithmeticException`。
- en: For example, if an interpreter tries to divide any value by zero, then the result
    becomes undefined, which is thrown as an exception. The same result can be seen
    when calculating the value of tan 90°.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果解释器尝试将任何值除以零，那么结果变为未定义，这将作为异常抛出。在计算tan 90°的值时也会出现相同的结果。
- en: 'A simple case might look like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的情况可能是这样的：
- en: '[PRE7]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Input/output exceptions
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入/输出异常
- en: The input/output functionality of a computing system depends on its hardware.
    However, in the case of gaming, an input/output exception occurs during a read/write
    operation. Most games are data driven. The basic principal is to feed data to
    the game software to control the elements in the game. This data is usually stored
    in a separate binary, text, XML, or JSON file.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 计算系统的输入/输出功能取决于其硬件。然而，在游戏中，输入/输出异常发生在读/写操作期间。大多数游戏都是数据驱动的。基本原则是向游戏软件提供数据以控制游戏中的元素。这些数据通常存储在单独的二进制、文本、XML或JSON文件中。
- en: Being separate files located at a particular path, these files can go missing,
    especially when those data files are downloaded from some other location, because
    there may be a connection interruption and the file may not get saved. In this
    case, when the game software tries to load such files, then `IOException` is thrown.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 作为位于特定路径的单独文件，这些文件可能会丢失，特别是当这些数据文件从其他位置下载时，因为可能会出现连接中断，文件可能无法保存。在这种情况下，当游戏软件尝试加载这些文件时，就会抛出`IOException`。
- en: 'Let''s look at a quick example:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个快速的例子：
- en: '[PRE8]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Network exceptions
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络异常
- en: This is the age of multiplayer gaming, which requires a mandatory network connection.
    An application thus depends on the quality and connectivity of the existing network
    connection. However, the mobile network connection state may change at any point
    in time. Often, game developers ignore network errors, which causes crashing,
    freezing, or some malfunctioning in the running of the game.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是多人游戏的时代，这需要强制性的网络连接。因此，应用程序取决于现有网络连接的质量和连接性。然而，移动网络连接状态可能随时发生变化。通常，游戏开发人员忽略网络错误，导致游戏运行中崩溃、冻结或某些故障。
- en: Commonly handled exceptions are `HttpRetryException`, `UnresolvedAddressException`,
    and `NetworkErrorException`. If any HTTP request cannot be retired automatically,
    then `HttpRetryException` is thrown. If an application wants to connect to a certain
    address and the address is not found, then `UnresolvedAddressException` is thrown.
    `NetworkErrorException` is used to handle any sort of network mishap such as network
    lost/dropped, a network using the wrong protocol, and so on.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的异常处理包括`HttpRetryException`、`UnresolvedAddressException`和`NetworkErrorException`。如果任何HTTP请求不能自动重试，那么就会抛出`HttpRetryException`。如果应用程序想要连接到某个地址，但该地址未找到，那么就会抛出`UnresolvedAddressException`。`NetworkErrorException`用于处理任何网络故障，如网络丢失/中断、使用错误协议的网络等。
- en: Custom exceptions
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义异常
- en: 'This is typically used for two purposes:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常用于两个目的：
- en: Gameplay exception handling
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏异常处理
- en: Game support tool exception handling
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏支持工具异常处理
- en: Gameplay might create a logical exception during runtime. However, there is
    small scope for this exception in game development. This is not practiced by most
    Android developers.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏过程中可能会在运行时创建逻辑异常。然而，在游戏开发中，这种异常的范围很小。大多数Android开发人员不会这样做。
- en: Tool programming is also an important part of the game development process.
    So, the possible exception should be handled by a custom exception if required.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 工具编程也是游戏开发过程中的重要部分。因此，如果需要，可能的异常应该由自定义异常处理。
- en: Debugging for Android while working with cross-platform engines
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在使用跨平台引擎进行Android调试
- en: Modern day game programming does not generally target a single platform. Most
    games are cross-platform. A cross-platform game engine is very useful for this
    kind of development.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现代游戏编程通常不针对单一平台。大多数游戏都是跨平台的。跨平台游戏引擎对这种开发非常有用。
- en: Most engines come with a built-in profiler and provide some features to debug
    the game. However, the profiler feature is completely dependent on the manufacturer
    of the specific game engine.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数引擎都配备了内置的性能分析器，并提供一些调试游戏的功能。然而，性能分析器功能完全依赖于特定游戏引擎的制造商。
- en: All native platforms provide complete debug information. Game engines create
    a wrapper to automatically switch from one platform configuration to another and
    display profiler details within a common user interface.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 所有本地平台都提供完整的调试信息。游戏引擎创建一个包装器，自动从一个平台配置切换到另一个，并在一个共同的用户界面中显示性能分析器的详细信息。
- en: However, these cross-platform debug tools cost some extra processing and memory.
    In a way, they limit game resource consumption to a certain level with an error
    margin.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些跨平台调试工具会消耗额外的处理和内存。在某种程度上，它们限制了游戏资源的消耗到一定水平，并带有误差范围。
- en: Best testing practices
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳测试实践
- en: There are many standards used in the Android game development industry for testing.
    Testing ensures correctness, stability, functional behavior, and durability after
    an application is published. The most common approach for Android game testing
    is manual testing.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android游戏开发行业中有许多用于测试的标准。测试确保应用程序发布后的正确性、稳定性、功能行为和耐久性。Android游戏测试的最常见方法是手动测试。
- en: However, this process is definitely not the best. As an Android developer, a
    unit test is always a best practice to save time and get accurate test results.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个过程绝对不是最佳的。作为Android开发人员，单元测试始终是一种最佳实践，可以节省时间并获得准确的测试结果。
- en: Tools and APIs
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具和API
- en: There are several tools and Android APIs that can be used to carry out the testing
    procedure. Some of them are inbuilt, such as Android Test Support Library, Dumpsys,
    Monkeyrunner, and so on.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种工具和Android API可用于执行测试过程。其中一些是内置的，如Android测试支持库、Dumpsys、Monkeyrunner等。
- en: Most of these testing tools can be triggered through the command line and run
    through Android Debug Bridge.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些测试工具可以通过命令行触发，并通过Android调试桥运行。
- en: 'The Monkey tools create a virtual environment to populate user actions such
    as click, touch, swipe and so on to determine real-time result. Monkey can be
    run with the following command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Monkey工具创建一个虚拟环境，模拟用户的点击、触摸、滑动等操作，以确定实时结果。Monkey可以通过以下命令运行：
- en: '[PRE9]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Dumpsys provides status of the system during the runtime of an Android application.
    This can be triggered through the following command:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Dumpsys在Android应用程序运行时提供系统状态。可以通过以下命令触发：
- en: '[PRE10]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Dumpsys is able to provide information on running services, input system, network
    status, RAM uses, and more.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Dumpsys能够提供关于运行服务、输入系统、网络状态、RAM使用等信息。
- en: Testing techniques
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试技术
- en: 'Mostly, two types of testing techniques are used in the game industry: automated
    testing and manual testing. We have already discussed the manual testing procedure
    in brief. Let''s have a look at automated testing.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏行业中，通常使用两种测试技术：自动化测试和手动测试。我们已经简要讨论了手动测试过程。现在让我们来看看自动化测试。
- en: Automated testing requires tools and extra programming effort. Game UI, memory
    consumption, network connectivity, and input system testing can be automated.
    A separate test runs on a simulator or on an actual device to determine the test
    result, and it is saved at a given location of the development system.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试需要工具和额外的编程工作。游戏UI、内存消耗、网络连接和输入系统测试可以自动化。单独的测试在模拟器上或实际设备上运行，以确定测试结果，并将其保存在开发系统的指定位置。
- en: 'Unit test code can be written to verify the logic of an individual module of
    a game. A unit test can be used for testing the smallest possible component of
    the application program, such as elements, classes, and methods. Unit tests are
    further categorized into two stages:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编写单元测试代码来验证游戏的单个模块的逻辑。单元测试可用于测试应用程序的最小可能组件，如元素、类和方法。单元测试进一步分为两个阶段：
- en: Local test
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地测试
- en: Instrumented test
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪器化测试
- en: Local test
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地测试
- en: This type of unit test works on a local machine and runs on the JVM. This saves
    a lot of testing time. A local test has either no dependency on the Android framework
    or limited dependency that can be satisfied with dummy objects.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的单元测试在本地机器上运行在JVM上。这节省了大量的测试时间。本地测试要么不依赖于Android框架，要么依赖有限，可以通过虚拟对象满足。
- en: Instrumented test
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仪器化测试
- en: Instrumented tests have full dependency on the Android framework and must run
    on an Android emulator or on an Android device. This testing technique is used
    to test the runtime behavior of an Android game. It can provide all system and
    debug information of the running application. However, this technique cannot be
    used easily with dummy objects. The developer needs to define the testing object
    data before it can run the test in an Android environment.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器化测试对Android框架有完全的依赖，必须在Android模拟器或Android设备上运行。这种测试技术用于测试Android游戏的运行时行为。它可以提供正在运行的应用程序的所有系统和调试信息。然而，这种技术不能轻易地与虚拟对象一起使用。开发人员需要在Android环境中定义测试对象数据，然后才能运行测试。
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Any development process is incomplete without quality and performance assurance.
    Testing is the phase of development where the game needs to be verified technically
    and logically to see whether it can perform in the real market.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 任何开发过程如果没有质量和性能保证都是不完整的。测试是开发阶段，需要在技术和逻辑上验证游戏是否能在真实市场中运行。
- en: The phases of testing, debugging, and profiling the game ensures the best possible
    quality of the game for the targeted Android platform range. Often, an Android
    game works on few Android devices but not on all targeted devices. The developer
    can identify and resolve the issues for some specific devices through a detailed
    testing procedure.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 测试、调试和分析游戏的阶段确保了针对目标Android平台范围的最佳质量。通常，Android游戏在少数Android设备上可以运行，但在所有目标设备上都不能运行。开发人员可以通过详细的测试程序识别和解决一些特定设备的问题。
