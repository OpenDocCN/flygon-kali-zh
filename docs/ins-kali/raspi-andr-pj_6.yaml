- en: Chapter 6. The Vehicle Pi
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。车载树莓派
- en: 'We will continue to use Bluetooth on our Pi in this chapter to track the location
    and data from our car. The following sections will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续在树莓派上使用蓝牙来跟踪我们汽车的位置和数据。本章将涵盖以下部分：
- en: Finding out the location of the car
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找汽车位置
- en: Using your Android device as an access point
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的Android设备作为访问点
- en: Collecting the car data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集汽车数据
- en: Sending data to the cloud
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据发送到云端
- en: Putting it all together
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: Finding out the car location
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找汽车位置
- en: 'In this chapter, we will collect the engine data from our car, but things will
    get more exciting if we can gather some for of location data as well. For this
    purpose, we will connect a USB GPS receiver to the Pi and receive our location
    through this piece of equipment. We will use one of the cheapest receivers available
    in the market, as shown in the following image:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从我们的汽车收集发动机数据，但如果我们也能收集一些位置数据，事情将变得更加有趣。为此，我们将连接一个USB GPS接收器到树莓派，并通过这个设备接收我们的位置。我们将使用市场上最便宜的接收器之一，如下图所示：
- en: '![Finding out the car location](img/image00138.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![查找汽车位置](img/image00138.jpeg)'
- en: The Globalsat BU-353 GPS receiver
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Globalsat BU-353 GPS接收器
- en: 'After connecting the GPS to the Pi, you can issue the `lsusb` command to see
    if it is registered correctly. The output from this command on my system is as
    follows, and here `Prolific` is the GPS adapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将GPS连接到树莓派后，您可以发出`lsusb`命令以查看它是否已正确注册。我的系统上此命令的输出如下，这里`Prolific`是GPS适配器：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next thing we need to install is a GPS daemon that receives location information
    from the adapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装的下一件事是一个GPS守护程序，它从适配器接收位置信息：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You might need to reboot in order to get the daemon to start. Otherwise, you
    can issue the following command to get it working immediately:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要重新启动以启动守护程序。否则，您可以发出以下命令立即使其工作：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The installation script has even provided us with a tool to see the current
    GPS location and the satellites that are in range through a text-based window:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安装脚本甚至为我们提供了一个工具，通过基于文本的窗口查看当前GPS位置和范围内的卫星：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The GPS receiver works best outdoors or with a clear view of the sky near a
    window.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: GPS接收器在室外或靠近窗户的地方可以最好地工作。
- en: 'The output on my system and in my location from the `cgps` command is shown
    in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我系统上`cgps`命令的输出以及我的位置在以下截图中显示：
- en: '![Finding out the car location](img/image00139.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![查找汽车位置](img/image00139.jpeg)'
- en: The output from the cgps –s command
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从cgps –s命令的输出
- en: Here, you can see the GPS satellites that I, in particular, have in my view,
    and my latitude and longitude as well as other useful information that is available
    through the GPS system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我特别在我的视野中拥有的GPS卫星，以及我的纬度和经度以及其他通过GPS系统可用的有用信息。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you get a timeout error from the `cgps` command, you need to restart the
    GPS daemon using the following commands:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从`cgps`命令中收到超时错误，您需要使用以下命令重新启动GPS守护程序：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you get this timeout even though you have rebooted the Pi, then you can
    put the following commands in **crontab**, but, there is even a better place to
    put these, which will be described later on:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您已经重新启动了树莓派，如果您仍然收到此超时错误，则可以将以下命令放入**crontab**中，但是，还有一个更好的地方可以放置这些命令，稍后将进行描述：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is possible to get the location information programmatically from Python
    as well. We will make use of this possibility later on. But for now, the following
    Python code in a file named `getgps.py` to test the Python `gps` library:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以从Python程序中以编程方式获取位置信息。我们稍后将利用这种可能性。但是现在，以下Python代码在名为`getgps.py`的文件中测试Python
    `gps`库：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The only thing this tiny program does is to output the GPS location whenever
    there is one to report. We can call it using the `python getgps.py` command.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小程序唯一的作用是在有报告时输出GPS位置。我们可以使用`python getgps.py`命令来调用它。
- en: Collecting the car data
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集汽车数据
- en: For the purpose of collecting the car data, we will use a standard **On-board**
    **diagnostics** (**OBD**) interface found on most cars and referred to as OBD-II
    or EOBD in Europe. These are equivalent standards used to connect to the OBD port
    of the car; you can also read diagnostics data and fault codes about the car from
    this port.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了收集汽车数据，我们将使用大多数汽车上都有的标准**车载** **诊断**（**OBD**）接口，欧洲称为OBD-II或EOBD。这些是用于连接到汽车OBD端口的等效标准；您还可以从该端口读取有关汽车的诊断数据和故障代码。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In 1996, the OBD-II specification was made mandatory for all cars manufactured
    and sold in the United States. The European Union followed suit in 2001 by making
    EOBD mandatory for all gasoline (petrol) vehicles sold in the European Union,
    followed by all diesel vehicles in 2003\. In 2010, the HDOBD (heavy duty) specification
    was made mandatory for certain select commercial (non-passenger car) engines sold
    in the United States. Even China followed suit in 2008, and by then, some light
    vehicles in China were required by the Environmental Protection Administration
    Office to implement OBD.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 1996年，OBD-II规范对所有在美国制造和销售的汽车都是强制性的。欧盟在2001年跟随步伐，要求所有在欧盟销售的汽油车辆都必须使用EOBD，随后在2003年要求所有柴油车辆也要使用EOBD。2010年，HDOBD（重型）规范对在美国销售的某些特定商用（非乘用车）发动机也是强制性的。甚至中国在2008年也跟随步伐，到那时，中国的一些轻型车辆被环保局要求实施OBD。
- en: 'On most cars, the OBD interface is found under the steering wheel. On a Toyota
    Aygo from 2008, it is found on the right-hand side under the steering wheel. Some
    car manufacturers do not have standard port connections. So, you might have to
    buy an extra OBD converter cable. The port in the car looks like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数汽车上，OBD接口位于方向盘下方。在2008年的丰田Aygo上，它位于方向盘下方的右侧。一些汽车制造商没有标准的端口连接。因此，您可能需要购买额外的OBD转换电缆。汽车上的端口看起来像这样：
- en: '![Collecting the car data](img/image00140.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![收集汽车数据](img/image00140.jpeg)'
- en: The OBD connection in the car
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车上的OBD连接
- en: 'We will connect an **ELM327**-Bluetooth sender to this OBD connection and the
    Bluetooth dongle from the previous chapter to the Pi and make the two communicate.
    The ELM327 is a programmed microcontroller produced by **ELM Electronics** to
    translate the on-board diagnostics (OBD) interface. The ELM327 command protocol
    is one of the most popular PC-to-OBD interface standards implemented. You can
    buy one of these pieces of hardware in any price range with different properties
    on Amazon. The one that I have is by **Goliton**:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将连接一个**ELM327**-蓝牙发送器到这个OBD连接，以及连接到树莓派的上一章中的蓝牙适配器，让这两者进行通信。ELM327是由**ELM Electronics**生产的一个用于翻译车载诊断（OBD）接口的程序化微控制器。ELM327命令协议是最流行的PC到OBD接口标准之一。你可以在亚马逊上以不同价格购买到具有不同性能的这些硬件。我拥有的这个是由**Goliton**生产的：
- en: '![Collecting the car data](img/image00141.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![收集汽车数据](img/image00141.jpeg)'
- en: The ELM 327-OBD Bluetooth sender
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ELM 327-OBD蓝牙发送器
- en: The easiest way to get data from a car is to use an app on Android that can
    translate the data for you. Search for OBD on the Play Store, and you will find
    lots of great apps that can connect to ELM327 and show you all the details of
    your car data. However, we want to have a lot more fun than this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从汽车获取数据的最简单方法是使用安卓上的一个应用程序，它可以为你翻译数据。在Play商店搜索OBD，你会找到很多可以连接到ELM327并显示汽车数据细节的优秀应用程序。然而，我们想要比这更有趣。
- en: Getting the car data to the Pi
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将汽车数据传输到树莓派
- en: 'To collect car data from the Pi using Python via Bluetooth, we need to install
    some tools. Run the following update command to download Bluetooth-related packages.
    Note that I am assuming that you have a **new Raspbian installation**. Same packages
    have been installed in previous chapters as well:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过Python通过蓝牙从树莓派收集汽车数据，我们需要安装一些工具。运行以下更新命令来下载与蓝牙相关的软件包。请注意，我假设你已经安装了**新的Raspbian**。相同的软件包也在之前的章节中安装过：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You are most probably sitting in your car and working right now. If you are
    struggling to figure out how to connect to the Internet, you can always use your
    Android device as a hotspot and connect to the Internet using the Wi-Fi dongle
    that we need for this chapter later on anyway.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能现在就坐在车里工作。如果你正在努力想弄清楚如何连接到互联网，你可以随时使用你的安卓设备作为热点，并使用我们稍后在本章中需要的Wi-Fi适配器连接到互联网。
- en: Connecting the Pi to a Wi-Fi network was covered previously, but lets remind
    ourselves about how it works.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将树莓派连接到Wi-Fi网络的方法之前已经介绍过了，但让我们再次了解一下它是如何工作的。
- en: 'Add the following lines to the `/etc/wpa_supplicant/wpa_supplicant.conf` file.
    You need to have configured the hotspot to apply the WPA PSK security instead
    of PSK2:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到`/etc/wpa_supplicant/wpa_supplicant.conf`文件中。你需要配置热点以应用WPA PSK安全，而不是PSK2：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, reboot the Pi, and after a few minutes, you will see that it is automatically
    connected to the hotspot on the Android device in the hotspot settings window.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启动树莓派，几分钟后，你会发现它自动连接到安卓设备的热点。
- en: 'Once again, we can use the `lsusb` command to list the connected USB devices.
    The output on my system is shown as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，我们可以使用`lsusb`命令来列出连接的USB设备。在我的系统上，输出如下所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `005` device is the Bluetooth dongle that I am reusing from the previous
    section. Issue the `hcitool scan` command to see if you can reach the OBD Bluetooth
    device connected to the car:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`005`设备是我从上一节中重复使用的蓝牙适配器。发出`hcitool scan`命令，看看是否可以连接到连接到汽车的OBD蓝牙设备：'
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see the MAC address of the OBD device as well; write it down as it will
    be used later.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以看到OBD设备的MAC地址；记下来，稍后会用到。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you get into problems, such as scanning or reaching the OBD, you can use
    the following commands to see the status of the connected Bluetooth dongle and
    the `bluetooth` service on the Pi:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到问题，比如扫描或连接到OBD，你可以使用以下命令来查看树莓派上连接的蓝牙适配器和`bluetooth`服务的状态：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s take a look at the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下命令：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding command is used to restart the `bluetooth` service.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令用于重新启动`bluetooth`服务。
- en: Now, we need to give the `pi` user access to the Bluetooth device. Edit the
    `/etc/group` file, find the row containing the `bluetooth` text, and add `pi`
    to the end of this row. It needs to look something similar to `bluetooth:x:113:pi`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要让`pi`用户访问蓝牙设备。编辑`/etc/group`文件，找到包含`bluetooth`文本的行，并在该行的末尾添加`pi`。它需要看起来类似于`bluetooth:x:113:pi`。
- en: 'We can now connect the Pi''s Bluetooth dongle to the OBD Bluetooth device using
    the `rfcomm` command. This command should be the first thing you execute before
    connecting to OBD. You can hang up before continuing using the *Ctrl*+*C* key
    combination:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`rfcomm`命令将树莓派的蓝牙适配器连接到OBD蓝牙设备。在连接到OBD之前，这个命令应该是你执行的第一件事。你可以在继续使用*Ctrl*+*C*组合键之前挂断：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, you should use the MAC address of your own ODB Bluetooth, which we found
    out previously using the `hcitool scan` command.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你应该使用你自己的OBD蓝牙的MAC地址，我们之前使用`hcitool scan`命令找到了它。
- en: 'Now, issue the following Bluetooth pairing command to pair the Pi with OBD
    and use the MAC address of OBD:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，发出以下蓝牙配对命令，将树莓派与OBD配对，并使用OBD的MAC地址：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The PIN is usually either `0000` or `1234`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: PIN通常是`0000`或`1234`：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We should even add the `dbus` connection support before we continue to the
    next command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一个命令之前，我们甚至应该添加`dbus`连接支持：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Make the OBD device trusted by the Pi in order to skip manual pairing the next
    time using the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让树莓派信任OBD设备，以便下次跳过手动配对，使用以下命令：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The following command will let you test the connection if you have any problems.
    Replace the MAC address with your OBD adapter''s MAC address:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到任何问题，以下命令将让你测试连接。用你的OBD适配器的MAC地址替换MAC地址：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will use a tool, called `pyOBD-pi`, to access the data that the OBD dongle
    makes available. Download and start the logger using the `git` command. This is
    a more developer-friendly version of a well-known library located at [https://github.com/peterh/pyobd](https://github.com/peterh/pyobd):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`pyOBD-pi`的工具来访问OBD dongle提供的数据。使用`git`命令下载并启动记录器。这是一个更开发者友好的版本，位于[https://github.com/peterh/pyobd](https://github.com/peterh/pyobd)：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Do not forget to turn your ignition on. Also, don''t forget to connect via
    Bluetooth using the upcoming command. It is a good idea to put this in crontab,
    otherwise, you''ll need to use it every time you reboot the Pi:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记打开点火开关。还要记得使用即将到来的命令通过蓝牙连接。最好将其放在crontab中，否则，您每次重新启动Pi时都需要使用它：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The command will save the data traffic to the `log` directory. If you get errors
    regarding `0100 response:CAN ERROR`, then you have problems with protocol selections,
    and you simply need to edit the `obd_io.py` file and find the following line:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将将数据流量保存到`log`目录。如果出现关于`0100 response:CAN ERROR`的错误，则表示您在协议选择方面存在问题，您只需要编辑`obd_io.py`文件并找到以下行：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, add the following lines of code just before it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在此之前添加以下代码行：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this way, we have forced the communication protocol to be chosen automatically.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经强制选择通信协议。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You may want to run the `init` server script on reboot. You cannot put it in
    cronbtab as the Bluetooth or GPS might not be ready when it is run. Put the commands
    at the end of `/etc/rc.local` file before the exit line, instead:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望在重新启动时运行`init`服务器脚本。您不能将其放在cronbtab中，因为在运行时蓝牙或GPS可能尚未准备就绪。将命令放在`/etc/rc.local`文件的末尾，而不是在退出行之前：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using your Android device as an access point
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的安卓设备用作访问点
- en: We will send the data we have gathered so far to a location on a cloud, but
    we need to connect the Pi to the Internet before we do this. Making an Android
    device an Internet access point or a hotspot is trivial and can be done from the
    settings of a device. We can then connect the Pi to this network that Android
    provides. However, there is a major problem with this setup. First of all, we
    want to be able to leave the Pi and the phone in the car all the time. As soon
    as the car starts, we want the data to be sent automatically, and we do not want
    to carry around the Pi and a phone. However, if we leave the phone in the car
    and it is connected to the 12V power output, the device will soon run out of battery
    and shut down. Then, we'll need to power it on manually and make changes in the
    hotspot settings again. We want all these steps to be undertaken automatically.
    For this reason, we need a way to get the device powered on as soon as it is connected
    to a power source, or the power source it is connected to, such as a 12V power
    output in the car, wakes up when we start the car. The techniques I will now present
    require that you have super user privileges to your Android device, which means
    that we need to root the device.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在将迄今为止收集的数据发送到云端之前，我们需要将Pi连接到互联网。将安卓设备设置为互联网访问点或热点非常简单，可以从设备的设置中完成。然后，我们可以将Pi连接到安卓提供的网络。但是，这种设置存在一个主要问题。首先，我们希望能够一直将Pi和手机留在车上。一旦汽车启动，我们希望数据能够自动发送，而不想携带Pi和手机。但是，如果我们将手机留在车上并将其连接到12V电源输出，设备很快就会耗尽电池并关闭。然后，我们需要手动将其打开并再次更改热点设置。我们希望所有这些步骤都能自动进行。因此，我们需要一种方法，可以在连接到电源源时或连接到的电源源，例如车上的12V电源输出，在我们启动汽车时唤醒设备。我现在将介绍的技术要求您对安卓设备拥有超级用户权限，这意味着我们需要对设备进行Rooting。
- en: An alternative to rooting
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rooting的替代方法
- en: 'An alternative to rooting a device is using a USB Wi-Fi 3G modem to get Internet
    access in the car. Note that most of the 3G USB modems in the market do not provide
    you with a Wi-Fi network. They only give network access to the computer into which
    they are plugged. The one we need acts similar to a Wi-Fi hotspot when connected
    to a USB power source. You can find these at online retailers, such as Amazon
    or AliExpress. The one I personally use is shown in the following image:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用USB Wi-Fi 3G调制解调器作为根设备的替代方法，以在汽车中获得互联网访问。请注意，市场上大多数3G USB调制解调器都不提供Wi-Fi网络。它们只为插入的计算机提供网络访问。我们需要的那种在连接到USB电源源时类似于Wi-Fi热点。您可以在在线零售商处找到这些产品，如亚马逊或速卖通。我个人使用的产品如下图所示：
- en: '![An alternative to rooting](img/image00142.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Rooting的替代方法](img/image00142.jpeg)'
- en: The USB Wi-Fi 3G modem
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: USB Wi-Fi 3G调制解调器
- en: If you choose to use one of these, you may jump over the rest of this section
    and go directly to the next.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择使用其中一种，可以跳过本节的其余部分，直接转到下一节。
- en: Rooting Samsung Galaxy S2
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rooting Samsung Galaxy S2
- en: There are different ways of rooting different devices. I will use one of the
    most common second hand Android devices in the market, namely, Samsung Galaxy
    S2\. If you have another phone, there are plenty of resources available on the
    Internet on how to root each device. The most popular one is located at [http://www.androidcentral.com/root](http://www.androidcentral.com/root),
    the **Android Central** website.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法可以对不同的设备进行Rooting。我将使用市场上最常见的二手安卓设备之一，即三星Galaxy S2。如果您有其他手机，互联网上有大量关于如何对每个设备进行Rooting的资源。最受欢迎的一个位于[http://www.androidcentral.com/root](http://www.androidcentral.com/root)，即**Android
    Central**网站。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that rooting a device will make the guarantee invalid. This may cause damage
    to your phone and is not a secure process. Do it on your own risk. But the steps
    provided here worked for me. You should backup any files you would like to keep
    before you continue with the rest of this chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对设备进行Rooting将使保修无效。这可能会损坏您的手机，并且不是一个安全的过程。请自担风险。但是这里提供的步骤对我有用。在继续本章的其余部分之前，您应该备份您想要保留的任何文件。
- en: Samsung devices can be put into recovery mode by pressing the *volume down*,
    *power*, *home* buttons at the same time. By pressing these buttons, you will
    get Samsung's standard recovery screen with a warning sign on it. We should replace
    this recovery program with another one, as the standard recovery is only to be
    done through a computer connected via a USB and downloads a complete OS image.
    However, what we really need to do is only replace a kernel with one that gives
    us super user rights. We also want to make sure that we do this from an SD card
    attached to an Android device. That is why we need to replace Samsung's default
    recovery program. We can do this again using the recovery operation provided by
    Samsung.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*音量减*、*电源*、*主页*按钮，三星设备可以进入恢复模式。按下这些按钮，您将会看到三星标准的恢复屏幕上有一个警告标志。我们应该用另一个恢复程序替换这个标准恢复程序，因为标准恢复只能通过连接到USB的计算机来完成，并下载完整的操作系统映像。然而，我们真正需要做的是只用一个给我们超级用户权限的内核来替换内核。我们还要确保我们是从连接到安卓设备的SD卡上进行这个操作。这就是为什么我们需要替换三星的默认恢复程序。我们可以再次使用三星提供的恢复操作来完成这个操作。
- en: When you put the device in this recovery mode, attach it to a computer through
    a USB. Next, we can download a software, named **Odin**, to upload a new recovery
    tool to the phone. It can be downloaded from quite a lot of places on the Internet
    along with different versions. The one we will use is called `ODIN3_v1.85.zip`,
    and it is located at [https://www.androidfilehost.com/?fid=9390169635556426736](https://www.androidfilehost.com/?fid=9390169635556426736).
    Another file we need is a kernel to replace the existing one that will help us
    with new ways of recovery operations. This file is named **Jeboo Kernel**, and
    can be found at [http://downloadandroidrom.com/file/GalaxyS2/kernels/JB/jeboo_kernel_i9100_v1-2a.tar](http://downloadandroidrom.com/file/GalaxyS2/kernels/JB/jeboo_kernel_i9100_v1-2a.tar).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将设备置于此恢复模式时，通过USB将其连接到计算机。接下来，我们可以下载一个名为**Odin**的软件，将一个新的恢复工具上传到手机上。它可以从互联网上的许多地方下载，有不同的版本。我们将使用的是名为`ODIN3_v1.85.zip`的版本，它位于[https://www.androidfilehost.com/?fid=9390169635556426736](https://www.androidfilehost.com/?fid=9390169635556426736)。我们需要的另一个文件是一个内核，用来替换现有的内核，帮助我们进行新的恢复操作。这个文件名为**Jeboo
    Kernel**，可以在[http://downloadandroidrom.com/file/GalaxyS2/kernels/JB/jeboo_kernel_i9100_v1-2a.tar](http://downloadandroidrom.com/file/GalaxyS2/kernels/JB/jeboo_kernel_i9100_v1-2a.tar)找到。
- en: 'As instructed on the recovery screen on the phone, you should press the *volume
    up* button to put the device in the download mode. Then, start Odin, and select
    the newly downloaded Jeboo Kernel as **PDA**. You should see a COM box marked
    in yellow if the phone is correctly connected, and is in the kernel download mode:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 按照手机上恢复屏幕上的指示，按下*音量增*按钮将设备置于下载模式。然后，启动Odin，并选择新下载的Jeboo Kernel作为**PDA**。如果手机正确连接并处于内核下载模式，您应该看到一个标记为黄色的COM框：
- en: '![Rooting Samsung Galaxy S2](img/image00143.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![三星Galaxy S2获取Root权限](img/image00143.jpeg)'
- en: Odin shows Jeboo as PDA and a connected device on `COM11`. Click on **Start**
    to upload upload the new Jeboo kernel you have selected.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Odin显示Jeboo为PDA，并显示连接到`COM11`的设备。点击**开始**上传您选择的新Jeboo内核。
- en: 'It should not take too much time before you get a **PASS** notification:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在您收到**PASS**通知之前不应该花费太多时间：
- en: '![Rooting Samsung Galaxy S2](img/image00144.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![三星Galaxy S2获取Root权限](img/image00144.jpeg)'
- en: Odin has been completed successfully
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Odin已成功完成
- en: Now, your phone should reboot, and you should see a warning triangle on the
    restart screen, indicating that you have a new kernel with the "recovery from
    SD card" feature.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的手机应该重新启动，您应该在重新启动屏幕上看到一个警告三角形，表示您有一个带有“从SD卡恢复”功能的新内核。
- en: The next step is to save the **CWM Super User** file from [http://downloadandroidrom.com/file/tools/SuperSU/CWM-SuperSU-v0.99.zip](http://downloadandroidrom.com/file/tools/SuperSU/CWM-SuperSU-v0.99.zip)
    to the SD card and attach it to the device. Now, power off your device and put
    it into recovery mode again this time using a slightly different key combination,
    that is, *volume up*, *power*, *home*. Note that we press *volume up* instead
    of *volume down* as we did before. You will see a different recovery screen called
    **CWM-based Recovery**. You can scroll up and down using the *volume up* and *volume
    down* keys. Select the **Install Zip** item using the *home* button, and then
    the **Choose from SD card** option. You should browse to the CWM Super User ZIP
    file that you have downloaded on to the SD card. Finally, choose **Yes**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将[http://downloadandroidrom.com/file/tools/SuperSU/CWM-SuperSU-v0.99.zip](http://downloadandroidrom.com/file/tools/SuperSU/CWM-SuperSU-v0.99.zip)上的**CWM
    Super User**文件保存到SD卡并将其连接到设备。现在，关闭设备并再次将其置于恢复模式，这次使用略有不同的按键组合，即*音量增*、*电源*、*主页*。请注意，我们按下*音量增*而不是之前的*音量减*。您将看到一个名为**CWM-based
    Recovery**的不同恢复屏幕。您可以使用*音量增*和*音量减*键上下滚动。使用*主页*按钮选择**安装Zip**项目，然后选择**从SD卡选择**选项。您应该浏览到您已经下载到SD卡上的CWM
    Super User ZIP文件。最后，选择**是**。
- en: Reboot the device, and you will see a new app called **Super User**, which indicates
    that you have successfully rooted your device. You can even verify that you have
    super user access to your device by downloading one of the Super User checker
    apps on Google Play. You will see a message box asking you a question from the
    Super User app, that we had installed from the previous step, if you want to grant
    super user privileges to any other app asking to get those.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动设备，您将看到一个名为**Super User**的新应用程序，这表明您已成功获取Root权限。您甚至可以通过在Google Play上下载一个Super
    User检查器应用程序来验证您对设备的超级用户访问权限。您将看到一个消息框，询问您是否要授予超级用户权限给任何其他应用程序。
- en: Enabling tethering on being connected to a power source
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到电源后启用共享网络
- en: 'As our phone hypothetically stays in the car all the time, and only gets powered
    up when the car is being used, we need to find a way to enable Wi-Fi tethering
    or a hotspot, as it is as well called, whenever the phone is connected to a power
    source. There are two cases that we might encounter, though:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的手机假设一直停在车上，并且只有在使用车辆时才会上电，因此我们需要找到一种方法，在手机连接到电源时启用Wi-Fi共享或热点。但我们可能会遇到两种情况：
- en: The battery has run out and the phone is turned off at night. Here, we need
    to find a way to turn on the phone whenever it gets powered up again. This happens
    when we start the car. When the phone is successfully turned on, we need to find
    a way to enable a hotspot.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电池已耗尽，手机在夜间关闭。在这种情况下，我们需要找到一种方法，以便在手机再次上电时打开手机。这发生在我们启动汽车时。当手机成功开机时，我们需要找到一种方法来启用热点。
- en: The phone still has enough battery to keep it turned on, but as it hasn't been
    used, the hotspot is disabled. Note that the only device using the phone's hotspot
    is the Pi and it is turned off if the car isn't being used. When we start the
    car again, the phone gets powered up from the USB contact. In this case, we need
    to enable the hotspot again.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手机仍然有足够的电池来保持其开启，但由于未被使用，热点已被禁用。请注意，使用手机热点的唯一设备是Pi，如果车辆未被使用，则其将被关闭。当我们再次启动汽车时，手机将从USB接触点上电。在这种情况下，我们需要再次启用热点。
- en: Automatic restart on power connect
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接电源时自动重启
- en: 'When we connect a turned off Samsung device to a power source, we will see
    a gray battery image with a turning arrow inside it. Then, when it begins charging
    the battery, we will see another colored battery image showing the current charge
    level. This second image is generated by a program that is triggered whenever
    a turned off device begins charging the battery. It is a binary file located in
    `/system/bin/playlpm` on the phone. We will change this file to a script of our
    own to reboot the device. In order to be able to edit this file, we need super
    user privileges. This is why we have rooted the phone. As an Android system is
    actually a Linux OS under the hood, we can run any Linux command on it. We can
    do this using an app that we can download from the Play Store, called **Terminal
    Emulator**:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将关闭的三星设备连接到电源时，我们将看到一个带有旋转箭头的灰色电池图像。然后，当它开始充电时，我们将看到另一个显示当前充电级别的彩色电池图像。这第二个图像是由一个程序生成的，该程序在关闭的设备开始充电电池时触发。它是手机上“/system/bin/playlpm”中的一个二进制文件。我们将更改此文件为我们自己的脚本以重新启动设备。为了能够编辑此文件，我们需要超级用户权限。这就是为什么我们对手机进行了root。由于Android系统实际上是一个Linux操作系统，我们可以在其下运行任何Linux命令。我们可以使用一个可以从Play商店下载的应用程序来做到这一点，名为**终端模拟器**：
- en: '![Automatic restart on power connect](img/image00145.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![连接电源时自动重启](img/image00145.jpeg)'
- en: The Terminal Emulator app screen
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 终端模拟器应用程序屏幕
- en: 'Now, issue the upcoming commands to change the contents of the `playlpm` file
    and make it an executable file. We need to also remount the `/system` directory
    in order to enable it for write operations:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，发出以下命令来更改“playlpm”文件的内容并使其成为可执行文件。我们还需要重新挂载“/system”目录，以便对其进行写操作：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Turn off the device and connect it to a power source. You will see that it turns
    on automatically after one minute. We have introduced the one minute delay because
    if the battery is totally discharged, it will not have enough capacity to restart
    the device. We want to wait at least one minute in these kinds of situations for
    the battery to get charged enough to restart the device. If it is not charged
    sufficiently, you might need to charge your phone before it can automatically
    restart. You can charge the phone without getting it restarted by putting it in
    to the recovery mode and then begin charging it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭设备并将其连接到电源。您会看到它在一分钟后自动开机。我们引入了一分钟的延迟，因为如果电池完全放电，它将没有足够的容量来重新启动设备。在这种情况下，我们希望至少等待一分钟，让电池充电到足以重新启动设备。如果充电不足，您可能需要在设备可以自动重新启动之前充电手机。您可以将手机放入恢复模式并开始充电，而无需重新启动手机。
- en: Auto tethering
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动共享
- en: Now we are able to restart the device on connecting it to a power source. We
    need to also enable tethering on the device when it wakes up or is connected to
    a power source. There are apps on the market that already do this, but the best
    ones are paid. This is one of the reasons that we will implement our own app for
    this purpose. The other reason is that it is fun.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在连接到电源时重新启动设备。当设备唤醒或连接到电源时，我们还需要启用设备上的共享。市场上已经有应用程序可以做到这一点，但最好的应用程序是收费的。这是我们要为此目的实现我们自己的应用程序的原因之一。另一个原因是这样做很有趣。
- en: We can create a new application in the Android Studio as we did before. We will
    not need any `Activity` for this application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以前一样在Android Studio中创建一个新的应用程序。对于这个应用程序，我们不需要任何“Activity”。
- en: 'Create a new java file, called `StartTetheringAtBootReceiver`, for `BroadcastReceiver`
    and add the following code in it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为“StartTetheringAtBootReceiver”的新java文件，用于“BroadcastReceiver”，并在其中添加以下代码：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This piece of code receives broadcast events whenever the phone is booted or
    connected to a power source, and enables tethering on the device with the default
    settings. If we'd like to change the name of the network or the password, we'll
    need to modify the settings on the device.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在手机启动或连接到电源时接收广播事件，并使用默认设置在设备上启用共享。如果我们想要更改网络名称或密码，我们需要修改设备上的设置。
- en: 'Add the manifest definition for the new broadcast receiver to `AndroidManifest.xml`
    inside the `application` tag:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将新广播接收器的清单定义添加到“AndroidManifest.xml”中的“application”标记内：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the following permission declarations inside the `manifest` tag:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在“manifest”标记内添加以下权限声明：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, install this app to your phone and see if the tethering is enabled whenever
    you reboot the device or connect a power cable to it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将此应用程序安装到您的手机上，并查看每当您重新启动设备或将电源线连接到设备时，共享是否已启用。
- en: 'We can optionally add a shortcut button for tethering in `MainActivity`. In
    the `activity_main.xml` file, add the following button definition:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`MainActivity`中可选地添加一个用于连接的快捷按钮。在`activity_main.xml`文件中，添加以下按钮定义：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, in the `MainAcitivty.java` file, define the handler for the button:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`MainAcitivty.java`文件中，为按钮定义处理程序：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we need to connect the Pi to the hotspot that we have created so far.
    Connecting the Pi to a Wi-Fi network was covered earlier, but let''s remind ourselves
    about this concept again. Add the upcoming lines of code to the `/etc/wpa_supplicant/wpa_supplicant.conf`
    file. We can configure the hotspot to apply WPA PSK security instead of PSK2:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将树莓派连接到我们迄今为止创建的热点。之前已经介绍了将树莓派连接到Wi-Fi网络，但让我们再次提醒自己这个概念。将以下代码添加到`/etc/wpa_supplicant/wpa_supplicant.conf`文件中。我们可以配置热点应用WPA
    PSK安全而不是PSK2：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we''ll reboot the Pi, and after a few minutes, we''ll see that it is automatically
    connected to a hotspot on the Android device in the hotspot settings window:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重新启动树莓派，几分钟后，我们将看到它自动连接到Android设备的热点，在热点设置窗口中：
- en: '![Auto tethering](img/image00146.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![自动连接](img/image00146.jpeg)'
- en: The list of connected devices is shown in hotspot settings in Android
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android的热点设置中显示已连接设备的列表
- en: You must be wondering why we have covered this content at this point. This is
    because in order to implement the next section, you'll most probably need to sit
    in your car and communicate with the Pi inside your car, where you most probably
    do not have more network access than the hotspot Android provides you with. Now,
    if you connect to the same hotspot on Android from your computer, you will be
    able to SSH to the Pi with a tool called **PuTTY** that you can install on Windows
    machines or using built in SSH terminal tool on a Mac.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定会想知道为什么我们在这个时候涵盖了这个内容。这是因为为了实现下一节，你很可能需要坐在你的车里，与你车内的树莓派进行通信，在那里你很可能没有比Android提供的热点更多的网络访问。现在，如果你从电脑上连接到Android上的同一个热点，你将能够使用一个叫做**PuTTY**的工具在Windows机器上安装，或者在Mac上使用内置的SSH终端工具来SSH到树莓派。
- en: Sending data to the cloud
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据发送到云端
- en: We will use a Google Docs spreadsheet to save data and a special Python library
    developed for this purpose. We begin doing this by creating an API key to access
    Google services.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Google Docs电子表格来保存数据，并使用专门为此目的开发的Python库。我们首先通过创建一个API密钥来访问Google服务来实现这一点。
- en: 'Browse to [https://console.developers.google.com/project](https://console.developers.google.com/project)
    and create an account for this purpose. When it''s ready, you will be directed
    to the Google Developer Console:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览[https://console.developers.google.com/project](https://console.developers.google.com/project)并为此目的创建一个帐户。当准备好时，您将被引导到Google
    Developer Console：
- en: '![Sending data to the cloud](img/image00147.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![将数据发送到云端](img/image00147.jpeg)'
- en: The Google Developer Console start page
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Google Developer Console的起始页面
- en: 'Here, we''ll need to create a new project in the **Select a project** drop-down
    menu. Give it a suitable name, accept the agreement, and click on **Create**.
    Select the newly created project, **APIs & auth**, and then select **APIs** from
    the menu on the left-hand side. Then, find and select **Drive API**, and press
    the **Enable API** button. When it is enabled, go to **Credentials** on the left-hand
    side menu under **APIs & auth**:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要在**选择项目**下拉菜单中创建一个新项目。给它一个合适的名字，接受协议，然后点击**创建**。选择新创建的项目，**APIs & auth**，然后从左侧菜单中选择**APIs**。然后，找到并选择**Drive
    API**，点击**启用API**按钮。当它被启用后，转到**APIs & auth**下的左侧菜单中的**凭据**：
- en: '![Sending data to the cloud](img/image00148.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![将数据发送到云端](img/image00148.jpeg)'
- en: The menu to enable OAuth in the Google Developer Console
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google Developer Console中启用OAuth的菜单
- en: 'Here, under **OAuth**, click on the **Create new Client ID** button. In the
    message box that appears, select the **Service account**, and click on the **Create
    Client ID** button. We''ll see a box telling us that we have successfully created
    **New public/private key pair** for the project. We''ll even see that the site
    has sent us a **JSON** file with credentials in it. For the dummy account I created,
    the contents looks similar to this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在**OAuth**下，点击**创建新的客户端ID**按钮。在出现的消息框中，选择**服务帐户**，然后点击**创建客户端ID**按钮。我们将看到一个框，告诉我们我们已成功为项目创建了**新的公共/私有密钥对**。我们甚至会看到网站已经向我们发送了一个带有凭据的**JSON**文件。对于我创建的虚拟帐户，内容看起来类似于这样：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can choose to generate a new key from the Developer Console site using the
    **Generate new JSON key** button for our project.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择使用Developer Console网站上的**生成新的JSON密钥**按钮为我们的项目生成新的密钥。
- en: 'At this stage, we need to generate a **P12** key using the **Generate new P12
    key** button. This file will be used later on. We will also be provided with a
    secret key when we download the file which we need to note down. The following
    screenshot illustrates the Google Developer Console after successful creation
    of the API key:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们需要使用**生成新的P12密钥**按钮生成一个**P12**密钥。这个文件将在以后使用。当我们下载文件时，还会提供一个秘钥，我们需要记下来。下面的截图展示了成功创建API密钥后的Google
    Developer Console：
- en: '![Sending data to the cloud](img/image00149.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![将数据发送到云端](img/image00149.jpeg)'
- en: Google Developer Console after successful API key creations
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 成功创建API密钥后的Google Developer Console
- en: 'Before we can install the Google Python library, we need to install a tool,
    called `pip`, which will help us install an OAuth client we will use to connect
    to Google services. Use the following commands to do this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们安装Google Python库之前，我们需要安装一个叫做`pip`的工具，它将帮助我们安装一个OAuth客户端，我们将用它来连接到Google服务。使用以下命令来完成这个过程：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, use this new `pip` tool to install the OAuth clients:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用这个新的`pip`工具来安装OAuth客户端：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next step is to download and install the client library to access Google
    Sheets on the Pi using the following commands:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是下载并安装客户端库，以使用以下命令在树莓派上访问Google Sheets：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Before we begin coding, we need to add a new spreadsheet on the [https://docs.google.com](https://docs.google.com)
    website. Select **Sheets** in the menu, create a new sheet using the plus (**+**)
    sign, and change the name from `Untitled spreadsheet` to `CAR_OBD_SHEET`. It should
    be saved automatically. We need to share this spreadsheet with the Google Developer
    Console client created for us when we generated the OAuth key pair. We''ll find
    a `client_email` field in the JSON file we''ve downloaded. We will share the new
    spreadsheet with this client. Now, open the `CAR_OBD_SHEET` spreadsheet in Google
    Docs and click on the **Share** button:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，我们需要在[https://docs.google.com](https://docs.google.com)网站上添加一个新的电子表格。在菜单中选择**表格**，使用加号（**+**）号创建一个新表格，并将名称从`Untitled
    spreadsheet`更改为`CAR_OBD_SHEET`。它应该会自动保存。我们需要与我们生成OAuth密钥对时为我们创建的Google开发者控制台客户端共享此电子表格。我们将在我们下载的JSON文件中找到一个`client_email`字段。我们将与此客户端共享新的电子表格。现在，在Google
    Docs中打开`CAR_OBD_SHEET`电子表格，并单击**共享**按钮：
- en: '![Sending data to the cloud](img/image00150.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![将数据发送到云端](img/image00150.jpeg)'
- en: Open the spreadsheet in Google Docs
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google Docs中打开电子表格
- en: 'In the pop-up window, paste `client_email` from the JSON file, then click on
    the **Send** button on the pop-up window. This will share the spreadsheet with
    the client generated when we created the OAuth key pair in the previous step:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出窗口中，粘贴JSON文件中的`client_email`，然后单击弹出窗口上的**发送**按钮。这将与在上一步创建OAuth密钥对时生成的客户端共享电子表格：
- en: '![Sending data to the cloud](img/image00151.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![将数据发送到云端](img/image00151.jpeg)'
- en: Sharing the spreadsheet with the generated client
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成的客户端共享电子表格
- en: 'Now, we will test to see if everything works fine. Create a file on the Pi,
    name it `send_to_sheet.py`, and put the following content in it. Do not forget
    to create the OAuth JSON file and put the contents of the one we have downloaded
    from the Google Developer Console and name it as `piandroidprojects.json`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将测试一下是否一切正常。在Pi上创建一个文件，命名为`send_to_sheet.py`，并将以下内容放入其中。不要忘记创建OAuth JSON文件，并将我们从Google开发者控制台下载的内容放入其中，并将其命名为`piandroidprojects.json`：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, run the file using the `python send_to_sheet.py` command, and we will see
    the update on the Google Docs sheet. The code will create a new worksheet named
    as the current timestamp and save a single value in this sheet. Note that Google
    allows 200 worksheets per sheet, and by default, 100 rows per worksheet; in our
    code, we create a new worksheet each time we run it. We need to clean the sheet
    from time to time in order to not to go beyond the limit.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`python send_to_sheet.py`命令运行该文件，我们将在Google Docs表格上看到更新。该代码将创建一个名为当前时间戳的新工作表，并在该工作表中保存一个单个值。请注意，Google允许每个表格200个工作表，默认情况下每个工作表100行；在我们的代码中，每次运行时都会创建一个新的工作表。我们需要定期清理工作表，以免超出限制。
- en: Putting it all together
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容放在一起
- en: In the next two sections, we will put together what we have done so far. First,
    we'll begin by sending data to the Google Docs sheet. Then, we will build an Android
    app to show the data on a map.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将总结到目前为止所做的工作。首先，我们将开始将数据发送到Google Docs表格。然后，我们将构建一个Android应用程序来在地图上显示数据。
- en: Sending measurements
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送测量数据
- en: 'We will use a Python script to access GPS data on the Pi that we''ll need to
    run on system reboot. For this purpose, add the following code at the end of the
    `/etc/rc.local` file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个Python脚本来访问Pi上的GPS数据，我们需要在系统重新启动时运行该脚本。为此，在`/etc/rc.local`文件的末尾添加以下代码：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we can restart the GPS services, connect to the OBD Bluetooth dongle,
    create a log file, and start the `sender.py` script that we will implement next:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以重新启动GPS服务，连接到OBD蓝牙适配器，创建日志文件，并启动我们将在下一步实现的`sender.py`脚本：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The code begins running at the end where we define `json_key` by loading the
    JSON key file. Then, we'll try to authorize using the `gspread.authorize(credentials)`
    method. The next step is to create a new worksheet with the date timestamp as
    the title, and then start to consume the GPS data in another thread defined by
    the `GpsPoller` class. Next, we'll initiate the `OBD_Sender` class and connect
    to the ODB Bluetooth device twice. The connect operation may fail when it's executed
    for the first time, but it almost always succeeds when it's run a second time.
    Then, we need to run the `get_data` method of the `OBD_Sender` class to begin
    the loop.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从定义`json_key`的末尾开始运行，加载JSON密钥文件。然后，我们将尝试使用`gspread.authorize(credentials)`方法进行授权。下一步是创建一个以日期时间戳为标题的新工作表，然后在由`GpsPoller`类定义的另一个线程中开始消耗GPS数据。接下来，我们将初始化`OBD_Sender`类并两次连接到OBD蓝牙设备。当执行连接操作时，第一次可能会失败，但第二次几乎总是成功。然后，我们需要运行`OBD_Sender`类的`get_data`方法来开始循环。
- en: The `GpsPoller` class consumes all the values of the GPS device connected to
    the serial USB port. This is required in order to get the most recent values whenever
    we access the `gpsd.fix.latitude` and `gpsd.fix.longitude` variables.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`GpsPoller`类消耗了连接到串行USB端口的GPS设备的所有值。这是为了在访问`gpsd.fix.latitude`和`gpsd.fix.longitude`变量时获得最新的值。'
- en: 'The `get_data` method of the `OBD_Sender` class sends the local time, latitude,
    and longitude values to the spreadsheet, and it also sends seven different readings
    defined in `self.sensorlist = [3,4,5,12,13,31,32]`. We can see these values from
    the `SENSORS` list in the `obd_sensors.py` file. For your information, these are
    the Fuel System Status, Calculated Load Value, Coolant Temp, Engine RPM, Vehicle
    Speed, Engine Start MIN, and Engine Run MIL values. We can change the indexes
    to read the values that we want. Take a look at additional values at [https://en.wikipedia.org/wiki/OBD-II_PIDs](https://en.wikipedia.org/wiki/OBD-II_PIDs).
    We go through these codes, read their current values, and send them to the different
    cells of a current row on our worksheet. After starting and driving your car around,
    you can see that the data is uploaded to the spreadsheet, as shown in the following
    screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`OBD_Sender`类的`get_data`方法将本地时间、纬度和经度值发送到电子表格，并且还发送了在`self.sensorlist = [3,4,5,12,13,31,32]`中定义的七个不同的读数。我们可以在`obd_sensors.py`文件的`SENSORS`列表中看到这些值。供您参考，这些是燃油系统状态、计算负荷值、冷却液温度、发动机转速、车速、发动机启动分钟和发动机运行MIL值。我们可以更改索引以读取我们想要的值。在[https://en.wikipedia.org/wiki/OBD-II_PIDs](https://en.wikipedia.org/wiki/OBD-II_PIDs)上查看其他值。我们遍历这些代码，读取它们的当前值，并将它们发送到工作表的当前行的不同单元格中。启动并驾驶您的汽车后，您会看到数据上传到电子表格，如下面的屏幕截图所示：'
- en: '![Sending measurements](img/image00152.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![发送测量值](img/image00152.jpeg)'
- en: Data uploaded to the spreadsheet
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 数据上传到电子表格
- en: Retrieving measurements
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索测量值
- en: We will build our very own app to download the measurement values and show them
    on a map. Create a new blank project in the Android Studio, and choose to include
    a Google Maps Activity during the last step of create project wizard. I've used
    Android 4.3 as the base SDK for this project; I will name my main activity as
    `MapsActivity`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建我们自己的应用程序来下载测量值并在地图上显示它们。在Android Studio中创建一个新的空白项目，并在创建项目向导的最后一步选择包含Google地图活动。我将Android
    4.3作为此项目的基本SDK；我将把我的主要活动命名为`MapsActivity`。
- en: 'To access Google Docs and download the content of the spreadsheet, we will
    use some of the Java libraries provided by Google. They are located at different
    places. Download the ZIP files from the following locations:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问Google文档并下载电子表格的内容，我们将使用Google提供的一些Java库。它们位于不同的位置。从以下位置下载ZIP文件：
- en: A general purpose Java client for Google data services is located at [https://github.com/google/gdata-java-client](https://github.com/google/gdata-java-client),
    and the file is named as `gdata-src.java-*.zip`, which is found under the **Source**
    link.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google数据服务的通用Java客户端位于[https://github.com/google/gdata-java-client](https://github.com/google/gdata-java-client)，文件名为`gdata-src.java-*.zip`，位于**Source**链接下。
- en: Download the HTTP client from [https://developers.google.com/api-client-library/java/google-http-java-client/download](https://developers.google.com/api-client-library/java/google-http-java-client/download)
    which is named as `google-http-java-client-featured.zip`. We will use this to
    authorize ourselves.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[https://developers.google.com/api-client-library/java/google-http-java-client/download](https://developers.google.com/api-client-library/java/google-http-java-client/download)下载HTTP客户端，名称为`google-http-java-client-featured.zip`。我们将使用这个来进行授权。
- en: Download the OAuth client contained in `google-oauth-java-client-featured.zip`,
    which is available at [https://developers.google.com/api-client-library/java/google-oauth-java-client/download](https://developers.google.com/api-client-library/java/google-oauth-java-client/download)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[https://developers.google.com/api-client-library/java/google-oauth-java-client/download](https://developers.google.com/api-client-library/java/google-oauth-java-client/download)下载包含OAuth客户端的`google-oauth-java-client-featured.zip`。
- en: 'Now, open these ZIP files, locate the following JAR libraries, and move them
    to the `libs` folder under your Android `app` directory:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开这些ZIP文件，找到以下JAR库，并将它们移动到Android `app`目录下的`libs`文件夹中：
- en: '`gdata-base-1.0.jar`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gdata-base-1.0.jar`'
- en: '`gdata-core-1.0.jar`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gdata-core-1.0.jar`'
- en: '`gdata-spreadsheet-3.0.jar`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gdata-spreadsheet-3.0.jar`'
- en: '`google-api-client-1.20.0.jar`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google-api-client-1.20.0.jar`'
- en: '`google-http-client-1.20.0.jar`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google-http-client-1.20.0.jar`'
- en: '`google-http-client-jackson-1.20.0.jar`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google-http-client-jackson-1.20.0.jar`'
- en: '`google-oauth-client-1.20.0.jar`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google-oauth-client-1.20.0.jar`'
- en: '`guava-11.0.2.jar`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`guava-11.0.2.jar`'
- en: '`jackson-core-asl-1.9.11.jar`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jackson-core-asl-1.9.11.jar`'
- en: To include these libraries in your Android project, you need to add them to
    the `build.gradle` file for `Module:app`. To do this, add the following code under
    the `dependencies` tag.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些库包含在您的Android项目中，您需要将它们添加到`build.gradle`文件的`Module:app`下。为此，请在`dependencies`标签下添加以下代码。
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When you edit the `build.gradle` file, you might get a message in Android, stating
    that **Gradle files has changed since last project sync. A project sync maybe
    necessary for the IDE to work properly**. Click on the **Sync Now** link located
    near this notification to update the project.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编辑`build.gradle`文件时，您可能会在Android中收到一条消息，指出**Gradle文件自上次项目同步以来已更改。可能需要进行项目同步以使IDE正常工作**。单击附近的**立即同步**链接以更新项目。
- en: The next step is to move the `P12` key file, which we have downloaded from the
    Google Developer Console, and include it in our Android project. We need to copy
    this file in the `raw` directory located at `PROJECT_HOME\app\src\main\res\raw`
    and rename it as `piandroidprojects.p12`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是移动我们从Google开发者控制台下载的`P12`密钥文件，并将其包含在我们的Android项目中。我们需要将此文件复制到位于`PROJECT_HOME\app\src\main\res\raw`的`raw`目录中，并将其重命名为`piandroidprojects.p12`。
- en: As we plan to show the content on a map, we will use Google's Map API for this
    purpose. To use it, we need an access API key. Go to the developer console again
    at [https://console.developers.google.com/project](https://console.developers.google.com/project),
    and select the project that we've created previously. In the menu located on the
    left-hand side, choose **APIs** under **APIS & auth**, then, **Google Maps Android
    API**, and finally, click on the **Enable API** button. Next, navigate to **Credential**s,
    and click on the **Create new key** button under the **Public API access** section.
    We need to choose **Android key** in the window that pops up. Copy the generated
    **API key** and replace it with the `YOUR_KEY_HERE` string in the `google_maps_api.xml`
    file. Now, we are ready with our Android project setup, and it is time to code
    now.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们计划在地图上显示内容，因此我们将使用 Google 的地图 API。为了使用它，我们需要一个访问 API 密钥。再次转到开发者控制台 [https://console.developers.google.com/project](https://console.developers.google.com/project)，并选择我们之前创建的项目。在左侧的菜单中，选择
    **APIs** 下的 **APIS & auth**，然后选择 **Google Maps Android API**，最后，单击 **启用 API**
    按钮。接下来，转到 **凭据**，并在 **公共 API 访问** 部分下单击 **创建新密钥** 按钮。我们需要在弹出的窗口中选择 **Android 密钥**。复制生成的
    **API 密钥**，并将其替换为 `google_maps_api.xml` 文件中的 `YOUR_KEY_HERE` 字符串。现在，我们已经准备好了我们的
    Android 项目设置，现在是编写代码的时候了。
- en: 'The first thing to do in the code is download a list of sheets from Google
    Docs. There is one sheet for each restart of the Pi. Add the following code inside
    the `onCreate` method of the `MapsActivity.java` file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中要做的第一件事是从 Google Docs 下载工作表列表。每次 Pi 重新启动时都会有一个工作表。将以下代码添加到 `MapsActivity.java`
    文件的 `onCreate` 方法中：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This piece of code will create an asynchronous task that is implemented as
    an Android `AsyncTask`, which downloads and presents the spreadsheets. Let''s
    define the task class in the same file as well:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将创建一个异步任务，该任务实现为 Android 的 `AsyncTask`，用于下载和显示电子表格。让我们在同一文件中定义任务类：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Before we describe the preceding code, define an instance variable for the
    spreadsheet service, which is used in the task we have just defined:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们描述上述代码之前，为电子表格服务定义一个实例变量，该变量在我们刚刚定义的任务中使用：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The Android `AsyncTask` requires us to override the `doInBackground` method,
    which is executed in a new thread whenever we call the `execute` method of the
    task that we performed in `onCreate`. In `doInBackground`, we will define `KeyStore`,
    and load the `P12` file that we've downloaded from the Google Developer Console
    and copied to the `raw` directory of our Android project. Note that `notasecret`
    was the secret that the Developer Console informed me about when I created and
    downloaded the `P12` file. Also, inside the `setServiceAccountId` method, you'll
    need to use your own account name. You can find it in the Developer Console under
    the **Service account** section in the **Email address** field as well as in the
    JSON key file **client_email** field. In the background method, after loading
    the key file and defining the credentials, we'll authorize ourselves to Google
    Spreadsheets service using OAuth. We'll simply get the first spreadsheet that
    I assume is `CAR_OBD_SHEET` and return the worksheets in it. We could go through
    all the spreadsheets and search for the title as well, but I will skip this part
    of the code and assume that you have only one spreadsheet in your account with
    the title as `CAR_OBD_SHEET`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的 `AsyncTask` 要求我们重写 `doInBackground` 方法，每当我们调用 `onCreate` 中执行的任务的 `execute`
    方法时，它就会在新线程中执行。在 `doInBackground` 中，我们将定义 `KeyStore`，并加载我们从 Google Developer Console
    下载并复制到 Android 项目的 `raw` 目录中的 `P12` 文件。请注意，`notasecret` 是开发者控制台在我创建和下载 `P12` 文件时通知我的秘密。此外，在
    `setServiceAccountId` 方法内，您需要使用自己的帐户名。您可以在开发者控制台的 **服务帐户** 部分的 **电子邮件地址** 字段以及
    JSON 密钥文件的 **client_email** 字段中找到它。在加载密钥文件并定义凭据之后，我们将使用 OAuth 授权自己访问 Google 电子表格服务。我们将简单地获取我假设是
    `CAR_OBD_SHEET` 的第一个电子表格，并返回其中的工作表。我们也可以遍历所有电子表格并搜索标题，但我将跳过此部分代码，并假设您的帐户中只有一个标题为
    `CAR_OBD_SHEET` 的电子表格。
- en: The second function we'll define is `onPostExecute`. This function is called
    inside the UI thread by the Android system whenever background processing is performed.
    It is important that this is run in the UI thread as we cannot touch UI elements
    if we run UI-related code in non-UI threads.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义的第二个函数是 `onPostExecute`。每当后台处理时，此函数由 Android 系统在 UI 线程中调用。重要的是，这在 UI 线程中运行，因为如果我们在非
    UI 线程中运行与 UI 相关的代码，就无法触摸 UI 元素。
- en: 'Note here that the return value of the `doInBackground` method is sent as a
    parameter to the `onPostExecute` method, which is a list of worksheets found in
    a sheet in the Google Docs service. We''ll go through this list and collect the
    titles in another list. Then, we''ll show this list in a pop-up dialog box, which
    a user can click on and select. Whenever the user selects one of the worksheets,
    Android calls the `onClick` method of `DialogInterface.OnClickListener`, which
    we have sent in as a parameter to the adapter of `AlertDialog`. This method calls
    the `execute` method of another `AsyncTask` that we''ll call `RetrieveWorksheetContent`,
    which, as the name implies, retrieves the content of the selected worksheet. Here
    is the definition for this task:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`doInBackground` 方法的返回值作为参数发送到 `onPostExecute` 方法，这是在 Google Docs 服务中找到的工作表的列表。我们将遍历此列表并将标题收集到另一个列表中。然后，我们将在弹出对话框中显示此列表，用户可以单击并选择。每当用户选择工作表之一时，Android
    将调用 `DialogInterface.OnClickListener` 的 `onClick` 方法，我们已将其作为参数发送到 `AlertDialog`
    的适配器中。此方法调用另一个名为 `RetrieveWorksheetContent` 的 `AsyncTask` 的 `execute` 方法，正如名称所示，它检索所选工作表的内容。以下是此任务的定义：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, the most important part is where we iterate through `feed.getEntries()`,
    which refers to all the rows in the spreadsheet and the part where we iterate
    through `entry.getCustomElements().getTags()`, refers to all the columns. Then,
    in `onPostExecute`, we''ll call the `setUpMap` method with all the values that
    we have retrieved. Inside this method, we''ll create markers on the map that is
    contained in **MapsActivity**. Comment out the automatically defined `setUpMap`
    method if you do not want a marker at location `0`,`0`, which Android Studio has
    defined for you as an example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，最重要的部分是我们遍历`feed.getEntries()`，它指的是电子表格中的所有行，以及我们遍历`entry.getCustomElements().getTags()`的部分，它指的是所有的列。然后，在`onPostExecute`中，我们将使用我们检索到的所有值调用`setUpMap`方法。在这个方法内部，我们将在**MapsActivity**中包含的地图上创建标记。如果您不希望在位置`0`,`0`处有一个标记，可以注释掉Android
    Studio为您自动定义的`setUpMap`方法作为示例：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When you start the app, you will see a list of spreadsheets to choose from:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动应用程序时，您将看到一个可供选择的电子表格列表：
- en: '![Retrieving measurements](img/image00153.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![检索测量数据](img/image00153.jpeg)'
- en: The list of spreadsheets
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格列表
- en: 'Next, after selecting one of these sheets, you can see the data on the map:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在选择这些表格中的一个之后，您可以在地图上看到数据：
- en: '![Retrieving measurements](img/image00154.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![检索测量数据](img/image00154.jpeg)'
- en: The data points on the map
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 地图上的数据点
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a lot of content, ranging from car diagnostics to
    Android device root process. We even covered a lot of Android code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容，从汽车诊断到Android设备的root过程。我们甚至涵盖了大量的Android代码。
- en: I hope that all of you have fun implementing these exciting projects, will try
    to enhance them and making them better than I did.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你们所有人都能乐在其中，实现这些令人兴奋的项目，会尝试改进它们，使它们比我做得更好。
