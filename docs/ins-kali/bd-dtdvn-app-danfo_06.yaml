- en: '*Chapter 4*: **Data Analysis, Wrangling, and Transformation**'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：**数据分析、整理和转换**'
- en: '**Data analysis**, **wrangling**, and **transformation** are important aspects
    of any data-driven project, and the majority of your time as a data analyst/scientist
    will be spent doing one form of data processing or the other. While JavaScript
    is a flexible language with good features for manipulating data structures, it
    is quite tedious to write utility functions to perform data wrangling operations
    all the time. As such, we have built powerful data wrangling and transformation
    features into Danfo.js, and this can greatly reduce the time that''s spent on
    this stage.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据分析**、**整理**和**转换**是任何数据驱动项目的重要方面，作为数据分析师/科学家，您大部分时间将花在进行一种形式的数据处理或另一种形式上。虽然JavaScript是一种灵活的语言，具有良好的用于操作数据结构的功能，但编写实用程序函数来执行数据整理操作非常繁琐。因此，我们在Danfo.js中构建了强大的数据整理和转换功能，这可以大大减少在此阶段花费的时间。'
- en: In this chapter, we will show you how to practically use Danfo.js on real-world
    datasets. You'll learn how to load different types of datasets and analyze them
    by performing operations such as handling missing values, calculating descriptive
    statistics, performing mathematical operations, combining datasets, and performing
    string manipulations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示如何在真实数据集上实际使用Danfo.js。您将学习如何加载不同类型的数据集，并通过执行操作（如处理缺失值、计算描述性统计、执行数学运算、合并数据集和执行字符串操作）来分析它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Transforming data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换数据
- en: Combining datasets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并数据集
- en: Series data accessors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Series数据访问器
- en: Calculating statistics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算统计数据
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with this chapter, you should have the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章，您应该具备以下条件：
- en: A modern browser such as Chrome, Safari, Opera, or Firefox
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代浏览器，如Chrome、Safari、Opera或Firefox
- en: Node.js, Danfo.js, and Dnotebook installed on your system
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js、Danfo.js和Dnotebook已安装在您的系统上
- en: A stable internet connection for downloading datasets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定的互联网连接用于下载数据集
- en: The installation instructions for Danfo.js can be found in [*Chapter 3*](B17076_03_ePub_RK.xhtml#_idTextAnchor066),
    *Getting Started with Danfo.js*, while the installation steps for Dnotebook can
    be found in [*Chapter 2*](B17076_02_ePub_RK.xhtml#_idTextAnchor045), *Dnotebook
    – An Interactive Computing Environment for JavaScript*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js的安装说明可以在[*第3章*](B17076_03_ePub_RK.xhtml#_idTextAnchor066)中找到，*开始使用Danfo.js*，而Dnotebook的安装步骤可以在[*第2章*](B17076_02_ePub_RK.xhtml#_idTextAnchor045)中找到，*Dnotebook
    – JavaScript的交互式计算环境*。
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you do not want to install any software or library, you can use the online
    version of Dnotebook at [https://playnotebook.jsdata.org/](https://playnotebook.jsdata.org/).
    However, don't forget to install the latest version of Danfo.js before using any
    functionality!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想安装任何软件或库，可以使用Dnotebook的在线版本[https://playnotebook.jsdata.org/](https://playnotebook.jsdata.org/)。但是，在使用任何功能之前，请不要忘记安装最新版本的Danfo.js！
- en: Transforming data
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换数据
- en: Data transformation is the process of converting data from one format (master
    format) into another (target format) based on defined steps/processes. Data transformation
    can be simple or complex, depending on the structure, format, end goal, size,
    or complexity of the dataset, and as such, it is important to know the features
    that are available in Danfo.js for doing these transformations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据转换是根据定义的步骤/过程将数据从一种格式（主格式）转换为另一种格式（目标格式）的过程。数据转换可以是简单的或复杂的，取决于数据集的结构、格式、最终目标、大小或复杂性，因此重要的是要了解Danfo.js中用于进行这些转换的功能。
- en: In this section, we'll introduce some features available in Danfo.js for doing
    data transformation. Under each sub-section, we'll introduce a couple of functions,
    including `fillna`, `drop_duplicates`, `map`, `addColumns`, `apply`, `query`,
    and `sample`, as well as functions for encoding data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍Danfo.js中用于进行数据转换的一些功能。在每个子节下，我们将介绍一些函数，包括`fillna`、`drop_duplicates`、`map`、`addColumns`、`apply`、`query`和`sample`，以及用于编码数据的函数。
- en: Replacing missing values
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换缺失值
- en: Many datasets come with missing values and in order to get the most out of these
    datasets, we must do some form of data filling/replacement. Danfo.js provides
    a `fillna` method that, when given a DataFrame or Series, can automatically fill
    any missing field with the specified value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据集都存在缺失值，为了充分利用这些数据集，我们必须进行某种形式的数据填充/替换。Danfo.js提供了`fillna`方法，当给定DataFrame或Series时，可以自动用指定的值填充任何缺失字段。
- en: When you load a dataset into Danfo.js data structures, all the missing values,
    which can be undefined, empty, null, none, and so on, are stored as `NaN`, and
    as such, the `fillna` method can easily find and replace them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将数据集加载到Danfo.js数据结构中时，所有缺失值（可能是未定义的、空的、null、none等）都存储为`NaN`，因此`fillna`方法可以轻松找到并替换它们。
- en: Replacing values in a Series
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换Series中的值
- en: 'The signature of the `fillna` method of a `Series` object is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series`对象的`fillna`方法的签名如下：'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `value` parameter is the new value you want to use for replacing missing
    values, while the `inplace` parameter is used to specify whether to make changes
    directly to the object or a copy. Let's look at an example of this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`参数是您想要用于替换缺失值的新值，而`inplace`参数用于指定是直接对对象进行更改还是创建副本。让我们看一个例子。'
- en: 'Let''s assume we have the following Series:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下Series：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In your Dnotebook environment, `table(sdata)` will display the table shown
    in the following figure:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Dnotebook环境中，`table(sdata)`将显示如下图所示的表格：
- en: '![Figure 4.1 – Series with missing values'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – 具有缺失值的Series'
- en: '](img/B17076_4_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_01.jpg)'
- en: Figure 4.1 – Series with missing values
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 具有缺失值的Series
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are working in a browser or the Node.js environment, you can view the
    output of the `print` function in the console.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器或Node.js环境中工作，可以在控制台中查看`print`函数的输出。
- en: 'To replace the missing values (`NaN`), we can do the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换缺失值（`NaN`），我们可以这样做：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Printing the output gives us the following table:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 打印输出给我们以下表格：
- en: '![Figure 4.2 – Series with missing values'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – 带有缺失值的Series'
- en: '](img/B17076_4_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_02.jpg)'
- en: Figure 4.2 – Series with missing values
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 带有缺失值的Series
- en: 'You can also fill missing values in place, that is, you can directly mutate
    the object, instead of creating a new one. This can be seen in the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以原地填充缺失值，也就是说，你可以直接改变对象，而不是创建一个新的对象。这可以在以下代码中看到：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Filling in place can help reduce memory usage in scenarios where you are working
    with large DataFrames or Series.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，原地填充可以帮助减少内存使用，特别是在处理大型DataFrame或Series时。
- en: Replacing values in DataFrames
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换DataFrame中的值
- en: 'The `fillna` function can also be used to fill in missing values in a DataFrame.
    The signature of the `fillna` method of a DataFrame object is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillna` 函数也可以用于填充DataFrame中的缺失值。DataFrame对象的 `fillna` 方法的签名如下：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, let''s understand the parameters:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解参数：
- en: '`columns`: The `columns` parameter is the array of column names that you want
    to fill.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`columns`: `columns` 参数是要填充的列名数组。'
- en: '`values`: The `values` parameter, which is also an array and must be the same
    size as `columns`, holds the corresponding values you want to replace with.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values`: `values` 参数也是一个数组，必须与 `columns` 的大小相同，保存你想要替换的相应值。'
- en: '`inplace`: This specifies whether we should modify the current DataFrame or
    return a new one.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inplace`: 这指定我们是否应修改当前的DataFrame还是返回一个新的DataFrame。'
- en: Now, let's look at an example.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个例子。
- en: 'Let''s assume we have the following DataFrame:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下DataFrame：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of the code is shown in the following figure:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下图所示：
- en: '![Figure 4.3 – DataFrame with missing values'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 – 带有缺失值的DataFrame'
- en: '](img/B17076_4_03.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_03.jpg)'
- en: Figure 4.3 – DataFrame with missing values
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 带有缺失值的DataFrame
- en: 'In terms of filling in the missing values, there are two ways we can approach
    this. First, we can fill in all the missing fields with single values, as shown
    in the following code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在填充缺失值方面，我们可以采取两种方法。首先，我们可以用单个值填充所有缺失字段，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code output is shown in the following figure:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码输出如下图所示：
- en: '![Figure 4.4 – Filling in all the missing values in a DataFrame with a single
    value'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 – 用单个值填充DataFrame中的所有缺失值'
- en: '](img/B17076_4_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_04.jpg)'
- en: Figure 4.4 – Filling in all the missing values in a DataFrame with a single
    value
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 用单个值填充DataFrame中的所有缺失值
- en: The majority of the time, when working with DataFrames, filling in all the missing
    values with the same field is not advisable or even useful, as you must take into
    consideration the fact that different fields have different types of values, which
    means the filling strategies will differ.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理DataFrame时，用同一个字段填充所有缺失值的情况并不可取，甚至没有用，因为你必须考虑到不同字段具有不同类型的值，这意味着填充策略会有所不同。
- en: To handle such cases, we can specify a list of columns and their corresponding
    values to fill them, as we will show here.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种情况，我们可以指定要填充的列及其相应的值的列表，如下所示。
- en: 'Using the same DataFrame we used in the previous example, we can specify the
    `Name` and `Count` columns and fill them with the `Apples` and `–99` values, as
    follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面例子中使用的相同DataFrame，我们可以指定 `Name` 和 `Count` 列，并用 `Apples` 和 `-99` 值填充它们，如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code''s output is shown in the following figure:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下图所示：
- en: '![Figure 4.5 – Filling in the missing values in a DataFrame with specific values'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 – 用特定值填充DataFrame中的缺失值'
- en: '](img/B17076_4_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_05.jpg)'
- en: Figure 4.5 – Filling in the missing values in a DataFrame with specific values
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 用特定值填充DataFrame中的缺失值
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Fill values such as -9, -99, and -999 are commonly used to indicate missingness
    in data analytics.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据分析中，常用填充值如-9、-99和-999来表示缺失值。
- en: Let's see how to remove duplicates in the next section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在下一节中删除重复项。
- en: Removing duplicates
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除重复项
- en: 'Duplicate fields are common scenarios when working with Series or columns in
    a DataFrame. For example, take a look at the Series in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Series或DataFrame中的列时，重复字段是常见的情况。例如，看一下以下代码中的Series：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code''s output is shown in the following figure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下图所示：
- en: '![Figure 4.6 – Series with duplicate fields'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 – 带有重复字段的Series'
- en: '](img/B17076_4_06.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_06.jpg)'
- en: Figure 4.6 – Series with duplicate fields
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 带有重复字段的Series
- en: 'In the preceding figure, you can see that the value `10` occurs multiple times.
    If the need arises, you can easily drop/remove these duplicates with the `drop_duplicates`
    function. The signature of the `drop_duplicates` function is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，你可以看到值 `10` 出现了多次。如果有需要，你可以使用 `drop_duplicates` 函数轻松删除这些重复项。`drop_duplicates`
    函数的签名如下：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `drop_duplicates` function has just two parameters, and the first parameter
    (`inplace`) is pretty self-explanatory. The second parameter, `keep`, can be used
    to specify which of the duplicates to keep. You can either keep the first or last
    duplicate in a Series. This helps preserve the structure and order or values in
    a Series after dropping duplicates.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`drop_duplicates` 函数只有两个参数，第一个参数（`inplace`）非常直观。第二个参数 `keep` 可以用于指定要保留哪个重复项。你可以保留Series中的第一个或最后一个重复项。这有助于在删除重复项后保持Series中的结构和值的顺序。'
- en: 'Let''s see this in action. In the following code block, we are dropping all
    the duplicate values and keeping just the first occurrence:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个实例。在下面的代码块中，我们正在删除所有重复的值，只保留第一次出现的值：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code''s output is shown in the following figure:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下图所示：
- en: '![Figure 4.7 – Series after dropping duplicates with keep set to first'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7 – 在keep设置为first的情况下删除重复项后的Series'
- en: '](img/B17076_4_07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_07.jpg)'
- en: Figure 4.7 – Series after dropping duplicates with keep set to first
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 在keep设置为first的情况下删除重复项后的Series
- en: 'Looking at the preceding output, you can see that the first value of the duplicates
    is kept while the others are dropped. In contrast, let''s set the `keep` parameter
    to `last` and watch the order of the fields change:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，您可以看到保留了重复项的第一个值，而其他值被丢弃。相反，让我们将`keep`参数设置为`last`，并观察字段的顺序变化：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code''s output is shown in the following figure:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下图所示：
- en: '![Figure 4.8 – Series after dropping duplicates with keep set to last'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8 - 在保留最后一个重复项的情况下删除重复项后的Series'
- en: '](img/B17076_4_08.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_08.jpg)'
- en: Figure 4.8 – Series after dropping duplicates with keep set to last
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 - 在保留最后一个重复项的情况下删除重复项后的Series
- en: 'Notice that the last `10` and `20` duplicates fields are kept, and that the
    order is different from when we set `keep` to `first`. The following figure will
    help you understand the `keep` parameter when dropping duplicates:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，保留了最后的`10`和`20`重复字段，并且顺序与我们将`keep`设置为`first`时不同。下图将帮助您理解在删除重复项时`keep`参数的含义：
- en: '![Figure 4.9 – Difference between the output when keep is set to first or last'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9 - 当keep设置为first或last时的输出差异'
- en: '](img/B17076_4_09.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_09.jpg)'
- en: Figure 4.9 – Difference between the output when keep is set to first or last
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 - 当keep设置为first或last时的输出差异
- en: From the preceding figure, you'll observe that the major difference between
    setting `keep` to `first` or `last` is the order of the resulting values.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图中，您会注意到将`keep`设置为`first`或`last`的主要区别是生成值的顺序。
- en: In the next sub-section, we'll look at data transformation with the `map` function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将使用`map`函数进行数据转换。
- en: Data transformation with the map function
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`map`函数进行数据转换
- en: In some cases, you may want to apply a transformation to each value in a Series
    or DataFrame column. This is usually useful when you have some custom function
    or mapping and want to apply it easily to each field. Danfo.js provides a simple
    interface called `map` that can be used here. Let's see an example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望对Series或DataFrame列中的每个值应用转换。当您有一些自定义函数或映射并希望轻松应用它们到每个字段时，这通常很有用。Danfo.js提供了一个称为`map`的简单接口，可以在这里使用。让我们看一个例子。
- en: 'Let''s assume we have a DataFrame of items and their corresponding weights
    in `grams`, as shown in the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含物品及其对应的重量（以克为单位）的DataFrame，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The code''s output is shown in the following figure:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下图所示：
- en: '![Figure 4.10 – DataFrame with items and their corresponding weights in grams'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10 - DataFrame中物品及其对应的重量（以克为单位）'
- en: '](img/B17076_4_10.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_10.jpg)'
- en: Figure 4.10 – DataFrame with items and their corresponding weights in grams
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 - DataFrame中物品及其对应的重量（以克为单位）
- en: 'We want to create a new column called `kilograms`, whose values are the corresponding
    grams but converted into kilograms. Here, we can do the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建一个名为`kilograms`的新列，其值是相应的克数，但转换为千克。在这里，我们可以这样做：
- en: 'Create a `convertToKg` function with the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`convertToKg`的函数，代码如下：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Call the `map` function on the `grams` column, as shown in the following code
    block:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`grams`列上调用`map`函数，如下面的代码块所示：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the new `kilograms` column to the DataFrame using the `addColumn` function,
    as shown in the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`addColumn`函数将新的`kilograms`列添加到DataFrame中，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Putting this all together, we have the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们有以下代码：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code output is shown in the following figure:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下图所示：
- en: '![Figure 4.11 – DataFrame with items and their corresponding weights in grams'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11 - DataFrame中物品及其对应的重量（以克为单位）'
- en: '](img/B17076_4_11.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_11.jpg)'
- en: Figure 4.11 – DataFrame with items and their corresponding weights in grams
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 - DataFrame中物品及其对应的重量（以克为单位）
- en: The `map` function can also perform one-to-one mapping when you pass it an object
    with key-value pairs. This can be used for things such as encoding, quick mapping,
    and so on. Let's see an example of this.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将一个对象与键值对传递给`map`函数时，`map`函数也可以执行一对一的映射。这可用于诸如编码、快速映射等情况。让我们看一个例子。
- en: 'Let''s assume we have the following Series:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下Series：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we want to map each numeric value to its corresponding name. We can specify
    a `mapper` object and pass it to the `map` function, as shown in the following
    code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想要将每个数字值映射到其对应的名称。我们可以指定一个`mapper`对象并将其传递给`map`函数，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The code''s output is shown in the following figure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下图所示：
- en: '![Figure 4.12 – Series with numeric values mapped to string names'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.12 - 数值映射为字符串名称的Series'
- en: '](img/B17076_4_12.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_12.jpg)'
- en: Figure 4.12 – Series with numeric values mapped to string names
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 - 数值映射为字符串名称的Series
- en: The `map` function is very useful when working with Series, but sometimes, you
    may want to apply functions to specific axes (rows or columns). In such scenarios,
    you can use another Danfo.js function called the `apply` function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`函数在处理Series时非常有用，但有时您可能希望将函数应用于特定轴（行或列）。在这种情况下，您可以使用另一个Danfo.js函数，称为`apply`函数。'
- en: In the next section, we'll introduce the `apply` function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍`apply`函数。
- en: Data transformation with the apply function
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`apply`函数进行数据转换
- en: The `apply` function can be used to map functions or transformations to a specific
    axis in a DataFrame. It is a little more advanced and powerful than the `map`
    function, and we'll explain why.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`函数可用于将函数或转换映射到DataFrame中的特定轴。它比`map`函数稍微高级和强大，我们将解释原因。'
- en: 'First is the fact that we can apply tensor operations across a specified axis.
    Let''s take a look at a DataFrame that contains the following values:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是我们可以在指定的轴上应用张量操作的事实。让我们看一个包含以下值的DataFrame：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The code''s output is shown in the following figure:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下图所示：
- en: '![Figure 4.13 – Sample DataFrame with three columns'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.13 - 具有三列的示例DataFrame'
- en: '](img/B17076_4_13.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_13.jpg)'
- en: Figure 4.13 – Sample DataFrame with three columns
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 - 具有三列的示例DataFrame
- en: 'Now, we can apply any compatible tensor operation across a specified axis.
    For example, in the following code, we can apply a `softmax` function ([https://en.wikipedia.org/wiki/Softmax_function](https://en.wikipedia.org/wiki/Softmax_function))
    to each element in the DataFrame:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在指定的轴上应用任何兼容的张量操作。例如，在以下代码中，我们可以对DataFrame中的每个元素应用`softmax`函数（[https://en.wikipedia.org/wiki/Softmax_function](https://en.wikipedia.org/wiki/Softmax_function)）：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The code''s output is shown in the following figure:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下图所示：
- en: '![Figure 4.14 – DataFrame after applying a softmax function element-wise'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.14-在逐个元素应用softmax函数后的DataFrame'
- en: '](img/B17076_4_14.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_14.jpg)'
- en: Figure 4.14 – DataFrame after applying a softmax function element-wise
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14-在逐个元素应用softmax函数后的DataFrame
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We set the axis to `0` for element-wise tensor operations. This is because some
    tensor operations cannot be performed element-wise. You can read more about the
    supported operations at [https://js.tensorflow.org/api/latest/](https://js.tensorflow.org/api/latest/).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将轴设置为`0`以进行逐个元素的张量操作。这是因为一些张量操作无法逐个元素执行。您可以在[https://js.tensorflow.org/api/latest/](https://js.tensorflow.org/api/latest/)上阅读有关支持的操作的更多信息。
- en: Let's look at another example of applying a function that can work on both columns
    (axis = 1) and rows (axis = 0), respectively.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个示例，应用一个既可以在列（axis=1）上工作，也可以在行（axis=0）上工作的函数。
- en: 'We''ll use the TensorFlow `sum` function for this, as shown in the following
    code. First, let''s apply it across the row axis:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用TensorFlow的`sum`函数进行操作，如下面的代码所示。首先，让我们在行轴上应用它：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Printing the `df_new` DataFrame results in the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`df_new` DataFrame的结果如下输出：
- en: '![Figure 4.15 – DataFrame after applying the sum function across the row (0)
    axis'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.15-在行（0）轴上应用sum函数后的DataFrame'
- en: '](img/B17076_4_15.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_15.jpg)'
- en: Figure 4.15 – DataFrame after applying the sum function across the row (0) axis
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15-在行（0）轴上应用sum函数后的DataFrame
- en: 'Using the same DataFrame as earlier, change the axis to `1` for the column-wise
    operation, as shown in the following code snippet:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的DataFrame，将轴更改为`1`以进行列操作，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 打印DataFrame的结果如下输出：
- en: '![Figure 4.16 – DataFrame after applying the sum function across the column
    (1) axis'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.16-在列（1）轴上应用sum函数后的DataFrame'
- en: '](img/B17076_4_16.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_16.jpg)'
- en: Figure 4.16 – DataFrame after applying the sum function across the column (1)
    axis
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16-在列（1）轴上应用sum函数后的DataFrame
- en: Custom JavaScript functions can also be used with the `apply` function. The
    only caveat here is that you do not need to specify an axis, as JavaScript functions
    are applied element-wise.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义JavaScript函数也可以与`apply`函数一起使用。这里唯一的注意事项是，您不需要指定轴，因为JavaScript函数是逐个元素应用的。
- en: 'Let''s look at an example of using `apply` with a JavaScript function. In the
    following code block, we are applying the `toLowerCase` string function to each
    element in the DataFrame:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用JavaScript函数的`apply`的示例。在以下代码块中，我们将`toLowerCase`字符串函数应用于DataFrame中的每个元素：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 打印DataFrame的结果如下输出：
- en: '![Figure 4.17 – DataFrame after applying a JavaScript function element-wise'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.17-在逐个元素应用JavaScript函数后的DataFrame'
- en: '](img/B17076_4_17.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_17.jpg)'
- en: Figure 4.17 – DataFrame after applying a JavaScript function element-wise
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17-在逐个元素应用JavaScript函数后的DataFrame
- en: The `apply` function is very powerful and can be used to apply custom transformations
    to columns or rows across a DataFrame or Series. In the next sub-section, we'll
    look at the different ways of filtering and querying DataFrames and Series.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`函数非常强大，可以用于在DataFrame或Series上应用自定义转换到列或行。在下一小节中，我们将看一下过滤和查询DataFrame和Series的不同方法。'
- en: Filtering and querying
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤和查询
- en: Filtering and querying are important when we need to get a subset of the data
    that satisfies a specific Boolean condition. Filtering and querying can be done
    on DataFrames and Series using the `query` method, as we'll demonstrate in the
    following examples.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要获取满足特定布尔条件的数据子集时，过滤和查询非常重要。我们将在以下示例中演示如何在DataFrame和Series上使用`query`方法进行过滤和查询。
- en: 'Let''s assume we have a DataFrame that contains the following columns:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含以下列的DataFrame：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 打印DataFrame的结果如下输出：
- en: '![Figure 4.18 – DataFrame with sample values for querying'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.18-用于查询的示例值的DataFrame'
- en: '](img/B17076_4_18.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_18.jpg)'
- en: Figure 4.18 – DataFrame with sample values for querying
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18-用于查询的示例值的DataFrame
- en: 'Now, let''s filter the DataFrame and only return rows where the `B` column
    has values greater than `5`. This should return rows `0` and `3`. We can do this
    with the `query` function, as shown in the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们过滤DataFrame，并仅返回`B`列的值大于`5`的行。这应该返回行`0`和`3`。我们可以使用`query`函数来实现，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This gives us the following output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '![Figure 4.19 – DataFrame after querying'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.19-查询后的DataFrame'
- en: '](img/B17076_4_19.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_19.jpg)'
- en: Figure 4.19 – DataFrame after querying
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19-查询后的DataFrame
- en: The `query` method accepts all JavaScript Boolean operators (`>`, `<`, `>=`,
    `<=`, and `==`), and it also works on string columns, as shown in the following
    example.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`query`方法接受所有JavaScript布尔运算符（`>`,`<`,`>=`,`<=`和`==`），并且也适用于字符串列，如下面的示例所示。'
- en: 'First, let''s create a DataFrame with string columns:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个具有字符串列的DataFrame：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is shown in the following figure:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下图所示：
- en: '![Figure 4.20 – DataFrame before applying the string query'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.20-应用字符串查询之前的DataFrame'
- en: '](img/B17076_4_20.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_20.jpg)'
- en: Figure 4.20 – DataFrame before applying the string query
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20-应用字符串查询之前的DataFrame
- en: 'Next, we will run a query with the equals to operator (`"=="`):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用等于运算符（`"=="`）运行一个查询：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This results in the following output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Figure 4.21 – DataFrame after applying the string query'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.21-应用字符串查询后的DataFrame'
- en: '](img/B17076_4_21.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_21.jpg)'
- en: Figure 4.21 – DataFrame after applying the string query
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21 - 应用字符串查询后的数据框
- en: 'In most scenarios, the DataFrame you''re querying is large, so you may want
    to perform a query in place. This can be done by specifying `inplace` as `true`,
    as shown in the following code block:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您查询的数据框很大，因此可能希望执行就地查询。这可以通过将`inplace`指定为`true`来完成，如下面的代码块所示：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 打印数据框的结果如下：
- en: '![Figure 4.22 – DataFrame after performing an inplace query'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.22 - 执行就地查询后的数据框'
- en: '](img/B17076_4_22.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_22.jpg)'
- en: Figure 4.22 – DataFrame after performing an inplace query
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22 - 执行就地查询后的数据框
- en: The `query` method is very important, and you use it a lot when filtering your
    data by specific properties. Another bonus of using the `query` function is that
    it allows `inplace` functionality, which means it's useful for filtering large
    datasets.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`query`方法非常重要，在通过特定属性过滤数据时经常使用它。使用`query`函数的另一个好处是它允许`inplace`功能，这意味着它对于过滤大型数据集非常有用。'
- en: In the next sub-section, we'll look at another useful concept called random
    sampling.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将看看另一个有用的概念，称为随机抽样。
- en: Random sampling
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机抽样
- en: '**Random sampling** from a DataFrame or Series is useful when you need to reorder
    rows randomly. This is mostly useful in preprocessing steps before **machine learning**
    (**ML**).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据框或系列中进行**随机抽样**在需要随机重新排序行时非常有用。这在**机器学习**（**ML**）之前的预处理步骤中非常有用。
- en: 'Let''s see an example of using random sampling. Let''s assume we have a DataFrame
    that contains the following values:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用随机抽样的例子。假设我们有一个包含以下值的数据框：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This results in the following output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![Figure 4.23 – DataFrame before random sampling'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.23 - 随机抽样前的数据框'
- en: '](img/B17076_4_23.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_23.jpg)'
- en: Figure 4.23 – DataFrame before random sampling
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23 - 随机抽样前的数据框
- en: 'Now, let''s randomly select two rows by calling the `sample` function on the
    DataFrame, as shown in the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在数据框上调用`sample`函数来随机选择两行，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This results in the following output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![Figure 4.24 – DataFrame in browser console after randomly sampling two rows'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.24 - 随机抽取两行后的浏览器控制台中的数据框'
- en: '](img/B17076_4_24.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_24.jpg)'
- en: Figure 4.24 – DataFrame in browser console after randomly sampling two rows
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24 - 随机抽取两行后的浏览器控制台中的数据框
- en: In the preceding code, you'll notice that the code is wrapped in an `async`
    function. This is because the `sample` method returns a promise, and as such,
    we have to await the result. The preceding code can be executed in the browser
    or node.js environment as is, but it will need a little bit of tweaking to work
    in Dnotebook.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，您会注意到代码被包装在一个`async`函数中。这是因为`sample`方法返回一个promise，因此我们必须等待结果。上述代码可以在浏览器或node.js环境中按原样执行，但是它需要一点调整才能在Dnotebook中工作。
- en: 'If you want to run the exact code in Dnotebook, you can tweak it like so:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在Dnotebook中运行确切的代码，可以像这样调整它：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, you can see that we explicitly defined `sample` using
    `var`. This makes the `sample` variable available to all cells. Using the `let`
    declaration here instead will make the variable available to only the cell where
    it was defined.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，您可以看到我们明确使用`var`定义了`sample`。这使得`sample`变量对所有单元格都可用。在这里改用`let`声明将使变量仅对定义它的单元格可用。
- en: 'Next, in a new cell, you can print the sample DataFrame using the `table` method,
    as shown in the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在一个新的单元格中，您可以使用`table`方法打印样本数据框，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This results in the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![Figure 4.25 – DataFrame in Dnotebook after randomly sampling two rows'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.25 - 在Dnotebook中随机抽取两行后的数据框'
- en: '](img/B17076_4_25.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_25.jpg)'
- en: Figure 4.25 – DataFrame in Dnotebook after randomly sampling two rows
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25 - 在Dnotebook中随机抽取两行后的数据框
- en: In the next section, we'll briefly talk about some encoding features available
    in Danfo.js.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要介绍Danfo.js中提供的一些编码特性。
- en: Encoding DataFrames and Series
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码数据框和系列
- en: '**Encoding** is another important transformation that can be applied to DataFrames/Series
    before ML or **statistical modeling**. It is an important data preprocessing step
    that is always performed before feeding data into models.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码**是在应用于ML或**统计建模**之前可以应用于数据框/系列的另一个重要转换。这是在将数据馈送到模型之前始终执行的重要数据预处理步骤。'
- en: ML or statistical models can only work with numeric values and as such, all
    string/categorical columns must be converted appropriately into numeric form.
    There are numerous types of encoding, such as **one-hot encoding**, **label encoding**,
    **mean encoding**, and so on, and the choice of encoding may differ, depending
    on the type of data you have.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ML或统计模型只能使用数值，因此所有字符串/分类列必须适当地转换为数值形式。有许多类型的编码，例如**独热编码**，**标签编码**，**均值编码**等，选择编码可能会有所不同，这取决于您拥有的数据类型。
- en: 'Danfo.js currently supports two popular encoding schemes: *label* and *one-hot
    encoder*, and in the following section, we''ll explain how to use them.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js目前支持两种流行的编码方案：*标签*和*独热编码器*，在接下来的部分中，我们将解释如何使用它们。
- en: Label encoder
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签编码器
- en: The label encoder maps categories in a column to an integer value between 0
    and the number of unique classes in the column. Let's see an example of using
    this on a DataFrame.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 标签编码器将列中的类别映射到列中唯一类别的整数值之间的值。让我们看一个在数据框上使用这个的例子。
- en: 'Let''s assume we have the following DataFrame:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下数据框：
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 打印数据框的结果如下：
- en: '![Figure 4.26 – DataFrame before encoding'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.26 - 编码前的数据框'
- en: '](img/B17076_4_26.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_26.jpg)'
- en: Figure 4.26 – DataFrame before encoding
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26 - 编码前的数据框
- en: 'Now, let''s encode the `fruits` column using `LabelEncoder`, as shown in the
    following code block:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`LabelEncoder`对`fruits`列进行编码，如下面的代码块所示：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code block, you will notice that we created a `LabelEncoder`
    object first and then called the `fit` method on the column (`fruits`). The `fit`
    method simply learns and stores the mapping in the encoder object. This can be
    used later to transform any column/array, as we'll see shortly.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，您会注意到我们首先创建了一个`LabelEncoder`对象，然后在列（`fruits`）上调用了`fit`方法。`fit`方法简单地学习并存储编码器对象中的映射。稍后可以用它来转换任何列/数组，我们很快就会看到。
- en: 'After calling the `fit` method, we must call the `transform` method to apply
    the labels, as shown in the following code block:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`fit`方法后，我们必须调用`transform`方法来应用标签，如下面的代码块所示：
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 打印DataFrame的结果如下：
- en: '![Figure 4.27 – DataFrame before label encoding'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.27 - 标签编码前的DataFrame'
- en: '](img/B17076_4_27.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_27.jpg)'
- en: Figure 4.27 – DataFrame before label encoding
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27 - 标签编码前的DataFrame
- en: 'From the preceding output, you can see that unique integers have been assigned
    to each label. In scenarios where `transform` is called on a column with a new
    category that was not available during the `fit` (learning) stage, it is represented
    with a value of `–1`. Let''s take a look at an example of this while using the
    same encoder from the preceding example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，您可以看到为每个标签分配了唯一的整数。在调用`transform`时，如果列中有一个在`fit`（学习）阶段不可用的新类别，则用值`-1`表示。让我们看一个例子，使用前面示例中的相同编码器：
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 打印DataFrame的结果如下：
- en: '![Figure 4.28 – DataFrame after applying transform to an array with new categories'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.28 - 应用transform后的新类别数组的DataFrame'
- en: '](img/B17076_4_28.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_28.jpg)'
- en: Figure 4.28 – DataFrame after applying transform to an array with new categories
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.28 - 应用transform后的新类别数组的DataFrame
- en: In the preceding example, you can see that we are calling the trained encoder
    on an array with new categories (`man` and `car`). Notice that the output has
    `–1` in place of these new categories, as we explained earlier.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您可以看到我们在一个具有新类别（`man`和`car`）的数组上调用了训练过的编码器。请注意，输出中用`-1`代替了这些新类别，正如我们之前解释的那样。
- en: Next, let's talk about one-hot encoding.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈独热编码。
- en: One-hot encoding
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独热编码
- en: One-hot encoding is mostly applied to ordinal categories in a dataset. In this
    encoding scheme, binary values of `0` (hot) and `1` (cold) are used to encode
    unique categories.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 独热编码主要应用于数据集中的有序类别。在这种编码方案中，使用二进制值`0`（热）和`1`（冷）来编码唯一类别。
- en: 'Using the same DataFrame as in the preceding section, let''s create a one-hot
    encoder object and apply it to the `country` column, as shown in the following
    code block:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与前一节相同的DataFrame，让我们创建一个独热编码器对象，并将其应用于`country`列，如下面的代码块所示：
- en: '[PRE37]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 打印DataFrame的结果如下：
- en: '![Figure 4.29 – DataFrame after one-hot encoding'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.29 - 应用独热编码后的DataFrame'
- en: '](img/B17076_4_29.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_29.jpg)'
- en: Figure 4.29 – DataFrame after one-hot encoding
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.29 - 应用独热编码后的DataFrame
- en: 'From the preceding output, you can see that for each unique category, a series
    of 1s and 0s are used to replace the categories, and that we now have two extra
    columns that have been generated. The following diagram gives us an intuitive
    understanding of how each unique class is mapped to one-hot categories:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，您可以看到对于每个唯一类别，一系列1和0被用来替换类别，并且现在我们生成了两列额外的列。以下图表直观地展示了每个唯一类别如何映射到独热编码：
- en: '![Figure 4.30 – One-hot encoding mapping for three categories'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.30 - 三个类别的独热编码映射'
- en: '](img/B17076_4_30.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_30.jpg)'
- en: Figure 4.30 – One-hot encoding mapping for three categories
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.30 - 三个类别的独热编码映射
- en: One last encoding feature available in Danfo.js that we'll talk about is the
    `get_dummies` function. This function works in the same way as the one-hot encoding
    function, but the major difference is the fact that you can apply it across a
    DataFrame and it will automatically encode any categorical column it finds.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js中的最后一个可用编码特性是`get_dummies`函数。这个函数的工作方式与独热编码函数相同，但主要区别在于您可以在整个DataFrame上应用它，并且它将自动编码找到的任何分类列。
- en: 'Let''s see an example of using the `get_dummies` function. Let''s assume we
    have the following DataFrame:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用`get_dummies`函数的例子。假设我们有以下DataFrame：
- en: '[PRE38]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 打印DataFrame的结果如下：
- en: '![Figure 4.31 – DataFrame before applying the get_dummies function'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.31 - 应用`get_dummies`函数前的DataFrame'
- en: '](img/B17076_4_31.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_31.jpg)'
- en: Figure 4.31 – DataFrame before applying the get_dummies function
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.31 - 应用`get_dummies`函数前的DataFrame
- en: 'Now, we can encode all the categorical columns (`fruits` and `country`) at
    once by passing the DataFrame to the `get_dummies` function, as shown in the following
    code block:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将DataFrame传递给`get_dummies`函数一次性编码所有分类列（`fruits`和`country`），如下面的代码块所示：
- en: '[PRE39]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 打印DataFrame的结果如下：
- en: '![Figure 4.32 – One-hot encoding a mapping for three categories'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.32 - 三个类别的独热编码映射'
- en: '](img/B17076_4_32.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_32.jpg)'
- en: Figure 4.32 – One-hot encoding a mapping for three categories
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.32 - 三个类别的独热编码映射
- en: From the preceding figure, you can see that the `get_dummies` function automatically
    detected the `fruits` and `country` categorical variables and one-hot encoded
    them. Columns are autogenerated and their names start with the corresponding column
    and category.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，您可以看到`get_dummies`函数自动检测到了`fruits`和`country`分类变量，并对它们进行了独热编码。列是自动生成的，它们的名称以相应的列和类别开头。
- en: Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can specify the columns you want to encode, as well as the prefix for naming
    each encoded column. To see more available options, please refer to the official
    Danfo.js documentation: [https://danfo.jsdata.org/](https://danfo.jsdata.org/).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定要编码的列，以及为每个编码列命名前缀。要了解更多可用选项，请参考官方Danfo.js文档：[https://danfo.jsdata.org/](https://danfo.jsdata.org/)。
- en: In the next section, we'll look at various ways of combining datasets.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看组合数据集的各种方法。
- en: Combining datasets
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合数据集
- en: DataFrames and Series can be combined using built-in functions in Danfo.js.
    Methods such as `danfo.merge` and `danfo.concat` exist that, depending on the
    configurations, can help you combine datasets in different forms using familiar
    database-like joins.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框和序列可以使用Danfo.js中的内置函数进行组合。存在诸如`danfo.merge`和`danfo.concat`之类的方法，根据配置的不同，可以帮助您使用熟悉的类似数据库的连接方式以不同形式组合数据集。
- en: In this section, we'll briefly talk about these join types, starting with the
    `merge` function.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要讨论这些连接类型，从`merge`函数开始。
- en: DataFrame merge
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据框合并
- en: 'The `merge` operation is similar to the database `Join` operation in that it
    performs join operations on columns or indexes found in the object. The signature
    of the `merge` operation is as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge`操作类似于数据库中的`Join`操作，它在对象中执行列或索引的连接操作。`merge`操作的签名如下：'
- en: '[PRE40]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s understand what each parameter entails:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解每个参数的含义：
- en: '`left`: The left-hand side DataFrame/Series you want to merge to.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left`：要合并到左侧的数据框/序列。'
- en: '`right`: The right-hand side DataFrame/Series you want to merge to.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right`：要合并到右侧的数据框/序列。'
- en: '`on`: The name(s) of the column(s) to join. These column(s) must be found in
    both the left and right DataFrames.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on`：要连接的列的名称。这些列必须在左侧和右侧的数据框中都找到。'
- en: '`how`: The `how` parameter specifies how the merge should be carried out. It
    is similar to the database-style joins, and it can be either `left`, `right`,
    `outer`, or `inner`.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`how`：`how`参数指定如何执行合并。它类似于数据库风格的连接，可以是`left`、`right`、`outer`或`inner`。'
- en: 'The Danfo.js `merge` function is very similar to the pandas `merge` function
    since it performs in-memory join operations that are similar to relational database
    joins. The following table provides a comparison of Danfo''s merge methods and
    SQL joins:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js的`merge`函数与pandas的`merge`函数非常相似，因为它执行类似于关系数据库连接的内存中连接操作。以下表格提供了Danfo的合并方法和SQL连接的比较：
- en: '![Figure 4.33 – Comparing the Danfo.js merge methods to SQL joins'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.33 – 比较Danfo.js合并方法和SQL连接'
- en: '](img/B17076_4_33.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_33.jpg)'
- en: 'Figure 4.33 – Comparing the Danfo.js merge methods to SQL joins (Source: pandas
    Doc: https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html#brief-primer-on-merge-methods-relational-algebra)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.33 – 比较Danfo.js合并方法和SQL连接（来源：pandas文档：https://pandas.pydata.org/pandas-docs/stable/user_guide/merging.html#brief-primer-on-merge-methods-relational-algebra）
- en: In the following sections, we'll present some examples to help you understand
    how and when to use the `merge` function.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将提供一些示例，帮助您了解何时以及如何使用`merge`函数。
- en: Inner merge by a single key
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过单个键进行内部合并
- en: Merging DataFrames on a single common key results in an inner join by default.
    An inner join requires two DataFrames to have matching column values, and it returns
    the intersection of the two; that is, it returns a DataFrame with only those rows
    that have common characteristics.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个共同键上合并数据框默认会导致内连接。内连接要求两个数据框具有匹配的列值，并返回两者的交集；也就是说，它返回一个只包含具有共同特征的行的数据框。
- en: 'Let''s assume we have two DataFrames, as shown in the following code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个数据框，如下所示：
- en: '[PRE41]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Printing the first DataFrame results in the following output:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 打印第一个数据框的结果如下：
- en: '![Figure 4.34 – First DataFrame to perform a merge operation on'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.34 – 执行合并操作的第一个数据框'
- en: '](img/B17076_4_34.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_34.jpg)'
- en: Figure 4.34 – First DataFrame to perform a merge operation on
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.34 – 执行合并操作的第一个数据框
- en: 'We will now print the second DataFrame, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将打印第二个数据框，如下所示：
- en: '[PRE42]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This results in the following output:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '![Figure 4.35 – Second DataFrame to perform a merge operation on'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.35 – 执行合并操作的第二个数据框'
- en: '](img/B17076_4_35.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_35.jpg)'
- en: Figure 4.35 – Second DataFrame to perform a merge operation on
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.35 – 执行合并操作的第二个数据框
- en: 'Next, we will perform an inner join, as shown in the following code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将执行内连接，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 打印数据框的结果如下：
- en: '![Figure 4.36 – Inner merge of two DataFrames on a single key'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.36 – 在单个键上对两个数据框进行内部合并'
- en: '](img/B17076_4_36.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_36.jpg)'
- en: Figure 4.36 – Inner merge of two DataFrames on a single key
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.36 – 在单个键上对两个数据框进行内部合并
- en: From the preceding output, you can see that the inner join in `Key1` results
    in a DataFrame that contains all the values from DataFrame 1 and DataFrame 2\.
    This is also called a **Cartesian product** of the two DataFrames.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，您可以看到在`Key1`上的内连接导致了一个包含来自数据框1和数据框2的所有值的数据框。这也被称为两个数据框的**笛卡尔积**。
- en: We can take things further and merge multiple keys. We'll look at this in the
    next section.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步合并多个键。我们将在下一节中讨论这个问题。
- en: Inner merge on two keys
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在两个键上进行内部合并
- en: Performing an inner merge on two keys will also return the intersection of both
    DataFrames, but it will only return rows with keys that have been found in both
    the left- and right-hand sides of the DataFrame.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个键上执行内部合并还将返回两个数据框的交集，但它只会返回在数据框的左侧和右侧都找到的键的行。
- en: 'Using the same DataFrames we created earlier, we can perform an inner join
    on two keys, as shown in the following code:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前创建的相同数据框，我们可以在两个键上执行内部连接，如下所示：
- en: '[PRE44]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 打印数据框的结果如下：
- en: '![Figure 4.37 – Inner merge of two DataFrames on two keys'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.37 – 在两个键上进行内部合并'
- en: '](img/B17076_4_37.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_37.jpg)'
- en: Figure 4.37 – Inner merge of two DataFrames on two keys
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.37 – 在两个键上进行内部合并
- en: From the preceding output, you can see that performing an inner merge on two
    keys results in a DataFrame with only those keys present in the left- and right-hand
    sides of the DataFrame.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，您可以看到在两个键上执行内部合并会导致一个只包含在数据框的左侧和右侧中都存在的键的数据框。
- en: Outer merge on a single key
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过单个键进行外部合并
- en: The outer merge, as we saw in the preceding table, performs a union of two DataFrames.
    That is, it returns values from the keys present in both DataFrames. Performing
    an outer join on a single key will return the same result as performing an inner
    join on a single key.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 外部合并，正如我们在前面的表中所看到的，执行两个数据框的并集。也就是说，它返回在两个数据框中都存在的键的值。在单个键上执行外部连接将返回与在单个键上执行内部连接相同的结果。
- en: 'Using the same DataFrames from earlier, we can specify the `how` parameter
    to change the merge behavior from its default `inner` join to `outer`, as shown
    in the following code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的相同数据框，我们可以指定`how`参数来将合并行为从其默认的`inner`连接更改为`outer`，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 打印数据框的结果如下：
- en: '![Figure 4.38 – Outer merge of two DataFrames on a single key'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.38 - 两个数据框在单个键上的外部合并'
- en: '](img/B17076_4_38.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_38.jpg)'
- en: Figure 4.38 – Outer merge of two DataFrames on a single key
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.38 - 两个数据框在单个键上的外部合并
- en: From the preceding diagram, you can see that the union of the first DataFrame
    with keys (`K0`, `K0`, `K1`, `K2`) and the second DataFrame with keys (`K0`, `K1`,
    `K1`, `K2`) is (`K0`, `K0`, `K1`, `K1`, `K2`). These keys are then used to unionize
    the DataFrames. After doing this, we received the result shown in the preceding
    table.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，您可以看到具有键（`K0`，`K0`，`K1`，`K2`）的第一个数据框和具有键（`K0`，`K1`，`K1`，`K2`）的第二个数据框的并集是（`K0`，`K0`，`K1`，`K1`，`K2`）。然后使用这些键来对数据框进行并集操作。在这样做之后，我们收到了前面表格中显示的结果。
- en: We can also perform an outer join on two keys. This will be different from the
    inner join on two keys, as we will see in the following sub-section.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在两个键上执行外部连接。这将与在两个键上执行内部连接不同，正如我们将在以下子节中看到的。
- en: Outer merge on two keys
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在两个键上的外部合并
- en: 'Still using the same DataFrames from earlier, we can add a second key, as shown
    in the following code:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然使用前面的相同数据框，我们可以添加第二个键，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 打印数据框的结果如下：
- en: '![Figure 4.39 – Outer merge of two DataFrames on two keys'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.39 - 两个数据框在两个键上的外部合并'
- en: '](img/B17076_4_39.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_39.jpg)'
- en: Figure 4.39 – Outer merge of two DataFrames on two keys
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.39 - 两个数据框在两个键上的外部合并
- en: In the preceding output, we can see that the rows that were returned always
    have keys in `Key1` and `Key2` present. If the keys present in the first DataFrame
    are not in the second, the values are always filled with `NaN`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到返回的行始终具有`Key1`和`Key2`中的键。如果第一个数据框中存在的键不在第二个数据框中，则值始终填充为`NaN`。
- en: Note
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Merging in Danfo.js does not support merging on more than two keys at a time.
    This may change in the future, so if you need support for such a feature, be sure
    to check out the *Discussions* section in the official Danfo.js GitHub repository
    ([https://github.com/opensource9ja/danfojs](https://github.com/opensource9ja/danfojs)).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在Danfo.js中进行合并不支持一次在两个以上的键上进行合并。这可能会在将来发生变化，因此，如果您需要支持这样的功能，请务必查看官方Danfo.js
    GitHub存储库的*讨论*部分（[https://github.com/opensource9ja/danfojs](https://github.com/opensource9ja/danfojs)）。
- en: In the following sections, we'll briefly look at left and right joins, which
    are also important when performing merging.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将简要介绍左连接和右连接，这在执行合并时也很重要。
- en: Right and left merges
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 右连接和左连接
- en: 'Right and left joins are pretty straightforward; they only return rows with
    keys present in the specified `how` parameter. For instance, let''s say we specify
    the `how` parameter as `right`, as shown in the following code:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 右连接和左连接非常简单；它们只返回具有指定`how`参数中存在的键的行。例如，假设我们将`how`参数指定为`right`，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 打印数据框的结果如下：
- en: '![Figure 4.40 – Right merge of two DataFrames on two keys'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.40 - 两个数据框在两个键上的右连接'
- en: '](img/B17076_4_40.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_40.jpg)'
- en: Figure 4.40 – Right merge of two DataFrames on two keys
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.40 - 两个数据框在两个键上的右连接
- en: The resulting diagram shows only rows whose keys are present in the right DataFrame.
    This means that the right DataFrame is given a higher preference when performing
    the merge.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图表仅显示了右侧数据框中存在的键的行。这意味着在执行合并时，右侧数据框被赋予了更高的优先级。
- en: 'If we set `how` to `left`, then a higher preference is given to the left DataFrame,
    and we only see rows whose keys are present in the left DataFrame. The following
    code shows an example of performing a `left` join:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`how`设置为`left`，那么左侧数据框将更偏好，并且我们只会看到键存在于左侧数据框中的行。下面的代码显示了执行`left`连接的示例：
- en: '[PRE48]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 打印数据框的结果如下：
- en: '![Figure 4.41 – Left merge of two DataFrames on two keys'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.41 - 两个数据框在两个键上的左连接'
- en: '](img/B17076_4_41.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_41.jpg)'
- en: Figure 4.41 – Left merge of two DataFrames on two keys
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.41 - 两个数据框在两个键上的左连接
- en: Looking at the preceding output, we can confirm that the resulting row gives
    more preference to the left DataFrame.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以确认结果行更偏向于左侧数据框。
- en: The Danfo.js `merge` function is very powerful and useful and will come in handy
    when you start working with more than one dataset with overlapping keys. In the
    next section, we'll introduce another useful function, known as **concatenation**,
    for transforming datasets.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js的`merge`函数非常强大和有用，在开始使用具有重叠键的多个数据集时会派上用场。在下一节中，我们将介绍另一个有用的函数，称为**连接**，用于转换数据集。
- en: Data concatenation
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据连接
- en: Concatenating data is another important data combination technique, and as its
    name suggests, this is basically joining, stacking, or arranging data together
    along an axis.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 连接数据是另一种重要的数据组合技术，正如其名称所示，这基本上是沿着一个轴连接、堆叠或排列数据。
- en: 'The function for concatenating data in Danfo.js is exposed as `danfo.concat`,
    and the signature of this function is as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在Danfo.js中用于连接数据的函数被公开为`danfo.concat`，该函数的签名如下：
- en: '[PRE49]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s understand what each parameter represents:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解每个参数代表什么：
- en: '`df_list`: The `df_list` parameter is an array of DataFrames or Series you
    want to join together.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`df_list`：`df_list`参数是要连接的DataFrames或Series的数组。'
- en: '`axis`: The `axis` parameters can accept a row (0) or column (1) and specify
    the axis where the objects will be aligned.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`axis`：`axis`参数可以接受行（0）或列（1），并指定对象将对齐的轴。'
- en: Next, we'll present some examples that will help you understand how to use the
    `concat` function. First up, we will learn how to concatenate three DataFrames
    along the row axis.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一些示例，这些示例将帮助您了解如何使用`concat`函数。首先，我们将学习如何沿行轴连接三个DataFrames。
- en: Concatenating DataFrames along the row axis (0)
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 沿行轴（0）连接DataFrames
- en: 'First, let''s create three DataFrames, as shown in the following code:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建三个DataFrames，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Printing each DataFrame using the `print` function in Node.js and the browser,
    or using the `table` function in Dnotebook, will give us the following output.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node.js和浏览器中的`print`函数或Dnotebook中的`table`函数打印每个DataFrame，将给我们以下输出。
- en: 'The output of the `df1` DataFrame is as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`df1` DataFrame的输出如下：'
- en: '![Figure 4.42 – First DataFrame (df1) to be concatenated'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.42 - 要连接的第一个DataFrame（df1）'
- en: '](img/B17076_4_42.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_42.jpg)'
- en: Figure 4.42 – First DataFrame (df1) to be concatenated
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.42 - 要连接的第一个DataFrame（df1）
- en: 'The output of the `df2` DataFrame is as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`df2` DataFrame的输出如下：'
- en: '![Figure 4.43 – Second DataFrame (df2) to be concatenated'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.43 - 要连接的第二个DataFrame（df2）'
- en: '](img/B17076_4_43.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_43.jpg)'
- en: Figure 4.43 – Second DataFrame (df2) to be concatenated
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.43 - 要连接的第二个DataFrame（df2）
- en: 'Finally, the output of the `df3` DataFrame is as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`df3` DataFrame的输出如下：
- en: '![Figure 4.44 – Third DataFrame (df3) to be concatenated'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.44 - 要连接的第三个DataFrame（df3）'
- en: '](img/B17076_4_44.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_44.jpg)'
- en: Figure 4.44 – Third DataFrame (df3) to be concatenated
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.44 - 要连接的第三个DataFrame（df3）
- en: 'Now, let''s combine these DataFrames using the `concat` function, as shown
    in the following code:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`concat`函数组合这些DataFrames，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This results in the following output:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![Figure 4.45 – Result of concatenating three DataFrames along the row axis
    (0)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.45 - 沿行轴（0）连接三个DataFrames的结果'
- en: '](img/B17076_4_45.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_45.jpg)'
- en: Figure 4.45 – Result of concatenating three DataFrames along the row axis (0)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.45 - 沿行轴（0）连接三个DataFrames的结果
- en: Here, you can see that the `concat` function simply combines each DataFrame
    (`df1`, `df2`, `df3`) along the column axis; that is, it stacks them below the
    first DataFrame in `df_list` to create one giant combination.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到`concat`函数简单地沿列轴组合每个DataFrame（`df1`，`df2`，`df3`）；也就是说，它们在`df_list`中第一个DataFrame的下方堆叠，以创建一个巨大的组合。
- en: 'Also, the index looks different. This is because, internally, Danfo.js generated
    new indexes for the combination. If you need numeric indexes, then you can use
    the `reset_index` function, as shown in the following code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，索引看起来不同。这是因为在内部，Danfo.js为组合生成了新的索引。如果您需要数字索引，那么可以使用`reset_index`函数，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This results in the following output:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![Figure 4.46 – Resetting the index of the combined DataFrames'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.46 - 重置组合DataFrames的索引'
- en: '](img/B17076_4_46.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_46.jpg)'
- en: Figure 4.46 – Resetting the index of the combined DataFrames
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.46 - 重置组合DataFrames的索引
- en: Now, what would a concatenation along the column axis using the same DataFrames
    look like? We'll try this out in the following section.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用相同的DataFrames进行沿列轴的连接会是什么样子？我们将在下一节中尝试这个。
- en: Concatenating DataFrames along the column axis (1)
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 沿列轴（1）连接DataFrames
- en: 'Using the same DataFrames we created earlier, simply change `axis` to `1` in
    the `concat` code, as shown in the following code:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前创建的相同DataFrames，只需在`concat`代码中将`axis`更改为`1`，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 打印DataFrame的结果如下：
- en: '![Figure 4.47 – Result of applying concat to three DataFrames along the column
    axis (0)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.47 - 沿列轴（0）应用concat到三个DataFrames的结果'
- en: '](img/B17076_4_47.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_47.jpg)'
- en: Figure 4.47 – Result of applying concat to three DataFrames along the column
    axis (0)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.47 - 沿列轴（0）应用concat到三个DataFrames的结果
- en: Concatenation also works on Series objects. We'll look at an example in the
    next section.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 连接也适用于Series对象。我们将在下一节中看一个例子。
- en: Concatenating Series along a specified axis
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 沿指定轴连接Series
- en: Series are also Danfo.js data structures, and as such, the `concat` function
    can also be used on them. This works the same way as concatenating DataFrames,
    as we'll demonstrate shortly.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Series也是Danfo.js数据结构，因此`concat`函数也可以在它们上面使用。这与连接DataFrames的方式相同，我们很快将进行演示。
- en: 'Using the DataFrames from the previous section, we''ll create some Series objects,
    as shown in the following code:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一节的DataFrames，我们将创建一些Series对象，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Notice that we are using a DataFrame sub-setting to grab different columns
    as Series from the DataFrames. Now, we can combine these Series into an array,
    which we''ll then pass to the `concat` function, as shown in the following code:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在使用DataFrame子集来从DataFrames中抓取不同的列作为Series。现在，我们可以将这些Series组合成一个数组，然后将其传递给`concat`函数，如下面的代码所示：
- en: '[PRE55]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 打印DataFrame的结果如下：
- en: '![Figure 4.48 – Result of applying concat to three Series along the row axis
    (0)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.48 - 沿行轴（0）应用concat到三个Series的结果'
- en: '](img/B17076_4_48.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_48.jpg)'
- en: Figure 4.48 – Result of applying concat to three Series along the row axis (0)
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.48 - 沿行轴（0）应用concat到三个Series的结果
- en: 'Changing the axis to row (0) will also work and return a DataFrame with lots
    of missing entries, as shown in the following diagram:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 将轴更改为行（0）也可以工作，并返回一个有很多缺失条目的DataFrame，如下图所示：
- en: '![Figure 4.49 – Result of applying concat to three Series along the column
    axis (1)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.49 - 沿列轴（1）应用concat到三个Series的结果'
- en: '](img/B17076_4_49.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_49.jpg)'
- en: Figure 4.49 – Result of applying concat to three Series along the column axis
    (1)
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.49 - 沿列轴（1）应用concat到三个Series的结果
- en: Now, you may be wondering why there are lots of missing fields in the resulting
    combination. This is because when objects are combined along a specified axis,
    sometimes, the position/length of the object will not align with the first DataFrame.
    Padding is done with `NaN` to return consistent lengths.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能想知道为什么在生成的组合中有很多缺失的字段。这是因为当对象沿指定轴组合时，有时对象的位置/长度与第一个DataFrame不对齐。使用`NaN`进行填充以返回一致的长度。
- en: In this sub-section, we covered two important functions (`merge` and `concat`)
    that can help you perform complex combinations on DataFrames or Series. In the
    next section, we'll talk about something different but important as well, and
    that is **string/text manipulation**.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们介绍了两个重要的函数（`merge`和`concat`），它们可以帮助您对DataFrame或Series执行复杂的组合。在下一节中，我们将讨论另一种不同但同样重要的内容，即**字符串/文本操作**。
- en: Series data accessors
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Series数据访问器
- en: Danfo.js provides data type-specific methods under various accessors. **Accessors**
    are namespaces within the Series object that can only be applied/called on specific
    data types. Two accessors are currently provided for string and date-time Series,
    and in this section, we'll discuss each and provide some examples for clarity.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js在各种访问器下提供了特定于数据类型的方法。**访问器**是Series对象内的命名空间，只能应用/调用特定数据类型。目前为字符串和日期时间Series提供了两个访问器，在本节中，我们将讨论每个访问器并提供一些示例以便理解。
- en: String accessors
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串访问器
- en: String columns in DataFrames or a Series with a `dtype` string can be accessed
    under the `str` accessor. Calling the `str` accessor on such an object exposes
    numerous string functions for manipulating the data. We will present some examples
    in this section.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame中的字符串列或具有`dtype`字符串的Series可以在`str`访问器下访问。在这样的对象上调用`str`访问器会暴露出许多用于操作数据的字符串函数。我们将在本节中提供一些示例。
- en: 'Let''s assume we have a Series that contains the following fields:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含以下字段的Series：
- en: '[PRE56]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Printing this Series results in the following diagram:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 打印此Series的结果如下图所示：
- en: '![Figure 4.50 – Result of applying concat to three Series along the column
    axis (1)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.50 - 沿列轴（1）将三个Series应用concat的结果'
- en: '](img/B17076_4_50.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_50.jpg)'
- en: Figure 4.50 – Result of applying concat to three Series along the column axis
    (1)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.50 - 沿列轴（1）将三个Series应用concat的结果
- en: 'From the preceding output, we can see that the Series (`sf`) contains text
    and is of the string type. You can confirm this with the `dtype` function, as
    shown in the following code:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到Series（`sf`）包含文本，并且是字符串类型。您可以使用`dtype`函数来确认这一点，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE58]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now that we have our Series, which is of the string data type, we can call the
    `str` accessor on it and use various JavaScript string methods, such as `capitalize`,
    `split`, `len`, `join`, `trim`, `substring`, `slice`, `replace`, and so on, as
    shown in the following examples.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的Series，它是字符串数据类型，我们可以在其上调用`str`访问器，并使用各种JavaScript字符串方法，如`capitalize`、`split`、`len`、`join`、`trim`、`substring`、`slice`、`replace`等，如下例所示。
- en: 'The following code applies the `capitalize` function to a Series:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将`capitalize`函数应用于Series：
- en: '[PRE59]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Printing this Series results in the following output:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 打印此Series的结果如下：
- en: '![Figure 4.51 – Result of applying capitalize to a string Series'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.51 - 将capitalize应用于字符串Series的结果'
- en: '](img/B17076_4_51.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_51.jpg)'
- en: Figure 4.51 – Result of applying capitalize to a string Series
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.51 - 将capitalize函数应用于字符串Series的结果
- en: 'The following code applies the `substring` function to a Series:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将`substring`函数应用于Series：
- en: '[PRE60]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Printing this Series results in the following output:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 打印此Series的结果如下：
- en: '![Figure 4.52 – Result of applying the substring function to a string Series'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.52 - 将substring函数应用于字符串Series的结果'
- en: '](img/B17076_4_52.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_52.jpg)'
- en: Figure 4.52 – Result of applying the substring function to a string Series
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.52 - 将substring函数应用于字符串Series的结果
- en: 'The following code applies the `replace` function to a Series:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将`replace`函数应用于Series：
- en: '[PRE61]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Printing this Series results in the following output:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 打印此Series的结果如下：
- en: '![Figure 4.53 – Result of applying the replace function to a string Series'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.53 - 将replace函数应用于字符串Series的结果'
- en: '](img/B17076_4_53.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_53.jpg)'
- en: Figure 4.53 – Result of applying the replace function to a string Series
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.53 - 将replace函数应用于字符串Series的结果
- en: 'The following code applies the `join` function to a Series:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将`join`函数应用于Series：
- en: '[PRE62]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Printing this Series results in the following diagram:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 打印此Series的结果如下图所示：
- en: '![Figure 4.54 – Result of applying the join function to a string Series'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.54 - 将join函数应用于字符串Series的结果'
- en: '](img/B17076_4_54.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_54.jpg)'
- en: Figure 4.54 – Result of applying the join function to a string Series
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.54 - 将join函数应用于字符串Series的结果
- en: 'The following code applies the `indexOf` function to a Series:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将`indexOf`函数应用于Series：
- en: '[PRE63]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Printing this Series results in the following output:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 打印此Series的结果如下：
- en: '![Figure 4.55 – Result of applying the indexOf function to a string Series'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.55 - 将indexOf函数应用于字符串Series的结果'
- en: '](img/B17076_4_55.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_55.jpg)'
- en: Figure 4.55 – Result of applying the indexOf function to a string Series
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.55 - 将indexOf函数应用于字符串Series的结果
- en: Note
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are numerous exposed string methods available via the `str` accessor.
    You can see the full list in the Danfo.js documentation ([https://danfo.jsdata.org/api-reference/series#string-handling](https://danfo.jsdata.org/api-reference/series#string-handling)).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`str`访问器提供了许多公开的字符串方法。您可以在Danfo.js文档中的完整列表中查看（[https://danfo.jsdata.org/api-reference/series#string-handling](https://danfo.jsdata.org/api-reference/series#string-handling)）。'
- en: Date-time accessors
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期时间访问器
- en: The second accessor that's exposed by Danfo.js on Series objects is the date-time
    accessor. This can be accessed under the `dt` namespace. Processing and extracting
    different information such as the day, month, and year from a date-time column
    is a common process when doing data transformations since the date-time raw format
    is barely useful.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js在系列对象上公开的第二个访问器是日期时间访问器。这可以在`dt`命名空间下访问。从日期时间列中处理和提取不同的信息，如日期、月份和年份，是进行数据转换时的常见过程，因为日期时间的原始格式几乎没有用处。
- en: If your data has a date-time column, the `dt` accessor can be called on it,
    and this, in turn, exposes various functions that can be used to extract information,
    such as the year, month, month name, day of the week, hour, second, and minute
    of the day.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的数据有一个日期时间列，则可以在其上调用`dt`访问器，这将公开各种函数，可用于提取信息，如年份、月份、月份名称、星期几、小时、秒和一天中的分钟数。
- en: 'Let''s look at some examples of using the `dt` accessor on a Series with date
    columns. First, we''ll create a Series with some date-time fields:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些在具有日期列的系列上使用`dt`访问器的示例。首先，我们将创建一个具有一些日期时间字段的系列：
- en: '[PRE64]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Printing this Series results in the following output:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 打印此系列的结果如下：
- en: '![Figure 4.56 – Series with date-time fields'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.56 - 具有日期时间字段的系列'
- en: '](img/B17076_4_56.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_56.jpg)'
- en: Figure 4.56 – Series with date-time fields
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.56 - 具有日期时间字段的系列
- en: 'Now that we have a Series with date fields, we can extract some information,
    such as the hour of the day, year, month, or day of the week. The first thing
    we need to do is convert the Series into Danfo.js''s date-time format using the
    `dt` accessor, as shown in the following code:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个具有日期字段的系列，我们可以提取一些信息，例如一天中的小时数、年份、月份或星期几。我们需要做的第一件事是使用`dt`访问器将系列转换为Danfo.js的日期时间格式，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `dateTime` variable now exposes different methods for extracting date information.
    Leveraging this, we can do any of the following:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`dateTime`变量现在公开了不同的方法来提取日期信息。利用这一点，我们可以做以下任何一项：'
- en: 'Get the hour of the day as a new Series:'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一天中的小时作为新系列：
- en: '[PRE66]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This gives us the following output:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '![Figure 4.57 – New Series showing the extracted hour of the day'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.57 - 显示提取的一天中的小时的新系列'
- en: '](img/B17076_4_57.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_57.jpg)'
- en: Figure 4.57 – New Series showing the extracted hour of the day
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.57 - 显示提取的一天中的小时的新系列
- en: 'Get the year as a new Series:'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取年份作为新系列：
- en: '[PRE67]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This gives us the following output:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '![Figure 4.58 – New Series showing the extracted year'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.58 - 显示提取的年份的新系列'
- en: '](img/B17076_4_58.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_58.jpg)'
- en: Figure 4.58 – New Series showing the extracted year
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.58 - 显示提取的年份的新系列
- en: 'Get the month as a new Series:'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取月份作为新系列：
- en: '[PRE68]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This gives us the following output:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '![Figure 4.59 – New Series showing the extracted name of the month'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.59 - 显示提取的月份名称的新系列'
- en: '](img/B17076_4_59.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_59.jpg)'
- en: Figure 4.59 – New Series showing the extracted name of the month
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.59 - 显示提取的月份名称的新系列
- en: 'Get the day of the week as a new Series:'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取星期几作为新系列：
- en: '[PRE69]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This gives us the following output:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '![Figure 4.60 – New Series showing the extracted day of the week'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.60 - 显示提取的星期几的新系列'
- en: '](img/B17076_4_60.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_60.jpg)'
- en: Figure 4.60 – New Series showing the extracted day of the week
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.60 - 显示提取的星期几的新系列
- en: 'Some other functions that are exposed by the `dt` accessors are as follows:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`dt`访问器公开的一些其他函数如下：'
- en: '`Series.dt.month`: This returns the month as an integer, starting from 1 (January)
    to 12 (December).'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Series.dt.month`：这将返回一个整数月份，从1（一月）到12（十二月）。'
- en: '`Series.dt.day`: This returns the day of the week as an integer, starting from
    0 (Monday) to 6 (Sunday).'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Series.dt.day`：这将返回一周中的天数作为整数，从0（星期一）到6（星期日）。'
- en: '`Series.dt.minutes`: This returns the minute of the day as an integer.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Series.dt.minutes`：这将返回一天中的分钟数作为整数。'
- en: '`Series.dt.seconds`: This returns the seconds of the day as an integer.'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Series.dt.seconds`：这将返回一天中的秒数作为整数。'
- en: Congratulations on making it to the end of this section! Data transformation
    and aggregation are very important aspects of data analysis. Armed with this knowledge,
    you can properly transform and wrangle your dataset.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您完成了本节！数据转换和聚合是数据分析的非常重要的方面。有了这些知识，您可以正确地转换和整理数据集。
- en: In the next section, we'll show you how to calculate descriptive statistics
    on your datasets using Danfo.js.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向您展示如何使用Danfo.js对数据集进行描述性统计。
- en: Calculating statistics
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算统计数据
- en: Danfo.js comes with some important statistical and mathematical functions. These
    functions can be used to generate a summary or descriptive statistics of entire
    DataFrames, as well as a single Series. In datasets, statistics are important
    because they can give us better insights into data.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js带有一些重要的统计和数学函数。这些函数可以用于生成整个数据框或单个系列的摘要或描述性统计。在数据集中，统计数据很重要，因为它们可以为我们提供更好的数据洞察。
- en: 'In the following sections, we''ll use the popular Titanic dataset, which you
    can download from the following GitHub repository: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter03/data/titanic.csv](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter03/data/titanic.csv).'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将使用流行的泰坦尼克号数据集，您可以从以下GitHub存储库下载：[https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter03/data/titanic.csv](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/blob/main/Chapter03/data/titanic.csv)。
- en: 'First, let''s load the dataset into Dnotebook using the `read_csv` function,
    as shown in the following code:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用`read_csv`函数将数据集加载到Dnotebook中，如下面的代码所示：
- en: '[PRE70]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The preceding code loads the Titanic dataset from the specified URL and persists
    it in the `df` variable.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码从指定的URL加载泰坦尼克号数据集，并将其保留在`df`变量中。
- en: Note
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are using the `load_csv` and `var` declarations here because we are working
    in Dnotebook. As we have mentioned consistently, you wouldn't use this approach
    in a browser or Node.js script.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`load_csv`和`var`声明，因为我们在Dnotebook中工作。正如我们一直提到的，你不会在浏览器或Node.js脚本中使用这种方法。
- en: 'Now, in a new cell, we can print the head of the loaded dataset:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在一个新的单元格中，我们可以打印加载数据集的头部：
- en: '[PRE71]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 打印DataFrame的结果如下：
- en: '![Figure 4.61 – The first five rows of the Titanic dataset'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.61 - 泰坦尼克号数据集的前五行'
- en: '](img/B17076_4_61.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_61.jpg)'
- en: Figure 4.61 – The first five rows of the Titanic dataset
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.61 - 泰坦尼克号数据集的前五行
- en: 'We can call the `describe` function on the entire data to quickly get description
    statistics for all the columns, as shown in the following code:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对整个数据调用`describe`函数，快速获取所有列的描述统计信息，如下面的代码所示：
- en: '[PRE72]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 打印DataFrame的结果如下：
- en: '![Figure 4.62 – Output of using the describe function on the Titanic dataset'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.62 - 在泰坦尼克号数据集上使用describe函数的输出'
- en: '](img/B17076_4_62.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_62.jpg)'
- en: Figure 4.62 – Output of using the describe function on the Titanic dataset
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.62 - 在泰坦尼克号数据集上使用describe函数的输出
- en: In the preceding code, we called the `describe` function and then printed the
    output with `table`. The `describe` function only works on numeric data types,
    and by default, it will only auto-select columns that are of the `float32` or
    `int32` type.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们调用了`describe`函数，然后用`table`打印了输出。`describe`函数只适用于数值数据类型，并且默认情况下只会自动选择`float32`或`int32`类型的列。
- en: Note
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By default, all statistical and mathematical computation removes `NaN` values
    before the computation is performed.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在进行计算之前，所有的统计和数学计算都会删除`NaN`值。
- en: 'The `describe` function provides descriptive statistics for the following:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`函数提供了以下内容的描述性统计信息：'
- en: '`NaN` values.'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NaN`值。'
- en: '**mean**: The average value in a column.'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均值**：一列中的平均值。'
- en: '**Standard Deviation** (**std**): The measure of the amount of variation or
    dispersion of a set of values.'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准差**（**std**）：一组值的变化或离散程度的度量。'
- en: '**Minimum** (**min**): The smallest value in a column.'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小值**（**min**）：一列中的最小值。'
- en: '**median**: The middle value in a column.'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中位数**：一列中的中间值。'
- en: '**Maximum** (**max**): The largest value in a column.'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大值**（**max**）：一列中的最大值。'
- en: '**variance**: The measure of the spread of values from the average.'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方差**：值从平均值的传播程度的度量。'
- en: Calculating statistics by axis
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按轴计算统计信息
- en: The `describe` function, while quick and easy to apply, is not very helpful
    when you need to calculate statistics along a specific axis. In this section,
    we'll introduce some of the most popular methods and show you how to calculate
    statistics based on a specified axis.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`函数虽然快速且易于应用，但在需要沿特定轴计算统计信息时并不是很有帮助。在本节中，我们将介绍一些最流行的方法，并向您展示如何根据指定的轴计算统计信息。'
- en: Central tendencies such as mean, mode, and median can be called on a DataFrame
    with a specified axis. Here, axis `0` represents `rows`, while axis `1` represents
    `columns`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在指定轴上对DataFrame调用诸如均值、众数和中位数等中心趋势。这里，轴`0`代表`行`，而轴`1`代表`列`。
- en: 'In the following code, we are computing the mean, mode, and median of the numeric
    columns in the Titanic dataset:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们正在计算泰坦尼克号数据集中数值列的均值、众数和中位数：
- en: '[PRE73]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the preceding code, we selected all the numeric columns so that we can apply
    mathematical operations. Next, we''ll call the `mean` function, which, by default,
    returns the mean across the column axis (`1`):'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们选择了所有的数值列，以便可以应用数学运算。接下来，我们将调用`mean`函数，默认情况下返回列轴（`1`）上的均值：
- en: '[PRE74]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 打印DataFrame的结果如下：
- en: '![Figure 4.63 – Calling the mean function on numeric columns'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.63 - 在数值列上调用均值函数'
- en: '](img/B17076_4_63.png)'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_63.png)'
- en: Figure 4.63 – Calling the mean function on numeric columns
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.63 - 在数值列上调用均值函数
- en: 'The precision shown in the preceding output looks a bit too long. We can round
    the result to two decimal places to make it more presentable, as shown in the
    following code:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 前面输出中显示的精度看起来有点太长了。我们可以将结果四舍五入到两位小数，使其更具可呈现性，如下面的代码所示：
- en: '[PRE75]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Printing the DataFrame results in the following output:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 打印DataFrame的结果如下：
- en: '![Figure 4.64 – Calling the mean function on numeric columns and rounding values
    to two decimal places'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.64 - 在数值列上调用均值函数并将值四舍五入到两位小数'
- en: '](img/B17076_4_64.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_64.jpg)'
- en: Figure 4.64 – Calling the mean function on numeric columns and rounding values
    to two decimal places
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.64 - 在数值列上调用均值函数并将值四舍五入到两位小数
- en: 'The resulting output looks cleaner when rounded to two decimal places. Next,
    let''s calculate `mean` across the row axis:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 将结果四舍五入到两位小数后，输出看起来更清晰。接下来，让我们计算沿着行轴的`mean`：
- en: '[PRE76]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This gives us the following output:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '![Figure 4.65 – Calling the mean function on the row axis'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.65 - 在行轴上调用均值函数'
- en: '](img/B17076_4_65.jpg)'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_4_65.jpg)'
- en: Figure 4.65 – Calling the mean function on the row axis
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.65 - 在行轴上调用均值函数
- en: In the preceding output, you can see that the returned values have numeric labels.
    This is because the row axis originally had numeric labels.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的输出中，您可以看到返回的值具有数值标签。这是因为行轴最初具有数值标签。
- en: 'Using the same idea, we can compute statistics such as mode, median, standard
    deviation, variance, cumulative sum, cumulative mean, absolute values, and so
    on. The following are the statistical functions that are currently available in
    Danfo.js:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的思路，我们可以计算众数、中位数、标准差、方差、累积和、累积均值、绝对值等统计信息。以下是Danfo.js当前可用的统计函数：
- en: '`abs`: Returns a Series/DataFrame with the absolute numeric value of each element.'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abs`：返回每个元素的绝对数值的Series/DataFrame。'
- en: '`count`: Counts the cells for each column or row, excluding `NaN` values.'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：计算每列或每行的单元格数，不包括`NaN`值。'
- en: '`cummax`: Returns the cumulative maximum over a DataFrame or Series.'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cummax`：返回DataFrame或Series的累积最大值。'
- en: '`cummin`: Returns the cumulative minimum over a DataFrame or Series.'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cummin`：返回DataFrame或Series的累积最小值。'
- en: '`cumprod`: Returns the cumulative product over a DataFrame or Series.'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cumprod`：返回DataFrame或Series的累积乘积。'
- en: '`cumsum`: Returns the cumulative sum over a DataFrame or Series.'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cumsum`：返回DataFrame或Series的累积和。'
- en: '`describe`: Generates descriptive statistics.'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe`：生成描述性统计。'
- en: '`max`: Returns the maximum of the values for the requested axis.'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max`：返回所请求轴的最大值。'
- en: '`mean`: Returns the mean of the values for the requested axis.'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mean`：返回所请求轴的平均值。'
- en: '`median`: Returns the median of the values for the requested axis.'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`median`：返回所请求轴的中位数。'
- en: '`min`: Returns the minimum of the values for the requested axis.'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min`：返回所请求轴的最小值。'
- en: '`mode`: Returns the mode(s) of elements along the selected axis.'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`：返回沿所选轴的元素的众数。'
- en: '`sum`: Returns the sum of the values for the requested axis.'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum`：返回所请求轴的值的总和。'
- en: '`std`: Returns the standard deviation over the requested axis.'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std`：返回所请求轴的标准偏差。'
- en: '`var`: Returns unbiased variance over the requested axis.'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`：返回所请求轴的无偏方差。'
- en: '`nunique`: Counts the distinct elements over the requested axis.'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nunique`：计算所请求轴上的不同元素的数量。'
- en: Note
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The list of supported functions will likely change, and new ones will be added.
    So, it is better to keep track of the new ones by checking out [https://danfo.jsdata.org/api-reference/dataframe#computations-descriptive-stats](https://danfo.jsdata.org/api-reference/dataframe#computations-descriptive-stats).
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的函数列表可能会发生变化，并且会添加新的函数。因此，最好通过查看[https://danfo.jsdata.org/api-reference/dataframe#computations-descriptive-stats](https://danfo.jsdata.org/api-reference/dataframe#computations-descriptive-stats)来跟踪新的函数。
- en: Descriptive statistics are very important, and in this section, we successfully
    covered some important functions that can help you calculate statistics based
    on a specified axis effectively in Danfo.js.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 描述性统计非常重要，在本节中，我们成功介绍了一些重要的函数，这些函数可以帮助您在Danfo.js中有效地基于指定轴计算统计数据。
- en: Summary
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have successfully covered the data transformation and wrangling
    functions available in Danfo.js. First, we introduced you to the various wrangling
    functions for replacing values, filling missing values, and detecting missing
    values, as well as applying and mapping methods for applying custom functions
    to your dataset. Knowledge of these functions and techniques ensures you have
    the required foundation for building data-driven products, as well as getting
    insights from your data.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们成功介绍了Danfo.js中可用的数据转换和整理函数。首先，我们向您介绍了用于替换值、填充缺失值和检测缺失值的各种整理函数，以及应用和映射方法，用于将自定义函数应用于数据集。掌握这些函数和技术可以确保您具有构建数据驱动产品所需的基础，以及从数据中获取见解的能力。
- en: Next, we showed you how to use the various merge and concatenation functions
    in Danfo.js. Finally, we showed you how to calculate descriptive statistics on
    your dataset.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向您展示了如何在Danfo.js中使用各种合并和连接函数。最后，我们向您展示了如何对数据集进行描述性统计。
- en: In the next chapter, we'll take things a step further and show you how to make
    beautiful and amazing charts/plots using Danfo.js's built-in plotting features,
    as well as by integrating third-party plotting libraries.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步介绍如何使用Danfo.js的内置绘图功能以及集成第三方绘图库来制作美丽而惊人的图表/图形。
