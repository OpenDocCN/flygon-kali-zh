- en: Implementing Kubernetes Features as an Alternative
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施Kubernetes功能作为替代方案
- en: The current microservice landscape contains a number of supportive services
    that implement important design patterns required in a large-scale microservice
    landscape; for example an edge, config, and authorization server, and a service
    for distributed tracing. For details, see [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Microservices*, and refer to the *Design patterns for microservices*
    section. In the previous chapter, we replaced the implementation of the design
    pattern for service discovery, based on Netflix Eureka, with the built-in discovery
    service in Kubernetes. In this chapter, we will further simplify the microservice
    landscape by reducing the number of supportive services required to be deployed.
    Instead, the corresponding design patterns will be handled by built-in capabilities
    in Kubernetes. The Spring Cloud Config Server will be replaced with Kubernetes
    config maps and secrets. The Spring Cloud Gateway will be replaced by a Kubernetes
    ingress resource, which can act as an edge server in the same way as Spring Cloud
    Gateway.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的微服务景观包含许多支持服务，这些服务实现了大规模微服务景观中所需的重要设计模式；例如边缘、配置和授权服务器，以及用于分布式跟踪的服务。有关详细信息，请参阅[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)，*微服务简介*，并参考*微服务设计模式*部分。在上一章中，我们用Kubernetes内置的发现服务替换了基于Netflix
    Eureka的服务发现设计模式的实现。在本章中，我们将通过减少所需部署的支持服务数量来进一步简化微服务景观。相应的设计模式将由Kubernetes的内置功能处理。Spring
    Cloud配置服务器将被Kubernetes配置映射和秘密替换。Spring Cloud网关将被Kubernetes入口资源替换，该资源可以像Spring
    Cloud网关一样充当边缘服务器。
- en: In [Chapter 11](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml), S*ecuring Access
    to APIs*, refer to the *Protecting the external communication with HTTPS* section,
    where we use certificates to protect the external API. Manual handling of certificates
    is both time-consuming and error-prone. As an alternative, we will be introduced
    to the Cert Manager, which can automatically provide new certificates and replace
    expired ones for the external HTTPS endpoint exposed by the ingress. We will configure `cert-manager`
    to use **Let's Encrypt** to issue the certificates. Let's Encrypt is a free Certificate
    Authority that can be used to automatically issue certificates. Let's Encrypt
    must be able to verify that we own the DNS name that the certificate will be issued
    for. Since our Kubernetes cluster runs locally in Minikube, we have to make it
    possible for Let's Encrypt to access our cluster during the provisioning. We will
    use `ngrok` to create a temporary HTTP tunnel from the internet to our local Kubernetes
    cluster to be used by Let's Encrypt.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml)中，*保护API的访问*，请参阅*使用HTTPS保护外部通信*部分，我们使用证书来保护外部API。手动处理证书既费时又容易出错。作为替代方案，我们将介绍Cert
    Manager，它可以自动提供新的证书，并替换外部HTTPS端点由入口暴露的过期证书。我们将配置`cert-manager`使用**Let's Encrypt**来颁发证书。Let's
    Encrypt是一个免费的证书颁发机构，可用于自动颁发证书。Let's Encrypt必须能够验证我们拥有将颁发证书的DNS名称。由于我们的Kubernetes集群在Minikube中本地运行，我们必须使Let's
    Encrypt能够在提供期间访问我们的集群。我们将使用`ngrok`从互联网创建临时HTTP隧道到我们的本地Kubernetes集群，以供Let's Encrypt使用。
- en: When using more and more features in a platform such as Kubernetes, it is important
    to ensure that the source code of the microservices isn't dependent on the platform;
    that is, should ensure that the microservices can still be used without Kubernetes.
    To ensure that we can still use the microservices outside Kubernetes, the chapter
    will conclude by deploying the microservice landscape using Docker Compose and
    executing the `test-em-all.bash` test script to verify that the microservices
    still work without using Kubernetes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Kubernetes等平台的更多功能时，重要的是确保微服务的源代码不依赖于平台；也就是说，应该确保微服务仍然可以在没有Kubernetes的情况下使用。为了确保我们仍然可以在Kubernetes之外使用微服务，本章将通过使用Docker
    Compose部署微服务景观，并执行`test-em-all.bash`测试脚本来验证微服务在没有使用Kubernetes的情况下仍然可以工作。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Replacing Spring Cloud Config Server with Kubernetes config maps and secrets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Kubernetes配置映射和秘密替换Spring Cloud配置服务器
- en: Replacing Spring Cloud Gateway with a Kubernetes ingress resource
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Kubernetes入口资源替换Spring Cloud网关
- en: Adding the Cert Manager to automatically provide certificates issued by Let's
    Encrypt
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加Cert Manager以自动提供由Let's Encrypt颁发的证书
- en: Using `ngrok` to establish an HTTP tunnel from the internet to our local Kubernetes
    cluster
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ngrok`在互联网和本地Kubernetes集群之间建立HTTP隧道
- en: Deploying and testing the microservice landscape using Docker Compose to ensure
    that the source code in the microservices isn't locked into Kubernetes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose部署和测试微服务景观，以确保微服务中的源代码不会被锁定在Kubernetes中
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All commands described in this book are run on a MacBook Pro using macOS Mojave
    but modifying this so that it can run on other platforms, such as Linux or Windows,
    should be straightforward.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都在使用macOS Mojave的MacBook Pro上运行，但修改为在其他平台（如Linux或Windows）上运行应该很简单。
- en: 'The only new tool required for this chapter is the command-line `ngrok` tool
    used for establishing an HTTP tunnel from the internet to our local environment.
    It can be installed using Homebrew with the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章唯一需要的新工具是命令行`ngrok`工具，用于在互联网和本地环境之间建立HTTP隧道。可以使用Homebrew安装该工具，命令如下：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To use `ngrok`, a free account has to be created and an authorization token
    also has to be registered by taking the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`ngrok`，必须创建一个免费帐户，并且还必须通过以下步骤注册授权令牌：
- en: 'Sign up here: [https://dashboard.ngrok.com/signup](https://dashboard.ngrok.com/signup).'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此注册：[https://dashboard.ngrok.com/signup](https://dashboard.ngrok.com/signup)。
- en: 'After the account is created, run the following command:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建帐户后，运行以下命令：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `<YOUR_AUTH_TOKEN>` is replaced with the authorization token found on
    the following page—[https://dashboard.ngrok.com/auth](https://dashboard.ngrok.com/auth).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<YOUR_AUTH_TOKEN>` 被替换为在以下页面找到的授权令牌 - [https://dashboard.ngrok.com/auth](https://dashboard.ngrok.com/auth)。
- en: The source code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter17](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter17).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter17](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter17)。
- en: 'To be able to run the commands as described in the book, you need to download
    the source code to a folder and set up an environment variable, `$BOOK_HOME`,
    that points to that folder. Sample commands are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够按照书中描述的命令运行命令，您需要将源代码下载到一个文件夹，并设置一个环境变量`$BOOK_HOME`，该变量指向该文件夹。示例命令如下：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1, SR2 (also known as the **Greenwich** release), Spring Boot
    2.1.6, and Spring 5.1.8—the latest available versions of the Spring components
    at the time of writing this chapter. The source code has been tested using Kubernetes
    v1.15.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是为Java 8编写的，并在Java 12上进行了测试。本章使用的是Spring Cloud 2.1，SR2（也称为**Greenwich**发布），Spring
    Boot 2.1.6和Spring 5.1.8 - 这是在撰写本章时可用的Spring组件的最新版本。该源代码已经使用Kubernetes v1.15进行了测试。
- en: All source code examples in this chapter come from the source code in `$BOOK_HOME/Chapter17` but
    have been edited in several cases to remove non-relevant parts of the source code,
    such as comments, imports, and log statements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有源代码示例都来自于`$BOOK_HOME/Chapter17`中的源代码，但在几种情况下已经进行了编辑，以删除源代码的非相关部分，例如注释、导入和日志语句。
- en: If you want to see the changes applied to the source code in [Chapter 17](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml), *Implementing
    Kubernetes Features as an Alternative*, that is, the changes required to replace
    the Spring Cloud Config Server and Spring Cloud Gateway with corresponding features
    in Kubernetes, you can compare it with the source code for [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml),
    *Deploying Our Microservices to Kubernetes*.  You can use your favorite `diff`
    tool and compare the `$BOOK_HOME/Chapter16` and `$BOOK_HOME/Chapter17` folders.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要查看应用于[第17章](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml)中源代码的更改，即替换Spring
    Cloud Config Server和Spring Cloud Gateway与Kubernetes中相应功能所需的更改，您可以将其与[第16章](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml)中的源代码进行比较，即*部署我们的微服务到Kubernetes*。您可以使用您喜欢的`diff`工具，比较`$BOOK_HOME/Chapter16`和`$BOOK_HOME/Chapter17`文件夹。
- en: Replacing the Spring Cloud Config Server
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换Spring Cloud Config Server
- en: As we have seen in the previous chapter, [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml),
    *Deploying Our Microservices to Kubernetes*, in the *Deploying to Kubernetes*
    section, config maps and secrets can be used to hold configuration information
    for our microservices. The Spring Cloud Config Server adds values such as keeping
    all configuration in one place, optional version control using Git, and the ability
    to encrypt sensitive information on the disk. But it also consumes a non-negligible
    amount of memory (as with any Java and Spring-based application) and adds significant
    overhead during startup. For example, when running automated integration tests
    such as the test script we are using in this book, `test-em-all.bash`, all microservices
    are started up at the same time, including the configuration server. Since the
    other microservices must get their configuration from the configuration server
    before they can start up, they all have to wait for the configuration server to
    be up and running before they can start up. This leads to a significant delay
    when running integration tests. If we use Kubernetes config maps and secrets instead,
    this delay is eliminated, making automated integration tests run faster. To me,
    it makes sense to use the Spring Cloud Config Server where the underlying platform
    doesn't provide a similar capability, but when deploying to Kubernetes, it is
    better to use config maps and secrets.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章[第16章](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml)中所看到的，在*部署到Kubernetes*部分，配置映射和密钥可以用来保存我们的微服务的配置信息。Spring
    Cloud Config Server添加了一些值，比如将所有配置保存在一个地方、使用Git进行可选版本控制以及在磁盘上加密敏感信息的能力。但是它也消耗了相当可观的内存（与任何基于Java和Spring的应用程序一样），并在启动过程中增加了显着的开销。例如，在运行自动化集成测试时，比如我们在本书中使用的测试脚本`test-em-all.bash`，所有微服务都同时启动，包括配置服务器。由于其他微服务必须从配置服务器获取它们的配置才能启动，它们都必须等待配置服务器启动并运行，然后它们才能启动。这导致在运行集成测试时出现了显着的延迟。如果我们使用Kubernetes配置映射和密钥，这种延迟就会消除，使得自动化集成测试运行更快。对我来说，在底层平台没有提供类似功能的情况下使用Spring
    Cloud Config Server是有意义的，但是在部署到Kubernetes时，最好使用配置映射和密钥。
- en: 'Using Kubernetes config maps and secrets instead of the Spring Cloud Config
    Server will make the microservice landscape start up faster and it will require
    less memory. It will also simplify the microservice landscape by eliminating one
    supportive service, the configuration server. This is illustrated by the following
    diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes配置映射和密钥代替Spring Cloud Config Server将使微服务景观启动更快，并且需要更少的内存。它还将通过消除一个支持服务
    - 配置服务器来简化微服务景观。下图说明了这一点：
- en: '![](img/7ab391b2-00bd-4930-8d8f-371cd083215a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ab391b2-00bd-4930-8d8f-371cd083215a.png)'
- en: Let's see what is required to replace the Spring Cloud Config Server with Kubernetes
    config maps and secrets!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何用Kubernetes配置映射和密钥替换Spring Cloud Config Server！
- en: Note especially that we only change the configuration; that is, no changes are
    required in the Java source code!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，我们只改变配置；也就是说，Java源代码不需要进行任何更改！
- en: Changes in the source code to replace the Spring Cloud Config Server
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换Spring Cloud Config Server的源代码更改
- en: 'The following changes have been applied in the configuration of the source
    code to replace the Spring Cloud Config Server with Kubernetes config maps and
    secrets:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码的配置中应用了以下更改，以用Kubernetes config maps和secrets替换Spring Cloud Config Server：
- en: 'Removed the project `spring-cloud/config-server`, also including:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了项目`spring-cloud/config-server`，还包括：
- en: Removed the project in the `settings.gradle` build file.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`settings.gradle`构建文件中删除了项目。
- en: Removed the configuration server YAML files and its declaration in the `kustomization.yml`
    files in the `kubernetes/services/base` and `kubernetes/services/overlays/prod` folders.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`kubernetes/services/base`和`kubernetes/services/overlays/prod`文件夹中的`kustomization.yml`文件中删除了配置服务器的YAML文件及其声明。
- en: 'Removed configuration from all microservices:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从所有微服务中删除了配置：
- en: Removed the `spring-cloud-starter-config` dependency in the `build.gradle` build
    files
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`build.gradle`构建文件中删除了`spring-cloud-starter-config`依赖项
- en: Removed the `bootstrap.yml` files in the `src/main/resource` folders in each
    project
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个项目的`src/main/resource`文件夹中删除了`bootstrap.yml`文件。
- en: Removed the  `spring.clod.config.enabled=false` property setting in integration
    tests
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集成测试中删除了`spring.clod.config.enabled=false`属性设置
- en: 'Changes in the configuration files in the `config-repo` folder:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`config-repo`文件夹中的配置文件中的更改：
- en: Removed properties with sensitive information, that is, credentials for MongoDB,
    MySQL, RabbiMQ, and the password for the TLS certificate used by the edge server.
    They will be replaced by Kubernetes secrets.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了包含敏感信息的属性，即MongoDB、MySQL、RabbitMQ的凭据，以及边缘服务器使用的TLS证书的密码。它们将被Kubernetes secrets替换。
- en: The route to the configuration server API is removed in the configuration of
    the edge server
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在边缘服务器的配置中删除了到配置服务器API的路由
- en: 'Changes in the Kubernetes definition files for deployment resources in the `kubernetes/services/base` folder:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`kubernetes/services/base`文件夹中的部署资源的Kubernetes定义文件中的更改：
- en: Config maps are mounted as volumes, that is, as folders in the filesystem of
    the container.  Each microservice gets its own config maps, which contain the
    configuration files applicable for the specific microservice.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将config maps作为卷挂载，即作为容器文件系统中的文件夹。每个微服务都有自己的config maps，其中包含适用于特定微服务的配置文件。
- en: Define the `SPRING_CONFIG_LOCATION` environment variable to point out the configuration
    files in the volume.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`SPRING_CONFIG_LOCATION`环境变量来指出卷中的配置文件。
- en: Define credentials for access to resource managers using secrets.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用secrets定义访问资源管理器的凭据。
- en: 'Most changes are in the Kubernetes definitions files for the deployment resources.
    Let''s look at the definition of the deployment resource for the `product` microservice
    as an example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分更改都在Kubernetes定义文件中的部署资源中。让我们以`product`微服务的部署资源定义为例：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that parts of the definition that have not been affected by the changes
    are left out for improved readability. See `kubernetes/services/base/product.yml`
    for the full source code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，未受更改影响的定义部分已被省略以提高可读性。请参阅`kubernetes/services/base/product.yml`以查看完整的源代码。
- en: 'The following explains the preceding source code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下解释了前面的源代码：
- en: The `config-repo-product` config map is mapped in a volume named `config-repo-volume`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config-repo-product` config map被映射到名为`config-repo-volume`的卷中。'
- en: The `config-repo-volume` volume is mounted in the filesystem at `/config-repo`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config-repo-volume`卷被挂载到文件系统的`/config-repo`位置。'
- en: The `SPRING_CONFIG_LOCATION` environment variable tells Spring where to find
    the property files, in this case, the `/config-repo/application.yml` and `/config-repo/product.yml` files.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPRING_CONFIG_LOCATION`环境变量告诉Spring在哪里找到属性文件，即`/config-repo/application.yml`和`/config-repo/product.yml`文件。'
- en: Credentials for accessing RabbitMQ and MongoDB are set up as environment variables
    based on the content in the `rabbitmq-credentials` and `mongodb-credentials` secrets.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于`rabbitmq-credentials`和`mongodb-credentials` secrets中的内容，设置了访问RabbitMQ和MongoDB的凭据作为环境变量。
- en: The Kubernetes config maps and secrets will be created in the *Testing with
    ConfigMaps, secrets, and ingress* section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes config maps和secrets将在*使用ConfigMaps、secrets和ingress进行测试*部分中创建。
- en: That is what is required to replace the configuration server with Kubernetes
    config maps and secrets. In the next section, we will learn about how we can replace
    the Spring Cloud Gateway with a Kubernetes ingress resource.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是用Kubernetes config maps和secrets替换配置服务器所需的内容。在下一节中，我们将学习如何使用Kubernetes ingress资源替换Spring
    Cloud Gateway。
- en: Replacing the Spring Cloud Gateway
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换Spring Cloud Gateway
- en: In this section, we will further simplify the microservice landscape by replacing
    the Spring Cloud Gateway with the built-in ingress resource in Kubernetes, reducing
    the number of supportive services required to be deployed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过使用Kubernetes中内置的ingress资源来简化微服务架构，减少需要部署的支持服务的数量。
- en: As introduced in [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml), *Introduction
    to Kubernetes*, an ingress resource can be used in Kubernetes to act as an edge
    server in the same way as a Spring Cloud Gateway. The Spring Cloud Gateway comes
    with a richer routing functionality compared to an ingress resource. But the ingress
    feature is part of the Kubernetes platform and can also be extended using the
    Cert Manager to automatically provide certificates, as we will see later on in
    this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第15章](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml)中介绍的，*Kubernetes简介*，在Kubernetes中可以使用ingress资源来充当边缘服务器，就像Spring
    Cloud Gateway一样。Spring Cloud Gateway具有比ingress资源更丰富的路由功能。但是ingress功能是Kubernetes平台的一部分，并且还可以使用Cert
    Manager进行扩展，以自动提供证书，我们将在本章后面看到。
- en: We have also used the Spring Cloud Gateway to protect our microservices from
    unauthenticated requests; that is, the microservices require a valid OAuth 2.0/OIDC
    access token from a trusted OAuth Authorization Server or OIDC Provider. See [Chapter
    11](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml), *Securing Access to APIs*, if
    a recap is required. Generally, Kubernetes ingress resources do not have support
    for that. Specific implementations of the ingress controller might, however, support
    it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了Spring Cloud Gateway来保护我们的微服务免受未经身份验证的请求；也就是说，微服务需要来自受信任的OAuth授权服务器或OIDC提供者的有效OAuth
    2.0/OIDC访问令牌。如果需要回顾，可以参见[第11章]（bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml），*保护API的访问*。一般来说，Kubernetes入口资源不支持这一点。然而，入口控制器的特定实现可能支持它。
- en: Finally, the composite health check we added to the gateway in [Chapter 10](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml),
    *Using Spring Cloud Gateway to Hide Microservices Behind an Edge Server* can be
    replaced by the Kubernetes liveness and readiness probes defined in each microservices
    deployment resource. To me, it makes sense to use the Spring Cloud Gateway where
    the underlying platform doesn't provide a similar capability, but when deploying
    to Kubernetes, it is better to use ingress resources.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在[第10章](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml)中我们添加到网关的复合健康检查可以被每个微服务部署资源中定义的Kubernetes活动性和就绪探针所替代。对我来说，在底层平台不提供类似功能时使用Spring
    Cloud Gateway是有意义的，但在部署到Kubernetes时，最好使用入口资源。
- en: In this chapter, we will delegate the responsibility for validating that the
    request contains a valid access token to the `product-composite` microservice.
    The next chapter will introduce the concept of a Service Mesh, where we will see
    an alternate implementation of an ingress that fully supports validating JWT-encoded
    access tokens, that is, the type of access tokens that we are using in this book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将委托验证请求是否包含有效访问令牌的责任给`product-composite`微服务。下一章将介绍服务网格的概念，在那里我们将看到一个完全支持验证JWT编码访问令牌的入口的替代实现，也就是我们在本书中使用的访问令牌类型。
- en: In the *Verifying that the microservices work without Kubernetes* section, we
    will still use the Spring Cloud Gateway together with Docker Compose, so we will
    not remove the project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在*验证微服务在没有Kubernetes的情况下工作*部分中，我们仍将使用Spring Cloud Gateway和Docker Compose，因此不会删除该项目。
- en: 'The following diagram shows how to remove the Spring Cloud Gateway from the
    microservice landscape when deploying to Kubernetes:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了在部署到Kubernetes时如何从微服务景观中移除Spring Cloud Gateway：
- en: '![](img/d19dde2e-6974-428d-a6e3-ba564833e00a.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d19dde2e-6974-428d-a6e3-ba564833e00a.png)'
- en: Let's see what is required to replace the Spring Cloud Gateway with a Kubernetes
    ingress resource!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何用Kubernetes入口资源替换Spring Cloud Gateway！
- en: Note especially that we only change the configuration; that is, no changes are
    required in the Java source code!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，我们只改变了配置；也就是说，Java源代码中不需要做任何更改！
- en: Changes in the source code for Spring Cloud Gateway
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway的源代码更改
- en: 'The following changes have been applied in the configuration of the source
    code to replace the Spring Cloud Gateway with a Kubernetes ingress resource:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码的配置中已经应用了以下更改，以将Spring Cloud Gateway替换为Kubernetes入口资源：
- en: Changes in the Kubernetes definition files for deployment resources in the `kubernetes/services` folder.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`kubernetes/services`文件夹中的部署资源的Kubernetes定义文件中进行更改。
- en: Removed the gateway YAML files and its declaration in the `kustomization.yml` files
    in the `base` and `overlays/prod` folders
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`base`和`overlays/prod`文件夹中的`kustomization.yml`文件中删除了网关YAML文件及其声明。
- en: Added the ingress resource in `base/ingress-edge-server.yml` and added a reference
    to it in `base/kustomization.yml`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`base/ingress-edge-server.yml`中添加了入口资源，并在`base/kustomization.yml`中添加了对它的引用。
- en: 'The definition of the ingress resource looks like the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 入口资源的定义如下代码所示：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following are the explanations for the preceding source code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述源代码的解释：
- en: The ingress resource is named `edge`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入口资源命名为`edge`。
- en: The `tls` section specifies that the ingress will require the use of HTTPS and
    that it will use a certificate issued for the `minikube.me` hostname.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tls`部分指定入口将需要使用HTTPS，并且将使用为`minikube.me`主机名颁发的证书。'
- en: The certificate is stored in a secret named `tls-certificate`
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书存储在名为`tls-certificate`的secret中
- en: The `tls-certificate` secret will be created in *step 4* in the *Testing with
    Kubernetes ConfigMaps, secrets, and ingress resource* section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`tls-certificate`密钥将在*步骤4*中在*使用Kubernetes ConfigMaps、secrets和ingress资源进行测试*部分中创建。'
- en: Routing rules are defined for requests to the `minikube.me` hostname.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由规则已定义为对`minikube.me`主机名的请求。
- en: The DNS name `minikube.me` will be mapped to the IP address of the Minikube
    instance in the next topic.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`minikube.me`的DNS名称将在下一个主题中映射到Minikube实例的IP地址。'
- en: 'Routes are defined for the following:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下路由已定义：
- en: The `auth-server` on the `/oauth` path
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth-server`在`/oauth`路径上'
- en: The `product-composite` microservice on the `/product-composite` path
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product-composite`微服务在`/product-composite`路径上'
- en: The `health` endpoint in the `product-composite` microservice on the `/actuator/health` path
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product-composite`微服务中的`health`端点在`/actuator/health`路径上'
- en: The Kubernetes ingress resource will be created in the next section where we
    will test the microservice landscape together with Kubernetes config maps, secrets,
    and an ingress resource.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes入口资源将在下一节中创建，我们将在那里测试微服务景观以及Kubernetes配置映射、secrets和入口资源。
- en: Testing with Kubernetes ConfigMaps, secrets, and ingress resource
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes ConfigMaps、secrets和ingress资源进行测试
- en: 'With the preceding changes described, we are ready to test the system landscape
    with the Spring Cloud Config Server and the Spring Cloud Gateway replaced by Kubernetes
    config maps, secrets, and an ingress resource.  As before, when we used the Spring
    Cloud Gateway as the edge server, the external API will be protected by HTTPS.
    With this deployment, we will configure the ingress resource to reuse the self-signed
    certificate we used with the Spring Cloud Gateway for HTTPS. This is illustrated
    by the following diagram:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述描述的更改，我们已准备好使用Kubernetes配置映射、secrets和ingress资源测试系统景观，替换了Spring Cloud Config
    Server和Spring Cloud Gateway。与之前一样，当我们使用Spring Cloud Gateway作为边缘服务器时，外部API将受到HTTPS保护。通过此部署，我们将配置ingress资源以重用我们在Spring
    Cloud Gateway中用于HTTPS的自签名证书。下图说明了这一点：
- en: '![](img/5eb38462-0a35-4944-a8e6-0e6ff5e338b1.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5eb38462-0a35-4944-a8e6-0e6ff5e338b1.png)'
- en: In the next section, we will enhance the certificate usage and replace the self-signed
    certificate with certificates issued by Let's Encrypt.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将增强证书的使用，并用Let's Encrypt颁发的证书替换自签名证书。
- en: 'The ingress will be exposed on the default HTTPS port, `443`, on the Minikube
    instance. This is handled by the ingress controller that was installed when we
    performed the `minikube addons enable ingress` command; see [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml),
    *Introduction to Kubernetes *and refer to the *Creating a Kubernetes cluster*
    section for a recap. The ingress controller consists of a deployment, `nginx-ingress-controller`,
    in the `kube-system` namespace. The deployment configures its pod using a `hostPort`
    to map port `443` in the host, that is, the Minikube instance, to port `443` in
    the container that runs in the pod. The central parts in the definition of the
    deployment look like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress将在Minikube实例的默认HTTPS端口`443`上公开。这由我们执行`minikube addons enable ingress`命令时安装的ingress控制器处理；参见[第15章](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml)，*Kubernetes简介*并参考*创建Kubernetes集群*部分进行回顾。
    Ingress控制器由`kube-system`命名空间中的部署`nginx-ingress-controller`组成。该部署使用`hostPort`配置其pod，将主机中的端口`443`（即Minikube实例）映射到在pod中运行的容器中的端口`443`。部署定义中的核心部分如下所示：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This setup works for a single-node Kubernetes cluster used for development and
    testing. In a multi-node Kubernetes cluster, external load balancers are used
    to expose an ingress controller for high availability and scalability.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置适用于用于开发和测试的单节点Kubernetes集群。在多节点Kubernetes集群中，使用外部负载均衡器来公开ingress控制器，以实现高可用性和可伸缩性。
- en: The deployment uses the same type of commands as we used in [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml),
    *Deploying Our Microservices to Kubernetes*; refer to the *Deploying to Kubernetes
    for development and test* section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 部署使用与我们在[第16章](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml)中使用的相同类型的命令；参见*部署到Kubernetes进行开发和测试*部分。
- en: 'The major differences are that this deployment will:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的区别在于此部署将：
- en: Create one config map for each microservice instead of one config map for the configuration
    server
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个微服务创建一个配置映射，而不是为配置服务器创建一个配置映射
- en: Create secrets for credentials to the resource managers and a secret for the
    TLS certificate used by the ingress instead of creating secrets for the credentials
    to the configuration server
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为资源管理器的凭据和用于ingress的TLS证书创建secrets，而不是为配置服务器的凭据创建secrets
- en: Create one ingress instead of using Spring Cloud Gateway
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个ingress，而不是使用Spring Cloud Gateway
- en: To simplify the deployment, deploy scripts for the development and production environments
    have been added to the source code. Let's go through the deploy script for the development environment
    that we will use in this section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化部署，已将开发和生产环境的部署脚本添加到了源代码中。让我们来看看我们将在本节中使用的*开发*环境的部署脚本。
- en: Walking through the deploy script
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过部署脚本进行步行
- en: 'The `kubernetes/scripts/deploy-dev-env.bash` script, contains the necessary
    commands for performing the deployment. The script will perform the following
    steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubernetes/scripts/deploy-dev-env.bash`脚本包含执行部署所需的必要命令。脚本将执行以下步骤：'
- en: 'It will create config maps, one per microservice. For example, for the `product`
    microservice, we have the following:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将创建配置映射，每个微服务一个。例如，对于`product`微服务，我们有以下内容：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, it will create the required secrets. For example, credentials for accessing
    RabbitMQ are created with the following command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将创建所需的secrets。例如，访问RabbitMQ的凭据是使用以下命令创建的：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Secrets are also created for the resource managers; their names are suffixed
    with `server-credentials`. They are used in the Kubernetes definitions files in
    the `kubernetes/services/overlays/dev` folder. For example, credentials used by
    RabbitMQ are created with the following command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源管理器的secrets也被创建；它们的名称以`server-credentials`为后缀。它们在`kubernetes/services/overlays/dev`文件夹中的Kubernetes定义文件中使用。例如，RabbitMQ使用的凭据是使用以下命令创建的：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The secret that contains the TLS certificate for the ingress, `tls-certificate`,
    is based on the already existing self-signed certificate in the `kubernetes/cert` folder.
    It is created with the following command:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含ingress的TLS证书的secret`tls-certificate`基于`kubernetes/cert`文件夹中已存在的自签名证书。它是使用以下命令创建的：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The self-signed certificate has been created with the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 自签名证书是使用以下命令创建的：
- en: '`openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout kubernetes/cert/tls.key
    -out kubernetes/cert/tls.crt -subj "/CN=minikube.me/O=minikube.me"`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout kubernetes/cert/tls.key
    -out kubernetes/cert/tls.crt -subj "/CN=minikube.me/O=minikube.me"`'
- en: 'Deploy the microservices for the development environment, based on the `dev` overlay,
    using the `-k` switch to activate Kustomize:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于`dev`覆盖，使用`-k`开关激活Kustomize，为开发环境部署微服务。
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Wait for the deployment and its pods to be up and running:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待部署及其pod启动和运行：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After this walkthrough, we are ready to run the commands required for deploying
    and testing!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此步骤后，我们已准备好运行所需的部署和测试命令！
- en: Running commands for deploying and testing
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行部署和测试的命令
- en: 'Before we can perform the deployment, we need to make the following preparations:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行部署之前，我们需要做以下准备：
- en: Map the DNS name used by the ingress, `minikube.me`, to the IP address of the
    Minikube instance
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将ingress使用的DNS名称`minikube.me`映射到Minikube实例的IP地址
- en: Build Docker images from source
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源代码构建Docker镜像
- en: Create a namespace in Kubernetes
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中创建一个命名空间
- en: 'Run the following commands to prepare, deploy, and test:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令进行准备、部署和测试：
- en: 'Map `minikube.me` to the IP address of the Minikube instance by adding a line
    to the file `/etc/hosts` with the following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向文件`/etc/hosts`添加一行将`minikube.me`映射到Minikube实例的IP地址，使用以下命令：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Verify the result with the `cat /etc/hosts` command. Expect a line that contains
    the IP address of your Minikube instance followed by `minikube.me` as shown in
    the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cat /etc/hosts`命令验证结果。期望找到一行，其中包含您的Minikube实例的IP地址，后面跟着`minikube.me`，如下面的截图所示：
- en: '![](img/e620ccae-5f94-4d2f-a0cc-9c5b94ffb268.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e620ccae-5f94-4d2f-a0cc-9c5b94ffb268.png)'
- en: 'Build Docker images from source with the following commands:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从源代码构建Docker镜像：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Recreate the namespace, `hands-on`, and set it as the default namespace:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新创建命名空间`hands-on`，并将其设置为默认命名空间：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Execute the deployment by running the script with the following command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令运行脚本来执行部署：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once the deployment is complete, start the tests with the following command:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署完成后，使用以下命令开始测试：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Expect the normal output that we have seen from the previous chapters as shown
    in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 期望看到正常的输出，就像前面章节中所看到的那样，如下面的截图所示：
- en: '![](img/2029adbf-aead-45bf-b8a5-78f258baa0f6.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2029adbf-aead-45bf-b8a5-78f258baa0f6.png)'
- en: 'You can try out the APIs manually by performing the same steps as in the earlier
    chapters: just replace the host and port with `minikube.me`. Get an OAuth/OIDC
    access token and use it to call an API with the following commands:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以尝试手动执行API，方法与之前的章节相同：只需将主机和端口替换为`minikube.me`。获取OAuth/OIDC访问令牌，并使用以下命令调用API：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Expect the requested product ID, `2`, in the response.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 期望在响应中找到请求的产品ID `2`。
- en: The deployment we have set up in this section is based on an environment aimed
    at developing and testing. If you want to set up an environment aimed at staging
    and production, such as the one described in [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml),
    *Deploying Our Microservices to Kubernetes*, refer to the *Deploying to Kubernetes
    for staging and production* section. For this, you can use the `./kubernetes/scripts/deploy-prod-env.bash` script.
    Use it in *step 4* as previously outlined instead of the `deploy-dev-env.bash` script.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中设置的部署是基于开发和测试的环境。如果您想要设置一个面向暂存和生产的环境，比如[第16章](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml)中描述的环境，*将我们的微服务部署到Kubernetes*，请参考*部署到Kubernetes用于暂存和生产*部分。为此，您可以使用`./kubernetes/scripts/deploy-prod-env.bash`脚本。在*步骤4*中，使用它来替代`deploy-dev-env.bash`脚本。
- en: Note that the `deploy-prod-env.bash` script will launch the three resource managers
    for MySQL, MongoDB, and RabbitMQ using Docker Compose; that is, they will run as
    Docker containers outside Kubernetes (in the same way as in [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml),
    *Deploying Our Microservices to Kubernetes*).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`deploy-prod-env.bash`脚本将使用Docker Compose启动MySQL、MongoDB和RabbitMQ的三个资源管理器；也就是说，它们将作为Docker容器在Kubernetes之外运行（与[第16章](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml)中的*将我们的微服务部署到Kubernetes*相同）。
- en: This deployment uses a self-signed certificate that was exposed by the Kubernetes
    ingress and that requires manual provisioning. Manual handling of certificates
    is both time-consuming and error-prone. It is, for example, very easy to forget
    to renew a certificate in time. In the next section, we will learn how to use
    the Cert Manager and Let's Encrypt to automate this provisioning process!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此部署使用了由Kubernetes ingress暴露的自签名证书，并且需要手动提供。手动处理证书既费时又容易出错。例如，很容易忘记及时更新证书。在下一节中，我们将学习如何使用Cert
    Manager和Let's Encrypt来自动化这个提供过程！
- en: Automating the provision of certificates
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化证书的提供
- en: As mentioned in the introduction to this chapter, we will use the Cert Manager
    to automate the provision of certificates used by the external HTTPS endpoint
    exposed by the ingress. The Cert Manager will run as an add-on in Kubernetes and
    will be configured to request the issuing of certificates from Let's Encrypt with
    a free Certificate Authority that can be used to automate the issuing of certificates.
    To be able to verify that we own the DNS name that the certificate shall be issued
    for, Let's Encrypt requires access to the endpoint we want to issue the certificate
    for. Since our Kubernetes cluster runs locally in Minikube, we must make it possible
    for Let's Encrypt to access our cluster during the provisioning. We will use the ngrok
    tool to create a temporary HTTP tunnel from the internet to our local Kubernetes
    cluster to be used by Let's Encrypt.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章介绍中所述，我们将使用Cert Manager来自动化由ingress暴露的外部HTTPS端点使用的证书的提供。Cert Manager将作为Kubernetes中的附加组件运行，并将被配置为请求从Let's
    Encrypt颁发证书的免费证书颁发机构，以自动化证书的颁发。为了能够验证我们拥有证书应该颁发的DNS名称，Let's Encrypt需要访问我们想要颁发证书的端点。由于我们的Kubernetes集群在Minikube中本地运行，我们必须让Let's
    Encrypt在提供期间能够访问我们的集群。我们将使用ngrok工具从互联网创建一个临时的HTTP隧道到我们的本地Kubernetes集群，以供Let's
    Encrypt使用。
- en: 'For more information on each product, see the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有关每个产品的更多信息，请参阅以下内容：
- en: Cert Manager: [http://docs.cert-manager.io/en/latest/index.html](http://docs.cert-manager.io/en/latest/index.html)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Cert Manager: [http://docs.cert-manager.io/en/latest/index.html](http://docs.cert-manager.io/en/latest/index.html)'
- en: Let's Encrypt: [https://letsencrypt.org/docs/](https://letsencrypt.org/docs/)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Let''s Encrypt: [https://letsencrypt.org/docs/](https://letsencrypt.org/docs/)'
- en: ngrok: [https://ngrok.com/docs](https://ngrok.com/docs)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ngrok: [https://ngrok.com/docs](https://ngrok.com/docs)'
- en: 'All this together might seem a bit overwhelming, so let''s take it step by
    step:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些可能看起来有点令人不知所措，所以让我们一步一步来：
- en: Deploy the Cert Manager and define issuers in Kubernetes based on Let's Encrypt.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署Cert Manager并在Kubernetes中定义基于Let's Encrypt的颁发者。
- en: Create an HTTP tunnel using ngrok.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用ngrok创建HTTP隧道。
- en: Provision certificates with the Cert Manager and Let's Encrypt.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Cert Manager和Let's Encrypt提供证书。
- en: Verify that we got certificates from Let's Encrypt.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们从Let's Encrypt获得了证书。
- en: Clean up.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理。
- en: The HTTP tunnel is only required if your Kubernetes cluster isn't reachable
    on the internet. If its ingress resource can be accessed directly from the internet,
    the use of ngrok can be skipped.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Kubernetes集群无法在互联网上访问，则只有在需要HTTP隧道。如果其入口资源可以直接从互联网访问，则可以跳过使用ngrok。
- en: Deploying the Cert Manager and defining Let's Encrypt issuers
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署Cert Manager并定义Let's Encrypt颁发者
- en: 'To deploy the Cert Manager, we can execute a single Kubernetes definition file
    that will create a namespace, `cert-manager`, and then deploy the Cert Manager
    into the namespace. We will install version 0.8.1, the latest available version
    when writing this chapter. Run the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署Cert Manager，我们可以执行一个单独的Kubernetes定义文件，该文件将创建一个命名空间`cert-manager`，然后将Cert
    Manager部署到该命名空间。我们将安装版本0.8.1，在编写本章时是最新可用版本。运行以下命令：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you get an error message such as `unable to recognize "https://github.com/jetstack/cert-manager/releases/download/v0.8.1/cert-manager.yaml":
    no matches for kind "Issuer" in version "certmanager.k8s.io/v1alpha1"`, then simply
    rerun the command again.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到错误消息，例如`无法识别"https://github.com/jetstack/cert-manager/releases/download/v0.8.1/cert-manager.yaml"：在版本"certmanager.k8s.io/v1alpha1"中没有与"Issuer"匹配的内容`，那么只需重新运行命令。
- en: 'Wait for the deployment and its pods to be available:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 等待部署及其pod可用：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Expect output similar to the following from the command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令中期望类似以下的输出：
- en: '![](img/196e1fc3-83ec-4d71-84dc-18e5f84a59ed.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/196e1fc3-83ec-4d71-84dc-18e5f84a59ed.png)'
- en: With the Cert Manager in place, we can define issuers in Kubernetes that are
    based on Let's Encrypt.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有了Cert Manager，我们可以在Kubernetes中定义基于Let's Encrypt的颁发者。
- en: 'Let''s Encrypt exposes the following issuers:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Let's Encrypt公开以下颁发者：
- en: '**Staging environment**, to be used during development and test phases where
    it can be expected that a lot of short-lived certificates are requested. The staging
    environment allows for the creation of many certificates but the root **CA** *(*short
    for **Certificate Authority**) in the certificate is not trusted. This means that
    certificates from the staging environment can''t be used to protect web pages
    or APIs used by a web browser. A web browser won''t trust its root CA and will
    complain when a user opens a web page protected by certificates from the staging
    environment.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试环境**，用于开发和测试阶段，在这些阶段可以预期会请求大量短暂的证书。测试环境允许创建许多证书，但是证书中的根**CA**（**证书颁发机构**的缩写）不受信任。这意味着无法使用测试环境中的证书来保护网页或API，这些网页或API由Web浏览器使用。Web浏览器不会信任其根CA，并且当用户打开受测试环境中的证书保护的网页时，会出现错误。'
- en: '**Production environment**, it uses a trusted root CA to issue certificates.
    It can, therefore, be used to issue certificates that are trusted by web browsers.
    The production environment limits the number of certificates that can be issued.
    For example, only 50 new certificates per week can be issued per registered domain,
    for instance, in case `ngrok.io`.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产环境**，它使用受信任的根CA来签发证书。因此，它可以用于签发受Web浏览器信任的证书。生产环境限制可以签发的证书数量。例如，每周只能为每个注册域签发50个新证书，例如`ngrok.io`。'
- en: We will register two issuers in Kubernetes, one for the staging environment
    and one for the production environment. Issuers can be registered either globally
    in the cluster or locally in a namespace. To keep things together, we will use
    namespace local issuers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Kubernetes中注册两个颁发者，一个用于测试环境，一个用于生产环境。颁发者可以在集群中全局注册，也可以在命名空间中本地注册。为了使事情保持在一起，我们将使用命名空间本地颁发者。
- en: 'Communication between the Cert Manager and Let''s Encrypt during the provision
    of certificates is based on a standard protocol, **Automated Certificate Management
    Environment v2**, or **ACME v2** for short. Let''s Encrypt will act as a CA and
    the Cert Manager will act as an ACME client. To validate the ownership of a DNS
    name, the ACME protocol specifies two types of challenge that a CA can use:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在证书提供期间，Cert Manager与Let's Encrypt之间的通信基于标准协议**自动证书管理环境v2**，简称**ACME v2**。Let's
    Encrypt将充当CA，而Cert Manager将充当ACME客户端。为了验证DNS名称的所有权，ACME协议规定CA可以使用两种类型的挑战：
- en: '`http-01`: The CA asks the ACME client for a randomly named file to be made
    available under the following URL: `http://<domainname>/.well-known/acme-challenge/<randomfilename>`.
    If the CA succeeds in accessing the file using this URL, the ownership of the
    domain is validated.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http-01`：CA要求ACME客户端在以下URL下提供一个随机命名的文件：`http://<domainname>/.well-known/acme-challenge/<randomfilename>`。如果CA成功使用此URL访问文件，则验证域的所有权。'
- en: '`dns-01`: The CA asks the ACME client for a specified value to be placed in
    a TXT record, `_acme-challenge.<YOUR_DOMAIN>`, under the domain in the DNS server.
    This is typically achieved by using an API of the DNS provider. If the CA succeeds
    in accessing the specified content in the TXT record in the DNS server, the ownership
    of the domain is validated.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dns-01`：CA要求ACME客户端在DNS服务器的域下放置一个TXT记录`_acme-challenge.<YOUR_DOMAIN>`的指定值。这通常是通过使用DNS提供程序的API来实现的。如果CA成功访问DNS服务器中TXT记录中的指定内容，则验证域的所有权。'
- en: Automating a `dns-01` based challenge is harder to achieve than automating an
    `http-01` challenge in most cases; however, it is preferred, for example, if the
    HTTP endpoint isn't available on the internet. A `dns-01` challenge also supports
    issuing wildcard certificates, which an `http-01` challenge can't be used for.
    In this chapter, we will configure the Cert Manager to use an `http-01`—based
    challenge.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，自动化基于`dns-01`的挑战比自动化基于`http-01`的挑战更难实现；但是，例如，如果HTTP端点在互联网上不可用，则更倾向于使用`dns-01`挑战。`dns-01`挑战还支持签发通配符证书，而`http-01`挑战无法使用。在本章中，我们将配置Cert
    Manager以使用基于`http-01`的挑战。
- en: 'The definition of the issuer for the Let''s Encrypt staging environment looks
    like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 发行人的定义对于Let's Encrypt的演练环境如下所示：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following explains the preceding source code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下解释了上述源代码：
- en: The `name` of the issuer, `letsencrypt-issuer-staging`, will be used in the
    ingress when referring to the issuer to be used when provisioning certificates
    for the ingress.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发行人的`name`，`letsencrypt-issuer-staging`，将在入口中使用，用于引用在为入口提供证书时要使用的发行人。
- en: The `email` must be filled in with your email address. Let's Encrypt will use
    the email address to contact you about expiring certificates and issues, if any,
    related to your account.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`必须填写您的电子邮件地址。Let''s Encrypt将使用电子邮件地址与您联系，以便告知您有关即将到期的证书和与您的帐户相关的任何问题。'
- en: The `server` field points out the URL for the Let's Encrypt staging environment.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server`字段指出了Let''s Encrypt演练环境的URL。'
- en: The `privateKeySecretRef` field contains the name of a secret. This secret will
    be created by the Cert Manager and will contain an ACME/Let's Encrypt `account
    private key`. This key identifies you (or your company) as a user of the ACME
    service, that is, Let's Encrypt. It is used to sign requests sent to Let's Encrypt
    to validate your identity.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`privateKeySecretRef`字段包含一个秘钥的名称。这个秘钥将由Cert Manager创建，并包含ACME/Let''s Encrypt的`账户私钥`。这个秘钥标识您（或您的公司）作为ACME服务的用户，也就是Let''s
    Encrypt。它用于签署发送给Let''s Encrypt以验证您身份的请求。'
- en: The `solver` definition declares that an `http-01` challenge shall be used to
    verify the ownership of the domain name.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`solver`定义声明将使用`http-01`挑战来验证域名的所有权。'
- en: The definition of the issuer for the Let's Encrypt production environment looks
    the same, the major difference is the ACME server URL used: [https://acme-v02.api.letsencrypt.org/directory](https://acme-v02.api.letsencrypt.org/directory).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Let's Encrypt生产环境的发行人定义看起来是一样的，主要区别是使用的ACME服务器URL：[https://acme-v02.api.letsencrypt.org/directory](https://acme-v02.api.letsencrypt.org/directory)。
- en: 'Edit the following files and replace `<your email address>` with your email
    address:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑以下文件，并用您的电子邮件地址替换`<your email address>`：
- en: '`kubernetes/services/base/letsencrypt-issuer-staging.yaml`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubernetes/services/base/letsencrypt-issuer-staging.yaml`'
- en: '`kubernetes/services/base/letsencrypt-issuer-prod.yaml`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubernetes/services/base/letsencrypt-issuer-prod.yaml`'
- en: 'Apply the definitions with the following commands:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令应用定义：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We now have the Cert Manager in place and have registered issuers for the Let's
    Encrypt staging and production environment. The next step is to create an HTTP
    tunnel using `ngrok`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经安装了Cert Manager，并为Let's Encrypt的演练和生产环境注册了发行人。下一步是使用`ngrok`创建HTTP隧道。
- en: Creating an HTTP tunnel using ngrok
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ngrok创建HTTP隧道
- en: 'The free subscription to `ngrok` can be used to create an HTTP tunnel where
    `ngrok` terminates the HTTPS traffic using its own wildcard certificate for `***.ngrok.io`,
    that is, before the HTTP requests reach the ingress resource in Kubernetes. The
    client that sends the HTTPS request will only see the `ngrok` certificate and
    not the certificate exposed by the ingress resource in Kubernetes. This means
    that we can''t use the HTTP tunnel to test a certificate that has been issued
    by Let''s Encrypt and is used by the ingress resource in Kubernetes. This is illustrated
    in the following diagram:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 免费订阅`ngrok`可以用于创建HTTP隧道，其中`ngrok`使用其自己的通配符证书终止HTTPS流量，即`***.ngrok.io`，也就是在HTTP请求到达Kubernetes中的入口资源之前。发送HTTPS请求的客户端只会看到`ngrok`的证书，而不是Kubernetes中入口资源暴露的证书。这意味着我们无法使用HTTP隧道来测试由Let's
    Encrypt颁发并由Kubernetes中的入口资源使用的证书。如下图所示：
- en: '![](img/a5583460-7ef4-4f1a-a566-507395d3be49.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5583460-7ef4-4f1a-a566-507395d3be49.png)'
- en: 'But the HTTP tunnel can be used during the provisioning phase where Let''s
    Encrypt needs to verify that the ACME client owns the DNS name it is requested
    to issue a certificate for. The DNS name will be the hostname that `ngrok` assigns
    to the HTTP tunnel, for example, `6cc09528.ngrok.io`. Once the provisioning is
    performed, we can shut down the HTTP tunnel and redirect the hostname to the IP
    address of the Minikube instance (using the local `/etc/hosts` file). This is
    illustrated in the following diagram:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在证书颁发机构需要验证ACME客户端是否拥有其请求颁发证书的DNS名称时，可以在颁发阶段使用HTTP隧道。DNS名称将是`ngrok`分配给HTTP隧道的主机名，例如`6cc09528.ngrok.io`。一旦颁发完成，我们可以关闭HTTP隧道，并将主机名重定向到Minikube实例的IP地址（使用本地的`/etc/hosts`文件）。如下图所示：
- en: '![](img/d42306ac-0d80-43ca-bbc8-f783f35353ed.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d42306ac-0d80-43ca-bbc8-f783f35353ed.png)'
- en: For paying customers, `ngrok` provides a TLS tunnel that passes through HTTPS
    traffic instead of terminating it; that is, a client that sends an HTTPS request
    will be able to see and verify the certificate exposed by the ingress resource
    in Kubernetes. Using a TLS tunnel instead of the HTTP tunnel should make this
    extra step unnecessary.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于付费客户，`ngrok`提供了一个TLS隧道，通过该隧道可以传递HTTPS流量，而不是终止它；也就是说，发送HTTPS请求的客户端将能够查看并验证Kubernetes中入口资源暴露的证书。使用TLS隧道而不是HTTP隧道应该使这一额外步骤变得不必要。
- en: 'Perform the following steps to create the HTTP tunnel:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤创建HTTP隧道：
- en: 'Create the HTTP tunnel with the following command:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建HTTP隧道：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Expect output similar to the following screenshot:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期望输出类似于以下截图：
- en: '![](img/cc23906d-f9c7-44e8-aa0d-da848bd6e750.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc23906d-f9c7-44e8-aa0d-da848bd6e750.png)'
- en: 'Pick up the hostname for the HTTP tunnel, `6cc09528.ngrok.io` in the preceding
    example, and save it in an environment variable such as the following:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上面的示例中，获取HTTP隧道的主机名`6cc09528.ngrok.io`，并将其保存在环境变量中，例如以下内容：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With the HTTP tunnel in place, we can prepare the definition of the ingress
    resource for automatic provisioning of its certificate using the Cert Manager
    and Let's Encrypt!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有了HTTP隧道，我们可以准备入口资源的定义，以便使用Cert Manager和Let's Encrypt自动提供其证书！
- en: Provisioning certificates with the Cert Manager and Let's Encrypt
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cert Manager和Let's Encrypt颁发证书
- en: 'Before configuring the ingress resource, it might be good to have a high level
    understanding of how the provisioning is performed. The automated provisioning of
    a certificate using the Cert Manager and Let''s Encrypt looks like the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置ingress资源之前，了解证书准备的高级过程可能是有益的。使用Cert Manager和Let's Encrypt进行自动证书准备的过程如下：
- en: '![](img/ed4a016d-32e6-4381-af09-0f5d93641c42.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed4a016d-32e6-4381-af09-0f5d93641c42.png)'
- en: 'The following steps will be taken during the provisioning:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备过程中将采取以下步骤：
- en: 'An ingress is created annotated with `certmanager.k8s.io/issuer: "name of a
    Let''s Encrypt issuer"`.'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建了一个带有`certmanager.k8s.io/issuer: "Let''s Encrypt颁发者名称"`注释的ingress。'
- en: This annotation will trigger the Cert Manager to start to provide a certificate
    for the ingress using Let's Encrypt.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此注释将触发Cert Manager开始为ingress提供使用Let's Encrypt的证书。
- en: During the provisioning process, Let's Encrypt will perform an `http-01` challenge
    and use the HTTP tunnel to verify that the Cert Manager owns the DNS name.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在证书准备过程中，Let's Encrypt将执行`http-01`挑战，并使用HTTP隧道来验证Cert Manager拥有DNS名称。
- en: Once the provisioning is complete, the Cert Manager will store the certificate
    in Kubernetes and create a secret with the name specified by the ingress.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦准备完成，Cert Manager将在Kubernetes中存储证书，并创建一个与ingress指定名称相同的secret。
- en: 'We will add a new ingress, `edge-ngrok`, defined in the `ingress-edge-server-ngrok.yml` file, which will
    route requests to the hostname of the HTTP tunnel. This ingress will have the
    same routing rules as the existing ingress. The part that differs looks like the
    following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个新的ingress，“edge-ngrok”，定义在“ingress-edge-server-ngrok.yml”文件中，将请求路由到HTTP隧道的主机名。这个ingress将具有与现有ingress相同的路由规则。不同的部分如下所示：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is an explanation for the preceding source code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面源代码的解释：
- en: 'Using the `certmanager.k8s.io/issuer: "letsencrypt-issuer-staging"` annotation, 
    we ask the Cert Manager to provision a certificate for this ingress using the
    issuer named `letsencrypt-issuer-staging`.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用`certmanager.k8s.io/issuer: "letsencrypt-issuer-staging"`注释，我们要求Cert Manager使用名为“letsencrypt-issuer-staging”的颁发者为此ingress提供证书。'
- en: The `xxxxxxxx.ngrok.io` hostname in the `tls` and `rules` declarations must
    be replaced with the actual hostname of your HTTP tunnel.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“tls”和“rules”声明中的“xxxxxxxx.ngrok.io”主机名必须替换为您的HTTP隧道的实际主机名。
- en: The secret with the name `tls-ngrok-letsencrypt-certificate` is where the certificate
    will be stored once the provisioning is complete.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名为“tls-ngrok-letsencrypt-certificate”的secret是证书准备完成后的存储位置。
- en: With this high level of understanding of the provisioning process and an ingress
    resource prepared for using it in place, we can start to provision certificates
    using the two environments that Let's Encrypt supports. Let's start with the staging
    environment, suitable for development and test activities.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有了对准备过程的高级理解，并准备好使用ingress资源，我们可以开始使用Let's Encrypt支持的两个环境来准备证书。让我们从适用于开发和测试活动的staging环境开始。
- en: Using Let's Encrypt's staging environment
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Let's Encrypt的staging环境
- en: 'Perform the following steps to provision a certificate from Let''s Encrypt
    staging environment and verify that it works:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来准备Let's Encrypt的staging环境中的证书，并验证其是否有效：
- en: Edit the `kubernetes/services/base/ingress-edge-server-ngrok.yml` file and replace `xxxxxxxx.ngrok.io` with
    the hostname of your HTTP tunnel in two places!
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑“kubernetes/services/base/ingress-edge-server-ngrok.yml”文件，并在两个地方将“xxxxxxxx.ngrok.io”替换为您的HTTP隧道的主机名！
- en: (`6cc09528.ngrok.io` in the preceding example.)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: （在上面的示例中为“6cc09528.ngrok.io”）
- en: 'Before starting up the provisioning, run a watch command in a separate Terminal
    window to monitor the provisioning of the certificate. Run the following command:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动准备之前，在单独的终端窗口中运行watch命令，以监视证书的准备过程。运行以下命令：
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Initiate the provisioning by applying the new ingress definition with the following
    command:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过应用新的ingress定义来启动准备，使用以下命令：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Cert Manager will now detect the new ingress and start to provide a certificate
    with Let's Encrypt staging environment as the issuer using the ACME v2 protocol
    via the HTTP tunnel set up by `ngrok`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cert Manager现在将检测到新的ingress，并开始使用通过`ngrok`设置的HTTP隧道，使用Let's Encrypt的staging环境作为颁发者，通过ACME
    v2协议提供证书。
- en: 'After a while, you should notice the `http-01` challenge in the Terminal window
    where the HTTP tunnel runs. Expect a request like the following in the output:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过一会儿，您应该在终端窗口中注意到HTTP隧道运行的`http-01`挑战。预计输出中会有以下请求：
- en: '![](img/48532285-e42c-41b8-87c5-953c433986d2.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48532285-e42c-41b8-87c5-953c433986d2.png)'
- en: 'A `tls-ngrok-letsencrypt-certificate` certificate will be created and it will
    be stored in the `tls-ngrok-letsencrypt-certificate` secret, as specified in the
    ingress. Expect output from the `kubectl get cert --watch` command similar to
    the following:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建一个名为“tls-ngrok-letsencrypt-certificate”的证书，并将其存储在ingress中指定的“tls-ngrok-letsencrypt-certificate”secret中。预计`kubectl
    get cert --watch`命令的输出类似于以下内容：
- en: '![](img/75548aa6-b6b1-4b86-b7f3-24a40a679869.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75548aa6-b6b1-4b86-b7f3-24a40a679869.png)'
- en: After a while the `READY` state of the certificate will be changed to `True`,
    meaning that the certificate is provisioned and we are ready to try it out!
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证书的“READY”状态将在一段时间后更改为“True”，这意味着证书已经准备好，我们可以开始尝试了！
- en: 'To try out the certificate provisioned by Let''s Encrypt, we need to redirect
    the `ngrok` hostname to point directly to the Minikube IP address. We will add
    the hostname of the HTTP tunnel to the `/etc/hosts` file resolved to the IP address
    of the Minikube instance. This will result in local requests sent to the hostname
    of the HTTP tunnel being directed to the Minikube instance as illustrated by the
    following diagram:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要尝试Let's Encrypt颁发的证书，我们需要将`ngrok`主机名重定向到Minikube IP地址。我们将在`/etc/hosts`文件中添加HTTP隧道的主机名，解析为Minikube实例的IP地址。这将导致发送到HTTP隧道的本地请求被定向到Minikube实例，如下图所示：
- en: '![](img/e82140ea-df2b-41c7-9abd-a64f465ec373.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e82140ea-df2b-41c7-9abd-a64f465ec373.png)'
- en: 'Edit the `/etc/hosts` file and add the hostname of your HTTP tunnel after `minikube.me`
    in the line we added earlier in the chapter. After the edit, the line should look
    similar to the following:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`/etc/hosts`文件，并在我们在本章前面添加的行中的`minikube.me`之后添加您的HTTP隧道的主机名。编辑后，该行应该类似于以下内容：
- en: '![](img/bc8718bb-49a9-4a2d-835a-7a07a6b48936.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc8718bb-49a9-4a2d-835a-7a07a6b48936.png)'
- en: 'Use the `keytool` command to see what certificate the hostname of the HTTP
    tunnel exposes:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`keytool`命令查看HTTP隧道主机名暴露的证书：
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Expect a response such as the following:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期望得到以下类似的响应：
- en: '![](img/02d1d310-1b40-4966-ab53-2a8b2a6dd43a.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02d1d310-1b40-4966-ab53-2a8b2a6dd43a.png)'
- en: If your `keytool` is localized, that is, it prints its output in another language
    rather than English, you will need to change the `Owner:|Issuer:` string used
    by the preceding `grep` command, to the localized version.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的`keytool`是本地化的，即以其他语言而不是英语打印输出，您将需要将前面的`grep`命令使用的`Owner:|Issuer:`字符串更改为本地化版本。
- en: The certificate is issued for the hostname of the HTTP tunnel (`6cc09528.ngrok.io` in
    the preceding example) and it is issued by `Fake LE Intermediate X1` using `Fake
    LE Root X1` as its Root CA. This verifies that the ingress uses the Let's Encrypt
    staging certificate!
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证书是为HTTP隧道的主机名（在上面的示例中为`6cc09528.ngrok.io`）颁发的，由`Fake LE Intermediate X1`使用`Fake
    LE Root X1`作为其根CA颁发。这验证了入口使用了Let's Encrypt的暂存证书！
- en: 'Wrap up by running the `test-em-all.bash` test script using the same command:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用相同的命令运行`test-em-all.bash`测试脚本来结束：
- en: '[PRE28]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Expect the usual output from the test script; check that it concludes with
    the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 期望从测试脚本中得到通常的输出；检查它是否以以下内容结尾：
- en: '![](img/b922e10e-eac0-41a4-8ca6-c714f34b08e5.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b922e10e-eac0-41a4-8ca6-c714f34b08e5.png)'
- en: Certificates provisioned by Let's Encrypt staging environment are, as mentioned
    previously, good for development and test activities. But since its root CA is
    not trusted by web browsers, they can't be used in production scenarios. Let's
    also try out Let's Encrypt's production environment, which is capable of provisioning
    trusted certificates, albeit in limited numbers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面提到的，由Let's Encrypt暂存环境配置的证书适用于开发和测试活动。但由于其根CA未受Web浏览器信任，因此不能在生产场景中使用。让我们也尝试一下Let's
    Encrypt的生产环境，它能够提供受信任的证书，尽管数量有限。
- en: Using Let's Encrypt's production environment
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Let's Encrypt的生产环境
- en: 'To provision a certificate from Let''s Encrypt production environment, instead
    of the staging environment, we have to change the issuer in the ingress definition
    and then apply the updated definition. Perform the following steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Let's Encrypt的生产环境配置证书，而不是暂存环境，我们必须更改入口定义中的发行者，然后应用更新后的定义。执行以下步骤：
- en: 'Edit the `kubernetes/services/base/ingress-edge-server-ngrok.yml`  file and
    change the following code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`kubernetes/services/base/ingress-edge-server-ngrok.yml`文件，并更改以下代码：
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code should now be as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码现在应该如下所示：
- en: '[PRE30]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Apply the change by running the following command:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令应用更改：
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Monitor the output from the `kubectl get cert --watch` command and wait for
    the new certificate to be provisioned. Its ready state will change to `False`
    immediately after the apply command, and after a short while it will go back to
    `True`. This means that the Cert Manager has provisioned a certificate issued
    by Let's Encrypt production environment!
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监视`kubectl get cert --watch`命令的输出，并等待新证书被配置。应用命令后，其就绪状态将立即更改为`False`，并在短时间后将返回为`True`。这意味着Cert
    Manager已经配置了由Let's Encrypt生产环境颁发的证书！
- en: 'Check the certificate with the following `keytool` command:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`keytool`命令检查证书：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Expect output such as the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 期望得到以下类似的输出：
- en: '![](img/5d0e1392-a7d9-469e-9b9e-6c49555ebdcb.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d0e1392-a7d9-469e-9b9e-6c49555ebdcb.png)'
- en: The new certificate is like the one previously issued for the hostname of the
    HTTP tunnel (`6cc09528.ngrok.io` in the preceding example), but this time the
    issuer and Root CA are from the production environment. This means that the certificate
    should be trusted by a web browser.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新证书与先前为HTTP隧道的主机名（在上面的示例中为`6cc09528.ngrok.io`）颁发的证书类似，但这次颁发者和根CA来自生产环境。这意味着证书应该被Web浏览器信任。
- en: 'Open the `https://6cc09528.ngrok.io/actuator/health` URL (replace `6cc09528.ngrok.io`
    with the hostname of your HTTP tunnel) in a local web browser. If you use Google
    Chrome and click on the certificate icon (the padlock in front of the URL) you
    should see something like the following output:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地Web浏览器中打开`https://6cc09528.ngrok.io/actuator/health` URL（将`6cc09528.ngrok.io`替换为您的HTTP隧道的主机名）。如果您使用Google
    Chrome并单击证书图标（URL前面的挂锁），您应该看到以下输出：
- en: '![](img/152c06f8-df1e-4c52-b633-84ac22f7717e.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/152c06f8-df1e-4c52-b633-84ac22f7717e.png)'
- en: 'As seen in the preceding screenshot Chrome reports: This certificate is valid!'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，Chrome报告：此证书有效！
- en: 'Wrap up by verifying that the `test-em-all.bash` test script also works with
    this certificate as follows:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过验证`test-em-all.bash`测试脚本也可以使用此证书来结束：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Expect the usual output from the test script; check that it concludes with
    the following output:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 期望从测试脚本中得到通常的输出；检查它是否以以下输出结尾：
- en: '![](img/6d63d35e-1728-4d39-a779-d1f4424d0918.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d63d35e-1728-4d39-a779-d1f4424d0918.png)'
- en: You can switch back to the staging issuer by following the same procedure but
    also change back to the staging issuer in the ingress definition.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过遵循相同的步骤切换回到暂存发行者，但同时还需要在入口定义中切换回到暂存发行者。
- en: Cleaning up
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: 'When you are done, clean up the resources created in Kubernetes (and optionally
    in Docker) using Docker Compose by running the following commands:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，通过运行以下命令在Kubernetes中清理创建的资源（以及可选地在Docker中使用Docker Compose）。：
- en: Stop the `kubectl get cert --watch` command with *Ctrl + C.*
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl + C.*停止`kubectl get cert --watch`命令。
- en: Stop the HTTP tunnel with *Ctrl* *+* *C.*
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止HTTP隧道，使用*Ctrl* *+* *C.*
- en: 'Delete the namespace in Kubernetes with the following command:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令删除Kubernetes中的命名空间：
- en: '[PRE34]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you tried out the production environment deployment using the `./kubernetes/scripts/deploy-prod-env.bash`
    script, you also need to stop the resource managers that were launched as Docker
    containers using Docker Compose. Run the following command to stop them:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尝试使用`./kubernetes/scripts/deploy-prod-env.bash`脚本进行生产环境部署，还需要停止使用Docker Compose启动的资源管理器。运行以下命令来停止它们：
- en: '[PRE35]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now that we are done automating the certificates to provision them, let's see
    how to verify that microservices work without Kubernetes. Let's see how this is
    done.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了自动化证书的配置，让我们看看如何验证微服务在没有Kubernetes的情况下工作。让我们看看这是如何完成的。
- en: Verifying that microservices work without Kubernetes
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证微服务在没有Kubernetes的情况下工作
- en: In this chapter and the previous one, we have seen how features in the Kubernetes
    platform, such as config maps, secrets, services, and ingress resources, can simplify
    the effort of developing a landscape of cooperating microservices. But it is important
    to ensure that the source code of the microservices doesn't get dependent on the
    platform from a functional perspective. Avoiding such a lock-in makes it possible
    to change to another platform in the future, if required, with minimal effort.
    Changing the platform should not require changes in the source code but only in
    the configuration of the microservices.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和上一章中，我们已经看到Kubernetes平台中的功能，如配置映射、秘密、服务和入口资源，可以简化开发合作微服务的工作。但是，确保微服务的源代码在功能上不依赖于平台是很重要的。避免这种锁定可以使将来更换到另一个平台时，只需进行最少的工作量。更改平台不应该需要更改源代码，而只需要更改微服务的配置。
- en: Testing the microservices using Docker Compose and the `test-em-all.bash` test
    script will ensure that they work from a functional perspective, meaning that
    they will verify that the functionality in the microservice source code still
    works without Kubernetes. When running microservices without Kubernetes, we will
    lack the non-functional features that Kubernetes provides us with, for example,
    monitoring, scaling, and restarting containers.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Compose和`test-em-all.bash`测试脚本测试微服务将确保它们从功能角度正常工作，这意味着它们将验证微服务源代码中的功能仍然可以在没有Kubernetes的情况下正常工作。在没有Kubernetes的情况下运行微服务，我们将缺少Kubernetes为我们提供的非功能特性，例如监视、扩展和重新启动容器。
- en: 'When using Docker Compose, we will map the following Kubernetes features:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Compose时，我们将映射以下Kubernetes功能：
- en: Instead of config maps, we use volumes that map the configuration files directly
    from the host filesystem.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用卷而不是配置映射，直接从主机文件系统映射配置文件。
- en: Instead of using secrets, we keep sensitive information such as credentials
    in the `.env` file.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将敏感信息，如凭据，保存在`.env`文件中，而不是使用秘密。
- en: Instead of an ingress, we will use the Spring Cloud Gateway.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用Spring Cloud Gateway而不是入口
- en: Instead of services, we will map hostnames used by the clients directly to the
    hostnames of the containers, meaning that we will not have any service discovery
    in place and will not be able to scale containers.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将直接将客户端使用的主机名映射到容器的主机名，而不是使用服务，这意味着我们将不会有任何服务发现，并且无法扩展容器。
- en: Using Docker Compose this way will result in significant disadvantages from
    a non-functional perspective compared to using Kubernetes. But it is acceptable,
    given that Docker Compose will only be used to run functional tests.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用Docker Compose将在非功能角度上产生显着的劣势，与使用Kubernetes相比。但鉴于Docker Compose只用于运行功能测试，这是可以接受的。
- en: Let's go through the code changes in the `docker-compose*.yml` files before
    we run the tests using Docker Compose.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Docker Compose测试之前，让我们先看一下`docker-compose*.yml`文件中的代码更改。
- en: Changes in the source code for Docker Compose
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose的源代码更改
- en: 'To run microservices outside Kubernetes, using Docker Compose, the following
    changes have been applied to the `docker-compose*.yml` files:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Compose在Kubernetes之外运行微服务时，对`docker-compose*.yml`文件进行了以下更改：
- en: Removed the configuration server definition
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了配置服务器定义
- en: Removed the use of the following configuration server environment variables: `CONFIG_SERVER_USR` and `CONFIG_SERVER_PWD`
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了以下配置服务器环境变量的使用：`CONFIG_SERVER_USR`和`CONFIG_SERVER_PWD`
- en: Mapped the `config-repo` folder as a volume in each container that needs to
    read configuration files from the configuration repository
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`config-repo`文件夹映射为每个需要从配置存储库读取配置文件的容器的卷
- en: Defined the `SPRING_CONFIG_LOCATION` environment variable to point to the configuration
    files in the configuration repository
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`SPRING_CONFIG_LOCATION`环境变量，指向配置存储库中的配置文件
- en: Stored sensitive information such as credentials and passwords in TLS certificates
    in the Docker Compose `.env` file
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker Compose的`.env`文件中存储敏感信息，如凭据和密码的TLS证书
- en: Defined environment variables with credentials for access to resource managers
    using the variables defined in the `.env` file
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在`.env`文件中定义的变量，定义了用于访问资源管理器的凭据的环境变量
- en: 'For example, the configuration of the `product` microservice looks like the
    following in `docker-compose.yml`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`docker-compose.yml`中，`product`微服务的配置如下：
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is an explanation for the preceding source code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面源代码的解释：
- en: The `config-repo` folder is mapped as a volume into the container at `/config-repo`.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config-repo`文件夹被映射为容器中的卷，位于`/config-repo`。'
- en: The `SPRING_CONFIG_LOCATION` environment variable tells Spring where to find
    the property files, in this case, the `/config-repo/application.yml` and `/config-repo/product.yml` files.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPRING_CONFIG_LOCATION`环境变量告诉Spring在哪里找到属性文件，本例中是`/config-repo/application.yml`和`/config-repo/product.yml`文件。'
- en: Credentials for accessing RabbitMQ and MongoDB are set up as environment variables
    based on the content in the `.env` file.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于`.env`文件中的内容，设置访问RabbitMQ和MongoDB的凭据作为环境变量。
- en: 'The credentials referred to in the preceding source code are defined in the `.env` file
    as:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 前面源代码中提到的凭据在`.env`文件中定义为：
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Testing with Docker Compose
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose进行测试
- en: 'To test with Docker Compose, we will use Docker Desktop (earlier named Docker
    for macOS) instead of Minikube. Perform the following steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Docker Compose进行测试，我们将使用Docker Desktop（之前称为Docker for macOS）而不是Minikube。执行以下步骤：
- en: 'To direct the Docker client to use Docker Desktop instead of Minikube run the
    following command:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将Docker客户端指向Docker Desktop而不是Minikube，请运行以下命令：
- en: '[PRE38]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To save memory, you might want to stop the Minikube instance:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了节省内存，您可能希望停止Minikube实例：
- en: '[PRE39]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Start Docker Desktop (if not already running).
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Docker Desktop（如果尚未运行）。
- en: 'Build the Docker images in Docker Desktop with the following command:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在Docker Desktop中构建Docker镜像：
- en: '[PRE40]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the tests using RabbitMQ (with one partition per topic):'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用RabbitMQ运行测试（每个主题一个分区）：
- en: '[PRE41]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The tests should begin by starting all the containers, run the tests, and finally
    stop all the containers. Expect output like the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该从启动所有容器开始，运行测试，最后停止所有容器。期望的输出如下：
- en: '![](img/949cd3b9-d551-4336-a25d-a256cae5ad6e.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/949cd3b9-d551-4336-a25d-a256cae5ad6e.png)'
- en: 'Optionally, run the tests using RabbitMQ with multiple partitions per topic:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，使用RabbitMQ在每个主题上设置多个分区来运行测试：
- en: '[PRE42]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Expect output that's similar to the preceding test.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 期望输出与前面的测试类似。
- en: 'Alternatively, run the test using Kafka with multiple partitions per topic:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，使用Kafka在每个主题上设置多个分区来运行测试：
- en: '[PRE43]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Expect output that's similar to the preceding test.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 期望输出与前面的测试类似。
- en: Stop Docker Desktop to save memory.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止Docker Desktop以节省内存。
- en: 'Start the Minikube instance, if it was stopped previously, and set the default
    namespace to `hands-on`:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Minikube实例，如果之前已停止，并将默认命名空间设置为`hands-on`：
- en: '[PRE44]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Point the Docker client back to the Kubernetes cluster in the Minikube instance:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Docker客户端指向Minikube实例中的Kubernetes集群：
- en: '[PRE45]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With the successful execution of these tests, we have verified that the microservices
    work without Kubernetes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些测试的成功执行，我们已经验证了微服务在没有Kubernetes的情况下可以正常工作。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how capabilities in Kubernetes can be used to
    simplify a microservice landscape, meaning that we reduce the number of support
    services to be developed and deployed together with the microservices. We have
    seen how Kubernetes config maps and secrets can be used to replace the Spring
    Cloud Config Server and how a Kubernetes ingress can replace an edge service based
    on Spring Cloud Gateway.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了Kubernetes中的功能如何可以用来简化微服务架构，这意味着我们可以减少需要与微服务一起开发和部署的支持服务的数量。我们已经看到了Kubernetes配置映射和秘钥如何可以用来替代Spring
    Cloud Config Server，以及Kubernetes Ingress如何可以替代基于Spring Cloud Gateway的边缘服务。
- en: Using the Cert Manager together with Let's Encrypt allowed us to automatically
    provision certificates for HTTPS endpoints exposed by the ingress, eliminating
    the need for manual and cumbersome work. Since our Kubernetes cluster running
    in a local Minikube instance isn't available from the internet, we used `ngrok`
    to establish an HTTP tunnel from the internet to the Minikube instance. The HTTP
    tunnel was used by Let's Encrypt to verify that we are the owner of the DNS name
    we requested a certificate for.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cert Manager和Let's Encrypt允许我们自动为Ingress暴露的HTTPS端点提供证书，消除了手动和繁琐的工作。由于我们在本地Minikube实例中运行的Kubernetes集群无法从互联网访问，我们使用`ngrok`从互联网到Minikube实例建立了HTTP隧道。HTTP隧道被Let's
    Encrypt用来验证我们是否是请求证书的DNS名称的所有者。
- en: To verify that the source code of the microservices can run on other platforms,
    that is, isn't locked into Kubernetes, we deployed the microservices using Docker
    Compose and ran the `test-em-all.bash` test script.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证微服务的源代码可以在其他平台上运行，即不被锁定在Kubernetes中，我们使用Docker Compose部署了微服务并运行了`test-em-all.bash`测试脚本。
- en: In the next chapter, we will be introduced to the concept of a service mesh
    and learn how a service mesh product, **Istio**, can be used to improve observability,
    security, resilience, and routing in a landscape of cooperating microservices
    that are deployed on Kubernetes.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍服务网格的概念，并了解如何使用服务网格产品**Istio**来改善在部署在Kubernetes上的合作微服务架构中的可观察性、安全性、弹性和路由。
- en: Head over to the next chapter!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 前往下一章！
- en: Questions
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How was the Spring Cloud Config Server replaced by Kubernetes resources?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Cloud Config Server是如何被Kubernetes资源替代的？
- en: How was the Spring Cloud Gateway replaced by Kubernetes resources?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway是如何被Kubernetes资源替代的？
- en: What does ACME stand for and what is it used for?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ACME代表什么，它用于什么？
- en: What role does the Cert Manager and Let's Encrypt play in automating the provision
    of certificates?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cert Manager和Let's Encrypt在自动化提供证书中扮演什么角色？
- en: What Kubernetes resources are involved in automating the provision of certificates?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些Kubernetes资源涉及自动化提供证书？
- en: Why did we use `ngrok` and what is required to be added to remove the use of
    ngrok?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们使用了`ngrok`，需要添加什么以删除对ngrok的使用？
- en: Why did we run the tests using Docker Compose?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们要使用Docker Compose运行测试？
