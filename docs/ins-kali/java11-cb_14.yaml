- en: Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'This chapter shows how to test your application—how to capture and automate
    the testing of use cases, how to unit test your APIs before they are integrated
    with other components, and how to integrate all of the units. We will introduce
    you to **Behavior-Driven Development** (**BDD**) and show how it can become the
    starting point of your application development. We will also demonstrate how JUnit
    framework can be used for unit testing. Sometimes, during unit testing, we would
    have to stub dependencies with some dummy data, and this can be done by mocking
    the dependencies. We will show you how to do this using a mocking library. We
    will also show you how to write fixtures to populate test data and then how you
    can test the behavior of your application by integrating different APIs and testing
    them together. We will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何测试你的应用程序——如何捕获和自动化测试用例，如何在将API与其他组件集成之前对API进行单元测试，以及如何集成所有单元。我们将向您介绍**行为驱动开发**（**BDD**）并展示它如何成为应用程序开发的起点。我们还将演示如何使用JUnit框架进行单元测试。有时，在单元测试期间，我们必须使用一些虚拟数据存根依赖项，这可以通过模拟依赖项来完成。我们将向您展示如何使用模拟库来做到这一点。我们还将向您展示如何编写固定装置来填充测试数据，然后如何通过集成不同的API并一起测试它们来测试应用程序的行为。我们将涵盖以下内容：
- en: Behavioral testing using Cucumber
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cucumber进行行为测试
- en: Unit testing of an API using JUnit
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JUnit对API进行单元测试
- en: Unit testing by mocking dependencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试通过模拟依赖关系
- en: Using fixtures to populate data for testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用固定装置来填充测试数据
- en: Integration testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Well-tested code provides peace of mind to the developer. If you get a feeling
    that writing a test for the new method you are developing is too much of an overhead,
    then you usually don't get it right the first time. You have to test your method
    anyway, and it is less time-consuming in the long run to set up or write a unit
    test than to build and start up the application many times—every time the code
    changes and for every logical pass through.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 经过良好测试的代码为开发人员提供了心灵上的安宁。如果你觉得为你正在开发的新方法编写测试太过繁琐，那么通常第一次就做不对。无论如何，你都必须测试你的方法，而在长远来看，设置或编写单元测试比构建和启动应用程序多次要少时间消耗——每次代码更改和每次逻辑通过都要这样做。
- en: One of the reasons we often feel pressed for time is that we do not include
    in our estimates the time needed for writing the test. One reason is that we sometimes
    just forget to do it. Another reason is that we shy away from giving a higher
    estimate because we do not want to be perceived as not skilled enough. Whatever
    the reason, it happens. Only after years of experience, we learn to include tests
    in our estimates and earn enough respect and clout to be able to assert publicly
    that doing things right requires more time up front, but saves much more time
    in the long run. Besides, doing it right leads to a robust code with far less
    stress, which means a better quality of life overall.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常感到时间紧迫的原因之一是我们在估算时间时没有包括编写测试所需的时间。一个原因是我们有时会忘记这样做。另一个原因是我们不愿意给出更高的估计，因为我们不想被认为技能不够。不管原因是什么，这种情况经常发生。只有经过多年的经验，我们才学会在估算中包括测试，并赢得足够的尊重和影响力，能够公开断言正确的做事方式需要更多的时间，但从长远来看节省了更多的时间。此外，正确的做法会导致健壮的代码，减少了很多压力，这意味着整体生活质量更好。
- en: Another advantage of testing early—before the main code is completed—is that
    the code weaknesses are discovered during the phase when fixing it is easy. If
    need be, you can even restructure code for better testability.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 早期测试的另一个优势是在主要代码完成之前发现代码的弱点，这时修复它很容易。如果需要，甚至可以重构代码以提高可测试性。
- en: If you are still not convinced, make note of the date when you read this and
    check back every year until this advice becomes obvious to you. Then, please share
    your experiences with others. This is how humanity makes progress—by passing knowledge
    from one generation to the next.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不相信，记下你阅读此文的日期，并每年回顾一次，直到这些建议对你来说变得显而易见。然后，请与他人分享你的经验。这就是人类取得进步的方式——通过将知识从一代传递到下一代。
- en: Methodologically, the content of this chapter is applicable to other languages
    and professions too, but the examples are written primarily for Java developers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从方法上讲，本章的内容也适用于其他语言和职业，但示例主要是为Java开发人员编写的。
- en: Behavioral testing using Cucumber
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cucumber进行行为测试
- en: 'The following are three recurring complaints of programmers:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序员经常提出的三个反复出现的抱怨：
- en: Lack of requirements
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏需求
- en: Ambiguity of requirements
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求的模糊性
- en: Requirements are changing all the time
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求一直在变化
- en: There are quite a few recommendations and processes that help alleviate these
    problems, but none of them were able to eliminate them completely. The most successful,
    in our opinion, was an agile process methodology in conjunction with BDD, using
    Cucumber or another similar framework. Short iterations allow quick adjustment
    and coordination between businesses (customers) and programmers, while BDD with
    Cucumber captures the requirements in a formal language called Gherkin, but without
    the overhead of maintaining extensive documentation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多建议和流程可以帮助缓解这些问题，但没有一个能够完全消除它们。在我们看来，最成功的是敏捷过程方法与BDD相结合，使用Cucumber或其他类似框架。短迭代允许快速调整和业务（客户）与程序员之间的协调，而BDD与Cucumber以Gherkin捕获需求，但没有维护大量文档的开销。
- en: The requirements written in Gherkin have to be broken into **features**. Each
    feature is stored in a file with a `.feature` extension and consists of one or
    more **scenarios** that describe different aspects of the feature. Each scenario
    consists of steps that describe user actions or just input data and how the application
    responds to it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin中编写的需求必须被分解成**特性**。每个特性存储在一个扩展名为`.feature`的文件中，包含一个或多个描述特性不同方面的**场景**。每个场景由描述用户操作或输入数据以及应用程序对其的响应的步骤组成。
- en: A programmer implements the necessary application functionality and then uses
    it to implement the scenarios in one or many `.java` files. Each step is implemented
    in a method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员实现必要的应用程序功能，然后使用它来在一个或多个`.java`文件中实现场景。每个步骤都在一个方法中实现。
- en: After their implementation, the scenarios become a suite of tests that can be
    as fine-grained as a unit test or as high-level as an integration test, and anything
    in between. It all depends on who writes the scenario and how the application
    code is structured. If the authors of the scenarios are business folk, the scenarios
    tend to be higher-level use cases. But if the application is structured so that
    each scenario (with possibly multiple permutations of input data) is implemented
    as a method, then it serves effectively as a unit test. Alternatively, if a scenario spans
    several methods or even subsystems, it can serve as an integration test, while
    programmers may complement it with finer-grained (more unit test-like) scenarios. Later,
    after the code is delivered, all the scenarios can serve as regression tests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施后，这些场景将成为一套测试，可以是像单元测试一样细粒度，也可以是像集成测试一样高级，以及介于两者之间的任何形式。这完全取决于谁编写了场景以及应用程序代码的结构。如果场景的作者是业务人员，那么场景往往更高级。但是，如果应用程序的结构使得每个场景（可能有多个输入数据的排列组合）都被实现为一个方法，那么它就可以有效地作为一个单元测试。或者，如果一个场景涉及多个方法甚至子系统，它可以作为一个集成测试，而程序员可以用更细粒度（更像单元测试）的场景来补充它。之后，在代码交付后，所有场景都可以作为回归测试。
- en: 'The price you pay is an overhead of the scenarios, maintenance, but the reward
    is the formal system that captures the requirements and provides an assurance
    that the application does exactly what is required. That said, one qualification
    is in order: capturing scenarios for the UI layer is usually more problematic
    because the UI tends to change more often, especially at the beginning of application
    development. Yet, as soon as UI has stabilized, the requirements to it can also
    be captured in Cucumber scenarios using Selenium or a similar framework.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您所付出的代价是场景的开销、维护，但回报是捕获需求并确保应用程序确实符合要求的正式系统。话虽如此，需要说明的一点是：捕获UI层的场景通常更加棘手，因为UI往往更频繁地发生变化，特别是在应用程序开发的初期。然而，一旦UI稳定下来，对其的需求也可以使用Selenium或类似的框架在Cucumber场景中进行捕获。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Install Cucumber. The Cucumber installation is nothing more than adding the
    framework to the project as a Maven dependency. Since we are going to add several
    Cucumber JAR files and all of them have to be of the same version, it makes sense
    to add the `cucumber.version` property in `pom.xml` first:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Cucumber。Cucumber的安装只是将框架作为Maven依赖项添加到项目中。由于我们将添加多个Cucumber JAR文件，而且它们都必须是相同版本，因此在`pom.xml`中添加`cucumber.version`属性是有意义的。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we can add the Cucumber main JAR file in `pom.xml` as a dependency:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`pom.xml`中将Cucumber主JAR文件添加为依赖项：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, if you prefer a fluent stream-based style of coding, you can
    add a different Cucumber main JAR file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您更喜欢流畅的基于流的编码风格，您可以添加一个不同的Cucumber主JAR文件：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If your project does not have JUnit set up as a dependency yet, you may add
    it as follows along with another `cucumber-junit` JAR file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目尚未设置JUnit作为依赖项，您可以按照以下步骤添加它以及另一个`cucumber-junit` JAR文件：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The above is necessary if you plan to take advantage of JUnit assertions. Note
    that, at the time of writing, Cucumber does not support JUnit 5.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以上是必要的，如果您计划利用JUnit断言。请注意，目前为止，Cucumber不支持JUnit 5。
- en: 'Alternatively, you can use assertions from TestNG ([https://testng.org](https://testng.org)):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用TestNG（[https://testng.org](https://testng.org)）中的断言：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, in this case, you need to add the `cucumber-testng` JAR file instead
    of the `cucumber-junit` JAR file. TestNG offers a rich variety of assertion methods,
    including deep collections and other object comparisons.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这种情况下，您需要添加`cucumber-testng` JAR文件，而不是`cucumber-junit` JAR文件。TestNG提供了丰富多样的断言方法，包括深度集合和其他对象比较。
- en: 'Run Cucumber. The `cucumber-junit` JAR file also provides an `@RunWith` annotation
    that designates a class as a test runner:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Cucumber。`cucumber-junit` JAR文件还提供了一个`@RunWith`注解，将一个类指定为测试运行器：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Execution of the preceding class will execute all scenarios in the same package
    where the runner is located. Cucumber reads each `.feature` file and the scenarios
    in it. For each step of each scenario, it tries to find its implementation in
    the same package as the runner and the `.feature` file. It executes each implemented
    step in the sequence they are listed in a scenario.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前述类将执行与运行器所在的相同包中的所有场景。Cucumber读取每个`.feature`文件及其中的场景。对于每个场景的每个步骤，它尝试在与运行器和`.feature`文件相同的包中找到其实现。它按照场景中列出的顺序执行每个已实现的步骤。
- en: 'Create a `.feature` file. As we have mentioned already, a `.feature` file contains
    one or more scenarios. The name of the file does not mean anything for Cucumber.
    The content of the file starts with the `Feature` keyword (with the colon `:` after
    it). The following text describes the feature and, similar to the filename, does
    not mean anything to Cucumber. The feature description ends when the `Scenario` keyword
    (with the colon `:` after it) starts a new line. That is when the first scenario
    description begins. Here is an example:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`.feature`文件。正如我们已经提到的，一个`.feature`文件包含一个或多个场景。文件的名称对Cucumber没有任何意义。文件的内容以`Feature`关键字（后面跟着冒号`:`）开始。接下来的文本描述了功能，并且与文件名类似，对Cucumber没有任何意义。功能描述在`Scenario`关键字（后面跟着冒号`:`）开始新行时结束。这就是第一个场景描述开始的地方。以下是一个例子：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The scenario description ends when one of the following keywords starts a new
    line: `Given`, `When`, `Then`, `And`, or `But`. Each of these keywords, when it
    starts a new line, indicates the beginning of a step definition. For Cucumber,
    such a keyword means nothing except the beginning of the step definition. But
    for humans, it is easier to read if the scenario starts with the keyword  `Given`—the
    step that describes the initial state of the system—prerequisite. Several other
    steps (prerequisites) may follow; each step starts with a new line and the keyword
    `And` or `But`, for example, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下关键字之一在新行上开始时，场景描述结束：`Given`、`When`、`Then`、`And`或`But`。每个这些关键字在新行开始时，都表示步骤定义的开始。对于Cucumber来说，这样的关键字除了表示步骤定义的开始外，没有其他意义。但对于人类来说，如果场景以`Given`关键字开始，即描述系统的初始状态的步骤，那么阅读起来更容易。可能会有几个其他步骤（前提条件）跟随；每个步骤都以新行和`And`或`But`关键字开头，例如如下所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, the group of steps describes the actions or events. For human readability,
    the group typically starts with the `When` keyword at a new line. Other actions
    or events follow, and each starts with a new line and the `And` or `But` keyword.
    It is recommended to keep the number of steps in this group to a minimum, so each
    scenario is well focused, for example, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，步骤组描述了动作或事件。为了人类可读性，该组通常以新行的`When`关键字开头。其他动作或事件随后，每个都以新行和`And`或`But`关键字开头。建议将该组中的步骤数量保持在最小限度，以便每个场景都能够集中精力，例如如下所示：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last group of steps in a scenario starts with the `Then` keyword in the
    new line. They describe the expected results. As in the previous two groups of
    steps, each subsequent step in this group starts with a new line and the `And` or `But` keyword
    too, for example, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中的最后一组步骤以新行中的`Then`关键字开始。它们描述了预期的结果。与前两组步骤一样，该组中的每个后续步骤都以新行和`And`或`But`关键字开头，例如如下所示：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To summarize the previous, the feature looks as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 总结之前，该功能如下：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We put it in the `CalculateSpeed.feature` file in the following folder: `src/test/resources/com/packt/cookbook/Chapter14_testing`,'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其放在以下文件夹中的`src/test/resources/com/packt/cookbook/Chapter14_testing`中的`CalculateSpeed.feature`文件中。
- en: Note that, it has to be in the `test/resources` folder and the path to it has
    to match the package name where the `RunScenariosTest` test runner belongs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它必须位于`test/resources`文件夹中，并且其路径必须与`RunScenariosTest`测试运行器所属的包名称匹配。
- en: The test runner is executed as any JUnit test, using the `mvn test` command,
    for example, or just by running it in JDE. When executed, it looks for all `.feature`
    files in the same package (Maven copies them from the `resources` folder to the
    `target/classes` folder, hence setting them on the classpath). It then reads the
    steps of each scenario sequentially and tries to find the implementation of each
    step in the same package.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器像执行任何JUnit测试一样，例如使用`mvn test`命令，或者只需在JDE中运行它。执行时，它会查找同一包中的所有`.feature`文件（Maven将它们从`resources`文件夹复制到`target/classes`文件夹，因此将它们设置在类路径上）。然后按顺序读取每个场景的步骤，并尝试在同一包中找到每个步骤的实现。
- en: As we have mentioned already, names of the file do not have any meaning for
    Cucumber. It looks for the `.feature` extension first, then finds the first step
    and, in the same directory, tries to find a class that has a method in it annotated
    by the same wording as the step.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，文件的名称对于Cucumber来说没有任何意义。它首先寻找`.feature`扩展名，然后找到第一个步骤，并在同一目录中尝试找到一个类，该类中有一个与步骤相同的注释方法。
- en: 'To illustrate what it means, let''s run the created feature by executing the
    test runner. The results are going to be as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明其含义，让我们通过执行测试运行器来运行创建的特性。结果将如下所示：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, Cucumber not only tells us which and how many features and scenarios
    are `undefined`, it even provides a possible way to implement them. Please note
    how Cucumber allows passing in parameters using a type in curly braces. The following
    are built-in types: `int`, `float`, `word`, `string`, `biginteger`, `bigdecimal`,
    `byte`, `short`, `long`, and `double`. The difference between `word` and `string`
    is that the latter allows spaces. But Cucumber also allows us to define custom
    types.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Cucumber不仅告诉我们有多少个`undefined`特性和场景，它甚至提供了一种可能的实现方式。请注意，Cucumber允许使用大括号中的类型传递参数。以下是内置类型：`int`、`float`、`word`、`string`、`biginteger`、`bigdecimal`、`byte`、`short`、`long`和`double`。`word`和`string`之间的区别在于后者允许空格。但Cucumber还允许我们定义自定义类型。
- en: Write and run step definitions. Cucumber's term `undefined` may be confusing
    because we did define the feature and scenarios. We just did not implement them.
    So, the `undefined` in the Cucumber message actually means `not implemented`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写并运行步骤定义。Cucumber术语中的`undefined`可能会令人困惑，因为我们确实定义了特性和场景。我们只是没有实现它们。因此，Cucumber消息中的`undefined`实际上意味着`未实现`。
- en: 'To start the implementation, we first create a class, `CalculateSpeedSteps`, in
    the same directory with the test runner. The class name has no meaning for Cucumber,
    so you can name it any other way you prefer. Then, we copy the three methods suggested previously
    with annotations and put them in that class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始实现，我们首先在与测试运行器相同的目录中创建一个名为`CalculateSpeedSteps`的类。类名对于Cucumber来说没有意义，所以您可以根据自己的喜好命名它。然后，我们将之前建议的三种方法与注释一起复制并放入该类中：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we execute the test runner again, the output will be as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次执行测试运行器，输出将如下所示：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The runner stopped executing at the first `PendingException`, so the other two
    steps were skipped. If BDD methodology is applied systematically, then the feature
    is written first—before any code of the application is written. So, every feature
    produces the previous result.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运行器在第一个`PendingException`处停止执行，因此其他两个步骤被跳过。如果系统地应用BDD方法论，那么特性将首先编写——在编写应用程序的任何代码之前。因此，每个特性都会产生前面的结果。
- en: As the application gets developed, each new feature is implemented and does
    not fail anymore.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的开发，每个新功能都得到了实现，并且不再失败。
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Immediately after the requirements are expressed as features, the application
    gets implemented feature by feature. For example, we could start by creating the `Vehicle` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在要求被表达为功能后，应用程序会逐个功能地实现。例如，我们可以从创建`Vehicle`类开始：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then the steps of the first feature shown previously can be implemented as
    follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，先前显示的第一个功能的步骤可以实现如下：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we run the test runner in the `com.packt.cookbook.ch16_testing` package again,
    the steps will be executed successfully.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次在`com.packt.cookbook.ch16_testing`包中运行测试运行器，步骤将成功执行。
- en: Now, if the requirements change and the `.feature` file is modified correspondingly,
    the test will fail, unless the application code is changed too and matches the
    requirements. That is the power of BDD. It keeps requirements in sync with the
    code. It also allows the Cucumber tests to serve as regression tests. If the code
    changes violate the requirements, the test fails.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果需求发生变化，并且`.feature`文件相应地进行了修改，除非应用程序代码也进行了更改并符合要求，否则测试将失败。这就是BDD的力量。它使要求与代码保持同步。它还允许Cucumber测试作为回归测试。如果代码更改违反了要求，测试将失败。
- en: Unit testing of an API using JUnit
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JUnit对API进行单元测试
- en: According to Wikipedia, more than 30% of the projects hosted on GitHub include
    JUnit—one of a family of unit testing frameworks collectively known as xUnit that
    originated with SUnit. It is linked as a JAR at compile time and resides (since
    JUnit 4) in the `org.junit` package.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，GitHub上托管的项目中超过30%包括JUnit，这是一组单元测试框架，统称为xUnit，起源于SUnit。它在编译时作为JAR链接，并且（自JUnit
    4以来）驻留在`org.junit`包中。
- en: In object-oriented programming, a unit can be an entire class but could be an
    individual method. We've found the last part—a unit as an individual method—the
    most useful in practice. It serves as the basis for the examples of the recipes
    of this chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，一个单元可以是整个类，也可以是一个单独的方法。在实践中，我们发现最有用的是作为一个单独方法的单元。它为本章的示例提供了基础。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'At the time of writing, the latest stable version of JUnit is 4.12, which can
    be used by adding the following Maven dependency to the `pom.xml` project level:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，JUnit的最新稳定版本是4.12，可以通过将以下Maven依赖项添加到`pom.xml`项目级别来使用：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After this, you can write your first JUnit test. Let''s assume you have the `Vehicle` class
    created in the `src/main/java/com/packt/cookbook.ch02_oop.a_classes` folder (this
    is the code we discussed in  [Chapter 2](db468cc9-60fa-4966-890a-872bef36ff01.xhtml), *Fast
    Track to OOP - Classes and Interfaces*):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以编写您的第一个JUnit测试。假设您已经在`src/main/java/com/packt/cookbook.ch02_oop.a_classes`文件夹中创建了`Vehicle`类（这是我们在[第2章](db468cc9-60fa-4966-890a-872bef36ff01.xhtml)中讨论的代码，*OOP
    - 类和接口的快速跟踪*）：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now you can create the `src/test/java/com/packt/cookbook.ch02_oop.a_classes` folder
    and a new file in it called `VehicleTest.java`, which contains the `VehicleTest`
    class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以创建`src/test/java/com/packt/cookbook.ch02_oop.a_classes`文件夹，并在其中创建一个名为`VehicleTest.java`的新文件，其中包含`VehicleTest`类：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run it using your favorite IDE or just with the `mvn test` command. You will
    see output that will include the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的IDE运行它，或者只需使用`mvn test`命令。您将看到包括以下内容的输出：
- en: '![](img/3ae6e5f2-a622-4f77-b934-2867786402f4.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ae6e5f2-a622-4f77-b934-2867786402f4.png)'
- en: Congratulations! You have created your first test class. It does not test anything
    yet, but it is an important setup—the overhead that is necessary for doing things
    the right way. In the next section, we will start with the actual testing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经创建了您的第一个测试类。它还没有测试任何东西，但这是一个重要的设置——这是以正确的方式进行操作所必需的开销。在下一节中，我们将开始实际测试。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s look at the `Vehicle` class closer. Testing the getters would be of
    little value, but we can still do it, making sure that the value passed to the
    constructor is returned by the corresponding getter. The exception in the constructor
    belongs to the must-test features as well as the `getSpeedMph()` method. There
    is also an object of the `Engine` class that has the `getHorsePower()` method.
    Can it return `null`? To answer this question, let''s look at the `Engine` class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下`Vehicle`类。测试getter的价值不大，但我们仍然可以这样做，确保传递给构造函数的值由相应的getter返回。构造函数中的异常也属于必须测试的功能，以及`getSpeedMph()`方法。还有一个`Engine`类的对象，它具有`getHorsePower()`方法。它能返回`null`吗？为了回答这个问题，让我们看一下`Engine`类：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `getHorsePower()` method cannot return `null`. The `horsePower` field will
    be initiated to the value zero by default if not set explicitly by the `setHorsePower()` method.
    But returning a negative value is a definite possibility, which in turn can cause
    problems for the `Math.sqrt()` function of the `getSpeedMph()` method. Should
    we make sure that the horsepower value will never be negative? It depends on how
    limited the method's usage is and the source of the input data for it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`getHorsePower()`方法不能返回`null`。如果没有通过`setHorsePower()`方法显式设置，`horsePower`字段将默认初始化为零。但是返回负值是一个明显的可能性，这反过来可能会导致`getSpeedMph()`方法的`Math.sqrt()`函数出现问题。我们应该确保马力值永远不会是负数吗？这取决于方法的使用限制程度以及输入数据的来源。'
- en: Similar considerations are applicable to the value of the `weightPounds` field
    of the `Vehicle` class. It can stop the application with `ArithmeticException`
    caused by the division by zero in the `getSpeedMph()` method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Vehicle`的`weightPounds`字段的值也适用类似的考虑。它可能会在`getSpeedMph()`方法中由于除以零而导致`ArithmeticException`而使应用程序停止。
- en: However, in practice, there is little chance that the values of an engine's
    horsepower and vehicle weight will be negative or close to zero, so we will assume
    this and will not add these checks to the code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，发动机马力和车辆重量的值几乎不可能是负数或接近零，因此我们将假设这一点，并不会将这些检查添加到代码中。
- en: Such analysis is the daily routine and the background thoughts of every developer,
    and that is the first step in the right direction. The second step is to capture
    all these thoughts and doubts in the unit tests and verify the assumptions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的分析是每个开发人员的日常例行公事和背景思考，这是朝着正确方向迈出的第一步。第二步是在单元测试中捕获所有这些思考和疑虑，并验证假设。
- en: 'Let''s go back to the test class we have created. As you may have noticed,
    the `@Test` annotation makes a certain method a test method. This means it will
    be run by your IDE or Maven every time you issue a command to run tests. The method
    can be named any way you like, but a best practice advises to indicate which method
    (of the `Vehicle` class, in this case) you are testing. So, the format usually
    looks like `test<methodname><scenario>`, where `scenario` indicates a particular
    test case: a happy path, a failure, or some other condition you would like to
    test. In the first example, though we do not use the suffix, just to keep the
    code simple. We will show examples of methods that test other scenarios later.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们创建的测试类。你可能已经注意到，`@Test`注解使某个方法成为测试方法。这意味着每次你发出运行测试的命令时，它都会被你的IDE或Maven运行。方法可以以任何你喜欢的方式命名，但最佳实践建议指出你正在测试的方法（在这种情况下是`Vehicle`类）。因此，格式通常看起来像`test<methodname><scenario>`，其中`scenario`表示特定的测试用例：一个成功的路径，一个失败，或者你想测试的其他条件。在第一个示例中，虽然我们没有使用后缀，但为了保持代码简单，我们将展示稍后测试其他场景的方法示例。
- en: 'In a test, you can call the application method you are testing, provide it
    with the data, and assert the result. You can create your own assertions (methods
    that compare the actual results with the expected ones) or you can use assertions
    provided by JUnit. To do the latter, just add the `static` import:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，你可以调用正在测试的应用程序方法，提供数据，并断言结果。你可以创建自己的断言（比较实际结果和预期结果的方法），或者你可以使用JUnit提供的断言。要做到后者，只需添加静态导入：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you use a modern IDE, you can type `import static org.junit.Assert` and
    see how many different assertions are available (or go to JUnit''s API documentation
    and see it there). There are a dozen or more overloaded methods available: `assertArrayEquals()`,
    `assertEquals()`, `assertNotEquals()`, `assertNull()`, `assertNotNull()`, `assertSame()`,
    `assertNotSame()`, `assertFalse()`, `assertTrue()`, `assertThat()`, and `fail()`.
    It would be helpful if you spend a few minutes reading what these methods do.
    You can also guess their purpose by their name. Here is an example of the usage
    of the `assertEquals()` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用现代IDE，你可以输入`import static org.junit.Assert`，看看有多少不同的断言可用（或者去JUnit的API文档中查看）。有十几个或更多的重载方法可用：`assertArrayEquals()`，`assertEquals()`，`assertNotEquals()`，`assertNull()`，`assertNotNull()`，`assertSame()`，`assertNotSame()`，`assertFalse()`，`assertTrue()`，`assertThat()`和`fail()`。如果你花几分钟阅读这些方法的作用将会很有帮助。你也可以根据它们的名称猜测它们的目的。下面是`assertEquals()`方法的使用示例：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We compare the actual length of the word `Hello` and the expected length of `4`.
    We know that the correct number would be `5`, but we would like the test to fail
    to demonstrate the failing behavior. If you run the preceding test, you''ll get
    the following result:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们比较单词`Hello`的实际长度和预期长度`4`。我们知道正确的数字应该是`5`，但我们希望测试失败以演示失败的行为。如果你运行前面的测试，你会得到以下结果：
- en: '![](img/e1062cd4-ecc4-430c-ab74-b23fe96f171d.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1062cd4-ecc4-430c-ab74-b23fe96f171d.png)'
- en: 'As you can see, the last line tells you what went wrong: the expected value
    was `4`, while the actual was `5`. Say you switch the order of the parameters
    like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，最后一行告诉你出了什么问题：预期值是`4`，而实际值是`5`。假设你像这样交换参数的顺序：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result will be as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/264588c3-e7e2-41ef-a779-f2450921c91e.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/264588c3-e7e2-41ef-a779-f2450921c91e.png)'
- en: The last message is misleading now.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最后一条消息是误导性的。
- en: It is important to remember that, in each of the asserting methods, the parameter
    with the expected value is located (in the signature of an assertion) **before**
    the actual one.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在每个断言方法中，预期值的参数位于（在断言的签名中）**实际值之前**。
- en: After the test is written, you will do something else, and months later, you
    will probably forget what each assertion actually evaluated. But it may well be
    that one day the test will fail (because the application code was changed). You
    will see the test method name, expected value, and the actual value, but you will
    have to dig through the code to figure out which of the assertions failed (there
    are often several of them in each test method). You will probably be forced to
    add a debug statement and run the test several times in order to figure it out.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 写完测试后，你会做其他事情，几个月后，你可能会忘记每个断言实际评估了什么。但有一天测试可能会失败（因为应用程序代码已更改）。你会看到测试方法名称，预期值和实际值，但你必须深入代码以找出哪个断言失败（每个测试方法通常有几个断言）。你可能会被迫添加调试语句并多次运行测试以找出原因。
- en: 'To help you avoid this extra digging, each of the JUnit assertions allows you
    to add a message that describes the particular assertion. For example, run this
    version of the test:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你避免这种额外的挖掘，JUnit的每个断言都允许你添加描述特定断言的消息。例如，运行测试的这个版本：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you do this, the result will be much more readable:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，结果会更容易阅读：
- en: '![](img/240214a0-c228-4e70-a98e-c153f7a27484.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/240214a0-c228-4e70-a98e-c153f7a27484.png)'
- en: 'To complete this demonstration, we change the expected value to `5`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个演示，我们将预期值更改为`5`：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now the test results show no failures:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试结果显示没有失败：
- en: '![](img/88e0720a-1f8b-4fdd-a58a-754ace2cc9aa.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88e0720a-1f8b-4fdd-a58a-754ace2cc9aa.png)'
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Equipped with the basic understanding of the usage of the JUnit framework,
    we can now write a real test method for the main case of the calculation of the
    speed of a vehicle with a certain weight and an engine of certain horsepower to
    determine. We take the formula we use for the speed calculations and calculate
    the expected value manually first. For example, if the vehicle has an engine of
    246 hp and weight of 4,000 lb, then in 10 seconds, its speed can reach 117 mph.
    Since the speed is of the `double` type, we will use the assertion with some delta.
    Otherwise, two `double` values may never be equal due to the way a `double` value
    is represented in the computer. Here is the assertion method of the `org.junit.Assert`
    class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 具备了对JUnit框架使用的基本理解，我们现在可以为计算具有特定重量和特定马力发动机的车辆速度的主要情况编写一个真正的测试方法。我们首先使用速度计算的公式手动计算预期值。例如，如果车辆的发动机功率为246
    hp，重量为4,000磅，那么在10秒内，其速度可以达到117英里/小时。由于速度是`double`类型，我们将使用带有一些delta的断言。否则，由于`double`值在计算机中的表示方式，两个`double`值可能永远不会相等。这是`org.junit.Assert`类的断言方法：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `delta` value is allowable precision. The resultant implementation of the
    `test` method will look as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`delta`值是允许的精度。`test`方法的最终实现将如下所示：'
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, we have decided that one-tenth of one percent of the value
    is a good enough precision for our purposes. If we run the preceding test, the
    output will be as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经决定值的千分之一是我们目的的足够精度。如果我们运行前面的测试，输出将如下所示：
- en: '![](img/c294b3f1-8103-4030-8038-af6f531c11b1.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c294b3f1-8103-4030-8038-af6f531c11b1.png)'
- en: 'To make sure the test is working, we can set the expected value to 119 mph
    (more than one percent different from the actual one) and run the test again.
    The result will be as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保测试有效，我们可以将预期值设置为119英里/小时（与实际值相差超过1％）并再次运行测试。结果将如下所示：
- en: '![](img/f79b70e9-475a-488a-8edc-f53d54f8b2b9.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f79b70e9-475a-488a-8edc-f53d54f8b2b9.png)'
- en: We change the expected value back to 117 and continue writing other test cases
    we discussed while analyzing the code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将预期值改回117，并继续编写我们在分析代码时讨论的其他测试用例。
- en: 'Let''s make sure that the exception is thrown when expected. To do that, we
    add another import:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保在预期时抛出异常。为此，我们添加另一个导入：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we can write the code that tests the case when the value passed in the
    constructor of the `Vehicle` class is null (so the exception should be thrown):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以编写测试代码，测试当`Vehicle`类的构造函数中传递的值为null时的情况（因此应该抛出异常）：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This test runs successfully, which means that the `Vehicle` constructor had
    thrown an exception and the code has never reached the line:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试成功运行，这意味着`Vehicle`构造函数抛出了异常，并且代码从未到达过这一行：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To make sure that the test works correctly, we temporarily pass a non-null
    value into the `Vehicle` constructor:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保测试正确工作，我们临时将非null值传递给`Vehicle`构造函数：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we observe the output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们观察输出：
- en: '![](img/e2efee35-c323-40dd-8a33-0dfb9df40e43.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2efee35-c323-40dd-8a33-0dfb9df40e43.png)'
- en: 'This way, we get a level of confidence that our test works as expected. Alternatively,
    we can create another test that fails when an exception is thrown:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以确保我们的测试按预期工作。或者，我们可以创建另一个测试，当抛出异常时失败：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The best way to write such tests is in the process of writing application code,
    so you can test the code as it grows in complexity. Otherwise, especially in more
    complex code, you might have problems debugging it after all of the code is written
    already.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这样的测试的最佳方式是在编写应用程序代码的过程中，这样您可以随着代码的复杂性增长而测试代码。否则，特别是在更复杂的代码中，您可能在编写所有代码后有问题调试它。
- en: There are quite a few other annotations and JUnit features that can be helpful
    to you, so please refer to the JUnit documentation for a more in-depth understanding
    of all the framework capabilities.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他注释和JUnit功能对您可能有帮助，因此请参考JUnit文档，以更深入地了解所有框架功能。
- en: Unit testing by mocking dependencies
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过模拟依赖项进行单元测试
- en: Writing a unit test requires controlling all the input data. In case a method
    receives its input from other objects, there arises a need to limit the depth
    of testing so that each layer can be tested in isolation as a unit. This is when
    the need for mocking the lower level comes into focus.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试需要控制所有输入数据。如果一个方法从其他对象接收其输入，就需要限制测试的深度，以便每个层可以作为一个单元独立测试。这就是模拟较低级别的需求时出现的情况。
- en: Mocking can be done not only vertically, but also horizontally at the same level.
    If a method is big and complicated, you might consider breaking it into several
    smaller methods so you can test only one of them while mocking the others. This
    is another advantage of unit testing code along with its development; it is easier
    to redesign code for better testability at the earlier stages of its development.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟不仅可以垂直进行，还可以在同一级别水平进行。如果一个方法很大且复杂，您可能需要考虑将其拆分为几个较小的方法，这样您可以在模拟其他方法的同时仅测试其中一个。这是单元测试代码与其开发一起的另一个优势；在开发的早期阶段更容易重新设计代码以获得更好的可测试性。
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Mocking other methods and classes is straightforward. Coding to an interface
    (as described in [Chapter 2](db468cc9-60fa-4966-890a-872bef36ff01.xhtml), *Fast
    Track to OOP - Classes and Interfaces*) makes it much easier, although there are
    mocking frameworks that allow you to mock classes that do not implement any interface
    (we will see examples of such framework usage in the next section of this recipe).
    Also, using object and method factories helps you create test-specific implementations
    of such factories so they can generate objects with methods that return the expected
    hardcoded values.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟其他方法和类很简单。编码到接口（如[第2章](db468cc9-60fa-4966-890a-872bef36ff01.xhtml)中描述的*快速跟踪到OOP-类和接口*）使得这变得更容易，尽管有一些模拟框架允许您模拟不实现任何接口的类（我们将在本食谱的下一部分看到此类框架使用的示例）。此外，使用对象和方法工厂可以帮助您创建特定于测试的工厂实现，以便它们可以生成具有返回预期硬编码值的方法的对象。
- en: 'For example, in [Chapter 4](69c0640b-9b2e-4515-bda6-8a481206da19.xhtml), *Going
    Functional*, we introduced `FactoryTraffic`, which produced one or many objects
    of `TrafficUnit`. In a real system, this factory would draw data from some external
    system. Using the real system as the source could complicate the code setup. As
    you could see, to get around this problem, we mocked the data by generating it
    according to the distribution that somewhat resembles the real one: a bit more
    cars than trucks, the weight of the vehicle depending on the type of the car,
    the number of passengers and weight of the payload, and similar. What is important
    for such a simulation is that the range of values (minimum and maximum) should
    reflect those coming from the real system, so the application would be tested
    on the full range of possible real data.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[第4章](69c0640b-9b2e-4515-bda6-8a481206da19.xhtml)*函数式编程*中，我们介绍了`FactoryTraffic`，它生产了一个或多个`TrafficUnit`对象。在真实系统中，这个工厂会从某个外部系统中获取数据。使用真实系统作为数据源可能会使代码设置变得复杂。正如你所看到的，为了解决这个问题，我们通过根据与真实系统相似的分布生成数据来模拟数据：汽车比卡车多一点，车辆的重量取决于汽车的类型，乘客数量和有效载荷的重量等。对于这样的模拟，重要的是值的范围（最小值和最大值）应该反映出来自真实系统的值，这样应用程序就可以在可能的真实数据的全部范围内进行测试。
- en: The important constraint for mocking code is that it should not be too complicated.
    Otherwise, its maintenance would require an overhead that would either decrease
    the team productivity or decrease the test coverage.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟代码的重要约束是它不应该太复杂。否则，它的维护将需要额外的开销，这将要么降低团队的生产力，要么降低测试覆盖率。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The mock of `FactoryTraffic` may look like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`FactoryTraffic`的模拟可能如下所示：'
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It assembles a collection of `TrafficUnit` objects. In a real system, these
    objects would be created from the rows of the result of some database query, for
    example. But in our case, we just hardcode the values:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它组装了一个`TrafficUnit`对象的集合。在真实系统中，这些对象可以从例如某个数据库查询结果的行创建。但在我们的情况下，我们只是硬编码了这些值：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, we used a random number generator to pick up the value from
    a range for each of the parameters. The range is in line with the ranges of the
    real data. This code is very simple and it does not require much maintenance,
    but it provides the application with the flow of data similar to the real one.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用随机数生成器来为每个参数选择一个范围内的值。这个范围与真实数据的范围一致。这段代码非常简单，不需要太多的维护，但它提供了与真实数据类似的数据流给应用程序。
- en: 'You can use another technique. For example, let''s revisit the `VechicleTest`
    class. Instead of creating a real `Engine` object, we can mock it using one of
    the mocking frameworks. In this case, we use Mockito. Here is the Maven dependency
    for it:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用另一种技术。例如，让我们重新审视`VechicleTest`类。我们可以使用其中一个模拟框架来模拟而不是创建一个真实的`Engine`对象。在这种情况下，我们使用Mockito。以下是它的Maven依赖项：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The test method now looks like this (the two lines that were changed are highlighted):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法现在看起来像这样（已更改的两行已突出显示）：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, we instruct the `mock` object to return a fixed value when
    the `getHorsePower()` method is called. We can even go as far as creating a mock
    object for the method we want to test:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们指示`mock`对象在调用`getHorsePower()`方法时返回一个固定值。我们甚至可以为我们想要测试的方法创建一个模拟对象：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, it always returns the same value:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它总是返回相同的值：
- en: '![](img/8d517f9e-a80c-4179-abb1-a42149aed65b.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d517f9e-a80c-4179-abb1-a42149aed65b.png)'
- en: However, this would defeat the purpose of testing because we would like to test
    the code that calculates the speed, not to mock it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将违背测试的目的，因为我们想测试计算速度的代码，而不是模拟它。
- en: 'For testing a stream''s pipeline methods, yet another technique can be used.
    Let''s assume we need to test the `trafficByLane()` method in the `TrafficDensity1`
    class (we are going to have  `TrafficDensity2` and `TrafficDensity3`, too):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试流的管道方法，还可以使用另一种技术。假设我们需要测试`TrafficDensity1`类中的`trafficByLane()`方法（我们也将有`TrafficDensity2`和`TrafficDensity3`）：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It uses two support classes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用了两个支持类：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It also uses the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它还使用以下内容：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We demonstrated the use of such support classes in Chapter 3, *Modular* *Programming*,
    while talking about streams. Now we realize that testing this class might not
    be easy.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第3章*模块化编程*中演示了这些支持类的使用，同时讨论了流。现在我们意识到测试这个类可能不容易。
- en: 'Because the `SpeedModel` object is an input parameter for the `trafficByLane()` method,
    we could test its `getSpeedMph()` method in isolation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`SpeedModel`对象是`trafficByLane()`方法的输入参数，我们可以单独测试它的`getSpeedMph()`方法：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Refer to the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, the current implementation of `FactorySpeedModel` requires
    the `TrafficUnit` object in order to get the traction value. To get around this
    problem, we can modify the preceding code and remove the `SpeedModel` dependency
    on `TrafficUnit`. We can do it by moving the traction application to the `calcSpeed()`
    method. The new version of `FactorySpeedModel` can look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`FactorySpeedModel`的当前实现需要`TrafficUnit`对象以获取牵引值。为了解决这个问题，我们可以修改前面的代码并移除`SpeedModel`对`TrafficUnit`的依赖。我们可以通过将牵引应用到`calcSpeed()`方法来实现。`FactorySpeedModel`的新版本可以看起来像这样：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The test method can now be implemented as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以实现测试方法如下：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'However, the `calcSpeed()` method in `TrafficUnitWrapper` remains untested.
    We could test the `trafficByLane()` method as a whole:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`TrafficUnitWrapper`中的`calcSpeed()`方法仍未经过测试。我们可以将`trafficByLane()`方法作为一个整体进行测试：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But this would require creating a stream of objects of `TrafficUnit` with fixed
    data:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但这将需要创建一个具有固定数据的`TrafficUnit`对象流：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Such a solution does not provide a variety of test data for different vehicle
    types and other parameters. We need to revisit the design of the `trafficByLane()` method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的解决方案不能为不同车辆类型和其他参数提供各种测试数据。我们需要重新审视`trafficByLane()`方法的设计。
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you look closely at the `trafficByLane()` method, you will notice that the
    problem is caused by the location of the calculation—inside the private class, `TrafficUnitWrapper`.
    We can move it out of there and create a new method, `calcSpeed()`, in the `TrafficDensity` class:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察`trafficByLane()`方法，你会注意到问题是由于计算的位置——在私有类`TrafficUnitWrapper`内部。我们可以将其移出，并在`TrafficDensity`类中创建一个新的`calcSpeed()`方法：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we can change its signature and include the `Vehicle` object and `traction`
    coefficient as parameters:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以改变其签名，并将`Vehicle`对象和`traction`系数作为参数包括进去：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s also add two methods to the `TrafficUnitWrapper` class (you will see
    in a moment why we need them):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还向`TrafficUnitWrapper`类添加两个方法（您马上就会看到我们为什么需要它们）：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding changes allow us to rewrite the stream pipeline as follows (the
    changed line is in bold):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的更改允许我们重写流管道如下（更改的行用粗体标出）：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'By making the `calcSpeed()` method protected and assuming that the `Vehicle`
    class is tested in its own test class, `VehicleTest`, we can now write the `testCalcSpeed()` method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`calcSpeed()`方法设置为protected，并假设`Vehicle`类在其自己的测试类`VehicleTest`中进行了测试，我们现在可以编写`testCalcSpeed()`方法：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The remaining functionality can be tested by mocking the `calcSpeed()` method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的功能可以通过模拟`calcSpeed()`方法来测试：
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This experience has made us aware that using an inner private class can make
    the functionality untestable in isolation. Let''s try to get rid of the `private`
    class, `CountByLane`. This leads us to the third version of the `TrafficDensity3`
    class (the changed code is highlighted):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种经验使我们意识到，使用内部私有类可能会使功能在隔离中无法测试。让我们试着摆脱`private`类`CountByLane`。这将导致`TrafficDensity3`类的第三个版本（更改的代码已突出显示）：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This change allows us to extend the class in our test:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变允许我们在我们的测试中扩展这个类：
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It also allows us to change the `calcLaneNumber()` test method in isolation:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它还允许我们单独更改`calcLaneNumber()`测试方法：
- en: '[PRE54]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Using fixtures to populate data for testing
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fixtures来为测试填充数据
- en: In more complex applications (that use a database, for example), there is often
    the need to set up the data before each test and clean it up after the test is
    completed. Some parts of the data need to be set before each test method and/or
    cleaned after each test method has completed. Other data may need to be set up
    before any test method of the test class was run and/or cleaned up after the last
    test method of the test class has completed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的应用程序中（例如使用数据库），通常需要在每个测试之前设置数据，并在测试完成后清理数据。一些数据的部分需要在每个测试方法之前设置和/或在每个测试方法完成后清理。其他数据可能需要在测试类的任何测试方法运行之前设置，并/或在测试类的最后一个测试方法完成后清理。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To accomplish this, you add an `@Before` annotation in front of it, which indicates
    that this method has to run before every test method. The corresponding cleaning
    method is identified by the `@After` annotation. Similarly, the class-level setup
    methods are annotated by `@BeforeClass` and `@AfterClass`, which means these setup
    methods are going to be executed only once—before any test method of this class
    is executed (`@BeforeClass`) and after the last test method of this class has
    been executed (`@AfterClass`). Here is a quick demo of this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，您在其前面添加了一个`@Before`注释，这表示这个方法必须在每个测试方法之前运行。相应的清理方法由`@After`注释标识。类级别的设置方法由`@BeforeClass`和`@AfterClass`注释标识，这意味着这些设置方法只会在测试类的任何测试方法执行之前执行一次（`@BeforeClass`），并在测试类的最后一个测试方法执行之后执行一次（`@AfterClass`）。这是一个快速演示：
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If you run the tests now, you''ll get the following result:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行测试，你会得到以下结果：
- en: '![](img/5c124906-d843-4d1d-8a75-ba87f6e17401.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c124906-d843-4d1d-8a75-ba87f6e17401.png)'
- en: Such methods that *fix* the test context are called **fixtures**. Note that
    they have to be public, and the class-level setup/cleanup fixtures have to be
    static. The upcoming JUnit version 5 plans to lift these constraints, though.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这种修复测试上下文的方法称为**fixtures**。请注意，它们必须是公共的，类级别的设置/清理fixtures必须是静态的。然而，即将推出的JUnit版本5计划取消这些限制。
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A typical example of such a usage would be creating necessary tables before
    the first test method is run and removing them after the last method of the test
    class is finished. The setup/cleanup methods can also be used to create/close
    a database connection unless your code does it in the try-with-resources construct
    (refer to [Chapter 11](d8d77bf4-a30b-4474-95ca-0a166aef48c0.xhtml), *Memory Management
    and Debugging*).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法的典型例子是在第一个测试方法运行之前创建必要的表，并在测试类的最后一个方法完成后删除它们。设置/清理方法也可以用于创建/关闭数据库连接，除非您的代码在try-with-resources结构中执行（参见[第11章](d8d77bf4-a30b-4474-95ca-0a166aef48c0.xhtml)，*内存管理和调试*）。
- en: 'Here is an example of the usage of fixtures (refer to [Chapter 6](4d5627d7-8aa3-4ad8-912f-7525f77143b9.xhtml),
    *Database Programming*, for more on *how to set up a database for running it,*
    section). Let''s assume we need to test the `DbRelatedMethods` class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是fixtures的一个使用示例（参见[第6章](4d5627d7-8aa3-4ad8-912f-7525f77143b9.xhtml)，*数据库编程*，了解更多关于*如何设置数据库运行*的内容）。假设我们需要测试`DbRelatedMethods`类：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We would like to make sure that the previous method, `updateAllTextRecordsTo()`,
    always updates all the records of the `text` table with the provided value. Our
    first test, `updateAllTextRecordsTo1()`, is to update one existing record:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望确保前一个方法`updateAllTextRecordsTo()`总是使用提供的值更新`text`表的所有记录。我们的第一个测试`updateAllTextRecordsTo1()`是更新一个现有记录：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This means that the table has to exist in the test database and should have
    one record in it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着表必须存在于测试数据库中，并且其中应该有一条记录。
- en: 'Our second test, `updateAllTextRecordsTo2()`, makes sure that two records are
    updated even if each record contains a different value:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个测试，`updateAllTextRecordsTo2()`，确保即使每条记录包含不同的值，也会更新两条记录：
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Both the preceding tests use the same table, that is, `text`. Therefore, there
    is no need to drop the table after each test. This is why we create and drop it
    at the class level:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个测试都使用了相同的表，即`text`。因此，在每次测试后无需删除表。这就是为什么我们在类级别创建和删除它的原因：
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This means that all we need to do is populate the table before each test and
    clean it up after each test is completed:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们只需要在每个测试之前填充表格，并在每个测试完成后清理它：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Also, since we can use the same object, `dbRelatedMethods`, for all the tests,
    let''s create it on the class level too (as the test class''s property), so it''s
    created only once:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们可以为所有测试使用相同的对象`dbRelatedMethods`，因此让我们也在类级别上创建它（作为测试类的属性），这样它只会被创建一次：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If we run all the tests of the `test` class now, the output will look like
    this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行`test`类的所有测试，输出将如下所示：
- en: '![](img/05dd11a5-0699-4dfe-98cd-0ed6cbeb4627.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05dd11a5-0699-4dfe-98cd-0ed6cbeb4627.png)'
- en: The printed messages allow you to trace the sequence of all the method calls
    and see that they are executed as expected.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的消息可以让您跟踪所有方法调用的顺序，并查看它们是否按预期执行。
- en: Integration testing
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: If you have read all the chapters and have looked at the code examples, you
    may have noticed that, by now, we have discussed and built all the components
    necessary for a typical distributed application. It is the time to put all the
    components together and see whether they cooperate as expected. This process is
    called **integration**.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经阅读了所有章节并查看了代码示例，您可能已经注意到，到目前为止，我们已经讨论并构建了典型分布式应用程序所需的所有组件。现在是将所有组件放在一起并查看它们是否按预期协作的时候了。这个过程被称为**集成**。
- en: While doing this, we will look closely at assessing whether the application
    behaves according to the requirements. In cases where functional requirements
    are presented in an executable form (using the Cucumber framework, for example),
    we can run them and check whether all the checks pass. Many software companies
    follow a Behavior-Driven Development process and perform testing very early, sometimes
    even before any substantial amount of code is written (such tests fail, of course,
    but succeed as soon as the expected functionality is implemented). As mentioned
    already, early testing can be very helpful for writing a focused, clear, and well-testable
    code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将仔细评估应用程序是否符合要求。在功能需求以可执行形式呈现的情况下（例如使用Cucumber框架），我们可以运行它们并检查是否所有检查都通过。许多软件公司遵循行为驱动开发流程，并在很早的时候进行测试，有时甚至在编写大量代码之前（当然，这样的测试会失败，但一旦实现了预期的功能就会成功）。正如前面提到的，早期测试对于编写专注、清晰和易于测试的代码非常有帮助。
- en: However, even without strict adherence to the *test-first* process, the integration
    phase naturally includes some kind of behavioral testing too. In this recipe,
    we will see several possible approaches and specific examples related to this.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使不严格遵循“先测试”流程，集成阶段自然也包括某种行为测试。在本章中，我们将看到几种可能的方法和与此相关的具体示例。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You might have noticed that, in the course of this book, we have built several
    classes that compose an application that analyzes and models traffic. For your
    convenience, we have included all of them in the `com.packt.cookbook.ch16_testing` 
    package.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在本书的过程中，我们构建了几个组成应用程序的类，用于分析和建模交通。为了方便起见，我们已经将它们全部包含在`com.packt.cookbook.ch16_testing`包中。
- en: 'From the earlier chapters, you''re already familiar with the five interfaces
    in the `api` folder—`Car`, `SpeedModel`, `TrafficUnit`, `Truck`, and `Vehicle`.
    Their implementations are encapsulated inside classes called **factories** in
    the folder with the same name: `FactorySpeedModel`, `FactoryTraffic`, and `FactoryVehicle`.
    These factories produce input for the functionality of the `AverageSpeed` class
    ([Chapter 7](cf1c5e81-eb66-4623-b141-a5fb7552ce49.xhtml), *Concurrent and Multithreaded
    Programming*) and the `TrafficDensity` class (based on [Chapter 5](eaa70333-8e9d-453d-a9b6-063152fcc1e1.xhtml),
    *Streams and Pipelines,* but created and discussed in this chapter)—the core classes
    of our demo application. They produce the values that motivated the development
    of this particular application in the first place.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的章节中，您已经熟悉了`api`文件夹中的五个接口——`Car`、`SpeedModel`、`TrafficUnit`、`Truck`和`Vehicle`。它们的实现被封装在同名文件夹中的类中：`FactorySpeedModel`、`FactoryTraffic`和`FactoryVehicle`。这些工厂为我们的演示应用程序的核心类`AverageSpeed`（[第7章](cf1c5e81-eb66-4623-b141-a5fb7552ce49.xhtml)，*并发和多线程编程*）和`TrafficDensity`（基于[第5章](eaa70333-8e9d-453d-a9b6-063152fcc1e1.xhtml)，*流和管道*，但在本章中创建和讨论）提供输入。它们产生了激发开发这个特定应用程序的值。
- en: The main functionality of the application is straightforward. For a given number
    of lanes and speed limit for each lane, `AverageSpeed` calculates (estimates)
    the actual speed of each lane (assuming all the drivers are behaving rationally,
    taking the lane according to their speed), while `TrafficDensity` calculates the number
    of vehicles in each lane after 10 seconds (assuming all the cars start at the
    same time after the traffic light). The calculations are done based on the data
    from the `numberOfTrafficUnits` vehicles collected at a certain location and time
    of the year. It does not mean that all the 1,000 vehicles were racing at the same
    time. These 1,000 measuring points have been collected over 50 years for approximately
    20 vehicles that drove at the specified intersection during the specified hour
    (which means one vehicle every three minutes, on average).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的主要功能很简单。对于每条车道的车道数和速度限制，`AverageSpeed`计算（估计）每条车道的实际速度（假设所有驾驶员都是理性的，根据他们的速度选择车道），而`TrafficDensity`计算了10秒后每条车道上的车辆数（假设所有车辆在交通灯后同时开始）。这些计算是基于在特定位置和时间收集的`numberOfTrafficUnits`辆车的数据。这并不意味着所有的1,000辆车都在同一时间比赛。这1,000个测量点是在50年内收集的，用于在指定的交叉口在指定的小时内行驶的大约20辆车（平均每三分钟一辆车）。
- en: 'The overall infrastructure of the application is supported by the classes in
    the `process` folder: `Dispatcher`, `Processor`, and `Subscription`. We discussed
    their functionality and demonstrated them in [Chapter 7](cf1c5e81-eb66-4623-b141-a5fb7552ce49.xhtml),
    *Concurrent and Multithreaded Programming*. These classes allow distributing the
    processing.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的整体基础设施由`process`文件夹中的类支持：`Dispatcher`、`Processor`和`Subscription`。我们讨论了它们的功能，并在[第7章](cf1c5e81-eb66-4623-b141-a5fb7552ce49.xhtml)，*并发和多线程编程*中进行了演示。这些类允许分发处理。
- en: The `Dispatcher` class sends a request for processing to the population of `Processors`
    in a pool, using the `Subscription` class. Each `Processor` class performs the
    task according to the request (using the `AverageSpeed` and `TraffciDensity` classes)
    and stores the results in the database (using the `DbUtil` class in the `utils`
    folder, based on the functionality discussed in [Chapter 6](4d5627d7-8aa3-4ad8-912f-7525f77143b9.xhtml),
    *Database Programming*).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispatcher`类向池中的`Processors`群发请求进行处理，使用`Subscription`类。每个`Processor`类根据请求执行任务（使用`AverageSpeed`和`TrafficDensity`类），并将结果存储在数据库中（使用`utils`文件夹中的`DbUtil`类，基于[第6章](4d5627d7-8aa3-4ad8-912f-7525f77143b9.xhtml)中讨论的功能，*数据库编程*）。'
- en: We have tested most of these classes as units. Now we are going to integrate
    them and test the application as a whole for correct behavior.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将大多数这些类作为单元进行了测试。现在我们将对它们进行集成，并测试整个应用程序的正确行为。
- en: The requirements were made up just for demonstrative purposes. The goal of the
    demonstration was to show something well motivated (resembling real data) and
    at the same time simple enough to understand without special knowledge of traffic
    analysis and modeling.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求仅用于演示目的。演示的目标是展示一些有动机的东西（类似真实数据），同时又足够简单，不需要特殊的交通分析和建模知识即可理解。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: There are several levels of integration. We need to integrate the classes and
    subsystems of the application and also integrate our application with the external
    system (the source of the traffic data developed and maintained by a third party).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 集成有几个级别。我们需要集成应用程序的类和子系统，还需要将我们的应用程序与外部系统集成（由第三方开发和维护的交通数据源）。
- en: 'Here is an example of class-level integration using the `demo1_class_level_integration()`
    method in the `Chapter14Testing` class:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`Chapter14Testing`类中的`demo1_class_level_integration()`方法进行类级别集成的示例：
- en: '[PRE62]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this example, we integrated each of the two main classes, namely `AverageSpeed`
    and `TrafficDensity`, with factories and implementations of their interfaces.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们集成了两个主要类，即`AverageSpeed`和`TrafficDensity`，并使用它们的接口的工厂和实现。
- en: 'The results are as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/30015170-2ee5-4be1-8ace-87c4e98f8982.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30015170-2ee5-4be1-8ace-87c4e98f8982.png)'
- en: Note that the results are slightly different from one run to another. This is
    because the data produced by `FactoryTraffic` varies from one request to another.
    But, at this stage, we just have to make sure that everything works together and
    produces some more or less accurate-looking results. We have tested the code by
    units and have a level of confidence that each unit is doing what it is supposed
    to do. We will get back to the results' validation during the actual integration
    *testing* process, not during integration.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，结果在每次运行时略有不同。这是因为`FactoryTraffic`生成的数据在每个请求之间都有所不同。但是，在这个阶段，我们只需要确保一切协同工作，并产生一些看起来更或多或少准确的结果。我们已经通过单元测试了代码，并且对每个单元是否按预期工作有一定的信心。在实际集成*测试*过程中，而不是在集成过程中，我们将回到结果的验证。
- en: 'After finishing the integration at the class level, see how the subsystems
    work together using the `demo1_subsystem_level_integration()` method in the `Chapter14Testing`
    class:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在类级别完成集成后，使用`Chapter14Testing`类中的`demo1_subsystem_level_integration()`方法查看子系统如何一起工作：
- en: '[PRE63]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In this code, we used `DBUtil` to create the necessary table that holds the
    input data and the results produced and recorded by `Processor`. The `Dispatcher`
    class sends a request and inputs data to the objects of the `Processor` class,
    as shown here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用`DBUtil`创建了一个必要的表，用于保存`Processor`生成和记录的输入数据和结果。`Dispatcher`类向`Processor`类的对象发送请求和输入数据，如下所示：
- en: '[PRE64]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `Subscription` class is used to send/get the message (refer to [Chapter
    7](cf1c5e81-eb66-4623-b141-a5fb7552ce49.xhtml), *Concurrent and Multithreaded
    Programming*, for a description of this functionality):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscription`类用于发送/接收消息（参考[第7章](cf1c5e81-eb66-4623-b141-a5fb7552ce49.xhtml)，*并发和多线程编程*，了解此功能的描述）：'
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The processors are doing their job; we just need to wait for a few seconds
    (you might adjust this time if the computer you are using requires more time to
    finish the job) before we get the results. We use `DBUtil` for reading the results
    from the database:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器正在执行它们的工作；我们只需要等待几秒钟（如果您使用的计算机需要更多时间来完成工作，可以调整此时间）然后我们就可以得到结果。我们使用`DBUtil`从数据库中读取结果：
- en: '![](img/e2e9ca71-45f0-42b1-955e-071d82ab264d.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2e9ca71-45f0-42b1-955e-071d82ab264d.png)'
- en: The names of the `Process` enum class point to the corresponding records in
    the `result` table in the database. Again, at this stage, we are primarily looking
    for getting any results at all, not at how correct the values are.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`Process`枚举类的名称指向数据库中`result`表中的相应记录。同样，在这个阶段，我们主要是希望得到任何结果，而不是关注值的正确性。'
- en: 'After the successful integration between the subsystems of our application
    based on the generated data from `FactoryTraffic`, we can try to connect to the
    external system that provides real traffic data. Inside `FactoryTraffic`, we would
    now switch from generating `TrafficUnit` objects to getting data from a real system:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于`FactoryTraffic`生成的数据的应用程序子系统之间成功集成后，我们可以尝试连接提供真实交通数据的外部系统。在`FactoryTraffic`中，我们现在将从生成`TrafficUnit`对象切换到从真实系统获取数据：
- en: '[PRE66]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The switch can be implemented as a `Boolean` property in the class (as seen
    in the preceding code) or the project configuration property. We leave out the
    details of the connection to a particular source of real traffic data as this
    is not relevant to the purpose of this book.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 该开关可以作为类中的`Boolean`属性实现（如前面的代码所示），也可以作为项目配置属性。我们不会详细介绍连接到特定真实交通数据源的细节，因为这与本书的目的无关。
- en: The main focus at this stage has to be the performance and having a smooth data
    flow between the external source of real data and our application. After we have
    made sure that everything works and produces realistic results with satisfactory
    performance, we can turn to integration *testing* with the actual results' assertion.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，主要关注性能，并在外部真实数据源和我们的应用程序之间实现平稳的数据流。在确保一切正常并且具有令人满意的性能的情况下，我们可以转向集成*测试*，并断言实际结果。
- en: How it works...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For testing, we need to set the expected values, which we can compare with the
    actual values produced by the application that processes real data. But real data
    changes slightly from run to run, and an attempt to predict the resultant values
    either makes the test fragile or forces the introduction of a huge margin of error,
    which may effectively defeat the purpose of testing.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试，我们需要设置预期值，然后与处理真实数据的应用程序产生的实际值进行比较。但是真实数据在每次运行时都会略有变化，试图预测结果值要么使测试变得脆弱，要么迫使引入巨大的误差范围，这可能会有效地破坏测试的目的。
- en: We cannot even mock the generated data (as we did in the case of unit testing)
    because we are at the integration stage and have to use the real data.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至不能模拟生成的数据（就像我们在单元测试中所做的那样），因为我们处于集成阶段，必须使用真实数据。
- en: One possible solution would be to store the incoming real data and the result
    our application produced in the database. Then, a domain specialist can walk through
    each record and assert whether the results are as expected.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个可能的解决方案是将传入的真实数据和我们应用程序生成的结果存储在数据库中。然后，领域专家可以浏览每条记录，并断言结果是否符合预期。
- en: 'To accomplish this, we introduced a `boolean` switch in the `TrafficDensity` class,
    so it records the input along with each unit of the calculations:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们在`TrafficDensity`类中引入了一个`boolean`开关，这样它就记录了每个计算单元的输入：
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We also introduced a static property to keep the same database connection across
    all the class instances. Otherwise, the connection pool should be very big because,
    as you may recall from [Chapter 7](cf1c5e81-eb66-4623-b141-a5fb7552ce49.xhtml), *Concurrent
    and Multithreaded Programming*, the number of workers that execute the task in
    parallel grows as the amount of work to do increases.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还引入了一个静态属性，以保持所有类实例之间相同的数据库连接。否则，连接池应该很大，因为正如你可能从[第7章](cf1c5e81-eb66-4623-b141-a5fb7552ce49.xhtml)中所记得的那样，*并发和多线程编程*，执行任务的工作人员数量随着要执行的工作量的增加而增加。
- en: 'If you look at `DbUtils`, you will see a new method that creates the `data` table
    designed to hold `TrafficUnits` coming from `FactoryTraffic` and the `data_common` table
    that keeps the main parameters used for data requests and calculations: requested
    numbers of traffic units, the date and geolocation of the traffic data, the time
    in seconds (the point when the speed is calculated), and the speed limit for each
    lane (its size defines how many lanes we plan to use while modeling the traffic).
    Here is the code that we configure to do the recording:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看`DbUtils`，你会看到一个创建`data`表的新方法，该表设计用于保存来自`FactoryTraffic`的`TrafficUnits`，以及保存用于数据请求和计算的主要参数的`data_common`表：请求的交通单位数量，交通数据的日期和地理位置，以秒为单位的时间（速度计算的时间点），以及每条车道的速度限制（其大小定义了我们在建模交通时计划使用多少条车道）。这是我们配置来进行记录的代码：
- en: '[PRE68]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: After the recording is completed, we can turn the data over to a domain specialist
    who can assert the correctness of the application behavior.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 记录完成后，我们可以将数据交给领域专家，他可以断言应用程序行为的正确性。
- en: 'The verified data can now be used for integration testing. We can add another
    switch to `FactoryTrafficUnit` and force it to read the recorded data instead
    of the unpredictable real data:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 验证的数据现在可以用于集成测试。我们可以在`FactoryTrafficUnit`中添加另一个开关，并强制它读取记录的数据，而不是不可预测的真实数据：
- en: '[PRE69]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As you may have noticed, we have also added the `isEnoughData()` method which
    checks whether there is enough recorded data:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，我们还添加了`isEnoughData()`方法，用于检查是否有足够的记录数据：
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This will help avoid the unnecessary frustration of debugging the test problem,
    especially in the case of testing a more complex system.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有助于避免在测试更复杂的系统时不必要的调试问题所带来的挫败感。
- en: 'Now we control not only the input values but also the expected results that
    we can use to assert the application behavior. Both are now included in the `TrafficUnit`
    object. To be able to do this, we took advantage of the new Java interface feature
    discussed in [Chapter 2](db468cc9-60fa-4966-890a-872bef36ff01.xhtml), *Fast Track
    to OOP - Classes and Interfaces*, which is the interface default method:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不仅控制输入值，还可以控制预期结果，这些结果可以用来断言应用程序的行为。这两者现在都包含在`TrafficUnit`对象中。为了能够做到这一点，我们利用了[第2章](db468cc9-60fa-4966-890a-872bef36ff01.xhtml)中讨论的新的Java接口特性，即接口默认方法：
- en: '[PRE71]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'So, we can attach the result to the input data. See the following method:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将结果附加到输入数据。请参阅以下方法：
- en: '[PRE72]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can attach the result to the `DbUtil` class and the `TrafficUnitImpl` class inside `DbUtil`
    too:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将结果附加到`DbUtil`类和`TrafficUnitImpl`类中的`DbUtil`中：
- en: '[PRE73]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: And we can attach it inside the `DbUtil` class too.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将其附加到`DbUtil`类中。
- en: 'The preceding changes allow us to write an integration test. First, we will
    test the speed model using the recorded data:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的更改使我们能够编写集成测试。首先，我们将使用记录的数据测试速度模型：
- en: '[PRE74]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: A similar test can be written for testing the speed calculation of the `AverageSpeed`
    class with real data.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用类似的方法来测试`AverageSpeed`类的速度计算。
- en: 'Then, we can write an integration test for the class level:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为类级别编写一个集成测试。
- en: '[PRE75]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Similar code can be written for the class-level testing of the `TrafficDensity` class
    too:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的代码也可以用于对TrafficDensity类进行类级别的测试：
- en: '[PRE76]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, we can write the integration test for the subsystem level as well:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们也可以为子系统级别编写集成测试：
- en: '[PRE77]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: All of the preceding tests are run successfully now and may be used for application
    regression testing any time later.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的测试现在都成功运行，并且随时可以用于应用程序的回归测试。
- en: An automated integration test between our application and the source of the
    real traffic data can be created only if the latter has a test mode from where
    the same flow of data can be sent our way so we can use it in the same manner
    we use recorded data (which is essentially the same thing).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当后者具有测试模式时，我们才能创建应用程序与真实交通数据源之间的自动集成测试，从而可以以与使用记录数据相同的方式发送相同的数据流。
- en: One parting thought—all of this integration testing is possible when the amount
    of processing data is statistically significant. This is because we do not have
    full control over the number of workers and how the JVM decides to split the load.
    It is quite possible that, on a particular occasion, the code demonstrated in
    this chapter would not work. In such a case, try to increase the number of requested
    traffic units. This will ensure more space for the load-distributing logic.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些集成测试都是可能的，当处理数据的数量在统计上是显著的时候。这是因为我们无法完全控制工作人员的数量以及JVM如何决定分配负载。很可能，在特定情况下，本章中演示的代码可能无法正常工作。在这种情况下，尝试增加请求的流量单位数量。这将确保更多的空间用于负载分配逻辑。
