- en: '*Chapter 6*: Generics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：泛型'
- en: In the previous chapter, we learned about OOP in C#. In this chapter, we will
    explore the concept of generics. Generics allow us to create classes, structures,
    interfaces, methods, and delegates in such a manner that they will work in a type-safe
    environment with different data types. Generics were added as a part of the C#
    2.0 release. It promotes code reusability and extensibility and is one of the
    most powerful features of C#.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了C#中的面向对象编程。在本章中，我们将探讨泛型的概念。泛型允许我们以一种类型安全的环境中使用不同的数据类型创建类、结构、接口、方法和委托。泛型是作为C#
    2.0版本的一部分添加的。它促进了代码的可重用性和可扩展性，是C#最强大的特性之一。
- en: 'We will learn about the following concepts in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下概念：
- en: Generic classes and generic inheritance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类和泛型继承
- en: Generic interfaces and variant generic interfaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型接口和变体泛型接口
- en: Generic structures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型结构
- en: Generic methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型方法
- en: Type constraints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型约束
- en: By the end of this chapter, you will have gained the skills necessary to write
    generic types, methods, and variant generic interfaces and to use type constraints.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将具备编写泛型类型、方法和变体泛型接口以及使用类型约束所需的技能。
- en: Understanding generics
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解泛型
- en: Simply put, generics are types parametrized with other types. As we mentioned
    before, we can create a class, structure, interface, method, or delegate that
    accepts one or more data types they use as parameters. These parameters are known
    as **type parameters** and act as *placeholders* for the actual data types that
    are passed during compile time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，泛型是用其他类型参数化的类型。正如我们之前提到的，我们可以创建一个类、结构、接口、方法或委托，它们接受一个或多个数据类型作为参数。这些参数被称为**类型参数**，充当编译时传递的实际数据类型的*占位符*。
- en: For example, we can create a class that models a list, which is a variable-length
    sequence of elements of the same type. Instead of having a different class that
    works with integers, doubles, strings, or any other user-defined types we might
    need, we can create a generic class that has a type parameter specifying the actual
    type of its elements. We will then specify the actual type at compile time when
    we instantiate the class.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个模拟列表的类，它是相同类型元素的可变长度序列。我们可以创建一个泛型类，它具有指定其元素实际类型的类型参数。然后，当我们实例化类时，我们将在编译时指定实际类型。
- en: 'Advantages of using generics include the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型的优点包括以下内容：
- en: '**Generics provide reusability**: We can create a single version of the code
    and reuse it for different data types.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**泛型提供了可重用性**：我们可以创建代码的单个版本，并将其用于不同的数据类型。'
- en: '**Generics promote type safety**: While using generics, we do not need to perform
    explicit typecasting. The typecasting is taken care of by the compiler.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**泛型提倡类型安全**：在使用泛型时，我们不需要执行显式类型转换。类型转换由编译器处理。'
- en: '`object` type to a reference type is time-consuming. Therefore, by avoiding
    these operations, they help to improve the execution time.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`object`类型转换为引用类型是耗时的。因此，通过避免这些操作，它们有助于提高执行时间。
- en: Generic types and methods can be constrained so that only the types that meet
    requirements can be used as type parameters. Information about the actual types
    is used to instantiate a generic type that can be obtained at runtime using reflection.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型和方法可以受限，以便只有满足要求的类型可以用作类型参数。关于实际类型的信息用于实例化可以在运行时使用反射获得的泛型类型。
- en: The most common use of generics is to create collection or wrapper classes.
    Collections will be the subject of the next chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型最常见的用途是创建集合或包装类。集合将是下一章的主题。
- en: Generic types
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型
- en: Both reference types and value types can be generic. We have already seen examples
    of generic types earlier in this book, such as `Nullable<T>` and `List<T>`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型和值类型都可以是泛型的。我们已经在本书的早期看到了泛型类型的例子，比如`Nullable<T>`和`List<T>`。
- en: In this section, we will learn how to create generic classes, structures, and
    interfaces.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何创建泛型类、结构和接口。
- en: Generic classes
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类
- en: 'The creation of generic classes is no different than non-generic classes. The
    only thing that differs is a list of type parameters and their use in the class
    as a placeholder for actual types. Let''s look at an example of a generic class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建泛型类与创建非泛型类没有区别。唯一不同的是类型参数列表及其在类中作为实际类型的占位符的使用。让我们看一个泛型类的例子：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we have defined a generic class, `GenericDemo`, that is accepting one
    type parameter, `T`. We have defined a property called `Value` of the `T` type
    and initialized it inside the class constructor. The constructor is accepting
    an argument of the `T` type. The overridden method, `ToString()`, will return
    a string containing the type and value of the property.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个泛型类`GenericDemo`，它接受一个类型参数`T`。我们定义了一个名为`Value`的`T`类型属性，并在类构造函数中对其进行了初始化。构造函数接受`T`类型的参数。重写的方法`ToString()`将返回一个包含属性类型和值的字符串。
- en: 'To instantiate objects of this generic class, we will proceed as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化这个泛型类的对象，我们将按以下步骤进行：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, we are specifying the data type for the type parameter while
    creating the object of the generic class, `GenericDemo<T>`. Both `obj1` and `obj2`
    are instances of the same generic type, but their type parameter differs: one
    is `int` and the other is `string`. Therefore, they are not type-compatible with
    each other. This means if we try to assign one object to another, it will result
    in a compile-time error.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在创建泛型类`GenericDemo<T>`的对象时为类型参数指定了数据类型。`obj1`和`obj2`都是相同泛型类型的实例，但它们的类型参数不同：一个是`int`，另一个是`string`。因此，它们彼此不兼容。这意味着如果我们尝试将一个对象分配给另一个对象，将导致编译时错误。
- en: 'We can get information about the type of these objects and their generic type
    parameters using reflection (which we will look at in [*Chapter 11*](B12346_11_Final_SK_ePub.xhtml#_idTextAnchor200),
    *Reflection and Dynamic Programming*), as shown in the following sample:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用反射来获取关于这些对象类型和它们的通用类型参数的信息（我们将在第11章“反射和动态编程”中进行讨论），如下面的示例所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Upon execution, we will see the output shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们将看到以下输出：
- en: '![Figure 6.1 – Screenshot of the console showing the reflected content of a
    type'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 - 显示类型反射内容的控制台截图'
- en: '](img/Figure_6.1_B12346.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.1_B12346.jpg)'
- en: Figure 6.1 – Screenshot of the console showing the reflected content of a type
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 - 显示类型反射内容的控制台截图
- en: 'We can declare more than one type parameter for a generic type. In this case,
    we need to specify all of the type parameters as a comma-separated value inside
    the angle brackets. The following shows an example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为泛型类型声明多个类型参数。在这种情况下，我们需要将所有类型参数指定为角括号内的逗号分隔值。以下是一个示例：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `Pair<T, U>` is a class that requires two type parameters. We are instantiating
    objects `p1`, `p2`, and `p3` using different combinations of types.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Pair<T, U>`是一个需要两个类型参数的类。我们使用不同类型的组合来实例化对象`p1`、`p2`和`p3`。
- en: This class is actually very similar to the .NET class `KeyValueType<TKey`, `TValue>`,
    from the `System.Collections.Generic` namespace. In fact, there are many generic
    classes that the framework is providing. You should use existing types when available,
    rather than defining your own.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实际上与.NET类`KeyValueType<TKey`,`TValue>`非常相似，它来自`System.Collections.Generic`命名空间。实际上，框架提供了许多泛型类。您应该在可能的情况下使用现有类型，而不是定义自己的类型。
- en: Inheritance with generic classes
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类的继承
- en: A generic class can behave either as a *base class* or a *derived class*. When
    deriving from a generic class, the child class must specify the type parameters
    that are required by the base class. These type parameters can be actual types
    or type parameters from the derived class, which is also a generic class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类可以作为*基类*或*派生类*。当从泛型类派生时，子类必须指定基类所需的类型参数。这些类型参数可以是实际类型，也可以是派生类的类型参数，即泛型类。
- en: 'Let''s understand how the inheritance of generic classes works with the example
    shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这里展示的示例来理解泛型类的继承是如何工作的：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have defined a generic abstract class, `Shape`, that contains a single and
    abstract property called `Area` that represents the area of a shape. The type
    of this property is also `T`. Consider the class definition here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个泛型抽象类`Shape`，其中包含一个表示形状面积的单个抽象属性`Area`。该属性的类型也是`T`。考虑这里的类定义：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we have defined a class called `Square`, which is inheriting from the
    generic abstract class `Shape`. We are using the `int` type for the type parameter.
    We have defined a property called `Length` for the `Square` class and initialized
    it in the constructor. We are overriding the `Area` property to calculate the
    area of the square. Now, consider another class definition shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`Square`的类，它继承自泛型抽象类`Shape`。我们使用`int`类型作为类型参数。我们为`Square`类定义了一个名为`Length`的属性，并在构造函数中对其进行了初始化。我们重写了`Area`属性以计算正方形的面积。现在，考虑下面的另一个类定义：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Circle` class is also inheriting from the generic abstract class `Shape<T>`.
    The type parameter for the parent class `Shape` is now specified as `double`.
    The `Radius` property is defined to store the radius of the circle. We are again
    overriding the `Area` property to calculate the area of a circle. We can use these
    derived classes as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle`类也继承自泛型抽象类`Shape<T>`。父类`Shape`的类型参数现在指定为`double`。定义了`Radius`属性来存储圆的半径。我们再次重写了`Area`属性以计算圆的面积。我们可以如下使用这些派生类：'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are creating instances of `Square` and `Circle` and printing to the console
    the area of each shape. Upon execution, we will see the output shown here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`Square`和`Circle`的实例，并将每个形状的面积打印到控制台上。执行后，我们将看到以下输出：
- en: '![Figure 6.2 – The areas of the square and circle displayed to the console'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 - 正方形和圆的面积显示在控制台上'
- en: '](img/Figure_6.2_B12346.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.2_B12346.jpg)'
- en: Figure 6.2 – The areas of the square and circle displayed to the console
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 - 正方形和圆的面积显示在控制台上
- en: It is important to note that although both `Square` and `Circle` derive from
    `Shape<T>`, these types cannot be treated polymorphically. One is `Shape<int>`
    and the other `Shape<double>`. Therefore, instances of `Square` and `Circle` cannot
    be put in a homogeneous container. The only possible solution is to use the `object`
    type to hold references to such instances and then perform type casts.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，尽管`Square`和`Circle`都是从`Shape<T>`派生出来的，但这些类型不能被多态地对待。一个是`Shape<int>`，另一个是`Shape<double>`。因此，`Square`和`Circle`的实例不能放在同质容器中。唯一可能的解决方案是使用`object`类型来保存对这些实例的引用，然后执行类型转换。
- en: In this example, `Shape<T>` is a generic type. `Shape<int>` is a type that is
    constructed from `Shape<T>` by replacing the type parameter `T` with `int`. Such
    a type is called a **constructed type**. This is also a *closed constructed type*
    because all of the type parameters have been substituted. Non-generic types are
    all *closed types*. Generic types are *open types*. Constructed generic types
    can be open or closed. An open constructed type is one that has a type parameter
    that has not been substituted. A closed constructed type is any type that is not
    open.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Shape<T>`是一个泛型类型。`Shape<int>`是从`Shape<T>`构造出来的类型，通过用`int`替换类型参数`T`。这样的类型被称为**构造类型**。这也是一个*封闭构造类型*，因为所有类型参数都已被替换。非泛型类型都是*封闭类型*。泛型类型是*开放类型*。构造泛型类型可以是开放的或封闭的。开放构造类型是具有未被替换的类型参数的类型。封闭构造类型是任何不是开放的类型。
- en: 'Another important thing to remember when creating generic types is that some
    operators, such as arithmetic operators, cannot be used with objects of type parameters.
    Let''s look at the following code to exemplify this case:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建通用类型时另一个重要的事情是，一些运算符，比如算术运算符，不能与类型参数的对象一起使用。让我们看下面的代码来举例说明这种情况：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Square` type is now a generic type. The type parameter `T` is used for
    the type parameter of the base class as well as the `Length` property. However,
    when computing the area, the use of the `*` operator generates a compiler error.
    That is because the compiler does not know what concrete types will be used for
    `T` and whether they have the `*` operator overloaded. To make sure that, under
    no circumstances, invalid instantiation may occur, the compiler generates an error.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Square`类型现在是一个通用类型。类型参数`T`用于基类的类型参数以及`Length`属性。然而，在计算面积时，使用`*`运算符会产生编译错误。这是因为编译器不知道`T`将使用什么具体类型，以及它们是否已重载`*`运算符。为了确保在任何情况下都不会发生无效实例化，编译器会生成错误。'
- en: It is possible to ensure that only types matching some pre-defined constraints
    are used at compile time to instantiate generic types or call generic methods.
    These are called *type constraints* and will be discussed later in this chapter
    in the *Type parameter constraints* section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以确保只有符合预定义约束的类型在编译时用于实例化通用类型或调用通用方法。这些被称为*类型约束*，将在本章的*类型参数约束*部分中讨论。
- en: Now that we've seen how to create and use generic classes, let's see how to
    do the same with generic interfaces.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何创建和使用通用类，让我们看看如何使用通用接口。
- en: Generic interfaces
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用接口
- en: 'In the previous examples, the generic class `Shape<T>` does not contain anything
    other than an abstract property. This is not a good candidate for a class and
    it should rather be an interface. Generic interfaces differ from non-generic interfaces
    in the same way as generic classes differ from non-generic classes. The following
    is an example of a generic interface:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，通用类`Shape<T>`除了一个抽象属性之外什么也没有。这不是一个好的类候选，它应该是一个接口。通用接口与非通用接口的区别与通用类与非通用类的区别相同。以下是一个通用接口的例子：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The type parameters are specified in the same manner as they are for classes
    or structures. This interface can be implemented as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数的指定方式与类或结构相同。这个接口可以这样实现：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The implementation of the `Square` and `Circle` classes is only slightly different
    from the one seen in the previous section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Square`和`Circle`类的实现与前一节中所见的略有不同。'
- en: Concrete classes, such as `Square` and `Circle` here, can implement closed constructed
    interfaces, such as `IShape<int>` or `IShape<double>`. Generic classes can also
    implement a generic or closed constructed interface if the class parameter list
    supplies all of the type parameters required by the interface. On the other hand,
    generic interfaces can inherit from non-generic interfaces; however, the generic
    class must be contravariant.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 具体类，比如这里的`Square`和`Circle`，可以实现封闭构造的接口，比如`IShape<int>`或`IShape<double>`。如果类参数列表提供了接口所需的所有类型参数，通用类也可以实现通用或封闭构造的接口。另一方面，通用接口可以继承非通用接口；然而，通用类必须是逆变的。
- en: The variance of generic interfaces will be discussed in the next section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通用接口的变异将在下一节中讨论。
- en: Variant generic interfaces
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变异通用接口
- en: 'It is possible to declare type parameters in generic interfaces as *covariant*
    or *contravariant*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将通用接口中的类型参数声明为*协变*或*逆变*：
- en: A *covariant* type parameter is declared with the `out` keyword and allows an
    interface method to have a return type that is more derived than the specified
    type parameter.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*协变*类型参数用`out`关键字声明，允许接口方法具有比指定类型参数更多派生的返回类型。'
- en: A *contravariant* type parameter is declared with the `in` keyword and allows
    an interface method to have a parameter that is less derived than the specified
    type parameter.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逆变*类型参数用`in`关键字声明，允许接口方法具有比指定类型参数更少派生的参数。'
- en: A generic interface that has covariant or contravariant type parameters is called
    a **variant generic interface**. Variance is only supported with reference types.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 具有协变或逆变类型参数的通用接口称为**变异通用接口**。变异只支持引用类型。
- en: 'To understand how covariance works, let''s look at the `System.IEnumerable<T>`
    generic interface. This is a variant interface because its type parameter is declared
    covariant. The interface is defined as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解协变是如何工作的，让我们看看`System.IEnumerable<T>`通用接口。这是一个变异接口，因为它的类型参数声明为协变。接口定义如下：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A class that implements `IEnumerable<T>` (and other interfaces) is `List<T>`.
    Because `T` is covariant, we can write the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`IEnumerable<T>`（和其他接口）的类是`List<T>`。因为`T`是协变的，我们可以编写以下代码：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, `names` is an `IEnumerable<string>` and `objects` is an `IEnumerable<object>`.
    The former does not derive from the latter, but `string` is derived from `object`,
    and because `T` is covariant, we can assign `names` to `objects`. However, this
    is only possible while using variant interfaces.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`names`是`IEnumerable<string>`，`objects`是`IEnumerable<object>`。前者不派生自后者，但`string`派生自`object`，并且因为`T`是协变的，我们可以将`names`赋值给`objects`。然而，这只有在使用变异接口时才可能。
- en: 'Classes that implement variant interfaces are not variant themselves but invariant.
    That means the following example, where we substitute `List<T>` for `IEnumerable<T>`,
    will produce a compiler error because `List<string>` cannot be assigned to `List<object>`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实现变异接口的类本身不是变异的，而是不变的。这意味着下面的例子，我们用`List<T>`替换`IEnumerable<T>`，将产生编译错误，因为`List<string>`不能赋值给`List<object>`：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As mentioned earlier, variance is not supported for value types. `IEnumerable<int>`
    cannot be assigned to `IEnumerable<object>`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，值类型不支持变异。`IEnumerable<int>`不能赋值给`IEnumerable<object>`：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In summary, a covariant type parameter in an interface must:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，接口中的协变类型参数必须：
- en: Be prefixed with the `out` keyword
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须以`out`关键字为前缀
- en: Be only used as the return type for methods and not as a type for method parameters
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能用作方法的返回类型，而不能用作方法参数的类型
- en: Not be used as a generic constraint for interface methods
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能用作接口方法的泛型约束
- en: 'Contravariance is the other form of variance that deals with arguments passed
    to interface methods. To understand how it works, let''s consider a situation
    where we want to compare the size of various shapes, defined as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 逆变是处理传递给接口方法的参数的另一种变体形式。为了理解它是如何工作的，让我们考虑一个情况，我们想要比较各种形状的大小，定义如下：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These are only slightly different from the types used previously because `IShape`
    is no longer generic to keep the example simple. What we want here is to be able
    to compare shapes. For this purpose, a series of classes are provided as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与之前使用的类型略有不同，因为`IShape`不再是泛型，以保持示例简单。我们想要的是能够比较形状。为此，提供了一系列类，如下所示：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, `ShapeComparer` compares `IShape` objects by their area, `SquareComparer`
    compares squares by their length, and `CircleComparer` compares circles by their
    radius. All of these classes implement the `IComparer<T>` interface from the `System.Collections.Generic`
    namespace. This interface is defined as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ShapeComparer`通过它们的面积比较`IShape`对象，`SquareComparer`通过它们的长度比较正方形，`CircleComparer`通过它们的半径比较圆。所有这些类都实现了`System.Collections.Generic`命名空间中的`IComparer<T>`接口。该接口定义如下：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This interface has a single method called `Compare()`, which takes two objects
    of the `T` type and returns one of the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口有一个名为`Compare()`的方法，它接受两个`T`类型的对象并返回以下之一：
- en: A negative number if the first is smaller than the second
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个小于第二个，则为负数
- en: 0, if they are equal
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们相等，则为0
- en: A positive number if the first is greater than the second
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个大于第二个，则为正数
- en: However, the key to its definition is the `in` keyword with the type parameter
    that makes it contravariant. Because of this, it is possible to pass `IShape`
    references where `Square` or `Circle` are expected. That means we can safely pass
    `IComparer<IShape>` where `IComparer<Square>` is required. Let's see a concrete
    example of that.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其定义的关键是使用类型参数的`in`关键字，使其逆变。因此，可以在期望`Square`或`Circle`的地方传递`IShape`引用。这意味着我们可以安全地传递`IComparer<IShape>`到需要`IComparer<Square>`的地方。让我们看一个具体的例子。
- en: 'The following class contains a single method that checks whether a `Square`
    object is bigger than another. The `IsBigger()` method also takes a reference
    to an object implementing `IComparer<Square>`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类包含一个检查`Square`对象是否比另一个大的方法。`IsBigger()`方法还接受一个实现`IComparer<Square>`的对象的引用：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We could call this method passing both `SquareComparer` or `ShapeComparer`,
    and the result would be the same:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用这个方法传递`SquareComparer`或`ShapeComparer`，结果将是相同的：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Had the `IComparer<T>` interface been invariant, passing `ShapeComparer` would
    result in a compiler error. A compiler error is also issued, with the implementation
    shown here, if we try to pass `CircleComparer` because `Circle` is not a lesser
    derived class than `Square`; it is actually a sibling in the inheritance hierarchy.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`IComparer<T>`接口是不变的，传递`ShapeComparer`将导致编译错误。如果我们尝试传递`CircleComparer`，也会发出编译错误，因为`Circle`不是`Square`的派生类，它实际上是继承层次结构中的同级。
- en: 'In summary, a contravariant type parameter in an interface:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，接口中的逆变类型参数：
- en: Must be prefixed with the `in` keyword
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须以`in`关键字为前缀
- en: Must be used only for method parameters and not as a return type
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能用于方法参数，而不能作为返回类型
- en: Can be used as a generic constraint for interface methods
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用作接口方法的泛型约束
- en: 'It is possible to define an interface that is both *covariant and contravariant*
    as shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义一个既是*协变又是逆变*的接口，如下所示：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `IMultiVariant<T, U>` interface shown in the preceding snippet is covariant
    with respect to `T` and contravariant with respect to `U`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中显示的`IMultiVariant<T, U>`接口对`T`是协变的，对`U`是逆变的。
- en: Generic structures
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型结构
- en: 'Similar to generic classes, we can also create generic structures. The syntax
    for a generic structure is the same as that of a generic class. The `Circle` and
    `Square` types used in the previous example are small and can be defined as structures
    instead of classes:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与泛型类类似，我们也可以创建泛型结构。泛型结构的语法与泛型类相同。在前面的示例中使用的`Circle`和`Square`类型很小，可以定义为结构而不是类：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All of the rules that apply to generic classes also apply to generic structures.
    Because value types do not support inheritance, structures cannot derive from
    other generic types but can implement any number of generic or non-generic interfaces.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有适用于泛型类的规则也适用于泛型结构。因为值类型不支持继承，结构不能从其他泛型类型派生，但可以实现任意数量的泛型或非泛型接口。
- en: Generic methods
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型方法
- en: C# allows us to create generic methods that accept one or more generic type
    parameters. We can create a generic method inside a generic class as well as a
    non-generic class. Both static and non-static methods can be generic. The rules
    for type inference are the same for all. The type parameters must be declared
    after the method name and just before the parameter list, within angle brackets,
    just like we did for types.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: C#允许我们创建接受一个或多个泛型类型参数的泛型方法。我们可以在泛型类内部创建泛型方法，也可以在非泛型类内部创建泛型方法。静态方法和非静态方法都可以是泛型的。类型推断的规则对所有类型都是相同的。类型参数必须在方法名之后、参数列表之前的尖括号内声明，就像我们对类型所做的那样。
- en: 'Let''s understand how to use generic methods with the help of the example shown
    here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来了解如何使用泛型方法：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The non-generic class `CompareObjects` contains a generic method, `Compare`,
    which is used to compare two objects. This method is accepting two parameters—`input1`
    and `input2`. We are using the `Equals()` method from the `System.Object` base
    class to compare the input parameters. The method will return a Boolean based
    on whether the inputs are equal or not. Consider the code shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 非泛型类`CompareObjects`包含一个泛型方法`Compare`，用于比较两个对象。该方法接受两个参数——`input1`和`input2`。我们使用`System.Object`基类的`Equals()`方法来比较输入参数。该方法将根据输入是否相等返回一个布尔值。考虑下面的代码：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We are creating an object of the `CompareObjects` class and invoking the `Compare()`
    method for various data types. In this example, the type argument is explicitly
    specified. However, the compiler is able to infer that from the arguments; therefore,
    it can be skipped, as shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建`CompareObjects`类的对象，并为各种数据类型调用`Compare()`方法。在这个例子中，类型参数是显式指定的。然而，编译器能够从参数中推断出来，因此可以省略，如下所示：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If a generic method has a type parameter that is the same as a type parameter
    of the class, structure, or interface where it is defined, the compiler issues
    a warning because the method type parameter hides the type parameter of the outer
    type, as shown in the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果泛型方法具有与定义它的类、结构或接口的类型参数相同的类型参数，编译器会发出警告，因为方法类型参数隐藏了外部类型的类型参数，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Generic methods, as well as generic types, support type parameter constraints
    to impose restrictions on types. This topic will be discussed in the next section
    of this chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型方法和泛型类型都支持类型参数约束来对类型施加限制。这个主题将在本章的下一节中讨论。
- en: Type parameter constraints
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型参数约束
- en: The type parameters in a generic type or method can be replaced by any valid
    type. However, there are scenarios when we want to restrict the types that can
    be used for a type parameter. Take, for instance, the generic `Shape<T>` class
    or the `IShape<T>` interface we saw earlier.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型或方法中的类型参数可以被任何有效类型替换。然而，在某些情况下，我们希望限制可以用作类型参数的类型。例如，我们之前看到的泛型`Shape<T>`类或`IShape<T>`接口。
- en: The type parameter `T` was used for the type of the `Area` property. We would
    expect that to be either an integral type or a floating-point type. But there
    is no restriction and someone could use `bool`, `string`, or any other type. Of
    course, depending on the way the type parameter is used, that could lead to various
    compiler errors. However, it is useful to be able to restrict the types used to
    instantiate generic types or call generic methods.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数`T`被用于`Area`属性的类型。我们期望它要么是整数类型，要么是浮点类型。但是没有限制，有人可以使用`bool`，`string`或任何其他类型。当然，根据类型参数的使用方式，这可能导致各种编译错误。然而，能够限制用于实例化泛型类型或调用泛型方法的类型是有用的。
- en: For this purpose, we can apply constraints to the type parameters. The constraints
    are used to inform the compiler about what kind of capabilities the type parameter
    must have. If we do not specify a constraint, then the type parameter can be replaced
    by any type. Applying a constraint will limit the types that can be used as a
    type parameter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以对类型参数应用约束。约束用于告诉编译器类型参数必须具有什么样的能力。如果我们不指定约束，那么类型参数可以被任何类型替换。应用约束将限制可以用作类型参数的类型。
- en: 'Constraints are specified using the keyword `where`. C# defines the following
    eight types of constraints on generics:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 约束使用关键字`where`来指定。C#定义了以下八种泛型约束类型：
- en: '![](img/Chapter_6Table_1_01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_6Table_1_01.jpg)'
- en: 'A constraint should be specified after the type parameters. We can use more
    than one constraint by separating them with a comma. There are some rules for
    using these constraints:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 约束应该在类型参数之后指定。我们可以通过逗号分隔它们来使用多个约束。对于使用这些约束有一些规则：
- en: The `struct` constraint implies `the new()` constraint and therefore all value
    types must have a public parameterless constructor. These two constraints, `struct`
    and `new()`, cannot be used together.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct`约束意味着`new()`约束，因此所有值类型必须有一个公共的无参数构造函数。这两个约束，`struct`和`new()`，不能一起使用。'
- en: The `unmanaged` constraint implies the `struct` constraint; therefore, these
    two cannot be used together. It also cannot be used with the `new()` constraint.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unmanaged`约束意味着`struct`约束；因此，这两个不能一起使用。它也不能与`new()`约束一起使用。'
- en: When using more than one constraint, the `new()` constraint must be mentioned
    last in the list of constraints.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用多个约束时，`new()`约束必须在约束列表中最后提及。
- en: The `notnull` constraint is available as of C# 8 and must be used in a nullable
    context, otherwise, the compiler generates a warning. When the constraint is violated,
    the compiler does not generate an error but a warning.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notnull`约束从C# 8开始可用，必须在可空上下文中使用，否则编译器会生成警告。当约束被违反时，编译器不会生成错误，而是生成警告。'
- en: As of C# 7.3, `System.Enum`, `System.Delegate`, and `System.MulticastDelegate`
    can be used as base class constraints.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从C# 7.3开始，`System.Enum`，`System.Delegate`和`System.MulticastDelegate`可以用作基类约束。
- en: 'Type parameters that do not have constraints are called *unbounded*. There
    are several rules for unbounded type parameters:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 没有约束的类型参数称为*无界*。无界类型参数有几条规则：
- en: You cannot use the`!=` and `==` operators with these types since it is not possible
    to know whether the concrete type overloads them.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能使用`!=`和`==`运算符来处理这些类型，因为不可能知道具体类型是否重载了它们。
- en: They can be compared to `null`. For value types, this comparison will always
    yield `false`.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以与`null`进行比较。对于值类型，这种比较总是返回`false`。
- en: They can be converted to and from `System.Object`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以转换为和从`System.Object`。
- en: They can be converted to and from any interface type.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以转换为任何接口类型。
- en: 'To understand how constraints work, let''s start with the following example
    of a generic structure:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解约束的工作原理，让我们从以下泛型结构的示例开始：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`Point<T>` is a structure that represents a point in the two-dimensional space.
    This class is generic because we might want to use integral values for the point
    coordinates or real values (floating-point values). However, we can instantiate
    the class using any types, such as `bool`, `string`, or `Circle`, as shown in
    the following example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point<T>`是表示二维空间中的点的结构。这个类是泛型的，因为我们可能希望使用整数值作为点坐标或实数值（浮点值）。但是，我们可以使用任何类型来实例化该类，例如`bool`，`string`或`Circle`，如下例所示：'
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To restrict the instantiation of `Point<T>` to numerical types (that is integral
    and floating-point types), we can write constraints for the type parameter `T`,
    as shown here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`Point<T>`的实例化限制为数字类型（即整数和浮点类型），我们可以为类型参数`T`编写约束，如下所示：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have used two types of constraints: the `struct` constraint and the interface
    constraint, and they are listed separated by a comma. Unfortunately, there is
    no constraint to define a type as numeric but these constraints are the best combination
    to represent one because all numerical types are value types and they all implement
    the five interfaces listed here. The `bool` type implements the first four but
    not `IFormattable`. Therefore, instantiating `Point<T>` with `bool` or `string`
    will now produce compiler errors.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两种类型的约束：`struct`约束和接口约束，并且它们用逗号分隔列出。不幸的是，没有约束可以将类型定义为数字，但这些约束是表示数字类型的最佳组合，因为所有数字类型都是值类型，并且它们都实现了这里列出的五个接口。`bool`类型实现了前四个，但没有实现`IFormattable`。因此，使用`bool`或`string`实例化`Point<T>`现在将产生编译错误。
- en: 'A type or method can have more than one type parameter and each of them can
    have their own constraints. We can see this in the following example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类型或方法可以有多个类型参数，每个类型参数都可以有自己的约束。我们可以在下面的示例中看到这一点：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `RestrictedDictionary<TKey, TValue>` class is a special dictionary that
    allows only enumeration types for the key type. For this, it uses the base class
    constraint with `System.Enum`. The type of the value must be a reference type
    with a public default constructor. For this, it uses the `class` and `new()` constraints.
    This class has a public generic method called `Make<T>()`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestrictedDictionary<TKey, TValue>`类是一个特殊的字典，它只允许枚举类型作为键类型。为此，它使用了基类约束`System.Enum`。值的类型必须是具有公共默认构造函数的引用类型。为此，它使用了`class`和`new()`约束。这个类有一个名为`Make<T>()`的公共泛型方法。'
- en: The type parameter, `T`, must be either `TValue` or a type derived from `TValue`
    and must also have a public default constructor. This method creates a new instance
    of the type, `T`, adds it to the dictionary in a list associated with the specified
    key, and returns a reference to the newly created object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数`T`必须是`TValue`或从`TValue`派生的类型，并且还必须具有公共默认构造函数。此方法创建类型`T`的新实例，将其添加到与指定键关联的字典中的列表中，并返回对新创建对象的引用。
- en: 'Let''s also consider the following hierarchy of shape classes. Notice that
    for simplicity these are kept to a minimum:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也考虑以下形状类的层次结构。请注意，为简单起见，这些被保持在最低限度：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can use the `RestrictedDictionary` class as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用`RestrictedDictionary`类：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, we are adding several shapes (a circle, ellipsis, rectangle,
    and square) to the restricted dictionary. The key type is `ShapeType` and the
    value type is `Shape`. The `Make()` method takes an argument of the `ShapeType`
    type and returns a reference to a shape object. Each type must be derived from
    `Shape` and have a public default constructor. Otherwise, the code would produce
    an error.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将几种形状（圆形、椭圆形、矩形和正方形）添加到受限制的字典中。键类型是`ShapeType`，值类型是`Shape`。`Make()`方法接受`ShapeType`类型的参数，并返回对形状对象的引用。每种类型都必须派生自`Shape`并具有公共默认构造函数。否则，代码将产生错误。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about generics in C#. Generics allow us to create
    parameterized types in C#. Generics enhance code reusability and ensure type safety.
    We explored how to create generic classes and generic structs. We also implemented
    inheritance in a generic class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了C#中的泛型。泛型允许我们在C#中创建参数化类型。泛型增强了代码的可重用性并确保类型安全。我们探讨了如何创建泛型类和泛型结构。我们还在泛型类中实现了继承。
- en: We learned how to implement constraints on the type parameters of a generic
    type or method. Constraints allow us to limit the data types that can be used
    as a type parameter. We also learned about creating generic methods and generic
    interfaces.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何在泛型类型或方法的类型参数上实现约束。约束允许我们限制可以用作类型参数的数据类型。我们还学习了如何创建泛型方法和泛型接口。
- en: You can use generics primarily for creating collections and wrappers. In the
    next chapter, we will explore the most important collections available in .NET.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以主要用于创建集合和包装的泛型。在下一章中，我们将探讨.NET中最重要的集合。
- en: Test what you learned
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你所学到的
- en: What are generics and what benefits do they provide?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型是什么，它们提供了什么好处？
- en: What are type parameters?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是类型参数？
- en: How do you define a generic class? What about generic methods?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何定义泛型类？泛型方法呢？
- en: Can a class be derived from a generic type? What about structures?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个类可以从泛型类型派生吗？结构呢？
- en: What is a constructed type?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是构造类型？
- en: What is a covariant type parameter of a generic interface?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型接口的协变类型参数是什么？
- en: What is a contravariant type parameter of a generic interface?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型接口的逆变类型参数是什么？
- en: What are type parameter constraints and how are they specified?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是类型参数约束，以及如何指定它们？
- en: What does the `new()` type parameter constraint do?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`new()`类型参数约束是做什么的？'
- en: What type parameter constraint was introduced in C# 8 and what does it do?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C# 8中引入了什么类型参数约束，它是做什么的？
