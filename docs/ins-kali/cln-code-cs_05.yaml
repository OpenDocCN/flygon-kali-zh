- en: Exception Handling
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理
- en: In the previous chapter, we looked at functions. Despite the best efforts of
    programmers to write robust code, functions will, at some point, generate exceptions.
    This could be for a number of reasons, such as a missing file or folder, an empty
    or null value, the location can't be written to, or the user is denied access.
    So, with that in mind, in this chapter, you will learn about appropriate ways
    to use exception handling to produce clean C# code. First, we will start by looking
    at checked and unchecked exceptions with regards to arithmetic `OverflowExceptions`.
    We will look at what they are, why they are used, and some examples of them being
    used in code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了函数。尽管程序员尽力编写健壮的代码，但函数最终会产生异常。这可能是由于许多原因，例如缺少文件或文件夹，空值或空值，无法写入位置，或者用户被拒绝访问。因此，在本章中，您将学习使用异常处理产生清晰的C#代码的适当方法。首先，我们将从算术`OverflowExceptions`的检查和未经检查的异常开始。我们将看看它们是什么，为什么使用它们，以及它们在代码中的一些示例。
- en: Then, we'll look at how we can avoid the `NullPointerReference` exception. After
    that, we'll look at implementing specific business rules for specific types of
    exceptions. With our fresh understanding of exceptions and exception business
    rules, we will set about building our own custom exceptions and then finish off
    by looking at why we should not use exceptions to control the flow of our computer
    programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将看看如何避免`NullPointerReference`异常。之后，我们将研究为特定类型的异常实现特定业务规则。在对异常和异常业务规则有了新的理解之后，我们将开始构建自己的自定义异常，然后最后看看为什么我们不应该使用异常来控制计算机程序的流程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Checked and unchecked exceptions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查和未经检查的异常
- en: Avoiding `NullPointerExceptions`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免`NullPointerExceptions`
- en: Business rule exceptions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务规则异常
- en: Exceptions should provide meaningful information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常应提供有意义的信息
- en: Building your own custom exceptions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自定义异常
- en: 'By the end of this chapter, you will have the skills to do the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将具备以下技能：
- en: You will be able to understand what checked and unchecked exceptions are, and
    why they are in C#.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将能够理解C#中的检查和未经检查的异常，以及它们的原因。
- en: You will be able to understand what an `OverflowException` is and how to trap
    them at compile time.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将能够理解什么是`OverflowException`以及如何在编译时捕获它们。
- en: You will know what `NullPointerExceptions` are and how to avoid them.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将了解什么是`NullPointerExceptions`以及如何避免它们。
- en: You will be able to write your own custom exceptions that provide meaningful
    information to the customer and that aid you and fellow programmers to easily
    identify and resolve any issues that are raised.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将能够编写自己的自定义异常，为客户提供有意义的信息，并帮助您和其他程序员轻松识别和解决引发的任何问题。
- en: You will be able to understand why you should not use exceptions to control
    program flow.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将能够理解为什么不应该使用异常来控制程序流程。
- en: You will know how to replace business rule exceptions with C# statements and
    Boolean checks to control program flow.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将知道如何使用C#语句和布尔检查来替换业务规则异常，以控制程序流程。
- en: Checked and unchecked exceptions
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查和未经检查的异常
- en: In unchecked mode, an arithmetic overflow is *ignored*. In this situation, the
    high-order bits that cannot be assigned to the destination type are discarded
    from the result.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在未经检查的模式下，算术溢出会被*忽略*。在这种情况下，无法分配给目标类型的高阶位将从结果中丢弃。
- en: By default, C# operates in the unchecked context while performing non-constant
    expressions at runtime. But compile-time constant expressions are *always* checked
    by default. When an arithmetic overflow is encountered in checked mode, an `OverflowException`
    is raised. One reason why unchecked exceptions are used is to increase performance.
    Checked exceptions can decrease the performance of methods by a small amount.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，C#在运行时执行非常量表达式时处于未经检查的上下文中。但是编译时常量表达式*始终*默认进行检查。在检查模式下遇到算术溢出时，会引发`OverflowException`。未经检查异常被使用的一个原因是为了提高性能。检查异常可能会稍微降低方法的性能。
- en: The rule of thumb is to make sure that you perform arithmetic operations in
    the checked context. Any arithmetic overflow exceptions will be picked up as compile-time
    errors, and you can then fix them before you release your code. That is much better
    than releasing your code and then having to fix customer runtime errors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则是确保在检查上下文中执行算术运算。任何算术溢出异常都将被视为编译时错误，然后您可以在发布代码之前修复它们。这比发布代码然后不得不修复客户运行时错误要好得多。
- en: Running code in unchecked mode is dangerous as you are making assumptions about
    the code. Assumptions are not facts and they can lead to exceptions being raised
    at runtime. Runtime exceptions lead to poor customer satisfaction and can produce
    serious follow-on exceptions that negatively impact a customer in some way.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在未经检查的模式下运行代码是危险的，因为您对代码进行了假设。假设并非事实，它们可能导致在运行时引发异常。运行时异常会导致客户满意度降低，并可能产生严重的后续异常，以某种方式对客户产生负面影响。
- en: Allowing an application to continue running that has experienced an overflow
    exception is very dangerous from a business perspective. The reason for this is
    that data can end up in a non-reversible invalid state. If the data is critical
    customer data, then this can be considerably costly to the business, and you don't
    want that on your shoulders.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 允许应用程序继续运行，即使发生了溢出异常，从商业角度来看是非常危险的。原因在于数据可能会处于不可逆转的无效状态。如果数据是关键的客户数据，那么这对企业来说可能会非常昂贵，你不希望承担这样的责任。
- en: 'Consider the following code. This code demonstrates how bad an unchecked overflow
    can be in the world of customer banking:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码。这段代码演示了在客户银行业务中未经检查的溢出有多糟糕：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Imagine the horror on this customer's face when they see that adding £1 to their
    bank balance of £2,147,483,647 causes them to be in debt by -£2,147,483,648!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，当客户看到将1英镑加到他们的银行余额2,147,483,647英镑时，他们的脸上会有多么恐慌！
- en: '![](img/a108b152-4768-43c9-acf0-164699f74f0b.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a108b152-4768-43c9-acf0-164699f74f0b.png)'
- en: 'Now, it''s time to demonstrate checked and unchecked exceptions with some code
    examples. First, start a new **console application** and declare some variables:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候用一些代码示例演示检查和未检查异常了。首先，启动一个新的**控制台应用程序**并声明一些变量：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code declares two bytes that we will use in our arithmetic code
    examples. Now, add the `CheckedAdd()` method. This method will raise a checked
    `OverflowException` if an arithmetic overflow is encountered when adding two numbers
    that result in a number that is too big to be stored as a byte:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码声明了两个字节，我们将在算术代码示例中使用。现在，添加`CheckedAdd()`方法。如果在添加两个数字时遇到算术溢出导致的结果太大无法存储为字节，此方法将引发一个检查过的`OverflowException`：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, write the `CheckedMultiplication()` method. Again, a checked `OverflowException`
    will be raised if an arithmetic overflow is detected during the multiplication,
    which results in a number that is larger than a byte:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编写`CheckedMultiplication()`方法。如果在乘法过程中检测到算术溢出，导致的数字大于一个字节，将引发检查过的`OverflowException`：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we add the `UncheckedAdd()` method. This method will ignore any overflow
    that happens as a result of an addition, and so an `OverflowException` will not
    be raised. The result of this overflow will be stored as a byte, but the value
    will be incorrect:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加`UncheckedAdd()`方法。此方法将忽略由于加法而发生的任何溢出，因此不会引发`OverflowException`。溢出的结果将存储为一个字节，但值将是不正确的：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And now, we add the `UncheckedMultiplication()` method. This method will not
    throw an `OverflowException` when an overflow is encountered as the result of
    this multiplication. The exception will simply be ignored. This will result in
    an incorrect number being stored as a byte:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加`UncheckedMultiplication()`方法。当遇到溢出时，此方法不会抛出`OverflowException`。异常将被简单地忽略。这将导致一个不正确的数字被存储为字节：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, it is time to modify our `Main(string[] args)` method so that we can
    initialize the variables and execute the methods. Here, we add the maximum value
    for a byte to the `y` variable and `2` to the `z` variable. Then, we run the `CheckedAdd()`
    and `CheckedMultiplication()` methods, which will both generate `OverflowException()`.
    This is thrown because the `y` variable contains the maximum value for a byte.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候修改我们的`Main(string[] args)`方法，以便我们可以初始化变量并执行方法。在这里，我们将最大值添加到`y`变量和`2`添加到`z`变量。然后，我们运行`CheckedAdd()`和`CheckedMultiplication()`方法，这两个方法都会生成`OverflowException()`。这是因为`y`变量包含了一个字节的最大值。
- en: 'So, by adding or multiplying by `2`, you are exceeding the address space needed
    to store the variable. Next, we will run the `UncheckedAdd()` and `UncheckedMultiplication()`
    methods. Both these methods ignore overflow exceptions, assign the result to the
    `x` variable, and disregard any bits that overflow. Finally, we print a message
    to the screen and then exit when the user presses any key:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过添加或乘以`2`，您超出了存储变量所需的地址空间。接下来，我们将运行`UncheckedAdd()`和`UncheckedMultiplication()`方法。这两种方法都忽略溢出异常，将结果分配给`x`变量，并忽略任何溢出的位。最后，我们在用户按下任意键时打印一条消息，然后退出：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we run the preceding code, we end up with the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的代码时，我们得到以下输出：
- en: '![](img/575def5c-092b-4eda-b195-6fc08d6d56bd.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/575def5c-092b-4eda-b195-6fc08d6d56bd.png)'
- en: As you can see, when we use checked exceptions, exceptions are raised when `OverflowException`
    is encountered. But when we use unchecked exceptions, no exception is raised.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我们使用检查异常时，当遇到`OverflowException`时会引发异常。但当我们使用未检查异常时，不会引发异常。
- en: It is apparent from the preceding screenshot that problems can arise from unexpected
    values and that certain behaviors can arise from using unchecked exceptions. Therefore,
    the rule of thumb when performing arithmetic operations must be to always use
    checked exceptions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图可以看出，意外值可能导致问题，并且使用未检查异常可能导致某些行为。因此，在执行算术运算时的经验法则必须始终使用检查异常。
- en: Now, let's move on and look at a very common exception that is encountered frequently
    by programmers, known as `NullPointerException`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看一个程序员经常遇到的非常常见的异常，称为`NullPointerException`。
- en: Avoiding NullPointerExceptions
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免NullPointerExceptions
- en: '`NullReferenceException` is a common exception that has been experienced by
    most programmers. It is thrown when an attempt is made to access a property or
    method on a `null` object.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`NullReferenceException`是大多数程序员经历过的常见异常。当尝试访问`null`对象的属性或方法时，会引发此异常。'
- en: To defend against computer program crashes, the common course of action among
    fellow programmers is to use `try{...}catch (NullReferenceExceptionre){...}` blocks.
    This is a part of defensive programming. But the problem is that, a lot of the
    time, the error is simply *logged* and *rethrown*. Besides this, a lot of wasted
    computations are performed that could have been avoided.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止计算机程序崩溃，程序员们常用的做法是使用`try{...}catch (NullReferenceExceptionre){...}`块。这是防御性编程的一部分。但问题是，很多时候错误只是*记录*和*重新抛出*。此外，还进行了很多不必要的计算。
- en: A much better way of handling `ArgumentNullExceptions` is to implement `ArgumentNullValidator`.
    The parameters of a method are usually the source of a `null` object. It makes
    sense to test the parameters of a method before they are used and, if they are
    found to be invalid for any reason, to throw an appropriate `Exception`. In the
    case of `ArgumentNullValidator`, you would place this validator at the top of
    the method and then test each parameter. If any parameter was found to be `null`,
    then `NullReferenceException` would be thrown. This would save computations and
    remove the need to wrap your method's code in a `try...catch` block.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`ArgumentNullExceptions`的一个更好的方法是实现`ArgumentNullValidator`。方法的参数通常是`null`对象的来源。在使用参数之前测试方法的参数并且如果发现它们因任何原因无效，则抛出适当的`Exception`是有意义的。在`ArgumentNullValidator`的情况下，您将把此验证器放在方法的顶部，然后测试每个参数。如果发现任何参数为`null`，则会抛出`NullReferenceException`。这将节省计算并消除了将方法代码包装在`try...catch`块中的需要。
- en: 'To make things clear, we will write `ArgumentNullValidator` and use it in a
    method to test the method''s arguments:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确事物，我们将编写`ArgumentNullValidator`并在一个方法中使用它来测试方法的参数：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we have created the `Person` class with a single read-only
    property called `Name`. This will be the object that we will use to pass into
    the example methods to cause `NullReferenceException`. Next, we will create our
    `Attribute` for the validator called `ValidatedNotNullAttribibute`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个名为`Name`的只读属性的`Person`类。这将是我们将用于传递到示例方法中以引发`NullReferenceException`的对象。接下来，我们将为验证器创建我们的`Attribute`，称为`ValidatedNotNullAttribibute`：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have our `Attribute`, it''s time to write the validator:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的`Attribute`，是时候编写验证器了：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`ArgumentNullValidator` takes two arguments:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArgumentNullValidator`接受两个参数：'
- en: The name of the object
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的名称
- en: The object itself
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象本身
- en: The object is checked to see if it is `null`. If it is `null`, `ArgumentNullException`
    is thrown, passing in the name of the object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 检查对象是否为`null`。如果是`null`，则抛出`ArgumentNullException`，并传入对象的名称。
- en: 'The following method is our `try/catch` example method. Notice that we log
    a message and throw the exception. However, we don''t use the declared exception
    parameter, and so by rights, this should be removed. You will see this quite often
    in code. It is unnecessary and should be removed to tidy the code up:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法是我们的`try/catch`示例方法。请注意，我们记录了一条消息并抛出了异常。然而，我们没有使用声明的异常参数，因此按理说应该将其删除。您会经常在代码中看到这种情况。这是不必要的，应该删除以整理代码：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we will write our example method that will use `ArgumentNullValidator`.
    We will call it `ArgumentNullValidatorExample`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个将使用`ArgumentNullValidator`的示例方法。我们将其称为`ArgumentNullValidatorExample`：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that we have gone from nine lines, including braces, to only two lines.
    We also don't attempt to use the value before it has been validated. All we need
    to do now is modify our `Main` method to run the methods. Test each method by
    commenting out one of the methods and running the program. When you do this, it
    is best to step through your code to see what's going on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经从包括大括号在内的九行代码减少到了只有两行。我们也不会在验证之前尝试使用该值。现在我们需要做的就是修改我们的`Main`方法来运行这些方法。通过注释掉其中一个方法并运行程序来测试每个方法。这样做时，最好逐步执行代码以查看发生了什么。
- en: 'The following is the output of running the `TryCatchExample` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行`TryCatchExample`方法的输出：
- en: '![](img/af29322d-9c55-4bf5-919a-2d18d325f98e.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af29322d-9c55-4bf5-919a-2d18d325f98e.png)'
- en: 'The following is the output of running `ArgumentNullValidatorExample`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行`ArgumentNullValidatorExample`的输出：
- en: '![](img/c1e41646-e39e-46c3-a8ea-43d813d5e302.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1e41646-e39e-46c3-a8ea-43d813d5e302.png)'
- en: If you study the previous screenshots carefully, you will see that we have only
    logged the error once when using `ArgumentNullValidatorExample`. When throwing
    the exception using `TryCatchExample`, the exception is logged twice.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细研究前面的屏幕截图，您会发现在使用`ArgumentNullValidatorExample`时我们只记录了一次错误。当使用`TryCatchExample`抛出异常时，异常被记录了两次。
- en: The first time, we have a meaningful message, but the second time, the message
    is *cryptic*. However, the exception that is logged by the calling method, `Main`,
    is not cryptic at all. It is, in fact, very helpful as it shows us that the value
    cannot be `null` for the `Person` parameter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次，我们有一个有意义的消息，但第二次，消息是*神秘的*。然而，由调用方法`Main`记录的异常并不神秘。事实上，它非常有帮助，因为它向我们显示了`Person`参数的值不能为`null`。
- en: Hopefully, this section has shown you the value of checking your parameters
    in your constructors and methods before you use them. By doing this, you can see
    how argument validators reduce your code, thus making it more readable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一部分向您展示了在使用构造函数和方法之前检查参数的价值。通过这样做，您可以看到参数验证器如何减少您的代码，从而使其更易读。
- en: Now, we will look at implementing business rules for specific exceptions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何为特定异常实现业务规则。
- en: Business rule exceptions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务规则异常
- en: Technical exceptions are exceptions that are thrown by a computer program as
    a result of programmer mistakes and/or environmental issues such as there not
    being enough disk space.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 技术异常是由计算机程序由于程序员的错误和/或环境问题（例如磁盘空间不足）而抛出的异常。
- en: But business rule exceptions are different. Business rule exceptions imply that
    such behavior is expected and is used to control program flow, when in fact, exceptions
    should be an exception to the normal flow of the program and not the expected
    output of a method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但是业务规则异常是不同的。业务规则异常意味着这种行为是预期的，并且用于控制程序流程，而实际上，异常应该是程序的正常流程的例外，而不是方法的预期输出。
- en: For example, picture a person at an ATM drawing out £100 from their account
    that has £0 in it and does not have the ability to go overdrawn. The ATM accepts
    the user request to draw £100 out, and so it issues the `Withdraw(100);` command.
    The `Withdraw` method checks the balance, discovers that the account has insufficient
    funds, and so throws `InsufficientFundsException()`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个在ATM机上从账户中取出100英镑的人，账户里没有钱，也没有透支的能力。ATM接受用户的100英镑取款请求，因此发出`Withdraw(100);`命令。`Withdraw`方法检查余额，发现账户资金不足，因此抛出`InsufficientFundsException()`。
- en: You may think that having such exceptions is a good idea as they are explicit
    and help identify issues so that you can carry out a very specific action upon
    receiving such exceptions – but no! This is not a good idea.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能认为拥有这样的异常是一个好主意，因为它们是明确的，并有助于识别问题，以便在收到这样的异常时执行非常具体的操作——但不是！这不是一个好主意。
- en: In such a scenario, when the user submits the request, the amount requested
    should be checked to see if it can be withdrawn. If it can, then the transaction
    should go ahead, as requested by the user. But if the validation check identifies
    that the transaction is unable to go ahead, then the program should follow normal
    program flow to cancel the transaction and inform the user who issued the request
    without raising an exception.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当用户提交请求时，应检查所请求的金额是否可以取款。如果可以，那么交易应该继续进行，如用户所请求的那样。但是，如果验证检查确定无法继续进行交易，那么程序应该按照正常的程序流程取消交易，并通知发出请求的用户，而不引发异常。
- en: The withdrawal scenario we've just looked at shows that the programmer has correctly
    pondered upon the normal flow of the program and the different outcomes. The program
    flow has been appropriately coded using Boolean checks to allow for the successful
    withdrawal transactions and to prevent disallowed withdrawal transactions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的取款情景表明，程序员已经正确考虑了程序的正常流程和不同的结果。程序流程已经适当地使用布尔检查编码，以允许成功的取款交易并防止不允许的取款交易。
- en: Let's see how we would implement a withdrawal from a bank account that does
    not allow an overdraft scenario using **Business Rule Exceptions** (**BREs**).
    Then, we'll take a look at how we would implement the same scenario but using
    normal program flow instead of employing BREs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用**业务规则异常**（**BREs**）来实现不允许透支的银行账户的取款。然后，我们将看看如何实现相同的场景，但是使用正常的程序流程而不是使用BREs。
- en: 'Start a new console application and add two folders called `BankAccountUsingExceptions`
    and `BankAccountUsingProgramFlow`. Update your `void Main(string[] args)` method
    with the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的控制台应用程序，并添加两个名为`BankAccountUsingExceptions`和`BankAccountUsingProgramFlow`的文件夹。使用以下代码更新您的`void
    Main(string[] args)`方法：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code runs each scenario. `UsingBusinessRuleExceptions()` demonstrates
    the use of exceptions as the expected output that's used to control program flow,
    while `UsingProgramFlow()` demonstrates the clean way of controlling program flow
    without the use of exceptional conditions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码运行每个情景。`UsingBusinessRuleExceptions()`演示了异常作为控制程序流程的预期输出的使用，而`UsingProgramFlow()`演示了在不使用异常条件的情况下控制程序流程的干净方式。
- en: 'We now need a class to hold our current account information. So, add a class
    called `CurrentAccount` to your Visual Studio console project, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个类来保存我们的活期账户信息。因此，在您的Visual Studio控制台项目中添加一个名为`CurrentAccount`的类，如下所示：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The properties of this class can only be set internally or externally via the
    constructor. Now, add the constructor that takes the customer identifier as the
    only parameter:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的属性只能通过构造函数内部或外部设置。现在，添加一个以客户标识符作为唯一参数的构造函数：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The current account constructor initializes all the properties. As shown in
    the preceding code, some properties are initialized using methods. Let''s implement
    each of the methods in turn:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当前账户构造函数初始化所有属性。如前面的代码所示，一些属性是使用方法初始化的。让我们依次实现每个方法：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`GetAgreedOverdraftLimit()` returns the value of the agreed overdraft limit
    on the account. In this example, it is hardcoded to zero. But in a real scenario,
    it would extract the actual figure from a configuration file or other data store.
    This would allow non-technical users to update the agreed overdraft limit without
    developers having to change the code.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAgreedOverdraftLimit()`返回账户上约定的透支限额的值。在本例中，它被硬编码为零。但在实际情况中，它将从配置文件或其他数据存储中提取实际数字。这将允许非技术用户更新约定的透支限额，而无需开发人员更改代码。'
- en: '`GetIsAllowedToGoOverdrawn()` determines if the account can be overdrawn, even
    if it has not been agreed, as some banks allow. In this case, we just return `false`
    to determine that the account is unable to go overdrawn:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetIsAllowedToGoOverdrawn()`确定账户是否可以透支，即使没有经过同意，有些银行是允许的。在这种情况下，我们只需返回`false`来确定账户无法透支：'
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For the purpose of this example, we will set the user''s account balance to
    £250 in the `GetCurrentBalance()` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本例的目的，我们将在`GetCurrentBalance()`方法中将用户的账户余额设置为250英镑：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As a part of our example, we need to make sure that even if the person has
    £250 in their account, but their available balance is less than that, they are
    unable to withdraw more than the available balance as this would cause them to
    go overdrawn. To do this, we will set the available balance to £173.64 in the `GetAvailableBalance()` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们示例的一部分，我们需要确保即使用户的账户余额为250英镑，但其可用余额小于该金额，他们也无法取出超过可用余额的金额，因为这将导致透支。为此，我们将在`GetAvailableBalance()`方法中将可用余额设置为173.64英镑：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, in the UK, ATM machines will either allow you to withdraw a maximum of
    £200 or £250\. So, in the `GetAtmDailyLimit()` method, we will set the ATM daily
    limit to £250:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在英国，ATM机要么允许您最多取款200英镑，要么允许您最多取款250英镑。因此，在`GetAtmDailyLimit()`方法中，我们将将ATM每日限额设置为250英镑：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's write the code for our two scenarios by using business rule exceptions
    and normal program flow to handle different conditions within a program.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用业务规则异常和正常程序流程来处理程序中的不同条件，编写我们两种情景的代码。
- en: Example 1 – handling conditions with business rule exceptions
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例1 - 使用业务规则异常处理条件
- en: 'Add a new class to your project called `UsingBusinessRuleExceptions` and then
    add the following `Run()` method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 向项目添加一个名为 `UsingBusinessRuleExceptions` 的新类，然后添加以下 `Run()` 方法：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Run()` method calls two methods:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run()` 方法调用两个方法：'
- en: The first method is called `ExceedAtmDailyLimit()`. This method intentionally
    exceeds the daily amount that is allowed to be withdrawn from an ATM. `ExceedAtmDailyLimit()`
    causes `ExceededAtmDailyLimitException`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个方法称为 `ExceedAtmDailyLimit()`。该方法故意超出了允许从 ATM 提取的每日金额。`ExceedAtmDailyLimit()`
    导致 `ExceededAtmDailyLimitException`。
- en: 'Secondly, the `ExceedAvailableBalance()` method is called, which intentionally
    causes an `InsufficientFundsException`. Add the `ExceedAtmDailyLimit()` method:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，调用 `ExceedAvailableBalance()` 方法，该方法故意引发 `InsufficientFundsException`。添加
    `ExceedAtmDailyLimit()` 方法：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `ExceedAtmDailyLimit()` method creates a new `CustomerAccount` method and
    passes in the customer''s identifier, as represented by the number `1`. Then,
    an attempt is made to withdraw £300\. If the request is successful, then the message
    `Request accepted. Take cash and card.` is printed to the console window. Should
    the request fail, then the method traps `ExceededAtmLimitException` and prints
    the exception''s message to the console window:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceedAtmDailyLimit()` 方法创建一个新的 `CustomerAccount` 方法，并传入客户的标识符，表示为数字 `1`。然后，尝试提取
    £300。如果请求成功，那么将在控制台窗口打印消息 `Request accepted. Take cash and card.`。如果请求失败，那么该方法会捕获
    `ExceededAtmLimitException` 并将异常消息打印到控制台窗口：'
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ExceedAvailableBalance()` method creates a new `CurrentAccount` and passes
    in the customer identifier, as represented by the number `1`. An attempt is then
    made to withdraw £180\. Since `GetAvailableMethod()` returns £173.64, the method
    causes an `InsufficientFundsException`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceedAvailableBalance()` 方法创建一个新的 `CurrentAccount` 并传入客户标识符，表示为数字 `1`。然后尝试提取
    £180。由于 `GetAvailableMethod()` 返回 £173.64，该方法导致 `InsufficientFundsException`。'
- en: With that, we've seen how to manage different conditions using business rule
    exceptions. Now, let's look at the proper way to manage the same conditions using
    normal program flow, without the use of exceptions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经看到了如何使用业务规则异常来管理不同的条件。现在，让我们看看如何以正常的程序流程管理相同的条件，而不使用异常。
- en: Example 2 – handling conditions with normal program flow
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例2 - 使用正常程序流程处理条件
- en: 'Add a class called `UsingProgramFlow` and then add the following code to it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为 `UsingProgramFlow` 的类，然后向其中添加以下代码：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the constructor of the `UsingProgramFlow` class, we will create a new `CurrentAccount`
    class and pass in the customer identifier. Next, we''ll add the `Run()` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UsingProgramFlow` 类的构造函数中，我们将创建一个新的 `CurrentAccount` 类并传入客户标识符。接下来，我们将添加
    `Run()` 方法：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Run()` method sets the `_requestedAmount` variable three times. Each time
    it does this, a message is printed stating the withdrawn amount on the console
    window before calling the `WithdrawMoney()` method. Now, add the `ExceedsDailyLimit()`
    method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run()` 方法三次设置 `_requestedAmount` 变量。每次这样做时，在调用 `WithdrawMoney()` 方法之前，将在控制台窗口上打印提取的金额的消息。现在，添加
    `ExceedsDailyLimit()` 方法：'
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `ExceedDailyLimit()` method returns `true` if `_requestedAmount` exceeds
    the daily ATM withdrawal limit. Otherwise, it returns false. Now, add the `ExceedsAvailableBalance()`
    method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceedDailyLimit()` 方法如果 `_requestedAmount` 超过每日 ATM 提款限额，则返回 `true`。否则，返回
    false。现在，添加 `ExceedsAvailableBalance()` 方法：'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `ExceedsAvailableBalance()` method returns `true` if the requested amount
    is more than is available for withdrawal. Finally, we come to the last method,
    called `WithdrawMoney()`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceedsAvailableBalance()` 方法如果请求的金额超过了可提取的金额，则返回 `true`。最后，我们来到最后一个方法，称为
    `WithdrawMoney()`：'
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `WithdrawMoney()` method does not use BREs to control the program flow.
    Instead, this method calls Boolean validation methods that determine the program
    flow. If `_requestedAmount` exceeds the ATM daily limit, as determined by the
    call to `ExceedsDailyLimit()`, then the request is denied. Otherwise, the next
    check is carried out to see if `_requestedAmount` is more than `AvailableBalance`.
    If it is, then the request is rejected. If not, then the code is executed that
    grants the request.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithdrawMoney()` 方法不使用 BREs 来控制程序流程。相反，该方法调用布尔验证方法来确定程序流程。如果 `_requestedAmount`
    超过了由调用 `ExceedsDailyLimit()` 确定的 ATM 每日限额，则请求被拒绝。否则，将进行下一个检查，以查看 `_requestedAmount`
    是否超过了 `AvailableBalance`。如果是，则拒绝请求。如果不是，则执行授予请求的代码。'
- en: I hope you can see that it makes more sense to control the flow of a program
    using the available logic rather than expecting exceptions to be thrown. The code
    is a lot cleaner and more correct. Exceptions should be reserved for exceptional
    circumstances that are not a part of the business requirements.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您能看到，使用可用逻辑控制程序的流程比期望抛出异常更有意义。代码更清晰，更正确。异常应该保留给不属于业务需求的特殊情况。
- en: When proper exceptions are raised in the correct manner, it is important for
    them to be meaningful. Cryptic error messages are no good for anyone and can actually
    add unnecessary stress for end users or developers. Now, we are going to look
    at providing meaningful information in any of the exceptions that are raised by
    our computer programs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确引发适当的异常时，对它们提供有意义的信息非常重要。晦涩的错误消息对任何人都没有好处，实际上可能会给最终用户或开发人员增加不必要的压力。现在，我们将看看如何在计算机程序引发的任何异常中提供有意义的信息。
- en: Exceptions should provide meaningful information
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常应该提供有意义的信息
- en: Critical errors that state "There is no error" and then kill a program are just
    not useful at all. I have experienced the actual "There is no error" critical
    exception first hand. It is a critical exception that stops an application from
    working. Yet the message is informing us that there is no error. Well, if there
    is no error, then why has a critical exception warning appeared on the screen?
    And why am I unable to continue using the application? Obviously, for the critical
    exception to be raised, there must be a critical exception somewhere that occurred.
    But where and why?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 声明“没有错误”并终止程序的关键错误根本没有用。我亲身经历过实际的“没有错误”关键异常。这是一个阻止应用程序工作的关键异常。然而，消息告诉我们没有错误。好吧，如果没有错误，那么为什么屏幕上会出现关键异常警告？为什么我无法继续使用应用程序？显然，要引发关键异常，必须在某个地方发生了关键异常。但是在哪里，为什么？
- en: What makes such exceptions even more annoying is when they are deep-rooted in
    the framework or library that you are using (which you have no control over),
    and where you have no access to the source code. Such exceptions have caused programmers
    to say negative things out of frustration. I've been guilty of this and I've experienced
    fellow colleagues do the same. One of the main reasons for the frustration is
    the unhelpful fact that the code has raised an error and the user or programmer
    has been informed, but there is no helpful information to suggest what the problem
    is or where to look or even what remedial action to take.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些异常深植于你正在使用的框架或库中（你无法控制），并且你无法访问源代码时，这样的异常会变得更加恼人。这些异常导致程序员因沮丧而说出负面的话。我曾经有过这样的经历，也见过同事有同样的情况。沮丧的主要原因之一是代码引发了错误，用户或程序员已经被通知，但没有有用的信息来建议问题所在或查找位置，甚至采取什么补救措施。
- en: Exceptions must provide information that is human-friendly, especially to the
    technically challenged. During my time developing dyslexia testing and assessment
    software, I have worked with many teachers and IT technicians.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 异常必须提供对技术挑战者尤其友好的信息。在开发阅读障碍测试和评估软件的时候，我和许多教师和IT技术人员一起工作过。
- en: It can be said that many IT technicians and teachers at all levels of ability
    have often been clueless when it comes to responding to software exception messages.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，许多各种能力水平的IT技术人员和教师在回应软件异常消息时经常一无所知。
- en: 'One error that has perplexed many of the end users of the software I''ve supported
    has been **Error 76: Path not found**. This is an old Microsoft exception that
    has been around as far back as Windows 95, and that still exists today. For the
    end user of the software that raises this exception, the error message is totally
    useless. It would be useful for the end user to know what file and location cannot
    be found and to know what steps to take to remedy the situation.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我支持的软件的许多最终用户一直困惑的一个错误是**错误76：路径未找到**。这是一个古老的微软异常，早在Windows 95时代就存在，今天仍然存在。对于引发此异常的软件的最终用户来说，错误消息是完全无用的。最终用户知道哪个文件和位置找不到，并知道应采取什么步骤来解决问题将是有用的。
- en: 'A potential solution would be to implement the following steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个潜在的解决方案是实施以下步骤：
- en: Check for the existence of the location.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查位置是否存在。
- en: If the location does not exist or access is denied, then display the file save
    or open dialog as needed.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果位置不存在或访问被拒绝，则根据需要显示文件保存或打开对话框。
- en: Save the user-selected location to a configuration file for future use.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户选择的位置保存到配置文件以供将来使用。
- en: On subsequent runs of the same code, use the location set by the user.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一段代码的后续运行中，使用用户设置的位置。
- en: But if you were to stay with the error message, then you should at least provide
    the name of the location and/or file that is missing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你要保留错误消息，那么你至少应该提供缺失的位置和/或文件的名称。
- en: 'With that said, it is now time to look at how we can build our own exceptions
    to provide just the right amount of information that will be useful to the end
    user and to the programmer. But take note: you must be careful not to disclose
    sensitive information or data.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些说法，现在是时候看看我们如何构建自己的异常，以提供对最终用户和程序员有用的信息了。但请注意：你必须小心，不要透露敏感信息或数据。
- en: Building your own custom exceptions
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自定义异常
- en: Microsoft .NET Framework already has a good number of exceptions that can be
    raised that you are able to trap. But there may be instances where you'll require
    a custom exception that provides more detailed information or that is more end
    user friendly in its terminology.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft .NET Framework已经有许多可以引发的异常，你可以捕获。但可能会有一些情况，你需要一个提供更详细信息或在术语上更加用户友好的自定义异常。
- en: 'So, we are now going to look at what the requirements are for building our
    own custom exceptions. It is surprisingly simple to build your own custom exception.
    All you have to do is give your class a name that ends with `Exception` and inherit
    from `System.Exception`. Then, you need to add three constructors, as shown in
    the following code example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在将看看构建自定义异常的要求是什么。构建自定义异常其实非常简单。你只需要给你的类一个以`Exception`结尾的名称，并继承自`System.Exception`。然后，你需要添加三个构造函数，如下面的代码示例所示：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`TickerListNotFoundException` inherits from the `System.Exception` class. It
    contains three mandatory constructors:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`TickerListNotFoundException`继承自`System.Exception`类。它包含三个必需的构造函数：'
- en: A default constructor
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个默认构造函数
- en: A constructor that accepts a string of text for the exception message
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受异常消息文本字符串的构造函数
- en: A constructor that accepts a string of text for the exception message and an
    `Exception` object for the inner exception
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受异常消息文本字符串和`Exception`对象的构造函数
- en: 'We are now going to write and execute three methods that will use each of our
    custom exception''s constructors. You will be able to clearly see the benefit
    of using custom exceptions to create more meaningful exceptions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并执行三种方法，这些方法将使用我们自定义异常的每个构造函数。您将能够清楚地看到使用自定义异常来创建更有意义的异常的好处：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code shows our updated `Main(string[] args)` method, which has
    been updated to execute our three methods. These will test each of our custom
    exception''s constructors in turn:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了我们更新的`Main(string[] args)`方法，该方法已更新以依次执行我们的三种方法。这将测试每个自定义异常的构造函数：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `ThrowCustomExceptionA()` method throws a new `TickerListNotFoundException`
    by using the default constructor. When you run the code, the message that''s printed
    to the console window informs the user that a `CH05_CustomExceptions.TickerListNotFoundException`
    has been thrown:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThrowCustomExceptionA()`方法通过使用默认构造函数抛出一个新的`TickerListNotFoundException`。当您运行代码时，打印到控制台窗口的消息会通知用户已抛出`CH05_CustomExceptions.TickerListNotFoundException`：'
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`ThrowCustomExceptionB()` throws a new `TickerListNotFoundException` by using
    the constructor that accepts a text message. In this case, the end user is informed
    that the ticker list hasn''t been found:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThrowCustomExceptionB()`通过使用接受文本消息的构造函数抛出一个新的`TickerListNotFoundException`。在这种情况下，最终用户被告知找不到股票列表：'
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Finally, the `ThrowCustomExceptionC()` method throws a `TickerListNotFoundException`
    by using the constructor that takes a text message and inner exception. In our
    example, we provide a meaningful message stating that the ticker list has not
    been found for this exchange. The inner `FileNotFoundException` expands upon this
    by providing the name of the specific file that was not found, which happens to
    be the ticker list of Aim companies on the **London Stock Exchange** (**LSE**).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`ThrowCustomExceptionC()`方法通过使用接受文本消息和内部异常的构造函数抛出`TickerListNotFoundException`。在我们的示例中，我们提供了一个有意义的消息，说明在该交易所找不到股票列表。内部的`FileNotFoundException`通过提供未找到的特定文件的名称来扩展这一点，这恰好是**伦敦证券交易所**（**LSE**）上的Aim公司的股票列表。
- en: Here, we can see that there are genuine advantages to creating your own custom
    exceptions. But in most cases, using the intrinsic exceptions within .NET Framework
    should suffice. The main benefit of custom exceptions is that they're more meaningful
    exceptions that aid with debugging and resolution.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到创建自定义异常的真正优势。但在大多数情况下，使用.NET Framework中的内在异常应该就足够了。自定义异常的主要好处是它们是更有意义的异常，有助于调试和解决问题。
- en: 'Here is a brief list of C# exception handling best practices:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是C#异常处理最佳实践的简要列表：
- en: Use try/catch/finally blocks to recover from errors or release resources.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用try/catch/finally块来从错误中恢复或释放资源。
- en: Handle common conditions without throwing exceptions.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理常见条件而不抛出异常。
- en: Design classes so that exceptions can be avoided.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计类以避免异常。
- en: Throw exceptions instead of returning an error code.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常而不是返回错误代码。
- en: Use the predefined .NET exception types.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预定义的.NET异常类型。
- en: End exception class names with the word **Exception**.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常类的名称以单词**Exception**结尾。
- en: Include three constructors in custom exception classes.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自定义异常类中包含三个构造函数。
- en: Ensure that exception data is available when code executes remotely.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在代码远程执行时可用异常数据。
- en: Use grammatically correct error messages.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用语法正确的错误消息。
- en: Include a localized string message in every exception.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个异常中包含本地化的字符串消息。
- en: In custom exceptions, provide additional properties as needed.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自定义异常中根据需要提供额外的属性。
- en: Place throw statements so that the stack trace will be helpful.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放置throw语句，以便堆栈跟踪将有所帮助。
- en: Use exception builder methods.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异常生成器方法。
- en: Restore state when methods don't complete due to exceptions.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当方法由于异常而无法完成时，恢复状态。
- en: Now, it's time to summarize what we have learned in regard to exception handling.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候总结我们在异常处理方面学到的内容了。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about checked exceptions and unchecked exceptions.
    Checked exceptions prevent arithmetic overflow conditions from entering any production
    code as they are trapped at compile time. Unchecked exceptions go unchecked at
    compile time and can often make it into production code. This can lead to some
    *hard-to-track-down* bugs in your code through unexpected data values and even
    result in exceptions being thrown that cause your programs to crash.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了已检查异常和未检查异常。已检查异常可以防止算术溢出条件进入任何生产代码，因为它们在编译时被捕获。未检查异常在编译时不被检查，通常会进入生产代码。这可能导致一些*难以跟踪*的错误在您的代码中通过意外数据值并最终导致抛出异常，导致程序崩溃。
- en: You then learned about the common `NullPointerException` and how to validate
    parameters that have been passed in using custom `Attribute` and `Validator` classes,
    which are placed at the top of your methods. These allow you to provide meaningful
    feedback when validation fails. This leads to more robust programs in the long
    run.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您了解了常见的`NullPointerException`以及如何使用自定义`Attribute`和`Validator`类来验证传入的参数，这些类放置在方法的顶部。这使您能够在验证失败时提供有意义的反馈。从长远来看，这将导致更健壮的程序。
- en: Then, we discussed using **BREs** to control program flow. You were shown how
    to control the program flow by expecting exceptional output. Then, you saw how
    to achieve better control over the flow of computer code without using exceptions
    by using conditional checks.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了使用**BREs**来控制程序流程。您将学习如何通过期望异常输出来控制程序流程。然后，您将看到如何通过使用条件检查而不是使用异常来更好地控制计算机代码的流程。
- en: The discussion then moved onto the importance of providing meaningful exception
    messages and how this can be achieved; that is, by writing your own custom exceptions
    that inherit from the `Exception` class and implement the required three parameters.
    Through the examples provided, you learned how to use your custom exceptions and
    how they aid better debugging and resolution.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论随后转向提供有意义的异常消息的重要性以及如何实现这一点；也就是说，通过编写继承自`Exception`类并实现所需的三个参数的自定义异常。通过提供的示例，你学会了如何使用自定义异常以及它们如何帮助更好地调试和解决问题。
- en: So, now, it is time to put what you've learned to the test by answering some
    questions. There is also further reading for you to do if you wish to expand upon
    what you have learned in this chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在是时候通过回答一些问题来检验你所学到的知识了。如果你希望扩展本章学到的知识，还有进一步的阅读材料。
- en: In the next chapter, we will be looking at unit testing and how to write your
    tests first so that they fail. Then, we will write just enough code for the tests
    to pass and refactor the working code before moving on to the next unit test.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习单元测试以及如何先编写测试使其失败。然后，我们将编写足够的代码使测试通过，并在继续进行下一个单元测试之前对工作代码进行重构。
- en: Questions
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a checked exception?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是已检查异常？
- en: What is an unchecked exception?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是未检查异常？
- en: What is an arithmetic overflow exception?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算术溢出异常是什么？
- en: What is a `NullPointerException`?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`NullPointerException`？
- en: How can you validate null parameters to improve your overall code?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何验证空参数以改进你的整体代码？
- en: What does BRE stand for?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BRE代表什么？
- en: Are BREs good or bad practice, and why do you think that?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BRE是好还是坏的实践，你为什么这样认为？
- en: What is the alternative to BREs, is it good or bad, and why do you think that?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BRE的替代方案是什么，它是好还是坏，你为什么这样认为？
- en: How can you provide meaningful exception messages?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何提供有意义的异常消息？
- en: What are the requirements for writing your own custom exceptions?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写自定义异常的要求是什么？
- en: Further reading
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/exceptions/](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/):
    This is the official documentation for handling and throwing exceptions in .NET.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/exceptions/](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/)：这是处理和抛出.NET异常的官方文档。'
- en: '[https://reflectoring.io/business-exceptions/](https://reflectoring.io/business-exceptions/):
    The author of this article provides five reasons why BREs are a bad idea after
    originally believing they were a good idea. There is extra information in this
    article that was not covered in this chapter.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://reflectoring.io/business-exceptions/](https://reflectoring.io/business-exceptions/)：本文作者提供了五个原本认为BRE是一个好主意后认为它们是一个坏主意的原因。本文中还有一些本章未涉及的额外信息。'
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions):
    The best practices from Microsoft in regard to C# exception handling, along with
    code examples and explanations.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions)：微软关于C#异常处理的最佳实践，包括代码示例和解释。'
