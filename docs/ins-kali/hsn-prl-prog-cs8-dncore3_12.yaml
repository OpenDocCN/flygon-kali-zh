- en: Async, Await, and Task-Based Asynchronous Programming Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步、等待和基于任务的异步编程基础
- en: In the previous chapter, we introduced asynchronous programming practices and
    solutions available in C#, even prior to .NET Core. We also discussed scenarios
    where asynchronous programming can be handy, and where it should be avoided.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了C#中可用的异步编程实践和解决方案，甚至在.NET Core之前。我们还讨论了异步编程可以派上用场的场景，以及应该避免使用的场景。
- en: 'In this chapter, we will dig more deeply into asynchronous programming, and
    will introduce two keywords that make writing asynchronous code very easy. We
    will be covering the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨异步编程，并介绍两个使编写异步代码变得非常容易的关键字。本章将涵盖以下主题：
- en: Introduction to `async` and `await`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍`async`和`await`
- en: Async delegates and lambda expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步委托和lambda表达式
- en: The** Task-Based Asynchronous Pattern** (**TAP**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于任务的异步模式**（**TAP**）'
- en: Exception handling in asynchronous code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步代码中的异常处理
- en: Async with PLINQ
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PLINQ进行异步
- en: Measuring async code performance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量异步代码性能
- en: Guidelines for using async code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步代码的指南
- en: Let's start with an introduction to the `async` and `await` keywords, which
    were first introduced in C# 5.0 and adopted in .NET Core as well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从介绍`async`和`await`关键字开始，这两个关键字首次在C# 5.0中引入，并在.NET Core中也被采用。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Readers should have a good understanding of the **Task Parallel Library **(**TPL**) and
    C#. The source code for this chapter is available on GitHub at [https://github.com/PacktPublishing/-Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter09](https://github.com/PacktPublishing/-Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter09).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应该对**任务并行库**（**TPL**）和C#有很好的理解。本章的源代码可在GitHub上找到：[https://github.com/PacktPublishing/-Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter09](https://github.com/PacktPublishing/-Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter09)。
- en: Introducing async and await
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍异步和await
- en: '`async` and `await` are two very popular keywords among .NET Core developers
    writing asynchronous code with the new asynchronous APIs provided by .NET Framework.
    They are used for marking code when calling asynchronous operations. In the last
    chapter, we discussed the challenges of converting a synchronous method into an
    asynchronous one. Previously, we did this by breaking down the method into two
    methods, `BeginMethodName` and `EndMethodName`, which can be called asynchronously.
    This approach makes the code clumsy and difficult to write, debug, and maintain.
    With the `async` and `await` keywords, however, the code can stay how it was in
    the synchronous implementation, with only small changes required. All the difficult
    work of breaking down the method, executing the asynchronous method, and getting
    the response back to the program is done by the compiler.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`和`await`是.NET Core开发人员中非常流行的两个关键字，用于在调用.NET Framework提供的新异步API时标记代码。在上一章中，我们讨论了将同步方法转换为异步方法的挑战。以前，我们通过将方法分解为两个方法`BeginMethodName`和`EndMethodName`来实现异步调用。这种方法使代码变得笨拙，难以编写、调试和维护。然而，使用`async`和`await`关键字，代码可以保持与同步实现相同，只需要进行少量的更改。将方法分解、执行异步方法以及将响应返回给程序的所有困难工作都由编译器完成。'
- en: All new I/O APIs provided by .NET Framework support task-based asynchrony, which
    we discussed in the previous chapter. Let's now try to understand a few scenarios
    involving I/O operations, wherein we can take advantage of the `async` and `await`
    keywords. Let's say we want to download data from a public API that returns data
    in JSON format. In older versions of C#, we can write synchronous code using the
    `WebClient` class available in the `System.Net` namespace, as follows.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework提供的所有新I/O API都支持基于任务的异步性，我们在上一章中已经讨论过。现在让我们尝试理解一些涉及I/O操作的场景，我们可以利用`async`和`await`关键字。假设我们想从返回JSON格式数据的公共API中下载数据。在较旧版本的C#中，我们可以使用`System.Net`命名空间中提供的`WebClient`类编写同步代码，如下所示。
- en: 'First, add a reference to the `System.Net` assembly:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加对`System.Net`程序集的引用：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, create an object of the `WebClient` class and call the `DownloadString`
    method by passing the URL of the page to download. The method will run synchronously,
    and the calling thread will be blocked until the download operation is finished.
    This can hamper the performance of the server (if used in server-side code) and
    the responsiveness of the application (if used in Windows application code).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个`WebClient`类的对象，并通过传递要下载的页面的URL来调用`DownloadString`方法。该方法将同步运行，并且调用线程将被阻塞，直到下载操作完成。这可能会影响服务器的性能（如果在服务器端代码中使用）和应用程序的响应性（如果在Windows应用程序代码中使用）。
- en: To improve performance and responsiveness, we can use the asynchronous version
    of the `DownloadString` method, which was introduced much later.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能和响应性，我们可以使用稍后引入的`DownloadString`方法的异步版本。
- en: 'Here is a method that creates a download request for a remote resource that
    is `http://www.aspnet.com` and subscribes to the `DownloadStringCompleted` event,
    rather than waiting for the download to complete:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个创建远程资源`http://www.aspnet.com`的下载请求并订阅`DownloadStringCompleted`事件的方法，而不是等待下载完成的方法：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And here is the `DownloadComplete` event handler, which gets fired when the
    download is finished:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`DownloadComplete`事件处理程序，当下载完成时触发：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we have used the **Event-Based Asynchronous Pattern**
    (**EAP**). As you can see, we have subscribed to the `DownloadCompleted` event,
    which will be raised by the `WebClient` class once the download is finished. Then,
    we have made a call to the `DownloadStringAsync` method, which will call the code
    asynchronously and return immediately, avoiding the need to block the thread.
    When the download finishes in the background, the `DownloadComplete` method will
    be called, and we can receive either the error, using the `e.Error` property,
    or the data, using the `e.Result` property of `DownloadStringCompletedEventArgs`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用了**基于事件的异步模式**（**EAP**）。正如您所看到的，我们已经订阅了`DownloadCompleted`事件，该事件将在`WebClient`类完成下载后被触发。然后，我们调用了`DownloadStringAsync`方法，该方法将异步调用代码并立即返回，避免了阻塞线程的需要。当后台下载完成时，将调用`DownloadComplete`方法，我们可以使用`DownloadStringCompletedEventArgs`的`e.Error`属性接收错误，或使用`e.Result`属性接收数据。
- en: If we run the preceding code in a Windows application, the results will be as
    expected, but the response will always be received by a worker thread (which executes
    in the background), and not by the main thread. As Windows application developers,
    we need to be mindful of the fact that we cannot update the UI controls from the `DownloadComplete`
    method, and that all such calls need to be delegated back to the main UI thread
    using techniques such as Invoke in classic Windows Forms, or Dispatcher in **Windows
    Presentation Foundation** (**WPF**). The best thing about using the Invoke/Dispatcher
    approach is that the main thread is never blocked, and the application is, therefore,
    more responsive as a whole.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Windows应用程序中运行上述代码，结果将如预期那样，但响应将始终由工作线程（在后台执行）接收，而不是由主线程接收。作为Windows应用程序开发人员，我们需要注意的是，我们不能从`DownloadComplete`方法更新UI控件，所有这样的调用都需要使用经典Windows
    Forms中的Invoke或WPF中的Dispatcher等技术委托回主UI线程。使用Invoke/Dispatcher方法的最大好处是主线程永远不会被阻塞，因此整个应用程序更加响应。
- en: In the code samples accompanying this book, we have included scenarios for Windows
    Forms as well as for WPF, although .NET Core doesn't yet support Windows applications
    or WPF. This support is expected to be introduced in the next version of Visual
    Studio, VS 2019.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书附带的代码示例中，我们包括了Windows Forms和WPF的场景，尽管.NET Core目前尚不支持Windows应用程序或WPF。预计这种支持将在下一个版本的Visual
    Studio，即VS 2019中引入。
- en: 'Let''s try to run the preceding code in a .NET Core console application from
    the main thread, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在.NET Core控制台应用程序的主线程中运行上述代码，如下所示：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can modify the `DownloadComplete` method by adding a `Console.WriteLine`
    statement, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`DownloadComplete`方法中添加`Console.WriteLine`语句来修改它，如下所示：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: According to the logic, the program should download the page asynchronously,
    print the output, and wait for the user input before it terminates. When we run
    the preceding code, we will see that the program terminates without printing anything
    and without waiting for the user input. Why did this happen?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 根据逻辑，程序应该异步下载页面，打印输出，并在终止之前等待用户输入。当我们运行上述代码时，会发现程序在不打印任何内容且不等待用户输入的情况下终止了。为什么会发生这种情况呢？
- en: As already stated, the main thread gets unblocked as soon as it calls the `DownloadStringAsync`
    method. The main thread doesn't wait for the callback to execute. This is by design,
    and asynchronous methods are expected to behave in this manner. However, since
    the main thread has nothing else to do and has already done what it was expected
    to do, which was calling the method, the application terminates.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，一旦主线程调用`DownloadStringAsync`方法，它就会被解除阻塞。主线程不会等待回调函数执行。这是设计上的考虑，异步方法预期以这种方式行为。然而，由于主线程没有其他事情可做，而且已经完成了它预期要做的事情，即调用方法，应用程序终止了。
- en: 'As a web application developer, you might face a similar problem if you use
    the preceding code in a server-side application using Web Forms or ASP.NET MVC.
    The IIS thread executing your request will return immediately, without waiting
    for the download to finish, if you have called the method asynchronously. The
    results will therefore not be as expected. We are not expecting the code to print
    the output to the console in a web application, and the `Console.WriteLine` statement
    is simply ignored when run in web application code. Suppose your logic is to return
    the web page as a response to the client request. We can achieve this using the `WebClient`
    class synchronously, as shown in the following example, using ASP.NET MVC:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Web应用程序开发人员，如果在使用Web Forms或ASP.NET MVC的服务器端应用程序中使用上述代码，可能会遇到类似的问题。如果您以异步方式调用了该方法，执行您的请求的IIS线程将立即返回，而不会等待下载完成。因此，结果将不如预期。我们不希望代码在Web应用程序中将输出打印到控制台，当在Web应用程序代码中运行时，`Console.WriteLine`语句会被简单地忽略。假设您的逻辑是将网页作为响应返回给客户端请求。我们可以使用ASP.NET
    MVC中的`WebClient`类同步实现这一点，如下例所示：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The problem here is that the preceding code will block the thread, which can
    have an impact on the performance of the server and lead to a self-inflicted **Denial-of-Service**
    (**DoS**) attack, which occurs when a lot of users hit a portion of the application
    concurrently. As more and more threads are hit and become blocked, there will
    be a point at which the server won''t have any threads free to process client
    requests, and will start queueing requests. Once the queue limit is reached, the
    server will start throwing a 503 error: Service Unavailable.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，上述代码将阻塞线程，这可能会影响服务器的性能，并导致自我发起的**拒绝服务**（**DoS**）攻击，当许多用户同时访问应用程序的某一部分时会发生。随着越来越多的线程被命中并被阻塞，将会有一个点，服务器将没有任何空闲线程来处理客户端请求，并开始排队请求。一旦达到队列限制，服务器将开始抛出503错误：服务不可用。
- en: We cannot use the `DownloadStringAsync` method because the moment it is called,
    the thread will return a response back to the client, without waiting for `DownloadComplete`
    to finish. We need a way to make the server thread wait without blocking it. `async`
    and `await` come to our rescue in such a scenario. Apart from helping us to achieve
    our objective, they also help us to have clean code that is easy to write, debug,
    and maintain.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一旦调用`DownloadStringAsync`方法，线程将立即向客户端返回响应，而不等待`DownloadComplete`完成，因此我们无法使用该方法。我们需要一种方法使服务器线程等待而不阻塞它。在这种情况下，`async`和`await`来拯救我们。除了帮助我们实现我们的目标外，它们还帮助我们编写、调试和维护清晰的代码。
- en: To demonstrate `async` and `await`, we can use another important class of .NET
    Core, `HttpClient`, which is available in the `System.Net.Http` namespace. `HttpClient`
    should be used instead of `WebClient`, as it has full support for task-based asynchronous
    operations, has a vastly improved performance, and supports HTTP methods such
    as GET, POST, PUT, and DELETE.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`async`和`await`，我们可以使用.NET Core的另一个重要类`HttpClient`，它位于`System.Net.Http`命名空间中。应该使用`HttpClient`而不是`WebClient`，因为它完全支持基于任务的异步操作，具有大大改进的性能，并支持GET、POST、PUT和DELETE等HTTP方法。
- en: 'Here is an async version of the preceding code, using the `HttpClient` class
    and introducing the `async` and `await` keywords:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`HttpClient`类和引入`async`和`await`关键字的前面代码的异步版本：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we need to change the method signature to include the `async` keyword.
    This is an instruction to the compiler that this method will execute asynchronously
    where necessary. Then, we wrap the return type of the method inside `Task<T>`.
    This is important since .NET Framework supports task-based async operations, and
    all async methods must return `Task`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更改方法签名以包含`async`关键字。这是对编译器的指示，表明该方法将根据需要异步执行。然后，我们将方法的返回类型包装在`Task<T>`中。这很重要，因为.NET
    Framework支持基于任务的异步操作，所有异步方法必须返回`Task`。
- en: 'We need to create an instance of the `HttpClient` class and call the `GetAsync()`
    method, passing the URL of the resource that you want to download. Unlike the
    EAP pattern, which relies on callbacks, we instead just write the `await` keyword
    with the call. This makes sure of the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建`HttpClient`类的一个实例，并调用`GetAsync()`方法，传递要下载的资源的URL。与依赖于回调的EAP模式不同，我们只需在调用时写上`await`关键字。这确保了以下情况：
- en: The method executes asynchronously.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法异步执行。
- en: The calling thread gets unblocked so that it can go back to the thread pool
    and process other client requests, thus making the server responsive.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用线程被解除阻塞，以便它可以返回线程池并处理其他客户端请求，从而使服务器响应。
- en: When the download is complete, the `ThreadPool` receives an interrupt signal
    from the processor, and it will take out a free thread from the `ThreadPool`,
    which can be either the same thread that was operating on the request or a different
    thread.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当下载完成时，`ThreadPool`从处理器接收到中断信号，并从`ThreadPool`中取出一个空闲线程，可以是正在处理请求的相同线程，也可以是不同的线程。
- en: The `ThreadPool` thread receives the response and starts executing the rest
    of the method.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadPool`线程接收到响应并开始执行方法的其余部分。'
- en: When the download finishes, we can read the content that is downloaded by using
    another async operation, called `ReadAsStringAsync()`. This section has shown
    that it is easy to write async methods that resemble their synchronous counterparts,
    making their logic straightforward as well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当下载完成时，我们可以使用另一个异步操作`ReadAsStringAsync()`来读取下载的内容。本节已经表明，编写类似于同步方法的异步方法非常容易，使它们的逻辑也很直接。
- en: The return type of async methods
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步方法的返回类型
- en: 'In the preceding example, we changed the return type of the method from `IAsyncResult`
    to `Task<IAsyncResult>`. There can be three return types from async methods:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们将方法的返回类型从`IAsyncResult`更改为`Task<IAsyncResult>`。异步方法可以有三种返回类型：
- en: '`void`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`'
- en: '`Task`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task`'
- en: '`Task<T>`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task<T>`'
- en: All async methods must return a `Task` in order to be awaited (using the `await`
    keyword). This is because, once you call them, they don't return immediately,
    but rather, they execute a long-running task asynchronously. In doing this, the
    caller thread may switch in and out of context as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有异步方法必须返回一个`Task`以便被等待（使用`await`关键字）。这是因为一旦调用它们，它们不会立即返回，而是异步执行一个长时间运行的任务。在这样做的过程中，调用线程也可能在上下文中切换。
- en: '`void` can be used with asynchronous methods where the caller thread doesn''t
    want to wait. These methods can be any operation that can happen in the background
    that''s not part of the response being returned to the user. For example, logging
    and auditing can be made asynchronous. This means that they can be wrapped inside
    async `void` methods. The caller thread will return immediately on calling the
    operation, and the logging and auditing operations will take place later on. It''s
    thus highly recommended to return a `Task` instead of `void` from asynchronous
    methods.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`可以与调用线程不想等待的异步方法一起使用。这些方法可以是后台发生的任何操作，不是返回给用户的响应的一部分。例如，日志记录和审计可以是异步的。这意味着它们可以包装在异步的`void`方法中。调用操作时，调用线程将立即返回，日志记录和审计操作将稍后进行。因此，强烈建议从异步方法返回`Task`而不是`void`。'
- en: Async delegates and lambda expressions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步委托和lambda表达式
- en: We can use the `async` keyword to create asynchronous delegates and lambda expressions
    as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`async`关键字创建异步委托和lambda表达式。
- en: 'Here is a synchronous delegate that returns the square of a number:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是返回数字的平方的同步委托：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can make the preceding delegate asynchronous by appending the `async` keyword,
    as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加`async`关键字使前面的委托异步化，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, lambda expressions can be converted, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，lambda表达式可以转换如下：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Asynchronous methods work in a chain. Once you have made any one method asynchronous,
    then all methods that call that method need to be converted to being asynchronous
    as well, thus creating a long chain of asynchronous methods.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法在一个链条中工作。一旦你将任何一个方法变成异步方法，那么调用该方法的所有方法也需要被转换为异步方法，从而创建一个长链的异步方法。
- en: Task-based asynchronous patterns
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于任务的异步模式
- en: 'In [Chapter 2](a001ad9c-7e57-4af7-961f-91c1e983b937.xhtml), *Task Parallelism*,
    we discussed how the TAP can be achieved using the `Task` class. There are two
    ways to implement this pattern:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](a001ad9c-7e57-4af7-961f-91c1e983b937.xhtml)中，*任务并行性*，我们讨论了如何使用`Task`类实现TAP。有两种实现这种模式的方法：
- en: The compiler method, using the `async` keyword
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器方法，使用`async`关键字
- en: The manual method
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动方法
- en: Let's see how these methods operate, in the subsequent sections.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在后续章节中看看这些方法是如何操作的。
- en: The compiler method, using the async keyword
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器方法，使用async关键字
- en: When we use the `async` keyword to make any method asynchronous, the compiler
    carries out the required optimization to execute the method asynchronously, using
    the TAP internally. An async method must return either `System.Threading.Task`
    or `System.Threading.Task<T>`. The compiler takes care of executing the method
    asynchronously and returns results or exceptions back to the caller.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`async`关键字使任何方法成为异步方法时，编译器会进行必要的优化，使用TAP在内部异步执行该方法。异步方法必须返回`System.Threading.Task`或`System.Threading.Task<T>`。编译器负责异步执行方法并将结果或异常返回给调用者。
- en: Implementing the TAP manually
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动实现TAP
- en: 'We have already shown how to implement the TAP manually in the EAP and **Asynchronous
    Programming Model** (**APM**). Implementing this pattern gives us more control
    over the overall implementation of the method. We can create a `TaskCompletionSource<TResult>`
    class and then perform an asynchronous operation. When the asynchronous operation
    finishes, we can return the result back to the caller by calling the `SetResult`,
    `SetException`, or `SetCanceled` methods of the `TaskCompletionSource<TResult>`
    class, as shown in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何在EAP和**异步编程模型**（**APM**）中手动实现TAP。实现这种模式可以让我们更好地控制方法的整体实现。我们可以创建一个`TaskCompletionSource<TResult>`类，然后执行一个异步操作。当异步操作完成时，我们可以通过调用`TaskCompletionSource<TResult>`类的`SetResult`、`SetException`或`SetCanceled`方法将结果返回给调用者，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, we created a method returning `Task<int>` that can work
    on any `System.IO.FileStream` object as an extension method. Within the method,
    we created a `TaskCompletionSource<int>` object, and then called the asynchronous
    operation provided by the `FileStream` class to read the file into a byte array.
    If the read operation finishes successfully, we return the results back to the
    caller using the `SetResult` method; otherwise, we return the exceptions using
    the `SetException` method. Finally, the method returns the underlying task from
    the `TaskCompletionSource<int>` object to the caller.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个返回`Task<int>`的方法，可以作为扩展方法在任何`System.IO.FileStream`对象上工作。在方法内部，我们创建了一个`TaskCompletionSource<int>`对象，然后调用`FileStream`类提供的异步操作将文件读入字节数组。如果读取操作成功完成，我们使用`SetResult`方法将结果返回给调用者；否则，我们使用`SetException`方法返回异常。最后，该方法将从`TaskCompletionSource<int>`对象返回底层任务给调用者。
- en: Exception handling with async code
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步代码的异常处理
- en: In the case of synchronous code, all exceptions are propagated to the top of
    the stack until they are handled by a try-catch block or they are thrown as an
    unhandled exception. When we await on any asynchronous method, the call stack
    will not be the same, as the thread has made a transition from the method to the
    thread pool, and is now coming back. C#, however, has made it easier for us to
    do exception handling by changing the exception behavior for async methods. All
    async methods return either `Task` or `void`. Let's try to understand both scenarios
    with examples, and see how the programs will behave.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步代码的情况下，所有异常都会传播到堆栈的顶部，直到它们被try-catch块处理或作为未处理的异常抛出。当我们在任何异步方法上等待时，调用堆栈将不会相同，因为线程已经从方法转换到线程池，并且现在正在返回。然而，C#通过改变异步方法的异常行为，使我们更容易进行异常处理。所有异步方法都返回`Task`或`void`。让我们尝试用例子理解这两种情况，并看看程序的行为。
- en: A method that returns Task and throws an exception
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回Task并抛出异常的方法
- en: 'Let''s say we have the following method, which is `void`. As a best practice,
    we return `Task` from it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下方法，它是`void`。作为最佳实践，我们从中返回`Task`：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The method throws an exception after a delay of two seconds.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在延迟两秒后抛出异常。
- en: 'We will try to call this method using various methods to try to understand
    the behavior of how exceptions are handled for async methods. The following scenarios
    will be discussed in this section:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用各种方法调用此方法，以尝试理解异步方法的异常处理行为。本节将讨论以下场景：
- en: Calling the async method from outside the try-catch block without the `await`
    keyword
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在try-catch块外部调用异步方法，没有使用`await`关键字
- en: Calling the async method from inside the try-catch block without the `await`
    keyword
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在try-catch块内部调用异步方法，没有使用`await`关键字
- en: Calling the async method with the `await` keyword from outside the try-catch
    block
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在try-catch块外部使用await关键字调用异步方法
- en: Methods returning `void`
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`void`的方法
- en: We will see these methods in detail in the subsequent sections.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中详细介绍这些方法。
- en: An async method from outside a try-catch block without the await keyword
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在try-catch块外部调用异步方法，没有使用await关键字
- en: The following is a sample async method that returns a `Task`.  The method, in
    turn, calls another method, `DoSomethingFaulty ()`, which throws an exception.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个返回`Task`的示例异步方法。该方法调用另一个方法`DoSomethingFaulty()`，该方法会抛出异常。
- en: 'Here is our `DoSomethingFaulty()` method implementation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`DoSomethingFaulty()`方法实现：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And here is the code for the `AsyncReturningTaskExample()` method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`AsyncReturningTaskExample()`方法的代码：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is a call to this method from the `Main()` method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从`Main()`方法调用的：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Async main is a handy addition to C# from version 7.1 onward. It became broken
    in release 7.2 but was fixed back in .NET Core 3.0.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 异步主方法是C# 7.1版本以后的一个方便的补充。它在7.2版本中出现了问题，但在.NET Core 3.0中得到了修复。
- en: 'As you can see, the program calls the async method—that is `AsyncReturningTaskExample()`—without
    using the `await` keyword. The `AsyncReturningTaskExample()` method further calls
    the `DoSomethingFaulty()` method, which throws an exception. The following output
    is produced when we run this code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，程序调用了异步方法——即`AsyncReturningTaskExample()`——而没有使用`await`关键字。`AsyncReturningTaskExample()`方法进一步调用了`DoSomethingFaulty()`方法，该方法抛出异常。当我们运行此代码时，将产生以下输出：
- en: '![](img/88073eb0-9010-45f1-838e-1239ced84266.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88073eb0-9010-45f1-838e-1239ced84266.png)'
- en: 'In the case of synchronous programming, the program would have resulted in
    an unhandled exception, and it would have crashed. But here, the program continues
    as if nothing happened. This is due to the way in which `Task` objects are handled
    by the framework. In this case, the task will return to the caller with a Status
    of Faulted, as can be seen in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步编程的情况下，程序会导致未处理的异常，并且会崩溃。但在这里，程序会继续进行，就好像什么都没有发生一样。这是由于框架处理`Task`对象的方式。在这种情况下，任务将以故障状态返回给调用者，如下面的截图所示：
- en: '![](img/27e57487-af51-4fc0-94a8-7c5a17059fa6.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27e57487-af51-4fc0-94a8-7c5a17059fa6.png)'
- en: 'A better code would have been to check the task status and fetch all exceptions
    if there are any:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的代码应该是检查任务状态并在有异常时获取所有异常：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we saw in [Chapter 2](a001ad9c-7e57-4af7-961f-91c1e983b937.xhtml), *Task
    Parallelism*, this task returns an instance of `AggregateExceptions`. To get all
    inner exceptions thrown, we can use the `Flatten()` method, as demonstrated in
    the previous screenshot.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](a001ad9c-7e57-4af7-961f-91c1e983b937.xhtml)中看到的*任务并行性*，这个任务返回一个`AggregateExceptions`的实例。要获取所有抛出的内部异常，我们可以使用`Flatten()`方法，就像在前面的截图中演示的那样。
- en: An async method from inside the try-catch block without the await keyword
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在try-catch块内部没有使用await关键字的异步方法
- en: Let's change the method to move the call to the async method `GetSomethingFaulty()` inside
    the try-catch block, and call from the `Main()` method.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将调用异步方法`GetSomethingFaulty()`的方法移动到try-catch块内，并从`Main()`方法调用。
- en: 'Here is the `Main` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Main`方法：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And here is the `Scenario2CallAsyncWithoutAwaitFromInsideTryCatch()` method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Scenario2CallAsyncWithoutAwaitFromInsideTryCatch()`方法：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This time, we see that the exception will be thrown and received by the catch
    block, after which time the program will resume as normal.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们看到异常将被抛出并被catch块接收，之后程序将正常恢复。
- en: 'It''s worth taking a look at the value of the `Task` object inside the `Main`
    method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一看的是`Main`方法中`Task`对象的值：
- en: '![](img/e97dd4ef-dfcd-4677-b88d-d4e855a6c81b.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e97dd4ef-dfcd-4677-b88d-d4e855a6c81b.png)'
- en: As you can see, if task creation is not carried out inside the try-catch block,
    the exceptions will be unobserved. This can cause issues, since the logic may
    not work as expected. A best practice is to always wrap the task creation inside
    the try-catch block.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果任务创建不在try-catch块内进行，异常将不会被观察到。这可能会导致问题，因为逻辑可能不会按预期工作。最佳实践是始终将任务创建包装在try-catch块内。
- en: As you can see, since the exceptions were handled, the execution returned normally
    from the async method. The status of the returned task becomes `RanToCompletion`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，由于异常已被处理，执行从异步方法正常返回。返回任务的状态变为`RanToCompletion`。
- en: Calling an async method with the await keyword from outside the try-catch block
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用await关键字从try-catch块外部调用异步方法
- en: 'The following code block shows the code for the method that calls the faulty
    method, `DoSomethingFaulty()`, and waits for the method to finish, using the `await`
    keyword:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了调用有错误的方法`DoSomethingFaulty()`并等待方法完成的方法的代码，使用`await`关键字：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And here is the call from the `Main` method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从`Main`方法调用的：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The behavior of the program, in this case, will be the same as in the first
    scenario.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，程序的行为将与第一个场景相同。
- en: Methods returning void
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回void的方法
- en: If the methods return `void` instead of `Task`, the program will crash. You
    can try running the following code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法返回`void`而不是`Task`，程序将崩溃。您可以尝试运行以下代码。
- en: 'Here is a method returning `void` instead of `Task`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个返回`void`而不是`Task`的方法：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And here is a call from the `Main` method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从`Main`方法调用的：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There will be no output, as the program will crash.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不会有输出，因为程序会崩溃。
- en: Although it makes sense to never return `void` from async methods, mistakes
    do happen. We should write code so that it never crashes or only crashes gracefully
    after logging exceptions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从异步方法中返回`void`是没有意义的，但错误确实会发生。我们应该编写代码，使其永远不会崩溃，或者在记录异常后优雅地崩溃。
- en: 'We can handle this globally by subscribing to two global event handlers, as
    follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过订阅两个全局事件处理程序来全局处理这个问题，如下所示：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code will handle all unhandled exceptions in the program, and
    accounts for good practices in exception management. The program should not crash
    randomly, and, if it needs to crash at all, then it should log information and
    clean up all resources.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将处理程序中的所有未处理异常，并考虑了异常管理中的良好实践。程序不应该随机崩溃，如果需要崩溃，那么应该记录信息并清理所有资源。
- en: Async with PLINQ
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PLINQ进行异步
- en: 'PLINQ is a very handy tool for developers, to improve the performance of applications
    by executing a set of tasks in parallel. Creating a number of tasks can improve
    performance, but, if tasks are blocking in nature, then the application will end
    up creating lots of blocking threads and, at some point, will become unresponsive.
    This is especially true if the task is executing some I/O operations. Here is
    a method that needs to download 100 pages from the web as quickly as possible:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ是开发人员非常方便的工具，可以通过并行执行一组任务来提高应用程序的性能。创建多个任务可以提高性能，但是，如果任务具有阻塞性质，那么应用程序最终将创建大量阻塞线程，并且在某些时候会变得无响应。特别是如果任务正在执行一些I/O操作。以下是一个需要尽快从网络下载100页的方法：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, the preceding code, being synchronous, has a complexity of *O(n)*.
    If one request takes one second to finish, the method will take at least 100 seconds
    (n = 100 here).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，上述代码是同步的，具有*O(n)*的复杂度。如果一个请求需要一秒钟才能完成，那么该方法至少需要100秒（n = 100）。
- en: 'To make the download faster (assuming we have a good server configuration that
    can handle this load multiplied by the number of users your application wants
    to support), we need to make this method parallel. We can do this using `Parallel.ForEach`,
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快下载速度（假设我们有一个能够处理此负载的良好服务器配置，乘以应用程序想要支持的用户数量），我们需要并行执行此方法。我们可以使用`Parallel.ForEach`来实现：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Suddenly, the code starts complaining:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 突然，代码开始抱怨：
- en: '*The ''await'' operator can only be used within an async lambda expression.
    Consider marking this lambda expression with the ''async'' modifier.*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*''await''运算符只能在异步lambda表达式中使用。考虑使用''async''修饰符标记此lambda表达式。*'
- en: 'This is because we have used a lambda expression, which needs to be made async
    as well, as shown in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们使用了lambda表达式，它也需要被标记为async，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code will now compile and work as expected, with much-improved performance.
    Talking more about performance in the next section, we will dig more deeply into
    how to measure the performance of asynchronous code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码将会编译并按预期工作，性能得到了大幅提升。在下一节中，我们将更深入地讨论异步代码性能的测量方法。
- en: Measuring the performance of async code
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量异步代码的性能
- en: Async code can improve the performance and responsiveness of applications, but
    there are trade-offs. In the case of GUI-based applications, such as Windows Forms
    or WPF, if a method is taking a long time, it makes sense to make it async. For
    server applications, however, you need to measure the trade-off between the extra
    memory utilized by the blocked threads and the extra processor overhead required
    to make methods asynchronous.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 异步代码可以提高应用程序的性能和响应性，但也存在一些权衡。在基于GUI的应用程序（如Windows Forms或WPF）中，如果一个方法花费了很长时间，将其标记为异步是有意义的。然而，对于服务器应用程序，您需要权衡受阻线程所使用的额外内存和使方法异步所需的额外处理器开销之间的权衡。
- en: 'Consider the following code, which creates three tasks. Each task runs asynchronously,
    one after another. As one method finishes, it goes on to execute another task
    asynchronously. The total time taken to finish the method can be calculated using
    `Stopwatch`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它创建了三个任务。每个任务都是异步运行的，一个接一个地执行。当一个方法完成时，它会继续异步执行另一个任务。使用`Stopwatch`可以计算完成方法所需的总时间：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/c0d8cd2f-b74e-4b8c-ba02-0640678401d6.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0d8cd2f-b74e-4b8c-ba02-0640678401d6.png)'
- en: 'This is as good as writing synchronous code. The benefit is that the thread
    is not blocked, but the overall performance of the application is poor since all
    code now runs synchronously. We could change the preceding code to improve the
    performance, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这与编写同步代码一样好。好处是线程不会被阻塞，但应用程序的整体性能较差，因为所有代码现在都是同步运行的。我们可以改变上述代码以提高性能，如下所示：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see, this is a better use of Parallel and async to get an improved
    performance:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是更好地使用并行和异步以获得更好的性能：
- en: '![](img/f7c04eec-fc9f-43ca-8fe3-a329e7f7046b.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7c04eec-fc9f-43ca-8fe3-a329e7f7046b.png)'
- en: To understand async better, we also need to understand which thread runs our
    code. Since new async APIs work with the `Task` class, all the calls are executed
    by the `ThreadPool` thread. When we make async calls—say, to fetch data from a
    network—the control gets transferred to the I/O completion port thread, which
    is managed by the OS. Usually, this is only one thread that is shared across all
    network requests. When the I/O request completes, the OS fires an interrupt signal
    that adds a job to the queue of the I/O completion port. In the case of server-side
    applications, which usually work in **Multi-Threaded Apartment** (**MTA**) mode,
    any thread can start an async request and any other thread can receive it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解异步，我们还需要了解哪个线程运行我们的代码。由于新的异步API与`Task`类一起工作，所有调用都由`ThreadPool`线程执行。当我们进行异步调用时，比如从网络获取数据，控制权会转移到由操作系统管理的I/O完成端口线程。通常，这只是一个线程，跨所有网络请求共享。当I/O请求完成时，操作系统会触发中断信号，将作业添加到I/O完成端口的队列中。在通常以**多线程公寓**（**MTA**）模式工作的服务器端应用程序中，任何线程都可以启动异步请求，任何其他线程都可以接收它。
- en: In the case of Windows applications, however, (including both WinForms and WPF),
    which work in **Single-Threaded Apartment** (**STA**) mode, it becomes important
    that an async call gets returned to the same thread that started it (normally
    a UI thread). Every UI thread in a Windows application has a `SynchronizationContext` that
    makes sure that the code is always executed by the correct thread. This is important
    due to control ownership. To avoid cross-threading issues, only the owner thread
    can change the values of the controls. The most important method of the `SynchronizationContext`
    class is `Post`, which can make a delegate run in the right context, thus avoiding
    cross-threading issues.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows应用程序的情况下（包括WinForms和WPF），它们以**单线程公寓**（STA）模式工作，因此异步调用返回到启动它的同一线程（通常是UI线程）变得很重要。Windows应用程序中的每个UI线程都有一个`SynchronizationContext`，它确保代码始终由正确的线程执行。这对于控件所有权很重要。为了避免跨线程问题，只有所有者线程才能更改控件的值。`SynchronizationContext`类的最重要方法是`Post`，它可以使委托在正确的上下文中运行，从而避免跨线程问题。
- en: Whenever we await a task, the current `SynchronizationContext` is captured.
    Then, when the method needs to be resumed, the `await` keyword internally uses
    the `Post` method to resume the method in the captured `SynchronizationContext`.
    Calling the `Post` method is very costly, however, but there is a built-in performance
    optimization provided by the framework. The `Post` method doesn't get called if
    the captured `SynchronizationContext` is the same as the current `SynchronizationContext` of
    the returning thread.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们等待一个任务时，当前的`SynchronizationContext`都会被捕获。然后，当方法需要恢复时，`await`关键字在内部使用`Post`方法在捕获的`SynchronizationContext`中恢复方法。然而，调用`Post`方法非常昂贵，但框架提供了内置的性能优化。如果捕获的`SynchronizationContext`与返回线程的当前`SynchronizationContext`相同，则不会调用`Post`方法。
- en: 'If we are writing a class library and we don''t really care about which `SynchronizationContext` the
    call will be returned to, we can completely turn off the `Post` method. We can
    achieve this by calling the `ConfigureAwait()` method on the returning task, as
    follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在编写一个类库，并且我们并不真的关心调用将返回到哪个`SynchronizationContext`，我们可以完全关闭`Post`方法。我们可以通过在返回的任务上调用`ConfigureAwait()`方法来实现这一点，如下所示：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So far, we have learned the important aspects of asynchronous programming. We
    now need to know the guidelines for using async code while programming!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了异步编程的重要方面。现在我们需要了解在编程时使用异步代码的指南！
- en: Guidelines for using async code
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步代码的指南
- en: 'Some guidelines/best practices while writing with asynchronous code are the
    following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写异步代码时的一些建议/最佳实践如下：
- en: Avoid using async void.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用异步void。
- en: Async chain all the way.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步链一直延续。
- en: Use `ConfigureAwait` wherever possible.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下使用`ConfigureAwait`。
- en: We will learn more about these in the following sections.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的部分中了解更多。
- en: Avoid using async void
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用异步void
- en: We have already seen how returning `void` from async methods actually affects
    the exception handling. Async methods should return `Task` or `Task<T>` so that
    exceptions can be observed and not become unhandled.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到从异步方法返回`void`实际上会影响异常处理。异步方法应该返回`Task`或`Task<T>`，以便可以观察异常并且不会变成未处理的异常。
- en: Async chain all the way
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步链一直延续
- en: 'Mixing async and blocking methods will have an impact on performance. Once
    we decide to make a method async, the entire chain of methods that are supposed
    to be called from that method should be made async as well. Not doing so can sometimes
    result in a deadlock, as demonstrated in the following code example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 混合异步和阻塞方法会影响性能。一旦决定将方法设置为异步，从该方法调用的整个方法链也应该设置为异步。不这样做有时会导致死锁，如下面的代码示例所示：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If we call the `Deadlock()` method from any ASP.NET or GUI-based application,
    it would create a deadlock, although the same code would run fine in a console
    application. When we call the `DelayAsync()` method, it captures the current `SynchronizationContext`,
    or the current `TaskScheduler` if the `SynchronizationContext` is null. When the
    awaited task is complete, it tries to execute the remainder of the method with
    the captured context. The problem here is that there is already a thread that's
    waiting synchronously for the async method to finish. In this situation, both
    threads will be waiting for the other thread to finish, thus causing a deadlock. This
    problem is raised only in GUI-based or ASP.NET applications because they rely
    on the `SynchronizationContext` that can only execute one chunk of code at a time. Console
    applications, on the other hand, utilize `ThreadPool` instead of `SynchronizationContext`.
    When the await finishes, the pending async method part is scheduled on a `ThreadPool`
    thread. The method is completed on a separate thread and returns the task back
    to the caller, so there is no deadlock.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从任何ASP.NET或基于GUI的应用程序中调用`Deadlock()`方法，它将创建死锁，尽管相同的代码在控制台应用程序中可以正常运行。当我们调用`DelayAsync()`方法时，它会捕获当前的`SynchronizationContext`，或者如果`SynchronizationContext`为null，则捕获当前的`TaskScheduler`。当等待的任务完成时，它会尝试使用捕获的上下文执行方法的其余部分。问题在于已经有一个线程在同步等待异步方法完成。在这种情况下，两个线程都将等待另一个线程完成，从而导致死锁。这个问题只会在基于GUI或ASP.NET的应用程序中出现，因为它们依赖于只能一次执行一块代码的`SynchronizationContext`。另一方面，控制台应用程序使用`ThreadPool`而不是`SynchronizationContext`。当等待完成时，挂起的异步方法部分被安排在`ThreadPool`线程上。该方法在单独的线程上完成并将任务返回给调用者，因此不会发生死锁。
- en: Never try to create sample `async`/`await` code in a console application and
    copy and paste it in a GUI or ASP.NET application, as they have different models
    for executing async code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在控制台应用程序中尝试创建示例`async`/`await`代码，然后将其复制粘贴到GUI或ASP.NET应用程序中，因为它们有不同的执行异步代码的模型。
- en: Using ConfigureAwait wherever possible
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在可能的情况下使用ConfigureAwait
- en: 'We could have avoided deadlock in the preceding code example by completely
    skipping the use of `SynchronizationContext`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过完全跳过使用`SynchronizationContext`来避免前面代码示例中的死锁：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When we use `ConfigureAwait(false)`, the method is awaited. When the await completes,
    the processor tries to execute the rest of the async method within the thread
    pool context. The method is able to complete with no issues since there are no
    blocking contexts. The method completes its returned task, and there's no deadlock.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`ConfigureAwait(false)`时，该方法会被等待。当等待完成时，处理器会尝试在线程池上下文中执行剩余的异步方法。由于没有阻塞上下文，该方法能够顺利完成。该方法完成了其返回的任务，没有死锁。
- en: We have come to the end of this chapter. Let's now see all we have learned!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了本章的结尾。现在让我们看看我们学到了什么！
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed two very important constructs that make writing
    asynchronous code very easy. All the heavy work is done by the compiler when we
    use these keywords, and the code looks very similar to its synchronous counterpart.
    We also discussed which thread the code runs on when we make methods asynchronous,
    and the performance penalty associated with utilizing `SynchronizationContext`.
    Finally, we looked at how we can turn off the `SynchronizationContext` completely
    to improve performance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了两个非常重要的构造，使得编写异步代码变得非常容易。当我们使用这些关键字时，所有繁重的工作都是由编译器完成的，代码看起来与其同步对应物非常相似。我们还讨论了当我们使方法异步化时，代码运行在哪个线程上，以及利用`SynchronizationContext`会带来的性能损失。最后，我们看了如何完全关闭`SynchronizationContext`以提高性能。
- en: In the next chapter, we will introduce parallel debugging techniques using Visual
    Studio. We will also learn the tools available in Visual Studio to help in parallel
    code debugging.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍使用Visual Studio进行并行调试技术。我们还将学习Visual Studio中可用的工具，以帮助并行代码调试。
- en: Questions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What keyword is used to unblock a thread inside async methods?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在异步方法中，用什么关键字来解除线程阻塞？
- en: '`async`'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`异步`'
- en: '`await`'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`await`'
- en: '`Thread.Sleep`'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Thread.Sleep`'
- en: '`Task`'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task`'
- en: Which of the following are valid return types for async methods?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是异步方法的有效返回类型？
- en: '`void`'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`无`'
- en: '`Task`'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task`'
- en: '`Task<T>`'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task<T>`'
- en: '`IAsyncResult`'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IAsyncResult`'
- en: '`TaskCompletionSource<T>` can be used to implement a task-based async pattern
    manually.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TaskCompletionSource<T>`可以用来手动实现基于任务的异步模式。'
- en: 'True'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假
- en: Can we write `Main` methods as async?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将`Main`方法写成异步的吗？
- en: 'Yes'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是
- en: 'No'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不
- en: Which property of the `Task` class can be used to check whether an exception
    has been thrown by an async method?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task`类的哪个属性可以用来检查异步方法是否抛出了异常？'
- en: '`IsException`'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IsException`'
- en: '`IsFaulted`'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IsFaulted`'
- en: We should always use `void` as a return type for async methods.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该总是将`void`作为异步方法的返回类型使用。
- en: 'True'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假
