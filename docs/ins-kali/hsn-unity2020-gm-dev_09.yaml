- en: '*Chapter 9*: Fullscreen Effects with postprocessing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：使用后期处理的全屏效果'
- en: So far, we have created different objects to alter the visuals of our scene,
    such as meshes, particles, and lights. We can tweak the settings of those objects
    here and there to improve our scene quality, but you will always feel that something
    is missing when comparing it with modern game scenes, and that is fullscreen or
    postprocessing effects. In this chapter, you will learn how to apply effects to
    the final rendered frame, which will alter the look of the overall scene.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了不同的对象来改变场景的视觉效果，例如网格、粒子和灯光。我们可以在这里和那里调整这些对象的设置，以改善我们的场景质量，但是当与现代游戏场景进行比较时，您总会感到缺少某些东西，即全屏或后期处理效果。在本章中，您将学习如何将效果应用于最终渲染的帧，这将改变整个场景的外观。
- en: 'In this chapter, we will examine the following image effect concepts:'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下图像效果概念：
- en: Using postprocessing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '](img/Figure_9.03_B14199.jpg)'
- en: Using advanced effects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级效果
- en: Using postprocessing
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用后期处理
- en: '**postprocessing** is a Unity feature that allows us to apply several effects
    (a stack of effects) one on top of the other, which will alter the final look
    of an image. Each one will affect the finished frame, changing the colors in it
    based on different criteria. In the following screenshots, you can see a scene
    before and after applying image effects. You will notice a dramatic difference,
    but that scene doesn''t have any change in its objects, including lights, particles,
    or meshes. The effects applied are based on pixel analysis. Have a look at both
    scenes here:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**后期处理**是Unity的一个功能，允许我们应用多种效果（一堆效果）叠加在一起，这将改变图像的最终外观。每个效果都会影响完成的帧，根据不同的标准改变其中的颜色。在以下截图中，您可以看到应用图像效果之前和之后的场景。您会注意到明显的差异，但是该场景的对象，包括灯光、粒子或网格，都没有任何变化。应用的效果是基于像素分析的。在这里看看两个场景：'
- en: '![Figure 9.1 A scene without image effects (left) and the same scene with effects
    (right)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1没有图像效果的场景（左）和具有效果的相同场景（右）'
- en: '](img/Figure_9.01_B14199(merged).jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.01_B14199(merged).jpg)'
- en: Figure 9.1 – A scene without image effects (left) and the same scene with effects
    (right)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1-没有图像效果的场景（左）和具有效果的相同场景（右）
- en: Something to take into account is that the previous postprocessing solution,
    **postprocessing Stack version 2** (**PPv2**) won't work on the **Universal Render
    Pipeline** (**URP**); it has its own postprocessing implementation, so we will
    see that one in this chapter. Anyway, they are very similar, so even if you are
    using PPv2, you can still get something from this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的是，以前的后期处理解决方案**postprocessing Stack version 2**（**PPv2**）在**Universal Render
    Pipeline**（**URP**）上无法使用；它有自己的后期处理实现，因此我们将在本章中看到它。无论如何，它们非常相似，因此即使您使用PPv2，您仍然可以从本章中获得一些东西。
- en: 'In this section, we will discuss the following URP postprocessing concepts:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下URP后期处理概念：
- en: Setting up a profile
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置配置文件
- en: Using basic effects
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基本效果
- en: Let's start preparing our scene to apply effects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始准备我们的场景应用效果。
- en: Setting up a profile
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置配置文件
- en: To start applying effects, we need to create a **Profile**, it being an Asset
    containing all the effects and settings we want to apply. This is a separated
    asset for the same reason the Material also is, because we can share the same
    post-processing profile across different scenes and parts of scenes. When we refer
    to parts of the scenes, we are referring to volumes or areas of the game that
    have certain effects applied. We can define a global area that applies effects
    regardless of the position of the player, or we can apply different effects—for
    example, when we are outdoors or indoors.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始应用效果，我们需要创建一个**Profile**，它是一个包含我们想要应用的所有效果和设置的资产。出于与材质相同的原因，这是一个单独的资产，因为我们可以在不同的场景和场景部分之间共享相同的后期处理配置文件。当我们提到场景的部分时，我们指的是应用了某些效果的体积或游戏区域。我们可以定义一个全局区域，无论玩家的位置如何都会应用效果，或者我们可以应用不同的效果-例如，当我们在室外或室内时。
- en: 'In this case, we will use a global volume, one that we will use to apply a
    profile with our first effect, by doing the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用全局体积，我们将使用它来应用我们的第一个效果配置文件，方法如下：
- en: Create a new empty Game Object (**GameObject** | **Create Empty**).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空游戏对象（**GameObject** | **Create Empty**）。
- en: Name it as `PP Volume` (meaning postprocessing Volume).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`PP Volume`（表示后期处理体积）。
- en: Add the **Volume** component to it.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Volume**组件添加到其中。
- en: Make sure the **Mode** is set to **Global**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保**Mode**设置为**Global**。
- en: Click on the **New** button at the right of the **Profile** setting, which will
    generate a new Profile Asset named like our object (PPVolume Profile). You can
    later move that to its own folder, which is recommended for Asset organization
    purposes. The process is illustrated in the following screenshot:![Figure 9.2
    Volume component
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Profile**设置右侧的**New**按钮，这将生成一个名为我们对象的新配置文件资产（PPVolume Profile）。您可以稍后将其移动到自己的文件夹中，这是为了资产组织目的而推荐的。该过程如下截图所示：![图9.2体积组件
- en: '](img/Figure_9.02_B14199.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.02_B14199.jpg)'
- en: Figure 9.2 – Volume component
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2-体积组件
- en: To test if the volume is working, let's add an effect. Click the **Add Override**
    button, and select the **postprocessing** | **Chromatic Aberration** option.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试体积是否起作用，让我们添加一个效果。单击**Add Override**按钮，然后选择**postprocessing** | **Chromatic
    Aberration**选项。
- en: Check the `0.5`, as illustrated in the following screenshot:![Figure 9.3 Chromatic
    aberration effect
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`0.5`，如下截图所示：![图9.3色差效果
- en: '](img/Figure_9.03_B14199.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用后期处理
- en: Figure 9.3 – C Chromatic aberration effect
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3-色差效果
- en: Now, you will see an aberration effect being applied in the corners of the image.
    Remember to look at this in the Scene Panel; we will apply the effect to the Game
    View in the next step. This is illustrated in the following screenshot:![Figure
    9.4 Chromatic aberration applied to the scene
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将看到图像的角落应用了一种像差效果。请记住在场景面板中查看这一点；我们将在下一步中将效果应用于游戏视图。这在以下截图中有所说明：![图9.4应用于场景的色差
- en: '](img/Figure_9.04_B14199.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.04_B14199.jpg)'
- en: Figure 9.4 – Chromatic aberration applied to the scene
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 - 应用到场景中的色差
- en: 'Now, if you hit `Main Camera`, you will see that the effect is not being applied,
    and that''s because we need to check the `Main Camera`, as illustrated in the
    following screenshot:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你点击`Main Camera`，你会发现效果没有被应用，这是因为我们需要勾选`Main Camera`，如下面的截图所示：
- en: '![Figure 9.5 Enabling post-processing'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 启用后期处理'
- en: '](img/Figure_9.05_B14199.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.05_B14199.jpg)'
- en: Figure 9.5 – Enabling post-processing
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 - 启用后期处理
- en: So, we have created a global volume, which will apply the effects specified
    as overrides to the entire scene regardless of the player position.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了一个全局体积，它将将指定的效果作为覆盖应用到整个场景，而不管玩家的位置如何。
- en: Now that we have prepared our scene to use postprocessing, we can start experimenting
    with different effects. Let's start with the simplest ones in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好使用后期处理来准备我们的场景，我们可以开始尝试不同的效果。让我们从下一节中最简单的效果开始。
- en: Using basic effects
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基本效果
- en: Now that we have postprocessing in our scene, the only thing needed is to start
    adding effects and set them up until we have the desired look and feel. In order
    to do that, let's explore several simple effects included in the system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在场景中有了后期处理，唯一需要做的就是开始添加效果并设置它们，直到我们得到期望的外观和感觉。为了做到这一点，让我们探索系统中包含的几种简单效果。
- en: 'Let''s start with **Chromatic Aberration**, the one we just used, which, as
    with most image effects, tries to replicate a particular real-life effect. All
    game-engine rendering systems use a simple mathematical approximation of how eye
    vision really works, and because of that, we don''t have some effects that occur
    in the human eyes or camera lenses. A real camera lens works by bending light
    rays to point them toward the camera sensors, but that bending is not perfect
    in some lenses (sometimes intentionally), and, hence, you can see a distortion,
    as shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**色差**开始，这是我们刚刚使用的效果，与大多数图像效果一样，它试图复制特定的真实效果。所有游戏引擎渲染系统都使用了眼睛视觉真实工作的简单数学近似，因此我们没有一些发生在人眼或相机镜头中的效果。真实的相机镜头通过弯曲光线来将其指向相机传感器，但在一些镜头中（有时是故意的），这种弯曲并不完美，因此你会看到一些失真，如下面的截图所示：
- en: '![Figure 9.6 Image without chromatic aberration (left) and same image with
    chromatic aberration (right)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 没有色差的图像（左）和有色差的相同图像（右）'
- en: '](img/Figure_9.06_B14199(merged).jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.06_B14199(merged).jpg)'
- en: Figure 9.6 – I1mage without chromatic aberration (left) and the same image with
    chromatic aberration (right)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 - 没有色差的图像（左）和有色差的相同图像（右）
- en: 'This effect will be one of several that we will add to generate a cinematic
    feeling in our game, simulating the usage of real-life cameras. Of course, this
    effect won''t look nice in every kind of game; maybe a simplistic cartoonish style
    won''t benefit from this one, but you never know: art is subjective, so it''s
    a matter of trial and error.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个效果将是我们添加的几个效果之一，以在游戏中产生一种电影感，模拟真实相机的使用。当然，这种效果并不适合每种类型的游戏；也许简单的卡通风格不会从中受益，但你永远不知道：艺术是主观的，所以这是一个试错的过程。
- en: Also, we have exaggerated the intensity a little bit in the previous example
    to make the effect more noticeable, but I would recommend using an intensity of
    0.25 in this scenario. It is usually recommended to be gentle with the intensity
    of the effects; it's tempting to have intense effects, but as you will be adding
    lots of them, after a while the image will be bloated, with too many distortions.
    So, try to add several subtle effects instead of a few intense ones. But, again,
    this depends on the target style you are looking for; there are no absolute truths
    here (but common sense still applies).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在上一个例子中夸大了强度，以使效果更加明显，但我建议在这种情况下使用强度为0.25。通常建议对效果的强度要温和；强烈的效果很诱人，但当你添加了很多效果之后，图像会变得臃肿，扭曲太多。因此，尽量添加一些微妙的效果，而不是少量强烈的效果。但是，这取决于你所追求的目标风格；在这里没有绝对的真理（但常识仍然适用）。
- en: Finally, before moving on to discuss other effects, if you are used to using
    other kinds of postprocessing effects frameworks, you will notice that this version
    of chromatic aberration has fewer settings, and that's because the URP version
    seeks performance, so it will be as simple as possible.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在讨论其他效果之前，如果你习惯使用其他类型的后期处理效果框架，你会注意到这个版本的色差设置较少，这是因为URP版本追求性能，所以尽可能简单。
- en: 'The next effect we are going to discuss is **Vignette**. This is another camera-lens
    imperfection where the image intensity is lost at the edges of the lens. This
    can be applied not only to simulate older cameras but also to draw the attention
    of the user toward the center of the camera—for example, during cinematics. Also,
    if you are developing **virtual reality** (**VR**) applications, this can be used
    to reduce motion sickness by reducing the peripheral vision of the player. In
    the following screenshot, you can see an example of vignetting on an old camera:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要讨论的效果是**晕影**。这是另一个相机镜头的缺陷，图像强度在镜头边缘会丢失。这不仅可以用来模拟旧相机，还可以吸引用户的注意力集中在相机的中心，比如在电影中。此外，如果你正在开发**虚拟现实**（**VR**）应用程序，这可以通过减少玩家的外围视觉来减轻晕动病。在下面的截图中，你可以看到一个旧相机上晕影的例子：
- en: '![Figure 9.7 Photo taken with an old camera, with vignetting over the edges'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 使用旧相机拍摄的照片，边缘有晕影'
- en: '](img/Figure_9.07_B14199.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.07_B14199.jpg)'
- en: Figure 9.7 – Photo taken with an old camera, with vignetting over the edges
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 - 使用旧相机拍摄的照片，边缘有晕影
- en: 'Just to try it, let''s apply some vignetting to our scene by doing the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 只是试试，让我们通过以下方式向我们的场景应用一些晕影：
- en: Select the `PP Volume` GameObject.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`PP Volume`游戏对象。
- en: Add the **postprocessing** | **Vignette** effect by clicking on the **Add Override**
    button.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**添加覆盖**按钮添加**后期处理** | **晕影**效果。
- en: Check the `0.3`, increasing the effect.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`0.3`，增加效果。
- en: 'Check the `0.5`; this will increase the spread of the effect. You can see the
    result in the following screenshot:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`0.5`；这将增加效果的扩散。您可以在下面的截图中看到结果：
- en: '![Figure 9.8 Vignette effect'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 晕影效果'
- en: '](img/Figure_9.08_B14199.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.08_B14199.jpg)'
- en: Figure 9.8 – Vignette effect
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 晕影效果
- en: If you want, you can change the color by checking the `Center` and `Rounded`,
    work as `Particles`. You can create nice effects just playing with the values.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以通过勾选`Center`和`Rounded`，以`Particles`的方式工作。您可以通过调整数值来创建漂亮的效果。
- en: 'Another effect we are going to review in this basics section is **Motion Blur**,
    and again, it simulates the way the cameras work. A camera has an exposure time,
    the time it needs to capture photons to get each frame. When an object moves fast
    enough, the same object is placed in different positions during that brief exposure
    time, so it will appear blurred. In the following screenshot, you can see the
    effect applied to our scene. In the case of this image, we are rotating the camera
    up and down fast, with the following result:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个基础部分中审查的另一个效果是**运动模糊**，再次模拟相机的工作方式。相机有一个曝光时间，它需要捕捉光子以获得每一帧。当一个物体移动得足够快时，在那短暂的曝光时间内，同一个物体会处于不同的位置，因此它会显得模糊不清。在下面的截图中，您可以看到该效果应用到我们的场景中。在这张图片中，我们快速上下旋转相机，得到以下结果：
- en: '![Figure 9.9 Motion Blur being applied to our scene'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9 将运动模糊应用到我们的场景中'
- en: '](img/Figure_9.09_B14199.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.09_B14199.jpg)'
- en: Figure 9.9 Motion Blur being applied to our scene
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 将运动模糊应用到我们的场景中
- en: One thing to consider is that this blur will only be applied to the camera movement
    and not the movement of the objects (still camera, moving objects), due to the
    fact that this URP doesn't support motion vectors yet.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一件事是，这种模糊只会应用于相机的移动，而不是物体的移动（静止相机，移动物体），因为URP目前不支持运动矢量。
- en: 'In order to use this effect, follow these next steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此效果，请按照以下步骤进行：
- en: Add the **Post-processing** | **Motion Blur** override with the **Add override**
    button.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Post-processing** | **Motion Blur**覆盖，点击**Add override**按钮。
- en: Check the `0.5`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`0.5`。
- en: 'Rotate the camera while seeing the Game View (not the Scene View). You can
    click and drag the **X** property of the **Transform** of the camera (not the
    value—the **X** label), as illustrated in the following screenshot:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查看游戏视图时旋转相机（而不是场景视图）。您可以单击并拖动相机的**Transform**的**X**属性（不是值，而是**X**标签），如下面的截图所示：
- en: '![Figure 9.10 Changing rotation](img/Figure_9.10_B14199.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 改变旋转](img/Figure_9.10_B14199.jpg)'
- en: Figure 9.10 – Changing rotation
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 改变旋转
- en: As you can see, this effect cannot be seen in the Scene View, as well as other
    effects, so take that into account before concluding the effect is not working.
    Unity does this because it would be very annoying to have that effect while working
    in the scene.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这种效果在场景视图中是看不到的，其他效果也是如此，因此在得出效果不起作用的结论之前，请考虑这一点。Unity之所以这样做，是因为在场景中工作时，拥有这种效果会非常恼人。
- en: 'Finally, we are going to briefly discuss two final simple effects, **Film Grain**
    and **White Balance**. The first is pretty simple: add it, set the intensity to
    1, and you will get the famous grain effect from the old movies. You can set the
    **Type** with different sizes to make it more subtle or obvious. White Balance
    allows you to change the color temperature, making colors warmer or cooler depending
    on how you configure it. In our case, we are working in a cold dark scene, so
    you can add it and set the temperature to -20 to adjust the appearance just slightly,
    and improve the look and feel in this kind of scene.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将简要讨论两个最终简单的效果，**胶片颗粒**和**白平衡**。第一个非常简单：添加它，将强度设置为1，您将得到老电影中著名的颗粒效果。您可以通过不同大小的**Type**来使其更加微妙或明显。白平衡允许您改变色温，根据您的配置使颜色变得更温暖或更凉爽。在我们的情况下，我们正在处理一个寒冷的黑暗场景，因此您可以添加它并将温度设置为-20，稍微调整外观，改善这种场景的外观和感觉。
- en: Now that we have seen a few of the simple effects, let's check out a few of
    the remaining ones, which are affected by some advanced rendering features.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了一些简单的效果，让我们来看看剩下的一些受一些高级渲染特性影响的效果。
- en: Using advanced effects
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高级效果
- en: The effects we are going to see in this section don't differ a lot from the
    previous ones; they are just a little bit trickier and need some background to
    properly use them. So, let's dive into them!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中看到的效果与之前的效果并没有太大的区别；它们只是有点棘手，需要一些背景知识才能正确使用它们。所以，让我们深入了解它们！
- en: In this section, we are going to see the advanced effect concepts of
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到高级效果概念
- en: '**High Dynamic Range** (**HDR**) and Depth Maps.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**高动态范围**（**HDR**）和深度图。'
- en: Advanced effects
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级效果
- en: Let's start by discussing some requirements for some of these effects to work
    properly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论一些这些效果正常工作所需的要求。
- en: HDR and Depth Map
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HDR和深度图
- en: 'Some effects not only work with the rendered image but also need additional
    data. We can first discuss the **Depth Map**, a concept we already discussed in
    the previous chapter. To do a recap, a Depth Map is an image rendered from the
    point of view of the camera, but instead of generating a final image of the scene,
    it renders the scene objects'' depth, rendering the objects in shades of gray.
    The darker the color, the further from the camera the pixel is, and vice versa.
    In the following screenshot, you can see an example of a depth map:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有些效果不仅适用于渲染图像，还需要额外的数据。我们首先讨论**深度图**，这是我们在上一章中已经讨论过的概念。简而言之，深度图是从相机的视角渲染的图像，但它不是生成场景的最终图像，而是渲染场景对象的深度，以灰度渲染对象。颜色越深，像素距离相机越远，反之亦然。在下面的截图中，您可以看到深度图的一个示例：
- en: '![Figure 9.11 – Depth map of a few primitive shapes'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.11 – 几何图形的深度图'
- en: '](img/Figure_9.11_B14199.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.11_B14199.jpg)'
- en: Figure 9.11 – Depth map of a few primitive shapes
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – 几何图形的深度图
- en: We will see some effects such as **Depth of Field**, which will blur some parts
    of the image based on the distance of the camera, but it can be used for several
    purposes on custom effects (not in the base URP package).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一些效果，比如**景深**，它会根据相机的距离模糊图像的某些部分，但它可以用于自定义效果的几个目的（不在基本URP包中）。
- en: Another concept to discuss here that will alter how colors are treated and,
    hence, how some effects work is HDR. In older hardware, color channels (red, green,
    and blue) were encoded in a 0 to 1 range, 0 being no intensity and 1 being full
    intensity (per channel), so all lighting and color calculations were done in that
    range. That seems okay but doesn't reflect how light actually works. You can see
    full white (all channels set to 1) in a piece of paper being lit by sunlight,
    and you can see full white when you look directly at a light bulb, but even if
    both light and paper are of the same color, the latter will, first, irritate the
    eye after a while, and secondly, will have some overglow due to an excess of light.
    The problem here is that the maximum value (1) is not enough to represent the
    most intense color, so if you have a high-intensity light and another with even
    more intensity, both will generate the same color (1 in each channel) because
    calculations cannot go further than 1\. So, that's why **HDR Rendering** was created.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要讨论的另一个概念会改变颜色的处理方式，因此也会改变一些效果的工作方式，那就是HDR。在旧的硬件中，颜色通道（红色、绿色和蓝色）被编码在0到1的范围内，0表示没有强度，1表示完全强度（每个通道），因此所有照明和颜色计算都是在该范围内进行的。这似乎没问题，但并不反映光的实际工作方式。您可以看到一张纸被阳光照射时呈现全白（所有通道设置为1），当您直接看灯泡时也会看到全白，但即使光和纸都是相同的颜色，后者首先会在一段时间后刺激眼睛，其次，由于光线过多，会有一些过亮。问题在于最大值（1）不足以表示最强烈的颜色，因此，如果您有一个高强度的光和另一个甚至更高强度的光，由于计算无法超过1，两者都将生成相同的颜色（每个通道中的1）。这就是为什么创建了**HDR渲染**。
- en: 'HDR is a way for colors to exceed the 0.1 range, so lighting and effects that
    work based on color intensity have better accuracy in this mode. It is the same
    idea of the new TV feature with the same name, although in this case, Unity will
    do the calculations in HDR, but the final image will still work using the previous
    color space (0 to 1, or **Low Dynamic Range (LDR**), so don''t confuse Unity''s
    **HDR Rendering** with the **Display''s HDR**. To convert the HDR calculations
    back to LDR, Unity (and also TVs) uses a concept called **tonemapping**. You can
    see an example of an LDR-rendered scene and tonemapping being used in an HDR scene
    in the following screenshots:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: HDR是一种使颜色超出0.1范围的方式，因此基于颜色强度工作的照明和效果在此模式下具有更好的准确性。这与具有相同名称的新电视功能的想法相同，尽管在这种情况下，Unity将以HDR进行计算，但最终图像仍将使用先前的颜色空间（0到1，或**低动态范围（LDR）**），因此不要将Unity的**HDR渲染**与**显示的HDR**混淆。要将HDR计算转换回LDR，Unity（以及电视）使用了一个称为**色调映射**的概念。您可以在以下屏幕截图中看到一个LDR渲染的场景和色调映射在HDR场景中的应用示例：
- en: '![Figure 9.12 An LDR-rendered scene (left) and an HDR scene with corrected
    overbrights using tonemapping (right)](img/Figure_9.12_B14199(Merged).jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12 左边是LDR渲染的场景，右边是使用色调映射校正过亮的HDR场景](img/Figure_9.12_B14199(Merged).jpg)'
- en: Figure 9.12 – An LDR-rendered scene (left) and an HDR scene with corrected overbrights
    using tonemapping (right)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12-左边是LDR渲染的场景，右边是使用色调映射校正过亮的HDR场景
- en: Tonemapping is a way to bring colors outside the 0.1 range back to it. It basically
    uses some formulas and curves to determine how each color channel should be mapped
    back. You can clearly see this in the typical darker-to-lighter scene transition,
    such as when you exit a building without windows to go out into a bright day.
    For a time, you will see everything lighter until everything goes back to normal.
    The idea here is that calculations are not different when you are inside or outside
    the building; a white wall inside the building will have a color near the 1 intensity,
    while the same white wall outside will have a higher value (due to sunlight).
    The difference is that tonemapping will take the higher-than-1 color back to 1
    when you are outside the building, and maybe it will increase the lighting of
    the wall inside if all the scene is darker, depending on how you set it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 色调映射是一种将颜色从0.1范围之外带回到其中的方法。它基本上使用一些公式和曲线来确定如何映射每个颜色通道。您可以在典型的从暗到亮的场景转换中清楚地看到这一点，比如当您走出没有窗户的建筑物，走到明亮的一天。有一段时间，您会看到一切变得更亮，直到一切恢复正常。这里的想法是，当您在建筑物内外时，计算并不不同；建筑物内的白墙将具有接近1强度的颜色，而外面的同样白墙将具有更高的值（由于阳光）。不同之处在于，当您在建筑物外时，色调映射将把高于1的颜色带回到1，并且根据您的设置，如果整个场景较暗，可能会增加建筑物内墙壁的照明。
- en: 'Even if HDR is enabled by default, let''s just see how we can check that, by
    doing the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 即使HDR默认启用，让我们看看如何通过以下方式检查：
- en: Go to **Edit** | **Project Settings**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**编辑** | **项目设置**。
- en: Click on the **Graphics Settings** section in the left panel.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击左侧面板中的**图形设置**部分。
- en: Click the asset referenced under the **Scriptable Render Pipeline Settings**
    property.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**脚本渲染管线设置**属性下引用的资产。
- en: Click on the highlighted asset in the Project Panel. Ensure that this panel
    is visible before clicking the property in the **Graphics** settings.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击项目面板中突出显示的资产。在单击**图形**设置中的属性之前，请确保此面板可见。
- en: 'Under the **Quality** section, ensure that **HDR** is checked, as illustrated
    in the following screenshot:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**质量**部分，确保**HDR**已被选中，如下面的屏幕截图所示：
- en: '![Figure 9.13 Enabling HDR'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13 启用HDR'
- en: '](img/Figure_9.13_B14199.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.13_B14199.jpg)'
- en: Figure 9.13 – Enabling HDR
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13-启用HDR
- en: Of course, the fact that HDR is togglable means that there are scenarios where
    you don't want to use it. As you can guess, not all hardware supports HDR, and
    using it incurs a performance overhead, so take that into account. Luckily, most
    effects work with both HDR and LDR color ranges, so if you have HDR enabled but
    the user device doesn't support it, you won't get any errors, just different results.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，HDR是可切换的，这意味着有些情况下您可能不想使用它。正如您可以猜到的，不是所有的硬件都支持HDR，并且使用它会带来性能开销，所以请考虑这一点。幸运的是，大多数效果都适用于HDR和LDR颜色范围，因此如果您启用了HDR但用户设备不支持它，您不会遇到任何错误，只是会得到不同的结果。
- en: Now that we are sure we have HDR enabled, let's explore some advanced effects
    that use this and Depth Mapping.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们确定已启用HDR，让我们探索一些使用这个和深度映射的高级效果。
- en: 'Let''s see certain effects that use the previously described techniques, starting
    with the commonly used Bloom. This effect, as usual, emulates the overglow that
    happens around a heavily lit object on a camera lens or even the human eye. In
    the following screenshots, you can see the difference between the default version
    of our scene and an exaggerated Bloom version. You can observe how the effect
    is only applied to the brightest areas of our scene. Have a look at both effects
    here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些使用先前描述的技术的特定效果，首先是常用的Bloom。这种效果通常模拟相机镜头或甚至人眼周围发生的强烈照明物体的过度发光。在下面的截图中，您可以看到我们场景的默认版本和夸张的Bloom版本之间的差异。您可以观察到效果只应用于我们场景最明亮的区域。在这里看看这两种效果：
- en: '![Figure 9.14 The default scene (left) and the same scene with a high-intensity
    Bloom (right)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 默认场景（左）和相同场景的高强度Bloom（右）'
- en: '](img/Figure_9.14_B14199(Merged).jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.14_B14199(Merged).jpg)'
- en: Figure 9.14 – The default scene (left) and the same scene with a high-intensity
    Bloom (right)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 - 默认场景（左）和相同场景的高强度Bloom（右）
- en: 'This effect is actually very common and simple, but I considered it advanced
    because the results are drastically affected by HDR. This effect relies on calculating
    the intensity of each pixel''s color to detect areas where it can be applied.
    In LDR, we can have a white object that isn''t actually overbright, but due to
    the limitations in this color range, Bloom may cause an overglow over it. In HDR,
    due to its increased color range, we can detect if an object is white or if the
    object is maybe light blue but just overbright, generating the illusion that it
    is white (such as objects near a high-intensity lamp). In the following screenshot,
    you can see the difference between our scene with HDR and without it. You will
    notice that the LDR version will have overglow in areas that are not necessarily
    overlit. The difference may be very subtle, but pay attention to the little details
    to note the difference. And remember, I exaggerated the effect here. Have a look
    at both scenes here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果实际上非常普遍和简单，但我认为它是高级的，因为结果受到HDR的影响很大。这种效果依赖于计算每个像素的颜色强度，以便检测可以应用它的区域。在LDR中，我们可能有一个白色的物体，实际上并不是过亮的，但由于这种颜色范围的限制，Bloom可能会在其上产生过度发光。在HDR中，由于其增加的颜色范围，我们可以检测物体是否是白色，或者物体可能是浅蓝色但只是过亮，产生了它是白色的错觉（比如在高强度灯附近的物体）。在下面的截图中，您可以看到我们的场景在启用HDR和未启用HDR时的区别。您会注意到LDR版本会在不一定是过亮的区域产生过度发光。差异可能非常微妙，但请注意细节以注意到差异。记住，我在这里夸大了效果。在这里看看两个场景：
- en: '![Figure 9.15 – Bloom in an LDR scene (left) and Bloom in an HDR scene (right).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15 - LDR场景中的Bloom（左）和HDR场景中的Bloom（右）。'
- en: '](img/Figure_9.15_B14199(Merged).jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.15_B14199(Merged).jpg)'
- en: Figure 9.15 – Bloom in an LDR scene (left) and Bloom in an HDR scene (right).
    Notice that the Bloom settings were changed to try to approximate them as much
    as possible
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 - LDR场景中的Bloom（左）和HDR场景中的Bloom（右）。请注意，Bloom设置已更改，以尽量接近它们
- en: 'For now, let''s stick with the HDR version of the scene. In order to enable
    Bloom, do the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续使用场景的HDR版本。为了启用Bloom，执行以下操作：
- en: Add the **Bloom** override to the profile, as usual.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，将**Bloom**覆盖添加到配置文件中。
- en: Enable the `1.5`. This controls how much overglow will be applied.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用`1.5`。这控制着将应用多少过度发光。
- en: Enable `0.7`. This value indicates the minimum intensity a color needs to have
    to be considered for overglow. In our case, our scene is somewhat dark, so we
    need to reduce this value in the Bloom effect settings to have more pixels included.
    As usual, those values need to be adjusted to your specific scenario.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用`0.7`。这个值表示颜色需要具有的最小强度，才能被认为是过度发光。在我们的情况下，我们的场景有点暗，所以我们需要在Bloom效果设置中减少这个值，以包括更多的像素。通常情况下，这些值需要根据您的具体情况进行调整。
- en: 'You will notice that the difference is very subtle, but again, remember that
    you will have several effects, so all those little differences will sum up. You
    can see both effects in the following screenshots:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到差异非常微妙，但再次记住，您将有几种效果，所以所有这些小差异将累积起来。您可以在以下截图中看到这两种效果：
- en: '![Figure 9.16 – Bloom effect'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16 - Bloom效果'
- en: '](img/Figure_9.16_B14199(Merged).jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.16_B14199(Merged).jpg)'
- en: Figure 9.16 – Bloom effect
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 - Bloom效果
- en: As usual, it is recommended for you to fiddle with the other values. Some interesting
    settings I recommend you to test are the **Dirt Texture** and **Dirt Intensity**
    values.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，建议您调整其他值。我建议您测试一些有趣的设置，比如**Dirt Texture**和**Dirt Intensity**值。
- en: 'Now, let''s move to another common effect, **Depth of Field**. This one relies
    on the depth map we discussed earlier. It is not that obvious to the naked eye,
    but when you focus on an object within your sight, the surrounding objects became
    blurred because they are out of focus. We can use this to focus the attention
    of the player in key moments of the gameplay. This effect will sample the Depth
    Map to see if the object is within the focus range; if it is, no blur will be
    applied, and vice versa. In order to use it, do the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转移到另一个常见的效果，**景深**。这个效果依赖于我们之前讨论过的深度图。肉眼并不那么明显，但当你专注于视野内的一个物体时，周围的物体会变得模糊，因为它们失焦了。我们可以利用这一点来在游戏玩法的关键时刻引起玩家的注意。这个效果将对深度图进行采样，以查看物体是否在焦点范围内；如果是，就不会应用模糊效果，反之亦然。为了使用它，做如下操作：
- en: This effect depends on the camera positioning of your game. To test it, in this
    case, we will put the camera near a column to try to focus on that specific object,
    as illustrated in the following screenshot:![Figure 9.17 – Camera positioning
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个效果取决于你的游戏摄像机定位。在这种情况下，我们将把摄像机放在柱子附近，以尝试专注于特定物体，如下截图所示：![图9.17 – 摄像机定位
- en: '](img/Figure_9.17_B14199.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.17_B14199.jpg)'
- en: Figure 9.17 – Camera positioning
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 – 摄像机定位
- en: Add the **Depth of Field** override.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加**景深**覆盖。
- en: 'Enable and set the **Mode** setting to **Gaussian**: the simplest one to use.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用并将**模式**设置为**高斯**：这是最简单的模式。
- en: In my case, I have set `10` and `20`, which will make the effect start at a
    distance behind the target object. The **End** setting will control how the blur´s
    intensity will increase, reaching its maximum at a distance of 20 meters. Remember
    to tweak these values to your case.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我的情况下，我设置了`10`和`20`，这将使效果从目标物体后面的一定距离开始。**结束**设置将控制模糊的强度增加，达到最大值时距离为20米。记得根据你的情况调整这些值。
- en: 'If you want to exaggerate the effect a little bit, set `1.5`. The result is
    shown in the following screenshot:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想稍微夸张效果，设置为`1.5`。结果如下截图所示：
- en: '![Figure 9.18 Exaggerated effect'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.18 夸张效果'
- en: '](img/Figure_9.18_B14199.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.18_B14199.jpg)'
- en: Figure 9.18 – Exaggerated effect
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 – 夸张效果
- en: Something to consider here is that our particular game will have a top-down
    perspective, and unlike the first-person camera, where you can see distant objects,
    here we will have objects near enough to not notice the effect, so we can limit
    the use of this effect just for cutscenes in our scenario.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要考虑的一点是，我们的特定游戏将采用俯视视角，与第一人称摄像机不同，你可以看到远处的物体，而在这里，物体足够近以至于不会注意到效果，所以我们可以将这个效果限制在剧情场景中使用。
- en: 'Now, most of the remaining effects are different ways to alter the actual colors
    of the scene. The idea is that the real color sometimes doesn''t give you the
    exact look and feel you are seeking. Maybe you need the dark zones to be darker
    to reinforce the sensation of a horror ambience, or maybe you want to do the opposite:
    increase the lightness of dark areas to represent an open scene. Maybe you want
    to tint the highlights a little bit to get a neon effect if you are creating a
    futuristic game, or perhaps you want a sepia effect temporarily, to do a flashback.
    We have a myriad ways to do this, and in this case, I will use a simple but powerful
    effect called **Shadow, Midtones, Highlights**.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的大部分效果都是改变场景实际颜色的不同方式。思路是，真实的颜色有时并不能给你想要的精确外观和感觉。也许你需要让暗区域更暗，以加强恐怖氛围的感觉，或者你想做相反的事情：增加暗区域的亮度，以代表一个开放的场景。也许你想给高光着色一点，以获得霓虹效果，如果你正在创建一个未来主义游戏，或者也许你想暂时使用棕褐色效果，进行一个回忆。我们有无数种方法可以做到这一点，在这种情况下，我将使用一个简单但强大的效果，叫做**阴影、中间色调、高光**。
- en: 'This effect will apply different color corrections to—well —Shadows, Midtones,
    and Highlights, meaning that we can modify darker, lighter, and medium areas separately.
    Let''s try it by doing the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个效果将对**阴影**、**中间色调**和**高光**应用不同的颜色校正，这意味着我们可以分别修改较暗、较亮和中等区域。让我们尝试一下：
- en: Add the **Shadow, Midtones, Highlights** override.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加**阴影、中间色调、高光**覆盖。
- en: Let's start doing some testing. Check the three **Shadows**, **Midtones**, and
    **Highlights** checkboxes.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始做一些测试。勾选三个**阴影**、**中间色调**和**高光**复选框。
- en: Move the **Shadow** and **Midtones** sliders all the way to the left and the
    one for **Highlights** to the right. This will reduce the intensity of Shadows
    and Midtones and increase the intensity of Highlights. We did this so that you
    can see the areas that **Highlights** will alter, based on their intensity (this
    can also be an interesting effect in a horror game). You can do the same with
    the rest of the sliders to check the other two areas. You can see the result in
    the following screenshot:![Figure 9.19 – Isolating highlights
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**阴影**和**中间色调**滑块全部向左移动，将**高光**的滑块向右移动。这将减少阴影和中间色调的强度，并增加高光的强度。我们这样做是为了让你看到**高光**会根据其强度改变的区域（这在恐怖游戏中也可能是一个有趣的效果）。你可以用其他滑块做同样的操作来检查其他两个区域。你可以在下面的截图中看到结果：![图9.19
    – 高光隔离
- en: '](img/Figure_9.19_B14199.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.19_B14199.jpg)'
- en: Figure 9.19 – Isolating highlights
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19 – 高光隔离
- en: Also, you can test moving the white circle at the center of the colored circle
    to apply a little bit of tinting to those areas. Reduce the intensity of the highlights
    by moving the slider a little bit to the left to make the tinting more noticeable.
    You can see the result in the following screenshot:![Figure 9.20 – Tinting highlights
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，你可以尝试移动彩色圆圈中心的白色圆圈，对这些区域进行轻微着色。将滑块稍微向左移动以减少高光的强度，使着色效果更加明显。你可以在下面的截图中看到结果：![图9.20
    – 高光着色
- en: '](img/Figure_9.20_B14199.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.20_B14199.jpg)'
- en: Figure 9.20 – Tinting highlights
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 – 高光着色
- en: By doing this, you can explore how those controls work, but of course, those
    extreme values are useful for some edge cases. In our scene, the settings you
    can see in the following screenshot worked best for me. As always, it is better
    to use subtler values to not distort too much the original result, as illustrated
    here:![Figure 9.21 – Subtle changes
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这样做，您可以探索这些控件的工作方式，但当然，这些极端值对于某些边缘情况是有用的。在我们的场景中，您可以在下面的屏幕截图中看到的设置对我来说效果最好。一如既往，最好使用更微妙的值，以不要过度扭曲原始结果，如下所示：![图9.21
    – 微妙的变化
- en: '](img/Figure_9.21_B14199.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.21_B14199.jpg)'
- en: Figure 9.21 – Subtle changes
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21 – 微妙的变化
- en: 'You can see the before-and-after effects in the following screenshots:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是屏幕截图中的前后效果：
- en: '![Figure 9.22 – Before-and-after effects'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.22 – 前后效果'
- en: '](img/Figure_9.22_B14199(Merged).jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.22_B14199(Merged).jpg)'
- en: Figure 9.22 – Before-and-after effects
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22 – 前后效果
- en: You have other simpler options such as **Split Toning**, which does something
    similar but just with Shadows and Highlights, or **Color Curves**, which give
    you advanced control of how each color channel of the scene will be mapped, but
    the idea is the same—that is, to alter the actual color of the resulting scene
    to apply a specific color ambience to your scene. If you remember the movie series
    *The Matrix,* when the characters were in the Matrix, everything had subtle green
    tinting and, while outside it, the tinting was blue.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您还有其他更简单的选项，比如**分割调色**，它做的事情类似，但只涉及阴影和高光，或者**颜色曲线**，它可以让您更高级地控制场景的每个颜色通道将如何映射，但其思想是相同的——即改变结果场景的实际颜色，以赋予您的场景特定的色彩氛围。如果您还记得电影系列*黑客帝国*，当角色在矩阵中时，一切都带有微妙的绿色色调，而在外面时，色调是蓝色的。
- en: Remember that the results of using HDR and not using it regarding these effects
    is important, so it is better to decide sooner rather than later whether to use
    HDR, excluding certain target platforms (which may not be important to your target
    audience), or not to use it (using LDR) and have less control over your scene
    lighting levels.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用HDR和不使用它对于这些效果的结果是重要的，因此最好尽早决定是否使用HDR，排除某些目标平台（这可能对您的目标受众不重要），或者不使用它（使用LDR）并且对场景的光照水平控制较少。
- en: Also, take into account that maybe you will need to tweak some object's settings,
    such as light intensities and material properties, because sometimes we use postprocessing
    to fix graphics errors that may be caused by wrongly set objects, and that's not
    okay. For example, increasing the Ambient Lighting in our scene will drastically
    change the output of the effects, and we can use that to increase the overall
    brightness instead of using an effect if we find the scene too dark.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还要考虑到，也许您需要调整一些对象的设置，比如光强度和材质属性，因为有时我们使用后期处理来修复可能由错误设置的对象引起的图形错误，这是不好的。例如，增加场景中的环境光照会大大改变效果的输出，我们可以利用这一点来增加整体亮度，而不是使用效果，如果我们发现场景太暗。
- en: This has covered the main image effects to use. Remember that the idea is not
    to use every single one but to use the ones that you feel are contributing to
    your scene; they are not free in terms of performance (although not that resource-intensive),
    so use them wisely. Also, you can check for the already created profiles to apply
    them to your game and see how little changes can make a huge difference.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了要使用的主要图像效果。请记住，不是使用每一个效果，而是使用您认为对您的场景有贡献的效果；它们在性能方面并不是免费的（尽管不是那么资源密集），所以要明智地使用它们。此外，您可以查看已创建的配置文件，将它们应用到您的游戏中，看看微小的变化如何产生巨大的影响。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed basic and advanced fullscreen effects to apply
    in our scene, making it look more realistic in terms of camera-lens effects and
    more stylish in terms of color distortions. We also discussed the internals of
    HDR and Depth Maps and how they are important when using those effects, which
    can immediately increase your game's graphic quality with minimal effort.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在我们的场景中应用的基本和高级全屏效果，使其在相机镜头效果方面看起来更真实，在颜色扭曲方面更时尚。我们还讨论了HDR和深度图的内部结构，以及在使用这些效果时它们的重要性，这可以立即提高您游戏的图形质量，而付出的努力却很少。
- en: Now that we have covered most of the common graphics found in Unity systems,
    let's start looking at how to increase the immersion of our scene, using sounds.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了Unity系统中常见的大部分图形，让我们开始看看如何通过声音增强我们场景的沉浸感。
