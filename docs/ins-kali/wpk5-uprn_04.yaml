- en: APIs, Plugins, and Loaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API、插件和加载器
- en: An **Application Programming Interface** (**API**) is typically used for interfaces
    between remotely stationed programs, such as when a company offers partial access
    to their website's functionality as part of an integrated system through, say,
    a mobile app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**API**）通常用于远程站点程序之间的接口，例如当公司通过移动应用程序部分访问其网站功能作为集成系统的一部分时。'
- en: Webpack seeks to compile and optimize localized code, so knowing the difference
    between localized code and an external API is essential for operating the software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 旨在编译和优化本地化代码，因此了解本地化代码和外部 API 之间的区别对于操作软件至关重要。
- en: Plugins and loaders are similar. A loader essentially instructs Webpack on how
    to handle specific tasks involved in more unusual programming languages and bundling.
    Loaders are often developed by the user community, rather than by in-house Webpack developers.
    Plugins, on the other hand, offer some of the processes that loaders don't currently
    offer and so are more general in their operation than loaders. A concise explanation
    of each feature with detailed examples will follow during the course of this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 插件和加载器类似。加载器基本上指示 Webpack 如何处理与更不寻常的编程语言和捆绑相关的特定任务。加载器通常由用户社区开发，而不是内部 Webpack
    开发人员开发。另一方面，插件提供了一些加载器目前不提供的过程，因此在其操作上比加载器更通用。本章将在课程中提供每个功能的简明解释和详细示例。
- en: Webpack 5 offers developers a rich plugin interface. Most of the features within
    Webpack use this plugin interface, making Webpack quite flexible to use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 5 提供了丰富的插件接口。Webpack 中的大多数功能都使用这个插件接口，使得 Webpack 非常灵活。
- en: This chapter will explore plugins, loaders, and APIs, as well as the salience
    of each and how each feature plays its part in the operation of Webpack.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨插件、加载器和 API，以及每个的重要性以及每个功能在 Webpack 操作中的作用。
- en: 'The topics discussed in this chapter are as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的主题如下：
- en: Loaders
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载器
- en: APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API
- en: Plugins
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件
- en: Loaders
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载器
- en: Loaders are fundamental to Webpack and many of them enable greater functionality,
    particularly with scripts and frameworks that are not native ECMAScripts, such
    as JavaScript and JSON.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器对于 Webpack 是基础的，其中许多加载器使得更多功能成为可能，特别是对于不是原生 ECMAScript 的脚本和框架，比如 JavaScript
    和 JSON。
- en: This chapter aims to give you a broad overview of the available loaders as well
    as some that you may need to buy. When working with a salient or unique code that
    is specific to your project, you should search the Webpack online registry to
    ensure that the code can be transpiled.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在为您提供可用加载器的广泛概述，以及您可能需要购买的一些加载器。当处理与您的项目特定的显著或独特的代码时，您应该搜索 Webpack 在线注册表，以确保代码可以被转译。
- en: 'In particular, this section will discuss the following loaders:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，本节将讨论以下加载器：
- en: '`cache-loader`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache-loader`'
- en: '`coffee-loader`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coffee-loader`'
- en: '`coffee-redux-loader`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coffee-redux-loader`'
- en: '`worker-loader`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`worker-loader`'
- en: '`cover.js`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cover.js`'
- en: '`i18n-loader`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i18n-loader`'
- en: '`imports-loader`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imports-loader`'
- en: '`polymer-webpack-loader`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`polymer-webpack-loader`'
- en: '`script-loader`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script-loader`'
- en: '`source-map-loader`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source-map-loader`'
- en: '`less-loader`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`less-loader`'
- en: We'll discuss and give examples of each loader, where appropriate, although
    some may need no real elaboration. Let's begin with `cache-loader`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论并举例说明每个加载器，如果适用的话，尽管有些可能不需要真正的详细说明。让我们从 `cache-loader` 开始。
- en: cache-loader
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cache-loader
- en: 'Caching is something that we alluded to in the previous chapter. `cache-loader`
    allows caches to be made from a loader. We can set it up as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是我们在上一章中提到的内容。`cache-loader` 允许从加载器创建缓存。我们可以按照以下方式设置它：
- en: 'Begin by installing the loader through the **Command-Line Interface** (**CLI**),
    as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先通过**命令行界面**（**CLI**）安装加载器，如下所示：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that other loaders are executed in our configuration (see the following
    code) and a cache will be made of any of the resulting outputs made by the loader
    that start with `cache-loader`. This will be made, by default, in the project
    folder but can also be configured to be made in the cache in a database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的配置中执行了其他加载器（请参见以下代码），并且将由以 `cache-loader` 开头的任何加载器生成的任何输出进行缓存。默认情况下，这将在项目文件夹中进行，但也可以配置为在数据库中进行。
- en: 'To configure this, use `webpack.config.js`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要配置此内容，请使用 `webpack.config.js`：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that where `cache-loader` is placed in the configuration is where it should
    always be placed, ahead of other loaders.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`cache-loader` 放置在配置中的位置应该始终放在其他加载器之前。
- en: That explains the installation and use of `cache-loader`. We'll go through a
    few other loaders in the same way, starting with `worker-loader`. As it will need
    to be declared first, we should discuss it first, even though it is always used
    in a chain or sequence with other loaders.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了安装和使用 `cache-loader`。我们将以相同的方式介绍其他几个加载器，从 `worker-loader` 开始。虽然它总是与其他加载器以链式或序列的方式使用，但由于它需要首先声明，因此我们应该首先讨论它。
- en: worker-loader
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: worker-loader
- en: '`worker-loader` essentially gives the developer a solution for getting the
    program to handle large computation tasks in the background. To get the loader
    up and running, we will take the following steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`worker-loader` 本质上为开发人员提供了一个解决方案，用于在后台处理大型计算任务。要使加载器运行起来，我们将采取以下步骤：'
- en: 'To begin with, use the command line to install `worker-loader`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用命令行安装 `worker-loader`：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, there is an inline way to import `worker-loader` from the `App.js`
    file. In this file, which is present in any Webpack project directory, make the
    following amendment, if it hasn''t been done already:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，还有一种内联方式从 `App.js` 文件导入 `worker-loader`。在任何 Webpack 项目目录中的这个文件中，如果还没有进行以下修改，可以进行以下修改：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you have imported the loader, perform a configuration using `webpack.config.js`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦导入了加载器，就使用 `webpack.config.js` 进行配置：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`use` refers to the configuration needed to allow access to the loader.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`use` 指的是允许访问加载器所需的配置。'
- en: 'Write the following code in `App.js` to allow this file to be an export location
    for the loader:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `App.js` 中编写以下代码，以允许该文件成为加载器的导出位置：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code also adds an `event` listener to allow testing later in the
    development console.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码还添加了一个`event`监听器，以便以后在开发控制台中进行测试。
- en: 'Finally, run Webpack via your preferred method to see the results:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过您喜欢的方法运行Webpack以查看结果：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should see `worker-loader` installed and imported from `App.js` if you chose
    that method. This can be observed in the console window or by viewing the page
    source.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择了该方法，您应该看到`worker-loader`已安装并从`App.js`导入。这可以在控制台窗口中观察到，也可以通过查看页面源代码来观察到。
- en: This gives you a couple of choices for utilizing `worker-loader`, either through
    the command-line utility or through the configuration of the `App.js` file. Next,
    we'll discuss `coffee-loader`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这为您提供了两种使用`worker-loader`的选择，可以通过命令行实用程序或通过`App.js`文件的配置。接下来，我们将讨论`coffee-loader`。
- en: coffee-loader
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coffee-loader
- en: CoffeeScript is a simplified form of JavaScript, but it isn't exactly JavaScript,
    so a loader must be used to work with it in Webpack.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CoffeeScript是JavaScript的简化形式，但它并不完全是JavaScript，因此必须使用加载器才能在Webpack中使用它。
- en: 'Let''s go through the following steps to be able to use `coffee-loader`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来使用`coffee-loader`：
- en: 'Begin by installing `coffee-loader`. To install the loader, use the following
    command line:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先安装`coffee-loader`。要安装加载器，请使用以下命令行：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Ensure that you are using the recommended configuration of the loader for the
    sake of testing and to use the `literate` key. To allow testing, load `coffee-loader` and
    set the `literate` key to `true`. The `literate` key will ensure that the loader''s
    usage is interpreted by the compiler :'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您正在使用推荐的加载器配置进行测试，并使用`literate`键。为了进行测试，加载`coffee-loader`并将`literate`键设置为`true`。`literate`键将确保加载器的使用由编译器解释：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code in the preceding example shows how the loader can be used and a new
    rule set up.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例中的代码显示了如何使用加载器以及设置新规则。
- en: 'Should you need it, we will show you how to install `coffee-redux`. **Redux**
    is an open source library for managing JavaScript application states. It is frequently
    used with libraries such as **React** and **Angular**. To install it, type the
    following command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，我们将向您展示如何安装`coffee-redux`。**Redux**是用于管理JavaScript应用程序状态的开源库。它经常与**React**和**Angular**等库一起使用。要安装它，请键入以下命令：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding example will not only help you understand the procedure for installing
    and using CoffeeScript in your bundles but also how the procedure works for the
    loaders that are not mentioned here, as they work in pretty much the same way.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例不仅将帮助您了解在包中安装和使用CoffeeScript的过程，还将帮助您了解这里未提及的加载器的工作原理，因为它们的工作方式基本相同。
- en: You will see, however, that the shorthand installation and development mode
    for setting the command line has been used— `i` and `-D`, respectively. This works,
    in most cases, although you may find that there is now a response when there is
    a compatibility issue between your command-line utility and the Webpack version
    you are using.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您会看到，已经使用了快捷安装和开发模式来设置命令行—`i`和`-D`。在大多数情况下，这是有效的，尽管您可能会发现，在您的命令行实用程序与您使用的Webpack版本之间存在兼容性问题时，现在会有响应。
- en: Doing things this way can save you time, but when in doubt, use the verbose
    command-line convention demonstrated in this guide.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式做事可以节省您的时间，但是如果有疑问，请使用本指南中演示的冗长命令行约定。
- en: Now, let's move on to `coverjs`, which works a little differently.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向`coverjs`，它的工作方式略有不同。
- en: coverjs
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: coverjs
- en: '`coverjs` allows your code to be instrumented. This essentially means it allows
    your code to be measured or monitored in terms of performance.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`coverjs`允许对您的代码进行仪器化。这基本上意味着它允许对您的代码进行性能测量或监视。'
- en: The `coverjs` loader does not need to be combined with `mocha-loader`, as it
    is independent. The `reportHtml` function will append to the output of the body.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`coverjs`加载器不需要与`mocha-loader`结合使用，因为它是独立的。`reportHtml`函数将附加到输出的主体部分。'
- en: 'In the following example, `webpackOptions.js` is the subject of the code. In
    the first set of curly braces (`{`) are the options related to the module export
    procedures. In the double-set of braces (`[{`) is the code that binds the `coverjs`
    loader and the `test:""` statement (which indicates that every file will be tested):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`webpackOptions.js`是代码的主题。在第一组花括号（`{`）中是与模块导出程序相关的选项。在双花括号（`[{`）中是绑定`coverjs`加载器和`test:""`语句的代码（表示每个文件都将被测试）：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, this particular loader has its options set through a local file.
    Amendments to this will have the same effect as the configuration discussed in
    the previous chapter. That should be all you need to get `coverjs` up and running
    in your application. Next up is a more complicated topic, involving the use of
    international languages.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个特定的加载器通过本地文件设置了它的选项。对此的修改将产生与上一章讨论的配置相同的效果。这应该是您在应用程序中启动`coverjs`所需的全部内容。接下来是一个更复杂的主题，涉及使用国际语言。
- en: i18n-loader
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: i18n-loader
- en: '`i18n-loader` deals with internationalization (`i18n`), which is the process
    of preparing an application so that it supports local languages and cultural settings.
    Let''s set it up by going through the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`i18n-loader`处理国际化（`i18n`），这是准备应用程序以支持本地语言和文化设置的过程。让我们通过以下步骤进行设置：'
- en: 'Begin with the command-line installation:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行安装开始：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s start by using CSS. We will set up our style sheet for use with
    `i18n`**. **This is done with our usual project style sheet, `css/styles.css`.
    It''s fine if you are importing another style sheet; just make the alterations
    there:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们从使用CSS开始。我们将为`i18n`**设置我们的样式表。**这是通过我们通常的项目样式表`css/styles.css`完成的。如果您导入另一个样式表，也可以在那里进行修改：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The loader can be called, assuming our locale is `de-de-berlin` (the German
    language and regional settings, for the sake of this example).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的区域设置是`de-de-berlin`（德语语言和区域设置，以此为例），现在可以调用加载器。
- en: 'Next, we will localize the color scheme for our code in the `i18n` setting
    by using the `index.js` file:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过使用`index.js`文件为`i18n`设置本地化代码的颜色方案：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, wait for the status to be ready. This is only required once for all locales because
    all locales of the same language are merged into one module chunk:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，等待状态准备就绪。这只需要一次，因为同一语言的所有区域设置都会合并成一个模块块：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is usually all done in the same file as previously. The preceding code
    will append a child node to the `locale` variable in the `console.log` function,
    which will help with testing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这都是在与之前相同的文件中完成的。前面的代码将在`console.log`函数中的`locale`变量中添加一个子节点，这将有助于测试。
- en: 'Now, configure the loader with `webpack.config.js` and make use of the related
    options available. As there are also options with this loader, you should tell
    the loader about all your locales, if you want to load them once and then want
    to use them synchronously:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`webpack.config.js`配置加载器，并利用相关的可用选项。由于该加载器也有选项，如果你想要一次加载所有区域设置并且想要同步使用它们，你应该告诉加载器所有的区域设置：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note the `// "bundleTogether": false` statement in the preceding code—this can
    be uncommented and set to disable the bundling of locales.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意前面代码中的`// "bundleTogether": false`语句，这可以取消注释并设置为禁用区域设置的捆绑。'
- en: 'There are alternative calls. The following code chooses the correct file by
    locale:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他的调用方式。以下代码通过区域设置选择正确的文件：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, this will not merge the objects. In the following code, the first
    line will concatenate all the locales that fit and the second line will merge
    the resulting objects:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这不会合并对象。在下面的代码中，第一行将连接所有符合条件的区域设置，第二行将合并生成的对象：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As a result, `./file.js` in the preceding code block is executed while compiling:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的代码块中，编译时会执行`./file.js`：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code block simply reinforces the regular expression. It ensures
    that either of the `require` statements will load the same file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块只是加强了正则表达式。它确保`require`语句中的任何一个都会加载相同的文件。
- en: Don't forget to polyfill `require` if you want to use it in Node.js. See the
    *Further reading* section at the end of this chapter for the relevant Webpack
    documentation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Node.js中使用`require`，不要忘记进行polyfill。请参阅本章末尾的*进一步阅读*部分，了解相关的Webpack文档。
- en: The previous code blocks simply adjusted your project so that it is compatible
    with German-language territories with a German-speaking audience. Next up is `imports-loader`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块只是调整了你的项目，使其与德语领土和德语听众兼容。接下来是`imports-loader`。
- en: imports-loader
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: imports-loader
- en: '`imports-loader` allows you to use modules that depend on specific global variables.
    This is useful for third-party modules that may rely on global variables. `imports-loader`
    can add the necessary `require` calls, making them work with Webpack. Let''s set
    it up by going through the following steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`imports-loader`允许你使用依赖于特定全局变量的模块。这对于可能依赖于全局变量的第三方模块很有用。`imports-loader`可以添加必要的`require`调用，使它们能够与Webpack一起工作。让我们通过以下步骤进行设置：'
- en: 'To install the loader in the command line, use the following statement:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在命令行中安装加载器，请使用以下语句：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Assuming that you have the `example.js` file, this loader allows you to append
    an imported script to image tags using jQuery, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有`example.js`文件，这个加载器允许你使用jQuery将导入的脚本附加到图像标签中，如下所示：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `$` variable can then be injected into the module by configuring `imports-loader`,
    as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后可以通过配置`imports-loader`将`$`变量注入到模块中，如下所示：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will simply prepend `var $ = require("jquery");` to `example.js`. This
    can be useful, for instance, if you are optimizing your code to run libraries
    locally.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将简单地将`var $ = require("jquery");`添加到`example.js`的开头。例如，如果你正在优化代码以在本地运行库，这可能会很有用。
- en: Using `polymer-loader` similarly optimizes your code or automates your processes
    to allow transitions. This is the next topic of our discussion.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用`polymer-loader`可以优化代码或自动化流程以允许转换。这是我们讨论的下一个主题。
- en: polymer-loader
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: polymer-loader
- en: '`polymer-loader` is used to convert HTML files into JavaScript files. To configure
    the loader, use the following code with `webpack.config.js`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`polymer-loader`用于将HTML文件转换为JavaScript文件。要配置加载器，请在`webpack.config.js`中使用以下代码：'
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `polymer-webpack-loader` phrase allows the developer to write HTML, CSS,
    and JavaScript code together as polymer elements in single documents—for instance,
    while still being able to use the full Webpack system, including module bundling
    and code splitting.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`polymer-webpack-loader`短语允许开发人员在单个文档中编写HTML、CSS和JavaScript代码作为聚合元素，例如，同时仍然能够使用完整的Webpack系统，包括模块捆绑和代码拆分。'
- en: script-loader
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: script-loader
- en: '`script-loader` essentially allows JavaScript to be loaded in a single instance.
    This applies globally throughout your project. Let''s set this up by going through
    the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`script-loader`基本上允许JavaScript在单个实例中加载。这适用于整个项目。让我们通过以下步骤进行设置：'
- en: 'To install `script-loader`, type the following in the command line:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装`script-loader`，在命令行中输入以下内容：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that this doesn't work in Node.js.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这在Node.js中不起作用。
- en: 'Use `webpack.config.js` to configure Webpack, which will export `exec` from `''script.exec.js'';.`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`webpack.config.js`配置Webpack，将`exec`从`'script.exec.js';`导出：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There is also an inline way of doing this, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种内联的方法，如下所示：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That should be all you need to be able to use `script-loader` with your Webpack
    application. Next is `source-map-loader`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是你在Webpack应用程序中使用`script-loader`所需要的全部内容。接下来是`source-map-loader`。
- en: source-map-loader
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: source-map-loader
- en: '`source-map-loader` extracts existing source maps from all JavaScript entries
    in your project. This includes both inline source maps as well as those that are
    externally loaded. All source map data is processed as per a chosen source map
    style, which you specify with the `devtool` option in `webpack.config.js`. The
    following code shows that configuration:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`source-map-loader`从项目中的所有JavaScript入口中提取现有的源映射。这包括内联源映射以及外部加载的源映射。所有源映射数据都按照你在`webpack.config.js`中使用`devtool`选项指定的源映射样式进行处理。以下代码显示了该配置：'
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This loader can be extremely useful when using third-party libraries that have
    source maps. If not extracted and processed into the source map of the bundle,
    browsers may interpret source map data incorrectly. This loader allows the maintenance
    of source map data continuity across libraries and frameworks to ensure easy debugging.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用具有源映射的第三方库时，此加载器可能非常有用。如果不将其提取并处理为包的源映射，浏览器可能会错误地解释源映射数据。此加载器允许在库和框架之间维护源映射数据的连续性，以确保轻松调试。
- en: The loader will extract from any JavaScript file, including those in the `node_modules`
    directory. Care should be taken when setting `include` and `exclude` rule conditions
    to optimize bundling performance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该加载器将从任何JavaScript文件中提取，包括`node_modules`目录中的文件。在设置`include`和`exclude`规则条件时，应注意优化捆绑性能。
- en: less-loader
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: less-loader
- en: '**`less-loader` **loads **LESS** (a type of **CSS**) scripts. You should install
    this in the usual way using the command line—for example, `npm i less-loader`.
    For the uninitiated, LESS is a more syntactically succinct form of CSS that is
    useful for backward compatibility.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**`less-loader`**加载**LESS**（一种**CSS**类型）脚本。你应该以通常的方式使用命令行安装它，例如`npm i less-loader`。对于未经培训的人来说，LESS是CSS的一种更简洁的语法形式，对于向后兼容性非常有用。'
- en: 'You should chain `less-loader` with `css-loader` and `style-loader` to immediately
    apply all styles to the document. To configure this, use the following example
    code using the `webpack.config.js` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将`less-loader`与`css-loader`和`style-loader`链接起来，以立即将所有样式应用到文档中。要配置此项，请使用以下示例代码，使用`webpack.config.js`文件：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can pass any LESS-specific options to the `less-loader` through the loader
    options. Since these options are passed to LESS as part of the program, they will
    need to be passed in `camelCase`; the following example in **`webpack.config.js` **shows
    how this is done:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过加载器选项将任何LESS特定选项传递给`less-loader`。由于这些选项作为程序的一部分传递给LESS，它们需要以`camelCase`形式传递；以下示例在**`webpack.config.js`**中展示了如何做到这一点：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that LESS won't map all options to `camelCase` individually. It is recommended
    that you check the relevant executable and search for the `dash-case` option.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，LESS不会将所有选项单独映射到`camelCase`。建议你检查相关的可执行文件，并搜索`dash-case`选项。
- en: When in production mode, it is usually recommended that you extract the style
    sheets into a dedicated file using `MiniCssExtractPlugin`. This way, your styles
    are not dependent on JavaScript (more on this later).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产模式下，通常建议使用`MiniCssExtractPlugin`将样式表提取到专用文件中。这样，你的样式就不会依赖于JavaScript（稍后会详细介绍）。
- en: In this section, we have discussed loaders in depth and also made a detailed
    examination of some of the more useful ones. Most loaders follow the same logic
    of installation and configuration and are built by the Webpack community, rather
    than by Webpack themselves. We'll discuss custom loaders in more detail in the
    final chapter of this book.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入讨论了加载器，并对一些更有用的加载器进行了详细的检查。大多数加载器都遵循相同的安装和配置逻辑，并由Webpack社区构建，而不是由Webpack自己构建。我们将在本书的最后一章中更详细地讨论自定义加载器。
- en: There are too many other loaders to mention here, but this gives you a very
    solid foundation to work with them in all sorts of imaginative ways. Something
    that is related to the non-native script that loaders tend to handle is the use
    of APIs with Webpack. We'll investigate this in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有太多其他加载器要提及，但这为你提供了一个非常坚实的基础，可以以各种富有想象力的方式与它们一起工作。与加载器通常处理的非本地脚本相关的东西是使用Webpack的API。我们将在下一节中进行调查。
- en: APIs
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API
- en: APIs are crucial to getting the most out of Webpack. In simple terms, APIs are
    required when communicating between applications and a website. When it comes
    to a JavaScript bundler such as Webpack, this includes the database and backend
    connectivity.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: API对于充分利用Webpack至关重要。简单来说，API在应用程序和网站之间进行通信时是必需的。对于像Webpack这样的JavaScript捆绑器，这包括数据库和后端连接。
- en: There is a huge number of APIs available when working with JavaScript but we
    cannot go through all of them here; however, there are some more useful common,
    but also complex, APIs that are used as tools quite often when programming with
    Webpack.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用JavaScript时，有大量的API可用，但我们无法在这里逐一介绍它们；然而，有一些更有用的常见但也复杂的API在使用Webpack进行编程时经常被用作工具。
- en: These tools are specific to Webpack and allow extensive or versatile functionality
    within Webpack, rather than just simple access to external code. The most notable
    of these tools are Babel and Node.js. So, let's use these tools as examples and
    learn about their usage in the following subsections, starting with Babel.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具是特定于Webpack的，允许在Webpack中进行广泛或多功能的功能，而不仅仅是简单地访问外部代码。其中最值得注意的工具是Babel和Node.js。因此，让我们以这些工具为例，并在接下来的小节中学习它们的用法，首先是Babel。
- en: Babel and its loader builder
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Babel及其加载器构建者
- en: 'In case you are not aware, Babel is a toolchain that mainly converts ECMAScript
    2015 and the preceding code into a regressive version of JavaScript that is compatible
    with current and older browsers or environments. The main things that Babel can
    do for you as a developer are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道，Babel是一个主要将ECMAScript 2015及其前版本代码转换为与当前和旧版浏览器或环境兼容的JavaScript的工具链。Babel可以为开发者做的主要事情如下：
- en: Transform syntax
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换语法
- en: Polyfill features that are missing in your target environment using `@babel/polyfill`
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@babel/polyfill`填充目标环境中缺失的功能
- en: Perform source code transformations, called code mods
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行源代码转换，称为代码修改
- en: 'Webpack uses an API for the Babel interface. If you attempt to install it with
    the command line, you should get the following message:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack使用Babel接口的API。如果你尝试使用命令行安装它，你应该会收到以下消息：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you receive this message, it means that you have the `npm` package that Babel installed
    and it is using the short notation of the loader in the Webpack configuration
    file (which is not valid anymore, as of Webpack versions 2 and later).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到此消息，意味着你已经安装了`Babel`并且在Webpack配置文件中使用了加载器的简短表示法（这在Webpack 2及更高版本中已不再有效）。
- en: 'In `webpack.config.js`, you may see the following script:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`webpack.config.js`中，您可能会看到以下脚本：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As a result of installing Babel, Webpack tries to load the `babel` package instead
    of `babel-loader`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安装了Babel，Webpack尝试加载`babel`包而不是`babel-loader`。
- en: 'To resolve this, the `npm` package Babel should be installed, as it is deprecated
    in Babel version 6\. If you''re using Babel version 6, then you should instead
    install `@babel/cli `or `@babel/core`. If one of your dependencies is installing Babel and
    you cannot uninstall it yourself, use the complete name of the loader in `webpack.config.js`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，应该安装`npm`包Babel，因为它在Babel版本6中已被弃用。如果您使用的是Babel版本6，则应该安装`@babel/cli`或`@babel/core`。如果您的一个依赖项正在安装Babel，并且您无法自行卸载它，请在`webpack.config.js`中使用加载器的完整名称：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The example you have followed so far should stand you in good stead for using
    Babel in general, but one key use of Babel is the customized loader. This is a
    topic covered more extensively in the final chapter of this book, but we will
    now go over how Babel works with customized loaders, especially since you may
    not use a loader that you customize yourself.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您所遵循的示例应该为您在一般情况下使用Babel奠定了良好的基础，但Babel的一个关键用途是自定义加载器。这是本书最后一章更全面地介绍的一个主题，但我们现在将讨论Babel如何与自定义加载器一起工作，特别是因为您可能不使用自定义的加载器。
- en: '`babel-loader` exposes a `loader-builder` utility that allows users to add
    custom handling of Babel''s configuration for each file that it processes.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`babel-loader`公开了一个`loader-builder`实用程序，允许用户为它处理的每个文件添加Babel配置的自定义处理。'
- en: The `.custom` phrase accepts a callback that will be called with the loader's
    instance of Babel. This is so that the tool can ensure that it uses the same `@babel/core` instance
    as the loader itself.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`.custom`短语接受一个回调函数，将使用Babel的加载器实例进行调用。这样工具可以确保它使用与加载器本身相同的`@babel/core`实例。'
- en: In cases where you want to customize but don't actually have a file to call `.custom`,
    you can also pass the `customize` option with a string pointing to a file that
    exports your custom callback function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在您想要自定义但实际上没有文件调用`.custom`的情况下，您还可以使用`customize`选项，并将其指向导出您自定义回调函数的文件的字符串。
- en: Probably the best way to learn how this works is through a practical example;
    let's go through one in the following exercise.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可能了解其工作原理的最佳方法是通过一个实际的例子；让我们在以下练习中进行一次。
- en: The goal of this example is to demonstrate how `babel-loader` can be used to
    build custom loaders.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的目标是演示如何使用`babel-loader`来构建自定义加载器。
- en: 'This example first uses a custom filename. This can be whatever you want, but
    for the sake of this exercise, the name we have chosen is `./my-custom-loader.js`.
    You can export from this location or wherever you want:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子首先使用了一个自定义的文件名。这可以是任何你想要的，但为了这个练习，我们选择的名称是`./my-custom-loader.js`。您可以从这个位置或任何您想要的地方导出：
- en: 'Begin by creating a custom file by using the following code in `./my-custom-loader.js`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过使用以下代码在`./my-custom-loader.js`中创建一个自定义文件：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code block, we can see a `require` statement. This uses `babel-loader`,
    which we will need to create the custom loader.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码块中，我们可以看到一个`require`语句。这使用了`babel-loader`，我们需要创建自定义加载器。
- en: 'Now, we need to configure our project to set up passing for the loader, as
    shown:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要配置我们的项目以设置传递给加载器的传递，如下所示：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that `custom:` refers to pulling out any custom options that the loader
    might have. Also, note the `loader` reference after the two options. This passes
    the options back with the two `custom` options removed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`custom:`指的是提取加载器可能具有的任何自定义选项。还要注意两个选项后面的`loader`引用。这将删除两个`custom`选项并将选项传回。
- en: 'Then, we pass Babel''s `PartialConfig` object, setting the normal configuration
    as `return cfg.options`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们传递Babel的`PartialConfig`对象，将正常配置设置为`return cfg.options`：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, where the `testPlugin` statement is made, we can see the
    inclusion of a custom plugin, which will then be available as an option.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，当`testPlugin`语句被执行时，我们可以看到自定义插件的包含，然后将作为一个选项可用。
- en: 'Now, let''s make the placeholder text to test the custom loader on. The preceding
    code should generate something like the following:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建占位文本来测试自定义加载器。前面的代码应该生成类似以下的内容：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code block shows that the custom loader is generating code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块显示了自定义加载器正在生成代码。
- en: 'Ensure that your configuration is made correctly. Note that you should always
    replace `__dirname` and `custom-loader` with a name of your choice. In the Webpack
    configuration module, type the following:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的配置是正确的。请注意，您应该始终将`__dirname`和`custom-loader`替换为您选择的名称。在Webpack配置模块中，键入以下内容：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding block shows you how to set up and configure `customOptions`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块向您展示了如何设置和配置`customOptions`。
- en: 'Given the loader''s options, split the custom options out of the options for `babel-loader`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据加载器的选项，将自定义选项从`babel-loader`的选项中拆分出来：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Given Babel''s `PartialConfig` object, return the `options` object that should
    be passed to `babel.transform`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定Babel的`PartialConfig`对象，返回应传递给`babel.transform`的`options`对象：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Both of the preceding code blocks refer to the contents of the custom file we
    have built, which, in this example, is `./my-custom-loader.js`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前面两个代码块都涉及到我们构建的自定义文件的内容，在这个例子中是`./my-custom-loader.js`。
- en: Note that Babel's `result` object will allow loaders to make additional tweaks
    to it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Babel的`result`对象将允许加载器对其进行额外的调整。
- en: That should be all you need to get the custom loader working with Babel. Read
    the last chapter of this book on authoring and custom loaders for further information.
    Another key API often used in Webpack projects is the Node.js API.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是你需要让自定义加载器与Babel一起工作的全部内容。阅读本书最后一章有关编写和自定义加载器的更多信息。在Webpack项目中经常使用的另一个关键API是Node.js
    API。
- en: The Node.js API
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js API
- en: The Node.js API is useful when using a custom development process. This is because
    all reporting and error handling is done manually. In this situation, Webpack
    simply handles the compilation processes. Note that the `stats` configuration
    options will not have any effect when using the Node.js API.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用自定义开发流程时，Node.js API非常有用。这是因为所有的报告和错误处理都是手动完成的。在这种情况下，Webpack只是处理编译过程。请注意，在使用Node.js
    API时，`stats`配置选项将不会产生任何效果。
- en: 'This API will be installed whenever you install Webpack 5; you can refer to
    the first chapter if you are reading this section out of sequence. Let''s set
    this API up by taking the following steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装Webpack 5时，这个API将被安装；如果您按顺序阅读本节，可以参考第一章。让我们通过以下步骤设置这个API：
- en: 'Begin by including the `webpack` module to your Node.js script. This is done
    using the `webpack.config.js` file:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`webpack`模块包含到您的Node.js脚本中。这是通过`webpack.config.js`文件完成的：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the previous example, a callback function was provided—`webpack()`—which
    runs the compiler. The code presents a few conditions. This is only an example
    and should be substituted with your code, of course. Also, the `some` term should
    similarly be replaced with the correct object name associated with your project.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，提供了一个回调函数`webpack()`，它运行编译器。代码呈现了一些条件。这只是一个例子，当然应该用您的代码替换。同样，`some`术语应该被替换为与您的项目相关的正确对象名称。
- en: Note that the `some` object won't include compilation errors, but only issues
    related to Webpack specifically, such as misconfiguration. Those errors are instead
    handled using the `stats.hasErrors()` function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`some`对象不会包括编译错误，而只包括与Webpack特定的问题，如错误配置相关的问题。这些错误将使用`stats.hasErrors()`函数来处理。
- en: Next, ensure that the passing of the compiler instance is done correctly.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确保正确传递编译器实例。
- en: If the Webpack function is not provided with a callback, it will return a `compiler`
    instance. The `compiler` instance can manually trigger the `webpack()` function
    or ensure that it watches for changes (using `.run(callback)` or `.watch(watchOptions,
    handler)`) during a build, or even runs the build itself without the need for
    the CLI.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Webpack函数没有提供回调，它将返回一个`compiler`实例。`compiler`实例可以手动触发`webpack()`函数，或者确保它在构建过程中观察更改（使用`.run(callback)`或`.watch(watchOptions,
    handler)`），甚至在不需要CLI的情况下运行构建本身。
- en: The `compiler` instance permits the use of child compilers and will delegate
    all the bundling, writing, and loading work to registered plugins.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`compiler`实例允许使用子编译器，并将所有捆绑、写入和加载工作委托给注册的插件。'
- en: There is something called a `hook` property, which is part of the `compiler`
    instance. Its purpose is to register any plugin to any hook event during a compiler's
    life cycle. You can configure this compiler with the `WebpackOptionsDefaulter`
    and `WebpackOptions Apply` utilities.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个叫做`hook`属性，它是`compiler`实例的一部分。它的目的是在编译器的生命周期中注册任何插件到任何钩子事件。您可以使用`WebpackOptionsDefaulter`和`WebpackOptions
    Apply`工具来配置这个编译器。
- en: Upon completion of a build run, the previously mentioned callback function will
    be executed. The final logging of any errors or statistics are done with this
    function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建运行完成后，之前提到的回调函数将被执行。使用这个函数来最终记录任何错误或统计信息。
- en: The Node.js API will only support a single compilation once. Concurrent watches
    or builds can corrupt the output bundle.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js API只支持单个编译一次。并发的观察或构建可能会破坏输出捆绑包。
- en: Using the API to call a run is similar to using the `compiler` instance.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API调用运行类似于使用`compiler`实例。
- en: 'We should now run a compilation using `webpack.config.js`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们应该使用`webpack.config.js`运行一个编译：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'From here, we can also trigger a `watch` session. When the `webpack()` function
    detects a change, it will run again and return an instance of `watching`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，我们还可以触发一个`watch`会话。当`webpack()`函数检测到更改时，它将再次运行并返回一个`watching`实例：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As filesystem inaccuracies can trigger multiple builds if a change is detected,
    the `console.log` statement in the previous code block may cause this trigger
    multiple times for any single modification. Checking `stats.hash` can help you
    see whether the file has changed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件系统的不准确性可能会触发多次构建，如果检测到更改，前面代码块中的`console.log`语句可能会多次触发任何单个修改。检查`stats.hash`可以帮助您查看文件是否已更改。
- en: 'Using the `watch` method this way will return a `watching` instance and a `.close(callback)`
    method. The calling of this method will end the `watching` session:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这种方式的`watch`方法将返回一个`watching`实例和一个`.close(callback)`方法。调用这个方法将结束`watching`会话：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note that using the `invalidate` watching function will allow the manual invalidation
    of the current compilation without stopping the `watch` process. This is useful
    as only one run is permitted at once:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`invalidate`观察函数将允许手动使当前编译无效，而不会停止`watch`过程。这很有用，因为一次只允许运行一次：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As multiple, simultaneous compilations are restricted, Webpack offers something
    called `MultiCompiler` to expedite your project development. It is a module that
    allows Webpack to run multiple configurations in separate compilers. If your `options`
    parameter is an array, Webpack will apply separate compilers and execute any callbacks
    after all the compilers have completed their process:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多个同时的编译是受限制的，Webpack提供了一个叫做`MultiCompiler`的东西来加快项目的开发。它是一个模块，允许Webpack在单独的编译器中运行多个配置。如果您的`options`参数是一个数组，Webpack将应用单独的编译器，并在所有编译器完成其过程后执行任何回调：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The preceding code block shows you how to configure your project in `webpack.config.js` to
    allow this procedure.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块向您展示了如何在`webpack.config.js`中配置项目以允许这个过程。
- en: As explained, attempting to run these compilations in parallel will produce
    incorrect outputs. If this is done accidentally, error management comes to the
    fore.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所解释的，尝试并行运行这些编译将产生不正确的输出。如果这是意外发生的，错误管理就变得很重要。
- en: Generally, error handling encompasses three types of errors—fatal Webpack errors
    (such as misconfiguration), compilation errors (such as missing assets), and compilation
    warnings.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，错误处理包括三种类型的错误——严重的 Webpack 错误（例如配置错误）、编译错误（例如缺少资源）和编译警告。
- en: 'The following code block shows you how you can configure your project—in this
    example, using `webpack.config.js`—to handle those errors:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块向您展示了如何配置您的项目——在本例中，使用 `webpack.config.js`——来处理这些错误：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding block, the `some` element indicates these errors as a variable.
    We can see the various conditions that will register those errors in the console
    log.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码块中，`some` 元素表示这些错误作为一个变量。我们可以看到各种条件将在控制台日志中注册这些错误。
- en: We have given you an intensive crash course on how APIs work with Webpack, so
    if you survived, you are now a hardcore expert in programming skills. Well done!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为您提供了关于如何使用 Webpack 的 API 的密集速成课程，所以如果您幸存下来，现在您是编程技能的专家。干得好！
- en: Now that we have explored a variety of loaders and APIs (including Babel and
    Node.js), it is time to look at the final feature covered in this chapter—plugins.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了各种加载器和 API（包括 Babel 和 Node.js），是时候看一下本章涵盖的最后一个功能了——插件。
- en: Plugins
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件
- en: Plugins serve the purpose of doing everything that a loader cannot do. Loaders
    often help run code that is not native to Webpack and plugins do the same; however,
    loaders are often built by the community whereas plugins are built by Webpack's
    in-house developers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的作用是做任何加载器无法做到的事情。加载器通常帮助运行不适用于 Webpack 的代码，插件也是如此；然而，加载器通常由社区构建，而插件由 Webpack
    的内部开发人员构建。
- en: Plugins are said to be the backbone of Webpack. The software is built on the
    same plugin system that you use in your Webpack configuration.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 插件被认为是 Webpack 的支柱。该软件是建立在与您在 Webpack 配置中使用的相同的插件系统上的。
- en: 'Webpack has a rich plugin interface and most of the features within Webpack
    itself use it. The following is a bulleted list of the available plugins that
    this section will cover in detail. Next to each name is a brief description of
    the plugin:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 有丰富的插件接口，Webpack 自身的大多数功能都使用它。以下是本节将详细介绍的可用插件的项目列表。每个名称旁边都有一个插件的简要描述：
- en: '`BabelMinifyWebpackPlugin`: Minificates with `babel-minify`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BabelMinifyWebpackPlugin`：使用 `babel-minify` 进行最小化'
- en: '`CommonsChunkPlugin`: Extracts common modules shared between chunks'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommonsChunkPlugin`：提取在块之间共享的公共模块'
- en: '`ContextReplacementPlugin`: Overrides the inferred context of a require expression'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContextReplacementPlugin`：覆盖 require 表达式的推断上下文'
- en: '`HotModuleReplacementPlugin`: Enables **Hot Module Replacement** (**HMR**)
    (more on this later)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HotModuleReplacementPlugin`：启用 **热模块替换**（**HMR**）（稍后详细介绍）'
- en: '`HtmlWebpackPlugin`: Easily creates HTML files to serve your bundles'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HtmlWebpackPlugin`：轻松创建用于提供捆绑包的 HTML 文件'
- en: '`LimitChunkCountPlugin`: Sets minimum/maximum limits for chunking to better
    control the process'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LimitChunkCountPlugin`：设置分块的最小/最大限制，以更好地控制该过程'
- en: '`ProgressPlugin`: Reports compilation progress'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgressPlugin`：报告编译进度'
- en: '`ProvidePlugin`: Uses modules without having to use `import`/`require`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProvidePlugin`：使用模块而无需使用 `import`/`require`'
- en: '`TerserPlugin`: Enables control of the version of Terser in your project'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TerserPlugin`：启用对项目中 Terser 版本的控制'
- en: There are many more plugins available on the Webpack community pages; however,
    the preceding list illustrates the more salient and useful ones. Next, we will
    go over each one with a detailed explanation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 社区页面上有许多其他插件可用；然而，上述列表说明了更显著和有用的插件。接下来，我们将详细解释每一个。
- en: We won't go over the final three plugins as they only need to be installed in
    the usual fashion.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍最后三个插件，因为它们只需要按照通常的方式安装。
- en: 'The installation of each plugin follows the same process as the one used for
    loaders:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每个插件的安装都遵循与加载器相同的过程：
- en: 'First, install the plugin using the command line and then alter the configuration
    file to require the plugin, similar to the following example:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用命令行安装插件，然后修改配置文件以引入插件，类似于以下示例：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Remember, this is a generic example; you will have to add your plugin name.
    The same can be said of the following configuration, which follows the same procedure
    as most Webpack projects and the same configuration file that we previously used, `webpack.config.js`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这只是一个通用示例；您将需要添加您的插件名称。与之前使用的相同的 Webpack 项目和相同的配置文件 `webpack.config.js`
    一样，以下配置也是如此。
- en: 'We should prepare our configuration file now:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们应该准备我们的配置文件：
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'That concludes your general introduction to plugins. We took a general approach
    to prevent over-complication. Now, we can move on to some of the intriguing aspects
    of the various plugins available on Webpack. In the following subsection, we will
    discuss the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了关于插件的一般介绍。我们采取了一般方法来防止过度复杂化。现在，我们可以继续讨论 Webpack 上可用的各种插件的一些有趣方面。在下一小节中，我们将讨论以下内容：
- en: '`BabelMinifyWebpackPlugin`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BabelMinifyWebpackPlugin`'
- en: '`CommonsChunkPlugin`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommonsChunkPlugin`'
- en: '`ContextReplacementPlugin`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContextReplacementPlugin`'
- en: '`HtmlWebpackPlugin`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HtmlWebpackPlugin`'
- en: '`LimitChunkCountPlugin`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LimitChunkCountPlugin`'
- en: Most plugins are developed by Webpack inhouse and fill the development gaps
    that loaders are not yet able to. These are some of the more interesting ones.
    Let's start with `BabelMinifyWebpackPlugin`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数插件由 Webpack 内部开发，并填补了加载器尚不能填补的开发空白。以下是一些更有趣的插件。让我们从 `BabelMinifyWebpackPlugin`
    开始。
- en: BabelMinifyWebpackPlugin
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BabelMinifyWebpackPlugin
- en: In this subsection, we are going to install `BabelMinifyWebpackPlugin`. This
    plugin is designed to minify Babel script. Minifying, as previously discussed,
    refers to the removal of erroneous or surplus code to compress the application
    size. To use `babel-loader` and include `minify` as a preset, use `babel-minify`.
    The use of `babel-loader` with this plugin will be much faster and will operate
    on smaller file sizes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将安装 `BabelMinifyWebpackPlugin`。该插件旨在最小化 Babel 脚本。如前所述，最小化是指删除错误或多余的代码以压缩应用程序大小。要使用
    `babel-loader` 并将 `minify` 作为预设包含在内，使用 `babel-minify`。使用此插件的 `babel-loader` 将更快，并且将在较小的文件大小上运行。
- en: 'Loaders in Webpack operate on single files and the preset of `minify` will
    execute each file directly in the browser''s global scope; this is done by default.
    Some things in the top-level scope will not be optimized. Optimization of the
    `topLevel` scope of the file can be done using the following code and `minifyOptions`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack中的加载器操作单个文件，`minify`的预设将直接在浏览器的全局范围内执行每个文件；这是默认行为。顶层范围中的一些内容将不被优化。可以使用以下代码和`minifyOptions`来优化文件的`topLevel`范围：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When `node_modles` is excluded from the run through `babel-loader`, then the
    minify optimizations are not applied to the excluded files since nothing is passed
    through `minifer`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当`node_modles`被排除在`babel-loader`的运行之外时，排除的文件不会应用缩小优化，因为没有传递给`minifer`。
- en: When using `babel-loader`, the generated code does not go through the loader
    and is not optimized.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`babel-loader`时，生成的代码不经过加载器，也不被优化。
- en: A plugin can operate on the entire chunk or bundle output and can optimize the
    whole bundle, and some differences can be seen in the minified output; however,
    in that case, the file size would be huge.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 插件可以操作整个块或捆绑输出，并且可以优化整个捆绑包，可以在缩小的输出中看到一些差异；但是，在这种情况下，文件大小将会很大。
- en: The Babel plugin is very useful when working with Webpack and it works across
    multiple platforms. The next plugin we will discuss is `CommonsChunkPlugin`, which
    is designed to work with multiple module chunks—again, something that is very
    native to Webpack.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Babel插件在使用Webpack时非常有用，并且可以跨多个平台使用。我们将讨论的下一个插件是`CommonsChunkPlugin`，它旨在与多个模块块一起使用，这是Webpack非常本地的功能。
- en: CommonsChunkPlugin
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CommonsChunkPlugin
- en: '`CommonsChunkPlugin` is an optional feature that creates a separate feature
    known as a chunk. Chunks consist of common modules shared between multiple entry
    points.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommonsChunkPlugin`是一个可选功能，它创建一个称为块的单独功能。块由多个入口点之间共享的公共模块组成。'
- en: This plugin has been removed in Webpack 4 (Legato).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件已经在Webpack 4（Legato）中被移除了。
- en: Looking into `SplitChunkPlugin` will show you more on how chunks are treated
    in Legato.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`SplitChunkPlugin`将更多地了解Legato中如何处理块。
- en: The resulting chunked file can be initially loaded once by separating the common
    modules that form the bundle. This is stored in the cache for later use.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的分块文件可以通过分离形成捆绑包的公共模块来最初加载一次。这将被存储在缓存中以供以后使用。
- en: Using the cache in this way will allow the browser to load pages quicker, rather
    than forcing it to load larger bundles.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用缓存将允许浏览器更快地加载页面，而不是强制它加载更大的捆绑包。
- en: 'Use the following declaration in your configuration to use this plugin:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的配置中使用以下声明来使用这个插件：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: A short and simple installation, but worth the introduction. Next, let's work
    with `ContextReplacementPlugin`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简短而简单的安装，但是值得介绍。接下来，让我们使用`ContextReplacementPlugin`。
- en: ContextReplacementPlugin
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ContextReplacementPlugin
- en: '`ContextReplacementPlugin` refers to a `require` statement with an extension,
    such as the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContextReplacementPlugin`是指带有扩展名的`require`语句，例如以下内容：'
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When you encounter an expression such as this, the plugin will infer the directory
    of `./local/` and a regular expression. If a name is not included at the time
    of compilation, then every file will be included as a module in the bundle. This
    plugin will allow the inferred information to be overridden.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到这样的表达式时，插件将推断`./local/`的目录和一个正则表达式。如果在编译时没有包含名称，那么每个文件都将作为模块包含在捆绑包中。这个插件将允许覆盖推断的信息。
- en: The next plugin to discuss is `HtmlWebpackPlugin`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要讨论的插件是`HtmlWebpackPlugin`。
- en: HtmlWebpackPlugin
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HtmlWebpackPlugin
- en: '`HtmlWebpackPlugin` simplifies the creation of HTML files to serve the bundle.
    This is especially useful for bundles that include a hash in the filename, which
    changes every compilation.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`HtmlWebpackPlugin`简化了创建用于提供捆绑包的HTML文件。这对于包含文件名中的哈希值的捆绑包特别有用，因为每次编译都会更改。'
- en: When using this method, we have three choices—use a template with `lodash` templates,
    use your loader, or let the plugin generate an HTML file. The template is simply
    an HTML template that you can automatically load using `lodash` for speed. The
    loader or the plugin can generate its HTML file. This all speeds up any automated
    processes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法时，我们有三种选择——使用带有`lodash`模板的模板，使用您的加载器，或者让插件生成一个HTML文件。模板只是一个HTML模板，您可以使用`lodash`自动加载以提高速度。加载器或插件可以生成自己的HTML文件。这都可以加快任何自动化流程。
- en: When using multiple entry points, they will be included with the `<script>` tags
    in the generated HTML.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多个入口点时，它们将与生成的HTML中的`<script>`标签一起包含。
- en: If you have any CSS assets in Webpack's output, then these will be included
    with the `<link>` tags in the `<head>` element of the generated HTML. An example
    would be if CSS is extracted with `MiniCssExtractPlugin`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Webpack的输出中有任何CSS资产，那么这些资产将包含在生成的HTML的`<head>`元素中的`<link>`标签中。例如，如果使用`MiniCssExtractPlugin`提取CSS。
- en: Back to working with chunks. The next plugin to look at is a plugin that deals
    with limiting the chunk count.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 回到处理块。下一个要看的插件是处理限制块计数的插件。
- en: LimitChunkCountPlugin
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LimitChunkCountPlugin
- en: '`LimitChunkCountPlugin` is used when loading on-demand because many code splits
    can be used. When compiling, you might notice that some chunks are very small,
    which creates a larger HTTP overhead. `LimitChunkCountPlugin` can postprocess
    chunks by merging them.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在按需加载时使用`LimitChunkCountPlugin`。在编译时，您可能会注意到一些块非常小，这会产生更大的HTTP开销。`LimitChunkCountPlugin`可以通过合并块来后处理块。
- en: 'Limiting the maximum number of chunks can be done by using a value greater
    than or equal to `1`. Using `1` prevents additional chunks from being added as
    the main or entry point chunk:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用大于或等于`1`的值来限制最大块数。使用`1`可以防止将额外的块添加为主块或入口点块：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Keeping the chunk size above the specified limit is not a feature you will find
    in Webpack 5; `MinChuckSizePlugin` should be used, instead, in this situation.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 保持块大小在指定限制以上不是Webpack 5中的一个功能；在这种情况下应该使用`MinChuckSizePlugin`。
- en: That concludes our introduction to plugins and this chapter in general. Plugins
    allow Webpack to work in a variety of ways and Webpack enables developers to build
    loaders and plug gaps in functionality issues. They are indispensable when working
    on a larger scale project or complex projects that require automation.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对插件的介绍以及本章的总结。插件使Webpack能够以各种方式工作，而Webpack使开发人员能够构建加载程序并填补功能问题的空白。在处理大型项目或需要自动化的复杂项目时，它们是不可或缺的。
- en: Our section on APIs showed you how, sometimes, we don't always want to use local
    code and provided you with an excellent transition to libraries, which we will
    discuss in the next chapter.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于API的部分向您展示了，有时我们并不总是想使用本地代码，并为您提供了一个很好的过渡到我们将在下一章中讨论的库。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has given you an in-depth view of loaders and how they are used
    in Webpack. Loaders are fundamental to Webpack, but plugins are the core and backbone.
    This chapter took you through the major features of these topics, demonstrating
    the best uses for each and when it is a good time to switch between them.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入介绍了加载程序及其在Webpack中的使用方式。加载程序对于Webpack来说是基础，但插件是核心和支柱。本章带您了解了这些主题的主要特点，展示了每个主题的最佳用法以及何时切换使用它们的好时机。
- en: We then explored plugins and how they are used, including Babel, custom plugins,
    and loaders. We have also looked at APIs and their usage, specifically APIs that
    facilitate a wider range of functionality within Webpack, such as the Babel and
    Node APIs.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们探讨了插件及其使用方式，包括Babel、自定义插件和加载程序。我们还研究了API及其使用方式，特别是那些在Webpack中实现更广泛功能的API，比如Babel和Node
    API。
- en: In the next chapter, we will discuss libraries and frameworks. Our examination
    of plugins, APIs, and loaders has revealed that sometimes, we don't want to use
    remote code such as libraries, but other times we do. Webpack generally deals
    with locally hosted code, but there are times when we might want to work with
    libraries. This provides a good transition to that topic.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论库和框架。我们对插件、API和加载程序的研究表明，有时我们不想使用诸如库之类的远程代码，但有时我们确实需要。Webpack通常处理本地托管的代码，但有时我们可能需要使用库。这为我们提供了一个很好的过渡到这个主题。
- en: Questions
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is an `i18n` loader?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`i18n`加载程序？
- en: What is the toolchain that Webpack typically uses to convert ECMA scripts?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webpack通常使用哪种工具链来转换ECMA脚本？
- en: What is Babel mainly used for?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Babel主要用于什么？
- en: Which loader allows users to add custom handling of Babel's configuration?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个加载程序允许用户添加对Babel配置的自定义处理？
- en: What does `polymer-webpack-loader` do?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`polymer-webpack-loader`是做什么的？'
- en: What does `polymer-webpack-loader` offer a developer?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`polymer-webpack-loader`为开发人员提供了什么？'
- en: When using the Node.js API, what will the callback function that is provided
    run?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用Node.js API时，提供的回调函数将运行什么？
