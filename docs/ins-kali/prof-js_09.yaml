- en: '*Chapter 9*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*'
- en: Event-Driven Programming and Built-In Modules
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动编程和内置模块
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Use event modules in Node.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Node.js中使用事件模块
- en: Create an event emitter to enhance the functionality of existing code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建事件发射器以增强现有代码的功能
- en: Build custom event emitters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自定义事件发射器
- en: Use built-in modules and utilities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置模块和实用工具
- en: Implement a timer module to get an API to schedule timer functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个计时器模块，以获得调度计时器函数的API
- en: In this chapter, we will use event emitters and built-in modules to avoid creating
    projects with deeply coupled dependencies.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用事件发射器和内置模块，以避免创建具有紧密耦合依赖关系的项目。
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we talked about how event-driven programming is used
    in Node.js and how we can modify normal callback-based async operations to use
    async-await and promises. We know that the Node.js core API is built on async-driven
    architecture. Node.js has one event loop that does the processing for most async
    and event-based operations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了Node.js中如何使用事件驱动编程，以及如何修改正常的基于回调的异步操作以使用async-await和promises。我们知道Node.js核心API是建立在异步驱动架构上的。Node.js有一个事件循环，用于处理大多数异步和基于事件的操作。
- en: 'In JavaScript, the event loops run constantly and digest messages from the
    callback queue to make sure it is executing the right functions. Without events,
    we can see that the code is very deeply coupled. For a simple chatroom application,
    we would need to write something like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，事件循环不断地运行并从回调队列中消化消息，以确保执行正确的函数。没有事件，我们可以看到代码非常紧密耦合。对于一个简单的聊天室应用程序，我们需要编写类似这样的东西：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, because we are not using events, we need to keep a list of
    all the users in the room. When we add a user to the room, we also need to add
    the user to the list we created. When sending messages, we also need to iterate
    through all the users in our list and call the `sendMessage` method. Our user
    class would be defined like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，因为我们没有使用事件，我们需要保留房间中所有用户的列表。当我们将用户添加到房间时，我们还需要将用户添加到我们创建的列表中。在发送消息时，我们还需要遍历我们列表中的所有用户并调用`sendMessage`方法。我们的用户类将被定义如下：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see how this is getting far too complicated; in order to join a chatroom,
    we need to add both the room and the current user to the room. When our application
    eventually gets very complicated, we will see that this raises an issue with the
    traditional approach. If this application ever requires network requests (async
    operations), it will get very complex because we would need to wrap all the code
    we wish to execute with the async operation. We might be able to pull that logic
    out but when we are dealing with applications that are being driven by an unknown
    number of random events, using event-driven programming has the benefit of making
    our code much easier to maintain.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这变得过于复杂；为了加入聊天室，我们需要同时将房间和当前用户添加到房间中。当我们的应用程序最终变得非常复杂时，我们会发现这会引发传统方法的问题。如果此应用程序需要网络请求（异步操作），它将变得非常复杂，因为我们需要用异步操作包装我们希望执行的所有代码。我们可能能够将该逻辑提取出来，但是当我们处理由未知数量的随机事件驱动的应用程序时，使用事件驱动编程的好处在于使我们的代码更易于维护。
- en: The Traditional Approach versus Event-Driven Programming
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统方法与事件驱动编程
- en: 'As we mentioned in the introduction, in traditional programming patterns, we
    like to have a direct link between our components when we want them to communicate.
    This is shown in the following diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中提到的，在传统的编程模式中，当我们希望它们进行通信时，我们喜欢在组件之间建立直接的联系。这在下图中有所体现：
- en: '![Figure 9.1: Traditional programming approach'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1：传统编程方法'
- en: '](Images/C14587_09_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_01.jpg)'
- en: 'Figure 9.1: Traditional programming approach'
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.1：传统编程方法
- en: 'For a simple application that allows the user to update their profile and receive
    messages, we can see that we have four components:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的应用程序，允许用户更新其个人资料并接收消息，我们可以看到我们有四个组件：
- en: Agent
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Profile
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人资料
- en: Votes
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投票
- en: Messages
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息
- en: 'The way these components interact with each other is by calling the appropriate
    methods in the component that wishes to communicate. By doing this, it makes the
    code very easy to understand, but we might have to pass the component reference
    over. Take our `Agent` class, for example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件之间的交互方式是通过调用希望通信的组件中的适当方法来实现的。通过这样做，使得代码非常易于理解，但我们可能需要传递组件引用。以我们的`Agent`类为例：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Agent` class must store the reference to the component it wants to communicate
    with in the future. Without it, there is no way for our component to communicate
    with other components. In the preceding example, the `Agent` object we created
    is very deeply coupled with everything else. It needs all the references for these
    objects when it is created, which makes our code very hard to decouple if we want
    to change something in the future. Consider the preceding `Agent` code. If we
    are going to add more features to it, we want the agent class to communicate with
    new features such as a social page, a live stream page, and so on. It is technically
    doable as long we add the reference to these objects in our `constructor`. By
    doing this, we risk having our code look like this in the future:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Agent`类必须在未来存储与其希望通信的组件的引用。如果没有，我们的组件就无法与其他组件通信。在前面的示例中，我们创建的`Agent`对象与其他所有内容都非常紧密耦合。它在创建时需要所有这些对象的引用，这使得我们的代码在未来要更改某些内容时非常难以解耦。考虑前面的`Agent`代码。如果我们要为其添加更多功能，我们希望代理类与新功能进行通信，例如社交页面、直播页面等。只要我们在我们的`constructor`中添加对这些对象的引用，这在技术上是可行的。通过这样做，我们将冒着我们的代码在未来看起来像这样的风险：'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When our application gets more and more complex, so does our `Agent` class.
    Since it has all the references in `constructor`, we are open to issues that can
    be caused by mistakenly passing the wrong type for a parameter. This is a common
    problem when we are trying to communicate between multiple components at once.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序变得越来越复杂时，我们的`Agent`类也会变得越来越复杂。因为它在`constructor`中有所有的引用，所以我们容易因为错误地传递参数类型而引起问题。当我们试图一次性在多个组件之间进行通信时，这是一个常见的问题。
- en: Eventing
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: Our previous approach – that is, dealing with component communication – was
    direct and really static. We need to store the component reference we want to
    communicate with and write very component-specific code when we want to send a
    message to it. In JavaScript, there is a new way of communicating, and it's called
    **eventing**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的方法——即处理组件通信的方法——是直接的，而且非常静态。我们需要存储我们想要进行通信的组件引用，并且在想要向其发送消息时编写非常特定于组件的代码。在JavaScript中，有一种新的通信方式，它被称为**事件**。
- en: 'Let''s consider this example; the light that''s passed to you by your friend
    is a way for you to receive events from your friend. In JavaScript, we can have
    objects that have the ability to emit events. By emitting events, we can create
    a new way of communicating between our objects. This is also called the observer
    pattern. The following diagram depicts the observer pattern:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这个例子；你朋友传递给你的光是你从朋友那里接收事件的一种方式。在JavaScript中，我们可以拥有能够发出事件的对象。通过发出事件，我们可以创建对象之间的新通信方式。这也被称为观察者模式。以下图表描述了观察者模式：
- en: '![Figure 9.2: The observer pattern'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2：观察者模式'
- en: '](Images/C14587_09_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_02.jpg)'
- en: 'Figure 9.2: The observer pattern'
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.2：观察者模式
- en: 'In this pattern, instead of calling specific methods in our component, the
    component that wants to initiate communication will simply emit an event. We can
    have multiple observers that observe events from the components. This way, we
    put the responsibility of consuming the message purely on the consumer. When the
    observer decides to observe the event, it will receive the event every time the
    component emits it. If the preceding complex example is implemented using events,
    it will look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式中，我们不是在组件中调用特定的方法，而是希望发起通信的组件只是发出一个事件。我们可以有多个观察者观察来自组件的事件。这样，我们把消费消息的责任完全放在了消费者身上。当观察者决定观察事件时，它将在组件发出事件时每次接收到事件。如果使用事件来实现前面复杂的例子，它会是这样的：
- en: '![Figure 9.3: Observer patterns using events'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3：使用事件的观察者模式'
- en: '](Images/C14587_09_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_03.jpg)'
- en: 'Figure 9.3: Observer patterns using events'
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.3：使用事件的观察者模式
- en: 'Here, we can see that each component follows our observer pattern, and when
    we convert this into code, it will look something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到每个组件都遵循我们的观察者模式，当我们将其转换为代码时，它会看起来像这样：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, instead of taking all the references of all the components we want to communicate
    with, we are only passing one event emitter over, which handles all the messaging.
    This makes our code much more decoupled from the other components. This is basically
    how we implement an event observer pattern in our code. In real life, this can
    get more complicated. In the next exercise, we will go over a simple example to
    demonstrate how we can use the built-in event system in Node.js to emit events.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再需要获取所有我们想要进行通信的组件的引用，而是只传递一个事件发射器，它处理所有的消息。这使得我们的代码与其他组件的耦合度大大降低。这基本上就是我们在代码中实现事件观察者模式的方式。在现实生活中，这可能会变得更加复杂。在下一个练习中，我们将介绍一个简单的例子，演示如何使用Node.js中内置的事件系统来发出事件。
- en: 'Exercise 67: A Simple Event Emitter'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习67：一个简单的事件发射器
- en: In the introduction, we talked about how we can use the event observer pattern
    to remove the references of all the components we want to communicate within our
    code. In this exercise, we will go over the built-in event module in Node.js,
    how we can create an `EventEmitter`, and how we can use it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍中，我们谈到了如何使用事件观察者模式来消除我们代码中想要进行通信的所有组件的引用。在这个练习中，我们将介绍Node.js中内置的事件模块，我们如何创建`EventEmitter`以及如何使用它。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个练习：
- en: 'Import the `events` module:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`events`模块：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will be importing the `events` module built-in in Node.js. It provides a
    constructor that we can use to create our custom event emitters or create a class
    that inherits from it. Because this is a built-in module, there is no need to
    install it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入Node.js中内置的`events`模块。它提供了一个构造函数，我们可以用它来创建自定义的事件发射器或创建一个继承自它的类。因为这是一个内置模块，所以不需要安装它。
- en: 'Create a new `EventEmitter`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`EventEmitter`：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Try to emit an event:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试发出一个事件：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Attach an event listener:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 附加一个事件监听器：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To add an event listener to our emitter, we need to call the `on` method on
    our emitter with the event name and the function to be called when an event is
    emitted. When we add the event listener after we emit an event, we will see that
    the event listener is not called. The reason for this is that when we emitted
    our event before, there was no event listener attached for that event, and so
    it wasn't called.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们的发射器添加事件监听器，我们需要在发射器上调用`on`方法，传入事件名称和在发出事件时要调用的函数。当我们在发出事件后添加事件监听器时，我们会发现事件监听器没有被调用。原因是在我们之前发出事件时，并没有为该事件附加事件监听器，因此它没有被调用。
- en: 'Emit another event:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再发出一个事件：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we emit an event this time, we will see that our event listener is correctly
    called, and our event value is correctly printed out, like so:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这次发出事件时，我们会看到我们的事件监听器被正确调用，并且我们的事件值被正确打印出来，就像这样：
- en: '![Figure 9.4: Emitted event with the correct event value'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4：使用正确的事件值发出的事件'
- en: '](Images/C14587_09_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_04.jpg)'
- en: 'Figure 9.4: Emitted event with the correct event value'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.4：使用正确的事件值发出的事件
- en: 'Attach another event listener for `my-event`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`my-event`附加另一个事件监听器：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are not limited to only one listener per event – we can attach as many event
    listeners as possible. When an event is emitted, it will invoke all the listeners.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于每个事件只有一个监听器 - 我们可以附加尽可能多的事件监听器。当发射事件时，它将调用所有监听器。
- en: 'Emit another event:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发射另一个事件：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the output of the preceding code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 9.5: Output after emitting an event multiple times'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5：多次发射事件后的输出'
- en: '](Images/C14587_09_05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_05.jpg)'
- en: 'Figure 9.5: Output after emitting an event multiple times'
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.5：多次发射事件后的输出
- en: When we emit the events again, we will see the first event we emitted. We will
    also see that it successfully printed out our messages. Notice that it kept the
    same order as when we attached the listener. When we emit an error, the emitter
    iterates through the array and invokes each listener, one by one.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次发射事件时，我们将看到我们发射的第一个事件。我们还将看到它成功地打印出我们的消息。请注意，它保持了与我们附加监听器时相同的顺序。当我们发射错误时，发射器会遍历数组并依次调用每个监听器。
- en: 'Create the `handleEvent` function:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`handleEvent`函数：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we set our event listeners, we used anonymous functions. While this is
    easy and simple, it doesn''t offer us all of the capability that `EventEmitters`
    offers:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置我们的事件监听器时，我们使用了匿名函数。虽然这很容易和简单，但它并没有为我们提供`EventEmitters`提供的所有功能：
- en: 'Attach the new `handleEvent` to a new type of event:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的“handleEvent”附加到新类型的事件上：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Emit the new event type:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发射新的事件类型：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is the output of the preceding code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 9.6: Emitting the new event type'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6：发射新的事件类型'
- en: '](Images/C14587_09_06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_06.jpg)'
- en: 'Figure 9.6: Emitting the new event type'
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.6：发射新的事件类型
- en: 'Remove the event listener:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除事件监听器：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Because we are using a named function, we can use this function reference to
    remove listeners once we no longer need events to be passed to that listener.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用了命名函数，所以我们可以使用这个函数引用来移除监听器，一旦我们不再需要将事件传递给该监听器。
- en: 'Emit the event after the listener has been removed:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在移除监听器后发射事件：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the output of the preceding code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 9.7: Output of the emit event after the listener has been removed'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7：移除监听器后发射事件的输出'
- en: '](Images/C14587_09_07.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_07.jpg)'
- en: 'Figure 9.7: Output of the emit event after the listener has been removed'
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.7：移除监听器后发射事件的输出
- en: Because we just removed the listener to `event-with-type`, when we emit the
    event again, it will not be invoked.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们刚刚移除了对“event-with-type”的监听器，当我们再次发射事件时，它将不会被调用。
- en: In this exercise, we built a very simple event emitter and tested adding and
    removing listeners. Now, we know how to use events to pass messages from one component
    to another. Next, we will dig deeply into event listener methods and see what
    we can accomplish by calling them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们构建了一个非常简单的事件发射器，并测试了添加和移除监听器。现在，我们知道如何使用事件将消息从一个组件传递到另一个组件。接下来，我们将深入研究事件监听器方法，并看看通过调用它们我们可以实现什么。
- en: EventEmitter Methods
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件发射器方法
- en: In the previous exercise, we went over a couple of methods we can call to emit
    events and attach listeners. We also used `removeListener` to remove the listener
    we had attached. Now, we will go over the various methods we can call on the event
    listeners. This will help us manage event emitters much more easily.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们讨论了一些可以调用的方法来发射事件和附加监听器。我们还使用了`removeListener`来移除我们附加的监听器。现在，我们将讨论我们可以在事件监听器上调用的各种方法。这将帮助我们更轻松地管理事件发射器。
- en: Removing Listeners
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除监听器
- en: 'There are cases where we want to remove listeners from our emitter. Like we
    did in the previous exercise, we can remove a listener simply by calling `removeListener`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，我们希望从我们的发射器中移除监听器。就像我们在上一个练习中所做的那样，我们可以通过调用`removeListener`来简单地移除一个监听器：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we call the `removeListener` method, we must provide it with an event
    name and function reference. When we are calling the method, it doesn''t matter
    if the event listener is set or not; if the listener is not set to begin with,
    nothing will happen. If it is set, it will iterate through the array of the listener
    in our event emitter and remove the first occurrence of that listener, like so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`removeListener`方法时，我们必须为其提供事件名称和函数引用。当我们调用该方法时，无论事件监听器是否已设置都无关紧要；如果监听器一开始就没有设置，什么也不会发生。如果设置了，它将遍历我们的事件发射器中监听器的数组，并移除该监听器的第一次出现，就像这样：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this code, we attached the same listener three times. This is allowed in
    event emitters when we are attaching event listeners; it is simply appended to
    the event listener array for that event. When we emit our event before `removeListener`,
    we will see that our listener is invoked three times:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们三次附加了相同的监听器。在事件发射器中，当我们附加事件监听器时，允许这样做，它只是简单地追加到该事件的事件监听器数组中。当我们在`removeListener`之前发射我们的事件时，我们将看到我们的监听器被调用三次：
- en: '![Figure 9.8: Listener invoked three times with the emit event before removing
    the listener'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8：在移除监听器之前使用emit事件调用三次监听器'
- en: '](Images/C14587_09_08.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_08.jpg)'
- en: 'Figure 9.8: Listener invoked three times with the emit event before removing
    the listener'
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.8：在移除监听器之前使用emit事件调用三次监听器
- en: 'In this case, because we have three of the same listeners attached to our event,
    when we call `removeListener`, it will only remove the first listener in our `listener`
    array. When we emit the same event again, we will see that it will only runs two
    times:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，因为我们有三个相同的监听器附加到我们的事件上，当我们调用`removeListener`时，它只会移除我们的`listener`数组中的第一个监听器。当我们再次发射相同的事件时，我们会看到它只运行两次：
- en: '![Figure 9.9: After using removeListener, the first listener is removed'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9：使用removeListener后，第一个监听器被移除'
- en: '](Images/C14587_09_09.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_09.jpg)'
- en: 'Figure 9.9: After using removeListener, the first listener is removed'
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.9：使用removeListener后，第一个监听器被移除
- en: Removing all Listeners
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除所有监听器
- en: 'We can remove a specific listener from our event emitter. But often, when we
    are dealing with several listeners on our emitter, there are cases where we want
    to remove all listeners. The `EventEmitter` class provides us with a method that
    we can use to remove all the listeners for a specific event. Consider the same
    example we used previously:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从我们的事件发射器中删除特定的侦听器。但通常，当我们在发射器上处理多个侦听器时，有时我们希望删除所有侦听器。`EventEmitter`类为我们提供了一个方法，我们可以使用它来删除特定事件的所有侦听器。考虑我们之前使用的相同示例：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we wanted to remove all the listeners for the `event-with-type` event, we
    would have to call `removeListener` multiple times. Sometimes, when we are sure
    that all the event listeners have been added by us and no other component or module,
    we can use a single method call to remove all the listeners for that event:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要删除`event-with-type`事件的所有侦听器，我们将不得不多次调用`removeListener`。有时，当我们确定所有事件侦听器都是由我们添加的，没有其他组件或模块时，我们可以使用单个方法调用来删除该事件的所有侦听器：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When we are calling `removeAllListeners`, all we need to provide is the event
    name. This removes all the listeners attached to the event. After it is called,
    the event will have no handlers. Make sure you are not removing listeners that
    have been attached by another component if you are using this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`removeAllListeners`时，我们只需要提供事件名称。这将删除附加到事件的所有侦听器。调用后，事件将没有处理程序。确保您不要删除由另一个组件附加的侦听器，如果您使用此功能：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we emit the same event again after calling `removeAllListeners`, we will
    see that our program will output nothing:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在调用`removeAllListeners`后再次发出相同的事件时，我们将看到我们的程序不会输出任何内容：
- en: '![Figure 9.10: Using removeAllListeners will output nothing'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.10：使用`removeAllListeners`将不会输出任何内容'
- en: '](Images/C14587_09_10.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_10.jpg)'
- en: 'Figure 9.10: Using removeAllListeners will output nothing'
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.10：使用`removeAllListeners`将不会输出任何内容
- en: Attaching a One-Time Listener
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加一次性侦听器
- en: 'There are times when we want our component to receive a certain event only
    once. We can accomplish this by using `removeListener` to make sure we remove
    the listener after it is called:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望我们的组件只接收特定事件一次。我们可以通过使用`removeListener`来确保在调用后删除侦听器：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we can see that, in our `handleEvent` listener, we are also removing
    the listener after it has been executed. This way, we can make sure that our event
    listener will only be called once. When we run the preceding code, we will see
    this output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，在我们的`handleEvent`侦听器中，执行后我们还删除了侦听器。这样，我们可以确保我们的事件侦听器只会被调用一次。当我们运行上述代码时，我们将看到以下输出：
- en: '![Figure 9.11: Output after using the handleEvent listener'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.11：使用`handleEvent`侦听器后的输出'
- en: '](Images/C14587_09_11.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_11.jpg)'
- en: 'Figure 9.11: Output after using the handleEvent listener'
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.11：使用`handleEvent`侦听器后的输出
- en: 'This does what we want, but it is not good enough. It requires us to keep a
    reference of the emitter inside the event listener. Also, it is not robust enough
    because there is no way for us to separate the listener logic into a different
    file. The `EventEmitter` class provided us with a very simple method that can
    be used to attach a one-time listener:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这做到了我们想要的，但还不够好。它要求我们在事件侦听器中保留发射器的引用。此外，它还不够健壮，因为我们无法将侦听器逻辑分离到不同的文件中。`EventEmitter`类为我们提供了一个非常简单的方法，可以用来附加一次性侦听器：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we used the `.once` method when we were attaching our event listener.
    This tells our emitter that the function we are passing should only be invoked
    once and will be removed from the list of event listeners after it is invoked.
    When we run it, it will provide us with the same output as before:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当我们附加事件侦听器时，我们使用了`.once`方法。这告诉我们的发射器，我们传递的函数应该只被调用一次，并且在被调用后将从事件侦听器列表中删除。当我们运行它时，它将为我们提供与以前相同的输出：
- en: '![Figure 9.12: Getting a one-time listener using the .once method'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：使用`.once`方法获取一次性侦听器
- en: '](Images/C14587_09_12.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_12.jpg)'
- en: 'Figure 9.12: Getting a one-time listener using the .once method'
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.12：使用`.once`方法获取一次性侦听器
- en: This way, we do not need to keep a reference to our event emitter in our listener.
    This makes our code more flexible and easily modularized.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就不需要在侦听器中保留对事件发射器的引用。这使我们的代码更灵活，更容易模块化。
- en: Reading from Event Emitters
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从事件发射器中读取
- en: 'Until now, we have been setting and removing listeners from our event emitter.
    The `EventEmitter` class also provides us with several read methods where we can
    get more information about our event emitter. Consider the following example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在设置和删除事件发射器的侦听器。`EventEmitter`类还为我们提供了几种读取方法，我们可以从中获取有关事件发射器的更多信息。考虑以下示例：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we added three types of event listeners to our emitter. For `event 2`,
    we set two listeners to it. To get the number of event listeners for a certain
    event in our emitter, we can call `listenerCount`. For the preceding example,
    if we want to know the number of event listeners that are attached to `event 1`,
    we can execute the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向我们的发射器添加了三种类型的事件侦听器。对于`event 2`，我们为其设置了两个侦听器。要获取我们的发射器中特定事件的事件侦听器数量，我们可以调用`listenerCount`。对于上面的示例，如果我们想要知道附加到`event
    1`的事件侦听器的数量，我们可以执行以下命令：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following is the output of the preceding code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 9.13: Output showing the number of events attached to event 1'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：输出显示附加到事件1的事件数量
- en: '](Images/C14587_09_13.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_13.jpg)'
- en: 'Figure 9.13: Output showing the number of events attached to event 1'
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.13：输出显示附加到事件1的事件数量
- en: 'Similarly, we can check the number of event listeners attached to `event 2`
    by executing the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过执行以下命令来检查附加到`event 2`的事件侦听器的数量：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is the output of the preceding code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 9.14: Output showing the number of events attached to event 2'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14：输出显示附加到事件2的事件数量'
- en: '](Images/C14587_09_14.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_14.jpg)'
- en: 'Figure 9.14: Output showing the number of events attached to event 2'
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.14：输出显示附加到事件2的事件数量
- en: 'There are times when we want to know about a list of event listeners that are
    attached to an event so that we can determine whether a certain handler is already
    attached, like so:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想要知道已经附加到事件的事件监听器列表，以便我们可以确定某个处理程序是否已经附加，就像这样：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we have attached one anonymous function to `event 4` and another listener
    using a named function. If we want to know whether `anotherHandler` is already
    attached to `event 4`, we can attach a list of listeners to that event. The `EventEmitter`
    class provides us with a very easy method to invoke this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们附加了一个匿名函数到`event 4`，并使用一个命名函数附加了另一个监听器。如果我们想知道`anotherHandler`是否已经附加到`event
    4`，我们可以附加一个监听器列表到该事件。`EventEmitter`类为我们提供了一个非常简单的方法来调用这个：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the output of the preceding code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 9.15: Getting a list of listeners attached to the event using the
    EventEmitter class'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15：使用EventEmitter类获取附加到事件的监听器列表'
- en: '](Images/C14587_09_15.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_15.jpg)'
- en: 'Figure 9.15: Getting a list of listeners attached to the event using the EventEmitter
    class'
  id: totrans-158
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.15：使用EventEmitter类获取附加到事件的监听器列表
- en: 'Here, we can see the two listeners we have already attached to our emitter:
    one is our anonymous function, while the other is our named function, `anotherHandler`.
    To check whether our handler is already attached to the emitter, we can check
    to see if `anotherHandler` is in the `event4Listeners` array:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们已经附加到我们的发射器的两个监听器：一个是我们的匿名函数，另一个是我们的命名函数`anotherHandler`。要检查我们的处理程序是否已经附加到发射器，我们可以检查`event4Listeners`数组中是否有`anotherHandler`：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following is the output of the preceding code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 9.16: Checking whether the handler is attached to the emitter'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16：检查处理程序是否附加到发射器'
- en: '](Images/C14587_09_16.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_16.jpg)'
- en: 'Figure 9.16: Checking whether the handler is attached to the emitter'
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.16：检查处理程序是否附加到发射器
- en: By using this method with the array includes a method, we can determine whether
    a function is already attached to our event.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个方法和数组包含一个方法，我们可以确定一个函数是否已经附加到我们的事件。
- en: Getting a List of Events That Have Listeners Registered
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取已注册监听器的事件列表
- en: 'There are also times when we need to get a list of events that have listeners
    registered to them. This could be used to determine whether we have already attached
    listeners to an event or to see if an event name is already taken. Continuing
    from the preceding example, we can get that information by calling another internal
    method in the `EventEmitter` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要获取已注册监听器的事件列表。这可以用于确定我们是否已经为事件附加了监听器，或者查看事件名称是否已经被使用。继续前面的例子，我们可以通过调用`EventEmitter`类中的另一个内部方法来获取这些信息：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the output of the preceding code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 9.17: Getting information on event names using the EventEmitter class'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.17：使用EventEmitter类获取事件名称的信息'
- en: '](Images/C14587_09_17.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_17.jpg)'
- en: 'Figure 9.17: Getting information on event names using the EventEmitter class'
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.17：使用EventEmitter类获取事件名称的信息
- en: Here, we can see that our event emitter has listeners attached to four different
    event types; that is, events 1-4.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的事件发射器已经附加到四种不同的事件类型的监听器；即事件1-4。
- en: Max Listeners
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最大监听器
- en: 'By default, each event emitter can only register a maximum of 10 listeners
    for any single event. When we attach more than the maximum, we will get a warning
    like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个事件发射器只能为任何单个事件注册最多10个监听器。当我们附加超过最大数量时，我们将收到类似这样的警告：
- en: '![Figure 9.18: Warning when attaching more than 10 listeners for a single event'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.18：为单个事件附加超过10个监听器时的警告'
- en: '](Images/C14587_09_18.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_18.jpg)'
- en: 'Figure 9.18: Warning when attaching more than 10 listeners for a single event'
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.18：为单个事件附加超过10个监听器时的警告
- en: 'This is set as a preventive measure to make sure that we aren''t leaking memory,
    but there are also times where we need to set more than 10 listeners for an event.
    If we are sure of that, we can update the default maximum by calling `setMaxListeners`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了确保我们不会泄漏内存而设置的预防措施，但也有时我们需要为一个事件设置超过10个监听器。如果我们确定了，我们可以通过调用`setMaxListeners`来更新默认的最大值：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we set the max listener default to `20`. We can also set it to `0` or
    Infinity to allow an unlimited number of listeners.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将最大监听器默认设置为`20`。我们也可以将其设置为`0`或无穷大，以允许无限数量的监听器。
- en: Prepend Listeners
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在事件之前添加监听器
- en: 'When we add listeners, they are appended to the end of the listener array.
    When an event is emitted, the emitter will call each of the assigned listeners
    in the order they were assigned. In some cases, where we need our listener to
    be invoked first, we can use a built-in method provided by the event emitter to
    accomplish this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加监听器时，它们被附加到监听器数组的末尾。当事件被发出时，发射器将按照它们被分配的顺序调用每个分配的监听器。在某些情况下，我们需要我们的监听器首先被调用，我们可以使用事件发射器提供的内置方法来实现这一点：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, we attached `handleEventSecond` before `handleEventFirst`. When we emit
    the event, we will see the following output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`handleEventFirst`之前附加了`handleEventSecond`。当我们发出事件时，我们将看到以下输出：
- en: '![Figure 9.19: Emitting the event after attaching the second event before the
    first one'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.19：在第一个事件之前附加第二个事件后发出事件'
- en: '](Images/C14587_09_19.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_19.jpg)'
- en: 'Figure 9.19: Emitting the event after attaching the second event before the
    first one'
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.19：在第一个事件之前附加第二个事件后发出事件
- en: 'Because the event listeners are invoked in the order in which they are attached,
    we can see that when we emit the event, `handleEventSecond` is called first and
    `handleEventFirst` is called after. If we want `handleEventFirst` to be called
    first without modifying the order when they are attached using `emitter.on()`,
    we can call `prependListener`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因为事件监听器是按照它们附加的顺序调用的，我们可以看到当我们发出事件时，`handleEventSecond`首先被调用，然后是`handleEventFirst`。如果我们希望`handleEventFirst`在使用`emitter.on()`附加它们的顺序不变的情况下首先被调用，我们可以调用`prependListener`：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code will yield the following output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将产生以下输出：
- en: '![Figure 9.20: Ordering the event using prependListener'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.20：使用prependListener对事件进行排序'
- en: '](Images/C14587_09_20.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_20.jpg)'
- en: 'Figure 9.20: Ordering the event using prependListener'
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.20：使用prependListener对事件进行排序
- en: This can help us keep the order of our listeners and make sure the higher-priority
    listener is always called first. We will talk about concurrency in listeners next.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以帮助我们保持监听器的顺序，并确保优先级较高的监听器始终首先被调用。接下来我们将讨论监听器中的并发性。
- en: Concurrency in Listeners
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听器中的并发性
- en: 'In the previous chapters, we mentioned how we can attach multiple listeners
    to our emitter and how these work when an event is emitted. Later, we also talked
    about how to prepend listeners so that they are called first when an event is
    emitted. The reason we might want to prepend listeners is that when listeners
    are called, they are called one by one synchronously. Consider the following example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们提到了如何将多个监听器附加到我们的发射器上，以及在事件被触发时这些监听器是如何工作的。之后，我们还谈到了如何在事件被触发时添加监听器，使得它们首先被调用。我们可能想要添加监听器的原因是，当监听器被调用时，它们是同步一个接一个被调用的。考虑以下例子：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we have two listeners attached to the `event` type. When the event is
    emitted, it will call `slowHandle` first and `quickHandle` second. In `slowHandle`,
    we have a very large loop simulating a very time-consuming operation you can perform
    in the event listener. When we run the preceding code, we will first see `doing
    calculation` printed out, and then there will be a long wait until `I am called
    finally` is called. We can see that when the emitter invokes the event listeners,
    it does so synchronously. This might create issues for us because, in most cases,
    we do not want to wait for one listener to finish before we fire another one.
    There is an easy way to solve this, though: we can wrap our costly logic with
    the `setImmediate` function. The `setImmediate` function will wrap our logic into
    an immediately executed async block, meaning that the time-consuming loop is then
    non-blocking. We will cover the `setImmediate` function later in this book:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个附加到`event`类型的监听器。当事件被触发时，它将首先调用`slowHandle`，然后调用`quickHandle`。在`slowHandle`中，我们有一个非常大的循环，模拟一个在事件监听器中可以执行的非常耗时的操作。当我们运行前面的代码时，我们首先会看到`doing
    calculation`被打印出来，然后会有一个很长的等待，直到`I am called finally`被调用。我们可以看到，当发射器调用事件监听器时，它是同步进行的。这可能会给我们带来问题，因为在大多数情况下，我们不希望等待一个监听器完成后再触发另一个监听器。不过，有一种简单的解决方法：我们可以用`setImmediate`函数包装我们的耗时逻辑。`setImmediate`函数将我们的逻辑包装成一个立即执行的异步块，这意味着耗时的循环是非阻塞的。我们将在本书的后面介绍`setImmediate`函数：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When we wrap our costly logic with `setImmediate()`, the code outputs **doing
    calculation** and **I am called finally** at almost the same time. By wrapping
    all the logic with `setImmediate`, we can make sure that it is invoked asynchronously.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用`setImmediate()`包装我们的耗时逻辑时，代码几乎同时输出**doing calculation**和**I am called finally**。通过用`setImmediate`包装所有逻辑，我们可以确保它是异步调用的。
- en: Building Custom Event Emitters
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建自定义事件发射器
- en: 'There are cases where we want to build event emitting functionality into our
    own custom classes. We can do that by using **JavaScript ES6** inheritance. This
    allows us to create a custom class while extending all the functionality of event
    emitters. For example, let''s say we are building a class for fire alarms:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，我们希望将事件发射功能构建到我们自己的自定义类中。我们可以通过使用**JavaScript ES6**继承来实现这一点。这允许我们创建一个自定义类，同时扩展事件发射器的所有功能。例如，假设我们正在构建一个火警类：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we have a `FireAlarm` class with a constructor storing information about
    this fire alarm. It also has a couple of custom methods for testing the alarm,
    such as checking the battery level, and a `getDetail` method to return a string
    representing information about the alarm. After defining this class, we can use
    the `FireAlarm` class like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`FireAlarm`类，它有一个存储有关这个火警的信息的构造函数。它还有一些自定义方法来测试警报，比如检查电池电量，以及一个`getDetail`方法来返回表示警报信息的字符串。在定义了这个类之后，我们可以像这样使用`FireAlarm`类：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following is the output of the preceding code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 9.21: Defining the fire alarm class'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.21：定义火警类'
- en: '](Images/C14587_09_21.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_21.jpg)'
- en: 'Figure 9.21: Defining the fire alarm class'
  id: totrans-210
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.21：定义火警类
- en: 'Now, we want to set up events on the fire alarm we just created. One way we
    can do this is by creating a generic event emitter and storing that inside our
    `FireAlarm` object:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想在刚刚创建的火警上设置事件。我们可以通过创建一个通用事件发射器并将其存储在我们的`FireAlarm`对象中来实现这一点：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And when we want to watch the events on the alarm, we must do something like
    this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要监视警报上的事件时，我们必须这样做：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'While this is perfectly fine and will work for our use cases, this is certainly
    not the most robust solution. Because our fire alarm is the one emitting the event,
    we want something like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是完全可以的，并且对我们的用例有效，但这显然不是最健壮的解决方案。因为我们的火警是发出事件的一方，我们希望像这样：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'By using `.on` directly on the fire alarm, we tell the future developer who''s
    going to be working on this that our fire alarm is also an event emitter. But
    right now, our class definition does not allow one to be used. We can fix this
    by using class inheritance, where we can make our `FireAlarm` class extend the
    `EventEmitter` class. By doing that, it will have all the functionality of `EventEmitter`.
    We can modify our class like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接在火警上使用`.on`，我们告诉未来的开发人员，将要在这上面工作，我们的火警也是一个事件发射器。但是现在，我们的类定义不允许使用。我们可以通过使用类继承来解决这个问题，在那里我们可以使我们的`FireAlarm`类扩展`EventEmitter`类。通过这样做，它将拥有`EventEmitter`的所有功能。我们可以修改我们的类如下：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'By using the `extends` keyword followed by `EventEmitter`, we tell JavaScript
    that the `FireAlarm` class is a child class of `EventEmitter`. Therefore, it will
    inherit all the properties and methods from the parent. But this alone doesn''t
    solve everything. When we run our code with the updated `FireAlarm`, we will see
    that an error is thrown:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`extends`关键字后跟`EventEmitter`，我们告诉JavaScript`FireAlarm`类是`EventEmitter`的子类。因此，它将继承父类的所有属性和方法。但这本身并不能解决所有问题。当我们运行更新后的`FireAlarm`代码时，我们会看到抛出一个错误：
- en: '![Figure 9.22: An error is thrown when we run the code with the updated FireAlarm'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.22：当我们运行更新后的FireAlarm代码时会抛出错误'
- en: '](Images/C14587_09_22.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_22.jpg)'
- en: 'Figure 9.22: An error is thrown when we run the code with the updated FireAlarm'
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.22：当我们运行更新后的FireAlarm代码时会抛出错误
- en: 'This is happening because we are using a very customized class with a custom
    constructor and accessing `this` (this is used as a reference to the current object).
    We will need to make sure we call the parent constructor before that. To make
    this error disappear, we simply add a call to our parent constructor in our own
    constructor:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们使用了一个非常定制的类，具有自定义的构造函数，并访问`this`（这用作对当前对象的引用）。在此之前，我们需要确保在此之前调用父构造函数。为了使此错误消失，我们只需在自己的构造函数中添加对父构造函数的调用：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s test our own custom `EventEmitter`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试我们自己的自定义`EventEmitter`：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following is the output of the preceding code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 9.23: Event listener for the ''low-battery'' event triggered correctly'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.23：''low-battery''事件的事件监听器被正确触发'
- en: '](Images/C14587_09_23.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_23.jpg)'
- en: 'Figure 9.23: Event listener for the ''low-battery'' event triggered correctly'
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.23：'low-battery'事件的事件监听器被正确触发
- en: Here, we can see that we are treating `livingRoomAlarm` just like a regular
    `EventEmitter`, and when we emit the *low-battery* event, we see that the event
    listener for that event is triggered correctly. In the next exercise, we will
    make a very simple chatroom application with everything we have learned about
    `EventEmitters`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们将`livingRoomAlarm`视为常规的`EventEmitter`，当我们发出*low-battery*事件时，我们看到该事件的事件监听器被正确触发。在下一个练习中，我们将使用我们对`EventEmitters`的所有了解制作一个非常简单的聊天室应用程序。
- en: 'Exercise 68: Building A Chatroom Application'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习68：构建聊天室应用程序
- en: Previously, we talked about how to attach event listeners and emit events on
    our event emitter. In this exercise, we will build a simple piece of chatroom
    managing software that communicates with events. We will create multiple components
    and see how we can make them communicate with each other.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了如何在我们的事件发射器上附加事件监听器并发出事件。在这个练习中，我们将构建一个简单的聊天室管理软件，该软件使用事件进行通信。我们将创建多个组件，并查看如何使它们相互通信。
- en: 'Note:'
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：
- en: The code files for this exercise can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson09/Exercise68](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson09/Exercise68).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码文件可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson09/Exercise68](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson09/Exercise68)找到。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: 'Create a `User` class:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`User`类：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we created a `User` class for our user. It has a `joinRoom` method that
    we can call to join that user to a room. It also has a `sendMessage` method, which
    will send the message to everyone in the room. When we join a room, we also listen
    to all the new message events from that room and append messages when we receive
    them.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为用户创建了一个`User`类。它有一个`joinRoom`方法，我们可以调用该方法将用户加入房间。它还有一个`sendMessage`方法，该方法将消息发送给房间中的所有人。当我们加入一个房间时，我们还会监听来自该房间的所有新消息事件，并在接收到消息时追加消息。
- en: 'Create a `Room` class that extends the `EventEmitter` class:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展`EventEmitter`类的`Room`类：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we created a new `Room` class by extending the existing `EventEmitter`
    class. The reason we are doing this is that we want to have our own custom properties
    on our `room` object, and this creates more flexibility in our code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过扩展现有的`EventEmitter`类创建了一个新的`Room`类。我们这样做的原因是我们希望在我们的`room`对象上拥有自定义属性，并且这样可以增加代码的灵活性。
- en: 'Create two users, `bob` and `kevin`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个用户，`bob`和`kevin`：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a room using our `Room` class:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的`Room`类创建一个房间：
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Join `bob` and `kevin` to `lobby`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`bob`和`kevin`加入`lobby`：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Send a couple of messages from `bob`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`bob`发送几条消息：
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Print the message log for `bob`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印`bob`的消息日志：
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following is the output of the preceding code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 9.24: Printing the message log for bob'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.24：打印bob的消息日志'
- en: '](Images/C14587_09_24.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_24.jpg)'
- en: 'Figure 9.24: Printing the message log for bob'
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.24：打印bob的消息日志
- en: Here, you can see that all of our messages are added correctly to the log of
    `bob`. Next, we will check the log of `kevin`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们所有的消息都正确添加到了`bob`的日志中。接下来，我们将检查`kevin`的日志。
- en: 'Print the message log for `kevin`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印`kevin`的消息日志：
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following is the output of the preceding code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 9.25: Printing the message log for kevin'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.25：打印kevin的消息日志'
- en: '](Images/C14587_09_25.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_25.jpg)'
- en: 'Figure 9.25: Printing the message log for kevin'
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.25：打印kevin的消息日志
- en: Even though we never explicitly did anything with `kevin`, he is receiving all
    the messages because he is listening to a new message event in the room.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们从未明确对`kevin`做过任何事情，他也会收到所有消息，因为他正在监听房间中的新消息事件。
- en: 'Send messages from `kevin` and `bob`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`kevin`和`bob`发送消息：
- en: '[PRE52]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Check the message log for `kevin`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`kevin`的消息日志：
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following is the output of the preceding code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 9.26: Checking the message log for kevin'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.26：检查kevin的消息日志'
- en: '](Images/C14587_09_26.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_26.jpg)'
- en: 'Figure 9.26: Checking the message log for kevin'
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.26：检查kevin的消息日志
- en: Here, we can see that all our messages are added correctly to our `user` objects.
    Because we are using event emitters, we avoided passing references of our receiver
    around. Also, because we are emitting the message event on our room and our users
    just listen to that event, we do not need to manually iterate through all the
    users in the room and pass the message on.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到所有我们的消息都正确地添加到我们的`user`对象中。因为我们使用事件发射器，所以我们避免了在我们的接收者周围传递引用。此外，因为我们在我们的房间上发出了消息事件，而我们的用户只是监听该事件，所以我们不需要手动遍历房间中的所有用户并传递消息。
- en: 'Let''s modify `joinRoom` and `constructor` so that we can remove the listener
    later:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改`joinRoom`和`constructor`，以便稍后可以移除监听器：
- en: '[PRE54]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When we remove our listener, we need to pass a reference of that listener function,
    Because of this, we need to store that reference in the object so that we can
    use it to remove our listener later.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们移除监听器时，我们需要传递该监听器函数的引用，因此，我们需要将该引用存储在对象中，以便稍后可以使用它来移除我们的监听器。
- en: 'Add `leaveRoom`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`leaveRoom`：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we are using the function reference we set in our constructor and passing
    it to the `removeListener` for our room. We also removed the reference in our
    object so that it can be released in memory later.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用我们在构造函数中设置的函数引用，并将其传递给我们房间的`removeListener`。我们还从对象中移除了引用，以便稍后可以释放内存。
- en: 'Remove `bob` from `room`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`room`中移除`bob`：
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Send a message from `kevin`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`kevin`发送一条消息：
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Check the message list for `bob`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`bob`的消息列表：
- en: '[PRE58]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The following is the output of the preceding code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 9.27: Checking the message list for bob'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.27：再次检查鲍勃的消息列表'
- en: '](Images/C14587_09_27.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_27.jpg)'
- en: 'Figure 9.27: Checking the message list for bob'
  id: totrans-289
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.27：检查鲍勃的消息列表
- en: Because `bob` left the room, and we removed the message listener, the `newMessage`
    event handler is not invoked again when a new message event is emitted.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`bob`离开了房间，并且我们移除了消息监听器，所以当发出新消息事件时，`newMessage`事件处理程序不会再被调用。
- en: 'Check the message list for `kevin`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`kevin`的消息列表：
- en: '[PRE59]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following is the output of the preceding code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 9.28: Checking the message list for kevin again'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.28：再次检查kevin的消息列表'
- en: '](Images/C14587_09_28.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_28.jpg)'
- en: 'Figure 9.28: Checking the message list for kevin again'
  id: totrans-296
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.28：再次检查kevin的消息列表
- en: When we check the message list for `kevin`, we should still able to see that
    he is still getting new messages from the room. If this was done using the traditional
    approach, we would need to write way more code to accomplish the same thing, which
    would be very error-prone.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查`kevin`的消息列表时，我们应该仍然能够看到他仍然从房间中收到新消息。如果使用传统方法来完成这项工作，我们将需要编写更多的代码来完成相同的事情，这将非常容易出错。
- en: In this exercise, we built a mock chat application with events in Node.js. We
    can see how easy passing events is in Node.js and how we can use it properly.
    Event-driven programming is not for every application, but when we need to connect
    multiple components together, it is much easier to implement that logic with events.
    The preceding code can still be improved – we can add notifications to the room
    when a user leaves a room and we can add checks while adding and removing rooms
    to make sure we aren't adding a duplicate room and make sure we are only removing
    rooms that we are in. Please feel free to extend this functionality on your own.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用Node.js构建了一个带有事件的模拟聊天应用程序。我们可以看到在Node.js中传递事件是多么容易，以及我们如何正确使用它。事件驱动编程并不适用于每个应用程序，但是当我们需要将多个组件连接在一起时，使用事件来实现这种逻辑要容易得多。上述代码仍然可以改进-我们可以在用户离开房间时向房间添加通知，并且我们可以在添加和移除房间时添加检查，以确保我们不会添加重复的房间，并确保我们只移除我们所在的房间。请随意自行扩展此功能。
- en: During this chapter we went over ways we can use events to manage the communication
    between components in our applications. In the next activity, we will build an
    event-driven module.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用事件来管理应用程序中组件之间的通信。在下一个活动中，我们将构建一个基于事件驱动的模块。
- en: 'Activity 13: Building an Event-Driven Module'
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动13：构建一个基于事件驱动的模块
- en: 'Suppose you are working for a software company that builds simulators for smoke
    detectors. You need to build a smoke detector simulator that raises an alarm when
    the detector''s battery drops below a certain level. Here are the requirements:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在为一家构建烟雾探测器模拟器的软件公司工作。您需要构建一个烟雾探测器模拟器，当探测器的电池电量低于一定水平时会引发警报。以下是要求：
- en: The detector needs to emit an `alarm event`.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探测器需要发出`警报事件`。
- en: The smoke detector needs to emit a *low battery* event when the battery is below
    0.5 units.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当电池低于0.5单位时，烟雾探测器需要发出*低电量*事件。
- en: Each smoke detector has 10 units of battery level when it's initially created.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个烟雾探测器在初始创建时都有10个单位的电池电量。
- en: The test function on the smoke detector will return true if the battery level
    is above 0 and false if it's below 0\. Each time a test function is run, it will
    decrease the battery by 0.1 units.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 烟雾探测器上的测试函数如果电池电量高于0则返回true，如果低于0则返回false。每次运行测试函数时，电池电量将减少0.1个单位。
- en: You need to modify the provided `House` class to add the `addDetector` and `demoveDetector`
    methods.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要修改提供的`House`类以添加`addDetector`和`demoveDetector`方法。
- en: '`addDetector` will take a detector object and attach a listener for the alarm
    event before printing out both *low battery* and an *alarm event* when they are
    emitted.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addDetector`将接受一个探测器对象，并在打印出*低电量*和*警报事件*之前，为警报事件附加一个监听器。'
- en: The `removeDetector` method will take a **detector** object and remove the listeners.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeDetector`方法将接受一个**探测器**对象并移除监听器。'
- en: 'Perform the following steps to complete this activity:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动，执行以下步骤：
- en: Open the `event.js` file and find the existing code. Then, modify and add your
    own changes to it.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`event.js`文件并找到现有的代码。然后，修改并添加你自己的更改。
- en: Import the `events` module.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`events`模块。
- en: Create the `SmokeDetector` class that extends `EventEmitter` and set `batteryLevel`
    to `10`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`SmokeDetector`类，该类扩展`EventEmitter`并将`batteryLevel`设置为`10`。
- en: Create a `test` method inside the `SmokeDetector` class to emit the *low battery*
    message.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SmokeDetector`类内创建一个`test`方法来发出*低电量*消息。
- en: Create the `House` class, which will store the instances of our alarms.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`House`类，它将存储我们警报的实例。
- en: Create an `addDetector` method in the `House` class, which will attach the event
    listeners.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`House`类中创建一个`addDetector`方法，它将附加事件监听器。
- en: Create a `removeDetector` method, which will help us remove the *alarm event*
    listeners we attached previously.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`removeDetector`方法，它将帮助我们移除之前附加的*警报事件*监听器。
- en: Create a `House` instance called `myHouse.`
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`myHouse`的`House`实例。
- en: Create a `SmokeDetector` instance called `detector`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`detector`的`SmokeDetector`实例。
- en: Add the detector to `myHouse.`
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将探测器添加到`myHouse`中。
- en: Create a loop to call the test function 96 times.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环来调用测试函数96次。
- en: Emit an alarm on the `detector` object.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`detector`对象上发出警报。
- en: Remove the detector from the `myHouse` object.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`myHouse`对象中移除探测器。
- en: Test it to emit alarms on the detector.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在探测器上测试发出警报。
- en: Note
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 617.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第617页找到。
- en: In this activity, we learned how we can model a smoke detector using event-driven
    programming. By using this approach, we eliminated the need to store multiple
    instances in our `House` object and avoided using many lines of code for their
    interactions.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们学习了如何使用事件驱动编程来建模烟雾探测器。通过使用这种方法，我们消除了在我们的`House`对象中存储多个实例的需要，并避免使用大量代码来进行它们的交互。
- en: In the section, we went over ways we can use the event system fully to help
    us manage complex communications in our application. In the next section, we will
    go over some of the best practices for working with event emitters.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何充分利用事件系统来帮助我们管理应用程序中的复杂通信。在下一节中，我们将介绍一些处理事件发射器的最佳实践。
- en: Event-Driven Programming Best Practices
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件驱动编程最佳实践
- en: In the previous chapter, we mentioned ways we can create event-driven components
    using the event emitter and event emitter inheritance. But often, your code needs
    to be more than just able to work correctly. Having a better-managed code structure
    will not only make our code look less messy, it can also help us avoid making
    some avoidable mistakes in the future. In this section, we will go over some of
    the best practices when dealing with events in our code.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们提到了使用事件发射器和事件发射器继承创建事件驱动组件的方法。但通常，您的代码需要的不仅仅是能够正确工作。拥有更好管理的代码结构不仅可以使我们的代码看起来不那么凌乱，还可以帮助我们避免将来一些可避免的错误。在本节中，我们将介绍在处理代码中的事件时的一些最佳实践。
- en: 'Recalling what we went over at the beginning of this chapter, we can pass events
    using the `EventEmitter` object:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下我们在本章开头所讨论的内容，我们可以使用`EventEmitter`对象传递事件：
- en: '[PRE60]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When we want to use the event emitter we have created, we will need to have
    its reference so that we can attach listeners and call the `emit` function on
    the emitter when we want to emit events later. This might cause our source code
    to be incredibly large, which will make future maintenance very difficult:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要使用我们创建的事件发射器时，我们需要有它的引用，这样我们才能在以后想要发出事件时附加监听器并调用发射器的`emit`函数。这可能会导致我们的源代码非常庞大，这将使未来的维护非常困难：
- en: '[PRE61]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To be able to use our emitters, we need to make sure that our emitter is accessible
    in the current scope. One way to do this is to create a file to keep all our emitters
    and the logic for attaching the event listeners. While this simplifies our code
    a lot, we will create very large source code that will confuse future developers,
    and maybe even us. To make our code more modularized, we can start by pulling
    all the listener functions into their respective files. Consider the following
    huge source code:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用我们的发射器，我们需要确保我们的发射器在当前范围内是可访问的。做到这一点的一种方法是创建一个文件来保存所有我们的发射器和附加事件监听器的逻辑。虽然这样大大简化了我们的代码，但我们将创建非常庞大的源代码，这将使未来的开发人员困惑，甚至可能连我们自己也会困惑。为了使我们的代码更模块化，我们可以开始将所有的监听器函数放入它们各自的文件中。考虑以下庞大的源代码：
- en: '[PRE62]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Just by doing this, we have considerably reduced the file size of our code.
    But we can do more. One way to keep our code organized is to put all the emitters
    in one file and then import it when we need them. We can do that by creating a
    file called `emitters.js` and storing all the emitters in that file:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过这样做，我们已经大大减少了我们代码的文件大小。但我们可以做得更多。保持我们代码有组织的一种方法是将所有的发射器放在一个文件中，然后在需要时导入它。我们可以通过创建一个名为`emitters.js`的文件，并将所有的发射器存储在该文件中来实现这一点：
- en: '[PRE63]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'What we did here is to create all our emitters in one file and set that `emitter`
    file to the exports module. By doing this, we can have all the emitters in one
    place and then, when we use the emitters, we can just import the file. This changes
    our code to the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是在一个文件中创建所有的发射器，并将该`emitter`文件设置为导出模块。通过这样做，我们可以将所有的发射器放在一个地方，然后当我们使用发射器时，我们只需导入该文件。这将改变我们的代码如下：
- en: '[PRE64]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, when we import `emitter.js`, we can use object restructuring to only pick
    the emitter we want. We can have multiple emitters in one file, and we can just
    pick the one we want when we require it. When we want to emit an event on the
    `userEmitter`, all we need to do is import the emitter into our code and send
    that event over:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们导入`emitter.js`时，我们可以使用对象解构来只选择我们想要的发射器。我们可以在一个文件中拥有多个发射器，然后在需要时选择我们想要的发射器。当我们想要在`userEmitter`上发出事件时，我们只需将发射器导入我们的代码并发送该事件即可：
- en: '[PRE65]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can see that whenever we want to use `userEmitter`, we can just import our
    `emitter` file over. This also applies when we want to attach listeners:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，每当我们想要使用`userEmitter`时，我们只需导入我们的`emitter`文件。当我们想要附加监听器时，也适用这一点：
- en: '[PRE66]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: When we separate our emitters into different files, we not only make our code
    smaller but also make it more modular. By pulling our emitters into a separate
    file, it makes it very easy for us to reuse that file if we want to access our
    emitters in the future. By doing this, we do not need to pass our emitters around
    in functions, thus ensuring that our function declaration isn't cluttered.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将我们的发射器分成不同的文件时，我们不仅使我们的代码更小，而且使其更模块化。通过将我们的发射器拉入一个单独的文件，如果我们将来想要访问我们的发射器，那么我们可以很容易地重用该文件。通过这样做，我们不需要在函数中传递我们的发射器，从而确保我们的函数声明不会混乱。
- en: Node.js Built-In Modules
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js内置模块
- en: In the previous section, we extensively went over the `events` module and learned
    everything about using events to achieve easy communication within our applications.
    The `events` module is a built-in module offered by Node.js, meaning that we do
    not need to use `npm` to install it. In this module, we will discuss how to use
    the `fs`, `path`, and `util` modules.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们广泛讨论了`events`模块，并学习了如何使用事件来实现应用程序内的简单通信。`events`模块是Node.js提供的内置模块，这意味着我们不需要使用`npm`来安装它。在这个模块中，我们将讨论如何使用`fs`、`path`和`util`模块。
- en: path
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: path
- en: The `path` module is a built-in module that provides utilities that can help
    us work with file paths and filenames.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`path`模块是一个内置模块，提供了一些工具，可以帮助我们处理文件路径和文件名。'
- en: '**path.join(…paths)**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**path.join(…paths)**'
- en: '`Path.join()` is a very useful function when we are working with directories
    and files in our applications. It allows us to join paths together and output
    a path string that we can use in the **fs** module. To use `join` paths, we can
    call the `join` method and provide it with a list of paths. Let''s look at the
    following example:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path.join()`是一个非常有用的函数，当我们在应用程序中处理目录和文件时。它允许我们将路径连接在一起，并输出一个路径字符串，我们可以在**fs**模块中使用。要使用`join`路径，我们可以调用`join`方法，并为其提供一组路径。让我们看下面的例子：'
- en: '[PRE67]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we want to access the data directory in our current directory, we can use
    the `path.join` function to combine different paths into one string:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要访问我们当前目录中的数据目录，我们可以使用`path.join`函数将不同的路径组合成一个字符串：
- en: '[PRE68]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following is the output of the preceding code:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 9.29: Using the path.join function to combine different paths'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.29：使用path.join函数组合不同的路径'
- en: '](Images/C14587_09_29.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_29.jpg)'
- en: 'Figure 9.29: Using the path.join function to combine different paths'
  id: totrans-357
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.29：使用path.join函数组合不同的路径
- en: 'It also works with `..` and `.`, if you are familiar with how the POSIX system
    signifies the current directory and parent directories. `..` represents the parent
    directory while `.` represents the current directory. For example, the following
    code can give us the path of the parent directory of our current directory:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以处理`..`和`.`，如果你熟悉POSIX系统如何表示当前目录和父目录。`..`表示父目录，而`.`表示当前目录。例如，以下代码可以给出我们当前目录的父目录的路径：
- en: '[PRE69]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The following is the output of the preceding code:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 9.30: Showing the parent directory of our current directory'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.30：显示我们当前目录的父目录'
- en: '](Images/C14587_09_30.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_30.jpg)'
- en: 'Figure 9.30: Showing the parent directory of our current directory'
  id: totrans-363
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.30：显示我们当前目录的父目录
- en: '**path.parse(path)**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**path.parse(path)**'
- en: 'When we want to get information about a file path, we can use the `path.parse()`
    function to get its root directory, base directory, filename, and extension. Let''s
    look at the following example:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要获取有关文件路径的信息时，我们可以使用`path.parse()`函数来获取其根目录、基本目录、文件名和扩展名。让我们看下面的例子：
- en: '[PRE70]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If we want to parse this file path, we can call `path.parse` with the `myData`
    string to get the different path elements:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要解析这个文件路径，我们可以使用`path.parse`调用`myData`字符串来获取不同的路径元素：
- en: '[PRE71]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This will generate the following output:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Figure 9.31: File path parsed using the path.parse function'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.31：使用path.parse函数解析的文件路径'
- en: '](Images/C14587_09_31.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_31.jpg)'
- en: 'Figure 9.31: File path parsed using the path.parse function'
  id: totrans-372
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.31：使用path.parse函数解析的文件路径
- en: Here, we can see that our file path includes a filename with a base name of
    `data.json`. The extension is `.json` and the filename is `data`. It also parsed
    out the directory in which the file is present.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的文件路径包括一个文件名，基本名称为`data.json`。扩展名是`.json`，文件名是`data`。它还解析出文件所在的目录。
- en: '**path.format(path)**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**path.format(path)**'
- en: 'In the previous `parse` function, we managed to parse out our file path into
    its respected components. We can use `path.format` to combine that information
    into a single string path. Let''s have a look at it:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`parse`函数中，我们成功地将文件路径解析为其各自的组件。我们可以使用`path.format`将这些信息组合成一个单一的字符串路径。让我们来看一下：
- en: '[PRE72]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The following is the output of the preceding code:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 9.32: Combining information into a single string path using path.format'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.32：使用path.format将信息组合成单个字符串路径'
- en: '](Images/C14587_09_32.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_32.jpg)'
- en: 'Figure 9.32: Combining information into a single string path using path.format'
  id: totrans-380
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.32：使用path.format将信息组合成单个字符串路径
- en: This gives us the file path from the components we supplied to it.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了从我们提供给它的组件中生成的文件路径。
- en: fs
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fs
- en: The **fs** module is a built-in module that provides APIs for you so that you
    can interact with the host filesystem. It is very useful when we need to work
    with files in our application. In this section, we will talk about how we can
    use the **fs** module in our application with `async` and `await`. Later, we will
    go over the recently added `fs.promises` API, which provides the same functionality
    but returns a promise rather than using callbacks.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**fs**模块是一个内置模块，为您提供API，以便您可以与主机文件系统进行交互。当我们需要在应用程序中处理文件时，它非常有用。在本节中，我们将讨论如何在我们的应用程序中使用**fs**模块与`async`和`await`。稍后，我们将介绍最近添加的`fs.promises`API，它提供相同的功能，但返回一个promise而不是使用回调。'
- en: Note
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'In this section, we will be using a POSIX system. If you are using a Windows
    system, make sure that you update the file path to the Windows equivalent. To
    import the fs module into your code, execute the following command:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将使用POSIX系统。如果你使用的是Windows系统，请确保将文件路径更新为Windows的等价物。要将fs模块导入到你的代码中，执行以下命令：
- en: '[PRE73]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '**fs.createReadStream(path, options)**'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**fs.createReadStream(path, options)**'
- en: 'When we are dealing with large files in Node.js, it is advised to always use
    `stream`. To create a read stream, we can call the `fs.createReadStream` method.
    It will return a stream object that we can attach to event handlers so that they
    get the content of the file:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Node.js中处理大文件时，建议始终使用`stream`。要创建一个读取流，我们可以调用`fs.createReadStream`方法。它将返回一个流对象，我们可以将其附加到事件处理程序，以便它们获取文件的内容：
- en: '[PRE74]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '**fs.createWriteStream(path, options)**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**fs.createWriteStream(path, options)**'
- en: 'This works similar to `createReadStream`, but instead creates a writable stream
    that we can use to stream contents to it:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`createReadStream`类似，但是创建了一个可写流，我们可以用它来流式传输内容：
- en: '[PRE75]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '**fs.stat(path, callback)**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**fs.stat(path, callback)**'
- en: The `fs.stat` method is very useful when we need detailed information about
    the file we are accessing. We also see many developers use `fs.stat` to check
    for the existence of the file before calling, opening, reading, or writing data
    to it. While checking the file's existence using `stat` doesn't create any new
    issues, it is not recommended to do this. We should just use the error that's
    returned from the function we are using; this will eliminate any extra layers
    of logic and can reduce the number of API calls.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要关于我们正在访问的文件的详细信息时，`fs.stat`方法非常有用。我们还看到许多开发人员在调用、打开、读取或写入数据之前使用`fs.stat`来检查文件的存在。虽然使用`stat`检查文件的存在不会创建任何新问题，但不建议这样做。我们应该只使用从我们使用的函数返回的错误；这将消除任何额外的逻辑层，并可以减少API调用的数量。
- en: 'Consider the following example:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '[PRE76]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This will give us output similar to the following:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个类似以下的输出：
- en: '![Figure 9.33: Output after using the fs.stat method'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.33：使用fs.stat方法后的输出'
- en: '](Images/C14587_09_33.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_33.jpg)'
- en: 'Figure 9.33: Output after using the fs.stat method'
  id: totrans-400
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.33：使用fs.stat方法后的输出
- en: '**fs.readFile(path, options, callback)**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**fs.readFile(path, options, callback)**'
- en: This is the function that most people will be familiar with. When supplied with
    a file path, the method will attempt to read the entire content of a file. It
    will do so in an async fashion, and the callback will be called with the entire
    content of the file. When the file doesn't exist, the callback will be called
    with an error.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这是大多数人熟悉的函数。当提供文件路径时，该方法将尝试以异步方式读取文件的整个内容。它将以异步方式执行，并且回调将被调用以获取文件的整个内容。当文件不存在时，回调将被调用以获取错误。
- en: 'Consider the following example:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子：
- en: '[PRE77]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This will give us the following output:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下输出：
- en: '![Figure 9.34: Reading the entire content of a file using the fs.readFile function'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.34：使用fs.readFile函数读取文件的整个内容'
- en: '](Images/C14587_09_34.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_34.jpg)'
- en: 'Figure 9.34: Reading the entire content of a file using the fs.readFile function'
  id: totrans-408
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.34：使用fs.readFile函数读取文件的整个内容
- en: 'This didn''t output the result we wanted. This is because we didn''t supply
    the encoding in our options; to read the contents into a string, we will need
    to supply encoding options. This changes our code into the following:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有输出我们想要的结果。这是因为我们没有在选项中提供编码；要将内容读入字符串，我们需要提供编码选项。这将改变我们的代码为以下内容：
- en: '[PRE78]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, when we run the preceding code, it will give us the following output:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行上述代码时，它会给我们以下输出：
- en: '![Figure 9.35: Reading the entire content of a file using the fs.readFile function
    after encoding'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.35：使用fs.readFile函数读取文件的整个内容后编码'
- en: '](Images/C14587_09_35.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_35.jpg)'
- en: 'Figure 9.35: Reading the entire content of a file using the fs.readFile function
    after encoding'
  id: totrans-414
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.35：使用fs.readFile函数读取文件的整个内容后编码
- en: We just made a program that output itself.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚做了一个输出自身的程序。
- en: '**fs.readFileSync(path, options)**'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**fs.readFileSync(path, options)**'
- en: This function does the same thing as the `readFile` method, but executes the
    `read` function synchronously, meaning it will block execution. During program
    startup, it is recommended – and is expected – to be called only once. The synchronous
    function is not recommended when it needs to be invoked more than once.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数和`readFile`方法做的事情一样，但是以同步的方式执行`read`函数，这意味着它会阻塞执行。在程序启动期间，建议 - 并且期望 - 只调用一次。当需要多次调用时，不建议使用同步函数。
- en: '**fs.writeFile(file, data, options, callback)**'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '**fs.writeFile(file, data, options, callback)**'
- en: The `writeFile` function writes data to the file we specified. It will also
    replace the existing file unless you pass an append as `flag` to options.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeFile`函数将数据写入我们指定的文件。它还将替换现有的文件，除非你在选项中传递一个附加的`flag`。'
- en: '**fs.writeFileSync()**'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**fs.writeFileSync()**'
- en: Just like `readFileSync`, it does the same as its non-sync counterpart. The
    difference between them is that this does the operation synchronously.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`readFileSync`一样，它和它的非同步对应物做的事情一样。它们之间的区别在于这个是同步执行操作。
- en: 'Exercise 69: Basic Usage of the Fs Module'
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习69：Fs模块的基本用法
- en: In this exercise, we will be using the `fs` module to read and write files in
    our application. We will be using the methods we covered in the preceding section
    and will use them with callbacks. Then, we will `promisify` them so that we can
    use them with `async` and `await`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`fs`模块来读取和写入应用程序中的文件。我们将使用我们在前一节中介绍的方法，并将它们与回调一起使用。然后，我们将对它们进行`promisify`，这样我们就可以用`async`和`await`来使用它们。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个练习：
- en: 'Create a new file called `test.txt`:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`test.txt`的新文件：
- en: '[PRE79]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If you did this correctly, you will see the following output:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做对了，你会看到以下输出：
- en: '![Figure 9.36: New test.txt file created'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.36：创建新的test.txt文件'
- en: '](Images/C14587_09_36.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_36.jpg)'
- en: 'Figure 9.36: New test.txt file created'
  id: totrans-430
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.36：创建新的test.txt文件
- en: 'You should be able to see the new file in the same directory as your source
    code:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够在与源代码相同的目录中看到新文件：
- en: '![Figure 9.37: New file created in the same directory as your source code'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.37：在与源代码相同的目录中创建新文件'
- en: '](Images/C14587_09_37.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_37.jpg)'
- en: 'Figure 9.37: New file created in the same directory as your source code'
  id: totrans-434
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.37：在与源代码相同的目录中创建新文件
- en: 'Read its contents and output it in the console:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取其内容并在控制台中输出：
- en: '[PRE80]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This simply reads our file back; we are supplying an encoding because we want
    the output to be a string instead of a buffer. This will give us the following
    output:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是简单地读取我们的文件；我们提供了一个编码，因为我们希望输出是一个字符串而不是一个缓冲区。这将给我们以下输出：
- en: '![Figure 9.38: Reading the file''s content using fs.readFile'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.38：使用fs.readFile读取文件内容'
- en: '](Images/C14587_09_38.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_38.jpg)'
- en: 'Figure 9.38: Reading the file''s content using fs.readFile'
  id: totrans-440
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.38：使用fs.readFile读取文件内容
- en: 'Try to read from a file that doesn''t exist:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试读取一个不存在的文件：
- en: '[PRE81]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'When we try to open a file that doesn''t exist, our callback will be called
    with an error. It is recommended that we handle any file-related errors inside
    the handler instead of creating a separate function to check it. When we run the
    preceding code, we will get the following error:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试打开一个不存在的文件时，我们的回调将会被调用并出现错误。建议我们在处理任何与文件相关的错误时，应该在处理程序内部处理，而不是创建一个单独的函数来检查它。当我们运行上述代码时，将会得到以下错误：
- en: '![Figure 9.39: Error thrown when we try to read a file that doesn''t exist'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.39：尝试读取不存在的文件时抛出的错误'
- en: '](Images/C14587_09_39.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_39.jpg)'
- en: 'Figure 9.39: Error thrown when we try to read a file that doesn''t exist'
  id: totrans-446
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.39：尝试读取不存在的文件时抛出的错误
- en: 'Let''s create our own version of `readFile` with promises:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建自己的带有promise的`readFile`版本：
- en: '[PRE82]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This is the same thing we could have done with any callback-based methods,
    as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们可以使用任何基于回调的方法做的事情是一样的，如下所示：
- en: '[PRE83]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This will generate the following output:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Figure 9.40: Creating a readFile using callback-based methods'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.40：使用基于回调的方法创建readFile'
- en: '](Images/C14587_09_40.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_40.jpg)'
- en: 'Figure 9.40: Creating a readFile using callback-based methods'
  id: totrans-454
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.40：使用基于回调的方法创建readFile
- en: 'Let''s use file `stat` to get information about our file. After Node.js 10.0.0,
    `fsPromises` was introduced, so instead of converting them into promises and returning
    functions manually, we can simply import `fsPromise` and call the promised counterpart:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用文件`stat`来获取有关我们文件的信息。在Node.js 10.0.0之后，引入了`fsPromises`，因此我们可以简单地导入`fsPromise`并调用promise的对应项，而不是手动将它们转换为promise并手动返回函数：
- en: '[PRE84]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This will generate the following output:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Figure 9.41: Calling the promise counterpart by importing fspromise'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.41：通过导入fspromise调用promise的对应项'
- en: '](Images/C14587_09_41.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_41.jpg)'
- en: 'Figure 9.41: Calling the promise counterpart by importing fspromise'
  id: totrans-460
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.41：通过导入fspromise调用promise的对应项
- en: Here, you can get the size, creation time, modification time, and permission
    information about our file.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以获取有关我们文件的大小、创建时间、修改时间和权限信息。
- en: In this exercise, we went over some of the basic usages of the **fs** module.
    It is a very useful module in Node.js. Next, we will talk about how we should
    handle large files in Node.js.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们介绍了**fs**模块的一些基本用法。这是Node.js中一个非常有用的模块。接下来，我们将讨论如何在Node.js中处理大文件。
- en: Handling Large Files in Node.js
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Node.js中处理大文件
- en: In the previous exercise, we went over how we can use the `fs` module to read
    file contents in Node.js. This works well when we are dealing with small files
    that are smaller than 100 MB. When we are dealing with large files (> 2 GB), sometimes,
    it is not possible to read the entire file using `fs.readFile`. Consider the following
    scenario.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们讨论了如何使用`fs`模块在Node.js中读取文件内容。当处理小于100MB的小文件时，这很有效。当处理大文件（> 2GB）时，有时使用`fs.readFile`无法读取整个文件。考虑以下情况。
- en: You are given a 20 GB text file and you need to process the data in the file
    line by line and write the output into an output file. Your computer only has
    8 GB of memory.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到了一个20GB的文本文件，你需要逐行处理文件中的数据，并将输出写入输出文件。你的计算机只有8GB的内存。
- en: When you are using `fs.readFile`, it will attempt to read the entire content
    of the file into the computer's memory. In our case, this won't be possible because
    our computer does not have enough memory installed to fit the entire content of
    the file we are processing. Here, we need a separate approach to this problem.
    To process large files, we need to use streams.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`fs.readFile`时，它会尝试将文件的整个内容读入计算机的内存中。在我们的情况下，这是不可能的，因为我们的计算机没有足够的内存来容纳我们正在处理的文件的整个内容。在这里，我们需要一个单独的方法来解决这个问题。为了处理大文件，我们需要使用流。
- en: 'The stream is an interesting concept in programming. It treats data not as
    a single block of memory but a stream of data that comes from the source one chunk
    at a time. This way, we do not need to fit all the data inside the memory. To
    create a file stream, we simply use the provided method in the `fs` module:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 流是编程中一个有趣的概念。它将数据视为不是单一的内存块，而是来自源的数据流，每次一个数据块。这样，我们就不需要将所有数据都放入内存中。要创建一个文件流，我们只需使用`fs`模块中提供的方法：
- en: '[PRE85]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'By using `fs.createReadStream`, we create a file stream that we can use later
    to get the contents of the file. We call this function just like `fs.readFile`,
    with the file path and encoding. The difference with this is that this doesn''t
    require a callback to be supplied because it simply returns a `stream` object.
    To get the file content from the stream, we need to attach the event handlers
    to the `stream` object:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`fs.createReadStream`，我们创建了一个文件流，以便稍后可以获取文件的内容。我们像使用`fs.readFile`一样调用这个函数，传入文件路径和编码。与`fs.readFile`的区别在于，这不需要提供回调，因为它只是返回一个`stream`对象。要从流中获取文件内容，我们需要将事件处理程序附加到`stream`对象上：
- en: '[PRE86]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Inside the event handler for the `data` event, we will get the content of the
    file, and this handler will be called multiple times when the file is read by
    the stream. When we finish reading the file, we will also get an event emitted
    on the stream object to handle this event:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在`data`事件的事件处理程序中，我们将获得文件的内容，并且当流读取文件时，此处理程序将被多次调用。当我们完成读取文件时，流对象还会发出一个事件来处理此事件：
- en: '[PRE87]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Util
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Util
- en: '**Util** is a module that includes a lot of functions that help with the Node.js
    internal APIs. These can also be useful in our own development.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**Util**是一个包含许多有助于Node.js内部API的函数的模块。这些也可以在我们自己的开发中很有用。'
- en: '**util.callbackify(function)**'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '**util.callbackify(function)**'
- en: 'This is very useful when we are working on `async` and `await` code with existing
    legacy callback-based code. To use our `async` function as a callback-based function,
    we can call `util.callbackify` function. Let''s consider the following example:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们处理现有的基于回调的遗留代码时非常有用。要将我们的`async`函数用作基于回调的函数，我们可以调用`util.callbackify`函数。让我们考虑以下示例：
- en: '[PRE88]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The following is the output of the preceding code:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 9.42: Using the async function as a callback-based function'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.42：将async函数用作基于回调的函数'
- en: '](Images/C14587_09_42.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_42.jpg)'
- en: 'Figure 9.42: Using the async function as a callback-based function'
  id: totrans-481
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.42：将async函数用作基于回调的函数
- en: 'To use this `async` function with callbacks, simple call `callbackify`:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此`async`函数与回调一起使用，只需调用`callbackify`：
- en: '[PRE89]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then, we can use it like this:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以这样使用它：
- en: '[PRE90]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This will generate the following output:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Figure 9.43: Using the async function by calling the callbackify function'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.43：通过调用callbackify函数使用async函数'
- en: '](Images/C14587_09_43.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_43.jpg)'
- en: 'Figure 9.43: Using the async function by calling the callbackify function'
  id: totrans-489
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.43：通过调用callbackify函数使用async函数
- en: We have successfully converted an `async` function into a legacy function that
    uses callbacks. This is very useful when we need to keep backward compatibility.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功将`async`函数转换为使用回调的遗留函数。当我们需要保持向后兼容性时，这非常有用。
- en: '**util.promisify(function)**'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**util.promisify(function)**'
- en: 'There is also a very useful method in the **util** module to help us `promisify`
    callback-based functions. This method takes a function as its parameter and will
    return a new function that returns a promise, like so:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`util`模块中还有一个非常有用的方法，可以帮助我们将基于回调的函数转换为`promisify`函数。该方法以一个函数作为参数，并将返回一个返回promise的新函数，如下所示：'
- en: '[PRE91]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '`callbackFunction` takes a parameter and will call the callback function we
    supplied with a new string. To convert this function to use promises, we can use
    the `promisify` function:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`callbackFunction`接受一个参数，并将使用我们提供的新字符串调用回调函数。要将此函数转换为使用promises，我们可以使用`promisify`函数：'
- en: '[PRE92]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This returns a new function. Later, we can use it as a function that returns
    a promise:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个新函数。稍后，我们可以将其用作返回promise的函数：
- en: '[PRE93]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The following is the output of the preceding code:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 9.44: The promisify function is used for callbacks'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.44：使用promisify函数进行回调'
- en: '](Images/C14587_09_44.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_44.jpg)'
- en: 'Figure 9.44: The promisify function is used for callbacks'
  id: totrans-501
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.44：使用promisify函数进行回调
- en: There are also a number of type checking methods in the `util` module, which
    are very useful when we are trying to figure out the types of variables in our
    application.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`util`模块中还有许多类型检查方法，在我们尝试确定应用程序中变量类型时非常有用。'
- en: Timer
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Timer
- en: The timer module gives us an API for scheduling timer functions. We can use
    it to set delays on parts of our code or to execute our code at desired intervals.
    Unlike the previous modules, the `timer` module does not need to be imported before
    we use it. Let's have a look at all the timer functions that are provided in Node.js
    and how we can use them in our application.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器模块为我们提供了一个用于调度计时器函数的API。我们可以使用它在代码的某些部分设置延迟，或者在所需的间隔执行我们的代码。与之前的模块不同，不需要在使用之前导入`timer`模块。让我们看看Node.js提供的所有计时器函数以及如何在我们的应用程序中使用它们。
- en: '**setInterval(callback, delay)**'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '**setInterval(callback, delay)**'
- en: 'When we want to set up a function that is repeatedly executed by Node.js, we
    can use the `setInterval` function while providing a callback and a delay. To
    use it, we call the `setInterval` function with a function we want to run and
    a delay in milliseconds. For example, if we want to print the same message every
    second, we can achieve this like this:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要设置一个在Node.js中重复执行的函数时，我们可以使用`setInterval`函数，并提供一个回调和延迟。要使用它，我们调用`setInterval`函数，并提供我们想要运行的函数以及以毫秒为单位的延迟。例如，如果我们想每秒打印相同的消息，我们可以这样实现：
- en: '[PRE94]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'When we run the preceding code, we will see the following output:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的代码时，将看到以下输出：
- en: '![Figure 9.45: Setting up a repeatedly executing function using the setInterval
    function'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.45：使用setInterval函数设置重复执行的函数'
- en: '](Images/C14587_09_45.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_45.jpg)'
- en: 'Figure 9.45: Setting up a repeatedly executing function using the setInterval
    function'
  id: totrans-511
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.45：使用setInterval函数设置重复执行的函数
- en: Here, we can see that the message is printed out every second.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到消息每秒打印一次。
- en: '**setTimeout(callback, delay)**'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '**setTimeout(callback, delay)**'
- en: 'Using this function, we can set a one-time delayed invocation of a function.
    When we want to wait a certain amount of time before we run the function, we can
    use `setTimeout` to achieve this. In the previous sections, we also used `setTimeout`
    to simulate network and disk requests in our tests. To use it, we need to pass
    a function we want to run and a delay integer in milliseconds. If we want to print
    a message after 3 seconds, we can use the following code:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数，我们可以设置一次性延迟调用函数。当我们想要在运行函数之前等待一定的时间时，我们可以使用`setTimeout`来实现这一点。在前面的部分中，我们还使用`setTimeout`来模拟测试中的网络和磁盘请求。要使用它，我们需要传递我们想要运行的函数和以毫秒为单位的延迟整数。如果我们想在3秒后打印一条消息，我们可以使用以下代码：
- en: '[PRE95]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This will generate the following output:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Figure 9.46: Setting a one-time delayed invocation of a function using the
    setTimeout function'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.46：使用setTimeout函数设置一次延迟调用函数'
- en: '](Images/C14587_09_46.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_46.jpg)'
- en: 'Figure 9.46: Setting a one-time delayed invocation of a function using the
    setTimeout function'
  id: totrans-519
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.46：使用setTimeout函数设置一次延迟调用函数
- en: You will see that the message is printed out after 3 seconds. This is very useful
    when we need delayed invocation of a function or just want to use it to mock API
    calls in our tests.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到消息在3秒后打印出。当我们需要延迟调用函数或只想在测试中使用它模拟API调用时，这非常有用。
- en: '**setImmediate(callback)**'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '**setImmediate(callback)**'
- en: 'By using this method, we can push a function to be executed at the end of the
    event loop. If you want to invoke a certain piece of code after everything has
    completed running in the current event loop, you can use `setImmediate` to achieve
    this. Have a look at the following example:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种方法，我们可以推送一个函数，在事件循环结束时执行。如果您想在当前事件循环中的所有内容完成运行后调用某段代码，可以使用`setImmediate`来实现这一点。看一下以下示例：
- en: '[PRE96]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Here, we made a function that prints out `I will be printed out second`, which
    will be executed at the end of the event loop. When we execute this, we will see
    the following output:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个函数，打印出`I will be printed out second`，它将在事件循环结束时执行。当我们执行这个函数时，我们将看到以下输出：
- en: '![Figure 9.47: Function to be executed at the end of the event loop pushed
    using setimmediate'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.47：使用setimmediate推送到事件循环结束时执行的函数'
- en: '](Images/C14587_09_47.jpg)'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_47.jpg)'
- en: 'Figure 9.47: Function to be executed at the end of the event loop pushed using
    setimmediate'
  id: totrans-527
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.47：使用setimmediate推送到事件循环结束时执行的函数
- en: 'We can also achieve the same by using `setTimeout` and using `0` as the delay
    parameter:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用`setTimeout`并将`0`作为延迟参数来实现相同的效果：
- en: '[PRE97]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '**clearInterval(timeout)**'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '**clearInterval(timeout)**'
- en: 'When we use `setInterval` to create a recurring function, the function also
    returns an object representing the timer. When we want to stop the interval from
    running, we can use `clearInterval` to clear the timer:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`setInterval`创建一个重复的函数时，该函数还会返回表示计时器的对象。当我们想要停止间隔运行时，我们可以使用`clearInterval`来清除计时器：
- en: '[PRE98]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'When we run the preceding code, we will see no output being produced because
    we cleared the interval we just created and it never got the chance to run:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述代码时，我们将看到没有输出产生，因为我们清除了刚刚创建的间隔，并且它从未有机会运行：
- en: '![Figure 9.48: Stopping the interval from running using the clearInterval function'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.48：使用clearInterval函数停止间隔运行'
- en: '](Images/C14587_09_48.jpg)'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_48.jpg)'
- en: 'Figure 9.48: Stopping the interval from running using the clearInterval function'
  id: totrans-536
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.48：使用clearInterval函数停止间隔运行
- en: 'If we want to run this interval for 3 seconds, we can wrap `clearInterval`
    inside `setTimeout` so that it will clear our interval after `3.1` seconds. We
    are giving 100 ms extra because we want the third invocation to happen before
    we clear the interval:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要运行这个间隔3秒，我们可以将`clearInterval`包装在`setTimeout`内，这样它将在`3.1`秒后清除我们的间隔。我们额外给了100毫秒，因为我们希望第三次调用发生在我们清除间隔之前：
- en: '[PRE99]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'When we run the preceding code, we will see our output printed out 3 times:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述代码时，我们将看到我们的输出打印出3次：
- en: '![Figure 9.49: Using setTimeout to wrap clearInterval within the specified
    seconds'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.49：使用setTimeout在指定的秒数内包装clearInterval'
- en: '](Images/C14587_09_49.jpg)'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_09_49.jpg)'
- en: 'Figure 9.49: Using setTimeout to wrap clearInterval within the specified seconds'
  id: totrans-542
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.49：使用setTimeout在指定的秒数内包装clearInterval
- en: This is very useful when we are dealing with multiple scheduled timers. By clearing
    them, we can avoid issues such as memory leaks and unexpected issues in our application.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理多个预定计时器时，这非常有用。通过清除它们，我们可以避免内存泄漏和应用程序中的意外问题。
- en: 'Activity 14: Building a File Watcher'
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动14：构建文件监视器
- en: 'In this activity, we will create a file watcher using timer functions that
    will indicate any modifications in the file. These timer functions will set up
    a watch on the file and will generate output every time there is a change in the
    file. Let''s get started:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将使用定时器函数创建一个文件监视器，该监视器将指示文件中的任何修改。这些定时器函数将在文件上设置监视，并在文件发生更改时生成输出。让我们开始吧：
- en: We will need to create a `fileWatcher` class.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要创建一个`fileWatcher`类。
- en: A file watcher will be created with a file to watch. If no file exists, it will
    throw an exception.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将创建一个带有要监视的文件的文件监视器。如果没有文件存在，它将抛出异常。
- en: The file watcher will take another parameter to store the time between checks.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件监视器将需要另一个参数来存储检查之间的时间。
- en: The file watcher needs to allow us to remove the watch on the file.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件监视器需要允许我们移除对文件的监视。
- en: The file watcher needs to emit the file change event when the file is changed.
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件监视器需要在文件更改时发出文件更改事件。
- en: When the file is changed, the file watcher will emit the event with the new
    content of the file.
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当文件更改时，文件监视器将发出带有文件新内容的事件。
- en: 'Open the `filewatcher.js` file and do your work in that file. Perform the following
    steps to complete this activity:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`filewatcher.js`文件，并在该文件中进行您的工作。执行以下步骤以完成此活动：
- en: Import our libraries; that is, `fs` and `events`.
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们的库；即`fs`和`events`。
- en: Create a file watcher class that extends the `EventEmitter` class. Use a `modify`
    timestamp to keep track of the file change.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件监视器类，该类扩展了`EventEmitter`类。使用`modify`时间戳来跟踪文件更改。
- en: Create the `startWatch` method to start watching the changes on the file.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`startWatch`方法以开始监视文件的更改。
- en: Create the `stopWatch` method to stop watching the changes on the file.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`stopWatch`方法以停止监视文件的更改。
- en: Create a `test.txt` file in the same directory as `filewatch.js`.
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`filewatch.js`相同的目录中创建一个`test.txt`文件。
- en: Create a `FileWatcher` instance and start watching the file.
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`FileWatcher`实例并开始监视文件。
- en: Modify some content in `test.txt` and save it.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`test.txt`中的一些内容并保存。
- en: Modify `startWatch` so that it also retrieves the new content.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`startWatch`以便还检索新内容。
- en: Modify `startWatch` so that it emits events when the file is modified and an
    error when it encounters an error.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`startWatch`，使其在文件被修改时发出事件，并在遇到错误时发出错误。
- en: Attach event handlers to the error and change it in `fileWatcher.`
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`fileWatcher`中附加事件处理程序以处理错误和更改。
- en: Run the code and modify `test.txt` to see the result.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并修改`test.txt`以查看结果。
- en: Note
  id: totrans-564
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 620.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第620页找到。
- en: If you see the preceding output, this means your event system and file reading
    is working perfectly. Please feel free to extend this functionality on your own.
    You can also try to enable watching the entire folder or multiple files. In this
    activity, we just created a simple `fileWatcher` class using the filesystem module
    and event-driven programming. Using this helped us create a much smaller code
    base and gave us more clarity when we read the code directly.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到前面的输出，这意味着您的事件系统和文件读取完全正常。请随意扩展这个功能。您也可以尝试启用监视整个文件夹或多个文件。在这个活动中，我们只是使用文件系统模块和事件驱动编程创建了一个简单的`fileWatcher`类。使用这个帮助我们创建了一个更小的代码库，并在直接阅读代码时给了我们更多的清晰度。
- en: Summary
  id: totrans-567
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we talked about the event system in JavaScript and how we can
    use the built-in `events` module to create our own event emitters. Later, we went
    over a few useful built-in modules and their sample usage. Using event-driven
    programming can help us avoid interlaced logic when we are writing a program that
    requires multiple components to communicate with each other. Also, by using built-in
    modules, we can avoid adding modules that provide the same functionality and avoid
    creating projects with huge dependencies. We also mentioned how we can use timers
    to control program execution, `fs` to manipulate files, and `path` to combine
    and get useful information about our file path. These are all very useful modules
    that can help us later when building applications. In the next chapter, we will
    go over how we can use functional programming in JavaScript.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了JavaScript中的事件系统，以及如何使用内置的`events`模块来创建我们自己的事件发射器。后来，我们介绍了一些有用的内置模块及其示例用法。使用事件驱动编程可以帮助我们避免在编写需要多个组件相互通信的程序时出现交织的逻辑。此外，通过使用内置模块，我们可以避免添加提供相同功能的模块，并避免创建具有巨大依赖关系的项目。我们还提到了如何使用定时器来控制程序执行，使用`fs`来操作文件，以及使用`path`来组合和获取有关我们文件路径的有用信息。这些都是非常有用的模块，可以在构建应用程序时帮助我们。在下一章中，我们将讨论如何在JavaScript中使用函数式编程。
