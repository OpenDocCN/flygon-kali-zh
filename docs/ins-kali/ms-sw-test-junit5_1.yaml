- en: Retrospective On Software Quality And Java Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件质量和Java测试的回顾
- en: In order to make an apple pie from scratch, you must first invent the universe.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '为了从头开始制作一个苹果派，你必须首先创造宇宙。 '
- en: '*- Carl Sagan*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*- 卡尔·萨根*'
- en: 'The well-known testing framework JUnit has come a long way since its inception
    in 1995\. On September 10, 2017, an important milestone in the project life cycle
    took place, i.e. the release of JUnit 5.0.0\. Before going deep into the details
    of JUnit 5, it is worth reviewing the status quo of software testing, in order
    to understand from where we have come, and where we are going. To that aim, this
    chapter provides a high-level review of the background of software quality, software
    testing, and testing for Java. Concretely, the chapter is composed of three sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 自1995年创立以来，著名的测试框架JUnit已经走过了很长的路。2017年9月10日，项目生命周期中的一个重要里程碑发生了，即发布了JUnit 5.0.0。在深入了解JUnit
    5的细节之前，值得回顾一下软件测试的现状，以便了解我们来自何处，以及我们将要去往何处。为此，本章提供了对软件质量、软件测试和Java测试背景的高层次回顾。具体来说，本章由三个部分组成：
- en: '**Software quality**: The first section reviews the status quo in quality engineering:
    Quality assurance, ISO/IEC-2500, **V****erification & Validation** (**V&V**),
    and software defects (*bugs*).'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件质量**：第一部分回顾了质量工程的现状：质量保证、ISO/IEC-2500、验证和验证（V&V）以及软件缺陷（错误）。'
- en: '**Software testing**: This is the most commonly performed activity to guarantee
    software quality and reduce the number of software defects. This section provides
    a theoretical background of software testing levels (unit, integration, system,
    and acceptance), methods (black-box, white-box, and non-functional),  automated
    and manual software testing.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件测试**：这是最常见的活动，用于保证软件质量并减少软件缺陷的数量。本部分提供了软件测试层次（单元、集成、系统和验收）、方法（黑盒、白盒和非功能性）、自动化和手动软件测试的理论背景。'
- en: '**Testing frameworks for the** **Java Virtual Machine** (**JVM**): This section
    provides a summary of the main features of the legacy versions of the JUnit framework
    (that is, versions 3 and 4). Finally, a brief description of alternative testing
    frameworks and enhancers to JUnit is depicted.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java虚拟机的测试框架**（JVM）：本部分概述了JUnit框架的旧版本（即版本3和4）的主要特点。最后，简要描述了替代测试框架和对JUnit的增强。'
- en: Software quality
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件质量
- en: 'Software is the collection of computer programs, related data, and associated
    documentation developed for a particular customer or for a general market. It
    is an essential part of the modern world, and it has become pervasive in telecommunications,
    utilities, commerce, culture, entertainment, and so on. The question *What is
    software quality?* can generate different answers, depending on the involved practitioner''s
    role in a software system. There are two main groups of people involved in a software
    product or service:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 软件是为特定客户或一般市场开发的计算机程序、相关数据和相关文档的集合。它是现代世界的重要组成部分，在电信、公用事业、商业、文化、娱乐等领域普遍存在。问题*什么是软件质量？*可能会得到不同的答案，取决于涉及从业者在软件系统中的角色。在软件产品或服务中涉及两大主要群体：
- en: '**Consumers**: are people who use software. In this group, we can differentiate
    between *customers* (that is, people responsible for the acquisition of software
    products or services) and *users* (that is, people who use the software products
    or services for various purposes). Nevertheless, the dual roles of customers and
    users are quite common.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者**：是使用软件的人。在这个群体中，我们可以区分*客户*（即负责获取软件产品或服务的人）和*用户*（即为各种目的使用软件产品或服务的人）。然而，客户和用户的双重角色是非常普遍的。'
- en: '**Producers**: are people involved with the development, management, maintenance,
    marketing, and service of software products.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者**：参与软件产品的开发、管理、维护、营销和服务的人。'
- en: 'The quality expectations of consumers are that a software system performs useful
    functions as specified. For software producers, the fundamental quality question
    is fulfilling their contractual obligations by producing software products that
    conform to the **Service Level Agreement** (**SLA**). The definition of software
    quality by the well-known software engineer Roger Pressman comprises both points
    of view:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者的质量期望是软件系统按规定执行有用的功能。对于软件生产商来说，基本的质量问题是通过生产符合服务级别协议（SLA）的软件产品来履行他们的合同义务。著名软件工程师Roger
    Pressman对软件质量的定义包括两个观点：
- en: An effective software process applied in a manner that creates a useful product
    that provides measurable value for those who produce it and those who use it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的软件过程以创造有用的产品，并为生产者和使用者提供可衡量的价值。
- en: Quality engineering
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 质量工程
- en: 'Quality engineering (also known as quality management) is a process that evaluates,
    assesses, and improves the quality of software. There are three major groups of
    activities in the quality engineering process:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 质量工程（也称为质量管理）是一个评估、评价和改进软件质量的过程。在质量工程过程中有三大主要活动组：
- en: '**Quality planning**: This stage establishes the overall quality goal by managing
    customer''s expectations under the project cost and budgetary constraints. This
    quality plan also includes the strategy, that is, the selection of activities
    to perform and the appropriate quality measurements to provide feedback and assessment.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**质量规划**：这个阶段通过管理项目成本和预算限制来建立整体质量目标。这个质量计划还包括策略，即选择要执行的活动和适当的质量测量以提供反馈和评估。'
- en: '**Quality Assurance (QA)**: This guarantees that software products and processes
    in the project life cycle meet their specified requirements by planning and performing
    a set of activities to provide adequate confidence that quality is being built
    into the software. The main QA activity is Verification & Validation, but there
    are others, such as software quality metrics, the use of quality standards, configuration
    management, documentation management, or an expert''s opinion.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**质量保证（QA）**：通过规划和执行一系列活动来保证项目生命周期中的软件产品和过程满足其指定的要求，从而提供足够的信心，质量被构建到软件中。主要的QA活动是验证和验证，但还有其他活动，如软件质量度量、使用质量标准、配置管理、文档管理或专家意见。'
- en: '**Post-QA**: These stage includes activities for quality quantification and
    improvement measurement, analysis, feedback, and follow-up activities. The aim
    of these activities is to provide quantitative assessment of product quality and
    identification of improvement opportunities.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**质量保证后**：这个阶段包括质量量化和改进测量、分析、反馈和后续活动。这些活动的目的是提供产品质量的定量评估和改进机会的识别。'
- en: 'These phases are represented in the following chart:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些阶段在下图中表示：
- en: '![](img/00005.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00005.jpeg)'
- en: Software Quality Engineering Process
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 软件质量工程过程
- en: Requirements and specification
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求和规范
- en: 'Requirements are a key topic in the quality engineering domain. A requirement
    is a statement identifying a capability, physical characteristic, or quality factor
    that bounds a product or process need for which a solution will be pursued. The
    requirement development (also known as requirements engineering) is the process
    of producing and analyzing customer, product, and product-component requirements.
    The set of procedures that support the development of requirements, including
    planning, traceability, impact analysis, change management, and so on, is known
    as requirements management. There are two kinds of software requirements:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 需求是质量工程领域的关键主题。需求是确定产品或过程需求的能力、物理特征或质量因素的陈述。需求开发（也称为需求工程）是产生和分析客户、产品和产品组件需求的过程。支持需求开发的一系列程序，包括规划、可追溯性、影响分析、变更管理等，被称为需求管理。软件需求有两种类型：
- en: '**Functional requirements** are actions that the product must do to be useful
    to its users. They arise from the work that stakeholders need to do. Almost any
    action such as, inspecting, publishing, or most other active verbs can be a functional
    requirement.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能性需求**是产品必须执行的操作，以使其对用户有用。它们源自利益相关者需要做的工作。几乎任何动作，如检查、发布或大多数其他动词都可以是功能性需求。'
- en: '**Non-functional requirements** are properties, or qualities, that the product
    must have. For example, they can describe properties such as performance, usability,
    or security. They are often called *quality attributes*.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非功能性需求**是产品必须具有的属性或特性。例如，它们可以描述性能、可用性或安全性等属性。它们通常被称为*质量属性*。'
- en: Another important topic strongly linked with the requirements is the specification,
    which is a document that specifies in a complete, precise, verifiable manner,
    the requirements, design, behavior, or other characteristics of a system, and
    often the procedures for determining whether these provisions have been satisfied.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与需求密切相关的重要主题是规范，它是一份文件，以完整、精确、可验证的方式规定了系统的需求、设计、行为或其他特征，通常还包括确定这些规定是否得到满足的程序。
- en: Quality Assurance
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 质量保证
- en: '**Quality Assurance** (**QA**) is primarily concerned with defining or selecting
    standards that should be applied to the software development process or software
    product. Daniel Galin, the author of the book *Software Quality Assurance* (2004)
    defined QA as:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**质量保证**（**QA**）主要关注定义或选择应用于软件开发过程或软件产品的标准。《软件质量保证》（2004）一书的作者丹尼尔·加林将QA定义为：'
- en: Systematic, planned set of actions necessary to provide adequate confidence
    that the software development and maintenance process of a software system product
    conforms to established specification as well as with the managerial requirements
    of keeping the schedule and operating within the budgetary confines.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 系统化、计划的一系列行动，以提供足够的信心，使软件系统产品的开发和维护过程符合已建立的规范以及保持进度和在预算范围内运作的管理要求。
- en: The QA process selects the V&V activities, tools, and methods to support the
    selected quality standards. V&V is a set of activities carried out with the main
    objective of withholding products from shipment if they do not qualify. In contrast,
    QA is meant to minimize the costs of quality by introducing a variety of activities
    throughout the development and maintenance process in order to prevent the causes
    of errors, detect them, and correct them in the early stages of development. As
    a result, QA substantially reduces the rates of non-qualifying products. All in
    all, V&V activities are only a part of the total range of QA activities.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 质量保证（QA）过程选择V&V活动、工具和方法来支持所选的质量标准。V&V是一组活动，其主要目标是如果产品不符合资格，则阻止产品发货。相比之下，QA旨在通过在开发和维护过程中引入各种活动来最小化质量成本，以防止错误的原因，检测它们，并在开发的早期阶段纠正它们。因此，QA大大降低了不合格产品的比率。总的来说，V&V活动只是QA活动的一部分。
- en: ISO/IEC-25000
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ISO/IEC-25000
- en: Various quality standards have been proposed to accommodate these different
    quality views and expectations. The standard **ISO/IEC-9126** was one of the most
    influential in the software engineering community. Nevertheless, researchers and
    practitioners detected several problems and weaknesses in this standard. For that
    reason, the ISO/IEC-9126 international standard is superseded by the **ISO/IEC-25000**
    series of international standards on **Software product Quality Requirements and
    Evaluation** (**SQuaRE**). This section provides a high-level overview of this
    standard.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 已经提出了各种质量标准以适应这些不同的质量视图和期望。标准**ISO/IEC-9126**是软件工程界中最有影响力的标准之一。然而，研究人员和实践者发现了该标准的一些问题和弱点。因此，ISO/IEC-9126国际标准被**ISO/IEC-25000**系列国际标准**软件产品质量要求和评估**（**SQuaRE**）所取代。本节提供了该标准的高级概述。
- en: 'The ISO/IEC-2500 quality reference model distinguishes different views on software
    quality:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ISO/IEC-2500质量参考模型区分了软件质量的不同视图：
- en: '**Internal quality**: This concerns the properties of the system, that can
    be measured without executing it.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部质量**：这涉及可以在不执行系统的情况下进行测量的系统属性。'
- en: '**External quality**: This concerns the properties of the system, that can
    be observed during its execution.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部质量**：这涉及可以在执行过程中观察到的系统属性。'
- en: '**Quality in use**: This concerns the properties experienced by its consumer
    during operation and maintenance of the system.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用质量**：这涉及消费者在操作和维护系统过程中体验到的属性。'
- en: 'Ideally, the development (*process quality*) influences the internal quality;
    then, the internal quality determines the external quality. Finally, external
    quality determines quality in use. This chain is depicted in the following picture:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，开发（*过程质量*）影响内部质量；然后，内部质量决定外部质量。最后，外部质量决定使用质量。这一链条在下图中描述：
- en: '![](img/00006.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00006.jpeg)'
- en: ISO/IEC-2500 Product Quality Reference Model
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ISO/IEC-2500产品质量参考模型
- en: 'The quality model of ISO/IEC-25000 divides the product quality model (that
    is, the internal and external attributes) into eight top-level quality features:
    *functional suitability,* *performance efficiency, compatibility*, *usability*,
    *reliability*, *security*, *maintainability*, and *portability*. The following
    definitions have been extracted directly from the standard:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ISO/IEC-25000的质量模型将产品质量模型（即内部和外部属性）分为八个顶层质量特征：*功能适用性*、*性能效率*、*兼容性*、*可用性*、*可靠性*、*安全性*、*可维护性*和*可移植性*。以下定义直接从标准中提取：
- en: '**Functional suitability:** This represents the degree to which a product or
    system provides functions that meet stated and implied needs when used under specified
    conditions.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能适用性**：这代表产品或系统在指定条件下使用时提供满足规定和隐含需求的功能程度。'
- en: '**Performance efficiency:** This represents the performance relative to the
    amount of resources used under stated conditions.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能效率**：这代表在规定条件下使用的资源量相对于性能的表现。'
- en: '**Compatibility:** This is the degree to which a product, system or component
    can exchange information with other products, systems or components, and/or perform
    its required functions, while sharing the same hardware or software environment.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性**：这是产品、系统或组件能够与其他产品、系统或组件交换信息，并/或执行其所需功能的程度，同时共享相同的硬件或软件环境。'
- en: '**Usability:** This is the degree to which a product or system can be used
    by specified users to achieve specified goals with effectiveness, efficiency,
    and satisfaction in a specified context of use.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：这是产品或系统在指定使用环境中由指定用户使用以实现指定目标时的效果、效率和满意度程度。'
- en: '**Reliability:** This is the degree to which a system, product, or component
    performs specified functions under specified conditions for a specified period
    of time.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：这是系统、产品或组件在指定条件下在指定时间内执行指定功能的程度。'
- en: '**Security:** This is the degree to which a product or system protects information
    and data so that persons or other products or systems have the degree of data
    access appropriate to their types and levels of authorization'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：这是产品或系统保护信息和数据的程度，使得人员或其他产品或系统能够获得适合其类型和授权级别的数据访问程度。'
- en: '**Maintainability:** This represents the degree of effectiveness and efficiency
    with which a product or system can be modified to improve it, correct it, or adapt
    it to changes in environment and in requirements'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：这代表产品或系统可以被修改以改进、纠正或适应环境和需求变化的效果和效率程度。'
- en: '**Portability:** This is the degree of effectiveness and efficiency with which
    a system, product, or component can be transferred from one hardware, software,
    or other operational or usage environment to another'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：这是系统、产品或组件能够从一个硬件、软件或其他操作或使用环境转移到另一个环境的效果和效率程度。'
- en: 'On the other hand, the attributes of quality in use can be categorized into
    the following five characteristics:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用质量的属性可以归类为以下五个特征：
- en: '**Effectiveness:** This is the accuracy and completeness with which users achieve
    specified goals.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效性**：这是用户实现指定目标的准确性和完整性。'
- en: '**Efficiency:** These are the resources expended in relation to the accuracy
    and completeness with which users achieve goals.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：这是用户实现目标所需的准确性和完整性所耗费的资源。'
- en: '**Satisfaction:** This is the degree to which user needs are satisfied when
    a product or system is used in a specified context of use.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**满意度**：这是在指定使用环境中使用产品或系统时满足用户需求的程度。'
- en: '**Freedom from risk:** This is the degree to which a product or system mitigates
    the potential risk to economic status, human life, health, or the environment.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免于风险**：这是产品或系统减轻对经济状况、人类生命、健康或环境潜在风险的程度。'
- en: '**Context coverage:** This is the degree to which a product or system can be
    used with effectiveness, efficiency, freedom from risk, and satisfaction in both
    specified contexts of use and in contexts beyond those initially explicitly identified.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文覆盖**：这是产品或系统在指定使用环境和初始明确定义的环境以外的环境中能够有效、高效、无风险和满意程度的程度。'
- en: Verification and Validation
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证和验证
- en: Verification and Validation -also known as Software Quality Control- is concerned
    with evaluating that the software being developed meets its specifications and
    delivers the functionality expected by the consumers. These checking processes
    start as soon as requirements become available, and continue through all stages
    of the development process. Verification is different to validation, although
    they are often confused.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 验证和验证-也称为软件质量控制-涉及评估正在开发的软件是否满足其规范并提供消费者期望的功能。这些检查过程从需求可用开始，并贯穿开发过程的所有阶段。验证与验证不同，尽管它们经常被混淆。
- en: 'The distinguished professor of computer science Barry Boehm expressed the difference
    between them back in 1979:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学杰出教授Barry Boehm在1979年就表达了它们之间的区别：
- en: '**Verification**: *are we building the product right?* The aim of verification
    is to check that the software meets its stated functional and non-functional requirements
    (that is, the specification).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证：我们是否正在正确构建产品？验证的目的是检查软件是否满足其规定的功能和非功能要求（即规范）。
- en: '**Validation**: *are we building the right product?* The aim of validation
    is to ensure that the software meets consumer''s expectations. It is a more general
    process than verification, due to the fact that specifications do not always reflect
    the real wishes or needs of consumers.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：我们是否在构建正确的产品？验证的目的是确保软件满足消费者的期望。由于规范并不总是反映消费者的真实愿望或需求，因此它比验证更为普遍。'
- en: 'V&V activities include a wide array of QA activities. Although software testing
    plays an extremely important role in V&V, other activities are also necessary.
    Within the V&V process, two big groups of techniques of system checking and analysis
    may be used:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: V&V活动包括各种QA活动。虽然软件测试在V&V中起着极其重要的作用，但其他活动也是必要的。在V&V过程中，可以使用两大类系统检查和分析技术：
- en: '**Software testing**: This is the most commonly performed activity within QA.
    Given a piece of code, software testing (or simply testing) consists of observing
    a sample of executions (test cases), and giving a verdict on them. Hence, testing
    is an execution-based QA activity, so a prerequisite is the existence of the implemented
    software units, components, or system to be tested. For this reason, it is sometimes
    called dynamic analysis.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件测试**：这是QA中最常见的活动。给定一段代码，软件测试（或简单地测试）包括观察一些执行（测试用例）并对其做出裁决。因此，测试是一种基于执行的QA活动，因此前提是已实施的软件单元、组件或系统需要进行测试。因此，有时它被称为动态分析。'
- en: '**Static analysis**: This is a form of V&V that does not require execution
    of the software. Static analysis works on a source representation of the software:
    either a model of the specification of design or the source or the program. Perhaps,
    the most commonly used are inspections and reviews, where a specification, design,
    or program is checked by a group of people. Additional static analysis techniques
    may be used, such as automated software analysis (the source code of a program
    is checked for patterns that are known to be potentially erroneous).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态分析**：这是一种不需要执行软件的V&V形式。静态分析是针对软件的源表示进行的：规范、设计或程序的模型。也许最常用的是检查和审查，其中一组人员检查规范、设计或程序。还可以使用其他静态分析技术，例如自动化软件分析（检查程序的源代码是否存在已知潜在错误的模式）。'
- en: It should be noted that there is a strong divergence of opinion about what types
    of testing constitute validation or verification. Some authors believe that all
    testing is verification and that validation is conducted when requirements are
    reviewed and approved. Other authors view unit and integration testing as verification
    and higher-order testing (for example, system or user testing) as validation.
    To solve this divergence, V&V can be treated as a single topic rather than as
    two separate topics.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，关于哪些测试构成验证或验证存在着强烈的分歧意见。一些作者认为所有测试都是验证，而验证是在需求被审查和批准时进行的。其他作者认为单元测试和集成测试是验证，而更高级别的测试（例如系统或用户测试）是验证。为了解决这种分歧，V&V可以被视为一个单一主题，而不是两个单独的主题。
- en: Software defects
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件缺陷
- en: 'Key to the correctness aspect of V&V is the concept of software defects. The
    term **defect** (also known as *bug*) refers to a generic software problem. The
    IEEE Standard 610.12 propose the following taxonomy related to software defects:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: V&V正确性方面的关键是软件缺陷的概念。术语**缺陷**（也称为*错误*）指的是一般的软件问题。IEEE标准610.12提出了与软件缺陷相关的以下分类：
- en: '**Error**: A human action that produces an incorrect result. Errors can be
    classified into two categories:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：产生不正确结果的人为行为。错误可以分为两类：'
- en: Syntax error (program statement that violates one or more rules of the language
    in which it is written).
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语法错误（违反所写语言的一个或多个规则的程序语句）。
- en: Logic error (incorrect data fields, out-of-range terms, or invalid combinations).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑错误（不正确的数据字段，超出范围的术语或无效的组合）。
- en: '**Fault**: The manifestation of an error in the software system is known as
    a fault. For example, an incorrect step, process, or data definition.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障**：软件系统中错误的表现被称为故障。例如，不正确的步骤、过程或数据定义。'
- en: '**Failure**: The inability of the software system to perform its required functions
    is known as (system) failure.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障：软件系统无法执行其所需功能被称为（系统）故障。
- en: The term *bug* was first coined in 1946 by the software pioneer Grace Hooper,
    when a moth trapped in rely of an electromechanical computer caused a system malfunction.
    In this decade, the term *debug* was also introduced, as the process of detecting
    and correcting defects in a system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“bug”最早是由软件先驱格雷斯·胡珀在1946年创造的，当时一只被困在电机计算机的继电器中的飞蛾导致系统故障。在这十年中，术语“debug”也被引入，作为在系统中检测和纠正缺陷的过程。
- en: 'In addition to this level of granularity for defects, it is also interesting
    to contemplate **incidences** as symptoms associated with a failure perceived
    by the software consumer. All in all, error, faults, failures, and incidences
    are different aspects of software defects. A causal relation exists between these
    four aspects of defects. Errors may cause faults to be injected into the software,
    and faults may cause failures when the software is executed. Finally, incidences
    happen when failures are experienced by the final user or costumer. Different
    QA activities can be carried out to try to minimize the number of defects within
    a software system. As defined by Jeff Tian in his book *Software Quality Engineering*
    (2005), the alternatives can be grouped into the following three generic categories:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了缺陷的这种细粒度之外，还有一个有趣的**事件**，即软件消费者感知到的与故障相关的症状。总的来说，错误、故障、故障和事件是软件缺陷的不同方面。这四个缺陷方面之间存在因果关系。错误可能导致故障注入软件中，故障可能在执行软件时导致故障。最后，当最终用户或客户经历故障时，就会发生事件。可以进行不同的质量保证活动来尽量减少软件系统中的缺陷数量。正如杰夫·田在他的书《软件质量工程》（2005）中所定义的那样，这些替代方案可以分为以下三个通用类别：
- en: 'Defect prevention through error removal: For example, the use of certain processes
    and product standards can help to minimize the injection certain kinds of faults
    into the software.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过错误修复预防缺陷：例如，使用某些流程和产品标准可以帮助最小化将某些类型的故障注入软件中。
- en: 'Defect reduction through fault detection and removal: The traditional testing
    and static analysis activities are examples of this category. We discover the
    specific types of these mechanisms in the body of this chapter.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过故障检测和修复减少缺陷：传统的测试和静态分析活动就是这一类别的例子。我们将在本章的内容中发现这些机制的具体类型。
- en: 'Defect containment through failure prevention: These activities are typically
    out of the scope of the software system. The objective of containment is to minimize
    the damage caused by software system failures (for example, walls to contain radioactive
    material in case of reactor failures).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺陷控制通过预防故障：这些活动通常超出软件系统的范围。控制的目标是最小化软件系统故障造成的损害（例如，在反应堆故障时用墙壁来包含放射性材料）。
- en: '![](img/00007.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00007.jpeg)'
- en: Software defect chain and associated QA activities
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 软件缺陷链和相关的质量保证活动
- en: Static analysis
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态分析
- en: 'Static analysis of a software piece is performed without executing the code.
    There are several advantages to software analysis over testing:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对软件片段的静态分析是在不执行代码的情况下进行的。与测试相比，软件分析有几个优点：
- en: During testing, errors can hide other errors. This situation does not happen
    with static analysis, because it is not concerned with interactions between errors.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试过程中，错误可能会隐藏其他错误。这种情况在静态分析中不会发生，因为它不涉及错误之间的相互作用。
- en: Incomplete versions of a system can be statically analyzed without additional
    cost. In testing, if a program is incomplete, test harnesses have to be developed.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不完整的系统版本可以在不增加额外成本的情况下进行静态分析。在测试中，如果程序不完整，就必须开发测试工具。
- en: Static analysis can consider broader quality attributes of a software system,
    such as compliance with standards, portability, and maintainability.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态分析可以考虑软件系统的更广泛的质量属性，例如符合标准、可移植性和可维护性。
- en: 'There are different methods that can be identified as static analysis:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法可以被确定为静态分析：
- en: '**Inspection** (first proposed by Michael Fagan in 1976) are examinations of
    software artifacts by human inspectors aimed at discovering and fixing faults
    in the software systems. All kinds of software assets are subject to be inspected,
    for example the specification, design models, and so on. The primary reason for
    the existence of inspection is not waiting for the availability of executable
    programs (such as in testing) before starting performing inspection.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查**（1976年由迈克尔·法根首次提出）是人员检查软件工件，旨在发现和修复软件系统中的故障。所有类型的软件资产都可能被检查，例如规范、设计模型等。检查存在的主要原因不是等待可执行程序的可用性（例如在测试中）才开始进行检查。'
- en: '**Review** is the process in which a group of people examine the software and
    its associated documentation, looking for potential problems and non-conformance
    with standards, and other potential problems or omissions. Nowadays, reviews are
    frequently carried out for new code before being merged in a shared source code
    repository. Typically, the review is done by a different person to the code author
    within the same team (**peer review**). This process is quite expensive in terms
    of time and effort, but on the other side, when correctly performed, it helps
    to ensure a high internal code quality reducing potential risks.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审查**是一个过程，其中一组人员检查软件及其相关文档，寻找潜在问题和与标准不符合，以及其他潜在问题或遗漏。如今，在将新代码合并到共享源代码存储库之前，通常会进行审查。通常，审查由团队内的不同人员（**同行审查**）进行。这个过程在时间和精力方面非常昂贵，但另一方面，当正确执行时，它有助于确保高内部代码质量，减少潜在风险。'
- en: A **walkthrough** is a special form of review. According to IEEE Standard for
    Software Reviews, a walkthrough is a form of software peer review in which a designer
    or programmer leads members of the development team and other interested parties
    through a software product, and the participants ask questions and make comments
    about possible errors, violation of development standards, and other problems.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**审查**是一种特殊形式的审查。根据IEEE软件审查标准，审查是一种软件同行审查形式，其中设计师或程序员带领开发团队成员和其他感兴趣的人员浏览软件产品，参与者提出问题并对可能的错误、违反开发标准和其他问题进行评论。'
- en: '**Automated software analysis** assesses the source code using patterns that
    are known to be potentially dangerous. This technique is usually delivered as
    commercial or open source tools and services, commonly known as **lint** or **linter**.
    These tools can locate many common programming faults, analyze the source code
    before it is tested, and identify potential problems in order to re-code them
    before they manifest themselves as failures. The intention of this linting process
    is to draw a code reader’s attention to faults in the program, such as:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化软件分析**使用已知潜在危险的模式来评估源代码。这种技术通常以商业或开源工具和服务的形式提供，通常被称为**lint**或**linter**。这些工具可以定位许多常见的编程错误，在代码被测试之前分析源代码，并识别潜在问题，以便在它们表现为故障之前重新编码。这种linting过程的目的是引起代码阅读者对程序中的错误的注意，比如：'
- en: 'Data faults: This may include variables declared but never used, variables
    assigned twice but never used between assignments, and so on.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据故障：这可能包括声明但从未使用的变量，两次赋值但在赋值之间从未使用的变量等。
- en: 'Control faults: This may include unreachable code or unconditional branches
    into loops.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制故障：这可能包括无法到达的代码或无条件进入循环。
- en: 'Input/output faults: This may include variables output twice with no intervening
    assignment.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入/输出故障：这可能包括变量在没有中间赋值的情况下输出两次。
- en: 'Interface faults: This may include parameter-type mismatches, parameter under
    mismatches, non-usage of the results of functions, uncalled functions and procedures,
    and so on.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口故障：这可能包括参数类型不匹配、参数不匹配、函数结果未使用、未调用的函数和过程等。
- en: 'Storage management faults: This may include unassigned pointers, pointers arithmetic,
    and so on.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储管理故障：这可能包括未分配的指针、指针算术等。
- en: Halfway between static analysis and dynamic testing we find an especial way
    of software evaluation, called **formal verification**. This kind of assessment
    provides mechanisms to check that a system operates according to its formal specification.
    To that aim, software is treated as a mathematical entity whose correctness can
    be proved using logical operations, combining different types of static and dynamic
    evaluation. Nowadays, formal methods are not widely adopted mainly due to scalability
    problems. Projects using these techniques are mostly relatively small, such as
    critical kernel systems. As systems grow, the effort required to develop a formal
    specification and verification grow excessively.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态分析和动态测试之间，我们发现了一种特殊的软件评估方式，称为**形式验证**。这种评估提供了检查系统是否按照其正式规范运行的机制。为此，软件被视为一个可以使用逻辑操作证明其正确性的数学实体，结合不同类型的静态和动态评估。如今，由于可扩展性问题，形式方法并不被广泛采用。使用这些技术的项目大多相对较小，比如关键的内核系统。随着系统的增长，开发正式规范和验证所需的工作量也会过分增长。
- en: Software testing
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件测试
- en: 'Software testing consists of the dynamic evaluation of the behavior of a program
    on a finite set of test cases, suitably selected from the usually infinite executions
    domain, against the expected behavior. The key concepts of this definition are
    depicted as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试包括对程序在通常无限执行域中合适选择的有限测试用例的动态评估，以检查其行为是否符合预期。这个定义的关键概念如下所示：
- en: '**Dynamic**: The **System Under Test** (**SUT**) is executed with specific
    input values to find failures in its behavior. Thus, the actual SUT should ensure
    that the design and code are correct, and also the environment, such as the libraries,
    the operating system and network support, and so on.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态**：**被测试系统**（**SUT**）使用特定的输入值来查找其行为中的故障。因此，实际的SUT应该确保设计和代码是正确的，还有环境，比如库、操作系统和网络支持等等。'
- en: '**Finite**: Exhaustive testing is not possible or practical for most real programs.
    They usually have a large number of allowable inputs to each operation, plus even
    more invalid or unexpected inputs and the possible sequences of operations are
    usually infinite as well. Testers must choose a number of tests so that we can
    run the tests in the available time.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限的**：对于大多数真实程序来说，穷举测试是不可能或不切实际的。它们通常对每个操作有大量允许的输入，还有更多无效或意外的输入，操作序列通常也是无限的。测试人员必须选择一定数量的测试，以便在可用时间内运行这些测试。'
- en: '**Selected**: Since there is a huge or infinite set of possible tests and we
    can can afford to run only a small fraction of them, the key challenge of testing
    is how to select the tests that are most likely to expose failures in the system.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选定的**：由于可能的测试集合庞大甚至无限，我们只能运行其中的一小部分，测试的关键挑战在于如何选择最有可能暴露系统故障的测试。'
- en: '**Expected**: After each test execution, it must be decided whether the observed
    behavior of the system was a failure or not.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预期的**：在每次测试执行后，必须决定系统的观察行为是否是故障。'
- en: Software testing is a broad term encompassing a wide spectrum of different concepts.
    There is no universal classification for all the different testing forms available
    in the literature. For the shake of clarity, in this book we classify the different
    form of tests using three axis, namely testing level (unit, integration, system,
    and acceptance), testing methods (black-box, white-box, and non-functional testing),
    and testing types (manual and automated).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试是一个广泛的术语，涵盖了许多不同的概念。在文献中，并没有所有不同测试形式的通用分类。为了清晰起见，在本书中，我们使用三个轴对不同的测试形式进行分类，即测试级别（单元、集成、系统和验收）、测试方法（黑盒、白盒和非功能测试）和测试类型（手动和自动化）。
- en: 'Next sections provide more details about all of these concepts, which are summarized
    in the following diagram:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将提供关于所有这些概念的更多细节，这些概念在以下图表中进行了总结：
- en: '![](img/00008.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.jpeg)'
- en: 'Taxonomy of software testing in three categories: levels, methods, and types'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试的分类法分为三类：级别、方法和类型
- en: For example, as we will discover, a JUnit test that exercises a method in a
    class according to its functional behaviour can be seen as an automated unit black-box
    test. When a final consumer uses a software product to validate if works as expected,
    according the taxonomy before we can see this as a manual black-box acceptance
    test. It should be noticed than not all possible combination of these three axes
    is always meaningful. For instance, non-functional tests (example, performance)
    is typically carried out automatically and at system levels (it would be very
    unlikely to do manually or at unit level).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，正如我们将会发现的，根据其功能行为执行类中的方法的JUnit测试可以被视为自动化的单元黑盒测试。当最终用户使用软件产品来验证其是否按预期工作时，根据之前的分类，我们可以将其视为手动黑盒验收测试。应该注意的是，并非所有这三个轴的可能组合总是有意义的。例如，非功能测试（例如性能）通常是在系统级别自动进行的（手动或在单元级别进行的可能性非常小）。
- en: Testing levels
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试级别
- en: 'Depending on the size of the SUT and the scenario in which it is exercised,
    testing can be carried out at different levels. In this book, we classify the
    different testing levels in four phases:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根据SUT的大小和测试的场景，测试可以在不同的级别进行。在本书中，我们将不同的测试级别分类为四个阶段：
- en: '**Unit testing**: Here, individual program units are tested. Unit testing should
    focus on the functionality of objects or methods.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：在这里，测试单独的程序单元。单元测试应该专注于对象或方法的功能。'
- en: '**Integration testing**: Here, units are combined to create composite components.
    Integration testing should focus on testing components, interfaces.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：在这里，单元被组合成复合组件。集成测试应该专注于测试组件和接口。'
- en: '**System testing**: Here, all of the components are integrated and the system
    is tested as a whole.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**：在这里，所有组件都被集成，整个系统被测试。'
- en: '**Acceptance testing**: Here, consumers decide whether or not the system is
    ready to be deployed in the consumer environment. It can be seen as a high-level
    functional testing performed at system level by final users or customers.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收测试**：在这里，消费者决定系统是否准备部署到消费者环境中。它可以被视为由最终用户或客户在系统级进行的高级功能测试。'
- en: There is no universal classification in the many different forms of testing.
    Regarding testing levels, in this book, we use the aforementioned classification
    of four levels. Nevertheless, other levels or approaches are present in the literature
    (for example, *system integration testing* or *regression testing*). In the last
    part of this section, we can find a review of different testing approaches.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多不同形式的测试中，没有通用的分类。关于测试级别，在本书中，我们使用上述的四个级别分类。然而，文献中还存在其他级别或方法（例如*系统集成测试*或*回归测试*）。在本节的最后部分，我们可以找到对不同测试方法的审查。
- en: 'The first three levels (unit, integration, and system) are typically carried
    out during the development phases of the software life cycle. These tests are
    typically performed by different roles of software engineers (that is, programmers,
    testers, QA team, and so on). The objective of these tests is the verification
    of the system. On the other side, the fourth level (acceptance) is a type of user
    testing, in which potential or real users are usually involved (validation). The
    following picture provides a graphical description of these concepts:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个级别（单元、集成和系统）通常在软件生命周期的开发阶段进行。这些测试通常由软件工程师的不同角色执行（即程序员、测试人员、质量保证团队等）。这些测试的目标是对系统进行验证。另一方面，第四个级别（验收）是一种用户测试，其中通常涉及潜在或真实用户（验证）。以下图片提供了这些概念的图形描述：
- en: '![](img/00009.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.jpeg)'
- en: Testing levels and its relationship with V&V
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 测试级别及其与V&V的关系
- en: Unit testing
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Unit testing is a method by which individual pieces of source code are tested
    to verify that the design and implementation for that unit have been correctly
    implemented. There are four phases executed in sequence in a unit test case are
    the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种通过测试单个源代码片段来验证该单元的设计和实现是否正确的方法。在单元测试用例中按顺序执行的四个阶段如下：
- en: '**Setup**: The test case initializes the *test fixture*, that is the *before*
    picture required for the SUT to exhibit the expected behavior.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**：测试用例初始化*测试装置*，即SUT展示预期行为所需的*之前*图片。'
- en: '**Exercise**: The test case interacts with the SUT, getting some outcome from
    it as a result. The SUT usually queries another component, named the **Depended-On
    Component** (**DOC**).'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**：测试用例与SUT进行交互，从中获得一些结果。SUT通常查询另一个组件，称为**依赖组件**（**DOC**）。'
- en: '**Verify**: The test case determines whether the expected outcome has been
    obtained using assertions (also known as predicates).'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：测试用例使用断言（也称为谓词）确定是否获得了预期的结果。'
- en: '**Teardown**: The test case tears down the test fixture to put the SUT back
    into the initial state.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拆卸**：测试用例拆除测试装置，将SUT恢复到初始状态。'
- en: 'These phases and its relationship with the SUT and DOC is illustrated as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些阶段及其与SUT和DOC的关系如下所示：
- en: '![](img/00010.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpeg)'
- en: Unit test generic structure
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通用结构
- en: 'Unit testing is done with the unit under test in isolation, that is, without
    interacting its DOCs. To that aim, *test doubles* are employed to replace any
    components on which the SUT depends. There are several kinds of test doubles:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是在单元测试中进行的，即在不与其DOCs进行交互的情况下进行。为此，使用*测试替身*来替换SUT所依赖的任何组件。有几种类型的测试替身：
- en: A **dummy** object simply satisfies the real object API but it is never actually
    used. The typical use case for dummy objects is when they are passed as parameters
    to meet the method signature, but then the dummy object is not actually used.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟**对象只是满足真实对象的API，但实际上从未被使用。虚拟对象的典型用例是当它们作为参数传递以满足方法签名时，但然后虚拟对象实际上并未被使用。'
- en: A **fake** object replaces the real object with a simpler implementation, for
    example, an in-memory database.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**伪造**对象用更简单的实现替换真实对象，例如，内存数据库。'
- en: A **stub** object replaces the real object providing hard-coded values as responses.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根**对象替换真实对象，提供硬编码的值作为响应。'
- en: A **mock** object also replaces the real object, but this time with programmed
    expectations as responses.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟**对象也替换真实对象，但这次是使用编程期望作为响应。'
- en: A **spy** object is a partial mock object, meaning that some of its methods
    are programmed with expectations, but the others use the real object's implementation.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间谍**对象是部分模拟对象，意味着它的一些方法是使用期望进行编程的，但其他方法使用真实对象的实现。'
- en: Integration testing
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'Integration testing should expose defects in the interfaces, and the interaction
    between integrated components or modules. There are different strategies for performing
    integration testing. These strategies describe the order in which units are to
    be integrated, presuming that the units have been separately tested. Examples
    of common integration strategies are the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试应该暴露接口中的缺陷，以及集成组件或模块之间的交互。有不同的策略来执行集成测试。这些策略描述了要集成单元的顺序，假设这些单元已经分别进行了测试。常见的集成策略示例包括以下内容：
- en: '**Top-down integration**: This strategy starts with the main unit (module),
    that is, the root of the procedural tree. Any lower-level module that is called
    by the main unit should be substituted by a test double. Once testers are convinced
    that the main unit logic is correct, the stubs are gradually replaced with the
    actual code. This process is repeated for the rest of the lower-unit in the procedural
    tree. The main advantage of this approach is that defects are more easily found.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自顶向下集成**：这种策略从主要单元（模块）开始，即程序树的根部。任何被主要单元调用的较低级别模块都应该被测试替身替换。一旦测试人员确信主要单元逻辑是正确的，存根将逐渐被实际代码替换。这个过程将重复进行，直到程序树中的其余较低单元。这种方法的主要优点是缺陷更容易被发现。'
- en: '**Bottom-up integration**: This strategy starts the testing process with the
    most elementary units. Larger subsystems are assembled from the tested components.
    The main advantage of this type is that test doubles are not needed.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自底向上集成**：这种策略从最基本的单元开始测试。较大的子系统是由经过测试的组件组装而成。这种类型的主要优点是不需要测试替身。'
- en: '**Ad hoc integration**: The components are integrated in the natural order
    in which are finished. It allows an early testing of the system. Test doubles
    are usually required.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**临时集成**：组件按照完成的自然顺序进行集成。它允许对系统进行早期测试。通常需要测试替身。'
- en: '**Backbone integration**: A skeleton of components is built and others are
    gradually integrated. The main disadvantage of this approach is the creation of
    the backbone, which can be labor-intensive.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**骨干集成**：构建组件的骨架，逐渐集成其他组件。这种方法的主要缺点是骨干的创建可能需要大量工作。'
- en: Another strategy commonly referred in the literature is **big-bang integration**.
    In this strategy, testers wait until all or most of the units are developed e
    integrated. As a result, all the failures are found at the same time, making very
    difficult and time-consuming to correct the underlying faults. If possible, this
    strategy should be avoided.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 文献中常常提到的另一种策略是**大爆炸集成**。在这种策略中，测试人员等待直到所有或大多数单元都被开发和集成。结果，所有的故障都会同时被发现，使得纠正潜在故障非常困难和耗时。如果可能的话，应该避免使用这种策略。
- en: System testing
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统测试
- en: System testing during development involves integrating components to create
    a version of the system and the testing the integrated system. It verifies that
    the components are compatible, interacts correctly, and transfer the right data
    at the right time, topically across its user interfaces. It obviously overlaps
    with integration testing, but the difference here is that system testing should
    involve all the system components together with the final user (typically impersonated).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 开发过程中的系统测试涉及将组件集成以创建系统的一个版本，并测试集成系统。它验证组件是否兼容，正确地进行交互，并在正确的时间传输正确的数据，通常跨越其用户界面。显然，它与集成测试重叠，但这里的区别在于系统测试应该涉及所有系统组件以及最终用户（通常是模拟的）。
- en: There is an special type of system testing called *end-to-end testing*. In this
    approach, the final user is typically impersonated, that is, simulated using automation
    techniques.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种特殊类型的系统测试称为*端到端测试*。在这种方法中，最终用户通常被模拟，即使用自动化技术进行模拟。
- en: Testing methods
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试方法
- en: Testing methods (or strategies) define the way for designing test cases. They
    can be responsibility based (**black-box**), implementation based (**white box**),
    or **non-functional**. Black-box techniques design test cases on the basis of
    the specified functionality of the item to be tested. White-box ones rely on source
    code analysis to develop test cases. Hybrid techniques (grey-box) testing designs
    test cases using both responsibility-based and implementation-based approaches.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法（或策略）定义了设计测试用例的方式。它们可以基于责任（黑盒），基于实现（白盒），或非功能性。黑盒技术根据被测试项的指定功能设计测试用例。白盒技术依靠源代码分析来开发测试用例。混合技术（灰盒）测试使用基于责任和基于实现的方法设计测试用例。
- en: Black-box testing
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑盒测试
- en: '**Black-box testing** (also known as **functional** or **behavioral** testing)
    is based on requirements with no knowledge of the internal program structure or
    data. Black-box testing relies on the specification of the system or the component
    that is being tested to derive test cases. The system is a black-box whose behavior
    can only be determined by studying its inputs and the related outputs. There are
    a lot of specific black-box testing techniques; some of the most well-known ones
    are described as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试（也称为功能或行为测试）是基于需求的，不了解内部程序结构或数据。黑盒测试依赖于正在测试的系统或组件的规范来推导测试用例。系统是一个只能通过研究其输入和相关输出来确定其行为的黑盒。有许多具体的黑盒测试技术；以下是一些最著名的技术：
- en: '**Systematic testing**: This refers to a complete testing approach in which
    SUT is shown to conform exhaustively to a specification, up to the testing assumptions.
    It generates test cases only in the limiting sense that each domain point is a
    singleton sub-domain. Inside this category, some of the most commonly performed
    are *equivalence partitioning* and *boundary value analysis*, and also logic-based
    techniques, such as *cause-effect graphing*, *decision table*, or *pairwise testing*.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统化测试：这指的是一种完整的测试方法，其中系统被证明完全符合规范，直到测试假设。它仅在限制意义上生成测试用例，即每个域点都是单例子域。在这个类别中，一些最常执行的是等价类划分和边界值分析，以及基于逻辑的技术，如因果图、决策表或成对测试。
- en: '**Random testing**: This is literally the antithesis of systematic testing
    -the sampling is over the entire input domain-. *Fuzz testing* is a form of black-box
    random testing, which randomly mutates well-formed inputs and tests the program
    on the resulting data. It delivers randomly sequenced and/or structurally bad
    data to a system to see if failures occur.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机测试：这实际上是系统化测试的对立面-对整个输入域进行抽样。模糊测试是一种黑盒随机测试，它会随机变异格式良好的输入，并对生成的数据进行测试。它会向系统提供随机顺序和/或结构不良的数据，以查看是否发生故障。
- en: '**Graphic User Interface** (**GUI**) **testing**: This is the process of ensuring
    the specification of software with a graphic interface interacting with the user.
    GUI testing is event-driven (for example, mouse movements or menu selections)
    and provides a frontend to the underlying application code through messages or
    method calls. GUI testing at unit level is used typically at the button level.
    GUI testing at system level exercises the event-driven nature of the SUT.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形用户界面（GUI）测试：这是确保具有图形界面的软件与用户进行交互的规范的过程。GUI测试是事件驱动的（例如，鼠标移动或菜单选择），并通过消息或方法调用向底层应用程序代码提供前端。单元级别的GUI测试通常在按钮级别使用。系统级别的GUI测试会测试系统的事件驱动特性。
- en: '**Model-based testing** (**MBT**): This is a testing strategy in which test
    cases are derived in part from a model that describes some (if not all) aspects
    of the SUT. MBT is a form of black-box testing because tests are generated from
    a model, which is derived from the requirements documentation. It can be done
    at different levels (unit, integration, or system).'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于模型的测试（MBT）：这是一种测试策略，其中测试用例部分地源自描述系统下测试对象的模型。MBT是一种黑盒测试，因为测试是从模型生成的，而模型又源自需求文档。它可以在不同的级别（单元、集成或系统）进行。
- en: '**Smoke testing**: This is the process of ensuring the critical functionality
    of the SUT. A smoke test case is the first to be run by testers before accepting
    a build for further testing. Failure of a smoke test case will mean that the software
    build is refused. The name of *smoke testing* derives electrical system testing,
    whereby the first test was to switch on and see if it smoked.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒烟测试：这是确保系统关键功能的过程。冒烟测试用例是测试人员在接受构建进行进一步测试之前运行的第一个测试。冒烟测试用例失败意味着软件构建被拒绝。冒烟测试的名称源自电气系统测试，即首次测试是打开开关并查看是否冒烟。
- en: '**Sanity testing**: This is the process of ensuring the basic functionality
    of the SUT. Similarly to smoke testing, sanity tests are performed at the beginning
    of the test process, but its objective is different. Sanity tests are supposed
    to ensure that the SUT basic features continue working as expected (i.e. the *rationality*
    of the SUT), before conducting more exhaustive tests.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理智测试：这是确保系统基本功能的过程。与冒烟测试类似，理智测试是在测试过程开始时执行的，但其目标不同。理智测试旨在确保系统基本功能继续按预期工作（即系统的合理性），然后进行更详尽的测试。
- en: Smoke and sanity testing are usually confusing terms in the software testing
    community. It is commonly accepted that both kind of tests are performed to avoid
    wasting effort in rigorous testing when these tests fail, being the main difference
    their target (critical vs. basic functionality).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 冒烟测试和理智测试通常在软件测试社区中容易混淆。通常认为这两种测试都是为了避免在这些测试失败时浪费精力进行严格的测试，它们的主要区别在于目标（关键功能
    vs. 基本功能）。
- en: White-box testing
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 白盒测试
- en: '**White-box** **testing** (also known as **structural** testing) is based on
    knowledge of the internal logic of an application''s code. It determines if the
    program-code structure and logic is faulty. White-box test cases are accurate
    only if the tester knows what the program is supposed to do.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试（也称为结构测试）基于对应用程序代码内部逻辑的了解。它确定程序代码结构和逻辑是否有错误。只有当测试人员知道程序应该做什么时，白盒测试用例才是准确的。
- en: 'Black-box testing uses only the specification to identify use cases, while
    white-box testing uses the program source code (implementation) as the basis of
    test case identification. Both approaches, used in conjunction, should be necessary
    in order to select a good set of test cases for the SUT. Some of the most significant
    white-box techniques are as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试仅使用规范来识别用例，而白盒测试使用程序源代码（实现）作为测试用例识别的基础。这两种方法结合使用，应该是选择SUT的一组良好测试用例所必需的。以下是一些最重要的白盒技术：
- en: '**Code coverage** defines the degree of source code, which has been tested,
    for example, in terms of percentage of LOCs. There are several criteria for the
    code coverage:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码覆盖定义了已经测试的源代码程度，例如以LOC百分比的形式。代码覆盖有几个标准：
- en: 'Statement coverage: The line of code coverage granularity.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语句覆盖：代码覆盖粒度。
- en: 'Decision (branch) coverage: Control structure (for example, if-else) coverage
    granularity.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决策（分支）覆盖：控制结构（例如，if-else）覆盖粒度。
- en: 'Condition coverage: Boolean expression (true-false) coverage granularity.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件覆盖：布尔表达式（真-假）覆盖粒度。
- en: 'Paths coverage: Every possible route coverage granularity.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路径覆盖：每个可能的路径覆盖粒度。
- en: 'Function coverage: Program functions coverage granularity.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能覆盖：程序功能覆盖粒度。
- en: 'Entry/exit coverage: Call and return of the coverage granularity.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 入口/出口覆盖：调用和返回的覆盖粒度。
- en: '**Fault injection** is the process of injecting faults into software to determine
    how well (or badly) some SUT behaves. Defects can be said to propagate, and in
    that case, their effects are visible in program states beyond the state in which
    the error existed (a fault became a failure).'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障注入是向软件中注入故障以确定某个SUT的表现如何的过程。缺陷可以说是传播的，如果是这种情况，它们的影响会在错误存在的状态之外的程序状态中可见（故障变成了失败）。
- en: '**Mutation testing** validates tests and their data by running them against
    many copies of the SUT containing different, single, and deliberately inserted
    changes. Mutation testing helps to identify omissions in the code.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 突变测试通过对包含不同、单一且故意插入更改的SUT的多个副本运行测试和它们的数据来验证。突变测试有助于识别代码中的遗漏。
- en: Non-functional testing
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非功能测试
- en: The **non-functional** aspects of a system can require considerable effort to
    test. Within this group it can be found different means of testing, for example,
    performance testing conducted to evaluate the compliance of a SUT with specified
    performance requirements. These requirements usually include constraints about
    the time behavior and resource usage. *Performance testing* may measure response
    time with a single user exercising the system or with multiple users exercising
    the system. *Load testing* is focused on increasing the load on the system to
    some stated or implied maximum load, to verify the system can handle the defined
    system boundaries. *Volume testing* is often considered synonymous with load testing,
    yet volume testing focuses on data. *Stress testing* exercises beyond normal operational
    capacity to the extent that the system fails, identifying actual boundaries at
    which the system breaks. The aim of stress testing is to observe how the system
    fails and where the bottlenecks are.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的非功能方面可能需要大量的测试工作。在这一组中，可以找到不同的测试手段，例如，性能测试用于评估SUT是否符合指定的性能要求。这些要求通常包括有关时间行为和资源使用的约束。性能测试可以通过单个用户对系统进行操作或多个用户对系统进行操作来测量响应时间。负载测试侧重于增加系统的负载到某个规定或暗示的最大负载，以验证系统能够处理定义的系统边界。体积测试通常被认为是负载测试的同义词，但体积测试侧重于数据。压力测试超出正常操作能力的范围，以至系统失败，识别系统破裂的实际边界。压力测试的目的是观察系统如何失败以及瓶颈在哪里。
- en: '*Security testing* tries to ensure the following concepts: confidentiality
    (protection against the disclosure of information), integrity (ensuring the correctness
    of the information), authentication (ensuring the identity of the user), authorization
    (determining that a user is allowed to receive a service or perform an operation),
    availability (ensuring that the system performs its functionality when required),
    and non-repudiation (ensuring the denial that an action happened). Authorized
    attempts for evaluating the security of system infrastructure is often known as
    *penetration testing*.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 安全测试试图确保以下概念：机密性（保护信息不被泄露），完整性（确保信息的正确性），认证（确保用户的身份），授权（确定用户是否被允许接收服务或执行操作），可用性（确保系统在需要时执行其功能），不可否认性（确保否认某个动作发生）。评估系统基础设施安全性的授权尝试通常被称为渗透测试。
- en: '*Usability testing* focuses on finding user interface problems, which may make
    the software difficult to use or may cause users to misinterpret the output. *Accessibility
    testing* is the technique of making sure that our product is accessibility (the
    ability to access the system functionality) compliant.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性测试侧重于发现可能使软件难以使用或导致用户误解输出的用户界面问题。可访问性测试是确保产品符合可访问性（访问系统功能的能力）的技术。
- en: Testing types
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'There are two main types to carrying out software testing:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要的软件测试方法：
- en: '**Manual testing**: This is the process of assessing the SUT is done by a human,
    typically a software engineer or the final consumer. In this type of testing,
    we can find the so-called *exploratory testing*, which is a type of manual testing
    in which human testers evaluate the system by investigating and freely evaluating
    the system using its personal perception.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动测试**：这是由人类进行的评估SUT的过程，通常是软件工程师或最终用户。在这种类型的测试中，我们可以找到所谓的*探索性测试*，这是一种人工测试，人类测试人员通过调查和自由评估系统使用其个人感知来评估系统。'
- en: '**Automated testing**: This is the process of assessing the SUT in which the
    testing process (test execution, reporting, and so on) is carried out with special
    software and infrastructure for testing. Elfriede Dustin, in her book *Implementing
    Automated Software Testing: How to Save Time and Lower Costs While Raising Quality*
    (2009)*,* defined **Automated Software Testing** (**AST**) as the:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化测试**：这是评估SUT的过程，其中测试过程（测试执行、报告等）是通过专门的软件和基础设施进行的。Elfriede Dustin在她的书*Implementing
    Automated Software Testing: How to Save Time and Lower Costs While Raising Quality*（2009）*中定义了**自动化软件测试**（**AST**）为：'
- en: Application and implementation of software technology throughout the entire
    software testing life cycle with the goal to improve efficiencies and effectiveness.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 应用和实施软件技术贯穿整个软件测试生命周期，目标是提高效率和效果。
- en: 'The main benefits of AST are: anticipated cost savings, shortened test duration,
    heightened thoroughness of the tests performed, improvement of test accuracy,
    improvement of result reporting as well as statistical processing, and subsequent
    reporting.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: AST的主要好处是：预期的成本节约、缩短的测试持续时间、提高测试的彻底性、提高测试的准确性、改进结果报告以及统计处理，以及随后的报告。
- en: Automated tests are typically executed in build servers in the context of **Continuous
    Integration** (**CI**) processes. More details about this are provided in [chapter
    7](part0160.html#4OIQ00-ef8404ed083f459d860f84cc8198f8bb), *Testing Management.*
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试通常在构建服务器上在**持续集成**（**CI**）过程的上下文中执行。关于这方面的更多细节在[第7章](part0160.html#4OIQ00-ef8404ed083f459d860f84cc8198f8bb)中提供，*测试管理*。
- en: AST is most effective when implemented within a *framework*. Testing frameworks
    may be defined as a set of abstract concepts, processes, procedures and environments
    in which automated tests will be designed, created, and implemented. This framework
    definition includes the physical structures used for test creation and implementation,
    as well as the logical interactions among those components.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: AST在*框架*内实施时效果最好。测试框架可以被定义为一组抽象概念、过程、程序和环境，其中自动化测试将被设计、创建和实施。这个框架定义包括用于测试创建和实施的物理结构，以及这些组件之间的逻辑交互。
- en: 'Strictly speaking, that definition of framework is not very far from what we
    can understand by library. In order to make the difference clearer, consider the
    following quote from the well-known software engineering guru Martin Folwer:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，框架的定义与我们对库的理解并没有太大的区别。为了更清楚地区分，考虑一下著名的软件工程专家马丁·福勒的以下引用：
- en: A library is essentially a set of functions that you can call, these days usually
    organized into classes. Each call does some work and returns control to the client.
    A framework embodies some abstract design, with more behavior built in. In order
    to use it you need to insert your behavior into various places in the framework
    either by subclassing or by plugging in your own classes. The framework's code
    then calls your code at these points.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 库本质上是一组可以调用的函数，这些天通常组织成类。每次调用都会执行一些工作并将控制返回给客户端。框架包含了一些抽象设计，并内置了更多的行为。为了使用它，您需要将您的行为插入到框架的各个位置，要么通过子类化，要么通过插入您自己的类。然后框架的代码在这些点调用您的代码。
- en: '![](img/00011.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: Visual explanation of the difference between library and framework
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 库和框架之间的视觉解释
- en: 'Frameworks are becoming more and more important in modern software development.
    They provide a capability highly desired in software-intensive systems: reusability.
    This way, large applications will end up consisting of layers of frameworks that
    cooperate with each other.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 框架在现代软件开发中变得越来越重要。它们提供了软件密集型系统中非常需要的可重用性能力。这样，大型应用程序最终将由相互合作的框架层组成。
- en: Other testing approaches
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他测试方法
- en: As introduced at the beginning of this section, there is no an universal definition
    for the different forms of testing. In this section we review some of the most
    commonly varieties of testing available in the literature not covered so far.
    For instance, when the testing process is performed to determine whether the system
    meets its specifications, it is known as *conformance testing*. When a new feature
    or functionality is introduced to a system (we can call it a build), the way of
    testing this new feature in known as *progression testing*. In addition to that,
    to check that the new introduced changes do not affect the correctness of the
    rest of the system, the existing test cases are exercised. This approach is commonly
    known as *regression testing*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节开头介绍的，对于不同形式的测试并没有一个通用的定义。在本节中，我们回顾了一些文献中常见的测试种类，例如当测试过程用于确定系统是否符合其规格时，它被称为*一致性测试*。当向系统引入新功能或功能（我们可以称之为构建）时，测试这个新功能的方式被称为*渐进测试*。此外，为了检查新引入的更改不会影响系统其余部分的正确性，现有的测试用例被执行。这种方法通常被称为*回归测试*。
- en: When the system interacts with any external or third-party system, another testing
    could be done, known as *system integration testing*. This kind of testing verifies
    that the system is integrated to any external systems properly.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统与任何外部或第三方系统进行交互时，可以进行另一种称为*系统集成测试*的测试。这种测试验证系统是否正确地集成到任何外部系统中。
- en: '*User or customer testing* is a stage in the testing process in which users
    or customers provide input and advice for system testing. *Acceptance testing*
    is a type of user testing, but there can also be different types of *user testing*:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户或客户测试* 是测试过程中的一个阶段，在该阶段用户或客户提供系统测试的输入和建议。*验收测试* 是用户测试的一种类型，但也可以有不同类型的*用户测试*：'
- en: '**Alpha testing**: This takes place at developers'' sites, working together
    with the software''s consumers, before it is released to external users or customers.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Alpha测试**：这在开发者的站点进行，与软件的消费者一起工作，然后才发布给外部用户或客户。'
- en: '**Beta testing**: This takes place at customer''s sites and involves testing
    by a group of customers who use the system at their own locations and provide
    feedback, before the system is released to other customers.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Beta测试**：这在客户的站点进行，涉及由一组客户对系统进行测试，他们在自己的位置使用系统并提供反馈，然后系统才会发布给其他客户。'
- en: '**Operational testing**: This is performed by the end user in its normal operating
    environment.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行测试**：这是由最终用户在其正常操作环境中执行的测试。'
- en: Finally, *release testing* refers to the process of testing a particular release
    of a system performed by a separate team outside the development team. The primary
    goal of the release testing process is to convince the supplier of the system
    that is good enough for use.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*发布测试* 指的是由开发团队之外的一个独立团队对系统的特定发布进行测试的过程。发布测试的主要目标是说服系统的供应商系统足够好以供使用。
- en: Testing frameworks for the JVM
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM的测试框架
- en: JUnit is a testing framework which allows to create automated tests. The development
    of JUnit was started by Kent Beck and Erich Gamma in late 1995\. Since then, the
    popularity of the framework has been growing. Nowadays, it is broadly considered
    as the *de facto* standard for testing Java applications.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit是一个允许创建自动化测试的测试框架。JUnit的开发始于1995年底，由Kent Beck和Erich Gamma发起。自那时起，该框架的流行度一直在增长。如今，它被广泛认为是测试Java应用程序的*事实*标准。
- en: JUnit was designed to be a unit-testing framework. Nevertheless, it can be used
    to implement not just unit tests, but also other kinds of tests. As we will discover
    in the body of this book, depending on how the test logic exercises the piece
    of software under test, a test case implemented with JUnit can be considered as
    an unit, integration, system, and even acceptance test. All in all, we can think
    of JUnit as a multi-purpose testing framework for Java.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit旨在成为一个单元测试框架。然而，它不仅可以用于实现单元测试，还可以用于其他类型的测试。正如我们将在本书的内容中发现的那样，根据测试逻辑如何对受测试软件进行测试，使用JUnit实现的测试用例可以被视为单元、集成、系统，甚至验收测试。总的来说，我们可以将JUnit视为Java的多用途测试框架。
- en: JUnit 3
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 3
- en: 'Since the early versions of JUnit 3, the framework can work with Java 2 and
    higher. JUnit3 is open source software, released under **Common Public License**
    (**CPL**) Version 1.0 and hosted on SourceForge ([https://sourceforge.net/projects/junit/](https://sourceforge.net/projects/junit/)).
    The latest version of JUnit 3 was JUnit 3.8.2, released on May 14, 2007\. The
    main requirements introduced by JUnit in the world of testing frameworks were
    the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 自JUnit 3的早期版本以来，该框架可以与Java 2及更高版本一起使用。JUnit3是开源软件，根据**Common Public License**（**CPL**）版本1.0发布，并托管在SourceForge（[https://sourceforge.net/projects/junit/](https://sourceforge.net/projects/junit/)）上。JUnit
    3的最新版本是JUnit 3.8.2，于2007年5月14日发布。JUnit在测试框架的世界中引入的主要要求如下：
- en: It should be easy to define which tests will run.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该很容易定义哪些测试将运行。
- en: The framework should be able to run tests independently of all other tests.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 框架应该能够独立运行所有其他测试。
- en: The framework should detect and report errors test by test.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 框架应该能够逐个测试检测和报告错误。
- en: Standard tests in JUnit 3
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 3中的标准测试
- en: In JUnit 3, in order to create test cases, we need to extend the class `junit.framework.TestCase`.
    This base class includes the framework code that JUnit needs to automatically
    run the tests. Then, we simply make sure that the method name follows the `testXXX()`
    pattern. This naming convention makes it clear to the framework that the method
    is a unit test and that it can be run automatically.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在JUnit 3中，为了创建测试用例，我们需要扩展类 `junit.framework.TestCase`。这个基类包括JUnit需要自动运行测试的框架代码。然后，我们只需确保方法名遵循
    `testXXX()` 模式。这个命名约定使得框架清楚地知道该方法是一个单元测试，并且可以自动运行。
- en: The test life cycle is controlled in the `setup()` and `tearDown()`methods.
    The `TestCase` calls `setup()` before running each of its tests and then calls
    `teardown()` when each test is complete. One reason to put more than one test
    method into the same test case is to share the same test fixture.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 测试生命周期由 `setup()` 和 `tearDown()` 方法控制。`TestCase` 在运行每个测试之前调用 `setup()`，然后在每个测试完成时调用
    `teardown()`。将多个测试方法放入同一个测试用例的原因之一是共享相同的测试装置。
- en: 'Finally, in order to implement the verification stage in the test case, JUnit
    3 defines several assert methods in a utility class named `junit.framework.Assert`.
    The following table summarizes the main assertions provided by this class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了在测试用例中实现验证阶段，JUnit 3在名为 `junit.framework.Assert` 的实用类中定义了几个断言方法。以下表总结了该类提供的主要断言：
- en: '| **Method** | **Description** |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `assertTrue` | Asserts that a condition is true. If it isn’t, the method
    throws an `AssertionFailedError` with the given message (if any). |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `assertTrue` | 断言条件为真。如果不是，方法将抛出带有给定消息的 `AssertionFailedError`（如果有的话）。'
- en: '| `assertFalse` | Asserts that a condition is false. If it isn’t, the method
    throws an `AssertionFailedError` with the given message (if any). |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `assertFalse` | 断言条件为假。如果不是，方法将抛出带有给定消息的 `AssertionFailedError`（如果有的话）。'
- en: '| `assertEquals` | Asserts that two objects are equal. If they are not, the
    method throws an `AssertionFailedError` with the given message (if any). |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `assertEquals` | 断言两个对象相等。如果它们不相等，方法将抛出带有给定消息的 `AssertionFailedError`（如果有的话）。'
- en: '| `assertNotNull` | Asserts that an object is not null. If it is, the method
    throws an `AssertionFailedError` with the message (if any). |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `assertNotNull` | 断言对象不为空。如果为空，方法将抛出带有消息的 `AssertionFailedError`（如果有的话）。'
- en: '| `assertNull` | Asserts that an object is null. If it isn’t, the method throws
    an `AssertionFailedError` with the given message (if any). |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `assertNull` | 断言对象为空。如果不是，则该方法将抛出带有给定消息的`AssertionFailedError`（如果有）。'
- en: '| `assertSame` | Asserts that two objects refer to the same object. If they
    do not, the method throws an `AssertionFailedError` with the given message (if
    any). |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `assertSame` | 断言两个对象引用同一个对象。如果不是，则该方法将抛出带有给定消息的`AssertionFailedError`（如果有）。'
- en: '| `assertNotSame` | Asserts that two objects do not refer to the same object.
    If they do, the method throws an `AssertionFailedError` with the given message
    (if any). |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `assertNotSame` | 断言两个对象不引用同一个对象。如果是，则该方法将抛出带有给定消息的`AssertionFailedError`（如果有）。'
- en: '| `fail` | Fails a test (throwing `AssertionFailedError`) with the given message
    (if any). |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `fail` | 使测试失败（抛出`AssertionFailedError`），并附上给定的消息（如果有）。'
- en: 'The following class shows a simple test implemented with JUnit 3.8.2\. As we
    can see, this test case contains two tests. Before each test, the method `setUp()`
    will be invoked by the framework, and after the execution of each test, the method
    `tearDown()` will be also invoked. This example has been coded so that the first
    test, named `testSuccess()` finishes correctly, and the second test named `testFailure()`
    ends with an error (the assertion throws an exception):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类显示了使用JUnit 3.8.2实现的简单测试。正如我们所看到的，这个测试用例包含两个测试。在每个测试之前，框架将调用`setUp()`方法，并且在每个测试执行之后，也将调用`tearDown()`方法。这个例子已经编码，使得第一个名为`testSuccess()`的测试正确完成，而第二个名为`testFailure()`的测试以错误结束（断言抛出异常）：
- en: '[PRE0]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All the code examples explained in this book are available on the GitHub repository
    [https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中解释的所有代码示例都可以在GitHub存储库[https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)上找到。
- en: Test execution in JUnit 3
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 3中的测试执行
- en: 'JUnit 3 allows to run test cases by means of Java applications called test
    runners. JUnit 3.8.2 provides three different test runners out of the box: two
    graphical (Swing and AWT based) and one textual that can be used from the command
    line. The JUnit framework provides separate class loaders for each test, in order
    to avoid side effects among tests.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 3允许通过称为测试运行器的Java应用程序运行测试用例。JUnit 3.8.2提供了三种不同的测试运行器：两种图形化（基于Swing和AWT）和一种可以从命令行使用的文本运行器。JUnit框架为每个测试提供单独的类加载器，以避免测试之间的副作用。
- en: It is a common practice that build tools (such as Ant or Maven) and **Integrated
    Development Environments** -**IDE**- (such as Eclipse and IntelliJ) implement
    its own JUnit test runner.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 构建工具（如Ant或Maven）和**集成开发环境**-**IDE**-（如Eclipse和IntelliJ）实现了自己的JUnit测试运行器是一种常见做法。
- en: The following image shows what the previous test looks like when we use the
    JUnit Swing runner, and also when we use Eclipse to run the same test case.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图片显示了当我们使用JUnit Swing运行器以及使用Eclipse运行相同的测试用例时，先前的测试是什么样子的。
- en: '![](img/00012.jpeg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00012.jpeg)'
- en: Execution of an JUnit 3 test case using the graphical Swing test runner and
    also with the Eclipse test runner
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图形化Swing测试运行器和Eclipse测试运行器执行JUnit 3测试用例
- en: 'When a test is not succeeded in JUnit, it can be for two reasons: a failure
    or an error. On the one hand, a failure is caused by an assertion (`Assert` class)
    which is not meet. On the other hand, an error is an unexpected condition not
    expected by the test, such as a conventional exception in the software under test.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当JUnit中的测试未成功时，可能有两个原因：失败或错误。一方面，失败是由未满足的断言（`Assert`类）引起的。另一方面，错误是测试中未预期的条件，例如被测试软件中的常规异常。
- en: Another important contribution of JUnit 3 is the concept of the test suite,
    which is a convenient way to group tests that are related. Test suites are implemented
    by means of the JUnit class `junit.framework.TestSuite`. This class, in the same
    way as `TestCase`, implements the framework interface `junit.framework.Test`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 3的另一个重要贡献是测试套件的概念，这是一种方便的方式来分组相关的测试。测试套件是通过JUnit类`junit.framework.TestSuite`实现的。这个类，与`TestCase`一样，实现了框架接口`junit.framework.Test`。
- en: 'A diagram containing the main classes and methods of JUnit 3 is depicted as
    follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了JUnit 3的主要类和方法：
- en: '![](img/00013.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: Core JUnit 3 classes
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 核心JUnit 3类
- en: '[PRE1]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This test suite can be later executed using a test runner. For example, we
    could use the command-line test runner (`junit.textui.TestRunner`) and the command
    line, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后可以使用测试运行器执行此测试套件。例如，我们可以使用命令行测试运行器（`junit.textui.TestRunner`）和命令行，如下所示：
- en: '![](img/00014.gif)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.gif)'
- en: Test suite executed using the textual test runner and the command line
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本测试运行器和命令行执行的测试套件
- en: JUnit 4
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 4
- en: JUnit 4 is still an open source framework, though the license changed with respect
    to JUnit 3, from CPL to **Eclipse Public License** (**EPL**) Version 1.0\. The
    source code of JUnit 4 is hosted on GitHub ([https://github.com/junit-team/junit4/](https://github.com/junit-team/junit4/)).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 4仍然是一个开源框架，尽管许可证与JUnit 3相比发生了变化，从CPL更改为**Eclipse Public License**（**EPL**）版本1.0。JUnit
    4的源代码托管在GitHub上（[https://github.com/junit-team/junit4/](https://github.com/junit-team/junit4/)）。
- en: On February 18, 2006, JUnit 4.0 was released. It follows the same high-level
    guidelines than JUnit 3, that is, easily define test, the framework run tests
    independently, and the framework detects and report errors by the test.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 2006年2月18日，发布了JUnit 4.0。它遵循与JUnit 3相同的高级指导方针，即轻松定义测试，框架独立运行测试，并且框架检测并报告测试中的错误。
- en: 'One of the main differences of JUnit 4 with respect to JUnit 3 is the way that
    JUnit 4 allows to define tests. In JUnit 4, Java annotations are used to mark
    methods as tests. For this reason, JUnit 4 can only be used for Java 5 or later.
    As the documentation of JUnit 4.0 stated back in 2006:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 4相对于JUnit 3的主要区别之一是JUnit 4允许定义测试的方式。在JUnit 4中，使用Java注解标记方法为测试。因此，JUnit
    4只能用于Java 5或更高版本。正如2006年JUnit 4.0的文档所述：
- en: The architecture of JUnit 4.0 is a substantial departure from that of earlier
    releases. Instead of tagging test classes by subclassing junit.framework.TestCase
    and tagging test methods by starting their name with 'test', you now tag test
    methods with the @Test annotation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 4.0的架构与早期版本有着很大的不同。现在，不再通过将测试类标记为子类化`junit.framework.TestCase`和通过以'test'开头的名称标记测试方法，而是使用`@Test`注解来标记测试方法。
- en: Standard tests in JUnit 4
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 4中的标准测试
- en: In JUnit 4, the `@Test` annotation (contained in package `org.junit`) represents
    a test. Any public method can be annotated with `@Test` to make it a test method.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在JUnit 4中，`@Test`注解（包含在`org.junit`包中）表示一个测试。任何公共方法都可以用`@Test`注解来标记为测试方法。
- en: 'In order to set up the test fixture, JUnit 4 provides the `@Before` annotation.
    This annotation can be used in any public method. Similarly, any public method
    annotated with `@After` gets executed after each test method execution. JUnit
    4 provides two more annotations to enhance the test life cycle: `@BeforeClass`
    and `@AfterClass`. They are executed only once per test class, before and after
    all tests, respectively. The following picture depicts the life cycle of a JUnit
    4 test case:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置测试装置，JUnit 4提供了`@Before`注解。这个注解可以在任何公共方法中使用。同样，任何使用`@After`注解标记的公共方法在每次测试方法执行后执行。JUnit
    4还提供了两个注解来增强测试生命周期：`@BeforeClass`和`@AfterClass`。它们只在每个测试类中执行一次，分别在所有测试之前和之后执行。以下图片描述了JUnit
    4测试用例的生命周期：
- en: '![](img/00015.jpeg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: JUnit 4 test life cycle
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 4测试生命周期
- en: '`@Before` and `@After` can be applied to any public void methods. `@AfterClass`
    and `@BeforeClass` can be applied to only public static void methods.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Before`和`@After`可以应用于任何公共void方法。`@AfterClass`和`@BeforeClass`只能应用于公共静态void方法。'
- en: 'The following table summarizes the main differences between JUnit 3 and JUnit
    4 seen so far:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了迄今为止在JUnit 3和JUnit 4中看到的主要区别：
- en: '| **Feature** | **JUnit 3** | **JUnit 4** |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: 特性 | JUnit 3 | JUnit 4
- en: '| Test definition | `testXXX` pattern | `@Test` annotation |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 测试定义 | `testXXX`模式 | `@Test`注解 |'
- en: '| Run before the first test | Not supported | `@BeforeClass` annotation |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 在第一个测试之前运行 | 不支持 | `@BeforeClass`注解 |'
- en: '| Run after all the tests | Not supported | `@AfterClass` annotation |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 在所有测试之后运行 | 不支持 | `@AfterClass`注解 |'
- en: '| Run before each test | Override `setUp()` method | `@Before` annotation |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 在每个测试之前运行 | 重写`setUp()`方法 | `@Before`注解 |'
- en: '| Run after each test | Override `tearDown()` method | `@After` annotation
    |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 在每个测试之后运行 | 重写`tearDown()`方法 | `@After`注解 |'
- en: '| Ignore tests | Not supported | `@Ignore` annotation |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 忽略测试 | 不支持 | `@Ignore`注解 |'
- en: 'The `org.junit.Assert` class provides static methods to carry out assertions
    (predicates). The following are the most useful assertion methods:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.junit.Assert`类提供了执行断言（谓词）的静态方法。以下是最有用的断言方法：'
- en: '`assertTrue`: If the condition becomes false, the assertion fails and `AssertionError`
    is thrown.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTrue`：如果条件变为false，则断言失败并抛出`AssertionError`。'
- en: '`assertFalse`: If the condition becomes true, the assertion fails and `AssertionError`
    is thrown.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFalse`：如果条件变为true，则断言失败并抛出`AssertionError`。'
- en: '`assertNull`: This checks whether the argument is null, otherwise throws `AssertionError`
    if the argument is not `null`.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNull`：这检查参数是否为空，否则如果参数不为空则抛出`AssertionError`。'
- en: '`assertNotNull`: This checks whether the argument is not null; otherwise, it
    throws `AssertionError`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotNull`：这检查参数是否不为空；否则，它会抛出`AssertionError`。'
- en: '`assertEquals`: This compares two objects or primitive types. Moreover, if
    the actual value doesn''t match the expected value, `AssertionError` is thrown.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEquals`：这比较两个对象或原始类型。此外，如果实际值与期望值不匹配，则会抛出`AssertionError`。'
- en: '`assertSame`: This supports only objects and checks the object reference using
    the `==` operator.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertSame`：这仅支持对象，并使用`==`运算符检查对象引用。'
- en: '`assertNotSame`: This is the opposite of `assertSame`.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotSame`：这是`assertSame`的相反。'
- en: 'The following snippets provide a simple example of a JUnit 4 test case. As
    we can see, it is the equivalent test case as seen in the previous section, this
    time using the JUnit 4 programming model, that is, using `@Test` annotation to
    identify tests and other annotations (`@AfterAll`, `@After`, `@BeforeAll`, `@Before`)
    to implement the test life cycle (setup and teardown test fixture):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段提供了JUnit 4测试用例的简单示例。正如我们所看到的，这是与前一节中看到的等效测试用例相同，这次使用JUnit 4编程模型，即使用`@Test`注解来标识测试和其他注解（`@AfterAll`，`@After`，`@BeforeAll`，`@Before`）来实现测试生命周期（设置和拆卸测试装置）：
- en: '[PRE3]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Test execution in JUnit 4
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 4中的测试执行
- en: 'The concept of the test runner is also present in JUnit 4, but it was slightly
    improved with respect to JUnit 3\. In JUnit 4, a test runner is a Java class used
    to manage a test’s life cycle: instantiation, calling setup and teardown methods,
    running the test, handling exceptions, sending notifications, and so on. The default
    JUnit 4 test runner is called `BlockJUnit4ClassRunner`, and it implements the
    JUnit 4 standard test case class model.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器的概念在JUnit 4中也存在，但与JUnit 3相比略有改进。在JUnit 4中，测试运行器是一个用于管理测试生命周期的Java类：实例化，调用设置和拆卸方法，运行测试，处理异常，发送通知等等。默认的JUnit
    4测试运行器称为`BlockJUnit4ClassRunner`，它实现了JUnit 4标准测试用例类模型。
- en: The test runner to be used in a JUnit 4 test case can be changed simply using
    the annotation `@RunWith`. JUnit 4 provides a collection of built-in test runners
    that allows to change the nature of the test class. In this section, we are going
    to review the most important ones.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在JUnit 4测试用例中使用的测试运行器可以通过简单地使用`@RunWith`注解来更改。JUnit 4提供了一系列内置的测试运行器，允许更改测试类的性质。在本节中，我们将回顾最重要的运行器。
- en: 'To run a group of tests (that is, a test suite) JUnit 4 provides the `Suite`
    runner. In addition to the runner, the class `Suite.SuiteClasses` allows to define
    the individual test classes belonging to the suite. For example:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了运行一组测试（即测试套件），JUnit 4提供了`Suite`运行器。除了运行器，`Suite.SuiteClasses`类还允许定义属于套件的单个测试类。例如：
- en: '[PRE4]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Parameterized tests are used to specify different input data that is going
    to be used in the same test logic. To implement this kind of tests, JUnit 4 provides
    the `Parameterized` runner. To define the data parameters in this type of test,
    we need to annotate a static method of the class with the annotation `@Parameters`.
    This method should return a `Collection` of the two-dimensional array providing
    input parameters for the test. Now, there will be two options to inject the input
    data into the test:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化测试用于指定将在相同测试逻辑中使用的不同输入数据。为了实现这种类型的测试，JUnit 4提供了`Parameterized`运行器。要在此类型的测试中定义数据参数，我们需要使用注解`@Parameters`对类的静态方法进行注释。此方法应返回提供测试输入参数的二维数组的`Collection`。现在，将有两种选项将输入数据注入到测试中：
- en: Using the constructor class.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用构造函数类。
- en: Annotating class attributes with the annotation `@Parameter`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用注解`@Parameter`对类属性进行注释。
- en: 'The following snippets show an example of the latter:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了后者的示例：
- en: '[PRE5]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The execution of this test on Eclipse would be as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse上执行此测试将如下所示：
- en: '![](img/00016.jpeg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: Execution of a Parameterized test in Eclipse
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中执行参数化测试
- en: 'JUnit theories are an alternative to JUnit''s parameterized tests. A JUnit
    theory is expected to be true for all datasets. Thus, in JUnit theories, we have
    a method providing data points (that is, the input values to be used for the test).
    Then, we need to specific a method annotated with `@Theory` which takes parameters.
    The theories in a class get executed with every possible combination of data points:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit理论是JUnit参数化测试的一种替代方法。JUnit理论预期对所有数据集都为真。因此，在JUnit理论中，我们有一个提供数据点的方法（即用于测试的输入值）。然后，我们需要指定一个带有`@Theory`注解的方法，该方法带有参数。类中的理论将使用数据点的每种可能组合执行：
- en: '[PRE6]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Take a look at the execution of this example, again in Eclipse:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在Eclipse中查看此示例的执行：
- en: '![](img/00017.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: Execution of a JUnit 4 theory in Eclipse
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中执行JUnit 4理论
- en: Advanced features of JUnit 4
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 4的高级功能
- en: 'One of the most significant innovations introduced in JUnit 4 was the use of
    *rules*. Rules allow flexible addition or redefinition of the behavior of each
    test method in a test class. A rule should be included in a test case by annotating
    a class attribute with the annotation `@Rule`. The type of this attribute should
    inherit the JUnit interface `org.junit.rulesTestRule`. The following rules are
    provided out of the box in JUnit 4:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在JUnit 4中引入的最重要的创新之一是使用*规则*。规则允许灵活地添加或重新定义测试类中每个测试方法的行为。通过使用注解`@Rule`将规则包含在测试用例中。此属性的类型应继承JUnit接口`org.junit.rulesTestRule`。JUnit
    4中提供了以下规则：
- en: '`ErrorCollector`: This rule allows execution of a test to continue after the
    first problem is found'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ErrorCollector`：此规则允许在发现第一个问题后继续执行测试'
- en: '`ExpectedException`: This rule allows to verify that a test throws a specific
    exception'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExpectedException`：此规则允许验证测试是否引发特定异常'
- en: '`ExternalResource`: This rule provides a base class for Rules that set up an
    external resource before a test (a file, socket, server, database connection,
    and so on) and guarantee to tear it down afterward'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExternalResource`：此规则为在测试之前设置外部资源（文件、套接字、服务器、数据库连接等）并保证在之后拆除的规则提供了一个基类'
- en: '`TestName`: This rule makes the current test name available inside test methods'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestName`：此规则使当前测试名称在测试方法内部可用'
- en: '`TemporaryFolder`: This rule allows creation of files and folders that should
    be deleted when the test method finishes'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TemporaryFolder`：此规则允许创建在测试方法完成时应删除的文件和文件夹'
- en: '`Timeout`: This rule applies the same timeout to all test methods in a class'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Timeout`：此规则将相同的超时应用于类中的所有测试方法'
- en: '`TestWatcher`: It is a base class for rules that will keep a log of each passing
    and failing test'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestWatcher`：这是一个记录每个通过和失败测试的规则的基类'
- en: 'Another advance JUnit 4 features allow to:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 4的另一个先进功能允许：
- en: Execute tests is a given order, using the annotation `@FixMethodOrder`.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注解`@FixMethodOrder`按给定顺序执行测试。
- en: Create assumptions using the class Assume. This class offers many static methods,
    such as `assumeTrue(condition)`, `assumeFalse(condition)`, `assumeNotNull(condition)`,
    and `assumeThat(condition)`. Before executing a test, JUnit checks the assumptions
    present in the test. If one of the assumptions fail, the JUnit runner ignores
    the tests with failing assumptions.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Assume类创建假设。该类提供许多静态方法，例如`assumeTrue(condition)`、`assumeFalse(condition)`、`assumeNotNull(condition)`和`assumeThat(condition)`。在执行测试之前，JUnit会检查测试中的假设。如果其中一个假设失败，JUnit运行器将忽略具有失败假设的测试。
- en: JUnit provides a timeout value (in milliseconds) in the `@Test` annotation to
    make sure that if a test runs longer than the specified value, the test fails.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit在`@Test`注解中提供了一个超时值（以毫秒为单位），以确保如果测试运行时间超过指定值，则测试失败。
- en: Categorize tests using the test runner `Categories` and identify the types of
    test annotating the tests method with the annotation `Category`.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试运行器`Categories`对测试进行分类，并使用注解`Category`对测试方法进行标注以识别测试的类型。
- en: Meaningful examples for each of one of the earlier mentioned features can be
    found in the GitHub repository ([https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub存储库中可以找到每个先前提到的功能的有意义的示例（[https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)）。
- en: JUnit ecosystem
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit生态系统
- en: 'JUnit is one of the most popular test frameworks for the JVM, and it is considered
    one of the most influential frameworks in software engineering. We can find several
    libraries and frameworks that provide additional functionality on top of JUnit.
    Some examples of these ecosystem enhancers are:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit是JVM中最受欢迎的测试框架之一，被认为是软件工程中最有影响力的框架之一。我们可以找到几个库和框架，它们在JUnit的基础上提供了额外的功能。这些生态系统增强器的一些示例是：
- en: 'Mockito ([http://site.mockito.org/](http://site.mockito.org/)): This is the
    mock framework, which can be used in conjunction with JUnit.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mockito（[http://site.mockito.org/](http://site.mockito.org/)）：这是一个模拟框架，可以与JUnit一起使用。
- en: 'AssertJ ([http://joel-costigliola.github.io/assertj/](http://joel-costigliola.github.io/assertj/)):
    This is the fluent assertions library for Java.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AssertJ（[http://joel-costigliola.github.io/assertj/](http://joel-costigliola.github.io/assertj/)）：这是Java的流畅断言库。
- en: 'Hamcrest ([http://hamcrest.org/](http://hamcrest.org/)): This is the library
    with matchers that can be combined to create flexible and readable assertions.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hamcrest（[http://hamcrest.org/](http://hamcrest.org/)）：这是具有匹配器的库，可以组合以创建灵活且可读的断言。
- en: 'Cucumber ([https://cucumber.io/](https://cucumber.io/)): This is the testing
    framework that allows to run automated acceptance tests written in a **Behavior-Driven
    Development** (**BDD**) style.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cucumber（[https://cucumber.io/](https://cucumber.io/)）：这是允许以**行为驱动开发**（**BDD**）风格编写的自动化验收测试的测试框架。
- en: 'FitNesse ([http://www.fitnesse.org/](http://www.fitnesse.org/)): This is the
    testing framework designed to support acceptance testing by facilitating detailed
    readable descriptions of system functions.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FitNesse（[http://www.fitnesse.org/](http://www.fitnesse.org/)）：这是旨在通过支持系统功能的详细可读描述来支持验收测试的测试框架。
- en: 'While JUnit is the largest testing framework for the JVM, it is not the only
    one. There are several other testing frameworks available for the JVM. Some examples
    are:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JUnit是JVM上最大的测试框架，但并非唯一的测试框架。JVM上还有几个其他测试框架可用。一些例子包括：
- en: 'TestNG ([http://testng.org/](http://testng.org/)): This is the testing framework
    inspired from JUnit and NUnit.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TestNG（[http://testng.org/](http://testng.org/)）：这是受到JUnit和NUnit启发的测试框架。
- en: 'Spock ([http://spockframework.org/](http://spockframework.org/)): This is the
    testing and specification framework for Java and Groovy applications.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spock（[http://spockframework.org/](http://spockframework.org/)）：这是Java和Groovy应用程序的测试和规范框架。
- en: 'Jtest ([https://www.parasoft.com/product/jtest/](https://www.parasoft.com/product/jtest/)):
    This is the automated Java testing and static analysis framework made and distributed
    by the company Parasoft.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jtest（[https://www.parasoft.com/product/jtest/](https://www.parasoft.com/product/jtest/)）：这是由Parasoft公司制作和分发的自动化Java测试和静态分析框架。
- en: 'Scalatest ([http://www.scalatest.org/](http://www.scalatest.org/)): This is
    the testing framework for Scala, Scala.js (JavaScript), and Java applications.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scalatest（[http://www.scalatest.org/](http://www.scalatest.org/)）：这是Scala、Scala.js（JavaScript）和Java应用程序的测试框架。
- en: 'Thanks to JUnit, testing has moved to a central part of programming. Consequently,
    the underlying testing model implemented in JUnit, has been ported to a set of
    testing frameworks outside the boundary of the JVM, in the so-called xUnit family.
    In this model, we find the concepts of test case, runner, fixture, suite, test
    execution, report, and assertion. To name a few, consider the following frameworks.
    All of them fall into the xUnit family:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JUnit，测试已经成为编程的核心部分。因此，在JVM边界之外，JUnit实现的基础测试模型已被移植到所谓的xUnit家族的一系列测试框架中。在这个模型中，我们找到了测试用例、运行器、固定装置、套件、测试执行、报告和断言的概念。举几个例子，考虑以下框架。所有这些都属于xUnit家族：
- en: 'Google Test ([https://github.com/google/googletest](https://github.com/google/googletest)):
    Google''s C++ testing framework.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Test（[https://github.com/google/googletest](https://github.com/google/googletest)）：Google的C++测试框架。
- en: 'JSUnit ([http://www.jsunit.net/](http://www.jsunit.net/)): Unit testing framework
    for JavaScript.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSUnit（[http://www.jsunit.net/](http://www.jsunit.net/)）：JavaScript的单元测试框架。
- en: 'Mocha ([https://mochajs.org/](https://mochajs.org/)): Unit testing framework
    running on Node.js.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mocha（[https://mochajs.org/](https://mochajs.org/)）：在Node.js上运行的单元测试框架。
- en: 'NUnit ([https://www.nunit.org/](https://www.nunit.org/)): Unit testing framework
    for Microsoft.NET.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NUnit（[https://www.nunit.org/](https://www.nunit.org/)）：用于Microsoft.NET的单元测试框架。
- en: 'PHPUnit ([https://phpunit.de/](https://phpunit.de/)): Unit testing framework
    for PHP.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHPUnit（[https://phpunit.de/](https://phpunit.de/)）：PHP的单元测试框架。
- en: 'SimplyVBUnit ([http://simplyvbunit.sourceforge.net/](http://simplyvbunit.sourceforge.net/)):
    Unit testing framework for VB.NET.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SimplyVBUnit（[http://simplyvbunit.sourceforge.net/](http://simplyvbunit.sourceforge.net/)）：VB.NET的单元测试框架。
- en: 'Unittest ([https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)):
    Unit testing framework for Python.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unittest（[https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)）：Python的单元测试框架。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: '*Software quality* is a key concept in software engineering, since it determines
    the degree in which a software system meets its requirements and user expectations.
    Verification and Validation is the name given to set of activities aimed to assess
    a software system. The goal of V&V is to ensure the quality of a piece of software
    while reducing the number of defects. The two core activities in V&V are *software
    testing* (evaluation of a running piece of software) and *static analysis* (assessment
    of software artefacts without its execution).'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件质量*是软件工程中的关键概念，因为它决定了软件系统满足其要求和用户期望的程度。验证和验证是一组旨在评估软件系统的活动的名称。V&V的目标是确保软件的质量，同时减少缺陷的数量。V&V中的两个核心活动是*软件测试*（评估运行中的软件）和*静态分析*（评估软件构件而不执行）。'
- en: '*Automated software testing* has experienced biggest advances in the last few
    decades. In this arena, the *JUnit framework* has a remarkable position. JUnit
    was designed to be a unit framework for the JVM. Nowadays, it is a fact that JUnit
    is the most popular test frameworks in the Java community, providing a comprehensive
    programming model to create and execute test cases. In the next section, we will
    discover the features and capabilities provided by the new version of the framework,
    JUnit 5.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动化软件测试*在过去几十年中取得了最大的进步。在这个领域，*JUnit框架*占据着重要的地位。JUnit旨在成为JVM的单元框架。如今，事实上JUnit是Java社区中最流行的测试框架，提供了一个全面的编程模型来创建和执行测试用例。在下一节中，我们将了解框架的新版本JUnit
    5提供的功能和能力。'
