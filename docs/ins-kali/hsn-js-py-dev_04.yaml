- en: Nitty-Gritty Grammar
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 细枝末节的语法
- en: When comparing two programming languages, there are bound to be structural and
    grammatical differences. The good news is that both Python and JavaScript are
    very human-readable languages, so the context switch from Python to JavaScript
    and Node.js shouldn't be too taxing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较两种编程语言时，必然会有结构和语法上的差异。好消息是，Python和JavaScript都是非常易读的语言，所以从Python切换到JavaScript和Node.js的上下文转换不应该太费力。
- en: 'Style is a good question, though: tabs or spaces? Semicolons or not? Many stylistic
    questions that arise when writing in any programming languages have been answered
    by the dicta contained within Python''s PEP-8 style guide. While JavaScript doesn''t
    have an official style guide, don''t worry—it''s not the Wild West out there.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 风格是一个很好的问题：制表符还是空格？分号还是不用？在任何编程语言中写作时出现的许多风格问题都已经在Python的PEP-8风格指南中得到了回答。虽然JavaScript没有官方的风格指南，但不用担心——外面并不是西部荒野。
- en: Before we can write JavaScript, we must know what it is to be able to read it
    and understand it. All programming languages vary from one to another, and using
    your Python knowledge to learn a new language will require a bit of reframing
    of your thoughts. For example, what does JavaScript look like when we want to
    declare variables? How is it constructed so that the computer understands it?
    What do we need to watch out for as we progress?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够编写JavaScript之前，我们必须知道它是什么，才能够阅读和理解它。所有编程语言都有所不同，利用你的Python知识来学习一门新语言将需要一些思维的重新构建。例如，当我们想要声明变量时，JavaScript是什么样子的？它是如何构建的，以便计算机能够理解？在我们进展时，我们需要注意什么？
- en: This chapter is the key to unlocking what JavaScript can do and how to do it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是解锁JavaScript能做什么以及如何做的关键。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: A history of style
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风格的历史
- en: Grammar rules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法规则
- en: Punctuation and readability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标点和可读性
- en: The elephant in the room – whitespace
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 房间里的大象-空白
- en: Existing standards – linting to the rescue!
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有标准-使用linting来拯救！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To code along with the examples in this chapter, you have a few choices:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟着本章的示例编码，你有几种选择：
- en: Code directly in the JavaScript console in your browser
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接在浏览器的JavaScript控制台中编码
- en: Code in the Node command line
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Node命令行中编码
- en: Use a web editor, such as [jsfiddle.net](https://jsfiddle.net) or [codepen.io](https://codepen.io)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网络编辑器，如[jsfiddle.net](https://jsfiddle.net)或[codepen.io](https://codepen.io)
- en: Using a web editor may be preferable as you can easily save your progress. You
    should familiarize yourself with bringing up the JavaScript console in the browser
    anyway, as we'll be using it for debugging output. This is usually in the View menu
    in your browser; consult your browser's documentation for how to find it if it's
    not immediately obvious, as some browsers require turning on Developer mode in Preferences.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络编辑器可能更可取，因为你可以轻松保存你的进度。无论如何，你应该熟悉如何在浏览器中打开JavaScript控制台，因为我们将用它来调试输出。这通常在浏览器的“查看”菜单中；如果不是很明显，一些浏览器可能需要在“偏好设置”中打开开发者模式，所以请查阅你的浏览器文档以找到它。
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，网址为[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting)。
- en: A history of style
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 风格的历史
- en: Every programming language has its own style, designed to ease legibility and
    comprehension of each line of code. Some languages are stricter than others; JavaScript
    in its vanilla form is one of the looser languages in adhering to style. *The
    Elements of Programming Style* by Brian W. Kernighan and P. J. Plauger, first
    published in 1974, has a number of aphorisms that have helped shape not only coding
    standards but also programming languages themselves.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都有自己的风格，旨在简化每行代码的可读性和理解性。有些语言比其他语言更严格；JavaScript在其原始形式中是较为宽松的语言之一。Brian
    W. Kernighan和P. J. Plauger在1974年首次出版的《编程风格的要素》中有许多格言，这些格言不仅帮助塑造了编码标准，也塑造了编程语言本身。
- en: 'You may be familiar with the PEP-20 aphorisms from *The* *Zen of Python*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉*Python*的PEP-20格言：
- en: Beautiful is better than ugly.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美好胜过丑陋。
- en: Explicit is better than implicit.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确比隐式更好。
- en: Simple is better than complex.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单比复杂更好。
- en: Complex is better than complicated.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂比复杂更好。
- en: Flat is better than nested.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面比嵌套更好。
- en: Sparse is better than dense.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稀疏比密集好。
- en: Readability counts.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读性很重要。
- en: Special cases aren't special enough to break the rules.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊情况并不足以打破规则。
- en: Although practicality beats purity.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管实用性胜过纯洁性。
- en: Errors should never pass silently.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误不应该悄悄地传递。
- en: Unless explicitly silenced.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非明确被消除。
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面对模棱两可，拒绝猜测的诱惑。
- en: There should be one—and preferably only one—obvious way to do it.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一种——最好只有一种——明显的方法来做到这一点。
- en: Although that way may not be obvious at first unless you're Dutch.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管这种方式一开始可能不明显，除非你是荷兰人。
- en: Now is better than never.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在总比永远好。
- en: Although never is often better than *right* now.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管从来比*现在*好。
- en: If the implementation is hard to explain, it's a bad idea.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果实现难以解释，那是个坏主意。
- en: If the implementation is easy to explain, it may be a good idea.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果实现容易解释，那可能是个好主意。
- en: Namespaces are one honking great idea—let's do more of those!
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间是一个很棒的想法——我们应该做更多这样的事情！
- en: Tongue-in-cheek qualities aside, many of these aphorisms are inspired by the
    principles written and experiences gained before Python was developed. First released
    in 1991, Python from the start had an emphasis on code readability and has some
    strict guidelines in place, from PEP-8 to PEP-20.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 开玩笑的特质抛开不谈，这些格言中的许多都是在Python开发之前写下的原则和经验的启发。Python于1991年首次发布，从一开始就强调代码的可读性，并制定了一些严格的指导方针，从PEP-8到PEP-20。
- en: 'Let''s take, for example, two aphorisms:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子，比如两个格言：
- en: '| **The Elements of Programming Style, 1974** | **The Zen of Python, 1999**
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **编程风格的要素，1974** | **Python之禅，1999** |'
- en: '| Write clearly—don''t be too clever. | Explicit is better than implicit. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 写得清晰——不要太聪明。 | 明确比含蓄更好。 |'
- en: Similar ideas are being expressed here. I think most software engineers would
    agree with the statement that being clear, explicit, and legible are good qualities
    to strive for as you develop your program.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里表达了类似的观点。我认为大多数软件工程师都会同意这样一种说法，即清晰、明确和可读是你在开发程序时应该追求的良好品质。
- en: 'There is one idea to keep strongly in mind, however, as you keep advancing
    in your JavaScript learning: since JavaScript''s syntax is *designed* to be looser
    than that of some other languages, you may find that different companies have
    an in-house style to use for JavaScript code. This is not unique to JavaScript—many
    languages also have style guides in a company to enforce code consistency across
    employees. It also helps the greater ecosystem of the language to have consistently
    readable code. However, this does lead to differences from one code base to another
    in terms of style.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个观点需要牢记，随着你在JavaScript学习中不断进步：由于JavaScript的语法*设计*比其他一些语言更宽松，你可能会发现不同的公司对JavaScript代码有自己的内部风格。这并不是JavaScript独有的现象——许多语言在公司中也有风格指南，以确保员工之间的代码一致性。这也有助于语言的整体生态系统具有一致的可读性。然而，这会导致不同代码库在风格上存在差异。
- en: As with any language, we need to know our grammar to know how we're going to
    write JavaScript. As with Python, the machine expects properly formatted code
    before it does its work, and this is your job. On to grammar.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何语言一样，我们需要了解语法，以知道我们将如何编写JavaScript。与Python一样，机器在执行工作之前期望得到格式正确的代码，这是你的工作。接下来是语法。
- en: Grammar rules
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法规则
- en: 'Just like with any other programming language, JavaScript has grammar rules
    that are to be followed in order for the computer to understand what our code
    is trying to tell it. These rules are fairly straightforward and range from capitalizing
    and punctuating your code, which enhances the readability, to using specific structures
    within your code and avoiding common words that can confuse meaning. The rules
    of JavaScript syntax are fairly simple and straightforward; they include the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他编程语言一样，JavaScript有语法规则必须遵循，以便计算机理解我们的代码想要告诉它的内容。这些规则相当简单明了，从大写和标点符号到使用特定结构和避免混淆含义的常用词，都可以提高代码的可读性。JavaScript语法规则包括以下内容：
- en: Capitalization
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大写
- en: Reserved words
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留关键字
- en: Variable syntax
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量语法
- en: Data types
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: Logic structures
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑结构
- en: Functions
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Punctuation
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标点符号
- en: Capitalization counts
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大小写很重要
- en: As with most programming languages, capitalization makes a difference. The `myNode`
    and `mynode` variables will be interpreted as completely different variables.
    That is, the computer will absolutely see the relationship between `myNode` and `mynode`
    because they are capitalized differently.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数编程语言一样，大小写有所不同。`myNode`和`mynode`变量将被解释为完全不同的变量。也就是说，计算机会完全区分`myNode`和`mynode`，因为它们的大小写不同。
- en: Reserved words
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留关键字
- en: 'There are a good number of words reserved in JavaScript that cannot be used
    for variable names. Here is a list of most of them:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中有许多保留的关键字不能用作变量名。以下是其中大部分的列表：
- en: '| `abstract` `arguments`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '| `abstract` `arguments`'
- en: '`await`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`'
- en: '`boolean`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean`'
- en: '`break`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`byte`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte`'
- en: '`case`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`'
- en: '`catch`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`'
- en: '`char`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`'
- en: '`class`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`'
- en: '`const`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`'
- en: '`continue`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`'
- en: '`debugger`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`debugger`'
- en: '`default`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`'
- en: '`delete`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`'
- en: '`do` | `double` `else`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`do` | `double` `else`'
- en: '`enum`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`'
- en: '`eval`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`'
- en: '`export`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`export`'
- en: '`extends`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`extends`'
- en: '`false`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`final`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`'
- en: '`finally`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`'
- en: '`float`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`for`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`'
- en: '`function`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`function`'
- en: '`goto`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`'
- en: '`if`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`'
- en: '`implements`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`implements`'
- en: '`import` | `in` `instanceof`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` | `in` `instanceof`'
- en: '`int`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`interface`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`interface`'
- en: '`let`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`'
- en: '`long`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`long`'
- en: '`native`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`native`'
- en: '`new`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`'
- en: '`null`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`'
- en: '`package`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`package`'
- en: '`private`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`'
- en: '`protected`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`'
- en: '`public`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`'
- en: '`return`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`'
- en: '`short`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`short`'
- en: '`static` | `super` `switch`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` | `super` `switch`'
- en: '`synchronized`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized`'
- en: '`this`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`'
- en: '`throw`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`'
- en: '`throws`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`throws`'
- en: '`transient`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`transient`'
- en: '`true`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`'
- en: '`try`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`'
- en: '`typeof`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof`'
- en: '`var`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`'
- en: '`void`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`'
- en: '`volatile`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`volatile`'
- en: '`while`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`'
- en: '`with`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`'
- en: '`yield` |'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield` |'
- en: These are always in lowercase, and if you were to attempt to use one of these
    words as a variable name, the program would show an error.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键字始终以小写形式存在，如果尝试将其中一个关键字用作变量名，程序将显示错误。
- en: Declaring variables
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: In JavaScript, it's best practice to declare variables before using them. This
    declaration can happen at the time of assignment to a value, or you can define
    a variable without a value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，最好在使用变量之前声明变量。这个声明可以在赋值时进行，也可以定义一个没有值的变量。
- en: Unlike some other languages, JavaScript is *loosely typed*, so you don't need
    to declare what type of variable you're creating. By convention, variables in
    JavaScript start with a lowercase letter and follow camel-casing, rather than
    snake-casing. So, `myAge` is preferable to `my_age` or `MyAge`. Variables cannot
    start with a number.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些语言不同，JavaScript是*弱类型*的，因此不需要声明正在创建的变量的类型。按照惯例，JavaScript中的变量以小写字母开头，采用驼峰命名法，而不是蛇形命名法。因此，`myAge`比`my_age`或`MyAge`更可取。变量不能以数字开头。
- en: 'There are three keywords used to declare variables in JavaScript: `const`, `let`,
    and `var`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中有三个关键字用于声明变量：`const`、`let`和`var`。
- en: const
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: const
- en: 'A **const**, short for **constant**, is a variable that is not expected to
    change in value over the course of the program. They''re useful for enforcing
    values that you don''t want to change. Prior to the sixth edition of ECMAScript,
    ES2015 (often called ES6), it was possible to mutate the value of any variable,
    so mistakes such as using an assignment operator (`=`) instead of a comparison
    operator (`==` or `===`) were common:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**const**，即**constant**，是一个在程序运行过程中不会改变值的变量。它们对于强制执行不希望更改的值很有用。在ECMAScript的第六版ES2015（通常称为ES6）之前，任何变量的值都可以被改变，因此常见的错误，比如使用赋值运算符（`=`）而不是比较运算符（`==`或`===`）：'
- en: '[PRE0]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Sure, Captain Picard *could* change his name, but that doesn't seem very likely.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，皮卡德船长*可能*会改变他的名字，但这似乎不太可能。
- en: 'Sometimes, we want to declare a variable as a hard constant, such as pi or
    an API key. These use cases are, in general, the only exception to the naming
    standards, in that they are often all uppercase and sometimes have underscores:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想将变量声明为硬常量，比如π或API密钥。这些用例通常是对命名标准的唯一例外，通常全部大写，有时有下划线：
- en: '[PRE1]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So far, we have examples of two data types: **strings** and **numbers**. JavaScript
    doesn''t have a concept of *float* versus *int* versus *long*; they''re all numbers.
    If you noticed, we can also declare strings with single or double quotes. Some
    libraries and frameworks have a preference for one over the other, but for standard
    JavaScript, it''s OK to use either. It''s best practice to be consistent in your
    usage, however.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了两种数据类型的示例：**字符串**和**数字**。JavaScript没有*float*与*int*与*long*的概念；它们都是数字。如果你注意到了，我们也可以用单引号或双引号声明字符串。一些库和框架更喜欢其中一种，但对于标准的JavaScript来说，使用任何一种都可以。然而，最好保持一致。
- en: let
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: let
- en: 'When declaring a variable using `let`, we explicitly state that we expect or
    allow the value of the variable to change over the course of the program:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`声明变量时，我们明确声明我们期望或允许变量的值在程序运行过程中发生变化：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Captain Picard can be transferred to another ship at any time, so we want our
    program to allow changes in value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 皮卡德船长随时可以被转移到另一艘船上，所以我们希望我们的程序允许值的变化。
- en: var
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: var
- en: The oldest way of defining a variable in JavaScript is with the `var` keyword.
    Declaring with `var` does not place any restrictions on the value of the variable;
    it can be changed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中定义变量的最古老的方法是使用`var`关键字。使用`var`声明不会对变量的值施加任何限制；它可以被更改。
- en: The use of `var` is still supported but considered legacy and was deprecated
    in ES6\. However, with decades of existing programs and examples, it's important
    to at least be familiar with `var`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`的使用仍然受支持，但被认为是遗留的，并在ES6中被弃用。然而，由于存在数十年的现有程序和示例，至少熟悉`var`是很重要的。'
- en: Data types
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型
- en: Even though JavaScript is loosely typed, it's important to know about the data
    types available to us, as we will need to know them for issues such as comparisons
    and reassignment.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript是弱类型的，但了解可用的数据类型对我们很重要，因为我们需要了解它们以解决比较和重新赋值等问题。
- en: 'Here is a rough mapping of the base Pythonic variables to base JavaScript:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基本Python变量到基本JavaScript的粗略映射：
- en: '| **Python** | **JavaScript** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **Python** | **JavaScript** |'
- en: '| Number | Number |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| Number | Number |'
- en: '| String | String |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| String | String |'
- en: '| List | Array |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| List | Array |'
- en: '| Dictionary | Object |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| Dictionary | Object |'
- en: '| Set | Set |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| Set | Set |'
- en: 'This covers the base types you''re likely to use. Let''s examine other, more
    nuanced JavaScript data types. Some have equivalents in Python and some don''t:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了你可能会使用的基本类型。让我们来看看其他更微妙的JavaScript数据类型。有些在Python中有对应的，有些没有：
- en: '| **Python** | **JavaScript Semi-Equivalent** | **Reason for Difference** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **Python** | **JavaScript半等效** | **差异原因** |'
- en: '| `bool` | `boolean` | While the data types are identical in practice, Python''s
    `bool` data type inherits from `int`. While `1` and `0` can be used in JavaScript
    to represent `True` and `False`, they will not be recognized as the `boolean`
    type. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `boolean` | 虽然在实践中数据类型是相同的，但Python的`bool`数据类型继承自`int`。虽然在JavaScript中可以使用`1`和`0`表示`True`和`False`，但它们不会被识别为`boolean`类型。|'
- en: '| `None` | `null` | Technically, `None` is an object in and of itself, whereas
    `null` is a falsy value. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `None` | `null` | 从技术上讲，`None`本身就是一个对象，而`null`是一个假值。|'
- en: '|  | `undefined` | In JavaScript, a variable that has not been declared with
    a value still has a pseudovalue: the singleton of the `undefined` value. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|  | `undefined` | 在JavaScript中，一个没有用值声明的变量仍然有一个伪值：`undefined`的单例值。|'
- en: '|  | `object` | Both Python and JavaScript are object-oriented languages, but
    their use of objects is a bit different. The base use of an object in JavaScript
    is a key-value store. Objects are not primitives and can store multiple types
    of data. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  | `object` | Python和JavaScript都是面向对象的语言，但它们对对象的使用有些不同。JavaScript中对象的基本用法是键值存储。对象不是原始类型，可以存储多种类型的数据。|'
- en: '|  | `symbol` | Symbols are a new data type in ES6\. While the uses are nuanced,
    they''re worth mentioning. They are used to create unique identifiers for objects.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|  | `symbol` | 符号是ES6中的一种新数据类型。虽然使用方法有微妙之处，但值得一提。它们用于为对象创建唯一标识符。|'
- en: Now, we need to find out a bit more about types before we can use them, including
    how to compare them and work with them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更多地了解一些类型，包括如何比较它们和处理它们。
- en: typeof and equality
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: typeof和equality
- en: 'Even though variable types are mutable, it''s often useful to know what data
    type a variable is at that moment. The `typeof` operator helps us do that:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管变量类型是可变的，但了解变量在某一时刻是什么数据类型通常是有用的。`typeof`运算符帮助我们做到这一点：
- en: '[PRE3]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that the return values are strings.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意返回值是字符串。
- en: 'When comparing variables, there are two equality operators: loose and strict
    equality. Let''s take a look at some examples:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较变量时，有两种相等运算符：宽松相等和严格相等。让我们看一些例子：
- en: '[PRE4]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we were to run this comparison, we would have the result of `true`. However,
    we can see that `myAge` is a number, while `age` is a string. The reason the result
    is `true` is that when using the loose equality operator (the double-equals),
    JavaScript uses *type coercion* in an attempt to be helpful. When comparing variables
    of different types, the values are loosely compared, so while `38` and `"38"`
    are different types, the result of the comparison is truthy because of their values.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个比较，将得到 `true` 的结果。然而，我们可以看到 `myAge` 是一个数字，而 `age` 是一个字符串。结果为 `true`
    的原因是，当使用宽松相等运算符（双等号）时，JavaScript 使用*类型强制转换*来试图提供帮助。当比较不同类型的变量时，值会被宽松比较，因此虽然 `38`
    和 `"38"` 是不同类型，但由于它们的值，比较的结果是真值。
- en: 'As you can imagine, this can have some unexpected behavior. To ask JavaScript
    to include the type in the comparison, use the *strict equality* operator: the
    triple-equals.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以想象的那样，这可能会产生一些意想不到的行为。要求 JavaScript 在比较中包含类型，使用*严格相等*运算符：三个等号。
- en: With our preceding example, we can try `myAge === age` and will get the result
    of `false` because they are different data types. It's usually considered best
    practice to use strict equality to avoid type coercion unless you have a specific
    need to use loose equality.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的例子，我们可以尝试 `myAge === age`，将得到 `false` 的结果，因为它们是不同的数据类型。通常认为最佳实践是使用严格相等来避免类型强制转换，除非您有特定需要使用宽松相等。
- en: Arrays and objects
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组和对象
- en: 'Arrays and objects are not primitives and can contain mixed types. Here are
    a few examples:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和对象不是原始类型，可以包含混合类型。以下是一些示例：
- en: '[PRE5]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`officers` is an **array**, as we can see with the square brackets. One of
    the interesting facts about arrays is that even though we usually declare them
    as a const, the values *inside* the array can be changed. `.push()` and `.pop()`
    are two useful methods for manipulating arrays:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`officers` 是一个**数组**，我们可以通过方括号看到。关于数组的一个有趣的事实是，即使我们通常将它们声明为常量，数组中的值可以被更改。`.push()`
    和 `.pop()` 是两个用于操作数组的有用方法：'
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that the values in the array are not ordered in any way; we can get
    `Riker` by accessing the array with bracket notation: `officers[0]`. However,
    if we were to try to completely reassign the array, we would still get an error
    when reassigning a declared const. Arrays can hold any combination of data types.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数组中的值没有以任何方式排序；我们可以通过使用方括号表示法来获取 `Riker`。然而，如果我们尝试完全重新分配数组，当重新分配已声明的常量时，我们仍然会得到一个错误。数组可以容纳任何组合的数据类型。
- en: 'One very handy property of arrays that we''ll be using is `.length`. Since
    it''s a property, it does not use parentheses:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的一个非常方便的数组属性是 `.length`。由于它是一个属性，它不使用括号：
- en: '[PRE7]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that even though arrays are zero-indexed, the `length` property is not.
    There *are* four elements in the array, with *indices* from 0 to 3.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使数组是从零开始索引的，`length` 属性却不是。数组中有四个元素，索引从 0 到 3。
- en: We'll discuss methods and properties more throughout this chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中更详细地讨论方法和属性。
- en: '**Objects** are a very strong foundational component of JavaScript. In fact,
    technically (almost) everything in JavaScript *is* an object! Our array methods
    can be accessed via dot notation specifically because an array is technically
    a type of object. We can''t, however, access the *values *of an array with dot
    notation.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象**是 JavaScript 非常强大的基础组件。实际上，从技术上讲，JavaScript 中的几乎所有东西都是对象！我们可以通过点符号访问数组方法，因为数组从技术上讲是一种对象。但是，我们无法通过点符号访问数组的*值*。'
- en: 'If we look at `captain`, we can see three different data types: string, number,
    and array. Objects can have nested objects as well. As part of their function
    as key-value stores, the key should be a string. To access a value, we use dot
    notation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看 `captain`，我们可以看到三种不同的数据类型：字符串、数字和数组。对象也可以有嵌套对象。作为键值存储的一部分，键应该是一个字符串。要访问一个值，我们使用点符号：
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can access parts of an object with dot notation, which is similar to a **dict**
    in Python, but not quite! The nuances will become more clear as we work with objects
    since they are fundamental to what makes JavaScript unique.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用点符号访问对象的部分，这类似于 Python 中的**dict**，但不完全相同！随着我们使用对象，细微差别将变得更加清晰，因为它们是 JavaScript
    独特之处的基础。
- en: Conditionals
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'Let''s take a look at an `if`/`else` statement written in two ways in both
    Python and JavaScript:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 Python 和 JavaScript 中以两种方式编写的 `if`/`else` 语句：
- en: '| **Python** | **JavaScript** |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **Python** | **JavaScript** |'
- en: '|'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE12]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'In both columns, the code is doing the same thing: a simple test to see whether `a`
    is less than `b` and then assigning the smaller value to the `min` variable. The
    first row is a full `if`/`else` statement and the second row uses the ternary
    structure. There are a few grammar rules to note in these examples:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在两列中，代码正在执行相同的操作：简单测试以查看 `a` 是否小于 `b`，然后将较小的值分配给 `min` 变量。第一行是完整的 `if`/`else`
    语句，第二行使用三元结构。这些示例中有一些语法规则需要注意：
- en: '`min` must be declared before use, as a best practice. In strict mode, this
    would actually throw an error.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min` 必须在使用之前声明，作为最佳实践。在严格模式下，这实际上会抛出错误。'
- en: Our `if` clause is encapsulated with parentheses.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 `if` 子句被括号包围。
- en: Our `if`/`else` statements are encapsulated with curly braces.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 `if`/`else` 语句被大括号包围。
- en: The keywords and operators in the ternary are significantly different (and a
    bit more cryptic) than in Python.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三元运算符中的关键字和操作符与 Python 中的显着不同（并且有点更加神秘）。
- en: 'If we wanted to use what we now know about `typeof`, we can use strict equality
    to understand our variables a bit more:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用我们现在了解的 `typeof`，我们可以使用严格相等来更好地理解我们的变量：
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Loops
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'There are four main types of loops in JavaScript: `for`, `while`, `do`/`while`,
    and `for..in`. (There are a couple of other ways to structure a loop, but these
    are the main ones.) Their use cases shouldn''t be much of a surprise.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中有四种主要类型的循环：`for`、`while`、`do`/`while` 和 `for..in`。（还有一些其他的循环结构方式，但这些是主要的。）它们的使用情况应该不会有太多意外。
- en: for loops
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for 循环
- en: 'Use an iterator to execute code a specified number of times:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用迭代器执行指定次数的代码：
- en: '| **Python** | **JavaScript** |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **Python** | **JavaScript** |'
- en: '|'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Now, you may be wondering, "if JavaScript has a `for..in` loop, why aren''t
    we using it?". As it turns out, `for/in` of Python and `for..in` of JavaScript
    are *false cognates*: their names look alike but are very different in use. We''ll
    discuss JavaScript''s `for..in` loop shortly. Also, note how we needed to have
    three clauses in our `for` loop:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想，“如果JavaScript有`for..in`循环，为什么我们不使用它呢？”事实证明，Python的`for/in`和JavaScript的`for..in`是*假朋友*：它们的名字看起来很像，但在使用上却非常不同。我们将很快讨论JavaScript的`for..in`循环。另外，注意我们需要在`for`循环中有三个子句：
- en: '![](assets/a869732b-aee6-483a-80d5-041b081918d6.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a869732b-aee6-483a-80d5-041b081918d6.png)'
- en: Figure 3.1 - Declaration, Condition, and Execution stages of a `for` loop
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - `for`循环的声明、条件和执行阶段
- en: The **declaration** will either define an iterator or use an existing mutable
    variable. Note that it should be a mutable number!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**声明**将定义一个迭代器或使用现有的可变变量。注意它应该是一个可变的数字！'
- en: Our **condition** is what we're testing. We want our loop to run while `i` is
    less than `names.length`. Since `name.length` is `3`, we will run our loop three
    times, or until `i` equals `4`, which no longer meets our condition.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**条件**是我们要测试的内容。我们希望我们的循环在`i`小于`names.length`时运行。由于`name.length`是`3`，我们将运行我们的循环三次，或者直到`i`等于`4`，这不再满足我们的条件。
- en: At the end of every iteration of our loop, we **execute** something; usually
    a simple incrementing of our declaration. Now, notice the semicolons in between
    each of our clauses…unlike in other parts of JavaScript, these are *not* optional.
    There isn't one placed after the execution portion.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的循环的每次迭代结束时，我们都会**执行**一些东西；通常是简单地递增我们的声明。现在注意一下我们的每个子句之间的分号…不像JavaScript的其他部分，这些*不*是可选的。在执行部分之后没有分号。
- en: while loops
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while循环
- en: 'The JavaScript `while` loop is identical in use to its Pythonic equivalent,
    minus a little grammar:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的`while`循环在使用上与Python的等效部分相同，只是语法上有一点不同：
- en: '| **Python** | **JavaScript** |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **Python** | **JavaScript** |'
- en: '|'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: do/while loops
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: do/while循环
- en: 'As the name implies, the `do`/`while` loop executes the `do` code when a given
    condition equals `true`. Take a look at the JavaScript:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，`do`/`while`循环在给定条件等于`true`时执行`do`代码。看一下JavaScript：
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: for..in loops
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for..in循环
- en: Now, I promised to explain why Python's `for..in` is different from JavaScript's
    usage. The difference is that JavaScript's `for..in` is used to iterate over keys
    in an object, whereas Python's `for..in` is used as a loop over a discrete set
    of entities.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我承诺要解释为什么Python的`for..in`与JavaScript的用法不同。不同之处在于JavaScript的`for..in`用于遍历对象中的键，而Python的`for..in`用作离散实体的循环。
- en: 'Let''s look at an example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE19]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What do you think `myString` now equals? Since the purpose of `for..in` in *JavaScript* is
    to go over each *key* in the object, it's `Jean-Luc Picard 62 SP 937-215 NCC 1701-D
    Riker,Data,Worf`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为`myString`现在等于多少？由于*JavaScript*中`for..in`的目的是遍历对象中的每个*键*，它是`Jean-Luc Picard
    62 SP 937-215 NCC 1701-D Riker,Data,Worf`。
- en: for..of loops
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for..of循环
- en: 'There is one more `for` loop: `for..of`, which differs from `for..in`. The `for..of`loop
    iterates through values of any iterable, such as arrays, strings, sets, and similar.
    If we want to iterate over `officers` and log out each name, we can do this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`for`循环：`for..of`，它与`for..in`不同。`for..of`循环遍历任何可迭代的值，比如数组、字符串、集合等。如果我们想遍历`officers`并记录每个名字，我们可以这样做：
- en: '[PRE20]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next up, we'll discuss functions!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论函数！
- en: Functions
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'Ah, functions. We love them because they''re the key to modular, **don''t-repeat-yourself**
    (**DRY**) programs. The use cases in JavaScript and Python are the same: blocks
    of code intended to be called more than once, usually with varying parameters.
    Parameters are the variables that a function will take in order to execute its
    code on a mutable dataset. Arguments are what we pass when we call a function.
    They''re the same thing in essence, but have different words depending on where
    and when they''re used: are they the abstraction, or are they the actual data?
    Let''s take a look at a side-by-side comparison:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，函数。我们喜欢它们，因为它们是模块化、**不重复自己**（**DRY**）程序的关键。JavaScript和Python中的用例是一样的：代码块打算被调用多次，通常是带有不同参数。参数是函数将接受的变量，以便在可变数据集上执行其代码。参数是我们在调用函数时传递的东西。本质上它们是一样的，但根据它们在何时何地使用，有不同的词：它们是抽象，还是实际数据？让我们来看一个并排比较：
- en: '| **Python** | **JavaScript** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **Python** | **JavaScript** |'
- en: '|'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If you haven't already brought up the JavaScript console in your browser, you
    should do that now to see our output of `6`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有在浏览器中打开JavaScript控制台，现在应该打开来看看我们的输出`6`。
- en: 'You can see that the structure is fairly similar, with our parameter being
    passed in parentheses. As noted before, we prefer camel-case in JavaScript and
    encapsulate with curly braces. Calling the function with our argument of `5` is
    the same. For conciseness, we can increment `val` with the `++` operator on the
    left before `return` executes. Such shortcuts are common in JavaScript, but remember
    to use them judiciously: "Write clearly—don''t be too clever."'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到结构相当相似，我们的参数被传递在括号中。如前所述，我们在JavaScript中更喜欢驼峰命名，并用大括号封装。使用参数`5`调用函数是一样的。为了简洁起见，我们可以在`return`执行之前使用`++`运算符在左边递增`val`。这样的快捷方式在JavaScript中很常见，但记住要明智地使用它们：“写得清晰—不要太聪明。”
- en: However, JavaScript actually has two different ways to declare a function, plus
    a newer syntax introduced in ES6.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JavaScript实际上有两种不同的声明函数的方式，还有ES6中引入的新语法。
- en: Function declarations
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数声明
- en: '`addOne()` in the preceding code is an example of a *function declaration*.
    It uses the function keyword to declare our functionality. Its anatomy is just
    as simple as it looks:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`addOne()`是*函数声明*的一个例子。它使用函数关键字来声明我们的功能。它的结构和看起来一样简单：
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Function expressions
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数表达式
- en: 'Here''s an example of `addOne()`, constructed as a function expression:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`addOne()`的一个函数表达式的例子：
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Function expressions should use `const` in the expression, though it is not
    syntactically incorrect to use `var` or `let`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式应该在表达式中使用`const`，尽管使用`var`或`let`在语法上并不是错误的。
- en: What's the difference between declarations and expressions? The core difference
    is that a function *declaration* can be used anywhere in your program because
    it's *hoisted* to the top. As JavaScript is interpreted top-down; this is a major
    exception to that paradigm. So, conversely, using an *expression* must occur after
    the expression is written.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 声明和表达式之间有什么区别？核心区别在于函数*声明*可以在程序中的任何地方使用，因为它被*hoisted*到顶部。由于JavaScript是自上而下解释的；这是对该范例的一个重大例外。因此，相反，使用*表达式*必须在表达式编写后发生。
- en: Arrow functions
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'ES6 introduced the arrow syntax of writing function expressions:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了箭头语法来编写函数表达式：
- en: '[PRE25]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To further complicate matters, we can omit the parentheses around `val` because
    there''s only one parameter:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步复杂化问题，我们可以省略`val`周围的括号，因为只有一个参数：
- en: '[PRE26]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The main difference between arrow functions and expressions is centered around
    *lexical scoping*. We touched on scope with *hoisting*, and we'll discuss it in
    more detail in the next chapter.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数和表达式之间的主要区别集中在*词法作用域*上。我们在*hoisting*中提到了作用域，并且我们将在下一章中更详细地讨论它。
- en: Comments
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'As with any language, comments are important. There are two ways to declare
    comments in JavaScript:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何语言一样，注释都很重要。在JavaScript中有两种声明注释的方法：
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, we can start a comment with `//` and write text until the end of the line.
    We can have a full-line comment with `//` and we can also have a multiline comment
    with `/*`, ending with `*/`. Additionally, you may encounter comments in the JSDoc
    style, used for inline documentation:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以用`//`开始注释，并写到行尾。我们可以用`//`进行全行注释，还可以用`/*`进行多行注释，以`*/`结束。此外，您可能会在JSDoc风格的注释中遇到注释，用于内联文档：
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: More information on JSDoc is included in the *Further reading* section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有关JSDoc的更多信息包含在*进一步阅读*部分中。
- en: Methods and properties
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法和属性
- en: So far, we've seen `.push()` and `.pop()` as methods of array instances. In
    JavaScript, a **method** is simply a function inherent to its data type that operates
    on the data and properties of a variable. I mentioned before that nearly everything
    in JavaScript is an object, and that is not an exaggeration. From functionality
    and syntax to structure and usage, there are many similarities between the raw
    data type of an *object* and any other variable.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到`.push()`和`.pop()`作为数组实例的方法。在JavaScript中，**方法**只是一个固有于其数据类型的函数，它对变量的数据和属性进行操作。我之前提到过，几乎JavaScript中的一切都是对象，这并不夸张。从功能和语法到结构和用法，*对象*的原始数据类型与任何其他变量之间有许多相似之处。
- en: 'The next part of our understanding of the syntax of JavaScript is everyone''s
    favorite: punctuation. While it may seem trivial, it''s very important for the
    interpretation, by both humans and computers, of the code.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对JavaScript语法的理解的下一部分是每个人都喜欢的：标点符号。虽然这可能看起来微不足道，但对于代码的解释，*无论是人还是计算机*，它都非常重要。
- en: Punctuation and readability
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标点符号和可读性
- en: 'As with every language, JavaScript has conventions on punctuation and how spacing
    affects readability. Let''s take a look at a few ideas:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 与每种语言一样，JavaScript对标点符号和空格如何影响可读性有一些约定。让我们看看一些想法：
- en: '**Python**:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**：'
- en: '[PRE29]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Java**:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java**：'
- en: '[PRE30]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**C++**:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C++**：'
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**JavaScript**:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript**：'
- en: '[PRE32]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In JavaScript, the conventions of the preceding example are as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，前面示例的约定如下：
- en: No space between the function name and the parentheses.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名称和括号之间没有空格。
- en: A single space before the curly brace, which is on the same line.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左花括号之前有一个空格，它在同一行上。
- en: The closing curly brace is on its own line, aligned with the opening statement
    of `function`.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右花括号单独一行，与`function`的开头语句对齐。
- en: 'There''s also one more modern point to make here about JavaScript and the examples
    we''ll be using in this book versus what you may encounter in the field and examples
    online: **semicolons**.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，关于JavaScript和我们将在本书中使用的示例与您可能在现场和在线示例中遇到的示例之间还有一个现代观点：**分号**。
- en: With few exceptions, in modern JavaScript, semicolons at the end of statements
    are *optional*. It used to be a best practice to always terminate statement lines
    with semicolons, and you'll see a lot of semicolons in existing code. This is
    a question of style from company to company, project to project, and library to
    library. There are some standards in place, as we'll discuss shortly with linting,
    but for the purposes of this book, we will *not* be using semicolons to terminate
    statements, except in such cases as required by syntax (such as we saw in our
    loops).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代JavaScript中，除了少数例外，语句末尾的分号是*可选的*。过去，始终用分号终止语句行是最佳实践，您会在现有代码中看到很多分号。这是一个从公司到公司、项目到项目和库到库的风格问题。有一些标准，我们将很快在linting中讨论，但在本书的目的上，我们将*不*使用分号来终止语句，除非在语法上需要（例如我们在循环中看到的）。
- en: 'It''s also important to note that nested lines should be indented by two spaces.
    Two versus four is a style question, also, but in this book, we''ll be using **two
    spaces**. One way to help maintain consistency is to configure your code editor
    to translate tabs into two spaces (or four, as desired). That way, you just hit
    *Tab* instead of worrying about how many times you mashed the space bar. I won''t
    expound on the importance of proper indentation, but remember: the more your code
    adheres to styles and best practices, the more legible it will be to those who
    maintain your code—and to your future self!'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，嵌套行应该缩进两个空格。两个空格和四个空格是一个风格问题，但在这本书中，我们将使用**两个空格**。帮助保持一致性的一种方法是配置您的代码编辑器将制表符转换为两个空格（或四个，根据需要）。这样，您只需按一下*Tab*，而不用担心按了空格键多少次。我不会详细阐述正确缩进的重要性，但请记住：您的代码遵循的风格和最佳实践越多，对于维护您的代码的人员以及您未来的自己来说，它就会更易读！
- en: The elephant in the room – whitespace
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大象在房间里——空白
- en: 'OK, OK, we know that Python is whitespace-delimited: tabs matter! However,
    JavaScript really *doesn''t* care about whitespace in most cases. As we saw before,
    indentation and whitespace is a matter of *style*, not *syntax*.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，好的，我们知道Python是基于空格的：制表符很重要！然而，在大多数情况下，JavaScript真的*不在乎*空格。正如我们之前看到的，缩进和空格是*风格*而不是*语法*的问题。
- en: 'So here''s the thing: when I was first learning Python, the idea of a language
    that was whitespace-dependent was abhorrent. "How could a language that could
    break with an improper IDE setting survive?", I thought. My opinions aside, the
    good news is that indentation in Python is parallel to indentation plus curly
    braces in JavaScript.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 所以问题是：当我第一次学习Python时，依赖空格的语言的想法令人憎恶。我想：“一个依赖于不正确的IDE设置就会崩溃的语言怎么能生存？”。撇开我的观点不谈，好消息是Python中的缩进与JavaScript中的缩进加大括号是平行的。
- en: 'Here''s an example:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '| **Python** | **JavaScript** |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **Python** | **JavaScript** |'
- en: '|'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE33]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If you notice, our `if` statement inside our Python function is indented in
    the same way that this JavaScript example is indented, albeit without the curly
    braces. So yay! Your adherence to Pythonic indentation dicta actually comes *quite*
    in handy in JavaScript! While it's not required to include whitespace *à la* Python,
    it does definitely improve legibility.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到，我们Python函数中的`if`语句的缩进方式与此JavaScript示例的缩进方式相同，尽管没有大括号。所以耶！您对Python缩进规则的遵守实际上在JavaScript中*非常*有用！虽然不需要像Python那样包含空格，但它确实可以提高可读性。
- en: At the end of the day, JavaScript likes indentation as much as Python because
    it makes for more readable code, though it's not required for your program to
    run.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 归根结底，JavaScript喜欢缩进就像Python一样，因为这样可以使代码更易读，尽管对于程序运行来说并不是必需的。
- en: Existing standards – linting to the rescue!
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现有标准- linting来拯救！
- en: 'We''ve looked at JavaScript''s conventions and norms, but most rules have a
    caveat that "this could vary" or "this isn''t technically required." So, how do
    we make sense of our code in a malleable, opinion-driven environment? One answer:
    *linting*.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了JavaScript的约定和规范，但大多数规则都有一个“这可能会有所不同”的例外或“这在技术上并不是必需的”。那么，在一个可塑的、以意见为驱动的环境中，我们如何理解我们的代码呢？一个答案：*linting*。
- en: 'Simply put, **linting** refers to the process of running your code through
    predefined rules to ensure that not only is it syntactically correct, but it also
    adheres to proper style rules. This isn''t a practice limited to JavaScript; you
    may have linted your Python code, too. In modern JavaScript, linting has come
    to be seen as a best practice to ensure your code is consistent. Two of the main
    style guides in the community are AirBnB ([https://github.com/airbnb/javascript](https://github.com/airbnb/javascript)) and
    Google ([https://google.github.io/styleguide/jsguide.html](https://google.github.io/styleguide/jsguide.html)).
    Your code editor probably supports using a linter, but we won''t go into using
    them in practice right now, as each editor varies in setup. Here''s a quick look
    at what it can look like in Atom:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**linting**指的是通过预定义的规则运行代码的过程，以确保它不仅在语法上正确，而且还遵循适当的风格规则。这不仅限于JavaScript的实践；您可能也对Python代码进行了linting。在现代JavaScript中，linting已经被视为确保代码一致的最佳实践。社区中的两个主要风格指南是AirBnB
    ([https://github.com/airbnb/javascript](https://github.com/airbnb/javascript))和Google
    ([https://google.github.io/styleguide/jsguide.html](https://google.github.io/styleguide/jsguide.html))。您的代码编辑器可能支持使用linter，但我们现在不会进入实际使用它们的细节，因为每个编辑器的设置都有所不同。以下是在Atom中的快速查看：
- en: '![](assets/7dd21500-86c8-4ab5-84c7-58bf85c03d90.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7dd21500-86c8-4ab5-84c7-58bf85c03d90.png)'
- en: Figure 3.2 - Linting error in Atom
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - Atom中的Linting错误
- en: For our purposes, know that standards do exist, though they may vary from style
    guide to style guide. You can clone a repository demonstrating linting from [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，要知道标准是存在的，尽管它们可能会因风格指南而有所不同。您可以从[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-3/Linting)克隆一个演示linting的存储库。
- en: There are several popular linting tools available, such as ESLint and Prettier.
    The tool you choose can be customized to the style guide you choose to work with.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种流行的linting工具可用，例如ESLint和Prettier。您选择的工具可以根据您选择的风格指南进行自定义。
- en: OK, that's a lot for one chapter! Let's wrap up.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这一章内容太多了！让我们结束吧。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: JavaScript has a rich grammar and syntax, developed over years of use and refinement.
    Using ES6, we have a whole host of data types, methods of declaring functions,
    and code standards. While writing JavaScript can seem to be playing very loose
    and fast, there are best practices, and the fundamentals of the language are as
    robust as other languages. Remember that capitalization counts; don't use reserved
    words for variable names; use `const` or `let` to declare your variables; even
    though JavaScript is loosely typed, data types are important; and conditionals,
    loops, and functions all help structure the logic of your code.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript拥有丰富的语法和语法，经过多年的使用和完善。使用ES6，我们有各种数据类型、声明函数的方法和代码规范。虽然编写JavaScript似乎是非常随意和快速的，但有最佳实践，而且语言的基本原理与其他语言一样强大。请记住，大小写是有影响的；不要将保留字用作变量名；使用`const`或`let`声明变量；尽管JavaScript是弱类型的，但数据类型很重要；条件、循环和函数都有助于构建代码的逻辑结构。
- en: A mastery of the grammar and syntax of JavaScript is vital to understanding
    how to use this robust language, so take your time familiarizing yourself with
    the details and intricacies. Moving forward, we will presume you have fluency
    in JavaScript's style as we get into more difficult material.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 精通JavaScript的语法和语法对于理解如何使用这种强大的语言至关重要，所以花时间熟悉细节和复杂性。在向前迈进时，我们将假设您对JavaScript的风格流利，因为我们将涉及更困难的材料。
- en: In the next chapter, we will get our hands dirty with data and understanding
    how JavaScript works with and models data.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将亲自动手处理数据，并了解JavaScript如何处理和建模数据。
- en: Questions
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try your hand at answering the following questions to test your knowledge:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试回答以下问题来测试你的知识：
- en: Which of the following is not a valid JavaScript variable declaration?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是有效的JavaScript变量声明？
- en: '`var myVar = ''hello'';`'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var myVar = ''hello'';`'
- en: '`const myVar = "hello"`'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`const myVar = "hello"`'
- en: '`String myVar = "hello";`'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`String myVar = "hello";`'
- en: '`let myVar = "hello"`'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`let myVar = "hello"`'
- en: Which of these starts a function declaration?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个开始了函数声明？
- en: '`function`'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`function`'
- en: '`const`'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`const`'
- en: '`func`'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`func`'
- en: '`def`'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`def`'
- en: Which of these is not a basic loop type?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是基本循环类型？
- en: '`for..in`'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for..in`'
- en: '`for`'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for`'
- en: '`while`'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`while`'
- en: '`map`'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`map`'
- en: True or false – JavaScript *requires* line delineation with semicolons.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假 - JavaScript *需要*使用分号进行行分隔。
- en: 'True'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假
- en: True or false – whitespace *never* counts in JavaScript.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假 - 空格在JavaScript中*从不*计数。
- en: 'True'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假
- en: Further reading
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: B. W. Kernighan and P. J. Plauger, *The Elements of Programming Style 2nd Edition*,
    McGraw Hill, New York, 1978\. ISBN 0-07-034207-5
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B. W. Kernighan和P. J. Plauger，*编程风格的要素第二版*，McGraw Hill，纽约，1978年。 ISBN 0-07-034207-5
- en: 'PEP-8 – *A Style Guide for Python Code*: [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP-8 - *Python代码风格指南*：[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)
- en: 'PEP-20 – *The Zen of Python*: [https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP-20 - *Python之禅*：[https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/)
- en: 'JSDoc: [http://usejsdoc.org/](http://usejsdoc.org/)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSDoc：[http://usejsdoc.org/](http://usejsdoc.org/)
