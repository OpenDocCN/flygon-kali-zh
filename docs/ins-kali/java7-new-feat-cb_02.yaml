- en: Chapter 2. Locating Files and Directories Using Paths
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 使用路径定位文件和目录
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Creating a Path object
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Path对象
- en: Interoperability between java.io.File and java.nio.file.Files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.io.File和java.nio.file.Files之间的互操作性
- en: Converting a relative path into an absolute path
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相对路径转换为绝对路径
- en: Removing redundancies by normalizing a path
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过规范化路径来消除冗余
- en: Combining paths using path resolution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路径解析合并路径
- en: Creating a path between two locations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个位置之间创建路径
- en: Converting between path types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同路径类型之间转换
- en: Determining whether two paths are equivalent
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定两个路径是否等价
- en: Managing symbolic links
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理符号链接
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: A filesystem is a way of organizing data on a computer. Normally, it consists
    of one or more top-level directories, each of which contains a hierarchy of files.
    The top-level directory is frequently referred to as the root. In addition, the
    filesystem is stored on a media, which is referred to as the file store.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统是计算机上组织数据的一种方式。通常，它由一个或多个顶级目录组成，每个目录包含一系列文件。顶级目录通常被称为根。此外，文件系统存储在介质上，称为文件存储。
- en: Java 7 introduces a number of new classes and interfaces to make working with
    filesystems easier and more efficient. These have largely supplemented older classes
    found in the `java.io` package.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7引入了许多新的类和接口，使得与文件系统的工作更加简单和高效。这些类在很大程度上取代了`java.io`包中的旧类。
- en: 'In this and subsequent chapters, we will demonstrate how a filesystem can be
    managed using the directory structure, as shown in the following diagram:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和后续章节中，我们将演示如何使用目录结构管理文件系统，如下图所示：
- en: '![Introduction](img/5627_2_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Introduction](img/5627_2_01.jpg)'
- en: The ovals represent a directory/folder, while rectangles represent files. Unix-based
    systems and Windows systems differ in their support of a root node. Unix systems
    support a single root node, while Windows systems permit more than one root node.
    The location of a directory or file is described using a path. The elements, directories
    and files of the path are separated by either a forward or backward slash. In
    Unix, a forward slash is used. In Windows, a backward slash is used.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆代表目录，而矩形代表文件。基于Unix的系统和Windows系统在对根节点的支持上有所不同。Unix系统支持单个根节点，而Windows系统允许多个根节点。目录或文件的位置使用路径来描述。路径的元素、目录和文件之间用正斜杠或反斜杠分隔。在Unix中使用正斜杠，在Windows中使用反斜杠。
- en: The music files were obtained from [http://freepd.com/70s%20Sci%20Fi/](http://freepd.com/70s%20Sci%20Fi/).
    The `status.txt` is intended to hold simple status information, while the `users.txt`
    is assumed to hold a list of users. The `users.txt` file in the music directory
    is a symbolic link to the actual file in the `docs` directory as reflected with
    the red line. These files will be used in various examples throughout this chapter.
    Of course, you can use any file or file structure that you wish.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐文件来自[http://freepd.com/70s%20Sci%20Fi/](http://freepd.com/70s%20Sci%20Fi/)。`status.txt`用于保存简单的状态信息，而`users.txt`则用于保存用户列表。音乐目录中的`users.txt`文件是指向`docs`目录中实际文件的符号链接，如红线所示。这些文件将在本章的各个示例中使用。当然，您可以使用任何您希望的文件或文件结构。
- en: 'Symbolic links are more common in Unix-based platforms. To create a symbolic
    link for the `users.txt` file in the music directory, use the following command
    in the command console: `mklink users.txt c:\home\docs\users.txt`. This requires
    administrator privileges to execute.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接在基于Unix的平台上更常见。要为音乐目录中的`users.txt`文件创建符号链接，请在命令控制台中使用以下命令：`mklink users.txt
    c:\home\docs\users.txt`。这需要管理员权限才能执行。
- en: 'This chapter is concerned with the management of paths as represented by the
    `java.nio.file.Path` class. A `Path` object is used extensively by classes in
    the `java.nio` package and is composed of several parts that are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及由`java.nio.file.Path`类表示的路径的管理。`Path`对象被`java.nio`包中的类广泛使用，由以下几个部分组成：
- en: A root which is the base of the path, such as a C drive
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为路径基础的根目录，比如C盘
- en: A separator used to separate the names that make up directories and files of
    the path
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于分隔路径中组成目录和文件的名称的分隔符
- en: The names of the intermediate directories
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间目录的名称
- en: A terminal element, which can be a file or directory
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端元素，可以是文件或目录
- en: 'These are discussed and illustrated in the *Understanding paths* recipe. The
    following are the classes dealing with files and directories:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容在*理解路径*一节中进行了讨论和说明。以下是处理文件和目录的类：
- en: '`java.nio. file.Paths` contains static methods for the creation of a `Path`
    object'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.nio.file.Paths`包含用于创建`Path`对象的静态方法'
- en: '`java.nio. file.Path` interface contains numerous methods for working with
    paths'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.nio.file.Path`接口包含许多用于处理路径的方法'
- en: '`java.nio. file.FileSystems` is the primary class used to access a filesystem'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.nio.file.FileSystems`是用于访问文件系统的主要类'
- en: '`java.nio. file.FileSystem` represents a filesystem, such as the /on a UNIX
    system or the C drive on a Windows platform'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.nio.file.FileSystem`表示文件系统，比如UNIX系统上的/或Windows平台上的C盘'
- en: '`java.nio. file.FileStore` represents the actual storage device and provides
    device-specific information'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.nio.file.FileStore`表示实际存储设备并提供设备特定信息'
- en: '`java.nio. file.attribute.FileStoreAttributeView` provides access to file information'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.nio.file.attribute.FileStoreAttributeView`提供对文件信息的访问'
- en: The last two classes are discussed in more depth in later chapters. To gain
    access to a file or directory, we will typically use the `FileSystems` class'
    `getDefault` method to retrieve a reference to the filesystem accessible by the
    JVM. To get access to a specific drive, we can use the `getFileSystem` method
    with a **Uniform Resource Identifier** (**URI**) object representing the drive
    or directory of interest.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个类在后续章节中会更深入地讨论。为了访问文件或目录，我们通常会使用`FileSystems`类的`getDefault`方法来检索JVM可访问的文件系统的引用。要访问特定驱动器，我们可以使用`getFileSystem`方法，传入表示感兴趣的驱动器或目录的**统一资源标识符**（**URI**）对象。
- en: 'The `FileSystems` class provides techniques to create or access a filesystem.
    In this chapter, we are interested in how the class supports the creation of `Path`
    objects. Once we have reference to a file system object, we can obtain a `Path`
    object using any one of several methods:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileSystems`类提供了创建或访问文件系统的技术。在本章中，我们对类如何支持创建`Path`对象感兴趣。一旦我们有了文件系统对象的引用，我们就可以使用几种方法之一获取`Path`对象：'
- en: '`getPath:` This uses a system-dependent path to obtain a `Path` object. The
    `Path` object is used to locate and access the file.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPath：`这使用系统相关路径来获取`Path`对象。`Path`对象用于定位和访问文件。'
- en: '`getPathMatcher:` This creates a `PathMatcher`. It performs various matching
    type operations on a file and is covered in the *Getting filesystem information*
    recipe in [Chapter 5.](ch05.html "Chapter 5. Managing Filesystems")'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPathMatcher：`这将创建一个`PathMatcher`。它执行文件的各种匹配类型操作，并在[第5章](ch05.html "第5章
    管理文件系统")的“获取文件系统信息”配方中进行了讨论。'
- en: '`getRootDirectories:` This is used to obtain a list of root directories. This
    method is illustrated in the *Getting filesystem information* recipe in [Chapter
    5.](ch05.html "Chapter 5. Managing Filesystems")'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRootDirectories：`用于获取根目录列表。这个方法在[第5章](ch05.html "第5章 管理文件系统")的“获取文件系统信息”配方中进行了说明。'
- en: The creation and general use of `Path` objects is introduced in the *Understanding
    paths* recipe. This knowledge is used in subsequent recipes and other chapters,
    so be sure to understand the basic processes covered in this recipe.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*理解路径*配方介绍了`Path`对象的创建和一般用法。这些知识在后续配方和其他章节中使用，因此请确保理解本配方中涵盖的基本过程。'
- en: You can still use the older `java.io` package elements. A path representing
    a `java.io.File` object can be created using the `File` class's `toPath` method.
    This is discussed in the *Interoperability between java.io.File and java.nio.file.Files*
    recipe and can be useful when maintaining older code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以使用较旧的`java.io`包元素。可以使用`File`类的`toPath`方法创建表示`java.io.File`对象的路径。这在*java.io.File和java.nio.file.Files之间的互操作性*配方中进行了讨论，并且在维护较旧的代码时可能会有用。
- en: Paths can be either relative or absolute. These types of paths and techniques
    for dealing with them are discussed in the *Working with relative and absolute
    paths* recipe.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 路径可以是相对的，也可以是绝对的。这些类型的路径以及处理它们的技术在“使用相对和绝对路径”配方中进行了讨论。
- en: Paths can contain redundancies and extraneous elements. Removal of these elements
    is called **normalization.** The *Removing redundancies in a path by normalizing
    the path* recipe examines the techniques available to simplify these types of
    paths.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 路径可能包含冗余和多余的元素。去除这些元素称为**规范化**。通过“通过规范化路径来删除路径中的冗余”配方，我们可以检查简化这些类型路径的可用技术。
- en: Paths can be combined to form a new composite path. This is known as resolving
    a path and is addressed in the *Combining paths using path resolution* recipe.
    This technique can be useful for creating new paths, where parts of the path are
    available from different sources.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 路径可以组合成一个新的复合路径。这称为解析路径，并在*使用路径解析合并路径*配方中进行了讨论。这种技术可以用于创建新的路径，其中路径的部分来自不同的来源。
- en: When a reference is needed for a file, that path is sometimes relative to the
    current location or some other location. The *Creating a path between two locations*
    recipe illustrates the creation of such a path. The process is called **relativizing.**
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要文件的引用时，该路径有时相对于当前位置或其他位置。*在两个位置之间创建路径*配方说明了创建这样一个路径的过程。这个过程称为**相对化**。
- en: Not only are there relative and absolute paths, but there are also other ways
    of representing a path such as with a `java.net.URI` object. When a `Path` object
    is created, it is not necessary that the actual path exists. For example, the
    `Path` may be created to create a new filesystem element. The *Converting between
    path types* recipe looks at methods used to convert between these different types
    of paths.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅有相对和绝对路径，还有其他表示路径的方式，例如使用`java.net.URI`对象。创建`Path`对象时，并不一定需要实际路径存在。例如，可以创建`Path`以创建新的文件系统元素。*在不同路径类型之间转换*配方介绍了用于在这些不同类型路径之间转换的方法。
- en: Paths are system-dependent. That is, a path on one system such as UNIX is different
    from one found on a Windows system. Comparing two paths found on the same platform
    may or may not be the same. This is examined in the *Determining whether two paths
    are equivalent* recipe.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是依赖于系统的。也就是说，UNIX系统上的路径与Windows系统上找到的路径不同。比较在同一平台上找到的两个路径可能相同，也可能不同。这在*确定两个路径是否等效*配方中进行了研究。
- en: Creating a Path object
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Path对象
- en: A path to a directory or file is needed to identify that resource. The focus
    of this recipe is on how to obtain a `Path` object for typical file and directory
    operations. Paths are used for most of the recipes in this and many of the subsequent
    chapters that deal with files and directories.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 需要路径来标识目录或文件。本配方的重点是如何为典型的文件和目录操作获取`Path`对象。路径在本章和许多后续章节中用于大多数配方，这些配方涉及文件和目录。
- en: There are several methods that create or return a `Path` object. Here, we will
    examine those methods used to create a `Path` object and how to use its methods
    to further our understanding of the path concept as used in Java.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以创建或返回`Path`对象。在这里，我们将研究用于创建`Path`对象的方法以及如何使用其方法来进一步了解Java中使用的路径概念。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to create a `Path` object, we need to use either one of the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建`Path`对象，我们需要使用以下方法之一：
- en: The `FileSystem` class' `getPath` method
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileSystem`类的`getPath`方法'
- en: The `Paths` class' `get` method
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Paths`类的`get`方法'
- en: We will use the `getPath` method first. The `get` method is explained in the
    *There's more* section of this recipe.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用`getPath`方法。`get`方法在本配方的*更多*部分中进行了解释。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a console application with a `main` method. In the `main` method, add
    the following code sequence that creates a `Path` object for the file `status.txt`.
    We will use several `Path` class'' methods to examine the path created as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有“main”方法的控制台应用程序。在“main”方法中，添加以下代码序列，为文件“status.txt”创建一个“Path”对象。我们将使用几种“Path”类的方法来检查创建的路径，如下所示：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice the use of the forward slashes in the `path` string. This approach will
    work on any platform. However, on Windows you can also use back slashes shown
    as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意在“path”字符串中使用正斜杠。这种方法在任何平台上都可以工作。但是，在Windows上，您还可以使用如下所示的反斜杠：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While either approach will work for a Windows platform, the use of forward slashes
    is more portable.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows平台上，任何一种方法都可以工作，但使用正斜杠更具可移植性。
- en: 'Execute the program. Your output should appear as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行程序。您的输出应该如下所示：
- en: '**toString: \home\docs\status.txt**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'toString: \home\docs\status.txt'
- en: '**getFileName: status.txt**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'getFileName: status.txt'
- en: '**getRoot: \**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'getRoot: \'
- en: '**getNameCount: 3**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'getNameCount: 3'
- en: '**getName(0): home**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'getName(0): home'
- en: '**getName(1): docs**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'getName(1): docs'
- en: '**getName(2): status.txt**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'getName(2): status.txt'
- en: '**subpath(0,2): home\docs**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'subpath(0,2): home\docs'
- en: '**getParent: \home\docs**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'getParent: \home\docs'
- en: '**false**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'false'
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Path` object was created using invocation chaining, starting with the `FileSystems`
    class' `getDefault` method. This returns a `FileSystem` object representing the
    filesystem available to the JVM. The `FileSystem` object normally refers to the
    working directory of the current user. Next, the `getPath` method was executed
    using a string representing the file of interest.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调用链接创建了“Path”对象，从“FileSystems”类的“getDefault”方法开始。这返回一个表示JVM可用文件系统的“FileSystem”对象。“FileSystem”对象通常指的是当前用户的工作目录。接下来，使用表示感兴趣文件的字符串执行了“getPath”方法。
- en: The rest of the code used various methods to display information about the path.
    As detailed in the introduction of this chapter, we can display information about
    the parts of the path using methods of the `Path` class. The `toString` method
    is executed against the path to illustrate what you get by default.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分使用了各种方法来显示有关路径的信息。正如本章介绍中所详细介绍的那样，我们可以使用“Path”类的方法来显示有关路径部分的信息。“toString”方法针对路径执行，以说明默认情况下会得到什么。
- en: The `getFileName` returned the file name of the `Path` object, and the `getRoot`
    returned the root. The `getNameCount` method returned the number of intermediate
    directories plus one for the filename. The for loop listed the elements of the
    path. In this case, there were two directories and one file giving a count of
    three. The three elements make up the path.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: “getFileName”返回了“Path”对象的文件名，“getRoot”返回了根目录。“getNameCount”方法返回了中间目录的数量加上一个文件名。for循环列出了路径的元素。在这种情况下，有两个目录和一个文件，总共三个。这三个元素组成了路径。
- en: 'While a simple for loop was used to display these names, we could have also
    used the `iterator` method to list these names, as shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用简单的for循环来显示这些名称，但我们也可以使用“iterator”方法来列出这些名称，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Path` object may consist of other paths. Subpaths can be retrieved using
    the `subpath` method. The method possesses two arguments. The first represents
    an initial index and the second argument specifies the last index exclusively.
    In this example, the first argument was set to 0 indicating that the root level
    directory was to be retrieved. The last index was set to 2, which means only the
    top two directories were listed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: “Path”对象可能包括其他路径。可以使用“subpath”方法检索子路径。该方法具有两个参数。第一个表示初始索引，第二个参数指定排他性的最后索引。在此示例中，第一个参数设置为0，表示要检索根级目录。最后一个索引设置为2，这意味着只列出了顶部两个目录。
- en: The `getParent` method in this case also returned the identical path. However,
    notice that it began with the backslash. This represents the path from the top
    level element following each element except the last one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，“getParent”方法也返回相同的路径。但是，请注意它以反斜杠开头。这表示从每个元素的顶级元素开始，但最后一个元素除外的路径。
- en: There's more...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are several issues that bear further consideration:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个问题需要进一步考虑：
- en: Using the `Paths` class' `get` method
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“Paths”类的“get”方法
- en: The meaning of the parent path
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父路径的含义
- en: Using the Paths class' get method
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Paths类的get方法
- en: 'The `Paths` class'' `get` method can also be used to create a `Path` object.
    This method uses a variable number of `String` arguments to construct a path.
    In the following code sequence, a `path` is created starting at the root of the
    current filesystem:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: “Paths”类的“get”方法也可以用于创建“Path”对象。此方法使用可变数量的“String”参数来构造路径。在以下代码序列中，创建了一个从当前文件系统的根目录开始的“path”：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The output using the `toAbsolutePath` method shows the path constructed. Notice
    the **E** element. The code was executed on a Windows system where the current
    drive was the **E** drive. The `toAbsolutePath` method is discussed in the *Working
    with relative and absolute paths* recipe.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“toAbsolutePath”方法的输出显示了构建的路径。注意“E”元素。代码在Windows系统上执行，当前驱动器为“E”驱动器。“toAbsolutePath”方法在“使用相对路径和绝对路径”配方中进行了讨论。
- en: '**Absolute path: E:\home\docs\users.txt**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '绝对路径: E:\home\docs\users.txt'
- en: 'If we do not use the forward slash in the path''s `String`, then the path is
    created based on the current working directory. Remove the forward slash and execute
    the program. Your output should be similar to the following where, **currentDirectory**,
    is replaced with the one in use when the code is executed:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在路径的“String”中不使用斜杠，那么路径是基于当前工作目录创建的。删除斜杠并执行程序。您的输出应该类似于以下内容，其中“currentDirectory”被执行代码时使用的内容替换：
- en: '**Absolute path: currentDirectory\home\docs\users.txt**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '绝对路径: currentDirectory\home\docs\users.txt'
- en: A more flexible approach is to use the resolve method as discussed in the *Combining
    paths using path resolution* recipe.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“resolve”方法是一种更灵活的方法，如“使用路径解析合并路径”配方中所讨论的。
- en: 'The conversion of the input arguments to a path is system-dependent. If the
    characters used in the creation of the path are invalid for the filesystem, then
    a `java.nio.file.InvalidPathException` is thrown. For example, in most filesystems
    a null value is an illegal character. To illustrate this, add a back slash 0 to
    the `path` string as shown in the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入参数转换为路径是依赖于系统的。如果用于创建路径的字符对于文件系统无效，则会抛出`java.nio.file.InvalidPathException`。例如，在大多数文件系统中，空值是一个非法字符。为了说明这一点，将反斜杠0添加到`path`字符串中，如下所示：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When executed, the output in part will appear as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，部分输出将如下所示：
- en: '**Bad path: [/home \docs\users.txt] at position 5**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误路径：[/home \docs\users.txt] 位置在第5位**'
- en: The `InvalidPathException` class' `getInput` method returns the concatenated
    string used for creating the path. The `getIndex` method returns the position
    of the offending character, which in this case is the null character.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvalidPathException`类的`getInput`方法返回用于创建路径的连接字符串。`getIndex`方法返回有问题的字符的位置，在本例中是空字符。'
- en: The meaning of the parent path
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 父路径的含义
- en: The `getParent` method returns the parent path. However, the method does not
    access the filesystem. This means that for a given `Path` object, there may or
    may not be a parent.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`getParent`方法返回父路径。但是，该方法不访问文件系统。这意味着对于给定的`Path`对象，可能有也可能没有父级。'
- en: 'Consider the following path declaration:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下路径声明：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This refers to the `users.txt` file found in the current working directory.
    The `getNameCount` will return 1, and the `getParent` method will return null.
    In reality, the file exists in a directory structure and has a root and a parent.
    Thus, the results of this method may not be useful in some contexts.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在当前工作目录中找到的`users.txt`文件。`getNameCount`将返回1，`getParent`方法将返回null。实际上，文件存在于目录结构中，并且有一个根和一个父级。因此，该方法的结果在某些情境下可能无用。
- en: 'The use of this method is roughly equivalent to the following use of the `subpath`
    method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法大致相当于使用`subpath`方法：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The `toRealPath` method is discussed in the *Working with relative and absolute
    paths* recipe and in the *Removing redundancies in a path by normalizing the path*
    recipe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`toRealPath`方法在*使用相对路径和绝对路径*和*通过规范化路径来消除冗余*中有讨论。'
- en: Interoperability between java.io.File and java.nio.file.Files
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: java.io.File和java.nio.file.Files之间的互操作性
- en: Prior to the introduction of the `java.nio` package the classes and interfaces
    of the `java.io` package were the only ones available to Java developers for working
    with files and directories. While most of the capability of the `java.io` package
    has been supplemented by the newer packages, it is still possible to work with
    the older classes, in particular the `java.io.File` class. This recipe discusses
    how this can be accomplished.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入`java.nio`包之前，`java.io`包的类和接口是Java开发人员用于处理文件和目录的唯一可用选项。虽然较新的包已经补充了`java.io`包的大部分功能，但仍然可以使用旧类，特别是`java.io.File`类。本文介绍了如何实现这一点。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To obtain a `Path` object using a `File` class, the following steps need to
    be followed:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`File`类获取`Path`对象，需要按照以下步骤进行：
- en: Create a `java.io.File` object representing the file of interest
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示感兴趣文件的`java.io.File`对象
- en: Apply the `toPath` method to it to obtain a `Path` object
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用`toPath`方法以获得`Path`对象
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a console application. Add the following main method where we create
    a `File` object and a `Path` object representing the same file. Next, we compare
    the two objects to determine whether they represent the same file or not:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个控制台应用程序。添加以下主要方法，我们在其中创建一个`File`对象和一个表示相同文件的`Path`对象。接下来，我们比较这两个对象，以确定它们是否表示相同的文件：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When you execute the application, the output will be true.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行应用程序时，输出将为true。
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Two `Path` objects were created. The first `Path` object was declared using
    the Paths class' `get` method. It created a `Path` object to the `users.txt` file
    using a `java.net.URI` object. The second `Path` object, `toPath`, was created
    from a `File` object using the `toPath` method. The Path's `equals` method was
    used to demonstrate that the paths are equivalent.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了两个`Path`对象。第一个`Path`对象是使用`Paths`类的`get`方法声明的。它使用`java.net.URI`对象为`users.txt`文件创建了一个`Path`对象。第二个`Path`对象`toPath`是从`File`对象使用`toPath`方法创建的。使用`Path`的`equals`方法来证明这些路径是等价的。
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Notice the use of the forward and backward slashes for the strings used to represent
    the file. The `URI` string uses forward slashes, which is operating system-independent.
    Whereas, the back slash is used for a Windows path.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用正斜杠和反斜杠表示文件的字符串。`URI`字符串使用正斜杠，这是与操作系统无关的。而反斜杠用于Windows路径。
- en: See also
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The creation of a `Path` object is illustrated in the *Understanding paths*
    recipe. Also, the creation of a `URI` object is discussed in the *Working with
    relative and absolute paths* recipe.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*理解路径*中演示了创建`Path`对象。此外，*使用相对路径和绝对路径*中讨论了创建`URI`对象。'
- en: Converting a relative path into an absolute path
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将相对路径转换为绝对路径
- en: A path can be expressed either as an absolute path or a relative path. Both
    are common and are useful in different situations. The `Path` class and related
    classes support the creation of both absolute and relative paths.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 路径可以表示为绝对路径或相对路径。两者都很常见，在不同情况下都很有用。`Path`类和相关类支持创建绝对路径和相对路径。
- en: A relative path is useful for specifying the location of a file or directory
    in relationship to the current directory location. Typically, a single dot or
    two dots are used to indicate the current directory or next higher level directory
    respectively. However, the use of a dot is not required when creating a relative
    path.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 相对路径用于指定文件或目录的位置与当前目录位置的关系。通常，使用一个点或两个点来表示当前目录或下一个更高级目录。但是，在创建相对路径时，不需要使用点。
- en: An absolute path starts at the root level and lists each directory separated
    by either forward slashes or backward slashes, depending on the operating system,
    until the desired directory or file is reached.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对路径从根级别开始，列出每个目录，用正斜杠或反斜杠分隔，取决于操作系统，直到达到所需的目录或文件。
- en: In this recipe, we will determine the path separator used for the current system
    and learn how to convert a relative path to an absolute path. This is useful when
    handling user input for filenames. Related to absolute and relative paths is the
    URI representation of a path. We will learn how to use the `Path` class' `toUri`
    method to return this representation for a given path.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将确定当前系统使用的路径分隔符，并学习如何将相对路径转换为绝对路径。在处理文件名的用户输入时，这是有用的。与绝对和相对路径相关的是路径的URI表示。我们将学习如何使用`Path`类的`toUri`方法来返回给定路径的这种表示。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The following methods are frequently used when dealing with absolute and relative
    paths:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理绝对和相对路径时，经常使用以下方法：
- en: The `getSeparator` method determines the file separator
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSeparator`方法确定文件分隔符'
- en: The `subpath` method obtains a part or all parts/elements of a path
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subpath`方法获取路径的一个部分或所有部分/元素'
- en: The `toAbsolutePath` method obtains the absolute path for a relative path
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toAbsolutePath`方法获取相对路径的绝对路径'
- en: The `toUri` method obtains the URI representation of a path
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toUri`方法获取路径的URI表示'
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will address each of the previous methods one at a time. Start by creating
    a console application using the following `main` method:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将逐个解决前面的每个方法。首先，使用以下`main`方法创建一个控制台应用程序：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Execute the program. On a Windows platform, the output should appear as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行程序。在Windows平台上，输出应如下所示：
- en: '**The separator is \**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**分隔符是\**'
- en: '**subpath: home\docs\users.txt**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**子路径：home\docs\users.txt**'
- en: '**Absolute path: E:\home\docs\users.txt**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对路径：E:\home\docs\users.txt**'
- en: '**URI: file:///E:/home/docs/users.txt**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**URI：file:///E:/home/docs/users.txt**'
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `getDefault` method returned a `FileSystem` object representing the filesystem
    currently accessible to the JVM. The `getSeparator` method is executed against
    this object, returning a backslash character indicating that the code was executed
    on a Windows machine.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDefault`方法返回一个表示JVM当前可访问的文件系统的`FileSystem`对象。对此对象执行`getSeparator`方法，返回一个反斜杠字符，表示代码在Windows机器上执行。'
- en: A `Path` object was created for the `users.txt` file and the `subpath` method
    was executed against it. This method is discussed in more detail in the *Understanding
    paths* recipe. The `subpath` method always returns a relative path.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为`users.txt`文件创建了一个`Path`对象，并对其执行了`subpath`方法。这个方法在*理解路径*中有更详细的讨论。`subpath`方法总是返回一个相对路径。
- en: Next, a path was created using the `get` method. Since the forward slash was
    used with the first argument, the path started at the root of the current filesystem.
    In this example, the path provided is relative.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`get`方法创建了一个路径。由于第一个参数使用了正斜杠，路径从当前文件系统的根开始。在这个例子中，提供的路径是相对的。
- en: The URI representation of a path is related to absolute and relative paths.
    The `Path` class' `toUri` method returns this representation for a given path.
    A `URI` object is used to represent a resource on the Internet. In this case,
    it returned a string in the form of a URI scheme for files.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 路径的URI表示与绝对和相对路径相关。`Path`类的`toUri`方法返回给定路径的这种表示。`URI`对象用于表示互联网上的资源。在这种情况下，它返回了一个文件的URI方案形式的字符串。
- en: The absolute path can be obtained using the `Path` class' `toAbsolutePath` method.
    An absolute path contains the root element and all of the intermediate elements
    for the path. This can be useful when users are requested to enter the name of
    a file. For example, if the user is asked to supply a filename to save results,
    the filename can be added to an existing path representing a working directory.
    The absolute path can then be obtained and used as necessary.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对路径可以使用`Path`类的`toAbsolutePath`方法获得。绝对路径包含路径的根元素和所有中间元素。当用户被要求输入文件名时，这可能很有用。例如，如果用户被要求提供一个文件名来保存结果，文件名可以添加到表示工作目录的现有路径中。然后可以获取绝对路径并根据需要使用。
- en: There's more...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Bear in mind that the `toAbsolutePath` method works regardless of whether the
    path references a valid file or directory. The file used in the previous example
    does not need to exist. Consider the use of a bogus file as shown in the following
    code. The assumption is that the file, `bogusfile.txt`, does not exist in the
    specified directory:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`toAbsolutePath`方法无论路径引用有效文件还是目录都可以工作。前面示例中使用的文件不需要存在。考虑使用如下代码中所示的虚假文件。假设文件`bogusfile.txt`不存在于指定目录中：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the program is executed, the output will appear as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 程序执行时，输出如下：
- en: '**The separator is \**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**分隔符是\**'
- en: '**File exists: false**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件存在：false**'
- en: '**subpath: home\docs\bogusfile.txt**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**子路径：home\docs\bogusfile.txt**'
- en: '**File exists: false**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件存在：false**'
- en: '**Absolute path: E:\home\docs\bogusfile.txt**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对路径：E:\home\docs\bogusfile.txt**'
- en: '**URI: file:///E:/home/docs/bogusfile.txt**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**URI：file:///E:/home/docs/bogusfile.txt**'
- en: If we want to know whether this is a real path or not, we can use the `toRealPath`
    method as discussed in the *Removing redundancies in a path by normalizing the
    path* recipe.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想知道这是否是一个真实的路径，我们可以使用`toRealPath`方法，如*通过规范化路径来删除路径中的冗余*中所讨论的那样。
- en: See also
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Redundancies in a path can be removed using the `normalize` method as discussed
    in the *Removing redundancies in a path by normalizing the path* recipe.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`normalize`方法删除路径中的冗余，如*通过规范化路径来删除路径中的冗余*中所讨论的那样。
- en: When symbolic links are used for files, then the path may not be the real path
    for the file. The `Path` class' `toRealPath` method will return the real absolute
    path for the file. This is demonstrated in the *Removing redundancies in a path
    by normalizing the path* recipe.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当符号链接用于文件时，路径可能不是文件的真实路径。`Path`类的`toRealPath`方法将返回文件的真实绝对路径。这在*通过规范化路径来消除冗余*示例中进行了演示。
- en: Removing redundancies by normalizing a path
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过规范化路径消除冗余
- en: When the "." or ".." notation is used in defining a path, their use may introduce
    redundancies. That is, the path described may be simplified by removing or otherwise
    altering the path. This recipe discusses the use of the `normalize` method to
    affect this type of conversion. By simplifying a path, it avoids errors and can
    improve the performance of the application. The `toRealPath` method also performs
    normalization and is explained in the *There's more ..*. section of this recipe.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当在定义路径时使用“.”或“..”符号时，它们的使用可能会引入冗余。也就是说，所描述的路径可能通过删除或以其他方式更改路径来简化。本示例讨论了使用`normalize`方法来影响这种转换。通过简化路径，可以避免错误并提高应用程序的性能。`toRealPath`方法还执行规范化，并在本示例的*还有更多...*部分进行了解释。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The basic steps used for removing redundancies in a path include the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 消除路径中冗余的基本步骤包括以下内容：
- en: Identifying paths that may contain redundancies
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别可能包含冗余的路径
- en: Using the `normalize` method to remove the redundancies
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`normalize`方法消除冗余
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The directory structure from the introduction is duplicated here for convenience:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍中的目录结构在此处复制以方便起见：
- en: '![How to do it...](img/5627_2_01.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5627_2_01.jpg)'
- en: 'First consider the following paths:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑以下路径：
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These contain redundancies or extraneous parts. In the first example, the path
    starts at `home` and then goes down a directory level to `docs` directory. The
    `.`. notation then leads back up to the `home` directory. This then proceeds down
    the `music` directory and to the `mp3` file. The `docs/.`. element is extraneous.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包含冗余或多余的部分。在第一个示例中，路径从`home`开始，然后进入`docs`目录的一个目录级别。然后，`.`符号将路径返回到`home`目录。然后继续进入`music`目录并到`mp3`文件。`docs/.`元素是多余的。
- en: In the second example, the path starts at `home` and then encounters a single
    period. This represents the current directory, that is, the `home` directory.
    Next, the path goes down the `music` directory and then encounters the `mp3` file.
    The `/`. is redundant and is not needed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，路径从`home`开始，然后遇到一个句点。这代表当前目录，即`home`目录。接下来，路径进入`music`目录，然后遇到`mp3`文件。`/`是多余的，不需要。
- en: 'Create a new console application and add the following `main` method:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序，并添加以下`main`方法：
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Execute the application. You should get the following output, though the root
    directory may differ depending on the configuration of your system:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您应该获得以下输出，尽管根目录可能会根据系统配置而有所不同：
- en: '**Absolute path: E:\home\docs\..\music\Space Machine A.mp3**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对路径：E:\home\docs\..\music\Space Machine A.mp3**'
- en: '**URI: file:///E:/home/docs/../music/Space%20Machine%20A.mp3**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**URI：file:///E:/home/docs/../music/Space%20Machine%20A.mp3**'
- en: '**Normalized Path: \home\music\Space Machine A.mp3**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**规范化路径：\home\music\Space Machine A.mp3**'
- en: '**Normalized URI: file:///E:/home/music/Space%20Machine%20A.mp3**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**规范化的URI：file:///E:/home/music/Space%20Machine%20A.mp3**'
- en: '**Absolute path: E:\home\.\music\ Robot Brain A.mp3**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对路径：E:\home\.\music\ Robot Brain A.mp3**'
- en: '**URI: file:///E:/home/./music/%20Robot%20Brain%20A.mp3**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: URI：file:///E:/home/./music/%20Robot%20Brain%20A.mp3
- en: '**Normalized Path: \home\music\ Robot Brain A.mp3**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**规范化路径：\home\music\ Robot Brain A.mp3**'
- en: '**Normalized URI: file:///E:/home/music/%20Robot%20Brain%20A.mp3**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**规范化的URI：file:///E:/home/music/%20Robot%20Brain%20A.mp3**'
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`Paths` class'' `get` method was used to create two paths using the redundant
    extraneous paths discussed previously. The code that follows the `get` methods
    displayed the absolute path and the URI equivalent to illustrate the actual path
    created. Next, the `normalize` method was used and was then chained with the `toUri`
    method to further illustrate the normalization process. Notice that the redundancy
    and extraneous path elements are gone. The `toAbsolutePath` and `toUri` methods
    are discussed in the *Working with relative and absolute paths* recipe.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Paths`类的`get`方法使用先前讨论过的冗余多余路径创建了两个路径。`get`方法后面的代码显示了绝对路径和URI等效项，以说明创建的实际路径。接下来，使用了`normalize`方法，然后与`toUri`方法链接，以进一步说明规范化过程。请注意，冗余和多余的路径元素已经消失。`toAbsolutePath`和`toUri`方法在*使用相对和绝对路径*示例中进行了讨论。
- en: The `normalize` method does not check to see if the files or path are valid.
    The method simply performs a syntactic operation against the path. If a symbolic
    link was part of the original path, then the normalized path may no longer be
    valid. Symbolic links are discussed in the *Managing symbolic links* recipe.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`normalize`方法不会检查文件或路径是否有效。该方法只是针对路径执行语法操作。如果符号链接是原始路径的一部分，则规范化路径可能不再有效。符号链接在*管理符号链接*示例中讨论。'
- en: There's more...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Path` class' `toRealPath` will return a path representing the actual path
    to the file. It does check to see if the path is valid and will return a `java.nio.file.NoSuchFileException`
    if the file does not exist.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`类的`toRealPath`将返回表示文件实际路径的路径。它会检查路径是否有效，如果文件不存在，则会返回`java.nio.file.NoSuchFileException`。'
- en: 'Modify the previous example to use the `toRealPath` method with a non-existent
    file as shown in the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 修改先前的示例，使用`toRealPath`方法并显示不存在的文件，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Execute the application. The result should contain the following output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 执行应用程序。结果应包含以下输出：
- en: '**Absolute path: \\Richard-pc\e\home\docs\..\music\NonExistentFile.mp3**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对路径：\\Richard-pc\e\home\docs\..\music\NonExistentFile.mp3**'
- en: '**The file does not exist!**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件不存在！**'
- en: The `toRealPath` method normalizes the path. It also resolves any symbolic links,
    though there were none in this example.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`toRealPath`方法规范化路径。它还解析任何符号链接，尽管在此示例中没有符号链接。'
- en: See also
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The creation of a `Path` object is discussed in the *Understanding paths* recipe.
    Symbolic links are discussed in the *Managing symbolic links* recipe.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`对象的创建在*理解路径*配方中有所讨论。符号链接在*管理符号链接*配方中有所讨论。'
- en: Combining paths using path resolution
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路径解析来组合路径
- en: The `resolve` method is used to combine two paths, where one contains a root
    element and the other is a partial path. This is useful when creating paths that
    can vary, such as those used in the installation of an application. For example,
    there may be a default directory where an application is installed. However, the
    user may be able to select a different directory or drive. Using the `resolve`
    method to create a path allows the application to be configured independent of
    the actual installation directory.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve`方法用于组合两个路径，其中一个包含根元素，另一个是部分路径。这在创建可能变化的路径时非常有用，例如在应用程序的安装中使用的路径。例如，可能有一个默认目录用于安装应用程序。但是，用户可能能够选择不同的目录或驱动器。使用`resolve`方法创建路径允许应用程序独立于实际安装目录进行配置。'
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The use of the `resolve` method involves two basic steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`resolve`方法涉及两个基本步骤：
- en: Create a `Path` object that uses a root element
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个使用根元素的`Path`对象
- en: Execute the `resolve` method against this path with a second partial path
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对此路径执行`resolve`方法，使用第二个部分路径
- en: A partial path is one where only a part of the full path is provided and does
    not contain a root element.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 部分路径是指仅提供完整路径的一部分，并且不包含根元素。
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new application. Add the following `main` method to it:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的应用程序。将以下`main`方法添加到其中：
- en: '[PRE13]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Execute the code. You should get the following output:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码。您应该得到以下输出：
- en: '**rootPath: \home\docs**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**rootPath: \home\docs**'
- en: '**partialPath: users.txt**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**partialPath: users.txt**'
- en: '**resolvedPath: \home\docs\users.txt**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**resolvedPath: \home\docs\users.txt**'
- en: '**Resolved absolute path: E:\home\docs\users.txt**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**解析的绝对路径：E:\home\docs\users.txt**'
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The following three paths were created:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三条路径已创建：
- en: '`\home\docs:` This is the root path'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\home\docs：`这是根路径'
- en: '`users.txt:` This is the partial path'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users.txt：`这是部分路径'
- en: '`\home\docs\users.txt:` This is the resulting resolved path'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\home\docs\users.txt：`这是生成的解析路径'
- en: The resolved path was created by using the `partialPath` variable as an argument
    to the `resolve` method executed against the `rootPath` variable. These paths
    along with the absolute path of the `resolvedPath` were then displayed. The absolute
    path included the root directory, though this may differ on your system.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`partialPath`变量作为`resolve`方法的参数执行对`rootPath`变量的操作来创建解析路径。然后显示这些路径以及`resolvedPath`的绝对路径。绝对路径包括根目录，尽管这在您的系统上可能有所不同。
- en: There's more...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `resolve` methods are overloaded, one using a `String` argument and the
    second using a `Path` argument. The `resolve` method can also be misused. In addition,
    there is also an `overloadedresolveSibling` method that works similar to the `resolve`
    method except it removes the last element of the root path. These issues are addressed
    here.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve`方法是重载的，一个使用`String`参数，另一个使用`Path`参数。`resolve`方法也可能被误用。此外，还有一个`overloadedresolveSibling`方法，其工作方式类似于`resolve`方法，只是它会移除根路径的最后一个元素。这些问题在这里得到解决。'
- en: Using a String argument with the resolve method
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`String`参数与`resolve`方法
- en: 'The `resolve` method is overloaded with one that accepts a `String` argument.
    The following statement will achieve the same results as in the previous example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve`方法是重载的，其中一个接受`String`参数。以下语句将实现与前面示例相同的结果：'
- en: '[PRE14]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The path separator can also be used as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 路径分隔符也可以使用如下：
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using these statements with the earlier code results in the following output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些语句与先前的代码会产生以下输出：
- en: '**rootPath: \home\docs**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 根路径：\home\docs
- en: '**partialPath: users.txt**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**partialPath: users.txt**'
- en: '**resolvedPath: \home\docs\backup\users.txt**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**resolvedPath: \home\docs\backup\users.txt**'
- en: '**Resolved absolute path: E:\home\docs\backup\users.txt**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**解析的绝对路径：E:\home\docs\backup\users.txt**'
- en: Notice that the resolved path is not necessarily a valid path as the backup
    directory may or may not exist. The `toRealPath` method in the *Removing redundancies
    in a path by normalizing the path* recipe can be used to determine if it is valid
    or not.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，解析的路径不一定是有效路径，因为备份目录可能存在，也可能不存在。在*通过规范化路径来消除路径中的冗余*配方中，可以使用`toRealPath`方法来确定它是否有效。
- en: Improper use of the resolve method
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误使用`resolve`方法
- en: 'There are three uses of the `resolve` method that can result in unexpected
    behavior:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve`方法有三种用法，可能会导致意外行为：'
- en: Incorrect order of the root and partial paths
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根路径和部分路径的顺序不正确
- en: Using a partial path twice
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用部分路径两次
- en: Using the root path twice
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用根路径两次
- en: 'If we reverse the order in which the `resolve` method is used, that is apply
    the root path to the partial path, only the root path is returned. This is illustrated
    with the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们颠倒`resolve`方法的使用顺序，也就是将根路径应用于部分路径，那么只会返回根路径。下面的代码演示了这一点：
- en: '[PRE16]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When the code is executed, we get the following results:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行代码时，我们得到以下结果：
- en: '**rootPath: \home\docs**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 根路径：\home\docs
- en: '**partialPath: users.txt**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**partialPath: users.txt**'
- en: '**resolvedPath: \home\docs**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**resolvedPath: \home\docs**'
- en: '**Resolved absolute path: E:\home\docs**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**解析的绝对路径：E:\home\docs**'
- en: 'Only the root path is returned here. The partial path is not appended to the
    root path. Using the partial path twice as shown in the following code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只返回根路径。部分路径不会附加到根路径上。如下面的代码所示，使用部分路径两次：
- en: '[PRE17]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'will result in the following output:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将产生以下输出：
- en: '**rootPath: \home\docs**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**rootPath: \home\docs**'
- en: '**partialPath: users.txt**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**partialPath: users.txt**'
- en: '**resolvedPath: users.txt\users.txt**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**resolvedPath: users.txt\users.txt**'
- en: '**Resolved absolute path: currentWorkingDIrectory\users.txt\users.txt**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**解析的绝对路径：currentWorkingDIrectory\users.txt\users.txt**'
- en: 'Notice the resolved path is incorrect and that the absolute path uses the current
    working directory. Using the root path twice as shown below:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，解析的路径是不正确的，绝对路径使用了当前工作目录。如下所示，使用根路径两次：
- en: '[PRE18]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'results in the same output as when using the paths in the reverse order:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与以相反顺序使用路径时相同：
- en: '**rootPath: \home\docs**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**rootPath: \home\docs**'
- en: '**partialPath: users.txt**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**partialPath: users.txt**'
- en: '**resolvedPath: \home\docs**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**resolvedPath: \home\docs**'
- en: '**Resolved absolute path: E:\home\docs**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**解析的绝对路径：E:\home\docs**'
- en: Whenever an absolute path is used as the argument of the `resolve` method, that
    absolute path is returned. If an empty path is used as an argument to the method,
    the root path is returned.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 每当绝对路径被用作`resolve`方法的参数时，该绝对路径将被返回。如果空路径被用作方法的参数，则根路径将被返回。
- en: Using the resolveSibling
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`resolveSibling`
- en: 'The `resolveSibling` method is overloaded taking either a `String` or a `Path`
    object. With the `resolve` method, the partial path is appended to the end of
    the root path. The `resolveSibling` method differs from the `resolve` method in
    that the last element of the root path is removed before the partial path is appended.
    Consider the following code sequence:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolveSibling`方法是重载的，可以接受`String`或`Path`对象。使用`resolve`方法时，部分路径被附加到根路径的末尾。`resolveSibling`方法与`resolve`方法不同之处在于，在附加部分路径之前，根路径的最后一个元素被移除。考虑以下代码序列：'
- en: '[PRE19]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When executed we get the following output:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，我们得到以下输出：
- en: '**rootPath: \home\music**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**rootPath: \home\music**'
- en: '**resolvedPath: \home\music\tmp\Robot Brain A.mp3**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**resolvedPath: \home\music\tmp\Robot Brain A.mp3**'
- en: '**rootPath: \home\music**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**rootPath: \home\music**'
- en: '**resolvedPath: \home\tmp\Robot Brain A.mp3**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**resolvedPath: \home\tmp\Robot Brain A.mp3**'
- en: Notice the resolved path differs in the presence of the directory `music`. When
    the `resolve` method is used, the directory is present. It is absent when the
    `resolveSibling` method is used. If there is no parent path, or the argument of
    the method is an absolute path, then the argument passed to the method is returned.
    If the argument is empty then the parent is returned.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，解析路径在存在`music`目录时与使用`resolveSibling`方法时不同。当使用`resolve`方法时，目录存在。当使用`resolveSibling`方法时，目录不存在。如果没有父路径，或者方法的参数是绝对路径，则返回传递给方法的参数。如果参数为空，则返回父目录。
- en: See also
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The creation of a `Path` object is discussed in the *Understanding paths* recipe.
    Also, the `toRealPath` method is explained in the *Removing redundancies in a
    path by normalizing the path* recipe.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`对象的创建在*理解路径*配方中有所讨论。此外，`toRealPath`方法在*通过规范化路径来消除路径中的冗余*配方中有所解释。'
- en: Creating a path between two locations
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在两个位置之间创建路径
- en: To relativize a path means to create a path based on two other paths such that
    the new path represents a way of navigating from one of the original paths to
    the other. This technique finds a relative path from one location to another.
    For example, the first path could represent an application default directory.
    The second path could represent a target directory. A relative path created from
    these directories could facilitate operations against the target.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 相对化路径意味着基于另外两个路径创建一个路径，使得新路径表示从原始路径中的一个导航到另一个的方式。这种技术找到了从一个位置到另一个位置的相对路径。例如，第一个路径可以表示一个应用程序默认目录。第二个路径可以表示一个目标目录。从这些目录创建的相对路径可以促进对目标的操作。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use the `relativize` method to create a new path from one path to another,
    we need to do the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`relativize`方法从一个路径到另一个路径创建新路径，我们需要执行以下操作：
- en: Create a `Path` object that represents the first path.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表第一个路径的`Path`对象。
- en: Create a `Path` object that represents the second path.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表第二个路径的`Path`对象。
- en: Apply the `relativize` method against the first path using the second path as
    its argument.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对第一个路径使用第二个路径作为参数应用`relativize`方法。
- en: How to do it...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application and use the following `main` method. This
    method creates two `Path` objects, and shows the relative path between them as
    follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序，并使用以下`main`方法。该方法创建两个`Path`对象，并显示它们之间的相对路径如下：
- en: '[PRE20]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Execute the application. Your results should be similar to the following:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您的结果应该类似于以下内容：
- en: '**From firstPath to secondPath: ..\..\docs**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**从firstPath到secondPath: ..\..\docs**'
- en: '**From secondPath to firstPath: ..\music\Future Setting A.mp3**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**从secondPath到firstPath: ..\music\Future Setting A.mp3**'
- en: '**From firstPath to secondPath: ..**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**从firstPath到secondPath: ..**'
- en: '**From secondPath to firstPath: Future Setting A.mp3**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**从secondPath到firstPath: Future Setting A.mp3**'
- en: '**From firstPath to secondPath: ..\..\docs\users.txt**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**从firstPath到secondPath: ..\..\docs\users.txt**'
- en: '**From secondPath to firstPath: ..\..\music\Future Setting A.mp3**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**从secondPath到firstPath: ..\..\music\Future Setting A.mp3**'
- en: How it works...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the first example, a relative path was created from the `Future Setting A.mp3`
    file to the `docs` directory. The `music` and `docs` directories are assumed to
    be siblings. The `.`. notation means to move up one directory. This chapter's
    introduction illustrated the assumed directory structure for this example.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，从`Future Setting A.mp3`文件到`docs`目录创建了一个相对路径。假定`music`和`docs`目录是兄弟目录。`.`符号表示向上移动一个目录。本章的介绍说明了这个例子的假定目录结构。
- en: The second example demonstrates creating a path from within the same directory.
    The path from `firstpath` to `secondPath` is actually a potential error. Depending
    on how this is used, we could end up in the directory above the `music` directory
    since the path returned is `.`. meaning to move up one directory level. The third
    example is similar to the first example except both of the paths contain file
    names.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子演示了从同一目录中创建路径。从`firstpath`到`secondPath`的路径实际上是一个潜在的错误。取决于如何使用它，我们可能会最终进入`music`目录上面的目录，因为返回的路径是`.`，表示向上移动一个目录级别。第三个例子与第一个例子类似，只是两个路径都包含文件名。
- en: 'The relative path created by this method may not be a valid path. This is illustrated
    by using the potentially non-existent `tmp` directory, shown as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法创建的相对路径可能不是有效的路径。通过使用可能不存在的`tmp`目录来说明，如下所示：
- en: '[PRE21]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output should appear as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '**From firstPath to secondPath: ..\..\docs\tmp\users.txt**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**从firstPath到secondPath: ..\..\docs\tmp\users.txt**'
- en: '**From secondPath to firstPath: ..\..\..\music\Future Setting A.mp3**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**从secondPath到firstPath：..\..\..\music\Future Setting A.mp3**'
- en: There's more...
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are three other cases that we need to consider:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三种情况需要考虑：
- en: Both paths are equal
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两条路径相等
- en: One path contains a root
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条路径包含根
- en: Both paths contain a root
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两条路径都包含根
- en: Both paths are equal
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两条路径相等
- en: 'When both paths are equal, the `relativize` method will return an empty path
    as illustrated with the following code sequence:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当两条路径相等时，`relativize`方法将返回一个空路径，如下面的代码序列所示：
- en: '[PRE22]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '**From firstPath to secondPath:**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**从firstPath到secondPath：**'
- en: '**From secondPath to firstPath:**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**从secondPath到firstPath：**'
- en: While this is not necessarily an error, note that it does not return a single
    dot which is frequently used to represent the current directory.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不一定是错误，但请注意它不返回一个经常用来表示当前目录的单个点。
- en: One path contains a root
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一条路径包含根
- en: If only one of the paths contains a root element, then it may not be possible
    to construct a relative path. Whether it is possible or not is system-dependent.
    In the following example, the first path contains the root element `c:`
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两条路径中只有一条包含根元素，则可能无法构造相对路径。是否可能取决于系统。在下面的例子中，第一条路径包含根元素`c:`。
- en: '[PRE23]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When this code sequence is executed on Windows 7, we get the following output:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Windows 7上执行此代码序列时，我们得到以下输出：
- en: '**Exception in thread "main" java.lang.IllegalArgumentException: ''other''
    is different type of Path**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程"main"中的异常"java.lang.IllegalArgumentException: ''other''是不同类型的路径**'
- en: '**From firstPath to secondPath: .**.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**从firstPath到secondPath：.**。'
- en: '**From secondPath to firstPath: Future Setting A.mp3**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**从secondPath到firstPath：Future Setting A.mp3**'
- en: '**atsun.nio.fs.WindowsPath.relativize(WindowsPath.java:388)**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**atsun.nio.fs.WindowsPath.relativize(WindowsPath.java:388)**'
- en: '**atsun.nio.fs.WindowsPath.relativize(WindowsPath.java:44)**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**atsun.nio.fs.WindowsPath.relativize(WindowsPath.java:44)**'
- en: '**atpackt.RelativizePathExample.main(RelativizePathExample.java:25)**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**atpackt.RelativizePathExample.main(RelativizePathExample.java:25)**'
- en: '**Java Result: 1**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java结果：1**'
- en: Notice the reference to **other** in the output. This refers to the argument
    of the `relativize` method.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出中对**other**的引用。这指的是`relativize`方法的参数。
- en: Both paths contain a root
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两条路径都包含根
- en: 'The ability of the `relativize` method to create a relative path when both
    paths contain a root element is also system-dependent. This situation is illustrated
    in the following example:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`relativize`方法在两条路径都包含根元素时创建相对路径的能力也取决于系统。这种情况在下面的例子中有所说明：'
- en: '[PRE24]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When executed on Windows 7, we get the following output:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows 7上执行时，我们得到以下输出：
- en: '**From firstPath to secondPath: ..\..\docs\users.txt**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**从firstPath到secondPath：..\..\docs\users.txt**'
- en: '**From secondPath to firstPath: ..\..\music\Future Setting A.mp3**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**从secondPath到firstPath：..\..\music\Future Setting A.mp3**'
- en: See also
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The creation of a `Path` object is discussed in the *Understanding paths* recipe.
    Symbolic links results are system-dependent and are discussed in more depth in
    the *Managing symbolic links* recipe.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`对象的创建在*理解路径*配方中讨论。符号链接的结果取决于系统，并在*管理符号链接*配方中进行了更深入的讨论。'
- en: Converting between path types
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在路径类型之间进行转换
- en: The `Path` interface represents a path within a filesystem. This path may or
    may not be a valid path. There are times when we may want to use an alternative
    representation of a path. For example, a file can be loaded into most browsers
    using a `URI` for the file. The `toUri` method provides this representation of
    a path. In this recipe we will also see how to obtain an absolute path and a real
    path for a `Path` object.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`接口表示文件系统中的路径。这个路径可能是有效的，也可能不是。有时我们可能想要使用路径的另一种表示。例如，可以使用文件的`URI`在大多数浏览器中加载文件。`toUri`方法提供了路径的这种表示。在这个示例中，我们还将看到如何获取`Path`对象的绝对路径和真实路径。'
- en: Getting ready
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: 'There are three methods that provide alternative path representations:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法提供替代路径表示：
- en: The `toUri` method returns the `URI` representation
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toUri`方法返回`URI`表示'
- en: The `toAbsolutePath` method returns the absolute path
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toAbsolutePath`方法返回绝对路径'
- en: The `toRealPath` method returns the real path
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toRealPath`方法返回真实路径'
- en: How to do it...
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application. Within the `main` method, we will use each
    of the previous methods. Add the following `main` method to the application:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。在`main`方法中，我们将使用之前的每种方法。将以下`main`方法添加到应用程序中：
- en: '[PRE25]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If not already present, add a `users.txt` file in the working directory of
    your application. Execute the program. Your output should be similar to the following,
    except the **..**. in this output should reflect the location of the `users.txt`
    file:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未存在，请在应用程序的工作目录中添加一个`users.txt`文件。执行程序。您的输出应该类似于以下内容，除了此输出中的**..**应反映`users.txt`文件的位置：
- en: '**URI path: file:///.../ConvertingPathsExample/users.txt**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**URI路径：file:///.../ConvertingPathsExample/users.txt**'
- en: '**Absolute path...\ConvertingPathsExample\users.txt**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对路径...\ConvertingPathsExample\users.txt**'
- en: '**Real path: ...\ConvertingPathsExample\users.txt**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**真实路径：...\ConvertingPathsExample\users.txt**'
- en: How it works...
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A `users.txt` file was added to the working directory of the Java application.
    This file should contain a list of usernames. The `get` method returned a `Path`
    object representing this file. Each of the three methods were then executed against
    this object.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`users.txt`文件被添加到Java应用程序的工作目录中。该文件应包含用户名列表。`get`方法返回表示此文件的`Path`对象。然后对该对象执行了三种方法。
- en: The `toUri` and `toAbsolutePath` methods returned paths as expected for that
    method type. The path returned is dependent on the application's working directory.
    The `toRealPath` method should have returned the same output as the `toAbsolutePath`
    method. This is to be expected, since the `users.txt` file was not created as
    a symbolic link. Had this been a symbolic link, then a different path representing
    the actual path to the file would have been displayed.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`toUri`和`toAbsolutePath`方法按预期返回路径。返回的路径取决于应用程序的工作目录。`toRealPath`方法应该返回与`toAbsolutePath`方法相同的输出。这是预期的，因为`users.txt`文件不是作为符号链接创建的。如果这是一个符号链接，那么将显示代表文件实际路径的不同路径。'
- en: There's more...
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Since it is possible that a `Path` object may not actually represent a file,
    the use of the `toRealPath` method may throw a `java.nio.file.NoSuchFileException`
    if the file does not exist. Use an invalid file name, shown as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Path`对象可能实际上并不代表文件，如果文件不存在，使用`toRealPath`方法可能会抛出`java.nio.file.NoSuchFileException`。使用一个无效的文件名，如下所示：
- en: '[PRE26]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output should appear as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '**URI path: file:///.../ConvertingPathsExample/invalidFileName.txt**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**URI路径：file:///.../ConvertingPathsExample/invalidFileName.txt**'
- en: '**Absolute path: ...\ConvertingPathsExample\invalidFileName.txt**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对路径：...\ConvertingPathsExample\invalidFileName.txt**'
- en: '**Sep 11, 2011 6:40:40 PM packt.ConvertingPathsExample main**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sep 11, 2011 6:40:40 PM packt.ConvertingPathsExample main**'
- en: '**SEVERE: null**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**严重：null**'
- en: '**java.nio.file.NoSuchFileException: ...\ConvertingPathsExample\invalidFileName.txt**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**java.nio.file.NoSuchFileException: ...\ConvertingPathsExample\invalidFileName.txt**'
- en: 'Notice that the `toUri` and `toAbsolutePath` work regardless of whether the
    specified file exists or not. In situations where we want to use these methods,
    we can test whether the file exists or not using the `Files` class'' `exists`
    method. The previous code sequence has been modified to use the `exists` method
    shown as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`toUri`和`toAbsolutePath`方法无论指定的文件是否存在都可以工作。在我们想要使用这些方法的情况下，我们可以使用`Files`类的`exists`方法来测试文件是否存在。前面的代码序列已经修改为使用`exists`方法，如下所示：
- en: '[PRE27]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `java.nio.fil.LinkOption` enumeration was added in Java 7\. It is used to
    specify whether symbolic links should be followed or not.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.fil.LinkOption`枚举是在Java 7中添加的。它用于指定是否应该跟随符号链接。'
- en: 'When executed, the output should appear as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，输出应如下所示：
- en: '**URI path: file:///.../ConvertingPathsExample/invalidFileName.txt**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**URI路径：file:///.../ConvertingPathsExample/invalidFileName.txt**'
- en: '**Absolute path: ...\ConvertingPathsExample\invalidFileName.txt**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对路径：...\ConvertingPathsExample\invalidFileName.txt**'
- en: '**The file does not exist**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件不存在**'
- en: Determining whether two paths are equivalent
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定两个路径是否等效
- en: At times it may be necessary to compare paths. The `Path` class allows you to
    test the paths for equality using the `equals` method. You can also use the `compareTo`
    method to compare two paths lexicographically using an implementation of the `Comparable`
    interface. Finally, the `isSameFile` method can be used to determine if two `Path`
    objects will locate the same file.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 有时可能需要比较路径。`Path`类允许您使用`equals`方法测试路径的相等性。您还可以使用`compareTo`方法使用`Comparable`接口的实现按字典顺序比较两个路径。最后，`isSameFile`方法可用于确定两个`Path`对象是否将定位到相同的文件。
- en: Getting ready
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to compare two paths, you must:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较两个路径，您必须：
- en: Create a `Path` object that represents the first path.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表第一个路径的`Path`对象。
- en: Create a `Path` object that represents the second path.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表第二个路径的`Path`对象。
- en: Apply either the `equals, compareTo`, or `isSameFile` methods to the paths as
    needed.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要对路径应用`equals, compareTo`或`isSameFile`方法。
- en: How to do it...
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application and add a `main` method. Declare three `Path`
    object variables such as `path1, path2` and `path3`. Set the first two to the
    same file and the third one to a different path. All the three files must exist.
    Follow this with calls to three comparison methods:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序并添加一个`main`方法。声明三个`Path`对象变量，如`path1，path2`和`path3`。将前两个设置为相同的文件，第三个设置为不同的路径。所有三个文件必须存在。接下来调用三个比较方法：
- en: '[PRE28]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add three static methods as follows:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加三个静态方法如下：
- en: '[PRE29]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Execute the application. Your output should be similar to the following:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您的输出应该类似于以下内容：
- en: '**\home\docs\users.txt and \home\docs\users.txt are equal**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**\home\docs\users.txt 和 \home\docs\users.txt 是相等的**'
- en: '**\home\docs\users.txt and \home\music\Future Setting A.mp3 are NOT equal**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**\home\docs\users.txt 和 \home\music\Future Setting A.mp3 不相等**'
- en: '**\home\docs\users.txt and \home\docs\users.txt are identical**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: \home\docs\users.txt 和 \home\docs\users.txt 是相同的
- en: '**\home\docs\users.txt and \home\music\Future Setting A.mp3 are NOT identical**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**\home\docs\users.txt 和 \home\music\Future Setting A.mp3 不相同**'
- en: '**\home\docs\users.txt and \home\docs\users.txt are the same file**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**\home\docs\users.txt 和 \home\docs\users.txt 是相同的文件**'
- en: '**\home\docs\users.txt and \home\music\Future Setting A.mp3 are NOT the same
    file**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**\home\docs\users.txt 和 \home\music\Future Setting A.mp3 不是同一个文件**'
- en: How it works...
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `testEquals` method, we determined whether the path objects were considered
    to be equal. The `equals` method will return true if they are equal. However,
    the definition of equality is system-dependent. Some filesystems will use the
    case, among other factors, to determine if the paths are equal.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在`testEquals`方法中，我们确定了路径对象是否被视为相等。如果它们相等，`equals`方法将返回true。但是，相等的定义是依赖于系统的。一些文件系统将使用大小写等因素来确定路径是否相等。
- en: The `testCompareTo` method used the `compareTo` method to compare the paths
    alphabetically. If the paths are identical, the method returns a zero. The method
    returns an integer less than zero if the path is less than the argument and a
    value greater than zero if the path follows the argument lexicographically.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`testCompareTo`方法使用`compareTo`方法按字母顺序比较路径。如果路径相同，该方法返回零。如果路径小于参数，则该方法返回小于零的整数，如果路径按字典顺序跟随参数，则返回大于零的值。'
- en: The `testSameFile` method determines whether the paths locate the same file.
    The `Path` objects are first tested to see if they are the same object. If they
    are, the method will return true. If the `Path` objects are not equal, the method
    then determines whether the paths locate the same file. The method will return
    false if the `Path` objects were generated by different filesystem providers.
    A try block was used since the method may throw an `IOException.`
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`testSameFile`方法确定路径是否指向相同的文件。首先测试`Path`对象是否相同。如果是，则该方法将返回true。如果`Path`对象不相等，则该方法确定路径是否指向相同的文件。如果`Path`对象是由不同的文件系统提供程序生成的，则该方法将返回false。由于该方法可能引发`IOException`，因此使用了try块。'
- en: There's more...
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `equals` and `compareTo` methods will not successfully compare paths from
    different filesystems. However, as long as the files are on the same filesystem,
    the files in question do not have to exist and the filesystem is not accessed.
    The `isSameFile` method may require access to the files if the path objects being
    tested are not found to be equal. In this case, the files must exist otherwise
    the method will return false.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals`和`compareTo`方法将无法成功比较来自不同文件系统的路径。但是，只要文件位于同一文件系统上，所涉及的文件无需存在，文件系统也不会被访问。如果要测试的路径对象不相等，则`isSameFile`方法可能需要访问文件。在这种情况下，文件必须存在，否则该方法将返回false。'
- en: See also
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The `Files` class' `exists` and `notExists` methods can be used to determine
    whether a file or directory exists or not. This is covered in the *Getting file
    and directory information* recipe in [Chapter 3](ch03.html "Chapter 3. Obtaining
    File and Directory Information"), *Obtaining File and Directory Information*.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files`类的`exists`和`notExists`方法可用于确定文件或目录是否存在。这在[第3章](ch03.html "第3章。获取文件和目录信息")的*获取文件和目录信息*中有所涵盖。'
- en: Managing symbolic links
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理符号链接
- en: Symbolic links are used to create a reference to a file that actually exists
    in a different directory. In the introduction, a file hierarchy was detailed that
    listed the file, `users.txt`, twice; once in the `docs` directory and a second
    time in the `music` directory. The actual file is located in the `docs` directory.
    The `users.txt` file in the `music` directory is a symbolic link to the real file.
    To a user they appear to be different files. In reality, they are the same. Modification
    of either file results in the real file being changed.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接用于创建对实际存在于不同目录中的文件的引用。在介绍中，详细列出了文件层次结构，其中`users.txt`文件在`docs`目录和`music`目录中分别列出。实际文件位于`docs`目录中。`music`目录中的`users.txt`文件是对真实文件的符号链接。对用户来说，它们看起来是不同的文件。实际上，它们是相同的。修改任一文件都会导致真实文件被更改。
- en: From a programmer's perspective, we are often interested in knowing which files
    are symbolic links and which are not. In this recipe we will discuss the methods
    available in Java 7 to work with symbolic links. It is important to understand
    how a method behaves when used with a symbolic link.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序员的角度来看，我们经常想知道哪些文件是符号链接，哪些不是。在本教程中，我们将讨论Java 7中可用于处理符号链接的方法。重要的是要了解在与符号链接一起使用方法时方法的行为。
- en: Getting ready
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'While several methods may behave differently based on whether a `Path` object
    represents a symbolic link or not, in this chapter only the `toRealPath, exists`,
    and `notExists` methods take an optional `LinkOption` enumeration argument. This
    enumeration has only a single element: `NOFOLLOW_LINKS`. If the argument is not
    used then the methods default to following symbolic links.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然几种方法可能根据`Path`对象是否表示符号链接而有所不同，但在本章中，只有`toRealPath，exists`和`notExists`方法接受可选的`LinkOption`枚举参数。此枚举只有一个元素：`NOFOLLOW_LINKS`。如果未使用该参数，则方法默认会跟随符号链接。
- en: How to do it...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new console application. Use the following `main` method where we create
    several `Path` objects representing both the real and the symbolic `users.txt`
    file. The behavior of several of this chapter's `Path-related` methods is illustrated.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。使用以下`main`方法，在其中创建代表真实和符号`users.txt`文件的几个`Path`对象。演示了本章中几个`Path-related`方法的行为。
- en: '[PRE30]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The behavior of these methods can differ based on the underlying operating
    system. When the code is executed on a Windows platform, we get the following
    output:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些方法的行为可能因基础操作系统而异。当代码在Windows平台上执行时，我们会得到以下输出：
- en: '**false**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**false**'
- en: '**true**'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**true**'
- en: '**Normalized: C:\home\music\users.txt**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**标准化：C：\ home \ music \ users.txt**'
- en: '**Absolute path: C:\home\.\music\users.txt**'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对路径：C：\ home \。music \ users.txt**'
- en: '**URI: file:///C:/home/./music/users.txt**'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**URI：file:///C:/home/./music/users.txt**'
- en: '**toRealPath (Do not follow links): C:\home\music\users.txt**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: toRealPath（不要跟随链接）：C：\ home \ music \ users.txt
- en: '**toRealPath: C:\home\docs\users.txt**'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**toRealPath：C：\ home \ docs \ users.txt**'
- en: '**From firstPath to secondPath: ..\..\..\docs\status.txt**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**从firstPath到secondPath：..\..\..\docs\status.txt**'
- en: '**From secondPath to firstPath: ..\..\home\music\users.txt**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**从secondPath到firstPath：..\..\home\music\users.txt**'
- en: '**exists (Do not follow links): true**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**exists（不要跟随链接）：true**'
- en: '**exists: true**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**exists：true**'
- en: '**notExists (Do not follow links): false**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**notExists（不要跟随链接）：false**'
- en: '**notExists: false**'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**notExists：false**'
- en: How it works...
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `path1` and `path2` objects were created which referenced the real file
    and the symbolic link respectively. The `Files` class' `isSymbolicLink` method
    was executed against these objects indicating which path referenced the real file.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了`path1`和`path2`对象，分别引用了真实文件和符号链接。针对这些对象执行了`Files`类的`isSymbolicLink`方法，指示哪个路径引用了真实文件。
- en: The `Path` object was created using an extraneous dot notation. The result of
    the `normalize` method executed against the symbolic link returns a normalized
    path to the symbolic link. The use of the `toAbsolutePath` and `toUri` methods
    results in a path to the symbolic link and not the real file.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多余的点符号创建了`Path`对象。针对符号链接执行的`normalize`方法的结果返回了对符号链接的标准化路径。使用`toAbsolutePath`和`toUri`方法会返回对符号链接而不是真实文件的路径。
- en: The `toRealPath` method possesses an optional `LinkOption` argument. We used
    this to obtain a path to the real file. This method is useful when you need the
    real path, which is often not returned by the other methods executed against a
    symbolic link.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`toRealPath`方法具有可选的`LinkOption`参数。我们使用它来获取真实文件的路径。当您需要真实路径时，这个方法非常有用，通常其他方法执行符号链接时不会返回真实路径。'
- en: The `firstPath` and `secondPath` objects were used to explore how the `relativize`
    method works with symbolic links. In these examples, the symbolic links were used.
    The last set of examples used the `exists` and `notExists` methods. The use of
    symbolic links did not affect the results of these methods.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstPath`和`secondPath`对象被用来探索`relativize`方法如何与符号链接一起工作。在这些例子中，使用了符号链接。最后一组例子使用了`exists`和`notExists`方法。使用符号链接并不影响这些方法的结果。'
- en: See also
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The use of symbolic files as they affect other filesystem methods is discussed
    in subsequent chapters.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 符号文件的使用对其他文件系统方法的影响将在后续章节中讨论。
