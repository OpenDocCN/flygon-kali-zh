["```\n$ docker version\nClient:\n Version:      `17`.05.0-ce\n API version:  `1`.29\n Go version:   go1.7.5\n Git commit:   89658be\n Built:        Thu May  `4` `22`:10:54 `2017`\n OS/Arch:      linux/amd64\n\nServer:\n Version:      `17`.05.0-ce\n API version:  `1`.29 `(`minimum version `1`.12`)`\n Go version:   go1.7.5\n Git commit:   89658be\n Built:        Thu May  `4` `22`:10:54 `2017`\n OS/Arch:      linux/amd64\n Experimental: `false` \n```", "```\n//Run this command on Linux systems not using Systemd\n$ service docker status\ndocker start/running, process 29393\n\n//Run this command on Linux systems that are using Systemd\n$ systemctl is-active docker\nactive\n\n//Run this command on Windows Server 2016 systems from a PowerShell window\n> Get-Service docker\n\nStatus    Name      DisplayName\n------    ----      -----------\nRunning   Docker    docker \n```", "```\n`$` `docker` `container` `run` `-``it` `ubuntu``:``latest` `/``bin``/``bash`\n`Unable` `to` `find` `image` `'``ubuntu``:``latest``'` `locally`\n`latest``:` `Pulling` `from` `library``/``ubuntu`\n`952132``ac251a``:` `Pull` `complete`\n`82659f8f``1``b76``:` `Pull` `complete`\n`c19118ca682d``:` `Pull` `complete`\n`8296858250f``e``:` `Pull` `complete`\n`24e0251``a0e2c``:` `Pull` `complete`\n`Digest``:` `sha256``:``f4691c96e6bbaa99d9``...``e95a60369c506dd6e6f6ab`\n`Status``:` `Downloaded` `newer` `image` `for` `ubuntu``:``latest`\n`root``@3027``eb644874``:``/``#` \n```", "```\ndocker container run -it microsoft/powershell:nanoserver pwsh.exe \n```", "```\n`root``@3027``eb644874``:``/``#` `ls` `-``l`\n`total` `64`\n`drwxr``-``xr``-``x`   `2` `root` `root` `4096` `Aug` `19` `00``:``50` `bin`\n`drwxr``-``xr``-``x`   `2` `root` `root` `4096` `Apr` `12` `20``:``14` `boot`\n`drwxr``-``xr``-``x`   `5` `root` `root`  `380` `Sep` `13` `00``:``47` `dev`\n`drwxr``-``xr``-``x`  `45` `root` `root` `4096` `Sep` `13` `00``:``47` `etc`\n`drwxr``-``xr``-``x`   `2` `root` `root` `4096` `Apr` `12` `20``:``14` `home`\n`drwxr``-``xr``-``x`   `8` `root` `root` `4096` `Sep` `13`  `2015` `lib`\n`drwxr``-``xr``-``x`   `2` `root` `root` `4096` `Aug` `19` `00``:``50` `lib64`\n`drwxr``-``xr``-``x`   `2` `root` `root` `4096` `Aug` `19` `00``:``50` `media`\n`drwxr``-``xr``-``x`   `2` `root` `root` `4096` `Aug` `19` `00``:``50` `mnt`\n`drwxr``-``xr``-``x`   `2` `root` `root` `4096` `Aug` `19` `00``:``50` `opt`\n`dr``-``xr``-``xr``-``x` `129` `root` `root`    `0` `Sep` `13` `00``:``47` `proc`\n`drwx``------`   `2` `root` `root` `4096` `Aug` `19` `00``:``50` `root`\n`drwxr``-``xr``-``x`   `6` `root` `root` `4096` `Aug` `26` `18``:``50` `run`\n`drwxr``-``xr``-``x`   `2` `root` `root` `4096` `Aug` `26` `18``:``50` `sbin`\n`drwxr``-``xr``-``x`   `2` `root` `root` `4096` `Aug` `19` `00``:``50` `srv`\n`dr``-``xr``-``xr``-``x`  `13` `root` `root`    `0` `Sep` `13` `00``:``47` `sys`\n`drwxrwxrwt`   `2` `root` `root` `4096` `Aug` `19` `00``:``50` `tmp`\n`drwxr``-``xr``-``x`  `11` `root` `root` `4096` `Aug` `26` `18``:``50` `usr`\n`drwxr``-``xr``-``x`  `13` `root` `root` `4096` `Aug` `26` `18``:``50` `var`\n\n`root``@3027``eb644874``:``/``#` `ping` `www``.``docker``.``com`\n`bash``:` `ping``:` `command` `not` `found`\n`root``@3027``eb644874``:``/``#` \n```", "```\n`root``@3027``eb644874``:``/``#` `ps` `-``elf`\n`F` `S` `UID`   `PID`  `PPID`   `NI` `ADDR` `SZ` `WCHAN`  `STIME` `TTY`     `TIME`      `CMD`\n`4` `S` `root`    `1`     `0`    `0` `-`  `4558` `wait`   `00``:``47` `?`     `00``:``00``:``00`  `/``bin``/``bash`\n`0` `R` `root`   `11`     `1`    `0` `-`  `8604` `-`      `00``:``52` `?`     `00``:``00``:``00`  `ps` `-``elf` \n```", "```\n$ docker container ls\nCNTNR ID  IMAGE          COMMAND    CREATED  STATUS    NAMES\n`302`...74  ubuntu:latest  /bin/bash  `6` mins   Up 6mins  sick_montalcini \n```", "```\n`$` `docker` `container` `exec` `-``it` `3027``eb644874` `bash`\n`root``@3027``eb644874``:``/``#` \n```", "```\n$ docker container stop 3027eb64487\n3027eb64487\n\n$ docker container rm 3027eb64487\n3027eb64487 \n```", "```\n`$` `docker` `container` `run` `--``name` `percy` `-``it` `ubuntu``:``latest` `/``bin``/``bash`\n`root``@9``cb2d2fd1d65``:``/``#` \n```", "```\n`root``@9``cb2d2fd1d65``:``/``#` `cd` `tmp`\n\n`root``@9``cb2d2fd1d65``:``/``tmp``#` `ls` `-``l`\n`total` `0`\n\n`root``@9``cb2d2fd1d65``:``/``tmp``#` `echo` `\"DevOps FTW\"` `>` `newfile`\n\n`root``@9``cb2d2fd1d65``:``/``tmp``#` `ls` `-``l`\n`total` `4`\n`-``rw``-``r``--``r``--` `1` `root` `root` `14` `May` `23` `11``:``22` `newfile`\n\n`root``@9``cb2d2fd1d65``:``/``tmp``#` `cat` `newfile`\n`DevOps` `FTW` \n```", "```\n$ docker container stop percy\npercy \n```", "```\n$ docker container ls\nCONTAINER ID   IMAGE   COMMAND   CREATED  STATUS  PORTS   NAMES \n```", "```\n$ docker container ls -a\nCNTNR ID  IMAGE          COMMAND    CREATED  STATUS      NAMES\n9cb...65  ubuntu:latest  /bin/bash  `4` mins   Exited `(``0``)`  percy \n```", "```\n$ docker container start percy\npercy\n\n$ docker container ls\nCONTAINER ID  IMAGE          COMMAND      CREATED  STATUS     NAMES\n9cb2d2fd1d65  ubuntu:latest  `\"/bin/bash\"`  `4` mins   Up `3` secs  percy \n```", "```\n`$` `docker` `container` `exec` `-``it` `percy` `bash`\n`root``@9``cb2d2fd1d65``:``/``#` \n```", "```\n`root``@9``cb2d2fd1d65``:``/``#` `cd` `tmp`\n`root``@9``cb2d2fd1d65``:``/``#` `ls` `-``l`\n`-``rw``-``r``--``r``--` `1` `root` `root` `14` `Sep` `13` `04``:``22` `newfile`\n`root``@9``cb2d2fd1d65``:``/``#`\n`root``@9``cb2d2fd1d65``:``/``#` `cat` `newfile`\n`DevOps` `FTW` \n```", "```\n$ docker container stop percy\npercy\n\n$ docker container rm percy\npercy\n\n$ docker container ls -a\nCONTAINER ID    IMAGE      COMMAND    CREATED  STATUS     PORTS      NAMES \n```", "```\n$ docker container run --name neversaydie -it --restart always alpine sh\n\n//Wait a few seconds before typing the ```", "```` `command`\n\n/# `exit`\n\n$ docker container ls\nCONTAINER ID    IMAGE     COMMAND    CREATED           STATUS\n0901afb84439    alpine    `\"sh\"`       `35` seconds ago    Up `1` second \n```\n\n `Notice that the container was created 35 seconds ago, but has only been up for 1 second. This is because we killed it when we issued the `exit` command from within the container, and Docker has had to restart it.\n\nAn interesting feature of the `--restart always` policy is that a stopped container will be restarted when the Docker daemon starts. For example, you start a new container with the `--restart always` policy and then stop it with the `docker container stop` command. At this point the container is in the `Stopped (Exited)` state. However, if you restart the Docker daemon, the container will be automatically restarted when the daemon comes back up.\n\nThe main difference between the **always** and **unless-stopped** policies is that containers with the `--restart unless-stopped` policy will not be restarted when the daemon restarts if they were in the `Stopped (Exited)` state. That might be a confusing sentence, so let\u2019s walk through an example.\n\nWe\u2019ll create two new containers. One called \u201calways\u201d with the `--restart always` policy, and one called \u201cunless-stopped\u201d with the `--restart unless-stopped` policy. We\u2019ll stop them both with the `docker container stop` command and then restart Docker. The \u201calways\u201d container will restart, but the \u201cunless-stopped\u201d container will not.\n\n1.  Create the two new containers\n\n    ```\n     $ docker container run -d --name always \\\n       --restart always \\\n       alpine sleep 1d\n\n     $ docker container run -d --name unless-stopped \\\n       --restart unless-stopped \\\n       alpine sleep 1d\n\n     $ docker container ls\n     CONTAINER ID   IMAGE     COMMAND       STATUS       NAMES\n     3142bd91ecc4   alpine    \"sleep 1d\"    Up 2 secs    unless-stopped\n     4f1b431ac729   alpine    \"sleep 1d\"    Up 17 secs   always \n    ```\n\n `We now have two containers running. One called \u201calways\u201d and one called \u201cunless-stopped\u201d.\n\n1.  Stop both containers\n\n    ```\n     $ docker container stop always unless-stopped\n\n     $ docker container ls -a\n     CONTAINER ID   IMAGE     STATUS                        NAMES\n     3142bd91ecc4   alpine    Exited (137) 3 seconds ago    unless-stopped\n     4f1b431ac729   alpine    Exited (137) 3 seconds ago    always \n    ```\n\n`*   Restart Docker.`\n\n `The process for restarting Docker is different on different Operating Systems. This example shows how to stop Docker on Linux hosts running `systemd`. To restart Docker on Windows Server 2016 use `restart-service Docker`.\n\n```\n $ systemlctl restart docker \n```\n\n `1.  Once Docker has restarted, you can check the status of the containers.\n\n    ```\n     $ docker container ls -a\n     CONTAINER   CREATED             STATUS                       NAMES\n     314..cc4    2 minutes ago      Exited (137) 2 minutes ago    unless-stopped\n     4f1..729    2 minutes ago      Up 9 seconds                  always \n    ```\n\n `Notice that the \u201calways\u201d container (started with the `--restart always` policy) has been restarted, but the \u201cunless-stopped\u201d container (started with the `--restart unless-stopped` policy) has not.\n\nThe **on-failure** policy will restart a container if it exits with a non-zero exit code. It will also restart containers when the Docker daemon restarts, even containers that were in the stopped state.\n\nIf you are working with Docker Compose or Docker Stacks, you can apply the restart policy to a `service` object as follows:\n\n```\nversion: \"3\"\nservices:\n  myservice:\n    <Snip>\n    restart_policy:\n      condition: always | unless-stopped | on-failure \n```\n\n `#### Web server example\n\nSo far, we\u2019ve seen how to start a simple container and interact with it. We\u2019ve also seen how to stop, restart and delete containers. Now let\u2019s take a look at a Linux web server example.\n\nIn this example, we\u2019ll start a new container from an image I use in a few of my [Pluralsight video courses](https://www.pluralsight.com/search?q=nigel%20poulton%20docker&categories=all). The image runs an insanely simple web server on port 8080.\n\nUse the `docker container stop` and `docker container rm` commands to clean up any existing containers on your system. Then run the following `docker container run` command.\n\n```\n$ docker container run -d --name webserver -p `80`:8080 `\\`\n  nigelpoulton/pluralsight-docker-ci\n\nUnable to find image `'nigelpoulton/pluralsight-docker-ci:latest'` locally\nlatest: Pulling from nigelpoulton/pluralsight-docker-ci\na3ed95caeb02: Pull `complete`\n3b231ed5aa2f: Pull `complete`\n7e4f9cd54d46: Pull `complete`\n929432235e51: Pull `complete`\n6899ef41c594: Pull `complete`\n0b38fccd0dab: Pull `complete`\nDigest: sha256:7a6b0125fe7893e70dc63b2...9b12a28e2c38bd8d3d\nStatus: Downloaded newer image `for` nigelpoulton/plur...docker-ci:latest\n6efa1838cd51b92a4817e0e7483d103bf72a7ba7ffb5855080128d85043fef21 \n```\n\n `Notice that your shell prompt hasn\u2019t changed. This is because we started this container in the background with the `-d` flag. Starting a container in the background does not attach it to your terminal.\n\nThis example threw a few more arguments at the `docker container run` command, so let\u2019s take a quick look at them.\n\nWe know `docker container run` starts a new container. But this time we give it the `-d` flag instead of `-it`. `-d` stands for **d**aemon mode, and tells the container to run in the background.\n\nAfter that, we name the container and then give it `-p 80:8080`. The `-p` flag maps ports on the Docker host to ports inside the container. This time we\u2019re mapping port 80 on the Docker host to port 8080 inside the container. This means that traffic hitting the Docker host on port 80 will be directed to port 8080 inside of the container. It just so happens that the image we\u2019re using for this container defines a web service that listens on port 8080\\. This means our container will come up running a web server listening on port 8080.\n\nFinally, we tell it which image to use: `nigelpoulton/pluralsight-docker-ci`. This image is not kept up-to-date and **will** contain vulnerabilities!\n\nRunning a `docker container ls` command will show the container as running and show the ports that are mapped. It\u2019s important to know that port mappings are expressed as `host-port:container-port`.\n\n```\n$ docker container ls\nCONTAINER ID  COMMAND        STATUS       PORTS               NAMES\n6efa1838cd51  /bin/sh -c...  Up `2` mins  `0`.0.0.0:80->8080/tcp  webserver \n```\n\n `> **Note:** We\u2019ve removed some of the columns from the output above to help with readability.\n\nNow that the container is running and ports are mapped, we can connect to the container by pointing a web browser at the IP address or DNS name of the **Docker host** on port 80\\. Figure 7.4 shows the web page that is being served up by the container.\n\n![Figure 7.4](images/figure7-4.png)\n\nFigure 7.4\n\nThe same `docker container stop`, `docker container pause`, `docker container start`, and `docker container rm` commands can be used on the container. Also, the same rules of persistence apply \u2014 stopping or pausing the container does not destroy the container or any data stored in it.\n\n#### Inspecting containers\n\nIn the previous example, you might have noticed that we didn\u2019t specify an app for the container when we issued the `docker container run` command. Yet the container ran a simple web service. How did this happen?\n\nWhen building a Docker image, it\u2019s possible to embed an instruction that lists the default app you want containers using the image to run. If we run a `docker image inspect` against the image we used to run our container, we\u2019ll be able to see the app that the container will run when it starts.\n\n```\n$ docker image inspect nigelpoulton/pluralsight-docker-ci\n\n`[`\n    `{`\n        `\"Id\"`: `\"sha256:07e574331ce3768f30305519...49214bf3020ee69bba1\"`,\n        `\"RepoTags\"`: `[`\n            `\"nigelpoulton/pluralsight-docker-ci:latest\"`\n\n            <Snip>\n\n            `]`,\n            `\"Cmd\"`: `[`\n                `\"/bin/sh\"`,\n                `\"-c\"`,\n                `\"#(nop) CMD [\\\"/bin/sh\\\" \\\"-c\\\" \\\"cd /src \\u0026\\u0026 node \\`\n`./app.js\\\"]\"`\n            `]`,\n<Snip> \n```\n\n `We\u2019ve snipped the output to make it easier to find the information we\u2019re interested in.\n\nThe entries after `Cmd` show the command/app that the container will run unless you override with a different one when you launch the container with `docker container run`. If you remove all of the shell escapes in the example, you get the following command `/bin/sh -c \"cd /src && node ./app.js\"`. That\u2019s the default app a container based on this image will run.\n\nIt\u2019s common to build images with default commands like this, as it makes starting containers easier. It also forces a default behavior and is a form of self documentation for the image \u2014 i.e. we can *inspect* the image and know what app it\u2019s supposed to run.\n\nThat\u2019s us done for the examples in this chapter. Let\u2019s see a quick way to tidy our system up.\n\n#### Tidying up\n\nLet\u2019s look at the simplest and quickest way to get rid of **every running container** on your Docker host. Be warned though, the procedure will forcible destroy **all** containers without giving them a chance to clean up. **This should never be performed on production systems or systems running important containers.**\n\nRun the following command from the shell of your Docker host to delete all containers.\n\n```\n$ docker container rm `$(`docker container ls -aq`)` -f\n6efa1838cd51 \n```\n\n `In this example, we only had a single container running, so only one was deleted (6efa1838cd51). However, the command works the same way as the `docker image rm $(docker image ls -q)` command we used in the previous chapter to delete all images on a single Docker host. We already know the `docker container rm` command deletes containers. Passing it `$(docker container ls -aq)` as an argument, effectively passes it the ID of every container on the system. The `-f` flag forces the operation so that running containers will also be destroyed. Net result\u2026 all containers, running or stopped, will be destroyed and removed from the system.\n\nThe above command will work in a PowerShell terminal on a Windows Docker host.\n\n### Containers - The commands\n\n*   `docker container run` is the command used to start new containers. In its simplest form, it accepts an *image* and a *command* as arguments. The image is used to create the container and the command is the application you want the container to run. This example will start an Ubuntu container in the foreground, and tell it to run the Bash shell: `docker container run -it ubuntu /bin/bash`.\n*   `Ctrl-PQ` will detach your shell from the terminal of a container and leave the container running `(UP)` in the background.\n*   `docker container ls` lists all containers in the running `(UP)` state. If you add the `-a` flag you will also see containers in the stopped `(Exited)` state.\n*   `docker container exec` lets you run a new process inside of a running container. It\u2019s useful for attaching the shell of your Docker host to a terminal inside of a running container. This command will start a new Bash shell inside of a running container and connect to it: `docker container exec -it <container-name or container-id> bash`. For this to work, the image used to create your container must contain the Bash shell.\n*   `docker container stop` will stop a running container and put it in the `Exited (0)` state. It does this by issuing a `SIGTERM` to the process with PID 1 inside of the container. If the process has not cleaned up and stopped within 10 seconds, a SIGKILL will be issued to forcibly stop the container. `docker container stop` accepts container IDs and container names as arguments.\n*   `docker container start` will restart a stopped `(Exited)` container. You can give `docker container start` the name or ID of a container.\n*   `docker container rm` will delete a stopped container. You can specify containers by name or ID. It is recommended that you stop a container with the `docker container stop` command before deleting it with `docker container rm`.\n*   `docker container inspect` will show you detailed configuration and runtime information about a container. It accepts container names and container IDs as its main argument.\n\n### Chapter summary\n\nIn this chapter, we compared and contrasted the container and VM models. We looked at the *OS tax* problem inherent in the VM model, and saw how the container model can bring huge advantages in much the same way as the VM model brought huge advantages over the physical model.\n\nWe saw how to use the `docker container run` command to start a couple of simple containers, and we saw the difference between interactive containers in the foreground versus containers running in the background.\n\nWe know that killing the PID 1 process inside of a container will kill the container. And we\u2019ve seen how to start, stop, and delete containers.\n\nWe finished the chapter using the `docker container inspect` command to view detailed container metadata.\n\nSo far so good!````", "```````````````````````"]