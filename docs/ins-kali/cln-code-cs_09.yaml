- en: Designing and Developing APIs
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和开发APIs
- en: '**Application Programming Interfaces** (**APIs**) have never been so vital
    in so many ways as they are these days. APIs are used to connect governments and
    institutions in the sharing of data and in a collaborative manner for business
    and governmental issues. They are used between doctors'' surgeries and hospitals
    to share patient data in real time. You use APIs every day when you connect to
    your emails and collaborate with your colleagues and clients through platforms
    such as Microsoft Teams, Microsoft Azure, Amazon Web Services, and Google Cloud
    Platform.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**APIs**）在如今的许多方面从未像现在这样重要。APIs用于连接政府和机构共享数据，并以协作的方式解决商业和政府问题。它们用于医生诊所和医院实时共享患者数据。当您连接到您的电子邮件并通过Microsoft
    Teams、Microsoft Azure、Amazon Web Services和Google Cloud Platform等平台与同事和客户进行协作时，您每天都在使用APIs。'
- en: Every time you chat with someone or have a video call with them using your computers
    or phones, you are using APIs. When streaming video conferences, entering a website
    technical support chat, or streaming your favorite music and videos, you are using
    APIs. So, as a programmer, it is imperative that you are well versed in what APIs
    are and how to design, develop, secure, and deploy them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您使用计算机或手机与某人聊天或进行视频通话时，您都在使用API。当流媒体视频会议、进入网站技术支持聊天或播放您喜爱的音乐和视频时，您都在使用API。因此，作为程序员，了解API是什么以及如何设计、开发、保护和部署它们是至关重要的。
- en: In this chapter, we will talk about what APIs are, how they benefit you, and
    why it is necessary to learn about them. We will also be discussing API proxies,
    design and development guidelines, how to design APIs using RAML, and how to document
    APIs using Swagger.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论API是什么，它们如何使您受益，以及为什么有必要了解它们。我们还将讨论API代理、设计和开发指南，如何使用RAML设计API以及如何使用Swagger文档API。
- en: 'The following topics are covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: What is an API?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是API？
- en: API proxies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API代理
- en: API design guidelines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API设计指南
- en: API design using RAML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RAML进行API设计
- en: Swagger API development
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger API开发
- en: 'This chapter will assist you in gaining the following skills:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助您获得以下技能：
- en: Understanding APIs and why you need to learn about them
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解API以及为什么您需要了解它们
- en: Understanding API proxies and why we use them
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解API代理以及我们为什么使用它们
- en: Being aware of design guidelines when designing your own APIs
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设计自己的API时了解设计指南
- en: Using RAML to design your own APIs
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RAML设计自己的API
- en: Using Swagger to document your APIs
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Swagger来记录您的API
- en: By the end of this chapter, you will understand the basics of good API design
    and you will be armed with the knowledge needed to push your API abilities forward. It
    is important to understand what an API is, and so that is how we shall start this
    chapter. But first, make sure that you implement the following technical requirements
    to get the most out of this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将了解良好API设计的基础，并掌握推动API能力所需的知识。了解API是什么很重要，因此我们将从这一点开始本章。但首先，请确保您实现以下技术要求，以充分利用本章。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will be using the following technologies in this chapter to create an API:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用以下技术来创建API：
- en: Visual Studio 2019 Community edition or higher
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019社区版或更高版本
- en: Swashbuckle.AspNetCore 5 or higher
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swashbuckle.AspNetCore 5或更高版本
- en: Swagger ([https://swagger.io](https://swagger.io))
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger ([https://swagger.io](https://swagger.io))
- en: Atom ([http://atom.io](http://atom.io))
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atom ([http://atom.io](http://atom.io))
- en: API Workbench by MuleSoft
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MuleSoft的API Workbench
- en: What is an API?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是API？
- en: '**APIs** are reusable libraries that can be shared between different applications
    and can be made available via REST services (in which case, they are referred
    to as **RESTful APIs**).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**APIs**是可重用的库，可以在不同应用程序之间共享，并可以通过REST服务提供（在这种情况下，它们被称为**RESTful APIs**）。'
- en: '**Representational State Transfer** (**REST**) was introduced by Roy Fielding
    in 2000.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**表述状态转移**（**REST**）由Roy Fielding于2000年引入。'
- en: 'REST is an architectural style that is made up of *constraints*. Altogether
    there are six constraints that should be considered when writing REST services.
    These constraints are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种由*约束*组成的架构风格。总共有六个约束在编写REST服务时应该考虑。这些约束如下：
- en: '**Uniform interface**: This is used to identify resources, and it manipulates
    these resources through *representation*. Messages use hypermedia and are self-descriptive. **Hypermedia
    as the Engine of Application State** (**HATEOAS**) is utilized to contain information
    about what operation can be carried out next by the client.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一接口**：用于识别资源，并通过*表示*来操作这些资源。消息使用超媒体并且是自描述的。**超媒体作为应用程序状态的引擎**（**HATEOAS**）被用来包含关于客户端可以执行的下一步操作的信息。'
- en: '**Client-server**: This constraint utilizes information hiding through *encapsulation*. So,
    only the API calls that are to be used by clients will be visible and all the
    other APIs will be kept hidden. A RESTful API should be independent of other parts
    of the system, making it loosely coupled.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器**：这个约束通过*封装*利用信息隐藏。因此，只有客户端将要使用的API调用将是可见的，所有其他API将被保持隐藏。RESTful
    API应该独立于系统的其他部分，使其松散耦合。'
- en: '**Stateless**: This states that the RESTful API has no session nor history.
    If a session or history is required by the client, then the client must provide
    all the relevant information in the request to the server.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：这表示RESTful API没有会话或历史。如果客户端需要会话或历史，那么客户端必须在请求中提供所有相关信息给服务器。'
- en: '**Cacheable**: This constraint means that resources must declare themselves
    cacheable. This means that resources can be accessed quickly. As a result, our
    RESTful API gains speed and our server load is reduced.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可缓存**：这个约束意味着资源必须声明自己是可缓存的。这意味着资源可以被快速访问。因此，我们的RESTful API变得更快，服务器负载减少。'
- en: '**Layered system**: The layered system constraint dictates that each layer
    must do one and only one thing. Each component should only know what it needs
    to use in order to function and perform its tasks. A component should not know
    about the parts of the system that it does not use.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层系统**：分层系统约束规定每个层必须只做一件事。每个组件只应知道它需要使用的内容以便进行功能和任务的执行。组件不应该了解它不使用的系统部分。'
- en: '**Optional executable code**: The executable code constraint is optional. This
    constraint determines that servers can, on a temporary basis, extend or customize
    the functionality of a client by transferring executable code.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可选的可执行代码**：可执行代码约束是可选的。此约束确定服务器可以临时扩展或自定义客户端的功能，通过传输可执行代码。'
- en: So, when designing an API, it would be prudent to assume that the end user will
    be a programmer with any level of experience. They should be able to easily obtain
    the API, read up on it, and put it to work straight away.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在设计API时，最好假设最终用户是具有任何经验水平的程序员。他们应该能够轻松获取API，阅读相关信息，并立即投入使用。
- en: Don't worry about creating the perfect API. APIs usually evolve over time anyway,
    and if you have ever worked with Microsoft APIs, you will know that they regularly
    upgrade them. APIs with features that will be removed in the future are often
    marked with an annotation that informs the user not to use a particular property
    or method as they will be removed in a future release. Then, when they will no
    longer be used, they usually get marked with an obsolete annotation before they
    are finally removed. This tells the users of the API to upgrade any apps using
    deprecated features.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心创建完美的API。API通常会随着时间的推移而不断发展，如果您曾经使用过Microsoft的API，您会知道它们经常进行升级。将来将删除的功能通常会用注释标记，告知用户不要使用特定的属性或方法，因为它们将在将来的版本中被删除。然后，当它们不再被使用时，通常会在最终删除之前用过时的注释标记进行标记。这告诉API的用户升级使用过时功能的任何应用程序。
- en: Why use REST services for API access? Well, many companies make large profits
    from making their APIs available online and charging for them. So, RESTful APIs
    can be a very valuable asset. Rapid API ([https://rapidapi.com/](https://rapidapi.com/))
    has free and paid APIs available for use.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要使用REST服务进行API访问？嗯，许多公司通过在线提供API并对其收费而获得巨大利润。因此，RESTful API可以是一项非常有价值的资产。Rapid
    API ([https://rapidapi.com/](https://rapidapi.com/))提供免费和付费的API供使用。
- en: Your APIs can remain permanently in place. If you use a cloud provider, your
    APIs can be highly scalable and you can make them generally available either for
    free or via a subscription. You can encapsulate all the complicated workings and
    expose what you need to via a simple interface, and because your APIs will be
    small and cacheable, they are very fast. Let's look now at API proxies and why
    you would use them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您的API可以永久保持在原位。如果您使用云提供商，您的API可以具有高度可扩展性，并且您可以通过免费或订阅的方式使其普遍可用。您可以通过简单的接口封装所有复杂的工作，并暴露所需的内容，因为您的API将是小型且可缓存的，所以非常快速。现在让我们来看看API代理以及为什么要使用它们。
- en: API proxies
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API代理
- en: An **API proxy** is a class that sits between the client and your API. It is,
    in essence, an API contract between you and the developers who will be using your
    API. So, rather than giving developers direct access to your API's backend services,
    which may break over time as you refactor and extend them, you provide assurance
    to the consumers of your API that the API contract will be honored, even when
    the backend services change.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**API代理**是位于客户端和您的API之间的类。它本质上是您和将使用您的API的开发人员之间的API合同。因此，与其直接向开发人员提供API的后端服务（随着您对其进行重构和扩展，可能会发生故障），不如向API的使用者提供保证，即使后端服务发生变化，API合同也将得到遵守。'
- en: 'The following diagram displays the communication between the client, an API
    proxy, the actual API being accessed, and the API''s communication with the data
    source:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了客户端、API代理、实际访问的API以及API与数据源之间的通信：
- en: '![](img/ac1cf264-d3a0-461d-9552-f325c10357bd.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac1cf264-d3a0-461d-9552-f325c10357bd.png)'
- en: A console application that shows how easy it is to implement the proxy pattern
    will be programmed in this section. Our example will have an interface that will
    be implemented by the API and the proxy. The API will return the actual message
    and the proxy will obtain the message from the API and pass it to the client.
    Proxies can also do much more than simply call the API method and return a response.
    They can perform authentication, authorization, routing based on credentials,
    and much more. However, our example will be kept to the absolute minimum so that
    you can see the simplicity in the proxy pattern.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将编写一个演示实现代理模式的控制台应用程序。我们的示例将具有一个接口，该接口将由API和代理实现。API将返回实际消息，代理将从API获取消息并将其传递给客户端。代理还可以做的远不止简单调用API方法并返回响应。它们可以执行身份验证、授权、基于凭据的路由等等。但是，我们的示例将保持在绝对最低限度，以便您可以看到代理模式的简单性。
- en: 'Start a new .NET Framework console application. Add the `Apis`, `Interfaces`,
    and `Proxies` folders and place the `HelloWorldInterface` interface into the `Interfaces` folder:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的.NET Framework控制台应用程序。添加`Apis`、`Interfaces`和`Proxies`文件夹，并将`HelloWorldInterface`接口放入`Interfaces`文件夹中：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our interface method, `GetMessage()`, returns a message as a string. Both the
    proxy and API class will implement this interface. The `HelloWorldApi` class implements
    `HelloWorldInterface`, so add it to the `Apis` folder:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的接口方法`GetMessage()`以字符串形式返回一条消息。代理和API类都将实现这个接口。`HelloWorldApi`类实现了`HelloWorldInterface`，所以将其添加到`Apis`文件夹中：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, our API class implements the interface and returns a `"Hello
    World!"` message. We have also made the class an internal class. This prevents
    external callers from being able to access the contents of this class. Now, we''ll
    add our `HelloWorldProxy` class to the `Proxies` folder:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的API类实现了接口并返回了一个`"Hello World!"`的消息。我们还将类设置为内部类。这可以防止外部调用者访问此类的内容。现在，我们将`HelloWorldProxy`类添加到`Proxies`文件夹中：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our proxy class is set to `public` as this class will be called by clients.
    The proxy class will call the `GetMessage()` method within the API class and return
    the response to the caller. All that''s left to do now is to modify our `Main()` method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代理类设置为`public`，因为此类将由客户端调用。代理类将调用API类中的`GetMessage()`方法，并将响应返回给调用者。现在剩下的事情就是修改我们的`Main()`方法：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our `Main()` class calls the `GetMessage()` method of the `HelloWorldProxy` proxy
    class. Our proxy class calls the API class and the returned method is printed
    in the console window. The console then waits for a keypress before it exits.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Main()`类调用`HelloWorldProxy`代理类的`GetMessage()`方法。我们的代理类调用API类，并将返回的方法打印在控制台窗口中。然后控制台等待按键后退出。
- en: Run the code and view the output; you have successfully implemented an API proxy
    class. You can make your proxies as simple or as complicated as they need to be,
    but what you have done here is the foundation for success.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码并查看输出；您已成功实现了API代理类。您可以使代理尽可能简单或复杂，但您在这里所做的是成功的基础。
- en: In this chapter, we will be building an API. So, let's discuss what we will
    be building, and then get going with working on it. Once you've completed the
    project, you will have a working API that generates a monthly dividend payment
    calendar in JSON format.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个API。因此，让我们讨论一下我们将要构建的内容，然后开始着手处理它。完成项目后，您将拥有一个可以生成JSON格式的月度股息支付日历的工作API。
- en: API design guidelines
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API设计指南
- en: 'There are some basic guidelines to follow to write an effective API—for example,
    your resources should use nouns in plural form. So, for example, if you had a
    wholesale website, then your URLs would look something like the following dummy
    links:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些基本的指南可供遵循，以编写有效的API—例如，您的资源应使用复数形式的名词。因此，例如，如果您有一个批发网站，那么您的URL将看起来像以下虚拟链接：
- en: '`http://wholesale-website.com/api/customers/1`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://wholesale-website.com/api/customers/1`'
- en: '`http://wholesale-website.com/api/products/20`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://wholesale-website.com/api/products/20`'
- en: The preceding URLs will follow the controller routes of `api/controller/id`.
    In terms of relationships within the business domain, these should also be reflected
    in URLs such as `http://wholesale-website.com/api/categories/12/products`—this
    call will return a list of products for category `12`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述URL将遵循`api/controller/id`的控制器路由。在业务域内的关系方面，这些关系也应反映在URL中，例如`http://wholesale-website.com/api/categories/12/products`—此调用将返回类别`12`的产品列表。
- en: If you need to use a verb as a resource, then you can do so. When making an
    HTTP request, use `GET` to retrieve items, `HEAD` to retrieve only headers, `POST` to
    insert or save a new resource, `PUT` to replace a resource, and `DELETE` to remove
    a resource. Keep resources lean by using query parameters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要将动词用作资源，则可以这样做。在进行HTTP请求时，使用`GET`检索项目，`HEAD`仅检索标头，`POST`插入或保存新资源，`PUT`替换资源，`DELETE`删除资源。通过使用查询参数使资源保持精简。
- en: 'When paginating results, a ready-made set of links should be made available
    to the client. RFC 5988 introduced **link headers**. In the specification, an **International
    Resource Identifier (IRI)** is a typed connection between two resources. For more
    information, refer to [https://www.greenbytes.de/tech/webdav/rfc5988.html](https://www.greenbytes.de/tech/webdav/rfc5988.html).
    The format of link header requests is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在分页结果时，应向客户端提供一组现成的链接。RFC 5988引入了**链接标头**。在规范中，**国际资源标识符（IRI）**是两个资源之间的类型化连接。有关更多信息，请参阅[https://www.greenbytes.de/tech/webdav/rfc5988.html](https://www.greenbytes.de/tech/webdav/rfc5988.html)。链接标头请求的格式如下：
- en: '`<https://wholesale-website.com/api/products?page=10&per_page=100>; rel="next"`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<https://wholesale-website.com/api/products?page=10&per_page=100>; rel="next"`'
- en: '`<https://wholesale-website.com/api/products?page=11&per_page=100>; rel="last"`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<https://wholesale-website.com/api/products?page=11&per_page=100>; rel="last"`'
- en: 'The versioning of your API can be done in the URL. So, each resource will have
    a different URL for the same resource, as in the following examples:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您的API的版本可以在URL中进行版本控制。因此，每个资源将具有相同资源的不同URL，如以下示例：
- en: '`https://wholesale-website.com/api/v1/cart`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://wholesale-website.com/api/v1/cart`'
- en: '`https://wholesale-website.com/api/v2/cart`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://wholesale-website.com/api/v2/cart`'
- en: This form of versioning is very simple and makes it easy to find the correct
    version of the API.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种版本控制方式非常简单，可以轻松找到正确的API版本。
- en: JSON is the preferred resource representation. It is much more human-readable
    than XML and is also lighter in size. When you are using the `POST`, `PUT`, and `PATCH` verbs,
    you should also require the content-type header to be set to application/JSON,
    or throw the `415` HTTP status code (which means unsupported media type). Gzip
    is a single-file/stream lossless data compression utility. Use Gzip by default
    to save a good percentage in bandwidth, and always set the HTTP `Accept-Encoding` header
    to `gzip`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是首选的资源表示。它比XML更易于阅读，而且体积更小。当您使用`POST`、`PUT`和`PATCH`动词时，还应要求将内容类型标头设置为application/JSON，或抛出`415`HTTP状态码（表示不支持的媒体类型）。Gzip是一种单文件/流无损数据压缩实用程序。默认使用Gzip可以节省带宽的很大比例，并始终将HTTP
    `Accept-Encoding`标头设置为`gzip`。
- en: Always use HTTPS (TLS) for your APIs. The identification of the caller should
    always be done in the header. We saw this with our API when we set the `x-api-key` header
    with our API access key. Each request should be authenticated and authorized.
    Unauthorized access should result in an `HTTP 403 Forbidden` response. Also, use
    the correct HTTP response codes. So, if a request is successful, use the `200` status
    code, for a resource that is not found, use `404`, and so on. For an exhaustive
    list of HTTP status codes, visit [https://httpstatuses.com/](https://httpstatuses.com/).
    OAuth 2.0 is the industry-standard protocol for authorization. You can read all
    about it at [https://oauth.net/2/](https://oauth.net/2/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 始终为您的API使用HTTPS（TLS）。调用者的身份验证应始终在标头中完成。我们在设置API时看到了这一点，当我们使用API访问密钥设置了`x-api-key`标头。每个请求都应进行身份验证和授权。未经授权的访问应导致`HTTP
    403 Forbidden`响应。还应使用正确的HTTP响应代码。因此，如果请求成功，请使用`200`状态代码，如果找不到资源，请使用`404`，依此类推。有关HTTP状态代码的详尽列表，请访问[https://httpstatuses.com/](https://httpstatuses.com/)。OAuth
    2.0是授权的行业标准协议。您可以在[https://oauth.net/2/](https://oauth.net/2/)上阅读有关它的所有信息。
- en: An API should provide documentation on its usage with examples. Documentation
    should always be up to date with the current version, and it should be visually
    appealing and easy to read. We'll look at Swagger to help us create documentation
    later in this chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: API应提供有关其使用的文档和示例。文档应始终与当前版本保持最新，并且应具有视觉吸引力和易于阅读。我们将在本章后面看一下Swagger，以帮助我们创建文档。
- en: You never know when your API is going to need to scale. So, this should be factored
    in from the start. In our *Dividend Calendar API* project in the next chapter,
    you will see how we implement throttling to just one API call per month on a specific
    day of the month. However, you can effectively come up with 1,001 different ways
    to throttle your APIs depending on your own needs, but this should be done at
    the start of a project. So, as soon as you start a new project, think *scalability*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您永远不知道您的API何时需要扩展。因此，这应该从一开始就考虑进去。在下一章的*股息日历API*项目中，您将看到我们如何实现限流，每月只能调用一次API，在特定日期。但是，根据您自己的需求，您可以有效地想出1001种不同的方法来限制您的API，但这应该在项目开始时完成。因此，一旦开始新项目，就要考虑*可扩展性*。
- en: For security and performance reasons, you may decide to implement an API proxy.
    An API proxy disconnects the client from accessing your API directly. A proxy
    can access an API in the same project or on an external API. By using a proxy,
    you can avoid exposing your database schema.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全和性能原因，您可能决定实现API代理。API代理将客户端与直接访问您的API断开连接。代理可以访问同一项目中的API或外部API。通过使用代理，您可以避免暴露数据库架构。
- en: Responses to the client should never match the structure of your database. This
    can act as a green light for hackers. So, avoid one-to-one mappings between database
    structures and the responses you send back to clients. You should also hide identifiers
    from your clients as they can be used to manually access data by the client.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对客户端的响应不应与数据库的结构匹配。这可能会成为黑客的绿灯。因此，应避免数据库结构和发送回客户端的响应之间的一对一映射。您还应该向客户端隐藏标识符，因为客户端可以使用它们手动访问数据。
- en: An API contains resources. A **resource** is an item that can be operated on
    in some way. Resources can be files or data. For example, students in a school
    database are resources that can be added, edited, or deleted. Video files can
    be retrieved and played, as can audio files. Images are also resources, as are
    report templates that will be opened, manipulated, and filled with data before
    they are presented to the user.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: API包含资源。**资源**是可以以某种方式操作的项目。资源可以是文件或数据。例如，学校数据库中的学生是可以添加、编辑或删除的资源。视频文件可以被检索和播放，音频文件也可以。图像也是资源，报告模板也是，它们将在呈现给用户之前被打开、操作和填充数据。
- en: Often, resources form collections of items, such as students in a school database.
    `Students` is the name of a collection of the `Student` type. Resources are accessed
    via a URL. A URL contains the path to a resource.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，资源形成项目的集合，例如学校数据库中的学生。`Students`是`Student`类型的集合的名称。可以通过URL访问资源。URL包含到资源的路径。
- en: URLs are known as **API endpoints**. An API endpoint is an address of a resource.
    This resource may be accessed by an URL with one or more parameters or an URL
    without any parameters. An URL should only contain plural nouns (names of resources)
    and should not contain verbs or actions. Parameters can be used to identify a
    single resource within a collection. Pagination should be employed if the dataset
    is going to be very large. For requests with parameters that break the URI length
    limit, you can place the parameters in the body of a `POST` request.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: URL被称为**API端点**。API端点是资源的地址。可以通过带有一个或多个参数的URL或不带任何参数的URL访问此资源。URL应该只包含复数名词（资源的名称），不应包含动词或操作。参数可用于标识集合中的单个资源。如果数据集将非常庞大，则应使用分页。对于超出URI长度限制的带参数的请求，可以将参数放在`POST`请求的正文中。
- en: Verbs form part of the HTTP request. The `POST` verb is used to add a resource.
    To retrieve one or more resources, you use the `GET` verb. `PUT` updates or replaces
    one or more resources, and `PATCH` updates or modifies a resource or collection.
    `DELETE` deletes a resource or collection.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 动词是HTTP请求的一部分。`POST`动词用于添加资源。要检索一个或多个资源，您可以使用`GET`动词。`PUT`更新或替换一个或多个资源，`PATCH`更新或修改一个资源或集合。`DELETE`删除一个资源或集合。
- en: You should always make sure you provide and respond to HTTP status codes appropriately.
    For a complete list of HTTP status codes, visit [https://httpstatuses.com/](https://httpstatuses.com/).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终确保适当地提供和响应HTTP状态代码。有关完整的HTTP状态代码列表，请访问[https://httpstatuses.com/](https://httpstatuses.com/)。
- en: As for field, method, and property names, you can use any convention you like,
    but it must be consistent and follow the company guidelines. Camel case convention
    is normally used in JSON. Since you will be developing APIs in C#, it is best
    to stick to the industry-standard C# naming conventions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 至于字段、方法和属性名称，您可以使用任何您喜欢的约定，但必须保持一致并遵循公司的指南。在JSON中通常使用驼峰命名约定。由于您将在C#中开发API，最好遵循行业标准的C#命名约定。
- en: Since your API will evolve over time, it is best to employ some form of versioning.
    Versioning allows consumers to consume specific versions of your API. This can
    be very important for providing backward compatibility when new versions of your
    API implement breaking changes. It is normally a good idea to have the version
    number, such as v1 or v2, included in the URL. Whatever method you use to version
    your APIs, just remember to be *consistent*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的API将随着时间的推移而发展，最好采用某种形式的版本控制。版本控制允许消费者使用特定版本的API。当API的新版本实施破坏性更改时，这可能非常重要以提供向后兼容性。通常最好在URL中包含版本号，如v1或v2。无论您使用什么方法来为API版本，只需记住要保持*一致*。
- en: If you will be consuming third-party APIs, you will need to keep the API keys
    secret. One way to accomplish this is to store the keys in a key vault, such as
    Azure Key Vault, which requires authentication and authorization. You should also
    secure your own APIs with a method of your choosing. A common method nowadays
    is through the use of API keys. You will see how to use API keys and Azure Key
    Vault to secure third-party keys and your own APIs in the next chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将使用第三方API，您需要保持API密钥的机密性。实现这一点的一种方法是将密钥存储在诸如Azure Key Vault之类的密钥库中，该库需要进行身份验证和授权。您还应该使用您选择的方法保护自己的API。如今一个常见的方法是通过使用API密钥。在下一章中，您将看到如何使用API密钥和Azure
    Key Vault来保护第三方密钥和您自己的API。
- en: Well-defined software boundaries
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 明确定义的软件边界
- en: Nobody in their right mind likes spaghetti code. It is very hard to read, maintain,
    and extend. So, when designing an API, you can overcome this problem with well-defined
    software boundaries. A well-defined software boundary is known as a **bounded
    context** in **Domain-Driven Design** (**DDD**). In business terms, a bounded
    context is a business operational unit, such as HR, finance, customer services,
    infrastructure, and so on. These business operational units are known as **domains**,
    and they can be broken down into smaller sub-domains. Then, these sub-domains
    can be broken down into even smaller sub-domains.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 理智的人都不喜欢意大利面代码。它很难阅读、维护和扩展。因此，在设计API时，您可以通过明确定义的软件边界来解决这个问题。在**领域驱动设计**（**DDD**）中，一个明确定义的软件边界被称为**有界上下文**。在业务术语中，有界上下文是业务运营单位，如人力资源、财务、客户服务、基础设施等。这些业务运营单位被称为**领域**，它们可以被分解成更小的子领域。然后，这些子领域可以被进一步分解成更小的子领域。
- en: By breaking a business up into business operational units, domain experts can
    be employed in those specific areas. A common language can be determined at the
    start of a project so that the business understands the IT terms and the IT staff
    understands the business terms. If the business and IT staff are language-aligned,
    there is less margin for errors due to misunderstandings from both sides.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将业务分解为业务运营单位，领域专家可以在这些特定领域受雇。在项目开始时可以确定一个共同的语言，以便业务了解IT术语，IT员工了解业务术语。如果业务和IT员工的语言是一致的，由于双方的误解，错误的余地就会减少。
- en: Having a major project broken down into sub-domains means that you can have
    smaller teams working independently on projects. So, large development teams can
    be grouped into smaller teams working concurrently on various projects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个重大项目分解为子领域意味着您可以让较小的团队独立地在项目上工作。因此，大型开发团队可以分成较小的团队，同时在各种项目上并行工作。
- en: DDD is a big subject in itself and is not covered here. However, links to more
    information are posted in the *Further reading* section of this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: DDD是一个很大的主题，本章不涉及。然而，更多信息的链接已经发布在本章的*进一步阅读*部分。
- en: The only items that should be exposed by APIs are the interfaces that form contracts
    and API endpoints. Everything else should be hidden from the subscriber and consumer.
    This means that even large databases can be broken down so that each API has its
    own database. Given how large and complex websites can be by today's standards,
    we can even have micro-services with micro-databases and micro-frontends.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: API应该暴露的唯一项目是形成合同和API端点的接口。其他所有内容都应该对订阅者和消费者隐藏。这意味着即使是大型数据库也可以被分解，以便每个API都有自己的数据库。鉴于如今标准的网站可以是多么庞大和复杂，我们甚至可以拥有微服务、微数据库和微前端。
- en: A micro-frontend is a small portion of a web page that is dynamically retrieved
    and modified according to user interactions. That frontend will interact with
    an API, which in turn will access a micro-database. This is ideal in terms of
    **Single-Page Applications** (**SPAs**).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端是网页的一个小部分，根据用户交互动态检索和修改。该前端将与一个API进行交互，而该API将访问一个微数据库。这在**单页应用程序**（**SPAs**）方面是理想的。
- en: 'SPAs are websites consisting of a single page. When a user initiates an action,
    only the required portion of the web page is updated; the rest of the page remains
    the same. So, for example, say the web page has an aside. That aside displays
    adverts. Those adverts are stored in the database as portions of HTML. The aside
    is set to auto-update itself every 5 seconds. When 5 seconds is up, the aside
    requests the API to assign a new advert. The API then uses whatever algorithm
    is in place to obtain a new advert to display from the database. The HTML document
    is then updated, and the aside is updated with the new advert. The following diagram
    shows the typical SPA life cycle:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用是由单个页面组成的网站。当用户发起操作时，只更新网页的必需部分；页面的其余部分保持不变。例如，网页有一个aside。这个aside显示广告。这些广告以HTML的形式存储在数据库中。aside被设置为每5秒自动更新一次。当5秒时间到时，aside请求API分配一个新的广告。然后API使用任何已经存在的算法从数据库中获取要显示的新广告。然后HTML文档被更新，aside也被更新为新的广告。下图显示了典型的单页应用程序生命周期：
- en: '![](img/52b9aa3b-83f9-42c3-91f9-090c0663f494.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52b9aa3b-83f9-42c3-91f9-090c0663f494.png)'
- en: 'This aside is a well-defined software boundary. It does not need to know anything
    whatsoever about the rest of the page it is displayed in. All it is concerned
    with is displaying a new advert every 5 seconds:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个aside是一个明确定义的软件边界。它不需要知道显示在其中的页面的任何内容。它所关心的只是每5秒显示一个新的广告：
- en: '![](img/5031ec6d-2f95-4332-a93f-474caa205164.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5031ec6d-2f95-4332-a93f-474caa205164.png)'
- en: The previous diagram shows an SPA communicating with a RESTful API via an API
    proxy, and the API is able to access documents and databases.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的图表显示了一个单页应用通过API代理与一个RESTful API进行通信，API能够访问文档和数据库。
- en: The only components that make up the aside are an HTML document fragment, a
    micro-service, and a database. These can be worked on by a small team in whatever
    technology that the team prefers and is comfortable with. The full SPA could be
    made up of hundreds of micro-documents, micros-services, and micro-databases.
    The key point is that these services could be made up of any technology and worked
    on independently by any team. Multiple projects could also be worked on concurrently.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 组成aside的唯一组件是HTML文档片段、微服务和数据库。这些可以由一个小团队使用他们喜欢和熟悉的任何技术来处理。完整的单页应用程序可能由数百个微文档、微服务和微数据库组成。关键点在于这些服务可以由任何技术组成，并且可以由任何团队独立工作。也可以同时进行多个项目。
- en: 'Within our bounded context, we can use the following software methodologies
    to improve the quality of our code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的边界上下文中，我们可以使用以下软件方法来提高我们代码的质量：
- en: '**The Single Responsibility**, **Open/Closed**, **Liskov**, **Interface Segregation**,
    and **Dependency Inversion** (**SOLID**) principles'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责**、**开闭**、**里氏替换**、**接口隔离**和**依赖反转**（**SOLID**）原则'
- en: '**Don''t Repeat Yourself **(**DRY**)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要重复自己**（**DRY**）'
- en: '**You Ain''t Gonna Need It **(**YAGNI**)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你不会需要它**（**YAGNI**）'
- en: '**Keep It Simple, Stupid** (**KISS**)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持简单，愚蠢**（**KISS**）'
- en: These methodologies work well together to eliminate duplicate code, prevent
    you from writing code that you don't need, and to keep objects and methods small.
    The reason why we develop for a class and a method is that they should both do
    only one thing and do it well.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法可以很好地协同工作，消除重复代码，防止编写不需要的代码，并保持对象和方法的简洁。我们为类和方法开发的原因是它们应该只做一件事，并且做得很好。
- en: Namespaces are used to perform logical groupings. We can use namespaces to define
    software boundaries. The more specific a namespace is, the more meaningful it
    is to the programmer. Meaningful namespaces help programmers to partition code
    and find what they are looking for with ease. Use namespaces to logically group
    interfaces, classes, structs, and enums.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间用于执行逻辑分组。我们可以使用命名空间来定义软件边界。命名空间越具体，对程序员越有意义。有意义的命名空间帮助程序员分割代码，并轻松找到他们正在寻找的内容。使用命名空间来逻辑分组接口、类、结构和枚举。
- en: In the next section, you will learn how to design an API using RAML. Then, you
    will generate a C# API from the RAML file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，您将学习如何使用RAML设计API。然后，您将从RAML文件生成一个C# API。
- en: Understanding the importance of good quality API documentation
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解良好质量API文档的重要性
- en: When working on a project, it is necessary to understand all the APIs that are
    already used. The reason for this is that you can often end up writing code that
    already exists, which obviously leads to wasted effort. Not only that but by writing
    your own version of code that already exists, you now have two copies of code that
    do the same thing. This adds to the complexity of the software and increases the
    maintenance overhead as both versions of the code must be maintained. It also
    adds the potential for bugs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中工作时，有必要了解已经使用的所有API。这是因为您经常会写已经存在的代码，这显然会导致浪费。不仅如此，通过编写自己版本的已经存在的代码，现在您有两份做同样事情的代码。这增加了软件的复杂性，并增加了维护开销，因为必须维护两个版本的代码。这也增加了错误的可能性。
- en: On massive projects that are spread across multiple technologies and repositories,
    with teams that have a high staff turnaround, and especially where no documentation
    exists, code duplication becomes a real problem. Sometimes, there will only be
    one or two domain experts, with the majority of the team not knowing the system
    at all. I have worked on projects like this before and they are a real pain to
    maintain and expand.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨多个技术和存储库的大型项目中，团队人员流动性高，尤其是没有文档存在的情况下，代码重复成为一个真正的问题。有时，可能只有一两个领域专家，大多数团队根本不了解系统。我以前就曾参与过这样的项目，它们真的很难维护和扩展。
- en: That is why API documentation is vital for any project, no matter how large
    or how small it is. It is inevitable in the field of software development that
    people will move on, especially when more lucrative work is offered elsewhere.
    If the person moving on is the domain expert, then they will take their knowledge
    with them. If no documentation exists, then new developers to the project will
    have a steep learning curve in understanding the project by having to read the
    code. If the code is messy and complex, this can cause a real headache for onboarding
    new staff.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么API文档对于任何项目都是至关重要的，无论其大小如何。在软件开发领域，人们会离开，尤其是在其他地方提供更有利可图的工作时。如果离开的人是领域专家，那么他们将带走他们的知识。如果没有文档存在，那么新加入项目的开发人员将不得不通过阅读代码来陡峭地学习项目。如果代码混乱复杂，这可能会给新员工带来真正的头痛。
- en: As a result, due to the lack of system knowledge, programmers will be inclined
    to more or less write the code they need from scratch to get the job done as they
    will be under pressure to deliver to the business on time. This will often lead
    to duplicate code and code reuse not being utilized. This causes the software
    to become complex and error-prone, and this kind of software ends up being hard
    to extend and maintain.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于缺乏系统知识，程序员倾向于或多或少地从头开始编写他们需要的代码以按时交付给业务。这通常会导致重复的代码和未被利用的代码重用。这会导致软件变得复杂且容易出错，这种软件最终变得难以扩展和维护。
- en: Now, you understand why APIs must be documented. A well-documented API will
    lead to greater understanding by programmers and is more inclined to get reused,
    thereby reducing the potential for code duplication and producing code that is
    hard to extend or maintain.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您了解了为什么API必须进行文档化。良好文档化的API将使程序员更容易理解，并更有可能被重复使用，从而减少了代码重复的可能性，并产生了难以扩展或维护的代码。
- en: You should also be aware of any code that is marked as deprecated or obsolete.
    Deprecated code will be removed in future releases and obsolete code is no longer
    in use. If you are using APIs that are marked as deprecated or obsolete, then
    this code should be prioritized to address first.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该注意任何标记为弃用或过时的代码。弃用的代码将在未来版本中被移除，而过时的代码已不再使用。如果您正在使用标记为弃用或过时的API，则应优先处理此代码。
- en: Now that you understand the importance of good quality API documentation, we
    will look at a tool called Swagger. Swagger is an easy-to-use tool for producing
    nice-looking, high-quality API documentation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了良好质量API文档的重要性，我们将看一下一个名为Swagger的工具。Swagger是一个易于使用的工具，用于生成外观漂亮、高质量的API文档。
- en: Swagger API development
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Swagger API开发
- en: 'Swagger provides a powerful set of tools that are focused around API development.
    With Swagger, you can do the following things:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger提供了一套围绕API开发的强大工具。使用Swagger，您可以做以下事情：
- en: '**Design**: Design your API and model it to keep up with specification-based
    standards.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计**：设计您的API并对其进行建模，以符合基于规范的标准。'
- en: '**Build**: Build an API in C# that is stable and reusable.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**：构建一个稳定且可重用的C# API。'
- en: '**Document**: Provide developers with documentation that they can interact
    with.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：为开发人员提供可以交互的文档。'
- en: '**Test**: Easily test your API.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：轻松测试您的API。'
- en: '**Standardize**: Apply constraints to your API architecture using your company
    guidelines.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准化**：使用公司指南对API架构应用约束。'
- en: We are going to get Swagger up and running in our ASP.NET Core 3.0+ project.
    So, start by creating the project in Visual Studio 2019\. Select the Web API and
    No Authentication settings. Before we continue, it is worth noting that Swagger
    automatically generates aesthetically pleasing documentation that is functional.
    Very little code is required to set up Swagger, which is why many modern APIs
    use it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在ASP.NET Core 3.0+项目中启动Swagger。因此，请在Visual Studio 2019中创建项目。选择Web API和无身份验证设置。在我们继续之前，值得注意的是，Swagger会自动生成外观漂亮且功能齐全的文档。设置Swagger所需的代码非常少，这就是为什么许多现代API使用它的原因。
- en: 'Before we can use Swagger, we first need to install support for it in our project.
    To install Swagger, you must install version 5 or higher of the `Swashbuckle.AspNetCore` dependency
    package. As of the time of writing, the version available on NuGet is version
    5.3.3\. After the installation is complete, we need to add the Swagger services
    that we will be using to the services collection. In our case, we will only be
    using Swagger to document our API. In the `Startup.cs` class, add the following
    line to the `ConfigureServices()` method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用Swagger之前，我们首先需要在项目中安装对其的支持。要安装Swagger，您必须安装`Swashbuckle.AspNetCore`依赖包的5版或更高版本。截至撰写本文时，NuGet上可用的版本是5.3.3。安装完成后，我们需要将要使用的Swagger服务添加到服务集合中。在我们的情况下，我们只会使用Swagger来记录我们的API。在`Startup.cs`类中，将以下行添加到`ConfigureServices()`方法中：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the code we''ve just added, the Swagger documenting service has been assigned
    to the services collection. Our API version is `v1` and our API title is `Weather
    Forecast API`. We now need to update the `Configure()` method to add our Swagger
    middleware, as follows, immediately after the `if` statement:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚添加的代码中，Swagger文档服务已分配给了服务集合。我们的API版本是`v1`，API标题是`Weather Forecast API`。现在我们需要更新`Configure()`方法，在`if`语句之后立即添加我们的Swagger中间件，如下所示：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In our `Configure()` method, we are informing our app to use Swagger and the
    Swagger UI, and we assign our Swagger endpoint for `Weather Forecast API`. Next,
    you will need to install the `Swashbuckle.AspNetCore.Newtonsoft` NuGet dependency
    package (version 5.3.3, as of the time of writing). Then, add the following line
    to your `ConfigureServices()` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Configure()`方法中，我们正在通知我们的应用程序使用Swagger和Swagger UI，并为`Weather Forecast API`分配我们的Swagger端点。接下来，您需要安装`Swashbuckle.AspNetCore.Newtonsoft`NuGet依赖包（截至撰写本文时的版本为5.3.3）。然后，将以下行添加到您的`ConfigureServices()`方法中：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We added Newtonsoft support for our Swagger documentation generation. That
    is all there is to getting Swagger up and running. So, run your project and navigate
    to `https://localhost:PORT_NUMBER/swagger/index.html`. You should see the following
    web page:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的Swagger文档生成添加了Newtonsoft支持。这就是使Swagger运行起来的全部内容。因此，运行你的项目，然后导航到`https://localhost:PORT_NUMBER/swagger/index.html`。你应该看到以下网页：
- en: '![](img/4628e779-2c78-41dc-acad-7caea58b65fa.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4628e779-2c78-41dc-acad-7caea58b65fa.png)'
- en: We will now take a look at why we should pass immutable structs instead of mutable
    objects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一下为什么我们应该传递不可变的结构而不是可变的对象。
- en: Passing immutable structs instead of mutable objects
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递不可变的结构而不是可变的对象
- en: In this section, you are going to write a computer program that processes 1
    million objects and 1 million immutable structs. You will see how much quicker,
    in terms of performance, structs are over objects. We will be writing some code
    that processes 1 million objects in 1,440 milliseconds and processes 1 million
    structs in 841 milliseconds. That is a difference of 599 milliseconds. Such a
    small unit of time might not sound like a lot, but when working with massive datasets,
    you will see big performance improvements when using immutable structs over mutable
    objects.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将编写一个计算机程序，处理100万个对象和100万个不可变的结构。你将看到在性能方面，结构比对象更快。我们将编写一些代码，处理100万个对象需要1440毫秒，处理100万个结构需要841毫秒。这是599毫秒的差异。这样一个小的时间单位听起来可能不多，但当处理大型数据集时，使用不可变的结构而不是可变的对象将会带来很大的性能改进。
- en: Values in mutable objects can also be modified between threads, which can be
    very bad for business. Imagine having £15,000 in your bank account and you pay
    your landlord £435 in rent. Your account has an overdraft limit that can be exceeded.
    Now, at the same time that you are paying £435, someone else is paying a car firm
    £23,000 for a new car. The value on your account is modified by the car purchaser's
    thread. So, you end up paying your landlord £23,000, leaving your bank balance
    £8,000 in debt. We won't code an example of mutable data being changed between
    threads as this was covered in [Chapter 8](21b5d748-3720-4bea-a03c-5420862c01b3.xhtml),
    *Threading and Concurrency*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象中的值也可以在线程之间修改，这对业务来说可能非常糟糕。想象一下你的银行账户里有15000英镑，你支付房东435英镑的房租。你的账户有一个可以透支的限额。现在，在你支付435英镑的同时，另一个人正在支付23000英镑给汽车公司买一辆新车。汽车购买者的线程修改了你账户上的值。因此，你最终支付给房东23000英镑，使你的银行余额欠8000英镑。我们不会编写一个可变数据在线程之间被修改的示例，因为这在[第8章](21b5d748-3720-4bea-a03c-5420862c01b3.xhtml)中已经涵盖过了，*线程和并发*。
- en: The key points of this section are that structs are faster than objects and
    immutable structs are thread-safe.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的要点是，结构比对象更快，不可变的结构是线程安全的。
- en: When creating and passing objects, structs are more performant than objects.
    You can also make structs immutable so that they are thread-safe. Here, we will
    write a small program. This program will have two methods—one will create 1 million
    person objects and the other will create 1 million person structures.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建和传递对象时，结构比对象更高效。你也可以使结构不可变，这样它们就是线程安全的。在这里，我们将编写一个小程序。这个程序将有两个方法——一个将创建100万个人对象，另一个将创建100万个人结构。
- en: 'Add a new .NET Framework console application called `CH11_WellDefinedBoundaries` and
    the following `PersonObject` class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的.NET Framework控制台应用程序，名为`CH11_WellDefinedBoundaries`，以及以下`PersonObject`类：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This object will be used to create 1 million people objects. Now, add the `PersonStruct`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象将用于创建100万个人对象。现在，添加`PersonStruct`：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This struct is immutable, with the `readonly` properties being set via the
    constructor and used to create our 1 million structs. Now, we can modify the program
    to show the performance between object and struct creation. Add the `CreateObject()` method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构是不可变的，`readonly`属性是通过构造函数设置的，并用于创建我们的100万个结构。现在，我们可以修改程序来显示对象和结构创建之间的性能。添加`CreateObject()`方法：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, we start a stopwatch, create a new list, and add 1 million
    person objects to the list. We then stop the stopwatch, output the results to
    the window, and then call the garbage collector to clean up our resources. Let''s
    now add our `CreateStructs()` method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们启动了一个秒表，创建了一个新列表，并向列表中添加了100万个人对象。然后我们停止了秒表，将结果输出到窗口，然后调用垃圾收集器来清理我们的资源。现在让我们添加我们的`CreateStructs()`方法：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our structure does a similar thing here as for the `CreateObjects()` methods,
    but creates a list of structs and adds 1 million structs to the list. Finally,
    modify the `Main()` method, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结构在这里做了与`CreateObjects()`方法类似的事情，但是创建了一个结构列表，并向列表中添加了100万个结构。最后，修改`Main()`方法，如下所示：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We call both of our methods and then wait for the user to press any key before
    we exit. Run the program and you should see the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用我们的两种方法，然后等待用户按任意键退出。运行程序，你应该看到以下输出：
- en: '![](img/e5264597-6436-4a94-8ef7-6175e9f9350d.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5264597-6436-4a94-8ef7-6175e9f9350d.png)'
- en: As you can see from the previous screenshot, it took 1,440 milliseconds to create
    1 million objects and add them to a list of objects, and only 841 milliseconds
    to create 1 million structs and add them to a list of structs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从之前的截图中所看到的，创建100万个对象并将它们添加到对象列表中花费了1,440毫秒，而创建100万个结构并将它们添加到结构列表中只花费了841毫秒。
- en: So, not only are you able to make structs immutable and thread-safe as they
    cannot be modified between threads, but they also perform a lot faster when compared
    to objects. Therefore, if you are dealing with large amounts of data, structs
    can save you a lot of processing time. Not only that but if you are charged per
    cycle of execution time by your cloud computing service, then using structs over
    objects is going to save you money.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不仅可以使结构不可变和线程安全，因为它们不能在线程之间修改，而且与对象相比，它们的性能也更快。因此，如果你正在处理大量数据，结构可以节省大量处理时间。不仅如此，如果你的云计算服务按执行时间计费，那么使用结构而不是对象将为你节省金钱。
- en: Let's now have a look at writing third-party API tests for the APIs that you
    will be using.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看为将要使用的API编写第三方API测试。
- en: Testing third-party APIs
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试第三方API
- en: 'You may ask "*Why should I test third-party APIs*?" Well, that is a good question.
    The reason why you should test third-party APIs is that just like your own code,
    third-party code is susceptible to programming errors. I remember once running
    into some real difficulty on a document processing website I was building for
    a law firm. After much investigation, I found the problem was down due to faulty
    JavaScript embedded in the Microsoft API that I was using. The following screenshot
    is of the GitHub Issues page for the Microsoft Cognitive Toolkit, which has 738 outstanding issues:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我应该测试第三方API呢？这是一个很好的问题。你应该测试第三方API的原因是，就像你自己的代码一样，第三方代码也容易出现编程错误。我记得曾经在为一家律师事务所建立的文件处理网站上遇到了一些真正困难。经过多次调查，我发现问题是由于我使用的Microsoft
    API中嵌入的有错误的JavaScript导致的。下面的截图是Microsoft认知工具包的GitHub Issues页面，其中有738个未解决的问题：
- en: '![](img/140266fd-a189-4b3a-8816-e41df0518541.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/140266fd-a189-4b3a-8816-e41df0518541.png)'
- en: As you can see from the Microsoft Cognitive Toolkit, third-party APIs do have
    issues. That means as the programmer, the onus is on you to ensure that the third-party
    APIs that you employ work as expected. Should you encounter any bugs, then it
    is good practice to inform the third party of the bugs. If the API is open source
    and you have access to the source code, you can even check out the code and submit
    your own fixes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从Microsoft认知工具包中看到的，第三方API确实存在问题。这意味着作为程序员，你有责任确保你使用的第三方API能够正常工作。如果遇到任何bug，那么告知第三方是一个良好的做法。如果API是开源的，并且你可以访问源代码，甚至可以检查代码并提交你自己的修复。
- en: Whenever you encounter bugs in third-party code that will not be addressed in
    time for you to meet your deadlines, then one option you have available to you
    is to write a **wrapper class**that has all the same constructors, methods, and
    properties and makes them call the same constructors, methods, and properties
    on the third-party class, with the exception that you write your own bug-free
    version of the third-party property or method that has the bug in it. [Chapter
    11](c9f56c87-1d5a-45e1-b03c-30a2fb9f7713.xhtml), *Addressing Cross-Cutting Concerns*,
    provides sections on the proxy pattern and decorator pattern, which will help
    you write wrapper classes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你在第三方代码中遇到bug，而这些bug又无法及时解决以满足你的截止日期时，你可以选择编写一个**包装类**，该类具有与第三方类相同的构造函数、方法和属性，并使它们调用第三方类上的相同构造函数、方法和属性，但你需要编写第三方属性或方法的无bug版本。[第11章](c9f56c87-1d5a-45e1-b03c-30a2fb9f7713.xhtml)，“解决横切关注点”，提供了关于代理模式和装饰器模式的部分，这将帮助你编写包装类。
- en: Testing your own APIs
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你自己的API
- en: In [Chapter 6](ba53f821-d126-4fba-89a8-c148233510c1.xhtml), *Unit Testing,*
    and [Chapter 7](ab872898-c782-4edc-bc4f-d0ec85592dfa.xhtml), *End-to-End System
    Testing*, you saw, with code examples, how to test your own code. You should always
    test your own APIs as it is important to have complete trust in the quality of
    your APIs. Therefore, as a programmer, you should always unit test your code before
    you pass it on to quality assurance. Quality assurance should then run integration
    and regression testing on the API to ensure it meets the company's agreed level
    of quality.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ba53f821-d126-4fba-89a8-c148233510c1.xhtml)，“单元测试”，和[第7章](ab872898-c782-4edc-bc4f-d0ec85592dfa.xhtml)，“端到端系统测试”中，你看到了如何测试你自己的代码，还有代码示例。你应该始终测试自己的API，因为对API的质量完全信任是很重要的。因此，作为程序员，你应该在交付给质量保证之前对代码进行单元测试。质量保证应该进行集成和回归测试，以确保API达到公司约定的质量水平。
- en: Your API may do exactly what the business has asked for and be perfect without
    bugs; but when it's integrated with the system, do peculiar things happen that
    you were unable to test for in certain situations? Often, I have encountered situations
    in development teams where code will work on one person's computer but not on
    other computers. Yet, there often seems to be no logical reason for this to be
    the case. These problems can be incredibly frustrating and even time-consuming
    to get to the bottom of. But you want these problems to be ironed out before you
    pass on your code for quality assurance, and most definitely before it is released
    into production. Having to deal with customer bugs is not always a pleasant experience.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你的API可能完全符合业务要求，没有bug；但当它与系统集成时，在某些情况下会发生你无法测试的奇怪情况吗？在开发团队中，我经常遇到这样的情况，代码在一个人的电脑上可以工作，但在其他电脑上却不能。然而，这似乎并没有逻辑上的原因。这些问题可能会非常令人沮丧，甚至需要花费大量时间才能找到问题的根源。但你希望在将代码交给质量保证之前解决这些问题，而且在发布到生产环境之前更是如此。处理客户bug并不总是一种愉快的经历。
- en: 'Testing your programs should involve the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的程序应该包括以下内容：
- en: When given the correct range of values, the method under test outputs the correct
    result.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当给定正确的值范围时，被测试的方法会输出正确的结果。
- en: When given the incorrect range of values, the method provides the appropriate
    response without crashing.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当给定不正确的值范围时，该方法会提供适当的响应而不会崩溃。
- en: Remember that your API should only include what the business has asked for and
    should not make the internal details accessible to clients. This is where the
    product backlog, which is part of the Scrum project management methodology, is
    useful.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你的API应该只包括业务要求，并且不应该使内部细节对客户可见。这就是Scrum项目管理方法中的产品积压的用处。
- en: 'The product backlog is the list of new features and technical debts that you
    and your team will be working on. Each item in the product backlog will have a
    description and acceptance criteria, as shown in the following screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 产品积压是你和你的团队将要处理的新功能和技术债务的列表。产品积压中的每个项目都将有描述和验收标准，如下图所示：
- en: '![](img/550047ec-c17e-4810-9076-a1eb5ea19ee0.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/550047ec-c17e-4810-9076-a1eb5ea19ee0.png)'
- en: 'You write your unit tests around the acceptance criteria. Your tests will include
    the normal path of execution and abnormal paths of execution. Using this screenshot
    as an example, we have two acceptance criteria:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你的单元测试是围绕验收标准编写的。你的测试将包括正常执行路径和异常执行路径。以这个截图为例，我们有两个验收标准：
- en: Data is successfully obtained from third-party APIs.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功从第三方API获取数据。
- en: Data is successfully stored in Cosmos DB.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据已成功存储在Cosmos DB中。
- en: In these two acceptance criteria, we know we will be calling APIs that obtain
    data. That data will be obtained from third parties. Once obtained, the data will
    then be stored in the database. On the face of it, this specification that we
    have to work with is quite vague. In real life, I have found that this is often
    the case.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个验收标准中，我们知道我们将调用获取数据的API。这些数据将来自第三方。一旦获取，数据将存储在数据库中。从表面上看，我们必须处理的这个规范相当模糊。在现实生活中，我发现这种情况经常发生。
- en: Given the vagueness of the specification, we will make the assumption that the
    specification will be generic and will apply to different API calls, and we can
    assume that the data returned is JSON data. We will also make the assumption that
    the returned JSON data will be stored in its raw form in a Cosmos DB database.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于规范的模糊性，我们将假设规范是通用的，并适用于不同的API调用，并且我们可以假设返回的数据是JSON数据。我们还假设返回的JSON数据将以其原始形式存储在Cosmos
    DB数据库中。
- en: 'So, what tests can we write for our first acceptance criteria? Well, we can
    write the following test cases:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们可以为我们的第一个验收标准写什么测试？嗯，我们可以写以下测试用例：
- en: When given an URL with a parameter list, assert that we receive a status of
    `200` and JSON returned for a `GET` request when all the correct information is
    supplied.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当给定一个带参数列表的URL时，断言当提供所有正确的信息时，我们会收到`200`的状态和`GET`请求返回的JSON。
- en: Assert that we receive a status of `401` when an unauthorized `GET` request
    has been made.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当未经授权的`GET`请求被发出时，我们会收到`401`的状态。
- en: Assert that we receive a status of `403` when the authenticated user is forbidden
    from accessing the resource.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言当经过身份验证的用户被禁止访问资源时，我们会收到`403`的状态。
- en: Assert that we receive a status of `500` when the server is down.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当服务器宕机时，我们会收到`500`的状态。
- en: 'What tests can we write for our second acceptance criteria? Well, we can write
    the following test cases:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为我们的第二个验收标准写什么测试？嗯，我们可以写以下测试用例：
- en: Assert that unauthorized access to the database is denied.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言拒绝对数据库的未经授权访问。
- en: Assert that the API handles cases where the database is unavailable gracefully.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言API在数据库不可用的情况下能够优雅地处理。
- en: Assert that authorized access to the database is granted.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言授予对数据库的授权访问。
- en: Assert that JSON insertion into the database succeeds.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言JSON插入数据库成功。
- en: So, even from such a vague specification, we have been able to obtain eight
    test cases. Between them, all these cases test for a successful roundtrip to the
    third-party server and back, and then into the database. They also test for various
    points at which the process could fail. If all of these tests pass, we have complete
    confidence in our code and that it will pass quality control when it leaves our
    hands as developers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使从如此模糊的规范中，我们已经能够获得八个测试用例。在它们之间，所有这些情况都测试了成功地往返到第三方服务器，然后进入数据库。它们还测试了过程可能失败的各个点。如果所有这些测试都通过，我们对我们的代码完全有信心，并且在离开我们作为开发人员的手时，它将通过质量控制。
- en: In the next section, we will look at how to design APIs using RAML.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何使用RAML设计API。
- en: API design using RAML
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RAML进行API设计
- en: In this section, we will discuss designing an API using RAML. You can gain in-depth
    knowledge about all aspects of RAML from the RAML website ([https://raml.org/developers/design-your-api](https://raml.org/developers/design-your-api)). We
    are going to learn the basics of RAML by designing a really simple API using API
    Workbench in Atom. We'll start with the installation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论使用RAML设计API。你可以从RAML网站([https://raml.org/developers/design-your-api](https://raml.org/developers/design-your-api))获得关于RAML各个方面的深入知识。我们将通过在Atom中使用API
    Workbench设计一个非常简单的API来学习RAML的基础知识。我们将从安装开始。
- en: The first step is to install the packages.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是安装软件包。
- en: Installing Atom and API Workbench by MuleSoft
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Atom和MuleSoft的API Workbench
- en: 'Let''s see how to do that:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何做到这一点：
- en: Start by installing Atom from [http://atom.io](http://atom.io).
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://atom.io](http://atom.io)安装Atom。
- en: 'Then, click on Install a Package:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击`Install a Package`：
- en: '![](img/84999249-f95c-43c6-8dc7-293851edc1a8.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84999249-f95c-43c6-8dc7-293851edc1a8.png)'
- en: 'Then, search for `api-workbench by mulesoft` and install it:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后搜索`api-workbench by mulesoft`并安装它：
- en: '![](img/a16b724d-e6d1-46b8-8733-c5a57095c552.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a16b724d-e6d1-46b8-8733-c5a57095c552.png)'
- en: The installation is successful if you find it listed under Packages | Installed
    Packages.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在`Packages`|`Installed Packages`下找到它，安装就成功了。
- en: Now that we've installed the packages, let's move onto creating the project.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了软件包，让我们继续创建项目。
- en: Creating the project
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Let''s see how to go about this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何做到这一点：
- en: Click File | Add Project Folder.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`File`|`Add Project Folder`。
- en: Create a new folder or select an existing one. I will create a new folder called `C:\Development\RAML` and
    open it.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件夹或选择一个现有的文件夹。我将创建一个名为`C:\Development\RAML`的新文件夹并打开它。
- en: Add a new file to your project folder called `Shop.raml`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目文件夹中添加一个名为`Shop.raml`的新文件。
- en: Right-click in the file and select Add New | Create New API.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击文件，然后选择`Add New`|`Create New API`。
- en: Give it any name you want and then click on Ok. You have now just created your
    first API design.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给它任何你想要的名字，然后点击`Ok`。你现在刚刚创建了你的第一个API设计。
- en: 'If you look at the RAML file, you will see that its contents are in human-readable
    text. The API we''ve just created contains a simple `GET` command that returns
    a string that contains the words `"Hello World"`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下RAML文件，你会发现它的内容是人类可读的文本。我们刚刚创建的API包含一个简单的`GET`命令，返回一个包含单词`"Hello World"`的字符串：
- en: '[PRE12]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is RAML code. You will see that it is pretty similar to JSON in that the
    code is simple, human-readable code that is indented. Delete the file. From the Packages menu,
    select API Workbench | Create RAML Project. Fill out the Create RAML Project dialog,
    as in the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是RAML代码。您会看到它与JSON非常相似，因为代码是简单的、可读的代码，它是缩进的。删除文件。从“包”菜单中，选择“API Workbench |
    创建RAML项目”。填写“创建RAML项目”对话框，如下面的屏幕截图所示：
- en: '![](img/cdb8093f-1fe4-48c7-a255-488bffe88415.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdb8093f-1fe4-48c7-a255-488bffe88415.png)'
- en: 'The settings in this dialog will produce the following RAML code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此对话框中的设置将生成以下RAML代码：
- en: '[PRE13]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The main difference between the last RAML file and the first one you viewed
    is the insertion of the `version` and `baseUri` properties. These settings also
    update your Project folder''s content, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您查看的最后一个RAML文件和第一个RAML文件之间的主要区别是插入了“version”和“baseUri”属性。这些设置还会更新您的“Project”文件夹的内容，如下所示：
- en: '![](img/edc9a28c-8900-4cb1-b1e7-2f21a28d954f.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edc9a28c-8900-4cb1-b1e7-2f21a28d954f.png)'
- en: For a very detailed tutorial on this subject, head on over to[ ](http://apiworkbench.com/docs/)[http://apiworkbench.com/docs/](http://apiworkbench.com/docs/).
    This URL also provides details on how to add resources and methods; fill method
    bodies and responses; add sub-resources; add examples and types; create and extract
    resource types; add resource type parameters, method parameters, and traits; reuse
    traits, resource types, and libraries; add more types and resources; extract libraries;
    and much more than we can cover in this chapter.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的非常详细的教程，请访问[http://apiworkbench.com/docs/](http://apiworkbench.com/docs/)。此URL还提供了如何添加资源和方法、填写方法体和响应、添加子资源、添加示例和类型、创建和提取资源类型、添加资源类型参数、方法参数和特性、重用特性、资源类型和库、添加更多类型和资源、提取库等详细信息，远远超出了本章的范围。
- en: Now that we have a design that is language implementation-agnostic, how do we
    generate our API in C#?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有了一个与语言实现无关的设计，那么我们如何在C#中生成我们的API呢？
- en: Generating our C# API from our agnostic RAML design specification
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从我们的通用RAML设计规范生成我们的C# API
- en: 'You will need to have, as a minimum, Visual Studio 2019 Community edition installed.
    Then, make sure you close Visual Studio. Also, download and install the Visual
    Studio `MuleSoftInc.RAMLToolsforNET` tool. With these tools installed, we will
    now proceed through the steps required to produce the skeleton framework of our
    previously specified API. This will be accomplished by adding a RAML/OAS contract
    and importing our RAML file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您至少需要安装Visual Studio 2019社区版。然后确保关闭Visual Studio。还要下载并安装Visual Studio的`MuleSoftInc.RAMLToolsforNET`工具。安装了这些工具后，我们现在将按照生成我们先前指定的API的骨架框架所需的步骤进行。这将通过添加RAML/OAS合同并导入我们的RAML文件来实现：
- en: In Visual Studio 2019, create a new .NET Framework console application.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2019中，创建一个新的.NET Framework控制台应用程序。
- en: 'Right-click on the project and select Add RAML/OAS Contract. This will open
    the following dialog:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目，选择“添加RAML/OAS合同”。这将打开以下对话框：
- en: '![](img/bacd4cb7-ca52-41c2-904c-35491f7cd8bf.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bacd4cb7-ca52-41c2-904c-35491f7cd8bf.png)'
- en: 'Click on Upload, and then select your RAML file. The Import RAML/OAS dialog
    will then be presented. Fill the dialog out as shown and then click on Import:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“上传”，然后选择您的RAML文件。然后将呈现“导入RAML/OAS”对话框。填写对话框如下所示，然后点击“导入”：
- en: '![](img/5944bca4-a050-46f6-880f-d0ee6aefb58d.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5944bca4-a050-46f6-880f-d0ee6aefb58d.png)'
- en: 'Your project will now be updated with the required dependencies, and new folders
    and files will be added to your console application. You will notice three root
    folders, called `Contracts`, `Controllers`, and `Models`. In the `Contracts` folder,
    we have our RAML file and the `IV1HelloWorldController` interface. It contains
    one method: `Task<IHttpActionResult> Get()`. The `v1HelloWorldController` class
    implements the `Iv1HelloWorldController` interface. Let''s have a look at the
    implemented `Get()` method in the controller class:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目现在将使用所需的依赖项进行更新，并且新的文件夹和文件将被添加到您的控制台应用程序中。您将注意到三个根文件夹，称为“Contracts”、“Controllers”和“Models”。在“Contracts”文件夹中，我们有我们的RAML文件和“IV1HelloWorldController”接口。它包含一个方法：“Task<IHttpActionResult>
    Get()”。v1HelloWorldController类实现了Iv1HelloWorldController接口。让我们来看看控制器类中实现的`Get()`方法：
- en: '[PRE14]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, we can see that the code comments out the instantiation
    of the `HelloWorldGet200` class and the returned result. The `HelloWorldGet200` class
    is our model class. We can update our model to whatever data we want it to contain.
    In our simple example, we won''t bother too much with this; we will just return
    the `"Hello World!"` string. Update the uncommented line to the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们可以看到代码注释掉了`HelloWorldGet200`类的实例化和返回结果。`HelloWorldGet200`类是我们的模型类。我们可以更新我们的模型，使其包含我们想要的任何数据。在我们的简单示例中，我们不会太过于烦恼；我们只会返回`"Hello
    World!"`字符串。将取消注释的行更新为以下内容：
- en: '[PRE15]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Ok()` method returns a type of `OkNegotiatedContentResult<T>`. We will
    call this `Get()` method from our `Main()` method in the `Program` class. Update
    the `Main()` method, as shown:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: “Ok()`方法返回`OkNegotiatedContentResult<T>`类型。我们将从`Program`类中的`Main()`方法中调用此`Get()`方法。更新`Main()`方法，如下所示：
- en: '[PRE16]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we are running asynchronous code in a static method, we must add the work
    to the thread pool queue. We then execute our code and wait for the result. Once
    the code returns, we simply wait for a keypress and then exit.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在静态方法中运行异步代码，因此我们必须将工作添加到线程池队列中。然后执行我们的代码并等待结果。一旦代码返回，我们只需等待按键，然后退出。
- en: We have created an MVC API within a console app and executed API calls based
    on the RAML file that we imported. This same process works for the ASP.NET and
    ASP.NET Core websites. We will now extract RAML from an existing API.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在控制台应用程序中创建了一个MVC API，并根据我们导入的RAML文件执行了API调用。这个过程对于ASP.NET和ASP.NET Core网站也适用。现在我们将从现有API中提取RAML。
- en: 'Load the dividend calendar API project from earlier on in this chapter. Then,
    right-click on the project and select Extract RAML. Then, once the extraction
    has finished, run your project. Change the URL to `https://localhost:44325/raml`. When
    you extract RAML, the code generation process adds a `RamlController` class to
    your project, along with a RAML view. You will see that your API is now documented,
    as shown in the RAML view:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章前面的股息日历API项目中加载。然后，右键单击该项目并选择提取RAML。然后，一旦提取完成，运行您的项目。将URL更改为`https://localhost:44325/raml`。提取RAML时，代码生成过程会向您的项目添加一个`RamlController`类，以及一个RAML视图。您将看到您的API现在已经记录在案，如RAML视图所示：
- en: '![](img/dccb261d-f9c4-4b26-b0ed-5ac073ed5dd3.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dccb261d-f9c4-4b26-b0ed-5ac073ed5dd3.png)'
- en: By using RAML, you can design an API and then generate the structure and you
    can reverse engineer an API. The RAML specification helps you design your API
    and make changes by modifying the RAML code. You can view the [http://raml.org](http://raml.org) website
    for more information on how to get the most out of the RAML specification if you
    want to know more. We'll now have a look at Swagger and how to use it in ASP.NET
    Core 3+ projects.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用RAML，您可以设计一个API，然后生成结构，也可以反向工程一个API。RAML规范帮助您设计API，并通过修改RAML代码进行更改。如果您想了解更多信息，可以查看[http://raml.org](http://raml.org)网站，以了解如何充分利用RAML规范。现在，让我们来看看Swagger以及如何在ASP.NET
    Core 3+项目中使用它。
- en: Well, we've now reached the end of this chapter. Now, we will summarize what
    we have achieved and learned.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们现在已经到了本章的结尾。现在，我们将总结我们所取得的成就和所学到的知识。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed what an API is. Then, we looked at how we can
    use API proxies as contracts between ourselves and the consumers of our APIs.
    This protects our APIs from direct access by third parties. Next, we looked at
    a number of design guidelines for improving the quality of our APIs.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了API是什么。然后，我们看了如何使用API代理作为我们和API使用者之间的合同。这可以保护我们的API免受第三方的直接访问。接下来，我们看了一些改进API质量的设计准则。
- en: We then went on to discuss Swagger and saw how to document the Weather API with
    Swagger. Testing APIs was then covered, and we saw why it is good to test your
    code and any third-party code that you use in your projects. Finally, we looked
    at designing a language-agnostic API using RAML and translated it into a working
    project using C#.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了Swagger，并了解了如何使用Swagger记录天气API。然后介绍了测试API，并看到了为什么测试您的代码以及您在项目中使用的任何第三方代码是有益的。最后，我们看了如何使用RAML设计一个与语言无关的API，并将其翻译成一个使用C#的工作项目。
- en: In the next chapter, we will write a project to demonstrate securing keys using
    Azure Key Vault and securing our own API using API keys. But before then, let's
    put your brain to work to see what you have learned.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将编写一个项目来演示如何使用Azure Key Vault保护密钥，并使用API密钥保护我们自己的API。但在那之前，让我们让您的大脑运转一下，看看您学到了什么。
- en: Questions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does API stand for?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API代表什么？
- en: What does REST stand for?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST代表什么？
- en: What are the six constraints of REST?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST的六个约束是什么？
- en: What does HATEOAS stand for?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HATEOAS代表什么？
- en: What is RAML?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RAML是什么？
- en: What is Swagger?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swagger是什么？
- en: What is meant by the term **well-defined software boundary**?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 术语“良好定义的软件边界”是什么意思？
- en: Why should you understand the APIs that you are using?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么您应该了解您正在使用的API？
- en: What performs better—structs or objects?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构体和对象哪个性能更好？
- en: Why should you test third-party APIs?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该测试第三方API？
- en: Why should you test your own APIs?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该测试您自己的API？
- en: How can you determine what tests to write for your code?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何确定要为您的代码编写哪些测试？
- en: Name three ways to organize code into well-defined software boundaries.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举三种将代码组织成良好定义的软件边界的方法。
- en: Further reading
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://weblogs.asp.net/sukumarraju/asp-net-web-api-testing-using-nunit-framework](https://weblogs.asp.net/sukumarraju/asp-net-web-api-testing-using-nunit-framework) provides
    a complete example of using NUnit to test web APIs.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://weblogs.asp.net/sukumarraju/asp-net-web-api-testing-using-nunit-framework](https://weblogs.asp.net/sukumarraju/asp-net-web-api-testing-using-nunit-framework)提供了使用NUnit测试Web
    API的完整示例。'
- en: '[https://raml.org/developers/design-your-api](https://raml.org/developers/design-your-api) shows
    you how to design your API with RAML.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://raml.org/developers/design-your-api](https://raml.org/developers/design-your-api)展示了如何使用RAML设计您的API。'
- en: '[http://apiworkbench.com/docs/](http://apiworkbench.com/docs/) provides documentation
    on using RAML in Atom to design your APIs.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://apiworkbench.com/docs/](http://apiworkbench.com/docs/)提供了在Atom中使用RAML设计API的文档。'
- en: '[https://dotnetcoretutorials.com/2017/10/19/using-swagger-asp-net-core/](https://dotnetcoretutorials.com/2017/10/19/using-swagger-asp-net-core/) is
    a good introduction to using Swagger.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dotnetcoretutorials.com/2017/10/19/using-swagger-asp-net-core/](https://dotnetcoretutorials.com/2017/10/19/using-swagger-asp-net-core/)是使用Swagger的很好的介绍。'
- en: '[https://swagger.io/about/](https://swagger.io/about/) takes you to the Swagger
    About page.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://swagger.io/about/](https://swagger.io/about/)带您到Swagger关于页面。'
- en: '[https://httpstatuses.com/](https://httpstatuses.com/) is a list of HTTP status
    codes.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://httpstatuses.com/](https://httpstatuses.com/)是HTTP状态代码列表。'
- en: '[https://www.greenbytes.de/tech/webdav/rfc5988.html](https://www.greenbytes.de/tech/webdav/rfc5988.html) is
    the web linking specification RFC 5988.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.greenbytes.de/tech/webdav/rfc5988.html](https://www.greenbytes.de/tech/webdav/rfc5988.html)是RFC
    5988的Web链接规范。'
- en: '[https://oauth.net/2/](https://oauth.net/2/) takes you to the OAuth 2.0 home
    page.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://oauth.net/2/](https://oauth.net/2/)带您到OAuth 2.0主页。'
- en: '[https://en.wikipedia.org/wiki/Domain-driven_design](https://en.wikipedia.org/wiki/Domain-driven_design) is
    the Wikipedia page for domain-driven design.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Domain-driven_design](https://en.wikipedia.org/wiki/Domain-driven_design)是领域驱动设计的维基百科页面。'
- en: '[https://www.packtpub.com/gb/application-development/hands-domain-driven-design-net-core](https://www.packtpub.com/gb/application-development/hands-domain-driven-design-net-core) provides
    information on the *Hands-On Domain-Driven Design with .NET Core* book.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/gb/application-development/hands-domain-driven-design-net-core](https://www.packtpub.com/gb/application-development/hands-domain-driven-design-net-core)提供了关于《Hands-On
    Domain-Driven Design with .NET Core》一书的信息。'
- en: '[https://www.packtpub.com/gb/application-development/test-driven-development-c-and-net-core-mvc-video](https://www.packtpub.com/gb/application-development/test-driven-development-c-and-net-core-mvc-video) provides
    information on *Test-Driven Development with C# and .NET Core and MVC*.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/gb/application-development/test-driven-development-c-and-net-core-mvc-video](https://www.packtpub.com/gb/application-development/test-driven-development-c-and-net-core-mvc-video)
    提供了关于使用C#和.NET Core以及MVC进行测试驱动开发的信息。'
