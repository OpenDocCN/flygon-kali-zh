- en: '*Chapter 11*: More Object-Oriented Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：更多面向对象编程'
- en: This chapter is the second part of our whirlwind tour (theoretical and practical)
    into OOP. We have already briefly discussed the concepts of encapsulation, inheritance,
    and polymorphism, but in this chapter, we will get to see them more in action
    in some demo apps. While the working examples will show these concepts in their
    simplest forms, it will still be a significant stepping stone towards taking control
    of our layouts via our Java code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是我们对面向对象编程的风潮之旅（理论和实践）的第二部分。我们已经简要讨论了封装、继承和多态性的概念，但在本章中，我们将看到它们在一些演示应用程序中更加实际的运用。虽然工作示例将展示这些概念以其最简单的形式，但这仍然是朝着通过我们的Java代码控制布局的重要一步。
- en: 'In this chapter, we will explore the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: Encapsulation in depth and how it helps us
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解封装及其帮助我们的方式
- en: Inheritance in depth and how to take full advantage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解继承及如何充分利用
- en: Polymorphism explained in greater detail
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更详细地解释多态性
- en: Static classes and how we have been using them already
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类及我们已经在使用的方式
- en: Abstract classes and interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类和接口
- en: First, we will handle encapsulation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将处理封装。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2011](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2011).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中的代码文件[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2011](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2011)。
- en: Remember that encapsulation thing?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还记得封装吗？
- en: So far, what we have really seen is what amounts to a kind of code-organizing
    convention where we write classes, full of variables and methods. We did discuss
    the wider goals of all this OOP stuff but now we will take things further and
    begin to see how we actually manage to achieve encapsulation with OOP.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们真正看到的是一种代码组织约定，我们编写类，充满了变量和方法。我们确实讨论了所有这些面向对象编程的更广泛目标，但现在我们将进一步探讨，并开始看到我们如何实际通过面向对象编程实现封装。
- en: Definition of encapsulation
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的定义
- en: Encapsulation describes the ability of an object to hide its data and methods
    from the rest of the world, allowing only the variables and methods you choose
    to be accessed. This means your code can always be updated, extended, or improved
    without affecting the programs that use it – provided the exposed parts are still
    made accessible in the same way. It also allows the code that uses your encapsulated
    code to be much simpler and easier to maintain because much of the complexity
    of the task is encapsulated within your code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 封装描述了对象隐藏其数据和方法不让外界访问的能力，只允许访问您选择的变量和方法。这意味着您的代码始终可以更新、扩展或改进，而不会影响使用它的程序——只要暴露的部分仍然以相同的方式可访问。它还允许使用您封装的代码的代码变得更简单、更易于维护，因为任务的大部分复杂性都封装在您的代码中。
- en: 'But didn''t you say we don''t have to know what is going on inside? So you
    might question what we have seen so far like this: If we are constantly setting
    the instance variables like this `rambo.health` `= 100;`, isn''t it possible that,
    eventually, things could start to go wrong, perhaps like this?'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你不是说我们不需要知道内部发生了什么吗？所以你可能会像这样质疑我们迄今为止所看到的东西：如果我们不断地设置实例变量，比如`rambo.health
    = 100;`，难道不可能最终出现问题，比如这样吗？
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Encapsulation protects the objects of your class from being used in a way that
    they weren't meant to be. By controlling the way that your classes' code is used,
    it can only ever do what you want it to do and with value ranges that you can
    control.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 封装保护了您的类的对象，使其无法以其不应有的方式使用。通过控制类代码的使用方式，它只能做您想要做的事情，并且具有您可以控制的值范围。
- en: 'It can''t be forced into errors or crashes. Also, you are then free to make
    changes to the way your code works internally, without breaking the rest of your
    program or any programs that are using an older version of the code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会被强制出现错误或崩溃。此外，您可以自由地更改代码的内部工作方式，而不会破坏程序的其余部分或使用旧版本代码的任何程序：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Encapsulation is not just vital for writing code that other people will use
    (such as the Android API that we use), it is also essential when writing code
    we will reuse ourselves as it will save us from our own mistakes. Furthermore,
    a team of programmers will use encapsulation extensively so that different members
    of the team can work on the same program without all members of the team knowing
    how the other team members' code works. We can encapsulate our classes for this
    same advantage and here is how.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 封装不仅对于编写其他人将使用的代码（例如我们使用的Android API）至关重要，而且在编写自己将重复使用的代码时也是必不可少的，因为它将使我们免受自己的错误。此外，程序员团队将广泛使用封装，以便团队的不同成员可以在同一程序上工作，而不需要所有团队成员都知道其他团队成员的代码如何工作。我们可以为了获得同样的优势而封装我们的类，以下是如何做到的。
- en: Controlling class use with access modifiers
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问修饰符控制类的使用
- en: 'The designer of the class controls what can be seen and manipulated by any
    program that uses their class. We can add an `class` keyword like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类的设计者控制着任何使用其类的程序所能看到和操作的内容。我们可以像这样添加一个`class`关键字：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Class access modifiers
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类访问修饰符
- en: 'There are two main access modifiers for classes in the context we have discussed
    so far. Let''s briefly look at each in turn:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了上下文中类的两个主要访问修饰符。让我们依次简要地看一下每一个：
- en: '`public`: This is straightforward. A class declared as public can be seen by
    all other classes.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：这很简单。声明为public的类可以被所有其他类看到。'
- en: '`default`: A class has default access when no access modifier is specified.
    This will make it public but only to classes in the same package and inaccessible
    to all others.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：当未指定访问修饰符时，类具有默认访问权限。这将使其对同一包中的类公开，但对所有其他类不可访问。'
- en: So now we can make a start on this encapsulation thing. But even at a glance,
    the access modifiers described are not very fine-grained. We seem to be limited
    to complete lockdown to anything outside the package or a complete free-for-all.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始封装这个东西了。但是，即使乍一看，所描述的访问修饰符也不是非常精细。我们似乎只能完全封锁包外的任何东西，或者完全自由。
- en: Actually, the benefits here are easily taken advantage of. The idea would be
    to design a package of classes that fulfills a set of tasks. Then, all the complex
    inner workings of the package, the stuff that shouldn't be messed with by anybody
    but our package, should be default access (only accessible to classes within the
    package). We can then make available a careful choice of public classes that can
    be used by others (or other distinct parts of our program).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这里的好处很容易被利用。想法是设计一个包含一组任务的类包。然后，包的所有复杂内部工作，那些不应该被任何人干扰的东西，应该是默认访问权限（只能被包内的类访问）。然后我们可以提供一些精心选择的公共类，供其他人（或程序的其他不同部分）使用。
- en: Important note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: For the size and complexity of the apps in this book, creating multiple packages
    is overkill. We will of course be using other people's packages and classes (the
    public parts), so this stuff is worth knowing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中应用程序的大小和复杂性来说，创建多个包是过度的。当然，我们将使用其他人的包和类（公共部分），所以了解这些内容是值得的。
- en: Class access in summary
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类访问权限总结
- en: A well-designed app will probably consist of one or more packages, each containing
    only default or default and public classes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的应用程序可能由一个或多个包组成，每个包只包含默认或默认和公共类。
- en: In addition to class-level privacy controls, Java gives us programmers very
    fine-grained controls, but to use these controls, we have to look into variables
    with a little more detail.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类级别的隐私控制之外，Java还为我们程序员提供了非常精细的控制，但要使用这些控制，我们必须更详细地研究变量。
- en: Controlling variable use with access modifiers
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问修饰符控制变量的使用
- en: 'To build on the class visibility controls, we have variable access modifiers.
    Here is a variable with the `private` access modifier being declared:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强类的可见性控制，我们有变量访问修饰符。这是一个声明了`private`访问修饰符的变量：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note also that all of our discussion of variable access modifiers applies to
    object variables too. For example, here is an instance of our `Soldier` class
    being declared, created, and assigned. As you can see, the access specified in
    this case is public:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们对变量访问修饰符的所有讨论也适用于对象变量。例如，这里声明、创建和分配了我们的`Soldier`类的一个实例。如你所见，这种情况下指定的访问权限是公共的：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before you apply a modifier to a variable, you must first consider the class
    visibility. If class *a* is not visible to class *b*, say because class *a* has
    default access and class *b* is in another package, then it doesn't make any difference
    what access modifiers you use on the variables in class *a* – class *b* can't
    see any of them anyway.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在将修饰符应用于变量之前，必须首先考虑类的可见性。如果类*a*对类*b*不可见，比如因为类*a*具有默认访问权限，而类*b*在另一个包中，那么在类*a*的变量上使用任何访问修饰符都没有任何影响
    - 类*b*无法看到其中任何一个。
- en: So, it makes sense to show a class to another class when necessary but only
    to expose the variables that are directly needed – not everything.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有必要在必要时向另一个类显示一个类，但只公开直接需要的变量 - 而不是所有的变量。
- en: Here is an explanation of the different variable access modifiers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不同变量访问修饰符的解释。
- en: Variable access modifiers
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量访问修饰符
- en: 'Variable access modifiers are more numerous and finely grained than class access
    modifiers. The depth and complexity of access modification are not so much in
    the range of modifiers but rather in the smart ways we can combine them to achieve
    the worthy goals of encapsulation. Here are the variable access modifiers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 变量访问修饰符比类访问修饰符更多，也更精细。访问修改的深度和复杂性不在于修饰符的范围，而在于我们可以如何巧妙地组合它们以实现封装的可贵目标。以下是变量访问修饰符：
- en: '`public`: You guessed it, any class or method from any package can see this
    variable. Use `public` only when you are sure this is what you want.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：你猜对了，任何包中的任何类或方法都可以看到这个变量。只有当你确定这就是你想要的时候才使用`public`。'
- en: '`protected`: This is the next least restrictive after `public`. `protected`
    variables can be seen by any class and any method as long as they are in the same
    package.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`：这是继`public`之后的下一个最不限制的。只要它们在同一个包中，`protected`变量可以被任何类和任何方法看到。'
- en: '`default`: `default` doesn''t sound as restrictive as `protected` but it is
    more so. A variable has `default` access when no access is specified. The fact
    that `default` is restrictive perhaps implies we should be thinking of hiding
    our variables more than we should be exposing them. At this point, we need to
    introduce a new concept. Do you remember we briefly discussed inheritance and
    how we can quickly take on the attributes of a class and yet refine it by using
    the `extends` keyword? Just for the record, default access variables are not visible
    to subclasses; that is, when we extend a class as we did with an Activity, we
    cannot see its default variables. We will look at inheritance in more detail later
    in the chapter.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：`default`听起来不像`protected`那么限制，但实际上更加限制。当没有指定访问权限时，变量具有`default`访问权限。`default`限制的事实或许意味着我们应该考虑隐藏我们的变量，而不是暴露它们。在这一点上，我们需要介绍一个新概念。你还记得我们曾简要讨论过继承以及如何可以快速地继承一个类的属性，然后使用`extends`关键字对其进行改进吗？只是为了记录，`default`访问权限的变量对子类是不可见的；也就是说，当我们像对Activity一样扩展一个类时，我们无法看到它的默认变量。我们将在本章后面更详细地讨论继承。'
- en: '`private`: `private` variables can only be seen within the class they are declared.
    This means, like default access, they cannot be seen by subclasses (classes that
    inherit from the class in question).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`：`private`变量只能在声明它们的类内部可见。这意味着，与默认访问权限一样，它们对子类（从所讨论的类继承的类）也是不可见的。'
- en: Variable access summary
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量访问权限总结
- en: A well-designed app will probably consist of one or more packages, each containing
    only `default` or `default` and `public` classes. Within these classes, variables
    will have carefully chosen and varied access modifiers, chosen with a view to
    achieving our goal of encapsulation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的应用程序可能由一个或多个包组成，每个包只包含`default`或`default`和`public`类。在这些类中，变量将具有精心选择和不同的访问修饰符，以实现我们封装目标的目标。
- en: One more twist in all this access modification stuff before we get practical
    with it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际操作之前，让我们再谈一下所有这些访问修改的东西中的一个小技巧。
- en: Methods can have access modifiers too
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法也可以有访问修饰符
- en: We already briefly mentioned in [*Chapter 9*](B16773_09_ePub_RK.xhtml#_idTextAnchor169)*,
    Learning Java Methods*, that methods can have access modifiers. It makes sense
    because methods are the things that our classes can *do*. We will want to control
    what users of our classes can and can't do.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第9章*](B16773_09_ePub_RK.xhtml#_idTextAnchor169)*，学习Java方法*中简要提到，方法可以有访问修饰符。这是有道理的，因为方法是我们的类可以*做*的事情。我们将想要控制我们的类的用户可以做什么和不能做什么。
- en: The general idea here is that some methods will do things internally only and
    are therefore not needed by users of the class and some methods will be fundamental
    to how users of the class use the class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一般想法是，一些方法将只在内部执行操作，因此不需要类的用户，而一些方法将是类的用户使用类的基础。
- en: Method access modifiers
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法访问修饰符
- en: The access modifiers for methods are the same as for the class variables. This
    makes things easy to remember but suggests, again, that successful encapsulation
    is a matter of design rather than of following any specific set of rules.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的访问修饰符与类变量的访问修饰符相同。这使得事情容易记住，但再次表明，成功的封装是一种设计问题，而不是遵循任何特定规则的问题。
- en: 'As an example, this method, provided it is in a public class, could be used
    by any other class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，只要它在一个公共类中，这种方法可以被任何其他类使用：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Whereas this method could only be used internally by the class that it is part
    of:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个方法只能被它所属的类内部使用：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And this next method with no access specified has default visibility. It can
    be used only by other classes in the same package. If we extend the class holding
    this `default` access method, the child class will not have access to this parent
    class''s method:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个没有指定访问权限的方法具有默认可见性。它只能被同一包中的其他类使用。如果我们扩展持有此“默认”访问方法的类，子类将无法访问此父类的方法：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As the last example before we move on, here is a `protected` method, only visible
    to the package, but usable by our classes that extend it – just like `onCreate`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前的最后一个例子中，这是一个`protected`方法，只对包可见，但可以被我们扩展它的类使用-就像`onCreate`一样：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's have a quick recap of method encapsulation, but remember that you don't
    need to memorize everything.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下方法封装，但请记住，你不需要记住所有的东西。
- en: Method access summary
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法访问总结
- en: Method access should be chosen to best enforce the principles we have already
    discussed. It should provide the users of your class with just the access they
    need and preferably nothing more. Thereby we achieve our encapsulation goals,
    such as keeping the internal workings of your code safe from interference from
    the programs that use it, for all the reasons we have discussed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 方法访问应该被选择为最好地执行我们已经讨论过的原则。它应该为你的类的用户提供他们所需要的访问权限，最好是没有更多。通过这样做，我们实现了我们的封装目标，比如保护代码的内部工作免受使用它的程序的干扰，出于我们已经讨论过的所有原因。
- en: Accessing private variables with getters and setters
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用getter和setter访问私有变量
- en: Now, if it is best practice to hide our variables away as private, we need to
    consider how we allow access to them without spoiling our encapsulation. What
    if an object of the `Hospital` class wanted access to the `health` member variable
    from an object of type `Soldier`, so it could increase it? The `health` variable
    should be private because we don't want just any piece of code changing it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果将变量隐藏为私有是最佳实践，我们需要考虑如何允许访问它们，而不破坏我们的封装。如果`Hospital`类的对象想要访问`Soldier`类型的对象的`health`成员变量，以便增加它，`health`变量应该是私有的，因为我们不希望任何代码片段都可以更改它。
- en: To be able to make as many member variables as possible private and yet still
    allow some kind of limited access to some of them, we use **getters** and **setters**.
    Getters and setters are just methods that get and set variable values.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够尽可能多地将成员变量设置为私有，同时仍然允许对其中一些进行有限访问，我们使用**getter**和**setter**。Getter和setter只是获取和设置变量值的方法。
- en: This is not some special new Java thing we have to learn. It is just a convention
    for using what we already know. Let's have a look at getters and setters using
    our `Soldier` class and `Hospital` class examples.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们必须学习的一些特殊的新的Java东西。这只是一个使用我们已经知道的东西的惯例。让我们看一下使用我们的`Soldier`类和`Hospital`类示例的getter和setter。
- en: 'In this example, each of our two classes is created in its own file but the
    same package. First of all, here is our hypothetical `Hospital` class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的两个类分别在自己的文件中创建，但在同一个包中。首先，这是我们假设的`Hospital`类：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our implementation of the `Hospital` class has just one method, `healSoldier`.
    It receives a reference to a `Soldier` object as a parameter. So, this method
    will work on whichever `Soldier` object is passed in: `vassily`, `wellington`,
    `rambo`, or whoever.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Hospital`类的实现只有一个方法，`healSoldier`。它接收一个`Soldier`对象的引用作为参数。因此，这个方法将在传入的任何`Soldier`对象上工作：`vassily`，`wellington`，`rambo`，或其他人。
- en: It also has a local `health` variable, which it uses to temporarily hold and
    increase the soldier's health. In the same line, it initializes the `health` variable
    to the `Soldier` object's current health. The `Soldier` object's health is private
    so the public `getHealth` getter method is used instead.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有一个本地的`health`变量，它用来临时保存并增加士兵的健康。在同一行中，它将`health`变量初始化为`Soldier`对象的当前健康状况。`Soldier`对象的健康状况是私有的，因此使用公共的`getHealth`
    getter方法。
- en: Then `health` is increased by 10 and the `setHealth` setter method loads up
    the new revived health value, back to the `Soldier` object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`health`增加了10，`setHealth` setter方法加载了新的恢复后的健康值，返回到`Soldier`对象。
- en: The key here is that although a `Hospital` object can change a `Soldier` object's
    health, it only does so within the bounds of the getter and setter methods. The
    getter and setter methods can be written to control and check for potentially
    mistaken, or even harmful, values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，尽管`Hospital`对象可以改变`Soldier`对象的健康状况，但它只能在getter和setter方法的范围内这样做。getter和setter方法可以被编写来控制和检查可能错误的，甚至有害的值。
- en: 'Next, look at our hypothetical `Soldier` class we have just been using with
    the simplest implementation possible of its getter and setter methods:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，看看我们刚刚使用的假设的`Soldier`类，它具有最简单的getter和setter方法的实现：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have one instance variable called `health` and it is private. Private means
    it can only be changed by methods of the `Soldier` class. We then have a public
    `getHealth` method that returns the value held in the private `health` int variable.
    As this method is public, any code with access to an object of type `Soldier`
    can use it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`health`的实例变量，它是私有的。私有意味着它只能被`Soldier`类的方法更改。然后我们有一个公共的`getHealth`方法，它返回私有的`health`
    int变量中保存的值。由于这个方法是公共的，任何具有`Soldier`类型对象访问权限的代码都可以使用它。
- en: Next, the `setHealth` method is implemented. Again, it is public but this time
    it takes an `int` as a parameter and assigns whatever is passed in to the private
    `health` variable. In a more life-like example, we would write some more code
    here to make sure the value passed in is within the bounds we expect.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实现了`setHealth`方法。同样，它是公共的，但这次它接受一个`int`作为参数，并将传入的任何内容分配给私有的`health`变量。在更像生活的例子中，我们会在这里编写更多的代码，以确保传入的值在我们期望的范围内。
- en: 'Now we declare, create, and assign to make an object of each of our two new
    classes and see how our getters and setters work:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们声明、创建和赋值，创建每个新类的对象，并看看我们的getter和setter是如何工作的：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We see that we can call our public `setHealth` and `getHealth` methods directly
    on our object of type `Soldier`. Not only that, we can call the `healSoldier`
    method of the `Hospital` object, passing in a reference to the `Soldier` object,
    which too can use the public getters and setters to manipulate the private `health`
    variable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们可以直接在我们的`Soldier`类型的对象上调用我们的公共`setHealth`和`getHealth`方法。不仅如此，我们还可以调用`Hospital`对象的`healSoldier`方法，传入对`Soldier`对象的引用，后者也可以使用公共的getter和setter来操作私有的`health`变量。
- en: We see that the private `health` variable is simply accessible, yet totally
    within the control of the designer of the `Soldier` class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到私有的`health`变量是可以直接访问的，但完全受`Soldier`类的设计者控制。
- en: If you want to play around with this example, there is the code for a working
    app in the code bundle in the [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)
    folder called `GettersAndSetters`. I have added a few lines of code to print to
    the console.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试一下这个示例，[*第11章*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)文件夹中的代码包中有一个名为`GettersAndSetters`的工作应用程序的代码。我已经添加了几行代码来打印到控制台。
- en: Important note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Getters and setters are sometimes referred to by their more correct names, **Accessors**
    and **Mutators**. We will stick to getters and setters. I just thought you might
    like to know the jargon.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Getter和setter有时被称为它们更正确的名称**访问器**和**修改器**。我们将坚持使用getter和setter。我只是想让你知道这个行话。
- en: Yet again, our example and the explanation are probably raising more questions.
    That's good.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例和解释可能又引发了更多问题。这很好。
- en: By using encapsulation features (such as access control), it is like signing
    a really important deal about how to use and access a class, its methods, and
    variables. The contract is not just an agreement about now, but an implied guarantee
    for the future. We will see that as we go ahead through this chapter, there are
    more ways in which we'll refine and strengthen this contract.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用封装特性（如访问控制），就像签署了一个关于如何使用和访问类、它的方法和变量的重要协议。这份合同不仅仅是关于现在的协议，而且是对未来的暗示保证。当我们继续阅读本章时，我们会看到更多的方式来完善和加强这份合同。
- en: Tip
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Use encapsulation where it is needed or, of course, if you are being paid to
    use it by an employer. Often encapsulation is overkill on small learning projects,
    such as some of the examples in this book. Except, of course, when the topic you
    are learning is encapsulation itself.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要的时候使用封装，或者当然，如果你的雇主要求你使用它的话。在一些小型学习项目中，如本书中的一些示例中，封装通常是多余的。当然，除非你学习的主题就是封装本身。
- en: We are learning this Java OOP stuff under the assumption that you will one day
    want to write much more complex apps, whether on Android or some other platform
    that uses OOP. In addition, we will be using classes from the Android API that
    use it extensively and it will help us understand what is happening then as well.
    Typically, throughout this book, we will use encapsulation when implementing full
    projects and often overlook it when showing small code samples to demonstrate
    a single idea or topic.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在学习这些Java OOP的东西时，假设你将来会想要编写更复杂的应用程序，无论是在Android上还是其他使用OOP的平台上。此外，我们将使用Android
    API中广泛使用它的类，并且这也将帮助我们理解那时发生了什么。通常情况下，在本书中，我们将在实现完整项目时使用封装，并经常忽略它，当展示单个想法或主题的小代码示例时。
- en: Setting up our objects with constructors
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构造函数设置我们的对象
- en: 'With all these private variables and their getters and setters, does it mean
    that we need a getter and a setter for every private variable? What about a class
    with lots of variables that need initializing at the start. Think about the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些私有变量及其getter和setter，这是否意味着我们需要为每个私有变量都需要一个getter和setter？那么对于一个有很多需要在开始时初始化的变量的类呢？想想以下情况：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Some of these variables might need getters and setters, but what if we just
    want to set things up when the object is first created, to make the object function
    correctly?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些变量可能需要getter和setter，但如果我们只想在对象首次创建时设置一些东西，以使对象正确运行呢？
- en: Surely, we don't need two methods (a getter and a setter) for each?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定不需要为每个变量都有两个方法（一个getter和一个setter）吧？
- en: Fortunately, this is unnecessary. To solve this potential problem there is a
    special method called a **constructor**. We briefly mentioned the existence of
    a constructor when we discussed instantiating an object of a class in [*Chapter
    10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*, Object-Oriented Programming*.
    Let's look again at constructors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这是不必要的。为了解决这个潜在的问题，有一个特殊的方法叫做**构造函数**。我们在[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*面向对象编程*中讨论实例化一个类的对象时，简要提到了构造函数的存在。让我们再看看构造函数。
- en: 'Here, we create an object of type `Soldier` and assign it to an object called
    `mySoldier`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个类型为`Soldier`的对象，并将其赋给一个名为`mySoldier`的对象：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Nothing new here but look at the last part of that line of code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的，但是看一下代码行的最后部分：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This looks suspiciously like a method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可疑地像一个方法。
- en: All along, we have been calling a special method called a constructor that has
    been created behind the scenes, automatically, by the compiler.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一直以来，我们一直在调用一个特殊的方法，称为构造函数，这个方法是由编译器在幕后自动创建的。
- en: 'However, and this is getting to the point now, like a method, we can *override*
    the constructor, which means we can do useful things to set up our new object
    *before* it is used. This next code shows how we could do this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在到了重点，就像一个方法一样，我们可以*覆盖*构造函数，这意味着我们可以在使用新对象之前对其进行有用的设置。下面的代码展示了我们如何做到这一点：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The constructor has a lot of syntactical similarities to a method. It can, however,
    only be called with the use of the `new` keyword, and it is created for us automatically
    by the compiler – unless we create our own like in the previous code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数在语法上与方法有很多相似之处。但是，它只能在使用`new`关键字的情况下调用，并且它是由编译器自动为我们创建的 - 除非我们像在先前的代码中那样创建自己的构造函数。
- en: 'Constructors have the following features:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数具有以下特点：
- en: They have no return type
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们没有返回类型
- en: They have the exact same name as the class
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们与类具有完全相同的名称
- en: They can have parameters
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以有参数
- en: They can be overloaded
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以被重载
- en: One more piece of Java syntax that it is useful to introduce at this point is
    the Java `this` keyword.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，还有一些Java语法是有用的，那就是Java的`this`关键字。
- en: 'The `this` keyword is used when we want to be explicit about exactly which
    variables we are referring to. Look at this example constructor, again for a hypothetical
    variation of the `Soldier` class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要明确指出我们正在引用哪些变量时，就会使用`this`关键字。再看看这个例子构造函数，再看一个假设的`Soldier`类的变体：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, the constructor has a parameter for each of the variables we want
    to initialize. By using the `this` keyword, it is clear when we mean the member
    variable or the parameter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，构造函数为每个我们想要初始化的变量都有一个参数。通过使用`this`关键字，当我们指的是成员变量或参数时就很清楚。
- en: There are more twists and turns to be learned about variables and `this` and
    they make much more sense when applied to a practical project. In the next app,
    we will explore all we have learned so far in this chapter and some more new ideas
    too.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于变量和`this`还有更多的技巧和转折，当应用到一个实际项目时，它们会更有意义。在下一个应用程序中，我们将探索本章迄今为止学到的所有内容，还有一些新的想法。
- en: First, a bit more OOP.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，再多一点面向对象编程。
- en: Static methods
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法
- en: 'We know quite a lot about classes already. For example, we know how to turn
    them into objects and use their methods and variables. But something isn''t quite
    right. Since the very start of the book, we have been using two classes more than
    any other. We have repeatedly used `Log` and `Toast` to output to logcat or the
    user''s screen but have not instantiated them once! How can this be? We never
    did this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对类有相当多的了解。例如，我们知道如何将它们转换为对象并使用它们的方法和变量。但是有些地方不太对。自从书的开头，我们一直在使用两个类，比其他类更频繁地使用`Log`和`Toast`来输出到logcat或用户的屏幕，但我们从未实例化过它们！这怎么可能呢？我们从未这样做过：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We just went ahead and used the classes directly, like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接使用了这些类，就像这样：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The **static** methods of classes can be used *without* first instantiating
    an object of the class. We can think of this as a static method belonging to the
    class and all other methods belonging to an object/instance of a class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 类的**静态**方法可以在没有首先实例化类的对象的情况下使用。我们可以将其视为属于类的静态方法，而所有其他方法都属于类的对象/实例。
- en: 'And as you have probably realized by now, `Log` and `Toast` both contain static
    methods. To be clear: `Log` and `Toast` *contain* static methods; they themselves
    are still classes.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 而且你现在可能已经意识到，`Log`和`Toast`都包含静态方法。要清楚：`Log`和`Toast`*包含*静态方法；它们本身仍然是类。
- en: Classes can have both static and regular methods as well, but the regular methods
    would need to be used in a regular way, via an instance/object of the class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 类既可以有静态方法，也可以有常规方法，但是常规方法需要以常规方式使用，通过类的实例/对象。
- en: 'Take another look at `Log.i` in action:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 再看一下`Log.i`的使用：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, `i` is the method being statically accessed and the method takes two parameters,
    both of type String.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`i`是静态访问的方法，该方法接受两个参数，都是String类型。
- en: 'Next, we see the static method `makeText` of the `Toast` class in use:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到了`Toast`类的静态方法`makeText`的使用：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `makeText` method of the `Toast` class takes three arguments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Toast`类的`makeText`方法接受三个参数。'
- en: The first is `this`, which is a reference to the current class. We saw when
    talking about constructors that to explicitly refer to the member variables of
    the current instance of an object, we can use `this.health`, `this.regiment`,
    and so on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`this`，它是对当前类的引用。我们在谈论构造函数时看到，为了明确地引用对象的当前实例的成员变量，我们可以使用`this.health`，`this.regiment`等等。
- en: When we use `this` as we do in the previous line of code, we are referring to
    the instance of the class itself; not the `Toast` class but the `this` in the
    previous line of code is a reference to the class the method is being used *from*.
    In our case, we have used it from the `MainActivity` class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们像在上一行代码中那样使用`this`时，我们指的是类本身的实例；不是`Toast`类，而是上一行代码中的`this`是对方法所在的类的引用。在我们的例子中，我们已经从`MainActivity`类中使用了它。
- en: Many things in Android require a reference to an instance of `Activity` to do
    their job. We will fairly regularly throughout this book pass in `this` (a reference
    to `Activity`) in order to enable a class/object from the Android API to do its
    work. We will also write classes that need `this` as an argument in one or more
    of its methods. So, we will see how to handle `this` when it is passed in as well.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，许多事情都需要引用`Activity`的实例才能完成它们的工作。在本书中，我们将经常传递`this`（对`Activity`的引用）来使Android
    API中的类/对象能够完成它们的工作。我们还将编写需要`this`作为一个或多个方法参数的类。因此，我们将看到如何处理传递进来的`this`。
- en: The second argument of the `makeText` method is of course a `String`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeText`方法的第二个参数当然是一个`String`。'
- en: 'The third argument is accessing a `final` variable, `LENGTH_SHORT`, again via
    the class name not an instance of the class. If we declare a variable like this
    next line of code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是访问一个`final`变量`LENGTH_SHORT`，同样是通过类名而不是类的实例。如果我们像下一行代码那样声明一个变量：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the variable was declared in a class called `MyClass`, we could access the
    variable like this: `MyClass.LENGTH_SHORT` and use it like any other variable,
    but the `final` keyword makes sure that the value of the variable can never be
    changed. This type of variable is called a **constant**.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量是在一个名为`MyClass`的类中声明的，我们可以像这样访问变量：`MyClass.LENGTH_SHORT`，并像任何其他变量一样使用它，但`final`关键字确保变量的值永远不会改变。这种类型的变量被称为**常量**。
- en: The `static` keyword also has another consequence for a variable, especially
    when it is not a constant (can be changed) and we will see this in action in our
    next app.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`关键字对变量也有另一个影响，特别是当它不是一个常量（可以改变）时，我们将在我们的下一个应用程序中看到它的作用。'
- en: Now if you look carefully at the very end of the line of code that shows a `Toast`
    message to the user, you will see something else new, `.show()`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你仔细看代码行的最后，显示一个`Toast`消息给用户，你会看到另一个新的东西，`.show()`。
- en: This is called `Toast` class but using just one line of code. It is the `show`
    method that actually triggers the message.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为`Toast`类，但只使用了一行代码。实际触发消息的是`show`方法。
- en: We will look at chaining more closely as we proceed through the book, such as
    in [*Chapter 14*](B16773_14_ePub_RK.xhtml#_idTextAnchor249), *Android Dialog Windows*,
    when we make a pop-up dialog.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们继续阅读本书时，我们将更仔细地研究链式调用，比如在[*第14章*](B16773_14_ePub_RK.xhtml#_idTextAnchor249)中，*Android对话框窗口*，当我们创建一个弹出对话框时。
- en: Tip
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you want to read about the `Toast` class and some of its other methods in
    detail, you can do so here: [http://developer.android.com/reference/android/widget/Toast.html](http://developer.android.com/reference/android/widget/Toast.html).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想详细了解`Toast`类及其其他一些方法，你可以在这里查看：[http://developer.android.com/reference/android/widget/Toast.html](http://developer.android.com/reference/android/widget/Toast.html)。
- en: Static methods are often provided in classes that have uses that are so generic
    it doesn't make sense to create an object of the class. Another really useful
    class with static methods is `Math`. This class is actually a part of the Java
    API, not the Android API.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法通常在具有如此通用用途的类中提供，以至于创建该类的对象是没有意义的。另一个非常有用的具有静态方法的类是`Math`。这个类实际上是Java API的一部分，而不是Android
    API的一部分。
- en: Tip
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Want to write a calculator app? It''s easier than you think with the static
    methods of the `Math` class. You can look at them here: [http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html](http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 想写一个计算器应用程序吗？使用`Math`类的静态方法比你想象的要容易。你可以在这里查看它们：[http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html](http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html)。
- en: If you try this out, you will need to import the `Math` class the same way you
    imported all the other classes we have used. Next, we can try out a practical
    mini app to understand encapsulation and static methods.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试这个，你需要以同样的方式导入`Math`类，就像你导入我们使用过的所有其他类一样。接下来，我们可以尝试一个实际的迷你应用程序来理解封装和静态方法。
- en: Encapsulation and static methods mini-app
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装和静态方法迷你应用程序
- en: We have looked at the intricate way that access to variables and their scope
    is controlled and it would serve us well to look at an example of them in action.
    These will not so much be practical real-world examples of variable use, more
    a demonstration to help understand access modifiers for classes, methods, and
    variables alongside the different types of variables such as reference or primitive
    and local or instance, along with the new concepts of static and final variables
    and the `this` keyword.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了对变量和它们的作用域的访问是如何受控制的，我们最好看一个例子来了解它们的作用。这些不会是变量使用的实际实例，更多的是一个演示，以帮助理解类、方法和变量的访问修饰符，以及引用或原始和局部或实例变量的不同类型，以及静态和最终变量和`this`关键字的新概念。
- en: The completed code is in the [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)
    folder of the download bundle. It is called `Access Scope This And Static`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的代码在下载包的[*第11章*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)文件夹中。它被称为`Access
    Scope This And Static`。
- en: Create a new Empty Activity project and call it `Access Scope This And Static`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的空活动项目，并将其命名为`Access Scope This And Static`。
- en: Create a new class by right-clicking on the existing `MainActivity` class in
    the project explorer and clicking `AlienShip`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右键单击项目资源管理器中的现有`MainActivity`类并单击`AlienShip`来创建一个新类。
- en: 'Now we will declare our new class and some member variables. Note that `numShips`
    is `private` and `static`. We will see how this variable is the same across all
    instances of the class soon. The `shieldStrength` variable is `private` and `shipName`
    is public:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将声明我们的新类和一些成员变量。请注意，`numShips`是`private`和`static`。我们很快将看到这个变量在类的所有实例中是相同的。`shieldStrength`变量是`private`，`shipName`是公共的：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next is the constructor. We can see that the constructor is public, has no
    return type, and has the same name as the class – as per the rules. In it, we
    increment the private static `numShips` variable. Remember this will happen each
    time we create a new object of type `AlienShip`. Also, the constructor sets a
    value for the private variable `shieldStrength` using the private `setShieldStrength`
    method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是构造函数。我们可以看到构造函数是公共的，没有返回类型，并且与类名相同-根据规则。在其中，我们递增了私有静态的`numShips`变量。请记住，每当我们创建一个新的`AlienShip`类型的对象时，这将发生。此外，构造函数使用私有的`setShieldStrength`方法为私有变量`shieldStrength`设置一个值：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the public static getter method so classes outside of `AlienShip` can
    find out how many `AlienShip` objects there are. We will also see the way in which
    we use static methods:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是公共静态的getter方法，这样`AlienShip`外部的类就可以找出有多少个`AlienShip`对象了。我们还将看到我们如何使用静态方法：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And this is our private `setShieldStrength` method. We could have just set
    `shieldStrength` directly from within the class, but the code below shows how
    we distinguish between the `shieldStrength` local variable/parameter and the `shieldStrength`
    member variable by using the `this` keyword:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的私有`setShieldStrength`方法。我们本可以直接从类内部设置`shieldStrength`，但下面的代码显示了我们如何通过使用`this`关键字区分`shieldStrength`局部变量/参数和`shieldStrength`成员变量：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This next method is the getter so other classes can read but not alter the
    shield strength of each `AlienShip` object:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的方法是getter，这样其他类就可以读取但不能更改每个`AlienShip`对象的护盾强度：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we have a public method that can be called every time an `AlienShip` object
    is hit. It just prints to the console and then detects whether that object''s
    `shieldStrength` is zero. If it is, it calls the `destroyShip` method, which we''ll
    look at next:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个公共方法，每次击中`AlienShip`对象时都可以调用。它只是打印到控制台，然后检测该对象的`shieldStrength`是否为零。如果是，它调用`destroyShip`方法，我们将在下面看到：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And lastly for our `AlienShip` class, we will code the `destroyShip` method.
    We print a message that indicates which ship has been destroyed based on its `shipName`
    as well as decrementing the `numShips` static variable so we can keep track of
    how many objects of type `AlienShip` we have:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于我们的`AlienShip`类，我们将编写`destroyShip`方法。我们打印一条消息，指示基于其`shipName`已被销毁的飞船，并递减`numShips`静态变量，以便我们可以跟踪类型`AlienShip`的对象数量：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we switch over to our `MainActivity` class and write some code that uses
    our new `AlienShip` class. All the code goes in the `onCreate` method after the
    call to `setContentView`. First, we create two new `AlienShip` objects called
    `girlShip` and `boyShip`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们切换到我们的`MainActivity`类，并编写一些使用我们新的`AlienShip`类的代码。所有代码都放在`setContentView`调用之后的`onCreate`方法中。首先，我们创建两个名为`girlShip`和`boyShip`的新`AlienShip`对象：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the next code, look at how we get the value in `numShips`. We use the `getNumShips`
    method as we might expect. However, look closely at the syntax. We are using the
    class name and not an object. We can also access static variables with methods
    that are not static. We did it this way to see a static method in action:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码中，看看我们如何获取`numShips`的值。我们使用`getNumShips`方法，就像我们所期望的那样。但是，仔细看语法。我们使用的是类名，而不是对象。我们还可以使用不是静态的方法访问静态变量。我们这样做是为了看到静态方法的运行方式：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we assign names to our public `shipName` String variables:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为我们的公共`shipName`字符串变量分配名称：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this next code, we try to assign a value directly to a private variable.
    It won''t work. Then we use the public getter method `getShieldStrength` to print
    out the `shieldStrength`, which was assigned in the constructor:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码中，我们尝试直接为私有变量分配一个值。这是行不通的。然后我们使用公共的getter方法`getShieldStrength`来打印出在构造函数中分配的`shieldStrength`：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we get to blow some stuff up by playing with the `hitDetected` method
    and occasionally checking the `shieldStrength` of our two objects:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过使用`hitDetected`方法来炸毁一些东西，并偶尔检查我们两个对象的`shieldStrength`：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we think we have destroyed a ship, we again use our static `getNumShips`
    method to see if our static variable `numShips` was changed by the `destroyShip`
    method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们认为我们已经摧毁了一艘飞船时，我们再次使用我们的静态`getNumShips`方法来查看我们的静态变量`numShips`是否被`destroyShip`方法改变：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the demo and look at the console output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 运行演示并查看控制台输出：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the previous example, we saw that we can distinguish between local and member
    variables of the same name by using the `this` keyword. We can also use the `this`
    keyword to write code that refers to whatever the current object being acted upon
    is.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到我们可以通过使用`this`关键字区分相同名称的局部变量和成员变量。我们还可以使用`this`关键字编写代码，引用当前正在操作的对象。
- en: We saw that a static variable – in this case, `numShips` – is consistent across
    all instances; moreover, by incrementing it in the constructor and decrementing
    it in our `destroyShip` method, we can keep track of the number of `AlienShip`
    objects we currently have.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到静态变量-在这种情况下，`numShips`-在所有实例中是一致的；此外，通过在构造函数中递增它，并在我们的`destroyShip`方法中递减它，我们可以跟踪我们当前拥有的`AlienShip`对象的数量。
- en: We also saw that we can use static methods by using the class name with the
    dot operator instead of an actual object.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，我们可以使用静态方法，使用类名和点运算符而不是实际对象。
- en: Tip
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Yes, I know it is like living in the blueprint of a house – but it's quite useful
    too.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道这就像生活在房子的蓝图中一样-但这也非常有用。
- en: Finally, we proved how we could hide and expose certain methods and variables
    using an access specifier.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们证明了如何使用访问修饰符隐藏和公开某些方法和变量。
- en: Next, we will look at the topic of inheritance.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下继承的主题。
- en: OOP and inheritance
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程和继承
- en: We have seen how we can use other people's code by instantiating/creating objects
    from the classes of an API like Android. But this whole OOP thing goes even further
    than that.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以通过实例化/创建来自Android等API的类的对象来使用其他人的代码。但是这整个OOP的东西甚至比那更深入。
- en: What if there is a class that has loads of useful functionality in it but not
    exactly what we want? We can inherit from the class and then further refine or
    add to how it works and what it does.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个类有很多有用的功能，但不完全符合我们的要求，我们可以从该类继承，然后进一步完善或添加其工作方式和功能。
- en: 'You might be surprised to hear that we have done this already. In fact, we
    have done this with every single app we have created. When we use the `extends`
    keyword, we are inheriting. Remember this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地听到我们已经这样做了。实际上，我们已经为我们创建的每个应用程序都这样做了。当我们使用`extends`关键字时，我们正在继承。记住这一点：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we are inheriting the `AppCompatActivity` class along with all its functionality
    – or more specifically, all the functionality that the class designers want us
    to have access to. Here are some of the things we can do to classes we have extended.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们继承了`AppCompatActivity`类以及它的所有功能-更具体地说，类设计者希望我们能够访问的所有功能。以下是我们可以对我们扩展的类做的一些事情。
- en: 'We can even override a method *and* still rely in part on the overridden method
    in the class we inherit from. For example, we overrode the `onCreate` method every
    time we extended the `AppCompatActivity` class. But we also called on the default
    implementation provided by the class designers when we did this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以重写一个方法*并且*仍然部分依赖于我们继承的类中的重写方法。例如，我们每次扩展`AppCompatActivity`类时都重写了`onCreate`方法。但是当我们这样做时，我们也调用了类设计者提供的默认实现：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: And in [*Chapter 6*](B16773_06_ePub_RK.xhtml#_idTextAnchor119), *The Android
    Lifecycle*, we overrode just about all of the Activity class lifecycle methods.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B16773_06_ePub_RK.xhtml#_idTextAnchor119)，*Android生命周期*中，我们重写了几乎所有Activity类的生命周期方法。
- en: We discuss inheritance mainly so that we understand what is going on around
    us and as the first step towards being able to eventually design useful classes
    that we or others can extend.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要讨论继承，以便我们了解周围发生的事情，并作为最终能够设计有用的类的第一步，我们或其他人可以扩展。
- en: With this in mind, let's look at some example classes and see how we can extend
    them, just to see the syntax and as a first step, and also to be able to say we
    have done it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们看一些示例类，并看看我们如何扩展它们，只是为了看看语法并作为第一步，也为了能够说我们已经这样做了。
- en: When we look at the final major topic of this chapter, polymorphism, we will
    also dig a little deeper into inheritance at the same time. Here is some code
    using inheritance.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看这一章的最后一个主要主题，多态性时，我们也将同时深入研究继承。这里有一些使用继承的代码。
- en: 'This code would go in a file named `Animal.java`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将放在一个名为`Animal.java`的文件中：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then in a separate file named `Elephant.java`, we could do this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在一个名为`Elephant.java`的单独文件中，我们可以这样做：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can see in the previous code that we have implemented a class called `Animal`
    and it has four member variables: `age`, `weight`, `type`, and `hungerLevel`.
    It also has two methods, `eat` and `walk`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在前面的代码中，我们实现了一个名为`Animal`的类，它有四个成员变量：`age`，`weight`，`type`和`hungerLevel`。它还有两个方法，`eat`和`walk`。
- en: We then extended `Animal` with `Elephant`. `Elephant` can now do anything an
    `Animal` can and it also has all its variables.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们用`Elephant`扩展了`Animal`。`Elephant`现在可以做任何`Animal`可以做的事情，它也有所有的变量。
- en: We initialized the variables from `Animal` that `Elephant` has in the `Elephant`
    constructor. Two variables (`age` and `weight`) are passed into the constructor
    when an `Elephant` object is created and two variables (`type` and `hungerLevel`)
    are assigned the same for all `Elephant` objects.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Elephant`构造函数中初始化了`Animal`的变量，`Elephant`在创建对象时将两个变量（`age`和`weight`）传递给构造函数，并且为所有`Elephant`对象分配了两个变量（`type`和`hungerLevel`）。
- en: We could go ahead and write a bunch of other classes that extend `Animal`, perhaps
    `Lion`, `Tiger`, and `ThreeToedSloth`. Each would have an `age`, `weight`, `type`,
    and `hungerLevel` and each would be able to `walk` and `eat`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续编写一堆其他扩展`Animal`的类，也许是`Lion`，`Tiger`和`ThreeToedSloth`。每个类都会有`age`，`weight`，`type`和`hungerLevel`，并且每个类都能`walk`和`eat`。
- en: As if OOP were not useful enough already, we can now model real-world objects.
    We have also seen that we can make OOP even more useful by subclassing/extending/inheriting
    from other classes. The terminology we might like to learn here is that the class
    that is extended from is the **super class** and the class that inherits from
    the super class is the **subclass**. We can also say the parent and child class.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 好像OOP已经不够有用了，我们现在可以模拟现实世界的对象。我们还看到，通过子类化/扩展/继承其他类，我们可以使OOP变得更加有用。我们可能想要学习的术语是被扩展的类是**超类**，继承超类的类是**子类**。我们也可以说父类和子类。
- en: Tip
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'As usual, we might find ourselves asking this question about inheritance. Why?
    The reason is something like this: we can write common code once, in the parent
    class; we can update that common code and all classes that inherit from it are
    also updated. Furthermore, a subclass only gets to use public/protected instance
    variables and methods. So, designed properly, this also further enhances the goals
    of encapsulation.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们可能会问关于继承的这个问题。为什么？原因是这样的：我们可以在父类中编写一次通用代码；我们可以更新该通用代码，所有继承自它的类也会更新。此外，子类只能使用公共/受保护的实例变量和方法。因此，如果设计得当，这也进一步增强了封装的目标。
- en: Let's build another small app to play about with inheritance.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建另一个小应用程序来玩一下继承。
- en: Inheritance example app
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承示例应用程序
- en: We have looked at the way we can create hierarchies of classes to model a system
    that fits our app. So, let's try out some simple code that uses inheritance. The
    completed code is in the [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)
    folder of the code download. It is called `Inheritance Example`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了如何创建类的层次结构来模拟适合我们应用程序的系统。因此，让我们尝试一些使用继承的简单代码。完成的代码在[*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)文件夹中。它被称为`Inheritance
    Example`。
- en: Create a new project called `Inheritance Example` using the `AlienShip`, another
    `Fighter`, and the last one `Bomber`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AlienShip`、另一个`Fighter`和最后一个`Bomber`创建一个名为`Inheritance Example`的新项目。
- en: Here is the code for the `AlienShip` class. It is very similar to our previous
    class demo, `AlienShip`. The differences are that the constructor now takes an
    `int` parameter, which it uses to set the shield strength.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`AlienShip`类的代码。它与我们之前的类演示`AlienShip`非常相似。不同之处在于构造函数现在接受一个`int`参数，它用于设置护盾强度。
- en: The constructor also outputs a message to the logcat window, so we can see when
    it is being used. The `AlienShip` class also has a new method, `fireWeapon`, that
    is declared as `abstract`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数还会将消息输出到logcat窗口，这样我们就可以看到它何时被使用。`AlienShip`类还有一个新方法`fireWeapon`，声明为`abstract`。
- en: Declaring a class as abstract guarantees that any class that subclasses `AlienShip`
    must implement its own version of `fireWeapon`. Notice the class has the `abstract`
    keyword as part of its declaration. We have to do this because one of its methods
    also uses the `abstract` keyword. We will explain the `abstract` method when discussing
    this demo and the `abstract` class when we talk about polymorphism in the next
    section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个类声明为抽象类可以保证任何子类`AlienShip`都必须实现其自己的`fireWeapon`版本。注意类的声明中有`abstract`关键字。我们必须这样做是因为它的一个方法也使用了`abstract`关键字。当我们讨论这个演示和下一节中讨论多态时，我们将解释`abstract`方法和`abstract`类。
- en: 'Add the following code to the `AlienShip` class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`AlienShip`类中：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we will implement the `Bomber` class. Notice the call to `super(100)`.
    This calls the constructor of the super class with the value for `shieldStrength`.
    We could do further specific `Bomber` initialization in this constructor, but
    for now, we just print out the location so we can see when the `Bomber` constructor
    is being executed. We also, because we must, implement a `Bomber` specific version
    of the abstract `fireWeapon` method. Add the following code to the `Bomber` class:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现`Bomber`类。注意调用`super(100)`。这将使用`shieldStrength`的值调用超类的构造函数。我们可以在这个构造函数中进一步初始化特定的`Bomber`，但现在，我们只是打印出位置，这样我们就可以看到`Bomber`构造函数何时被执行。因为我们必须，我们还必须实现一个抽象`fireWeapon`方法的`Bomber`特定版本。将以下代码添加到`Bomber`类中：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we will implement the `Fighter` class. Notice the call to `super(400)`.
    This calls the constructor of the super class with the value for `shieldStrength`.
    We could do further specific `Fighter` initialization in this constructor but
    for now, we just print out the location so we can see when the `Fighter` constructor
    is being executed. We also must implement a `Fighter` specific version of the
    abstract `fireWeapon` method. Add the following code to the `Fighter` class:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现`Fighter`类。注意调用`super(400)`。这将使用`shieldStrength`的值调用超类的构造函数。我们可以在这个构造函数中进一步初始化特定的`Fighter`，但现在，我们只是打印出位置，这样我们就可以看到`Fighter`构造函数何时被执行。我们还必须实现一个抽象`fireWeapon`方法的`Fighter`特定版本。将以下代码添加到`Fighter`类中：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we will code the `onCreate` method of `MainActivity`. As usual, enter
    this code after the call to the `setContentView` method. This is the code that
    uses our three new classes. The code looks quite ordinary – nothing new. It is
    the output that is interesting:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写`MainActivity`的`onCreate`方法。像往常一样，在调用`setContentView`方法之后输入此代码。这是使用我们的三个新类的代码。代码看起来相当普通
    - 没有什么新东西。有趣的是输出：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the app and you will get the following output in the logcat window:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，您将在logcat窗口中获得以下输出：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can see how the constructor of the subclass calls the constructor of the
    super class. We can also clearly see that the individual implementations of the
    `fireWeapon` method work exactly as expected.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到子类的构造函数如何调用超类的构造函数。我们还可以清楚地看到`fireWeapon`方法的各个实现正如预期地工作。
- en: Let's take a closer look at the final major OOP concept, polymorphism. Then
    we will be able to do some more practical things with the Android API.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下最后一个重要的面向对象编程概念，多态。然后我们将能够在Android API中做一些更实际的事情。
- en: Polymorphism
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: We already know that polymorphism means *different forms*. But what does it
    mean to us?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道多态意味着*不同的形式*。但对我们来说意味着什么呢？
- en: 'Boiled down to its simplest:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之：
- en: Any subclass can be used as part of the code that uses the super class.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 任何子类都可以作为使用超类的代码的一部分。
- en: This means we can write code that is simpler and easier to understand, and easier
    to change.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以编写更简单、更容易理解和更容易更改的代码。
- en: Also, we can write code for the super class and rely on the fact that no matter
    how many times it is sub-classed, within certain parameters, the code will still
    work. Let's discuss an example.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以为超类编写代码，并依赖于这样一个事实：无论它被子类化多少次，在一定的参数范围内，代码仍然可以正常工作。让我们讨论一个例子。
- en: Suppose we want to use polymorphism to help to write a zoo management app. We
    will probably want to have a method such as `feed`. We will probably want to pass
    a reference to the animal to be fed into the `feed` method. This might seem like
    we need to write a `feed` method for each and every type of `Animal`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要使用多态来帮助编写一个动物园管理应用程序。我们可能希望有一个`feed`之类的方法。我们可能希望将要喂养的动物的引用传递到`feed`方法中。这似乎需要为每种类型的`Animal`编写一个`feed`方法。
- en: 'However, we can write polymorphic methods with polymorphic return types and
    arguments:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以编写具有多态返回类型和参数的多态方法：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding method has `Animal` as a parameter, which means that any object
    that is built from a class that extends `Animal` can be passed into it. And as
    you can see in the preceding code, the method also returns `Animal`, which has
    exactly the same benefits.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法将`Animal`作为参数，这意味着可以将从扩展`Animal`的类构建的任何对象传递给它。正如你在前面的代码中看到的，该方法也返回`Animal`，具有完全相同的好处。
- en: There is a small gotcha with polymorphic return types and that is that we need
    to be aware of what is being returned and make it explicit in the code that calls
    the method.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 多态返回类型有一个小问题，那就是我们需要意识到返回的是什么，并且在调用方法的代码中明确表示出来。
- en: 'For example, we could handle `Elephant` being passed into the `feed` method
    like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以像这样处理将`Elephant`传递到`feed`方法中：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice the highlighted `(Elephant)` in the previous code. This makes it plain
    that we want `Elephant` from the returned `Animal`. This is called **casting**.
    We will use casting occasionally throughout the rest of the book.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面代码中的`(Elephant)`。这明确表示我们想要从返回的`Animal`中得到`Elephant`。这被称为**转换**。我们将在本书的其余部分偶尔使用转换。
- en: So, you can even write code *today* and make another subclass in a week, month,
    or year, and the very same methods and data structures will still work.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你甚至可以*今天*编写代码，并在一周、一个月或一年后创建另一个子类，而相同的方法和数据结构仍然可以工作。
- en: Also, we can enforce upon our subclasses a set of rules as to what they can
    and cannot do, as well as how they do it. So, clever design in one stage can influence
    it at other stages.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以对我们的子类强制执行一组规则，规定它们可以做什么，不能做什么，以及如何做。因此，一个阶段的巧妙设计可以影响其他阶段。
- en: But will we ever really want to instantiate an actual `Animal`?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们真的会想要实例化一个实际的`Animal`吗？
- en: Abstract classes
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类
- en: We played with an abstract class in the inheritance example app but let's dig
    a little deeper. An abstract class is a class that cannot be instantiated; it
    cannot be made into an object. So, it's a blueprint that will never be used then?
    But that's like paying an architect to design your home and then never building
    it? You might be saying to yourself, "I kind of got the idea of an abstract method
    but abstract classes are just silly."
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在继承示例应用程序中，我们使用了一个抽象类，但让我们深入一点。抽象类是一个不能被实例化的类；它不能被制作成一个对象。那么，它就是一个永远不会被使用的蓝图？但这就像付钱给建筑师设计你的房子，然后永远不建造它？你可能会对自己说，“我有点明白了抽象方法的概念，但抽象类就是愚蠢。”
- en: If we or the designer of a class wants to force us to inherit *before* we use
    their class, they can declare a class **abstract**. Then, we cannot make an object
    from it; therefore, we must extend it first and make an object from the subclass.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们或类的设计者想要强制我们在使用他们的类之前继承，他们可以将一个类声明为**abstract**。然后，我们就不能从中创建一个对象；因此，我们必须首先扩展它并从子类创建一个对象。
- en: We can also declare a method `abstract` and then that method must be overridden
    in any class that extends the class with the abstract method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以声明一个方法为`abstract`，然后该方法必须在扩展具有抽象方法的类的任何类中被重写。
- en: 'Let''s look at an example – it will help. We make a class `abstract` by declaring
    it with the `abstract` keyword like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子——这会有所帮助。我们通过像这样使用`abstract`关键字来声明一个类为`abstract`：
- en: '[PRE47]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Yes, but why?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，但为什么？
- en: Sometimes we want a class that can be used as a polymorphic type, but we need
    to guarantee it can never be used as an object. For example, "animal" doesn't
    really make sense on its own.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想要一个可以用作多态类型的类，但我们需要保证它永远不能被用作对象。例如，“动物”本身并没有太多意义。
- en: We don't talk about animals; we talk about *types* of animals. We don't say,
    "Ooh, look at that lovely fluffy, white animal." Or, "Yesterday we went to the
    pet shop and got an animal and an animal bed." It's just too, well, *abstract*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不谈论动物；我们谈论*动物的类型*。我们不会说，“哦，看那只可爱的毛茸茸的白色动物。”或者，“昨天我们去宠物店买了一只动物和一个动物床。”这太，嗯，*抽象*了。
- en: So, an abstract class is kind of like a template to be used by any class that
    `extends` it (inherits from it).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，抽象类有点像一个模板，可以被任何`extends`它（继承自它）的类使用。
- en: We might want a `Worker` class and extend it to make `Miner`, `Steelworker`,
    `OfficeWorker`, and of course `Programmer`. But what exactly does a plain `Worker`
    do? Why would we ever want to instantiate one?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要一个`Worker`类，并将其扩展为`Miner`、`Steelworker`、`OfficeWorker`，当然还有`Programmer`。但一个普通的`Worker`到底是做什么的呢？我们为什么要实例化一个？
- en: The answer is we probably wouldn't want to instantiate one; but we might want
    to use it as a polymorphic type, so we can pass multiple worker subclasses between
    methods and have data structures that can hold all types of `Worker`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是我们可能不想实例化一个；但我们可能想要将其用作多态类型，这样我们可以在方法之间传递多个工作子类，并且可以拥有可以容纳所有类型的`Worker`的数据结构。
- en: We call this type of class an abstract class and when a class has even one abstract
    method, it must be declared abstract itself. And all abstract methods must be
    overridden by any class that extends it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这种类型的类为抽象类，当一个类有一个抽象方法时，它必须被声明为抽象类。并且所有抽象方法必须被任何扩展它的类重写。
- en: This means that the abstract class can give some of the common functionality
    that would be available in all its subclasses. For example, the `Worker` class
    might have the `height`, `weight`, and `age` member variables.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着抽象类可以提供一些在其所有子类中都可用的共同功能。例如，`Worker`类可能有`height`、`weight`和`age`成员变量。
- en: It might also have the `getPayCheck` method, which is not abstract and is the
    same in all the subclasses, but a `doWork` method is abstract and must be overridden,
    because all the different types of worker `doWork` differently.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能还有`getPayCheck`方法，这不是抽象的，并且在所有子类中都是相同的，但`doWork`方法是抽象的，必须被重写，因为所有不同类型的工作者都会以不同的方式`doWork`。
- en: This leads us neatly to another area of polymorphism that is going to make life
    easier for us throughout this book.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们顺利地进入了多态的另一个领域，这将在本书中为我们带来更多便利。
- en: Interfaces
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: An interface is like a class. Phew! Nothing complicated here then. But it's
    like a class that is always abstract and has only abstract methods.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接口就像一个类。哦！这里没有什么复杂的。但它就像一个始终是抽象的类，只有抽象方法。
- en: We can think of an interface as an entirely abstract class with all its methods
    abstract and no member variables either.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将接口视为一个完全抽象的类，其中所有方法都是抽象的，也没有成员变量。
- en: OK, so you can just about wrap your head around an abstract class because at
    least it can pass on some functionality in its methods that are not abstract and
    serve as a polymorphic type. But seriously, this interface seems a bit pointless.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你大概可以理解抽象类，因为至少它可以在其方法中传递一些功能，这些功能不是抽象的，并且可以作为多态类型。但说真的，这个接口似乎有点毫无意义。
- en: Let's look at the simplest possible generic example of an interface, then we
    can discuss it further.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个最简单的通用接口示例，然后我们可以进一步讨论它。
- en: 'To define an interface, we type the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个接口，我们输入以下内容：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The methods of an interface have no body because they are abstract, but they
    can still have return types and parameters, or not.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的方法没有方法体，因为它们是抽象的，但它们仍然可以有返回类型和参数，或者没有。
- en: 'To use an interface, we use the `implements` keyword after the class declaration:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用接口，我们在类声明后使用`implements`关键字：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This enables us to use polymorphism with multiple different objects that are
    from completely unrelated inheritance hierarchies. If a class implements an interface,
    the whole thing can be passed along or used as if it is that thing – because it
    is that thing. It is polymorphic (many things).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用多态性来处理来自完全不相关的继承层次结构的多个不同对象。如果一个类实现了一个接口，整个东西就可以被传递或用作它本身 - 因为它就是那个东西。它是多态的（多种形式）。
- en: We can even have a class implement multiple different interfaces at the same
    time. Just add a comma between each interface and list them after the `implements`
    keyword. Just be sure to implement all the necessary methods.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以让一个类同时实现多个不同的接口。只需在每个接口之间加上逗号，并在`implements`关键字后列出它们。只需确保实现所有必要的方法。
- en: In this book, we will use the interfaces of the Android API more often than
    we write our own. In [*Chapter 13*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)*,
    Anonymous Classes - Bringing Android Widgets to Life*, one such interface we will
    use in the Java Meet UI app is the `OnClickListener` interface.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将更频繁地使用Android API的接口，而不是编写我们自己的接口。在[*第13章*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)*，匿名类
    - 使Android小部件活跃*中，我们将在Java Meet UI应用程序中使用`OnClickListener`接口。
- en: Many things might like to know when they are being clicked. Perhaps a `Button`
    or a `TextView` widget, and so on. So, using an interface we don't need different
    methods for every type of UI element we might like to click.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 许多事情在被点击时可能想要知道。也许是`Button`或`TextView`小部件等等。因此，使用接口，我们不需要为每种我们想要点击的UI元素类型编写不同的方法。
- en: Frequently asked questions
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经常问的问题
- en: What is wrong with this class declaration?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类声明有什么问题？
- en: '[PRE50]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There are no private classes. Classes can be public or default. Public classes
    are public; default classes are private within their own package.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 没有私有类。类可以是公共的或默认的。公共类是公共的；默认类在其自己的包内是私有的。
- en: What is encapsulation?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装是什么？
- en: Encapsulation is how we contain our variables, code, and methods in a manner
    that exposes just the parts and functionality we want to other code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是我们如何以一种方式包含我们的变量、代码和方法，以仅暴露我们想要暴露给其他代码的部分和功能。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered more theory than in any other chapter. If you haven't
    memorized everything or some of the code seemed a bit too in-depth, then you have
    still succeeded completely.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了比其他任何章节都更多的理论。如果你没有记住所有内容，或者有些代码看起来有点太深入了，那么你仍然完全成功了。
- en: If you just understand that OOP is about writing reusable, extendable, and efficient
    code through encapsulation, inheritance, and polymorphism, then you have the potential
    to be a Java master.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是理解OOP是通过封装、继承和多态编写可重用、可扩展和高效的代码，那么你就有成为Java大师的潜力。
- en: Simply put, OOP enables us to use other peoples' code even when those other
    people were not aware of exactly what we would be doing at the time they wrote
    the code.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，面向对象编程使我们能够在其他人不知道我们在编写代码时会做什么的情况下使用其他人的代码。
- en: All you must do is keep practicing because we will constantly be using these
    same concepts over and over again throughout the book, so you do not need to have
    even begun to have mastered them at this point.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你所需要做的就是不断练习，因为我们将在整本书中不断地使用这些概念，所以你在这一点上甚至不需要已经掌握它们。
- en: In the next chapter, we will be revisiting some concepts from this chapter as
    well as looking at some new aspects of OOP and how it enables our Java code to
    interact with our XML layouts.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重新讨论本章的一些概念，以及看一些OOP的新方面，以及它如何使我们的Java代码与我们的XML布局进行交互。
- en: But first, there is an important incoming news flash!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，有一个重要的即将到来的新闻快讯！
- en: Important note
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: All the UI elements – `TextView`, `ConstraintLayout`, `CalenderView`, and `Button`
    – are classes too. Their attributes are member variables and they have loads of
    methods that we can use to do all sorts of things with the UI. This could prove
    useful.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的UI元素 - `TextView`、`ConstraintLayout`、`CalenderView`和`Button` - 也是类。它们的属性是成员变量，它们有大量的方法，我们可以使用这些方法来做各种各样的事情。这可能会很有用。
- en: There will much more on this revelation in the next two chapters, but first,
    we will see how Android handles trash.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将更多地了解这一点，但首先，我们将看看Android如何处理垃圾。
