- en: '*Chapter 10*:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第10章*：'
- en: Arrays and Strings
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和字符串
- en: This chapter covers a wide range of problems involving strings and arrays. Since
    Java strings and arrays are common topics for developers, I will briefly introduce
    them via several headlines that you must remember. However, if you need to deep
    dive into this topic, then consider the official Java documentation ([https://docs.oracle.com/javase/tutorial/java/](https://docs.oracle.com/javase/tutorial/java/)).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章涵盖了涉及字符串和数组的一系列问题。由于Java字符串和数组是开发人员常见的话题，我将通过几个你必须记住的标题来简要介绍它们。然而，如果你需要深入研究这个主题，那么请考虑官方的Java文档（[https://docs.oracle.com/javase/tutorial/java/](https://docs.oracle.com/javase/tutorial/java/)）。
- en: 'By the end of this chapter, you should be able to tackle any problem involving
    Java strings and/or arrays. It is highly likely that they will show up in a technical
    interview. So, the topics that will be covered in this chapter are pretty short
    and clear:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该能够解决涉及Java字符串和/或数组的任何问题。这些问题很可能会出现在技术面试中。因此，本章将涵盖的主题非常简短和清晰：
- en: Arrays and strings in a nutshell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和字符串概述
- en: Coding challenges
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码挑战
- en: Let's start with a quick recap of strings and arrays.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从快速回顾字符串和数组开始。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code present in this chapter can be found on GitHub at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都可以在GitHub上找到，网址为[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10)。
- en: Arrays and strings in a nutshell
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和字符串概述
- en: In Java, arrays are objects and are dynamically created. Arrays can be assigned
    to variables of the `Object` type. They can have a single dimension (for example,
    `m[]`) or multiple dimensions (for example, as a three-dimensional array, `m[][][]`).
    The elements of an array are stored starting with index 0, so an array of length
    *n* stores its elements between indexes 0 and *n*-1 (inclusive). Once an array
    object is created, its length never changes. Arrays cannot be immutable except
    for the useless array of length 0 (for example, `String[] immutable = new String[0]`).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，数组是对象并且是动态创建的。数组可以分配给`Object`类型的变量。它们可以有单个维度（例如，`m[]`）或多个维度（例如，作为三维数组，`m[][][]`）。数组的元素从索引0开始存储，因此长度为*n*的数组将其元素存储在索引0和*n*-1（包括）之间。一旦创建了数组对象，它的长度就永远不会改变。数组除了长度为0的无用数组（例如，`String[]
    immutable = new String[0]`）外，不能是不可变的。
- en: In Java, strings are immutable (`String` is immutable). A string can contain
    `char` data type (for example, calling `charAt(int index)` works as expected –
    `index` is the index varying from 0 to *string length* - 1). Unicode characters
    that exceed 65,535 until 1,114,111 (0x10FFFF) don't fit into 16 bits (Java `char`).
    They are stored as 32-bit integer values (known as *code points*). This aspect
    is detailed in the *Coding challenge 7 – Extracting code points of surrogate pairs*
    section.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，字符串是不可变的（`String`是不可变的）。字符串可以包含`char`数据类型（例如，调用`charAt(int index)`可以正常工作-`index`是从0到*字符串长度*
    - 1变化的索引）。超过65,535直到1,114,111（0x10FFFF）的Unicode字符不适合16位（Java`char`）。它们以32位整数值（称为*代码点*）存储。这一方面在*编码挑战7-提取代理对的代码点*部分有详细说明。
- en: A very useful class for manipulating strings is `StringBuilder` (and the thread-safe
    `StringBuffer`).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 用于操作字符串的一个非常有用的类是`StringBuilder`（以及线程安全的`StringBuffer`）。
- en: Now, let's look at some coding challenges.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一些编码挑战。
- en: Coding challenges
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码挑战
- en: 'In the following 29 coding challenges, we''ll tackle a set of popular problems
    encountered in Java technical interviews done by medium to large companies (including
    Google, Amazon, Flipkart, Adobe, and Microsoft). Besides these 29 coding challenges
    (discussed in this book), you may like to check out the following non-exhaustive
    list of strings and arrays coding challenges that you can find in my other book,
    *Java Coding Problems* ([https://www.amazon.com/gp/product/1789801419/](https://www.amazon.com/gp/product/1789801419/)),
    published by Packt as well:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的29个编码挑战中，我们将解决一组在Java技术面试中遇到的流行问题，这些面试由中大型公司（包括Google、Amazon、Flipkart、Adobe和Microsoft）进行。除了这本书中讨论的29个编码挑战，你可能还想查看我另一本书*Java编码问题*（[https://www.amazon.com/gp/product/1789801419/](https://www.amazon.com/gp/product/1789801419/)）中的以下非详尽列表中的字符串和数组编码挑战，该书由Packt出版：
- en: Counting duplicate characters
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算重复字符
- en: Finding the first non-repeated character
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到第一个不重复的字符
- en: Reversing letters and words
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转字母和单词
- en: Checking whether a string contains only digits
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查字符串是否只包含数字
- en: Counting vowels and consonants
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算元音和辅音
- en: Counting the occurrences of a certain character
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算特定字符的出现次数
- en: Removing white spaces from a string
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串中删除空格
- en: Joining multiple strings with a delimiter
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用分隔符连接多个字符串
- en: Checking whether a string is a palindrome
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查字符串是否是回文
- en: Removing duplicate characters
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除重复字符
- en: Removing a given character
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除给定字符
- en: Finding the character with the most appearances
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到出现最多次数的字符
- en: Sorting an array of strings by length
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按长度对字符串数组进行排序
- en: Checking that a string contains a substring
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查字符串是否包含子字符串
- en: Counting substring occurrences in a string
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算字符串中子字符串出现的次数
- en: Checking whether two strings are anagrams
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查两个字符串是否是变位词
- en: Declaring multiline strings (text blocks)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明多行字符串（文本块）
- en: Concatenating the same string *n* times
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相同的字符串* n *次连接
- en: Removing leading and trailing spaces
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除前导和尾随空格
- en: Finding the longest common prefix
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到最长的公共前缀
- en: Applying indentation
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用缩进
- en: Transforming strings
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换字符串
- en: Sorting an array
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数组进行排序
- en: Finding an element in an array
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数组中找到一个元素
- en: Checking whether two arrays are equal or mismatched
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查两个数组是否相等或不匹配
- en: Comparing two arrays lexicographically
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按字典顺序比较两个数组
- en: Minimum, maximum, and average of an array
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的最小值、最大值和平均值
- en: Reversing an array
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转数组
- en: Filling and setting an array
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充和设置数组
- en: Next greater element
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个更大的元素
- en: Changing array size
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变数组大小
- en: The 29 coding challenges tackled in this chapter are not covered in the preceding
    challenges and vice versa.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中涉及的29个编码挑战与前面的挑战没有涉及，反之亦然。
- en: Coding challenge 1 – Unique characters (1)
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战1 – 唯一字符（1）
- en: '**Google**, **Adobe**, **Microsoft**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**谷歌**，**Adobe**，**微软**'
- en: '`true` if this string contains unique characters. The whitespaces can be ignored.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`如果这个字符串包含唯一字符。空格可以忽略。'
- en: '**Solution**: Let''s consider the following three valid given strings:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑以下三个有效的给定字符串：'
- en: '![Figure 10.1 Strings'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 字符串'
- en: '](img/Figure_10.1_B15403.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.1_B15403.jpg)'
- en: Figure 10.1 – Strings
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 字符串
- en: First of all, it is important to know that we can fetch any character between
    0 and 65,535 via the `charAt(int index)` method (`index` is the index varying
    from 0 to *string length* – 1) because these characters are represented in Java
    using the 16-bit `char` data type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要知道我们可以通过`charAt(int index)`方法获取0到65,535之间的任何字符（`index`是从0到*字符串长度* -
    1变化的索引），因为这些字符在Java中使用16位的`char`数据类型表示。
- en: A simple solution to this problem consists of using a `Map<Character, Boolean>`.
    While we loop the characters of the given string via the `charAt(int index)` method,
    we try to put the character from `index` into this map and flip the corresponding
    `boolean` value from `false` to `true`. The `Map#put(K k, V v)` method returns
    `null` if there was no mapping for the given key (character). If there is a mapping
    for the given key (character), then `Map#put(K k, V v)` returns the previous value
    (in our case, `true`) associated with this key. So, when the returned value is
    not `null`, we can conclude that at least one character is duplicated, so we can
    say that the given string doesn't contain unique characters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的一个简单解决方案是使用`Map<Character, Boolean>`。当我们通过`charAt(int index)`方法循环给定字符串的字符时，我们尝试将`index`处的字符放入这个映射，并将相应的`boolean`值从`false`翻转为`true`。如果给定键（字符）没有映射，则`Map#put(K
    k, V v)`方法返回`null`。如果给定键（字符）有映射，则`Map#put(K k, V v)`返回与此键关联的先前值（在我们的情况下为`true`）。因此，当返回的值不是`null`时，我们可以得出结论至少有一个字符是重复的，因此我们可以说给定的字符串不包含唯一字符。
- en: 'Moreover, before trying to put a character in the map, we ensure that its code
    ranges between 0 and 65,535 via `String#codePointAt(index i)`. This method returns
    the Unicode character at the specified `index` as an `int`, which is known as
    the *code point*. Let''s see the code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在尝试将字符放入映射之前，我们通过`String#codePointAt(index i)`确保其代码在0到65,535之间。这个方法返回指定`index`处的Unicode字符作为`int`，这被称为*代码点*。让我们看看代码：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The complete application is called *UniqueCharacters*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*UniqueCharacters*。
- en: Coding challenge 2 – Unique characters (2)
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战2 – 唯一字符（2）
- en: '**Google**, **Adobe**, **Microsoft**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**谷歌**，**Adobe**，**微软**'
- en: '`true` if this string contains unique characters. The whitespaces can be ignored.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`如果这个字符串包含唯一字符。空格可以忽略。'
- en: '**Solution**: The solution presented in the preceding coding challenge covers
    this case as well. However, let''s try to come up with a solution specific to
    this case. The given string can contain only characters from *a-z*, so it can
    only contain ASCII codes from 97(*a*) to 122(*z*). Let''s consider that the given
    string is *afghnqrsuz*.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：前面编码挑战中提出的解决方案也涵盖了这种情况。但是，让我们试着提出一种特定于这种情况的解决方案。给定的字符串只能包含*a-z*中的字符，因此它只能包含从97（*a*）到122（*z*）的ASCII码。让我们假设给定的字符串是*afghnqrsuz*。'
- en: 'If we recall our experience from [*Chapter 9*](B15403_09_Final_JM_ePub.xhtml#_idTextAnchor181)*,
    Bit Manipulation*, then we can think of a bit mask that covers *a*-*z* letters
    with bits of 1, as shown in the following figure (the bits of 1 correspond to
    the letters of our string, *afghnqrsuz*):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下[*第9章*](B15403_09_Final_JM_ePub.xhtml#_idTextAnchor181)*，位操作*中的经验，那么我们可以想象一个位掩码，它用1覆盖了*a*-*z*字母，如下图所示（1的位对应于我们字符串的字母，*afghnqrsuz*）：
- en: '![Figure 10.2 – Unique characters bitmask'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 – 独特字符位掩码'
- en: '](img/Figure_10.2_B15403.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.2_B15403.jpg)'
- en: Figure 10.2 – Unique characters bit mask
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 唯一字符位掩码
- en: If we represent each letter from *a-z* as a bit of 1, then we obtain a bit mask
    of the unique characters, similar to the one shown in the preceding image. Initially,
    this bit mask contains only 0s (since no letter has been processed, we have all
    bits equal to 0 or they're unset).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将*a-z*中的每个字母表示为1的位，那么我们将获得一个唯一字符的位掩码，类似于前面图像中显示的位掩码。最初，这个位掩码只包含0（因为没有处理任何字母，我们所有的位都等于0或者未设置）。
- en: Next, we peek at the first letter from the given string and we compute the subtraction
    between its ASCII code and 97 (the ASCII code of *a*). Let's denote this with
    *s*. Now, we create another bit mask by left shifting 1 by *s* positions. This
    will result in a bit mask that has the MSB of 1 followed by *s* bits of 0 (1000...).
    Next, we can apply the AND[&] operator between the bit mask of unique characters
    (which is initially 0000...) and this bit mask (1000...). The result will be 0000...
    since 0 & 1 = 0\. This is the expected result since this is the first processed
    letter, so there are no letters being flipped in the bit mask of unique characters.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们窥视给定字符串的第一个字母，并计算其ASCII码和97（*a*的ASCII码）之间的差。让我们用*s*表示这个。现在，我们通过将1左移*s*位来创建另一个位掩码。这将导致一个位掩码，其最高位为1，后面跟着*s*位的0（1000...）。接下来，我们可以在唯一字符的位掩码（最初为0000...）和这个位掩码（1000...）之间应用AND[&]运算符。结果将是0000...，因为0
    & 1 = 0。这是预期的结果，因为这是第一个处理的字母，所以唯一字符的位掩码中没有字母被翻转。
- en: Next, we update the unique character's bit mask by flipping the bit from position
    *s* from 0 to 1\. This is done via the OR[|] operator. Now, the bit mask of unique
    characters is 1000.... There is a single bit of 1 since we flipped a single bit;
    that is, the one corresponding to the first letter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过将位掩码中的位置*s*的位从0翻转为1来更新唯一字符的位掩码。这是通过OR[|]运算符完成的。现在，唯一字符的位掩码是1000....
    由于我们翻转了一个位，所以现在有一个单独的1位，即对应于第一个字母的1位。
- en: Finally, we repeat this process for each letter of the given string. If you
    encounter a duplicate, then the AND[&] operation between the bit mask of unique
    characters and the 1000... mask corresponding to the currently processed letter
    will return 1 (1 & 1 = 1). If this happens, then we have found a duplicate, so
    we can return it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为给定字符串的每个字母重复此过程。如果遇到重复的字符，那么唯一字符的位掩码和当前处理的字母对应的1000...掩码之间的AND[&]操作将返回1（1
    & 1 = 1）。如果发生这种情况，那么我们已经找到了一个重复项，所以我们可以返回它。
- en: 'In terms of code, we have the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下情况：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The complete application is called *UniqueCharactersAZ*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*UniqueCharactersAZ*。
- en: Coding challenge 3 – Encoding strings
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战3 - 编码字符串
- en: '`char[]`, *str*. Write a snippet of code that replaces all whitespaces with
    a sequence, *%20*. The resulting string should be returned as a `char[]`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`char[]`，*str*。编写一小段代码，将所有空格替换为序列*%20*。结果字符串应作为`char[]`返回。'
- en: '`char[]` represents the following string:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`char[]`代表以下字符串：'
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The expected result is *%20%20String%20%20%20with%20spaces%20%20*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果是*%20%20String%20%20%20with%20spaces%20%20*。
- en: 'We can solve this problem in three steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过三个步骤解决这个问题：
- en: We count the number of whitespaces in the given `char[]`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算给定`char[]`中空格的数量。
- en: Next, create a new `char[]` that's the size of the initial `char[]`, *str*,
    plus the number of whitespaces multiplied by 2 (a single whitespace occupies one
    element in the given `char[]`, while the *%20* sequences will occupy three elements
    in the resulting `char[]`).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的`char[]`，其大小为初始`char[]`*str*的大小，加上空格的数量乘以2（单个空格占据给定`char[]`中的一个元素，而*%20*序列将占据结果`char[]`中的三个元素）。
- en: Lastly, we loop the given `char[]` and create the resulting `char[]`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们循环给定的`char[]`并创建结果`char[]`。
- en: 'In terms of code, we have the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下情况：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The complete application is called *EncodedString*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*EncodedString*。
- en: Coding challenge 4 – One edit away
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战4 - 一个编辑的距离
- en: '**Google**, **Microsoft**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google**，**Microsoft**'
- en: '**Problem**: Consider two given strings, *q* and *p*. Write a snippet of code
    that determines whether we can obtain two identical strings by performing a single
    edit in *q* or *p*. More precisely, we can insert, remove, or replace a single
    character in *q* or in *p*, and *q* will become equal to *p*.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个给定的字符串*q*和*p*。编写一小段代码，确定我们是否可以通过在*q*或*p*中进行单个编辑来获得两个相同的字符串。更确切地说，我们可以在*q*或*p*中插入、删除或替换一个字符，*q*将变成等于*p*。'
- en: '**Solution**: To better understand the requirements, let''s consider several
    examples:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：为了更好地理解要求，让我们考虑几个例子：'
- en: '*tank, tanc* One edit: Replace *k* with *c* (or vice versa)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*tank, tanc* 一个编辑：用*c*替换*k*（反之亦然）'
- en: '*tnk, tank* One edit: Insert *a* in *tnk* between *t* and *n* or remove *a*
    from *tank*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*tnk, tank* 一个编辑：在*tnk*中的*t*和*n*之间插入*a*，或者从*tank*中删除*a*'
- en: '*tank, tinck* More than one edit is needed!'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*tank, tinck* 需要多于一个编辑！'
- en: '*tank, tankist* More than one edit is needed!'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*tank, tankist* 需要多于一个编辑！'
- en: 'By inspecting these examples, we can conclude that we are one edit away if
    the following occurs:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查这些例子，我们可以得出以下结论：如果发生以下情况，我们离目标只有一个编辑的距离：
- en: The difference in length between *q* and *p* is not bigger than 1
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*q*和*p*之间的长度差异不大于1'
- en: '*q* and *p* are different in a single place'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*q*和*p*在一个地方不同'
- en: 'We can easily check the difference in length between *q* and *p* as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地检查*q*和*p*之间长度的差异，如下所示：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To find out whether *q* and *p* are different in a single place, we have to
    compare each character from *q* with each character from *p*. If we find more
    than one difference, then we return `false`; otherwise, we return `true`. Let''s
    see this in terms of code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出*q*和*p*在一个地方是否不同，我们必须将*q*的每个字符与*p*的每个字符进行比较。如果我们找到多于一个差异，那么我们返回`false`；否则，我们返回`true`。让我们看看这在代码方面是怎样的：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The complete application is called *OneEditAway*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*OneEditAway*。
- en: Coding challenge 5 – Shrinking a string
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战5 - 缩短字符串
- en: '**Problem:** Consider a given string containing only letters *a-z* and whitespaces.
    This string contains a lot of consecutive repeated characters. Write a snippet
    of code that shrinks this string by counting the consecutive repeated characters
    and creating another string that appends each character and the number of consecutive
    occurrences. The whitespaces should be copied in the resulting string as they
    are (don''t shrink the whitespaces). If the resulting string is not shorter than
    the given string, then return the given string.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个只包含字母*a-z*和空格的给定字符串。这个字符串包含很多连续重复的字符。编写一小段代码，通过计算连续重复的字符并创建另一个字符串，将这个字符串缩小。空格应该按原样复制到结果字符串中（不要缩小空格）。如果结果字符串不比给定字符串短，那么返回给定字符串。'
- en: '**Solution**: Consider that the given string is *abbb vvvv s rttt rr eeee f*.
    The expected result will be *a1b3 v4 s1 r1t3 r2 e4 f1*. To count the consecutive
    characters, we need to loop this string character by character:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：考虑给定的字符串是*abbb vvvv s rttt rr eeee f*。预期结果将是*a1b3 v4 s1 r1t3 r2 e4
    f1*。为了计算连续的字符，我们需要逐个字符循环这个字符串：'
- en: If the current character and the next character are the same, then we increment
    a counter.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前字符和下一个字符相同，那么我们增加一个计数器。
- en: If the next character is different from the current character, then we append
    the current character and the counter value to the final result, and we reset
    the counter to 0\.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果下一个字符与当前字符不同，那么我们将当前字符和计数器值附加到最终结果，并将计数器重置为0。
- en: In the end, after processing all the characters from the given string, we compare
    the length of the result with the length of the given string and we return the
    shortest string.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在处理给定字符串的所有字符之后，我们比较结果的长度与给定字符串的长度，并返回较短的字符串。
- en: 'In terms of code, we have the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下情况：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The complete application is called *StringShrinker*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*StringShrinker*。
- en: Coding challenge 6 – Extracting integers
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战6 - 提取整数
- en: '**Problem**: Consider a given string containing whitespaces and *a-z* and *0-9*
    characters. Write a snippet of code that extracts integers from this string. You
    can assume that any sequence of consecutive digits forms a valid integer.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个包含空格和*a-z*和*0-9*字符的给定字符串。编写一小段代码，从这个字符串中提取整数。您可以假设任何连续数字序列都形成一个有效的整数。'
- en: '**Solution**: Consider that the given string is *cv dd 4 k 2321 2 11 k4k2 66
    4d*. The expected result will contain the following integers: 4, 2321, 2, 11,
    4, 2, 66, and 4.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：考虑给定的字符串是*cv dd 4 k 2321 2 11 k4k2 66 4d*。预期结果将包含以下整数：4, 2321, 2,
    11, 4, 2, 66和4。'
- en: 'A straightforward solution will loop the given string character by character
    and concatenate sequences of consecutive digits. A digit contains ASCII code between
    48 (inclusive) and 97 (inclusive). So, any character whose ASCII code is in the
    range [48, 97] is a digit. We can also use the `Character#isDigit(char ch)` method.
    When a sequence of consecutive digits is interrupted by a non-digit character,
    we can convert the harvested sequence into an integer and append it as a list
    of integers. Let''s see this in terms of code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方案将循环给定的字符串，逐个字符连接连续数字序列。数字包含ASCII代码在48（包括）和97（包括）之间。因此，任何ASCII代码在[48,
    97]范围内的字符都是数字。我们还可以使用`Character#isDigit(char ch)`方法。当连续数字序列被非数字字符中断时，我们可以将收集到的序列转换为整数并将其附加为整数列表。让我们看看代码方面的内容：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The complete application is called *ExtractIntegers*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*ExtractIntegers*。
- en: Coding challenge 7 – Extracting the code points of surrogate pairs
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战7-提取代理对的代码点
- en: '**Problem**: Consider a given string containing any kind of characters, including
    Unicode characters, that are represented in Java as *surrogate pairs*. Write a
    snippet of code that extracts the *code points* of the *surrogate pairs* in a
    list.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个包含任何类型字符的给定字符串，包括在Java中表示为*代理对*的Unicode字符。编写一小段代码，从列表中提取*代理对*的*代码点*。'
- en: '**Solution**: Let''s consider that the given string contains the Unicode characters
    shown in the following image (the first three Unicode characters are represented
    in Java as *surrogate pairs*, while the last one is not):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑给定的字符串包含以下图像中显示的Unicode字符（前三个Unicode字符在Java中表示为*代理对*，而最后一个不是）：'
- en: '![Figure 10.3 – Unicode characters (surrogate pairs)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3-Unicode字符（代理对）'
- en: '](img/Figure_10.3_B15403.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.3_B15403.jpg)'
- en: Figure 10.3 – Unicode characters (surrogate pairs)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3-Unicode字符（代理对）
- en: 'In Java, we can write such a string as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们可以这样写这样的字符串：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To solve this problem, we must know several things, as follows (it is advisable
    to keep the following statements in mind since they are vital for solving problems
    that involve Unicode characters):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们必须了解一些事情，如下（牢记以下陈述对于解决涉及Unicode字符的问题至关重要）：
- en: Unicode characters that exceed 65,535 until 1,114,111 (0x10FFFF) don't fit into
    16 bits, and so 32-bit values (known as *code points*) were considered for the
    UTF-32 encoding scheme.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超过65,535直到1,114,111（0x10FFFF）的Unicode字符不适合16位，因此32位值（称为*代码点*）被考虑用于UTF-32编码方案。
- en: 'Unfortunately, Java doesn''t support UTF-32! Nevertheless, Unicode has come
    up with a solution for still using 16 bits to represent these characters. This
    solution implies the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Java不支持UTF-32！尽管如此，Unicode已经提出了一个解决方案，仍然使用16位来表示这些字符。这个解决方案意味着以下内容：
- en: '16-bit *high surrogates*: 1,024 values (U+D800 to U+DBFF)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16位*高代理项*：1,024个值（U+D800到U+DBFF）
- en: '16-bit *low surrogates*: 1,024 values (U+DC00 to U+DFFF)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16位*低代理项*：1,024个值（U+DC00到U+DFFF）
- en: Now, a *high surrogate* followed by a *low surrogate* defines what is known
    as a *surrogate pair*. These *surrogate pairs* are used to represent values between
    65,536 (0x10000) and 1,114,111 (0x10FFFF).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，*高代理项*后面跟着*低代理项*定义了所谓的*代理对*。这些*代理对*用于表示介于65,536（0x10000）和1,114,111（0x10FFFF）之间的值。
- en: Java takes advantage of this representation and exposes it via a suite of methods,
    such as `codePointAt()`, `codePoints()`, `codePointCount()`, and `offsetByCodePoints()`
    (take a look at the Java documentation for details).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java利用这种表示并通过一系列方法公开它，例如`codePointAt()`，`codePoints()`，`codePointCount()`和`offsetByCodePoints()`（查看Java文档以获取详细信息）。
- en: Calling `codePointAt()` instead of `charAt()`, `codePoints()` instead of `chars()`,
    and so on helps us write solutions that cover ASCII and Unicode characters as
    well.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`codePointAt()`而不是`charAt()`，`codePoints()`而不是`chars()`等有助于我们编写涵盖ASCII和Unicode字符的解决方案。
- en: 'For example, the well-known two-hearts symbol (first symbol in the preceding
    image) is a Unicode surrogate pair that can be represented as a `char[]` containing
    two values: \uD83D and \uDC95\. The *code point* of this symbol is 128149\. To
    obtain a `String` object from this code point, call the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，众所周知的双心符号（前图中的第一个符号）是一个Unicode代理对，可以表示为包含两个值的`char[]`：\uD83D和\uDC95。这个符号的*代码点*是128149。要从这个代码点获取一个`String`对象，请调用以下内容：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Counting the code points in `str` can be done by calling `str.codePointCount(0,str.length())`,
    which returns 1, even if the `str` length is 2\. Calling `str.codePointAt(0)`
    returns 128149, while calling `str.codePointAt(1)` returns 56469\. Calling `Character.toChars(128149).length`
    returns 2 since two characters are needed to represent this *code point* as a
    Unicode *surrogate pair*. For ASCII and Unicode 16-bit characters, it will return
    1.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`str.codePointCount(0,str.length())`可以计算`str`中的代码点数，即使`str`的长度为2，它也会返回1。调用`str.codePointAt(0)`返回128149，而调用`str.codePointAt(1)`返回56469。调用`Character.toChars(128149).length`返回2，因为需要两个字符来表示这个*代码点*作为Unicode*代理对*。对于ASCII和Unicode
    16位字符，它将返回1。
- en: 'Based on this example, we can identify a *surrogate pair* quite easily, as
    follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个例子，我们可以很容易地识别*代理对*，如下所示：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Or, like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，像这样：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The complete application is called *ExtractSurrogatePairs*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*ExtractSurrogatePairs*。
- en: Coding challenge 8 – Is rotation
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战8-是否旋转
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**'
- en: '**Problem**: Consider two given strings, *str1* and *str2*. Write a single
    line of code that tell us whether *str2* is a rotation of *str1*.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个给定的字符串*str1*和*str2*。编写一行代码，告诉我们*str2*是否是*str1*的旋转。'
- en: '**Solution**: Let''s consider that *str1* is *helloworld* and *str2* is *orldhellow*.
    Since *str2* is a rotation of *str1*, we can say that *str2* is obtained by cutting
    *str1* into two parts and rearranging them. The following image shows these words:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设*str1*是*helloworld*，*str2*是*orldhellow*。由于*str2*是*str1*的旋转，我们可以说*str2*是通过将*str1*分成两部分并重新排列得到的。以下图显示了这些单词：'
- en: '![Figure 10.4 – Cutting str1 into two parts and rearranging them'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 - 将str1分成两部分并重新排列'
- en: '](img/Figure_10.4_B15403.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.4_B15403.jpg)'
- en: Figure 10.4 – Cutting str1 into two parts and rearranging them
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 - 将str1分成两部分并重新排列
- en: 'So, based on this image, let''s denote the left-hand side of the scissor as
    *p1* and the right-hand side of the scissor as *p2*. With these notations, we
    can say that *p1 = hellow* and *p2 = orld*. Moreover, we can say that *str1 =
    p1+p2 = hellow + orld* and *str2 = p2+p1 = orld + hellow*. So, no matter where
    we perform the cut of *str1*, we can say that *str1 = p1+p2* and *str2=p2+p1*.
    However, this means that *str1+str2 = p1+p2+p2+p1 = hellow + orld + orld + hellow
    = p1+p2+p1+p2 = str1 + str1*, so *p2+p1* is a substring of *p1+***p2+p1***+p2*.
    In other words, *str2* must be a substring of *str1+str1*; otherwise, it cannot
    be a rotation of *str1*. In terms of code, we can write the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基于这个图像，让我们将剪刀的左侧表示为*p1*，将剪刀的右侧表示为*p2*。有了这些表示，我们可以说*p1 = hellow*，*p2 = orld*。此外，我们可以说*str1
    = p1+p2 = hellow + orld*，*str2 = p2+p1 = orld + hellow*。因此，无论我们在*str1*的哪里进行切割，我们都可以说*str1
    = p1+p2*，*str2=p2+p1*。然而，这意味着*str1+str2 = p1+p2+p2+p1 = hellow + orld + orld +
    hellow = p1+p2+p1+p2 = str1 + str1*，所以*p2+p1*是*p1+***p2+p1***+p2*的子字符串。换句话说，*str2*必须是*str1+str1*的子字符串；否则，它就不能是*str1*的旋转。在代码方面，我们可以写成以下形式：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The complete code is called *RotateString*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码称为*RotateString*。
- en: Coding challenge 9 – Rotating a matrix by 90 degrees
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战9 - 将矩阵逆时针旋转90度
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider a given *n* x *n* matrix of integers, *M*. Write a snippet
    of code that rotates this matrix by 90 degrees in a counterclockwise direction
    without using any extra space.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个给定的整数*n* x *n*矩阵*M*。编写一小段代码，将此矩阵逆时针旋转90度，而不使用任何额外空间。'
- en: '**Solution**: There are at least two solutions to this problem. One solution
    relies on the transpose of a matrix, while the other one relies on rotating the
    matrix ring by ring.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：对于这个问题，至少有两种解决方案。一种解决方案依赖于矩阵的转置，而另一种解决方案依赖于逐环旋转矩阵。'
- en: Using the matrix transpose
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用矩阵的转置
- en: 'Let''s tackle the first solution, which relies on finding the transpose of
    the matrix, *M*. The transpose of a matrix is a notion from linear algebra that
    means we need to flip a matrix over its main diagonal, which results in a new
    matrix denoted as *M*T. For example, having the matrix *M* and indices *i* and
    *j*, we can write the following relationship:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解决第一个解决方案，它依赖于找到矩阵*M*的转置。矩阵的转置是线性代数中的一个概念，意味着我们需要沿着其主对角线翻转矩阵，这将得到一个新的矩阵*M*T。例如，有矩阵*M*和索引*i*和*j*，我们可以写出以下关系：
- en: '![Figure 10.5 Relationship'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5关系'
- en: '](img/Figure_10.5_B15403.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.5_B15403.jpg)'
- en: Figure 10.5 – Matrix transpose relationship
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 - 矩阵转置关系
- en: 'Once we''ve obtained the transpose of *M*, we can reverse the columns of the
    transpose. This will give us the final result (the matrix *M* rotated by 90 degrees
    counterclockwise). The following image clarifies this relationship for a 5x5 matrix:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了*M*的转置，我们可以反转转置的列。这将给我们最终结果（矩阵*M*逆时针旋转90度）。以下图像阐明了这种关系，对于一个5x5的矩阵：
- en: '![Figure 10.6 – The transpose of a matrix on the left and the final result
    on the right'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6 - 矩阵的转置在左边，最终结果在右边'
- en: '](img/Figure_10.6_B15403.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.6_B15403.jpg)'
- en: Figure 10.6 – The transpose of a matrix on the left and the final result on
    the right
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 - 矩阵的转置在左边，最终结果在右边
- en: 'To obtain the transpose (*M*T), we can swap *M*[*j*][*i*] with *M*[*i*][*j*]
    via the following method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得转置(*M*T)，我们可以通过以下方法交换*M*[*j*][*i*]和*M*[*i*][*j*]：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Reversing the columns of *M*T can be done like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 反转*M*T的列可以这样做：
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This solution has a time complexity of O(n2) and a space complexity of O(1),
    so we respect the problem requirements. Now, let's look at another solution to
    this problem.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的时间复杂度为O(n2)，空间复杂度为O(1)，因此我们满足了问题的要求。现在，让我们看看这个问题的另一个解决方案。
- en: Rotating the matrix ring by ring
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逐环旋转矩阵
- en: 'If we think of a matrix as a set of concentric rings, then we can try to rotate
    each ring until the entire matrix is rotated. The following image is a visualization
    of this process for a 5x5 matrix:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将矩阵视为一组同心环，那么我们可以尝试旋转每个环，直到整个矩阵都被旋转。以下图像是一个5x5矩阵这个过程的可视化：
- en: '![Figure 10.7 – Rotating a matrix ring by ring'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7 - 逐环旋转矩阵'
- en: '](img/Figure_10.7_B15403.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.7_B15403.jpg)'
- en: Figure 10.7 – Rotating a matrix ring by ring
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 - 逐环旋转矩阵
- en: 'We can start from the outermost ring and eventually work our way inward. To
    rotate the outermost ring, we swap index by index, starting from the top, (0,
    0). This way, we move the right edge in place of the top edge, the bottom edge
    in place of the right edge, the left edge in place of the bottom edge, and the
    top edge in place of the left edge. When this process is done, the outermost ring
    is rotated by 90 degrees counterclockwise. We can continue with the second ring,
    starting from index (1, 1), and repeat this process until we rotate the second
    ring. Let''s see this in terms of code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从最外层开始，最终逐渐向内部工作。要旋转最外层，我们从顶部(0, 0)开始逐个交换索引。这样，我们将右边缘移到顶边缘的位置，将底边缘移到右边缘的位置，将左边缘移到底边缘的位置，将顶边缘移到左边缘的位置。完成此过程后，最外层环将逆时针旋转90度。我们可以继续进行第二个环，从索引(1,
    1)开始，并重复此过程，直到旋转第二个环。让我们看看代码方面的表现：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This solution has a time complexity of O(n2) and a space complexity of O(1),
    so we have respected the problem's requirements.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的时间复杂度为O(n2)，空间复杂度为O(1)，因此我们尊重了问题的要求。
- en: The complete application is called *RotateMatrix*. It also contains the solution
    for rotating the matrix 90 degrees clockwise. Moreover, it contains the solution
    for rotating the given matrix in a separate matrix.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*RotateMatrix*。它还包含了将矩阵顺时针旋转90度的解决方案。此外，它还包含了将给定矩阵旋转到一个单独矩阵的解决方案。
- en: Coding challenge 10 – Matrix containing zeros
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战10-包含零的矩阵
- en: '**Google**, **Adobe**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google**，**Adobe**'
- en: '**Problem**: Consider a given *n* x *m* matrix of integers, *M*. If *M*(*i,
    j*) is equal to 0, then the entire row, *i*, and column, *j*, should contain only
    zeros. Write a snippet of code that accomplishes this task without using any extra
    space.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个给定的*n* x *m*整数矩阵*M*。如果*M*(*i, j*)等于0，则整行*i*和整列*j*应该只包含零。编写一小段代码来完成这个任务，而不使用任何额外的空间。'
- en: '**Solution**: A naive approach consists of looping the matrix and for each
    (*i, j*) = 0, setting the row, *i*, and column, *j*, to zero. The problem is that
    when we traverse the cells of this row/column, we will find zeros and apply the
    same logic again. There is a big chance that we will end up with a matrix of zeros.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：一个天真的方法是循环遍历矩阵，对于每个(*i, j*) = 0，将行*i*和列*j*设置为零。问题在于当我们遍历这行/列的单元格时，我们会发现零并再次应用相同的逻辑。很有可能最终得到一个全是零的矩阵。'
- en: 'To avoid such naive approaches, it is better to take an example and try to
    visualize the solution. Let''s consider a 5x8 matrix, as shown in the following
    image:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种天真的方法，最好是拿一个例子并尝试可视化解决方案。让我们考虑一个5x8的矩阵，如下图所示：
- en: '![Figure 10.8 – Matrix containing zeros'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8-包含零的矩阵'
- en: '](img/Figure_10.8_B15403.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.8_B15403.jpg)'
- en: Figure 10.8 – Matrix containing zeros
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8-包含零的矩阵
- en: The initial matrix has a 0 at (0, 4) and another one at (2, 6). This means that
    the solved matrix should contains only zeros on rows 0 and 2 and on columns 4
    and 6.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 初始矩阵在(0,4)处有一个0，在(2,6)处有另一个0。这意味着解决后的矩阵应该只在第0行和第2行以及第4列和第6列上包含零。
- en: An easy-to-implement approach would be storing the locations of the zeros and,
    at a second traversal of the matrix, set the corresponding rows and columns to
    zero. However, storing the zeros means using some extra space, and this is not
    allowed by the problem.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一个易于实现的方法是存储零的位置，并在对矩阵进行第二次遍历时，将相应的行和列设置为零。然而，存储零意味着使用一些额外的空间，这是问题所不允许的。
- en: Tip
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: With a little trick and some work, we can keep the space complexity set to O(1).
    The trick consists of using the first row and column of the matrix to mark the
    zeros found in the rest of the matrix. For example, if we find a zero at cell
    (*i*, *j*) with *i*≠0 and *j*≠0, then we set *M*[*i*][0] = 0 and *M*[0][*j*] =
    0\. Once we've done that for the entire matrix, we can loop the first column (column
    0) and propagate each zero that's found on the row. After that, we can loop the
    first row (row 0) and propagate each zero that's found on the column.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一点技巧和一些工作，我们可以将空间复杂度设置为O(1)。技巧在于使用矩阵的第一行和第一列来标记在矩阵的其余部分找到的零。例如，如果我们在单元格(*i*,
    *j*)处找到一个零，其中*i*≠0且*j*≠0，则我们设置*M*[*i*][0] = 0和*M*[0][*j*] = 0。完成了整个矩阵的这个操作后，我们可以循环遍历第一列（列0）并传播在行上找到的每个零。之后，我们可以循环遍历第一行（行0）并传播在列上找到的每个零。
- en: 'But how about the potential initial zeros of the first row and column? Of course,
    we have to tackle this aspect as well, so we start by flagging whether the first
    row/column contains at least one 0:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但是第一行和第一列的潜在初始零怎么办？当然，我们也必须解决这个问题，所以我们首先标记第一行/列是否至少包含一个0：
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Furthermore, we apply what we''ve just said. To do this, we loop the rest of
    the matrix, and for each 0, we mark it on the first row and column:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们应用了我们刚才说的。为此，我们循环遍历矩阵的其余部分，对于每个0，我们在第一行和列上标记它：
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we can loop the first column (column 0) and propagate each zero that
    was found on the row. After that, we can loop the first row (row 0) and propagate
    each zero that was found on the column:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以循环遍历第一列（列0）并传播在行上找到的每个零。之后，我们可以循环遍历第一行（行0）并传播在列上找到的每个零：
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, if the first row contains at least one 0, then we set the entire row
    to 0\. Also, if the first column contains at least one 0, then we set the entire
    column to 0:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果第一行包含至少一个0，则我们将整行设置为0。同样，如果第一列包含至少一个0，则我们将整列设置为0：
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`setRowOfZero()` and `setColumnOfZero()` are quite simple:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`setRowOfZero()`和`setColumnOfZero()`都很简单：'
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The application is called *MatrixWithZeros*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序称为*MatrixWithZeros*。
- en: Coding challenge 11 – Implementing three stacks with one array
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战11-使用一个数组实现三个堆栈
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '`push()`, `pop()`, and `printStacks()`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()`，`pop()`和`printStacks()`。'
- en: '**Solution**: There are two main approaches to providing the required implementation.
    The approach that we''ll address here is based on interleaving the elements of
    these three stacks. Check out the following image:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：提供所需实现的两种主要方法。我们将在这里讨论的方法是基于交错这三个堆栈的元素。查看以下图片：'
- en: '![Figure 10.9 – Interleaving the nodes of the stacks'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9-交错堆栈的节点'
- en: '](img/Figure_10.9_B15403.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.9_B15403.jpg)'
- en: Figure 10.9 – Interleaving the nodes of the stacks
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9-交错堆栈的节点
- en: As you can see, there is a single array that holds the nodes of these three
    stacks, denoted as *Stack 1*, *Stack 2*, and *Stack 3*. The key to our implementation
    relies on the fact that each node that's pushed onto the stack (the array, respectively)
    has a backward link to its previous node. The bottom of each stack has a link
    to -1\. For example, for *Stack 1*, we know that value 2 at index 0 has a backward
    link to the dummy index -1, value 12 at index 1 has a backward link to the index
    0, and that value 1 at index 7 has a backward link to the index 1.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，有一个单一的数组，保存了这三个堆栈的节点，分别标记为*Stack 1*、*Stack 2*和*Stack 3*。我们实现的关键在于每个推送到堆栈（数组）上的节点都有一个指向其前一个节点的后向链接。每个堆栈的底部都有一个链接到-1。例如，对于*Stack
    1*，我们知道索引0处的值2有一个指向虚拟索引-1的后向链接，索引1处的值12有一个指向索引0的后向链接，索引7处的值1有一个指向索引1的后向链接。
- en: 'So, a stack node holds two pieces of information – the value and the backward
    link:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，堆栈节点保存了两个信息 – 值和后向链接：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On the other hand, the array manages a link to the next free slot. Initially,
    when the array is empty, we can only create free slots, so the links are shaped
    as follows (notice the `initializeSlots()` method):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，数组管理着到下一个空闲槽的链接。最初，当数组为空时，我们只能创建空闲槽，因此链接的形式如下（注意`initializeSlots()`方法）：
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, when we push a node into one of the stacks, we need to find a free slot
    and mark it as not free. This is done by the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们将一个节点推送到其中一个堆栈时，我们需要找到一个空闲槽并将其标记为非空闲。以下是相应的代码：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we pop a node from a stack, we must free that slot. This way, this slot
    can be reused by a future push. The relevant code is listed here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从堆栈中弹出一个节点时，我们必须释放该槽。这样，这个槽可以被未来的推送重用。相关的代码如下：
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The complete code, including the usage of `printStacks()`, is called *ThreeStacksInOneArray*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码，包括使用`printStacks()`，被称为*ThreeStacksInOneArray*。
- en: 'Another approach to solving this problem is splitting the array of stacks into
    three distinct zones:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的另一种方法是将堆栈数组分割成三个不同的区域：
- en: The first zone is assigned to the first stack and lies at the left-hand side
    of the array endpoint (while we push into this stack, it grows in the right direction).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一区域分配给第一个堆栈，并位于数组端点的左侧（当我们向这个堆栈推送时，它向右方向增长）。
- en: The second zone is assigned to the second stack and lies at the right-hand side
    of the array endpoint (while we push into this stack, it grows in the left direction).
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二区域分配给第二个堆栈，并位于数组端点的右侧（当我们向这个堆栈推送时，它向左方向增长）。
- en: The third zone is assigned to the third stack and lies in the middle of the
    array (while we push into this stack, it may grow in any direction).
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三区域分配给第三个堆栈，并位于数组的中间（当我们向这个堆栈推送时，它可以向任何方向增长）。
- en: 'The following image will help you clarify these points:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像将帮助您澄清这些观点：
- en: '![Figure 10.10 – Splitting the array into three zones'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10 – 将数组分割成三个区域'
- en: '](img/Figure_10.10_B15403.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.10_B15403.jpg)'
- en: Figure 10.10 – Splitting the array into three zones
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 将数组分割成三个区域
- en: The main challenge of this approach consists of avoiding stack collisions by
    shifting the middle stack accordingly. Alternatively, we can divide the array
    into three fixed zones and allow the individual stack to grow in that limited
    space. For example, if the array size is *s*, then the first stack can be from
    0 (inclusive) to *s*/3 (exclusive), the second stack can be from *s*/3 (inclusive)
    to 2**s*/3 (exclusive), and the third stack can be from 2**s*/3 (inclusive) to
    *s* (exclusive). This implementation is available in the bundled code as *ThreeStacksInOneArrayFixed*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要挑战在于通过相应地移动中间堆栈来避免堆栈碰撞。或者，我们可以将数组分成三个固定区域，并允许各个堆栈在有限的空间中增长。例如，如果数组大小为*s*，那么第一个堆栈可以从0（包括）到*s*/3（不包括），第二个堆栈可以从*s*/3（包括）到2*s*/3（不包括），第三个堆栈可以从2*s*/3（包括）到*s*（不包括）。这种实现在捆绑代码中作为*ThreeStacksInOneArrayFixed*可用。
- en: Alternatively, the middle stack could be implemented via an alternating sequence
    for subsequent pushes. This way, we also mitigate shifting but we are decreasing
    homogeneity. However, challenge yourself and implement this approach as well.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过交替序列实现中间堆栈以进行后续推送。这种方式，我们也可以减少移位，但我们正在减少均匀性。然而，挑战自己，也实现这种方法。
- en: Coding challenge 12 – Pairs
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战12 – 对
- en: '**Amazon**, **Adobe**, **Flipkart**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amazon**、**Adobe**、**Flipkart**'
- en: '**Problem**: Consider an array of integers (positive and negative), *m*. Write
    a snippet of code that finds all the pairs of integers whose sum is equal to a
    given number, *k*.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个整数数组（正数和负数），*m*。编写一小段代码，找到所有和为给定数字*k*的整数对。'
- en: '**Solution**: As usual, let''s consider an example. Let''s assume we have an
    array of 15 elements, as follows: -5, -2, 5, 4, 3, 7, 2, 1, -1, -2, 15, 6, 12,
    -4, 3\. Also, if *k*=10, then we have four pairs whose sum is 10: (-15 + 5), (-2
    + 12), (3 + 7), and (4 + 6). But how do we find these pairs?'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：像往常一样，让我们考虑一个例子。假设我们有一个包含15个元素的数组，如下所示：-5, -2, 5, 4, 3, 7, 2, 1, -1,
    -2, 15, 6, 12, -4, 3。另外，如果*k*=10，那么我们有四对和为10的数：(-15 + 5), (-2 + 12), (3 + 7),
    和 (4 + 6)。但是我们如何找到这些对呢？'
- en: There are different approaches to solving this problem. For example, we have
    the brute-force approach (usually, interviewers don't like this approach, so use
    it only as a last resort – while the brute-force approach can be a good start
    for understanding the details of the problem, it is not accepted as the final
    solution). Conforming to brute force, we take each element from the array and
    try to make a pair with each of the remaining elements. As with almost any brute-force-based
    solution, this one has an unacceptable complexity time as well.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有不同的方法。例如，我们有蛮力方法（通常，面试官不喜欢这种方法，所以只在万不得已时使用它 – 尽管蛮力方法可以很好地帮助我们理解问题的细节，但它不被接受为最终解决方案）。按照蛮力方法，我们从数组中取出每个元素，并尝试与其余元素中的每个元素配对。与几乎任何基于蛮力的解决方案一样，这个解决方案的时间复杂度也是不可接受的。
- en: 'We can find a better approach if we consider sorting the given array. We can
    do this via the Java built-in `Arrays.sort()` method, which has a runtime of O(n
    log n). Having a sorted array allows us to use two pointers that scan the whole
    array based on the following steps (this technique is known as *two-pointers*
    and you''ll see it at work in several problems during this chapter):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑对给定数组进行排序，我们可以找到更好的方法。我们可以通过Java内置的`Arrays.sort()`方法来实现这一点，其运行时间为O(n log
    n)。有了排序后的数组，我们可以使用两个指针来扫描整个数组，基于以下步骤（这种技术称为*双指针*，在本章的几个问题中都会看到它的应用）：
- en: One pointer starts from index 0 (left pointer; let's denote it as *l*) and the
    other pointer starts from (*m.length* - 1) index (right pointer; let's denote
    it as *r*).
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个指针从索引0开始（左指针；我们将其表示为*l*），另一个指针从（*m.length* - 1）索引开始（右指针；我们将其表示为*r*）。
- en: If *m*[*l*] *+ m*[*r*] *= k*, then we have a solution and we can increment the
    *l* position and decrement the *r* position.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*m*[*l*] *+ m*[*r*] *= k*，那么我们有一个解决方案，我们可以增加*l*位置并减少*r*位置。
- en: If *m*[*l*] *+ m*[*r*]*<k*, then we increment *l* and keep *r* in place.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*m*[*l*] *+ m*[*r*]*<k*，那么我们增加*l*并保持*r*不变。
- en: If *m*[*l*] *+ m*[*r*]*>k*, then we decrement *r* and keep *l* in place.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*m*[*l*] *+ m*[*r*]*>k*，那么我们减少*r*并保持*l*不变。
- en: We repeat *steps 2-4* until *l>= r*.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重复*步骤2-4*，直到*l>= r*。
- en: 'The following image will help you implement these steps:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片将帮助您实现这些步骤：
- en: '![Figure 10.11 – Finding all pairs whose sum is equal to the given number'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.11 - 找到所有和为给定数字的对'
- en: '](img/Figure_10.11_B15403.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.11_B15403.jpg)'
- en: Figure 10.11 – Finding all pairs whose sum is equal to the given number
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 - 找到所有和为给定数字的对
- en: 'Keep an eye on this image while we see how it works for *k*=10:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看看它如何适用于*k*=10时，请留意这张图片：
- en: '*l* = 0, *r* = 14 → *sum* = *m*[0] + *m*[14] = -5 + 15 = 10 → *sum* = *k* →
    *l*++, *r*--'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*l*= 0，*r*= 14 → *sum* = *m*[0] + *m*[14] = -5 + 15 = 10 → *sum* = *k* → *l*++，*r*--'
- en: '*l* = 1, *r* = 13 → *sum* = *m*[1] + *m*[13] = -4 + 12 = 8 → *sum < k* → *l*++'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*l*= 1，*r*= 13 → *sum* = *m*[1] + *m*[13] = -4 + 12 = 8 → *sum < k* → *l*++'
- en: '*l* = 2, *r* = 13 → *sum* = *m*[2] + *m*[13] = -2 + 12 = 10 → *sum* = *k* →
    *l*++, *r*--'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*l*= 2，*r*= 13 → *sum* = *m*[2] + *m*[13] = -2 + 12 = 10 → *sum* = *k* → *l*++，*r*--'
- en: '*l* = 3, *r* = 12 → *sum* = *m*[3] + *m*[12] = -2 + 7 = 5 → *sum < k* → *l*++'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*l*= 3，*r*= 12 → *sum* = *m*[3] + *m*[12] = -2 + 7 = 5 → *sum < k* → *l*++'
- en: '*l* = 4, *r* = 12 → *sum* = *m*[4] + *m*[12] = -1 + 7 = 6 → *sum* < *k* → *l*++'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*l*= 4，*r*= 12 → *sum* = *m*[4] + *m*[12] = -1 + 7 = 6 → *sum* < *k* → *l*++'
- en: '*l* = 5, *r* = 12 → *sum* = *m*[5] + *m*[12] = 1 + 7 = 8 → *sum* < *k* → *l*++'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*l*= 5，*r*= 12 → *sum* = *m*[5] + *m*[12] = 1 + 7 = 8 → *sum* < *k* → *l*++'
- en: '*l* = 6, *r* = 12 → *sum* = *m*[6] + *m*[12] = 2 + 7 = 9 → *sum* < *k* → *l*++'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*l*= 6，*r*= 12 → *sum* = *m*[6] + *m*[12] = 2 + 7 = 9 → *sum* < *k* → *l*++'
- en: '*l* = 7, *r* = 12 → *sum* = *m*[7] + *m*[12] = 3 + 7 = 10 → *sum* = *k* → *l*++,
    *r*--'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*l*= 7，*r*= 12 → *sum* = *m*[7] + *m*[12] = 3 + 7 = 10 → *sum* = *k* → *l*++，*r*--'
- en: '*l* = 8, *r* = 11 → *sum* = *m*[8] + *m*[11] = 3 + 6 = 9 → *sum* < *k* → *l*++'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*l*= 8，*r*= 11 → *sum* = *m*[8] + *m*[11] = 3 + 6 = 9 → *sum* < *k* → *l*++'
- en: '*l* = 9, *r*= 11 → *sum* = *m*[9] + *m*[11] = 4 + 6 = 10 → *sum* = *k* → *l*++,
    *r*--'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*l*= 9，*r*= 11 → *sum* = *m*[9] + *m*[11] = 4 + 6 = 10 → *sum* = *k* → *l*++，*r*--'
- en: '*l* = 10, *r* = 10 → STOP'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*l*= 10，*r*= 10 → 停止'
- en: 'If we put this logic into code, then we obtain the following method:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个逻辑放入代码中，那么我们会得到以下方法：
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The complete application is called *FindPairsSumEqualK*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*FindPairsSumEqualK*。
- en: Coding challenge 13 – Merging sorted arrays
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战13 - 合并排序数组
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Imagine that you have *k* sorted arrays of different lengths.
    Write an application that merges these arrays into O(nk log n), where *n* is the
    length of the longest array.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设您有*k*个不同长度的排序数组。编写一个应用程序，将这些数组合并到O(nk log n)中，其中*n*是最长数组的长度。'
- en: '**Solution**: Let''s assume that the given arrays are the following five arrays
    denoted with *a*, *b*, *c*, *d*, and *e*:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设给定的数组是以下五个数组，分别表示为*a*、*b*、*c*、*d*和*e*：'
- en: '*a*: {1, 2, 32, 46} *b*: {-4, 5, 15, 18, 20} *c*: {3} *d*: {6, 8} *e*: {-2,
    -1, 0}'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*：{1, 2, 32, 46} *b*：{-4, 5, 15, 18, 20} *c*：{3} *d*：{6, 8} *e*：{-2, -1,
    0}'
- en: 'The expected result will be as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果如下：
- en: '{-4, -2, -1, 0, 1, 2, 3, 5, 6, 8, 15, 18, 20, 32, 46}'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '{-4, -2, -1, 0, 1, 2, 3, 5, 6, 8, 15, 18, 20, 32, 46}'
- en: The simplest approach consists of copying all the elements from these arrays
    into a single array. This will take O(nk), where *n* is the length of the longest
    array and *k* is the number of arrays. Next, we sort this array via an O(n log
    n) time complexity algorithm (for example, via Merge Sort). This will result in
    O(nk log nk). However, the problem requires us to write an algorithm that can
    perform in O(nk log n).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是将这些数组中的所有元素复制到单个数组中。这将花费O(nk)的时间，其中*n*是最长数组的长度，*k*是数组的数量。接下来，我们通过O(n
    log n)的时间复杂度算法（例如，通过归并排序）对这个数组进行排序。这将导致O(nk log nk)。然而，问题要求我们编写一个可以在O(nk log n)中执行的算法。
- en: 'There are several solutions that perform in O(nk log n), and one of them is
    based on a Binary Min Heap (this is detailed in [*Chapter 13*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)*,
    Trees and Graphs*). In a nutshell, a Binary Min Heap is a complete binary tree.
    A Binary Min Heap is typically represented as an array (let''s denote it as *heap*)
    whose root is at *heap*[0]. More importantly, for *heap*[*i*], we have the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种解决方案可以在O(nk log n)中执行，其中之一是基于二进制最小堆（这在[*第13章*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)*，树和图*中有详细说明）。简而言之，二进制最小堆是一棵完全二叉树。二进制最小堆通常表示为一个数组（让我们将其表示为*heap*），其根位于*heap*[0]。更重要的是，对于*heap*[*i*]，我们有以下内容：
- en: '*heap*[(*i* - 1) / 2]: Returns the parent node'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*heap*[(*i* - 1) / 2]：返回父节点'
- en: '*heap*[(2 * *i*) + 1]: Returns the left child node'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*heap*[(2 * *i*) + 1]：返回左子节点'
- en: '*heap*[(2 * *i*) + 2]: Returns the right child node'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*heap*[(2 * *i*) + 2]：返回右子节点'
- en: 'Now, our algorithm follows these steps:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的算法遵循以下步骤：
- en: Create the resulting array of size *n*k*.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建大小为*nk*的结果数组。
- en: Create a Binary Min Heap of size *k* and insert the first element of all the
    arrays into this heap.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建大小为*k*的二进制最小堆，并将所有数组的第一个元素插入到此堆中。
- en: 'Repeat the following steps *n*k* times:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复以下步骤*nk*次：
- en: a. Get the minimum element from the Binary Min Heap and store it in the resulting
    array.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 从二进制最小堆中获取最小元素，并将其存储在结果数组中。
- en: b. Replace the Binary Min Heap's root with the next element from the array that
    the element was extracted from (if the array doesn't have any more elements, then
    replace the root element with infinite; for example, with `Integer.MAX_VALUE`).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: b. 用来自提取元素的数组的下一个元素替换二进制最小堆的根（如果数组没有更多元素，则用无限大替换根元素；例如，用`Integer.MAX_VALUE`）。
- en: c. After replacing the root, *heapify* the tree.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: c. 替换根后，*heapify*树。
- en: 'The code is too big to be listed in this book, so the following is just the
    end of its implementation (the heap structure and the `merge()` operation):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码太长，无法在本书中列出，因此以下只是其实现的结尾（堆结构和`merge()`操作）：
- en: '[PRE26]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following code is for the `merge()` operation:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`merge()`操作：
- en: '[PRE27]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The complete application is called *MergeKSortedArr*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*MergeKSortedArr*。
- en: Coding challenge 14 – Median
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战14 - 中位数
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider two sorted arrays, *q* and *p* (they can have different
    lengths). Write an application that computes the median value of these two arrays
    in logarithmic runtime.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个排序好的数组*q*和*p*（它们的长度可以不同）。编写一个应用程序，在对数时间内计算这两个数组的中位数值。'
- en: '**Solution**: A median value separates the higher half of a data sample (for
    example, an array) from the lower half. For example, the following image shows
    the median value of an array with an odd number of elements (left-hand side) and
    with an even number of elements (right-hand side), respectively:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：中位数值将数据样本（例如数组）的较高一半与较低一半分开。例如，下图分别显示了具有奇数元素数量的数组和具有偶数元素数量的数组的中位数值：'
- en: '![Figure 10.12 – Median values for odd and even arrays'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.12 - 奇数和偶数数组的中位数值'
- en: '](img/Figure_10.12_B15403.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.12_B15403.jpg)'
- en: Figure 10.12 – Median values for odd and even arrays
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 - 奇数和偶数数组的中位数值
- en: 'So, for an array with *n* number of elements, we have the following two formulas:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于一个包含*n*个元素的数组，我们有以下两个公式：
- en: If *n* is odd, then the median value is given by (*n*+1)/2
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*n*是奇数，则中位数值为(*n*+1)/2
- en: If *n* is even, then the median value is given by [(*n*/2+(*n*/2+1)]/2
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*n*是偶数，则中位数值为[(*n*/2+(*n*/2+1)]/2
- en: It is quite easy to compute the median of a single array. But how do we compute
    it for two arrays of different lengths? We have two sorted arrays and we must
    find something out from them. Having the experience of a candidate that knows
    how to prepare for an interview should be enough to intuit that the well-known
    Binary Search algorithm should be considered. Typically, having sorted arrays
    is something you should take into consideration when implementing the Binary Search
    algorithm.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 计算单个数组的中位数是相当容易的。但是，我们如何计算两个长度不同的数组的中位数呢？我们有两个排序好的数组，我们必须从中找出一些东西。有经验的求职者应该能够直觉到应该考虑使用著名的二分搜索算法。通常，在实现二分搜索算法时，应该考虑到有序数组。
- en: We can roughly intuit that finding the median value of two sorted arrays can
    be reduced to finding the proper conditions that must be respected by this value.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大致可以直觉到，找到两个排序数组的中位数值可以简化为找到必须被这个值遵守的适当条件。
- en: 'Since the median value divides input into two equal parts, we can conclude
    that the first condition imposes that the median value of the *q* array should
    be at the middle index. If we denote this middle index as *qPointer*, then we
    obtain two equal parts: [0, *qPointer*] and [*qPointer*+1*, q.length*]*.* If we
    apply the same logic to the *p* array, then the median value of the *p* array
    should be at the middle index as well. If we denote this middle index as *pPointer*,
    then we obtain two equal parts: [0, *pPointer*] and [*pPointer*+1, *p.length*].
    Let''s visualize this via the following diagram:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于中位数值将输入分成两个相等的部分，我们可以得出第一个条件是*q*数组的中位数值应该在中间索引处。如果我们将这个中间索引表示为*qPointer*，那么我们得到两个相等的部分：[0，*qPointer*]和[*qPointer*+1，*q.length*]。如果我们对*p*数组应用相同的逻辑，那么*p*数组的中位数值也应该在中间索引处。如果我们将这个中间索引表示为*pPointer*，那么我们得到两个相等的部分：[0，*pPointer*]和[*pPointer*+1，*p.length*]。让我们通过以下图表来可视化这一点：
- en: '![Figure 10.13 – Splitting arrays into two equal parts'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.13 - 将数组分成两个相等的部分'
- en: '](img/Figure_10.13_B15403.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.13_B15403.jpg)'
- en: Figure 10.13 – Splitting arrays into two equal parts
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 - 将数组分成两个相等的部分
- en: We can conclude from this diagram that the first condition that the median value
    should respect is *qLeft + pLeft = qRight + pRight*. In other words, *qPointer
    + pPointer =* (*q.length- qPointer*) *+* (*p.length - pPointer*).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这个图表中得出结论，中位数值应该遵守的第一个条件是*qLeft + pLeft = qRight + pRight*。换句话说，*qPointer
    + pPointer =* (*q.length- qPointer*) *+* (*p.length - pPointer*)。
- en: 'However, since our arrays aren''t the same length (they can be equal, but this
    is just a special case that should be covered by our solution as well), we cannot
    simply halve both of them. What we can do is assume that *p* >= *q* (if they are
    not given like this, then we just swap them to force this assumption). Furthermore,
    under the umbrella of this assumption, we can write the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们的数组长度不同（它们可以相等，但这只是我们解决方案应该覆盖的特殊情况），我们不能简单地将它们都减半。我们可以假设*p* >= *q*（如果它们没有给出这样的情况，那么我们只需交换它们以强制执行这个假设）。在这个假设的前提下，我们可以写出以下内容：
- en: '*qPointer + pPointer =* (*q.length- qPointer*) *+* (*p.length - pPointer*)
    *→*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*qPointer + pPointer =* (*q.length- qPointer*) *+* (*p.length - pPointer*)
    *→*'
- en: 2 ** pPointer = q.length + p.length -* 2 ** qPointer →*
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 2 ** pPointer = q.length + p.length -* 2 ** qPointer →*
- en: '*pPointer =* (*q.length + p.length*)*/*2 *- qPointer*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*pPointer =* (*q.length + p.length*)*/*2 *- qPointer*'
- en: 'So far, *pPointer* can fall in the middle and we can avoid this by adding 1,
    which means we have the following starting pointers:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，*pPointer*可以落在中间，我们可以通过添加1来避免这种情况，这意味着我们有以下起始指针：
- en: '*qPointer* = ((*q.length* - 1) + 0)/2'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*qPointer* = ((*q.length* - 1) + 0)/2'
- en: '*pPointer* = (*q.length* + *p.length* + 1)/2 - *qPointer*'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pPointer* = (*q.length* + *p.length* + 1)/2 - *qPointer*'
- en: If *p*>=*q*, then the minimum (*q.length* + *p.length* + 1)/2 - *qPointer* will
    always lead to *pPointer* as a positive integer. This will eliminate array-out-of-bounds
    exceptions and respects the first condition as well.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *p*>=*q*，那么最小值 (*q.length* + *p.length* + 1)/2 - *qPointer* 将始终导致 *pPointer*
    成为正整数。这将消除数组越界异常，并且也遵守第一个条件。
- en: 'However, our first condition is not enough because it doesn''t guarantee that
    all the elements in the left array are less than the elements in the right array.
    In other words, the maximum of the left part must be less than the minimum of
    the right part. The maximum of the left part can be *q*[*qPointer*-1] or *p*[*pPointer*-1],
    while the minimum of the right part can be *q*[*qPointer*] or *p*[*pPointer*].
    So, we can conclude that the following conditions should be respected as well:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的第一个条件还不够，因为它不能保证左数组中的所有元素都小于右数组中的元素。换句话说，左部分的最大值必须小于右部分的最小值。左部分的最大值可以是
    *q*[*qPointer*-1] 或 *p*[*pPointer*-1]，而右部分的最小值可以是 *q*[*qPointer*] 或 *p*[*pPointer*]。因此，我们可以得出以下条件也应该被遵守：
- en: '*q*[*qPointer*-1] <= *p*[*pPointer*]'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*q*[*qPointer*-1] <= *p*[*pPointer*]'
- en: '*p*[*pPointer*-1] <= *q*[*qPointer*]'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p*[*pPointer*-1] <= *q*[*qPointer*]'
- en: 'Under these conditions, the median value of *q* and *p* will be as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些条件下，*q* 和 *p* 的中值将如下所示：
- en: '*p.length* + *q.length* is even: The average of the maximum of the left part
    and the minimum of the right part'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p.length* + *q.length* 是偶数：左部分的最大值和右部分的最小值的平均值'
- en: '*p.length* + *q.length* is odd: The maximum of the left parts, max(*q*[*qPointer*-1],
    *p*[*pPointer*-1]).'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p.length* + *q.length* 是奇数：左部分的最大值，max(*q*[*qPointer*-1], *p*[*pPointer*-1])。'
- en: 'Let''s try to summarize this in an algorithm with three steps and an example.
    We start with *qPointer* as the middle of *q* (so as, [(*q.length* - 1) + 0)/2]
    and with *pPointer* as (*q.length* + *p.length* + 1)/2 - *qPointer*. Let''s go
    through the following steps:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用三个步骤和一个例子总结这个算法。我们以 *q* 的中间值作为 *qPointer*（即[(*q.length* - 1) + 0)/2]），以
    (*q.length* + *p.length* + 1)/2 - *qPointer* 作为 *pPointer*。让我们按照以下步骤进行：
- en: If *q*[*qPointer*-1] <= *p*[*pPointer*] and *p*[*pPointer*-1] <= *q*[*qPointer*],
    then we have found the perfect *qPointer* (the perfect index).
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 *q*[*qPointer*-1] <= *p*[*pPointer*] 并且 *p*[*pPointer*-1] <= *q*[*qPointer*]，那么我们找到了完美的
    *qPointer*（完美的索引）。
- en: If *p*[*pPointer*-1] >*q*[*qPointer*], then we know that *q*[*qPointer*] is
    too small, so *qPointer* must be increased and *pPointer* must be decreased. Since
    the arrays are sorted, this action will result in a bigger *q*[*qPointer*] and
    a smaller *p*[*pPointer*]. Moreover, we can conclude that *qPointer* can only
    be in the right part of *q* (from *middle*+1 to *q.length*). Go back to *step
    1*.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 *p*[*pPointer*-1] >*q*[*qPointer*]，那么我们知道 *q*[*qPointer*] 太小了，所以必须增加 *qPointer*
    并减少 *pPointer*。由于数组是排序的，这个操作将导致 *q*[*qPointer*] 变大，*p*[*pPointer*] 变小。此外，我们可以得出结论，*qPointer*
    只能在 *q* 的右部分（从 *middle*+1 到 *q.length*）中。回到 *步骤1*。
- en: If *q*[*qPointer*-1] >*p*[*pPointer*], then we know that *q*[*qPointer*-1] is
    too big. We must decrease *qPointer* to get *q*[*qPointer*-1] <= *p*[*pPointer*].
    Moreover, we can conclude that *qPointer* can be only in the left part of *q*
    (from 0 to *middle*-1). Go to *step 2*.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 *q*[*qPointer*-1] >*p*[*pPointer*]，那么我们知道 *q*[*qPointer*-1] 太大了。我们必须减少 *qPointer*
    以使 *q*[*qPointer*-1] <= *p*[*pPointer*]。此外，我们可以得出结论，*qPointer* 只能在 *q* 的左部分（从0到
    *middle*-1）中。前往 *步骤2*。
- en: Now, let's consider that *q*={ 2, 6, 9, 10, 11, 65, 67} and *p*={ 1, 5, 17,
    18, 25, 28, 39, 77, 88}, and let's apply the previous steps.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设 *q*={ 2, 6, 9, 10, 11, 65, 67}，*p*={ 1, 5, 17, 18, 25, 28, 39, 77,
    88}，并应用上述步骤。
- en: 'Conforming to our preceding statements, we know that *qPointer* = (0 + 6) /
    2 = 3 and *pPointer* = (7 + 9 + 1) / 2 - 3 = 5\. The following image speaks for
    itself:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的陈述，我们知道 *qPointer* = (0 + 6) / 2 = 3，*pPointer* = (7 + 9 + 1) / 2 - 3
    = 5。下面的图像说明了这一点：
- en: '![Figure 10.14 – Computing the median value (step 1)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.14 - 计算中值（步骤1）'
- en: '](img/Figure_10.14_B15403.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.14_B15403.jpg)'
- en: Figure 10.14 – Computing the median value (step 1)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 - 计算中值（步骤1）
- en: 'Step 1 of our algorithm specifies that *q*[*qPointer*-1] <= *p*[*pPointer*]
    and *p*[*pPointer*-1] <= *q*[*qPointer*]. Obviously, 9 < 28, but 25 > 10, so we
    apply *step 2* and afterward, go back to *step 1*. We increase *qPointer* and
    decrease *pPointer*, so *qPointerMin* becomes *qPointer* + 1\. The new *qPointer*
    will be (4 + 6) / 2 = 5 and the new *pPointer* will be (7 + 9 + 1)/2 - 5 = 3\.
    The following image will help you visualize this scenario:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的算法的第1步规定 *q*[*qPointer*-1] <= *p*[*pPointer*] 并且 *p*[*pPointer*-1] <= *q*[*qPointer*]。显然，9
    < 28，但 25 > 10，所以我们应用 *步骤2*，然后回到 *步骤1*。我们增加 *qPointer* 并减少 *pPointer*，所以 *qPointerMin*
    变为 *qPointer* + 1。新的 *qPointer* 将是 (4 + 6) / 2 = 5，新的 *pPointer* 将是 (7 + 9 + 1)/2
    - 5 = 3。下面的图像将帮助您可视化这种情况：
- en: '![Figure 10.15 – Computing the median value (step 2)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.15 - 计算中值（步骤2）'
- en: '](img/Figure_10.15_B15403.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.15_B15403.jpg)'
- en: Figure 10.15 – Computing the median value (step 2)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 - 计算中值（步骤2）
- en: Here, you can see that the new *qPointer* and new *pPointer* respect *step 1*
    of our algorithm since *q*[*qPointer*-1], which is 11, is less than *p*[*pPointer*],
    which is, 18; and *p*[*pPointer*-1], which is 17, is less than *q*[*qPointer*],
    which is 65\. With this, we found the perfect *qPointer* to be 5.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到新的 *qPointer* 和新的 *pPointer* 遵守了我们算法的 *步骤1*，因为 *q*[*qPointer*-1]，即11，小于
    *p*[*pPointer*]，即18；而 *p*[*pPointer*-1]，即17，小于 *q*[*qPointer*]，即65。有了这个，我们找到了完美的
    *qPointer*，为5。
- en: 'Finally, we have to find the maximum of the left-hand side and the minimum
    of the right-hand side and, based on the odd or even length of the two arrays,
    return the maximum of the left-hand side or the average of the maximum of the
    left-hand side and the minimum of the right-hand side. We know that the maximum
    of the left-hand side is max(*q*[*qPointer*-1], *p*[*pPointer*-1]), so max(11,
    17) = 17\. We also know that the minimum of the right-hand side is min(*q*[*qPointer*],
    *p*[*pPointer*]), so min(65, 18) = 18\. Since the sum of lengths is 7 + 9 = 16,
    we compute that the median value is the average of these two, so avg(17, 18) =
    17.5\. We can visualize this as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须找到左侧的最大值和右侧的最小值，并根据两个数组的奇偶长度返回左侧的最大值或左侧的最大值和右侧的最小值的平均值。我们知道左侧的最大值是max(*q*[*qPointer*-1],
    *p*[*pPointer*-1])，所以max(11, 17) = 17。我们也知道右侧的最小值是min(*q*[*qPointer*], *p*[*pPointer*])，所以min(65,
    18) = 18。由于长度之和为7 + 9 = 16，我们计算出中位数的值是这两个值的平均值，所以avg(17, 18) = 17.5。我们可以将其可视化如下：
- en: '![Figure 10.16 – Median value (final result)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.16 - 中位数（最终结果）'
- en: '](img/Figure_10.16_B15403.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.16_B15403.jpg)'
- en: Figure 10.16 – Median value (final result)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 - 中位数（最终结果）
- en: 'Putting this algorithm into code results in the following output:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个算法转化为代码的结果如下：
- en: '[PRE28]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our solution performs in O(log(max(*q.length, p.length*)) time. The complete
    application is called *MedianOfSortedArrays*.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的解决方案在O(log(max(*q.length, p.length*))时间内执行。完整的应用程序称为*MedianOfSortedArrays*。
- en: Coding challenge 15 – Sub-matrix of one
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战15-一个的子矩阵
- en: '**Amazon**, **Microsoft**, **Flipkart**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**微软**，**Flipkart**'
- en: '**Problem**: Consider that you''ve been given a matrix, *m* x *n*, containing
    only 0 and 1 (binary matrix). Write a snippet of code that returns the maximum
    size of the square sub-matrix so that it contains only elements of 1.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你得到了一个只包含0和1（二进制矩阵）的矩阵，*m* x *n*。编写一小段代码，返回只包含元素1的最大正方形子矩阵的大小。'
- en: '**Solution**: Let''s consider that the given matrix is the one in the following
    image (5x7 matrix):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们假设给定的矩阵是以下图像中的矩阵（5x7矩阵）：'
- en: '![Figure 10.17 – The given 5x7 binary matrix'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.17 - 给定的5x7二进制矩阵'
- en: '](img/Figure_10.17_B15403.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.17_B15403.jpg)'
- en: Figure 10.17 – The given 5 x 7 binary matrix
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 - 给定的5 x 7二进制矩阵
- en: As you can see, the square sub-matrix only containing elements of 1 has a size
    of 3\. The brute-force approach, or the naive approach, would be to find all the
    square sub-matrices containing all 1s and determine which one has the maximum
    size. However, for an *m* x *n* matrix that has *z*=min(*m, n*), the time complexity
    will be O(z3mn). You can find the brute-force implementation in the code bundled
    with this book. Of course, challenge yourself before checking the solution.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，只包含元素1的正方形子矩阵的大小为3。蛮力方法，或者说是朴素方法，是找到所有包含所有1的正方形子矩阵，并确定哪一个具有最大的大小。然而，对于一个*m*
    x *n*矩阵，其中*z*=min(*m, n*)，时间复杂度将为O(z3mn)。你可以在本书附带的代码中找到蛮力实现。当然，在查看解决方案之前，先挑战自己。
- en: 'For now, let''s try to find a better approach. Let''s consider that the given
    matrix is of size *n* x *n* and study several scenarios of a 4x4 sample matrix.
    In a 4x4 matrix, we can see that the maximum square sub-matrix of 1s can have
    a size of 3x3, so in a matrix of size *n* x *n*, the maximum square sub-matrix
    of 1s can have a size of *n*-1x *n*-1\. Moreover, the following image reveals
    two base cases that are true for an *m x n* matrix as well:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试着找到一个更好的方法。让我们假设给定的矩阵是大小为*n* x *n*，并研究一个4x4样本矩阵的几种情况。在4x4矩阵中，我们可以看到1s的最大正方形子矩阵可以有3x3的大小，因此在大小为*n*
    x *n*的矩阵中，1s的最大正方形子矩阵可以有大小为*n*-1x *n*-1。此外，以下图像显示了对*m x n*矩阵同样适用的两个基本情况：
- en: '![Figure 10.18 – Maxim sub-matrix of 1s in a 4x4 matrix'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.18 - 4x4矩阵中1s的最大子矩阵'
- en: '](img/Figure_10.18_B15403.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.18_B15403.jpg)'
- en: Figure 10.18 – Maxim sub-matrix of 1s in a 4 x 4 matrix
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 - 4 x 4矩阵中1s的最大子矩阵
- en: 'These cases are explained as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况解释如下：
- en: If the given matrix contains only one row, then cells with 1's in them will
    be the maximum size of the square sub-matrix. Therefore, the maximum size is 1.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给定的矩阵只包含一行，那么其中包含1的单元格将是最大正方形子矩阵的大小。因此，最大大小为1。
- en: If the given matrix contains only one column, then cells with 1's in them will
    be the maximum size of the square sub-matrix. Therefore, the maximum size is 1.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给定的矩阵只包含一列，那么其中包含1的单元格将是最大正方形子矩阵的大小。因此，最大大小为1。
- en: 'Next, let''s consider that *subMatrix*[*i*][*j*] represents the maximum size
    of the square sub-matrix, with all 1s ending at cell (*i,j*):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们假设*subMatrix*[*i*][*j*]表示以单元格(*i,j*)结尾的只包含1的最大正方形子矩阵的大小：
- en: '![Figure 10.19 – Overall recurrence relation'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.19 - 整体递归关系'
- en: '](img/Figure_10.19_B15403.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.19_B15403.jpg)'
- en: Figure 10.19 – Overall recurrence relation
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19 - 整体递归关系
- en: 'The preceding figure allows us to establish a recurrence relation between the
    given matrix and an auxiliary *subMatrix* (a matrix that''s the same size as the
    given matrix that should be filled in based on the recurrence relation):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表允许我们在给定矩阵和辅助*subMatrix*（与给定矩阵大小相同的矩阵，应根据递归关系填充）之间建立递归关系：
- en: It is not easy to intuit this, but we can see that if *matrix*[*i*][*j*] = 0,
    then *subMatrix*[*i*][*j*] = 0
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这并不容易直觉到，但我们可以看到，如果*matrix*[*i*][*j*] = 0，那么*subMatrix*[*i*][*j*] = 0
- en: If *matrix*[*i*][*j*] = 1, then *subMatrix*[*i*][*j*]
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*matrix*[*i*][*j*] = 1，那么*subMatrix*[*i*][*j*]
- en: = 1 + min(*subMatrix*[*i* - 1][*j*], *subMatrix*[*i*][*j* - 1], *subMatrix*[*i*
    - 1][*j* - 1])
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: = 1 + min(*subMatrix*[*i* - 1][*j*], *subMatrix*[*i*][*j* - 1], *subMatrix*[*i*
    - 1][*j* - 1])
- en: 'If we apply this algorithm to our 5 x 7 matrix, then we obtain the following
    result:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个算法应用到我们的5 x 7矩阵中，那么我们将得到以下结果：
- en: '![Figure 10.20 – Resolving our 5x7 matrix'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.20 - 解决我们的5x7矩阵'
- en: '](img/Figure_10.20_B15403.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.20_B15403.jpg)'
- en: Figure 10.20 – Resolving our 5 x 7 matrix
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20 - 解决我们的5 x 7矩阵
- en: 'Gluing together the preceding base cases and the recurrence relations results
    in the following algorithm:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 将前述基本情况和递归关系结合起来，得到以下算法：
- en: Create an auxiliary matrix (*subMatrix*) of the same size as the given matrix.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与给定矩阵大小相同的辅助矩阵（*subMatrix*）。
- en: Copy the first row and first column from the given matrix to this auxiliary
    *subMatrix* (these are the base cases).
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从给定矩阵中复制第一行和第一列到这个辅助*subMatrix*（这些是基本案例）。
- en: 'For each cell from the given matrix (starting at (1, 1)), do the following:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于给定矩阵的每个单元格（从（1, 1）开始），执行以下操作：
- en: a. Fill up the *subMatrix* conforming to the preceding recurrence relations.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: a. 填充符合前述递归关系的*subMatrix*。
- en: b. Track the maximum element of *subMatrix* since this element gives us the
    maximum size of the sub-matrix containing all 1's.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: b. 跟踪*subMatrix*的最大元素，因为这个元素给出了包含所有1的子矩阵的最大大小。
- en: 'The following implementation clarifies any remaining details:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现澄清了任何剩余的细节：
- en: '[PRE29]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since we iterate *m***n* times to fill the auxiliary matrix, the overall complexity
    of this solution is O(mn). The complete application is called *MaxMatrixOfOne*.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们迭代*m***n*次来填充辅助矩阵，因此这种解决方案的总体复杂度为O(mn)。完整的应用程序称为*MaxMatrixOfOne*。
- en: Coding challenge 16 – Container with the most water
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战16 – 包含最多水的容器
- en: '**Google**, **Adobe**, **Microsoft**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google**，**Adobe**，**Microsoft**'
- en: '**Problem**: Consider that you''ve been given *n* positive integers, *p*1,
    *p*2, ..., *p*n, where each integer represents a point at coordinate (*i, p*i)
    . Next, *n* vertical lines are drawn so that the two endpoints of line *i* are
    at (*i, p*i) and (*i*, 0). Write a snippet of code that finds two lines that,
    together with the X-axis, form a container that contains the most water.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设给定了*n*个正整数*p*1，*p*2，...，*p*n，其中每个整数表示坐标点（*i, p*i）。接下来，画出*n*条垂直线，使得线*i*的两个端点分别位于（*i,
    p*i）和（*i, 0）。编写一小段代码，找到两条线，与X轴一起形成一个包含最多水的容器。'
- en: '**Solution**: Let''s consider that the given integers are 1, 4, 6, 2, 7, 3,
    8, 5, and 3\. Following the problem statements, we can sketch the *n* vertical
    lines (line 1: {(0, 1), (0, 0)}, line 2: {(1, 4), (1,0)}, line 3: {(2, 6), (2,
    0)}, and so on). This can be seen in the following graph:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设给定的整数是1, 4, 6, 2, 7, 3, 8, 5和3。根据问题陈述，我们可以勾画*n*条垂直线（线1：{(0, 1),
    (0, 0)}，线2：{(1, 4), (1,0)}，线3：{(2, 6), (2, 0)}，依此类推）。这可以在下图中看到：'
- en: '![Figure 10.19 – The n vertical line representation'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.19 – n条垂直线表示'
- en: '](img/Figure_10.21_B15403.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.21_B15403.jpg)'
- en: Figure 10.21 – The n vertical line representation
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.21 – n条垂直线表示
- en: First of all, let's see how we should interpret the problem. We have to find
    the container that contains the most water. This means that, in our 2D representation,
    we have to find the rectangle that has the maximum area. In a 3D representation,
    this container will have the maximum volume, so it will contain the most water.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何解释这个问题。我们必须找到包含最多水的容器。这意味着在我们的2D表示中，我们必须找到具有最大面积的矩形。在3D表示中，这个容器将具有最大体积，因此它将包含最多的水。
- en: 'Thinking about the solution in terms of the brute-force approach is quite straightforward.
    For each line, we compute the areas showing the rest of the lines while tracking
    the largest area found. This requires two nested loops, as shown here:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 用暴力方法思考解决方案是非常直接的。对于每条线，我们计算显示其余线的面积，同时跟踪找到的最大面积。这需要两个嵌套循环，如下所示：
- en: '[PRE30]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The problem with this code is that its runtime is O(n2). A better approach consists
    of employing a technique known as *two-pointers*. Don't worry – it is a pretty
    simple technique that it is quite useful to have in your toolbelt. You never know
    when you'll need it!
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于它的运行时间是O(n2)。更好的方法是采用一种称为*双指针*的技术。别担心 - 这是一种非常简单的技术，对你的工具箱非常有用。你永远不知道什么时候会用到它！
- en: 'We know that we are looking for the maximum area. Since we are talking about
    a rectangular area, this means that the maximum area must accommodate the best
    report between the *biggest width* and the *biggest height* as much as possible.
    The biggest width is from 0 to *n*-1 (in our example, from 0 to 8). To find the
    biggest height, we must adjust the biggest width while tracking the maximum area.
    For this, we can start from the biggest width, as shown in the following graph:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们正在寻找最大面积。因为我们谈论的是一个矩形区域，这意味着最大面积必须尽可能多地容纳*最大宽度*和*最大高度*之间的最佳报告。最大宽度是从0到*n*-1（在我们的例子中，从0到8）。要找到最大高度，我们必须调整最大宽度，同时跟踪最大面积。为此，我们可以从最大宽度开始，如下图所示：
- en: '![Figure 10.22 – Area with the biggest width'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.22 – 最大宽度的区域'
- en: '](img/Figure_10.22_B15403.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.22_B15403.jpg)'
- en: Figure 10.22 – Area with the biggest width
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.22 – 最大宽度的区域
- en: 'So, if we demarcate the boundaries of the biggest width with two pointers,
    we can say that *i*=0 and *j*=8 (or *n*-1). In this case, the container that holds
    the water will have an area of *p*i* 8 = 1 * 8 = 8\. The container cannot be higher
    than *p*i = 1 because the water will flow out. However, we can increment *i* (*i*=1,
    *p*i=4) to obtain a higher container, and potentially a bigger container, as shown
    in the following graph:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们用两个指针标记最大宽度的边界，我们可以说*i*=0和*j*=8（或*n*-1）。在这种情况下，容纳水的容器的面积将为*p*i* 8 = 1
    * 8 = 8。容器的高度不能超过*p*i = 1，因为水会流出。然而，我们可以增加*i*（*i*=1，*p*i=4）以获得更高的容器，可能是更大的容器，如下图所示：
- en: '![Figure 10.23 – Increasing i to obtain a bigger container'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.23 – 增加i以获得更大的容器'
- en: '](img/Figure_10.23_B15403.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.23_B15403.jpg)'
- en: Figure 10.23 – Increasing i to obtain a bigger container
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.23 – 增加i以获得更大的容器
- en: 'Generally speaking, if *p*i ≤ *p*j, then we increment *i*; otherwise, we decrement
    *j*. By successively increasing/decreasing *i* and *j*, we can obtain the maximum
    area. From left to right and from top to bottom, the following image shows this
    statement at work for the next six steps:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果*p*i ≤ *p*j，则增加*i*；否则，减少*j*。通过不断增加/减少*i*和*j*，我们可以获得最大面积。从左到右，从上到下，下面的图像显示了这个语句在接下来的六个步骤中的工作：
- en: '![Figure 10.24 – Computing areas while increasing/decreasing i and j'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.24 – 在增加/减少i和j时计算面积'
- en: '](img/Figure_10.24_B15403.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.24_B15403.jpg)'
- en: Figure 10.24 – Computing areas while increasing/decreasing i and j
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.24 – 在增加/减少*i*和*j*时计算面积
- en: 'The steps are as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: In the top-left corner image, we decreased *j* since *p*i *> p*j*, p*1 *> p*8
    (4 > 3).
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左上角的图像中，我们减少了*j*，因为*p*i *> p*j*，p*1 *> p*8 (4 > 3)。
- en: In the top-middle image, we increased *i* since *p*i *< p*j*, p*1 *< p*7 (4
    < 5).
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部中间的图像中，我们增加了*i*，因为*p*i *< p*j*，p*1 *< p*7 (4 < 5)。
- en: In the top-right corner image, we decreased *j* since *p*i *> p*j*, p*2 *> p*7
    (6 > 5).
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角的图像中，我们减少了*j*，因为*p*i *> p*j*，p*2 *> p*7 (6 > 5)。
- en: In the bottom-left corner image, we increased *i* since *p*i *< p*j*, p*2 <
    *p*6 (6 < 8).
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左下角的图像中，我们增加了*i*，因为*p*i *< p*j*，p*2 < *p*6 (6 < 8)。
- en: In the bottom-middle image, we increased *i* since *p*i *< p*j*, p*3 *< p*6
    (2 < 8).
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在底部中间的图像中，我们增加了*i*，因为*p*i *< p*j*，p*3 *< p*6 (2 < 8)。
- en: In the bottom-right corner image, we increased *i* since *p*i *< p*j*, p*4 *<
    p*6 (7 < 8).
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右下角的图像中，我们增加了*i*，因为*p*i *< p*j*，p*4 *< p*6 (7 < 8)。
- en: 'Done! If we increase *i* or decrease *j* one more time, then *i=j* and the
    area is 0\. At this point, we can see that the maximum area is 25 (top-middle
    image). Well, this technique is known as *two-pointers* and can be implemented
    in this case with the following algorithm:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！如果我们再增加*i*或减少*j*一次，那么*i=j*，面积为0。此时，我们可以看到最大面积为25（顶部中间的图像）。嗯，这种技术被称为*双指针*，可以用以下算法实现：
- en: Start with the maximum area as 0*, i*=0 and *j=n*-1
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从最大面积为0*，i*=0和*j=n*-1开始。
- en: 'While *i < j*, do the following:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当*i < j*时，执行以下操作：
- en: a. Compute the area for the current *i* and *j*.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: a. 计算当前*i*和*j*的面积。
- en: b. Update the maximum area accordingly (if needed).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: b. 根据需要更新最大面积。
- en: c. If *p*i *≤ p*j, then *i++;* else, *j--*.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: c. 如果*p*i *≤ p*j，则*i++;* 否则，*j--*。
- en: 'In terms of code, we have the following:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下内容：
- en: '[PRE31]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The runtime of this code is O(n). The complete application is called *ContainerMostWater*.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n)。完整的应用程序称为*ContainerMostWater*。
- en: Coding challenge 17 – Searching in a circularly sorted array
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战17 – 在循环排序数组中搜索
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider that you''ve been given a circularly sorted array of
    integers with no duplicates, *m*. Write a program that searches for the given
    *x* in O(log n) complexity time.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经得到了一个没有重复的整数的循环排序数组*m*。编写一个程序，在O(log n)的时间复杂度内搜索给定的*x*。'
- en: '**Solution**: If we could solve this problem in O(n) complexity time, then
    the brute-force approach is the simplest solution. A linear search in the array
    will give the index of the searched *x*. However, we need to come up with an O(log
    n) solution, so we need to tackle the problem from another perspective.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：如果我们能在O(n)的时间复杂度内解决这个问题，那么蛮力方法是最简单的解决方案。在数组中进行线性搜索将给出所搜索的*x*的索引。然而，我们需要提出一个O(log
    n)的解决方案，因此我们需要从另一个角度来解决这个问题。'
- en: We have enough hints that point us to the well-known Binary Search algorithm,
    which we discussed in [*Chapter 7*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*,
    Big O Analysis of Algorithms* and in [*Chapter 14*](B15403_14_Final_JM_ePub.xhtml#_idTextAnchor340),
    *Sorting and Searching*. We have a sorted array, we need to find a certain value,
    and we need to do it in O(log n) complexity time. So, there are three hints that
    point us to the Binary Search algorithm. Of course, the big issue is represented
    by the circularity of the sorted array, so we cannot apply a plain Binary Search
    algorithm.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有足够的线索指向我们熟知的二分搜索算法，我们在[*第7章*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*，算法的大O分析*和[*第14章*](B15403_14_Final_JM_ePub.xhtml#_idTextAnchor340)*，排序和搜索*中讨论过。我们有一个排序后的数组，我们需要找到一个特定的值，并且需要在O(log
    n)的时间复杂度内完成。因此，有三个线索指向我们二分搜索算法。当然，最大的问题在于排序后的数组的循环性，因此我们不能应用普通的二分搜索算法。
- en: 'Let''s consider that *m* = {11, 14, 23, 24, -1, 3, 5, 6, 8, 9, 10} and *x*
    = 14, and we expected the output to be index 1\. The following image introduces
    several notations and serves as guidance in solving the problem at hand:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设*m* = {11, 14, 23, 24, -1, 3, 5, 6, 8, 9, 10}，*x* = 14，我们期望的输出是索引1。以下图像介绍了几个符号，并作为解决手头问题的指导：
- en: '![Figure 10.25 – Circularly sorted array and Binary Search algorithm'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.25 – 循环排序数组和二分搜索算法'
- en: '](img/Figure_10.25_B15403.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.25_B15403.jpg)'
- en: Figure 10.25 – Circularly sorted array and Binary Search algorithm
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.25 – 循环排序数组和二分搜索算法
- en: 'Since the sorted array is circular, we have a *pivot*. This is an index pointing
    to the head of the array. The elements from the left of the pivot have been rotated.
    When the array is not rotated, it will be {-1, 3, 5, 6, 8, 9, 10, **11, 14, 23,
    24**}. Now, let''s see the steps for the solution based on the Binary Search algorithm:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 由于排序后的数组是循环的，我们有一个*pivot*。这是一个指向数组头部的索引。从*pivot*左边的元素已经被旋转。当数组没有旋转时，它将是{-1,
    3, 5, 6, 8, 9, 10, **11, 14, 23, 24**}。现在，让我们看一下基于二分搜索算法的解决方案步骤：
- en: We apply the Binary Search algorithm, so we start by computing the *middle*
    of the array as (*left + right*) / 2.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应用二分搜索算法，因此我们从计算数组的*middle*开始，即(*left + right*) / 2。
- en: We check whether *x* = *m*[*middle*]. If so, we return the *middle*. If not,
    we continue with the next step.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查是否*x* = *m*[*middle*]。如果是，则返回*middle*。如果不是，则继续下一步。
- en: 'Next, we check whether the right-half of the array is sorted. All the elements
    from the range [*middle, right*] are sorted if *m*[*middle*] <= *m*[*right*]:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查数组的右半部分是否已排序。如果*m*[*middle*] <= *m*[*right*]，则范围[*middle, right*]中的所有元素都已排序：
- en: a. If *x* > *m*[*middle*] and *x* <= *m*[*right*], then we ignore the left-half,
    set *left* = *middle* + 1, and repeat from *step 1*.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: a. 如果*x* > *m*[*middle*]并且*x* <= *m*[*right*]，那么我们忽略左半部分，设置*left* = *middle*
    + 1，并从*步骤1*重复。
- en: b. If *x* <= *m*[*middle*] or *x > m*[*right*], then we ignore the right-half,
    set *right = middle* - 1, and repeat from *step 1*.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果*x* <= *m*[*middle*]或*x > m*[*right*]，那么我们忽略右半部分，设置*right = middle* - 1，并从*步骤1*重复。
- en: 'If the right-half of the array is not sorted, then the left-half must be sorted:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数组的右半部分没有排序，那么左半部分必须是排序的：
- en: a. If *x >= m*[*left*]and *x < m*[*middle*], then we ignore the right-half,
    set *right = middle*- 1, and repeat from *step 1*.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: a. 如果*x >= m*[*left*]并且*x < m*[*middle*]，那么我们忽略右半部分，设置*right = middle*- 1，并从*步骤1*重复。
- en: b. If *x < m*[*left*]or *x >= m*[*middle*], then we ignore the left-half, set
    *left = middle* + 1, and repeat from *step 1*.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果*x < m*[*left*]或*x >= m*[*middle*]，那么我们忽略左半部分，设置*left = middle* + 1，并从*步骤1*重复。
- en: We repeat *steps 1-4* as long as we didn't find *x* or *left <= right*.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复*步骤1-4*，只要我们没有找到*x*或*left <= right*。
- en: Let's apply the preceding algorithm to our case.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前述算法应用到我们的情况中。
- en: So, *middle* is (*left + right*) / 2 = (0 + 10) / 2 = 5\. Since *m*[5] ≠14 (remember
    that 14 is *x*), we continue with *step 3*. Since *m*[5]<*m*[10], we conclude
    that the right-half is sorted. However, we notice that *x>m*[*right*] (14 >10),
    so we apply *step 3b*. Basically, we ignore the right-half and we set *right =
    middle* - 1 = 5 - 1 = 4\. We apply *step 1* again.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*middle*是(*left + right*) / 2 = (0 + 10) / 2 = 5。由于*m*[5] ≠14（记住14是*x*），我们继续进行*步骤3*。由于*m*[5]<*m*[10]，我们得出右半部分是排序的结论。然而，我们注意到*x>m*[*right*]（14
    >10），所以我们应用*步骤3b*。基本上，我们忽略右半部分，然后设置*right = middle* - 1 = 5 - 1 = 4。我们再次应用*步骤1*。
- en: The new *middle* is (0 + 4) / 2 = 2\. Since *m*[2]≠14, we continue with *step
    3*. Since *m*[2] >*m*[4], we conclude that the left-half is sorted. We notice
    that *x*>*m*[*left*] (14 >11) and *x*<*m*[*middle*] (14<23), so we apply *step
    4a*. We ignore the right-half and we set *right*= *middle* - 1 = 2 - 1 = 1\. We
    apply *step 1* again.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 新的*middle*是(0 + 4) / 2 = 2。由于*m*[2]≠14，我们继续进行*步骤3*。由于*m*[2] >*m*[4]，我们得出左半部分是排序的结论。我们注意到*x*>*m*[*left*]（14
    >11）和*x*<*m*[*middle*]（14<23），所以我们应用*步骤4a*。我们忽略右半部分，然后设置*right*= *middle* - 1
    = 2 - 1 = 1。我们再次应用*步骤1*。
- en: The new *middle* is (0 + 1) / 2 = 0\. Since *m*[0]≠14, we continue with *step
    3*. Since *m*[0]<*m*[1], we conclude that the right-half is sorted. We notice
    that *x* > *m*[*middle*] (14 > 11) and *x* = *m*[*right*] (14 = 14), so we apply
    *step 3a*. We ignore the left-half and we set *left = middle* + 1 = 0 + 1 = 1\.
    We apply *step 1* again.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 新的*middle*是(0 + 1) / 2 = 0。由于*m*[0]≠14，我们继续进行*步骤3*。由于*m*[0]<*m*[1]，我们得出右半部分是排序的结论。我们注意到*x*
    > *m*[*middle*]（14 > 11）和*x* = *m*[*right*]（14 = 14），所以我们应用*步骤3a*。我们忽略左半部分，然后设置*left
    = middle* + 1 = 0 + 1 = 1。我们再次应用*步骤1*。
- en: The new *middle* is (1 + 1) / 2 = 1\. Since *m*[1]=14, we stop and return 1
    as the index of the array where we found the searched value.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 新的*middle*是(1 + 1) / 2 = 1。由于*m*[1]=14，我们停止并返回1作为我们找到搜索值的数组索引。
- en: 'Let''s put this into code:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这些放入代码中：
- en: '[PRE32]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The complete application is called *SearchInCircularArray*. Similar problems
    will ask you to find the maximum or the minimum value in a circularly sorted array.
    While both applications are available in the bundled code as *MaximumInCircularArray*
    and *MinimumInCircularArray*, it is advisable to use what you've learned so far
    and challenge yourself to find a solution.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*SearchInCircularArray*。类似的问题会要求你在一个循环排序的数组中找到最大值或最小值。虽然这两个应用程序都包含在捆绑代码中，分别为*MaximumInCircularArray*和*MinimumInCircularArray*，但建议你利用到目前为止学到的知识，挑战自己找到解决方案。
- en: Coding challenge 18 – Merging intervals
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战18-合并间隔
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider that you''ve been given an array of intervals of the
    [*start, end*] type. Write a snippet of code that merges all the intervals that
    are overlapping.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经得到了一个[*start, end*]类型的间隔数组。编写一小段代码，合并所有重叠的间隔。'
- en: '**Solution**: Let''s consider that the given intervals are [12,15], [12,17],
    [2,4], [16,18], [4,7], [9,11], and [1,2]. After we merge the overlapping intervals,
    we obtain the following result: [1, 7], [9, 11] [12, 18].'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们假设给定的间隔是[12,15]，[12,17]，[2,4]，[16,18]，[4,7]，[9,11]和[1,2]。在我们合并重叠的间隔之后，我们得到以下结果：[1,
    7]，[9, 11] [12, 18]。'
- en: We can start with the brute-force approach. It is quite intuitive that we take
    an interval (let's denote it as *p*i) and compare its end (*p*ei) with the starts
    of the rest of the intervals. If the start of an interval (from the rest of the
    intervals) is less than the end of *p*, then we can merge these two intervals.
    The end of the merged interval becomes the maximum of the ends of these two intervals.
    But this approach will perform in O(n2), so it will not impress the interviewer.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从蛮力方法开始。很直观的是，我们取一个间隔（让我们将其表示为*p*i），并将其结束（*p*ei）与其余间隔的开始进行比较。如果另一个间隔的开始（来自其余间隔）小于*p*的结束，那么我们可以合并这两个间隔。合并间隔的结束变为这两个间隔的结束的最大值。但是这种方法的时间复杂度为O(n2)，所以它不会给面试官留下深刻印象。
- en: However, the brute-force approach can give us an important hint for attempting
    a better implementation. At any moment of time, we must compare the end of *p*
    with the start of another interval. This is important because it can lead us to
    the idea of sorting the intervals by their starts. This way, we seriously reduce
    the number of comparisons. Having the sorted intervals allows us to combine all
    the intervals in a linear traversal.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，蛮力方法可以为我们尝试更好的实现提供重要提示。在任何时刻，我们必须将*p*的结束与另一个间隔的开始进行比较。这很重要，因为它可以引导我们思考按照它们的开始时间对间隔进行排序的想法。这样，我们可以大大减少比较的次数。有了排序的间隔，我们可以在线性遍历中合并所有间隔。
- en: 'Let''s try and use a graphical representation of our sample intervals sorted
    in ascending order by their starts (*p*si<*p*si+1<*p*si+2). Also, each interval
    is always forward-looking (*p*ei>*p*si, *p*ei+1>*p*si+1, *p*ei+2>*p*si+2, and
    so on). This will help us understand the algorithm that we''ll cover soon:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一个图形表示我们的样本间隔，按照它们的开始时间按升序排序（*p*si<*p*si+1<*p*si+2）。此外，每个间隔始终是向前看的（*p*ei>*p*si，*p*ei+1>*p*si+1，*p*ei+2>*p*si+2，依此类推）。这将帮助我们理解我们即将介绍的算法：
- en: '![Figure 10.26 – Sorting the given intervals'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.26-对给定的间隔进行排序'
- en: '](img/Figure_10.26_B15403.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.26_B15403.jpg)'
- en: Figure 10.26 – Sorting the given intervals
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.26-对给定的间隔进行排序
- en: Based on the preceding image, we can see that if the start of *p* is greater
    than the end of the previous *p*, (*p*si>*p*ei-1), then the start of the next
    *p* is greater than the end of the previous *p*, (*p*si+1>*p*ei-1), so there is
    no need to compare the previous *p* with the next *p*. In other words, if *p*i
    doesn't overlap with *p*i-1, then *p*i+1 cannot overlap with *p*i-1 because the
    start of *p*i+1 must be greater than or equal to *p*i.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图像，我们可以看到如果*p*的起始值大于前一个*p*的结束值（*p*si>*p*ei-1），那么下一个*p*的起始值也大于前一个*p*的结束值（*p*si+1>*p*ei-1），所以不需要比较前一个*p*和下一个*p*。换句话说，如果*p*i不与*p*i-1重叠，则*p*i+1也不能与*p*i-1重叠，因为*p*i+1的起始值必须大于或等于*p*i。
- en: 'If *p*si is less than *p*ei-1, then we should update *p*ei-1 with the maximum
    between *p*ei-1 and *p*ei and move to *p*ei+1\. This can be done via a stack,
    as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*p*si小于*p*ei-1，则我们应该将*p*ei-1更新为*p*ei-1和*p*ei之间的最大值，并移动到*p*ei+1。这可以通过栈来完成，具体步骤如下：
- en: '![Figure 10.27 – Using a stack to solve the problem'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.27 – 使用栈解决问题'
- en: '](img/Figure_10.27_B15403.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.27_B15403.jpg)'
- en: Figure 10.27 – Using a stack to solve the problem
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.27 – 使用栈解决问题
- en: 'These are the steps that occur:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是发生的步骤：
- en: '**Step 0**: We start with an empty stack.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤0**：我们从一个空栈开始。'
- en: '**Step 1**: Since the stack is empty, we push the first interval ([1, 2]) into
    the stack.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤1**：由于栈是空的，我们将第一个区间（[1, 2]）推入栈中。'
- en: '**Step 2**: Next, we focus on the second interval ([2, 4]). The start of [2,
    4] is equal to the end of the interval from the top of the stack, [1, 2], so we
    don''t push [2, 4] into the stack. We continue to compare the end of [1, 2] with
    the end of [2, 4]. Since 2 is less than 4, we update the interval [1, 2] to [1,
    4]. So, we merged [1, 2] with [2, 4].'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤2**：接下来，我们关注第二个区间（[2, 4]）。[2, 4]的起始值等于栈顶部的区间[1, 2]的结束值，所以我们不将[2, 4]推入栈中。我们继续比较[1,
    2]的结束值和[2, 4]的结束值。由于2小于4，我们将区间[1, 2]更新为[1, 4]。所以，我们将[1, 2]与[2, 4]合并。'
- en: '**Step 3**: Next, we focus on interval [4, 7]. The start of [4, 7] is equal
    to the end of the interval from the top of the stack, [1, 4], so we don''t push
    [4, 7] into the stack. We continue to compare the end of [1, 4] with the end of
    [4, 7]. Since 4 is less than 7, we update the interval [1, 4] to [1, 7]. So, we
    merged [1, 4] with [4, 7].'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤3**：接下来，我们关注区间[4, 7]。[4, 7]的起始值等于栈顶部的区间[1, 4]的结束值，所以我们不将[4, 7]推入栈中。我们继续比较[1,
    4]的结束值和[4, 7]的结束值。由于4小于7，我们将区间[1, 4]更新为[1, 7]。所以，我们将[1, 4]与[4, 7]合并。'
- en: '**Step 4**: Next, we focus on interval [9, 11]. The start of [9, 11] is greater
    than the end of the interval from the top of the stack, [1, 7], so intervals [1,
    7] and [9, 11] don''t overlap. This means that we can push interval [9, 11] into
    the stack.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤4**：接下来，我们关注区间[9, 11]。[9, 11]的起始值大于栈顶部的区间[1, 7]的结束值，所以区间[1, 7]和[9, 11]不重叠。这意味着我们可以将区间[9,
    11]推入栈中。'
- en: '**Step 5**: Next, we focus on interval [12, 15]. The start of [12, 15] is greater
    than the end of the interval from the top of the stack, [9, 11], so intervals
    [9, 11] and [12, 15] don''t overlap. This means that we can push interval [12,
    15] into the stack.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤5**：接下来，我们关注区间[12, 15]。[12, 15]的起始值大于栈顶部的区间[9, 11]的结束值，所以区间[9, 11]和[12,
    15]不重叠。这意味着我们可以将区间[12, 15]推入栈中。'
- en: '**Step 6**: Next, we focus on interval [12, 17]. The start of [12, 17] is equal
    to the end of the interval from the top of the stack, [12, 15], so we don''t push
    [12, 17] into the stack. We continue and compare the end of [12, 15] with the
    end of [12, 17]. Since 15 is less than 17, we update interval [12, 15] to [12,
    17]. So, here, we merged [12, 15] with [12, 17].'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤6**：接下来，我们关注区间[12, 17]。[12, 17]的起始值等于栈顶部的区间[12, 15]的结束值，所以我们不将[12, 17]推入栈中。我们继续比较[12,
    15]的结束值和[12, 17]的结束值。由于15小于17，我们将区间[12, 15]更新为[12, 17]。所以，这里我们将[12, 15]与[12, 17]合并。'
- en: '**Step 7**: Finally, we focus on interval [16, 18]. The start of [16, 18] is
    less than the end of the interval from the top of the stack, [12, 17], so intervals
    [16, 18] and [12, 17] are overlapping. This time, we have to update the end of
    the interval from the top of the stack with the maximum between the end of this
    interval and [16, 18]. Since 18 is greater than 17, the interval from the top
    of the stack becomes [12, 17].'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤7**：最后，我们关注区间[16, 18]。[16, 18]的起始值小于栈顶部的区间[12, 17]的结束值，所以区间[16, 18]和[12,
    17]重叠。这时，我们需要使用[16, 18]的结束值和栈顶部区间的结束值之间的最大值来更新栈顶部的区间的结束值。由于18大于17，栈顶部的区间变为[12,
    17]。'
- en: 'Now, we can pop the content of the stack to see the merged intervals, [[12,
    18], [9, 11], [1, 7]], as shown in the following image:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以弹出栈的内容来查看合并后的区间，[[12, 18], [9, 11], [1, 7]]，如下图所示：
- en: '![Figure 10.28 – The merged intervals'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.28 – 合并后的区间'
- en: '](img/Figure_10.28_B15403.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.28_B15403.jpg)'
- en: Figure 10.28 – The merged intervals
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.28 – 合并后的区间
- en: 'Based on these steps, we can create the following algorithm:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些步骤，我们可以创建以下算法：
- en: Sort the given intervals in ascending order based on their starts.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据起始值对给定的区间进行升序排序。
- en: Push the first interval into the stack.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个区间推入栈中。
- en: 'For the rest of intervals, do the following:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于剩下的区间，执行以下操作：
- en: a. If the current interval does not overlap with the interval from the top of
    the stack, then push it into the stack.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: a. 如果当前区间与栈顶部的区间不重叠，则将其推入栈中。
- en: b. If the current interval overlaps with the interval from the top of the stack
    and the end of the current interval is greater than that of the stack top, then
    update the top of the stack with the end of the current interval.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果当前区间与栈顶部的区间重叠，并且当前区间的结束值大于栈顶部的结束值，则使用当前区间的结束值更新栈顶部的结束值。
- en: At the end, the stack contains the merged intervals.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，栈中包含了合并后的区间。
- en: 'In terms of code, this algorithm looks as follows:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，该算法如下所示：
- en: '[PRE33]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The runtime of this code is O(n log n) with an auxiliary space of O(n) for the
    stack. While the interviewer should be satisfied with this approach, he/she may
    ask you for optimization. More precisely, can we drop the stack and obtain a complexity
    space of O(1)?
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n log n)，辅助空间为O(n)用于栈。虽然面试官应该对这种方法满意，但他/她可能会要求你进行优化。更确切地说，我们能否放弃栈并获得O(1)的复杂度空间？
- en: 'If we drop the stack, then we must perform the merge operation in-place. The
    algorithm that can do this is self-explanatory:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们放弃栈，那么我们必须在原地执行合并操作。能够做到这一点的算法是不言自明的：
- en: Sort the given intervals in ascending order based on their starts.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据它们的开始时间，对给定的区间进行升序排序。
- en: 'For the rest of the intervals, do the following:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于剩下的区间，做以下操作：
- en: a. If the current interval is not the first interval and it overlaps with the
    previous interval, then merge these two intervals. Do the same for all the previous
    intervals.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: a. 如果当前区间不是第一个区间，并且与前一个区间重叠，则合并这两个区间。对所有先前的区间执行相同的操作。
- en: b. Otherwise, add the current interval to the output array of intervals.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: b. 否则，将当前区间添加到输出数组中。
- en: 'Notice that, this time, the intervals are sorted in descending order of their
    starts. This means that we can check whether two intervals are overlapping by
    comparing the start of the previous interval with the end of the current interval.
    Let''s see the code for this:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次区间按照它们的开始时间降序排序。这意味着我们可以通过比较前一个区间的开始和当前区间的结束来检查两个区间是否重叠。让我们看看这段代码：
- en: '[PRE34]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The runtime of this code is O(n log n) with an auxiliary space of O(1). The
    complete application is called *MergeIntervals*.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n log n)，辅助空间为O(1)。完整的应用程序称为*MergeIntervals*。
- en: Coding challenge 19 – Petrol bunks circular tour
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战19 – 加油站环形旅游
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider that you''ve been given *n* petrol bunks along a circular
    route. Every petrol bunk contains two pieces of data: the amount of fuel (*fuel*[])
    and the distance from that current petrol bunk to the next petrol bunk (*dist*[]).
    Next, you have a truck with an unlimited gas tank. Write a snippet of code that
    calculates the first point from where the truck should start in order to complete
    a full tour. You begin the journey with an empty tank at one of the petrol bunks.
    With 1 liter of petrol, the truck can go 1 unit of distance.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经得到了沿着圆形路线的*n*个加油站。每个加油站包含两个数据：燃料量(*fuel*[])和从当前加油站到下一个加油站的距离(*dist*[])。接下来，你有一辆带有无限油箱的卡车。编写一小段代码，计算卡车应该从哪个加油站开始以完成一次完整的旅程。你从一个加油站开始旅程时，油箱是空的。用1升汽油，卡车可以行驶1单位的距离。'
- en: '**Solution**: Consider that you''ve been given the following data: *dist* =
    {5, 4, 6, 3, 5, 7}, *fuel* = {3, 3, 5, 5, 6, 8}.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：考虑到你已经得到了以下数据：*dist* = {5, 4, 6, 3, 5, 7}, *fuel* = {3, 3, 5, 5, 6,
    8}。'
- en: 'Let''s use the following images to get a better understanding of the context
    of this problem and to support us in finding a solution:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下图像更好地理解这个问题的背景，并支持我们找到解决方案：
- en: '![Figure 10.29 – Truck circular tour sample'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.29 – 卡车环形旅游示例'
- en: '](img/Figure_10.29_B15403.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.29_B15403.jpg)'
- en: Figure 10.29 – Truck circular tour sample
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.29 – 卡车环形旅游示例
- en: From 0 to 5, we have six petrol bunks. On the left-hand side of the image, you
    can see a sketch of the given circular route and the distribution of the petrol
    bunks. The first petrol bunk has 3 liters of petrol, and the distance to the next
    petrol bunk is 5 units. The second petrol bunk has 3 liters of petrol, and the
    distance to the next petrol bunk is 4 units. The third petrol bunk has 5 liters
    of petrol, and the distance to the next petrol bunk is 6 units, and so on. Obviously,
    a vital condition if we wish to go from petrol bunk *X* to petrol bunk *Y* is
    that the distance between *X* and *Y* is less than or equal to the amount of fuel
    in the tank of the truck. For example, if the truck starts the journey from petrol
    bunk 0, then it cannot go to petrol bunk 1 since the distance between these two
    petrol bunks is 5 units and the truck can have only 3 liters of petrol in the
    tank. On the other hand, if the truck starts the journey from petrol bunk 3, then
    it can go to petrol bunk 4 because the truck will have 5 liters of petrol in the
    tank. Actually, as shown on the right-hand side of the image, the solution to
    this case is to start from petrol bunk 3 with 5 liters of petrol in the tank –
    take your time and complete the tour using some paper and a pen.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 从0到5，我们有六个加油站。在图像的左侧，你可以看到给定圆形路线的草图和加油站的分布。第一个加油站有3升汽油，到下一个加油站的距离是5单位。第二个加油站有3升汽油，到下一个加油站的距离是4单位。第三个加油站有5升汽油，到下一个加油站的距离是6单位，依此类推。显然，如果我们希望从加油站*X*到加油站*Y*，一个重要的条件是*X*和*Y*之间的距离小于或等于卡车油箱中的燃料量。例如，如果卡车从加油站0开始旅程，那么它不能去加油站1，因为这两个加油站之间的距离是5单位，而卡车的油箱只能装3升汽油。另一方面，如果卡车从加油站3开始旅程，那么它可以去加油站4，因为卡车的油箱里会有5升汽油。实际上，如图像的右侧所示，这种情况的解决方案是从加油站3开始，油箱里有5升汽油
    – 用纸和笔芯花点时间完成旅程。
- en: 'The brute-force (or naive) approach can rely on a straightforward statement:
    we start from each petrol bunk and try to make the complete tour. This is simple
    to implement but its runtime will be O(n2). Challenge yourself to come up with
    a better implementation.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 蛮力（或者朴素）方法可以依赖于一个简单的陈述：我们从每个加油站开始，尝试完成整个旅程。这很容易实现，但其运行时间将为O(n2)。挑战自己想出一个更好的实现。
- en: 'To solve this problem more efficiently, we need to understand and use the following
    facts:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更有效地解决这个问题，我们需要理解和使用以下事实：
- en: If the *sum of fuel ≥ the sum of distances*, then the tour can be completed.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*燃料总量≥距离总量*，则旅程可以完成。
- en: If petrol bunk *X* cannot reach petrol bunk *Z* in the sequence of *X → Y →
    Z*, then *Y* cannot make it either.
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果加油站*X*不能在*X → Y → Z*的顺序中到达加油站*Z*，那么*Y*也不能到达。
- en: 'While the first bullet is a commonsense notion, the second bullet requires
    some extra proof. Here is the reasoning behind the second bullet:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要点是常识，第二个要点需要一些额外的证明。以下是第二个要点背后的推理：
- en: "If *fuel*[*X*] *< dist*[*X*], then *X* cannot even reach *Y*\L So to reach\
    \ *Z* from *X*, *fuel*[*X*] must be *≥ dist*[*X*]."
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*fuel*[*X*] *< dist*[*X*]，那么*X*甚至无法到达*Y*。因此，要从*X*到*Z*，*fuel*[*X*]必须*≥ dist*[*X*]。
- en: Given that *X* cannot reach *Z*, we have *fuel*[*X*] *+ fuel*[*Y*] *< dist*[*X*]
    *+ dist*[*Y*]*,* and *fuel*[*X*] *≥ dist*[*X*]. Therefore, *fuel*[*Y*] *< dist*[*Y*]
    and *Y* cannot reach *Z*.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于*X*无法到达*Z*，我们有*fuel*[*X*] *+ fuel*[*Y*] *< dist*[*X*] *+ dist*[*Y*]*，而*fuel*[*X*]
    *≥ dist*[*X*]。因此，*fuel*[*Y*] *< dist*[*Y*]，*Y*也无法到达*Z*。
- en: 'Based on these two points, we can come up with the following implementation:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这两点，我们可以得出以下实现：
- en: '[PRE35]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To understand this code, try to pass the given set of data through the code
    using some paper and a pen. Also, you may wish to try the following sets:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这段代码，可以尝试使用纸和笔将给定的数据通过代码传递。此外，您可能希望尝试以下集合：
- en: '[PRE36]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The runtime of this code is O(n). The complete application is called *PetrolBunks*.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n)。完整的应用程序称为*PetrolBunks*。
- en: Coding challenge 20 – Trapping rainwater
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战20 - 困住雨水
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider that you''ve been given a set of bars that are different
    heights (non-negative integers). The width of a bar is equal to 1\. Write a snippet
    of code that computes the amount of water that can be trapped within the bars.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了一组不同高度（非负整数）的酒吧。每个酒吧的宽度等于1。编写一小段代码，计算可以在酒吧之间困住的水量。'
- en: '**Solution**: Let''s consider that the given set of bars is an array, as follows:
    *bars* = { 1, 0, 0, 4, 0, 2, 0, 1, 6, 2, 3}. The following image is a sketch of
    these bars'' heights:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设给定的一组酒吧是一个数组，如下所示：*bars* = { 1, 0, 0, 4, 0, 2, 0, 1, 6, 2, 3}。以下图片是这些酒吧高度的草图：'
- en: '![Figure 10.30 – The given set of bars'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.30 - 给定的一组酒吧'
- en: '](img/Figure_10.30_B15403.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.30_B15403.jpg)'
- en: Figure 10.30 – The given set of bars
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.30 - 给定的一组酒吧
- en: 'Now, rain is filling up between the spaces of these bars. So, after the rain
    has fallen, we will have something like the following:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，雨水在这些酒吧之间的空隙中积水。因此，雨后我们将得到以下情况：
- en: '![Figure 10.31 – The given bars after rain'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.31 - 雨后的给定酒吧'
- en: '](img/Figure_10.31_B15403.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.31_B15403.jpg)'
- en: Figure 10.31 – The given bars after rain
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.31 - 雨后的给定酒吧
- en: So, here, we have a maximum amount of water equal to 16\. The solution to this
    problem depends on how we look at the water. For example, we can look at the water
    between the bars or at the water on top of each bar. The second view is exactly
    what we want.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，我们最多可以获得16单位的水。这个问题的解决方案取决于我们如何看待水。例如，我们可以看看酒吧之间的水，或者看看每个酒吧顶部的水。第二种观点正是我们想要的。
- en: 'Check out the following image, which has some additional guidance regarding
    how to isolate the water on top of each bar:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下图片，其中有一些关于如何隔离每个酒吧顶部的水的额外指导：
- en: '![Figure 10.32 – Water on top of each bar'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.32 - 每个酒吧顶部的水'
- en: '](img/Figure_10.32_B15403.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.32_B15403.jpg)'
- en: Figure 10.32 – Water on top of each bar
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.32 - 每个酒吧顶部的水
- en: 'So, above bar 0, we have no water. Above bar 1, we have 1 unit of water. Above
    bar 2, we have 1 unit of water, and so on and so forth. If we sum up these values,
    then we get 0 + 1 + 1 + 0 + 4 + 2 + 4 + 3 + 0 + 1 + 0 = 16, which is the precise
    amount of water we have. However, to determine the amount of water on top of bar
    *x*, we must know the minimum between the highest bars on the left- and right-hand
    sides. In other words, for each of the bars, that is, 1, 2, 3 ... 9 (notice that
    we don''t use bars 0 and 10 since they are the boundaries), we have to determine
    the highest bars on the left- and right-hand sides and compute the minimum between
    them. The following image reveals our computations (the bar in the middle ranges
    from 1 to 9):'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在酒吧0上方，我们没有水。在酒吧1上方，我们有1单位的水。在酒吧2上方，我们有1单位的水，依此类推。如果我们将这些值相加，那么我们得到0 + 1
    + 1 + 0 + 4 + 2 + 4 + 3 + 0 + 1 + 0 = 16，这就是我们拥有的水的精确数量。但是，要确定酒吧*x*顶部的水量，我们必须知道左右两侧最高酒吧之间的最小值。换句话说，对于每个酒吧，即1、2、3...9（注意我们不使用酒吧0和10，因为它们是边界），我们必须确定左右两侧最高酒吧，并计算它们之间的最小值。以下图片展示了我们的计算（中间的酒吧范围从1到9）：
- en: '![Figure 10.33 – Highest bars on the left- and right-hand sides'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.33 - 左右两侧最高的酒吧'
- en: '](img/Figure_10.33_B15403.jpg)'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.33_B15403.jpg)'
- en: Figure 10.33 – Highest bars on the left- and right-hand sides
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.33 - 左右两侧最高的酒吧
- en: 'Hence, we can conclude that a simple solution would be to traverse the bars
    to find the highest bars on the left- and right-hand sides. The minimum of these
    two bars can be exploited as follows:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出一个简单的解决方案，即遍历酒吧以找到左右两侧的最高酒吧。这两个酒吧的最小值可以被利用如下：
- en: If the minimum is smaller than the height of the current bar, then the current
    bar cannot hold water on top of it.
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最小值小于当前酒吧的高度，则当前酒吧无法在其顶部容纳水。
- en: If the minimum is greater than the height of the current bar, then the current
    bar can hold an amount of water equal to the difference between the minimum and
    the height of the current bar on top of it.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最小值大于当前酒吧的高度，则当前酒吧可以容纳的水量等于最小值与其顶部的当前酒吧高度之间的差值。
- en: 'So, this problem can be addressed by computing the highest bars on the left-
    and right-hand sides of every bar. An efficient implementation of these statements
    consists of pre-computing the highest bars on the left- and right-hand sides of
    every bar in O(n) time. Then, we need to use the results to find the amount of
    water on the top of each bar. The following code should clarify any other details:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个问题可以通过计算每个酒吧左右两侧的最高酒吧来解决。这些陈述的有效实现包括在O(n)时间内预先计算每个酒吧左右两侧的最高酒吧。然后，我们需要使用结果来找到每个酒吧顶部的水量。以下代码应该澄清任何其他细节：
- en: '[PRE37]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The runtime of this code is O(n) with an auxiliary space of O(n) for the *left*[]
    array. A similar Big O can be obtained by using an implementation based on a stack
    (the bundled code contains this implementation as well). How about writing an
    implementation that has O(1) space?
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间为O(n)，*left*[]数组的辅助空间为O(n)。使用基于堆栈的实现也可以获得类似的大O。那么如何编写一个具有O(1)空间的实现呢？
- en: 'Well, instead of maintaining an array of size *n* to store all the left maximum
    heights, we can use two variables to store the maximum until that bar (this technique
    is known as *two-pointers*)*.* As you may recall, you observed this in some of
    the previous coding challenges. The two pointers are `maxBarLeft` and `maxBarRight`.
    The implementation is as follows:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们可以使用两个变量来存储到目前为止的最大值（这种技术称为*双指针*），而不是维护一个大小为*n*的数组来存储所有左侧的最大高度。正如您可能记得的，您在之前的一些编程挑战中观察到了这一点。这两个指针是`maxBarLeft`和`maxBarRight`。实现如下：
- en: '[PRE38]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The runtime of this code is O(n) with an O(1) space. The complete application
    is called *TrapRainWater*.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间为O(n)，空间复杂度为O(1)。完整的应用程序称为*TrapRainWater*。
- en: Coding challenge 21 – Buying and selling stock
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战21 - 购买和出售股票
- en: '**Amazon**, **Microsoft**'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**微软**'
- en: '**Problem**: Consider that you''ve been given an array of positive integers
    representing the price of a stock on each day. So, the *i*th element of the array
    represents the price of the stock on day *i*. As a general rule, you may not perform
    multiple transactions (a buy-sell sequence is known as a transaction) at the same
    time and you must sell the stock before you buy again. Write a snippet of code
    that returns the maximum profit in one of the following scenarios (usually, the
    interviewer will give you one of the following scenarios):'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设您已经得到了一个表示每天股票价格的正整数数组。因此，数组的第i个元素表示第i天的股票价格。通常情况下，您可能不会同时进行多次交易（买卖序列称为一次交易），并且必须在再次购买之前出售股票。编写一小段代码，在以下情况中返回最大利润（通常情况下，面试官会给您以下情况中的一个）：'
- en: You are allowed to buy and sell the stock only once.
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您只允许买卖股票一次。
- en: You are allowed to buy and sell the stock only twice.
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您只允许买卖股票两次。
- en: You are allowed to buy and sell the stock unlimited times.
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以无限次地买卖股票。
- en: You are allowed to buy and sell the stock only *k* times (*k* is given).
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您只允许买卖股票* k*次（* k*已知）。
- en: '**Solution**: Let''s consider that the given array of prices is *prices*={200,
    500, 1000, 700, 30, 400, 900, 400, 550}. Let''s tackle each of the preceding scenarios.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设给定的价格数组为*prices*={200, 500, 1000, 700, 30, 400, 900, 400, 550}。让我们分别解决上述情况。'
- en: Buying and selling the stock only once
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只买卖一次股票
- en: 'In this scenario, we must obtain the maximum profit by buying and selling the
    stock only once. This is quite simple and intuitive. The idea is to buy the stock
    when it is at its cheapest and sell it when it is at its most expensive. Let''s
    identify this statement via the following price-trend graph:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须通过只买卖一次股票来获得最大利润。这是非常简单和直观的。想法是在股票最便宜时买入，在最昂贵时卖出。让我们通过以下价格趋势图来确认这一说法：
- en: '![Figure 10.34 – Price-trend graph'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.34 - 价格趋势图'
- en: '](img/Figure_10.34_B15403.jpg)'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.34_B15403.jpg)'
- en: Figure 10.34 – Price-trend graph
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.34 - 价格趋势图
- en: 'Conforming to the preceding graphic, we should buy the stock at a price of
    30 on day 5 and sell it at a price of 900 on day 7\. This way, the profit will
    be at its maximum (870). To determine the maximum profit, we can employ a simple
    algorithm, as follows:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上图，我们应该在第5天以30的价格买入股票，并在第7天以900的价格卖出。这样，利润将达到最大值（870）。为了确定最大利润，我们可以采用一个简单的算法，如下所示：
- en: Consider the *cheapest price* at day 1 and no profit (*maximum profit* is 0).
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑第1天的*最低价格*，没有利润（*最大利润*为0）。
- en: 'Iterate the rest of the days (2, 3, 4, ...) and do the following:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代剩余的天数（2、3、4、...）并执行以下操作：
- en: a. For each day, update the *maximum profit* as the max(*current maximum profit,*
    (*today's price - cheapest price*)).
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: a. 对于每一天，将*最大利润*更新为max(*当前最大利润，（今天的价格 - 最低价格）*)。
- en: b. Update the *cheapest price* as the min(*current cheapest price, today's price*).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: b. 将*最低价格*更新为min(*当前最低价格，今天的价格*)。
- en: 'Let''s apply this algorithm to our data. So, we consider the *cheapest price*
    as 200 (price at day 1) and the *maximum profit* is 0\. The following image reveals
    the computations day by day:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个算法应用到我们的数据中。因此，我们将第1天的*最低价格*视为200，*最大利润*为0。下图显示了每天的计算：
- en: '![Figure 10.35 – Computing the maximum profit'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.35 - 计算最大利润'
- en: '](img/Figure_10.35_B15403.jpg)'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.35_B15403.jpg)'
- en: Figure 10.35 – Computing the maximum profit
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.35 - 计算最大利润
- en: '**Day 1**: The *minimum price* is 200; the *price on day 1 - minimum price*
    = 0; therefore, the *maximum profit* so far is 200.'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '**第1天**：*最低价格*为200；第1天的价格 - 最低价格 = 0；因此，到目前为止*最大利润*为200。'
- en: '**Day 2**: The *minimum price* is 200 (since 500 > 200); the *price on day
    2 - minimum price* = 300; therefore, the *maximum profit* so far is 300 (since
    300 > 200).'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '**第2天**：*最低价格*为200（因为500 > 200）；第2天的价格 - 最低价格 = 300；因此，到目前为止*最大利润*为300（因为300
    > 200）。'
- en: '**Day 3**: The *minimum price* is 200 (since 1000 > 200); the *price on day
    3 - minimum price* = 800; therefore, the *maximum profit* so far is 800 (since
    800 > 300).'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3天**：*最低价格*为200（因为1000 > 200）；第3天的价格 - 最低价格 = 800；因此，到目前为止*最大利润*为800（因为800
    > 300）。'
- en: '**Day 4**: The *minimum price* is 200 (since 700 > 200); the *price on day
    4 - minimum price* = 500; therefore, the *maximum profit* so far is 800 (since
    800 > 500).'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4天**：*最低价格*为200（因为700 > 200）；第4天的价格 - 最低价格 = 500；因此，到目前为止*最大利润*为800（因为800
    > 500）。'
- en: '**Day 5**: The *minimum price* is 30 (since 200 > 30); the *price on day 5
    - minimum price* = 0; therefore, the *maximum profit* so far is 800 (since 800
    > 0).'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5天**：*最低价格*为30（因为200 > 30）；第5天的价格 - 最低价格 = 0；因此，到目前为止*最大利润*为800（因为800 >
    0）。'
- en: '**Day 6**: The *minimum price* is 30 (since 400 > 30); the *price on day 6
    - minimum price* = 370; therefore, the *maximum profit* so far is 800 (since 800
    > 370).'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**第6天**：*最低价格*是30（因为400 > 30）；第6天的价格 - 最低价格 = 370；因此，到目前为止*最大利润*是800（因为800
    > 370）。'
- en: '**Day 7**: The *minimum price* is 30 (since 900 > 30); the *price on day 7
    - minimum price* = 870; therefore, the *maximum profit* so far is 870 (since 870
    > 800).'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**第7天**：*最低价格*是30（因为900 > 30）；第7天的价格 - 最低价格 = 870；因此，到目前为止*最大利润*是870（因为870
    > 800）。'
- en: '**Day 8**: The *minimum price* is 30 (since 400 > 30); the *price on day 8
    - minimum price* = 370; therefore, the *maximum profit* so far is 870 (since 870
    > 370).'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '**第8天**：*最低价格*是30（因为400 > 30）；第8天的价格 - 最低价格 = 370；因此，到目前为止*最大利润*是870（因为870
    > 370）。'
- en: '**Day 9**: The *minimum price* is 30 (since 550 > 30); the *price on day 9
    - minimum price* = 520; therefore, the *maximum profit* so far is 870 (since 870
    >520).'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '**第9天**：*最低价格*是30（因为550 > 30）；第9天的价格 - 最低价格 = 520；因此，到目前为止*最大利润*是870（因为870
    >520）。'
- en: Finally, the *maximum profit* is 870.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*最大利润*是870。
- en: 'Let''s see the code:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE39]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The runtime of this code is O(n). Let's tackle the next scenario.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n)。让我们来解决下一个情景。
- en: Buying and selling the stock only twice
  id: totrans-568
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只买卖股票两次
- en: 'In this scenario, we must obtain the maximum profit by buying and selling the
    stock only twice. The idea is to buy the stock when it is as its cheapest and
    sell it when it is at its most expensive. We do this twice. Let''s identify this
    statement via the following price-trend graph:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须通过只买卖股票两次来获得最大利润。想法是在股票最便宜时买入，最昂贵时卖出。我们这样做两次。让我们通过以下价格趋势图来识别这个陈述：
- en: '![Figure 10.36 – Price-trend graph'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.36 - 价格趋势图'
- en: '](img/Figure_10.36_B15403.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.36_B15403.jpg)'
- en: Figure 10.36 – Price-trend graph
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.36 - 价格趋势图
- en: Conforming to the preceding graph, we should buy the stock at a price of 200
    on day 1 and sell it at a price of 1,000 on day 3\. This transaction brings a
    profit of 800\. Next, we should buy the stock at a price of 30 on day 5 and sell
    it at a price of 900 on day 7\. This transaction brings a profit of 870\. So,
    the maximum profit is 870+800=1670.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图表，我们应该在第1天以200的价格买入股票，然后在第3天以1000的价格卖出。这笔交易带来了800的利润。接下来，我们应该在第5天以30的价格买入股票，然后在第7天以900的价格卖出。这笔交易带来了870的利润。因此，最大利润是870+800=1670。
- en: 'To determine the *maximum profit*, we must find the two most profitable transactions.
    We can do this via dynamic programming and the *divide and conquer* technique.
    We *divide* the algorithm into two parts. The first part of the algorithm contains
    the following steps:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定*最大利润*，我们必须找到两笔最有利可图的交易。我们可以通过动态规划和*分治*技术来实现这一点。我们将算法*分*成两部分。算法的第一部分包含以下步骤：
- en: Consider the *cheapest price* at day 1.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑第1天的*最便宜的价格*。
- en: 'Iterate the rest of the days (2, 3, 4, ...) and do the following:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代剩下的天数（2，3，4，...）并执行以下操作：
- en: a. Update the *cheapest price* as the min(*current cheapest price, today's price*).
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: a. 更新*最便宜的价格*，作为min（*当前最便宜的价格*，今天的价格*）。
- en: b. Track the *maximum profit* for today as the max(*maximum profit of the previous
    day*, (*today price - cheapest price*)).
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: b. 跟踪今天的*最大利润*，作为max（*前一天的最大利润*，（*今天的价格 - 最便宜的价格*））。
- en: At the end of this algorithm, we will have an array (let's denote it as *left*[])
    representing the maximum profit that can be obtained before each day (inclusive
    of that day). For example, until day 3 (inclusive of day 3), the maximum profit
    is 800 since you can buy at a price of 200 on day 1 and sell at a price of 1,000
    on day 3, or until day 7 (inclusive of day 7), where the maximum profit is 870
    since you can buy at a price of 30 on day 5 and sell at a price of 900 on day
    7, and so on.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个算法结束时，我们将得到一个数组（让我们称之为*left*[]），表示每天（包括当天）之前可以获得的最大利润。例如，直到第3天（包括第3天），最大利润是800，因为你可以在第1天以200的价格买入，第3天以1000的价格卖出，或者直到第7天（包括第7天），最大利润是870，因为你可以在第5天以30的价格买入，第7天以900的价格卖出，依此类推。
- en: 'This array is obtained via *step 2b*. We can represent it for our data as follows:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组是通过*步骤2b*获得的。我们可以将它表示为我们的数据如下：
- en: '![Figure 10.37 – Computing the maximum profit before each day, starting from
    day 1'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.37 - 从第1天开始计算每天之前的最大利润'
- en: '](img/Figure_10.37_B15403.jpg)'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.37_B15403.jpg)'
- en: Figure 10.37 – Computing the maximum profit before each day, starting from day
    1
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.37 - 从第1天开始计算每天之前的最大利润
- en: 'The *left*[] array is useful for after we''ve covered the second part of the
    algorithm. Next, the second part of the algorithm goes as follows:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '*left*[]数组在我们覆盖算法的第二部分之后非常有用。接下来，算法的第二部分如下：'
- en: Consider the *most expensive price* on the last day.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑最后一天的*最昂贵的价格*。
- en: 'Iterate the rest of the days from (*last*-1) to the *first* day(*last-1, last-2,
    last-3, ...*) and do the following:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从（*最后*-1）到*第一*天（*最后-1，最后-2，最后-3，...*）迭代剩下的天数，并执行以下操作：
- en: a. Update the *most expensive price* as the max(*current most expensive price,
    today's price*).
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: a. 更新*最昂贵的价格*，作为max（*当前最昂贵的价格*，今天的价格*）。
- en: b. Track the *maximum profit* for today as the max(*maximum profit of the next
    day, (most expensive price - today price*)).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: b. 跟踪今天的*最大利润*，作为max（*下一天的最大利润*，（最昂贵的价格 - 今天的价格*））。
- en: 'At the end of this algorithm, we will have an array (let''s denote it as *right*[])
    representing the maximum profit that can be obtained after each day (inclusive
    of that day). For example, after day 3 (inclusive of day 3), the maximum profit
    is 870 since you can buy at a price of 30 on day 5 and sell at a price of 900
    on day 7, or after day 7 the maximum profit is 150 since you can buy at a price
    of 400 on day 8 and sell at a price of 550 on day 9, and so on. This array is
    obtained via *step 2b*. We can represent it for our data as follows:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个算法结束时，我们将得到一个数组（让我们称之为*right*[]），表示每天（包括当天）之后可以获得的最大利润。例如，第3天之后（包括第3天），最大利润是870，因为你可以在第5天以30的价格买入，第7天以900的价格卖出，或者第7天之后最大利润是150，因为你可以在第8天以400的价格买入，第9天以550的价格卖出，依此类推。这个数组是通过*步骤2b*获得的。我们可以将它表示为我们的数据如下：
- en: '![Figure 10.38 – Computing the maximum profit after each day, starting from
    last day'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.38 - 从前一天开始计算每天的最大利润'
- en: '](img/Figure_10.38_B15403.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.38_B15403.jpg)'
- en: Figure 10.38 – Computing the maximum profit after each day, starting from the
    previous day
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.38 - 从前一天开始计算每天的最大利润
- en: 'So far, we have accomplished the *divide* part. Now, it''s time for the *conquer*
    part. The *maximum profit* that can be accomplished in two transactions can be
    obtained as the max(*left*[*day*]*+right*[*day*]). We can see this in the following
    image:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了*分割*部分。现在，是*征服*部分的时间了。可以通过max(*left*[*day*]*+right*[*day*])获得可以在两次交易中实现的*最大利润*。我们可以在下图中看到这一点：
- en: '![Figure 10.39 – Computing the final maximum profit of transactions 1 and 2'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.39 - 计算第1和第2次交易的最终最大利润'
- en: '](img/Figure_10.39_B15403.jpg)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.39_B15403.jpg)'
- en: Figure 10.39 – Computing the final maximum profit of transactions 1 and 2
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.39 - 计算第1和第2次交易的最终最大利润
- en: 'Now, let''s see the code:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看代码：
- en: '[PRE40]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The runtime of this code is O(n). Now, let's tackle the next scenario.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n)。现在，让我们来处理下一个情景。
- en: Buying and selling the stock an unlimited amount of times
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 买卖股票的次数不限
- en: 'In this scenario, we must obtain the maximum profit by buying and selling the
    stock an unlimited amount of times. You can identify this statement via the following
    price-trend graph:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须通过买卖股票不限次数来获得最大利润。您可以通过以下价格趋势图来确定这一点：
- en: '![Figure 10.40 – Price-trend graph'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.40 - 价格趋势图'
- en: '](img/Figure_10.40_B15403.jpg)'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.40_B15403.jpg)'
- en: Figure 10.40 – Price-trend graph
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.40 - 价格趋势图
- en: Conforming to the preceding graphic, we should buy the stock at a price of 200
    on day 1 and sell it at a price of 500 on day 2\. This transaction brings in a
    profit of 300\. Next, we should buy the stock at a price of 500 on day 2 and sell
    it at a price of 1000 on day 3\. This transaction brings in a profit of 500\.
    Of course, we can merge these two transactions into one by buying at a price of
    200 on day 1 and selling at a price of 1000 on day 3\. The same logic can be applied
    until day 9\. The final maximum profit will be 1820\. Take your time and identify
    all the transactions from day 1 to day 9.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图表，我们应该在第1天以200的价格买入股票，然后在第2天以500的价格卖出。这次交易带来了300的利润。接下来，我们应该在第2天以500的价格买入股票，然后在第3天以1000的价格卖出。这次交易带来了500的利润。当然，我们可以将这两次交易合并为一次，即在第1天以200的价格买入，然后在第3天以1000的价格卖出。同样的逻辑可以应用到第9天。最终的最大利润将是1820。花点时间，确定从第1天到第9天的所有交易。
- en: 'By studying the preceding price-trend graphic, we can see that this problem
    can be viewed as an attempt to find all the ascending sequences. The following
    graph highlights the ascending sequences for our data:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 通过研究前面的价格趋势图，我们可以看到这个问题可以被视为尝试找到所有的升序序列。以下图突出显示了我们数据的升序序列：
- en: '![Figure 10.41 – Ascending sequences'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.41 - 升序序列'
- en: '](img/Figure_10.41_B15403.jpg)'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.41_B15403.jpg)'
- en: Figure 10.41 – Ascending sequences
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.41 - 升序序列
- en: 'Finding all the ascending sequences is a simple task based on the following
    algorithm:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下算法，找到所有的升序序列是一个简单的任务：
- en: Consider the *maximum profit* as 0 (no profit).
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*最大利润*视为0（无利润）。
- en: 'Iterate all the days, starting from day 2, and do the following:'
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代所有的天数，从第2天开始，并执行以下操作：
- en: a. Compute the difference between the *today price* and the *preceding day price*
    (for example, at the first iteration, compute (the price of day 2 - the price
    of day 1), so 500 - 200).
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: a. 计算*今日价格*和*前一天价格*之间的差异（例如，在第一次迭代中，计算（第2天的价格 - 第1天的价格），所以500 - 200）。
- en: b. If the computed difference is positive, then increment the *maximum profit*
    by this difference.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果计算出的差异为正数，则将*最大利润*增加这个差异。
- en: 'At the end of this algorithm, we will know the final *maximum profit*. If we
    apply this algorithm to our data, then we''ll obtain the following output:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个算法结束时，我们将知道最终的*最大利润*。如果我们将这个算法应用到我们的数据中，那么我们将得到以下输出：
- en: '![Figure 10.42 – Computing the final maximum profit'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.42 - 计算最终最大利润'
- en: '](img/Figure_10.42_B15403.jpg)'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.42_B15403.jpg)'
- en: Figure 10.42 – Computing the final maximum profit
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.42 - 计算最终最大利润
- en: '**Day 1**: The *maximum profit* is 0.'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '**第1天**：*最大利润*为0。'
- en: '**Day 2**: The *maximum profit* is 0 + (500 - 200) = 0 + 300 = 300.'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '**第2天**：*最大利润*为0 + (500 - 200) = 0 + 300 = 300。'
- en: '**Day 3**: The *maximum profit* is 300 + (1000 - 500) = 300 + 500 = 800.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3天**：*最大利润*为300 + (1000 - 500) = 300 + 500 = 800。'
- en: '**Day 4**: The *maximum profit* remains 800 since 700 - 1000 < 0.'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4天**：*最大利润*仍为800，因为700 - 1000 < 0。'
- en: '**Day 5**: The *maximum profit* remains 800 since 30 - 700 < 0.'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '**第5天**：*最大利润*仍为800，因为30 - 700 < 0。'
- en: '**Day 6**: The *maximum profit* is 800 + (400 - 30) = 800 + 370 = 1170.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '**第6天**：*最大利润*为800 + (400 - 30) = 800 + 370 = 1170。'
- en: '**Day 7**: The *maximum profit* is 1170 + (900 - 400) = 1170 + 500 = 1670.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '**第7天**：*最大利润*为1170 + (900 - 400) = 1170 + 500 = 1670。'
- en: '**Day 8**: The *maximum profit* remains 1670 since 400 - 900 < 0.'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**第8天**：*最大利润*仍为1670，因为400 - 900 < 0。'
- en: '**Day 9**: The *maximum profit* is 1670 + (550 - 400) = 1670 + 150 = 1820.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '**第9天**：*最大利润*为1670 + (550 - 400) = 1670 + 150 = 1820。'
- en: The final *maximum profit* is 1820.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的*最大利润*为1820。
- en: 'In terms of code, this looks as follows:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，情况如下：
- en: '[PRE41]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The runtime of this code is O(n). Next, let's tackle the last scenario.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n)。接下来，让我们来处理最后一个情景。
- en: Buying and selling the stock only k times (k is given)
  id: totrans-632
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只买卖股票k次（给定k）
- en: This scenario is the generalized version of the *Buying and selling the stock
    only twice*. scenario. Mainly, by solving this scenario, we also solve the *Buying
    and selling the stock only twice* scenario for *k*=2.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '这种情况是*只买卖股票两次*的一般化版本。主要是，通过解决这种情况，我们也解决了*k*=2时的*只买卖股票两次*情况。 '
- en: 'Based on our experience from the previous scenarios, we know that solving this
    problem can be done via Dynamic Programming. More precisely, we need to track
    two arrays:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们从之前情景中的经验，我们知道解决这个问题可以通过动态规划来完成。更确切地说，我们需要跟踪两个数组：
- en: The first array will track the *maximum profit* of *p* transactions when the
    last transaction is on the *q*th day.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个数组将跟踪在第*q*天进行最后一笔交易时*p*次交易的*最大利润*。
- en: The second array will track the *maximum profit* of *p* transactions until the
    *q*th day.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个数组将跟踪在第*q*天之前*p*次交易的*最大利润*。
- en: 'If we denote the first array as `temp` and the second array as `result`, then
    we have the following two relations:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将第一个数组表示为`temp`，第二个数组表示为`result`，那么我们有以下两个关系：
- en: '[PRE42]'
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For a better understanding, let''s put these relations into the context of
    code:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们将这些关系放入代码的上下文中：
- en: '[PRE44]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The runtime of this code is O(kn). The complete application is called *BestTimeToBuySellStock*.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(kn)。完整的应用程序称为*BestTimeToBuySellStock*。
- en: Coding challenge 22 – Longest sequence
  id: totrans-643
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战22-最长序列
- en: '**Amazon**, **Adobe**, **Microsoft**'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**Adobe**，**微软**'
- en: '**Problem**: Consider that you''ve been given an array of integers. Write a
    snippet of code that finds the longest sequence of integers. Notice that a sequence
    contains only consecutive distinct elements. The order of the elements in the
    given array is not important.'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经得到了一个整数数组。编写一小段代码，找到最长的整数序列。注意，序列只包含连续不同的元素。给定数组中元素的顺序并不重要。'
- en: '**Solution**: Let''s consider that the given array is { 4, 2, 9, 5, 12, 6,
    8}. The longest sequence contains three elements and it is formed from 4, 5, and
    6\. Alternatively, if the given array is {2, 0, 6, 1, 4, 3, 8}, then the longest
    sequence contains five elements and it is formed from 2, 0, 1, 4, and 3\. Again,
    notice that the order of the elements in the given array is not important.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设给定数组是{4, 2, 9, 5, 12, 6, 8}。最长序列包含三个元素，由4、5和6组成。或者，如果给定数组是{2, 0,
    6, 1, 4, 3, 8}，那么最长序列包含五个元素，由2、0、1、4和3组成。再次注意，给定数组中元素的顺序并不重要。'
- en: The brute-force or naive approach consists of sorting the array in ascending
    order and finding the longest sequence of consecutive integers. Since the array
    is sorted, a gap breaks a sequence. However, such an implementation will have
    a runtime of O(n log n).
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 蛮力或朴素方法包括对数组进行升序排序，并找到最长的连续整数序列。由于数组已排序，间隙会打破序列。然而，这样的实现将具有O(n log n)的运行时间。
- en: 'A better approach consists of employing a *hashing* technique. Let''s use the
    following image as support for our solution:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用*哈希*技术。让我们使用以下图像来支持我们的解决方案：
- en: '![Figure 10.43 – Sequence set'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.43-序列集'
- en: '](img/Figure_10.43_B15403.jpg)'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.43_B15403.jpg)'
- en: Figure 10.43 – Sequence set
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.43-序列集
- en: 'First, we build a set from the given array {4, 2, 9, 5, 12, 6, 8}. As the preceding
    image reveals, the set doesn''t maintain the order of insertion, but this is not
    important for us. Next, we iterate the given array and, for each traversed element
    (let''s denote it as *e*), we search the set for *e*-1\. For example, when we
    traverse 4, we search the set for 3, when we traverse 2, we search for 1, and
    so on. If *e-*1 is not in the set, then we can say that *e* represents the start
    of a new sequence of consecutive integers (in this case, we have sequences starting
    with 12, 8, 4, and 2); otherwise, it is already part of an existing sequence.
    When we have the start of a new sequence, we continue to search the set for the
    consecutive elements: *e*+1, *e*+2, *e*+3, and so on. As long as we find consecutive
    elements, we count them. If e+*i* (1, 2, 3, ...) cannot be found, then the current
    sequence is complete, and we know its length. Finally, we compare this length
    with the longest length we''ve found so far and proceed accordingly.'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从给定数组{4, 2, 9, 5, 12, 6, 8}构建一个集合。如前面的图像所示，集合不保持插入顺序，但这对我们来说并不重要。接下来，我们遍历给定数组，并对于每个遍历的元素（我们将其表示为*e*），我们搜索*e*-1的集合。例如，当我们遍历4时，我们搜索3的集合，当我们遍历2时，我们搜索1，依此类推。如果*e-*1不在集合中，那么我们可以说*e*代表连续整数新序列的开始（在这种情况下，我们有以12、8、4和2开头的序列）；否则，它已经是现有序列的一部分。当我们有新序列的开始时，我们继续搜索连续元素的集合：*e*+1、*e*+2、*e*+3等等。只要我们找到连续元素，我们就计数它们。如果找不到*e+*i*（1、2、3、...），那么当前序列就完成了，我们知道它的长度。最后，我们将这个长度与迄今为止找到的最长长度进行比较，并相应地进行下一步。
- en: 'The code for this is quite simple:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常简单：
- en: '[PRE45]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The runtime of this code is O(n) with an auxiliary space of O(n). Challenge
    yourself and print the longest sequence. The complete application is called *LongestConsecutiveSequence*.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n)，辅助空间是O(n)。挑战自己并打印最长的序列。完整的应用程序称为*LongestConsecutiveSequence*。
- en: Coding challenge 23 – Counting game score
  id: totrans-656
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战23-计分游戏
- en: '**Amazon**, **Google**, **Microsoft**'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**微软**'
- en: '**Problem**: Consider a game where a player can score 3, 5, or 10 points in
    a single move. Moreover, consider that you''ve been given a total score, *n*.
    Write a snippet of code that returns the number of ways to reach this score.'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个游戏，玩家可以在单次移动中得分3、5或10分。此外，考虑到你已经得到了一个总分*n*。编写一小段代码，返回达到这个分数的方法数。'
- en: '**Solution**: Let''s consider that the given score is 33\. There are seven
    ways to reach this score:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设给定的分数是33。有七种方法可以达到这个分数：'
- en: (10+10+10+3) = 33
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: (10+10+10+3) = 33
- en: (5+5+10+10+3) = 33
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: (5+5+10+10+3) = 33
- en: (5+5+5+5+10+3) = 33
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: (5+5+5+5+10+3) = 33
- en: (5+5+5+5+5+5+3) = 33
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: (5+5+5+5+5+5+3) = 33
- en: (3+3+3+3+3+3+3+3+3+3+3) = 33
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: (3+3+3+3+3+3+3+3+3+3+3) = 33
- en: (3+3+3+3+3+3+5+5+5) = 33
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: (3+3+3+3+3+3+5+5+5) = 33
- en: (3+3+3+3+3+3+5+10) = 33
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: (3+3+3+3+3+3+5+10) = 33
- en: 'We can solve this problem with the help of Dynamic Programming. We create a
    table (an array) whose size is equal to *n*+1\. In this table, we store the counts
    of all scores from 0 to *n*. For moves 3, 5, and 10, we increment the values in
    the array. The code speaks for itself:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以借助动态规划来解决这个问题。我们创建一个大小等于*n*+1的表（数组）。在这个表中，我们存储从0到*n*的所有分数的计数。对于移动3、5和10，我们增加数组中的值。代码说明了一切：
- en: '[PRE46]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The runtime of this code is O(n) with O(n) extra space. The complete application
    is called *CountScore3510*.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n)，额外空间是O(n)。完整的应用程序称为*CountScore3510*。
- en: Coding challenge 24 – Checking for duplicates
  id: totrans-670
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战24-检查重复项
- en: '**Amazon**, **Google**, **Adobe**'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**'
- en: '`true` if this array contains duplicates.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个数组包含重复项，则返回`true`。
- en: '**Solution**: Let''s assume that the given integer is *arr*={1, 4, 5, 4, 2,
    3}, so 4 is a duplicate. The brute-force approach (or the naive approach) will
    rely on nested loops, as shown in the following trivial code:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设给定的整数是*arr*={1, 4, 5, 4, 2, 3}，所以4是重复的。蛮力方法（或者朴素方法）将依赖嵌套循环，如下面的简单代码所示：'
- en: '[PRE47]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This code is very simple but it performs in O(n2) and O(1) auxiliary space.
    We can sort the array before checking for duplicates. If the array is sorted,
    then we can compare adjacent elements. If any adjacent elements are equal, we
    can say that the array contains duplicates:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常简单，但是它的时间复杂度是O(n2)，辅助空间复杂度是O(1)。我们可以在检查重复项之前对数组进行排序。如果数组已经排序，那么我们可以比较相邻的元素。如果任何相邻的元素相等，我们可以说数组包含重复项：
- en: '[PRE48]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This code performs in O(n log n) (since we sort the array) and O(1) auxiliary
    space. If we want to write an implementation that performs in O(n) time, we must
    also consider an auxiliary O(n) space. For example, we can rely on *hashing* (if
    you are not familiar with the concept of hashing, then please read [*Chapter 6*](B15403_06_Final_JM_ePub.xhtml#_idTextAnchor080)*,
    Object-Oriented Programming*, the *Hash table* problem). In Java, we can use hashing
    via the built-in `HashSet` implementation, so there is no need to write a hashing
    implementation from scratch. But how is this `HashSet` useful? While we iterate
    the given array, we add each element from the array to `HashSet`. But if the current
    element is already present in `HashSet`, this means we found a duplicate, so we
    can stop and return:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的时间复杂度是O(n log n)（因为我们对数组进行了排序），辅助空间复杂度是O(1)。如果我们想要编写一个时间复杂度为O(n)的实现，我们还必须考虑辅助空间复杂度为O(n)。例如，我们可以依赖*哈希*（如果您不熟悉哈希的概念，请阅读[*第6章*](B15403_06_Final_JM_ePub.xhtml#_idTextAnchor080)*，面向对象编程*，*哈希表*问题）。在Java中，我们可以通过内置的`HashSet`实现来使用哈希，因此无需从头开始编写哈希实现。但是`HashSet`有什么用呢？当我们遍历给定数组时，我们将数组中的每个元素添加到`HashSet`中。但是如果当前元素已经存在于`HashSet`中，这意味着我们找到了重复项，所以我们可以停止并返回：
- en: '[PRE49]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So, this code performs in O(n) time and auxiliary O(n) space. But we can simplify
    the preceding code if we remember that `HashSet` doesn't accept duplicates. In
    other words, if we insert all the elements of the given array into `HashSet` and
    this array contains duplicates, then the size of `HashSet` will differ from the
    size of the array. This implementation and a Java 8-based implementation that
    has an O(n) runtime and an O(n) auxiliary space can be found in the code bundled
    with this book.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这段代码的时间复杂度是O(n)，辅助空间复杂度是O(n)。但是，如果我们记住`HashSet`不接受重复项，我们可以简化上述代码。换句话说，如果我们将给定数组的所有元素插入`HashSet`，并且这个数组包含重复项，那么`HashSet`的大小将与数组的大小不同。这个实现和一个基于Java
    8的实现，具有O(n)的运行时间和O(n)的辅助空间，可以在本书附带的代码中找到。
- en: 'How about an implementation that has an O(n) runtime and an O(1) auxiliary
    space? This is possible if we take two important constraints of the given array
    into consideration:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现具有O(n)的运行时间和O(1)的辅助空间？如果我们考虑给定数组的两个重要约束，这是可能的：
- en: The given array doesn't contain negative elements.
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定的数组不包含负数元素。
- en: The elements lies in the range [0, *n*-1], where *n=arr.length*.
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素位于[0，*n*-1]的范围内，其中*n=arr.length*。
- en: Under the umbrella of these two constraints, we can employee the following algorithm.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个约束的保护下，我们可以使用以下算法。
- en: 'We iterate over the given array and for each *arr*[*i*], we do the following:'
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历给定的数组，对于每个*arr*[*i*]，我们执行以下操作：
- en: a. If *arr*[abs(*arr*[*i*])] is greater than 0, then we make it negative.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: a. 如果*arr*[abs(*arr*[*i*])]大于0，则将其变为负数。
- en: b. If *arr*[abs(*arr*[*i*])] is equal to 0, then we make it -(*arr.length*-1).
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果*arr*[abs(*arr*[*i*])]等于0，则将其变为-(*arr.length*-1)。
- en: c. Otherwise, we return `true` (there are duplicates).
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: c. 否则，我们返回`true`（有重复项）。
- en: 'Let''s consider our array, *arr*={1, 4, 5, 4, 2, 3}, and apply the preceding
    algorithm:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们的数组*arr*={1, 4, 5, 4, 2, 3}，并应用上述算法：
- en: '*i*=0, since *arr*[abs(*arr*[0])] = *arr*[1] = 4 > 0 results in *arr*[1] =
    -*arr*[1] = -4.'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*i*=0，因为*arr*[abs(*arr*[0])] = *arr*[1] = 4 > 0 导致*arr*[1] = -*arr*[1] = -4。'
- en: '*i*=1, since *arr*[abs(*arr*[1])] = *arr*[4] = 2 > 0 results in *arr*[4] =
    -*arr*[4] = -2.'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*i*=1，因为*arr*[abs(*arr*[1])] = *arr*[4] = 2 > 0 导致*arr*[4] = -*arr*[4] = -2。'
- en: '*i*=2, since *arr*[abs(*arr*[5])] = *arr*[5] = 3 > 0 results in *arr*[5] =
    -*arr*[5] = -3.'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*i*=2，因为*arr*[abs(*arr*[5])] = *arr*[5] = 3 > 0 导致*arr*[5] = -*arr*[5] = -3。'
- en: '*i*=3, since *arr*[abs(*arr*[4])] = *arr*[4] = -2 < 0 returns `true` (we found
    a duplicate)'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*i*=3，因为*arr*[abs(*arr*[4])] = *arr*[4] = -2 < 0 返回`true`（我们找到了重复项）。'
- en: 'Now, let''s look at *arr*={1, 4, 5, 3, 0, 2, 0}:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看*arr*={1, 4, 5, 3, 0, 2, 0}：
- en: '*i*=0, since *arr*[abs(*arr*[0])] = *arr*[1] = 4 > 0 results in *arr*[1] =
    -*arr*[1] = -4.'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*i*=0，因为*arr*[abs(*arr*[0])] = *arr*[1] = 4 > 0 导致*arr*[1] = -*arr*[1] = -4。'
- en: '*i*=1, since *arr*[abs(*arr*[1])] = *arr*[4] = 0 = 0 results in *arr*[4] =
    -(*arr.length*-1) = -6.'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*i*=1，因为*arr*[abs(*arr*[1])] = *arr*[4] = 0 = 0 导致*arr*[4] = -(*arr.length*-1)
    = -6。'
- en: '*i*=2, since *arr*[abs(*arr*[2])] = *arr*[5] = 2 > 0 results in *arr*[5] =
    -*arr*[5] = -2.'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*i*=2，因为*arr*[abs(*arr*[2])] = *arr*[5] = 2 > 0 导致*arr*[5] = -*arr*[5] = -2。'
- en: '*i*=3, since *arr*[abs(*arr*[3])] = *arr*[3] = 3 > 0 results in *arr*[3] =
    -*arr*[3] = -3.'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*i*=3，因为*arr*[abs(*arr*[3])] = *arr*[3] = 3 > 0 导致*arr*[3] = -*arr*[3] = -3。'
- en: '*i*=4, since *arr*[abs(*arr*[4])] = *arr*[6] = 0 = 0 results in *arr*[6] =
    -(*arr.length*-1) = -6.'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*i*=4，因为*arr*[abs(*arr*[4])] = *arr*[6] = 0 = 0 导致*arr*[6] = -(*arr.length*-1)
    = -6。'
- en: '*i*=5, since *arr*[abs(*arr*[5])] = *arr*[2] = 5 > 0 results in *arr*[2] =
    -*arr*[2] = -5.'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*i*=5，因为*arr*[abs(*arr*[5])] = *arr*[2] = 5 > 0 导致*arr*[2] = -*arr*[2] = -5。'
- en: '*i*=6, since *arr*[abs(*arr*[6])] = *arr*[6] = -6 < 0 returns `true` (we found
    a duplicate).'
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*i*=6，因为*arr*[abs(*arr*[6])] = *arr*[6] = -6 < 0 返回`true`（我们找到了重复项）。'
- en: 'Let''s put this algorithm into code:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个算法写成代码：
- en: '[PRE50]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The complete application is called *DuplicatesInArray*.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*DuplicatesInArray*。
- en: For the following five coding challenges, you can find the solutions in the
    code bundled with this book. Take your time and challenge yourself to come up
    with a solution before checking the bundled code.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的五个编码挑战，您可以在本书附带的代码中找到解决方案。花点时间，挑战自己在查看附带代码之前想出一个解决方案。
- en: Coding challenge 25 – Longest distinct substring
  id: totrans-705
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战25 - 最长不同子串
- en: '**Problem**: Consider you''ve been given a string, *str*. The accepted characters
    of *str* belong to the extended ASCII table (256 characters). Write a snippet
    of code that finds the longest substring of *str* containing distinct characters.'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了一个字符串*str*。*str*的接受字符属于扩展ASCII表（256个字符）。编写一小段代码，找到包含不同字符的*str*的最长子串。'
- en: '**Solution**: As a hint, use the *sliding window* technique. If you are not
    familiar with this technique, then consider reading *Sliding Window Technique*
    by Zengrui Wang ([https://medium.com/@zengruiwang/sliding-window-technique-360d840d5740](https://medium.com/@zengruiwang/sliding-window-technique-360d840d5740))
    before continuing. The complete application is called *LongestDistinctSubstring*.
    You can visit the following link to check the code: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/LongestDistinctSubstring](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/LongestDistinctSubstring)'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：作为提示，使用*滑动窗口*技术。如果您对这种技术不熟悉，请考虑在继续之前阅读Zengrui Wang的*滑动窗口技术*（[https://medium.com/@zengruiwang/sliding-window-technique-360d840d5740](https://medium.com/@zengruiwang/sliding-window-technique-360d840d5740)）。完整的应用程序称为*LongestDistinctSubstring*。您可以访问以下链接检查代码：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/LongestDistinctSubstring](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/LongestDistinctSubstring)'
- en: Coding challenge 26 – Replacing elements with ranks
  id: totrans-708
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战26-用排名替换元素
- en: '**Problem**: Consider you''ve been given an array without duplicates, *m*.
    Write a snippet of code that replaces each element of this array with the element''s
    rank. The minimum element in the array has a rank of 1, the second minimum has
    a rank of 2, and so on.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了一个没有重复元素的数组*m*。编写一小段代码，用数组的排名替换每个元素。数组中的最小元素排名为1，第二小的排名为2，依此类推。'
- en: '`TreeMap`. The complete application is called *ReplaceElementWithRank*. You
    can visit the following link to check the code: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/ReplaceElementWithRank](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/ReplaceElementWithRank)'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeMap`。完整的应用程序称为*ReplaceElementWithRank*。您可以访问以下链接检查代码：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/ReplaceElementWithRank](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/ReplaceElementWithRank)'
- en: Coding challenge 27 – Distinct elements in every sub-array
  id: totrans-711
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战27-每个子数组中的不同元素
- en: '**Problem**: Consider you''ve been given an array, *m*, and an integer, *n*.
    Write a snippet of code that counts the number of distinct elements in every sub-array
    of size *n*.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了一个数组*m*和一个整数*n*。编写一小段代码，计算大小为*n*的每个子数组中不同元素的数量。'
- en: '`HashMap` to store the frequency of the elements in the current window whose
    size is *n*. The complete application is called *CountDistinctInSubarray*. You
    can visit the following link to check the code: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/CountDistinctInSubarray](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/CountDistinctInSubarray)'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap`用于存储当前窗口（大小为*n*）中元素的频率。完整的应用程序称为*CountDistinctInSubarray*。您可以访问以下链接检查代码：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/CountDistinctInSubarray](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/CountDistinctInSubarray)'
- en: Coding challenge 28 – Rotating the array k times
  id: totrans-714
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战28-将数组旋转k次
- en: '**Problem**: Consider you''ve been given an array, *m*, and an integer, *k*.
    Write a snippet of code that rotates the array to the right *k* times (for example,
    array {1, 2, 3, 4, 5}, when rotated three times, results in {3, 4, 5, 1, 2}).'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了一个数组*m*和一个整数*k*。编写一小段代码，将数组向右旋转*k*次（例如，数组{1,2,3,4,5}，旋转三次后结果为{3,4,5,1,2}）。'
- en: '**Solution**: As a hint, rely on the modulo (%) operator. The complete application
    is called *RotateArrayKTimes*. You can visit the following link to check the code:
    [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/RotateArrayKTimes](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/RotateArrayKTimes).'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：作为提示，依赖于取模（%）运算符。完整的应用程序称为*RotateArrayKTimes*。您可以访问以下链接检查代码：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/RotateArrayKTimes](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/RotateArrayKTimes)。'
- en: Coding challenge 29 – Distinct absolute values in sorted arrays
  id: totrans-717
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战29-已排序数组中的不同绝对值
- en: '**Problem**: Consider you''ve been given a sorted array of integers, *m*. Write
    a snippet of code that counts the distinct absolute values (for example, -1 and
    1 are considered a single value).'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了一个已排序的整数数组*m*。编写一小段代码，计算不同的绝对值（例如，-1和1被视为一个值）。'
- en: '**Solution**: As a hint, use the *sliding window* technique. If you are not
    familiar with this technique, then consider reading *Sliding Window Technique*
    by Zengrui Wang ([https://medium.com/@zengruiwang/sliding-window-technique-360d840d5740](https://medium.com/@zengruiwang/sliding-window-technique-360d840d5740))
    before continuing. The complete application is called *CountDistinctAbsoluteSortedArray*.
    You can visit the following link to check the code: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/CountDistinctAbsoluteSortedArray](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/CountDistinctAbsoluteSortedArray)'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：作为提示，使用*滑动窗口*技术。如果您对这种技术不熟悉，可以考虑在继续之前阅读Zengrui Wang的*滑动窗口技术*（[https://medium.com/@zengruiwang/sliding-window-technique-360d840d5740](https://medium.com/@zengruiwang/sliding-window-technique-360d840d5740)）。完整的应用程序称为*CountDistinctAbsoluteSortedArray*。您可以访问以下链接检查代码：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/CountDistinctAbsoluteSortedArray](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter10/CountDistinctAbsoluteSortedArray)'
- en: Summary
  id: totrans-720
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The goal of this chapter was to help you master various coding challenges involving
    strings and/or arrays. Hopefully, the coding challenges in this chapter have provided
    various techniques and skills that will be very useful in tons of coding challenges
    that fall under this category. Don't forget that you can enrich your skills even
    more via the book *Java Coding Problems* ([https://www.amazon.com/gp/product/1789801419/](https://www.amazon.com/gp/product/1789801419/)),
    which is published by Packt as well. *Java Coding Problems* comes with 35+ strings
    and arrays problems that were not tackled in this book.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是帮助您掌握涉及字符串和/或数组的各种编码挑战。希望本章的编码挑战提供了各种技术和技能，这些技能将在许多属于这一类别的编码挑战中非常有用。不要忘记，您可以通过Packt出版的书籍*Java编码问题*（[https://www.amazon.com/gp/product/1789801419/](https://www.amazon.com/gp/product/1789801419/)）进一步丰富您的技能。*Java编码问题*包含35个以上的字符串和数组问题，这些问题在本书中没有涉及。
- en: In the next chapter, we will discuss linked lists and maps.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论链表和映射。
