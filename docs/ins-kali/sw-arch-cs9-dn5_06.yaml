- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Azure Service Fabric
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Service Fabric
- en: This chapter is dedicated to describing Azure Service Fabric, which is a Microsoft
    opinionated microservices orchestrator. It is available on Azure, but Service
    Fabric software is also available for download, meaning users can use it to define
    their own on-premises microservices clusters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门描述了Azure Service Fabric，它是微软的一种主观的微服务编排器。它在Azure上可用，但Service Fabric软件也可以下载，这意味着用户可以使用它来定义自己的本地微服务集群。
- en: While Service Fabric is not as diffused as Kubernetes, it has a better learning
    curve and enables you to experiment with the fundamental concepts of microservices,
    and to build sophisticated solutions in a very short space of time. Moreover,
    it offers an integrated deployment environment, which includes everything you
    need to implement a complete application. More specifically, it also offers its
    integrated communication protocol, and an easy and reliable way to store state
    information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Service Fabric并不像Kubernetes那样广泛使用，但它具有更好的学习曲线，使您能够尝试微服务的基本概念，并在很短的时间内构建复杂的解决方案。此外，它提供了一个集成的部署环境，包括您实现完整应用所需的一切。更具体地说，它还提供了集成的通信协议和一种简单可靠的存储状态信息的方式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Visual Studio support for Azure Service Fabric applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio对Azure Service Fabric应用程序的支持
- en: How to define and configure an Azure Service Fabric cluster
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义和配置Azure Service Fabric集群
- en: How to code reliable services, and their communication in practice, through
    the "logging microservices" use case
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过“日志微服务”使用案例来实践编写可靠的服务及其通信
- en: By the end of this chapter, you will have learned how to implement a complete
    solution based on Azure Service Fabric.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您将学会如何基于Azure Service Fabric实现一个完整的解决方案。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, you will require the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将需要以下内容：
- en: Visual Studio 2019 free Community Edition or better, with all the database tools
    and the Azure development workload installed.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019免费社区版或更高版本，已安装所有数据库工具和Azure开发工作负载。
- en: A free Azure account. The *Creating an Azure account* section in *Chapter 1*,
    *Understanding the Importance of Software Architecture*, explains how to create
    one.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个免费的Azure账户。*第1章*的*理解软件架构的重要性*中的*创建Azure账户*部分解释了如何创建账户。
- en: A local emulator for Azure Service Fabric to debug your microservices in Visual
    Studio. It is free and can be downloaded from [https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-get-started#install-the-sdk-and-tools](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-get-started#install-the-sdk-and).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio中调试微服务时，需要一个用于Azure Service Fabric的本地仿真器。它是免费的，可以从[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-get-started#install-the-sdk-and-tools](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-get-started#install-the-sdk-and)下载。
- en: 'To avoid installation issues, ensure that your version of Windows is up to
    date. Moreover, the emulator uses PowerShell high-privilege-level commands that,
    by default, are blocked by PowerShell. To enable them, you need to execute the
    following command in the Visual Studio Package Manager Console or in any PowerShell
    console. Visual Studio or an external PowerShell console must be started as an
    *administrator* for the following command to be successful:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免安装问题，请确保您的Windows版本是最新的。此外，仿真器使用PowerShell高特权级命令，默认情况下被PowerShell阻止。要启用它们，您需要在Visual
    Studio包管理器控制台或任何PowerShell控制台中执行以下命令。为了使以下命令成功，必须以*管理员*身份启动Visual Studio或外部PowerShell控制台：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Visual Studio support for Azure Service Fabric
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio对Azure Service Fabric的支持
- en: Visual Studio has a specific project template for microservice applications,
    based on the Service Fabric platform, where you can define various microservices,
    configure them, and deploy them to Azure Service Fabric, which is a microservice
    orchestrator. Azure Service Fabric will be described in more detail in the next
    section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio具有针对微服务应用程序的特定项目模板，基于Service Fabric平台，您可以在其中定义各种微服务，配置它们，并将它们部署到Azure
    Service Fabric，这是一个微服务编排器。Azure Service Fabric将在下一节中详细介绍。
- en: In this section, we will describe the various types of microservice you can
    define within a Service Fabric Application. A complete code example will be provided
    in the last section of this chapter. If you want to debug microservices on your
    development machine, you need to install the Service Fabric emulator listed in
    this chapter's technical requirements.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述在Service Fabric应用程序中可以定义的各种类型的微服务。本章最后一节将提供一个完整的代码示例。如果您想在开发机器上调试微服务，您需要安装本章技术要求中列出的Service
    Fabric仿真器。
- en: 'Service Fabric Applications can be found by selecting **Cloud** in the *Visual
    Studio project type drop-down filter*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在“Visual Studio项目类型下拉筛选器”中选择**云**来找到Service Fabric应用程序：
- en: '![](img/B16756_06_01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_06_01.png)'
- en: 'Figure 6.1: Selecting a Service Fabric Application'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：选择Service Fabric应用程序
- en: 'Once you have selected the project and chosen the project and solution names,
    you can choose from a variety of services:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 选择项目并选择项目和解决方案名称后，您可以选择多种服务：
- en: '![](img/B16756_06_02.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_06_02.png)'
- en: 'Figure 6.2: Choice of services'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：服务选择
- en: All projects under .NET Core use a microservice model that is specific to Azure
    Service Fabric. The Guest Executable adds a wrapper around an existing Windows
    application to turn it into a microservice that can run in Azure Service Fabric.
    The Container application enables the addition of any Docker image in the Service
    Fabric application. All the other choices scaffold a template that allows you
    to code a microservice with a Service Fabric-specific pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有基于.NET Core的项目都使用了针对Azure Service Fabric特定的微服务模型。Guest Executable在现有的Windows应用程序周围添加了一个包装器，将其转换为可以在Azure
    Service Fabric中运行的微服务。Container应用程序允许在Service Fabric应用程序中添加任何Docker镜像。所有其他选择都提供了一个模板，允许您使用Service
    Fabric特定的模式编写微服务。
- en: 'If you select **Stateless Service** and fill in all the request information,
    Visual Studio creates two projects: an application project that contains configuration
    information for the overall application, and a project for the specific service
    you have chosen that contains both the service code and a service-specific configuration.
    If you want to add more microservices to your application, right-click on the
    application project and select **Add** | **New Service Fabric Service**.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择**无状态服务**并填写所有请求信息，Visual Studio将创建两个项目：一个包含整个应用程序的配置信息的应用程序项目，以及一个包含您选择的特定服务的服务代码和特定服务配置的项目。如果您想向应用程序添加更多微服务，请右键单击应用程序项目，然后选择**添加**
    | **新的 Service Fabric 服务**。
- en: If you right-click on the solution and select **Add** | **New project**, a new
    Service Fabric application will be created instead of a new service being added
    to the already existing application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您右键单击解决方案并选择**添加** | **新项目**，将创建一个新的 Service Fabric 应用程序，而不是将新服务添加到已经存在的应用程序中。
- en: 'If you select **Guest Executable**, you need to provide the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择**Guest Executable**，您需要提供以下内容：
- en: The service name.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务名称。
- en: A folder containing the main executable file, along with all the files it needs
    in order to work properly. You need this if you want to create a copy of this
    folder in your project or simply to link to the existing folder.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含主可执行文件的文件夹，以及为了正常工作而需要的所有文件。如果您想要在项目中创建此文件夹的副本，或者只是链接到现有文件夹，您需要这个。
- en: Whether to add a link to this folder, or to copy the selected folder into the
    Service Fabric project.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否要添加一个链接到此文件夹，或者将所选文件夹复制到 Service Fabric 项目中。
- en: The main executable file.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主可执行文件。
- en: Arguments to pass on the command line to that executable.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要传递给可执行文件的命令行参数。
- en: Which folder to use as a working folder on Azure. You want to use the folder
    containing the main executable (`CodeBase`), the folder where Azure Service Fabric
    will package the entire microservice (`CodePackage`), or a new subfolder named
    `Work`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在Azure上使用作为工作文件夹的文件夹。您可以使用包含主可执行文件（`CodeBase`）的文件夹，Azure Service Fabric将在其中打包整个微服务的文件夹（`CodePackage`），或者命名为`Work`的新子文件夹。
- en: 'If you select **Container**, you need to provide the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择**容器**，您需要提供以下内容：
- en: The service name.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务名称。
- en: The complete name of a Docker image in your private Azure Container Registry.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您私有Azure容器注册表中的Docker镜像的完整名称。
- en: The username that will be used to connect to Azure Container Registry. The password
    will be specified manually in the same `RepositoryCredentials` XML element of
    the application configuration file that was automatically created for the username.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用于连接到Azure容器注册表的用户名。密码将在与用户名自动创建的应用程序配置文件的相同`RepositoryCredentials` XML元素中手动指定。
- en: The port where you can access your service (host port) and the port inside the
    container that the host port must be mapped to (container port). The container
    port must be the same port that was exposed in the Dockerfile and used to define
    the Docker image.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以访问服务的端口（主机端口）以及主机端口必须映射到的容器内部的端口（容器端口）。容器端口必须是在Dockerfile中公开并用于定义Docker镜像的相同端口。
- en: Afterward, you may need to add further manual configuration to ensure that your
    Docker application works properly. The *Further reading* section contains links
    to the official documentation where you can find more details.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可能需要添加进一步的手动配置，以确保您的Docker应用程序正常工作。*进一步阅读*部分包含指向官方文档的链接，您可以在其中找到更多详细信息。
- en: There are five types of .NET Core native Service Fabric services. The Actor
    service pattern is an opinionated pattern that was conceived several years ago
    by Carl Hewitt. We will not discuss it here, but the *Further reading* section
    contains some links that provide more information on this.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有五种.NET Core本机Service Fabric服务类型。Actor服务模式是由Carl Hewitt几年前构思的一种主观模式。我们不会在这里讨论它，但*进一步阅读*部分包含一些提供更多信息的链接。
- en: The remaining four patterns refer to the usage (or not) of ASP.NET (Core) as
    the main interaction protocol and to the fact that the service has or hasn't got
    an internal state. In fact, Service Fabric allows microservices to use distributed
    queues and dictionaries that are globally accessible to all instances of the microservice
    that declares them, independent of the hardware node where they are running (they
    are serialized and distributed to all available instances when they're needed).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 其余四种模式是指使用（或不使用）ASP.NET（Core）作为主要交互协议，以及服务是否具有内部状态。事实上，Service Fabric允许微服务使用分布式队列和字典，这些队列和字典对于声明它们的微服务的所有实例都是全局可访问的，与它们运行的硬件节点无关（在需要时它们被序列化和分发到所有可用的实例）。
- en: 'Stateful and stateless templates differ mainly in terms of their configuration.
    All native services are classes that specify just two methods. Stateful services
    specify:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态和无状态模板在配置方面主要有所不同。所有本机服务都是指定了两个方法的类。有状态服务指定：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While stateless services specify:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 而无状态服务则需要指定：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `CreateServiceReplicaListeners` and `CreateServiceInstanceListeners` methods
    specify a list of listeners that are used by the microservice to receive messages
    and the code that handles those messages. Listeners may use any protocol, but
    they are required to specify an implementation of the relative socket.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateServiceReplicaListeners`和`CreateServiceInstanceListeners`方法指定了微服务用于接收消息和处理这些消息的代码的监听器列表。监听器可以使用任何协议，但它们需要指定相对套接字的实现。'
- en: '`RunAsync` contains the code for background threads that asynchronously run
    tasks that are triggered by received messages. Here, you can build a host that
    runs several hosted services.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`RunAsync`包含用于异步运行由接收到的消息触发的任务的后台线程的代码。在这里，您可以构建一个运行多个托管服务的主机。'
- en: ASP.NET Core templates follow the same pattern; however, they use a unique ASP.NET
    Core-based listener and no `RunAsync` implementation, since background tasks can
    be launched from inside ASP.NET Core, whose listener defines a complete `WebHost`.
    However, you may add further listeners to the array of listeners returned by the
    `CreateServiceReplicaListeners` implementation created by Visual Studio, and also
    a custom `RunAsync` override.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core模板遵循相同的模式；但是，它们使用基于ASP.NET Core的唯一侦听器和没有`RunAsync`实现，因为可以从ASP.NET
    Core内部启动后台任务，其侦听器定义了一个完整的`WebHost`。但是，您可以将更多侦听器添加到由Visual Studio创建的`CreateServiceReplicaListeners`实现返回的侦听器数组中，还可以添加自定义的`RunAsync`覆盖。
- en: It is worth pointing out that as `RunAsync` is optional, and since the ASP.NET
    Core template doesn't implement it, `CreateServiceReplicaListeners` and `CreateServiceInstanceListeners`
    are also optional, and, for instance, a background worker operating on a timer
    doesn't need to implement any of them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，由于`RunAsync`是可选的，并且由于ASP.NET Core模板没有实现它，因此`CreateServiceReplicaListeners`和`CreateServiceInstanceListeners`也是可选的，例如，基于计时器的后台工作程序不需要实现它们中的任何一个。
- en: More details on Service Fabric's native services pattern will be provided in
    the following section, while a complete code example will be provided in the *Use
    case – Logging microservices* section of this chapter, which is dedicated to this
    book's use case.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Service Fabric的本机服务模式的更多详细信息将在下一节中提供，而本章的*用例-日志记录微服务*部分将提供一个完整的代码示例，专门针对本书的用例。
- en: Defining and configuring your Azure Service Fabric cluster
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和配置Azure Service Fabric集群
- en: Azure Service Fabric is the main Microsoft orchestrator that can host Docker
    containers, native .NET applications, and a distributed computing model called
    **reliable services**. We have already explained how we can create applications
    that contain these three types of services in the *Visual Studio support for Azure
    Service Fabric* section. In this section, we will explain how to create an Azure
    Service Fabric cluster in the Azure portal and provide some more details on reliable
    services. More practical details regarding *reliable services* will be provided
    in the example described in the *Use case – Logging microservices* section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Service Fabric是主要的微软编排器，可以托管Docker容器、本地.NET应用程序和一种名为**可靠服务**的分布式计算模型。我们已经在*Visual
    Studio支持Azure Service Fabric*部分中解释了如何创建包含这三种类型服务的应用程序。在本节中，我们将解释如何在Azure门户中创建Azure
    Service Fabric集群，并提供一些关于可靠服务的详细信息。有关*可靠服务*的更多实际细节将在*用例-日志记录微服务*部分中提供。
- en: You can enter the Service Fabric section of Azure by typing `Service Fabric`
    into the Azure search bar and selecting **Service Fabric Cluster**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在Azure搜索栏中输入`Service Fabric`并选择**Service Fabric Cluster**来进入Azure的Service
    Fabric部分。
- en: A summary page of all of your Service Fabric clusters appears which, in your
    case, should be empty. When you click the **Add** button to create your first
    cluster, a multi-step wizard is shown. The following subsections describe the
    available steps.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了所有Service Fabric集群的摘要页面，对于您的情况，应该是空的。当您点击**添加**按钮创建第一个集群时，将显示一个多步骤向导。以下小节描述了可用的步骤。
- en: Step 1 – Basic information
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步-基本信息
- en: 'The following screenshot shows the creation of Azure Service Fabric:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Azure Service Fabric的创建过程：
- en: '![](img/B16756_06_03.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_06_03.png)'
- en: 'Figure 6.3: Azure Service Fabric creation'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：Azure Service Fabric创建
- en: Here, you can choose the operating system, resource group, subscription, location,
    and username and password that you want to use to connect the remote desktop to
    all the cluster nodes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以选择操作系统、资源组、订阅、位置以及要用于连接远程桌面到所有集群节点的用户名和密码。
- en: You are required to choose a cluster name, which will be used to compose the
    cluster URI as `<cluster name>.<location>.cloudapp.azure.com`, where `location`
    is a name associated with the data center location you have chosen. Let's select
    Windows, since Service Fabric was primarily conceived for Windows. A better choice
    for Linux machines is Kubernetes, which will be described in the next chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要选择一个集群名称，该名称将用于组成集群URI，格式为`<集群名称>.<位置>.cloudapp.azure.com`，其中`位置`是您选择的数据中心位置的名称。由于Service
    Fabric主要是为Windows设计的，所以选择Windows是一个更好的选择。对于Linux机器来说，更好的选择是Kubernetes，这将在下一章中介绍。
- en: Then you are required to select your node type, that is, the kind of virtual
    machine you would like to use for your primary nodes, and the initial scale set,
    that is, the maximum number of virtual machines to use. Please choose a cheap
    node type and no more than three nodes, otherwise you might quickly waste all
    your free Azure credit.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要选择节点类型，即您想要为主节点使用的虚拟机类型，以及初始规模集，即要使用的虚拟机的最大数量。请选择一个廉价的节点类型，最多不超过三个节点，否则您可能很快就会耗尽所有的免费Azure信用额。
- en: More details on node configurations will be given in the next subsection.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有关节点配置的更多详细信息将在下一小节中给出。
- en: Finally, you have the option to select a certificate to secure your node-to-node
    communications. Let's click the **Select a certificate** link, and in the window
    that opens, select the automatic creation of a new key vault and of a new certificate.
    More information on security will be provided in the *Step 3 – Security configuration*
    section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以选择一个证书来保护节点之间的通信。让我们点击**选择证书**链接，在打开的窗口中选择自动创建新密钥保管库和新证书。有关安全性的更多信息将在*第3步-安全配置*部分中提供。
- en: Step 2 – Cluster configuration
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步-集群配置
- en: 'In the second step, you can fine-tune the cluster node type and number:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，您可以对集群节点类型和数量进行微调：
- en: '![](img/B16756_06_04.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_06_04.png)'
- en: 'Figure 6.4: Cluster configuration'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：集群配置
- en: More specifically, in the previous step, we selected the cluster primary node.
    Here, we can choose whether to add various kinds of secondary nodes with their
    scale capacities. Once you have created different node types, you can configure
    services to run only on specific node types whose capabilities are adequate to
    their needs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在上一步中，我们选择了集群的主节点。在这里，我们可以选择是否添加各种类型的辅助节点及其规模容量。一旦您创建了不同的节点类型，您可以配置服务仅在其需求所需的能力足够的特定节点类型上运行。
- en: 'Let''s click the **Add** button to add a new node type:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们点击**添加**按钮来添加一个新的节点类型：
- en: '![](img/B16756_06_05.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_06_05.png)'
- en: 'Figure 6.5: Adding a new node type'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：添加一个新的节点类型
- en: Nodes of a different node type can be scaled independently, and the **primary
    node** type is where Azure Service Fabric runtime services will be hosted. For
    each node type, you can specify the type of machine (**Durability tier**), machine
    dimensions (CPU and RAM), and the initial number of nodes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不同节点类型的节点可以独立进行扩展，**主节点**类型是Azure Service Fabric运行时服务的托管位置。对于每个节点类型，您可以指定机器类型（**耐久性层**）、机器规格（CPU和RAM）和初始节点数。
- en: You can also specify all the ports that will be visible from outside the cluster
    (**Custom endpoints**).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定所有从集群外部可见的端口（**自定义端点**）。
- en: The services that are hosted on the different nodes of a cluster can communicate
    through any port since they are part of the same local network. Therefore, **Custom
    endpoints** must declare the ports that need to accept traffic from outside the
    cluster. The port that are exposed in **Custom endpoints** are the cluster's public
    interface, which can be reached through the cluster URI, that is, `<cluster name>.<location>.cloudapp.azure.com`.
    Their traffic is automatically redirected to all the microservices that have had
    the same ports opened by the cluster load balancer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 托管在集群的不同节点上的服务可以通过任何端口进行通信，因为它们是同一本地网络的一部分。因此，**自定义端点**必须声明需要接受来自集群外部的流量的端口。在**自定义端点**中公开的端口是集群的公共接口，可以通过集群URI（即`<cluster
    name>.<location>.cloudapp.azure.com`）访问。它们的流量会自动重定向到由集群负载均衡器打开相同端口的所有微服务。
- en: To understand the **Enable reverse proxy** option, we must explain how communications
    are sent to several instances of services whose physical addresses change during
    their lifetimes. From within the cluster, services are identified with a URI such
    as `fabric://<application name>/<service name>`. That is, this name allows us
    to access one of the several load-balanced instances of `<service name>`. However,
    these URIs can't be used directly by communication protocols. Instead, they are
    used to get the physical URI of the required resource, along with all its available
    ports and protocols from the Service Fabric naming service.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解**启用反向代理**选项，我们必须解释在服务的物理地址在其生命周期中发生变化时，如何将通信发送到多个实例。在集群内部，服务通过`fabric://<application
    name>/<service name>`这样的URI进行标识。也就是说，这个名称允许我们访问`<service name>`的多个负载均衡实例之一。然而，这些URI不能直接用于通信协议。相反，它们用于从Service
    Fabric命名服务获取所需资源的物理URI，以及其所有可用的端口和协议。
- en: Later, we will learn how to perform this operation with *reliable services*.
    However, this model is not adequate for Dockerized services that weren't conceived
    to run specifically on Azure Service Fabric, since they are not aware of Service
    Fabric-specific naming services and APIs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将学习如何使用*可靠服务*执行此操作。然而，对于没有专门为Azure Service Fabric运行而设计的Docker化服务来说，这个模型是不合适的，因为它们不知道Service
    Fabric特定的命名服务和API。
- en: 'Therefore, Service Fabric provides two more options that we can use to standardize
    URLs instead of interacting directly with its naming service:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Service Fabric提供了另外两个选项，我们可以使用它们来标准化URL，而不是直接与其命名服务交互：
- en: '**DNS**: Each service can specify its `hostname` (also known as its **DNS name**).
    The DNS service takes care of translating it into the actual service URL. For
    example, if a service specifies an `order.processing` DNS name and it has an HTTP
    endpoint on port `80` and a `/purchase` path, we can reach this endpoint with
    `http://order.processing:80/purchase`. By default, the DNS service is active,
    but you can deactivate it either by showing the advanced settings selection in
    the secondary node screen by clicking **Configure advanced settings**, or by going
    to the **Advanced** tab.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DNS**：每个服务可以指定其`hostname`（也称为**DNS名称**）。DNS服务负责将其转换为实际的服务URL。例如，如果一个服务指定了一个`order.processing`的DNS名称，并且它在端口`80`上有一个HTTP端点和一个`/purchase`路径，我们可以使用`http://order.processing:80/purchase`来访问此端点。默认情况下，DNS服务是活动的，但您可以通过在辅助节点屏幕上点击**配置高级设置**来显示高级设置选择，或者转到**高级**选项卡来禁用它。'
- en: '**Reverse proxy**: Service Fabric''s reverse proxy intercepts all the calls
    that have been directed to the cluster address and uses the name service to send
    them to the right application and service within that application. Addresses that
    are resolved by the reverse proxy service have the following structure: `<cluster
    name>.<location>.cloudapp.azure.com: <port>//<app name>/<service name>/<endpoint
    path>?PartitionKey=<value>& PartitionKind=value`. Here, partition keys are used
    to optimize stateful reliable services and will be explained at the end of this
    subsection. This means that stateless services lack the query string part of the
    previous address. Thus, a typical address that''s solved by reverse proxy may
    be something similar to `myCluster.eastus.cloudapp.azure.com: 80//myapp/myservice/<endpoint
    path>?PartitionKey=A & PartitionKind=Named`. If the preceding endpoint is called
    from a service hosted on the same cluster, we can specify `localhost` instead
    of the complete cluster name (that is, from the same cluster, not from the same
    node): `localhost: 80//myapp/myservice/<endpoint path>?PartitionKey=A & PartitionKind=Named`.
    By default, reverse proxy is not enabled.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反向代理**：Service Fabric的反向代理拦截所有被定向到集群地址的调用，并使用名称服务将它们发送到正确的应用程序和该应用程序中的服务。由反向代理服务解析的地址具有以下结构：`<cluster
    name>.<location>.cloudapp.azure.com: <port>//<app name>/<service name>/<endpoint
    path>?PartitionKey=<value>& PartitionKind=value`。在这里，分区键用于优化有状态的可靠服务，并将在本小节末尾进行解释。这意味着无状态服务缺少前一个地址的查询字符串部分。因此，由反向代理解析的典型地址可能类似于`myCluster.eastus.cloudapp.azure.com:
    80//myapp/myservice/<endpoint path>?PartitionKey=A & PartitionKind=Named`。如果从同一集群上托管的服务调用前面的端点，我们可以指定`localhost`而不是完整的集群名称（即从同一集群，而不是从同一节点）：`localhost:
    80//myapp/myservice/<endpoint path>?PartitionKey=A & PartitionKind=Named`。默认情况下，反向代理未启用。'
- en: Since we are going to use Service Fabric reliable services with Service Fabric
    built-in communication facilities, and since these built-in communication facilities
    don't need either reverse proxy or DNS, please avoid changing these settings.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用Service Fabric可靠服务与Service Fabric内置通信设施，并且由于这些内置通信设施不需要反向代理或DNS，请避免更改这些设置。
- en: Moreover, if you are creating the Service Fabric cluster with the sole purpose
    of experimenting with the simple example at the end of the chapter, please stick
    with just the primary nodes and avoid wasting your free Azure credit by creating
    secondary nodes as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您只是为了在本章末尾的简单示例中进行实验而创建Service Fabric集群，请仅使用主节点，并避免通过创建辅助节点来浪费您的免费Azure信用。
- en: Step 3 – Security configuration
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步-安全配置
- en: 'Once the second step is complete, we come to a security page:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第二步后，我们来到一个安全页面：
- en: '![](img/B16756_06_06.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_06_06.png)'
- en: 'Figure 6.6: Security page'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：安全页面
- en: We already defined the main certificate in the first step. Here, you have the
    option to select a secondary certificate to be used when the primary certificate
    is near to its expiration. You can add also a certificate that will be used to
    enable HTTPS communication on reverse proxies. Since, in our example, we will
    not use Dockerized services (so we will not require reverse proxies), we don't
    need this option.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们已经定义了主要的证书。在这里，您可以选择一个次要的证书，在主要证书接近到期时使用。您还可以添加一个证书，用于在反向代理上启用HTTPS通信。由于在我们的示例中，我们不使用Docker化服务（因此不需要反向代理），所以我们不需要这个选项。
- en: 'At this point, we can click the review and create button to create the cluster.
    Submitting your approval will create the cluster. Pay attention to this: a cluster
    may spend your free Azure credit in a short time, so just keep your cluster on
    when you are testing. Afterward, you should delete it.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以点击“审查和创建”按钮来创建集群。提交您的批准将创建集群。请注意：一个集群可能会在短时间内消耗您的免费Azure信用，所以在测试时请保持您的集群开启。之后，您应该删除它。
- en: 'We need to download our primary certificate to our development machine, since
    we need it to deploy our application. Once the certificate has been downloaded,
    it is enough to double-click on it to install it on our machine. Before deploying
    the application, you are required to insert the following information into the
    **Cloud Publish Profile** of your Visual Studio Service Fabric applications (see
    this chapter''s *Use case – Logging microservices* section for more details):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将主要证书下载到开发机器上，因为我们需要它来部署我们的应用程序。一旦证书下载完成，只需双击它即可将其安装在我们的机器上。在部署应用程序之前，您需要将以下信息插入到Visual
    Studio Service Fabric应用程序的**Cloud Publish Profile**中（有关更多详细信息，请参见本章的*用例-日志记录微服务*部分）：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since both the client (Visual Studio) and the server use the same certificate
    for authentication, the server and client thumbprint are the same. The certificate
    thumbprint can be copied from your Azure Key Vault. It is worth mentioning that
    you can also add client-specific certificates to the main server certificate by
    selecting the corresponding option in *step 3*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户端（Visual Studio）和服务器使用相同的证书进行身份验证，因此服务器和客户端的指纹是相同的。证书指纹可以从Azure密钥保管库中复制。值得一提的是，您还可以通过在*第3步*中选择相应的选项来将特定于客户端的证书添加到主服务器证书中。
- en: 'As we mentioned in the *Visual Studio support for Azure Service Fabric* subsection,
    Azure Service Fabric supports two kinds of *reliable service*: stateless and stateful.
    Stateless services either don''t store permanent data or they store it in external
    supports such as the Redis cache or databases (see *Chapter 9*, *How to Choose
    Your Data Storage in the Cloud*, for the main storage options offered by Azure).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*Visual Studio对Azure Service Fabric的支持*小节中提到的，Azure Service Fabric支持两种类型的*可靠服务*：无状态和有状态。无状态服务要么不存储永久数据，要么将其存储在外部支持中，例如Redis缓存或数据库（有关Azure提供的主要存储选项，请参见*第9章*，*如何选择云中的数据存储*）。
- en: Stateful services, on the other hand, use Service Fabric-specific distributed
    dictionaries and queues. Each distributed data structure is accessible from all
    the *identical* replicas of a service, but only one replica, called the primary
    replica, is allowed to write on them to avoid synchronized access to those distributed
    resources, which may cause bottlenecks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有状态服务使用Service Fabric特定的分布式字典和队列。每个分布式数据结构可以从服务的所有*相同*副本中访问，但只允许一个副本，称为主副本，在其上进行写操作，以避免对这些分布式资源的同步访问，这可能会导致瓶颈。
- en: All the other replicas, known as secondary replicas, can only read from these
    distributed data structures.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他副本，即辅助副本，只能从这些分布式数据结构中读取。
- en: You can check if a replica is primary by looking at the context object your
    code receives from the Azure Service Fabric runtime, but usually, you don't need
    to do this. In fact, when you declare your service endpoints, you are required
    to declare those that are read-only. A read-only endpoint is supposed to receive
    requests so that it can read data from the shared data structures. Therefore,
    since only read-only endpoints are activated for secondary replicas, if you implement
    them correctly, write/update operations should automatically be prevented on stateful
    secondary replicas with no need to perform further checks.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看您的代码从Azure Service Fabric运行时接收到的上下文对象来检查副本是否为主副本，但通常情况下，您不需要这样做。实际上，当您声明服务端点时，您需要声明那些只读的端点。只读端点应该接收请求，以便它可以从共享数据结构中读取数据。因此，由于只有只读端点被激活用于辅助副本，如果您正确实现了它们，写/更新操作应该自动在有状态辅助副本上被阻止，无需进行进一步的检查。
- en: In stateful services, secondary replicas enable parallelism on read operations,
    so in order to get parallelism on write/update operations, stateful services are
    assigned different data partitions. More specifically, for each stateful service,
    Service Fabric creates a primary instance for each partition. Then, each partition
    may have several secondary replicas.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在有状态服务中，辅助副本可以在读操作上实现并行处理，因此为了在写/更新操作上实现并行处理，有状态服务被分配了不同的数据分区。具体来说，对于每个有状态服务，Service
    Fabric会为每个分区创建一个主实例。然后，每个分区可能有多个辅助副本。
- en: Distributed data structures are shared between the primary instance of each
    partition and its secondary replicas. The whole extent of data that can be stored
    in a stateful service is split among the chosen number of partitions, according
    to a partition key that is generated by a hashing algorithm on the data to be
    stored.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式数据结构在每个分区的主实例和其辅助副本之间共享。可以根据对要存储的数据进行哈希算法生成的分区键将有状态服务中可以存储的全部数据范围划分为所选的分区数。
- en: Typically, partition keys are integers that belong to a given interval that
    is split among all the available partitions. For instance, a partition key can
    be generated by calling a well-known hashing algorithm on one or more string fields
    to get integers that are then processed to get a unique integer (using, for instance,
    an exclusive OR operation on the integer bits). Then, this integer can be constrained
    to the integer interval that was chosen for the partition key by taking the remainder
    of an integer division (for instance, the remainder of a division for 1,000 will
    be an integer in the 0-999 interval). It is important to be sure that all services
    use exactly the same hashing algorithm, so the better solution is to provide a
    common hashing library to all of them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，分区键是属于给定间隔的整数，该间隔在所有可用分区之间进行划分。例如，可以通过调用一个众所周知的哈希算法对一个或多个字符串字段进行哈希运算来生成分区键，以获得然后处理为唯一整数的整数（例如，对整数位进行异或运算）。然后，可以通过取整数除法的余数来限制该整数在选择的分区键的整数间隔中（例如，除以1,000的余数将是0-999间隔中的整数）。确保所有服务使用完全相同的哈希算法非常重要，因此更好的解决方案是为所有服务提供一个公共的哈希库。
- en: 'Let''s say we want four partitions, which will be selected with an integer
    key in the 0-999 interval. Here, Service Fabric will automatically create four
    primary instances of our stateful service and assign them the following four partition
    key subintervals: 0-249, 250-499, 500-749, and 750-999.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要四个分区，这些分区将在0-999的整数键中进行选择。在这里，Service Fabric将自动创建我们有状态服务的四个主实例，并将它们分配给以下四个分区键子区间：0-249，250-499，500-749和750-999。
- en: From within your code, you are required to compute the partition key of the
    data you send to a stateful service. Then, Service Fabric's runtime will select
    the right primary instance for you. The following section provides more practical
    details on this and how to use reliable services in practice.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，您需要计算发送到有状态服务的数据的分区键。然后，Service Fabric的运行时将为您选择正确的主实例。下面的部分将提供更多关于此的实际细节以及如何在实践中使用可靠服务。
- en: Use case – Logging microservices
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 日志微服务
- en: In this section, we will look at a microservice-based system that logs data
    about purchases relating to various destinations in our WWTravelClub use case.
    In particular, we will design microservices that take care of computing daily
    revenues per location. Here, we're assuming that these microservices receive data
    from other subsystems hosted in the same Azure Service Fabric application. More
    specifically, each purchase log message is composed of the location name, the
    overall package cost, and the date and time of the purchase.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一个基于微服务的系统，该系统记录与我们的WWTravelClub用例中的各个目的地相关的购买数据。特别是，我们将设计微服务来计算每个位置的每日收入。在这里，我们假设这些微服务从同一Azure
    Service Fabric应用程序中托管的其他子系统接收数据。具体来说，每个购买日志消息由位置名称、总体套餐费用以及购买日期和时间组成。
- en: 'As a first step, let''s ensure that the Service Fabric emulator that we mentioned
    in the *Technical requirements* section of this chapter has been installed and
    is running on your development machine. Now, we need to switch it so that it runs
    **5 nodes**: right-click on the small Service Fabric cluster icon you have in
    your Windows notification area, and, in the context menu that opens, select **Switch
    Cluster Mode** -> **5 nodes**.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确保我们在本章*技术要求*部分提到的Service Fabric模拟器已经安装并在您的开发机器上运行。现在，我们需要将其切换，以便它运行**5个节点**：右键单击您在Windows通知区域中拥有的小Service
    Fabric集群图标，在打开的上下文菜单中，选择**切换集群模式** -> **5个节点**。
- en: Now, we can follow the steps set out in the *Visual Studio support for Azure
    Service Fabric* section to create a Service Fabric project named `PurchaseLogging`.
    Select a .NET Core stateful reliable service and name it `LogStore`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按照*Visual Studio对Azure Service Fabric的支持*部分中列出的步骤来创建一个名为`PurchaseLogging`的Service
    Fabric项目。选择一个.NET Core有状态可靠服务，并将其命名为`LogStore`。
- en: The solution that's created by Visual Studio is composed of a `PurchaseLogging`
    project, which represents the overall application, and a `LogStore` project, which
    will contain the implementation of the first microservice that's included in the
    `PurchaseLogging` application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由Visual Studio创建的解决方案由一个代表整体应用程序的`PurchaseLogging`项目和一个包含在`PurchaseLogging`应用程序中的第一个微服务的实现的`LogStore`项目组成。
- en: 'Under the `PackageRoot` folder, the `LogStore` service and each reliable service
    contain the `ServiceManifest.xml` configuration file and a `Settings.xml` folder
    (under the `Config` subfolder). The `Settings.xml` folder contains some settings
    that will be read from the service code. The initial file contains predefined
    settings that are needed by the Service Fabric runtime. Let''s add a new `Settings`
    section, as shown in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PackageRoot`文件夹下，`LogStore`服务和每个可靠服务都包含`ServiceManifest.xml`配置文件和一个`Settings.xml`文件夹（在`Config`子文件夹下）。`Settings.xml`文件夹包含一些将从服务代码中读取的设置。初始文件包含了Service
    Fabric运行时所需的预定义设置。让我们添加一个新的`Settings`部分，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will use the value of `MessageMaxDelaySeconds` to configure the system component
    and ensure message idempotency. The setting value is empty because most of the
    settings are overridden when the services are deployed by the overall application
    settings contained in the `PurchaseLogging` project.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`MessageMaxDelaySeconds`的值来配置系统组件，并确保消息的幂等性。设置值为空，因为大多数设置在服务部署时会被`PurchaseLogging`项目中包含的整体应用程序设置所覆盖。
- en: 'The `ServiceManifest.xml` file contains a number of configuration tags that
    are automatically handled by Visual Studio, as well as a list of endpoints. Two
    endpoints are preconfigured since they are used by the Service Fabric runtime.
    Here, we must add the configuration details of all the endpoints our microservice
    will listen to. Each endpoint definition has the following format:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceManifest.xml`文件包含了一些由Visual Studio自动处理的配置标签，以及一些端点的列表。由于这些端点被Service
    Fabric运行时使用，因此有两个端点是预配置的。在这里，我们必须添加我们的微服务将监听的所有端点的配置细节。每个端点定义的格式如下：'
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If `Type` is `Internal`, the port will be opened just inside the cluster's local
    network; otherwise, the port will be available from outside the cluster as well.
    In the preceding case, we must declare that port in the configuration of the Azure
    Service Fabric cluster as well, otherwise the cluster load balancer/firewall will
    not forward messages to it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Type`是`Internal`，则端口将仅在集群的本地网络中打开；否则，端口也将从集群外部可用。在前一种情况下，我们还必须在Azure Service
    Fabric集群的配置中声明该端口，否则集群负载均衡器/防火墙将无法将消息转发到该端口。
- en: Public ports can be reached directly from the cluster URI (`<cluster name>.<location
    code>.cloudapp.azure.com`) since the load balancer that interfaces each cluster
    will forward the input traffic it receives to them.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 公共端口可以直接从集群URI(`<cluster name>.<location code>.cloudapp.azure.com`)到达，因为每个集群的负载均衡器将把接收到的输入流量转发到它们。
- en: In this example, we won't define endpoints since we are going to use the predefined
    remoting-based communication, but we will show you how to use them later on in
    this section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不会定义端点，因为我们将使用预定义的基于远程通信，但我们将在本节的后面向您展示如何使用它们。
- en: 'The `PurchaseLogging` project contains a reference to the `LogStore` project
    under the *services* Solution Explorer node and contains various folders with
    various XML configuration files. More specifically, we have the following folders:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`PurchaseLogging`项目在*services*解决方案资源管理器节点下包含对`LogStore`项目的引用，并包含各种包含各种XML配置文件的文件夹。具体来说，我们有以下文件夹：'
- en: '`ApplicationPackageRoot`, which contains the overall application manifest named
    `ApplicationManifest.xml`. This file contains some initial parameter definitions
    and then further configurations. Parameters have the following format:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationPackageRoot`包含名为`ApplicationManifest.xml`的整体应用程序清单。该文件包含一些初始参数定义，然后进行进一步的配置。参数的格式如下：'
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once defined, parameters can replace any value in the remainder of the file.
    Parameter values are referenced by enclosing the parameter name between square
    brackets, as shown in the following code:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦定义，参数可以替换文件的其余部分中的任何值。参数值通过将参数名称括在方括号中来引用，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some parameters define the number of replicas and partitions for each service
    and are automatically created by Visual Studio. Let''s replace these initial values
    suggested by Visual Studio with those in the following code snippet:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一些参数定义了每个服务的副本和分区的数量，并且由Visual Studio自动创建。让我们用以下代码片段中的值替换Visual Studio建议的这些初始值：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will use just two partitions to show you how partitions work, but you can
    increase this value to improve write/update parallelism. Each partition of the
    `LogStore` service doesn't need several replicas, since replicas improve performance
    on read operations and this service is not designed to offer read services. In
    similar situations, you may choose two to three replicas to make the system redundant
    and more robust to failures. However, we've left one since, as this is just an
    example, we are not concerned with failures.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个分区来展示分区是如何工作的，但您可以增加此值以提高写入/更新并行性。`LogStore`服务的每个分区不需要多个副本，因为副本可以提高读取操作的性能，而此服务并非设计为提供读取服务。在类似情况下，您可以选择两到三个副本，使系统具有冗余性并更加健壮。但是，由于这只是一个示例，我们不关心故障，所以我们只留下一个。
- en: 'The preceding parameters are used to define the role of the `LogStore` service
    inside the overall application. This definition is generated automatically by
    Visual Studio in the same file, below the initial definition created by Visual
    Studio, with just the partition interval changed to 0-1,000:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前述参数用于定义整个应用程序中`LogStore`服务的角色。此定义是由Visual Studio在同一文件中自动生成的，位于Visual Studio创建的初始定义下方，只是分区间隔更改为0-1,000：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`ApplicationParameters` contains possible overrides for parameters defined
    in `ApplicationManifest.xml` for various deployment environments: the cloud (that
    is, the actual Azure Service Fabric cluster) and local emulators with one or five
    nodes.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationParameters`包含在各种部署环境（即实际的Azure Service Fabric集群和具有一个或五个节点的本地仿真器）中为`ApplicationManifest.xml`中定义的参数提供可能的覆盖。'
- en: '`PublishProfiles` contains the settings that are needed to publish the application
    in the same environments handled by the `ApplicationParameters` folder. You just
    need to customize the cloud publish profile with the actual name of your Azure
    Service Fabric URI and with the authentication certificate you downloaded during
    the Azure cluster configuration process:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublishProfiles`包含发布应用程序所需的设置，这些设置与`ApplicationParameters`文件夹处理的相同环境相关。您只需要使用实际的Azure
    Service Fabric URI名称和在Azure集群配置过程中下载的身份验证证书来自定义云发布配置文件：'
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The remaining steps that need to be followed in order to complete the application
    have been organized into several subsections. Let's start by looking at ensuring
    message idempotency.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 需要遵循的其余步骤已经组织成几个子部分。让我们首先看看如何确保消息的幂等性。
- en: Ensuring message idempotency
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保消息的幂等性
- en: Messages can become lost because of failures or small timeouts caused by load
    balancing. Here, we will use a predefined remoting-based communication that performs
    automatic message retries in the event of failures. However, this may cause the
    same messages to be received twice. Since we are summing up the revenues of purchase
    orders, we must protect ourselves from summing up the same purchase several times.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于故障或负载平衡引起的小超时，消息可能会丢失。在这里，我们将使用预定义的基于远程通信的通信，以在发生故障时执行自动消息重试。但是，这可能导致相同的消息被接收两次。由于我们正在对采购订单的收入进行汇总，因此必须防止多次对同一采购进行汇总。
- en: To do this, we will implement a library containing the necessary tools to ensure
    that message replicas are discarded.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将实现一个包含必要工具的库，以确保消息副本被丢弃。
- en: Let's add a new .NET Standard 2.0 library project called **IdempotencyTools**
    to our solution. Now, we can remove the initial class scaffolded by Visual Studio.
    This library needs a reference to the same version of the `Microsoft.ServiceFabric.Services`
    NuGet package referenced by `LogStore`, so let's verify the version number and
    add the same NuGet package reference to the `IdempotencyTools` project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向解决方案添加一个名为**IdempotencyTools**的新的.NET Standard 2.0库项目。现在，我们可以删除Visual Studio生成的初始类。该库需要引用与`LogStore`引用的`Microsoft.ServiceFabric.Services`
    NuGet包相同版本，因此让我们验证版本号并将相同的NuGet包引用添加到`IdempotencyTools`项目中。
- en: 'The main tool that ensures message idempotency is the `IdempotentMessage` class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 确保消息幂等性的主要工具是`IdempotentMessage`类：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We added the `DataContract` and `DataMember` attributes since they are needed
    by the remoting communication serializer we are going to use for all internal
    messages. Basically, the preceding class is a wrapper that adds a `Guid` and a
    time mark to the message class instance that's passed to its constructor.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`DataContract`和`DataMember`属性，因为它们是我们将用于所有内部消息的远程通信序列化器所需的。基本上，前述类是一个包装器，它向传递给其构造函数的消息类实例添加了`Guid`和时间标记。
- en: The `IdempotencyFilter` class uses a distributed dictionary to keep track of
    the messages it has already received. To avoid the indefinite growth of this dictionary,
    older entries are periodically deleted. Messages that are too old to be found
    in the dictionary are automatically discarded.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`IdempotencyFilter`类使用分布式字典来跟踪它已经收到的消息。为了避免这个字典的无限增长，较旧的条目会定期删除。在字典中找不到的太旧的消息会自动丢弃。'
- en: 'The time interval entries are kept in the dictionary and are passed in the
    `IdempotencyFilter` static factory method, which creates new filter instances,
    along with the dictionary name and the `IReliableStateManager` instance, which
    are needed to create the distributed dictionary:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 时间间隔条目保存在字典中，并在`IdempotencyFilter`静态工厂方法中传递，该方法创建新的过滤器实例，以及字典名称和`IReliableStateManager`实例，这些都是创建分布式字典所需的：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The dictionary contains each message time mark indexed by the message `Guid`
    and is created by invoking the `GetOrAddAsync` method of the `IReliableStateManager`
    instance with the dictionary type and name. `lastClear` contains the time of the
    removal of all old messages.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 字典包含每条消息的时间标记，由消息`Guid`索引，并通过调用`IReliableStateManager`实例的`GetOrAddAsync`方法以字典类型和名称创建。`lastClear`包含删除所有旧消息的时间。
- en: 'When a new message arrives, the `NewMessage` method checks whether it must
    be discarded. If the message must be discarded, it returns `null`; otherwise,
    it adds the new message to the dictionary and returns the message without the
    `IdempotentMessage` wrapper:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当新消息到达时，`NewMessage`方法会检查是否必须丢弃该消息。如果必须丢弃消息，则返回`null`；否则，将新消息添加到字典中，并返回不带`IdempotentMessage`包装的消息：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As a first step, the method verifies whether it''s time to clear the dictionary
    and whether the message is too old. Then, it starts a transaction to access the
    dictionary. All distributed dictionary operations must be enclosed in a transaction,
    as shown in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，该方法验证是否是清除字典的时间以及消息是否太旧。然后，它启动事务以访问字典。所有分布式字典操作都必须包含在事务中，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the message `Guid` is found in the dictionary, the transaction is aborted
    since the dictionary doesn't need to be updated and the method returns `default(T)`,
    which is actually `null` since the message must not be processed. Otherwise, the
    message entry is added to the dictionary and the unwrapped message is returned.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在字典中找到消息`Guid`，则事务将被中止，因为不需要更新字典，并且该方法返回`default(T)`，实际上是`null`，因为不必处理消息。否则，将消息条目添加到字典中，并返回未包装的消息。
- en: The code of the `Clear` method can be found in the GitHub repository associated
    with this book.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clear`方法的代码可以在与本书关联的GitHub存储库中找到。'
- en: The Interaction library
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互库
- en: There are some types that must be shared among all microservices. If the internal
    communication is implemented with either remoting or WCF, each microservice must
    expose an interface with all the methods other microservices call. Such interfaces
    must be shared among all microservices. Moreover, with all communication interfaces,
    the classes that implement the messages must also be shared among all microservices
    (or among some subsets of them). Therefore, all of these structures are declared
    in external libraries that are referenced by the microservices.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些类型必须在所有微服务之间共享。如果内部通信是使用远程调用或WCF实现的，每个微服务必须公开一个接口，其中包含其他微服务调用的所有方法。这些接口必须在所有微服务之间共享。此外，对于所有通信接口，实现消息的类也必须在所有微服务之间共享（或在它们的一些子集之间共享）。因此，所有这些结构都在外部库中声明，并由微服务引用。
- en: Now, let's add a new .NET Standard 2.0 library project called `Interactions`
    to our solution. Since this library must use the `IdempotentMessage` generic class,
    we must add it as a reference to the `IdempotencyTools` project. We must also
    add a reference to the remoting communication library contained in the `Microsoft.ServiceFabric.Services.Remoting`
    NuGet package, since all interfaces that are used to expose the microservice's
    remote methods must inherit from the `IService` interface defined in this package.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向我们的解决方案添加一个名为`Interactions`的新的.NET Standard 2.0库项目。由于此库必须使用`IdempotentMessage`泛型类，因此我们必须将其添加为对`IdempotencyTools`项目的引用。我们还必须添加对包含在`Microsoft.ServiceFabric.Services.Remoting`
    NuGet包中的远程通信库的引用，因为用于公开微服务远程方法的所有接口必须继承自此包中定义的`IService`接口。
- en: '`IService` is an empty interface that declares the communication role of the
    inheriting interface. The `Microsoft.ServiceFabric.Services.Remoting` NuGet package
    version must match the version of the `Microsoft.ServiceFabric.Services` package
    declared in the other projects.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`IService`是一个空接口，声明了继承接口的通信角色。`Microsoft.ServiceFabric.Services.Remoting` NuGet包的版本必须与其他项目中声明的`Microsoft.ServiceFabric.Services`包的版本匹配。'
- en: 'The following code shows the declarations of the interface that need to be
    implemented by the `LogStore` class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了需要由`LogStore`类实现的接口声明：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the code of the `PurchaseInfo` message class, which is referenced
    in the `ILogStore` interface:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`PurchaseInfo`消息类的代码，该类在`ILogStore`接口中被引用：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we are ready to implement our main `LogStore` microservice.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备实现我们的主要`LogStore`微服务。
- en: Implementing the receiving side of communications
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现通信接收端
- en: To implement the `LogStore` microservice, we must add a reference to the `Interaction`
    library, which will automatically create references to the remoting library and
    to the `IdempotencyTools` project.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`LogStore`微服务，我们必须添加对`Interaction`库的引用，该库将自动创建对远程库和`IdempotencyTools`项目的引用。
- en: 'Then, the `LogStore` class must implement the `ILogStore` interface:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`LogStore`类必须实现`ILogStore`接口：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once the service receives a `LogPurchase` call from the remoting runtime, it
    puts the message in the `LogQueue` to avoid the caller remaining blocked, waiting
    for message processing completion. This way, we achieve both the reliability of
    a synchronous message passing protocol (the caller knows that the message has
    been received) and the performance advantages of asynchronous message processing
    that are typical of asynchronous communication.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务从远程运行时接收到`LogPurchase`调用，它将消息放入`LogQueue`中，以避免调用者保持阻塞，等待消息处理完成。通过这种方式，我们既实现了同步消息传递协议的可靠性（调用者知道消息已被接收），又实现了异步消息处理的性能优势，这是异步通信的典型特点。
- en: '`LoqQueue`, as a best practice for all distributed collections, is created
    in the `RunAsync` method, so `LogQueue` may be null if the first call arrives
    before the Azure Service Fabric runtime has called `RunAsync`. In this event,
    the method returns `false` to signal that the service isn''t ready yet, in which
    case the sender will wait a little and will then resend the message. Otherwise,
    a transaction is created to enqueue the new message.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为所有分布式集合的最佳实践，`LoqQueue`在`RunAsync`方法中创建，因此如果第一个调用在Azure Service Fabric运行时调用`RunAsync`之前到达，则`LogQueue`可能为空。在这种情况下，该方法返回`false`以表示服务尚未准备好，发送方将稍等一会然后重新发送消息。否则，将创建事务以将新消息加入队列。
- en: 'However, our service will not receive any communication if we don''t furnish
    an implementation of `CreateServiceReplicaListeners()` that returns all the listeners
    that the service would like to activate. In the case of remoting communications,
    there is a predefined method that performs the whole job, so we just need to call
    it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们不提供一个返回服务想要激活的所有监听器的`CreateServiceReplicaListeners()`的实现，我们的服务将不会接收任何通信。在远程通信的情况下，有一个预定义的方法来执行整个工作，所以我们只需要调用它：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `CreateServiceRemotingReplicaListeners` is an extension method defined
    in the remoting communication library. It creates listeners for both primary replicas
    and secondary replicas (for read-only operations). When creating the client, we
    can specify whether its communications are addressed just to primary replicas
    or to secondary replicas as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CreateServiceRemotingReplicaListeners`是在远程通信库中定义的扩展方法。它为主副本和辅助副本（用于只读操作）创建监听器。在创建客户端时，我们可以指定它的通信是针对主副本还是辅助副本。
- en: 'If you would like to use different listeners, you must create an `IEnumerable`
    of `ServiceReplicaListener` instances. For each listener, you must invoke the
    `ServiceReplicaListener` constructor with three arguments:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用不同的监听器，您必须创建`ServiceReplicaListener`实例的`IEnumerable`。对于每个监听器，您必须使用三个参数调用`ServiceReplicaListener`构造函数：
- en: A function that receives the reliable service context object as its input and
    returns an implementation of the `ICommunicationListener` interface.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接收可靠服务上下文对象作为输入并返回`ICommunicationListener`接口实现的函数。
- en: The name of the listener. This second argument becomes obligatory when the service
    has more than one listener.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听器的名称。当服务有多个监听器时，这第二个参数就变得必须。
- en: A Boolean that is true if the listener must be activated on secondary replicas.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值，如果监听器必须在辅助副本上激活，则为true。
- en: 'For instance, if we would like to add both custom and HTTP listeners, the code
    becomes something like the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要添加自定义和HTTP监听器，代码就会变成以下的样子：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`MyCustomHttpListener` is a custom implementation of `ICommunicationListener`,
    while `KestrelCommunicationListener` is a predefined HTTP listener based on Kestrel
    and ASP.NET Core. The following is the full code that defines the `KestrelCommunicationListener`
    listener:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyCustomHttpListener`是`ICommunicationListener`的自定义实现，而`KestrelCommunicationListener`是基于Kestrel和ASP.NET
    Core的预定义HTTP监听器。以下是定义`KestrelCommunicationListener`监听器的完整代码：'
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`ICommunicationListener` implementations must also have a `Close` method, which
    must close the opened communication channel, and an `Abort` method, which must
    **immediately** close the communication channel (ungracefully, that is, without
    informing connected clients and so on).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICommunicationListener`的实现也必须有一个`Close`方法，它必须关闭已打开的通信通道，以及一个`Abort`方法，它必须**立即**关闭通信通道（不优雅地，也就是说，不通知连接的客户端等）。'
- en: Now that we have turned communications on, we can implement the service logic.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经打开了通信，我们可以实现服务逻辑。
- en: Implementing service logic
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现服务逻辑
- en: Service logic is executed by the tasks that are launched as independent threads
    when `RunAsync` is invoked by the Service Fabric runtime. It's good practice to
    create an `IHost` and design all the tasks as `IHostedService` implementations
    also when you only need to implement one task. In fact, `IHostedService` implementations
    are independent chunks of software that are easier to unit test. `IHost` and `IHostedService`
    were discussed in detail in the *Using generic hosts* subsection of *Chapter 5*,
    *Applying a Microservice Architecture to Your Enterprise Application*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 服务逻辑由在`RunAsync`被Service Fabric运行时启动的独立线程执行。当您只需要实现一个任务时，创建`IHost`并将所有任务设计为`IHostedService`实现是一个好的做法。事实上，`IHostedService`实现是独立的软件块，更容易进行单元测试。`IHost`和`IHostedService`在*使用通用主机*的*第5章*的*将微服务架构应用于企业应用程序*的子章节中有详细讨论。
- en: 'In this section, we will implement the logic that computes daily revenues for
    each location in an `IHostedservice` named `ComputeStatistics`, which uses a distributed
    dictionary whose keys are the location names and whose values are instances of
    a class called `RunningTotal`. This class stores the current running total and
    the day that is being computed:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现计算每个位置的日收入的逻辑，这个逻辑位于名为`ComputeStatistics`的`IHostedservice`中，它使用一个分布式字典，其键是位置名称，值是一个名为`RunningTotal`的类的实例。这个类存储当前的运行总数和正在计算的日期：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This class has an `Update` method that updates the instance when a new purchase
    message is received. First of all, the incoming message time is normalized to
    universal time. Then, the day part of this time is extracted and compared with
    the current `Day` of the running total, as shown in the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个`Update`方法，当接收到新的购买消息时更新实例。首先，传入消息的时间被标准化为世界标准时间。然后，这个时间的日期部分被提取出来，并与运行总数的当前`Day`进行比较，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If it''s a new day, we assume that the running total computation of the previous
    day has finished, so the `Update` method returns it in a new `RunningTotal` instance
    and resets `Day` and `Count` so that it can compute the running total for the
    new day. Otherwise, the new value is added to the running `Count` and the method
    returns `null`, meaning that the day total isn''t ready yet. This implementation
    can be seen in the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是新的一天，我们假设前一天的运行总数计算已经完成，所以`Update`方法将它返回到一个新的`RunningTotal`实例中，并重置`Day`和`Count`，以便它可以计算新一天的运行总数。否则，新值将被添加到运行的`Count`中，并且该方法返回`null`，表示当天的总数还没有准备好。这个实现可以在下面的代码中看到：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `IHostedService` implementation of `ComputeStatistics` requires some parameters
    in order to work properly, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComputeStatistics`的`IHostedService`实现需要一些参数才能正常工作，如下所示：'
- en: The queue containing all the incoming messages
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含所有传入消息的队列
- en: The `IReliableStateManager` service, so that it can create the distributed dictionary
    where it stores data
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IReliableStateManager`服务，这样它就可以创建分布式字典来存储数据'
- en: The `ConfigurationPackage` service, so that it can read the settings defined
    in the `Settings.xml` service file and possibly those overridden in the application
    manifest
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigurationPackage`服务，以便它可以读取在`Settings.xml`服务文件中定义的设置，以及可能在应用程序清单中被覆盖的设置'
- en: 'The preceding parameters must be passed in the `ComputeStatistics` constructor
    when a `ComputeStatistics` instance is created by `IHost` through dependency injection.
    We will return to the `IHost` definition in the next subsection. For now, let''s
    concentrate on the `ComputeStatistics` constructor and its fields:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过依赖注入由`IHost`创建`ComputeStatistics`实例时，必须将前面的参数传递给`ComputeStatistics`构造函数。我们将在下一小节中回到`IHost`的定义。现在，让我们专注于`ComputeStatistics`构造函数及其字段：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'All the constructor parameters are stored in private fields so that they can
    be used when `ExecuteAsync` is called:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所有构造函数参数都存储在私有字段中，以便在调用`ExecuteAsync`时可以使用它们：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Before entering its loop, the `ComputeStatistics` service prepares some structures
    and parameters. It declares that the queue isn''t empty, meaning it can start
    dequeuing messages. Then, it extracts `MessageMaxDelaySeconds` from the service
    settings and turns it into an integer. The value of this parameter was left empty
    in the `Settings.xml` file. Now, it''s time to override it and define its actual
    value in `ApplicationManifest.xml`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入循环之前，`ComputeStatistics`服务准备一些结构和参数。它声明队列不为空，意味着可以开始出队消息。然后，它从服务设置中提取`MessageMaxDelaySeconds`并将其转换为整数。这个参数的值在`Settings.xml`文件中为空。现在，是时候覆盖它并在`ApplicationManifest.xml`中定义其实际值了：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`ServiceManifestImport` imports the service manifest in the application and
    overrides some configuration. Its version number must be changed every time its
    content and/or the service definition is changed and the application is redeployed
    in Azure because version number changes tell the Service Fabric runtime what to
    change in the cluster. Version numbers also appear in other configuration settings.
    They must be changed every time the entities they refer to change.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceManifestImport`将服务清单导入应用程序并覆盖一些配置。每当更改其内容和/或服务定义并重新部署到Azure时，必须更改其版本号，因为版本号更改告诉Service
    Fabric运行时在群集中要更改什么。版本号还出现在其他配置设置中。每当它们所引用的实体发生更改时，必须更改它们。'
- en: '`MessageMaxDelaySeconds` is passed to the instance of the idempotency filter,
    along with a name for the dictionary of the already received messages, and with
    the instance of the `IReliableStateManager` service. Finally, the main distributed
    dictionary that''s used to store running totals is created.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageMaxDelaySeconds`与已接收消息的字典的名称以及`IReliableStateManager`服务的实例一起传递给幂等性过滤器的实例。最后，创建用于存储累计总数的主分布式字典。'
- en: 'After this, the service enters its loop and finishes when `stoppingToken` is
    signaled, that is, when the Service Fabric runtime signals that the service is
    going to be stopped:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，服务进入循环，并在`stoppingToken`被标记时结束，即当Service Fabric运行时发出信号表示服务将被停止时：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The inner loop runs until the queue becomes empty and then exits and waits 100
    milliseconds before verifying whether new messages have been enqueued.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 内部循环运行直到队列变为空，然后退出并等待100毫秒，然后验证是否有新的消息被入队。
- en: 'The following is the code for the inner loop, which is enclosed in a transaction:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是封装在事务中的内部循环的代码：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, the service is trying to dequeue a message. If the queue is empty, it
    sets `queueEmpty` to `true` to exit the loop; otherwise, it passes the message
    through the idempotency filter. If the message survives this step, it uses it
    to update the running total of the location referenced in the message. However,
    correct operation of the distributed dictionary requires that the old counter
    is replaced with a new counter each time an entry is updated. Accordingly, the
    old counter is copied into a new `RunningTotal` object. This new object can be
    updated with the new data if we call the `Update` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，服务尝试出队一条消息。如果队列为空，则将`queueEmpty`设置为`true`以退出循环；否则，它通过幂等性过滤器传递消息。如果消息在此步骤中幸存下来，它将使用它来更新消息中引用的位置的累计总数。然而，分布式字典的正确操作要求每次更新条目时将旧计数器替换为新计数器。因此，将旧计数器复制到新的`RunningTotal`对象中。如果调用`Update`方法，可以使用新数据更新此新对象：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, the transaction is committed, as shown in the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，事务被提交，如下所示：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When the `Update` method returns a complete computation result, that is, when
    `total != null`, the following method is called:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Update`方法返回完整的计算结果时，即`total != null`时，将调用以下方法：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `SendTotal` method sends the total to a service that publicly exposes all
    the statistics through an HTTP endpoint. After reading *Chapter 14*, *Applying
    Service-Oriented Architectures with .NET Core*, which is dedicated to the Web
    API, you may want to implement a similar service with a stateless ASP.NET Core
    microservice connected to a database. The stateless ASP.NET Core service template
    automatically creates an ASP.NET Core-based HTTP endpoint for you.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendTotal`方法将总数发送到一个通过HTTP端点公开所有统计信息的服务。在阅读了专门介绍Web API的*第14章*《使用.NET Core应用服务导向架构》之后，您可能希望使用连接到数据库的无状态ASP.NET
    Core微服务实现类似的服务。无状态ASP.NET Core服务模板会自动为您创建一个基于ASP.NET Core的HTTP端点。'
- en: However, since this service must receive data from the `SendTotal` method, it
    also needs remote-based endpoints. Therefore, we must create them, just as we
    did for the `LogStore` microservice, and concatenate the remote-based endpoint
    array with the pre-existing array containing the HTTP endpoint.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于该服务必须从`SendTotal`方法接收数据，它还需要基于远程的端点。因此，我们必须创建它们，就像我们为`LogStore`微服务所做的那样，并将基于远程的端点数组与包含HTTP端点的预先存在的数组连接起来。
- en: Defining the microservice's host
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义微服务的主机
- en: 'Now we have everything in place to define the microservice''s `RunAsync` method:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好定义微服务的`RunAsync`方法了：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the service queue is created, and the service settings are saved in `configurationPackage`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了服务队列，并将服务设置保存在`configurationPackage`中。
- en: 'After that, we can create the `IHost` service, as we explained in the *Using
    generic hosts* subsection of *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以创建`IHost`服务，就像我们在*第5章*的*将微服务架构应用于企业应用程序*的*使用通用主机*子部分中所解释的那样：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`ConfigureServices` defines all singleton instances that are needed by `IHostedService`
    implementations, so they are injected into the constructor of all the implementations
    that reference their types. Then, `AddHostedService` declares the unique `IHostedService`
    of the microservice. Once the `IHost` is built, we run it until the `RunAsync`
    cancellation token is signaled. When the cancellation token is signaled, the request
    to shut down is passed to all `IHostedService` implementations.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigureServices`定义了所有`IHostedService`实现所需的所有单例实例，因此它们被注入到引用其类型的所有实现的构造函数中。然后，`AddHostedService`声明了微服务的唯一`IHostedService`。一旦构建了`IHost`，我们就运行它，直到`RunAsync`取消令牌被标记。当取消令牌被标记时，关闭请求被传递给所有`IHostedService`实现。'
- en: Communicating with the service
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与服务通信
- en: Since we haven't implemented the whole purchase logic yet, we will implement
    a stateless microservice that sends random data to the `LogStore` service. Right-click
    on the `PurchaseLogging` project in the **Solution Explorer** and select **Add**
    | **Service Fabric Service**. Then, select the .NET Core stateless template and
    name the new microservice project `FakeSource`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未实现整个购买逻辑，我们将实现一个无状态的微服务，向`LogStore`服务发送随机数据。右键单击**Solution Explorer**中的`PurchaseLogging`项目，然后选择**Add**
    | **Service Fabric Service**。然后，选择.NET Core无状态模板，并将新的微服务项目命名为`FakeSource`。
- en: 'Now, let''s add a reference to the `Interaction` project. Before moving on
    to the service code, we need to update the replica count of the newly created
    service in `ApplicationManifest.xml` as well as in all the other environment-specific
    parameter overrides (the cloud, one local cluster node, five local cluster nodes):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加对`Interaction`项目的引用。在转到服务代码之前，我们需要在`ApplicationManifest.xml`中更新新创建的服务的副本计数，以及所有其他环境特定参数覆盖（云端，一个本地集群节点，五个本地集群节点）：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This fake service needs no listeners and its `RunAsync` method is straightforward:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个虚假服务不需要侦听器，它的`RunAsync`方法很简单：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In each loop, a random message is created and sent to the counting microservices.
    Then, the thread sleeps for a second and starts a new loop. The code that sends
    the created messages is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个循环中，创建一个随机消息并发送到计数微服务。然后，线程休眠一秒钟并开始新的循环。发送创建的消息的代码如下：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, a key in the 0-9,999 interval is computed from the location string. We
    used `GetHashCode` since we are sure that all involved services use the same .NET
    Core version and accordingly we are sure they use the same `GetHashCode` implementation
    that computes the hash in exactly the same way. However, in general, it is better
    to provide a library with a standard hash code implementation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，从位置字符串计算出0-9,999区间内的一个密钥。我们使用`GetHashCode`，因为我们确信所有涉及的服务都使用相同的.NET Core版本，因此我们确信它们使用相同的`GetHashCode`实现，以完全相同的方式计算哈希。然而，一般来说，最好提供一个具有标准哈希码实现的库。
- en: This integer is passed to the `ServicePartitionKey` constructor. Then, a service
    proxy is created, and the URI of the service to call and the partition key are
    passed. The proxy uses this data to ask the naming service for a physical URI
    for a primary instance for the given partition value.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个整数被传递给`ServicePartitionKey`构造函数。然后，创建一个服务代理，并传递要调用的服务的URI和分区键。代理使用这些数据向命名服务请求给定分区值的主要实例的物理URI。
- en: '`ServiceProxy.Create` also accepts a third optional argument that specifies
    whether messages that are sent by the proxy can also be routed to secondary replicas.
    The default is that messages are routed just to primary instances. If the message
    target returns `false`, meaning that it''s not ready (remember that `LogPurchase`
    returns `false` when the `LogStore` message queue hasn''t been created yet), the
    same transmission is attempted after 100 milliseconds.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceProxy.Create`还接受第三个可选参数，该参数指定代理发送的消息是否也可以路由到辅助副本。默认情况下，消息只路由到主要实例。如果消息目标返回`false`，表示它尚未准备好（请记住，当`LogStore`消息队列尚未创建时，`LogPurchase`返回`false`），则在100毫秒后尝试相同的传输。'
- en: 'Sending messages to a remoting target is quite easy. However, other communication
    listeners require that the sender interacts manually with the naming service to
    get a physical service URI. This can be done with the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 向远程目标发送消息非常容易。然而，其他通信侦听器要求发送者手动与命名服务交互，以获取物理服务URI。可以使用以下代码完成：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Moreover, in the case of generic communication protocols, we must manually handle
    failures and retries with a library such as Polly (see the *Resilient task execution*
    subsection of *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise
    Application*, for more information).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在通用通信协议的情况下，我们必须使用Polly这样的库手动处理故障和重试（有关更多信息，请参见*第5章*的*将微服务架构应用于企业应用程序*的*具有弹性的任务执行*子部分）。
- en: Testing the application
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: 'To test the application, you need to start Visual Studio with administrator
    permissions. Therefore, close Visual studio, then right-click on the Visual Studio
    icon and select the option to launch it as an administrator. Once you are again
    in Visual Studio, load the `PurchaseLogging` solution, and place a breakpoint
    in the `ComputeStatistics.cs` file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试应用程序，您需要以管理员权限启动Visual Studio。因此，关闭Visual Studio，然后右键单击Visual Studio图标，并选择以管理员身份启动的选项。一旦您再次进入Visual
    Studio，加载`PurchaseLogging`解决方案，并在`ComputeStatistics.cs`文件中设置断点：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Each time the breakpoint is hit, look at the content of `newCounter` to verify
    how the running totals of all the locations change. Before launching the application
    in debug mode, ensure the local cluster is running with five nodes. If you change
    from one to five nodes, the local cluster menu grays out until the operation is
    completed, so wait until the menu normalizes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 每次断点被触发时，查看`newCounter`的内容，以验证所有位置的运行总数如何变化。在调试模式下启动应用程序之前，请确保本地集群正在运行五个节点。如果您从一个节点更改为五个节点，则本地集群菜单会变灰，直到操作完成，请等待菜单恢复正常。
- en: Once you launch the application and the application is built, a console appears
    and you start receiving notifications of the operation completed in Visual Studio.
    The application takes some minutes to load on all nodes; after that, your breakpoint
    should start being hit.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动应用程序并构建应用程序，控制台将出现，并且您将开始在Visual Studio中接收操作完成的通知。应用程序需要一些时间在所有节点上加载；之后，您的断点应该开始被触发。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described how to define a Service Fabric solution in Visual
    Studio, and how to set up and configure a Service Fabric cluster in Azure.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了如何在Visual Studio中定义Service Fabric解决方案，以及如何在Azure中设置和配置Service Fabric集群。
- en: We described Service Fabric building blocks, reliable services, the various
    types of reliable services, and their roles within a Service Fabric application.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了Service Fabric的构建模块、可靠服务、各种类型的可靠服务以及它们在Service Fabric应用程序中的角色。
- en: Finally, we put these concepts into practice by implementing a Service Fabric
    application. Here, we provided more practical details on the architecture of each
    reliable service and how to organize and code their communications.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过实现Service Fabric应用程序将这些概念付诸实践。在这里，我们提供了关于每个可靠服务架构的更多实际细节，以及如何组织和编写它们的通信。
- en: The next chapter describes another famous microservices orchestrator, Kubernetes,
    and its implementation in the Azure Cloud.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章描述了另一个著名的微服务编排器Kubernetes及其在Azure Cloud中的实现。
- en: Questions
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a reliable service?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是可靠服务？
- en: Can you list the different types of reliable services and their roles in a Service
    Fabric application?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能列出可靠服务的不同类型及其在Service Fabric应用程序中的角色吗？
- en: What is `ConfigureServices`?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`ConfigureServices`？
- en: What kinds of port must be declared during the definition of an Azure Service
    Fabric cluster?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义Azure Service Fabric集群时必须声明哪些端口类型？
- en: Why are partitions of reliable stateful services needed?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要可靠有状态服务的分区？
- en: How can we declare that a remoting communication must be addressed by secondary
    replicas? What about other types of communication?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何声明远程通信必须由辅助副本处理？其他类型的通信呢？
- en: Further reading
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The official documentation for Azure Service Fabric can be found here: [https://docs.microsoft.com/en-US/azure/service-fabric/](https://docs.microsoft.com/en-US/azure/service-fabric/).'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Service Fabric的官方文档可以在这里找到：[https://docs.microsoft.com/en-US/azure/service-fabric/](https://docs.microsoft.com/en-US/azure/service-fabric/)。
- en: 'The official documentation for Azure Service Fabric''s reliable services can
    be found here: [https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction).'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Service Fabric可靠服务的官方文档可以在这里找到：[https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction)。
- en: 'More information about the Actor model can be found here: [https://www.researchgate.NET/publication/234816174_Actors_A_conceptual_foundation_for_concurrent_object-oriented_programming](https://www.researchgate.NET/publication/234816174_Actors_A_conceptual_foundation_for_concurrent_obj).'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Actor模型的更多信息可以在这里找到：[https://www.researchgate.NET/publication/234816174_Actors_A_conceptual_foundation_for_concurrent_object-oriented_programming](https://www.researchgate.NET/publication/234816174_Actors_A_conceptual_foundation_for_concurrent_obj)。
- en: 'The official documentation for Actor models that can be implemented in Azure
    Service Fabric can be found here: [https://docs.microsoft.com/en-US/azure/service-fabric/service-fabric-reliable-actors-introduction](https://docs.microsoft.com/en-US/azure/service-fabric/service-fabric-reliable-actors-introduction).'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在这里找到可以在Azure Service Fabric中实现的Actor模型的官方文档：[https://docs.microsoft.com/en-US/azure/service-fabric/service-fabric-reliable-actors-introduction](https://docs.microsoft.com/en-US/azure/service-fabric/service-fabric-reliable-actors-introduction)。
- en: 'Microsoft has also implemented an advanced Actor model that is independent
    of Service Fabric. This is known as the Orleans framework. More information about
    Orleans can be found at the following links:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 微软还实现了一个独立于Service Fabric的高级Actor模型，称为Orleans框架。有关Orleans的更多信息可以在以下链接找到：
- en: '**Orleans – Virtual Actors**: [https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/?from=https%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fprojects%2Forleans%2F](https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/?from=https%3A%2F%2Fresearch).'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Orleans - 虚拟演员**：[https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/?from=https%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fprojects%2Forleans%2F](https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/?from=https%3A%2F%2Fresearch).'
- en: '**Orleans** **Documentation**: [https://dotnet.github.io/orleans/docs/index.html](https://dotnet.github.io/orleans/docs/index.html)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Orleans** **文档**：[https://dotnet.github.io/orleans/docs/index.html](https://dotnet.github.io/orleans/docs/index.html)'
