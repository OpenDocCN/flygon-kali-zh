- en: Chapter 3. Asynchrony in Action
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。行动中的异步性
- en: We are going to explore features which are new to C# in the 5.0 release. Notably,
    most of them are related to built-in asynchrony features added to the language,
    which allow you to easily use the hardware running your software to its full potential.
    We will also discuss **Task Parallel Library** (**TPL**), which introduces primitives
    for asynchronous programming, C# 5.0 language support for easy asynchrony, TPL
    DataFlow, higher-level abstractions for agent-based asynchronous programming,
    and framework improvements that take advantage of the new asynchrony features,
    such as improvements to the I/O APIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨C# 5.0版本中的新功能。值得注意的是，其中大部分与语言中新增的内置异步功能相关，这些功能允许您轻松地充分利用运行软件的硬件。我们还将讨论**任务并行库**（**TPL**），它引入了用于异步编程的原语，C#
    5.0语言支持简单的异步性，TPL DataFlow，基于代理的异步编程的更高级抽象，以及利用新的异步性功能的框架改进，例如对I/O API的改进。
- en: All things considered, the latest release of the .NET Framework is enormous,
    and the concepts introduced in this chapter will serve as reference for the material
    covered in the rest of the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，.NET Framework的最新版本是庞大的，本章介绍的概念将作为本书其余部分涵盖材料的参考。
- en: Asynchrony
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步性
- en: When we talk about C# 5.0, the primary topic of conversation is the new asynchronous
    programming features. What does **asynchrony** mean? Well, it can mean a few different
    things, but in our context, it is simply the opposite of synchronous. When you
    break up the execution of a program into asynchronous blocks, you gain the ability
    to execute them side-by-side, in parallel.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论C# 5.0时，主要谈论的是新的异步编程功能。**异步性**是什么意思？嗯，它可能意味着一些不同的事情，但在我们的上下文中，它只是同步的相反。当您将程序的执行分解为异步块时，您可以并行执行它们。
- en: 'Pit of Success: in stark contrast to a summit, a peak, or a journey across
    a desert to find victory through many trials and surprises, we want our customers
    to simply fall into winning practices by using our platform and frameworks. To
    the extent that we make it easy to get into trouble we fail. –Rico Mariani'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 成功的陷阱：与峰会、高峰或穿越沙漠寻找胜利的旅程形成鲜明对比，我们希望我们的客户通过使用我们的平台和框架简单地获得胜利的实践。在我们让人陷入麻烦的程度上，我们失败了。-Rico
    Mariani
- en: 'Unfortunately, building asynchronous software has not always been easy, but
    with C# 5.0 you will see how easy it can be. As you can see in the following diagram,
    executing multiple actions concurrently can bring various positive qualities to
    your programs:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，构建异步软件并不总是容易的，但是通过C# 5.0，您将看到它可以有多容易。正如您在下图中所看到的，同时执行多个操作可以为您的程序带来各种积极的特性：
- en: '![Asynchrony](img/6761EN_03_04.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![异步性](img/6761EN_03_04.jpg)'
- en: Parallel execution can bring performance improvements to the execution of a
    program. The best way to put this into context is by way of an example, an example
    that has been experienced all too often in the world of desktop software.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 并行执行可以为程序的执行带来性能改进。最好的方法是通过一个例子来将其置于上下文中，这个例子在桌面软件的世界中经常遇到。
- en: 'Let''s say you have an application that you are developing, and this software
    should fulfill the following requirements:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在开发一个应用程序，并且该软件应满足以下要求：
- en: When the user clicks on a button, initiate a call to a web service.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户单击按钮时，启动对Web服务的调用。
- en: Upon completion of the web service call, store the results into a database.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成Web服务调用后，将结果存储到数据库中。
- en: Finally, bind the results and display them to the user.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，绑定结果并将其显示给用户。
- en: There are a number of problems with the naïve way of implementing this solution.
    The first is that many developers write code in such a way that the user interface
    will be completely unresponsive while we are waiting to receive the results of
    these web service calls. Then, once the results finally arrive, we continue to
    make the user wait while we store the results in a database, an operation that
    the user does not care about in this case.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个解决方案的天真方式存在许多问题。首先，许多开发人员以一种使用户界面在等待接收这些Web服务调用的结果时完全无响应的方式编写代码。然后，一旦结果最终到达，我们继续让用户等待，而我们将结果存储在数据库中，这是用户在这种情况下不关心的操作。
- en: The primary vehicle for mitigating these kinds of problems in the past has been
    writing multithreaded code. This is of course nothing new, as multi-threaded hardware
    has been around for many years, along with software capabilities to take advantage
    of this hardware. Most of the programming languages did not provide a very good
    abstraction layer on top of this hardware, often letting (or requiring) you program
    directly against the hardware threads.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 过去缓解这类问题的主要手段一直是编写多线程代码。这当然并不新鲜，因为多线程硬件已经存在多年，以及利用这些硬件的软件功能。大多数编程语言没有为这些硬件提供很好的抽象层，通常让（或要求）您直接针对硬件线程进行编程。
- en: Thankfully, Microsoft introduced a new library to simplify the task of writing
    highly concurrent programs, which is explained in the next section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，微软引入了一个新的库，以简化编写高度并发程序的任务，这将在下一节中解释。
- en: Task Parallel Library
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务并行库
- en: The **Task Parallel Library** (**TPL**) was introduced in .NET 4.0 (along with
    C# 4.0). We did not cover it in [Chapter 2](ch02.html "Chapter 2. Evolution of
    C#"), *Evolution of C#*, for several reasons. Firstly, it is a huge topic and
    could not have been examined properly in such a small space. Secondly, it is highly
    relevant to the new asynchrony features in C# 5.0, so much so that they are the
    literal foundation upon which the new features are built. So, in this section,
    we will cover the basics of the TPL, along with some of the background information
    about how and why it works.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务并行库**（**TPL**）是在.NET 4.0中引入的（以及C# 4.0）。我们在[第2章](ch02.html "第2章。C#的演变")*C#的演变*中没有涉及它，原因有几个。首先，这是一个庞大的主题，在如此狭小的空间内无法得到适当的审查。其次，它与C#
    5.0中的新异步特性高度相关，以至于它们是新特性的字面基础。因此，在本节中，我们将介绍TPL的基础知识，以及它如何以及为什么起作用的一些背景信息。'
- en: TPL introduces a new type, the `Task` type, which abstracts away the concept
    of *something that must be done* into an object. At first glance, you might think
    that this abstraction already exists in the form of the `Thread` class. While
    there are some similarities between `Task` and `Thread`, the implementations have
    quite different implications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TPL引入了一个新类型，即`Task`类型，它将*必须完成的任务*的概念抽象成一个对象。乍一看，您可能会认为这种抽象已经存在于`Thread`类中。虽然`Task`和`Thread`之间有一些相似之处，但实现有着相当不同的含义。
- en: 'With a `Thread` class, you can program directly against the lowest level of
    parallelism supported by the operating system, as shown in the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Thread`类，您可以直接针对操作系统支持的最低级别的并行性进行编程，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous example, we create a new `Thread` class, which when started
    will sleep for a second and then write out the text **Hello, from the Thread**.
    After we call `thread.Start()`, the code on the main thread immediately continues
    and writes **Hello, from the main thread**. After a second, we see the text from
    the background thread printed to the screen.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个新的`Thread`类，当启动时，它将休眠一秒钟，然后输出文本**Hello, from the Thread**。在调用`thread.Start()`之后，主线程上的代码立即继续执行，并输出**Hello,
    from the main thread**。一秒钟后，我们看到后台线程的文本被打印到屏幕上。
- en: In one sense, this example of using the `Thread` class shows how easy it is
    to branch off the execution to a background thread, while allowing execution of
    the main thread to continue, unimpeded. However, the problem with using the `Thread`
    class as your "concurrency primitive" is that the class itself is an indication
    of the implementation, which is to say, an operating system thread will be created.
    As far as abstractions go, it is not really an abstraction at all; your code must
    both manage the lifecycle of the thread, while at the same time dealing with the
    task the thread is executing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，使用`Thread`类的这个示例展示了如何轻松地将执行分支到后台线程，同时允许主线程的执行继续进行，不受阻碍。然而，使用`Thread`类作为您的“并发原语”的问题在于，该类本身就是实现的指示，也就是说，将创建一个操作系统线程。就抽象而言，它实际上并不是一个抽象；您的代码必须同时管理线程的生命周期，同时处理线程正在执行的任务。
- en: 'If you have multiple tasks to execute, spawning multiple threads can be disastrous,
    because the operating system can only spawn a finite number of them. For performance
    intensive applications, a thread should be considered a heavyweight resource,
    which means you should avoid using too many of them, and keep them alive for as
    long as possible. As you might imagine, the designers of the .NET Framework did
    not simply leave you to program against this without any help. The early versions
    of the frameworks had a mechanism to deal with this in the form of the `ThreadPool`,
    which lets you queue up a unit of work, and have the thread pool manage the lifecycle
    of a pool of threads. When a thread becomes available, your work item is then
    executed. The following is a simple example of using the thread pool:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个任务要执行，生成多个线程可能是灾难性的，因为操作系统只能生成有限数量的线程。对于性能密集型应用程序，线程应被视为一种重量级资源，这意味着您应该避免使用过多的线程，并尽可能地保持它们活动。正如您可能想象的那样，.NET
    Framework的设计者并没有简单地让您在没有任何帮助的情况下编写程序。框架的早期版本有一种机制来处理这个问题，即`ThreadPool`，它允许您排队一个工作单元，并让线程池管理一组线程的生命周期。当一个线程变得可用时，您的工作项就会被执行。以下是使用线程池的一个简单示例：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This sample simulates multiple tasks, which should be executed in parallel.
    We start with an array of numbers, and for each number we want to queue a work
    item that will sleep for half a second, and then write to the console. This works
    much better than trying to manage multiple threads yourself because the pool will
    take care of spawning more threads if there is more work. When the configured
    limit of concurrent threads is reached, it will hold work items until a thread
    becomes available to process it. This is all work that you would have done yourself
    if you were using threads directly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例模拟了多个任务，应该并行执行。我们从一个数字数组开始，对于每个数字，我们都想排队一个工作项，它将休眠半秒钟，然后写入控制台。这比自己尝试管理多个线程要好得多，因为线程池会在有更多工作时负责生成更多线程。当达到并发线程的配置限制时，它将保持工作项，直到有线程可用来处理它。这是您自己使用线程时会做的所有工作。
- en: However, the thread pool is not without its complications. First, it offers
    no way of synchronizing on completion of the work item. If you want to be notified
    when a job is completed, you have to code the notification yourself, whether by
    raising an event, or using a thread synchronization primitive, such as `ManualResetEvent`
    . You also have to be careful not to queue too many work items, or you may run
    into system limitations with the size of the thread pool.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，线程池并不是没有问题的。首先，它没有提供在工作项完成时同步的方法。如果您想在作业完成时收到通知，您必须自己编写通知，无论是通过引发事件，还是使用线程同步原语，比如`ManualResetEvent`。您还必须小心不要排队太多的工作项，否则可能会遇到线程池大小的系统限制。
- en: 'With the TPL, we now have a concurrency primitive called `Task`. Consider the
    following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TPL，我们现在有一个称为`Task`的并发原语。考虑以下代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Upon first glance, the code looks very similar to the sample using `Thread`,
    but they are very different. One big difference is that with `Task`, you are not
    committing to an implementation. The TPL uses some very interesting algorithms
    behind the scenes to manage the workload and system resources, and in fact, allows
    you customize those algorithms through the use of custom schedulers and synchronization
    contexts. This allows you to control the parallel execution of your programs with
    a high degree of control.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，代码看起来与使用`Thread`的示例非常相似，但它们是非常不同的。一个很大的区别是，使用`Task`时，您并没有承诺实现。TPL在幕后使用一些非常有趣的算法来管理工作负载和系统资源，并且实际上允许您通过使用自定义调度程序和同步上下文来自定义这些算法。这使您能够以高度控制并行执行程序。
- en: 'Dealing with multiple tasks, as we did with the thread pool, is also easier
    because each task has synchronization features built-in. To demonstrate how simple
    it is to quickly parallelize an arbitrary number of tasks, we start with the same
    array of integers, as shown in the previous thread pool example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 处理多个任务，就像我们在线程池中所做的那样，也更容易，因为每个任务都内置了同步功能。为了演示如何快速并行化任意数量的任务是多么简单，我们从与前一个线程池示例中相同的整数数组开始：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Because `Task` can be thought of as a primitive type that represents an asynchronous
    task, we can think of it as data. This means that we can use things such as Linq
    to project the numbers array to a list of tasks as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Task`可以被视为表示异步任务的原始类型，我们可以将其视为数据。这意味着我们可以使用诸如Linq之类的东西将数字数组投影到任务列表中，如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And finally, if we wanted to wait until all of the tasks were done before continuing
    on, we could easily do that by calling the following method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们想要等到所有任务都完成后再继续，我们可以通过调用以下方法轻松实现：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once the code reaches this method, it will wait until every task in the array
    completes before continuing on. This level of control is very convenient, especially
    when you consider that, in the past, you would have had to depend on a number
    of different synchronization techniques to achieve the very same result that was
    accomplished in just a few lines of TPL code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码到达这个方法，它将等待数组中的每个任务完成后才继续。这种控制水平非常方便，特别是当您考虑到过去，您必须依赖许多不同的同步技术来实现与TPL代码中仅用几行代码实现的完全相同的结果时。
- en: 'With the usage patterns that we have discussed so far, there is still a big
    disconnect between the process that spawns a task, and the child process. It is
    very easy to pass values into a background task, but the tricky part comes when
    you want to retrieve a value and then do something with it. Consider the following
    requirements:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的使用模式仍然存在一个很大的断裂，即生成任务的过程和子进程之间的断裂。将值传递到后台任务中非常容易，但当您想要检索一个值然后对其进行操作时，情况就会变得棘手。考虑以下要求：
- en: Make a network call to retrieve some data.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行网络调用以检索一些数据。
- en: Query the database for some configuration data.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询数据库以获取一些配置数据。
- en: Process the results of the network data, along with the configuration data.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理网络数据的结果，以及配置数据。
- en: 'The following diagram shows the logic:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了逻辑：
- en: '![Task Parallel Library](img/6761EN_03_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![任务并行库](img/6761EN_03_01.jpg)'
- en: Both the network call and query to the database can be done in parallel. With
    what we have learned so far about tasks, this is not a problem. However, acting
    on the results of those tasks would be slightly more complex, if it were not for
    the fact that the TPL provides support for exactly that scenario.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 网络调用和对数据库的查询可以并行进行。根据我们迄今为止对任务的了解，这不是问题。然而，对这些任务的结果进行操作将会稍微复杂一些，如果不是因为TPL恰好提供了对这种情况的支持。
- en: There is an additional kind of `Task`, which is especially useful in cases like
    this called `Task<T>`. This generic version of a task expects the running task
    to ultimately return a value, whenever it is finished. Clients of the task can
    access the value through the `.Result` property of the task. When you call that
    property, it will return immediately if the task is completed and the result is
    available. If the task is not done, however, it will block execution in the current
    thread until it is.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种特殊的`Task`，在这种情况下特别有用，称为`Task<T>`。这个任务的泛型版本期望运行的任务最终返回一个值。任务的客户端可以通过任务的`.Result`属性访问该值。当您调用该属性时，如果任务已完成并且结果可用，它将立即返回。但是，如果任务尚未完成，它将阻塞当前线程的执行，直到完成。
- en: 'Using this kind of task, which promises you a result, you can write your programs
    such that you can plan for and initiate the parallelism that is required, and
    handle the response in a very logical manner. Look at the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种承诺给您结果的任务，您可以编写程序，以便计划并启动所需的并行性，并以非常逻辑的方式处理响应。看看以下代码：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous example, we have two tasks, the `webTask`, and `dbTask`, which
    will execute at the same time. The `webTask` is simply downloading the HTML from
    [http://bing.com](http://bing.com). Accessing things over the Internet can be
    notoriously flaky due to the dynamic nature of accessing the network so you never
    know how long that is going to take. With the `dbTask` task, we are simulating
    accessing a database to return some stored settings. Although in this simple example
    we are just returning a static anonymous type, database access will usually access
    a different server over the network; again, this is an I/O bound task just like
    downloading something over the Internet.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有两个任务，`webTask`和`dbTask`，它们将同时执行。`webTask`只是从[http://bing.com](http://bing.com)下载HTML。由于访问互联网的动态特性，访问互联网上的内容可能会非常不稳定，因此您永远不知道需要多长时间。对于`dbTask`任务，我们模拟访问数据库以返回一些存储的设置。尽管在这个简单的示例中，我们只是返回一个静态的匿名类型，但数据库访问通常会访问网络上的不同服务器；同样，这是一个像从互联网上下载东西一样的I/O绑定任务。
- en: Rather than waiting for both of them to execute like we did with `Task.WaitAll`,
    we can simply access the `.Result` property of the task. If the task is done,
    the result will be returned and execution can continue, and if not, the program
    will simply wait until it is.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们使用`Task.WaitAll`等待它们都执行不同，我们可以简单地访问任务的`.Result`属性。如果任务已经完成，结果将被返回，执行可以继续，如果没有，程序将简单地等待直到完成。
- en: This ability to write your code without having to manually deal with task synchronization
    is great because the fewer concepts a programmer has to keep in his/her head,
    the more resources he/she can devote to the program.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在不必手动处理任务同步的情况下编写代码是很棒的，因为程序员需要记住的概念越少，他/她就可以将更多的资源投入到程序中。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you are curious about where this concept of a task that returns a value
    comes from, you can look for resources pertaining to "Futures", and "Promises"
    at:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对返回值的任务的概念感到好奇，你可以搜索有关"Futures"和"Promises"的资源：
- en: '[http://en.wikipedia.org/wiki/Promise_%28programming%29](http://en.wikipedia.org/wiki/Promise_%28programming%29)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Promise_%28programming%29](http://en.wikipedia.org/wiki/Promise_%28programming%29)'
- en: At the simplest level, this is a construct that "promises" to give you a result
    in the "future", which is exactly what `Task<T>` does.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的层面上，这是一个承诺在“未来”给你一个结果的构造，这正是`Task<T>`所做的。
- en: Task composability
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务的可组合性
- en: 'Having a proper abstraction for asynchronous tasks makes it easier to coordinate
    multiple asynchronous activities. Once the first task has been initiated, the
    TPL allows you to compose a number of tasks together into a cohesive whole using
    what are called **continuations** . Look at the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个适当的异步任务抽象使得协调多个异步活动变得更容易。一旦第一个任务被启动，TPL允许你使用所谓的**continuations**将多个任务组合成一个统一的整体。看看下面的代码：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Every task object has the `.ContinueWith` method, which lets you chain another
    task to it. This continuation task will begin execution once the first task is
    done. Unlike the previous example, where we relied on the `.Result` method to
    wait until the task was done—thus potentially holding up the main thread while
    it completed—the continuation will run asynchronously. This is a better approach
    for composing tasks because you can write tasks that will not block the UI thread,
    which results in very responsive applications.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务对象都有`.ContinueWith`方法，它让你将另一个任务链接到它上面。这个继续任务将在第一个任务完成后开始执行。与之前的示例不同，我们依赖`.Result`方法来等待任务完成，从而可能阻塞主线程，而继续任务将以异步方式运行。这是一个更好的组合任务的方法，因为你可以编写不会阻塞UI线程的任务，这会导致非常响应迅速的应用程序。
- en: 'Task composability does not stop at providing continuations though, the TPL
    also provides considerations for scenarios, where a task must launch a number
    of subtasks. You have the ability to control how completion of those child tasks
    affects the parent task. In the following example, we will start a task, which
    will in turn launch a number of subtasks:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的可组合性并不仅限于提供continuations，TPL还提供了考虑情况的能力，其中一个任务必须启动多个子任务。你可以控制这些子任务的完成方式如何影响父任务。在下面的示例中，我们将启动一个任务，该任务将依次启动多个子任务：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Each child task will write to the console, so that you can see how the child
    tasks behave along with the parent task. When you execute the previous program,
    it results in the following output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子任务都会写入控制台，这样你就可以看到子任务和父任务的行为。当你执行前面的程序时，会得到以下输出：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice how even though you have called the `.Wait()` method on the outer task
    before writing **done**, the execution of the child task continues a bit longer
    after the task is concluded. This is because, by default, child tasks are detached,
    which means their execution is not tied to the task that launched it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使在写入**done**之前调用了外部任务的`.Wait()`方法，子任务的执行在任务结束后仍会继续一段时间。这是因为，默认情况下，子任务是分离的，这意味着它们的执行与启动它的任务没有关联。
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: An unrelated, but important bit in the previous example code, is you will notice
    that we assigned the loop variable to an intermediary variable before using it
    in the task.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，一个无关但重要的部分是，你会注意到在使用任务之前，我们将循环变量赋值给一个中间变量。
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you remember our discussion on continuations in [Chapter 2](ch02.html "Chapter 2. Evolution
    of C#"), *Evolution of C#*, your intuition would suggest that you should be able
    to use `num` directly in the lambda expression. This is actually related to the
    way closures work, and is a common misconception when trying to "pass in" values
    in a loop. Because the closure actually creates a reference to the value, rather
    than copying the value in, using the loop value will end up changing every time
    the loop iterates, and you will not get the behavior you expect.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我们在[第2章](ch02.html "Chapter 2. Evolution of C#")中对continuations的讨论，*C#的演变*，你的直觉会告诉你应该能够直接在lambda表达式中使用`num`。这实际上与闭包的工作方式有关，在尝试在循环中“传递”值时，这是一个常见的误解。因为闭包实际上创建了对值的引用，而不是复制值，使用循环值将导致在循环迭代时每次都会改变，你将得不到你期望的行为。
- en: As you can see, an easy way to mitigate this is to set the value to a local
    variable before passing it into the lambda expression. That way, it will not be
    a reference to an integer that changes before it is used.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，缓解这个问题的一个简单方法是在将其传递到lambda表达式之前将值设置为一个本地变量。这样，它将不会是一个在使用之前改变的整数的引用。
- en: 'You do however have the option to mark a child task as `Attached`, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以选择将子任务标记为`Attached`，如下所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `TaskCreationOptions` enumeration has a number of different options. Specifically
    in this case, the ability to attach a task to its parent task means that the parent
    task will not complete until all child tasks are complete.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskCreationOptions`枚举有许多不同的选项。特别是在这种情况下，将任务附加到其父任务的能力意味着父任务将在所有子任务完成之前不会完成。'
- en: 'Other options in `TaskCreationOptions` let you give hints and instructions
    to the task scheduler. From the documentation, the following are the descriptions
    of all these options:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskCreationOptions`中的其他选项让你向任务调度程序提供提示和指令。从文档中，以下是所有这些选项的描述：'
- en: '`None`: This specifies that the default behavior should be used.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`None`: 这指定应该使用默认行为。'
- en: '`PreferFairness`: This is a hint to a `TaskScheduler` class to schedule a task
    in as fair a manner as possible, meaning that tasks scheduled sooner will be more
    likely to be run sooner, and tasks scheduled later will be more likely to be run
    later.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreferFairness`: 这是对`TaskScheduler`类的一个提示，尽可能公平地安排任务，这意味着更早安排的任务更有可能更早运行，而更晚安排的任务更有可能更晚运行。'
- en: '`LongRunning`: This specifies that a task will be a long-running, coarse-grained
    operation. It provides a hint to the `TaskScheduler` class that oversubscription
    may be warranted.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LongRunning`: 这指定任务将是一个长时间运行的、粗粒度的操作。它向`TaskScheduler`类提供了一个提示，表明可能需要过度订阅。'
- en: '`AttachedToParent`: This specifies that a task is attached to a parent in the
    task hierarchy.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AttachedToParent`: 这指定任务附加到任务层次结构中的父任务。'
- en: '`DenyChildAttach`: This specifies that an exception of the type `InvalidOperationException`
    will be thrown if an attempt is made to attach a child task to the created task.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DenyChildAttach`: 这指定如果尝试将子任务附加到创建的任务，则会抛出`InvalidOperationException`类型的异常。'
- en: '`HideScheduler`: This prevents the ambient scheduler from being seen as the
    current scheduler in the created task. This means that operations such as `StartNew`
    or `ContinueWith` that are performed in the created task, will see `Default` as
    the current scheduler.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HideScheduler`: 这样可以防止在创建的任务中看到环境调度程序作为当前调度程序。这意味着在创建的任务中执行的`StartNew`或`ContinueWith`等操作将把`Default`作为当前调度程序。'
- en: The best part about these options, and the way the TPL works, is that most of
    them are merely hints. So you can suggest that a task you are starting is long
    running, or that you would prefer tasks scheduled sooner to run first, but that
    does not guarantee this will be the case. The framework will take the responsibility
    of completing the tasks in the most efficient manner, so if you prefer fairness,
    but a task is taking too long, it will start executing other tasks to make sure
    it keeps using the available resources optimally.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项以及TPL的工作方式最好的部分是，它们大多数只是提示。因此，你可以建议你启动的任务是长时间运行的，或者你更希望较早安排的任务先运行，但这并不保证一定会这样。框架将负责以最有效的方式完成任务，因此如果你更喜欢公平性，但一个任务花费太长时间，它将开始执行其他任务，以确保它继续最优地使用可用资源。
- en: Error handling with tasks
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务的错误处理
- en: Error handling in the world of tasks needs special consideration. In summary,
    when an exception is thrown, the CLR will unwind the stack frames looking for
    an appropriate try/catch handler that wants to handle the error. If the exception
    reaches the top of the stack, the application crashes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务世界中的错误处理需要特别考虑。总之，当抛出异常时，CLR将展开堆栈帧，寻找一个适当的try/catch处理程序来处理错误。如果异常达到堆栈的顶部，应用程序就会崩溃。
- en: 'With asynchronous programs, though, there is not a single linear stack of execution.
    So when your code launches a task, it is not immediately obvious what will happen
    to an exception that is thrown inside of the task. For example, look at the following
    code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在异步程序中，并不是有一个单一的线性执行堆栈。所以当你的代码启动一个任务时，不会立即清楚在任务内部抛出的异常会发生什么。例如，看看下面的代码：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This exception will not bubble up as an unhandled exception, and your application
    will not crash if you leave it unhandled in your code. It was in fact handled,
    but by the task machinery. However, if you call the `.Wait()` method, the exception
    will bubble up to the calling thread at that point. This is shown in the following
    example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常不会作为未处理的异常冒泡上来，如果你在代码中不处理它，你的应用程序不会崩溃。实际上它已经被处理了，但是由任务机制处理。然而，如果你调用`.Wait()`方法，异常将在那一点上冒泡到调用线程。这在下面的例子中显示：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you execute that, it will print out the somewhat unhelpful message **One
    or more errors occurred**, rather than the **fail** message that is the actual
    message contained in the exception. This is because unhandled exceptions that
    occur in tasks will be wrapped in an `AggregateException` exception, which you
    can handle specifically when dealing with task exceptions. Look at the following
    code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行时，它将打印出一条不太有用的消息**发生了一个或多个错误**，而不是实际包含在异常中的**失败**消息。这是因为在任务中发生的未处理异常将被包装在一个`AggregateException`异常中，当处理任务异常时，你可以专门处理它。看看下面的代码：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you think about it, this makes sense, because of the way that tasks are
    composable with continuations and child tasks, this is a great way to represent
    *all* of the errors raised by this task. If you would rather handle exceptions
    on a more granular level, you can also pass a special `TaskContinuationOptions`
    parameter as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，这是有道理的，因为任务与继续和子任务是可组合的，这是表示此任务引发的*所有*错误的好方法。如果你更愿意在更细粒度的级别上处理异常，你也可以传递一个特殊的`TaskContinuationOptions`参数，如下所示：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This continuation task will only run if the task that it was attached to is
    faulted (for example, if there was an unhandled exception). Error handling is,
    of course, something that is often overlooked when developers write code, so it
    is important to be familiar with the various methods of handling exceptions in
    an asynchronous world.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个继续任务只有在附加的任务出现故障时才会运行（例如，如果有未处理的异常）。错误处理当然是开发人员编写代码时经常忽视的事情，因此熟悉在异步世界中处理异常的各种方法是很重要的。
- en: async and await
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: async和await
- en: Now that the foundation for asynchrony has been set, we are ready to finally
    start talking about C# 5.0\. The first feature we are going to discuss is quite
    possibly the largest impact to the way we develop applications—asynchronous programming
    using a new language feature that introduces the `async` and `await` keywords.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在异步的基础已经建立，我们准备最终开始讨论C# 5.0。我们将讨论的第一个功能可能是对我们开发应用程序方式影响最大的功能——使用引入`async`和`await`关键字的新语言特性进行异步编程。
- en: 'Before we go too far, let''s do a quick review of the versioning situation.
    Although it seemed like it was going to improve when the CLR, C#, and the .NET
    Framework all were incremented to 4.0, it has regressed into confusing territory.
    The following diagram shows the comparison between the versions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论之前，让我们快速回顾一下版本情况。尽管当CLR、C#和.NET Framework都增加到4.0时，似乎情况会有所改善，但它已经退化为令人困惑的领域。以下图表显示了版本之间的比较：
- en: '![async and await](img/6761EN_03_02.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![async and await](img/6761EN_03_02.jpg)'
- en: C# 5.0 comes with .NET 4.5, which also includes a new version of the Common
    Language Runtime. So when you develop C# 5.0 applications, you will generally
    be targeting the 4.5 version of the Framework.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: C# 5.0随附于.NET 4.5，其中还包括一个新版本的公共语言运行时。因此，当您开发C# 5.0应用程序时，通常会针对Framework的4.5版本。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you have an absolute need to target Version 4.0 of the framework, you can
    download the *Async Targeting Pack for Visual Studio 2012*, which will give you
    the ability to compile and deploy your C# 5.0 applications to .NET 4.0\. However,
    keep in mind that this is only for the C# 5.0 language features, such as async/await.
    The other framework updates in .NET 4.5 will not be available.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您绝对需要针对Framework的4.0版本，您可以下载*Visual Studio 2012的Async Targeting Pack*，这将使您能够将C#
    5.0应用程序编译和部署到.NET 4.0。但是，请记住，这仅适用于C# 5.0语言功能，如async/await。.NET 4.5中的其他Framework更新将不可用。
- en: 'You may be asking yourself what exactly is new, considering the Task Parallel
    Library was introduced in the previous version of the framework. The difference
    is that the language itself now takes an active part in the asynchronous operation
    of your program. Let''s start with a simple example showing the feature in action:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问自己，考虑到任务并行库是在之前的Framework版本中引入的，那么到底有什么新东西呢？不同之处在于，语言本身现在积极参与程序的异步操作。让我们从一个简单的示例开始，展示这个功能的运作方式：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a very simple method from the programmer''s logical perspective. It
    writes to the console to say **Async: method starting**, then it waits one second,
    and finally writes **Async: method completed**. Make special note of the two keywords
    in that method: `async` and `await`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '从程序员的逻辑角度来看，这是一个非常简单的方法。它写入控制台以表明**Async: method starting**，然后等待一秒，最后写入**Async:
    method completed**。请特别注意该方法中的两个关键字：`async`和`await`。'
- en: 'In another part of the program, we call that method writing to the console
    before and after we call the method as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的另一部分中，我们在调用该方法之前和之后将其写入控制台，如下所示：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Aside from the two new keywords, this code looks entirely sequential. Without
    knowing how `async` works, you might assume that the messages written to the console
    would come in this pattern: `parent`, `async`, `async`, `parent`. Although this
    is the order in which the statements are written, this is not the order in which
    they are executed. You can see the following example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了两个新关键字之外，这段代码看起来完全是顺序的。如果不知道`async`的工作原理，您可能会假设写入控制台的消息会按照这种模式出现：`parent`，`async`，`async`，`parent`。尽管这是语句编写的顺序，但这不是它们执行的顺序。您可以看到以下示例：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The statements are out of order because the method, or part of it, was executed
    asynchronously. What is happening here is that the compiler is analyzing the method,
    and literally breaking it up in such a way that everything that happens after
    the `await` keyword occurs asynchronously. Execution of the calling thread returns
    immediately and continues, and everything after the `await` call is executed in
    continuation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 语句的顺序是错乱的，因为该方法或其中的一部分是异步执行的。这里发生的情况是，编译器正在分析该方法，并以一种方式将其分解，以便在`await`关键字之后发生的一切都是异步执行的。调用线程的执行立即返回并继续，`await`调用之后的一切都是在继续执行。
- en: The first reaction from most developers when they first encounter this is, "What!?"
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员第一次遇到这种情况时的第一反应是：“什么！？”
- en: 'Although it will seem hard to understand at first, once you understand how
    the compiler handles this, you can start to build a mental model that will help
    you. If we were to write that same asynchronous method using the TPL, it would
    look something like the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始可能很难理解，但一旦了解编译器如何处理这一点，您就可以开始建立一个有助于您的心智模型。如果我们使用TPL编写相同的异步方法，它看起来会像以下内容：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this method, we have highlighted the lines of code present in the original
    method. The `Task.Delay` method, which returns `Task`, is called to kick off the
    task (in this sample case, just waiting for one second). The next line of code
    is then put into a continuation, which will execute as soon as the calling task
    is done.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们突出显示了原始方法中的代码行。调用返回`Task`的`Task.Delay`方法用于启动任务（在这个示例中，只是等待一秒）。然后，下一行代码被放入一个继续执行的部分，这部分将在调用任务完成后立即执行。
- en: Another interesting, and perhaps more important, feature of this rewritten code
    is that the continuation will run on the same synchronization context as the code
    before the asynchronous task. So it will actually run on the same thread as the
    code prior to the await keyword. This becomes particularly important when you
    are dealing with UI code, because you cannot set property values or call UI control
    methods from a thread other than the main UI thread without having an exception
    thrown.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段重写的代码的另一个有趣且可能更重要的特性是，继续执行将在与异步任务之前的代码相同的同步上下文中运行。因此，它实际上将在`await`关键字之前的代码所在的同一线程上运行。当处理UI代码时，这一点变得特别重要，因为您不能在主UI线程之外的线程上设置属性值或调用UI控件方法，否则会引发异常。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To be clear, this is not exactly what the compiler generates. Behind the scenes
    it will create a state machine that represents each stage of execution of the
    rewritten code. This can get very complex, when you start having loops that call
    and await asynchronous methods.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要清楚的是，这并不完全是编译器生成的代码。在幕后，它将创建一个代表重写代码执行每个阶段的状态机。当您开始使用循环调用和等待异步方法时，这可能会变得非常复杂。
- en: Despite that, the previous example is identical, logically speaking, to what
    the compiler generates in this case. So rather than spending a lot of time trying
    to explain what the compiler is doing, it is better to create a logical mental
    model of the behavior that you can work with.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，从逻辑上讲，前面的例子与编译器在这种情况下生成的代码是相同的。因此，与其花费大量时间试图解释编译器正在做什么，不如创建一个您可以使用的行为的逻辑心智模型。
- en: So far you will notice that every example we have given has had the asynchronous
    work done in a method, and is then called by another method that awaits the value.
    The method, or function, is a central piece of the asynchronous puzzle. Just as
    you can with tasks, you can return values from asynchronous methods.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您会注意到我们给出的每个例子都是在一个方法中完成异步工作，然后由另一个方法调用并等待其值。方法或函数是异步拼图的核心部分。就像您可以使用任务一样，您可以从异步方法中返回值。
- en: 'In this example, we have an asynchronous method with `Task<string>` set as
    the return type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个异步方法，返回类型设置为`Task<string>`：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Because the method was decorated with the `async` keyword, you can return an
    actual string, without having to wrap it in a task. When the caller awaits the
    result, it will be a string, so you can treat it as a simple return type as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因为该方法被标记为`async`关键字，您可以返回一个实际的字符串，而不必将其包装在任务中。当调用者等待结果时，它将是一个字符串，因此您可以将其视为简单的返回类型，如下所示：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again we see that you are able to deal with asynchronous operations, without
    having to worry about the infrastructure to execute them. As we showed earlier,
    when we rewrite the previous method to use tasks, it becomes obvious how the compiler
    handles the return values. Look at the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看到，您可以处理异步操作，而不必担心执行它们的基础设施。正如我们之前展示的，当我们重写以前的方法以使用任务时，编译器如何处理返回值就变得明显了。看看以下代码：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Composing async calls
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合异步调用
- en: Another reason that it is helpful to think of the way the compiler rewrites
    async methods with tasks and continuations, is because it keeps the fact that
    the TPL is in use to the fore. This means that you can use the new keywords in
    tandem with all of the existing features of the tasks in order to parallelize
    your application to match your requirements. This is important to remember, because
    you may be missing opportunities for parallelism, if you use the `await` keyword
    every time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有助于思考编译器如何使用任务和延续重写异步方法的方式的原因是，它使得TPL的使用方式始终保持在前沿。这意味着您可以将新关键字与任务的所有现有特性结合使用，以使您的应用程序并行化以满足您的需求。这一点很重要，因为如果您每次都使用`await`关键字，您可能会错过并行性的机会。
- en: 'In the following example, we are calling an asynchronous method twice. The
    method returns `Task<string>`, so instead of calling `await`, which would (logically)
    hold execution of the second task until the first one was completed, we put the
    return values into variables, and use the `Task.WhenAll` method to wait until
    they both complete as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们两次调用一个异步方法。该方法返回`Task<string>`，所以我们不是使用`await`来调用，因为这样会（逻辑上）在第一个任务完成之前阻止第二个任务的执行，而是将返回值放入变量中，并使用`Task.WhenAll`方法等待它们都完成，如下所示：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This allows both tasks to execute at the same time, and still gives you the
    ability to compose your program using the await keyword.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许两个任务同时执行，并且仍然可以使用`await`关键字来组合您的程序。
- en: Error handling with async methods
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用异步方法处理错误
- en: Error handling with asynchronous methods is very straightforward. Because the
    C# compiler is already rewriting the method entirely to await the completion of
    the task at hand before continuing, it lets you use the same exception based error
    handling methods that you have been using since C# 1.0.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步方法处理错误非常简单。因为C#编译器已经完全重写了方法以等待手头任务的完成，所以它让您可以使用与自C# 1.0以来一直在使用的基于异常的错误处理方法相同的方法。
- en: 'The following is an example of an async method that throws an exception from
    `Task`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个从`Task`中抛出异常的异步方法的示例：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we discussed in the *Error handling with tasks* section, if you were interacting
    with the return value of this method as a regular task, then the exception would
    not be directly raised in the same context as the calling code. Either it will
    be raised when you call the `.Wait` method on the task, or you can handle it in
    a special continuation. But if you use `await` with the method, then you can wrap
    the code in a `try`/`catch` block as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*使用任务处理错误*部分中讨论的那样，如果您将此方法的返回值视为常规任务进行交互，那么异常不会直接在调用代码的相同上下文中引发。它要么在调用任务的`.Wait`方法时引发，要么您可以在特殊的延续中处理它。但是如果您使用`await`与该方法，那么您可以将代码包装在`try`/`catch`块中，如下所示：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Execution of this code will seamlessly transition to the `catch` block when
    the unhandled exception is raised from the `async` method. This means that you
    don't really have to think about how you are going to handle exceptions if they
    are thrown from an asynchronous context, you simply `catch` them as you would
    if it was regular synchronous code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当从`async`方法中引发未处理的异常时，此代码的执行将无缝地转移到`catch`块。这意味着您实际上不必考虑如何处理从异步上下文中抛出的异常，您只需像处理常规同步代码一样`catch`它们。
- en: Impact of async
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步的影响
- en: Up to this point, we have just been discussing the mechanics of the asynchronous
    programming features that have been released in .Net 4.0 and C# 5.0\. However,
    the significance of making parallel software applications easy to program deserves
    to be highlighted once again. There are several factors that highlight the importance
    of these new developments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了在.Net 4.0和C# 5.0中发布的异步编程功能的机制。然而，使并行软件应用易于编程的重要性值得再次强调。有几个因素突出了这些新发展的重要性。
- en: The First is Moore's law, which famously states that the number of transistors
    in CPUs is likely to double every year. While this law held true for many years,
    over the last decade some practical limits in cost and heat have been reached,
    with what is commercially possible on a single CPU. As a result, manufacturers
    began making computers with multiple CPUs. These new designs still manage to keep
    up with the prediction of Moore's law, but programs have to be specifically written
    to take advantage of the hardware.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是摩尔定律，它著名地指出CPU中的晶体管数量可能每年翻一番。虽然这个定律多年来一直成立，但在过去的十年里，成本和热量方面已经达到了一些实际限制，使得在单个CPU上商业上可能的事情。因此，制造商开始制造带有多个CPU的计算机。这些新设计仍然能够跟上摩尔定律的预测，但程序必须专门编写以利用硬件。
- en: Another huge factor in the impact of `async` is the rise of distributed computing.
    These days it is becoming more and more popular to architect programs as individual
    programs running on multiple computers. These peer-to-peer or client-server architectures
    are rarely CPU-bound, because of the latency in communicating between one computer
    and another over the network (or Internet). When faced with this kind of architecture,
    it becomes very very important to be able to parallelize the computation so that
    the user interface is not left waiting for a network call to complete.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`影响的另一个重要因素是分布式计算的兴起。如今，将程序构建为在多台计算机上运行的个体程序变得越来越流行。这些点对点或客户端-服务器架构很少受CPU限制，因为在网络（或互联网）上的一台计算机与另一台计算机之间通信的延迟。面对这种架构，非常重要的是能够并行化计算，以便用户界面不必等待网络调用完成。'
- en: Moving forward, software applications that take advantage of opportunities to
    use parallelism will be the ones that are superior in performance and usability.
    Many of the largest Internet companies, such as Google, are already taking advantage
    of massive parallelization, to tackle very large problems that simply would not
    be computationally possible on a single computer. The `async` keyword makes it
    so that you almost do not have to think about how and when you take advantage
    of it (almost).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，利用并行性的机会的软件应用程序将是性能和可用性上更优越的应用程序。许多最大的互联网公司，如谷歌，已经开始利用大规模并行化，以解决在单台计算机上根本无法计算的非常大的问题。`async`关键字使得你几乎不必考虑如何以及何时利用它（几乎）。
- en: Improvements in .NET 4.5 Framework
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 4.5框架的改进
- en: In addition to all of the C# 5.0 language improvements, the .NET Framework 4.5
    also brings some improvements to the table. These improvements, of course, are
    available to all .NET languages (that is, VB.NET), but as they become available
    along with C# 5.0, they warrant mention.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有C# 5.0语言的改进之外，.NET Framework 4.5还带来了一些改进。当然，这些改进对所有.NET语言（即VB.NET）都是可用的，但随着C#
    5.0一起提供，它们值得一提。
- en: TPL DataFlow
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TPL DataFlow
- en: 'One interesting newcomer to the framework is the **TPL DataFlow** library,
    which aims to improve the architecture of your applications. The NuGet description
    for the library describes the library:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 框架中一个有趣的新成员是**TPL DataFlow**库，旨在改进应用程序的架构。该库的NuGet描述如下：
- en: TPL Dataflow is a .NET Framework library for building concurrent applications.
    It promotes actor/agent-oriented designs through primitives for in-process message
    passing, dataflow, and pipelining. TDF builds upon the APIs and scheduling infrastructure
    provided by the Task Parallel Library (TPL), and integrates with the language
    support for asynchrony provided by C#.
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TPL Dataflow是一个用于构建并发应用程序的.NET框架库。它通过进程内消息传递、数据流和流水线原语来促进actor/agent导向的设计。TDF建立在任务并行库（TPL）提供的API和调度基础设施之上，并与C#提供的异步支持集成。
- en: It can be installed via NuGet by searching for TPL DataFlow, or visiting the
    NuGet site at [https://nuget.org/packages/Microsoft.Tpl.Dataflow](https://nuget.org/packages/Microsoft.Tpl.Dataflow).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过NuGet搜索TPL DataFlow或访问NuGet网站[https://nuget.org/packages/Microsoft.Tpl.Dataflow](https://nuget.org/packages/Microsoft.Tpl.Dataflow)来安装它。
- en: As stated in the description, data flow builds on top of the Task Parallel Library,
    a trend that I trust you are starting to see in this release, where the TPL, and
    by extension `async`/`await` of C# 5, help you parallelize your programs; it does
    so without any prescription of how to structure your application at a higher level.
    In contrast, the TPL DataFlow library provides various building blocks for communication
    between disparate parts of an application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如描述所述，数据流建立在任务并行库的基础上，这是一个趋势，我相信你已经在这个版本中开始看到了，其中TPL，以及C# 5的`async`/`await`，帮助你并行化你的程序；它这样做，而不会对如何构造应用程序进行任何规定。相反，TPL
    DataFlow库提供了用于在应用程序的不同部分之间进行通信的各种构建块。
- en: 'TPL DataFlow introduces two interfaces, which like `IEnumerable` are both simple
    and quite deep in their implications. The following diagram shows these interfaces:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: TPL DataFlow引入了两个接口，就像`IEnumerable`一样，它们既简单又深刻地影响着。以下图表显示了这些接口：
- en: '![TPL DataFlow](img/6761EN_03_03.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![TPL DataFlow](img/6761EN_03_03.jpg)'
- en: We start with the `ITargetBlock<T>` , which is a block of code that will process
    a number of posted messages. You will primarily interact with it by calling the
    `.Post` method to post a message to the block. The other side of the equation
    is the `ISourceBlock<T>`, which acts as a source of data. Together, these interfaces,
    and the concrete implementations that ship with the TPL DataFlow library, help
    you create applications that are structured into discrete producers, and consumers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`ITargetBlock<T>`开始，这是一段将处理多个发布消息的代码块。您主要通过调用`.Post`方法向块发布消息来与其交互。方程的另一边是`ISourceBlock<T>`，它充当数据源。这些接口以及TPL
    DataFlow库提供的具体实现一起，帮助您创建结构化为离散生产者和消费者的应用程序。
- en: ActionBlock<T>
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ActionBlock<T>
- en: 'The `ActionBlock<T>` block is the simplest implementation of the `ITargetBlock<T>`.
    It accepts a delegate in the constructor that defines what action will be taken
    when a message is posted to it. The following is how you define a simple block
    that accepts a string and writes it to the console:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionBlock<T>`块是`ITargetBlock<T>`的最简单实现。它在构造函数中接受一个委托，该委托定义了在向其发布消息时将采取的操作。以下是如何定义一个简单的块，它接受一个字符串并将其写入控制台：'
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once you have defined the block, you can start posting messages to it. The
    action block executes asynchronously, which is not a requirement, just to show
    how this implementation handles the posting of messages. Look at the following
    code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您定义了块，就可以开始向其发布消息。操作块是异步执行的，这不是必需的，只是为了展示此实现如何处理消息的发布。请查看以下代码：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here we see a very simple loop that iterates 30 times and posts a string to
    the target action. Once you have defined the target block, you can use a number
    of different implementations of source blocks that come with the TPL DataFlow
    library to create very interesting routing scenarios.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个非常简单的循环，它迭代30次并向目标操作发布一个字符串。一旦您定义了目标块，您可以使用TPL DataFlow库提供的多种不同的源块实现来创建非常有趣的路由场景。
- en: TransformBlock<T>
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TransformBlock<T>
- en: 'One such `ISourceBlock<T>` that you will find quite useful is the `TransformBlock<T,
    K>` block. As the name suggests, the transform block lets you take in one kind
    of data, and potentially transform it into another. In the following example,
    we will create two blocks; the `TransformBlock` will take an integer and convert
    it to a string. The resulting output will then be routed to `ActionBlock`, which
    accepts a string for processing. Look at the following example code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您将发现一种非常有用的`ISourceBlock<T>`是`TransformBlock<T, K>`块。顾名思义，转换块允许您接收一种数据，并可能将其转换为另一种数据。在以下示例中，我们将创建两个块；`TransformBlock`将接收一个整数并将其转换为字符串。然后生成的输出将被路由到接受字符串进行处理的`ActionBlock`。请查看以下示例代码：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Input and output types for the transform block are designated in the form of
    generic parameters. You add the action block to the end of the data flow chain
    by using the `.LinkTo` method, which directs all the output of the source block
    to the target. This is explained in the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 转换块的输入和输出类型以通用参数的形式指定。您可以使用`.LinkTo`方法将操作块添加到数据流链的末尾，该方法将源块的所有输出定向到目标块。以下是代码解释：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When you post an integer to the transform block, you will see that the message
    first flows through the transform block, and is then routed to the action block.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向转换块发布整数时，您会看到消息首先流经转换块，然后路由到操作块。
- en: BatchBlock
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BatchBlock
- en: 'Another kind of source block shown in the following diagram, which can help
    you process a stream of information, is a **batch block**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了另一种源块，它可以帮助您处理信息流，即**批处理块**：
- en: '![BatchBlock](img/6761EN_03_05.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![BatchBlock](img/6761EN_03_05.jpg)'
- en: 'Usually this kind of batch processing can be useful if there are certain costs
    associated with the processing of each message, such as informational lookups
    to a database. Many times in cases like this, you can batch up the query values
    and do a single database lookup for multiple messages at a time and amortize the
    cost of the lookup as you increase the batch size. Look at the following example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果每条消息的处理都有一定的成本，例如对数据库的信息查找，这种批处理处理可能很有用。在这种情况下，您可以批量处理查询值，并一次性对多条消息进行单个数据库查找，并随着批处理大小的增加摊销查找成本。请查看以下示例：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can think of the batch block as a specific kind of transform block that
    takes a single instance of a message in the frontend, waits until a specified
    number of these messages have arrived, and then delivers that group as an array
    to the target block. This can be useful when you have a system that has to do
    some setup, such as looking up reference data for every message that it receives.
    If you can process many messages in one batch, then the cost of the initialization
    can be amortized over time. The more messages you process, the lower the cost.
    The following example shows how this is achieved:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将批处理块视为特定类型的转换块，该转换块在前端接收单个消息实例，等待到达指定数量的这些消息，然后将该组作为数组传递到目标块。当您的系统必须为接收到的每条消息查找参考数据等设置时，这可能很有用。如果您可以一次处理多条消息，则初始化成本可以随时间摊销。您处理的消息越多，成本越低。以下示例显示了如何实现这一点：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can also manually trigger a batch if you know that the threshold number
    of messages has not been reached. In this way, you can process a batch of a smaller
    size if your system has to process a message within a certain amount of time.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道尚未达到阈值消息数量，还可以手动触发批处理。通过这种方式，如果您的系统必须在一定时间内处理消息，您可以处理较小大小的批处理。
- en: BroadcastBlock
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BroadcastBlock
- en: 'The broadcast block shown in the following diagram is an interesting source
    block:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示的广播块是一个有趣的源块：
- en: '![BroadcastBlock](img/6761EN_03_06.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![BroadcastBlock](img/6761EN_03_06.jpg)'
- en: 'The way it works is that you can link multiple target blocks to the broadcaster.
    When a message is posted to the broadcaster, it will diligently be delivered to
    every target. One obvious application of this block is to write a server application
    that has to service multiple clients at the same time. Each client is then represented
    by a target block that gets linked to the broadcaster. Whenever you need to notify
    every client, you can just post a message to the broadcaster. Look at the following
    example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式是，您可以将多个目标块链接到广播器。当消息发布到广播器时，它将被传递到每个目标。这个块的一个明显的应用是编写一个必须同时为多个客户端提供服务的服务器应用程序。然后，每个客户端由一个目标块表示，该目标块链接到广播器。每当您需要通知每个客户端时，您只需将消息发布到广播器。看下面的例子：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, we link four separate action blocks. When we post **value posted**,
    we will see four separate verifications of receipt in the console output. In a
    way, this is very similar to the existing event system in the C# language.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们链接了四个单独的动作块。当我们发布**value posted**时，我们将在控制台输出中看到四个单独的接收验证。在某种程度上，这与C#语言中现有的事件系统非常相似。
- en: Async I/O
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步I/O
- en: To take advantage of the new `async`/`await` features, some very core features
    of the .NET Framework have evolved. Namely, the I/O features including streams,
    network, and file operations. This is huge because, as mentioned previously, I/O
    bound operations are coming to dominate the execution time of a modern application.
    So any improvements in the API to deal with those operations can be seen as a
    good sign.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用新的`async`/`await`功能，.NET Framework的一些核心功能已经发展。即，包括流、网络和文件操作在内的I/O功能。这是巨大的，因为如前所述，I/O绑定操作正在主导现代应用程序的执行时间。因此，API中对这些操作的任何改进都可以视为一个好迹象。
- en: At the lowest level are additions to the `Stream` API. Since .NET 1.0, this
    has been one of my favorite abstractions because it can be used in so many different
    ways. Reading and writing to a file, or a network socket, or a database, all use
    the stream API to represent a series of bytes of unknown size. Of course, the
    limiting factor here has been that, depending on the stream implementation that
    you are using, the performance and latency can vary greatly. So you should not
    write code to a network stream in the same way as code that is written to an in-memory
    stream, because the performance will be vastly different.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低级别上是对`Stream` API的添加。自.NET 1.0以来，这一直是我最喜欢的抽象之一，因为它可以以多种不同的方式使用。读写文件、网络套接字或数据库，都使用流API来表示未知大小的一系列字节。当然，这里的限制因素是，根据您使用的流实现，性能和延迟可能会有很大的变化。因此，您不应该像编写写入内存流的代码那样编写网络流的代码，因为性能会有很大的不同。
- en: 'With `async` though, this changes because the `Stream` class has received new
    awaitable versions of all of the methods in the class. In the following example,
    we write an asynchronous method that takes a set of numbers, and writes them to
    a string as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过`async`，这种情况发生了变化，因为`Stream`类已经收到了该类所有方法的新的可等待版本。在下面的例子中，我们编写了一个异步方法，该方法接受一组数字，并将它们写入字符串，如下所示：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Although code like this would have been possible to write in a similar fashion
    before, the addition of methods like `.WriteLineAsync` lets you write code that
    is simple without having to worry about the stream holding up execution of the
    calling thread.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在以前可能以类似的方式编写这样的代码，但是像`.WriteLineAsync`这样的方法的添加使您可以编写简单的代码，而无需担心流阻塞调用线程的执行。
- en: 'Because of the underlying improvements in the stream API, other areas, such
    as reading and writing files have improved. Look at the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于流API的基础改进，其他领域，如读写文件，也有所改进。看下面的代码：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I honestly cannot tell you how many times I have seen variations of this method
    over the years, of course, written in a non-asynchronous way. Without asynchrony,
    this method would absolutely choke if you attempted to read a very large file.
    A perfect example of this is the Notepad application that has come with every
    version of Windows. If you try to open a very large file, be prepared to wait
    because the interface will be frozen while the file is streamed from the disk.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，多年来我看到了这种方法的变体，当然，是以非异步方式编写的。没有异步性，如果您尝试读取一个非常大的文件，这种方法绝对会崩溃。一个很好的例子是随每个Windows版本一起提供的记事本应用程序。如果您尝试打开一个非常大的文件，准备等待，因为界面将在文件从磁盘流出时被冻结。
- en: But with the asynchronous version here, the interface will not be bogged down,
    regardless of the size of the file. That is the great feature of `async`, it accepts
    the kind of code developers are likely to write, and makes it so that common performance
    issues, such as buffering, will not affect the performance of the application
    quite as much. This is a perfect example of the "Pit of Success".
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在这里的异步版本中，接口不会被拖慢，无论文件的大小如何。这就是`async`的伟大特性，它接受开发人员可能编写的代码，并使得常见的性能问题，如缓冲，不会对应用程序的性能产生太大影响。这是“成功之坑”的完美例子。
- en: Caller attributes
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用者属性
- en: 'One of the only non-async related improvements are **caller attributes**. In
    Java, there is a very common convention, which has made you specify a class level
    static variable called `TAG` that would contain some useful string identifier
    for this class as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一与异步无关的改进之一是**调用者属性**。在Java中，有一个非常常见的约定，即您必须指定一个名为`TAG`的类级静态变量，该变量将包含该类的一些有用的字符串标识符，如下所示：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Anytime you want to write information to the system log (`logcat`), you can
    just use the `TAG` variable so that you can easily identify the information in
    the log output as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您想要将信息写入系统日志（`logcat`）时，您只需使用`TAG`变量，以便您可以轻松地在日志输出中识别信息，如下所示：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So anytime you need to log something, the caller is responsible for self-reporting
    the metadata about where and why this was logged. Of course, the need to have
    metadata such as this for logging reaches across languages, so the C# language
    designers finally added a nice little feature to help you out here.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所以任何时候你需要记录一些东西，调用者负责自行报告关于何时何地以及为什么记录这些日志的元数据。当然，对于日志记录这样的元数据的需求跨越了语言，因此C#语言设计者最终添加了一个很好的小功能来帮助你。
- en: C# has always had a very powerful reflection system, so it has always been possible
    to take a look at the stack information in a log method. This simplifies log calls
    because the caller does not have to do anything special. However, this method
    was prone to returning unexpected results when an application was compiled in
    release mode, because of compiler optimizations. Also, some of the relevant classes
    have been excluded in portable libraries.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: C#一直拥有非常强大的反射系统，因此一直可以查看日志方法中的堆栈信息。这简化了日志调用，因为调用者不必做任何特殊处理。然而，当应用程序在发布模式下编译时，这种方法容易返回意外结果，因为编译器进行了优化。此外，一些相关的类已经在可移植库中被排除。
- en: 'You can now add some compiler-optimized parameters to log methods in C# 5\.
    When you call the method, the compiler will insert the appropriate metadata so
    that the correct values are returned at runtime, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在C# 5中的日志方法中添加一些经过编译器优化的参数。当你调用该方法时，编译器将插入适当的元数据，以便在运行时返回正确的值，如下所示：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following are two other attributes that you can use:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另外两个你可以使用的属性：
- en: '`[CallerFilePath]`: This gives you the path of the file in which the caller
    resides'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[CallerFilePath]`：这给出了调用者所在文件的路径'
- en: '`[CallerLineNumber]`: This is the exact line number that the method was called
    from'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[CallerLineNumber]`：这是方法被调用的确切行号'
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we explored the world of asynchronous programming in C# 5
    and learned the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了C# 5中的异步编程世界，并学到了以下内容：
- en: Asynchrony in software, and by extension, concurrency, is the key through which
    optimal performance can be unlocked.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件中的异步性，以及由此延伸的并发性，是实现最佳性能的关键。
- en: Task Parallel Library is the fundamental building block for all of the new asynchronous
    programming features. Achieving a deep understanding of the TPL will prove quite
    useful.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务并行库是所有新的异步编程特性的基本构建块。深入理解TPL将非常有用。
- en: C# 5.0 language has support for easy async, quite easily one of the most significant
    upgrades to the language. It builds on the TPL to make it simple to build responsive
    and performant applications.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 5.0语言支持简单的异步，这很容易成为该语言最重要的升级之一。它建立在TPL的基础上，使构建响应迅速且性能良好的应用程序变得简单。
- en: TPL DataFlow provides higher level abstractions for agent-based asynchronous
    programming that can help you create easy-to-maintain programs.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TPL DataFlow为基于代理的异步编程提供了更高级别的抽象，可以帮助你创建易于维护的程序。
- en: Framework improvements that take advantage of the new asynchrony features, such
    as improvements to the I/O APIs, help you take advantage of the world of distributed
    computing.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用新的异步特性的框架改进，比如改进的I/O API，可以帮助你充分利用分布式计算的世界。
- en: Going forward, I believe that these features will make it very easy to write
    fast, bug-free, and maintainable programs with C#. The concepts covered here can
    serve as a reference for the rest of the material in this book.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，我相信这些特性将使使用C#编写快速、无bug且易于维护的程序变得非常容易。这里涵盖的概念可以作为本书其余材料的参考。
