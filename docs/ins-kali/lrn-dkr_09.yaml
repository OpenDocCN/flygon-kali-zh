- en: Using Docker to Supercharge Automation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker来加速自动化
- en: In the last chapter, we introduced techniques commonly used to allow a developer
    to evolve, modify, debug, and test their code while running in a container. We
    also learned how to instrument applications so that they generate logging information
    that can help us to do root cause analysis of failures or misbehaviors of applications
    or application services that are running in production.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了通常用于允许开发人员在容器中演变、修改、调试和测试其代码的技术。我们还学习了如何对应用程序进行工具化，以便它们生成日志信息，这些信息可以帮助我们对在生产环境中运行的应用程序或应用服务的故障或异常行为进行根本原因分析。
- en: In this chapter, we will show how you can use tools to perform administrative
    tasks without having to install those tools on the host computer. We will also
    illustrate the use of containers that host and run test scripts or code used to
    test and validate application services running in containers. Finally, we will
    guide the reader through the task of building a simple Docker-based CI/CD pipeline.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示如何使用工具执行管理任务，而无需在主机计算机上安装这些工具。我们还将说明托管和运行测试脚本或代码的容器，用于测试和验证在容器中运行的应用服务。最后，我们将指导读者构建一个基于Docker的简单CI/CD流水线。
- en: 'This is a quick overview of all of the subjects we are going to touch on in
    this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章中我们将涉及的所有主题的快速概述：
- en: Executing simple admin tasks in a container
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中执行简单的管理员任务
- en: Using test containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试容器
- en: Using Docker to power a CI/CD pipeline
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker来驱动CI/CD流水线
- en: 'After finishing this chapter, you will be able to do the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将能够执行以下操作：
- en: Run a tool not available on the host in a container
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行主机上不可用的工具
- en: Use a container to run test scripts or code against an application service
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器来运行测试脚本或代码来对应用服务进行测试
- en: Build a simple CI/CD pipeline using Docker
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker构建一个简单的CI/CD流水线
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this section, if you want to follow along with the code, you need Docker
    for Desktop on your macOS or Windows machine and a code editor, preferably Visual
    Studio Code. The sample will also work on a Linux machine with Docker and VS Code
    installed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，如果您想跟着代码进行操作，您需要在macOS或Windows机器上安装Docker for Desktop和一个代码编辑器，最好是Visual
    Studio Code。该示例也适用于安装了Docker和VS Code的Linux机器。
- en: Executing simple admin tasks in a container
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中执行简单的管理员任务
- en: 'Let''s assume you need to strip all leading whitespaces from a file and you
    found the following handy Perl script to do exactly that:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要从文件中删除所有前导空格，并且您找到了以下方便的Perl脚本来做到这一点：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As it turns out, you don''t have Perl installed on your working machine. What
    can you do? Install Perl on the machine? Well, that would certainly be an option,
    and it''s exactly what most developers or system admins do. But wait a second,
    you already have Docker installed on your machine. Can''t we use Docker to circumvent
    the need to install Perl? Yes, we can. This is how we''re going to do it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，您的工作机器上没有安装Perl。你能做什么？在机器上安装Perl吗？嗯，这当然是一个选择，这也是大多数开发人员或系统管理员所做的。但等一下，您已经在机器上安装了Docker。我们不能使用Docker来规避安装Perl的需要吗？是的，我们可以。这就是我们要做的：
- en: 'Create a folder, `ch07/simple-task`, and navigate to it:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ch07/simple-task`的文件夹，并导航到它：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open VS Code from within this folder:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个文件夹中打开VS Code：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this folder, create a `sample.txt` file with the following content:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹中，创建一个名为`sample.txt`的文件，内容如下：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Please note the whitespaces at the beginning of each line. Save the file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意每行开头的空格。保存文件。
- en: 'Now, we can run a container with Perl installed in it. Thankfully, there is
    an official Perl image on Docker Hub. We are going to use the slim version of
    the image:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行一个安装了 Perl 的容器。幸运的是，Docker Hub 上有一个官方的 Perl 镜像。我们将使用镜像的 slim 版本：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding command runs a Perl container (`perl:slim`) interactively, maps
    the content of the current folder into the `/usr/src/app` folder of the container,
    and sets the working folder inside the container to `/usr/src/app`. The command
    that is run inside the container is `sh -c "cat sample.txt | perl -lpe 's/^\s*//'"`,
    basically spawning a Bourne shell and executing our desired Perl command.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令以交互方式运行了一个 Perl 容器（`perl:slim`），将当前文件夹的内容映射到容器的`/usr/src/app`文件夹，并将容器内的工作文件夹设置为`/usr/src/app`。在容器内运行的命令是`sh
    -c "cat sample.txt | perl -lpe 's/^\s*//'"`，基本上是生成一个 Bourne shell 并执行我们想要的 Perl
    命令。
- en: 'The output generated by the preceding command should look like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令生成的输出应该如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Without needing to install Perl on our machine, we were able to achieve our
    goal.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无需在我们的机器上安装 Perl，我们就能实现我们的目标。
- en: 'If that doesn''t convince you yet because if you''re on macOS, you already
    have Perl installed, then consider you''re looking into running a Perl script
    named `your-old-perl-script.pl` that is old and not compatible with the newest
    release of Perl that you happen to have installed on your system. Do you try to
    install multiple versions of Perl on your machine and potentially break something?
    No, you just run a container with the (old) version of Perl that is compatible
    with your script, as in this example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不能说服你，因为如果你在 macOS 上，你已经安装了 Perl，那么请考虑一下，你想要运行一个名为`your-old-perl-script.pl`的
    Perl 脚本，它是旧的，不兼容你系统上已安装的最新版本的 Perl。你会尝试在你的机器上安装多个版本的 Perl 并可能破坏一些东西吗？不，你只需运行一个与你的脚本兼容的（旧）Perl
    版本的容器，就像这个例子：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `<old-version>` corresponds to the tag of the version of Perl that you
    need to run your script. The nice thing is that, after the script has run, the
    container is removed from your system without leaving any traces because we used
    the `--rm` flag in the `docker container run` command.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<old-version>`对应于你需要运行你的脚本的 Perl 版本的标签。好处是，脚本运行后，容器将从你的系统中删除，不会留下任何痕迹，因为我们在`docker
    container run`命令中使用了`--rm`标志。
- en: 'A lot of people use quick and dirty Python scripts or mini apps to automate
    tasks that are not easily coded with, say, Bash. Now if the Python script has
    been written in Python 3.7 and you only happen to have Python 2.7 installed, or
    no version at all on your machine, then the easiest solution is to execute the
    script inside a container. Let''s assume a simple example where the Python script
    counts lines, words, and letters in a given file and outputs the result to the
    console:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人使用快速而简单的 Python 脚本或迷你应用程序来自动化一些无法用 Bash 等编码的任务。现在，如果 Python 脚本是用 Python 3.7
    编写的，而你只安装了 Python 2.7，或者根本没有在你的机器上安装任何版本，那么最简单的解决方案就是在容器内执行脚本。让我们假设一个简单的例子，Python
    脚本统计给定文件中的行数、单词数和字母数，并将结果输出到控制台：
- en: 'Still in the `ch07/simple-task` folder add a `stats.py` file and add the following
    content:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ch07/simple-task`文件夹中添加一个`stats.py`文件，并添加以下内容：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After saving the file, you can run it with the following command:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件后，您可以使用以下命令运行它：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that, in this example, we are reusing the `sample.txt` file from before.
    The output in my case is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，我们重用了之前的`sample.txt`文件。在我的情况下，输出如下：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The beauty of this approach is that this Python script will now run on any computer
    with any OS installed, as long as the machine is a Docker host and, hence, can
    run containers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的美妙之处在于，这个 Python 脚本现在可以在任何安装了任何操作系统的计算机上运行，只要这台机器是一个 Docker 主机，因此可以运行容器。
- en: Using test containers
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试容器
- en: 'For each serious software project out there, it is highly recommended to have
    plenty of tests in place. There are various test categories such as unit tests,
    integration tests, stress and load tests, and end-to-end tests. I have tried to
    visualize the different categories in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个严肃的软件项目，强烈建议进行大量的测试。有各种测试类别，如单元测试、集成测试、压力和负载测试以及端到端测试。我尝试在以下截图中可视化不同的类别：
- en: '![](assets/f5d017fc-0214-43d4-9c0a-a701c9731c84.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f5d017fc-0214-43d4-9c0a-a701c9731c84.png)'
- en: Categories of application tests
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序测试的类别
- en: Unit tests assert the correctness and quality of an individual, isolated piece
    of the overall application or application service. Integration tests make sure
    that pieces that are closely related work together as expected. Stress and load
    tests often take the application or service as a whole and assert a correct behavior
    under various edge cases such as high load through multiple concurrent requests
    handled by the service, or by flooding the service with a huge amount of data.
    Finally, end-to-end tests simulate a real user working with the application or
    application service. The typical tasks that a user would do are automated.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试断言整体应用程序或应用程序服务中的单个、孤立部分的正确性和质量。集成测试确保紧密相关的部分按预期工作在一起。压力和负载测试通常将应用程序或服务作为整体，并断言在各种边缘情况下的正确行为，例如通过服务处理的多个并发请求的高负载，或通过向服务发送大量数据来淹没服务。最后，端到端测试模拟真实用户与应用程序或应用程序服务的工作。用户通常会执行的任务被自动化。
- en: The code or component under test is often called a **System Under Test** (**SUT**).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 受测试的代码或组件通常被称为**系统测试对象**（**SUT**）。
- en: Unit tests are in their nature tightly coupled to the actual code or SUT. It
    is, hence, necessary that those tests run in the same context as the code under
    test. Hence, the test code lives in the same container as the SUT. All external
    dependencies of the SUT are either mocked or stubbed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在其性质上与实际代码或SUT紧密耦合。因此，这些测试必须在与受测试代码相同的上下文中运行。因此，测试代码与SUT位于同一容器中。SUT的所有外部依赖项都是模拟的或存根的。
- en: 'Integration tests, stress and load tests, and end-to-end tests, on the other
    hand, act on public interfaces of the system under test and it is, hence, most
    common to run that test code in a separate container:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，集成测试、压力和负载测试以及端到端测试作用于系统测试对象的公共接口，因此最常见的是在单独的容器中运行测试代码：
- en: '![](assets/3e2a02c0-87e7-412b-b912-4060b337280f.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3e2a02c0-87e7-412b-b912-4060b337280f.png)'
- en: Integration tests using containers
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器的集成测试
- en: In the preceding diagram, we can see the **Test Code** running in its own **Test
    Container**. The **Test Code** accesses the public interface of the **API** component
    that also runs in a dedicated container. The **API** component has external dependencies
    such as **Other** **Service** and **Database** that each run in their dedicated
    container. In this case, the whole ensemble of **API**, **Other** **Service**, and
    **Database **is our system under test, or SUT.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到**测试代码**在其自己的**测试容器**中运行。**测试代码**访问也在专用容器中运行的**API**组件的公共接口。**API**组件具有外部依赖，如**其他**
    **服务**和**数据库**，它们分别在其专用容器中运行。在这种情况下，**API**，**其他** **服务**和**数据库**的整个集合是我们的系统测试对象，或SUT。
- en: 'What exactly would stress and load tests look like? Imagine a situation where
    we have a Kafka Streams application we want to put under test. The following diagram
    gives an idea of what exactly we could test, from a high level:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 压力和负载测试会是什么样子？想象一种情况，我们有一个Kafka Streams应用程序需要进行测试。以下图表给出了我们可以从高层次上测试的具体内容：
- en: '![](assets/7b928ee2-e7df-4a26-9c6c-1504683653ee.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7b928ee2-e7df-4a26-9c6c-1504683653ee.png)'
- en: Stress and load test a Kafka Streams application
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 压力和负载测试Kafka Streams应用程序
- en: 'In a nutshell, a **Kafka Streams application** consumes data from one or more
    topics stored in Apache Kafka(R). The application filters, transforms, or aggregates
    the data. The resulting data is written back to one or several topics in Kafka.
    Typically, when working with Kafka, we deal with real-time data streaming into
    Kafka. Tests could now simulate the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**Kafka Streams应用程序**从存储在Apache Kafka(R)中的一个或多个主题中消费数据。该应用程序过滤、转换或聚合数据。结果数据被写回Kafka中的一个或多个主题。通常，在使用Kafka时，我们处理实时数据流入Kafka。现在测试可以模拟以下情况：
- en: Large topics with a huge amount of records
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量记录的大型主题
- en: Data flowing into Kafka with a very high frequency
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据以非常高的频率流入Kafka
- en: Data being grouped by the application under test, where there is a lot of distinct
    keys, each one with low cardinality
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序在测试下分组的数据，其中有很多不同的键，每个键的基数很低
- en: Data aggregated by time windows where the size of the window is small, for example, each only
    a few seconds long
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按时间窗口聚合的数据，窗口的大小很小，例如，每个窗口只有几秒钟
- en: End-to-end tests automate the users that interact with an application by the
    use of tools such as the Selenium Web Driver, which provides a developer means
    to automate actions on a given web page such as filling out fields in a form or
    clicking buttons.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试通过使用诸如Selenium Web Driver之类的工具自动化与应用程序交互的用户，该工具提供了开发者手段来自动执行给定网页上的操作，例如填写表单字段或点击按钮。
- en: Integration tests for a Node.js application
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js应用程序的集成测试
- en: 'Let''s now have a look at a sample integration test implemented in Node.js.
    Here is the setup that we are going to look into:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个在Node.js中实现的样本集成测试。这是我们将要研究的设置：
- en: '![](assets/b2695574-24aa-48e3-9760-f0ab1e9e8247.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b2695574-24aa-48e3-9760-f0ab1e9e8247.png)'
- en: Integration tests for an Express JS Application
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Express JS应用程序的集成测试
- en: 'Following are the steps to create such an integration test:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建这样一个集成测试的步骤：
- en: 'Let''s first prepare our project folder structure. We create the project root
    and navigate to it:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先准备我们的项目文件夹结构。我们创建项目根目录并导航到它：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Within this folder, we create three subfolders, `tests`, `api`, and `database`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹中，我们创建三个子文件夹，`tests`，`api`和`database`：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we open VS Code from the project root:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们从项目根目录打开VS Code：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To the `database` folder, add an `init-script.sql` file with the following
    content:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`database`文件夹中，添加一个`init-script.sql`文件，内容如下：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding script will create a `hobbies` table in our Postgres database
    that we are going to use and fill it with some seed data. Save the file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本将在我们的Postgres数据库中创建一个`hobbies`表，并填充一些种子数据。保存文件。
- en: 'Now we can start the database. Of course, we are going to use the official
    Docker image for Postgres to run the database in a container. But first, we will
    create a Docker volume where the database will store its files. We will call the
    volume `pg-data`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以启动数据库。当然，我们将使用官方的Docker镜像来运行Postgres数据库。但首先，我们将创建一个Docker卷，数据库将在其中存储其文件。我们将称该卷为`pg-data`：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, it''s time to run the database container. From within the project root
    folder (`integration-test-node`), run the following:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候运行数据库容器了。从项目根目录（`integration-test-node`）中运行以下命令：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the folder from which you run the preceding command matters, due to
    the volume mounting we are using for the database initialization script, `init-script.sql`.
    Also note that we are using environment variables to define the name and user
    of the database in Postgres, and we are mapping port `5432` of Postgres to the
    equivalent port on our host machine.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，运行上述命令的文件夹很重要，因为我们在数据库初始化脚本`init-script.sql`中使用了卷挂载。还要注意，我们正在使用环境变量来定义Postgres中数据库的名称和用户，并且我们正在将Postgres的端口`5432`映射到主机上的等效端口。
- en: 'After you have started the database container, double-check that it runs as
    expected by retrieving its logs:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动数据库容器后，通过检索其日志来双重检查它是否按预期运行：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see something similar to this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似于这样的东西：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note, we have shortened the output for better readability. The important parts
    of the preceding output are the first few lines, where we can see that the database
    has picked up our initialization script, created the `hobbies` table and seeded
    it with five records. Also important is the last line, telling us that the database
    is ready to work. The container logs are always your first stop when troubleshooting
    problems!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经缩短了输出以便更好地阅读。前面输出的重要部分是前几行，我们可以看到数据库已经接受了我们的初始化脚本，创建了`hobbies`表并用五条记录进行了填充。最后一行也很重要，告诉我们数据库已经准备好工作。当解决问题时，容器日志总是你的第一站！
- en: 'With that, our first piece of the SUT is ready. Let''s move on to the next
    one, which is our API implemented in Express JS:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的SUT的第一部分就准备好了。让我们继续下一个部分，也就是我们在Express JS中实现的API：
- en: 'In the Terminal window, navigate to the `api` folder:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，导航到`api`文件夹：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, run `npm init` to initialize the API project. Just accept all defaults:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行`npm init`来初始化API项目。只接受所有默认值：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The resulting `package.json` file should look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`package.json`文件应该是这样的：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Modify the `scripts` node of the preceding file so that it contains a start
    command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改上述文件的`scripts`节点，使其包含一个启动命令：
- en: '![](assets/6c851736-d5d7-4656-b565-8666cd016cf8.png) Adding a start script
    to the package.json file'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6c851736-d5d7-4656-b565-8666cd016cf8.png) 在package.json文件中添加一个启动脚本'
- en: 'We then have to install Express JS and can do so with the following command:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要安装Express JS，可以使用以下命令来完成：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will install the library and all of its dependencies and add a dependencies node to
    our `package.json` file that looks similar to this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装库及其所有依赖项，并在我们的`package.json`文件中添加一个类似于这样的依赖项节点：
- en: '![](assets/6d01c027-f5be-4de4-be22-57af5ff422e0.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6d01c027-f5be-4de4-be22-57af5ff422e0.png)'
- en: Adding Express JS as a dependency to the API
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将Express JS添加为API的依赖项
- en: 'In the `api` folder, create a `server.js` file and add the following code snippet:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`api`文件夹中，创建一个`server.js`文件，并添加以下代码片段：
- en: '![](assets/55518a75-754f-4ef7-98bf-e93eb73332a7.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/55518a75-754f-4ef7-98bf-e93eb73332a7.png)'
- en: Simple Express JS API
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的Express JS API
- en: This is a simple Express JS API with only the `/` endpoint implemented. It serves
    as a starting point for our exploration into integration testing. Note that the
    API will be listening at port `3000`, on all endpoints inside the container (`0.0.0.0`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的Express JS API，只实现了`/`端点。它作为我们探索集成测试的起点。请注意，API将在端口`3000`上监听，在容器内的所有端点(`0.0.0.0`)。
- en: 'Now we can start the API with `npm start` and then test the home endpoint,
    for example, with `curl`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`npm start`启动API，然后使用`curl`测试主页端点，例如：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After all of these steps, we're ready to scaffold the test environment.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些步骤，我们已经准备好搭建测试环境了。
- en: 'We will be using `jasmine` to write our tests. Navigate to the `tests` folder
    and run `npm init` to initialize the test project:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`jasmine`来编写我们的测试。导航到`tests`文件夹并运行`npm init`来初始化测试项目：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Accept all of the defaults.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接受所有默认值。
- en: 'Next, add `jasmine` to the project:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`jasmine`添加到项目中：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then initialize `jasmine` for this project:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后为这个项目初始化`jasmine`：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also need to change our `package.json` file so that the scripts block looks
    like this:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要更改我们的`package.json`文件，使得脚本块看起来像这样：
- en: '![](assets/f06ce569-69d4-47ab-9346-700ec2fa8eaf.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f06ce569-69d4-47ab-9346-700ec2fa8eaf.png)'
- en: Adding a test script for our integration tests
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的集成测试添加一个测试脚本
- en: 'We cannot run the tests any time by executing `npm test` from within the `tests`
    folder. The first time we run it, we will get an error since we have not yet added
    any tests:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能随时通过在`tests`文件夹中执行`npm test`来运行测试。第一次运行时，我们会收到错误提示，因为我们还没有添加任何测试：
- en: '![](assets/fa888ef5-069b-4297-a38e-2af3a671686c.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fa888ef5-069b-4297-a38e-2af3a671686c.png)'
- en: The first run fails since no tests were found
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行失败，因为没有找到测试
- en: 'Now in the `spec/support` subfolder of the project, let''s create a `jasmine.json` file.
    This will contain the configuration settings for the `jasmine` test framework.
    Add the following code snippet to this file and save:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在项目的`spec/support`子文件夹中，让我们创建一个`jasmine.json`文件。这将包含`jasmine`测试框架的配置设置。将以下代码片段添加到此文件并保存：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since we are going to author integration tests we will want to access the SUT
    via its public interface, which, in our case, is a RESTful API. Hence, we need
    a client library that allows us to do so. My choice is the Requests library. Let''s
    add it to our project:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将要编写集成测试，我们希望通过其公共接口访问SUT，而在我们的情况下，这是一个RESTful API。因此，我们需要一个客户端库来允许我们这样做。我的选择是Requests库。让我们将其添加到我们的项目中：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add an `api-spec.js` file to the `spec` subfolder of the project. It will contain
    our test functions. Let''s start with the first one:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的`spec`子文件夹中添加一个`api-spec.js`文件。它将包含我们的测试函数。让我们从第一个开始：
- en: '![](assets/6f2f86bd-53a7-4447-ac3d-171f7955d2de.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6f2f86bd-53a7-4447-ac3d-171f7955d2de.png)'
- en: Sample test suite for the API
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: API的示例测试套件
- en: We are using the `request` library to make RESTful calls to our API (line `1`).
    Then, on line `3`, we're defining the base URL on which the API is listening.
    Note, the code that we use allows us to override the default of `http://localhost:3000`
    with whatever we define in an environment variable called `BASE_URL`. Line `5`
    defines our test suite, which, on line `6`, has a test for `GET /`. We then assert
    two outcomes, namely that the status code of a `GET` call to `/` is `200` (OK)
    and that the text returned in the body of the response is equal to `Sample API`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`request`库来对我们的API进行RESTful调用（第1行）。然后，在第3行，我们定义了API正在监听的基本URL。请注意，我们使用的代码允许我们使用环境变量`BASE_URL`来覆盖默认的`http://localhost:3000`。第5行定义了我们的测试套件，第6行有一个`GET
    /`的测试。然后我们断言两个结果，即`GET`调用`/`的状态码为`200`（OK），并且响应主体中返回的文本等于`Sample API`。
- en: 'If we run the test now, we get the following outcome:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在运行测试，将得到以下结果：
- en: '![](assets/11d9290c-3d06-4c15-84ac-ae664f87ad9b.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/11d9290c-3d06-4c15-84ac-ae664f87ad9b.png)'
- en: Successfully running Jasmine-based integration tests
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 成功运行基于Jasmine的集成测试
- en: We have two specifications—another word for tests—running; all of them are successful
    since we have zero failures reported.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个规范——测试的另一个词——正在运行；所有这些都是成功的，因为我们没有报告任何失败。
- en: Before we continue, please stop the API and remove the Postgres container with
    `docker container rm -f postgres`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，请停止API并使用`docker container rm -f postgres`删除Postgres容器。
- en: 'So far so good, but now let''s bring containers to the table. That''s what
    we are most excited about, isn''t it? We''re excited to run everything, including
    test code in containers. If you recall, we are going to deal with three containers,
    the database, the API, and the container with the test code. For the database,
    we are just using the standard Postgres Docker image, but, for the API and tests,
    we will create our own images:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，但现在让我们把容器引入讨论。这是我们最感兴趣的部分，不是吗？我们很兴奋地运行所有东西，包括容器中的测试代码。如果你还记得，我们将处理三个容器，数据库、API和包含测试代码的容器。对于数据库，我们只是使用标准的Postgres
    Docker镜像，但是对于API和测试，我们将创建自己的镜像：
- en: 'Let''s start with the API. To the `api` folder, add a `Dockerfile` file with
    this content:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从API开始。在`api`文件夹中，添加一个`Dockerfile`文件，内容如下：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is just a very standard way of creating a container image for a Node.js
    based application. There's nothing special here.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是创建一个基于Node.js的应用程序的容器镜像的非常标准的方法。这里没有什么特别的。
- en: 'To the `tests` folder, also add a Dockerfile with this content:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`tests`文件夹中添加一个具有以下内容的Dockerfile：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we''re ready to run all three containers, in the right sequence. To simplify
    this task, let''s create a shell script that does exactly that. Add a `test.sh` file to
    the `integration-test-node` folder, our project root folder. Add the following
    content to this file and save:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备按正确的顺序运行所有三个容器。为了简化这个任务，让我们创建一个shell脚本来做到这一点。将`test.sh`文件添加到`integration-test-node`文件夹中，我们的项目根文件夹。将以下内容添加到这个文件中并保存：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: On the first two lines of the script, we make sure that the two container images
    for API and tests are built with the newest code. Then, we create a Docker network
    called `test-net` on which we will run all three containers. Don't worry about
    the details of this as we will explain networks in detail in [Chapter 10](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml),
    *Single Host Networking*. For the moment, suffice to say that if all containers
    run on the same network, then the applications running inside those containers
    can see each other as if they were running natively on the host, and they can
    call each other by name.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的前两行，我们确保API和测试的两个容器镜像都使用最新的代码构建。然后，我们创建一个名为`test-net`的Docker网络，我们将在这个网络上运行所有三个容器。暂时不用担心这个的细节，因为我们将在[第10章](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml)中详细解释网络，*单主机网络*。暂且可以说，如果所有容器都在同一个网络上运行，那么在这些容器内运行的应用程序可以像在主机上本地运行一样看到彼此，并且它们可以通过名称相互调用。
- en: The next command starts the database container, followed by the command that
    starts the API. Then, we pause for a few seconds to give the database and the
    API time to completely start up and initialize, before we start the third and
    final container, the tests container.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令启动数据库容器，然后是启动API的命令。然后，我们暂停几秒钟，让数据库和API完全启动和初始化，然后我们启动第三个和最后一个容器，即测试容器。
- en: 'Make this file an executable with the following:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将此文件设置为可执行文件：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now you can run it:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以运行它：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If everything works as expected, you should see something along these lines
    (shortened for readability):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期运行，你应该看到类似以下内容的东西（为了便于阅读而缩短）：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can also create a script that cleans up after testing. For this, add a file
    called `cleanup.sh` and make it an executable the same way as you''ve done with
    the `test.sh` script. Add the following code snippet to this file:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以创建一个在测试后进行清理的脚本。为此，添加一个名为`cleanup.sh`的文件，并以与`test.sh`脚本相同的方式将其设置为可执行文件。将以下代码片段添加到这个文件中：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Line one removes the `postgres` and `api` containers. Line 2 removes the network
    we used for the third container, and finally, line 3 removes the volume used by
    Postgres. After each test run, execute this file with `./cleanup.sh`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行删除`postgres`和`api`容器。第2行删除我们用于第三个容器的网络，最后，第3行删除Postgres使用的卷。在每次测试运行后，使用`./cleanup.sh`执行此文件。
- en: Now you can start adding more code to your API component and more integration
    tests. Each time you want to test new or modified code, just run the `test.sh`
    script.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以开始向你的API组件添加更多的代码和更多的集成测试。每次你想要测试新的或修改过的代码，只需运行`test.sh`脚本。
- en: 'Challenge: How can you optimize this process further, so that fewer manual
    steps are required?'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战：你如何进一步优化这个过程，以便需要更少的手动步骤？
- en: Use what we have learned in [Chapter 6](b6647803-2c5c-4b9d-9a4a-a836ac356329.xhtml),
    *Debugging Code Running in Containers*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在[第6章](b6647803-2c5c-4b9d-9a4a-a836ac356329.xhtml)中学到的内容，*在容器中运行代码调试*。
- en: The Testcontainers project
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Testcontainers项目
- en: 'If you''re a Java developer, then there is a nice project called Testcontainers
    ([https://testcontainers.org](https://testcontainers.org)). In their own words,
    the project can be summarized as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Java开发人员，那么有一个名为Testcontainers的不错的项目（[https://testcontainers.org](https://testcontainers.org)）。用他们自己的话来说，该项目可以总结如下：
- en: '"Testcontainers is a Java library that supports JUnit tests, providing lightweight,
    throwaway instances of common databases, Selenium web browsers, or anything else
    that can run in  Docker container."To experiment with Testcontainer follow along:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '"Testcontainers是一个支持JUnit测试的Java库，提供常见数据库、Selenium Web浏览器或任何可以在Docker容器中运行的轻量级一次性实例。"要尝试Testcontainer，请跟随以下步骤：'
- en: 'First create a `testcontainer-node` folder and navigate to it:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个`testcontainer-node`文件夹并导航到它：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next open VS Code from within that folder with `code .`. Create three subfolders, `database`,
    `api`, and `tests`, within the same folder. To the `api` folder, add a `package.json` file with
    the following content:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`code .`从该文件夹中打开VS Code。在同一文件夹中创建三个子文件夹，`database`，`api`和`tests`。向`api`文件夹中添加一个`package.json`文件，并添加以下内容：
- en: '![](assets/7eb83bfd-88b9-4891-9349-2098351469b2.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/7eb83bfd-88b9-4891-9349-2098351469b2.png)
- en: Content of package.json for the API
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: API的package.json内容
- en: 'Add a `server.js` file to the `api` folder with this content:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`api`文件夹添加一个`server.js`文件，并添加以下内容：
- en: '![](assets/e1dd1426-e8cf-48fb-8cc7-f79f5b4f6c95.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/e1dd1426-e8cf-48fb-8cc7-f79f5b4f6c95.png)
- en: The sample API using the pg library to access Postgres
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pg库访问Postgres的示例API
- en: Here, we create an Express JS application listening at port `3000`. The application
    uses the `pg` library, which is a client library for Postgres, to access our database.
    On lines `8` through `15`, we are defining a connection pool object that will
    allow us to connect to Postgres and retrieve or write data. On lines `21` through
    `24`, we're defining a `GET` method on the `/hobbies` endpoint, which returns
    the list of hobbies that are retrieved from the database via the SQL query, `SELECT
    hobby FROM hobbies`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个在端口`3000`监听的Express JS应用程序。该应用程序使用`pg`库，这是一个用于Postgres的客户端库，用于访问我们的数据库。在第`8`到`15`行，我们正在定义一个连接池对象，它将允许我们连接到Postgres并检索或写入数据。在第`21`到`24`行，我们正在定义一个`GET`方法，它位于`/hobbies`端点上，该端点通过SQL查询`SELECT
    hobby FROM hobbies`从数据库中检索到的爱好列表。
- en: 'Now add a Dockerfile to the same folder with this content:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在同一文件夹中添加一个Dockerfile，并添加以下内容：
- en: '![](assets/b63beff8-619f-435f-801c-7fe06c7a1333.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/b63beff8-619f-435f-801c-7fe06c7a1333.png)
- en: Dockerfile for the API
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: API的Dockerfile
- en: This is exactly the same definition as we used in the previous example. With
    this, the API is ready to be used. Let's now continue with the tests that will
    use the `testcontainer` library to simplify container-based testing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在上一个示例中使用的定义完全相同。有了这个，API已经准备好使用了。现在让我们继续进行使用`testcontainer`库来简化基于容器的测试的测试。
- en: 'In your Terminal, navigate to the `tests` folder that we created earlier and
    use `npm init` to initialize it as a Node.js project. Accept all of the defaults.
    Next, use `npm` to install the `request` library and the `testcontainers` library:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中，导航到我们之前创建的`tests`文件夹，并使用`npm init`将其初始化为一个Node.js项目。接受所有默认值。接下来，使用`npm`安装`request`库和`testcontainers`库：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The result of this is a `package.json` file that should look similar to this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 其结果是一个`package.json`文件，应该看起来类似于这样：
- en: '![](assets/d2880fcf-f231-45d2-878b-3b4b2289f79f.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/d2880fcf-f231-45d2-878b-3b4b2289f79f.png)
- en: The package.json file for the tests project
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 测试项目的package.json文件
- en: 'Now, still in the `tests` folder, create a `tests.js` file and add the following
    code snippet:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`tests`文件夹中，创建一个`tests.js`文件，并添加以下代码片段：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note how we're requesting a new object such as the `request` object, which will
    help us to access the RESTful interface of our sample API component. We are also
    requesting the `GenericContainer` object from the `testcontainers` library that
    will allow us to build and run any container.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们正在请求一个新对象，比如`request`对象，它将帮助我们访问示例API组件的RESTful接口。我们还从`testcontainers`库请求`GenericContainer`对象，它将允许我们构建和运行任何容器。
- en: We then define an async self-invoking function, which will be the wrapper for
    our setup and test code. It has to be an async function since, inside it, we will
    be awaiting other async functions, such as the various methods used from the `testcontainers`
    library.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个异步自调用函数，它将作为我们设置和测试代码的包装器。它必须是一个异步函数，因为在其中，我们将等待其他异步函数，比如从`testcontainers`库使用的各种方法。
- en: 'As a very first step, we want to use the `testcontainers` library to create
    a Postgres container with the necessary seed data loaded. Let''s add this code
    snippet after `//TODO`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为非常重要的一步，我们想使用`testcontainers`库来创建一个带有必要种子数据的Postgres容器。让我们在`//TODO`之后添加这段代码片段：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding snippet has some similarities with a Docker `run` command. That
    is no accident since we are instructing the `testcontainers` library to do exactly
    that and run an instance of PostgreSQL for us.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段与Docker的`run`命令有一些相似之处。这并非偶然，因为我们正在指示`testcontainers`库做的正是这样，为我们运行一个PostgreSQL实例。
- en: 'Next, we need to find out to which host port the exposed port `5432` is mapped.
    We can do that with the following logic:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要找出暴露端口`5432`映射到哪个主机端口。我们可以用以下逻辑来做到这一点：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We will need this information since the API component will have to access Postgres
    via this port.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要这些信息，因为API组件将需要通过这个端口访问Postgres。
- en: 'We also need to know which IP address the host is reachable from within a container—note,
    localhost won''t work from within a container since that would map to the loopback
    adapter of the container''s own network stack. We can get this host IP address
    like this:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要知道主机在容器内可达的IP地址是哪个——注意，本地主机在容器内不起作用，因为这将映射到容器自己网络堆栈的环回适配器。我们可以这样获取主机IP地址：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `lookupPromise` function is a wrapper function to make the normal async
    `dns.lookup` function return a promise so that we can `await` it. Here is its
    definition:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookupPromise`函数是一个包装函数，使正常的异步`dns.lookup`函数返回一个promise，这样我们就可以`await`它。这是它的定义：'
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, with this information, we are ready to instruct the `testcontainer` library
    to first build the container image for the API and then run a container from this
    image. Let''s start with the build:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，有了这些信息，我们准备指示`testcontainer`库首先为API构建容器镜像，然后从该镜像运行容器。让我们从构建开始：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note how this command uses the Dockerfile that we defined in the `api` subfolder.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个命令如何使用我们在`api`子文件夹中定义的Dockerfile。
- en: 'Once we have the `apiContainer` variable referencing the new image, we can
    use this to run a container from it:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了引用新镜像的`apiContainer`变量，我们就可以使用它来从中运行一个容器：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once again, we need to find out to which host port the exposed port `3000`
    of the API component has been mapped. The `testcontainer` library makes this a
    breeze:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再一次，我们需要找出API组件的暴露端口`3000`映射到哪个主机端口。`testcontainer`库使这变得轻而易举：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With this last line, we have finished the test setup code and can now finally
    start implementing some tests. We start by defining the base URL for the API component
    that we want to access. Then, we use the `request` library to make an HTTP GET
    request to the `/hobbies` endpoint:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这最后一行，我们已经完成了测试设置代码，现在终于可以开始实现一些测试了。我们首先定义要访问的API组件的基本URL。然后，我们使用`request`库向`/hobbies`端点发出HTTP
    GET请求：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s now implement some assertions right after the `//Test code here...` comment:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在`//Test code here...`注释之后实现一些断言：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'First, we log our expectation to the console as a feedback when running tests.
    Then, we assert that the returned status code is `200`, and, if not, we log an
    error. The `logError` helper function just writes the given message in red to
    the console, and prefixes it with `***ERR`. Here is the definition of this function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当运行测试时，我们将我们的期望记录到控制台作为反馈。然后，我们断言返回的状态码是`200`，如果不是，我们会记录一个错误。`logError`辅助函数只是将给定的消息以红色写入控制台，并在前面加上`***ERR`。这是这个函数的定义：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s add two more assertions:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再添加两个断言：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: I leave it up to you, dear reader, to find out what these assertions do exactly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我把确切的断言做什么留给你，亲爱的读者，去找出来。
- en: 'At the end of the assertions, we have to clean up so that we''re ready for
    a next run:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在断言结束时，我们必须进行清理，以便为下一次运行做好准备：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: What we're doing is just stopping the API and the database container. This will
    automatically remove them from memory too.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的就是停止API和数据库容器。这将自动将它们从内存中删除。
- en: 'Now we can run this test suite using the following command from within the
    `tests` subfolder:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令在`tests`子文件夹中运行这个测试套件：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output in my case looks like this (note, I have sprinkled a few `console.log`
    statements in the code to more easily follow along what exactly is happening at
    a give time):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，输出看起来是这样的（注意，我在代码中添加了一些`console.log`语句，以更容易地跟踪到底在某个时间点发生了什么）：
- en: '![](assets/ba68b227-ae11-4625-9b29-b37915043c4f.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ba68b227-ae11-4625-9b29-b37915043c4f.png)'
- en: Running the testcontainer-based integration tests
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 运行基于testcontainer的集成测试
- en: The full code is given in the sample code repository that you cloned from GitHub.
    If you have problems running your tests, please compare your implementation to
    the given sample solution.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码在您从GitHub克隆的示例代码存储库中提供。如果您在运行测试时遇到问题，请将您的实现与给定的示例解决方案进行比较。
- en: Now that we have a good understanding of how to use containers to run our integration
    tests, we'll move on to another very popular use case for container based automation,
    namely, building a Continuous Integration and Continuous Deployment or Delivery
    (CI/CD) pipeline.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地了解了如何使用容器来运行我们的集成测试，我们将继续进行另一个非常流行的基于容器的自动化用例，即构建持续集成和持续部署或交付（CI/CD）流水线。
- en: Using Docker to power a CI/CD pipeline
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker来支持CI/CD流水线
- en: 'The goal of this section is to build a CI/CD pipeline that looks like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是构建一个类似于以下的CI/CD流水线：
- en: '![](assets/6e8eff3d-22ee-4c18-9b2b-30f7745a3e91.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6e8eff3d-22ee-4c18-9b2b-30f7745a3e91.png)'
- en: A simple CI/CD pipeline using Jenkins
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jenkins的简单CI/CD流水线
- en: We are going to use Jenkins ([https://jenkins.io](https://jenkins.io)) as our
    automation server. Other automation servers such as TeamCity ([https://www.jetbrains.com/teamcity](https://www.jetbrains.com/teamcity))
    work equally well. When using Jenkins, the central document is the `Jenkinsfile`,
    which will contain the definition of the pipeline with its multiple stages.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Jenkins（[https://jenkins.io](https://jenkins.io)）作为我们的自动化服务器。其他自动化服务器，如TeamCity（[https://www.jetbrains.com/teamcity](https://www.jetbrains.com/teamcity)）同样有效。在使用Jenkins时，中心文档是`Jenkinsfile`，其中包含了具有多个阶段的流水线的定义。
- en: 'A simple `Jenkinsfile` with the `Build`, `Test`, `Deploy to Staging`, and `Deploy
    to Production` stages could look like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`Jenkinsfile`与`Build`、`Test`、`Deploy to Staging`和`Deploy to Production`阶段可能是这样的：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Of course, the preceding pipeline just outputs a message during each stage
    and does nothing else. It is useful though as a starting point from which to build
    up our pipeline:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的流水线只是在每个阶段输出一条消息，什么也不做。尽管如此，它作为一个起点是有用的，可以从中构建我们的流水线。
- en: 'Create a project folder named `jenkins-pipeline` and navigate to it:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`jenkins-pipeline`的项目文件夹并导航到它：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, let''s run Jenkins in a Docker container. Use the following command to
    do so:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在Docker容器中运行Jenkins。使用以下命令来执行：
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that we are running as the `root` user inside the container and that we
    are mounting the Docker socket into the container (`-v /var/run/docker.sock:/var/run/docker.sock`)
    so that Jenkins can access Docker from within the container. Data produced and
    used by Jenkins will be stored in the Docker volume, `jenkins-data`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在作为容器内的`root`用户运行，并且我们正在将Docker套接字挂载到容器中（`-v /var/run/docker.sock:/var/run/docker.sock`），以便Jenkins可以从容器内访问Docker。Jenkins生成和使用的数据将存储在Docker卷`jenkins-data`中。
- en: 'We can find the initial admin password generated automatically by Jenkins with
    the following command:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令自动由Jenkins生成的初始管理员密码：
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In my case, this outputs `7f449293de5443a2bbcb0918c8558689`. Save this password
    as you will be using it in the next step.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，这将输出`7f449293de5443a2bbcb0918c8558689`。保存这个密码，因为您将在下一步中使用它。
- en: In your browser, navigate to `http://localhost:8080` to access the graphical
    UI of Jenkins.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，导航至`http://localhost:8080`以访问Jenkins的图形界面。
- en: Unlock Jenkins with the admin password that you retrieved with the previous
    command.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面的命令检索的管理员密码解锁Jenkins。
- en: Next, choose Install suggested plugins to have Jenkins automatically install
    the most useful plugins. Plugins include the GitHub integration, an email extension,
    Maven and Gradle integration, and so on.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择安装建议的插件，让Jenkins自动安装最有用的插件。插件包括GitHub集成，电子邮件扩展，Maven和Gradle集成等等。
- en: As soon as the plugins are installed, create your first admin account. When
    asked to restart Jenkins, do so.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦插件安装完成，创建您的第一个管理员帐户。在要求重新启动Jenkins时，这样做。
- en: 'Once you have configured your Jenkins server, start by creating a new project;
    you may need to click **New Item** in the main menu:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您配置了Jenkins服务器，首先创建一个新项目；您可能需要在主菜单中点击**新项目**：
- en: '![](assets/f64e3315-eaf5-43c9-8ffc-d8fd63e0cd4e.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f64e3315-eaf5-43c9-8ffc-d8fd63e0cd4e.png)'
- en: Add a new project in Jenkins
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkins中添加一个新项目
- en: Give the project the name `sample-pipeline`, select the `Pipeline` type, and
    click OK.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给项目命名为`sample-pipeline`，选择`Pipeline`类型，然后点击确定。
- en: 'In the configuration view, select the Pipeline tab and add the pipeline definition
    from the preceding into the Script textbox:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置视图中，选择Pipeline标签，并将前面的管道定义添加到脚本文本框中：
- en: '![](assets/b96d4516-0374-453f-b7a2-b419e6815a24.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b96d4516-0374-453f-b7a2-b419e6815a24.png)'
- en: Defining the pipeline in our Jenkins project called sample-pipeline
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的名为sample-pipeline的Jenkins项目中定义管道
- en: 'Click Save and then, in the main menu of Jenkins, select Build Now. After a
    short moment, you should see this:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击保存，然后在Jenkins的主菜单中选择立即构建。过一会儿，您应该会看到这个：
- en: '![](assets/009185ff-8c65-4336-82f3-1fb4673adc22.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/009185ff-8c65-4336-82f3-1fb4673adc22.png)'
- en: Running our sample pipeline in Jenkins
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkins中运行我们的示例管道
- en: 'Now that we have prepared Jenkins, we can start to integrate our sample application.
    Let''s start with the build step. First, we initialize the `jenkins-pipeline` project
    folder as a Git project:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了Jenkins，我们可以开始集成我们的示例应用程序。让我们从构建步骤开始。首先，我们将`jenkins-pipeline`项目文件夹初始化为Git项目：
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add a `package.json` file to this folder with this content:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向此文件夹添加一个`package.json`文件，内容如下：
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There is nothing exceptional in this file other the usual list of external dependencies,
    `express` and `jasmine`, in this case. Also, note the two scripts `start` and
    `test` that we define for use with `npm`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中没有什么特别的，除了通常的外部依赖列表，这种情况下是`express`和`jasmine`。还要注意我们为`npm`定义的两个脚本`start`和`test`。
- en: 'Add a `hobbies.js` file to the project, which implements the logic to retrieve
    hobbies as a JavaScript module called `hobbies`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目添加一个`hobbies.js`文件，该文件实现了作为JavaScript模块`hobbies`调用的爱好检索逻辑：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This code evidently is simulating a database by serving pre-canned data stored
    in the `hobbies` array. We do this for simplicity.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显然是通过提供存储在`hobbies`数组中的预先准备好的数据来模拟数据库。我们之所以这样做是为了简单起见。
- en: 'Next add a `server.js` file to the folder that defines a RESTful API with the
    three endpoints, `GET /`,  `GET /hobbies`, and `GET /hobbies/:id`. The code uses
    the logic defined in the `hobbies` module to retrieve data:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在文件夹中添加一个`server.js`文件，该文件定义了一个具有三个端点`GET /`、`GET /hobbies`和`GET /hobbies/:id`的RESTful
    API。该代码使用`hobbies`模块中定义的逻辑来检索数据：
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now we need to define some unit tests. Create a `spec` subfolder in the project
    and add the `hobbies-spec.js` file to it with the following code that tests the `hobbies` module:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要定义一些单元测试。在项目中创建一个`spec`子文件夹，并向其中添加`hobbies-spec.js`文件，其中包含以下代码，用于测试`hobbies`模块：
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The last step is to add a `support/jasmine.json` file to configure our test
    framework, Jasmine. Add the following code snippet:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是添加一个`support/jasmine.json`文件来配置我们的测试框架Jasmine。添加以下代码片段：
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is all the code that we need for the moment.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们目前所需要的所有代码。
- en: 'We can now start to build the CI/CD pipeline:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始构建CI/CD管道：
- en: 'Commit the code just created locally with the following command:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令提交本地创建的代码：
- en: '[PRE61]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To avoid all of the node modules being saved to GitHub, add a `.gitignore` file to
    the project `root` folder with the following content:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免所有的node模块都保存到GitHub上，向项目的`root`文件夹中添加一个`.gitignore`文件，并包含以下内容：
- en: '[PRE62]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, we need to define a repository on GitHub. Log in to your account on GitHub
    at [https://github.com](https://github.com).
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在GitHub上定义一个存储库。在[https://github.com](https://github.com)上登录您的GitHub帐户。
- en: 'Create a new repository there and call it `jenkins-pipeline`:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那里创建一个新的存储库，并将其命名为`jenkins-pipeline`：
- en: '![](assets/5bd043cb-4a05-4e38-b286-30d4c48a7b40.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5bd043cb-4a05-4e38-b286-30d4c48a7b40.png)'
- en: Create a new GitHub repository for the Jenkins pipeline sample applicationNote
    that my GitHub account is `gnschenker`. In your case, it will be your own account.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为Jenkins管道示例应用程序创建一个新的GitHub存储库请注意，我的GitHub帐户是`gnschenker`。在您的情况下，将是您自己的帐户。
- en: 'After you have clicked the green button, **Create repository**, go back to
    you project and execute the following two commands from within the project `root`
    folder:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您点击了绿色按钮“创建存储库”之后，回到您的项目，并在项目的`root`文件夹中执行以下两个命令：
- en: '[PRE63]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Make sure you replace `gnschenker` in the first line with your own GitHub account
    name. After this step, your code will be available on GitHub for further use.
    One of the users will be Jenkins, which will pull the code from this repository
    as we will show shortly.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在第一行中用您自己的GitHub帐户名替换`gnschenker`。完成此步骤后，您的代码将可在GitHub上供进一步使用。其中一个用户将是Jenkins，它将从该存储库中拉取代码，我们将很快展示。
- en: The next thing is to go back to Jenkins (`localhost:8080`) and modify the configuration
    of the project. Log in to Jenkins if needed and select your project, `sample-pipeline`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是返回Jenkins（`localhost:8080`）并修改项目的配置。如果需要，请登录Jenkins并选择您的项目`sample-pipeline`。
- en: 'Then, select Configure in the main menu. Select the Pipeline tab and modify
    the settings so that they look similar to this:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在主菜单中选择配置。选择Pipeline选项卡，并修改设置，使其看起来类似于这样：
- en: '![](assets/c975f0de-984a-4fc0-b092-e4e848fd34dd.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c975f0de-984a-4fc0-b092-e4e848fd34dd.png)'
- en: Configuring Jenkins to pull source from GitHub
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Jenkins以从GitHub拉取源代码
- en: 'With this, we configure Jenkins to pull code from GitHub and use a `Jenkinsfile`
    to define the pipeline. `Jenkinsfile` is expected to be found in the `root` of
    the project. Note that for the repository URL path, we need to give the relative
    path to the `/home` directory where our project is located. Remember that, when
    running the Jenkins container, we mapped our own home folder on the host to the
    `/home` folder inside the Jenkins container with this: `-v "$HOME":/home`.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们配置Jenkins从GitHub拉取代码，并使用`Jenkinsfile`来定义流水线。预计`Jenkinsfile`应该在项目的`根目录`中找到。请注意，对于存储库URL路径，我们需要给出相对路径到我们项目所在的`/home`目录。请记住，当运行Jenkins容器时，我们将我们自己的主机上的主目录映射到Jenkins容器内的`/home`目录，方法是：`-v
    "$HOME":/home`。
- en: Hit the green Save button to accept the changes.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色的保存按钮以接受更改。
- en: 'We have defined that `Jenkinsfile` needs to be in the project `root` folder.
    This is the foundation of **Pipeline-as-Code**, since the pipeline definition
    file will be committed to the GitHub repository along with the rest of the code.
    Hence, add a file called `Jenkinsfile` to the `jenkins-pipeline` folder and add
    this code to it:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经定义了`Jenkinsfile`需要在项目的`根目录`中。这是**Pipeline-as-Code**的基础，因为流水线定义文件将与其余代码一起提交到GitHub存储库中。因此，请在`jenkins-pipeline`文件夹中添加一个名为`Jenkinsfile`的文件，并将以下代码添加到其中：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'OK, let''s dive into this file one part at a time. At the top, we''re defining
    two environment variables that will be available throughout every stage of the
    pipeline. We will be using those variables in the `Build & Push Docker image` stage:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们一次解决这个文件的一部分。在顶部，我们定义了两个环境变量，它们将在流水线的每个阶段中都可用。我们将在`Build & Push Docker
    image`阶段中使用这些变量：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The first variable, `registry`, just contains the full name of the container
    image we will eventually produce and push to Docker Hub. Replace `gnschenker`
    with your own GitHub username. The second variable, `DOCKER_PWD`, is a bit more
    interesting. It will contain the password to log in to my Docker Hub account.
    Of course, I don't want to have the value hardcoded here in code, hence, I use
    the credentials function of Jenkins that gives me access to a secret stored under
    the name `docker-login-pwd` in Jenkins.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量`registry`只包含我们最终将生成并推送到Docker Hub的容器镜像的完整名称。用您自己的GitHub用户名替换`gnschenker`。第二个变量`DOCKER_PWD`更有趣一些。它将包含登录到我的Docker
    Hub帐户的密码。当然，我不想在这里将值硬编码在代码中，因此，我使用Jenkins的凭据功能，它让我访问存储在Jenkins中名称为`docker-login-pwd`的秘密。
- en: 'Next, we define the agent we want to use to run the Jenkins pipeline on. In
    our case, it is based on a Docker image. We are using the `gnschenker/node-docker` image for
    this purpose. This is an image based on `node:12.10-alpine`, which has Docker
    and `curl` installed, as we will need these two tools in some of the stages:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义要在其上运行Jenkins流水线的代理。在我们的情况下，它是基于Docker镜像的。我们使用`gnschenker/node-docker`镜像来实现这一目的。这是一个基于`node:12.10-alpine`的镜像，其中安装了Docker和`curl`，因为我们将在某些阶段需要这两个工具：
- en: '[PRE66]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: With the `args` parameter, we are also mapping the Docker socket into the container
    so that we can use Docker from within the agent.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`args`参数，我们还将Docker套接字映射到容器中，以便我们可以在代理内部使用Docker。
- en: 'Ignore the options part for the moment. We then are defining three stages:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时忽略选项部分。然后我们定义了三个阶段：
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The first stage, `Build`, just runs `npm install` to make sure all external
    dependencies of our app can be installed. If this were, for example, a Java application,
    we would probably also compile and package the application in this step.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个阶段`Build`只是运行`npm install`，以确保我们应用程序的所有外部依赖项都可以安装。例如，如果这是一个Java应用程序，我们可能还会在这一步中编译和打包应用程序。
- en: In the second stage, `Test`, we run `npm test`, which runs our unit tests that
    we have defined for the sample API.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二阶段`Test`中，我们运行`npm test`，这将运行我们为示例API定义的单元测试。
- en: 'The third stage, `Build & Push Docker image`, is a bit more interesting. Now
    that we have successfully built and tested our application, we can create a Docker
    image for it and push it to a registry. We are using Docker Hub as our registry,
    but any private or public registry would work. In this stage, we define four steps:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 第三阶段，`构建和推送Docker镜像`，有点更有趣。现在我们已经成功构建并测试了我们的应用程序，我们可以为它创建一个Docker镜像并将其推送到注册表中。我们使用Docker
    Hub作为我们的注册表，但任何私有或公共注册表都可以使用。在这个阶段，我们定义了四个步骤：
- en: We use Docker to build the image. We use the `$registry` environment variable
    we have defined in the first part of the Jenkinsfile. The `$BUILD_NUMBER` variable is
    defined by Jenkins itself.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用Docker来构建镜像。我们使用了在Jenkinsfile的第一部分中定义的`$registry`环境变量。`$BUILD_NUMBER`变量是由Jenkins自己定义的。
- en: Before we can push something to the registry, we need to log in. Here, I am
    using the `$DOCKER_PWD` variable that I defined earlier on.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以将某些东西推送到注册表之前，我们需要登录。在这里，我使用了之前定义的`$DOCKER_PWD`变量。
- en: Once we're successfully logged in to the registry, we can push the image.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们成功登录到注册表，我们就可以推送镜像。
- en: Since the image is now in the registry, we can delete it from the local cache
    to avoid wasting space.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于镜像现在在注册表中，我们可以从本地缓存中删除它，以避免浪费空间。
- en: Remember that all of the stages run inside our `gnschenker/node-docker` builder
    container. Hence, we're running Docker inside Docker. But, since we have mapped
    the Docker socket into the builder, the Docker commands act on the host.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有阶段都在我们的`gnschenker/node-docker`构建器容器内运行。因此，我们在Docker内部运行Docker。但是，由于我们已经将Docker套接字映射到了构建器中，Docker命令会在主机上执行。
- en: 'Let''s add two more stages to the pipeline. The first one looks like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在流水线中再添加两个阶段。第一个看起来像这样：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Add it just after the `Build & Push Docker image` stage. This stage just executes
    a `deploy.sh` script located in the `jenkins/scripts` subfolder. We do not yet
    have such a file in our project.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 将其添加到`构建和推送Docker镜像`阶段之后。这个阶段只是执行位于`jenkins/scripts`子文件夹中的`deploy.sh`脚本。我们的项目中还没有这样的文件。
- en: 'Hence, add this file to your project with the following content:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请将这个文件添加到你的项目中，并包含以下内容：
- en: '[PRE69]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: OK, so this code does the following. First, it tries to remove any artifacts
    that might have been left over from an earlier, failed run of the pipeline. Then,
    it creates a Docker network called `test-net`. Next, it runs a container from
    the image we built in the previous step. This container is our Express JS API
    and is called `api` accordingly.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以这段代码做了以下几件事。首先，它试图移除可能残留在之前失败的流水线运行中的任何残留物。然后，它创建了一个名为`test-net`的Docker网络。接下来，它从我们在上一步中构建的镜像中运行一个容器。这个容器是我们的Express
    JS API，相应地被称为`api`。
- en: This container and the application within it may take a moment to be ready.
    Hence, we define some logic that uses the `netcat` or `nc` tool to probe port
    `3000`. Once the application is listening at port `3000`, we continue with the
    smoke test. In our case, the smoke test is just making sure it can access the
    `/` endpoint of our API. We are using `curl` for this task. In a more realistic
    setup, you would run some more sophisticated tests here.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器和其中的应用可能需要一些时间才能准备好。因此，我们定义了一些逻辑，使用`netcat`或`nc`工具来探测端口`3000`。一旦应用程序在端口`3000`上监听，我们就可以继续进行烟雾测试。在我们的情况下，烟雾测试只是确保它可以访问我们API的`/`端点。我们使用`curl`来完成这个任务。在一个更现实的设置中，你可能会在这里运行一些更复杂的测试。
- en: 'As a last stage, we are adding a `Cleanup` step:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后阶段，我们添加了一个`Cleanup`步骤：
- en: 'Add the following snippet as a last stage to your `Jenkinsfile`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Jenkinsfile`中添加以下片段作为最后一个阶段：
- en: '[PRE70]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Once again, this `Cleanup` stage uses a script located in the `jenkins/script` subfolder.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个`Cleanup`阶段使用了位于`jenkins/script`子文件夹中的脚本。
- en: 'Please add such a file to your project with the following content:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请向你的项目添加一个包含以下内容的文件：
- en: '[PRE71]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This script removes the `api` container and the Docker network, `test-net`,
    that we used to run our containers on.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本删除了我们用来运行容器的`api`容器和Docker网络`test-net`。
- en: 'Now, we are ready to roll. Use `git` to commit your changes and push them to
    your repository:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好了。使用`git`提交您的更改并将其推送到您的存储库：
- en: '[PRE72]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Once the code is pushed to GitHub, go back to Jenkins.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 代码推送到GitHub后，返回Jenkins。
- en: 'Select your `sample-pipeline` project and click Build now in the main menu.
    Jenkins will start to build the pipeline. If everything goes well, you should
    see something like this:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您的`sample-pipeline`项目并在主菜单中点击立即构建。Jenkins将开始构建流水线。如果一切顺利，您应该看到类似于这样的东西：
- en: '![](assets/09e00d85-9229-40a2-bad3-1fbf4e92e1bc.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/09e00d85-9229-40a2-bad3-1fbf4e92e1bc.png)'
- en: Running our full code-based pipeline in Jenkins
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkins中运行我们的完整基于代码的流水线
- en: Our pipeline is executed successfully and now has six steps. The checkout from
    GitHub has been automatically added as a first enabling step. To access the logs
    generated during the pipeline execution, you can click the little ball icon on
    the left side of the run under Build History. In the preceding screenshot, it
    is the bluish icon on the left of **#26**. This is especially helpful if the pipeline
    step fails to quickly find the root cause of the failure.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的流水线已成功执行，现在有六个步骤。从GitHub检出已自动添加为第一个启用步骤。要访问流水线执行期间生成的日志，可以点击构建历史下运行左侧的小球图标。在前面的屏幕截图中，它是**#26**左侧的蓝色图标。如果流水线步骤失败，这将特别有帮助，可以快速找到失败的根本原因。
- en: To summarize, we have built a simple CI/CD pipeline where everything, including
    the automation server, Jenkins, is running in containers. We have only scratched
    the surface of what is possible.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们已经构建了一个简单的CI/CD流水线，其中包括自动化服务器Jenkins在内的所有内容都在容器中运行。我们只是触及了可能性的表面。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we learned how to use Docker containers to optimize various
    kinds of automation tasks, from running a simple one-off task to building up a
    containerized CI/CD pipeline.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Docker容器来优化各种自动化任务，从运行简单的一次性任务到构建容器化的CI/CD流水线。
- en: In the next chapter, we will introduce advanced tips, tricks, and concepts useful
    when containerizing complex distributed applications or when using Docker to automate
    sophisticated tasks.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍在容器化复杂的分布式应用程序或使用Docker自动化复杂任务时有用的高级技巧、技巧和概念。
- en: Questions
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Name a few pros and cons for running a one-off task in a container instead of
    directly on the host machine.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出在容器中运行一次性任务的几个优缺点。
- en: List two or three advantages of running tests in containers.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出在容器中运行测试的两三个优点。
- en: Sketch a high-level diagram of a containerized CI/CD pipeline, starting from
    the user producing code till the code being deployed into production.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾画一个以容器化的CI/CD流水线为起点的高层次图，从用户生成代码到代码部署到生产环境。
- en: Further reading
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Write Maintainable Integration Tests with Docker at [https://www.docker.com/blog/maintainable-integration-tests-with-docker/](https://www.docker.com/blog/maintainable-integration-tests-with-docker/)
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker编写可维护的集成测试 [https://www.docker.com/blog/maintainable-integration-tests-with-docker/](https://www.docker.com/blog/maintainable-integration-tests-with-docker/)
- en: A Docker Workflow for .NET Developer - Part 2 (Integration Tests) at [https://gabrielschenker.com/index.php/2019/10/09/a-docker-workflow-for-net-developers-part-2/](https://gabrielschenker.com/index.php/2019/10/09/a-docker-workflow-for-net-developers-part-2/)
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET开发人员的Docker工作流程-第2部分（集成测试）[https://gabrielschenker.com/index.php/2019/10/09/a-docker-workflow-for-net-developers-part-2/](https://gabrielschenker.com/index.php/2019/10/09/a-docker-workflow-for-net-developers-part-2/)
- en: Jenkins on Docker Hub at [https://hub.docker.com/_/jenkins/](https://hub.docker.com/_/jenkins/)
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub上的Jenkins [https://hub.docker.com/_/jenkins/](https://hub.docker.com/_/jenkins/)
- en: Jenkins Tutorial Overview at [https://jenkins.io/doc/tutorials/](https://jenkins.io/doc/tutorials/)
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins教程概述在[https://jenkins.io/doc/tutorials/](https://jenkins.io/doc/tutorials/)。
