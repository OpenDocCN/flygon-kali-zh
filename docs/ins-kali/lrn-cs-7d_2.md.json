["```cs\nusing System; \n\nnamespace Day02 \n{ \nclass Program \n    { \n     static void Main(string[] args) \n        { \n         Console.WriteLine(\"Hello World!\"); \n        } \n    } \n} \n```", "```cs\nnamespace Day02 \n{ \npublic class ClassExample \n    { \npublic void Display() \n        { \nConsole.WriteLine(\"This is a class 'ClassExample' of namespace 'Day02'. \"); \n        } \n    } \n} \n\nnamespace Day02New \n{ \n\npublic class ClassExample \n    { \npublic void Display() \n        { \nConsole.WriteLine(\"This is a class 'ClassExample' of namespace 'Day02New'. \"); \n        } \n    } \n} \n```", "```cs\nprivate static void SameClassDifferentNamespacesExample() \n{ \nvar class1 = new ClassExample(); \nvar class2 = new Day02New.ClassExample(); \n    class1.Display(); \n    class2.Display(); \n} \n```", "```cs\nprivate static (int, int) DisplayColorMenu(ConsoleColor[] colors) \n{ \nvar count = 0; \n\nforeach (var color in colors) \n    { \n        WriteLine($\"{count}{color}\"); \n        count += 1; \n    } \nWriteLine($\"{count + 1} Reset\"); \nWriteLine($\"{count + 2} Exit\"); \n\nWrite(\"Choose Foreground color:\"); \nvar foreground = Convert.ToInt32(ReadLine()); \nWrite(\"Choose Background color:\"); \nvar background = Convert.ToInt32(ReadLine()); \n\nreturn new ValueTuple<int, int>(background, foreground); \n} \n```", "```cs\nprivate static void ConsoleBeepExample() \n{ \nfor (int i = 0; i &lt; 9; i++) \nBeep(); \n} \n```", "```cs\nas identifier:\n```", "```cs\npublic class Stackholder \n{ \npublic void GetAuthorName(Person person) \n    { \nvar authorName = person as Author; \nConsole.WriteLine(authorName != null ? $\"Author is {authorName.Name}\" :\"No author.\"); \n    } \n\n} \n\n//Rest code is omitted \nas operator, it is called by the following code:\n```", "```cs\nprivate static void ExampleIsAsOperator() \n{ \nWriteLine(\"isas Operator\"); \nvar author = new Author{Name = \"Gaurav Aroraa\"}; \n\nWriteLine(\"Author name using as:\\n\"); \nstackholder.GetAuthorName(author); \n\n} \n```", "```cs\npublic class TeamMember :Person \n{ \npublic override string Name { get; set; } \npublic void GetMemberName() \n    { \n     Console.WriteLine($\"Member name:{Name}\"); \n    } \n} \n\npublic class ContentMember :TeamMember \n{ \npublic ContentMember(string name) \n    { \n     base.Name = name; \n    } \npublic void GetContentMemberName() \n    { \n     base.GetMemberName(); \n    } \n} \n```", "```cs\nint sumWillthrowError = 2147483647 + 19; //compile time error\n```", "```cs\nPrivate static void CheckOverFlowExample()\n{\nvar maxValue = int.MaxValue;\nvar addSugar = 19;\nvar sumWillNotThrowError = maxValue + addSugar;\nWriteLine($\"sum value:{sumWillNotThrowError} is not the correct value because it is larger than {maxValue}.\");\n} \n```", "```cs\nprivate static void CheckOverFlowExample() \n{ \nconst int maxValue = int.MaxValue; \nconst int addSugar = 19; \nvar sumWillNotThrowError = checked(maxValue+addSugar); //compile time error \nWriteLine( \n$\"sum value:{sumWillNotThrowError} is not the correct value because it is larger than {maxValue}.\"); \n} \n```", "```cs\npublic void GetStackholdersname(Person person) \n{ \nif (person is Author) \n    { \n     Console.WriteLine($\"Author name:{((Author)person).Name}\"); \n    } \nelseif (person is Reviewer) \n    { \n     Console.WriteLine($\"Reviewer name:{((Reviewer)person).Name}\"); \n    } \nelseif(person is TeamMember) \n    { \n     Console.WriteLine($\"Member name:{((TeamMember)person).Name}\"); \n    } \nelse \n    { \n     Console.Write(\"Not a valid name.\"); \n    } \n\n} \n```", "```cs\nprivate static void SizeofExample() \n{ \nWriteLine(\"Various inbuilt types have size as mentioned below:\\n\"); \nWriteLine($\"The size of data type int is: {sizeof(int)}\"); \nWriteLine($\"The size of data type long is: {sizeof(long)}\"); \nWriteLine($\"The size of data type double is: {sizeof(double)}\"); \nWriteLine($\"The size of data type bool is: {sizeof(bool)}\"); \nWriteLine($\"The size of data type short is: {sizeof(short)}\"); \nWriteLine($\"The size of data type byte is: {sizeof(byte)}\"); \n} \n```", "```cs\nprivate static void TypeofExample() \n{ \nvar thisIsADouble = 30.3D; \nWriteLine(\"using typeof()\"); \nWriteLine($\"System.Type Object of {nameof(Program)} is {typeof(Program)}\\n\"); \nvar objProgram = newProgram(); \nWriteLine(\"using GetType()\"); \nWriteLine($\"Sytem.Type Object of {nameof(objProgram)} is {objProgram.GetType()}\"); \nWriteLine($\"Sytem.Type Object of {nameof(thisIsADouble)} is {thisIsADouble.GetType()}\"); \n} \n```", "```cs\nprivate static void CheckOverFlowExample() \n{ \nconst int maxValue = int.MaxValue; \nconst int addSugar = 19; \n//int sumWillthrowError = 2147483647 + 19; //compile time error \nvar sumWillNotThrowError = unchecked(maxValue+addSugar); \n//var sumWillNotThrowError = checked(maxValue + addSugar); //compile time error \nWriteLine( \n$\"sum value:{sumWillNotThrowError} is not the correct value because it is larger than {maxValue}.\"); \n} \n```", "```cs\nusing System;\n```", "```cs\nusing static System.Console;\n```", "```cs\nConsole.WriteLine(\"This WriteLien is without using static directive\");\nWriteLine(\"This WriteLien is called after using static directive\");\nConsole.WriteLine, but in the second statement, there is no need to write the class name, so we can directly call the WriteLine method.\nIDisposable interface):\n```", "```cs\npublic class DisposableClass : IDisposable \n{ \npublic string GetMessage() \n    { \n     return\"This is from a Disposable class.\"; \n    } \nprotected virtual void Dispose(bool disposing) \n    { \n     if (disposing) \n        { \n         //disposing code here \n        } \n    } \n\npublic void Dispose() \n    { \n       Dispose(true); \n       GC.SuppressFinalize(this); \n    } \n} \nprivate static void UsingExample() \n{ \nusing (var disposableClass = new DisposableClass()) \n    { \n     WriteLine($\"{disposableClass.GetMessage()}\"); \n    } \n} \n```", "```cs\npublic void GetAuthorName(Person person) \n{ \nvar authorName = person as Author; \nConsole.WriteLine(authorName != null ? $\"Author is {authorName.Name}\" :\"No author.\"); \n} \ngetAuthorName() method is of void type; hence, it does not return anything.\n```", "```cs\ninternal class Parent\n{\n//stuff goes here\n}\ninternal class Child : Parent\n{\n//stuff goes here\n}\n\n```", "```cs\nParent myObject = new Child();\n```", "```cs\nprivate static void DynamicTypeExample() \n{ \ndynamic dynamicInt = 10; \ndynamic dynamicString = \"This is a string\"; \nobject obj = 10; \nWriteLine($\"Run-time type of {nameof(dynamicInt)} is {dynamicInt.GetType()}\"); \nWriteLine($\"Run-time type of {nameof(dynamicString)} is {dynamicString.GetType()}\"); \nWriteLine($\"Run-time type of {nameof(obj)} is {obj.GetType()}\"); \n\n} \n```", "```cs\n//Code is omitted \npublic static void Display() \n{ \nWriteLine(\"Table :: Data Types\"); \nvar dataTypes = DataTypes(); \nWriteLine(RepeatIt('\\u2500', 100)); \nWriteLine(\"{0,-10} {1,-20} {2,-50} {3,-5}\", \"Type\", \"CLR Type\", \"Range\", \"Default Value\"); \nWriteLine(RepeatIt('\\u2500', 100)); \nforeach (var dataType in dataTypes) \nWriteLine(\"{0,-10} {1,-20} {2,-50} {3,-5}\", dataType.Type, dataType.CLRType, dataType.Range, \ndataType.DefaultValue); \nWriteLine(RepeatIt('\\u2500', 100)); \n} \n//Code is omitted \n```", "```cs\nprivate static void BoxingUnboxingExample() \n{ \nint thisIsvalueTypeVariable = 786; \nobject thisIsObjectTypeVariable = thisIsvalueTypeVariable; //Boxing \nthisIsvalueTypeVariable += 1; \n    WriteLine(\"Boxing\"); \nWriteLine($\"Before boxing: Value of {nameof(thisIsvalueTypeVariable)}: {thisIsvalueTypeVariable}\"); \nWriteLine($\"After boxing: Value of {nameof(thisIsObjectTypeVariable)}: {thisIsObjectTypeVariable}\"); \n\nthisIsObjectTypeVariable = 1900; \nthisIsvalueTypeVariable = (int) thisIsObjectTypeVariable; //Unboxing \n    WriteLine(\"Unboxing\"); \nWriteLine($\"Before Unboxing: Value of {nameof(thisIsObjectTypeVariable)}: {thisIsObjectTypeVariable}\"); \nWriteLine($\"After Unboxing: Value of {nameof(thisIsvalueTypeVariable)}: {thisIsvalueTypeVariable}\"); \n }\nthisIsvalueTypeVariable variable is assigned to an object thisIsObjectTypeVariable. On the other hand, unboxing happened when we cast object variable thisIsObjectTypeVariable to our value type thisIsvalueTypeVariable variable with int. This is the output of the code:\n```", "```cs\nprivate void ArithmeticOperators() \n{ \nWriteLine(\"\\nArithmetic operators\\n\"); \nWriteLine($\"Operator '+' (add): {nameof(Num1)} + {nameof(Num2)} = {Num1 + Num2}\"); \nWriteLine($\"Operator '-' (substract): {nameof(Num1)} - {nameof(Num2)} = {Num1 - Num2}\"); \nWriteLine($\"Operator '*' (multiplication): {nameof(Num1)} * {nameof(Num2)} = {Num1 * Num2}\"); \nWriteLine($\"Operator '/' (division): {nameof(Num1)} / {nameof(Num2)} = {Num1 / Num2}\"); \nWriteLine($\"Operator '%' (modulus): {nameof(Num1)} % {nameof(Num2)} = {Num1 % Num2}\"); \nWriteLine($\"Operator '++' (incremental): pre-increment: ++{nameof(Num1)} = {++Num1}\"); \nWriteLine($\"Operator '++' (incremental): post-increment: {nameof(Num1)}++ = {Num1++}\"); \nWriteLine($\"Operator '--' (decremental): pre-decrement: --{nameof(Num2)} = {--Num2}\"); \nWriteLine($\"Operator '--' (decremental): post-decrement: {nameof(Num2)}-- = {Num2--}\"); \nReadLine(); \n} \n//Code omitted \n```", "```cs\nprivate void OperatorPrecedence() \n{ \nWrite(\"Enter first number:\"); \n    Num1 = Convert.ToInt32(ReadLine()); \nWrite(\"Enter second number:\"); \n    Num2 = Convert.ToInt32(ReadLine()); \nWrite(\"Enter third number:\"); \n    Num3 = Convert.ToInt32(ReadLine()); \nWrite(\"Enter fourth number:\"); \n    Num4 = Convert.ToInt32(ReadLine()); \nint result = Num1 + Num2 * Num3/Num4; \nWriteLine($\"Num1 + Num2 * Num3/Num4 = {result}\"); \n    result = Num1 + Num2 * (Num3 / Num4); \nWriteLine($\"Num1 + Num2 * (Num3/Num4) = {result}\"); \n    result = (Num1 + (Num2 * Num3)) / Num4; \nWriteLine($\"(Num1 + (Num2 * Num3)) /Num4 = {result}\"); \n    result = (Num1 + Num2) * Num3 / Num4; \nWriteLine($\"(Num1 + Num2) * Num3/Num4 = {result}\"); \nReadLine(); \n} \n```", "```cs\npublic struct Coordinate \n{ \n//code omitted \n\npublic static Coordinateoperator +(Coordinate coordinate1, Coordinate coordinate2) =>; \nnew Coordinate(coordinate1._xAxis + coordinate2._xAxis, coordinate1._yAxis + coordinate2._yAxis); \npublic static Coordinateoperator-(Coordinate coordinate1, Coordinate coordinate2) => \nnew Coordinate(coordinate1._xAxis - coordinate2._xAxis, coordinate1._yAxis - coordinate2._yAxis); \npublic static Coordinateoperator *(Coordinate coordinate1, Coordinate coordinate2) => \nnew Coordinate(coordinate1._xAxis * coordinate2._xAxis, coordinate1._yAxis * coordinate2._yAxis); \n//code omitted \n\npublic static booloperator ==(Coordinate coordinate1, Coordinate coordinate2) =>; \n        coordinate1._xAxis == coordinate2._xAxis && coordinate1._yAxis == coordinate2._yAxis; \n\npublic static booloperator !=(Coordinate coordinate1, Coordinate coordinate2) => !(coordinate1 == coordinate2); \n\n//code omitted \n\npublic double Area() => _xAxis * _yAxis; \n\npublic override string ToString() =>$\"({_xAxis},{_yAxis})\"; \n}\n```", "```cs\nprivate static void OperatorOverloadigExample() \n{ \nWriteLine(\"Operator overloading example\\n\"); \nWrite(\"Enter x-axis of Surface1: \"); \nvar x1 = ReadLine(); \nWrite(\"Enter y-axis of Surface1: \"); \nvar y1 = ReadLine(); \nWrite(\"Enter x-axis of Surface2: \"); \nvar x2= ReadLine(); \nWrite(\"Enter y-axis of Surface2: \"); \nvar y2= ReadLine(); \n\nvar surface1 = new Coordinate(Convert.ToInt32(x1),Convert.ToInt32(y1)); \nvar surface2 = new Coordinate(Convert.ToInt32(x2),Convert.ToInt32(y2)); \nWriteLine(); \nClear(); \nWriteLine($\"Surface1:{surface1}\"); \nWriteLine($\"Area of Surface1:{surface1.Area()}\"); \nWriteLine($\"Surface2:{surface2}\"); \nWriteLine($\"Area of Surface2:{surface2.Area()}\"); \nWriteLine(); \nWriteLine($\"surface1 == surface2: {surface1==surface2}\"); \nWriteLine($\"surface1 < surface2: {surface1 < surface2}\"); \nWriteLine($\"surface1 > surface2: {surface1 > surface2}\"); \nWriteLine($\"surface1 <= surface2: {surface1 <= surface2}\"); \nWriteLine($\"surface1 >= surface2: {surface1 >= surface2}\"); \nWriteLine(); \nvar surface3 = surface1 + surface2; \nWriteLine($\"Addition: {nameof(surface1)} + {nameof(surface2)} = {surface3}\"); \nWriteLine($\"{nameof(surface3)}:{surface3}\"); \nWriteLine($\"Area of {nameof(surface3)}: {surface3.Area()} \"); \nWriteLine(); \nWriteLine($\"Substraction: {nameof(surface1)} - {nameof(surface2)} = {surface1-surface2}\"); \nWriteLine($\"Multiplication: {nameof(surface1)} * {nameof(surface2)} = {surface1 * surface2}\"); \nWriteLine($\"Division: {nameof(surface1)} / {nameof(surface2)} = {surface1 / surface2}\"); \nWriteLine($\"Modulus: {nameof(surface1)} % {nameof(surface2)} = {surface1 % surface2}\"); \n} \nCoordinate and call operators for various operations. Note that by overloading, we have changed the actual behavior of the operator, for instance, the add (*+*) operator, which generally adds two numbers, but with the implementation here, the add (*+*) operator gives the sum of two surfaces. The complete code produces the following result:\n```", "```cs\nprivate static void ImplicitExplicitTypeConversionExample() \n{ \nWriteLine(\"Implicit conversion\"); \nint numberInt = 2589; \ndouble doubleNumber = numberInt; // implicit type conversion \n\nWriteLine($\"{nameof(numberInt)} of type:{numberInt.GetType().FullName} has value:{numberInt}\"); \nWriteLine($\"{nameof(doubleNumber)} of type:{doubleNumber.GetType().FullName} implicitly type casted and has value:{doubleNumber}\"); \n\nWriteLine(\"Implicit conversion\"); \ndoubleNumber = 2589.05D; \nnumberInt = (int)doubleNumber; //explicit type conversion \nWriteLine($\"{nameof(doubleNumber)} of type:{doubleNumber.GetType().FullName} has value:{doubleNumber}\"); \nWriteLine($\"{nameof(numberInt)} of type:{numberInt.GetType().FullName} explicitly type casted and has value:{numberInt}\"); \n} \nnumberInt of int type to a variable doubleNumber of double type, which is called implicit type conversion, and the reverse is an explicit type conversion that requires a casting using int. Note that implicitly, type conversion does not require any casting, but explicitly, conversion requires type casting, and there are chances for loss of data during explicit conversion. For instance, our explicit conversion from double to int would result in a loss of data (all precision would be truncated while a value is assigned to int type variable). This code produces the following result:\n```", "```cs\nprivate static void StatementExample() \n{ \nWriteLine(\"Statement example:\"); \nint singleLineStatement; //declarative statement \nWriteLine(\"'intsingleLineStatement;' is a declarative statment.\"); \nsingleLineStatement = 125; //assignment statement \nWriteLine(\"'singleLineStatement = 125;' is an assignmnet statement.\"); \nWriteLine($\"{nameof(singleLineStatement)} = {singleLineStatement}\"); \nvar persons = newList<Person> \n    { \n     newAuthor {Name = \"Gaurav Aroraa\" } \n    }; //declarative and assignmnet statement \nWriteLine(\"'var persons = new List&lt;Person&gt;();' is a declarative and assignmnet statement.\"); \n\n//block statement \nforeach (var person in persons) \n    { \n      WriteLine(\"'foreach (var person in persons){}' is a block statement.\"); \n      WriteLine($\"Name:{person.Name}\"); \n    } \n} \n```", "```cs\nint singleLineStatement; //declarative statement \n```", "```cs\nConsole.WriteLine($\"Member name:{Name}\"); \nvar result = Num1 + Num2 * Num3 / Num4; \n```", "```cs\nprivate static void IfStatementExample() \n{ \nWriteLine(\"if statement example.\"); \nWrite(\"Enter character:\"); \nchar inputChar = Convert.ToChar(ReadLine()); \n\n//so many if statement, compiler go through all if statement \n//not recommended way \nif (char.ToLower(inputChar) == 'a') \nWriteLine($\"Character {inputChar} is a vowel.\"); \nif (char.ToLower(inputChar) == 'e') \nWriteLine($\"Character {inputChar} is a vowel.\"); \nif (char.ToLower(inputChar) == 'i') \nWriteLine($\"Character {inputChar} is a vowel.\"); \nif (char.ToLower(inputChar) == 'o') \nWriteLine($\"Character {inputChar} is a vowel.\"); \nif (char.ToLower(inputChar) == 'u') \nWriteLine($\"Character {inputChar} is a vowel.\"); \n} \nif statements without caring about the scenario where my first if statement got passed. Say, if you enter *a*, which is a vowel in this case, the compiler finds the first expression to be true and prints the output (we get our result), then the compiler checks the next if statement, and so on. In this case, the compiler unnecessarily checks the rest of all four statements that should not have happened. There might be a scenario where our code does not fall into any of the if statements in the preceding code; in that case, we would not get the expected result. To overcome such situations, we have the if...else statement, which we are going to discuss in the upcoming section.\n```", "```cs\nprivate static void IfElseStatementExample() \n{ \nWriteLine(\"if statement example.\"); \nWrite(\"Enter character:\"); \nchar inputChar = Convert.ToChar(ReadLine()); \nchar[] vowels = {'a', 'e', 'i', 'o', 'u'}; \n\nif (vowels.Contains(char.ToLower(inputChar))) \nWriteLine($\"Character '{inputChar}' is a vowel.\"); \nelse \nWriteLine($\"Character '{inputChar}' is a consonent.\"); \n} \nelse followed by the if statement. When the if statement evaluates to false, then the else block code will be executed.\n```", "```cs\nprivate static void IfElseIfElseStatementExample() \n{ \nWriteLine(\"if statement example.\"); \nWrite(\"Enter character:\"); \nchar inputChar = Convert.ToChar(ReadLine()); \n\nif (char.ToLower(inputChar) == 'a') \n{ WriteLine($\"Character {inputChar} is a vowel.\");} \nelseif (char.ToLower(inputChar) == 'e') \n{ WriteLine($\"Character {inputChar} is a vowel.\");} \nelseif (char.ToLower(inputChar) == 'i') \n{ WriteLine($\"Character {inputChar} is a vowel.\");} \nelseif (char.ToLower(inputChar) == 'o') \n{ WriteLine($\"Character {inputChar} is a vowel.\");} \nelseif (char.ToLower(inputChar) == 'u') \n{ WriteLine($\"Character {inputChar} is a vowel.\");} \nelse \n{ WriteLine($\"Character '{inputChar}' is a consonant.\");} \n} \nif...else if...else statements that evaluate the expression: whether inputchar is equivalent to comparative characternot. In this code, if you enter a character other than *a*,*e*,i,*o*,*u* that does not fall in any of the preceding condition, then the case else code block executes and it produces the final result. So, when else executes, it returns the result by saying that the entered character is a consonant.\n```", "```cs\nprivate static void NestedIfStatementExample() \n{ \nWriteLine(\"nested if statement example.\"); \nWrite(\"Enter your age:\"); \nint age = Convert.ToInt32(ReadLine()); \n\nif (age < 18) \n    { \n      WriteLine(\"Your age should be equal or greater than 18yrs.\"); \n      if (age < 15) \n        { \n         WriteLine(\"You need to complete your school first\"); \n        } \n    } \n} \n```", "```cs\nprivate static void SwitchCaseExample() \n{ \nWriteLine(\"switch case statement example.\"); \nWrite(\"Enter character:\"); \ncharinputChar = Convert.ToChar(ReadLine()); \n\nswitch (char.ToLower(inputChar)) \n{ \ncase'a': \nWriteLine($\"Character {inputChar} is a vowel.\"); \nbreak; \ncase'e': \nWriteLine($\"Character {inputChar} is a vowel.\"); \nbreak; \ncase'i': \nWriteLine($\"Character {inputChar} is a vowel.\"); \nbreak; \ncase'o': \nWriteLine($\"Character {inputChar} is a vowel.\"); \nbreak; \ncase'u': \nWriteLine($\"Character {inputChar} is a vowel.\"); \nbreak; \ndefault: \nWriteLine($\"Character '{inputChar}' is a consonant.\"); \nbreak; \n} \n}\n```", "```cs\nprivate static void DoWhileStatementExample() \n{ \nWriteLine(\"do...while example\"); \nWrite(\"Enter repeatitive length:\"); \nint length = Convert.ToInt32(ReadLine()); \nint count = 0; \ndo \n    { \n        count++; \n        WriteLine(newstring('*',count));  \n    } while (count < length); \n} \ndo block executes until the statement of the while block evaluates to false.\n```", "```cs\nprivate static void WhileStatementExample() \n{ \nWriteLine(\"while example\"); \nWrite(\"Enter repeatitive length:\"); \nint length = Convert.ToInt32(ReadLine()); \nint count = 0; \nwhile (count < length) \n    { \n       count++; \n       WriteLine(newstring('*', count)); \n    } \n}   \n```", "```cs\nprivate static void ForStatementExample() \n{ \nWriteLine(\"for loop example.\"); \nWrite(\"Enter repeatitive length:\"); \nint length = Convert.ToInt32(ReadLine()); \nfor (intcountIndex = 0; countIndex < length; countIndex++) \n    { \n     WriteLine(newstring('*', countIndex)); \n    } \n}\nfor loop. Here, our code statement within the for loop block will executive repeatedly until the countIndex&lt; length expression evaluates to false.\n```", "```cs\nprivate static void ForEachStatementExample() \n{ \nWriteLine(\"foreach loop example\"); \nchar[] vowels = {'a', 'e', 'i', 'o', 'u'}; \nWriteLine(\"foreach on Array.\"); \nforeach (var vowel in vowels) \n    { \n        WriteLine($\"{vowel}\"); \n    } \nWriteLine(); \nvar persons = new List<Person> \n    { \n     new Author {Name = \"Gaurav Aroraa\"}, \n     new Reviewer {Name = \"ShivprasadKoirala\"}, \n     new TeamMember {Name = \"Vikas Tiwari\"}, \n     new TeamMember {Name = \"Denim Pinto\"} \n    }; \nWriteLine(\"foreach on collection\"); \nforeach (var person in persons) \n    { \n        WriteLine($\"{person.Name}\"); \n    } \n}\n```", "```cs\nprivate static void BreakStatementExample() \n{ \nWriteLine(\"break statement example\"); \nWriteLine(\"break in for loop\"); \nfor (int count = 0; count &lt; 50; count++ \n{ \nif (count == 8) \n   { \n    break; \n   } \nWriteLine($\"{count}\"); \n} \nWriteLine(); \nWriteLine(\"break in switch statement\"); \nSwitchCaseExample(); \n} \n```", "```cs\nprivate static void ContinueStatementExample() \n{ \nWriteLine(\"continue statement example\"); \nWriteLine(\"continue in for loop\"); \nfor (int count = 0; count &lt; 15; count++) \n{ \nif (count< 8) \n{ \n continue; \n} \n WriteLine($\"{count}\"); \n} \n} \n```", "```cs\nprivate static void ArrayExample() \n{ \nWriteLine(\"Array example.\\n\"); \nchar[] vowels = {'a', 'e', 'i', 'o', 'u'}; \nWriteLine(\"char[] vowels = {'a', 'e', 'i', 'o', 'u'};\\n\"); \nWriteLine(\"acces array using for loop\"); \nfor (intrankIndex = 0; rankIndex&lt;vowels.Length; rankIndex++) \n{ \n    Write($\"{vowels[rankIndex]} \"); \n} \nWriteLine(); \nWriteLine(\"acces array using foreach loop\"); \nforeach (char vowel in vowels) \n    { \n        Write($\"{vowel} \"); \n    } \n} \n```", "```cs\nstring[] cardinalDirections = {\"North\",\"East\",\"South\",\"West\"}; \n```", "```cs\nint[,] numbers = new int[2,2]; \nint[,] numbers = new int[2, 2] {{1,2},{3,4} }; \n```", "```cs\nint[,] numbers = new int[2, 2] {{1,2},{3,4} }; \nfor (introwsIndex = 0; rowsIndex< 2; rowsIndex++) \n{ \nfor (intcolIndex = 0; colIndex< 2; colIndex++) \n    { \n        WriteLine($\"numbers[{rowsIndex},{colIndex}] = {numbers[rowsIndex, colIndex]}\"); \n    } \n} \nfor loops; the outer loop will work on rows and the inner loop will work on columns, and finally, we can get the element value using number[rowIndex][colIndex].\n```", "```cs\nstring[][,] collaborators = new string[5][,]; \n```", "```cs\nWriteLine(\"Jagged array.\\n\"); \nstring[][,] collaborators = new string[3][,] \n{ \nnew[,] {{\"Name\", \"ShivprasadKoirala\"}, {\"Age\", \"40\"}}, \nnew[,] {{\"Name\", \"Gaurav Aroraa\" }, {\"Age\", \"43\"}}, \nnew[,] {{\"Name\", \"Vikas Tiwari\"}, {\"Age\", \"28\"}} \n}; \n\nfor (int index = 0; index <collaborators.Length; index++) \n{ \n     for (introwIndex = 0; rowIndex< 2; rowIndex++) \n    { \n         for (intcolIndex = 0; colIndex< 2; colIndex++) \n        { \n            WriteLine($\"collaborators[{index}][{rowIndex},\n            {colIndex}] = {collaborators[index]  \n            [rowIndex,colIndex]}\"); \n        } \n    } \n} \n```", "```cs\nprivate static void StringExample() \n{ \nWriteLine(\"String object creation\"); \nstring authorName = \"Gaurav Aroraa\"; //string literal assignment \nWriteLine($\"{authorName}\"); \nstring property = \"Name: \"; \nstring person = \"Gaurav\"; \nstring personName = property + person; //string concatenation \nWriteLine($\"{personName}\"); \n\nchar[] language = {'c', 's', 'h', 'a', 'r', 'p'}; \nstringstr Language = new string(language); //initializing the constructor \nWriteLine($\"{strLanguage}\"); \nstring repeatMe = new string('*', 5); \nWriteLine($\"{repeatMe}\"); \nstring[] members = {\"Shivprasad\", \"Denim\", \"Vikas\", \"Gaurav\"}; \nstring name = string.Join(\" \", members); \nWriteLine($\"{name}\"); \n} \n```", "```cs\npublic struct BookAuthor \n{ \npublic string Name; \npublic string BookTitle; \npublic int Age; \npublic string City; \npublic string State; \npublic string Country; \n\n   //Code omitted \n} \n```", "```cs\nprivate static void StructureExample() \n{ \nWriteLine(\"Structure example\\n\"); \nWrite(\"Author name:\"); \nvar name = ReadLine(); \nWrite(\"Book Title:\"); \nvar bookTitle = ReadLine(); \nWrite(\"Author age:\"); \nvar age = ReadLine(); \nWrite(\"Author city:\"); \nvar city = ReadLine(); \nWrite(\"Author state:\"); \nvar state = ReadLine(); \nWrite(\"Author country:\"); \nvar country = ReadLine(); \n\nBookAuthor author = new BookAuthor(name,bookTitle,Convert.ToInt32(age),city,state,country); \nWriteLine($\"{author.ToString()}\"); \nBookAuthor author1 = author; //copy structure, it will copy only data as this is //not a class \n\nWrite(\"Change author name:\"); \nvar name1 = ReadLine(); \nauthor.Name = name1; \n\nWriteLine(\"Author1\"); \nWriteLine($\"{author.ToString()}\"); \nWriteLine(\"Author2\"); \nWriteLine($\"{author1.ToString()}\"); \n} \n```", "```cs\nprivate static void StructureExample() \n{ \nWriteLine(\"Structure example\\n\"); \nWrite(\"Author name:\"); \nvar name = ReadLine(); \nWrite(\"Book Title:\"); \nvar bookTitle = ReadLine(); \nWrite(\"Author age:\"); \nvar age = ReadLine(); \nWrite(\"Author city:\"); \nvar city = ReadLine(); \nWrite(\"Author state:\"); \nvar state = ReadLine(); \nWrite(\"Author country:\"); \nvar country = ReadLine(); \n\nClassBookAuthor author = new ClassBookAuthor(name,bookTitle,Convert.ToInt32(age),city,state,country); \nWriteLine($\"{author.ToString()}\"); \nClassBookAuthor author1 = author; //copy class, it will copy reference \n\nWrite(\"Change author name:\"); \nvar name1 = ReadLine(); \nauthor.Name = name1; \n\nWriteLine(\"Author1\"); \nWriteLine($\"{author.ToString()}\"); \nWriteLine(\"Author2\"); \nWriteLine($\"{author1.ToString()}\"); \n} \n```"]